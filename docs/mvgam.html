<!DOCTYPE html><html><head><title>Help for package mvgam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvgam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_residuals.mvgam'><p>Calculate randomized quantile residuals for mvgam objects</p></a></li>
<li><a href='#all_neon_tick_data'><p>NEON Amblyomma and Ixodes tick abundance survey data</p></a></li>
<li><a href='#code'><p>Print the model code from an mvgam object</p></a></li>
<li><a href='#conditional_effects.mvgam'><p>Display Conditional Effects of Predictors</p></a></li>
<li><a href='#dynamic'><p>Defining dynamic coefficients in mvgam formulae</p></a></li>
<li><a href='#evaluate_mvgams'><p>Evaluate forecasts from fitted mvgam objects</p></a></li>
<li><a href='#fitted.mvgam'><p>Expected Values of the Posterior Predictive Distribution</p></a></li>
<li><a href='#forecast.mvgam'><p>Extract or compute hindcasts and forecasts for a fitted <code>mvgam</code> object</p></a></li>
<li><a href='#formula.mvgam'><p>Extract formulae from mvgam objects</p></a></li>
<li><a href='#get_mvgam_priors'><p>Extract information on default prior distributions for an mvgam model</p></a></li>
<li><a href='#GP'><p>Specify dynamic Gaussian processes</p></a></li>
<li><a href='#hindcast.mvgam'><p>Extract hindcasts for a fitted <code>mvgam</code> object</p></a></li>
<li><a href='#index-mvgam'><p>Index <code>mvgam</code> objects</p></a></li>
<li><a href='#lfo_cv.mvgam'><p>Approximate leave-future-out cross-validation of fitted <code>mvgam</code> objects</p></a></li>
<li><a href='#logLik.mvgam'><p>Compute pointwise Log-Likelihoods from fitted <code>mvgam</code> objects</p></a></li>
<li><a href='#loo.mvgam'><p>LOO information criteria for <code>mvgam</code> models</p></a></li>
<li><a href='#lv_correlations'><p>Calculate trend correlations based on mvgam latent factor loadings</p></a></li>
<li><a href='#mcmc_plot.mvgam'><p>MCMC plots as implemented in <span class="pkg">bayesplot</span></p></a></li>
<li><a href='#model.frame.mvgam'><p>Extract model.frame from a fitted mvgam object</p></a></li>
<li><a href='#monotonic'><p>Monotonic splines in mvgam</p></a></li>
<li><a href='#mvgam'><p>Fit a Bayesian dynamic GAM to a univariate or multivariate set of time series</p></a></li>
<li><a href='#mvgam_diagnostics'><p>Extract diagnostic quantities of <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#mvgam_draws'><p>Extract posterior draws from fitted <code>mvgam</code> objects</p></a></li>
<li><a href='#mvgam_families'><p>Supported mvgam families</p></a></li>
<li><a href='#mvgam_forecast-class'><p><code>mvgam_forecast</code> object description</p></a></li>
<li><a href='#mvgam_formulae'><p>Details of formula specifications in <code>mvgam</code></p></a></li>
<li><a href='#mvgam_marginaleffects'><p>Helper functions for mvgam marginaleffects calculations</p></a></li>
<li><a href='#mvgam_trends'><p>Supported mvgam trend models</p></a></li>
<li><a href='#mvgam-class'><p>Fitted <code>mvgam</code> object description</p></a></li>
<li><a href='#pairs.mvgam'><p>Create a matrix of output plots from a <code>mvgam</code> object</p></a></li>
<li><a href='#plot_mvgam_factors'><p>Latent factor summaries for a fitted mvgam object</p></a></li>
<li><a href='#plot_mvgam_forecasts'><p>Plot mvgam posterior predictions for a specified series</p></a></li>
<li><a href='#plot_mvgam_pterms'><p>Plot mvgam parametric term partial effects</p></a></li>
<li><a href='#plot_mvgam_randomeffects'><p>Plot mvgam random effect terms</p></a></li>
<li><a href='#plot_mvgam_resids'><p>Residual diagnostics for a fitted mvgam object</p></a></li>
<li><a href='#plot_mvgam_series'><p>Plot observed time series used for mvgam modelling</p></a></li>
<li><a href='#plot_mvgam_smooth'><p>Plot mvgam smooth terms</p></a></li>
<li><a href='#plot_mvgam_trend'><p>Plot mvgam latent trend for a specified series</p></a></li>
<li><a href='#plot_mvgam_uncertainty'><p>Plot mvgam forecast uncertainty contributions for a specified series</p></a></li>
<li><a href='#plot.mvgam'><p>Default mvgam plots</p></a></li>
<li><a href='#plot.mvgam_lfo'><p>Plot Pareto-k and ELPD values from a leave-future-out object</p></a></li>
<li><a href='#portal_data'><p>Portal Project rodent capture survey data</p></a></li>
<li><a href='#posterior_epred.mvgam'><p>Draws from the Expected Value of the Posterior Predictive Distribution</p></a></li>
<li><a href='#posterior_linpred.mvgam'><p>Posterior Draws of the Linear Predictor</p></a></li>
<li><a href='#posterior_predict.mvgam'><p>Draws from the Posterior Predictive Distribution</p></a></li>
<li><a href='#pp_check.mvgam'><p>Posterior Predictive Checks for <code>mvgam</code> Objects</p></a></li>
<li><a href='#ppc.mvgam'><p>Plot mvgam posterior predictive checks for a specified series</p></a></li>
<li><a href='#predict.mvgam'><p>Predict from the GAM component of an mvgam model</p></a></li>
<li><a href='#print.mvgam'><p>Summary for a fitted mvgam object</p></a></li>
<li><a href='#PW'><p>Specify piecewise linear or logistic trends</p></a></li>
<li><a href='#residuals.mvgam'><p>Posterior draws of <code>mvgam</code> residuals</p></a></li>
<li><a href='#RW'><p>Specify autoregressive dynamic processes</p></a></li>
<li><a href='#score.mvgam_forecast'><p>Compute probabilistic forecast scores for mvgam objects</p></a></li>
<li><a href='#series_to_mvgam'><p>This function converts univariate or multivariate time series (<code>xts</code> or <code>ts</code> objects)</p>
to the format necessary for <code>mvgam</code></a></li>
<li><a href='#sim_mvgam'><p>Simulate a set of discrete time series for mvgam modelling</p></a></li>
<li><a href='#summary.mvgam'><p>Summary for a fitted mvgam object</p></a></li>
<li><a href='#ti'><p>Defining smooths in <span class="pkg">mvgam</span> formulae</p></a></li>
<li><a href='#update.mvgam'><p>Update an existing <code>mvgam</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multivariate (Dynamic) Generalized Additive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Bayesian Dynamic Generalized Additive Models to sets of time series. Users can build dynamic nonlinear State-Space models that can incorporate semiparametric effects in observation and process components, using a wide range of observation families. Estimation is performed using Markov Chain Monte Carlo with Hamiltonian Monte Carlo in the software 'Stan'. References: Clark &amp; Wells (2022) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13974">doi:10.1111/2041-210X.13974</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nicholasjclark/mvgam">https://github.com/nicholasjclark/mvgam</a>,
<a href="https://nicholasjclark.github.io/mvgam/">https://nicholasjclark.github.io/mvgam/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nicholasjclark/mvgam/issues">https://github.com/nicholasjclark/mvgam/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), brms (&ge; 2.17)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, mgcv (&ge; 1.8-13), insight (&ge; 0.19.1),
marginaleffects (&ge; 0.16.0), Rcpp (&ge; 0.12.0), rstan (&ge;
2.29.0), posterior (&ge; 1.0.0), loo (&ge; 2.3.1), rstantools (&ge;
2.1.1), bayesplot (&ge; 1.5.0), ggplot2 (&ge; 2.0.0), parallel,
pbapply, mvnfast, purrr, zoo, smooth, dplyr, magrittr, Matrix,
rlang</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>scoringRules, matrixStats, cmdstanr (&ge; 0.5.0), tweedie,
splines2, extraDistr, wrswoR, xts, lubridate, knitr, collapse,
rmarkdown, rjags, coda, runjags, usethis, testthat</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-30 23:21:45 UTC; uqnclar2</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas J Clark <a href="https://orcid.org/0000-0001-7131-3301"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas J Clark &lt;nicholas.j.clark1214@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-01 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_residuals.mvgam'>Calculate randomized quantile residuals for mvgam objects</h2><span id='topic+add_residuals.mvgam'></span><span id='topic+add_residuals'></span>

<h3>Description</h3>

<p>Calculate randomized quantile residuals for mvgam objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_residuals(object, ...)

## S3 method for class 'mvgam'
add_residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_residuals.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="add_residuals.mvgam_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each series, randomized quantile (i.e. Dunn-Smyth) residuals are calculated for inspecting model diagnostics
If the fitted model is appropriate then Dunn-Smyth residuals will be standard normal in distribution and no
autocorrelation will be evident. When a particular observation is missing, the residual is calculated by comparing independent
draws from the model's posterior distribution
</p>


<h3>Value</h3>

<p>A list object of class <code>mvgam</code> with residuals included in the <code>'resids'</code> slot
</p>

<hr>
<h2 id='all_neon_tick_data'>NEON Amblyomma and Ixodes tick abundance survey data</h2><span id='topic+all_neon_tick_data'></span>

<h3>Description</h3>

<p>A dataset containing timeseries of Amblyomma americanum and Ixodes scapularis nymph abundances at NEON sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_neon_tick_data
</code></pre>


<h3>Format</h3>

<p>A tibble/dataframe containing covariate information alongside the main fields of:
</p>

<dl>
<dt>Year</dt><dd><p>Year of sampling</p>
</dd>
<dt>epiWeek</dt><dd><p>Epidemiological week of sampling</p>
</dd>
<dt>plot_ID</dt><dd><p>NEON plot ID for survey location</p>
</dd>
<dt>siteID</dt><dd><p>NEON site ID for survey location</p>
</dd>
<dt>amblyomma_americanum</dt><dd><p>Counts of A. americanum nymphs</p>
</dd>
<dt>ixodes_scapularis</dt><dd><p>Counts of I. scapularis nymphs</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.neonscience.org/data">https://www.neonscience.org/data</a>
</p>

<hr>
<h2 id='code'>Print the model code from an mvgam object</h2><span id='topic+code'></span>

<h3>Description</h3>

<p>Print the model code from an mvgam object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the model code in a tidy format
</p>

<hr>
<h2 id='conditional_effects.mvgam'>Display Conditional Effects of Predictors</h2><span id='topic+conditional_effects.mvgam'></span><span id='topic+plot.mvgam_conditional_effects'></span><span id='topic+print.mvgam_conditional_effects'></span>

<h3>Description</h3>

<p>Display conditional effects of one or more numeric and/or categorical
predictors in <code>mvgam</code> models, including two-way interaction effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
conditional_effects(
  x,
  effects = NULL,
  type = "response",
  points = TRUE,
  rug = TRUE,
  ...
)

## S3 method for class 'mvgam_conditional_effects'
plot(x, plot = TRUE, ask = FALSE, ...)

## S3 method for class 'mvgam_conditional_effects'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_effects.mvgam_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvgam</code> or <code>mvgam_conditional_effects</code></p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_effects">effects</code></td>
<td>
<p>An optional character vector naming effects (main effects or
interactions) for which to compute conditional plots. Interactions are
specified by a <code>:</code> between variable names. If <code>NULL</code> (the
default), plots are generated for all main effects and two-way interactions
estimated in the model. When specifying <code>effects</code> manually, <em>all</em>
two-way interactions (including grouping variables) may be plotted
even if not originally modeled.</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_type">type</code></td>
<td>
<p><code>character</code> specifying the scale of predictions.
When this has the value <code>link</code> (default) the linear predictor is calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an N-mixture distribution,
while type <code>detection</code> will return the estimated detection probability from an N-mixture distribution</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_points">points</code></td>
<td>
<p><code>Logical</code>. Indicates if the original data points should be added,
but only if <code>type == 'response'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_rug">rug</code></td>
<td>
<p><code>Logical</code>. Indicates if displays tick marks should be plotted on the
axes to mark the distribution of raw data, but only if <code>type == 'response'</code>.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code></p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_plot">plot</code></td>
<td>
<p>Logical; indicates if plots should be
plotted directly in the active graphic device.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_ask">ask</code></td>
<td>
<p><code>Logical</code>. Indicates if the user is prompted before a new page is plotted.
Only used if plot is <code>TRUE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function acts as a wrapper to the more
flexible <code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code>.
When creating <code>conditional_effects</code> for a particular predictor
(or interaction of two predictors), one has to choose the values of all
other predictors to condition on. By default, the mean is used for
continuous variables and the reference category is used for factors. Use
<code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code> to change these
and create more bespoke conditional effects plots.
</p>


<h3>Value</h3>

<p><code>conditional_effects</code> returns an object of class
<code>mvgam_conditional_effects</code> which is a
named list with one slot per effect containing a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object,
which can be further customized using the <span class="pkg">ggplot2</span> package.
The corresponding <code>plot</code> method will draw these plots in the active graphic device
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code>, <code><a href="marginaleffects.html#topic+plot_slopes">plot_slopes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data
simdat &lt;- sim_mvgam(family = poisson(),
                    seasonality = 'hierarchical')

# Fit a model
mod &lt;- mvgam(y ~ s(season, by = series, k = 5) + year:series,
             family = poisson(),
             data = simdat$data_train,
             chains = 2)

# Plot all main effects on the response scale
conditional_effects(mod)

# Change the prediction interval to 70% using plot_predictions() argument
# 'conf_level'
conditional_effects(mod, conf_level = 0.7)

# Plot all main effects on the link scale
conditional_effects(mod, type = 'link')

# Works the same for smooth terms, including smooth interactions
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
mod &lt;- mvgam(y ~ te(x0, x1, k = 5) + s(x2, k = 6) + s(x3, k = 6),
            data = dat,
            family = gaussian(),
            chains = 2)
conditional_effects(mod)
conditional_effects(mod, conf_level = 0.5, type = 'link')

</code></pre>

<hr>
<h2 id='dynamic'>Defining dynamic coefficients in mvgam formulae</h2><span id='topic+dynamic'></span>

<h3>Description</h3>

<p>Set up time-varying (dynamic) coefficients for use in mvgam models. Currently, only
low-rank Gaussian Process smooths are available for estimating the dynamics of the
time-varying coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamic(variable, k, rho = 5, stationary = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamic_+3A_variable">variable</code></td>
<td>
<p>The variable that the dynamic smooth will be a function of</p>
</td></tr>
<tr><td><code id="dynamic_+3A_k">k</code></td>
<td>
<p>Optional number of basis functions for computing approximate GPs. If missing,
<code>k</code> will be set as large as possible to accurately estimate the nonlinear function</p>
</td></tr>
<tr><td><code id="dynamic_+3A_rho">rho</code></td>
<td>
<p>Either a positive numeric stating the length scale to be used for approximating the
squared exponential Gaussian Process smooth (see <code><a href="mgcv.html#topic+gp.smooth">gp.smooth</a></code> for details)
or missing, in which case the length scale will be estimated by setting up a Hilbert space approximate
GP</p>
</td></tr>
<tr><td><code id="dynamic_+3A_stationary">stationary</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default) and <code>rho</code> is supplied,
the latent Gaussian Process smooth will not have a linear trend component. If <code>FALSE</code>,
a linear trend in the covariate is added to the Gaussian Process smooth. Leave at <code>TRUE</code>
if you do not believe the coefficient is evolving with much trend, as the linear component of the
basis functions can be hard to penalize to zero. This sometimes causes divergence issues in <code>Stan</code>.
See <code><a href="mgcv.html#topic+gp.smooth">gp.smooth</a></code> for details. Ignored if <code>rho</code> is missing (in which case a
Hilbert space approximate GP is used)</p>
</td></tr>
<tr><td><code id="dynamic_+3A_scale">scale</code></td>
<td>
<p>Logical; If <code>TRUE</code> (the default) and <code>rho</code> is missing, predictors
are scaled so that the maximum Euclidean distance between two points is <code>1</code>. This
often improves sampling speed and convergence. Scaling also affects the estimated
length-scale parameters in that they resemble those of scaled predictors
(not of the original predictors) if scale is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvgam</code> currently sets up dynamic coefficients as low-rank
squared exponential Gaussian Process smooths via
the call <code>s(time, by = variable, bs = "gp", m = c(2, rho, 2))</code>. These smooths, if specified with
reasonable values for the length scale parameter, will give more realistic out of sample forecasts
than standard splines such as thin plate or cubic. But the user must set the
value for <code>rho</code>, as there is currently no support for estimating this value in <code>mgcv</code>.
This may not be too big of a problem, as estimating latent length scales is often difficult anyway. The
<code>rho</code> parameter should be thought of as a prior on the smoothness of the latent dynamic coefficient
function (where higher values of <code>rho</code> lead to smoother functions with more temporal covariance structure.
Values of <code>k</code> are
set automatically to ensure enough basis functions are used to approximate the expected
wiggliness of the underlying dynamic function (<code>k</code> will increase as <code>rho</code> decreases)
</p>


<h3>Value</h3>

<p>a <code>list</code> object for internal usage in 'mvgam'
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate a time-varying coefficient
#(as a Gaussian Process with length scale = 10)
set.seed(1111)
N &lt;- 200

# A function to simulate from a squared exponential Gaussian Process
sim_gp = function(N, c, alpha, rho){
 Sigma &lt;- alpha ^ 2 *
          exp(-0.5 * ((outer(1:N, 1:N, "-") / rho) ^ 2)) +
          diag(1e-9, N)
c + mgcv::rmvn(1,
               mu = rep(0, N),
               V = Sigma)
}

beta &lt;- sim_gp(alpha = 0.75,
              rho = 10,
              c = 0.5,
              N = N)
plot(beta, type = 'l', lwd = 3,
    bty = 'l', xlab = 'Time',
    ylab = 'Coefficient',
    col = 'darkred')

# Simulate the predictor as a standard normal
predictor &lt;- rnorm(N, sd = 1)

# Simulate a Gaussian outcome variable
out &lt;- rnorm(N, mean = 4 + beta * predictor,
            sd = 0.25)
time &lt;- seq_along(predictor)
plot(out,  type = 'l', lwd = 3,
    bty = 'l', xlab = 'Time', ylab = 'Outcome',
    col = 'darkred')

# Gather into a data.frame and fit a dynamic coefficient model
data &lt;- data.frame(out, predictor, time)

# Split into training and testing
data_train &lt;- data[1:190,]
data_test &lt;- data[191:200,]

# Fit a model using the dynamic function
mod &lt;- mvgam(out ~
             # mis-specify the length scale slightly as this
             # won't be known in practice
             dynamic(predictor, rho = 8, stationary = TRUE),
            family = gaussian(),
            data = data_train,
            chains = 2)

# Inspect the summary
summary(mod)

# Plot the time-varying coefficient estimates
plot(mod, type = 'smooths')

# Extrapolate the coefficient forward in time
plot_mvgam_smooth(mod, smooth = 1, newdata = data)
abline(v = 190, lty = 'dashed', lwd = 2)

# Overlay the true simulated time-varying coefficient
lines(beta, lwd = 2.5, col = 'white')
lines(beta, lwd = 2)

</code></pre>

<hr>
<h2 id='evaluate_mvgams'>Evaluate forecasts from fitted mvgam objects</h2><span id='topic+evaluate_mvgams'></span><span id='topic+eval_mvgam'></span><span id='topic+roll_eval_mvgam'></span><span id='topic+compare_mvgams'></span>

<h3>Description</h3>

<p>Evaluate forecasts from fitted mvgam objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_mvgam(
  object,
  n_samples = 5000,
  eval_timepoint = 3,
  fc_horizon = 3,
  n_cores = 2,
  score = "drps",
  log = FALSE,
  weights
)

roll_eval_mvgam(
  object,
  n_evaluations = 5,
  evaluation_seq,
  n_samples = 5000,
  fc_horizon = 3,
  n_cores = 2,
  score = "drps",
  log = FALSE,
  weights
)

compare_mvgams(
  model1,
  model2,
  n_samples = 1000,
  fc_horizon = 3,
  n_evaluations = 10,
  n_cores = 2,
  score = "drps",
  log = FALSE,
  weights
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_mvgams_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_n_samples">n_samples</code></td>
<td>
<p><code>integer</code> specifying the number of samples to generate from the model's
posterior distribution</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_eval_timepoint">eval_timepoint</code></td>
<td>
<p><code>integer</code> indexing the timepoint that represents our last 'observed'
set of outcome data</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_fc_horizon">fc_horizon</code></td>
<td>
<p><code>integer</code> specifying the length of the forecast horizon for evaluating forecasts</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_n_cores">n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for generating particle forecasts in parallel</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_score">score</code></td>
<td>
<p><code>character</code> specifying the type of ranked probability score to use for evaluation. Options are:
<code>variogram</code>, <code>drps</code> or <code>crps</code></p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_log">log</code></td>
<td>
<p><code>logical</code>. Should the forecasts and truths be logged prior to scoring?
This is often appropriate for comparing
performance of models when series vary in their observation ranges</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_weights">weights</code></td>
<td>
<p>optional <code>vector</code> of weights (where <code>length(weights) == n_series</code>)
for weighting pairwise correlations when evaluating the variogram score for multivariate
forecasts. Useful for down-weighting series that have larger magnitude observations or that
are of less interest when forecasting. Ignored if <code>score != 'variogram'</code></p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_n_evaluations">n_evaluations</code></td>
<td>
<p><code>integer</code> specifying the total number of evaluations to perform</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_evaluation_seq">evaluation_seq</code></td>
<td>
<p>Optional <code>integer sequence</code> specifying the exact set of timepoints for
evaluating the model's forecasts. This sequence cannot have values
<code>&lt;3</code> or <code>&gt; max(training timepoints) - fc_horizon</code></p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_model1">model1</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code> representing the first model to be
evaluated</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_model2">model2</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code> representing the second model to be
evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eval_mvgam</code> may be useful when both repeated fitting of a model using <code><a href="#topic+update.mvgam">update.mvgam</a></code>
for exact leave-future-out cross-validation and approximate
leave-future-out cross-validation using <code><a href="#topic+lfo_cv">lfo_cv</a></code> are impractical. The function generates a set of samples representing fixed parameters estimated from the full
<code>mvgam</code> model and latent trend states at a given point in time. The trends are rolled forward
a total of <code>fc_horizon</code> timesteps according to their estimated state space dynamics to
generate an 'out-of-sample' forecast that is evaluated against the true observations in the horizon window.
This function therefore simulates a situation where the model's parameters had already been estimated but
we have only observed data up to the evaluation timepoint and would like to generate forecasts from the
latent trends that have been observed up to that timepoint. Evaluation involves calculating an
appropriate Rank Probability Score and a binary indicator
for whether or not the true value lies within the forecast's 90% prediction interval
</p>
<p><code>roll_eval_mvgam</code> sets up a sequence of evaluation timepoints along a rolling window and iteratively
calls <code>eval_mvgam</code> to evaluate 'out-of-sample' forecasts.
Evaluation involves calculating the Rank Probability Scores and a binary indicator
for whether or not the true value lies within the forecast's 90% prediction interval
</p>
<p><code>compare_mvgams</code> automates the evaluation to compare two fitted models using rolling window forecast evaluation and
provides a series of summary plots to facilitate model selection. It is essentially a wrapper for
<code>roll_eval_mvgam</code>
</p>


<h3>Value</h3>

<p>For <code>eval_mvgam</code>, a <code>list</code> object containing information on specific evaluations for each series
(if using <code>drps</code> or <code>crps</code> as the score) or a vector of scores when using <code>variogram</code>.
</p>
<p>For <code>roll_eval_mvgam</code>, a <code>list</code> object containing information on specific evaluations for each series as well as
a total evaluation summary (taken by summing the forecast score for each series at each evaluation and averaging
the coverages at each evaluation)
</p>
<p>For <code>compare_mvgams</code>, a series of plots comparing forecast Rank Probability Scores for each competing
model. A lower score is preferred. Note however that it is possible to select a model that ultimately
would perform poorly in true out-of-sample forecasting. For example if a wiggly smooth function of 'year'
is included in the model then this function will be learned prior to evaluating rolling window forecasts,
and the model could generate very tight predictions as a result. But when forecasting ahead to timepoints
that the model has not seen (i.e. next year), the smooth function will end up extrapolating, sometimes
in very strange and unexpected ways. It is therefore recommended to only use smooth functions for
covariates that are adequately measured in the data (i.e. 'seasonality', for example) to reduce possible
extrapolation of smooths and let the latent trends in the <code>mvgam</code> model capture any
temporal dependencies in the data. These trends are time series models and so will provide much more
stable forecasts
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast">forecast</a></code>, <code><a href="#topic+score">score</a></code>, <code><a href="#topic+lfo_cv">lfo_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate from a Poisson-AR2 model with a seasonal smooth
set.seed(100)
dat &lt;- sim_mvgam(T = 75,
                n_series = 1,
                prop_trend = 0.75,
                trend_model = 'AR2',
                family = poisson())


# Fit an appropriate model
mod_ar2 &lt;- mvgam(y ~ s(season, bs = 'cc'),
                trend_model = AR(p = 2),
                family = poisson(),
                data = dat$data_train,
                newdata = dat$data_test,
                chains = 2)

# Fit a less appropriate model
mod_rw &lt;- mvgam(y ~ s(season, bs = 'cc'),
               trend_model = RW(),
               family = poisson(),
               data = dat$data_train,
               newdata = dat$data_test,
               chains = 2)

# Compare Discrete Ranked Probability Scores for the testing period
fc_ar2 &lt;- forecast(mod_ar2)
fc_rw &lt;- forecast(mod_rw)
score_ar2 &lt;- score(fc_ar2, score = 'drps')
score_rw &lt;- score(fc_rw, score = 'drps')
sum(score_ar2$series_1$score)
sum(score_rw$series_1$score)

# Use rolling evaluation for approximate comparisons of 3-step ahead
# forecasts across the training period
compare_mvgams(mod_ar2,
              mod_rw,
              fc_horizon = 3,
              n_samples = 1000,
              n_evaluations = 5)

# Now use approximate leave-future-out CV to compare
# rolling forecasts; start at time point 40 to reduce
# computational time and to ensure enough data is available
# for estimating model parameters
lfo_ar2 &lt;- lfo_cv(mod_ar2,
                 min_t = 40,
                 fc_horizon = 3)
lfo_rw &lt;- lfo_cv(mod_rw,
                min_t = 40,
                fc_horizon = 3)

# Plot Pareto-K values and ELPD estimates
plot(lfo_ar2)
plot(lfo_rw)

# Proportion of timepoints in which AR2 model gives
# better forecasts
length(which((lfo_ar2$elpds - lfo_rw$elpds) &gt; 0)) /
      length(lfo_ar2$elpds)

# A higher total ELPD is preferred
lfo_ar2$sum_ELPD
lfo_rw$sum_ELPD

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted.mvgam'>Expected Values of the Posterior Predictive Distribution</h2><span id='topic+fitted.mvgam'></span>

<h3>Description</h3>

<p>This method extracts posterior estimates of the fitted values
(i.e. the actual predictions, included estimates for any trend states,
that were obtained when fitting the model). It also includes an option
for obtaining summaries of the computed draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
fitted(
  object,
  process_error = TRUE,
  scale = c("response", "linear"),
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.mvgam_+3A_object">object</code></td>
<td>
<p>An object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and a dynamic trend model was fit,
expected uncertainty in the process model is accounted for by using draws
from the latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent trend
component is ignored when calculating predictions</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale
of the response variable. If <code>"linear"</code>,
results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or
other transformations.</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method gives the actual fitted values from the model (i.e. what you
will see if you generate hindcasts from the fitted model using <code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code>
with <code>type = 'expected'</code>). These
predictions can be overly precise if a flexible dynamic trend component was included
in the model. This is in contrast to the set of predict functions (i.e.
<code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> or <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>), which will assume
any dynamic trend component has reached stationarity when returning hypothetical predictions
</p>


<h3>Value</h3>

<p>An <code>array</code> of predicted <em>mean</em> response values.
If <code>summary = FALSE</code> the output resembles those of
<code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> and <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>.
</p>
<p>If <code>summary = TRUE</code> the output is an <code>n_observations</code> x <code>E</code>
matrix. The number of summary statistics <code>E</code> is equal to <code>2 +
  length(probs)</code>: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
            trend_model = 'AR1',
            data = simdat$data_train,
            chains = 2,
            burnin = 300,
            samples = 300)

# Extract fitted values (posterior expectations)
expectations &lt;- fitted(mod)
str(expectations)

## End(Not run)
</code></pre>

<hr>
<h2 id='forecast.mvgam'>Extract or compute hindcasts and forecasts for a fitted <code>mvgam</code> object</h2><span id='topic+forecast.mvgam'></span><span id='topic+forecast'></span>

<h3>Description</h3>

<p>Extract or compute hindcasts and forecasts for a fitted <code>mvgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast(object, ...)

## S3 method for class 'mvgam'
forecast(object, newdata, data_test, n_cores = 1, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
in addition to any other variables included in the linear predictor of the original <code>formula</code>. If included, the
covariate information in <code>newdata</code> will be used to generate forecasts from the fitted model equations. If
this same <code>newdata</code> was originally included in the call to <code>mvgam</code>, then forecasts have already been
produced by the generative model and these will simply be extracted and plotted. However if no <code>newdata</code> was
supplied to the original model call, an assumption is made that the <code>newdata</code> supplied here comes sequentially
after the data supplied in the original model (i.e. we assume there is no time gap between the last
observation of series 1 in the original data and the first observation for series 1 in <code>newdata</code>)</p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_n_cores">n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for generating forecasts in parallel</p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_type">type</code></td>
<td>
<p>When this has the value <code>link</code> (default) the linear predictor is
calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. When <code>variance</code> is used, the variance of the response
with respect to the mean (mean-variance relationship) is returned.
When <code>type = "terms"</code>, each component of the linear predictor is
returned separately in the form of a <code>list</code> (possibly with standard
errors, if <code>summary = TRUE</code>): this includes parametric model components,
followed by each smooth component, but excludes any offset and any intercept.
Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an
N-mixture distribution, while type <code>detection</code> will return the estimated
detection probability from an N-mixture distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior predictions are drawn from the fitted <code>mvgam</code> and used to simulate a forecast distribution
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_forecast</code> containing hindcast and forecast distributions.
See <code><a href="#topic+mvgam_forecast-class">mvgam_forecast-class</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hindcast">hindcast</a></code>, <code><a href="#topic+score">score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 3, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2)

# Hindcasts on response scale
hc &lt;- hindcast(mod)
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

# Forecasts on response scale
fc &lt;- forecast(mod, newdata = simdat$data_test)
str(fc)
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

# Forecasts as expectations
fc &lt;- forecast(mod, newdata = simdat$data_test, type = 'expected')
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

# Dynamic trend extrapolations
fc &lt;- forecast(mod, newdata = simdat$data_test, type = 'trend')
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

</code></pre>

<hr>
<h2 id='formula.mvgam'>Extract formulae from mvgam objects</h2><span id='topic+formula.mvgam'></span><span id='topic+formula.mvgam_prefit'></span>

<h3>Description</h3>

<p>Extract formulae from mvgam objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
formula(x, trend_effects = FALSE, ...)

## S3 method for class 'mvgam_prefit'
formula(x, trend_effects = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.mvgam_+3A_x">x</code></td>
<td>
<p><code>mvgam</code> or <code>mvgam_prefit</code> object</p>
</td></tr>
<tr><td><code id="formula.mvgam_+3A_trend_effects">trend_effects</code></td>
<td>
<p><code>logical</code>, return the formula from the
observation model (if <code>FALSE</code>) or from the underlying process
model (if<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="formula.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>formula</code> object
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='get_mvgam_priors'>Extract information on default prior distributions for an mvgam model</h2><span id='topic+get_mvgam_priors'></span>

<h3>Description</h3>

<p>This function lists the parameters that can have their prior distributions
changed for a given <code>mvgam</code> model, as well listing their default distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mvgam_priors(
  formula,
  trend_formula,
  data,
  data_train,
  family = "poisson",
  knots,
  use_lv = FALSE,
  n_lv,
  use_stan = TRUE,
  trend_model = "None",
  trend_map,
  drift = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mvgam_priors_+3A_formula">formula</code></td>
<td>
<p>A <code>character</code> string specifying the GAM observation model formula. These are exactly like the formula
for a GLM except that smooth terms, <code>s()</code>, <code>te()</code>, <code>ti()</code>, <code>t2()</code>, as well as time-varying
<code>dynamic()</code> terms, can be added to the right hand side
to specify that the linear predictor depends on smooth functions of predictors
(or linear functionals of these). In <code>nmix()</code> family models, the <code>formula</code> is used to
set up a linear predictor for the detection probability. Details of the formula syntax used by <span class="pkg">mvgam</span>
can be found in <code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_trend_formula">trend_formula</code></td>
<td>
<p>An optional <code>character</code> string specifying the GAM process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture process model evolution
separately from the observation model. Should not have a response variable specified on the left-hand side
of the formula (i.e. a valid option would be <code>~ season + s(year)</code>). Also note that you should not use
the identifier <code>series</code> in this formula to specify effects that vary across time series. Instead you should use
<code>trend</code>. This will ensure that models in which a <code>trend_map</code> is supplied will still work consistently
(i.e. by allowing effects to vary across process models, even when some time series share the same underlying
process model). This feature is only currently available for <code>RW()</code>, <code>AR()</code> and <code>VAR()</code> trend models.
In <code>nmix()</code> family models, the <code>trend_formula</code> is used to set up a linear predictor for the underlying
latent abundance</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response variable and covariates
required by the GAM <code>formula</code> and optional <code>trend_formula</code>. Should include columns:
#'</p>

<ul>
<li><p><code>series</code> (a <code>factor</code> index of the series IDs; the number of levels should be identical
to the number of unique series labels (i.e. <code>n_series = length(levels(data$series))</code>))
</p>
</li>
<li><p><code>time</code> (<code>numeric</code> or <code>integer</code> index of the time point for each observation).
For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>), time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>). However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. See an example of <code>CAR()</code> trends in <code><a href="#topic+CAR">CAR</a></code>
</p>
</li></ul>

<p>Should also include any other variables to be included in the linear predictor of <code>formula</code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_data_train">data_train</code></td>
<td>
<p>Deprecated. Still works in place of <code>data</code> but users are recommended to use
<code>data</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the exponential observation family for the series. Currently supported
families are:
</p>

<ul>
<li><p><code>gaussian()</code> for real-valued data
</p>
</li>
<li><p><code>betar()</code> for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li><p><code>lognormal()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>student_t()</code> for real-valued data
</p>
</li>
<li><p><code>Gamma()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>bernoulli()</code> for binary data
</p>
</li>
<li><p><code>poisson()</code> for count data
</p>
</li>
<li><p><code>nb()</code> for overdispersed count data
</p>
</li>
<li><p><code>binomial()</code> for count data with imperfect detection when the number of trials is known;
note that the <code>cbind()</code> function must be used to bind the discrete observations and the discrete number
of trials
</p>
</li>
<li><p><code>beta_binomial()</code> as for <code>binomial()</code> but allows for overdispersion
</p>
</li>
<li><p><code>nmix()</code> for count data with imperfect detection when the number of trials
is unknown and should be modeled via a State-Space N-Mixture model.
The latent states are Poisson, capturing the 'true' latent
abundance, while the observation process is Binomial to account for
imperfect detection.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for an example of how to use this family</p>
</li></ul>

<p>Note that only <code>nb()</code> and <code>poisson()</code> are available if using <code>JAGS</code> as the backend.
Default is <code>poisson()</code>.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for more details</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_knots">knots</code></td>
<td>
<p>An optional <code>list</code> containing user specified knot values to be used for basis construction.
For most bases the user simply supplies the knots to be used, which must match up with the k value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can use different numbers of knots,
unless they share a covariate</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_use_lv">use_lv</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for
<code>RW()</code>, <code>AR()</code> and <code>GP()</code> trend models. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code> the number of latent dynamic factors to use if <code>use_lv == TRUE</code>.
Cannot be <code>&gt; n_series</code>. Defaults arbitrarily to <code>min(2, floor(n_series / 2))</code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_use_stan">use_stan</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model will be compiled and sampled using
Hamiltonian Monte Carlo with a call to <code><a href="cmdstanr.html#topic+cmdstan_model">cmdstan_model</a></code> or
a call to <code><a href="rstan.html#topic+stan">stan</a></code>. Note that
there are many more options when using <code>Stan</code> vs <code>JAGS</code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_trend_model">trend_model</code></td>
<td>
<p><code>character</code> or  <code>function</code> specifying the time series dynamics for the latent trend. Options are:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>'RW'</code> or <code>RW()</code>
</p>
</li>
<li> <p><code>'AR1'</code> or <code>AR(p = 1)</code>
</p>
</li>
<li> <p><code>'AR2'</code> or <code>AR(p = 2)</code>
</p>
</li>
<li> <p><code>'AR3'</code> or <code>AR(p = 3)</code>
</p>
</li>
<li> <p><code>'CAR1'</code> or <code>CAR(p = 1)</code>
</p>
</li>
<li> <p><code>'VAR1'</code>  or <code>VAR()</code>(only available in <code>Stan</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;'PWlogistic&#8288;</code>, <code>'PWlinear'</code> or <code>PW()</code> (only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>'GP'</code> or <code>GP()</code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p>
</li></ul>

<p>For all trend types apart from <code>GP()</code>, <code>CAR()</code> and <code>PW()</code>, moving average and/or correlated
process error terms can also be estimated (for example, <code>RW(cor = TRUE)</code> will set up a
multivariate Random Walk if <code>n_series &gt; 1</code>). See <a href="#topic+mvgam_trends">mvgam_trends</a> for more details</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_trend_map">trend_map</code></td>
<td>
<p>Optional <code>data.frame</code> specifying which series should depend on which latent
trends. Useful for allowing multiple series to depend on the same latent trend process, but with
different observation processes. If supplied, a latent factor model is set up by setting
<code>use_lv = TRUE</code> and using the mapping to set up the shared trends. Needs to have column names
<code>series</code> and <code>trend</code>, with integer values in the <code>trend</code> column to state which trend each series
should depend on. The <code>series</code> column should have a single unique entry for each series in the
data (names should perfectly match factor levels of the <code>series</code> variable in <code>data</code>). See examples
for details</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_drift">drift</code></td>
<td>
<p><code>logical</code> estimate a drift parameter in the latent trend components. Useful if the latent
trend is expected to broadly follow a non-zero slope. Only available for
<code>RW()</code> and <code>AR()</code> trend models. Note that if the latent trend is more or less stationary,
the drift parameter can become unidentifiable, especially if an intercept term is included in the GAM linear
predictor (which it is by default when calling <code><a href="mgcv.html#topic+jagam">jagam</a></code>). Drift parameters will also likely
be unidentifiable if using dynamic factor models. Therefore this defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users can supply a model formula, prior to fitting the model, so that default priors can be inspected and
altered. To make alterations, change the contents of the <code>prior</code> column and supplying this
<code>data.frame</code> to the <code>mvgam</code> function using the argument <code>priors</code>. If using <code>Stan</code> as the backend,
users can also modify the parameter bounds by modifying the <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns.
This will be necessary if using restrictive distributions on some parameters, such as a Beta distribution
for the trend sd parameters for example (Beta only has support on  <code>(0,1)</code>), so the upperbound cannot
be above <code>1</code>. Another option is to make use of the prior modification functions in <code>brms</code>
(i.e. <code><a href="brms.html#topic+prior">prior</a></code>) to change prior distributions and bounds (just use the name of the parameter that
you'd like to change as the <code>class</code> argument; see examples below)
</p>


<h3>Value</h3>

<p>either a <code>data.frame</code> containing the prior definitions (if any suitable
priors can be altered by the user) or <code>NULL</code>, indicating that no priors in the model
can be modified through the <code>mvgam</code> interface
</p>


<h3>Note</h3>

<p>Only the <code>prior</code>, <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns of the output
should be altered when defining the user-defined priors for the <code>mvgam</code> model. Use only if you are
familiar with the underlying probabilistic programming language. There are no sanity checks done to
ensure that the code is legal (i.e. to check that lower bounds are smaller than upper bounds, for
example)
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvgam">mvgam</a></code>, <code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code>, <code><a href="brms.html#topic+prior">prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate three integer-valued time series
library(mvgam)
dat &lt;- sim_mvgam(trend_rel = 0.5)

# Get a model file that uses default mvgam priors for inspection (not always necessary,
# but this can be useful for testing whether your updated priors are written correctly)
mod_default &lt;- mvgam(y ~ s(series, bs = 're') +
              s(season, bs = 'cc') - 1,
              family = nb(),
              data = dat$data_train,
              trend_model = AR(p = 2),
              run_model = FALSE)

# Inspect the model file with default mvgam priors
code(mod_default)

# Look at which priors can be updated in mvgam
test_priors &lt;- get_mvgam_priors(y ~ s(series, bs = 're') +
                              s(season, bs = 'cc') - 1,
                              family = nb(),
                              data = dat$data_train,
                              trend_model = AR(p = 2))
test_priors

# Make a few changes; first, change the population mean for the series-level
# random intercepts
test_priors$prior[2] &lt;- 'mu_raw ~ normal(0.2, 0.5);'

# Now use stronger regularisation for the series-level AR2 coefficients
test_priors$prior[5] &lt;- 'ar2 ~ normal(0, 0.25);'

# Check that the changes are made to the model file without any warnings by
# setting 'run_model = FALSE'
mod &lt;- mvgam(y ~ s(series, bs = 're') +
            s(season, bs = 'cc') - 1,
            family = nb(),
            data = dat$data_train,
            trend_model = AR(p = 2),
            priors = test_priors,
            run_model = FALSE)
code(mod)

# No warnings, the model is ready for fitting now in the usual way with the addition
# of the 'priors' argument

# The same can be done using 'brms' functions; here we will also change the ar1 prior
# and put some bounds on the ar coefficients to enforce stationarity; we set the
# prior using the 'class' argument in all brms prior functions
brmsprior &lt;- c(prior(normal(0.2, 0.5), class = mu_raw),
              prior(normal(0, 0.25), class = ar1, lb = -1, ub = 1),
              prior(normal(0, 0.25), class = ar2, lb = -1, ub = 1))
brmsprior

mod &lt;- mvgam(y ~ s(series, bs = 're') +
            s(season, bs = 'cc') - 1,
          family = nb(),
          data = dat$data_train,
          trend_model = AR(p = 2),
          priors = brmsprior,
          run_model = FALSE)
code(mod)

# Look at what is returned when an incorrect spelling is used
test_priors$prior[5] &lt;- 'ar2_bananas ~ normal(0, 0.25);'
mod &lt;- mvgam(y ~ s(series, bs = 're') +
            s(season, bs = 'cc') - 1,
            family = nb(),
            data = dat$data_train,
            trend_model = AR(p = 2),
            priors = test_priors,
            run_model = FALSE)
code(mod)

# Example of changing parametric (fixed effect) priors
simdat &lt;- sim_mvgam()

# Add a fake covariate
simdat$data_train$cov &lt;- rnorm(NROW(simdat$data_train))

priors &lt;- get_mvgam_priors(y ~ cov + s(season),
                          data = simdat$data_train,
                          family = poisson(),
                          trend_model = AR())

# Change priors for the intercept and fake covariate effects
priors$prior[1] &lt;- '(Intercept) ~ normal(0, 1);'
priors$prior[2] &lt;- 'cov ~ normal(0, 0.1);'

mod2 &lt;- mvgam(y ~ cov + s(season),
             data = simdat$data_train,
             trend_model = AR(),
             family = poisson(),
             priors = priors,
             run_model = FALSE)
code(mod2)

# Likewise using 'brms' utilities (note that you can use
# Intercept rather than `(Intercept)`) to change priors on the intercept
brmsprior &lt;- c(prior(normal(0.2, 0.5), class = cov),
              prior(normal(0, 0.25), class = Intercept))
brmsprior

mod2 &lt;- mvgam(y ~ cov + s(season),
             data = simdat$data_train,
             trend_model = AR(),
             family = poisson(),
             priors = brmsprior,
             run_model = FALSE)
code(mod2)

# The "class = 'b'" shortcut can be used to put the same prior on all
# 'fixed' effect coefficients (apart from any intercepts)
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
dat$time &lt;- 1:NROW(dat)
mod &lt;- mvgam(y ~ x0 + x1 + s(x2) + s(x3),
            priors = prior(normal(0, 0.75), class = 'b'),
            data = dat,
            family = gaussian(),
            run_model = FALSE)
code(mod)

</code></pre>

<hr>
<h2 id='GP'>Specify dynamic Gaussian processes</h2><span id='topic+GP'></span>

<h3>Description</h3>

<p>Set up low-rank approximate Gaussian Process trend models using Hilbert
basis expansions in <code>mvgam</code>. This function does not evaluate its arguments 
it exists purely to help set up a model with particular GP
trend models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GP(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GP_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A GP trend is estimated for each series using
<a href="https://arxiv.org/abs/2004.11408">Hilbert space approximate Gaussian Processes</a>.
In <code>mvgam</code>, latent squared exponential GP trends are approximated using by
default <code>20</code> basis functions and using a multiplicative factor of <code>c = 5/4</code>,
which saves computational costs compared to fitting full GPs while adequately estimating
GP <code>alpha</code> and <code>rho</code> parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_trend</code>, which contains a list of
arguments to be interpreted by the parsing functions in <code>mvgam</code>
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+gp">gp</a></code>
</p>

<hr>
<h2 id='hindcast.mvgam'>Extract hindcasts for a fitted <code>mvgam</code> object</h2><span id='topic+hindcast.mvgam'></span><span id='topic+hindcast'></span>

<h3>Description</h3>

<p>Extract hindcasts for a fitted <code>mvgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hindcast(object, ...)

## S3 method for class 'mvgam'
hindcast(object, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hindcast.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="hindcast.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="hindcast.mvgam_+3A_type">type</code></td>
<td>
<p>When this has the value <code>link</code> (default) the linear predictor is
calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. When <code>variance</code> is used, the variance of the response
with respect to the mean (mean-variance relationship) is returned.
When <code>type = "terms"</code>, each component of the linear predictor is
returned separately in the form of a <code>list</code> (possibly with standard
errors, if <code>summary = TRUE</code>): this includes parametric model components,
followed by each smooth component, but excludes any offset and any intercept.
Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an
N-mixture distribution, while type <code>detection</code> will return the estimated
detection probability from an N-mixture distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior retrodictions are drawn from the fitted <code>mvgam</code> and
organized into a convenient format
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_forecast</code> containing hindcast distributions.
See <code><a href="#topic+mvgam_forecast-class">mvgam_forecast-class</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 3, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2)

# Hindcasts on response scale
hc &lt;- hindcast(mod)
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

# Hindcasts as expectations
hc &lt;- hindcast(mod, type = 'expected')
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

# Estimated latent trends
hc &lt;- hindcast(mod, type = 'trend')
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

</code></pre>

<hr>
<h2 id='index-mvgam'>Index <code>mvgam</code> objects</h2><span id='topic+index-mvgam'></span><span id='topic+variables'></span><span id='topic+Index'></span><span id='topic+and'></span><span id='topic+their'></span><span id='topic++60mgcv+60'></span><span id='topic+coefficient'></span><span id='topic+names'></span><span id='topic+variables.mvgam'></span>

<h3>Description</h3>

<p>Index <code>mvgam</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
variables(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index-mvgam_+3A_x">x</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="index-mvgam_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> object of the variables that can be extracted, along
with their aliases
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             trend_model = AR(),
             data = simdat$data_train,
            burnin = 300,
            samples = 300,
            chains = 2)
variables(mod)

## End(Not run)
</code></pre>

<hr>
<h2 id='lfo_cv.mvgam'>Approximate leave-future-out cross-validation of fitted <code>mvgam</code> objects</h2><span id='topic+lfo_cv.mvgam'></span><span id='topic+lfo_cv'></span>

<h3>Description</h3>

<p>Approximate leave-future-out cross-validation of fitted <code>mvgam</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfo_cv(object, ...)

## S3 method for class 'mvgam'
lfo_cv(
  object,
  data,
  min_t,
  fc_horizon = 1,
  pareto_k_threshold = 0.7,
  silent = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfo_cv.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response variable and covariates
required by the GAM <code>formula</code>. Should include columns:
'series' (character or factor index of the series IDs)
'time' (numeric index of the time point for each observation).
Any other variables to be included in the linear predictor of <code>formula</code> must also be present</p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_min_t">min_t</code></td>
<td>
<p>Integer specifying the minimum training time required before making predictions
from the data. Default is either <code>30</code>, or whatever training time allows for at least
<code>10</code> lfo-cv calculations (i.e. <code>pmin(max(data$time) - 10, 30)</code>). This value is essentially
arbitrary so it is highly recommended to change it to something that is more suitable to the
data and models being evaluated</p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_fc_horizon">fc_horizon</code></td>
<td>
<p>Integer specifying the number of time steps ahead for evaluating forecasts</p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_pareto_k_threshold">pareto_k_threshold</code></td>
<td>
<p>Proportion specifying the threshold over which the Pareto shape parameter
is considered unstable, triggering a model refit. Default is <code>0.7</code></p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>. If <code>1</code> (the default), most of the informational
messages of compiler and sampler are suppressed. If <code>2</code>, even more messages are suppressed. The
actual sampling progress is still printed. Set <code>refresh = 0</code> to turn this off as well. If using
<code>backend = "rstan"</code> you can also set open_progress = FALSE to prevent opening additional
progress bars.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximate leave-future-out cross-validation uses an expanding training window scheme
to evaluate a model on its forecasting ability. The steps used in this function mirror those laid out
in the <a href="https://mc-stan.org/loo/articles/loo2-lfo.html">lfo vignette from the <code>loo</code> package</a>,
written by Paul Brkner, Jonah Gabry, Aki Vehtari. First, we refit the model using the first <code>min_t</code>
observations to perform a single exact <code>fc_horizon</code>-ahead forecast step. This forecast is evaluated against
the <code>min_t + fc_horizon</code> out of sample observations using the Expected Log Predictive Density (ELPD).
Next, we approximate each successive round of
expanding window forecasts by moving forward one step at a time <code style="white-space: pre;">&#8288;for i in 1:N_evaluations&#8288;</code> and re-weighting
draws from the model's posterior predictive distribution using Pareto Smoothed
Importance Sampling (PSIS). In each iteration <code>i</code>, PSIS weights are obtained for the next observation
that would have been included in the model if we had re-fit (i.e. the last observation that would have
been in the training data, or <code>min_t + i</code>). If these importance ratios are stable, we consider the
approximation adequate and use the re-weighted posterior's forecast for evaluating the next holdout
set of testing observations (<code>(min_t + i + 1):(min_t + i + fc_horizon)</code>). At some point the
importance ratio variability will become too large and importance sampling will fail. This is
indicated by the estimated shape parameter <code>k</code> of the generalized Pareto distribution
crossing a certain threshold <code>pareto_k_threshold</code>. Only then do we refit the model using
all of the observations up to the time of the failure. We then restart the process and iterate forward
until the next refit is triggered (Brkner et al. 2020).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>mvgam_lfo</code> containing the approximate ELPD scores,
the Pareto-k shape values and 'the specified <code>pareto_k_threshold</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Paul-Christian Brkner, Jonah Gabry &amp; Aki Vehtari (2020). Approximate leave-future-out cross-validation for Bayesian time series models
Journal of Statistical Computation and Simulation. 90:14, 2499-2523.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast">forecast</a></code>, <code><a href="#topic+score">score</a></code>, <code><a href="#topic+compare_mvgams">compare_mvgams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate from a Poisson-AR2 model with a seasonal smooth
set.seed(100)
dat &lt;- sim_mvgam(T = 75,
                n_series = 1,
                prop_trend = 0.75,
                trend_model = 'AR2',
                family = poisson())

# Plot the time series
plot_mvgam_series(data = dat$data_train,
                 newdata = dat$data_test,
                 series = 1)

# Fit an appropriate model
mod_ar2 &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
               trend_model = AR(p = 2),
               family = poisson(),
               data = dat$data_train,
               newdata = dat$data_test,
               burnin = 300,
               samples = 300,
               chains = 2)

# Fit a less appropriate model
mod_rw &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
              trend_model = RW(),
              family = poisson(),
              data = dat$data_train,
              newdata = dat$data_test,
              burnin = 300,
              samples = 300,
              chains = 2)

# Compare Discrete Ranked Probability Scores for the testing period
fc_ar2 &lt;- forecast(mod_ar2)
fc_rw &lt;- forecast(mod_rw)
score_ar2 &lt;- score(fc_ar2, score = 'drps')
score_rw &lt;- score(fc_rw, score = 'drps')
sum(score_ar2$series_1$score)
sum(score_rw$series_1$score)

# Now use approximate leave-future-out CV to compare
# rolling forecasts; start at time point 40 to reduce
# computational time and to ensure enough data is available
# for estimating model parameters
lfo_ar2 &lt;- lfo_cv(mod_ar2,
                 min_t = 40,
                 fc_horizon = 3)
lfo_rw &lt;- lfo_cv(mod_rw,
                min_t = 40,
                fc_horizon = 3)

# Plot Pareto-K values and ELPD estimates
plot(lfo_ar2)
plot(lfo_rw)

# Proportion of timepoints in which AR2 model gives better forecasts
length(which((lfo_ar2$elpds - lfo_rw$elpds) &gt; 0)) /
      length(lfo_ar2$elpds)

# A higher total ELPD is preferred
lfo_ar2$sum_ELPD
lfo_rw$sum_ELPD

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.mvgam'>Compute pointwise Log-Likelihoods from fitted <code>mvgam</code> objects</h2><span id='topic+logLik.mvgam'></span>

<h3>Description</h3>

<p>Compute pointwise Log-Likelihoods from fitted <code>mvgam</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
logLik(object, linpreds, newdata, family_pars, include_forecast = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_linpreds">linpreds</code></td>
<td>
<p>Optional <code>matrix</code> of linear predictor draws to use for calculating
pointwise log-likelihoods</p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>list</code> object specifying which series each column
in <code>linpreds</code> belongs to. If <code>linpreds</code> is supplied, then <code>newdata</code> must also be supplied</p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_family_pars">family_pars</code></td>
<td>
<p>Optional <code>list</code> containing posterior draws of
family-specific parameters (i.e. shape, scale or overdispersion parameters). Required if
<code>linpreds</code> and <code>newdata</code> are supplied</p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_include_forecast">include_forecast</code></td>
<td>
<p>Logical. If <code>newdata</code> were fed to the model to compute
forecasts, should the log-likelihood draws for these observations also be returned.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of dimension <code style="white-space: pre;">&#8288;n_samples x n_observations&#8288;</code> containing the pointwise
log-likelihood draws for all observations in <code>newdata</code>. If no <code>newdata</code> is supplied,
log-likelihood draws are returned for all observations that were originally fed to
the model (training observations and, if supplied to the
original model via the <code>newdata</code> argument in <code><a href="#topic+mvgam">mvgam</a></code>,
testing observations)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             trend_model = AR(),
             data = simdat$data_train,
             burnin = 300,
             samples = 300,
             chains = 2)

# Extract logLikelihood values
lls &lt;- logLik(mod)
str(lls)

## End(Not run)
</code></pre>

<hr>
<h2 id='loo.mvgam'>LOO information criteria for <code>mvgam</code> models</h2><span id='topic+loo.mvgam'></span><span id='topic+loo_compare.mvgam'></span>

<h3>Description</h3>

<p>Extract the LOOIC (leave-one-out information criterion) using
<code><a href="loo.html#topic+loo">loo::loo()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
loo(x, incl_dynamics = TRUE, ...)

## S3 method for class 'mvgam'
loo_compare(x, ..., model_names = NULL, incl_dynamics = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.mvgam_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="loo.mvgam_+3A_incl_dynamics">incl_dynamics</code></td>
<td>
<p>Logical; indicates if any latent dynamic structures that
were included in the model should be considered when calculating in-sample
log-likelihoods. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="loo.mvgam_+3A_...">...</code></td>
<td>
<p>More <code>mvgam</code> objects.</p>
</td></tr>
<tr><td><code id="loo.mvgam_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names derived
from deparsing the call. Otherwise will use the passed values as model names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing two (or more) fitted <code>mvgam</code> models, we can estimate the
difference in their in-sample predictive accuracies using the Expcted Log Predictive
Density (ELPD). This metric can be approximated using Pareto Smoothed Importance Sampling, which
is a method to re-weight posterior draws to approximate what predictions the models might have
made for a given datapoint had that datapoint not been included in the original model fit (i.e.
if we were to run a leave-one-out cross-validation and then made a prediction for the held-out
datapoint). See details from <code><a href="loo.html#topic+loo">loo::loo()</a></code> and <code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code> for further information
on how this importance sampling works.
</p>
<p>There are two fundamentally different ways to calculate ELPD from <code>mvgam</code> models that included
dynamic latent processes (i.e. &quot;trend_models&quot;). The first is to use the predictions that were
generated when estimating these latent processes by setting <code>incl_dynamics = TRUE</code>. This works
in the same way that setting <code>incl_autocor = TRUE</code> in <code><a href="brms.html#topic+prepare_predictions">brms::prepare_predictions()</a></code>. But it may
also be desirable to compare predictions by considering that the dynamic processes are nuisance
parameters that we'd wish to account for when making inferences about other processes in the
model (i.e. the linear predictor effects). Setting <code>incl_dynamics = FALSE</code> will accomplish
this by ignoring the dynamic processes when making predictions. This option matches up with
what <code>mvgam</code>'s prediction functions return (i.e. <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>, <code><a href="#topic+ppc">ppc</a></code>,
<code><a href="#topic+pp_check.mvgam">pp_check.mvgam</a></code>, <code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code>) and will be far less forgiving
of models that may be overfitting the training data due to highly flexible dynamic processes
(such as Random Walks, for example). However setting <code>incl_dynamics = FALSE</code> will often result
in less stable Pareto k diagnostics for models with dynamic trends, making ELPD comparisons
difficult and unstable. It is therefore recommended to generally stick with
<code>incl_dynamics = TRUE</code> when comparing models based on in-sample fits, and then to perhaps use
forecast evaluations for further scrutiny of models (see for example <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code>,
<code><a href="#topic+score.mvgam_forecast">score.mvgam_forecast</a></code> and <code><a href="#topic+lfo_cv">lfo_cv</a></code>)
</p>


<h3>Value</h3>

<p>for <code>loo.mvgam</code>, an object of class <code>psis_loo</code> (see <code><a href="loo.html#topic+loo">loo::loo()</a></code>
for details). For <code>loo_compare.mvgam</code>, an object of class <code>compare.loo</code> (
<code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code> for details)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate 4 time series with hierarchical seasonality
# and independent AR1 dynamic processes
set.seed(111)
simdat &lt;- sim_mvgam(seasonality = 'hierarchical',
                   trend_model = AR(),
                   family = gaussian())

# Fit a model with shared seasonality
mod1 &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             data = rbind(simdat$data_train,
             simdat$data_test),
             family = gaussian(),
             chains = 2)

# Inspect the model and calculate LOO
conditional_effects(mod1)
mc.cores.def &lt;- getOption('mc.cores')
options(mc.cores = 1)
loo(mod1)

# Now fit a model with hierarchical seasonality
mod2 &lt;- update(mod1,
              formula = y ~ s(season, bs = 'cc', k = 6) +
              s(season, series, bs = 'fs',
              xt = list(bs = 'cc'), k = 4),
              chains = 2)
conditional_effects(mod2)
loo(mod2)

# Now add AR1 dynamic errors to mod2
mod3 &lt;- update(mod2,
              trend_model = AR(),
              chains = 2)
conditional_effects(mod3)
plot(mod3, type = 'trend')
loo(mod3)

# Compare models using LOO
loo_compare(mod1, mod2, mod3)
options(mc.cores = mc.cores.def)

# Compare forecast abilities using an expanding training window and
# forecasting ahead 1 timepoint from each window; the first window by includes
# the first 92 timepoints (of the 100 that were simulated)
max(mod2$obs_data$time)
lfo_mod2 &lt;- lfo_cv(mod2, min_t = 92)
lfo_mod3 &lt;- lfo_cv(mod3, min_t = 92)

# Take the difference in forecast ELPDs; a model with higher ELPD is preferred,
# so negative values here indicate that mod3 gave better forecasts for a particular
# out of sample timepoint
plot(y = lfo_mod2$elpds - lfo_mod3$elpds,
    x = lfo_mod2$eval_timepoints, pch = 16,
    ylab = 'ELPD_mod2 - ELPD_mod3',
    xlab = 'Evaluation timepoint')
abline(h = 0, lty = 'dashed')

</code></pre>

<hr>
<h2 id='lv_correlations'>Calculate trend correlations based on mvgam latent factor loadings</h2><span id='topic+lv_correlations'></span>

<h3>Description</h3>

<p>This function uses samples of latent trends for each series from a fitted
mvgam model to calculates correlations among series' trends
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lv_correlations(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lv_correlations_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object containing the mean posterior correlations
and the full array of posterior correlations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simdat &lt;- sim_mvgam()
mod &lt;- mvgam(y ~ s(season, bs = 'cc',
                  k = 6),
            trend_model = AR(),
            use_lv = TRUE,
            n_lv = 2,
            data = simdat$data_train,
            burnin = 300,
            samples = 300,
            chains = 2)
lvcors &lt;- lv_correlations(mod)
names(lvcors)
lapply(lvcors, class)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmc_plot.mvgam'>MCMC plots as implemented in <span class="pkg">bayesplot</span></h2><span id='topic+mcmc_plot.mvgam'></span>

<h3>Description</h3>

<p>Convenient way to call MCMC plotting functions
implemented in the <span class="pkg">bayesplot</span> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
mcmc_plot(
  object,
  type = "intervals",
  variable = NULL,
  regex = FALSE,
  use_alias = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_plot.mvgam_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object typically of class <code>brmsfit</code></p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_type">type</code></td>
<td>
<p>The type of the plot.
Supported types are (as names) <code>hist</code>, <code>dens</code>,
<code>hist_by_chain</code>, <code>dens_overlay</code>,
<code>violin</code>, <code>intervals</code>, <code>areas</code>,
<code>areas_ridges</code>, <code>combo</code>, <code>acf</code>,
<code>acf_bar</code>, <code>trace</code>, <code>trace_highlight</code>,
<code>scatter</code>, <code>hex</code>, <code>pairs</code>, <code>violin</code>,
<code>rhat</code>, <code>rhat_hist</code>, <code>neff</code>, <code>neff_hist</code>
and <code>nuts_energy</code>.
For an overview on the various plot types see
<code><a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_variable">variable</code></td>
<td>
<p>Names of the variables (parameters) to plot, as given by a
character vector or a regular expression (if <code>regex = TRUE</code>). By
default, a hopefully not too large selection of variables is plotted.</p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_regex">regex</code></td>
<td>
<p>Logical; Indicates whether <code>variable</code> should
be treated as regular expressions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_use_alias">use_alias</code></td>
<td>
<p>Logical. If more informative names for parameters are available
(i.e. for beta coefficients <code>b</code> or for smoothing parameters <code>rho</code>), replace the uninformative
names with the more informative alias. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plotting functions.
See <code><a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a></code> for
more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
that can be further customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvgam_draws">mvgam_draws</a></code> for an overview of some of the shortcut strings
that can be used for argument <code>variable</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2)
mcmc_plot(mod)
mcmc_plot(mod, type = 'neff_hist')
mcmc_plot(mod, variable = 'betas', type = 'areas')
mcmc_plot(mod, variable = 'trend_params', type = 'combo')

## End(Not run)
</code></pre>

<hr>
<h2 id='model.frame.mvgam'>Extract model.frame from a fitted mvgam object</h2><span id='topic+model.frame.mvgam'></span><span id='topic+model.frame.mvgam_prefit'></span>

<h3>Description</h3>

<p>Extract model.frame from a fitted mvgam object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
model.frame(formula, trend_effects = FALSE, ...)

## S3 method for class 'mvgam_prefit'
model.frame(formula, trend_effects = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.mvgam_+3A_formula">formula</code></td>
<td>
<p>a model <code><a href="stats.html#topic+formula">formula</a></code> or <code><a href="stats.html#topic+terms">terms</a></code>
object or an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="model.frame.mvgam_+3A_trend_effects">trend_effects</code></td>
<td>
<p><code>logical</code>, return the model.frame from the
observation model (if <code>FALSE</code>) or from the underlying process
model (if<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="model.frame.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> containing the fitted model frame
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='monotonic'>Monotonic splines in mvgam</h2><span id='topic+monotonic'></span><span id='topic+smooth.construct.moi.smooth.spec'></span><span id='topic+smooth.construct.mod.smooth.spec'></span><span id='topic+Predict.matrix.moi.smooth'></span><span id='topic+Predict.matrix.mod.smooth'></span>

<h3>Description</h3>

<p>Uses constructors from package <span class="pkg">splines2</span> to build monotonically increasing
or decreasing splines. Details also in Wang &amp; Yan (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'moi.smooth.spec'
smooth.construct(object, data, knots)

## S3 method for class 'mod.smooth.spec'
smooth.construct(object, data, knots)

## S3 method for class 'moi.smooth'
Predict.matrix(object, data)

## S3 method for class 'mod.smooth'
Predict.matrix(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monotonic_+3A_object">object</code></td>
<td>
<p>A smooth specification object, usually generated by a term
<code>s(x, bs = "moi", ...)</code> or <code>s(x, bs = "mod", ...)</code></p>
</td></tr>
<tr><td><code id="monotonic_+3A_data">data</code></td>
<td>
<p>a list containing just the data (including any <code>by</code> variable) required by this term, 
with names corresponding to <code>object$term</code> (and <code>object$by</code>). The <code>by</code> variable 
is the last element.</p>
</td></tr>
<tr><td><code id="monotonic_+3A_knots">knots</code></td>
<td>
<p>a list containing any knots supplied for basis setup &mdash; in same order and with same names as <code>data</code>. 
Can be <code>NULL</code>. See details for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor is not normally called directly,
but is rather used internally by <a href="#topic+mvgam">mvgam</a>. If they are not supplied then the
knots of the spline are placed evenly throughout the covariate values to
which the term refers: For example, if fitting 101 data with an 11
knot spline of x then there would be a knot at every 10th (ordered) x value.
The spline is an implementation of the closed-form I-spline basis based
on the recursion formula given by Ramsay (1988), in which the basis coefficients
must be constrained to either be non-negative (for monotonically increasing
functions) or non-positive (monotonically decreasing)
<br />
<br />
Take note that when using either monotonic basis, the number of basis functions
<code>k</code> must be supplied as an even integer due to the manner in
which monotonic basis functions are constructed
</p>


<h3>Value</h3>

<p>An object of class <code>"moi.smooth"</code> or <code>"mod.smooth"</code>. In addition to
the usual elements of a smooth class documented under <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>,
this object will contain a slot called <code>boundary</code> that defines the endpoints beyond
which the spline will begin extrapolating (extrapolation is flat due to the first
order penalty placed on the smooth function)
</p>


<h3>Note</h3>

<p>This constructor will result in a valid smooth if using a call to
<code><a href="mgcv.html#topic+gam">gam</a></code> or <code><a href="mgcv.html#topic+bam">bam</a></code>, however the resulting
functions will not be guaranteed to be monotonic because constraints on
basis coefficients will not be enforced
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Wang, Wenjie, and Jun Yan. &quot;Shape-Restricted Regression Splines with R Package splines2.&quot;
Journal of Data Science 19.3 (2021).
<br />
<br />
Ramsay, J. O. (1988). Monotone regression splines in action. Statistical Science, 3(4), 425&ndash;441.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data from a monotonically increasing function
set.seed(123123)
x &lt;- runif(80) * 4 - 1
x &lt;- sort(x)
f &lt;- exp(4 * x) / (1 + exp(4 * x))
y &lt;- f + rnorm(80) * 0.1
plot(x, y)

# A standard TRPS smooth doesn't capture monotonicity
mod_data &lt;- data.frame(y = y, x = x)
mod &lt;- gam(y ~ s(x, k = 16),
           data = mod_data,
           family = gaussian())

library(marginaleffects)
plot_predictions(mod,
                 by = 'x',
                 newdata = data.frame(x = seq(min(x) - 0.5,
                                              max(x) + 0.5,
                                              length.out = 100)),
                 points = 0.5)

# Using the 'moi' basis in mvgam rectifies this
mod_data$time &lt;- 1:NROW(mod_data)
mod2 &lt;- mvgam(y ~ s(x, bs = 'moi', k = 18),
             data = mod_data,
             family = gaussian(),
             chains = 2)

plot_predictions(mod2,
                 by = 'x',
                 newdata = data.frame(x = seq(min(x) - 0.5,
                                              max(x) + 0.5,
                                              length.out = 100)),
                 points = 0.5)

plot(mod2, type = 'smooth', realisations = TRUE)

# 'by' terms that produce a different smooth for each level of the 'by'
# factor are also allowed
set.seed(123123)
x &lt;- runif(80) * 4 - 1
x &lt;- sort(x)

# Two different monotonic smooths, one for each factor level
f &lt;- exp(4 * x) / (1 + exp(4 * x))
f2 &lt;- exp(3.5 * x) / (1 + exp(3 * x))
fac &lt;- c(rep('a', 80), rep('b', 80))
y &lt;- c(f + rnorm(80) * 0.1,
       f2 + rnorm(80) * 0.2)
plot(x, y[1:80])
plot(x, y[81:160])

# Gather all data into a data.frame, including the factor 'by' variable
mod_data &lt;- data.frame(y, x, fac = as.factor(fac))
mod_data$time &lt;- 1:NROW(mod_data)

# Fit a model with different smooths per factor level
mod &lt;- mvgam(y ~ s(x, bs = 'moi', by = fac, k = 8),
             data = mod_data,
             family = gaussian(),
             chains = 2)

# Visualise the different monotonic functions
plot_predictions(mod, condition = c('x', 'fac', 'fac'),
                 points = 0.5)
plot(mod, type = 'smooth', realisations = TRUE)

# First derivatives (on the link scale) should never be
# negative for either factor level
(derivs &lt;- slopes(mod, variables = 'x',
                 by = c('x', 'fac'),
                 type = 'link'))
all(derivs$estimate &gt; 0)

</code></pre>

<hr>
<h2 id='mvgam'>Fit a Bayesian dynamic GAM to a univariate or multivariate set of time series</h2><span id='topic+mvgam'></span>

<h3>Description</h3>

<p>This function estimates the posterior distribution for Generalised Additive Models (GAMs) that can include
smooth spline functions, specified in the GAM formula, as well as latent temporal processes,
specified by <code>trend_model</code>. Further modelling options include State-Space representations to allow covariates
and dynamic processes to occur on the latent 'State' level while also capturing observation-level effects.
Prior specifications are flexible and explicitly encourage users to apply
prior distributions that actually reflect their beliefs. In addition, model fits can easily be assessed and
compared with posterior predictive checks, forecast comparisons and leave-one-out / leave-future-out cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvgam(
  formula,
  trend_formula,
  knots,
  trend_knots,
  data,
  data_train,
  newdata,
  data_test,
  run_model = TRUE,
  prior_simulation = FALSE,
  return_model_data = FALSE,
  family = "poisson",
  share_obs_params = FALSE,
  use_lv = FALSE,
  n_lv,
  trend_map,
  trend_model = "None",
  drift = FALSE,
  noncentred = FALSE,
  chains = 4,
  burnin = 500,
  samples = 500,
  thin = 1,
  parallel = TRUE,
  threads = 1,
  priors,
  refit = FALSE,
  lfo = FALSE,
  residuals = TRUE,
  use_stan = TRUE,
  backend = getOption("brms.backend", "cmdstanr"),
  algorithm = getOption("brms.algorithm", "sampling"),
  autoformat = TRUE,
  save_all_pars = FALSE,
  max_treedepth = 12,
  adapt_delta = 0.85,
  silent = 1,
  jags_path,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvgam_+3A_formula">formula</code></td>
<td>
<p>A <code>character</code> string specifying the GAM observation model formula. These are exactly like the formula
for a GLM except that smooth terms, <code>s()</code>, <code>te()</code>, <code>ti()</code>, <code>t2()</code>, as well as time-varying
<code>dynamic()</code> terms, can be added to the right hand side
to specify that the linear predictor depends on smooth functions of predictors
(or linear functionals of these). In <code>nmix()</code> family models, the <code>formula</code> is used to
set up a linear predictor for the detection probability. Details of the formula syntax used by <span class="pkg">mvgam</span>
can be found in <code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_trend_formula">trend_formula</code></td>
<td>
<p>An optional <code>character</code> string specifying the GAM process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture process model evolution
separately from the observation model. Should not have a response variable specified on the left-hand side
of the formula (i.e. a valid option would be <code>~ season + s(year)</code>). Also note that you should not use
the identifier <code>series</code> in this formula to specify effects that vary across time series. Instead you should use
<code>trend</code>. This will ensure that models in which a <code>trend_map</code> is supplied will still work consistently
(i.e. by allowing effects to vary across process models, even when some time series share the same underlying
process model). This feature is only currently available for <code>RW()</code>, <code>AR()</code> and <code>VAR()</code> trend models.
In <code>nmix()</code> family models, the <code>trend_formula</code> is used to set up a linear predictor for the underlying
latent abundance</p>
</td></tr>
<tr><td><code id="mvgam_+3A_knots">knots</code></td>
<td>
<p>An optional <code>list</code> containing user specified knot values to be used for basis construction.
For most bases the user simply supplies the knots to be used, which must match up with the k value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can use different numbers of knots,
unless they share a covariate</p>
</td></tr>
<tr><td><code id="mvgam_+3A_trend_knots">trend_knots</code></td>
<td>
<p>As for <code>knots</code> above, this is an optional <code>list</code> of knot values for smooth
functions within the <code>trend_formula</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response variable and covariates
required by the GAM <code>formula</code> and optional <code>trend_formula</code>. Should include columns:
#'</p>

<ul>
<li><p><code>series</code> (a <code>factor</code> index of the series IDs; the number of levels should be identical
to the number of unique series labels (i.e. <code>n_series = length(levels(data$series))</code>))
</p>
</li>
<li><p><code>time</code> (<code>numeric</code> or <code>integer</code> index of the time point for each observation).
For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>), time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>). However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. See an example of <code>CAR()</code> trends in <code><a href="#topic+CAR">CAR</a></code>
</p>
</li></ul>

<p>Should also include any other variables to be included in the linear predictor of <code>formula</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_data_train">data_train</code></td>
<td>
<p>Deprecated. Still works in place of <code>data</code> but users are recommended to use
<code>data</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least <code>series</code> and <code>time</code>
in addition to any other variables included in the linear predictor of <code>formula</code>. If included, the
observations in variable <code>y</code> will be set to <code>NA</code> when fitting the model so that posterior
simulations can be obtained</p>
</td></tr>
<tr><td><code id="mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="mvgam_+3A_run_model">run_model</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code>, the model is not fitted but instead the function will
return the model file and the data / initial values that are needed to fit the model outside of <code>mvgam</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_prior_simulation">prior_simulation</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, no observations are fed to the model, and instead
simulations from prior distributions are returned</p>
</td></tr>
<tr><td><code id="mvgam_+3A_return_model_data">return_model_data</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the list of data that is needed to fit the
model is returned, along with the initial values for smooth and AR parameters, once the model is fitted.
This will be helpful if users wish to modify the model file to add
other stochastic elements that are not currently available in <code>mvgam</code>.
Default is <code>FALSE</code> to reduce
the size of the returned object, unless <code>run_model == FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the exponential observation family for the series. Currently supported
families are:
</p>

<ul>
<li><p><code>gaussian()</code> for real-valued data
</p>
</li>
<li><p><code>betar()</code> for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li><p><code>lognormal()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>student_t()</code> for real-valued data
</p>
</li>
<li><p><code>Gamma()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>bernoulli()</code> for binary data
</p>
</li>
<li><p><code>poisson()</code> for count data
</p>
</li>
<li><p><code>nb()</code> for overdispersed count data
</p>
</li>
<li><p><code>binomial()</code> for count data with imperfect detection when the number of trials is known;
note that the <code>cbind()</code> function must be used to bind the discrete observations and the discrete number
of trials
</p>
</li>
<li><p><code>beta_binomial()</code> as for <code>binomial()</code> but allows for overdispersion
</p>
</li>
<li><p><code>nmix()</code> for count data with imperfect detection when the number of trials
is unknown and should be modeled via a State-Space N-Mixture model.
The latent states are Poisson, capturing the 'true' latent
abundance, while the observation process is Binomial to account for
imperfect detection.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for an example of how to use this family</p>
</li></ul>

<p>Note that only <code>nb()</code> and <code>poisson()</code> are available if using <code>JAGS</code> as the backend.
Default is <code>poisson()</code>.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for more details</p>
</td></tr>
<tr><td><code id="mvgam_+3A_share_obs_params">share_obs_params</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and the <code>family</code>
has additional family-specific observation parameters (e.g. variance components in
<code>student_t()</code> or <code>gaussian()</code>, or dispersion parameters in <code>nb()</code> or <code>betar()</code>),
these parameters will be shared across all series. This is handy if you have multiple
time series that you believe share some properties, such as being from the same
species over different spatial units. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mvgam_+3A_use_lv">use_lv</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for
<code>RW()</code>, <code>AR()</code> and <code>GP()</code> trend models. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code> the number of latent dynamic factors to use if <code>use_lv == TRUE</code>.
Cannot be <code>&gt; n_series</code>. Defaults arbitrarily to <code>min(2, floor(n_series / 2))</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_trend_map">trend_map</code></td>
<td>
<p>Optional <code>data.frame</code> specifying which series should depend on which latent
trends. Useful for allowing multiple series to depend on the same latent trend process, but with
different observation processes. If supplied, a latent factor model is set up by setting
<code>use_lv = TRUE</code> and using the mapping to set up the shared trends. Needs to have column names
<code>series</code> and <code>trend</code>, with integer values in the <code>trend</code> column to state which trend each series
should depend on. The <code>series</code> column should have a single unique entry for each series in the
data (names should perfectly match factor levels of the <code>series</code> variable in <code>data</code>). See examples
for details</p>
</td></tr>
<tr><td><code id="mvgam_+3A_trend_model">trend_model</code></td>
<td>
<p><code>character</code> or  <code>function</code> specifying the time series dynamics for the latent trend. Options are:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>'RW'</code> or <code>RW()</code>
</p>
</li>
<li> <p><code>'AR1'</code> or <code>AR(p = 1)</code>
</p>
</li>
<li> <p><code>'AR2'</code> or <code>AR(p = 2)</code>
</p>
</li>
<li> <p><code>'AR3'</code> or <code>AR(p = 3)</code>
</p>
</li>
<li> <p><code>'CAR1'</code> or <code>CAR(p = 1)</code>
</p>
</li>
<li> <p><code>'VAR1'</code>  or <code>VAR()</code>(only available in <code>Stan</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;'PWlogistic&#8288;</code>, <code>'PWlinear'</code> or <code>PW()</code> (only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>'GP'</code> or <code>GP()</code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p>
</li></ul>

<p>For all trend types apart from <code>GP()</code>, <code>CAR()</code> and <code>PW()</code>, moving average and/or correlated
process error terms can also be estimated (for example, <code>RW(cor = TRUE)</code> will set up a
multivariate Random Walk if <code>n_series &gt; 1</code>). See <a href="#topic+mvgam_trends">mvgam_trends</a> for more details</p>
</td></tr>
<tr><td><code id="mvgam_+3A_drift">drift</code></td>
<td>
<p><code>logical</code> estimate a drift parameter in the latent trend components. Useful if the latent
trend is expected to broadly follow a non-zero slope. Only available for
<code>RW()</code> and <code>AR()</code> trend models. Note that if the latent trend is more or less stationary,
the drift parameter can become unidentifiable, especially if an intercept term is included in the GAM linear
predictor (which it is by default when calling <code><a href="mgcv.html#topic+jagam">jagam</a></code>). Drift parameters will also likely
be unidentifiable if using dynamic factor models. Therefore this defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_noncentred">noncentred</code></td>
<td>
<p><code>logical</code> experimental feature to use the non-centred parameterisation for
trend models. Only available for certain trend models
(i.e. <code>RW()</code>, <code>AR()</code>, or <code>CAR()</code> with or without <code>drift</code>, or for
<code>trend = 'None'</code> when using a <code>trend_formula</code>). Not yet available for moving average or
correlated error models</p>
</td></tr>
<tr><td><code id="mvgam_+3A_chains">chains</code></td>
<td>
<p><code>integer</code> specifying the number of parallel chains for the model. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_burnin">burnin</code></td>
<td>
<p><code>integer</code> specifying the number of warmup iterations of the Markov chain to run
to tune sampling algorithms. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_samples">samples</code></td>
<td>
<p><code>integer</code> specifying the number of post-warmup iterations of the Markov chain to run for
sampling the posterior distribution</p>
</td></tr>
<tr><td><code id="mvgam_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitors.  Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_parallel">parallel</code></td>
<td>
<p><code>logical</code> specifying whether multiple cores should be used for
generating MCMC simulations in parallel. If <code>TRUE</code>, the number of cores to use will be
<code>min(c(chains, parallel::detectCores() - 1))</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> Experimental option to use multithreading for within-chain
parallelisation in <code>Stan</code>. We recommend its use only if you are experienced with
<code>Stan</code>'s <code>reduce_sum</code> function and have a slow running model that cannot be sped
up by any other means. Only available for some families(<code>poisson()</code>, <code>nb()</code>, <code>gaussian()</code>) and
when using <code>Cmdstan</code> as the backend</p>
</td></tr>
<tr><td><code id="mvgam_+3A_priors">priors</code></td>
<td>
<p>An optional <code>data.frame</code> with prior
definitions (in JAGS or Stan syntax). if using Stan, this can also be an object of
class <code>brmsprior</code> (see. <code><a href="brms.html#topic+prior">prior</a></code> for details). See <a href="#topic+get_mvgam_priors">get_mvgam_priors</a> and
'Details' for more information on changing default prior distributions</p>
</td></tr>
<tr><td><code id="mvgam_+3A_refit">refit</code></td>
<td>
<p>Logical indicating whether this is a refit, called using <a href="#topic+update.mvgam">update.mvgam</a>. Users should leave
as <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_lfo">lfo</code></td>
<td>
<p>Logical indicating whether this is part of a call to <a href="#topic+lfo_cv.mvgam">lfo_cv.mvgam</a>. Returns a
lighter version of the model with no residuals and fewer monitored parameters to speed up
post-processing. But other downstream functions will not work properly, so users should always
leave this set as <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_residuals">residuals</code></td>
<td>
<p>Logical indicating whether to compute series-level randomized quantile residuals and include
them as part of the returned object. Defaults to <code>TRUE</code>, but you can set to <code>FALSE</code> to save
computational time and reduce the size of the returned object (users can always add residuals to
an object of class <code>mvgam</code> using <a href="#topic+add_residuals">add_residuals</a>)</p>
</td></tr>
<tr><td><code id="mvgam_+3A_use_stan">use_stan</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model will be compiled and sampled using
Hamiltonian Monte Carlo with a call to <code><a href="cmdstanr.html#topic+cmdstan_model">cmdstan_model</a></code> or
a call to <code><a href="rstan.html#topic+stan">stan</a></code>. Note that
there are many more options when using <code>Stan</code> vs <code>JAGS</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_backend">backend</code></td>
<td>
<p>Character string naming the package to use as the backend for fitting
the Stan model (if <code>use_stan = TRUE</code>). Options are &quot;cmdstanr&quot; (the default) or &quot;rstan&quot;. Can be set globally
for the current R session via the <code>"brms.backend"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Details on
the rstan and cmdstanr packages are available at https://mc-stan.org/rstan/ and
https://mc-stan.org/cmdstanr/, respectively</p>
</td></tr>
<tr><td><code id="mvgam_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with factorized normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, <code>"laplace"</code> for a Laplace approximation (only available
when using cmdstanr as the backend) or <code>"pathfinder"</code> for the pathfinder
algorithm (only currently available when using cmdstanr as the backend).
Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Limited testing
suggests that <code>"meanfield"</code> performs best out of the non-MCMC approximations for
dynamic GAMs, possibly because of the difficulties estimating covariances among the
many spline parameters and latent trend parameters. But rigorous testing has not
been carried out</p>
</td></tr>
<tr><td><code id="mvgam_+3A_autoformat">autoformat</code></td>
<td>
<p><code>Logical</code>. Use the <code>stanc</code> parser to automatically format the
<code>Stan</code> code and check for deprecations. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_save_all_pars">save_all_pars</code></td>
<td>
<p><code>Logical</code> flag to indicate if draws from all
variables defined in Stan's <code>parameters</code> block should be saved
(default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mvgam_+3A_max_treedepth">max_treedepth</code></td>
<td>
<p>positive integer placing a cap on the number of simulation steps evaluated during each iteration when
<code>use_stan == TRUE</code>. Default is <code>12</code>. Increasing this value can sometimes help with exploration of complex
posterior geometries, but it is rarely fruitful to go above a <code>max_treedepth</code> of <code>14</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>positive numeric between <code>0</code> and <code>1</code> defining the target average proposal acceptance probability
during Stan's adaptation period, if <code>use_stan == TRUE</code>. Default is <code>0.8</code>. In general you should not need to change adapt_delta
unless you see a warning message about divergent transitions, in which case you can increase adapt_delta from the default
to a value closer to <code>1</code> (e.g. from <code>0.95</code> to <code>0.99</code>, or from <code>0.99</code> to <code>0.999</code>, etc).
The step size used by the numerical integrator is a function of <code>adapt_delta</code> in that increasing
<code>adapt_delta</code> will result in a smaller step size and fewer divergences. Increasing <code>adapt_delta</code> will
typically result in a slower sampler, but it will always lead to a more robust sampler</p>
</td></tr>
<tr><td><code id="mvgam_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>. If <code>1</code> (the default), most of the informational
messages of compiler and sampler are suppressed. If <code>2</code>, even more messages are suppressed. The
actual sampling progress is still printed. Set <code>refresh = 0</code> to turn this off as well. If using
<code>backend = "rstan"</code> you can also set open_progress = FALSE to prevent opening additional
progress bars.</p>
</td></tr>
<tr><td><code id="mvgam_+3A_jags_path">jags_path</code></td>
<td>
<p>Optional character vector specifying the path to the location of the <code>JAGS</code> executable (.exe) to use
for modelling if <code>use_stan == FALSE</code>. If missing, the path will be recovered from a call to <code><a href="runjags.html#topic+findjags">findjags</a></code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments passed to Stan.
For <code>backend = "rstan"</code> the arguments are passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code> or <code><a href="rstan.html#topic+vb">vb</a></code>.
For <code>backend = "cmdstanr"</code> the arguments are passed to the
<code>cmdstanr::sample</code>, <code>cmdstanr::variational</code>,
<code>cmdstanr::laplace</code> or
<code>cmdstanr::pathfinder</code> method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic GAMs are useful when we wish to predict future values from time series that show temporal dependence
but we do not want to rely on extrapolating from a smooth term (which can sometimes lead to unpredictable and unrealistic behaviours).
In addition, smooths can often try to wiggle excessively to capture any autocorrelation that is present in a time series,
which exacerbates the problem of forecasting ahead. As GAMs are very naturally viewed through a Bayesian lens, and we often
must model time series that show complex distributional features and missing data, parameters for <code>mvgam</code> models are estimated
in a Bayesian framework using Markov Chain Monte Carlo by default. A general overview is provided
in the primary vignettes: <code>vignette("mvgam_overview")</code> and <code>vignette("data_in_mvgam")</code>.
For a full list of available vignettes see <code>vignette(package = "mvgam")</code>
<br />
<br />
<em>Formula syntax</em>: Details of the formula syntax used by <span class="pkg">mvgam</span> can be found in
<code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code>. Note that it is possible to supply an empty formula where
there are no predictors or intercepts in the observation model (i.e. <code>y ~ 0</code> or <code>y ~ -1</code>).
In this case, an intercept-only observation model will be set up but the intercept coefficient
will be fixed at zero. This can be handy if you wish to fit pure State-Space models where
the variation in the dynamic trend controls the average expectation, and/or where intercepts
are non-identifiable (as in piecewise trends, see examples below)
<br />
<br />
<em>Families and link functions</em>: Details of families supported by <span class="pkg">mvgam</span> can be found in
<code><a href="#topic+mvgam_families">mvgam_families</a></code>.
<br />
<br />
<em>Trend models</em>: Details of latent trend dynamic models supported by <span class="pkg">mvgam</span> can be found in
<code><a href="#topic+mvgam_trends">mvgam_trends</a></code>.
<br />
<br />
<em>Priors</em>: A <code><a href="mgcv.html#topic+jagam">jagam</a></code> model file is generated from <code>formula</code> and
modified to include any latent
temporal processes. Default priors for intercepts and any scale parameters are generated
using the same practice as <span class="pkg">brms</span>. Prior distributions for most important model parameters can be
altered by the user to inspect model
sensitivities to given priors (see <code><a href="#topic+get_mvgam_priors">get_mvgam_priors</a></code> for details).
Note that latent trends are estimated on the link scale so choose priors
accordingly. However more control over the model specification can be accomplished by first using <code>mvgam</code> as a
baseline, then editing the returned model accordingly. The model file can be edited and run outside
of <code>mvgam</code> by setting <code>run_model = FALSE</code> and this is encouraged for complex
modelling tasks. Note, no priors are
formally checked to ensure they are in the right syntax for the respective
probabilistic modelling framework, so it is
up to the user to ensure these are correct (i.e. use <code>dnorm</code> for normal
densities in <code>JAGS</code>, with the mean and precision
parameterisation; but use <code>normal</code> for normal densities in <code>Stan</code>, with the mean
and standard deviation parameterisation)
<br />
<br />
<em>Random effects</em>: For any smooth terms using the random effect basis (<code><a href="mgcv.html#topic+smooth.construct.re.smooth.spec">smooth.construct.re.smooth.spec</a></code>),
a non-centred parameterisation is automatically employed to avoid degeneracies that are common in hierarchical models.
Note however that centred versions may perform better for series that are particularly informative, so as with any
foray into Bayesian modelling, it is worth building an understanding of the model's assumptions and limitations by following a
principled workflow. Also note that models are parameterised using <code>drop.unused.levels = FALSE</code> in <code><a href="mgcv.html#topic+jagam">jagam</a></code>
to ensure predictions can be made for all levels of the supplied factor variable
<br />
<br />
<em>Observation level parameters</em>: When more than one series is included in <code>data</code> and an
observation family that contains more than one parameter is used, additional observation family parameters
(i.e. <code>phi</code> for <code>nb()</code> or <code>sigma</code> for <code>gaussian()</code>) are
by default estimated independently for each series. But if you wish for the series to share
the same observation parameters, set <code>share_obs_params = TRUE</code>
<br />
<br />
<em>Factor regularisation</em>: When using a dynamic factor model for the trends with <code>JAGS</code> factor precisions are given
regularized penalty priors to theoretically allow some factors to be dropped from the model by squeezing increasing
factors' variances to zero. This is done to help protect against selecting too many latent factors than are needed to
capture dependencies in the data, so it can often be advantageous to set <code>n_lv</code> to a slightly larger number. However
larger numbers of factors do come with additional computational costs so these should be balanced as well. When using
<code>Stan</code>, all factors are parameterised with fixed variance parameters
<br />
<br />
<em>Residuals</em>: For each series, randomized quantile (i.e. Dunn-Smyth) residuals are calculated for inspecting model diagnostics
If the fitted model is appropriate then Dunn-Smyth residuals will be standard normal in distribution and no
autocorrelation will be evident. When a particular observation is missing, the residual is calculated by comparing independent
draws from the model's posterior distribution
<br />
<br />
<em>Using Stan</em>: <code>mvgam</code> is primarily designed to use Hamiltonian Monte Carlo for parameter estimation
via the software <code>Stan</code> (using either the <code>cmdstanr</code> or <code>rstan</code> interface).
There are great advantages when using <code>Stan</code> over Gibbs / Metropolis Hastings samplers, which includes the option
to estimate smooth latent trends via <a href="https://arxiv.org/abs/2004.11408">Hilbert space approximate Gaussian Processes</a>.
This often makes sense for ecological series, which we expect to change smoothly. In <code>mvgam</code>, latent squared
exponential GP trends are approximated using by default <code>20</code> basis functions, which saves computational
costs compared to fitting full GPs while adequately estimating
GP <code>alpha</code> and <code>rho</code> parameters. Because of the many advantages of <code>Stan</code> over <code>JAGS</code>,
<em>further development of the package will only be applied to <code>Stan</code></em>. This includes the planned addition
of more response distributions, plans to handle zero-inflation, and plans to incorporate a greater
variety of trend models. Users are strongly encouraged to opt for <code>Stan</code> over <code>JAGS</code> in any proceeding workflows
</p>


<h3>Value</h3>

<p>A <code>list</code> object of class <code>mvgam</code> containing model output, the text representation of the model file,
the mgcv model output (for easily generating simulations at
unsampled covariate values), Dunn-Smyth residuals for each series and key information needed
for other functions in the package. See <code><a href="#topic+mvgam-class">mvgam-class</a></code> for details.
Use <code>methods(class = "mvgam")</code> for an overview on available methods.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Nicholas J Clark &amp; Konstans Wells (2020). Dynamic generalised additive models (DGAMs) for forecasting discrete ecological time series.
Methods in Ecology and Evolution. 14:3, 771-784.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+jagam">jagam</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="mgcv.html#topic+gam.models">gam.models</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate a collection of three time series that have shared seasonal dynamics
# and independent AR1 trends, with a Poisson observation process
set.seed(0)
dat &lt;- sim_mvgam(T = 80,
                n_series = 3,
                mu = 2,
                trend_model = AR(p = 1),
                prop_missing = 0.1,
                prop_trend = 0.6)

# Plot key summary statistics for a single series
plot_mvgam_series(data = dat$data_train, series = 1)

# Plot all series together
plot_mvgam_series(data = dat$data_train, series = 'all')

# Formulate a model using Stan where series share a cyclic smooth for
# seasonality and each series has an independent AR1 temporal process;
# Set run_model = FALSE to inspect the returned objects
mod1 &lt;- mvgam(formula = y ~ s(season, bs = 'cc', k = 6),
             data = dat$data_train,
             trend_model = AR(),
             family = poisson(),
             noncentred = TRUE,
             use_stan = TRUE,
             run_model = FALSE)

# View the model code in Stan language
code(mod1)

# Now fit the model, noting that 'noncentred = TRUE' will likely give performance gains
mod1 &lt;- mvgam(formula = y ~ s(season, bs = 'cc', k = 6),
              data = dat$data_train,
              trend_model = AR(),
              family = poisson(),
              noncentred = TRUE,
              chains = 2)

# Extract the model summary
summary(mod1)

# Plot the estimated historical trend and forecast for one series
plot(mod1, type = 'trend', series = 1)
plot(mod1, type = 'forecast', series = 1)

# Residual diagnostics
plot(mod1, type = 'residuals', series = 1)
resids &lt;- residuals(mod1)
str(resids)

# Compute the forecast using covariate information in data_test
fc &lt;- forecast(mod1, newdata = dat$data_test)
str(fc)
plot(fc)

# Plot the estimated seasonal smooth function
plot(mod1, type = 'smooths')

# Plot estimated first derivatives of the smooth
plot(mod1, type = 'smooths', derivatives = TRUE)

# Plot partial residuals of the smooth
plot(mod1, type = 'smooths', residuals = TRUE)

# Plot posterior realisations for the smooth
plot(mod1, type = 'smooths', realisations = TRUE)

# Plot conditional response predictions using marginaleffects
library(marginaleffects)
conditional_effects(mod1)
plot_predictions(mod1, condition = 'season', points = 0.5)

# Generate posterior predictive checks using bayesplot
pp_check(mod1)

# Extract observation model beta coefficient draws as a data.frame
beta_draws_df &lt;- as.data.frame(mod1, variable = 'betas')
head(beta_draws_df)
str(beta_draws_df)

# Investigate model fit
mc.cores.def &lt;- getOption('mc.cores')
options(mc.cores = 1)
loo(mod1)
options(mc.cores = mc.cores.def)


# Example of supplying a trend_map so that some series can share
# latent trend processes
sim &lt;- sim_mvgam(n_series = 3)
mod_data &lt;- sim$data_train

# Here, we specify only two latent trends; series 1 and 2 share a trend,
# while series 3 has it's own unique latent trend
trend_map &lt;- data.frame(series = unique(mod_data$series),
                       trend = c(1, 1, 2))

# Fit the model using AR1 trends
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             trend_map = trend_map,
             trend_model = AR(),
             data = mod_data,
             return_model_data = TRUE,
             chains = 2)

# The mapping matrix is now supplied as data to the model in the 'Z' element
mod$model_data$Z
code(mod)

# The first two series share an identical latent trend; the third is different
plot(mod, type = 'trend', series = 1)
plot(mod, type = 'trend', series = 2)
plot(mod, type = 'trend', series = 3)


# Example of how to use dynamic coefficients
# Simulate a time-varying coefficient for the effect of temperature
set.seed(123)
N &lt;- 200
beta_temp &lt;- vector(length = N)
beta_temp[1] &lt;- 0.4
for(i in 2:N){
 beta_temp[i] &lt;- rnorm(1, mean = beta_temp[i - 1] - 0.0025, sd = 0.05)
}
plot(beta_temp)

# Simulate a covariate called 'temp'
temp &lt;- rnorm(N, sd = 1)

# Simulate the Gaussian observation process
out &lt;- rnorm(N, mean = 4 + beta_temp * temp,
             sd = 0.5)

# Gather necessary data into a data.frame; split into training / testing
data = data.frame(out, temp, time = seq_along(temp))
data_train &lt;- data[1:180,]
data_test &lt;- data[181:200,]

# Fit the model using the dynamic() formula helper
mod &lt;- mvgam(out ~
              dynamic(temp,
                      scale = FALSE,
                      k = 40),
             family = gaussian(),
             data = data_train,
             newdata = data_test,
             chains = 2)

# Inspect the model summary, forecast and time-varying coefficient distribution
summary(mod)
plot(mod, type = 'smooths')
fc &lt;- forecast(mod, newdata = data_test)
plot(fc)

# Propagating the smooth term shows how the coefficient is expected to evolve
plot_mvgam_smooth(mod, smooth = 1, newdata = data)
abline(v = 180, lty = 'dashed', lwd = 2)
points(beta_temp, pch = 16)


# Example showing how to incorporate an offset; simulate some count data
# with different means per series
set.seed(100)
dat &lt;- sim_mvgam(prop_trend = 0, mu = c(0, 2, 2),
                 seasonality = 'hierarchical')

# Add offset terms to the training and testing data
dat$data_train$offset &lt;- 0.5 * as.numeric(dat$data_train$series)
dat$data_test$offset &lt;- 0.5 * as.numeric(dat$data_test$series)

# Fit a model that includes the offset in the linear predictor as well as
# hierarchical seasonal smooths
mod &lt;- mvgam(formula = y ~ offset(offset) +
              s(series, bs = 're') +
              s(season, bs = 'cc') +
              s(season, by = series, m = 1, k = 5),
             data = dat$data_train,
             chains = 2)

# Inspect the model file to see the modification to the linear predictor
# (eta)
code(mod)

# Forecasts for the first two series will differ in magnitude
fc &lt;- forecast(mod, newdata = dat$data_test)
layout(matrix(1:2, ncol = 2))
plot(fc, series = 1, ylim = c(0, 75))
plot(fc, series = 2, ylim = c(0, 75))
layout(1)

# Changing the offset for the testing data should lead to changes in
# the forecast
dat$data_test$offset &lt;- dat$data_test$offset - 2
fc &lt;- forecast(mod, newdata = dat$data_test)
plot(fc)

# Relative Risks can be computed by fixing the offset to the same value
# for each series
dat$data_test$offset &lt;- rep(1, NROW(dat$data_test))
preds_rr &lt;- predict(mod, type = 'link', newdata = dat$data_test,
                    summary = FALSE)
series1_inds &lt;- which(dat$data_test$series == 'series_1')
series2_inds &lt;- which(dat$data_test$series == 'series_2')

# Relative Risks are now more comparable among series
layout(matrix(1:2, ncol = 2))
plot(preds_rr[1, series1_inds], type = 'l', col = 'grey75',
     ylim = range(preds_rr),
     ylab = 'Series1 Relative Risk', xlab = 'Time')
for(i in 2:50){
 lines(preds_rr[i, series1_inds], col = 'grey75')
}

plot(preds_rr[1, series2_inds], type = 'l', col = 'darkred',
     ylim = range(preds_rr),
     ylab = 'Series2 Relative Risk', xlab = 'Time')
for(i in 2:50){
 lines(preds_rr[i, series2_inds], col = 'darkred')
 }
layout(1)


# Example showcasing how cbind() is needed for Binomial observations
# Simulate two time series of Binomial trials
trials &lt;- sample(c(20:25), 50, replace = TRUE)
x &lt;- rnorm(50)
detprob1 &lt;- plogis(-0.5 + 0.9*x)
detprob2 &lt;- plogis(-0.1 -0.7*x)
dat &lt;- rbind(data.frame(y = rbinom(n = 50, size = trials, prob = detprob1),
                        time = 1:50,
                        series = 'series1',
                        x = x,
                        ntrials = trials),
             data.frame(y = rbinom(n = 50, size = trials, prob = detprob2),
                        time = 1:50,
                        series = 'series2',
                        x = x,
                        ntrials = trials))
dat &lt;- dplyr::mutate(dat, series = as.factor(series))
dat &lt;- dplyr::arrange(dat, time, series)
plot_mvgam_series(data = dat, series = 'all')

# Fit a model using the binomial() family; must specify observations
# and number of trials in the cbind() wrapper
mod &lt;- mvgam(cbind(y, ntrials) ~ series + s(x, by = series),
             family = binomial(),
             data = dat,
             chains = 2)
summary(mod)
pp_check(mod, type = "bars_grouped",
         group = "series", ndraws = 50)
pp_check(mod, type = "ecdf_overlay_grouped",
         group = "series", ndraws = 50)
conditional_effects(mod, type = 'link')

</code></pre>

<hr>
<h2 id='mvgam_diagnostics'>Extract diagnostic quantities of <span class="pkg">mvgam</span> models</h2><span id='topic+mvgam_diagnostics'></span><span id='topic+nuts_params'></span><span id='topic+rhat'></span><span id='topic+neff_ratio'></span><span id='topic+nuts_params.mvgam'></span><span id='topic+log_posterior.mvgam'></span><span id='topic+rhat.mvgam'></span><span id='topic+neff_ratio.mvgam'></span>

<h3>Description</h3>

<p>Extract quantities that can be used to diagnose sampling behavior
of the algorithms applied by <span class="pkg">Stan</span> at the back-end of <span class="pkg">mvgam</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
nuts_params(object, pars = NULL, ...)

## S3 method for class 'mvgam'
log_posterior(object, ...)

## S3 method for class 'mvgam'
rhat(x, pars = NULL, ...)

## S3 method for class 'mvgam'
neff_ratio(object, pars = NULL, ...)

## S3 method for class 'mvgam'
neff_ratio(object, pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvgam_diagnostics_+3A_object">object</code>, <code id="mvgam_diagnostics_+3A_x">x</code></td>
<td>
<p>A <code>mvgam</code> object.</p>
</td></tr>
<tr><td><code id="mvgam_diagnostics_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names.
For <code>nuts_params</code> these will be NUTS sampler parameter
names rather than model parameters. If pars is omitted
all parameters are included.</p>
</td></tr>
<tr><td><code id="mvgam_diagnostics_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see
<code><a href="bayesplot.html#topic+bayesplot-extractors">bayesplot-extractors</a></code>.
</p>


<h3>Value</h3>

<p>The exact form of the output depends on the method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2)
np &lt;- nuts_params(mod)
head(np)

# extract the number of divergence transitions
sum(subset(np, Parameter == "divergent__")$Value)

head(neff_ratio(mod))

</code></pre>

<hr>
<h2 id='mvgam_draws'>Extract posterior draws from fitted <code>mvgam</code> objects</h2><span id='topic+mvgam_draws'></span><span id='topic+as.data.frame.mvgam'></span><span id='topic+as.matrix.mvgam'></span><span id='topic+as.array.mvgam'></span><span id='topic+as_draws.mvgam'></span><span id='topic+as_draws_matrix.mvgam'></span><span id='topic+as_draws_df.mvgam'></span><span id='topic+as_draws_array.mvgam'></span><span id='topic+as_draws_list.mvgam'></span><span id='topic+as_draws_rvars.mvgam'></span>

<h3>Description</h3>

<p>Extract posterior draws in conventional formats as data.frames, matrices, or arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
as.data.frame(
  x,
  row.names = NULL,
  optional = TRUE,
  variable = "betas",
  use_alias = TRUE,
  regex = FALSE,
  ...
)

## S3 method for class 'mvgam'
as.matrix(x, variable = "betas", regex = FALSE, use_alias = TRUE, ...)

## S3 method for class 'mvgam'
as.array(x, variable = "betas", regex = FALSE, use_alias = TRUE, ...)

## S3 method for class 'mvgam'
as_draws(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_matrix(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_df(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_array(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_list(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_rvars(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvgam_draws_+3A_x">x</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_row.names">row.names</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_optional">optional</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_variable">variable</code></td>
<td>
<p>A character specifying which parameters to extract. Can either be one of the
following options:
</p>

<ul>
<li> <p><code>obs_params</code> (other parameters specific to the observation model, such as overdispsersions
for negative binomial models or observation error SD for gaussian / student-t models)
</p>
</li>
<li> <p><code>betas</code> (beta coefficients from the GAM observation model linear predictor; default)
</p>
</li>
<li> <p><code>smooth_params</code> (smoothing parameters from the GAM observation model)
</p>
</li>
<li> <p><code>linpreds</code> (estimated linear predictors on whatever link scale was used in the model)
</p>
</li>
<li> <p><code>trend_params</code> (parameters governing the trend dynamics, such as AR parameters,
trend SD parameters or Gaussian Process parameters)
</p>
</li>
<li> <p><code>trend_betas</code> (beta coefficients from the GAM latent process model linear predictor;
only available if a <code>trend_formula</code> was supplied in the original model)
</p>
</li>
<li> <p><code>trend_smooth_params</code> (process model GAM smoothing parameters;
only available if a <code>trend_formula</code> was supplied in the original model)
</p>
</li>
<li> <p><code>trend_linpreds</code> (process model linear predictors on the identity scale;
only available if a <code>trend_formula</code> was supplied in the original model)</p>
</li></ul>
<p> OR can be a character vector
providing the variables to extract</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_use_alias">use_alias</code></td>
<td>
<p>Logical. If more informative names for parameters are available
(i.e. for beta coefficients <code>b</code> or for smoothing parameters <code>rho</code>), replace the uninformative
names with the more informative alias. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_regex">regex</code></td>
<td>
<p>Logical. If not using one of the prespecified options for extractions,
should <code>variable</code> be treated as a (vector of)
regular expressions? Any variable in x matching at least one of the regular expressions
will be selected. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Should warmup draws be included? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, <code>matrix</code>, or <code>array</code> containing the posterior draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim &lt;- sim_mvgam(family = Gamma())
mod1 &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = 'AR1',
             data = sim$data_train,
             family = Gamma(),
             chains = 2,
             samples = 300)
beta_draws_df &lt;- as.data.frame(mod1, variable = 'betas')
head(beta_draws_df)
str(beta_draws_df)

beta_draws_mat &lt;- as.matrix(mod1, variable = 'betas')
head(beta_draws_mat)
str(beta_draws_mat)

shape_pars &lt;- as.matrix(mod1, variable = 'shape', regex = TRUE)
head(shape_pars)
## End(Not run)
</code></pre>

<hr>
<h2 id='mvgam_families'>Supported mvgam families</h2><span id='topic+mvgam_families'></span><span id='topic+tweedie'></span><span id='topic+student_t'></span><span id='topic+betar'></span><span id='topic+nb'></span><span id='topic+nmix'></span>

<h3>Description</h3>

<p>Supported mvgam families
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tweedie(link = "log")

student_t(link = "identity")

betar(...)

nb(...)

nmix(link = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvgam_families_+3A_link">link</code></td>
<td>
<p>a specification for the family link function. At present these cannot
be changed</p>
</td></tr>
<tr><td><code id="mvgam_families_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the <span class="pkg">mgcv</span> version of the associated functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvgam</code> currently supports the following standard observation families:
</p>

<ul>
<li> <p><code><a href="stats.html#topic+gaussian">gaussian</a></code> with identity link, for real-valued data
</p>
</li>
<li> <p><code><a href="stats.html#topic+poisson">poisson</a></code> with log-link, for count data
</p>
</li>
<li> <p><code><a href="stats.html#topic+Gamma">Gamma</a></code> with log-link, for non-negative real-valued data
</p>
</li>
<li> <p><code><a href="stats.html#topic+binomial">binomial</a></code> with logit-link, for count data when the number
of trials is known (and must be supplied)
</p>
</li></ul>

<p>In addition, the following extended families from the <code>mgcv</code> and <code>brms</code> packages are supported:
</p>

<ul>
<li> <p><code><a href="mgcv.html#topic+betar">betar</a></code> with logit-link, for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li> <p><code><a href="mgcv.html#topic+nb">nb</a></code> with log-link, for count data
</p>
</li>
<li> <p><code><a href="brms.html#topic+lognormal">lognormal</a></code> with identity-link, for non-negative real-valued data
</p>
</li>
<li> <p><code><a href="brms.html#topic+bernoulli">bernoulli</a></code> with logit-link, for binary data
</p>
</li>
<li> <p><code><a href="brms.html#topic+beta_binomial">beta_binomial</a></code> with logit-link, as for <code>binomial()</code> but allows
for overdispersion
</p>
</li></ul>

<p>Finally, <code>mvgam</code> supports the three extended families described here:
</p>

<ul>
<li> <p><code>tweedie</code> with log-link, for count data (power parameter <code>p</code> fixed at <code>1.5</code>)
</p>
</li>
<li> <p><code>student_t()</code> (or <code><a href="brms.html#topic+student">student</a></code>) with identity-link, for real-valued data
</p>
</li>
<li> <p><code>nmix</code> for count data with imperfect detection modeled via a
State-Space N-Mixture model. The latent states are Poisson (with log link), capturing the 'true' latent
abundance, while the observation process is Binomial to account for imperfect detection. The
observation <code>formula</code> in these models is used to set up a linear predictor for the detection
probability (with logit link). See the example below for a more detailed worked explanation
of the <code>nmix()</code> family
</p>
</li></ul>

<p>Only <code>poisson()</code>, <code>nb()</code>, and <code>tweedie()</code> are available if
using <code>JAGS</code>. All families, apart from <code>tweedie()</code>, are supported if
using <code>Stan</code>.
</p>
<p>Note that currently it is not possible to change the default link
functions in <code>mvgam</code>, so any call to change these will be silently ignored
</p>


<h3>Value</h3>

<p>Objects of class <code>family</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example showing how to set up N-mixture models
set.seed(999)
# Simulate observations for species 1, which shows a declining trend and 0.7 detection probability
data.frame(site = 1,
          # five replicates per year; six years
          replicate = rep(1:5, 6),
          time = sort(rep(1:6, 5)),
          species = 'sp_1',
          # true abundance declines nonlinearly
          truth = c(rep(28, 5),
                    rep(26, 5),
                    rep(23, 5),
                    rep(16, 5),
                    rep(14, 5),
                    rep(14, 5)),
          # observations are taken with detection prob = 0.7
          obs = c(rbinom(5, 28, 0.7),
                  rbinom(5, 26, 0.7),
                  rbinom(5, 23, 0.7),
                  rbinom(5, 15, 0.7),
                  rbinom(5, 14, 0.7),
                  rbinom(5, 14, 0.7))) %&gt;%
 # add 'series' information, which is an identifier of site, replicate and species
 dplyr::mutate(series = paste0('site_', site,
                               '_', species,
                               '_rep_', replicate),
               time = as.numeric(time),
               # add a 'cap' variable that defines the maximum latent N to
               # marginalize over when estimating latent abundance; in other words
               # how large do we realistically think the true abundance could be?
               cap = 80) %&gt;%
 dplyr::select(- replicate) -&gt; testdat

# Now add another species that has a different temporal trend and a smaller
# detection probability (0.45 for this species)
testdat = testdat %&gt;%
 dplyr::bind_rows(data.frame(site = 1,
                             replicate = rep(1:5, 6),
                             time = sort(rep(1:6, 5)),
                             species = 'sp_2',
                             truth = c(rep(4, 5),
                                       rep(7, 5),
                                       rep(15, 5),
                                       rep(16, 5),
                                       rep(19, 5),
                                       rep(18, 5)),
                             obs = c(rbinom(5, 4, 0.45),
                                     rbinom(5, 7, 0.45),
                                     rbinom(5, 15, 0.45),
                                     rbinom(5, 16, 0.45),
                                     rbinom(5, 19, 0.45),
                                     rbinom(5, 18, 0.45))) %&gt;%
                    dplyr::mutate(series = paste0('site_', site,
                                                  '_', species,
                                                  '_rep_', replicate),
                                  time = as.numeric(time),
                                  cap = 50) %&gt;%
                    dplyr::select(-replicate))

# series identifiers
testdat$species &lt;- factor(testdat$species,
                          levels = unique(testdat$species))
testdat$series &lt;- factor(testdat$series,
                         levels = unique(testdat$series))

# The trend_map to state how replicates are structured
testdat %&gt;%
# each unique combination of site*species is a separate process
dplyr::mutate(trend = as.numeric(factor(paste0(site, species)))) %&gt;%
 dplyr::select(trend, series) %&gt;%
 dplyr::distinct() -&gt; trend_map
trend_map

# Fit a model
mod &lt;- mvgam(
            # the observation formula sets up linear predictors for
            # detection probability on the logit scale
            formula = obs ~ species - 1,

            # the trend_formula sets up the linear predictors for
            # the latent abundance processes on the log scale
            trend_formula = ~ s(time, by = trend, k = 4) + species,

            # the trend_map takes care of the mapping
            trend_map = trend_map,

            # nmix() family and data
            family = nmix(),
            data = testdat,

            # priors can be set in the usual way
            priors = c(prior(std_normal(), class = b),
                       prior(normal(1, 1.5), class = Intercept_trend)),
            chains = 2)

# The usual diagnostics
summary(mod)

# Plotting conditional effects
library(ggplot2); library(marginaleffects)
plot_predictions(mod, condition = 'species',
                 type = 'detection') +
     ylab('Pr(detection)') +
     ylim(c(0, 1)) +
     theme_classic() +
     theme(legend.position = 'none')

# Example showcasing how cbind() is needed for Binomial observations
# Simulate two time series of Binomial trials
trials &lt;- sample(c(20:25), 50, replace = TRUE)
x &lt;- rnorm(50)
detprob1 &lt;- plogis(-0.5 + 0.9*x)
detprob2 &lt;- plogis(-0.1 -0.7*x)
dat &lt;- rbind(data.frame(y = rbinom(n = 50, size = trials, prob = detprob1),
                        time = 1:50,
                        series = 'series1',
                        x = x,
                        ntrials = trials),
             data.frame(y = rbinom(n = 50, size = trials, prob = detprob2),
                        time = 1:50,
                        series = 'series2',
                        x = x,
                        ntrials = trials))
dat &lt;- dplyr::mutate(dat, series = as.factor(series))
dat &lt;- dplyr::arrange(dat, time, series)

# Fit a model using the binomial() family; must specify observations
# and number of trials in the cbind() wrapper
mod &lt;- mvgam(cbind(y, ntrials) ~ series + s(x, by = series),
             family = binomial(),
             data = dat)
summary(mod)

</code></pre>

<hr>
<h2 id='mvgam_forecast-class'><code>mvgam_forecast</code> object description</h2><span id='topic+mvgam_forecast-class'></span>

<h3>Description</h3>

<p>A <code>mvgam_forecast</code> object returned by function <code><a href="#topic+hindcast">hindcast</a></code> or <code><a href="#topic+forecast">forecast</a></code>.
Run <code>methods(class = "mvgam_forecast")</code> to see an overview of available methods.
</p>


<h3>Details</h3>

<p>A <code>mvgam_forecast</code> object contains the following elements:
</p>

<ul>
<li> <p><code>call</code> the original observation model formula
</p>
</li>
<li> <p><code>trend_call</code> If a <code style="white-space: pre;">&#8288;trend_formula was supplied&#8288;</code>, the original trend model formula is
returned. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>family</code> <code>character</code> description of the observation distribution
</p>
</li>
<li> <p><code>family_pars</code> <code>list</code> containing draws of family-specific parameters (i.e.
shape, scale or overdispersion parameters). Only returned if <code>type = link</code>. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>trend_model</code> <code>character</code> description of the latent trend model
</p>
</li>
<li> <p><code>drift</code> Logical specifying whether a drift term was used in the trend model
</p>
</li>
<li> <p><code>use_lv</code> Logical flag indicating whether latent dynamic factors were used in the model
</p>
</li>
<li> <p><code>fit_engine</code> <code>Character</code> describing the fit engine, either as <code>stan</code> or <code>jags</code>
</p>
</li>
<li> <p><code>type</code> The type of predictions included (either <code>link</code>, <code>response</code> or <code>trend</code>)
</p>
</li>
<li> <p><code>series_names</code> Names of the time series, taken from <code>levels(data$series)</code> in the original
model fit
</p>
</li>
<li> <p><code>train_observations</code> A <code>list</code> of training observation vectors of length <code>n_series</code>
</p>
</li>
<li> <p><code>train_times</code> A <code>vector</code> of the unique training times
</p>
</li>
<li> <p><code>test_observations</code> If the <code><a href="#topic+forecast">forecast</a></code> function was used,
a <code>list</code> of test observation vectors of length <code>n_series</code>. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>test_times</code> If the <code><a href="#topic+forecast">forecast</a></code> function was used, a
<code>vector</code> of the unique validation (testing) times. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>hindcasts</code> A <code>list</code> of posterior hindcast distributions of length <code>n_series</code>.
</p>
</li>
<li> <p><code>forecasts</code> If the <code><a href="#topic+forecast">forecast</a></code> function was used,
a <code>list</code> of posterior forecast distributions of length <code>n_series</code>. Otherwise <code>NULL</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><a href="#topic+mvgam">mvgam</a>, <a href="#topic+hindcast.mvgam">hindcast.mvgam</a>, <a href="#topic+forecast.mvgam">forecast.mvgam</a>
</p>

<hr>
<h2 id='mvgam_formulae'>Details of formula specifications in <code>mvgam</code></h2><span id='topic+mvgam_formulae'></span>

<h3>Description</h3>

<p>Details of formula specifications in <code>mvgam</code>
</p>


<h3>Details</h3>

<p><code><a href="#topic+mvgam">mvgam</a></code> will accept an observation model formula and an optional
process model formula (via the argument <code>trend_formula</code>). Neither of these formulae can
be specified as lists, contrary to the accepted behaviour in some <code>mgcv</code> or <code>brms</code> models.
<br />
<br />
Note that it is possible to supply an empty formula where
there are no predictors or intercepts in the observation model (i.e. <code>y ~ 0</code> or <code>y ~ -1</code>).
In this case, an intercept-only observation model will be set up but the intercept coefficient
will be fixed at zero. This can be handy if you wish to fit pure State-Space models where
the variation in the dynamic trend controls the average expectation, and/or where intercepts
are non-identifiable.
<br />
<br />
The formulae supplied to <code><a href="#topic+mvgam">mvgam</a></code> are exactly like those supplied to
<code><a href="stats.html#topic+glm">glm</a></code> except that smooth terms,
<code><a href="mgcv.html#topic+s">s</a></code>,
<code><a href="mgcv.html#topic+te">te</a></code>,
<code><a href="mgcv.html#topic+ti">ti</a></code> and
<code><a href="mgcv.html#topic+t2">t2</a></code>,
time-varying effects using <code><a href="#topic+dynamic">dynamic</a></code>,
monotonically increasing (using <code>s(x, bs = 'moi')</code>)
or decreasing splines (using <code>s(x, bs = 'mod')</code>;
see <code><a href="#topic+smooth.construct.moi.smooth.spec">smooth.construct.moi.smooth.spec</a></code> for
details), as well as
Gaussian Process functions using <code><a href="brms.html#topic+gp">gp</a></code>,
can be added to the right hand side (and <code>.</code> is not supported in <code>mvgam</code> formulae).
<br />
<br />
Further details on specifying different kinds of smooth functions, and how to control their behaviours
by modifying their potential complexities and / or how the penalties behave, can be found in the
extensive documentation for the <code>mgcv</code> package.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvgam">mvgam</a></code>,
<code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>,
<code><a href="mgcv.html#topic+gam.models">gam.models</a></code>,
<code><a href="mgcv.html#topic+jagam">jagam</a></code>,
<code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="mgcv.html#topic+s">s</a></code>,
<code><a href="stats.html#topic+formula">formula</a></code>
</p>

<hr>
<h2 id='mvgam_marginaleffects'>Helper functions for mvgam marginaleffects calculations</h2><span id='topic+mvgam_marginaleffects'></span><span id='topic+get_coef.mvgam'></span><span id='topic+set_coef.mvgam'></span><span id='topic+get_vcov.mvgam'></span><span id='topic+get_predict.mvgam'></span><span id='topic+get_data.mvgam'></span><span id='topic+get_data.mvgam_prefit'></span><span id='topic+find_predictors.mvgam'></span><span id='topic+find_predictors.mvgam_prefit'></span>

<h3>Description</h3>

<p>Helper functions for mvgam marginaleffects calculations
</p>
<p>Functions needed for working with marginaleffects
</p>
<p>Functions needed for getting data / objects with insight
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
get_coef(model, trend_effects = FALSE, ...)

## S3 method for class 'mvgam'
set_coef(model, coefs, trend_effects = FALSE, ...)

## S3 method for class 'mvgam'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'mvgam'
get_predict(model, newdata, type = "response", process_error = FALSE, ...)

## S3 method for class 'mvgam'
get_data(x, source = "environment", verbose = TRUE, ...)

## S3 method for class 'mvgam_prefit'
get_data(x, source = "environment", verbose = TRUE, ...)

## S3 method for class 'mvgam'
find_predictors(
  x,
  effects = c("fixed", "random", "all"),
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion", "instruments",
    "correlation", "smooth_terms"),
  flatten = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'mvgam_prefit'
find_predictors(
  x,
  effects = c("fixed", "random", "all"),
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion", "instruments",
    "correlation", "smooth_terms"),
  flatten = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvgam_marginaleffects_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_trend_effects">trend_effects</code></td>
<td>
<p><code>logical</code>, extract from the process model component
(only applicable if a <code>trend_formula</code> was specified in the model)</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_coefs">coefs</code></td>
<td>
<p>vector of coefficients to insert in the model object</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_newdata">newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate the slopes.
</p>

<ul>
<li><p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li> <p><code><a href="marginaleffects.html#topic+datagrid">datagrid()</a></code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li><p> See the Examples section and the <code><a href="marginaleffects.html#topic+datagrid">datagrid()</a></code> documentation.
</p>
</li></ul>

</li>
<li><p> string:
</p>

<ul>
<li><p> &quot;mean&quot;: Marginal Effects at the Mean. Slopes when each predictor is held at its mean or mode.
</p>
</li>
<li><p> &quot;median&quot;: Marginal Effects at the Median. Slopes when each predictor is held at its median or mode.
</p>
</li>
<li><p> &quot;marginalmeans&quot;: Marginal Effects at Marginal Means. See Details section below.
</p>
</li>
<li><p> &quot;tukey&quot;: Marginal Effects at Tukey's 5 numbers.
</p>
</li>
<li><p> &quot;grid&quot;: Marginal Effects on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_process_error">process_error</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, uncertainty in the latent
process (or trend) model is incorporated in predictions</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_source">source</code></td>
<td>
<p>String, indicating from where data should be recovered. If
<code>source = "environment"</code> (default), data is recovered from the environment
(e.g. if the data is in the workspace). This option is usually the fastest
way of getting data and ensures that the original variables used for model
fitting are returned. Note that always the <em>current</em> data is recovered from
the environment. Hence, if the data was modified <em>after</em> model fitting
(e.g., variables were recoded or rows filtered), the returned data may no
longer equal the model data. If <code>source = "frame"</code> (or <code>"mf"</code>), the data
is taken from the model frame. Any transformed variables are back-transformed,
if possible. This option returns the data even if it is not available in
the environment, however, in certain edge cases back-transforming to the
original data may fail. If <code>source = "environment"</code> fails to recover the
data, it tries to extract the data from the model frame; if
<code>source = "frame"</code> and data cannot be extracted from the model frame, data
will be recovered from the environment. Both ways only returns observations
that have no missing data in the variables used for model fitting.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_effects">effects</code></td>
<td>
<p>Should model data for fixed effects (<code>"fixed"</code>), random
effects (<code>"random"</code>) or both (<code>"all"</code>) be returned? Only applies to mixed
or gee models.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned
as character vector, not as list. Duplicated values are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objects suitable for internal 'marginaleffects' functions to proceed.
See <code><a href="marginaleffects.html#topic+get_coef">marginaleffects::get_coef()</a></code>, <code><a href="marginaleffects.html#topic+set_coef">marginaleffects::set_coef()</a></code>,
<code><a href="marginaleffects.html#topic+get_vcov">marginaleffects::get_vcov()</a></code>, <code><a href="marginaleffects.html#topic+get_predict">marginaleffects::get_predict()</a></code>,
<code><a href="insight.html#topic+get_data">insight::get_data()</a></code> and <code><a href="insight.html#topic+find_predictors">insight::find_predictors()</a></code> for details
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='mvgam_trends'>Supported mvgam trend models</h2><span id='topic+mvgam_trends'></span>

<h3>Description</h3>

<p>Supported mvgam trend models
</p>


<h3>Details</h3>

<p><code>mvgam</code> currently supports the following dynamic trend models:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>RW()</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;AR(p = 1, 2, or 3)&#8288;</code>
</p>
</li>
<li> <p><code>CAR(p = 1)</code>(continuous time autoregressive trends; only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>VAR()</code>(only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>PW()</code> (piecewise linear or logistic trends; only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>GP()</code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p>
</li></ul>

<p>For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>), time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>). However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. For all trend types
apart from <code>GP()</code>, <code>PW()</code>, and <code>CAR()</code>, moving average and/or correlated
process error terms can also be estimated (for example, <code>RW(cor = TRUE)</code> will set up a
multivariate Random Walk if <code>data</code> contains <code style="white-space: pre;">&#8288;&gt;1&#8288;</code> series). Character strings can also be supplied
instead of the various trend functions. The full list of possible models that are
currently supported is:
</p>

<ul>
<li><p> 'RW'
</p>
</li>
<li><p> 'RWMA'
</p>
</li>
<li><p> 'RWcor'
</p>
</li>
<li><p> 'RWMAcor'
</p>
</li>
<li><p> 'AR1'
</p>
</li>
<li><p> 'AR1MA'
</p>
</li>
<li><p> 'AR1cor'
</p>
</li>
<li><p> 'AR1MAcor'
</p>
</li>
<li><p> 'AR2'
</p>
</li>
<li><p> 'AR2MA'
</p>
</li>
<li><p> 'AR2cor'
</p>
</li>
<li><p> 'AR2MAcor'
</p>
</li>
<li><p> 'AR3'
</p>
</li>
<li><p> 'AR3MA'
</p>
</li>
<li><p> 'AR3cor'
</p>
</li>
<li><p> 'AR3MAcor'
</p>
</li>
<li><p> 'CAR1'
</p>
</li>
<li><p> 'VAR'
</p>
</li>
<li><p> 'VARcor'
</p>
</li>
<li><p> 'VAR1' (same as 'VAR')
</p>
</li>
<li><p> 'VAR1cor' (same as 'VARcor')
</p>
</li>
<li><p> 'VARMA'
</p>
</li>
<li><p> 'VARMAcor'
</p>
</li>
<li><p> 'VARMA1,1cor'
</p>
</li>
<li><p> 'PWlinear'
</p>
</li>
<li><p> 'PWlogistic'
</p>
</li>
<li><p> 'GP'
</p>
</li>
<li><p> 'None'
</p>
</li></ul>

<p>Note that only <code>RW</code>, <code>AR1</code>, <code>AR2</code> and <code>AR3</code> are available if
using <code>JAGS</code>. All trend models are supported if using <code>Stan</code>.
Dynamic factor models can be used in which the latent factors evolve as either
<code>RW</code>, <code>AR1-3</code>, <code>VAR</code> or <code>GP</code>. For <code>VAR</code> models
(i.e. <code>VAR</code> and <code>VARcor</code> models), users can either fix the trend error covariances to be <code>0</code>
(using <code>VAR</code>) or estimate them and potentially allow for contemporaneously correlated errors using
<code>VARcor</code>. For all <code>VAR</code> models, stationarity of
the latent process is enforced through the prior using the parameterisation given by
Heaps (2022). Stationarity is not enforced when using <code>AR1</code>, <code>AR2</code> or <code>AR3</code> models,
though this can be changed by the user by specifying lower and upper bounds on autoregressive
parameters using functionality in <a href="#topic+get_mvgam_priors">get_mvgam_priors</a> and the <code>priors</code> argument in
<a href="#topic+mvgam">mvgam</a>. Piecewise trends follow the formulation in the popular <code>prophet</code> package produced
by <code>Facebook</code>, where users can allow for changepoints to control the potential flexibility
of the trend. See Taylor and Letham (2018) for details
</p>


<h3>References</h3>

<p>Sarah E. Heaps (2022) Enforcing stationarity through the prior in Vector Autoregressions.
Journal of Computational and Graphical Statistics. 32:1, 1-10.
</p>
<p>Sean J. Taylor and Benjamin Letham (2018) Forecasting at scale.
The American Statistician 72.1, 37-45.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RW">RW</a></code>, <code><a href="#topic+AR">AR</a></code>, <code><a href="#topic+CAR">CAR</a></code>,
<code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+PW">PW</a></code>, <code><a href="#topic+GP">GP</a></code>
</p>

<hr>
<h2 id='mvgam-class'>Fitted <code>mvgam</code> object description</h2><span id='topic+mvgam-class'></span>

<h3>Description</h3>

<p>A fitted <code>mvgam</code> object returned by function <code><a href="#topic+mvgam">mvgam</a></code>.
Run <code>methods(class = "mvgam")</code> to see an overview of available methods.
</p>


<h3>Details</h3>

<p>A <code>mvgam</code> object contains the following elements:
</p>

<ul>
<li> <p><code>call</code> the original observation model formula
</p>
</li>
<li> <p><code>trend_call</code> If a <code style="white-space: pre;">&#8288;trend_formula was supplied&#8288;</code>, the original trend model formula is
returned. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>family</code> <code>character</code> description of the observation distribution
</p>
</li>
<li> <p><code>trend_model</code> <code>character</code> description of the latent trend model
</p>
</li>
<li> <p><code>trend_map</code> <code>data.frame</code> describing the mapping of trend states to
observations, if supplied in the original model. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>drift</code> Logical specifying whether a drift term was used in the trend model
</p>
</li>
<li> <p><code>priors</code> If the model priors were updated from their defaults, the prior <code>dataframe</code>
will be returned. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>model_output</code> The <code>MCMC</code> object returned by the fitting engine. If the model was fitted
using <code>Stan</code>, this will be an object of class <code>stanfit</code> (see <code><a href="rstan.html#topic+stanfit-class">stanfit-class</a></code> for details).
If <code>JAGS</code> was used as the backend, this will be an object of class <code>runjags</code>
(see <code><a href="runjags.html#topic+runjags-class">runjags-class</a></code> for details)
</p>
</li>
<li> <p><code>model_file</code> The <code>character</code> string model file used to describe the model in either
<code>Stan</code> or <code>JAGS</code> syntax
</p>
</li>
<li> <p><code>model_data</code> If <code>return_model_data</code> was set to <code>TRUE</code> when fitting the model, the <code>list</code> object
containing all data objects needed to condition the model is returned. Each item in the <code>list</code> is described
in detail at the top of the <code>model_file</code>. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>inits</code> If <code>return_model_data</code> was set to <code>TRUE</code> when fitting the model, the initial value
functions used to initialise the MCMC chains will be returned. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>monitor_pars</code> The parameters
that were monitored during MCMC sampling are returned as a <code style="white-space: pre;">&#8288;character vector&#8288;</code>
</p>
</li>
<li> <p><code>sp_names</code> A <code style="white-space: pre;">&#8288;character vector&#8288;</code> specifying the names for each smoothing parameter
</p>
</li>
<li> <p><code>mgcv_model</code> An object of class <code>gam</code> containing the <code>mgcv</code> version of the observation model.
This object is used for generating the linear predictor matrix when making predictions for new data. The
coefficients in this model object will contain the posterior median coefficients from the GAM linear predictor,
but these are only used if generating plots of smooth functions that <code>mvgam</code> currently cannot handle
(such as plots for three-dimensional smooths). This model therefore should not be used for inference.
See <code><a href="mgcv.html#topic+gamObject">gamObject</a></code> for details
</p>
</li>
<li> <p><code>trend_mgcv_model</code> If a <code style="white-space: pre;">&#8288;trend_formula was supplied&#8288;</code>, an object of class <code>gam</code> containing
the <code>mgcv</code> version of the trend model. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>ytimes</code> The <code>matrix</code> object used in model fitting for indexing which series and timepoints
were observed in each row of the supplied data. Used internally by some downstream plotting
and prediction functions
</p>
</li>
<li> <p><code>resids</code> A named <code>list</code> object containing posterior draws of Dunn-Smyth
randomized quantile residuals
</p>
</li>
<li> <p><code>use_lv</code> Logical flag indicating whether latent dynamic factors were used in the model
</p>
</li>
<li> <p><code>n_lv</code> If <code>use_lv == TRUE</code>, the number of latent dynamic factors used in the model
</p>
</li>
<li> <p><code>upper_bounds</code> If bounds were supplied in the original model fit, they will be returned.
Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>obs_data</code> The original data object (either a <code>list</code> or <code>dataframe</code>) supplied in model
fitting.
</p>
</li>
<li> <p><code>test_data</code> If test data were supplied (as argument <code>newdata</code> in the original model), it
will be returned. Othwerise <code>NULL</code>
</p>
</li>
<li> <p><code>fit_engine</code> <code>Character</code> describing the fit engine, either as <code>stan</code> or <code>jags</code>
</p>
</li>
<li> <p><code>backend</code> <code>Character</code> describing the backend used for modelling, either as <code>rstan</code>, <code>cmdstanr</code> or <code>rjags</code>
</p>
</li>
<li> <p><code>algorithm</code> <code>Character</code> describing the algorithm used for finding the posterior,
either as <code>sampling</code>, <code>laplace</code>, <code>pathfinder</code>, <code>meanfield</code> or <code>fullrank</code>
</p>
</li>
<li> <p><code>max_treedepth</code> If the model was fitted using <code>Stan</code>, the value supplied for the maximum
treedepth tuning parameter is returned (see <code><a href="rstan.html#topic+stan">stan</a></code> for details).
Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>adapt_delta</code> If the model was fitted using <code>Stan</code>, the value supplied for the adapt_delta
tuning parameter is returned (see <code><a href="rstan.html#topic+stan">stan</a></code> for details).
Otherwise <code>NULL</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><a href="#topic+mvgam">mvgam</a>
</p>

<hr>
<h2 id='pairs.mvgam'>Create a matrix of output plots from a <code>mvgam</code> object</h2><span id='topic+pairs.mvgam'></span>

<h3>Description</h3>

<p>A <code><a href="graphics.html#topic+pairs">pairs</a></code>
method that is customized for MCMC output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
pairs(x, variable = NULL, regex = FALSE, use_alias = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.mvgam_+3A_x">x</code></td>
<td>
<p>An object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="pairs.mvgam_+3A_variable">variable</code></td>
<td>
<p>Names of the variables (parameters) to plot, as given by a
character vector or a regular expression (if <code>regex = TRUE</code>). By
default, a hopefully not too large selection of variables is plotted.</p>
</td></tr>
<tr><td><code id="pairs.mvgam_+3A_regex">regex</code></td>
<td>
<p>Logical; Indicates whether <code>variable</code> should
be treated as regular expressions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairs.mvgam_+3A_use_alias">use_alias</code></td>
<td>
<p>Logical. If more informative names for parameters are available
(i.e. for beta coefficients <code>b</code> or for smoothing parameters <code>rho</code>), replace the uninformative
names with the more informative alias. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="pairs.mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed description see
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>.
</p>


<h3>Value</h3>

<p>Plottable objects whose classes depend on the arguments supplied.
See <code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2)
pairs(mod)
pairs(mod, variable = c('ar1', 'sigma'), regex = TRUE)


</code></pre>

<hr>
<h2 id='plot_mvgam_factors'>Latent factor summaries for a fitted mvgam object</h2><span id='topic+plot_mvgam_factors'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> object and returns plots and summary statistics for
the latent dynamic factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_factors(object, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_factors_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_factors_+3A_plot">plot</code></td>
<td>
<p><code>logical</code> specifying whether factors should be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model in <code>object</code> was estimated using dynamic factors, it is possible that not all factors
contributed to the estimated trends. This is due to the regularisation penalty that acts independently on each
factor's Gaussian precision, which will squeeze un-needed factors to a white noise process (effectively dropping
that factor from the model). In this function, each factor is tested against a null hypothesis of white noise by
calculating the sum of the factor's 2nd derivatives. A factor that has a larger contribution will have a larger
sum due to the weaker penalty on the factor's precision. If
<code>plot == TRUE</code>, the factors are also plotted.
</p>


<h3>Value</h3>

<p>A <code>dataframe</code> of factor contributions and,
optionally, a series of base <code>R</code> plots
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam()
mod &lt;- mvgam(y ~ s(season, bs = 'cc',
                  k = 6),
            trend_model = AR(),
            use_lv = TRUE,
            n_lv = 2,
            data = simdat$data_train,
            chains = 2)
plot_mvgam_factors(mod)

</code></pre>

<hr>
<h2 id='plot_mvgam_forecasts'>Plot mvgam posterior predictions for a specified series</h2><span id='topic+plot_mvgam_forecasts'></span><span id='topic+plot_mvgam_fc'></span><span id='topic+plot.mvgam_forecast'></span>

<h3>Description</h3>

<p>Plot mvgam posterior predictions for a specified series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_fc(
  object,
  series = 1,
  newdata,
  data_test,
  realisations = FALSE,
  n_realisations = 15,
  hide_xlabels = FALSE,
  xlab,
  ylab,
  ylim,
  n_cores = 1,
  return_forecasts = FALSE,
  return_score = FALSE,
  ...
)

## S3 method for class 'mvgam_forecast'
plot(
  x,
  series = 1,
  realisations = FALSE,
  n_realisations = 15,
  hide_xlabels = FALSE,
  xlab,
  ylab,
  ylim,
  return_score = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_forecasts_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
in addition to any other variables included in the linear predictor of the original <code>formula</code>. If included, the
covariate information in <code>newdata</code> will be used to generate forecasts from the fitted model equations. If
this same <code>newdata</code> was originally included in the call to <code>mvgam</code>, then forecasts have already been
produced by the generative model and these will simply be extracted and plotted. However if no <code>newdata</code> was
supplied to the original model call, an assumption is made that the <code>newdata</code> supplied here comes sequentially
after the data supplied as <code>data</code> in the original model (i.e. we assume there is no time gap between the last
observation of series 1 in <code>data</code> and the first observation for series 1 in <code>newdata</code>). If
<code>newdata</code> contains observations in column <code>y</code>, these observations will be used to compute a Discrete Rank
Probability Score for the forecast distribution</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_realisations">realisations</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, forecast realisations are shown as a spaghetti plot,
making it easier to visualise the diversity of possible forecasts. If <code>FALSE</code>, the default,
empirical quantiles of the forecast distribution are shown</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_n_realisations">n_realisations</code></td>
<td>
<p><code>integer</code> specifying the number of posterior realisations to plot, if
<code>realisations = TRUE</code>. Ignored otherwise</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_hide_xlabels">hide_xlabels</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, no xlabels are printed to allow the user to add custom labels using
<code>axis</code> from base <code>R</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_ylim">ylim</code></td>
<td>
<p>Optional <code>vector</code> of y-axis limits (min, max)</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_n_cores">n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for generating forecasts in parallel</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_return_forecasts">return_forecasts</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the function will plot the forecast
as well as returning the forecast object (as a <code>matrix</code> of dimension <code>n_samples</code> x <code>horizon</code>)</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_return_score">return_score</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and out of sample test data is provided as
<code>newdata</code>, a probabilistic score will be calculated and returned. The score used will depend on the
observation family from the fitted model. Discrete families (<code>poisson</code>, <code>negative binomial</code>, <code>tweedie</code>)
use the Discrete Rank Probability Score. Other families use the Continuous Rank Probability Score. The value
returned is the <code>sum</code> of all scores within the out of sample forecast horizon</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_...">...</code></td>
<td>
<p>further <code><a href="graphics.html#topic+par">par</a></code> graphical parameters.</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvgam_forecast</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_mvgam_fc</code> draws posterior predictions from an object of class <code>mvgam</code> and calculates posterior
empirical quantiles.
</p>
<p><code>plot.mvgam_forecast</code> takes an object of class <code>mvgam_forecast</code>, in which forecasts have already
been computed, and plots the resulting forecast distribution.
</p>
<p>If <code>realisations = FALSE</code>, these posterior quantiles are plotted along
with the true observed data that was used to train the model. Otherwise, a spaghetti plot is returned
to show possible forecast paths.
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot and an optional <code>list</code> containing the forecast distribution
and the out of sample probabilistic forecast score
</p>

<hr>
<h2 id='plot_mvgam_pterms'>Plot mvgam parametric term partial effects</h2><span id='topic+plot_mvgam_pterms'></span>

<h3>Description</h3>

<p>This function plots posterior empirical quantiles for partial effects of parametric terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_pterms(object, trend_effects = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_pterms_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_pterms_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical. If <code>TRUE</code> and a <code>trend_formula</code> was used in model
fitting, terms from the trend (i.e. process) model will be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior empirical quantiles of each parametric term's partial effect estimates
(on the link scale) are calculated and visualised as ribbon plots. These effects can
be interpreted as the partial effect that a parametric term contributes when all other
terms in the model have been set to <code>0</code>
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>

<hr>
<h2 id='plot_mvgam_randomeffects'>Plot mvgam random effect terms</h2><span id='topic+plot_mvgam_randomeffects'></span>

<h3>Description</h3>

<p>This function plots posterior empirical quantiles for random effect smooths (bs = re)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_randomeffects(object, trend_effects = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_randomeffects_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_randomeffects_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical. If <code>TRUE</code> and a <code>trend_formula</code> was used in model
fitting, terms from the trend (i.e. process) model will be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior empirical quantiles of random effect coefficient estimates
(on the link scale) are calculated and visualised as ribbon plots.
Labels for coefficients are taken from the levels of the original factor variable
that was used to specify the smooth in the model's formula
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>

<hr>
<h2 id='plot_mvgam_resids'>Residual diagnostics for a fitted mvgam object</h2><span id='topic+plot_mvgam_resids'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> object and returns various residual diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_resids(object, series = 1, newdata, data_test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_resids_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_resids_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_resids_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series', 'y', and 'time'
in addition to any other variables included in the linear predictor of <code>formula</code>. If included, the
covariate information in <code>newdata</code> will be used to generate forecasts from the fitted model equations. If
this same <code>newdata</code> was originally included in the call to <code>mvgam</code>, then forecasts have already been
produced by the generative model and these will simply be extracted and used to calculate residuals.
However if no <code>newdata</code> was supplied to the original model call, an assumption is made that
the <code>newdata</code> supplied here comes sequentially after the data supplied as <code>data</code> in
the original model (i.e. we assume there is no time gap between the last
observation of series 1 in <code>data_train</code> and the first observation for series 1 in <code>newdata</code>).</p>
</td></tr>
<tr><td><code id="plot_mvgam_resids_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A total of four base <code>R</code> plots are generated to examine Dunn-Smyth residuals for
the specified series. Plots include a residuals vs fitted values plot,
a Q-Q plot, and two plots to check for any remaining temporal autocorrelation in the residuals.
Note, all plots use posterior medians of fitted values / residuals, so uncertainty is not represented.
</p>


<h3>Value</h3>

<p>A series of base <code>R</code> plots
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='plot_mvgam_series'>Plot observed time series used for mvgam modelling</h2><span id='topic+plot_mvgam_series'></span>

<h3>Description</h3>

<p>This function takes either a fitted <code>mvgam</code> object or a <code>data_train</code> object
and produces plots of observed time series, ACF, CDF and histograms for exploratory data analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_series(
  object,
  data,
  data_train,
  newdata,
  data_test,
  y = "y",
  lines = TRUE,
  series = 1,
  n_bins,
  log_scale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_series_+3A_object">object</code></td>
<td>
<p>Optional <code>list</code> object returned from <code>mvgam</code>. Either <code>object</code> or <code>data_train</code>
must be supplied.</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_data">data</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of training data containing at least 'series' and 'time'.
Use this argument if training data have been gathered in the correct format for <code>mvgam</code> modelling
but no model has yet been fitted.</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_data_train">data_train</code></td>
<td>
<p>Deprecated. Still works in place of <code>data</code> but users are recommended to use
<code>data</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
for the forecast horizon, in addition to any other variables included in the linear predictor of <code>formula</code>. If
included, the observed values in the test data are compared to the model's forecast distribution for exploring
biases in model predictions.</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_y">y</code></td>
<td>
<p>Character. What is the name of the outcome variable in the supplied data? Defaults to
<code>'y'</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_lines">lines</code></td>
<td>
<p>Logical. If <code>TRUE</code>, line plots are used for visualising time series. If
<code>FALSE</code>, points are used.</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_series">series</code></td>
<td>
<p>Either a <code>integer</code> specifying which series in the set is to be plotted or
the string 'all', which plots all series available in the supplied data</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_n_bins">n_bins</code></td>
<td>
<p><code>integer</code> specifying the number of bins to use for binning observed values when plotting
a the histogram. Default is to use the number of bins returned by a call to <code>hist</code> in base <code>R</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_log_scale">log_scale</code></td>
<td>
<p><code>logical</code>. If <code>series == 'all'</code>, this flag is used to control whether
the time series plot is shown on the log scale (using <code>log(Y + 1)</code>). This can be useful when
visualising many series that may have different observed ranges. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of base <code>R</code> graphics plots. If <code>series</code> is an integer, the plots will
show observed time series, autocorrelation and
cumulative distribution functions, and a histogram for the series. If <code>series == 'all'</code>,
a set of observed time series plots is returned in which all series are shown on each plot but
only a single focal series is highlighted, with all remaining series shown as faint gray lines.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate and plot series with observations bounded at 0 and 1 (Beta responses)
sim_data &lt;- sim_mvgam(family = betar(),
                     trend_model = RW(), prop_trend = 0.6)
plot_mvgam_series(data = sim_data$data_train, series = 'all')
plot_mvgam_series(data = sim_data$data_train,
                 newdata = sim_data$data_test, series = 1)

# Now simulate series with overdispersed discrete observations
sim_data &lt;- sim_mvgam(family = nb(), trend_model = RW(),
                     prop_trend = 0.6, phi = 10)
plot_mvgam_series(data = sim_data$data_train, series = 'all')
</code></pre>

<hr>
<h2 id='plot_mvgam_smooth'>Plot mvgam smooth terms</h2><span id='topic+plot_mvgam_smooth'></span>

<h3>Description</h3>

<p>This function plots posterior empirical quantiles for a series-specific smooth term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_smooth(
  object,
  trend_effects = FALSE,
  series = 1,
  smooth,
  residuals = FALSE,
  n_resid_bins = 25,
  realisations = FALSE,
  n_realisations = 15,
  derivatives = FALSE,
  newdata
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_smooth_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical. If <code>TRUE</code> and a <code>trend_formula</code> was used in model
fitting, terms from the trend (i.e. process) model will be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_smooth">smooth</code></td>
<td>
<p>either a <code>character</code> or <code>integer</code> specifying which smooth term to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_residuals">residuals</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> then posterior quantiles of partial residuals are added
to plots of 1-D smooths as a series of ribbon rectangles.
Partial residuals for a smooth term are the median Dunn-Smyth residuals that would be obtained by dropping the term
concerned from the model, while leaving all other estimates fixed (i.e. the
estimates for the term plus the original median Dunn-Smyth residuals). Note that because <code>mvgam</code> works with
Dunn-Smyth residuals and not working residuals, which are used by <code>mgcv</code>, the magnitudes of
partial residuals will be different to what you would expect from <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>. Interpretation
is similar though, as these partial residuals should be evenly scattered
around the smooth function if the function is well estimated</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_n_resid_bins">n_resid_bins</code></td>
<td>
<p><code>integer</code> specifying the number of bins group the covariate into when plotting partial residuals.
Setting this argument too high can make for messy plots that are difficult to interpret, while setting it too
low will likely mask some potentially useful patterns in the partial residuals. Default is <code>25</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_realisations">realisations</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, posterior realisations are shown as a spaghetti plot,
making it easier to visualise the diversity of possible functions. If <code>FALSE</code>, the default,
empirical quantiles of the posterior distribution are shown</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_n_realisations">n_realisations</code></td>
<td>
<p><code>integer</code> specifying the number of posterior realisations to plot, if
<code>realisations = TRUE</code>. Ignored otherwise</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_derivatives">derivatives</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, an additional plot will be returned to show the
estimated 1st derivative for the specified smooth (Note, this only works for univariate smooths)</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> for predicting the smooth, containing at least 'series'
in addition to any other variables included in the linear predictor of the original model's <code>formula</code>.
Note that this currently is only supported for plotting univariate smooths</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Smooth functions are shown as empirical quantiles (or spaghetti plots) of posterior partial expectations
across a sequence of 500 values between the variable's <code>min</code> and <code>max</code>,
while zeroing out effects of all other variables. At present, only univariate and bivariate smooth plots
are allowed, though note that bivariate smooths rely on default behaviour from
<code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>. For more nuanced visualisation, supply
<code>newdata</code> just as you would when predicting from a <code><a href="mgcv.html#topic+gam">gam</a></code> model
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>
</p>

<hr>
<h2 id='plot_mvgam_trend'>Plot mvgam latent trend for a specified series</h2><span id='topic+plot_mvgam_trend'></span>

<h3>Description</h3>

<p>Plot mvgam latent trend for a specified series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_trend(
  object,
  series = 1,
  newdata,
  data_test,
  realisations = FALSE,
  n_realisations = 15,
  n_cores = 1,
  derivatives = FALSE,
  hide_xlabels = FALSE,
  xlab,
  ylab,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_trend_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
in addition to any other variables included in the linear predictor of the original <code>formula</code>.</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_realisations">realisations</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, posterior trend realisations are shown as a spaghetti plot,
making it easier to visualise the diversity of possible trend paths. If <code>FALSE</code>, the default,
empirical quantiles of the posterior distribution are shown</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_n_realisations">n_realisations</code></td>
<td>
<p><code>integer</code> specifying the number of posterior realisations to plot, if
<code>realisations = TRUE</code>. Ignored otherwise</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_n_cores">n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for generating trend forecasts in parallel</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_derivatives">derivatives</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, an additional plot will be returned to show the
estimated 1st derivative for the estimated trend</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_hide_xlabels">hide_xlabels</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, no xlabels are printed to allow the user to add custom labels using
<code>axis</code> from base <code>R</code>. Ignored if <code>derivatives = TRUE</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_...">...</code></td>
<td>
<p>further <code><a href="graphics.html#topic+par">par</a></code> graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 3, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2)

# Plot estimated trends for some series
plot_mvgam_trend(mod)
plot_mvgam_trend(mod, series = 2)

# Extrapolate trends forward in time and plot on response scale
plot_mvgam_trend(mod, newdata = simdat$data_test)
plot_mvgam_trend(mod, newdata = simdat$data_test, series = 2)

# But it is recommended to compute extrapolations for all series
# first and then plot
trend_fc &lt;- forecast(mod, newdata = simdat$data_test)
plot(trend_fc, series = 1)
plot(trend_fc, series = 2)

</code></pre>

<hr>
<h2 id='plot_mvgam_uncertainty'>Plot mvgam forecast uncertainty contributions for a specified series</h2><span id='topic+plot_mvgam_uncertainty'></span>

<h3>Description</h3>

<p>Plot mvgam forecast uncertainty contributions for a specified series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_uncertainty(
  object,
  series = 1,
  newdata,
  data_test,
  legend_position = "topleft",
  hide_xlabels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mvgam_uncertainty_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_newdata">newdata</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing at least 'series' and 'time' for the forecast horizon, in
addition to any other variables included in the linear predictor of <code>formula</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_legend_position">legend_position</code></td>
<td>
<p>The location may also be specified by setting x to a single keyword from the
list: &quot;none&quot;, &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;.
This places the legend on the inside of the plot frame at the given location (if it is not &quot;none&quot;).</p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_hide_xlabels">hide_xlabels</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, no xlabels are printed to allow the user to add custom labels using
<code>axis</code> from base <code>R</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>

<hr>
<h2 id='plot.mvgam'>Default mvgam plots</h2><span id='topic+plot.mvgam'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> object and produces plots of smooth functions, forecasts, trends and
uncertainty components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
plot(
  x,
  type = "residuals",
  series = 1,
  residuals = FALSE,
  newdata,
  data_test,
  trend_effects = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mvgam_+3A_x">x</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_type">type</code></td>
<td>
<p><code>character</code> specifying which type of plot to return. Options are:
series,
residuals,
smooths,
re (random effect smooths),
pterms (parametric effects),
forecast,
trend,
uncertainty,
factors</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted. This is ignored
if <code>type == 're'</code></p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_residuals">residuals</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and <code>type = 'smooths'</code>, posterior quantiles of partial residuals are added
to plots of 1-D smooths as a series of ribbon rectangles.
Partial residuals for a smooth term are the median Dunn-Smyth residuals that would be obtained by dropping the term
concerned from the model, while leaving all other estimates fixed (i.e. the
estimates for the term plus the original median Dunn-Smyth residuals). Note that because <code>mvgam</code> works with
Dunn-Smyth residuals and not working residuals, which are used by <code>mgcv</code>, the magnitudes of
partial residuals will be different to what you would expect from <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>. Interpretation
is similar though, as these partial residuals should be evenly scattered
around the smooth function if the function is well estimated</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
in addition to any other variables included in the linear predictor of the original <code>formula</code>.
This argument is optional when plotting out of sample forecast period observations
(when <code>type = forecast</code>) and required when plotting
uncertainty components (<code>type = uncertainty</code>).</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical. If <code>TRUE</code> and a <code>trend_formula</code> was used in model
fitting, terms from the trend (i.e. process) model will be plotted</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_...">...</code></td>
<td>
<p>Additional arguments for each individual plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plots are useful for getting an overview of the fitted model and its estimated
random effects or smooth functions,
but the individual plotting functions and the functions from the marginaleffects package
offer far more more customisation.
</p>


<h3>Value</h3>

<p>A base R plot or set of plots
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_mvgam_resids">plot_mvgam_resids</a></code>, <code><a href="#topic+plot_mvgam_smooth">plot_mvgam_smooth</a></code>, <code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code>,
<code><a href="#topic+plot_mvgam_trend">plot_mvgam_trend</a></code>, <code><a href="#topic+plot_mvgam_uncertainty">plot_mvgam_uncertainty</a></code>, <code><a href="#topic+plot_mvgam_factors">plot_mvgam_factors</a></code>,
<code><a href="#topic+plot_mvgam_randomeffects">plot_mvgam_randomeffects</a></code>, <code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code>, <code><a href="marginaleffects.html#topic+plot_slopes">plot_slopes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some time series
dat &lt;- sim_mvgam(T = 80, n_series = 3)

# Fit a basic model
mod &lt;- mvgam(y ~ s(season, bs = 'cc') + s(series, bs = 're'),
            data = dat$data_train,
            trend_model = RW(),
            chains = 2)

# Plot predictions and residuals for each series
plot(mod, type = 'forecast', series = 1)
plot(mod, type = 'forecast', series = 2)
plot(mod, type = 'forecast', series = 3)
plot(mod, type = 'residuals', series = 1)
plot(mod, type = 'residuals', series = 2)
plot(mod, type = 'residuals', series = 3)

# Plot model effects
plot(mod, type = 'smooths')
plot(mod, type = 're')

# More flexible plots with 'marginaleffects' utilities
library(marginaleffects)
plot_predictions(mod, condition = 'season', type = 'link')
plot_predictions(mod,
                condition = c('season', 'series', 'series'),
                type = 'link')
plot_predictions(mod, condition = 'series', type = 'link')

# When using a State-Space model with predictors on the process
# model, set trend_effects = TRUE to visualise process effects
mod &lt;- mvgam(y ~ -1,
            trend_formula = ~ s(season, bs = 'cc'),
            data = dat$data_train,
            trend_model = RW(),
            chains = 2)
plot(mod, type = 'smooths', trend_effects = TRUE)

# But marginaleffects functions work without any modification
plot_predictions(mod, condition = 'season', type = 'link')


</code></pre>

<hr>
<h2 id='plot.mvgam_lfo'>Plot Pareto-k and ELPD values from a leave-future-out object</h2><span id='topic+plot.mvgam_lfo'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>mvgam_lfo</code> and creates several
informative diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_lfo'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mvgam_lfo_+3A_x">x</code></td>
<td>
<p>An object of class <code>mvgam_lfo</code></p>
</td></tr>
<tr><td><code id="plot.mvgam_lfo_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base <code>R</code> plot of Pareto-k and ELPD values over the
evaluation timepoints. For the Pareto-k plot, a dashed red line indicates the
specified threshold chosen for triggering model refits. For the ELPD plot,
a dashed red line indicates the bottom 10% quantile of ELPD values. Points below
this threshold may represent outliers that were more difficult to forecast
</p>

<hr>
<h2 id='portal_data'>Portal Project rodent capture survey data</h2><span id='topic+portal_data'></span>

<h3>Description</h3>

<p>A dataset containing timeseries of total captures (across all control plots) for select rodent species from the Portal Project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portal_data
</code></pre>


<h3>Format</h3>

<p>A dataframe containing the following fields:
</p>

<dl>
<dt>moon</dt><dd><p>time of sampling in lunar cycles</p>
</dd>
<dt>DM</dt><dd><p>Total captures of species Dipodomys merriami</p>
</dd>
<dt>DO</dt><dd><p>Total captures of species Dipodomys ordii</p>
</dd>
<dt>PP</dt><dd><p>Total captures of species Chaetodipus penicillatus</p>
</dd>
<dt>OT</dt><dd><p>Total captures of species Onychomys torridus</p>
</dd>
<dt>year</dt><dd><p>Sampling year</p>
</dd>
<dt>month</dt><dd><p>Sampling month</p>
</dd>
<dt>mintemp</dt><dd><p>Monthly mean minimum temperature</p>
</dd>
<dt>precipitation</dt><dd><p>Monthly mean precipitation</p>
</dd>
<dt>ndvi</dt><dd><p>Monthly mean Normalised Difference Vegetation Index</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/weecology/PortalData/blob/main/SiteandMethods/Methods.md">https://github.com/weecology/PortalData/blob/main/SiteandMethods/Methods.md</a>
</p>

<hr>
<h2 id='posterior_epred.mvgam'>Draws from the Expected Value of the Posterior Predictive Distribution</h2><span id='topic+posterior_epred.mvgam'></span><span id='topic+posterior_epred'></span>

<h3>Description</h3>

<p>Compute posterior draws of the expected value of the posterior predictive
distribution (i.e. the conditional expectation).
Can be performed for the data used to fit the model (posterior
predictive checks) or for new data. By definition, these predictions have
smaller variance than the posterior predictions performed by the
<code><a href="#topic+posterior_predict.mvgam">posterior_predict.mvgam</a></code> method. This is because only the
uncertainty in the expected value of the posterior predictive distribution is
incorporated in the draws computed by <code>posterior_epred</code> while the
residual error is ignored there. However, the estimated means of both methods
averaged across draws should be very similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
posterior_epred(
  object,
  newdata,
  data_test,
  ndraws = NULL,
  process_error = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_epred.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the
variables included in the linear predictor of <code>formula</code>. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive <code>integer</code> indicating how many posterior draws should be used.
If <code>NULL</code> (the default) all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>newdata</code> is supplied,
expected uncertainty in the process model is accounted for by using draws
from any latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent
trend component is ignored when calculating predictions. If no <code>newdata</code> is
supplied, draws from the fitted model's posterior predictive distribution will be used
(which will always include uncertainty in any latent trend components)</p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for all types of predictions for models that did not include
a <code>trend_formula</code>, uncertainty in the dynamic trend
component can be ignored by setting <code>process_error = FALSE</code>. However,
if a <code>trend_formula</code> was supplied in the model, predictions for this component cannot be
ignored. If <code>process_error = TRUE</code>, trend predictions will ignore autocorrelation
coefficients or GP length scale coefficients, ultimately assuming the process is stationary.
This method is similar to the types of posterior predictions returned from <code>brms</code> models
when using autocorrelated error predictions for newdata.
This function is therefore more suited to posterior simulation from the GAM components
of a <code>mvgam</code> model, while the forecasting functions
<code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code> and <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code> are better suited to generate h-step ahead forecasts
that respect the temporal dynamics of estimated latent trends.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> of dimension <code>n_samples x new_obs</code>,
where <code>n_samples</code> is the number of posterior samples from the fitted object
and <code>n_obs</code> is the number of observations in <code>newdata</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code> <code><a href="#topic+posterior_linpred.mvgam">posterior_linpred.mvgam</a></code> <code><a href="#topic+posterior_predict.mvgam">posterior_predict.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train)

# Compute posterior expectations
expectations &lt;- posterior_epred(mod)
str(expectations)

</code></pre>

<hr>
<h2 id='posterior_linpred.mvgam'>Posterior Draws of the Linear Predictor</h2><span id='topic+posterior_linpred.mvgam'></span>

<h3>Description</h3>

<p>Compute posterior draws of the linear predictor, that is draws before
applying any link functions or other transformations. Can be performed for
the data used to fit the model (posterior predictive checks) or for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
posterior_linpred(
  object,
  transform = FALSE,
  newdata,
  ndraws = NULL,
  data_test,
  process_error = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_linpred.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_transform">transform</code></td>
<td>
<p>Logical; if <code>FALSE</code>
(the default), draws of the linear predictor are returned.
If <code>TRUE</code>, draws of the transformed linear predictor,
i.e. the conditional expectation, are returned.</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the
variables included in the linear predictor of <code>formula</code>. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive <code>integer</code> indicating how many posterior draws should be used.
If <code>NULL</code> (the default) all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>newdata</code> is supplied,
expected uncertainty in the process model is accounted for by using draws
from any latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent
trend component is ignored when calculating predictions. If no <code>newdata</code> is
supplied, draws from the fitted model's posterior predictive distribution will be used
(which will always include uncertainty in any latent trend components)</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for all types of predictions for models that did not include
a <code>trend_formula</code>, uncertainty in the dynamic trend
component can be ignored by setting <code>process_error = FALSE</code>. However,
if a <code>trend_formula</code> was supplied in the model, predictions for this component cannot be
ignored. If <code>process_error = TRUE</code>, trend predictions will ignore autocorrelation
coefficients or GP length scale coefficients, ultimately assuming the process is stationary.
This method is similar to the types of posterior predictions returned from <code>brms</code> models
when using autocorrelated error predictions for newdata.
This function is therefore more suited to posterior simulation from the GAM components
of a <code>mvgam</code> model, while the forecasting functions
<code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code> and <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code> are better suited to generate h-step ahead forecasts
that respect the temporal dynamics of estimated latent trends.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> of dimension <code>n_samples x new_obs</code>,
where <code>n_samples</code> is the number of posterior samples from the fitted object
and <code>n_obs</code> is the number of observations in <code>newdata</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> <code><a href="#topic+posterior_predict.mvgam">posterior_predict.mvgam</a></code>
</p>
<p><code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code> <code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> <code><a href="#topic+posterior_predict.mvgam">posterior_predict.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2)

# Extract linear predictor values
linpreds &lt;- posterior_linpred(mod)
str(linpreds)

</code></pre>

<hr>
<h2 id='posterior_predict.mvgam'>Draws from the Posterior Predictive Distribution</h2><span id='topic+posterior_predict.mvgam'></span>

<h3>Description</h3>

<p>Compute posterior draws of the posterior predictive distribution. Can be
performed for the data used to fit the model (posterior predictive checks) or
for new data. By definition, these draws have higher variance than draws
of the expected value of the posterior predictive distribution computed by
<code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code>. This is because the residual error
is incorporated in <code>posterior_predict</code>. However, the estimated means of
both methods averaged across draws should be very similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
posterior_predict(
  object,
  newdata,
  data_test,
  ndraws = NULL,
  process_error = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_predict.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the
variables included in the linear predictor of <code>formula</code>. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive <code>integer</code> indicating how many posterior draws should be used.
If <code>NULL</code> (the default) all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>newdata</code> is supplied,
expected uncertainty in the process model is accounted for by using draws
from any latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent
trend component is ignored when calculating predictions. If no <code>newdata</code> is
supplied, draws from the fitted model's posterior predictive distribution will be used
(which will always include uncertainty in any latent trend components)</p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for all types of predictions for models that did not include
a <code>trend_formula</code>, uncertainty in the dynamic trend
component can be ignored by setting <code>process_error = FALSE</code>. However,
if a <code>trend_formula</code> was supplied in the model, predictions for this component cannot be
ignored. If <code>process_error = TRUE</code>, trend predictions will ignore autocorrelation
coefficients or GP length scale coefficients, ultimately assuming the process is stationary.
This method is similar to the types of posterior predictions returned from <code>brms</code> models
when using autocorrelated error predictions for newdata.
This function is therefore more suited to posterior simulation from the GAM components
of a <code>mvgam</code> model, while the forecasting functions
<code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code> and <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code> are better suited to generate h-step ahead forecasts
that respect the temporal dynamics of estimated latent trends.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> of dimension <code>n_samples x new_obs</code>,
where <code>n_samples</code> is the number of posterior samples from the fitted object
and <code>n_obs</code> is the number of observations in <code>newdata</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code> <code><a href="#topic+posterior_linpred.mvgam">posterior_linpred.mvgam</a></code> <code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
            trend_model = 'AR1',
            data = simdat$data_train)

# Compute posterior predictions
predictions &lt;- posterior_predict(mod)
str(predictions)

## End(Not run)
</code></pre>

<hr>
<h2 id='pp_check.mvgam'>Posterior Predictive Checks for <code>mvgam</code> Objects</h2><span id='topic+pp_check.mvgam'></span><span id='topic+pp_check'></span>

<h3>Description</h3>

<p>Perform posterior predictive checks with the help
of the <span class="pkg">bayesplot</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
pp_check(
  object,
  type,
  ndraws = NULL,
  prefix = c("ppc", "ppd"),
  group = NULL,
  x = NULL,
  newdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_check.mvgam_+3A_object">object</code></td>
<td>
<p>An object of class <code>mvgam</code>.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_type">type</code></td>
<td>
<p>Type of the ppc plot as given by a character string.
See <code><a href="bayesplot.html#topic+PPC-overview">PPC</a></code> for an overview
of currently supported types. You may also use an invalid
type (e.g. <code>type = "xyz"</code>) to get a list of supported
types in the resulting error message.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many
posterior draws should be used.
If <code>NULL</code> all draws are used. If not specified,
the number of posterior draws is chosen automatically.
Ignored if <code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_prefix">prefix</code></td>
<td>
<p>The prefix of the <span class="pkg">bayesplot</span> function to be applied. 
Either '&quot;ppc&quot;' (posterior predictive check; the default)
or '&quot;ppd&quot;' (posterior predictive distribution), the latter being the same
as the former except that the observed data is not shown for '&quot;ppd&quot;'.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_group">group</code></td>
<td>
<p>Optional name of a factor variable in the model
by which to stratify the ppc plot. This argument is required for
ppc <code>*_grouped</code> types and ignored otherwise.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_x">x</code></td>
<td>
<p>Optional name of a variable in the model.
Only used for ppc types having an <code>x</code> argument
and ignored otherwise.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the
variables included in the linear predictor of <code>formula</code>. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>
as well as to the PPC function specified in <code>type</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed explanation of each of the ppc functions,
see the <code><a href="bayesplot.html#topic+PPC-overview">PPC</a></code>
documentation of the <span class="pkg"><a href="bayesplot.html#topic+bayesplot-package">bayesplot</a></span>
package.
</p>


<h3>Value</h3>

<p>A ggplot object that can be further
customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppc">ppc</a></code> <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simdat &lt;- sim_mvgam(seasonality = 'hierarchical')
mod &lt;- mvgam(y ~ series +
              s(season, bs = 'cc', k = 6) +
              s(season, series, bs = 'fs', k = 4),
            data = simdat$data_train,
            burnin = 300,
            samples = 300)

# Use pp_check(mod, type = "xyz") for a list of available plot types

# Default is a density overlay for all observations
pp_check(mod)

# Rootograms particularly useful for count data
pp_check(mod, type = "rootogram")

# Grouping plots by series is useful
pp_check(mod, type = "bars_grouped",
        group = "series", ndraws = 50)
pp_check(mod, type = "ecdf_overlay_grouped",
        group = "series", ndraws = 50)
pp_check(mod, type = "stat_freqpoly_grouped",
        group = "series", ndraws = 50)

# Custom functions accepted
prop_zero &lt;- function(x) mean(x == 0)
pp_check(mod, type = "stat", stat = "prop_zero")
pp_check(mod, type = "stat_grouped",
        stat = "prop_zero",
        group = "series")

# Some functions accept covariates to set the x-axes
pp_check(mod, x = "season",
        type = "ribbon_grouped",
        prob = 0.5,
        prob_outer = 0.8,
        group = "series")

# Many plots can be made without the observed data
pp_check(mod, prefix = "ppd")

## End(Not run)

</code></pre>

<hr>
<h2 id='ppc.mvgam'>Plot mvgam posterior predictive checks for a specified series</h2><span id='topic+ppc.mvgam'></span><span id='topic+ppc'></span>

<h3>Description</h3>

<p>Plot mvgam posterior predictive checks for a specified series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc(object, ...)

## S3 method for class 'mvgam'
ppc(
  object,
  newdata,
  data_test,
  series = 1,
  type = "hist",
  n_bins,
  legend_position,
  xlab,
  ylab,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppc.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_...">...</code></td>
<td>
<p>further <code><a href="graphics.html#topic+par">par</a></code> graphical parameters.</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
for the forecast horizon, in addition to any other variables included in the linear predictor of <code>formula</code>. If
included, the observed values in the test data are compared to the model's forecast distribution for exploring
biases in model predictions.
Note this is only useful if the same <code>newdata</code> was also included when fitting the original model.</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_type">type</code></td>
<td>
<p><code>character</code> specifying the type of posterior predictive check to calculate and plot.
Valid options are: 'rootogram', 'mean', 'hist', 'density', 'prop_zero', 'pit' and 'cdf'</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_n_bins">n_bins</code></td>
<td>
<p><code>integer</code> specifying the number of bins to use for binning observed values when plotting
a rootogram or histogram. Default is <code>50</code> bins for a rootogram, which means that if
there are <code style="white-space: pre;">&#8288;&gt;50&#8288;</code> unique observed values, bins will
be used to prevent overplotting and facilitate interpretation. Default for a histogram is to use the
number of bins returned by a call to <code>hist</code> in base <code>R</code></p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_legend_position">legend_position</code></td>
<td>
<p>The location may also be specified by setting x to a single keyword from the
list &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;.
This places the legend on the inside of the plot frame at the given location. Or alternatively,
use &quot;none&quot; to hide the legend.</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior predictions are drawn from the fitted <code>mvgam</code> and compared against
the empirical distribution of the observed data for a specified series to help evaluate the model's
ability to generate unbiased predictions. For all plots apart from <code>type = 'rootogram'</code>, posterior predictions
can also be compared to out of sample observations as long as these observations were included as
'data_test' in the original model fit and supplied here. Rootograms are currently only plotted using the
'hanging' style.
<br />
Note that the predictions used for these plots are those that have been generated directly within
the <code>mvgam()</code> model, so they can be misleading if the model included flexible dynamic trend components. For
a broader range of posterior checks that are created using &quot;new data&quot; predictions, see
<code><a href="#topic+pp_check.mvgam">pp_check.mvgam</a></code>
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot showing either a posterior rootogram (for <code>type == 'rootogram'</code>),
the predicted vs observed mean for the
series (for <code>type == 'mean'</code>), predicted vs observed proportion of zeroes for the
series (for <code>type == 'prop_zero'</code>),predicted vs observed histogram for the
series (for <code>type == 'hist'</code>), kernel density or empirical CDF estimates for
posterior predictions (for <code>type == 'density'</code> or <code>type == 'cdf'</code>) or a Probability
Integral Transform histogram (for <code>type == 'pit'</code>).
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp_check.mvgam">pp_check.mvgam</a></code>, <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some smooth effects and fit a model
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
mod &lt;- mvgam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
            data = dat,
            family = gaussian(),
            chains = 2)

# Posterior checks
ppc(mod, type = 'hist')
ppc(mod, type = 'density')
ppc(mod, type = 'cdf')

# Many more options are available with pp_check()
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
pp_check(mod, type = 'freqpoly')

</code></pre>

<hr>
<h2 id='predict.mvgam'>Predict from the GAM component of an mvgam model</h2><span id='topic+predict.mvgam'></span>

<h3>Description</h3>

<p>Predict from the GAM component of an mvgam model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
predict(
  object,
  newdata,
  data_test,
  type = "link",
  process_error = TRUE,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the
variables included in the linear predictor of <code>formula</code>. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_type">type</code></td>
<td>
<p>When this has the value <code>link</code> (default) the linear predictor is
calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. When <code>variance</code> is used, the variance of the response
with respect to the mean (mean-variance relationship) is returned.
When <code>type = "terms"</code>, each component of the linear predictor is
returned separately in the form of a <code>list</code> (possibly with standard
errors, if <code>summary = TRUE</code>): this includes parametric model components,
followed by each smooth component, but excludes any offset and any intercept.
Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an
N-mixture distribution, while type <code>detection</code> will return the estimated
detection probability from an N-mixture distribution</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and a dynamic trend model was fit,
expected uncertainty in the process model is accounted for by using draws
from the latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent trend
component is ignored when calculating predictions</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for all types of predictions for models that did not include
a <code>trend_formula</code>, uncertainty in the dynamic trend
component can be ignored by setting <code>process_error = FALSE</code>. However,
if a <code>trend_formula</code> was supplied in the model, predictions for this component cannot be
ignored. If <code>process_error = TRUE</code>, trend predictions will ignore autocorrelation
coefficients or GP length scale coefficients, ultimately assuming the process is stationary.
This method is similar to the types of posterior predictions returned from <code>brms</code> models
when using autocorrelated error predictions for newdata.
This function is therefore more suited to posterior simulation from the GAM components
of a <code>mvgam</code> model, while the forecasting functions
<code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code> and <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code> are better suited to generate h-step ahead forecasts
that respect the temporal dynamics of estimated latent trends.
</p>


<h3>Value</h3>

<p>Predicted values on the appropriate scale.
If <code>summary = FALSE</code> and <code>type != "terms"</code>,
the output is a matrix of dimension <code style="white-space: pre;">&#8288;n_draw x n_observations&#8288;</code>
containing predicted values for each posterior draw in <code>object</code>.
</p>
<p>If <code>summary = TRUE</code> and <code>type != "terms"</code>, the output is an <code>n_observations</code> x <code>E</code>
matrix. The number of summary statistics <code>E</code> is equal to <code>2 +
  length(probs)</code>: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>
<p>If <code>type = "terms"</code> and <code>summary = FALSE</code>, the output is a named <code>list</code>
containing a separate slot for each effect, with the effects returned as
matrices of dimension <code style="white-space: pre;">&#8288;n_draw x 1&#8288;</code>. If <code>summary = TRUE</code>, the output resembles that
from <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> when using the call
<code>predict.gam(object, type = "terms", se.fit = TRUE)</code>, where mean contributions
from each effect are returned in <code>matrix</code> form while standard errors (representing
the interval: <code>(max(probs) - min(probs)) / 2</code>) are returned in a separate <code>matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate 4 time series with hierarchical seasonality
# and independent AR1 dynamic processes
set.seed(111)
simdat &lt;- sim_mvgam(seasonality = 'hierarchical',
                   trend_model = 'AR1',
                   family = gaussian())

# Fit a model with shared seasonality
mod1 &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             data = simdat$data_train,
             family = gaussian(),
             trend_model = AR(),
             noncentred = TRUE,
             chains = 2)

# Generate predictions against observed data
preds &lt;- predict(mod1, summary = TRUE)
head(preds)

# Generate predictions against test data
preds &lt;- predict(mod1, newdata = simdat$data_test, summary = TRUE)
head(preds)

</code></pre>

<hr>
<h2 id='print.mvgam'>Summary for a fitted mvgam object</h2><span id='topic+print.mvgam'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> object and prints a quick summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mvgam_+3A_x">x</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
<tr><td><code id="print.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A brief summary of the model's call is printed
</p>


<h3>Value</h3>

<p>A <code>list</code> is printed on-screen
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='PW'>Specify piecewise linear or logistic trends</h2><span id='topic+PW'></span>

<h3>Description</h3>

<p>Set up piecewise linear or logistic trend models
in <code>mvgam</code>. These functions do not evaluate their arguments 
they exist purely to help set up a model with particular piecewise
trend models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PW(
  n_changepoints = 10,
  changepoint_range = 0.8,
  changepoint_scale = 0.05,
  growth = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PW_+3A_n_changepoints">n_changepoints</code></td>
<td>
<p>A non-negative integer specifying the number of potential
changepoints. Potential changepoints are selected uniformly from the
first <code>changepoint_range</code> proportion of timepoints in <code>data</code>. Default is <code>10</code></p>
</td></tr>
<tr><td><code id="PW_+3A_changepoint_range">changepoint_range</code></td>
<td>
<p>Proportion of history in <code>data</code> in which trend changepoints
will be estimated. Defaults to 0.8 for the first 80%.</p>
</td></tr>
<tr><td><code id="PW_+3A_changepoint_scale">changepoint_scale</code></td>
<td>
<p>Parameter modulating the flexibility of the
automatic changepoint selection by altering the scale parameter of a Laplace distribution.
The resulting prior will be <code>double_exponential(0, changepoint_scale)</code>.
Large values will allow many changepoints and a more flexible trend, while
small values will allow few changepoints. Default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="PW_+3A_growth">growth</code></td>
<td>
<p>Character string specifying either 'linear' or 'logistic' growth of
the trend. If 'logistic', a variable labelled <code>cap</code> MUST be in <code>data</code> to specify the
maximum saturation point for the trend (see details and examples in <code><a href="#topic+mvgam">mvgam</a></code> for
more information).
Default is 'linear'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Offsets and intercepts</em>:
For each of these trend models, an offset parameter is included in the trend
estimation process. This parameter will be incredibly difficult to identify
if you also include an intercept in the observation formula. For that reason,
it is highly recommended that you drop the intercept from the formula
(i.e. <code>y ~ x + 0</code> or <code>y ~ x - 1</code>, where <code>x</code> are your optional predictor terms).
<br />
<br />
<em>Logistic growth and the cap variable</em>:
When forecasting growth, there is often some maximum achievable point that
a time series can reach. For example, total market size, total population size
or carrying capacity in population dynamics. It can be advantageous for the forecast
to saturate at or near this point so that predictions are more sensible.
This function allows you to make forecasts using a logistic growth trend model,
with a specified carrying capacity. Note that this capacity does not need to be static
over time, it can vary with each series x timepoint combination if necessary. But you
must supply a <code>cap</code> value for each observation in the data when using <code>growth = 'logistic'</code>.
For observation families that use a non-identity link function, the <code>cap</code> value will
be internally transformed to the link scale (i.e. your specified <code>cap</code> will be log
transformed if you are using a <code>poisson()</code> or <code>nb()</code> family). It is therefore important
that you specify the <code>cap</code> values on the scale of your outcome. Note also that
no missing values are allowed in <code>cap</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_trend</code>, which contains a list of
arguments to be interpreted by the parsing functions in <code>mvgam</code>
</p>


<h3>References</h3>

<p>Taylor, Sean J., and Benjamin Letham. &quot;Forecasting at scale.&quot; The American Statistician 72.1 (2018): 37-45.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of logistic growth with possible changepoints
# Simple logistic growth model
dNt = function(r, N, k){
   r * N * (k - N)
}

# Iterate growth through time
Nt = function(r, N, t, k) {
for (i in 1:(t - 1)) {

 # population at next time step is current population + growth,
 # but we introduce several 'shocks' as changepoints
 if(i %in% c(5, 15, 25, 41, 45, 60, 80)){
   N[i + 1] &lt;- max(1, N[i] + dNt(r + runif(1, -0.1, 0.1),
                                 N[i], k))
   } else {
   N[i + 1] &lt;- max(1, N[i] + dNt(r, N[i], k))
   }
  }
 N
}

# Simulate expected values
set.seed(11)
expected &lt;- Nt(0.004, 2, 100, 30)
plot(expected, xlab = 'Time')

# Take Poisson draws
y &lt;- rpois(100, expected)
plot(y, xlab = 'Time')

# Assemble data into dataframe and model. We set a
# fixed carrying capacity of 35 for this example, but note that
# this value is not required to be fixed at each timepoint
mod_data &lt;- data.frame(y = y,
                       time = 1:100,
                       cap = 35,
                       series = as.factor('series_1'))
plot_mvgam_series(data = mod_data)

# The intercept is nonidentifiable when using piecewise
# trends because the trend functions have their own offset
# parameters 'm'; it is recommended to always drop intercepts
# when using these trend models
mod &lt;- mvgam(y ~ 0,
             trend_model = PW(growth = 'logistic'),
             family = poisson(),
             data = mod_data,
             chains = 2)
summary(mod)

# Plot the posterior hindcast
plot(mod, type = 'forecast')

# View the changepoints with ggplot2 utilities
library(ggplot2)
mcmc_plot(mod, variable = 'delta_trend',
          regex = TRUE) +
scale_y_discrete(labels = mod$trend_model$changepoints) +
labs(y = 'Potential changepoint',
     x = 'Rate change')

</code></pre>

<hr>
<h2 id='residuals.mvgam'>Posterior draws of <code>mvgam</code> residuals</h2><span id='topic+residuals.mvgam'></span>

<h3>Description</h3>

<p>This method extracts posterior draws of Dunn-Smyth (randomized quantile)
residuals in the order in which the data were supplied to the model. It included
additional arguments for obtaining summaries of the computed residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
residuals(object, summary = TRUE, robust = FALSE, probs = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mvgam_+3A_object">object</code></td>
<td>
<p>An object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="residuals.mvgam_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="residuals.mvgam_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.mvgam_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method gives residuals as Dunn-Smyth (randomized quantile) residuals. Any
observations that were missing (i.e. <code>NA</code>) in the original data will have missing values
in the residuals
</p>


<h3>Value</h3>

<p>An <code>array</code> of randomized quantile residual values.
If <code>summary = FALSE</code> the output resembles those of
<code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> and <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>.
</p>
<p>If <code>summary = TRUE</code> the output is an <code>n_observations</code> x <code>E</code>
matrix. The number of summary statistics <code>E</code> is equal to <code>2 +
  length(probs)</code>: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2)

# Extract posterior residuals
resids &lt;- residuals(mod)
str(resids)

</code></pre>

<hr>
<h2 id='RW'>Specify autoregressive dynamic processes</h2><span id='topic+RW'></span><span id='topic+AR'></span><span id='topic+CAR'></span><span id='topic+VAR'></span>

<h3>Description</h3>

<p>Set up autoregressive or autoregressive moving average trend models
in <code>mvgam</code>. These functions do not evaluate their arguments 
they exist purely to help set up a model with particular autoregressive
trend models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RW(ma = FALSE, cor = FALSE)

AR(p = 1, ma = FALSE, cor = FALSE)

CAR(p = 1)

VAR(ma = FALSE, cor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RW_+3A_ma">ma</code></td>
<td>
<p><code>Logical</code> Include moving average terms of order <code>1</code>?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="RW_+3A_cor">cor</code></td>
<td>
<p><code>Logical</code> Include correlated process errors as part of a
multivariate normal process model? If <code>TRUE</code> and if <code>n_series &gt; 1</code>
in the supplied data, a fully structured covariance matrix will be estimated
for the process errors. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="RW_+3A_p">p</code></td>
<td>
<p>A non-negative integer specifying the autoregressive (AR) order.
Default is <code>1</code>. Cannot currently be larger than <code>3</code> for <code>AR</code> terms,
and cannot be anything other than <code>1</code> for continuous time AR (<code>CAR</code>) terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mvgam_trend</code>, which contains a list of
arguments to be interpreted by the parsing functions in <code>mvgam</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A short example to illustrate CAR(1) models
# Function to simulate CAR1 data with seasonality
sim_corcar1 = function(n = 120,
                      phi = 0.5,
                      sigma = 1,
                      sigma_obs = 0.75){
# Sample irregularly spaced time intervals
time_dis &lt;- c(0, runif(n - 1, -0.1, 1))
time_dis[time_dis &lt; 0] &lt;- 0; time_dis &lt;- time_dis * 5

# Set up the latent dynamic process
x &lt;- vector(length = n); x[1] &lt;- -0.3
for(i in 2:n){
 # zero-distances will cause problems in sampling, so mvgam uses a
 # minimum threshold; this simulation function emulates that process
 if(time_dis[i] == 0){
   x[i] &lt;- rnorm(1, mean = (phi ^ 1e-12) * x[i - 1], sd = sigma)
  } else {
    x[i] &lt;- rnorm(1, mean = (phi ^ time_dis[i]) * x[i - 1], sd = sigma)
  }
}

# Add 12-month seasonality
cov1 &lt;- sin(2 * pi * (1 : n) / 12); cov2 &lt;- cos(2 * pi * (1 : n) / 12)
beta1 &lt;- runif(1, 0.3, 0.7); beta2 &lt;- runif(1, 0.2, 0.5)
seasonality &lt;- beta1 * cov1 + beta2 * cov2

# Take Gaussian observations with error and return
data.frame(y = rnorm(n, mean = x + seasonality, sd = sigma_obs),
           season = rep(1:12, 20)[1:n],
           time = cumsum(time_dis))
}

# Sample two time series
dat &lt;- rbind(dplyr::bind_cols(sim_corcar1(phi = 0.65,
                                         sigma_obs = 0.55),
                             data.frame(series = 'series1')),
            dplyr::bind_cols(sim_corcar1(phi = 0.8,
                             sigma_obs = 0.35),
                             data.frame(series = 'series2'))) %&gt;%
      dplyr::mutate(series = as.factor(series))

# mvgam with CAR(1) trends and series-level seasonal smooths; the
# State-Space representation (using trend_formula) will be more efficient
mod &lt;- mvgam(formula = y ~ 1,
            trend_formula = ~ s(season, bs = 'cc',
                                k = 5, by = trend),
            trend_model = CAR(),
            data = dat,
            family = gaussian(),
            samples = 300,
            chains = 2)

# View usual summaries and plots
summary(mod)
conditional_effects(mod, type = 'expected')
plot(mod, type = 'trend', series = 1)
plot(mod, type = 'trend', series = 2)
plot(mod, type = 'residuals', series = 1)
plot(mod, type = 'residuals', series = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='score.mvgam_forecast'>Compute probabilistic forecast scores for mvgam objects</h2><span id='topic+score.mvgam_forecast'></span><span id='topic+score'></span>

<h3>Description</h3>

<p>Compute probabilistic forecast scores for mvgam objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_forecast'
score(
  object,
  score = "crps",
  log = FALSE,
  weights,
  interval_width = 0.9,
  n_cores = 1,
  ...
)

score(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.mvgam_forecast_+3A_object">object</code></td>
<td>
<p><code>mvgam_forecast</code> object. See <code><a href="#topic+forecast.mvgam">forecast.mvgam()</a></code>.</p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_score">score</code></td>
<td>
<p><code>character</code> specifying the type of proper scoring rule to use for evaluation. Options are:
<code>sis</code> (i.e. the Scaled Interval Score), <code>energy</code>, <code>variogram</code>, <code>elpd</code>
(i.e. the Expected log pointwise Predictive Density),
<code>drps</code> (i.e. the Discrete Rank Probability Score) or <code>crps</code> (the Continuous Rank Probability Score).
Note that when choosing <code>elpd</code>, the supplied object must have forecasts on the <code>link</code> scale so that
expectations can be calculated prior to scoring. For all other scores, forecasts should be supplied
on the <code>response</code> scale (i.e. posterior predictions)</p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_log">log</code></td>
<td>
<p><code>logical</code>. Should the forecasts and truths be logged prior to scoring?
This is often appropriate for comparing
performance of models when series vary in their observation ranges</p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_weights">weights</code></td>
<td>
<p>optional <code>vector</code> of weights (where <code>length(weights) == n_series</code>)
for weighting pairwise correlations when evaluating the variogram score for multivariate
forecasts. Useful for down-weighting series that have larger magnitude observations or that
are of less interest when forecasting. Ignored if <code>score != 'variogram'</code></p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_interval_width">interval_width</code></td>
<td>
<p>proportional value on <code style="white-space: pre;">&#8288;[0.05,0.95]&#8288;</code> defining the forecast interval
for calculating coverage and, if <code>score = 'sis'</code>, for calculating the interval score</p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_n_cores">n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for calculating scores in parallel</p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing scores and interval coverages per forecast horizon.
If <code>score %in% c('drps', 'crps', 'elpd')</code>,
the list will also contain return the sum of all series-level scores per horizon. If
<code>score %in% c('energy','variogram')</code>, no series-level scores are computed and the only score returned
will be for all series. For all scores apart from <code>elpd</code>, the <code>in_interval</code> column in each series-level
slot is a binary indicator of whether or not the true value was within the forecast's corresponding
posterior empirical quantiles. Intervals are not calculated when using <code>elpd</code> because forecasts
will only contain the linear predictors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate observations for three count-valued time series
data &lt;- sim_mvgam()
# Fit a dynamic model using 'newdata' to automatically produce forecasts
mod &lt;- mvgam(y ~ 1,
            trend_model = RW(),
            data = data$data_train,
            newdata = data$data_test,
            chains = 2)

# Extract forecasts into a 'mvgam_forecast' object
fc &lt;- forecast(mod)

# Compute Discrete Rank Probability Scores and 0.90 interval coverages
fc_scores &lt;- score(fc, score = 'drps')
str(fc_scores)

</code></pre>

<hr>
<h2 id='series_to_mvgam'>This function converts univariate or multivariate time series (<code>xts</code> or <code>ts</code> objects)
to the format necessary for <code><a href="#topic+mvgam">mvgam</a></code></h2><span id='topic+series_to_mvgam'></span>

<h3>Description</h3>

<p>This function converts univariate or multivariate time series (<code>xts</code> or <code>ts</code> objects)
to the format necessary for <code><a href="#topic+mvgam">mvgam</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_to_mvgam(series, freq, train_prop = 0.85)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="series_to_mvgam_+3A_series">series</code></td>
<td>
<p><code><a href="xts.html#topic+xts">xts</a></code> or <code><a href="stats.html#topic+ts">ts</a></code> object to be converted to <code><a href="#topic+mvgam">mvgam</a></code> format</p>
</td></tr>
<tr><td><code id="series_to_mvgam_+3A_freq">freq</code></td>
<td>
<p><code>integer</code>. The seasonal frequency of the series</p>
</td></tr>
<tr><td><code id="series_to_mvgam_+3A_train_prop">train_prop</code></td>
<td>
<p><code>numeric</code> stating the proportion of data to use for training. Should be between <code>0.25</code> and <code>0.95</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object containing outputs needed for <code><a href="#topic+mvgam">mvgam</a></code>,
including 'data_train' and 'data_test'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A ts object example
data("sunspots")
series &lt;- cbind(sunspots, sunspots)
colnames(series) &lt;- c('blood', 'bone')
head(series)
series_to_mvgam(series, frequency(series), 0.85)

# An xts object example
library(xts)
dates &lt;- seq(as.Date("2001-05-01"), length=30, by="quarter")
data  &lt;- cbind(c(gas = rpois(30, cumprod(1+rnorm(30, mean = 0.01, sd = 0.001)))),
c(oil = rpois(30, cumprod(1+rnorm(30, mean = 0.01, sd = 0.001)))))
series &lt;- xts(x = data, order.by = dates)
colnames(series) &lt;- c('gas', 'oil')
head(series)
series_to_mvgam(series, freq = 4, train_prop = 0.85)

</code></pre>

<hr>
<h2 id='sim_mvgam'>Simulate a set of discrete time series for mvgam modelling</h2><span id='topic+sim_mvgam'></span>

<h3>Description</h3>

<p>This function simulates discrete time series data for fitting a multivariate GAM that includes
shared seasonality and dependence on state-space latent dynamic factors. Random dependencies among series, i.e.
correlations in their long-term trends, are included in the form of correlated loadings on the latent dynamic factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_mvgam(
  T = 100,
  n_series = 3,
  seasonality = "shared",
  use_lv = FALSE,
  n_lv = 1,
  trend_model = "RW",
  drift = FALSE,
  prop_trend = 0.2,
  trend_rel,
  freq = 12,
  family = poisson(),
  phi,
  shape,
  sigma,
  nu,
  mu,
  prop_missing = 0,
  prop_train = 0.85
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_mvgam_+3A_t">T</code></td>
<td>
<p><code>integer</code>. Number of observations (timepoints)</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_n_series">n_series</code></td>
<td>
<p><code>integer</code>. Number of discrete time series</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_seasonality">seasonality</code></td>
<td>
<p><code>character</code>. Either <code>shared</code>, meaning that all series share the exact same seasonal pattern,
or <code>hierarchical</code>, meaning that there is a global seasonality but each series' pattern can deviate slightly</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_use_lv">use_lv</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. If <code>FALSE</code>, estimate independent latent trends for each series</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code>. Number of latent dynamic factors for generating the series' trends</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_trend_model">trend_model</code></td>
<td>
<p><code>character</code> specifying the time series dynamics for the latent trend. Options are:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>RW</code> (random walk with possible drift)
</p>
</li>
<li> <p><code>AR1</code> (with possible drift)
</p>
</li>
<li> <p><code>AR2</code> (with possible drift)
</p>
</li>
<li> <p><code>AR3</code> (with possible drift)
</p>
</li>
<li> <p><code>VAR1</code> (contemporaneously uncorrelated VAR1)
</p>
</li>
<li> <p><code>VAR1cor</code> (contemporaneously correlated VAR1)
</p>
</li>
<li> <p><code>GP</code> (Gaussian Process with squared exponential kernel)</p>
</li></ul>
<p> See <a href="#topic+mvgam_trends">mvgam_trends</a> for more details</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_drift">drift</code></td>
<td>
<p><code>logical</code>, simulate a drift term for each trend</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_prop_trend">prop_trend</code></td>
<td>
<p><code>numeric</code>. Relative importance of the trend for each series. Should be between <code>0</code> and <code>1</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_trend_rel">trend_rel</code></td>
<td>
<p>Deprecated. Use <code>prop_trend</code> instead</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_freq">freq</code></td>
<td>
<p><code>integer</code>. The seasonal frequency of the series</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the exponential observation family for the series. Currently supported
families are: <code>nb()</code>, <code>poisson()</code>, <code>bernoulli()</code>, <code>tweedie()</code>, <code>gaussian()</code>,
<code>betar()</code>, <code>lognormal()</code>, <code>student()</code> and <code>Gamma()</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_phi">phi</code></td>
<td>
<p><code>vector</code> of dispersion parameters for the series
(i.e. <code>size</code> for <code>nb()</code> or
<code>phi</code> for <code>betar()</code>). If <code>length(phi) &lt; n_series</code>,
the first element of <code>phi</code> will
be replicated <code>n_series</code> times.
Defaults to <code>5</code> for <code>nb()</code> and <code>tweedie()</code>; <code>10</code> for
<code>betar()</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_shape">shape</code></td>
<td>
<p><code>vector</code> of shape parameters for the series
(i.e. <code>shape</code> for <code>gamma()</code>)
If <code>length(shape) &lt; n_series</code>, the first element of <code>shape</code> will
be replicated <code>n_series</code> times. Defaults to <code>10</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_sigma">sigma</code></td>
<td>
<p><code>vector</code> of scale parameters for the series
(i.e. <code>sd</code> for <code>gaussian()</code> or <code>student()</code>,
<code>log(sd)</code> for <code>lognormal()</code>). If <code>length(sigma) &lt; n_series</code>, the first element of <code>sigma</code> will
be replicated <code>n_series</code> times. Defaults to <code>0.5</code> for <code>gaussian()</code> and
<code>student()</code>; <code>0.2</code> for <code>lognormal()</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_nu">nu</code></td>
<td>
<p><code>vector</code> of degrees of freedom parameters for the
series (i.e. <code>nu</code> for <code>student()</code>)
If <code>length(nu) &lt; n_series</code>, the first element of <code>nu</code> will
be replicated <code>n_series</code> times. Defaults to <code>3</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_mu">mu</code></td>
<td>
<p><code>vector</code> of location parameters for the series. If <code>length(mu) &lt; n_series</code>, the first element of <code>mu</code> will
be replicated <code>n_series</code> times. Defaults to small random values between <code>-0.5</code> and <code>0.5</code> on the link scale</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_prop_missing">prop_missing</code></td>
<td>
<p><code>numeric</code> stating proportion of observations that are missing. Should be between
<code>0</code> and <code>0.8</code>, inclusive</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_prop_train">prop_train</code></td>
<td>
<p><code>numeric</code> stating the proportion of data to use for training. Should be between <code>0.2</code> and <code>1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object containing outputs needed for <code><a href="#topic+mvgam">mvgam</a></code>, including 'data_train' and 'data_test',
as well as some additional information about the simulated seasonality and trend dependencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate series with observations bounded at 0 and 1 (Beta responses)
sim_data &lt;- sim_mvgam(family = betar(), trend_model = RW(), prop_trend = 0.6)
plot_mvgam_series(data = sim_data$data_train, series = 'all')

# Now simulate series with overdispersed discrete observations
sim_data &lt;- sim_mvgam(family = nb(), trend_model = RW(), prop_trend = 0.6, phi = 10)
plot_mvgam_series(data = sim_data$data_train, series = 'all')
</code></pre>

<hr>
<h2 id='summary.mvgam'>Summary for a fitted mvgam object</h2><span id='topic+summary.mvgam'></span><span id='topic+summary.mvgam_prefit'></span><span id='topic+coef.mvgam'></span>

<h3>Description</h3>

<p>These functions take a fitted <code>mvgam</code> object and return various useful summaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
summary(object, include_betas = TRUE, smooth_test = TRUE, digits = 2, ...)

## S3 method for class 'mvgam_prefit'
summary(object, ...)

## S3 method for class 'mvgam'
coef(object, summarise = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_include_betas">include_betas</code></td>
<td>
<p>Logical. Print a summary that includes posterior summaries
of all linear predictor beta coefficients (including spline coefficients)?
Defaults to <code>TRUE</code> but use <code>FALSE</code> for a more concise summary</p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_smooth_test">smooth_test</code></td>
<td>
<p>Logical. Compute estimated degrees of freedom and approximate
p-values for smooth terms? Defaults to <code>TRUE</code>, but users may wish to set
to <code>FALSE</code> for complex models with many smooth or random effect terms</p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits for printing out the summary;
defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_summarise">summarise</code></td>
<td>
<p><code>logical</code>. Summaries of coefficients will be returned
if <code>TRUE</code>. Otherwise the full posterior distribution will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.mvgam</code> and <code>summary.mvgam_prefit</code> return brief summaries of the model's call, along with posterior intervals for
some of the key parameters in the model. Note that some smooths have extra penalties on the null space,
so summaries for the <code>rho</code> parameters may include more penalty terms than the number of smooths in
the original model formula. Approximate p-values for smooth terms are also returned,
with methods used for their
calculation following those used for <code>mgcv</code> equivalents (see <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code> for details).
The Estimated Degrees of Freedom (edf) for smooth terms is computed using
either <code>edf.type = 1</code> for models with no trend component, or <code>edf.type = 0</code> for models with
trend components. These are described in the documentation for <code><a href="mgcv.html#topic+jagam">jagam</a></code>. Experiments suggest
these p-values tend to be more conservative than those that might be returned from an equivalent
model fit with <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code> using <code>method = 'REML'</code>
</p>
<p><code>coef.mvgam</code> returns either summaries or full posterior estimates for <code>GAM</code> component
coefficients
</p>


<h3>Value</h3>

<p>For <code>summary.mvgam</code> and <code>summary.mvgam_prefit</code>, a <code>list</code> is printed
on-screen showing the summaries for the model
</p>
<p>For <code>coef.mvgam</code>, either a <code>matrix</code> of posterior coefficient distributions
(if <code>summarise == FALSE</code> or <code>data.frame</code> of coefficient summaries)
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='ti'>Defining smooths in <span class="pkg">mvgam</span> formulae</h2><span id='topic+ti'></span><span id='topic+te'></span>

<h3>Description</h3>

<p>Functions used in definition of smooth terms within model formulae.
The functions do not evaluate a (spline) smooth - they exist purely
to help set up mvgam models using spline based smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ti(...)

te(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ti_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="mgcv.html#topic+ti">mgcv::ti</a></code> or
<code><a href="mgcv.html#topic+ti">mgcv::te</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions defined here are just simple wrappers of the respective
functions of the <span class="pkg">mgcv</span> package. When using them, please cite the
appropriate references obtained via <code>citation("mgcv")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+ti">mgcv::ti</a></code>, <code><a href="mgcv.html#topic+ti">mgcv::te</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)

# Fit univariate smooths for all predictors
fit1 &lt;- mvgam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
              data = dat, chains = 2, family = gaussian())
summary(fit1)
conditional_effects(fit1)

# Fit a more complicated smooth model
fit2 &lt;- mvgam(y ~ te(x0, x1) + s(x2, by = x3),
              data = dat, chains = 2, family = gaussian())
summary(fit2)
conditional_effects(fit2)


</code></pre>

<hr>
<h2 id='update.mvgam'>Update an existing <code>mvgam</code> object</h2><span id='topic+update.mvgam'></span>

<h3>Description</h3>

<p>This function allows a previously fitted <code>mvgam</code> model to be updated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
update(
  object,
  formula,
  trend_formula,
  data,
  newdata,
  trend_model,
  trend_map,
  use_lv,
  n_lv,
  family,
  share_obs_params,
  priors,
  chains,
  burnin,
  samples,
  threads,
  algorithm,
  lfo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_formula">formula</code></td>
<td>
<p>Optional new <code>formula</code> object. Note, <code>mvgam</code> currently does not support dynamic formula
updates such as removal of specific terms with <code>- term</code>. When updating, the entire formula needs
to be supplied</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_trend_formula">trend_formula</code></td>
<td>
<p>An optional <code>character</code> string specifying the GAM process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture process model evolution
separately from the observation model. Should not have a response variable specified on the left-hand side
of the formula (i.e. a valid option would be <code>~ season + s(year)</code>). Also note that you should not use
the identifier <code>series</code> in this formula to specify effects that vary across time series. Instead you should use
<code>trend</code>. This will ensure that models in which a <code>trend_map</code> is supplied will still work consistently
(i.e. by allowing effects to vary across process models, even when some time series share the same underlying
process model). This feature is only currently available for <code>RW()</code>, <code>AR()</code> and <code>VAR()</code> trend models.
In <code>nmix()</code> family models, the <code>trend_formula</code> is used to set up a linear predictor for the underlying
latent abundance</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response variable and covariates
required by the GAM <code>formula</code> and optional <code>trend_formula</code>. Should include columns:
#'</p>

<ul>
<li><p><code>series</code> (a <code>factor</code> index of the series IDs; the number of levels should be identical
to the number of unique series labels (i.e. <code>n_series = length(levels(data$series))</code>))
</p>
</li>
<li><p><code>time</code> (<code>numeric</code> or <code>integer</code> index of the time point for each observation).
For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>), time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>). However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. See an example of <code>CAR()</code> trends in <code><a href="#topic+CAR">CAR</a></code>
</p>
</li></ul>

<p>Should also include any other variables to be included in the linear predictor of <code>formula</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least <code>series</code> and <code>time</code>
in addition to any other variables included in the linear predictor of <code>formula</code>. If included, the
observations in variable <code>y</code> will be set to <code>NA</code> when fitting the model so that posterior
simulations can be obtained</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_trend_model">trend_model</code></td>
<td>
<p><code>character</code> or  <code>function</code> specifying the time series dynamics for the latent trend. Options are:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>'RW'</code> or <code>RW()</code>
</p>
</li>
<li> <p><code>'AR1'</code> or <code>AR(p = 1)</code>
</p>
</li>
<li> <p><code>'AR2'</code> or <code>AR(p = 2)</code>
</p>
</li>
<li> <p><code>'AR3'</code> or <code>AR(p = 3)</code>
</p>
</li>
<li> <p><code>'CAR1'</code> or <code>CAR(p = 1)</code>
</p>
</li>
<li> <p><code>'VAR1'</code>  or <code>VAR()</code>(only available in <code>Stan</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;'PWlogistic&#8288;</code>, <code>'PWlinear'</code> or <code>PW()</code> (only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>'GP'</code> or <code>GP()</code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p>
</li></ul>

<p>For all trend types apart from <code>GP()</code>, <code>CAR()</code> and <code>PW()</code>, moving average and/or correlated
process error terms can also be estimated (for example, <code>RW(cor = TRUE)</code> will set up a
multivariate Random Walk if <code>n_series &gt; 1</code>). See <a href="#topic+mvgam_trends">mvgam_trends</a> for more details</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_trend_map">trend_map</code></td>
<td>
<p>Optional <code>data.frame</code> specifying which series should depend on which latent
trends. Useful for allowing multiple series to depend on the same latent trend process, but with
different observation processes. If supplied, a latent factor model is set up by setting
<code>use_lv = TRUE</code> and using the mapping to set up the shared trends. Needs to have column names
<code>series</code> and <code>trend</code>, with integer values in the <code>trend</code> column to state which trend each series
should depend on. The <code>series</code> column should have a single unique entry for each series in the
data (names should perfectly match factor levels of the <code>series</code> variable in <code>data</code>). See examples
for details</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_use_lv">use_lv</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for
<code>RW()</code>, <code>AR()</code> and <code>GP()</code> trend models. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code> the number of latent dynamic factors to use if <code>use_lv == TRUE</code>.
Cannot be <code>&gt; n_series</code>. Defaults arbitrarily to <code>min(2, floor(n_series / 2))</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the exponential observation family for the series. Currently supported
families are:
</p>

<ul>
<li><p><code>gaussian()</code> for real-valued data
</p>
</li>
<li><p><code>betar()</code> for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li><p><code>lognormal()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>student_t()</code> for real-valued data
</p>
</li>
<li><p><code>Gamma()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>bernoulli()</code> for binary data
</p>
</li>
<li><p><code>poisson()</code> for count data
</p>
</li>
<li><p><code>nb()</code> for overdispersed count data
</p>
</li>
<li><p><code>binomial()</code> for count data with imperfect detection when the number of trials is known;
note that the <code>cbind()</code> function must be used to bind the discrete observations and the discrete number
of trials
</p>
</li>
<li><p><code>beta_binomial()</code> as for <code>binomial()</code> but allows for overdispersion
</p>
</li>
<li><p><code>nmix()</code> for count data with imperfect detection when the number of trials
is unknown and should be modeled via a State-Space N-Mixture model.
The latent states are Poisson, capturing the 'true' latent
abundance, while the observation process is Binomial to account for
imperfect detection.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for an example of how to use this family</p>
</li></ul>

<p>Note that only <code>nb()</code> and <code>poisson()</code> are available if using <code>JAGS</code> as the backend.
Default is <code>poisson()</code>.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for more details</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_share_obs_params">share_obs_params</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and the <code>family</code>
has additional family-specific observation parameters (e.g. variance components in
<code>student_t()</code> or <code>gaussian()</code>, or dispersion parameters in <code>nb()</code> or <code>betar()</code>),
these parameters will be shared across all series. This is handy if you have multiple
time series that you believe share some properties, such as being from the same
species over different spatial units. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_priors">priors</code></td>
<td>
<p>An optional <code>data.frame</code> with prior
definitions (in JAGS or Stan syntax). if using Stan, this can also be an object of
class <code>brmsprior</code> (see. <code><a href="brms.html#topic+prior">prior</a></code> for details). See <a href="#topic+get_mvgam_priors">get_mvgam_priors</a> and
'Details' for more information on changing default prior distributions</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_chains">chains</code></td>
<td>
<p><code>integer</code> specifying the number of parallel chains for the model. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_burnin">burnin</code></td>
<td>
<p><code>integer</code> specifying the number of warmup iterations of the Markov chain to run
to tune sampling algorithms. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_samples">samples</code></td>
<td>
<p><code>integer</code> specifying the number of post-warmup iterations of the Markov chain to run for
sampling the posterior distribution</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> Experimental option to use multithreading for within-chain
parallelisation in <code>Stan</code>. We recommend its use only if you are experienced with
<code>Stan</code>'s <code>reduce_sum</code> function and have a slow running model that cannot be sped
up by any other means. Only available for some families(<code>poisson()</code>, <code>nb()</code>, <code>gaussian()</code>) and
when using <code>Cmdstan</code> as the backend</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with factorized normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, <code>"laplace"</code> for a Laplace approximation (only available
when using cmdstanr as the backend) or <code>"pathfinder"</code> for the pathfinder
algorithm (only currently available when using cmdstanr as the backend).
Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Limited testing
suggests that <code>"meanfield"</code> performs best out of the non-MCMC approximations for
dynamic GAMs, possibly because of the difficulties estimating covariances among the
many spline parameters and latent trend parameters. But rigorous testing has not
been carried out</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_lfo">lfo</code></td>
<td>
<p>Logical indicating whether this is part of a call to <a href="#topic+lfo_cv.mvgam">lfo_cv.mvgam</a>. Returns a
lighter version of the model with no residuals and fewer monitored parameters to speed up
post-processing. But other downstream functions will not work properly, so users should always
leave this set as <code>FALSE</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+mvgam">mvgam</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object of class <code>mvgam</code> containing model output, the text representation of the model file,
the mgcv model output (for easily generating simulations at
unsampled covariate values), Dunn-Smyth residuals for each series and key information needed
for other functions in the package. See <code><a href="#topic+mvgam-class">mvgam-class</a></code> for details.
Use <code>methods(class = "mvgam")</code> for an overview on available methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a Poisson AR1 model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2)
summary(mod)
conditional_effects(mod, type = 'link')

# Update to an AR2 model
updated_mod &lt;- update(mod, trend_model = AR(p = 2),
                      noncentred = TRUE)
summary(updated_mod)
conditional_effects(updated_mod, type = 'link')

# Now update to a Binomial AR1 by adding information on trials
# requires that we supply newdata that contains the 'trials' variable
simdat$data_train$trials &lt;- max(simdat$data_train$y) + 15
updated_mod &lt;- update(mod,
                      formula = cbind(y, trials) ~ s(season, bs = 'cc'),
                      noncentred = TRUE,
                      data = simdat$data_train,
                      family = binomial())
summary(updated_mod)
conditional_effects(updated_mod, type = 'link')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
