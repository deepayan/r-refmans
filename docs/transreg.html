<!DOCTYPE html><html><head><title>Help for package transreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {transreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#transreg-package'><p>Penalised regression with multiple sets of prior effects</p></a></li>
<li><a href='#.residuals'><p>Calculate residuals</p></a></li>
<li><a href='#.signdisc'><p>Sign discovery</p></a></li>
<li><a href='#calibrate'><p>Internal functions</p></a></li>
<li><a href='#coef.transreg'><p>Extract Coefficients</p></a></li>
<li><a href='#compare'><p>Cross-validation (reproducibility)</p></a></li>
<li><a href='#extract'><p>Internal functions</p></a></li>
<li><a href='#fitted.transreg'><p>Fitted values</p></a></li>
<li><a href='#plot.transreg'><p>Plot transreg-object</p></a></li>
<li><a href='#predict.transreg'><p>Make Predictions</p></a></li>
<li><a href='#print.transreg'><p>Print transreg-object</p></a></li>
<li><a href='#simulate'><p>Simulation (reproducibility)</p></a></li>
<li><a href='#transreg'><p>Penalised regression with multiple sets of prior effects</p></a></li>
<li><a href='#weights.transreg'><p>Extract Weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Penalised Regression with Multiple Sets of Prior Effects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Improves the predictive performance of ridge and lasso regression exploiting one or more sources of prior information on the importance and direction of effects (Rauschenberger and others 2023, &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtad680">doi:10.1093/bioinformatics/btad680</a>&gt;). For running the vignette, install 'fwelnet' from 'GitHub' <a href="https://github.com/kjytay/fwelnet">https://github.com/kjytay/fwelnet</a>.</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, starnet, joinet</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown, mvtnorm</td>
</tr>
<tr>
<td>Enhances:</td>
<td>glmtrans, xrnet, ecpc, fwelnet, doMC, palasso, xtable,
devtools, CVXR</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lcsb-bds.github.io/transreg/">https://lcsb-bds.github.io/transreg/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-11 09:49:20 UTC; armin.rauschenberger</td>
</tr>
<tr>
<td>Author:</td>
<td>Armin Rauschenberger
    <a href="https://orcid.org/0000-0001-6498-4801"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Armin Rauschenberger &lt;armin.rauschenberger@uni.lu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-11 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='transreg-package'>Penalised regression with multiple sets of prior effects</h2><span id='topic+transreg-package'></span>

<h3>Description</h3>

<p>The R package <code>transreg</code> implements penalised regression
with multiple sets of prior effects.
</p>


<h3>Details</h3>

<p>Use function <code><a href="#topic+transreg">transreg()</a></code> for model fitting.
Type <code>library(transreg)</code> and then <code>?transreg</code> or
<code>help("transreg")</code> to open its help file.
</p>
<p>See the vignette for further examples.
Type <code>vignette("transreg")</code> or <code>browseVignettes("transreg")</code>
to open the vignette.
</p>


<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>,
<a href="https://orcid.org/0000-0002-2327-3904">Zied Landoulsi</a>,
<a href="https://orcid.org/0000-0003-4780-8472">Mark A. van de Wiel</a>,
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2023).
&quot;Penalised regression with multiple sets of prior effects&quot;.
<em>Bioinformatics (In press).</em>
<a href="https://doi.org/10.1093/bioinformatics/btad680">doi:10.1093/bioinformatics/btad680</a>
<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>?transreg
?predict.transreg
?coef.transreg

</code></pre>

<hr>
<h2 id='.residuals'>Calculate residuals</h2><span id='topic+.residuals'></span>

<h3>Description</h3>

<p>Calculates residuals from observed outcome
and predicted values (Gaussian family)
or predicted probabilities (binomial family).
Called by <code>.exp.multiple</code> and <code>.iso.multiple</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.residuals(y, y_hat, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".residuals_+3A_y">y</code></td>
<td>
<p>response: vector of length <code class="reqn">n</code> (see family)</p>
</td></tr>
<tr><td><code id=".residuals_+3A_y_hat">y_hat</code></td>
<td>
<p>predicted values or probabilities (see family):
vector of length <code class="reqn">n</code>,
or matrix with <code class="reqn">n</code> rows (samples) and <code class="reqn">k</code> columns (methods)</p>
</td></tr>
<tr><td><code id=".residuals_+3A_family">family</code></td>
<td>
<p>character
&quot;gaussian&quot; (<code class="reqn">y</code>: real numbers, <code class="reqn">y\_hat</code>: real numbers)
or &quot;binomial&quot; (<code class="reqn">y</code>: 0s and 1s, <code class="reqn">y\_hat</code>: unit interval)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 5
X &lt;- matrix(stats::rnorm(n*p),nrow=n,ncol=p)
#y &lt;- stats::rbinom(n,size=1,prob=0.5)
y &lt;- stats::rnorm(n)
glm &lt;- glm(y~X,family="gaussian")
res &lt;- residuals.glm(glm)
y_hat &lt;- predict(glm,type="response")
all.equal(res,y-y_hat)

</code></pre>

<hr>
<h2 id='.signdisc'>Sign discovery</h2><span id='topic+.signdisc'></span>

<h3>Description</h3>

<p>Assigns signs to prior weights to obtain prior coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.signdisc(y, X, prior, family, foldid = NULL, nfolds = 10, track = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".signdisc_+3A_y">y</code></td>
<td>
<p>target: vector of length <code class="reqn">n</code> (see <code>family</code>)</p>
</td></tr>
<tr><td><code id=".signdisc_+3A_x">X</code></td>
<td>
<p>features: matrix with <code class="reqn">n</code> rows (samples)
and <code class="reqn">p</code> columns (features)</p>
</td></tr>
<tr><td><code id=".signdisc_+3A_prior">prior</code></td>
<td>
<p>prior coefficients: matrix with <code class="reqn">p</code> rows (features)
and <code class="reqn">k</code> columns (sources of co-data)</p>
</td></tr>
<tr><td><code id=".signdisc_+3A_family">family</code></td>
<td>
<p>character &quot;gaussian&quot; (<code class="reqn">y</code>: real numbers),
&quot;binomial&quot; (<code class="reqn">y</code>: 0s and 1s),
or &quot;poisson&quot; (<code class="reqn">y</code>: non-negative integers);</p>
</td></tr>
<tr><td><code id=".signdisc_+3A_foldid">foldid</code></td>
<td>
<p>fold identifiers: vector of length <code class="reqn">n</code>
with entries from 1 to <code>nfolds</code></p>
</td></tr>
<tr><td><code id=".signdisc_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds: positive integer</p>
</td></tr>
<tr><td><code id=".signdisc_+3A_track">track</code></td>
<td>
<p>show intermediate output (messages and plots): logical</p>
</td></tr>
</table>

<hr>
<h2 id='calibrate'>Internal functions</h2><span id='topic+calibrate'></span><span id='topic+.exp.multiple'></span><span id='topic+.iso.multiple'></span><span id='topic+.iso.fast.single'></span><span id='topic+.iso.slow.single'></span>

<h3>Description</h3>

<p>Internal functions called by
<code><a href="#topic+transreg">transreg()</a></code>,
depending on choice between
exponential and isotonic calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.exp.multiple(
  y,
  X,
  prior,
  family,
  switch = FALSE,
  select = TRUE,
  track = FALSE
)

.iso.multiple(
  y,
  X,
  prior,
  family,
  switch = FALSE,
  select = TRUE,
  track = FALSE
)

.iso.fast.single(y, X, prior, family)

.iso.slow.single(y, X, prior, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_+3A_y">y</code></td>
<td>
<p>target: vector of length <code class="reqn">n</code> (see <code>family</code>)</p>
</td></tr>
<tr><td><code id="calibrate_+3A_x">X</code></td>
<td>
<p>features: matrix with <code class="reqn">n</code> rows (samples)
and <code class="reqn">p</code> columns (features)</p>
</td></tr>
<tr><td><code id="calibrate_+3A_prior">prior</code></td>
<td>
<p>prior coefficients: matrix with <code class="reqn">p</code> rows (features)
and <code class="reqn">k</code> columns (sources of co-data)</p>
</td></tr>
<tr><td><code id="calibrate_+3A_family">family</code></td>
<td>
<p>character &quot;gaussian&quot; (<code class="reqn">y</code>: real numbers),
&quot;binomial&quot; (<code class="reqn">y</code>: 0s and 1s),
or &quot;poisson&quot; (<code class="reqn">y</code>: non-negative integers);</p>
</td></tr>
<tr><td><code id="calibrate_+3A_switch">switch</code></td>
<td>
<p>choose between positive and negative weights for each source: logical</p>
</td></tr>
<tr><td><code id="calibrate_+3A_select">select</code></td>
<td>
<p>select from sources: logical</p>
</td></tr>
<tr><td><code id="calibrate_+3A_track">track</code></td>
<td>
<p>show intermediate output (messages and plots): logical</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>.exp.multiple()</code>: called by <code>transreg</code> if <code>scale="exp"</code>
</p>
</li>
<li> <p><code>.iso.multiple()</code>: called by <code>transreg</code> if <code>scale="iso"</code>
</p>
</li>
<li> <p><code>.iso.fast.single()</code>: called by <code>transreg</code> if <code>scale="iso"</code> (via <code>.iso.multiple</code>)
</p>
</li>
<li> <p><code>.iso.slow.single()</code>: replaced by <code>.iso.fast.single</code>
</p>
</li></ul>


<h3>See Also</h3>

<p>Use <code><a href="#topic+transreg">transreg()</a></code> for model fitting.
</p>

<hr>
<h2 id='coef.transreg'>Extract Coefficients</h2><span id='topic+coef.transreg'></span>

<h3>Description</h3>

<p>Extracts coefficients
from an object of class <a href="#topic+transreg">transreg</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transreg'
coef(object, stack = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.transreg_+3A_object">object</code></td>
<td>
<p>object of class <code>transreg</code></p>
</td></tr>
<tr><td><code id="coef.transreg_+3A_stack">stack</code></td>
<td>
<p>character &quot;sta&quot; (standard stacking) or &quot;sim&quot; (simultaneous stacking)</p>
</td></tr>
<tr><td><code id="coef.transreg_+3A_...">...</code></td>
<td>
<p>(not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns estimated coefficients.
The output is a list with two slots:
slot <code>alpha</code> with the estimated intercept (scalar),
and slot <code>beta</code> with the estimated slopes (vector).
</p>


<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>,
<a href="https://orcid.org/0000-0002-2327-3904">Zied Landoulsi</a>,
<a href="https://orcid.org/0000-0003-4780-8472">Mark A. van de Wiel</a>,
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2023).
&quot;Penalised regression with multiple sets of prior effects&quot;.
<em>Bioinformatics (In press).</em>
<a href="https://doi.org/10.1093/bioinformatics/btad680">doi:10.1093/bioinformatics/btad680</a>
<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>
</p>


<h3>See Also</h3>

<p>Methods for objects of class <a href="#topic+transreg">transreg</a>
include <code><a href="#topic+coef.transreg">coef</a></code>
and <code><a href="#topic+predict.transreg">predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- simulation ---
set.seed(1)
n &lt;- 100; p &lt;- 500
X &lt;- matrix(rnorm(n=n*p),nrow=n,ncol=p)
beta &lt;- rnorm(p)
prior &lt;- beta + rnorm(p)
y &lt;- X %*% beta

#--- glmnet (without prior effects) ---
object &lt;- glmnet::cv.glmnet(y=y,x=X,alpha=0)
beta_hat &lt;- coef(object,s="lambda.min")[-1]
mean((beta-beta_hat)^2)

#--- transreg (with prior effects) ---
object &lt;- transreg(y=y,X=X,prior=prior,alpha=0)
beta_hat &lt;- coef(object)$beta
mean((beta-beta_hat)^2) # decrease in MSE?

</code></pre>

<hr>
<h2 id='compare'>Cross-validation (reproducibility)</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Function for reproducing hold-out method (simulation)
and <code class="reqn">k</code>-fold cross-validation (application).
See vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(
  target,
  source = NULL,
  prior = NULL,
  z = NULL,
  family,
  alpha,
  scale = "iso",
  sign = FALSE,
  switch = FALSE,
  select = TRUE,
  foldid.ext = NULL,
  nfolds.ext = 10,
  foldid.int = NULL,
  nfolds.int = 10,
  type.measure = "deviance",
  alpha.prior = NULL,
  naive = TRUE,
  seed = NULL,
  cores = 1,
  xrnet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_target">target</code></td>
<td>
<p>list with slot x (feature matrix with n rows and p columns) and slot y (target vector of length n)</p>
</td></tr>
<tr><td><code id="compare_+3A_source">source</code></td>
<td>
<p>list of k lists, each with slot x (feature matrix with m_i rows and p columns) and slot y (target vector of length m_i)</p>
</td></tr>
<tr><td><code id="compare_+3A_prior">prior</code></td>
<td>
<p>prior coefficients: matrix with <code class="reqn">p</code> rows (features)
and <code class="reqn">k</code> columns (sources of co-data)</p>
</td></tr>
<tr><td><code id="compare_+3A_z">z</code></td>
<td>
<p>prior weights</p>
</td></tr>
<tr><td><code id="compare_+3A_family">family</code></td>
<td>
<p>character &quot;gaussian&quot; (<code class="reqn">y</code>: real numbers),
&quot;binomial&quot; (<code class="reqn">y</code>: 0s and 1s),
or &quot;poisson&quot; (<code class="reqn">y</code>: non-negative integers);</p>
</td></tr>
<tr><td><code id="compare_+3A_alpha">alpha</code></td>
<td>
<p>elastic net mixing parameter (0=ridge, 1=lasso):
number between 0 and 1</p>
</td></tr>
<tr><td><code id="compare_+3A_scale">scale</code></td>
<td>
<p>character
&quot;exp&quot; for exponential calibration or
&quot;iso&quot; for isotonic calibration</p>
</td></tr>
<tr><td><code id="compare_+3A_sign">sign</code></td>
<td>
<p>sign discovery procedure: logical
(experimental argument)</p>
</td></tr>
<tr><td><code id="compare_+3A_switch">switch</code></td>
<td>
<p>choose between positive and negative weights for each source: logical</p>
</td></tr>
<tr><td><code id="compare_+3A_select">select</code></td>
<td>
<p>select from sources: logical</p>
</td></tr>
<tr><td><code id="compare_+3A_foldid.ext">foldid.ext</code></td>
<td>
<p>external fold identifiers</p>
</td></tr>
<tr><td><code id="compare_+3A_nfolds.ext">nfolds.ext</code></td>
<td>
<p>number of external folds</p>
</td></tr>
<tr><td><code id="compare_+3A_foldid.int">foldid.int</code></td>
<td>
<p>internal fold identifiers</p>
</td></tr>
<tr><td><code id="compare_+3A_nfolds.int">nfolds.int</code></td>
<td>
<p>number of internal folds</p>
</td></tr>
<tr><td><code id="compare_+3A_type.measure">type.measure</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="compare_+3A_alpha.prior">alpha.prior</code></td>
<td>
<p>alpha for source regression</p>
</td></tr>
<tr><td><code id="compare_+3A_naive">naive</code></td>
<td>
<p>compare with naive transfer learning: logical</p>
</td></tr>
<tr><td><code id="compare_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="compare_+3A_cores">cores</code></td>
<td>
<p>number of cores for parallel computing
(requires R package <code>doMC</code>)</p>
</td></tr>
<tr><td><code id="compare_+3A_xrnet">xrnet</code></td>
<td>
<p>compare with xrnet: logical</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+transreg">transreg()</a></code>
</p>

<hr>
<h2 id='extract'>Internal functions</h2><span id='topic+extract'></span><span id='topic+.predict.sta'></span><span id='topic+.predict.sim'></span><span id='topic+.coef.sta'></span><span id='topic+.coef.sim'></span><span id='topic+.weights.sta'></span><span id='topic+.weights.sim'></span><span id='topic+.which.stack'></span>

<h3>Description</h3>

<p>Internal functions called by
<code><a href="#topic+coef.transreg">coef.transreg()</a></code>, <code><a href="#topic+predict.transreg">predict.transreg()</a></code> and <code><a href="#topic+weights.transreg">weights.transreg()</a></code>,
depending on choice between
standard stacking
and simultaneous stacking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.predict.sta(object, newx, ...)

.predict.sim(object, newx, ...)

.coef.sta(object, ...)

.coef.sim(object, ...)

.weights.sta(object, ...)

.weights.sim(object, ...)

.which.stack(object, stack)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_object">object</code></td>
<td>
<p>object of class <code>transreg</code></p>
</td></tr>
<tr><td><code id="extract_+3A_newx">newx</code></td>
<td>
<p>features:
matrix with <code class="reqn">n</code> rows (samples) and <code class="reqn">p</code> columns (variables)</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>(not applicable)</p>
</td></tr>
<tr><td><code id="extract_+3A_stack">stack</code></td>
<td>
<p>character &quot;sta&quot; (standard stacking) or &quot;sim&quot; (simultaneous stacking)</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>.predict.sta()</code>: called by <code>predict.transreg</code> if <code>stack="sta"</code>
</p>
</li>
<li> <p><code>.predict.sim()</code>: called by <code>predict.transreg</code> if <code>stack="sim"</code>
</p>
</li>
<li> <p><code>.coef.sta()</code>: called by <code>coef.transreg</code> if <code>stack="sta"</code>
</p>
</li>
<li> <p><code>.coef.sim()</code>: called by <code>coef.transreg</code> if <code>stack="sim"</code>
</p>
</li>
<li> <p><code>.weights.sta()</code>: called by <code>weights.transreg</code> if <code>stack="sta"</code>
</p>
</li>
<li> <p><code>.weights.sim()</code>: called by <code>weights.transreg</code> if <code>stack="sim"</code>
</p>
</li>
<li> <p><code>.which.stack()</code>: called by <code>coef.transreg</code>, <code>predict.transreg</code> and <code>weights.transreg</code>
</p>
</li></ul>


<h3>See Also</h3>

<p>Use <code><a href="#topic+coef.transreg">coef</a></code>,
<code><a href="#topic+predict.transreg">predict</a></code>
and <code><a href="#topic+weights.transreg">weights</a></code>.
</p>

<hr>
<h2 id='fitted.transreg'>Fitted values</h2><span id='topic+fitted.transreg'></span>

<h3>Description</h3>

<p>Extracts fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transreg'
fitted(object, stack = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.transreg_+3A_object">object</code></td>
<td>
<p>object of class <code>transreg</code></p>
</td></tr>
<tr><td><code id="fitted.transreg_+3A_stack">stack</code></td>
<td>
<p>character &quot;sta&quot; (standard stacking) or &quot;sim&quot; (simultaneous stacking)</p>
</td></tr>
<tr><td><code id="fitted.transreg_+3A_...">...</code></td>
<td>
<p>(not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns fitted values.
The output is a numerical vector
with one entry for sample.
</p>


<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>,
<a href="https://orcid.org/0000-0002-2327-3904">Zied Landoulsi</a>,
<a href="https://orcid.org/0000-0003-4780-8472">Mark A. van de Wiel</a>,
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2023).
&quot;Penalised regression with multiple sets of prior effects&quot;.
<em>Bioinformatics (In press).</em>
<a href="https://doi.org/10.1093/bioinformatics/btad680">doi:10.1093/bioinformatics/btad680</a>
<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>
</p>


<h3>See Also</h3>

<p>Methods for objects of class <a href="#topic+transreg">transreg</a>
include <code><a href="#topic+coef.transreg">coef</a></code>
and <code><a href="#topic+predict.transreg">predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- simulation ---
set.seed(1)
n0 &lt;- 100; n1 &lt;- 10000; n &lt;- n0 + n1; p &lt;- 500
X &lt;- matrix(rnorm(n=n*p),nrow=n,ncol=p)
beta &lt;- rnorm(p)
prior &lt;- beta + rnorm(p)
y &lt;- X %*% beta

#--- train-test split ---
foldid &lt;- rep(c(0,1),times=c(n0,n1))
y0 &lt;- y[foldid==0]
X0 &lt;- X[foldid==0,]
y1 &lt;- y[foldid==1]
X1 &lt;- X[foldid==1,]

object &lt;- transreg(y=y0,X=X0,prior=prior)

#--- fitted values ---
y0_hat &lt;- fitted(object)
mean((y0-y0_hat)^2)

#--- predicted values ---
y1_hat &lt;- predict(object,newx=X1)
mean((y1-y1_hat)^2) # increase in MSE?

</code></pre>

<hr>
<h2 id='plot.transreg'>Plot transreg-object</h2><span id='topic+plot.transreg'></span>

<h3>Description</h3>

<p>Plot transreg-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transreg'
plot(x, stack = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.transreg_+3A_x">x</code></td>
<td>
<p>object of type transreg</p>
</td></tr>
<tr><td><code id="plot.transreg_+3A_stack">stack</code></td>
<td>
<p>character &quot;sta&quot; (standard stacking) or &quot;sim&quot; (simultaneous stacking)</p>
</td></tr>
<tr><td><code id="plot.transreg_+3A_...">...</code></td>
<td>
<p>(not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns four plots.
</p>

<ul>
<li><p> top-left:
Calibrated prior effects (<code class="reqn">y</code>-axis) against
original prior effects (<code class="reqn">x</code>-axis).
Each line is for one source of prior effects,
with the colour given by <code><a href="grDevices.html#topic+palette">grDevices::palette()</a></code>
(black: 1, red: 2, green: 3, blue: 4, ...).
</p>
</li>
<li><p> top-right:
Estimated coefficients with transfer learning (<code class="reqn">y</code>-axis)
against estimated coefficients without transfer learning (<code class="reqn">x</code>-axis).
Each point represents one feature.
</p>
</li>
<li><p> bottom-left:
Estimated weights for sources of prior effects
(labels 1 to <code class="reqn">k</code>),
and either
estimated weights for <code>lambda.min</code> and <code>lambda.1se</code> models
(standard stacking)
or estimated weights for features
(simultaneous stacking).
</p>
</li>
<li><p> bottom-right:
Absolute deviance residuals (<code class="reqn">y</code>-axis)
against fitted values (<code class="reqn">x</code>-axis).
Each point represents one sample.
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>,
<a href="https://orcid.org/0000-0002-2327-3904">Zied Landoulsi</a>,
<a href="https://orcid.org/0000-0003-4780-8472">Mark A. van de Wiel</a>,
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2023).
&quot;Penalised regression with multiple sets of prior effects&quot;.
<em>Bioinformatics (In press).</em>
<a href="https://doi.org/10.1093/bioinformatics/btad680">doi:10.1093/bioinformatics/btad680</a>
<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>
</p>


<h3>See Also</h3>

<p>Methods for objects of class <a href="#topic+transreg">transreg</a>
include <code><a href="#topic+coef.transreg">coef</a></code>
and <code><a href="#topic+predict.transreg">predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- simulation ---
set.seed(1)
n &lt;- 100; p &lt;- 500
X &lt;- matrix(rnorm(n=n*p),nrow=n,ncol=p)
beta &lt;- rnorm(p) #*rbinom(n=n,size=1,prob=0.2)
prior1 &lt;- beta + rnorm(p)
prior2 &lt;- beta + rnorm(p)
prior3 &lt;- rnorm(p)
prior4 &lt;- rnorm(p)
y &lt;- X %*% beta

prior &lt;- cbind(prior1,prior2,prior3,prior4)
object &lt;- transreg(y=y,X=X,prior=prior,alpha=0,stack=c("sta","sim"))

plot(object,stack="sta")

</code></pre>

<hr>
<h2 id='predict.transreg'>Make Predictions</h2><span id='topic+predict.transreg'></span>

<h3>Description</h3>

<p>Predicts outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transreg'
predict(object, newx, stack = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.transreg_+3A_object">object</code></td>
<td>
<p>object of class <code>transreg</code></p>
</td></tr>
<tr><td><code id="predict.transreg_+3A_newx">newx</code></td>
<td>
<p>features:
matrix with <code class="reqn">n</code> rows (samples) and <code class="reqn">p</code> columns (variables)</p>
</td></tr>
<tr><td><code id="predict.transreg_+3A_stack">stack</code></td>
<td>
<p>character &quot;sta&quot; (standard stacking) or &quot;sim&quot; (simultaneous stacking)</p>
</td></tr>
<tr><td><code id="predict.transreg_+3A_...">...</code></td>
<td>
<p>(not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns predicted values or predicted probabilities.
The output is a column vector with one entry for each sample.
</p>


<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>,
<a href="https://orcid.org/0000-0002-2327-3904">Zied Landoulsi</a>,
<a href="https://orcid.org/0000-0003-4780-8472">Mark A. van de Wiel</a>,
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2023).
&quot;Penalised regression with multiple sets of prior effects&quot;.
<em>Bioinformatics (In press).</em>
<a href="https://doi.org/10.1093/bioinformatics/btad680">doi:10.1093/bioinformatics/btad680</a>
<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>
</p>


<h3>See Also</h3>

<p>Methods for objects of class <a href="#topic+transreg">transreg</a>
include <code><a href="#topic+coef.transreg">coef</a></code>
and <code><a href="#topic+predict.transreg">predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- simulation ---
set.seed(1)
n0 &lt;- 100; n1 &lt;- 10000; n &lt;- n0 + n1; p &lt;- 500
X &lt;- matrix(rnorm(n=n*p),nrow=n,ncol=p)
beta &lt;- rnorm(p)
prior &lt;- beta + rnorm(p)
y &lt;- X %*% beta

#--- train-test split ---
foldid &lt;- rep(c(0,1),times=c(n0,n1))
y0 &lt;- y[foldid==0]
X0 &lt;- X[foldid==0,]
y1 &lt;- y[foldid==1]
X1 &lt;- X[foldid==1,]

#--- glmnet (without prior effects) ---
object &lt;- glmnet::cv.glmnet(y=y0,x=X0)
y_hat &lt;- predict(object,newx=X1,s="lambda.min")
mean((y1-y_hat)^2)

#--- transreg (with prior effects) ---
object &lt;- transreg(y=y0,X=X0,prior=prior)
y_hat &lt;- predict(object,newx=X1)
mean((y1-y_hat)^2) # decrease in MSE?

</code></pre>

<hr>
<h2 id='print.transreg'>Print transreg-object</h2><span id='topic+print.transreg'></span>

<h3>Description</h3>

<p>Show summary of transreg-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transreg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.transreg_+3A_x">x</code></td>
<td>
<p>object of class transreg</p>
</td></tr>
<tr><td><code id="print.transreg_+3A_...">...</code></td>
<td>
<p>(not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns family of distributions,
elastic net mixing parameter (<code class="reqn">alpha</code>),
number of samples (<code class="reqn">n</code>),
number of features (<code class="reqn">p</code>),
number of sources of co-data (<code class="reqn">k</code>),
chosen calibration method (exponential or isotonic),
and chosen stacking method (standard or simultaneous).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- simulation ---
set.seed(1)
n &lt;- 100; p &lt;- 500
X &lt;- matrix(rnorm(n=n*p),nrow=n,ncol=p)
beta &lt;- rnorm(p)
prior &lt;- beta + rnorm(p)
y &lt;- X %*% beta

#--- print.transreg  ---
object &lt;- transreg(y=y,X=X,prior=prior)
object

</code></pre>

<hr>
<h2 id='simulate'>Simulation (reproducibility)</h2><span id='topic+simulate'></span>

<h3>Description</h3>

<p>Function for reproducing 'internal' simulation study.
See vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate(
  p = 1000,
  n.target = 100,
  n.source = 150,
  k = 2,
  family = "gaussian",
  prop = 0.01,
  rho.beta = 0.95,
  rho.x = 0.95,
  w = 0.5,
  trans = rep(TRUE, times = k),
  exp = rep(1, times = k)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_p">p</code></td>
<td>
<p>number of features</p>
</td></tr>
<tr><td><code id="simulate_+3A_n.target">n.target</code></td>
<td>
<p>sample size for target data set</p>
</td></tr>
<tr><td><code id="simulate_+3A_n.source">n.source</code></td>
<td>
<p>sample size(s) for source data set(s), scalar or vector of length k</p>
</td></tr>
<tr><td><code id="simulate_+3A_k">k</code></td>
<td>
<p>number of source data sets</p>
</td></tr>
<tr><td><code id="simulate_+3A_family">family</code></td>
<td>
<p>&quot;Gaussian&quot;, &quot;binomial&quot; or &quot;poisson&quot;</p>
</td></tr>
<tr><td><code id="simulate_+3A_prop">prop</code></td>
<td>
<p>approximate proportion of features with effects</p>
</td></tr>
<tr><td><code id="simulate_+3A_rho.beta">rho.beta</code></td>
<td>
<p>correlation between effects (across different data sets)</p>
</td></tr>
<tr><td><code id="simulate_+3A_rho.x">rho.x</code></td>
<td>
<p>base for decreasing correlation structure for correlation between features</p>
</td></tr>
<tr><td><code id="simulate_+3A_w">w</code></td>
<td>
<p>weight between signal and noise</p>
</td></tr>
<tr><td><code id="simulate_+3A_trans">trans</code></td>
<td>
<p>logical vector of length <code class="reqn">k</code>:
transferable (TRUE) or non-transferable (FALSE) source</p>
</td></tr>
<tr><td><code id="simulate_+3A_exp">exp</code></td>
<td>
<p>non-negative vector of length <code class="reqn">k</code>
for transforming beta to sign(beta)*abs(beta)^exp</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Use <code><a href="glmtrans.html#topic+models">glmtrans::models()</a></code> for reproducing 'external' simulation study.
</p>

<hr>
<h2 id='transreg'>Penalised regression with multiple sets of prior effects</h2><span id='topic+transreg'></span>

<h3>Description</h3>

<p>Implements penalised regression with multiple sets of prior effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transreg(
  y,
  X,
  prior,
  family = "gaussian",
  alpha = 1,
  foldid = NULL,
  nfolds = 10,
  scale = "iso",
  stack = "sim",
  sign = FALSE,
  switch = FALSE,
  select = TRUE,
  track = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transreg_+3A_y">y</code></td>
<td>
<p>target: vector of length <code class="reqn">n</code> (see <code>family</code>)</p>
</td></tr>
<tr><td><code id="transreg_+3A_x">X</code></td>
<td>
<p>features: matrix with <code class="reqn">n</code> rows (samples)
and <code class="reqn">p</code> columns (features)</p>
</td></tr>
<tr><td><code id="transreg_+3A_prior">prior</code></td>
<td>
<p>prior coefficients: matrix with <code class="reqn">p</code> rows (features)
and <code class="reqn">k</code> columns (sources of co-data)</p>
</td></tr>
<tr><td><code id="transreg_+3A_family">family</code></td>
<td>
<p>character &quot;gaussian&quot; (<code class="reqn">y</code>: real numbers),
&quot;binomial&quot; (<code class="reqn">y</code>: 0s and 1s),
or &quot;poisson&quot; (<code class="reqn">y</code>: non-negative integers);</p>
</td></tr>
<tr><td><code id="transreg_+3A_alpha">alpha</code></td>
<td>
<p>elastic net mixing parameter (0=ridge, 1=lasso):
number between 0 and 1</p>
</td></tr>
<tr><td><code id="transreg_+3A_foldid">foldid</code></td>
<td>
<p>fold identifiers: vector of length <code class="reqn">n</code>
with entries from 1 to <code>nfolds</code></p>
</td></tr>
<tr><td><code id="transreg_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds: positive integer</p>
</td></tr>
<tr><td><code id="transreg_+3A_scale">scale</code></td>
<td>
<p>character
&quot;exp&quot; for exponential calibration or
&quot;iso&quot; for isotonic calibration</p>
</td></tr>
<tr><td><code id="transreg_+3A_stack">stack</code></td>
<td>
<p>character &quot;sta&quot; (standard stacking) or &quot;sim&quot; (simultaneous stacking)</p>
</td></tr>
<tr><td><code id="transreg_+3A_sign">sign</code></td>
<td>
<p>sign discovery procedure: logical
(experimental argument)</p>
</td></tr>
<tr><td><code id="transreg_+3A_switch">switch</code></td>
<td>
<p>choose between positive and negative weights for each source: logical</p>
</td></tr>
<tr><td><code id="transreg_+3A_select">select</code></td>
<td>
<p>select from sources: logical</p>
</td></tr>
<tr><td><code id="transreg_+3A_track">track</code></td>
<td>
<p>show intermediate output (messages and plots): logical</p>
</td></tr>
<tr><td><code id="transreg_+3A_parallel">parallel</code></td>
<td>
<p>logical (see cv.glmnet)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code class="reqn">n</code>: sample size
</p>
</li>
<li> <p><code class="reqn">p</code>: number of features
</p>
</li>
<li> <p><code class="reqn">k</code>: number of sources
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>transreg</code>.
Rather than accessing its slots (see list below),
it is recommended to use methods like
<code><a href="#topic+coef.transreg">coef.transreg()</a></code> and <code><a href="#topic+predict.transreg">predict.transreg()</a></code>.
</p>

<ul>
<li><p> slot <code>base</code>:
Object of class <code>glmnet</code>.
Regression of outcome on features (without prior effects),
with <code class="reqn">1 + p</code> estimated coefficients
(intercept + features).
</p>
</li>
<li><p> slot <code>meta.sta</code>:
<code>NULL</code> or object of class <code>glmnet</code>.
Regression of outcome on cross-validated linear predictors
from prior effects and estimated effects,
with <code class="reqn">1 + k + 2</code> estimated coefficients
(intercept + sources of co-data + lambda_min and lambda_1se).
</p>
</li>
<li><p> slot <code>meta.sim</code>:
<code>NULL</code> or object of class <code>glmnet</code>.
Regression of outcome on meta-features
(cross-validated linear predictors from prior effects)
and original features,
with <code class="reqn">1 + k + p</code> estimated coefficients
(intercept + sources of co-data + features).
</p>
</li>
<li><p> slot <code>prior.calib</code>:
Calibrated prior effects.
Matrix with <code class="reqn">p</code> rows and <code class="reqn">k</code> columns.
</p>
</li>
<li><p> slot <code>data</code>:
Original data.
List with slots <code>y</code>, <code>X</code> and <code>prior</code> (see arguments).
</p>
</li>
<li><p> slot <code>info</code>:
Information on call.
Data frame with entries
<code class="reqn">n</code>, <code class="reqn">p</code>, <code class="reqn">k</code>, <code>family</code>, <code>alpha</code>, <code>scale</code> and <code>stack</code>
(see details and arguments).
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>,
<a href="https://orcid.org/0000-0002-2327-3904">Zied Landoulsi</a>,
<a href="https://orcid.org/0000-0003-4780-8472">Mark A. van de Wiel</a>,
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2023).
&quot;Penalised regression with multiple sets of prior effects&quot;.
<em>Bioinformatics (In press).</em>
<a href="https://doi.org/10.1093/bioinformatics/btad680">doi:10.1093/bioinformatics/btad680</a>
<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>
</p>


<h3>See Also</h3>

<p>Methods for objects of class <a href="#topic+transreg">transreg</a>
include <code><a href="#topic+coef.transreg">coef</a></code>
and <code><a href="#topic+predict.transreg">predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- simulation ---
n &lt;- 100; p &lt;- 500
X &lt;- matrix(rnorm(n=n*p),nrow=n,ncol=p)
beta &lt;- rnorm(p)*rbinom(n=p,size=1,prob=0.2)
prior1 &lt;- beta + rnorm(p)
prior2 &lt;- beta + rnorm(p)
y_lin &lt;- X %*% beta
y_log &lt;- 1*(y_lin &gt; 0)

#--- single vs multiple priors ---
one &lt;- transreg(y=y_lin,X=X,prior=prior1)
two &lt;- transreg(y=y_lin,X=X,prior=cbind(prior1,prior2))
weights(one)
weights(two)


#--- linear vs logistic regression ---
lin &lt;- transreg(y=y_lin,X=X,prior=prior1,family="gaussian")
log &lt;- transreg(y=y_log,X=X,prior=prior1,family="binomial")
hist(predict(lin,newx=X)) # predicted values
hist(predict(log,newx=X)) # predicted probabilities

#--- ridge vs lasso penalisation ---
ridge &lt;- transreg(y=y_lin,X=X,prior=prior1,alpha=0)
lasso &lt;- transreg(y=y_lin,X=X,prior=prior1,alpha=1)
# initial coefficients (without prior)
plot(x=coef(ridge$base)[-1]) # dense
plot(x=coef(lasso$base)[-1]) # sparse
# final coefficients (with prior)
plot(x=coef(ridge)$beta) # dense
plot(x=coef(lasso)$beta) # not sparse

#--- exponential vs isotonic calibration ---
exp &lt;- transreg(y=y_lin,X=X,prior=prior1,scale="exp")
iso &lt;- transreg(y=y_lin,X=X,prior=prior1,scale="iso")
plot(x=prior1,y=exp$prior.calib)
plot(x=prior1,y=iso$prior.calib)

#--- standard vs simultaneous stacking ---
prior &lt;- c(prior1[1:250],rep(0,250))
sta &lt;- transreg(y=y_lin,X=X,prior=prior,stack="sta")
sim &lt;- transreg(y=y_lin,X=X,prior=prior,stack="sim")
plot(x=coef(sta$base)[-1],y=coef(sta)$beta)
plot(x=coef(sim$base)[-1],y=coef(sim)$beta)

</code></pre>

<hr>
<h2 id='weights.transreg'>Extract Weights</h2><span id='topic+weights.transreg'></span>

<h3>Description</h3>

<p>Extracts weights from an object of class <a href="#topic+transreg">transreg</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transreg'
weights(object, stack = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights.transreg_+3A_object">object</code></td>
<td>
<p>object of class <code>transreg</code></p>
</td></tr>
<tr><td><code id="weights.transreg_+3A_stack">stack</code></td>
<td>
<p>character &quot;sta&quot; (standard stacking) or &quot;sim&quot; (simultaneous stacking)</p>
</td></tr>
<tr><td><code id="weights.transreg_+3A_...">...</code></td>
<td>
<p>(not applicable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns weights.
The output is a numerical vector
with one entry for each source of co-data.
</p>


<h3>References</h3>

<p><a href="https://orcid.org/0000-0001-6498-4801">Armin Rauschenberger</a>,
<a href="https://orcid.org/0000-0002-2327-3904">Zied Landoulsi</a>,
<a href="https://orcid.org/0000-0003-4780-8472">Mark A. van de Wiel</a>,
and
<a href="https://orcid.org/0000-0003-3977-7469">Enrico Glaab</a>
(2023).
&quot;Penalised regression with multiple sets of prior effects&quot;.
<em>Bioinformatics (In press).</em>
<a href="https://doi.org/10.1093/bioinformatics/btad680">doi:10.1093/bioinformatics/btad680</a>
<a href="mailto:armin.rauschenberger@uni.lu">armin.rauschenberger@uni.lu</a>
</p>


<h3>See Also</h3>

<p>This function is about weights for sources of prior effects.
To extract weights for features (estimated regression coefficients),
use <code><a href="stats.html#topic+coef">coef()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- simulation ---
set.seed(1)
n &lt;- 100; p &lt;- 500
X &lt;- matrix(rnorm(n=n*p),nrow=n,ncol=p)
beta &lt;- rnorm(p)
prior &lt;- cbind(beta+rnorm(p),beta+rnorm(p),rnorm(p),rnorm(p))
y &lt;- X %*% beta

#--- example ---
object &lt;- transreg(y=y,X=X,prior=prior)
weights(object)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
