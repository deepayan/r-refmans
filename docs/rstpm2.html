<!DOCTYPE html><html lang="en"><head><title>Help for package rstpm2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rstpm2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aft'>
<p>Parametric accelerated failure time model with smooth time functions</p></a></li>
<li><a href='#aft-class'><p>Class &quot;stpm2&quot; ~~~</p></a></li>
<li><a href='#bhazard'>
<p>Placemarker function for a baseline hazard function.</p></a></li>
<li><a href='#brcancer'>
<p>German breast cancer data from Stata.</p></a></li>
<li><a href='#coef+26lt+3B-'>
<p>Generic method to update the coef in an object.</p></a></li>
<li><a href='#colon'>
<p>Colon cancer.</p></a></li>
<li><a href='#cox.tvc'><p>Test for a time-varying effect in the <code>coxph</code> model</p></a></li>
<li><a href='#eform.stpm2'>
<p>S3 method for to provide exponentiated coefficents with confidence intervals.</p></a></li>
<li><a href='#grad'><p>gradient function (internal function)</p>
</a></li>
<li><a href='#gsm'>
<p>Parametric and penalised generalised survival models</p></a></li>
<li><a href='#gsm_design'><p>Extract design information from an stpm2/gsm object and newdata</p>
for use in C++</a></li>
<li><a href='#gsm.control'>
<p>Defaults for the gsm call</p></a></li>
<li><a href='#incrVar'>
<p>Utility that returns a function to increment a variable in a data-frame.</p></a></li>
<li><a href='#legendre.quadrature.rule.200'>
<p>Legendre quadrature rule for n=200.</p></a></li>
<li><a href='#lines.stpm2'>
<p>S3 methods for lines</p></a></li>
<li><a href='#markov_msm'>
<p>Predictions for continuous time, nonhomogeneous Markov multi-state</p>
models using parametric and penalised survival models.</a></li>
<li><a href='#markov_sde'>
<p>Predictions for continuous time, nonhomogeneous Markov multi-state</p>
models using Aalen's additive hazards models.</a></li>
<li><a href='#nsx'><p>Generate a Basis Matrix for Natural Cubic Splines (with eXtensions)</p></a></li>
<li><a href='#nsxD'><p>Generate a Basis Matrix for the first derivative of Natural Cubic Splines (with eXtensions)</p></a></li>
<li><a href='#numDeltaMethod'>
<p>Calculate numerical delta method for non-linear predictions.</p></a></li>
<li><a href='#plot-methods'><p> plots for an stpm2 fit</p></a></li>
<li><a href='#popmort'>
<p>Background mortality rates for the colon dataset.</p></a></li>
<li><a href='#predict-methods'><p> Predicted values for an stpm2 or pstpm2 fit</p></a></li>
<li><a href='#predict.nsx'><p>Evaluate a Spline Basis</p></a></li>
<li><a href='#predictnl'>
<p>Estimation of standard errors using the numerical delta method.</p></a></li>
<li><a href='#predictnl-methods'><p> ~~ Methods for Function predictnl  ~~</p></a></li>
<li><a href='#pstpm2-class'><p>Class &quot;pstpm2&quot;</p></a></li>
<li><a href='#residuals-methods'><p>Residual values for an stpm2 or pstpm2 fit</p></a></li>
<li><a href='#rstpm2-internal'>
<p>Internal functions for the rstpm2 package.</p></a></li>
<li><a href='#simulate-methods'><p>Simulate values from an stpm2 or pstpm2 fit</p></a></li>
<li><a href='#smoothpwc'>
<p>Utility to use a smooth function in markov_msm based on piece-wise constant values</p></a></li>
<li><a href='#stpm2-class'><p>Class &quot;stpm2&quot; ~~~</p></a></li>
<li><a href='#tvcCoxph-class'><p>Class <code>"tvcCoxph"</code></p></a></li>
<li><a href='#update-methods'><p> Methods for Function update</p></a></li>
<li><a href='#voptimize'><p>Vectorised One Dimensional Optimization</p></a></li>
<li><a href='#vuniroot'><p>Vectorised One Dimensional Root (Zero) Finding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Smooth Survival Models, Including Generalized Survival Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.6.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), methods, survival, splines</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, Rcpp (&ge; 0.10.2), stats, mgcv, bbmle (&ge; 1.0.20),
fastGHQuad, utils, parallel, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>eha, testthat, ggplot2, lattice, readstata13, mstate, scales,
survPen, flexsurv, timereg, deSolve</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp,RcppArmadillo,BH</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Clements &lt;mark.clements@ki.se&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>R implementation of generalized survival models (GSMs), smooth accelerated failure time (AFT) models and Markov multi-state models. For the GSMs, g(S(t|x))=eta(t,x) for a link function g, survival S at time t with covariates x and a linear predictor eta(t,x). The main assumption is that the time effect(s) are smooth &lt;<a href="https://doi.org/10.1177%2F0962280216664760">doi:10.1177/0962280216664760</a>&gt;. For fully parametric models with natural splines, this re-implements Stata's 'stpm2' function, which are flexible parametric survival models developed by Royston and colleagues. We have extended the parametric models to include any smooth parametric smoothers for time. We have also extended the model to include any smooth penalized smoothers from the 'mgcv' package, using penalized likelihood. These models include left truncation, right censoring, interval censoring, gamma frailties and normal random effects &lt;<a href="https://doi.org/10.1002%2Fsim.7451">doi:10.1002/sim.7451</a>&gt;, and copulas. For the smooth AFTs, S(t|x) = S_0(t*eta(t,x)), where the baseline survival function S_0(t)=exp(-exp(eta_0(t))) is modelled for natural splines for eta_0, and the time-dependent cumulative acceleration factor eta(t,x)=\int_0^t exp(eta_1(u,x)) du for log acceleration factor eta_1(u,x). The Markov multi-state models allow for a range of models with smooth transitions to predict transition probabilities, length of stay, utilities and costs, with differences, ratios and standardisation.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mclements/rstpm2">https://github.com/mclements/rstpm2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mclements/rstpm2/issues">https://github.com/mclements/rstpm2/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-21 14:43:31 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Clements [aut, cre],
  Xing-Rong Liu [aut],
  Benjamin Christoffersen [aut],
  Paul Lambert [ctb],
  Lasse Hjort Jakobsen [ctb],
  Alessandro Gasparini [ctb],
  Gordon Smyth [cph],
  Patrick Alken [cph],
  Simon Wood [cph],
  Rhys Ulerich [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-21 16:08:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='aft'>
Parametric accelerated failure time model with smooth time functions
</h2><span id='topic+aft'></span>

<h3>Description</h3>

<p>This implements the accelerated failure time models S_0(t exp(beta x))
and S_0(int_0^t exp(beta x(u)) du). The baseline function S_0(t*) is
modelled as exp(-exp(eta_0(log(t*)))), where eta_0(log(t*)) is a linear
predictor using natural splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aft(formula, data, smooth.formula = NULL, df = 3,
    tvc = NULL, cure.formula = ~1, control = list(),
    init = NULL, weights = NULL, tvc.intercept = TRUE,
    tvc.integrated = FALSE,
    timeVar = "", time0Var = "",
    cure = FALSE, mixture = FALSE, contrasts = NULL, subset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aft_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a <code>~</code> operator,
and the regression terms (excluding time) on the right. The response
should be a survival object as returned by the <code><a href="survival.html#topic+Surv">Surv</a></code>
function. The terms can include linear effects for any time-varying
coefficients. [required]
</p>
</td></tr>
<tr><td><code id="aft_+3A_data">data</code></td>
<td>

<p>a data-frame in which to interpret the variables named in the
<code>formula</code> argument. [at present: required]
</p>
</td></tr>
<tr><td><code id="aft_+3A_smooth.formula">smooth.formula</code></td>
<td>

<p>a formula for describing the time effects for the linear predictor,
excluding the baseline S_0(t*), but including time-dependent
acceleration factors. The time-dependent acceleration factors can be
modelled with any smooth functions.
</p>
</td></tr>
<tr><td><code id="aft_+3A_df">df</code></td>
<td>

<p>an integer that describes the degrees of freedom for the <code>ns</code>
function for modelling the baseline log-cumulative hazards function (default=3).
</p>
</td></tr>
<tr><td><code id="aft_+3A_tvc">tvc</code></td>
<td>

<p>a list with the names of the time-varying coefficients. This uses natural splines
(e.g. <code>tvc=list(hormon=3)</code> is equivalent to
<code>smooth.formula=~...+hormon:nsx(log(time),df=3)</code>), which by default
does <em>not</em> include an intercept (or main effect) term. 
</p>
</td></tr>
<tr><td><code id="aft_+3A_cure.formula">cure.formula</code></td>
<td>

<p>a formula for describing the cure fraction.
</p>
</td></tr>
<tr><td><code id="aft_+3A_control">control</code></td>
<td>

<p><code>control</code> argument passed to <code>optim</code>.
</p>
</td></tr>
<tr><td><code id="aft_+3A_init">init</code></td>
<td>

<p><code>init</code> should either be <code>FALSE</code>, such that initial
values will be determined using Cox regression, or a numeric
vector of initial values.
</p>
</td></tr>
<tr><td><code id="aft_+3A_weights">weights</code></td>
<td>

<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.
</p>
</td></tr>
<tr><td><code id="aft_+3A_tvc.intercept">tvc.intercept</code></td>
<td>

<p>logical for whether to include an intercept in the time-varying
acceleration factor (defaults to TRUE)
</p>
</td></tr>
<tr><td><code id="aft_+3A_tvc.integrated">tvc.integrated</code></td>
<td>

<p>logical for whether the time-varying
acceleration factor should be based on a integration, rather than a
cumulative effect (defaults to FALSE)
</p>
</td></tr>
<tr><td><code id="aft_+3A_timevar">timeVar</code></td>
<td>

<p>string variable defining the time variable. By default, this is
determined from the survival object, however this may be ambiguous if
two variables define the time.
</p>
</td></tr>
<tr><td><code id="aft_+3A_time0var">time0Var</code></td>
<td>

<p>string variable to determine the entry variable; useful
for when more than one data variable is used in the entry time.
</p>
</td></tr>
<tr><td><code id="aft_+3A_cure">cure</code></td>
<td>

<p>logical for whether to model for cure using a non-mixture model (default=FALSE)
</p>
</td></tr>
<tr><td><code id="aft_+3A_mixture">mixture</code></td>
<td>

<p>logical for whether to model for cure using a mixture model (default=FALSE)
</p>
</td></tr>
<tr><td><code id="aft_+3A_contrasts">contrasts</code></td>
<td>

<p>an optional list. See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.
</p>
</td></tr>
<tr><td><code id="aft_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to
be used in the fitting process.
</p>
</td></tr>
<tr><td><code id="aft_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to the <code><a href="bbmle.html#topic+mle2">mle2</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation extends the <code>mle2</code> object from the
<code>bbmle</code> package. The model inherits all of the methods from the
<code>mle2</code> class.
</p>


<h3>Value</h3>

<p>An <code>aft-class</code> object that inherits from <code>mle2-class</code>. 
</p>


<h3>Author(s)</h3>

<p>Mark Clements.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+survreg">survreg</a></code>, <code><a href="survival.html#topic+coxph">coxph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(aft(Surv(rectime,censrec==1)~hormon,data=brcancer,df=4))
</code></pre>

<hr>
<h2 id='aft-class'>Class &quot;stpm2&quot; ~~~ </h2><span id='topic+aft-class'></span><span id='topic+plot+2Caft+2Cmissing-method'></span><span id='topic+lines+2Caft-method'></span><span id='topic+predict+2Caft-method'></span><span id='topic+predictnl+2Caft-method'></span>

<h3>Description</h3>

<p>Regression object for <code>aft</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("aft", ...)</code> and
<code>aft( ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>args</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class for <code><a href="bbmle.html#topic+mle2">mle2</a></code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "aft", y = "missing")</code>: ... </p>
</dd>
<dt>lines</dt><dd><p><code>signature(x = "aft")</code>: ... </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "aft")</code>: ... </p>
</dd>
<dt>predictnl</dt><dd><p><code>signature(object = "aft", ...)</code>: ... </p>
</dd>

</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("aft")
</code></pre>

<hr>
<h2 id='bhazard'>
Placemarker function for a baseline hazard function. 
</h2><span id='topic+bhazard'></span>

<h3>Description</h3>

<p>Defined as the identity function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bhazard(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bhazard_+3A_x">x</code></td>
<td>

<p>Input (and output) value
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input value
</p>

<hr>
<h2 id='brcancer'>
German breast cancer data from Stata.
</h2><span id='topic+brcancer'></span>

<h3>Description</h3>

<p>See <a href="https://www.stata-press.com/data/r11/brcancer.dta">https://www.stata-press.com/data/r11/brcancer.dta</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(brcancer)</code></pre>


<h3>Format</h3>

<p>A data frame with 686 observations on the following 15 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>hormon</code></dt><dd><p>hormonal therapy</p>
</dd>
<dt><code>x1</code></dt><dd><p>age, years</p>
</dd>
<dt><code>x2</code></dt><dd><p>menopausal status</p>
</dd>
<dt><code>x3</code></dt><dd><p>tumour size, mm</p>
</dd>
<dt><code>x4</code></dt><dd><p>tumour grade</p>
</dd>
<dt><code>x5</code></dt><dd><p>number of positive nodes</p>
</dd>
<dt><code>x6</code></dt><dd><p>progesterone receptor, fmol</p>
</dd>
<dt><code>x7</code></dt><dd><p>estrogen receptor, fmol</p>
</dd>
<dt><code>rectime</code></dt><dd><p>recurrence free survival time, days</p>
</dd>
<dt><code>censrec</code></dt><dd><p>censoring indicator</p>
</dd>
<dt><code>x4a</code></dt><dd><p>tumour grade&gt;=2</p>
</dd>
<dt><code>x4b</code></dt><dd><p>tumour grade==3</p>
</dd>
<dt><code>x5e</code></dt><dd><p>exp(-0.12*x5)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(brcancer)
## maybe str(brcancer) ; plot(brcancer) ...
</code></pre>

<hr>
<h2 id='coef+26lt+3B-'>
Generic method to update the coef in an object.
</h2><span id='topic+coef+3C-'></span>

<h3>Description</h3>

<p>Generic method to update the coef in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef+2B26lt+2B3B-_+3A_x">x</code></td>
<td>

<p>object to be updated
</p>
</td></tr>
<tr><td><code id="coef+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>value of the coefficient to be updated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple generic method is used for the numerical delta method.
</p>


<h3>Value</h3>

<p>The updated object is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (x, value) 
UseMethod("coef&lt;-")
</code></pre>

<hr>
<h2 id='colon'>
Colon cancer.
</h2><span id='topic+colon'></span>

<h3>Description</h3>

<p>Diagnoses of colon cancer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(colon)</code></pre>


<h3>Format</h3>

<p>A data frame with 15564 observations on the following 13 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>Sex (1=male, 2=female))</p>
</dd>
<dt><code>age</code></dt><dd><p>Age at diagnosis</p>
</dd>
<dt><code>stage</code></dt><dd><p>Clinical stage at diagnosis  (1=Unknown,
2=Localised, 3=Regional, 4=Distant)</p>
</dd>
<dt><code>mmdx</code></dt><dd><p>Month of diagnosis</p>
</dd>
<dt><code>yydx</code></dt><dd><p>Year of diagnosis</p>
</dd>
<dt><code>surv_mm</code></dt><dd><p>Survival time in months</p>
</dd>
<dt><code>surv_yy</code></dt><dd><p>Survival time in years</p>
</dd>
<dt><code>status</code></dt><dd><p>Vital status at last contact (1=Alive,
2=Dead: cancer, 3=Dead; other, 4=Lost to follow-up)</p>
</dd>
<dt><code>subsite</code></dt><dd><p>Anatomical subsite of tumour (1=Coecum and
ascending, 2=Transverse, 3=Descending and sigmoid, 4=Other and NOS)</p>
</dd>
<dt><code>year8594</code></dt><dd><p>Year of diagnosis (1=Diagnosed 75-84, 2=Diagnosed
85-94)</p>
</dd>
<dt><code>agegrp</code></dt><dd><p>Age in 4 categories (1=0-44, 2=45-59, 3=60-74, 4=75+)</p>
</dd>
<dt><code>dx</code></dt><dd><p>Date of diagnosis</p>
</dd>
<dt><code>exit</code></dt><dd><p>Date of exit</p>
</dd>
</dl>



<h3>Details</h3>

<p>Caution: there is a <code>colon</code> dataset in the <code>survival</code>
package. We recommend using <code>data(colon,package="rstpm2")</code> to
ensure the correct dataset is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(colon,package="rstpm2") # avoids name conflict with survival::colon
## maybe str(colon) ; ...
</code></pre>

<hr>
<h2 id='cox.tvc'>Test for a time-varying effect in the <code>coxph</code> model</h2><span id='topic+cox.tvc'></span>

<h3>Description</h3>

<p>Test for a time-varying effect in the <code>coxph</code> model by re-fitting
the partial likelihood including a time-varying effect, plot 
the effect size, and return the re-fitted model. The
main advantage of this function over the <code>tt()</code> special is
that it scales well for moderate sized datasets
(cf. <code>tt</code> which expands the dataset and scales very poorly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.tvc(obj, var=NULL, method="logt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cox.tvc_+3A_obj">obj</code></td>
<td>
<p>A <code>coxph</code> object. Currently restricted to right
censoring with Breslow ties and without stratification, etc.</p>
</td></tr>
<tr><td><code id="cox.tvc_+3A_var">var</code></td>
<td>
<p>String for the effect name. Currently assumes simple
continuous effects.</p>
</td></tr>
<tr><td><code id="cox.tvc_+3A_method">method</code></td>
<td>
<p>A string representing the possible time
transformations. Currently only &quot;logt&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>tvcCoxph</code> object (which inherits from the <code>mle2</code> class) of the re-fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+coxph">coxph</a></code>, <code><a href="survival.html#topic+cox.zph">cox.zph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## As per the example for cox.zph:
fit &lt;- coxph(Surv(futime, fustat) ~ age + ecog.ps,  
             data=ovarian) 
temp &lt;- rstpm2:::cox.tvc(fit, "age") 
print(temp)                  # display the results 
plot(temp)                   # plot curves 
</code></pre>

<hr>
<h2 id='eform.stpm2'>
S3 method for to provide exponentiated coefficents with confidence intervals. 
</h2><span id='topic+eform'></span><span id='topic+eform.stpm2'></span><span id='topic+eform.default'></span>

<h3>Description</h3>

<p>S3 method for to provide exponentiated coefficents with confidence intervals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eform(object, ...)
## S3 method for class 'stpm2'
eform(object, parm, level = 0.95, method = c("Profile","Delta"),
    name = "exp(beta)", ...)
## Default S3 method:
eform(object, parm, level = 0.95, method =
c("Delta","Profile"), name = "exp(beta)", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eform.stpm2_+3A_object">object</code></td>
<td>

<p>regression object
</p>
</td></tr>
<tr><td><code id="eform.stpm2_+3A_parm">parm</code></td>
<td>

<p>not currently used
</p>
</td></tr>
<tr><td><code id="eform.stpm2_+3A_level">level</code></td>
<td>

<p>significance level for the confidence interval
</p>
</td></tr>
<tr><td><code id="eform.stpm2_+3A_method">method</code></td>
<td>

<p>method for confidence interval estimation
</p>
</td></tr>
<tr><td><code id="eform.stpm2_+3A_name">name</code></td>
<td>

<p>name for the fitted value
</p>
</td></tr>
<tr><td><code id="eform.stpm2_+3A_...">...</code></td>
<td>

<p>other arguments
</p>
</td></tr>
</table>

<hr>
<h2 id='grad'>gradient function (internal function)

</h2><span id='topic+grad'></span>

<h3>Description</h3>

<p>Numerical gradient for a function at a given value (internal).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad(func, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grad_+3A_func">func</code></td>
<td>

<p>Function taking a vector argument x (returns a vector of length&gt;=1)
</p>
</td></tr>
<tr><td><code id="grad_+3A_x">x</code></td>
<td>

<p>vector of arguments for where the gradient is wanted.
</p>
</td></tr>
<tr><td><code id="grad_+3A_...">...</code></td>
<td>

<p>other arguments to the function
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(func(x+delta,...)-func(x-delta,...))/(2 delta) where delta is the third root
of the machine precision times pmax(1,abs(x)).
</p>


<h3>Value</h3>

<p>A vector if func(x) has length 1, otherwise a matrix with rows for x
and columns for func(x).
</p>


<h3>Author(s)</h3>

<p>Mark Clements.
</p>


<h3>See Also</h3>

<p>numDelta()
</p>

<hr>
<h2 id='gsm'>
Parametric and penalised generalised survival models
</h2><span id='topic+gsm'></span><span id='topic+pstpm2'></span><span id='topic+stpm2'></span>

<h3>Description</h3>

<p>This implements the generalised survival model g(S(t|x)) = eta, where
g is a link function, S is survival, t is time, x are covariates and eta
is a linear predictor. The linear predictor can include either
parametric or penalised
smoothers for the time effects, for time:covariate interactions and for
covariate effects. The main model assumption is that the time
effects in the linear predictor are smooth. This extends the class of
flexible parametric survival models developed by Royston and
colleagues. The model has been extended to include relative survival
(excess hazards),
Gamma frailties and normal random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsm(formula, data, smooth.formula = NULL, smooth.args = NULL,
                df = 3, cure = FALSE,
                tvc = NULL, tvc.formula = NULL,
                control = list(), init = NULL,
                weights = NULL, robust = FALSE, baseoff = FALSE,
                timeVar = "", time0Var = "", use.gr = NULL,
                optimiser=NULL, log.time.transform=TRUE,
                reltol=NULL, trace = NULL,
                link.type=c("PH","PO","probit","AH","AO"), theta.AO=0,
                contrasts = NULL, subset = NULL,
                robust_initial=NULL,
                coxph.strata = NULL, coxph.formula = NULL,
                logH.formula = NULL, logH.args = NULL,
                bhazard = NULL, bhazinit=NULL, copula=FALSE,
                frailty = !is.null(cluster) &amp; !robust &amp; !copula,
                cluster = NULL, logtheta=NULL,
                nodes=NULL, RandDist=c("Gamma","LogN"), recurrent = FALSE,
                adaptive = NULL, maxkappa = NULL,
                sp=NULL, criterion=NULL, penalty=NULL,
                smoother.parameters=NULL, Z=~1, outer_optim=NULL,
                alpha=1, sp.init=1,
                penalised=FALSE,
                ...)
stpm2(formula, data, weights=NULL, subset=NULL, coxph.strata=NULL, ...)
pstpm2(formula, data, weights=NULL, subset=NULL, coxph.strata=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsm_+3A_formula">formula</code></td>
<td>

<p>a formula object, with the response on the left of a <code>~</code> operator, and
the parametric terms on the right.  The response must be a survival object as
returned by the <code><a href="survival.html#topic+Surv">Surv</a></code> function. Specials include
<code>cluster</code> and <code>bhazard</code>. [required]
</p>
</td></tr>
<tr><td><code id="gsm_+3A_data">data</code></td>
<td>

<p>a data.frame in which to interpret the variables named in
the <code>formula</code> argument.
</p>
</td></tr>
<tr><td><code id="gsm_+3A_smooth.formula">smooth.formula</code></td>
<td>

<p>either a parametric formula or a penalised <code>mgcv::gam</code> formula for
describing the time effects and
time-dependent effects and smoothed covariate effects on the linear
predictor scale
(default=NULL). The default model is equal to <code>~s(log(time),k=-1)</code>
where <code>time</code> is the time variable.
</p>
</td></tr>
<tr><td><code id="gsm_+3A_df">df</code></td>
<td>

<p>an integer that describes the degrees of freedom for the <code>ns</code>
function for modelling the baseline log-cumulative hazard
(default=3). Parametric model only.
</p>
</td></tr>
<tr><td><code id="gsm_+3A_smooth.args">smooth.args</code></td>
<td>

<p>a list describing the arguments for the <code>s</code> function for modelling
the baseline time effect on the linear predictor scale (default=NULL). 
</p>
</td></tr>
<tr><td><code id="gsm_+3A_tvc">tvc</code></td>
<td>

<p>a list with the names of the time-varying coefficients. For a parametric
model, this uses natural splines (e.g. <code>tvc=list(hormon=3)</code> is equivalent
to
<code>smooth.formula=~...+as.numeric(hormon):nsx(log(time),df=3)</code>), which by default
does <em>not</em> include an intercept term, hence you
should include a main effect. Note that
this will convert a logical or factor variable to a numeric value, so
the user should use indicators for factor terms. For a penalised
model, this uses cubic splines
(e.g. <code>tvc=list(hormon=-1)</code> is equivalent to
<code>smooth.formula=~...+s(log(time),by=hormon,k=-1))</code>, which by
default <em>does</em> include an intercept (or main effect) term (and this
code will remove any main effect from <code>formula</code>). 
</p>
</td></tr>
<tr><td><code id="gsm_+3A_tvc.formula">tvc.formula</code></td>
<td>

<p>separate formula for the time-varying effects. This is combined with
<code>smooth.formula</code> or the default <code>smooth.formula</code>.
</p>
</td></tr>
<tr><td><code id="gsm_+3A_baseoff">baseoff</code></td>
<td>
<p>Boolean used to determine whether fully define the model
using <code>tvc.formula</code> rather than combining <code>logH.formula</code> and <code>tvc.formula</code></p>
</td></tr>
<tr><td><code id="gsm_+3A_logh.args">logH.args</code></td>
<td>

<p>as per <code>smooth.args</code>. Deprecated.
</p>
</td></tr>
<tr><td><code id="gsm_+3A_logh.formula">logH.formula</code></td>
<td>

<p>as per <code>smooth.formula</code>. Deprecated.
</p>
</td></tr>
<tr><td><code id="gsm_+3A_cure">cure</code></td>
<td>
<p>logical for whether to estimate a cure model (parametric
model only).</p>
</td></tr>
<tr><td><code id="gsm_+3A_control">control</code></td>
<td>
<p>list of arguments passed to <code><a href="#topic+gsm.control">gsm.control</a></code>.</p>
</td></tr>
<tr><td><code id="gsm_+3A_init">init</code></td>
<td>
<p><code>init</code> should either be <code>NULL</code>, such that initial
values will be determined using Cox regression, or a numeric
vector of initial values.</p>
</td></tr>
<tr><td><code id="gsm_+3A_coxph.strata">coxph.strata</code></td>
<td>
<p>variable in the <code>data</code> argument for
stratification of the <code>coxph</code> model fit for estimating initial values.</p>
</td></tr>
<tr><td><code id="gsm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process. Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="gsm_+3A_robust">robust</code></td>
<td>
<p>Boolean used to determine whether to use a robust variance
estimator.</p>
</td></tr>
<tr><td><code id="gsm_+3A_bhazard">bhazard</code></td>
<td>
<p>variable for the baseline hazard for relative survival</p>
</td></tr>
<tr><td><code id="gsm_+3A_bhazinit">bhazinit</code></td>
<td>

<p>scalar used to adjust the background cumulative hazards for calculating
initial values. Default=0.1. Deprecated argument: use of the
<code>control</code> argument is preferred.
</p>
</td></tr>
<tr><td><code id="gsm_+3A_copula">copula</code></td>
<td>
<p>logical to indicate whether to use a copula model (experimental)</p>
</td></tr>
<tr><td><code id="gsm_+3A_timevar">timeVar</code></td>
<td>
<p>variable defining the time variable. By default, this is
determined from the survival object, however this may be ambiguous if
two variables define the time</p>
</td></tr>
<tr><td><code id="gsm_+3A_sp">sp</code></td>
<td>
<p>fix the value of the smoothing parameters.</p>
</td></tr>
<tr><td><code id="gsm_+3A_use.gr">use.gr</code></td>
<td>
<p>in R, a Boolean to determine whether to use the gradient
in the optimisation. Default=TRUE, Deprecated argument: use of the
<code>control</code> argument is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_criterion">criterion</code></td>
<td>
<p>in Rcpp, determine whether to use &quot;GCV&quot; or &quot;BIC&quot; for for the smoothing parameter selection.</p>
</td></tr>
<tr><td><code id="gsm_+3A_penalty">penalty</code></td>
<td>
<p>use either the &quot;logH&quot; penalty, which is the default
penalty from mgcv, or the &quot;h&quot; hazard penalty. Default=&quot;logH&quot;. Deprecated argument: use of the
<code>control</code> argument is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_smoother.parameters">smoother.parameters</code></td>
<td>
<p>for the hazard penalty, a list with components which are lists with components var, transform and inverse.</p>
</td></tr>
<tr><td><code id="gsm_+3A_alpha">alpha</code></td>
<td>
<p>an ad hoc tuning parameter for the smoothing parameter.</p>
</td></tr>
<tr><td><code id="gsm_+3A_sp.init">sp.init</code></td>
<td>
<p>initial values for the smoothing parameters.</p>
</td></tr>
<tr><td><code id="gsm_+3A_trace">trace</code></td>
<td>
<p>integer for trace reporting; 0 represents no additional
reporting. Default=0. Deprecated argument: use of the
<code>control</code> argument is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.
</p>
</td></tr>
<tr><td><code id="gsm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="gsm_+3A_coxph.formula">coxph.formula</code></td>
<td>
<p>additional formula used to improve the fitting of
initial values [optional and rarely used].</p>
</td></tr>
<tr><td><code id="gsm_+3A_time0var">time0Var</code></td>
<td>
<p>string variable to determine the entry variable; useful
for when more than one data variable is used in the entry time.</p>
</td></tr>
<tr><td><code id="gsm_+3A_link.type">link.type</code></td>
<td>
<p>type of link function. For &quot;PH&quot; (generalised
proportional hazards), g(S)=log(-log(S)); for
&quot;PO&quot; (generalised proportional odds), g(S)=-logit(S); for &quot;probit&quot;
(generalised probit), g(S)=-probit(S); for &quot;AH&quot; (generalised additive
hazards), g(S)=-log(S); for &quot;AO&quot; (generalised Aranda-Ordaz), g(S)=log((S^(-theta.AO)-1)/theta.AO).</p>
</td></tr>
<tr><td><code id="gsm_+3A_theta.ao">theta.AO</code></td>
<td>
<p>theta parameter for the Aranda-Ordaz link type.</p>
</td></tr>
<tr><td><code id="gsm_+3A_optimiser">optimiser</code></td>
<td>
<p>select which optimiser is used. Default=&quot;BFGS&quot;. Deprecated argument: use of the
<code>control</code> argument is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_log.time.transform">log.time.transform</code></td>
<td>
<p>should a log-transformation be used for
calculating the derivative of the design matrix with respect to time? (default=TRUE)</p>
</td></tr>
<tr><td><code id="gsm_+3A_recurrent">recurrent</code></td>
<td>
<p>logical for whether clustered, left truncated data are
recurrent or for first event (where the latter requires an adjustment
for the frailties or random effects)</p>
</td></tr>
<tr><td><code id="gsm_+3A_frailty">frailty</code></td>
<td>
<p>logical for whether to fit a shared frailty model</p>
</td></tr>
<tr><td><code id="gsm_+3A_cluster">cluster</code></td>
<td>
<p>variable that determines the cluster
for the frailty. This can be a vector, a string for the column, or a
name. This can also be specified using a special.</p>
</td></tr>
<tr><td><code id="gsm_+3A_logtheta">logtheta</code></td>
<td>
<p>initial value for log-theta used in the gamma shared frailty
model (defaults to value from a <code>coxph</code> model fit)</p>
</td></tr>
<tr><td><code id="gsm_+3A_nodes">nodes</code></td>
<td>
<p>number of integration points for Gaussian
quadrature. Default=9. Deprecated argument: use of the
<code>control</code> argument is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_randdist">RandDist</code></td>
<td>
<p>type of distribution for the random effect or frailty</p>
</td></tr>
<tr><td><code id="gsm_+3A_adaptive">adaptive</code></td>
<td>
<p>logical for whether to use adaptive or non-adaptive
quadrature, Default=TRUE. Deprecated argument: use of the
<code>control</code> argument is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_maxkappa">maxkappa</code></td>
<td>
<p>double float value for the maximum value of the weight
used in the constraint. Default=1000. Deprecated argument: use of the
<code>control</code> argument is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_z">Z</code></td>
<td>
<p>formula for the design matrix for the random effects</p>
</td></tr>
<tr><td><code id="gsm_+3A_reltol">reltol</code></td>
<td>
<p>list with components for search and final relative
tolerances. Default=list(search=1e-10, final=1e-10, outer=1e-5). Deprecated argument: use of the
<code>control</code> argument with arguments <code>reltol.search</code>,
<code>reltol.final</code> and <code>reltol.outer</code> is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_outer_optim">outer_optim</code></td>
<td>
<p>Integer to indicate the algorithm for outer
optimisation. If outer_optim=1 (default), then use Neldear-Mead,
otherwise use Nlm.</p>
</td></tr> 
<tr><td><code id="gsm_+3A_robust_initial">robust_initial</code></td>
<td>
<p>logical for whether to use Nelder-Mead
to find initial values (max 50 iterations). This is useful for
ill-posed initial values. Default= FALSE. Deprecated argument: use of the
<code>control</code> argument is preferred.</p>
</td></tr>
<tr><td><code id="gsm_+3A_penalised">penalised</code></td>
<td>
<p>logical to show whether to use penalised models with
<code>pstpm</code> (<code>penalised=TRUE</code>) or parametrics models with
<code>stpm2</code> (<code>penalised=FALSE</code>).</p>
</td></tr>
<tr><td><code id="gsm_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to the <code><a href="bbmle.html#topic+mle2">mle2</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation extends the <code>mle2</code> object from the
<code>bbmle</code> package.
</p>
<p>The default smoothers for time on the linear predictor scale are
<code>nsxs(log(time),df=3)</code> for the parametric model and
<code>s(log(time))</code> for the penalised model.
</p>
<p>A frequently asked question is: why does rstpm2 give different spline
estimates to flexsurv and Stata's stpm2? The short answer is that
rstpm2 uses a different natural spline basis compared with flexsurv
and Stata's stpm2 and slightly different
knot placement than Stata's stpm2. If the knot
placement is the same, then the predictions and other coefficients are
expected to be very similar. As a longer answer, the default smoother
in rstpm2 is to use an extension of the <code>splines::ns</code> function
(<code>rstpm2::nsx</code>), which uses a QR projection of B-splines for
natural splines. In contrast, flexsurv and Stata's stpm2 use truncated
power splines for the natural spline basis (also termed 'restricted
cubic splines'). The B-splines are known to
have good numerical properties, while Stata's stpm2 implementation
defaults to using matrix orthogonalisation to account for any
numerical instability in the truncated power basis. Furthermore,
rstpm2 allows for any smooth parametric function to be used as a
smoother in <code>stpm2</code>/<code>gsm</code>, which is an extension over
flexsurv and Stata's stpm2. Finally, it may be difficult to get rstpm2 and
Stata's stpm2 to return the same estimates: although
<code>nsx</code> includes an argument <code>stata.stpm2.compatible = FALSE</code> (change to <code>TRUE</code> for
compatibility), the design matrix for rstpm2 is based on individuals
with events, while Stata's stpm2 determines the spline knots from the
individuals with events and the design matrix is otherwise based on all individuals.
</p>


<h3>Value</h3>

<p>Either a <code>stpm2-class</code> or <code>pstpm2-class</code> object. 

</p>


<h3>Author(s)</h3>

<p>Mark Clements, Xing-Rong Liu, Benjamin Christoffersen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    data(brcancer)
    summary(fit &lt;- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3))
    
    ## some predictions
    head(predict(fit,se.fit=TRUE,type="surv"))
    head(predict(fit,se.fit=TRUE,type="hazard"))
    
    ## some plots
    plot(fit,newdata=data.frame(hormon=0),type="hazard")
    plot(fit,newdata=data.frame(hormon=0),type="surv")

    ## time-varying coefficient
    summary(fit.tvc &lt;- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3,
                             tvc=list(hormon=3)))
    anova(fit,fit.tvc) # compare with and without tvc
    
    ## some more plots
    plot(fit.tvc,newdata=data.frame(hormon=0),type="hr",var="hormon", ylim=c(0,2))
    lines(fit.tvc,newdata=data.frame(hormon=1),type="hr",var="hormon",
          col=2)

    plot(fit.tvc,newdata=data.frame(hormon=0),type="sdiff",var="hormon")
    
    plot(fit.tvc,newdata=data.frame(hormon=0),type="hdiff",var="hormon")

    library(scales)
    cols &lt;- c(alpha("red",alpha=0.2), alpha("blue",alpha=0.2))
    plot(fit.tvc,newdata=data.frame(hormon=0),type="hazard",ci.col=cols[1])
    lines(fit.tvc,newdata=data.frame(hormon=1),type="hazard",lty=2,ci.col=cols[2],
          ci=TRUE)
    legend("topright",legend=c("No hormonal treatment", "(95
           lty=c(1,1,2,1), lwd=c(1,10,1,10), col=c("black",cols[1],"black",cols[2]), bty="n")

    
    ## compare number of knots
    hormon0 &lt;- data.frame(hormon=0)
    plot(fit,type="hazard",newdata=hormon0)
    AIC(fit)
    for (df in 4:6) {
        fit.new &lt;- stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,df=df)
        plot(fit.new,type="hazard",newdata=hormon0,add=TRUE,ci=FALSE,line.col=df)
        print(AIC(fit.new))
    }

    ## compatibility with Stata's stpm2 using the smooth.formula argument (see Details)
    summary(stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,
                  smooth.formula=~nsx(log(rectime),df=3,stata.stpm2.compatible=TRUE)))
    summary(stpm2(Surv(rectime,censrec==1)~hormon,data=brcancer,
                  smooth.formula=~nsx(log(rectime),df=3,stata=TRUE)+
                  hormon:nsx(log(rectime),df=3,stata=TRUE)))

    
## End(Not run)
</code></pre>

<hr>
<h2 id='gsm_design'>Extract design information from an stpm2/gsm object and newdata
for use in C++</h2><span id='topic+gsm_design'></span>

<h3>Description</h3>

<p>Extract design information from an stpm2/gsm object and newdata
for use in C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsm_design(object, newdata, newdata0 = NULL, t0 = NULL, inflate = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsm_design_+3A_object">object</code></td>
<td>
<p>stpm2/gsm object</p>
</td></tr>
<tr><td><code id="gsm_design_+3A_newdata">newdata</code></td>
<td>
<p>list or data-frame used for evaluation</p>
</td></tr>
<tr><td><code id="gsm_design_+3A_newdata0">newdata0</code></td>
<td>
<p>list or data-frame used for evaluation at the entry time</p>
</td></tr>
<tr><td><code id="gsm_design_+3A_t0">t0</code></td>
<td>
<p>possible delayed entry time (numeric scalar)</p>
</td></tr>
<tr><td><code id="gsm_design_+3A_inflate">inflate</code></td>
<td>
<p>double value to inflate minimum and maximum times for root finding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list that can be read by 'gsm ssim::read_gsm(SEX args)' in C++
</p>

<hr>
<h2 id='gsm.control'>
Defaults for the gsm call
</h2><span id='topic+gsm.control'></span>

<h3>Description</h3>

<p>Set useful default and allow changes for the gsm call. This is meant to
make the gsm call simpler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsm.control(parscale = 1, maxit = 300, optimiser = c("BFGS", "NelderMead"), trace = 0,
            nodes = 9, adaptive = TRUE, kappa.init = 1, maxkappa = 1000,
            suppressWarnings.coxph.frailty = TRUE, robust_initial = FALSE, bhazinit = 0.1,
            eps.init = 1e-5, use.gr = TRUE, penalty = c("logH", "h"), outer_optim = 1,
            reltol.search = 1e-10, reltol.final = 1e-10, reltol.outer = 1e-05,
            criterion = c("GCV", "BIC"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsm.control_+3A_parscale">parscale</code></td>
<td>

<p>numeric vector or scalar for the scaling of the parameter values;
default 1
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_maxit">maxit</code></td>
<td>

<p>integer for the maximum number of iterations for the optimisation process
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_optimiser">optimiser</code></td>
<td>

<p>which optimiser to use for the outer optimisation
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_trace">trace</code></td>
<td>

<p>integer indicating the trace level for each optimiser
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_nodes">nodes</code></td>
<td>

<p>number of quadrature nodes
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_adaptive">adaptive</code></td>
<td>

<p>logical for whether to use adaptive or non-adaptive
quadrature, Default=TRUE. 
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_kappa.init">kappa.init</code></td>
<td>

<p>initial value for the quadratic penalty for inequality constraints
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_eps.init">eps.init</code></td>
<td>

<p>initial value for epsilon
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_maxkappa">maxkappa</code></td>
<td>

<p>double float value for the maximum value of the weight
used in the constraint.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_suppresswarnings.coxph.frailty">suppressWarnings.coxph.frailty</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_robust_initial">robust_initial</code></td>
<td>

<p>Not currently documented.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_bhazinit">bhazinit</code></td>
<td>

<p>Not currently documented.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_use.gr">use.gr</code></td>
<td>

<p>Logical for whether to use gradients.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_penalty">penalty</code></td>
<td>

<p>Not currently documented.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_outer_optim">outer_optim</code></td>
<td>

<p>Not currently documented.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_reltol.search">reltol.search</code></td>
<td>

<p>Relative tolerance. Not currently documented.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_reltol.final">reltol.final</code></td>
<td>

<p>Relative tolerance. Not currently documented.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_reltol.outer">reltol.outer</code></td>
<td>

<p>Relative tolerance. Not currently documented.
</p>
</td></tr>
<tr><td><code id="gsm.control_+3A_criterion">criterion</code></td>
<td>

<p>Not currently documented.
</p>
</td></tr>
</table>

<hr>
<h2 id='incrVar'>
Utility that returns a function to increment a variable in a data-frame.
</h2><span id='topic+incrVar'></span>

<h3>Description</h3>

<p>A functional approach to defining an increment in one or more
variables in a data-frame. Given a variable name and an increment
value, return a function that takes any data-frame to return a
data-frame with incremented values.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incrVar(var, increment = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incrVar_+3A_var">var</code></td>
<td>

<p>String for the name(s) of the variable(s) to be incremented
</p>
</td></tr>
<tr><td><code id="incrVar_+3A_increment">increment</code></td>
<td>

<p>Value that the variable should be incremented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Useful for defining transformations for calculating rate ratios.
</p>


<h3>Value</h3>

<p>A function with a single <code>data</code> argument that increments the variables
in the <code>data</code> list/data-frame. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (var, increment = 1) 
{
    n &lt;- length(var)
    if (n &gt; 1 &amp;&amp; length(increment)==1) 
        increment &lt;- rep(increment, n)
    function(data) {
        for (i in 1:n) {
            data[[var[i]]] &lt;- data[[var[i]]] + increment[i]
        }
        data
    }
  }
</code></pre>

<hr>
<h2 id='legendre.quadrature.rule.200'>
Legendre quadrature rule for n=200.
</h2><span id='topic+legendre.quadrature.rule.200'></span>

<h3>Description</h3>

<p>Legendre quadrature rule for n=200.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(legendre.quadrature.rule.200)</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>x values between -1 and 1</p>
</dd>
<dt><code>w</code></dt><dd><p>weights</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(legendre.quadrature.rule.200)
## maybe str(legendre.quadrature.rule.200) ; ...
</code></pre>

<hr>
<h2 id='lines.stpm2'>
S3 methods for lines
</h2><span id='topic+lines.stpm2'></span><span id='topic+lines.pstpm2'></span>

<h3>Description</h3>

<p>S3 methods for lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stpm2'
lines(x, newdata = NULL, type = "surv", col = 1, ci.col= "grey",
lty = par("lty"), ci = FALSE, rug = FALSE, var = NULL,
exposed = NULL, times = NULL,
type.relsurv = c("excess", "total", "other"),
ratetable = survival::survexp.us, rmap, scale = 365.24, ...)
## S3 method for class 'pstpm2'
lines(x, newdata = NULL, type = "surv", col = 1,
ci.col= "grey",
lty = par("lty"), ci = FALSE, rug = FALSE, var = NULL,
exposed = NULL, times = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines.stpm2_+3A_x">x</code></td>
<td>
<p>an <code>stpm2</code> object</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_newdata">newdata</code></td>
<td>
<p>required list of new data. This defines the unexposed
newdata (<em>excluding</em> the event times).</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_type">type</code></td>
<td>
<p>specify the type of prediction
</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_col">col</code></td>
<td>
<p>line colour</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_ci.col">ci.col</code></td>
<td>
<p>confidence interval colour</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_ci">ci</code></td>
<td>
<p>whether to plot the confidence interval band (default=TRUE)</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_rug">rug</code></td>
<td>
<p>whether to add a rug plot of the event times to the current
plot (default=TRUE)</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_var">var</code></td>
<td>
<p>specify the variable name or names for the
exposed/unexposed (names are given as characters)</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_exposed">exposed</code></td>
<td>
<p>function that takes newdata and returns the exposed
dataset. By default, this increments <code>var</code> (except for cure
models, where it defaults to the last event time).</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_times">times</code></td>
<td>
<p>specifies the times. By default, this uses a span of the
observed times.</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_type.relsurv">type.relsurv</code></td>
<td>
<p>type of predictions for relative survival models:
either &quot;excess&quot;, &quot;total&quot; or &quot;other&quot;</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_scale">scale</code></td>
<td>
<p>scale to go from the days in the <code>ratetable</code> object
to the analysis time used in the analysis</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_rmap">rmap</code></td>
<td>
<p>an optional list that maps data set names to the ratetable
names. See <code>survexp</code></p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_ratetable">ratetable</code></td>
<td>
<p>a table of event rates used in relative survival when
<code>type.relsurv</code> is &quot;total&quot; or &quot;other&quot;</p>
</td></tr>
<tr><td><code id="lines.stpm2_+3A_...">...</code></td>
<td>
<p>additional arguments (add to the <code>plot</code> command)</p>
</td></tr>
</table>

<hr>
<h2 id='markov_msm'>
Predictions for continuous time, nonhomogeneous Markov multi-state
models using parametric and penalised survival models.
</h2><span id='topic+markov_msm'></span><span id='topic+vcov.markov_msm'></span><span id='topic+as.data.frame.markov_msm'></span><span id='topic+as.data.frame.markov_msm_diff'></span><span id='topic+as.data.frame.markov_msm_ratio'></span><span id='topic+standardise'></span><span id='topic+standardise.markov_msm'></span><span id='topic+plot.markov_msm'></span><span id='topic+subset.markov_msm'></span><span id='topic+diff'></span><span id='topic+diff.markov_msm'></span><span id='topic+ratio_markov_msm'></span><span id='topic+rbind.markov_msm'></span><span id='topic+transform.markov_msm'></span><span id='topic+collapse_markov_msm'></span><span id='topic+zeroModel'></span><span id='topic+hrModel'></span><span id='topic+aftModel'></span><span id='topic+addModel'></span><span id='topic+hazFun'></span><span id='topic+splineFun'></span>

<h3>Description</h3>

<p>A numerically efficient algorithm to calculate predictions from a
continuous time, nonhomogeneous Markov multi-state model. The main
inputs are the models for the transition intensities, the initial values,
the transition matrix and the covariate patterns. The predictions
include state occupancy probabilities (possibly with discounting and
utilities), length of stay and costs. Standard errors are calculated
using the delta method. Includes, differences, ratios and standardisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markov_msm(x, trans, t = c(0,1), newdata = NULL, init=NULL,
              tmvar = NULL, 
              sing.inf = 1e+10, method="adams", rtol=1e-10, atol=1e-10, slow=FALSE,
              min.tm=1e-8,
              utility=function(t) rep(1, nrow(trans)),
              utility.sd=rep(0,nrow(trans)),
              use.costs=FALSE,
              transition.costs=function(t) rep(0, sum(!is.na(trans))), # per transition
              transition.costs.sd=rep(0,sum(!is.na(trans))),
              state.costs=function(t) rep(0,nrow(trans)), # per unit time
              state.costs.sd=rep(0,nrow(trans)),
              discount.rate = 0,
              block.size=500,
              spline.interpolation=FALSE,
              debug=FALSE,
              ...)
## S3 method for class 'markov_msm'
vcov(object, ...)
## S3 method for class 'markov_msm'
as.data.frame(x, row.names=NULL, optional=FALSE,
                                   ci=TRUE,
                                   P.conf.type="logit", L.conf.type="log",
				   C.conf.type="log",
                                   P.range=c(0,1), L.range=c(0,Inf),
				   C.range=c(0,Inf),
                                   state.weights=NULL, obs.weights=NULL,
                                   ...)
## S3 method for class 'markov_msm_diff'
as.data.frame(x, row.names=NULL, optional=FALSE,
                                   P.conf.type="plain", L.conf.type="plain",
				   C.conf.type="plain",
                                   P.range=c(-Inf,Inf), L.range=c(-Inf,Inf),
				   C.range=c(-Inf,Inf),
                                   ...)
## S3 method for class 'markov_msm_ratio'
as.data.frame(x, row.names=NULL, optional=FALSE, ...)
standardise(x, ...)
## S3 method for class 'markov_msm'
standardise(x,
                                 weights = rep(1,nrow(x$newdata)),
                                 normalise = TRUE, ...)
## S3 method for class 'markov_msm'
plot(x, y, stacked=TRUE, which=c('P','L'),
                          xlab="Time", ylab=NULL, col=2:6, border=col,
                          ggplot2=FALSE, lattice=FALSE, alpha=0.2,
                          strata=NULL,
                          ...)
## S3 method for class 'markov_msm'
subset(x, subset, ...)
## S3 method for class 'markov_msm'
diff(x, y, ...)
ratio_markov_msm(x, y, ...)
## S3 method for class 'markov_msm'
rbind(..., deparse.level=1)
## S3 method for class 'markov_msm'
transform(`_data`, ...)
collapse_markov_msm(object, which=NULL, sep="; ")
zeroModel(object)
hrModel(object,hr=1,ci=NULL,seloghr=NULL)
aftModel(object,af=1,ci=NULL,selogaf=NULL)
addModel(...)
hazFun(f, tmvar="t", ...)
splineFun(time,rate,method="natural",scale=1,...)
</code></pre>


<h3>Arguments</h3>

<p>For <code>markov_msm</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_x">x</code></td>
<td>

<p>list of functions or parametric or penalised survival models. Currently
the models include
combinations of <code><a href="#topic+stpm2">stpm2</a></code>, <code><a href="#topic+pstpm2">pstpm2</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="survPen.html#topic+survPen">survPen</a></code> or an object of class <code>"zeroModel"</code> from
<code><a href="#topic+zeroModel">zeroModel</a></code> based on one of the other classes. The order in
the list matches the indexing in the <code>trans</code> argument. The
functions can optionally use a <code>t</code> argument for time and/or a
<code>newdata</code> argument. Uncertainty in the models are incorporated into
the gradients, while uncertainty in the functions are currently not modelled.
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_trans">trans</code></td>
<td>
<p>Transition matrix describing the states and transitions
in the multi-state model. If S is the number of states in the
multi-state model, <code>trans</code> should be an S x S matrix,
with (i,j)-element a positive integer if a transition from i to j
is possible in the multi-state model, <code>NA</code> otherwise. In particular,
all diagonal elements should be <code>NA</code>. The
integers indicating the possible transitions in the multi-state
model should be sequentially numbered, 1,...,K, with K the number
of transitions. See <code><a href="mstate.html#topic+msprep">msprep</a></code></p>
</td></tr>
<tr><td><code id="markov_msm_+3A_t">t</code></td>
<td>

<p>numerical vector for the times to evaluation the predictions. Includes
the start time
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_newdata">newdata</code></td>
<td>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> of the covariates to use in the predictions
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_init">init</code></td>
<td>

<p>vector of the initial values with the same length as the number of states. Defaults to the first state having an
initial value of 1 (i.e. <code>"[&lt;-"(rep(0,nrow(trans)),1,1)</code>).
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_tmvar">tmvar</code></td>
<td>

<p>specifies the name of the time variable. This should be set for
regression models that do not specify this (e.g. <code><a href="stats.html#topic+glm">glm</a></code>) or
where the time variable is ambiguous
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_sing.inf">sing.inf</code></td>
<td>
<p>If there is a singularity in the observed hazard,
for example a Weibull distribution with <code>shape &lt; 1</code> has infinite
hazard at <code>t=0</code>, then as a workaround, the hazard is assumed to
be a large finite number, <code>sing.inf</code>, at this time.   The
results should not be sensitive to the exact value assumed, but
users should make sure by adjusting this parameter in these cases.
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_method">method</code></td>
<td>

<p>For <code>markov_msm</code>, the method used by the ordinary differential equation solver. Defaults to
Adams method (<code>"adams"</code>) for non-stiff differential equations.
</p>
<p>For <code>splineFun</code>, the method jused for spline interpolation; see <code>splinefun</code>.
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a
scalar or an array as long as the number of states. Passed to <code><a href="deSolve.html#topic+lsode">lsode</a></code>
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or an array as
long as the number of states. Passed to <code><a href="deSolve.html#topic+lsode">lsode</a></code>
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_slow">slow</code></td>
<td>

<p>logical to show whether to use the slow <code>R</code>-only
implementation. Useful for debugging. Currently needed for costs.
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_min.tm">min.tm</code></td>
<td>

<p>Minimum time used for evaluations. Avoids log(0) for some models.
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_utility">utility</code></td>
<td>

<p>a function of the form <code>function(t)</code> that returns a utility for
each state at time <code>t</code> for the length of stay values
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_utility.sd">utility.sd</code></td>
<td>

<p>a function of the form <code>function(t)</code> that returns the standard
deviation for the utility for
each state at time <code>t</code> for the length of stay values
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_use.costs">use.costs</code></td>
<td>

<p>logical for whether to use costs. Default: FALSE
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_transition.costs">transition.costs</code></td>
<td>

<p>a function of the form <code>function(t)</code> that returns the cost for each transition
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_transition.costs.sd">transition.costs.sd</code></td>
<td>

<p>a function of the form <code>function(t)</code> that returns the standard deviation
for the cost for each transition
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_state.costs">state.costs</code></td>
<td>

<p>a function of the form <code>function(t)</code> that returns the cost per unit
time for each state
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_state.costs.sd">state.costs.sd</code></td>
<td>

<p>a function of the form <code>function(t)</code> that returns the standard deviation
for the cost per unit time for each state
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_discount.rate">discount.rate</code></td>
<td>

<p>numerical value for the proportional reduction (per unit time) in the length of stay
and costs
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_block.size">block.size</code></td>
<td>

<p>divide <code>newdata</code> into blocks. Uses less memory but is slower. Reduce this number if the function call runs out of memory. 
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_spline.interpolation">spline.interpolation</code></td>
<td>

<p>logical for whether to use spline interpolation for the transition
hazards rather than the model predictions directly (default=TRUE).
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_debug">debug</code></td>
<td>

<p>logical flag for whether to keep the full output from the ordinary differential equation in the <code>res</code> component (default=<code>FALSE</code>). 
</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_...">...</code></td>
<td>

<p>other arguments. For <code>markov_msm</code>, these are passed to the <code><a href="deSolve.html#topic+ode">ode</a></code> solver from the
<code>deSolve</code> package. For <code>plot.markov_msm</code>, these arguments are passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>
</td></tr>
</table>
<p>For <code>as.data.frame.markov_msm</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_row.names">row.names</code></td>
<td>
<p>add in row names to the output data-frame</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_optional">optional</code></td>
<td>
<p>(not currently used)</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_ci">ci</code></td>
<td>
<p>logical for whether to include confidence intervals. Default:
TRUE</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_p.conf.type">P.conf.type</code></td>
<td>
<p>type of transformation for the confidence interval
calculation for the state occupancy probabilities. Default: log-log transformation. This is changed for
<code><a href="#topic+diff">diff</a></code> and <code><a href="#topic+ratio_markov_msm">ratio_markov_msm</a></code> objects</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_l.conf.type">L.conf.type</code></td>
<td>
<p>type of transformation for the confidence interval
calculation for the length of stay calculation. Default: log transformation. This is changed for
<code><a href="#topic+diff">diff</a></code> and <code><a href="#topic+ratio_markov_msm">ratio_markov_msm</a></code> objects</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_c.conf.type">C.conf.type</code></td>
<td>
<p>type of transformation for the confidence interval
calculation for the length of stay calculation. Default: log transformation. This is changed for
<code><a href="#topic+diff">diff</a></code> and <code><a href="#topic+ratio_markov_msm">ratio_markov_msm</a></code> objects</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_p.range">P.range</code></td>
<td>
<p>valid values for the state occupancy probabilities. Default: (0,1). This is changed for
<code><a href="#topic+diff">diff</a></code> and <code><a href="#topic+ratio_markov_msm">ratio_markov_msm</a></code> objects</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_l.range">L.range</code></td>
<td>
<p>valid values for the state occupancy probabilities. Default: (0,Inf). This is changed for
<code><a href="#topic+diff">diff</a></code> and <code><a href="#topic+ratio_markov_msm">ratio_markov_msm</a></code> objects</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_c.range">C.range</code></td>
<td>
<p>valid values for the state occupancy probabilities. Default: (0,Inf). This is changed for
<code><a href="#topic+diff">diff</a></code> and <code><a href="#topic+ratio_markov_msm">ratio_markov_msm</a></code> objects</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_state.weights">state.weights</code></td>
<td>
<p>Not currently documented</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_obs.weights">obs.weights</code></td>
<td>
<p>Not currently documented</p>
</td></tr>
</table>
<p>For <code>standardise.markov_msm</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_weights">weights</code></td>
<td>
<p>numerical vector to use in standardising the state
occupancy probabilities, length of stay and costs. Default: 1 for each observation. </p>
</td></tr>
<tr><td><code id="markov_msm_+3A_normalise">normalise</code></td>
<td>
<p>logical for whether to normalise the weights to
1. Default: TRUE</p>
</td></tr>
</table>
<p>For <code>plot.markov_msm</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_y">y</code></td>
<td>
<p>(currently ignored)</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_stacked">stacked</code></td>
<td>
<p>logical for whether to stack the plots. Default: TRUE</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_ylab">ylab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_col">col</code></td>
<td>
<p>colours (ignored if <code>ggplot2=TRUE</code>)</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_border">border</code></td>
<td>
<p>border colours for the <code><a href="graphics.html#topic+polygon">polygon</a></code> (ignored if <code>ggplot=TRUE</code>)</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_ggplot2">ggplot2</code></td>
<td>
<p>use <code>ggplot2</code></p>
</td></tr>
<tr><td><code id="markov_msm_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for confidence bands (ggplot)</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_lattice">lattice</code></td>
<td>
<p>use <code>lattice</code></p>
</td></tr>
<tr><td><code id="markov_msm_+3A_strata">strata</code></td>
<td>
<p>formula for the stratification factors for the plot</p>
</td></tr>
</table>
<p>For <code>subset.markov_msm</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_subset">subset</code></td>
<td>
<p>expression that is evaluated on the <code>newdata</code>
component of the object to filter (or restrict) for the covariates used
for predictions</p>
</td></tr>
</table>
<p>For <code>transform.markov_msm</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A__data">_data</code></td>
<td>
<p>an object of class <code>"markov_msm"</code></p>
</td></tr>
</table>
<p>For <code>rbind.markov_msm</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_deparse.level">deparse.level</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>
<p>For <code>collapse.states</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_which">which</code></td>
<td>
<p>either an index of the states to collapse or a character vector of the state names to collapse</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_sep">sep</code></td>
<td>
<p>separator to use for the collapsed state names</p>
</td></tr>
</table>
<p>For <code>zeroModel</code> to predict zero rates:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_object">object</code></td>
<td>
<p>survival regression object to be wrapped</p>
</td></tr>
</table>
<p>For <code>hrModel</code> to predict rates times a hazard ratio:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_hr">hr</code></td>
<td>
<p>hazard ratio</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_seloghr">seloghr</code></td>
<td>
<p>alternative specification for the se of the log(hazard ratio); see also <code>ci</code> argument</p>
</td></tr>
</table>
<p>For <code>aftModel</code> to predict accelerated rates:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_af">af</code></td>
<td>
<p>acceleration factor</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_selogaf">selogaf</code></td>
<td>
<p>alternative specification for the se of the log(acceleration factor); see also <code>ci</code> argument</p>
</td></tr>
</table>
<p><code>addModel</code> predict rates based on adding rates from different models
</p>
<p><code>hazFun</code> provides a rate function without uncertainty:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_f">f</code></td>
<td>
<p>rate function, possibly with <code>tmvar</code> and/or <code>newdata</code> as arguments</p>
</td></tr>
</table>
<p><code>splineFun</code> predicts rates using spline interpolation:
</p>
<table role = "presentation">
<tr><td><code id="markov_msm_+3A_time">time</code></td>
<td>
<p>exact times</p>
</td></tr>
<tr><td><code id="markov_msm_+3A_rate">rate</code></td>
<td>
<p>rates as per <code>time</code></p>
</td></tr>
<tr><td><code id="markov_msm_+3A_scale">scale</code></td>
<td>
<p>rate multiplier (e.g. <code>scale=365.25</code> for converting from daily rates to yearly rates)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictions are calculated using an ordinary differential equation
solver. The algorithm uses a single run of the solver to calculate the
state occupancy probabilities, length of stay, costs and their partial
derivatives with respect to the model parameters. The predictions can also be combined to
calculate differences, ratios and standardised.
</p>
<p>The current implementation supports a list of models for each
transition. 
</p>
<p>The current implementation also only allows for a vector of initial
values rather than a matrix. The predictions will need to be re-run for
different vectors of initial values.
</p>
<p>For <code>as.data.frame.markov_msm_ratio</code>, the data are provided in
log form, hence the default transformations and bounds are as per
<code>as.data.frame.markov_msm_diff</code>, with untransformed data on the
real line.
</p>
<p>TODO: allow for one model to predict for the different transitions.
</p>


<h3>Value</h3>

<p><code>markov_msm</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>"markov_msm"</code>.
</p>
<p>The function <code>summary</code> is used to
obtain and print a summary and analysis of variance table of the
results.  The generic accessor functions <code>coef</code> and <code>vcov</code> extract
various useful features of the value returned by <code>markov_msm</code>.
</p>
<p>An object of class <code>"markov_msm"</code> is a list containing at least the
following components:
</p>
<table role = "presentation">
<tr><td><code>time</code></td>
<td>
<p>a numeric vector with the times for the predictions</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>an <code><a href="base.html#topic+array">array</a></code> for the predicted state occupancy
probabilities. The array has three dimensions: time, state, and observations.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>an <code><a href="base.html#topic+array">array</a></code> for the predicted sojourn times (or
length of stay). The array has three dimensions: time, state, and observations.</p>
</td></tr>
<tr><td><code>Pu</code></td>
<td>
<p>an <code><a href="base.html#topic+array">array</a></code> for the partial derivatives of the
predicted state occupancy probabilities with respect to the model coefficients. The array has
four dimensions: time, state, coefficients, and observations.</p>
</td></tr>
<tr><td><code>Lu</code></td>
<td>
<p>an <code><a href="base.html#topic+array">array</a></code> for the partial derivatives of the predicted sojourn times (or
length of stay) with respect to the model coefficients. The array has
four dimensions: time, state, coefficients, and observations.</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with the covariates used for
the predictions</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the variance-covariance matrix for the models of the
transition intensities</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>copy of the <code>trans</code> input argument</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call to the function</p>
</td></tr>
</table>
<p>For debugging:
</p>
<table role = "presentation">
<tr><td><code>res</code></td>
<td>
<p>data returned from the ordinary differential equation
solver. This may include more information on the predictions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mark Clements
</p>


<h3>See Also</h3>

<p><code><a href="flexsurv.html#topic+pmatrix.fs">pmatrix.fs</a></code>, <code><a href="mstate.html#topic+probtrans">probtrans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("deSolve")) {
    library(readstata13)
    library(mstate)
    library(ggplot2)
    library(survival)
    ## Two states: Initial -&gt; Final
    ## Note: this shows how to use markov_msm to estimate survival and risk probabilities based on
    ## smooth hazard models.
    two_states &lt;- function(model, ...) {
        transmat = matrix(c(NA,1,NA,NA),2,2,byrow=TRUE)
        rownames(transmat) &lt;- colnames(transmat) &lt;- c("Initial","Final")
        rstpm2::markov_msm(list(model), ..., trans = transmat)
    }
    ## Note: the first argument is the hazard model. The other arguments are arguments to the
    ## markov_msm function, except for the transition matrix, which is defined by the new function.
    death = gsm(Surv(time,status)~factor(rx), data=survival::colon, subset=(etype==2), df=3)
    cr = two_states(death, newdata=data.frame(rx="Obs"), t = seq(0,2500, length=301))
    plot(cr,ggplot=TRUE)

    ## Competing risks
    ## Note: this shows how to adapt the markov_msm model for competing risks.
    competing_risks &lt;- function(listOfModels, ...) {
        nRisks = length(listOfModels)
        transmat = matrix(NA,nRisks+1,nRisks+1)
        transmat[1,1+(1:nRisks)] = 1:nRisks
        rownames(transmat) &lt;- colnames(transmat) &lt;- c("Initial",names(listOfModels))
        rstpm2::markov_msm(listOfModels, ..., trans = transmat)
    }
    ## Note: The first argument for competing_risks is a list of models. Names from that list are
    ## used for labelling the states. The other arguments are as per the markov_msm function,
    ## except for the transition matrix, which is defined by the competing_risks function.
    recurrence = gsm(Surv(time,status)~factor(rx), data=survival::colon, subset=(etype==1), df=3)
    death = gsm(Surv(time,status)~factor(rx), data=survival::colon, subset=(etype==2), df=3)
    cr = competing_risks(list(Recurrence=recurrence,Death=death),
                         newdata=data.frame(rx=levels(survival::colon$rx)),
                         t = seq(0,2500, length=301))
    ## Plot the probabilities for each state for three different treatment arms
    plot(cr, ggplot=TRUE) + facet_grid(~ rx)
    ## And: differences in probabilities
    cr_diff = diff(subset(cr,rx=="Lev+5FU"),subset(cr,rx=="Obs"))
    plot(cr_diff, ggplot=TRUE, stacked=FALSE)
    
    ## Extended example: Crowther and Lambert (2017)
    ## library(rstpm2); library(readstata13); library(ggplot2)
    mex.1 &lt;- read.dta13("http://fmwww.bc.edu/repec/bocode/m/multistate_example.dta")
    transmat &lt;- rbind("Post-surgery"=c(NA,1,2), 
                      "Relapsed"=c(NA,NA,3),
                      "Died"=c(NA,NA,NA))
    colnames(transmat) &lt;- rownames(transmat)
    mex.2 &lt;- transform(mex.1,osi=(osi=="deceased")+0)
    levels(mex.2$size)[2] &lt;- "&gt;20-50 mm" # fix typo
    mex &lt;- mstate::msprep(time=c(NA,"rf","os"),status=c(NA,"rfi","osi"),
                          data=mex.2,trans=transmat,id="pid",
                          keep=c("age","size","nodes","pr_1","hormon"))
    mex &lt;- transform(mex,
                     size2=(unclass(size)==2)+0, # avoids issues with TRUE/FALSE
                     size3=(unclass(size)==3)+0,
                     hormon=(hormon=="yes")+0,
                     Tstart=Tstart/12,
                     Tstop=Tstop/12)
    ##
    c.ar &lt;- stpm2(Surv(Tstart,Tstop,status) ~ age + size2 + size3 + nodes + pr_1 + hormon,
                  data = mex, subset=trans==1, df=3, tvc=list(size2=1,size3=1,pr_1=1))
    c.ad &lt;- stpm2(Surv(Tstart, Tstop, status) ~ age + size + nodes + pr_1 + hormon,
                  data = mex, subset=trans==2, df=1)
    c.rd &lt;- stpm2( Surv(Tstart,Tstop,status) ~ age + size + nodes + pr_1 + hormon,
                  data=mex, subset=trans==3, df=3, tvc=list(pr_1=1))
    ##
    nd &lt;- expand.grid(nodes=seq(0,20,10), size=levels(mex$size))
    nd &lt;- transform(nd, age=54, pr_1=3, hormon=0,
                    size2=(unclass(size)==2)+0,
                    size3=(unclass(size)==3)+0)
    ## Predictions
    system.time(pred1 &lt;- rstpm2::markov_msm(list(c.ar,c.ad,c.rd), t = seq(0,15,length=301),
                                            newdata=nd, trans = transmat)) # ~2 seconds
    pred1 &lt;- transform(pred1, Nodes=paste("Nodes =",nodes), Size=paste("Size",size))
    ## Figure 3
    plot(pred1, ggplot=TRUE) + facet_grid(Nodes ~ Size) + xlab("Years since surgery")
    plot(pred1, ggplot=TRUE, flipped=TRUE) +
        facet_grid(Nodes ~ Size) + xlab("Years since surgery")
    plot(pred1, strata=~nodes+size, xlab="Years since surgery", lattice=TRUE)
    ## Figure 4
    plot(subset(pred1, nodes==0 &amp; size=="&lt;=20 mm"), stacked=FALSE, ggplot=TRUE) +
        facet_grid(. ~ state) +
        xlab("Years since surgery")
    ## Figure 5
    a &lt;- diff(subset(pred1,nodes==0 &amp; size=="&lt;=20 mm"),
              subset(pred1,nodes==0 &amp; size=="&gt;20-50 mm"))
    a &lt;- transform(a, label = "Prob(Size&lt;=20 mm)-Prob(20mm&lt;Size&lt;50mm)")
    b &lt;- ratio_markov_msm(subset(pred1,nodes==0 &amp; size=="&lt;=20 mm"),
                          subset(pred1,nodes==0 &amp; size=="&gt;20-50 mm"))
    b &lt;- transform(b,label="Prob(Size&lt;=20 mm)-Prob(20mm&lt;Size&lt;50mm)")
    ##
    c &lt;- diff(subset(pred1,nodes==0 &amp; size=="&lt;=20 mm"),
              subset(pred1,nodes==0 &amp; size=="&gt;50 mm"))
    c &lt;- transform(c, label = "Prob(Size&lt;=20 mm)-Prob(Size&gt;=50mm)")
    d &lt;- ratio_markov_msm(subset(pred1,nodes==0 &amp; size=="&lt;=20 mm"),
                          subset(pred1,nodes==0 &amp; size=="&gt;50 mm"))
    d &lt;- transform(d,label= "Prob(Size&lt;=20 mm)-Prob(Size&gt;=50mm)")
    ##
    e &lt;- diff(subset(pred1,nodes==0 &amp; size=="&gt;20-50 mm"),
              subset(pred1,nodes==0 &amp; size=="&gt;50 mm"))
    e &lt;- transform(e,label="Prob(20mm&lt;Size&lt;50 mm)-Prob(Size&gt;=50mm)")
    f &lt;- ratio_markov_msm(subset(pred1,nodes==0 &amp; size=="&gt;20-50 mm"),
                          subset(pred1,nodes==0 &amp; size=="&gt;50 mm"))
    f &lt;- transform(f, label = "Prob(20mm&lt;Size&lt;50 mm)-Prob(Size&gt;=50mm)")
    ## combine
    diffs &lt;- rbind(a,c,e)
    ratios &lt;- rbind(b,d,f)
    ## Figure 5
    plot(diffs, stacked=FALSE, ggplot2=TRUE) + xlab("Years since surgery") +
        ylim(c(-0.4, 0.4)) + facet_grid(label ~ state)
    ##
    plot(ratios, stacked=FALSE, ggplot2=TRUE) + xlab("Years since surgery") +
        ylim(c(0, 3)) + facet_grid(label ~ state)
    ## Figure 6
    plot(subset(pred1, nodes==0 &amp; size=="&lt;=20 mm"), stacked=FALSE, which="L", ggplot2=TRUE) +
        facet_grid(. ~ state) + xlab("Years since surgery")
    ## Figure 7
    plot(diffs, stacked=FALSE, which="L", ggplot2=TRUE) + xlab("Years since surgery") +
        ylim(c(-4, 4)) + facet_grid(label ~ state)
    plot(ratios, stacked=FALSE, which="L", ggplot2=TRUE) + xlab("Years since surgery") +
        ylim(c(0.1, 10)) + coord_trans(y="log10") + facet_grid(label ~ state)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='markov_sde'>
Predictions for continuous time, nonhomogeneous Markov multi-state
models using Aalen's additive hazards models.
</h2><span id='topic+markov_sde'></span><span id='topic+standardise.markov_sde'></span><span id='topic+plot.markov_sde'></span><span id='topic+as.data.frame.markov_sde'></span>

<h3>Description</h3>

<p>A numerically efficient algorithm to calculate predictions from a
continuous time, nonhomogeneous Markov multi-state model. The main
inputs are are a list of Aalen's additive hazards models, the initial values,
the transition matrix and the covariate patterns. The predictions
include state occupancy probabilities and length of stay. Standard errors are calculated
using the delta method. Includes differences and standardisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markov_sde(models, trans, newdata, init = NULL, nLebesgue = 10000 + 1, los = FALSE,
           nOut = 300, weights = 1)
## S3 method for class 'markov_sde'
standardise(x, ...)
## S3 method for class 'markov_sde'
plot(x, y, stacked=TRUE, which=c("P","L"), index=NULL,
    xlab="Time", ylab=NULL, col=2:6, border=col,
    ggplot2=FALSE, lattice=FALSE, alpha=0.2,
    strata=NULL,
    ...)
## S3 method for class 'markov_sde'
as.data.frame(x, row.names=NULL, optional=NULL, ci=TRUE,
    P.conf.type="logit", L.conf.type="log",
    P.range=c(0,1), L.range=c(0,Inf),
    ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markov_sde_+3A_models">models</code></td>
<td>

<p>list of models. Currently allows only for <code><a href="timereg.html#topic+aalen">aalen</a></code> regression models.
</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_trans">trans</code></td>
<td>

<p>Transition matrix describing the states and transitions
in the multi-state model. If S is the number of states in the
multi-state model, <code>trans</code> should be an S x S matrix,
with (i,j)-element a positive integer if a transition from i to j
is possible in the multi-state model, <code>NA</code> otherwise. In particular,
all diagonal elements should be <code>NA</code>. The
integers indicating the possible transitions in the multi-state
model should be sequentially numbered, 1,...,K, with K the number
of transitions. See <code><a href="mstate.html#topic+msprep">msprep</a></code>
</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_newdata">newdata</code></td>
<td>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> of the covariates to use in the predictions
</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_init">init</code></td>
<td>

<p>vector of the initial values with the same length as the number of states. Defaults to the first state having an
initial value of 1 (i.e. <code>"[&lt;-"(rep(0,nrow(trans)),1,1)</code>).
</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_nlebesgue">nLebesgue</code></td>
<td>

<p>Number of steps for the continuous integration
</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_los">los</code></td>
<td>

<p>logical variable for whether to estimate the length of stay
</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_nout">nOut</code></td>
<td>

<p>number of rows to represent the continuous changes
</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_weights">weights</code></td>
<td>

<p>numeric vector to represent differences or standardisation
</p>
</td></tr>
</table>
<p>For <code>plot.markov_sde</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_sde_+3A_y">y</code></td>
<td>
<p>(currently ignored)</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_stacked">stacked</code></td>
<td>
<p>logical for whether to stack the plots. Default: TRUE</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_index">index</code></td>
<td>
<p>indicator of which row of <code>newdata</code> to plot</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_which">which</code></td>
<td>
<p>character to indicate either transition probabilities (<code>"P"</code>) or length of stay (<code>"L"</code>)). Default: <code>"P"</code>.</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_ylab">ylab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_col">col</code></td>
<td>
<p>colours (ignored if <code>ggplot2=TRUE</code>)</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_border">border</code></td>
<td>
<p>border colours for the <code><a href="graphics.html#topic+polygon">polygon</a></code> (ignored if <code>ggplot=TRUE</code>)</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_ggplot2">ggplot2</code></td>
<td>
<p>use <code>ggplot2</code></p>
</td></tr>
<tr><td><code id="markov_sde_+3A_alpha">alpha</code></td>
<td>
<p>alpha value for confidence bands (ggplot)</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_lattice">lattice</code></td>
<td>
<p>use <code>lattice</code></p>
</td></tr>
<tr><td><code id="markov_sde_+3A_strata">strata</code></td>
<td>
<p>formula for the stratification factors for the plot</p>
</td></tr>
</table>
<p>For <code>as.data.frame.markov_sde</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_sde_+3A_row.names">row.names</code></td>
<td>
<p>add in row names to the output data-frame</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_optional">optional</code></td>
<td>
<p>(not currently used)</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_ci">ci</code></td>
<td>
<p>logical for whether to include confidence intervals. Default:
TRUE</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_p.conf.type">P.conf.type</code></td>
<td>
<p>type of transformation for the confidence interval
calculation for the state occupancy probabilities. Default: logit transformation. This is changed to <code>"identity"</code> if any of the weights are negative</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_l.conf.type">L.conf.type</code></td>
<td>
<p>type of transformation for the confidence interval
calculation for the length of stay calculation. Default: log transformation. <code>"identity"</code> if any of the weights are negative</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_p.range">P.range</code></td>
<td>
<p>valid values for the state occupancy probabilities. Default: (0,1). </p>
</td></tr>
<tr><td><code id="markov_sde_+3A_l.range">L.range</code></td>
<td>
<p>valid values for the state occupancy probabilities. Default: (0,Inf). </p>
</td></tr>
</table>
<p>For <code>standardise.markov_sde</code>:
</p>
<table role = "presentation">
<tr><td><code id="markov_sde_+3A_x">x</code></td>
<td>
<p>object to extract standardised values</p>
</td></tr>
<tr><td><code id="markov_sde_+3A_...">...</code></td>
<td>

<p>other arguments. For <code>plot.markov_sde</code>, these arguments are passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>. For <code>standardise.markov_sde</code>, these arguments are not used, as the standardisation must be done earlier in <code>markov_sde</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses an approach developed by Ryalen and colleagues. This is a re-implementation in C++.
</p>
<p>The current implementation only allows for a vector of initial
values rather than a matrix. The predictions will need to be re-run for
different vectors of initial values.
</p>


<h3>Value</h3>

<p><code>markov_sde</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>"markov_sde"</code>.
</p>


<h3>Author(s)</h3>

<p>Mark Clements
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markov_msm">markov_msm</a></code>
</p>

<hr>
<h2 id='nsx'>Generate a Basis Matrix for Natural Cubic Splines (with eXtensions)</h2><span id='topic+nsx'></span>

<h3>Description</h3>

<p>Generate the B-spline basis matrix for a natural cubic spline (with eXtensions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsx(x, df = NULL, knots = NULL, intercept = FALSE,
    Boundary.knots = range(x), derivs = if (cure) c(2, 1) else c(2, 2),
    log = FALSE, centre = FALSE, 
    cure = FALSE, stata.stpm2.compatible = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsx_+3A_x">x</code></td>
<td>
<p>the predictor variable.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="nsx_+3A_df">df</code></td>
<td>
<p>degrees of freedom. One can supply <code>df</code> rather than
knots; <code>ns()</code> then chooses <code>df - 1 - intercept + 4 - sum(derivs)</code> knots at
suitably chosen quantiles of <code>x</code> (which will ignore missing values).</p>
</td></tr>
<tr><td><code id="nsx_+3A_knots">knots</code></td>
<td>
<p>breakpoints that define the spline.  The default is no
knots; together with the natural boundary conditions this results in
a basis for linear regression on <code>x</code>.  Typical values are the
mean or median for one knot, quantiles for more knots.  See also
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="nsx_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, an intercept is included in the
basis; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nsx_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to impose the natural
boundary conditions and anchor the B-spline basis (default the range
of the data).  If both <code>knots</code> and <code>Boundary.knots</code> are
supplied, the basis parameters do not depend on <code>x</code>. Data can
extend beyond <code>Boundary.knots</code></p>
</td></tr>
<tr><td><code id="nsx_+3A_derivs">derivs</code></td>
<td>
<p>an integer vector of length 2 with values between 0 and
2 giving the derivative constraint order at
the left and right boundary knots; an order of 2 constrains the
second derivative to zero (f&rdquo;(x)=0); an order of 1 constrains the
first and second derivatives to zero (f'(x)=f&rdquo;(x)=0); an order of 0
constrains the zero, first and second derivatives to zero (f(x)=f'(x)=f&rdquo;(x)=0)</p>
</td></tr>
<tr><td><code id="nsx_+3A_log">log</code></td>
<td>
<p>a Boolean indicating whether the underlying values have been
log transformed; (deprecated: only used to calculate derivatives in rstpm2:::stpm2Old</p>
</td></tr>
<tr><td><code id="nsx_+3A_centre">centre</code></td>
<td>
<p>if specified, then centre the splines at this value
(i.e. f(centre)=0) (default=FALSE)</p>
</td></tr>
<tr><td><code id="nsx_+3A_cure">cure</code></td>
<td>
<p>a Boolean indicated whether to estimate cure; changes the
default derivs argument, such that the right boundary has the first
and second derivatives constrained to zero; defaults to FALSE</p>
</td></tr>
<tr><td><code id="nsx_+3A_stata.stpm2.compatible">stata.stpm2.compatible</code></td>
<td>
<p>a Boolean to determine whether to use
Stata stpm's default knot placement; defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code>length(x) * df</code> where either <code>df</code> was
supplied or if <code>knots</code> were supplied,
<code>df = length(knots) + 1 + intercept</code>.
Attributes are returned that correspond to the arguments to <code>ns</code>,
and explicitly give the <code>knots</code>, <code>Boundary.knots</code> etc for
use by <code>predict.nsx()</code>.
</p>
<p><code>nsx()</code> is based on the functions <code><a href="splines.html#topic+ns">ns</a></code> and <code><a href="splines.html#topic+spline.des">spline.des</a></code>.  It
generates a basis matrix for representing the family of
piecewise-cubic splines with the specified sequence of
interior knots, and the natural boundary conditions.  These enforce
the constraint that the function is linear beyond the boundary knots,
which can either be supplied, else default to the extremes of the
data.  A primary use is in modeling formula to directly specify a
natural spline term in a model.
</p>
<p>The extensions from <code><a href="splines.html#topic+ns">ns</a></code> are: specification of the
derivative constraints at the boundary knots; whether to centre the
knots; incorporation of cure using derivatives; compatible knots
with Stata's stpm2; and an indicator for a log-transformation of
<code>x</code> for calculating derivatives.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992)
Generalized additive models.
Chapter 7 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="splines.html#topic+bs">bs</a></code>, <code>predict.nsx</code>, <code><a href="stats.html#topic+SafePrediction">SafePrediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats); require(graphics); require(splines)
nsx(women$height, df = 5)
summary(fm1 &lt;- lm(weight ~ ns(height, df = 5), data = women))

## example of safe prediction
plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
ht &lt;- seq(57, 73, length.out = 200)
lines(ht, predict(fm1, data.frame(height=ht)))

</code></pre>

<hr>
<h2 id='nsxD'>Generate a Basis Matrix for the first derivative of Natural Cubic Splines (with eXtensions)</h2><span id='topic+nsxD'></span>

<h3>Description</h3>

<p>Generate the B-spline basis matrix for the first derivative of a natural cubic spline (with eXtensions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsxD(x, df = NULL, knots = NULL, intercept = FALSE,
    Boundary.knots = range(x), derivs = if (cure) c(2, 1) else c(2, 2),
    log = FALSE, centre = FALSE, 
    cure = FALSE, stata.stpm2.compatible = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsxD_+3A_x">x</code></td>
<td>
<p>the predictor variable.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="nsxD_+3A_df">df</code></td>
<td>
<p>degrees of freedom. One can supply <code>df</code> rather than
knots; <code>ns()</code> then chooses <code>df - 1 - intercept + 4 - sum(derivs)</code> knots at
suitably chosen quantiles of <code>x</code> (which will ignore missing values).</p>
</td></tr>
<tr><td><code id="nsxD_+3A_knots">knots</code></td>
<td>
<p>breakpoints that define the spline.  The default is no
knots; together with the natural boundary conditions this results in
a basis for linear regression on <code>x</code>.  Typical values are the
mean or median for one knot, quantiles for more knots.  See also
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="nsxD_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, an intercept is included in the
basis; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nsxD_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to impose the natural
boundary conditions and anchor the B-spline basis (default the range
of the data).  If both <code>knots</code> and <code>Boundary.knots</code> are
supplied, the basis parameters do not depend on <code>x</code>. Data can
extend beyond <code>Boundary.knots</code></p>
</td></tr>
<tr><td><code id="nsxD_+3A_derivs">derivs</code></td>
<td>
<p>an integer vector of length 2 with values between 0 and
2 giving the derivative constraint order at
the left and right boundary knots; an order of 2 constrains the
second derivative to zero (f&rdquo;(x)=0); an order of 1 constrains the
first and second derivatives to zero (f'(x)=f&rdquo;(x)=0); an order of 0
constrains the zero, first and second derivatives to zero (f(x)=f'(x)=f&rdquo;(x)=0)</p>
</td></tr>
<tr><td><code id="nsxD_+3A_log">log</code></td>
<td>
<p>a Boolean indicating whether the underlying values have been
log transformed; (deprecated: only used to calculate derivatives in rstpm2:::stpm2Old</p>
</td></tr>
<tr><td><code id="nsxD_+3A_centre">centre</code></td>
<td>
<p>if specified, then centre the splines at this value
(i.e. f(centre)=0) (default=FALSE)</p>
</td></tr>
<tr><td><code id="nsxD_+3A_cure">cure</code></td>
<td>
<p>a Boolean indicated whether to estimate cure; changes the
default derivs argument, such that the right boundary has the first
and second derivatives constrained to zero; defaults to FALSE</p>
</td></tr>
<tr><td><code id="nsxD_+3A_stata.stpm2.compatible">stata.stpm2.compatible</code></td>
<td>
<p>a Boolean to determine whether to use
Stata stpm's default knot placement; defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimension <code>length(x) * df</code> where either <code>df</code> was
supplied or if <code>knots</code> were supplied,
<code>df = length(knots) + 1 + intercept</code>.
Attributes are returned that correspond to the arguments to <code>ns</code>,
and explicitly give the <code>knots</code>, <code>Boundary.knots</code> etc for
use by <code>predict.nsxD()</code>.
</p>
<p><code>nsxD()</code> is based on the functions <code><a href="splines.html#topic+ns">ns</a></code> and <code><a href="splines.html#topic+spline.des">spline.des</a></code>.  It
generates a basis matrix for representing the family of
piecewise-cubic splines with the specified sequence of
interior knots, and the natural boundary conditions.  These enforce
the constraint that the function is linear beyond the boundary knots,
which can either be supplied, else default to the extremes of the
data.  A primary use is in modeling formula to directly specify a
natural spline term in a model.
</p>
<p>The extensions from <code><a href="splines.html#topic+ns">ns</a></code> are: specification of the
derivative constraints at the boundary knots; whether to centre the
knots; incorporation of cure using derivatives; compatible knots
with Stata's stpm2; and an indicator for a log-transformation of
<code>x</code> for calculating derivatives.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992)
Generalized additive models.
Chapter 7 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="splines.html#topic+bs">bs</a></code>, <code>predict.nsx</code>, <code><a href="stats.html#topic+SafePrediction">SafePrediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats); require(graphics); require(splines)
nsx(women$height, df = 5)
summary(fm1 &lt;- lm(weight ~ ns(height, df = 5), data = women))

## example of safe prediction
plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
ht &lt;- seq(57, 73, length.out = 200)
lines(ht, predict(fm1, data.frame(height=ht)))

</code></pre>

<hr>
<h2 id='numDeltaMethod'>
Calculate numerical delta method for non-linear predictions.
</h2><span id='topic+numDeltaMethod'></span>

<h3>Description</h3>

<p>Given a regression object and an independent prediction function (as a
function of the coefficients), calculate the point estimate and
standard errors 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numDeltaMethod(object, fun, gd=NULL, conf.int=FALSE, level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numDeltaMethod_+3A_object">object</code></td>
<td>

<p>A regression object with methods <code>coef</code> and <code>vcov</code>.
</p>
</td></tr>
<tr><td><code id="numDeltaMethod_+3A_fun">fun</code></td>
<td>

<p>An independent prediction function with signature
<code>function(coef, ...)</code>.
</p>
</td></tr>
<tr><td><code id="numDeltaMethod_+3A_gd">gd</code></td>
<td>

<p>Specified gradients
</p>
</td></tr>
<tr><td><code id="numDeltaMethod_+3A_conf.int">conf.int</code></td>
<td>

<p>Logical for whether to also calculate the confidence interval
</p>
</td></tr>
<tr><td><code id="numDeltaMethod_+3A_level">level</code></td>
<td>

<p>Numeric for the level of the confidence interval
</p>
</td></tr>
<tr><td><code id="numDeltaMethod_+3A_...">...</code></td>
<td>

<p>Other arguments passed to <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A more user-friendly interface is provided by <code>predictnl</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>Point estimates</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Standard errors</p>
</td></tr>
<tr><td><code>Estimate</code></td>
<td>
<p>Point estimates</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>Standard errors</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower confidence interval (if conf.int=TRUE)</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper confidence interval (if conf.int=TRUE)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+predictnl">predictnl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (object, fun, ...) 
{
    coef &lt;- coef(object)
    est &lt;- fun(coef, ...)
    Sigma &lt;- vcov(object)
    gd &lt;- grad(fun, coef, ...)
    se.est &lt;- as.vector(sqrt(colSums(gd * (Sigma %*% gd))))
    data.frame(Estimate = est, SE = se.est)
  }
</code></pre>

<hr>
<h2 id='plot-methods'> plots for an stpm2 fit</h2><span id='topic+plot-methods'></span><span id='topic+plot+2Cstpm2-method'></span><span id='topic+plot+2Cpstpm2-method'></span>

<h3>Description</h3>

<p>Given an <code>stpm2</code> fit, return a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    ## S4 method for signature 'stpm2'
plot(x,y,newdata,type="surv",
                      xlab="Time",line.col=1,ci.col="grey",
                      add=FALSE,ci=TRUE,rug=TRUE,
                      var=NULL,exposed=NULL,times=NULL,...)
    ## S4 method for signature 'pstpm2'
plot(x,y,newdata,type="surv",
                      xlab="Time",line.col=1,ci.col="grey",
                      add=FALSE,ci=TRUE,rug=TRUE,
                      var=NULL,exposed=NULL,times=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>an <code>stpm2</code> object</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>not used (for generic compatibility)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_newdata">newdata</code></td>
<td>
<p>required list of new data. This defines the unexposed
newdata (<em>excluding</em> the event times).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_type">type</code></td>
<td>
<p>specify the type of prediction
</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_line.col">line.col</code></td>
<td>
<p>line colour</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ci.col">ci.col</code></td>
<td>
<p>confidence interval colour</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ci">ci</code></td>
<td>
<p>whether to plot the confidence interval band (default=TRUE)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_add">add</code></td>
<td>
<p>whether to add to the current plot (<code>add=TRUE</code>) or make a new
plot (<code>add=FALSE</code>) (default=FALSE)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_rug">rug</code></td>
<td>
<p>whether to add a rug plot of the event times to the current
plot (default=TRUE)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_var">var</code></td>
<td>
<p>specify the variable name or names for the
exposed/unexposed (names are given as characters)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_exposed">exposed</code></td>
<td>
<p>function that takes newdata and returns the exposed
dataset. By default, this increments <code>var</code>  (except for cure
models, where it defaults to the last event time).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_times">times</code></td>
<td>
<p>specifies the times. By default, this uses a span of the
observed times.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>additional arguments (add to the <code>plot</code> command)</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;stpm2&quot;, y = &quot;missing&quot;</dt><dd><p>an <code>stpm2</code> fit</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+stpm2">stpm2</a></code></p>

<hr>
<h2 id='popmort'>
Background mortality rates for the colon dataset.
</h2><span id='topic+popmort'></span>

<h3>Description</h3>

<p>Background mortality rates for the colon dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(popmort)</code></pre>


<h3>Format</h3>

<p>A data frame with 10600 observations on the following 5 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>Sex (1=male, 2=female)</p>
</dd>
<dt><code>prob</code></dt><dd><p>One year probability of survival</p>
</dd>
<dt><code>rate</code></dt><dd><p>All cause mortality rate</p>
</dd>
<dt><code>age</code></dt><dd><p>Age by single year of age through to age 105 years</p>
</dd>
<dt><code>year</code></dt><dd><p>Calendar period</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(popmort)
## maybe str(popmort) ; ...
</code></pre>

<hr>
<h2 id='predict-methods'> Predicted values for an stpm2 or pstpm2 fit</h2><span id='topic+predict-methods'></span><span id='topic+predict+2Cstpm2-method'></span><span id='topic+predict+2Cpstpm2-method'></span>

<h3>Description</h3>

<p>Given an <code>stpm2</code> fit and an optional list of new data, return predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    ## S4 method for signature 'stpm2'
predict(object, newdata=NULL,
               type=c("surv","cumhaz","hazard","density","hr","sdiff",
               "hdiff","loghazard","link","meansurv","meansurvdiff","meanhr",
               "odds","or","margsurv","marghaz","marghr","meanhaz","af",
               "fail","margfail","meanmargsurv","uncured","rmst","probcure",
               "lpmatrix", "gradh", "gradH","rmstdiff","lpmatrixD"),
               grid=FALSE,seqLength=300,
               type.relsurv=c("excess","total","other"), scale=365.24,
               rmap, ratetable=survival::survexp.us,
               se.fit=FALSE,link=NULL,exposed=NULL,var=NULL,
               keep.attributes=FALSE, use.gr=TRUE,level=0.95,
               n.gauss.quad=100,full=FALSE,...)
    ## S4 method for signature 'pstpm2'
predict(object, newdata=NULL,
               type=c("surv","cumhaz","hazard","density","hr","sdiff",
               "hdiff","loghazard","link","meansurv","meansurvdiff","meanhr",
               "odds","or","margsurv","marghaz","marghr","meanhaz","af",
               "fail","margfail","meanmargsurv","rmst","lpmatrix",
               "gradh", "gradH","rmstdiff","lpmatrixD"),
               grid=FALSE,seqLength=300,
               se.fit=FALSE,link=NULL,exposed=NULL,var=NULL,
               keep.attributes=FALSE, use.gr=TRUE,level=0.95,
               n.gauss.quad=100,full=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict-methods_+3A_object">object</code></td>
<td>
<p>an <code>stpm2</code> or <code>pstpm2</code> object</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_newdata">newdata</code></td>
<td>
<p>optional list of new data (required if type in
(&quot;hr&quot;,&quot;sdiff&quot;,&quot;hdiff&quot;,&quot;meansurvdiff&quot;,&quot;or&quot;,&quot;uncured&quot;)). For type in
(&quot;hr&quot;,&quot;sdiff&quot;,&quot;hdiff&quot;,&quot;meansurvdiff&quot;,&quot;or&quot;,&quot;af&quot;,&quot;uncured&quot;), this defines the unexposed
newdata. This can be combined with <code>grid</code> to get a
regular set of event times (i.e. newdata would <em>not</em>
include the event times). </p>
</td></tr>
<tr><td><code id="predict-methods_+3A_type">type</code></td>
<td>
<p>specify the type of prediction:
</p>

<dl>
<dt>&quot;surv&quot;</dt><dd><p>survival probabilities</p>
</dd>
<dt>&quot;cumhaz&quot;</dt><dd><p>cumulative hazard</p>
</dd>
<dt>&quot;hazard&quot;</dt><dd><p>hazard</p>
</dd>
<dt>&quot;density&quot;</dt><dd><p>density</p>
</dd>
<dt>&quot;hr&quot;</dt><dd><p>hazard ratio</p>
</dd>
<dt>&quot;sdiff&quot;</dt><dd><p>survival difference</p>
</dd>
<dt>&quot;hdiff&quot;</dt><dd><p>hazard difference</p>
</dd>
<dt>&quot;loghazard&quot;</dt><dd><p>log hazards</p>
</dd>
<dt>&quot;meansurv&quot;</dt><dd><p>mean survival</p>
</dd>
<dt>&quot;meansurvdiff&quot;</dt><dd><p>mean survival difference</p>
</dd>
<dt>&quot;odds&quot;</dt><dd><p>odds</p>
</dd>
<dt>&quot;or&quot;</dt><dd><p>odds ratio</p>
</dd>
<dt>&quot;margsurv&quot;</dt><dd><p>marginal (population) survival</p>
</dd>
<dt>&quot;marghaz&quot;</dt><dd><p>marginal (population) hazard</p>
</dd>
<dt>&quot;marghr&quot;</dt><dd><p>marginal (population) hazard ratio</p>
</dd>
<dt>&quot;meanhaz&quot;</dt><dd><p>mean hazard</p>
</dd>
<dt>&quot;meanhr&quot;</dt><dd><p>mean hazard ratio</p>
</dd>
<dt>&quot;af&quot;</dt><dd><p>attributable fraction</p>
</dd>
<dt>&quot;fail&quot;</dt><dd><p>failure (=1-survival)</p>
</dd>
<dt>&quot;margfail&quot;</dt><dd><p>marginal failure (=1-marginal survival)</p>
</dd>
<dt>&quot;meanmargsurv&quot;</dt><dd><p>mean marginal survival, averaged over the
frailty distribution</p>
</dd>
<dt>&quot;uncured&quot;</dt><dd><p>distribution for the uncured</p>
</dd>
<dt>&quot;rmst&quot;</dt><dd><p>restricted mean survival time</p>
</dd>
<dt>&quot;rmstdiff&quot;</dt><dd><p>restricted mean survival time difference</p>
</dd>
<dt>&quot;probcure&quot;</dt><dd><p>probability of cure</p>
</dd>
<dt>&quot;lpmatrix&quot;</dt><dd><p>design matrix</p>
</dd>
<dt>&quot;lpmatrixD&quot;</dt><dd><p>design matrix for the derivative with respect
to time</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="predict-methods_+3A_grid">grid</code></td>
<td>
<p>whether to merge newdata with a regular sequence of event
times (default=FALSE)</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_seqlength">seqLength</code></td>
<td>
<p>length of the sequence used when <code>grid=TRUE</code></p>
</td></tr>
<tr><td><code id="predict-methods_+3A_type.relsurv">type.relsurv</code></td>
<td>
<p>type of predictions for relative survival models:
either &quot;excess&quot;, &quot;total&quot; or &quot;other&quot;</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_scale">scale</code></td>
<td>
<p>scale to go from the days in the <code>ratetable</code> object
to the analysis time used in the analysis</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_rmap">rmap</code></td>
<td>
<p>an optional list that maps data set names to the ratetable
names. See <code>survexp</code></p>
</td></tr>
<tr><td><code id="predict-methods_+3A_ratetable">ratetable</code></td>
<td>
<p>a table of event rates used in relative survival when
<code>type.relsurv</code> is &quot;total&quot; or &quot;other&quot;</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_se.fit">se.fit</code></td>
<td>
<p>whether to calculate confidence intervals (default=FALSE)</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_link">link</code></td>
<td>
<p>allows a different link for the confidence interval
calculation (default=NULL, such that
switch(type,surv=&quot;cloglog&quot;,cumhaz=&quot;log&quot;,hazard=&quot;log&quot;,hr=&quot;log&quot;,sdiff=&quot;I&quot;,
hdiff=&quot;I&quot;,loghazard=&quot;I&quot;,link=&quot;I&quot;,odds=&quot;log&quot;,or=&quot;log&quot;,margsurv=&quot;cloglog&quot;,
marghaz=&quot;log&quot;,marghr=&quot;log&quot;))</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_exposed">exposed</code></td>
<td>
<p>a function that takes newdata and returns a transformed
data-frame for those exposed or the counterfactual. By default, this increments <code>var</code> (except for cure
models, where it defaults to the last event time).</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_var">var</code></td>
<td>
<p>specify the variable name or names for the
exposed/unexposed (names are given as characters)</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_keep.attributes">keep.attributes</code></td>
<td>
<p>Boolean to determine whether the output should
include the newdata as an attribute (default=TRUE)</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_use.gr">use.gr</code></td>
<td>
<p>Boolean to determine whether to use gradients in the
variance calculations when they are available (default=TRUE)</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_level">level</code></td>
<td>
<p>confidence level for the confidence intervals (default=0.95)</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_n.gauss.quad">n.gauss.quad</code></td>
<td>
<p>number of Gauassian quadrature points used for
integrations (default=100)</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_full">full</code></td>
<td>
<p>logical for whether to return a full data-frame with
predictions and <code>newdata</code> combined. Useful for
<code>lattice</code> and <code>ggplot2</code> plots. (default=FALSE)</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_...">...</code></td>
<td>
<p>additional arguments (for generic compatibility)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence interval estimation is based on the delta method using
numerical differentiation.
</p>


<h3>Value</h3>

<p>A data-frame with components <code>Estimate</code>, <code>lower</code> and
<code>upper</code>, with an attribute &quot;newdata&quot; for the <code>newdata</code>
data-frame.  
</p>


<h3>Methods</h3>


<dl>
<dt>object= &quot;stpm2&quot;</dt><dd><p>an <code>stpm2</code> fit</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+stpm2">stpm2</a></code></p>

<hr>
<h2 id='predict.nsx'>Evaluate a Spline Basis</h2><span id='topic+predict.nsx'></span>

<h3>Description</h3>

<p>Evaluate a predefined spline basis at given values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nsx'
predict(object, newx, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.nsx_+3A_object">object</code></td>
<td>
<p>the result of a call to <code><a href="#topic+nsx">nsx</a></code> having attributes describing <code>knots</code>,
<code>degree</code>, etc.</p>
</td></tr>
<tr><td><code id="predict.nsx_+3A_newx">newx</code></td>
<td>
<p>the <code>x</code> values at which evaluations are required.</p>
</td></tr>
<tr><td><code id="predict.nsx_+3A_...">...</code></td>
<td>
<p>Optional additional arguments.  At present no additional
arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object just like <code>object</code>, except evaluated at the new values
of <code>x</code>.
</p>
<p>These are methods for the generic function <code><a href="stats.html#topic+predict">predict</a></code> for
objects inheriting from classes <code>"nsx"</code>.  See
<code><a href="stats.html#topic+predict">predict</a></code> for the general behavior of this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsx">nsx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>basis &lt;- nsx(women$height, df = 5)
newX &lt;- seq(58, 72, length.out = 51)
# evaluate the basis at the new data
predict(basis, newX)
</code></pre>

<hr>
<h2 id='predictnl'>
Estimation of standard errors using the numerical delta method.
</h2><span id='topic+predictnl'></span><span id='topic+predictnl.default'></span><span id='topic+predictnl.lm'></span><span id='topic+predict.formula'></span><span id='topic+confint.predictnl'></span>

<h3>Description</h3>

<p>A simple, yet exceedingly useful, approach to estimate the variance of a
function using the numerical delta method. A number of packages provide
functions that analytically calculate the gradients; we use numerical
derivatives, which generalises to models that do not offer analytical
derivatives (e.g. ordinary differential equations, integration), or to
examples that are tedious or error-prone to calculate (e.g. sums of
predictions from GLMs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
predictnl(object, fun, newdata=NULL, gd=NULL, ...)
## S3 method for class 'lm'
predictnl(object, fun, newdata=NULL, ...)
## S3 method for class 'formula'
predict(object,data,newdata,na.action,type="model.matrix",...)
## S3 method for class 'predictnl'
confint(object, parm, level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictnl_+3A_object">object</code></td>
<td>

<p>An object with <code>coef</code>, <code>vcov</code> and <code>`coef&lt;-`</code>
methods (required). 
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_fun">fun</code></td>
<td>

<p>A function that takes <code>object</code> as the first argument, possibly with
<code>newdata</code> and other arguments (required). See notes for why it is
often useful to include <code>newdata</code> as an argument to the function.
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_newdata">newdata</code></td>
<td>

<p>An optional argument that defines newdata to be passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_gd">gd</code></td>
<td>

<p>An optional matrix of gradients. If this is not specified, then the
gradients are calculated using finite differences.
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_parm">parm</code></td>
<td>

<p>currently ignored
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_level">level</code></td>
<td>

<p>significance level for 2-sided confidence intervals
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_data">data</code></td>
<td>

<p>object used to define the model frame
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_na.action">na.action</code></td>
<td>

<p>passed to <code>model.frame</code>
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_type">type</code></td>
<td>

<p>currently restricted to <code>"model.matrix"</code>
</p>
</td></tr>
<tr><td><code id="predictnl_+3A_...">...</code></td>
<td>

<p>Other arguments that are passed to <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The signature for <code>fun</code>
is either <code>fun(object, ...)</code> or <code>fun(object, newdata=NULL,
  ...)</code>.
</p>
<p>The different <code>predictnl</code> methods call the utility function
<code>numDeltaMethod</code>, which in turn calls the <code>grad</code> function for
numerical differentiation. The <code>numDeltaMethod</code> function calls the
standard <code>coef</code> and <code>vcov</code> methods, and the non-standard
<code>`coef&lt;-`</code> method for changing the coefficients in a regression
object. This non-standard method has been provided for several
regression objects and essentially mirrors the <code>coef</code> method.
</p>
<p>One potential issue is that some <code>predict</code> methods do not
re-calculate their predictions for the fitted dataset (i.e. when
<code>newdata=NULL</code>). As the <code>predictnl</code> function changes the
fitted coefficients, it is required that the predictions are
re-calculated. One solution is to pass <code>newdata</code> as an argument to
both <code>predictnl</code> and <code>fun</code>; alternatively, <code>newdata</code> can
be specified in <code>fun</code>. These approaches are described in the examples
below. The <code>numDeltaMethod</code> method called by <code>predictnl</code>
provides a warning when the variance estimates are zero, which may be
due to this cause.
</p>
<p>For completeness, it is worth discussing why the example
<code>predictnl(fit,predict)</code> does not work for when <code>fit</code> is a
<code>glm</code> object. First, <code>predict.glm</code> does not update the
predictions for the fitted data. Second, the default <code>predict</code>
method has a signature <code>predict(object, ...)</code>, which does not
include a <code>newdata</code> argument. We could then either (i) require that
a <code>newdata</code> argument be passed to the <code>fun</code> function for all
examples, which would make this corner case work, or (ii) only pass the
<code>newdata</code> argument if it is non-null or in the formals for the
<code>fun</code> function, which would fail for this corner case. The current
API defaults to the latter case (ii).  To support this approach, the
<code>predictnl.lm</code> method replaces a null <code>newdata</code> with
<code>object$data</code>. We also provide a revised
<code>numdelta:::predict.lm</code> method that performs the same operation,
although its use is not encouraged due to its clumsiness.
</p>


<h3>Value</h3>

<p> Returns an object of class
an object with class <code>c("predictnl","data.frame")</code> elements
<code>c("fit","se.fit","Estimate","SE")</code> and with methods <code>print</code>
and <code>confint</code>. Note that the Estimate and SE fields are deprecated
and their use is discouraged, as we would like to remove them from future releases.
</p>


<h3>Author(s)</h3>

<p>Mark Clements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(x=0:1, y=c(10, 20))
fit &lt;- glm(y ~ x, df, family=poisson)

predictnl(fit,
          function(obj,newdata)
          diff(predict(obj,newdata,type="response")))

</code></pre>

<hr>
<h2 id='predictnl-methods'> ~~ Methods for Function predictnl  ~~</h2><span id='topic+predictnl-methods'></span><span id='topic+predictnl+2Cmle2-method'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>predictnl</code>  ~~
</p>


<h3>Methods</h3>


<dl>
<dt>predictnl</dt><dd><p><code>signature(object = "mle2", ...)</code>: Similar to
predictnl.default, using S4 methods. </p>
</dd>
</dl>


<hr>
<h2 id='pstpm2-class'>Class &quot;pstpm2&quot; </h2><span id='topic+pstpm2-class'></span><span id='topic+plot+2Cpstpm2+2Cmissing-method'></span><span id='topic+lines+2Cpstpm2-method'></span><span id='topic+predictnl+2Cpstpm2-method'></span><span id='topic+AIC+2Cpstpm2-method'></span><span id='topic+AICc+2Cpstpm2-method'></span><span id='topic+BIC+2Cpstpm2-method'></span><span id='topic+anova+2Cpstpm2-method'></span><span id='topic+qAICc+2Cpstpm2-method'></span><span id='topic+summary+2Cpstpm2-method'></span><span id='topic+eform+2Cpstpm2-method'></span>

<h3>Description</h3>

<p>Regression object for <code>pstpm2</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("pstpm2", ...)</code> and
<code>pstpm2( ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>xlevels</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>contrasts</code>:</dt><dd><p>Object of class <code>"listOrNULL"</code> ~~ </p>
</dd>
<dt><code>terms</code>:</dt><dd><p>Object of class <code>"terms"</code> ~~ </p>
</dd>
<dt><code>gam</code>:</dt><dd><p>Object of class <code>"gam"</code> ~~ </p>
</dd>
<dt><code>logli</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>timeVar</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>time0Var</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>time0Expr</code>:</dt><dd><p>Object of class <code>"nameOrcall"</code> ~~ </p>
</dd>
<dt><code>timeExpr</code>:</dt><dd><p>Object of class <code>"nameOrcall"</code> ~~ </p>
</dd>
<dt><code>like</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>model.frame</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>delayed</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>frailty</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>xd</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>termsd</code>:</dt><dd><p>Object of class <code>"terms"</code> ~~ </p>
</dd>
<dt><code>Call</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>y</code>:</dt><dd><p>Object of class <code>"Surv"</code> ~~ </p>
</dd>
<dt><code>sp</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>nevent</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>link</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>edf</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>edf_var</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>df</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> ~~ </p>
</dd>
<dt><code>call.orig</code>:</dt><dd><p>Object of class <code>"language"</code> ~~ </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>min</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>details</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>optimizer</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>args</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class for <code><a href="bbmle.html#topic+mle2">mle2</a></code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "pstpm2", y = "missing")</code>: ... </p>
</dd>
<dt>lines</dt><dd><p><code>signature(x = "pstpm2", ...)</code>: ... </p>
</dd>

<dt>anova</dt><dd><p><code>signature(object = "pstpm2",...)</code>: ... </p>
</dd>
<dt>AIC</dt><dd><p><code>signature(object = "pstpm2",...,k=2)</code>: ... </p>
</dd>
<dt>AICc</dt><dd><p><code>signature(object = "pstpm2",...,nobs=NULL, k=2)</code>: ... </p>
</dd>
<dt>BIC</dt><dd><p><code>signature(object = "pstpm2",..., nobs = NULL)</code>: ... </p>
</dd>
<dt>qAICc</dt><dd><p><code>signature(object = "pstpm2",..., nobs = NULL, dispersion = 1, k = 2)</code>: ... </p>
</dd>
<dt>qAIC</dt><dd><p><code>signature(object = "pstpm2",..., dispersion = 1, k = 2)</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "pstpm2",...)</code>: ... </p>
</dd>
<dt>eform</dt><dd><p><code>signature(object = "pstpm2",...)</code>: ... </p>
</dd>
<dt>predictnl</dt><dd><p><code>signature(object = "pstpm2",...)</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("pstpm2")
</code></pre>

<hr>
<h2 id='residuals-methods'>Residual values for an stpm2 or pstpm2 fit</h2><span id='topic+residuals-methods'></span><span id='topic+residuals+2Cstpm2-method'></span><span id='topic+residuals+2Cpstpm2-method'></span>

<h3>Description</h3>

<p>Given an <code>stpm2</code> or <code>pstpm2</code> fit, return residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
    ## S4 method for signature 'stpm2'
residuals(object, type=c("li","gradli"))
    ## S4 method for signature 'pstpm2'
residuals(object, type=c("li","gradli"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals-methods_+3A_object">object</code></td>
<td>
<p>an <code>stpm2</code> or <code>pstpm2</code> object</p>
</td></tr>
<tr><td><code id="residuals-methods_+3A_type">type</code></td>
<td>
<p>specify the type of residuals:
</p>

<dl>
<dt>&quot;li&quot;</dt><dd><p>log-likelihood components (not strictly residuals)</p>
</dd>
<dt>&quot;gradli&quot;</dt><dd><p>gradient of the log-likelihood components (not
strictly residuals)</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The gradients are analytical.
</p>


<h3>Value</h3>

<p>A vector or matrix.
</p>


<h3>Methods</h3>


<dl>
<dt>object= &quot;stpm2&quot;</dt><dd><p>an <code>stpm2</code> fit</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+stpm2">stpm2</a></code></p>

<hr>
<h2 id='rstpm2-internal'>
Internal functions for the rstpm2 package.
</h2><span id='topic+lhs'></span><span id='topic+rhs'></span><span id='topic+lhs+3C-'></span><span id='topic+rhs+3C-'></span>

<h3>Description</h3>

<p>Various utility functions used internally to the rstpm2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs(formula)
rhs(formula)
lhs(formula) &lt;- value
rhs(formula) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rstpm2-internal_+3A_formula">formula</code></td>
<td>

<p>A formula
</p>
</td></tr>
<tr><td><code id="rstpm2-internal_+3A_value">value</code></td>
<td>

<p>A symbolic value to replace the current value. 
</p>
</td></tr>
</table>

<hr>
<h2 id='simulate-methods'>Simulate values from an stpm2 or pstpm2 fit</h2><span id='topic+simulate-methods'></span><span id='topic+simulate+2Cstpm2-method'></span><span id='topic+simulate+2Cpstpm2-method'></span>

<h3>Description</h3>

<p>Given an <code>stpm2</code> fit and a data-frame
of new data, return simulated values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S4 method for signature 'stpm2'
simulate(object, nsim=1,
        seed=NULL, newdata=NULL,
        lower=1e-06, upper=1e+05, start=NULL, ...)
    ## S4 method for signature 'pstpm2'
simulate(object, nsim=1,
        seed=NULL, newdata=NULL,
        lower=1e-06, upper=1e+05, start=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate-methods_+3A_object">object</code></td>
<td>
<p>an stpm2 or pstpm2 object</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations per row in newdata</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_seed">seed</code></td>
<td>
<p>optional random number seed</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_newdata">newdata</code></td>
<td>
<p>list of new data. If not specified, then defaults to object@data</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_lower">lower</code></td>
<td>
<p>smallest possible time</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_upper">upper</code></td>
<td>
<p>largest possible time</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_start">start</code></td>
<td>
<p>left truncated entry time (assumed to be zero if NULL)</p>
</td></tr>
<tr><td><code id="simulate-methods_+3A_...">...</code></td>
<td>
<p>additional arguments (for generic compatibility)</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>object = &quot;stpm2&quot;</dt><dd><p>an <code>stpm2</code> fit</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1002)
fit1 &lt;- gsm(Surv(rectime,censrec==1)~hormon,data=brcancer,df=3)
simulate(fit1, nsim=10, newdata=data.frame(hormon=1))
simulate(fit1, newdata=data.frame(hormon=0:1))

</code></pre>

<hr>
<h2 id='smoothpwc'>
Utility to use a smooth function in markov_msm based on piece-wise constant values
</h2><span id='topic+smoothpwc'></span>

<h3>Description</h3>

<p>Utility to use a smooth function in markov_msm based on piece-wise constant values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothpwc(midts, rates, tmvar = "t", offsetvar = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothpwc_+3A_midts">midts</code></td>
<td>

<p>mid-point values for time in each segment
</p>
</td></tr>
<tr><td><code id="smoothpwc_+3A_rates">rates</code></td>
<td>

<p>rates at those mid-points (or for the interval)
</p>
</td></tr>
<tr><td><code id="smoothpwc_+3A_tmvar">tmvar</code></td>
<td>

<p>string for the time variable
</p>
</td></tr>
<tr><td><code id="smoothpwc_+3A_offsetvar">offsetvar</code></td>
<td>

<p>string for a time offset variable
</p>
</td></tr>
<tr><td><code id="smoothpwc_+3A_...">...</code></td>
<td>

<p>other arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses splines to smooth the log-rates. This assumes that the rates are
strictly greater than zero.
</p>


<h3>Value</h3>

<p>a function that is used in markov_msm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (midts, rates, tmvar = "t", offsetvar = "", ...) 
{
    log.smoother &lt;- splinefunx(midts, log(rates), constant.right = TRUE)
    haz &lt;- function(newdata) {
        t &lt;- newdata[[tmvar]] + (if (offsetvar != "") 
            newdata[[offsetvar]]
        else 0)
        exp(log.smoother(t))
    }
    structure(list(haz = haz), class = "smoothpwc")
  }
</code></pre>

<hr>
<h2 id='stpm2-class'>Class &quot;stpm2&quot; ~~~ </h2><span id='topic+stpm2-class'></span><span id='topic+plot+2Cstpm2+2Cmissing-method'></span><span id='topic+lines+2Cstpm2-method'></span><span id='topic+predictnl+2Cstpm2-method'></span><span id='topic+summary+2Cstpm2-method'></span><span id='topic+eform+2Cstpm2-method'></span>

<h3>Description</h3>

<p>Regression object for <code>stpm2</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("stpm2", ...)</code> and
<code>stpm2( ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>xlevels</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>contrasts</code>:</dt><dd><p>Object of class <code>"listOrNULL"</code> ~~ </p>
</dd>
<dt><code>terms</code>:</dt><dd><p>Object of class <code>"terms"</code> ~~ </p>
</dd>
<dt><code>logli</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>lm</code>:</dt><dd><p>Object of class <code>"lm"</code> ~~ </p>
</dd>
<dt><code>timeVar</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>time0Var</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>timeExpr</code>:</dt><dd><p>Object of class <code>"nameOrcall"</code> ~~ </p>
</dd>
<dt><code>time0Expr</code>:</dt><dd><p>Object of class <code>"nameOrcall"</code> ~~ </p>
</dd>
<dt><code>delayed</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>frailty</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>interval</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>model.frame</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>call.formula</code>:</dt><dd><p>Object of class <code>"formula"</code> ~~ </p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>xd</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>termsd</code>:</dt><dd><p>Object of class <code>"terms"</code> ~~ </p>
</dd>
<dt><code>Call</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>y</code>:</dt><dd><p>Object of class <code>"Surv"</code> ~~ </p>
</dd>
<dt><code>link</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> ~~ </p>
</dd>
<dt><code>call.orig</code>:</dt><dd><p>Object of class <code>"language"</code> ~~ </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>min</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>details</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>optimizer</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>args</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="bbmle.html#topic+mle2">mle2</a></code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "stpm2", y = "missing")</code>: ... </p>
</dd>
<dt>lines</dt><dd><p><code>signature(x = "stpm2", ...)</code>: ... </p>
</dd>

<dt>predictnl</dt><dd><p><code>signature(object = "stpm2", ...)</code>: ... </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "stpm2", ...)</code>: ... </p>
</dd>
<dt>eform</dt><dd><p><code>signature(object = "stpm2", ...)</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("stpm2")
</code></pre>

<hr>
<h2 id='tvcCoxph-class'>Class <code>"tvcCoxph"</code></h2><span id='topic+tvcCoxph-class'></span><span id='topic+plot+2CtvcCoxph+2Cmissing-method'></span>

<h3>Description</h3>

<p>Experimental approach to modelling time-dependent effects in Cox regression.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("tvcCoxph", ...)</code>
or <code>cox.tvc(...)</code>. See the <code><a href="bbmle.html#topic+mle2">mle2</a></code>
documentation.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"language"</code> ~~ </p>
</dd>
<dt><code>call.orig</code>:</dt><dd><p>Object of class <code>"language"</code> ~~ </p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>fullcoef</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>min</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>details</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>minuslogl</code>:</dt><dd><p>Object of class <code>"function"</code> ~~ </p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>optimizer</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code><a href="bbmle.html#topic+mle2">mle2</a></code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "tvcCoxph", y = "missing")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("tvcCoxph")
</code></pre>

<hr>
<h2 id='update-methods'> Methods for Function update</h2><span id='topic+update-methods'></span><span id='topic+update+2Cstpm2-method'></span>

<h3>Description</h3>

<p>Methods for function <code>update</code>
</p>


<h3>Methods</h3>


<dl>
<dt>update</dt><dd><p><code>signature(object = "stpm2", ...)</code>: Similar to
update.default, using S4 methods. </p>
</dd>
</dl>


<hr>
<h2 id='voptimize'>Vectorised One Dimensional Optimization</h2><span id='topic+voptimize'></span><span id='topic+voptimise'></span>

<h3>Description</h3>

<p>The function <code>voptimize</code> searches the interval from
<code>lower</code> to <code>upper</code> for a minimum or maximum of
the vectorised function <code>f</code> with respect to its first argument.
</p>
<p><code>optimise</code> is an alias for <code>optimize</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voptimize(f, interval, ...,
          lower=pmin(interval[,1], interval[,2]),
          upper=pmax(interval[,1], interval[,2]),
          maximum = FALSE,
          tol = .Machine$double.eps^0.25)
voptimise(f, interval, ...,
          lower=pmin(interval[,1], interval[,2]),
          upper=pmax(interval[,1], interval[,2]),
          maximum = FALSE,
          tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voptimize_+3A_f">f</code></td>
<td>
<p>the function to be optimized.  The function is
either minimized or maximized over its first argument
depending on the value of <code>maximum</code>.</p>
</td></tr>
<tr><td><code id="voptimize_+3A_interval">interval</code></td>
<td>
<p>a matrix with two columns containing the end-points of the interval
to be searched for the minimum.</p>
</td></tr>
<tr><td><code id="voptimize_+3A_...">...</code></td>
<td>
<p>additional named or unnamed arguments to be passed
to <code>f</code></p>
</td></tr>
<tr><td><code id="voptimize_+3A_lower">lower</code>, <code id="voptimize_+3A_upper">upper</code></td>
<td>
<p>the lower and upper end points of the interval to
be searched.</p>
</td></tr>
<tr><td><code id="voptimize_+3A_maximum">maximum</code></td>
<td>
<p>logical.  Should we maximize or minimize (the default)?</p>
</td></tr>
<tr><td><code id="voptimize_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arguments after <code>...</code> must be matched exactly.
</p>
<p>The method used is a combination of golden section search and
successive parabolic interpolation, and was designed for use with
continuous functions.  Convergence is never much slower
than that for a Fibonacci search.  If <code>f</code> has a continuous second
derivative which is positive at the minimum (which is not at <code>lower</code> or
<code>upper</code>), then convergence is superlinear, and usually of the
order of about 1.324.
</p>
<p>The function <code>f</code> is never evaluated at two points closer together
than <code class="reqn">\epsilon</code><code class="reqn"> |x_0| + (tol/3)</code>, where
<code class="reqn">\epsilon</code> is approximately <code>sqrt(<a href="base.html#topic+.Machine">.Machine</a>$double.eps)</code>
and <code class="reqn">x_0</code> is the final abscissa <code>optimize()$minimum</code>.<br />
If <code>f</code> is a unimodal function and the computed values of <code>f</code>
are always unimodal when separated by at least <code class="reqn">\epsilon</code>
<code class="reqn"> |x| + (tol/3)</code>, then <code class="reqn">x_0</code> approximates the abscissa of the
global minimum of <code>f</code> on the interval <code>lower,upper</code> with an
error less than <code class="reqn">\epsilon</code><code class="reqn"> |x_0|+ tol</code>.<br />
If <code>f</code> is not unimodal, then <code>optimize()</code> may approximate a
local, but perhaps non-global, minimum to the same accuracy.
</p>
<p>The first evaluation of <code>f</code> is always at
<code class="reqn">x_1 = a + (1-\phi)(b-a)</code> where <code>(a,b) = (lower, upper)</code> and
<code class="reqn">\phi = (\sqrt 5 - 1)/2 = 0.61803..</code>
is the golden section ratio.
Almost always, the second evaluation is at
<code class="reqn">x_2 = a + \phi(b-a)</code>.
Note that a local minimum inside <code class="reqn">[x_1,x_2]</code> will be found as
solution, even when <code>f</code> is constant in there, see the last
example.
</p>
<p><code>f</code> will be called as <code>f(<var>x</var>, ...)</code> for a numeric value
of <var>x</var>.
</p>
<p>The argument passed to <code>f</code> has special semantics and used to be
shared between calls.  The function should not copy it.
</p>
<p>The implementation is a vectorised version of the <code>optimize</code> function.
</p>


<h3>Value</h3>

<p>A list with components <code>minimum</code> (or <code>maximum</code>)
and <code>objective</code> which give the location of the minimum (or maximum)
and the value of the function at that point.
</p>


<h3>Source</h3>

<p>Based on R's C translation of Fortran code <a href="https://netlib.org/fmm/fmin.f">https://netlib.org/fmm/fmin.f</a>
(author(s) unstated)
based on the Algol 60 procedure <code>localmin</code> given in the reference.
</p>


<h3>References</h3>

<p>Brent, R. (1973)
<em>Algorithms for Minimization without Derivatives.</em>
Englewood Cliffs, NJ: Prentice-Hall.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optimize">optimize</a></code> for the standard single optimiser solver,
<code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(graphics)

f &lt;- function (x, a) (x - a)^2
xmin &lt;- voptimize(f, lower=c(0, 0), upper=c(1,1), tol = 0.0001, a = c(1/3,2/3))
xmin

## See where the function is evaluated:
voptimize(function(x) x^2*(print(x)-1), lower = c(0,0), upper = c(10,10))

## "wrong" solution with unlucky interval and piecewise constant f():
f  &lt;- function(x) ifelse(x &gt; -1, ifelse(x &lt; 4, exp(-1/abs(x - 1)), 10), 10)
fp &lt;- function(x) { print(x); f(x) }

plot(f, -2,5, ylim = 0:1, col = 2)
voptimize(fp, cbind(-4, 20))   # doesn't see the minimum
voptimize(fp, cbind(-7, 20))   # ok

</code></pre>

<hr>
<h2 id='vuniroot'>Vectorised One Dimensional Root (Zero) Finding</h2><span id='topic+vuniroot'></span>

<h3>Description</h3>

<p>The function <code>vuniroot</code> searches the interval from <code>lower</code>
to <code>upper</code> for a root (i.e., zero) of the vectorised function <code>f</code> with
respect to its first argument.
</p>
<p>Setting <code>extendInt</code> to a non-<code>"no"</code> string, means searching
for the correct <code>interval = c(lower,upper)</code> if <code>sign(f(x))</code>
does not satisfy the requirements at the interval end points; see the
&lsquo;Details&rsquo; section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vuniroot(f, interval, ...,
        lower, upper,
        f.lower = f(lower, ...), f.upper = f(upper, ...),
        extendInt = c("no", "yes", "downX", "upX"), check.conv = FALSE,
        tol = .Machine$double.eps^0.25, maxiter = 1000, trace = 0,
        n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vuniroot_+3A_f">f</code></td>
<td>
<p>the function for which the root is sought.</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_interval">interval</code></td>
<td>
<p>a matrix with two columns containing the end-points of the interval
to be searched for the root.</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_...">...</code></td>
<td>
<p>additional named or unnamed arguments to be passed
to <code>f</code></p>
</td></tr>
<tr><td><code id="vuniroot_+3A_lower">lower</code>, <code id="vuniroot_+3A_upper">upper</code></td>
<td>
<p>the lower and upper end points of the interval to
be searched.</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_f.lower">f.lower</code>, <code id="vuniroot_+3A_f.upper">f.upper</code></td>
<td>
<p>the same as <code>f(upper)</code> and
<code>f(lower)</code>, respectively.  Passing these values from the caller
where they are often known is more economical as soon as <code>f()</code>
contains non-trivial computations.</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_extendint">extendInt</code></td>
<td>
<p>character string specifying if the interval
<code>c(lower,upper)</code> should be extended or directly produce an error
when <code>f()</code> does not have differing signs at the endpoints.  The
default, <code>"no"</code>, keeps the search interval and hence produces
an error.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_check.conv">check.conv</code></td>
<td>
<p>logical indicating whether a convergence warning of the
underlying <code><a href="#topic+vuniroot">vuniroot</a></code> should be caught as an error and if
non-convergence in <code>maxiter</code> iterations should be an error
instead of a warning.</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_trace">trace</code></td>
<td>
<p>integer number; if positive, tracing information is
produced.  Higher values giving more details.</p>
</td></tr>
<tr><td><code id="vuniroot_+3A_n">n</code></td>
<td>
<p>integer number; size of input vector to <code>f</code>
(only used if <code>lower</code> and <code>upper</code> are of length 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arguments after <code>...</code> must be matched exactly.
</p>
<p>Either <code>interval</code> or both <code>lower</code> and <code>upper</code> must be
specified: the upper endpoint must be strictly larger than the lower
endpoint.
</p>
<p>The function values at the endpoints must be of opposite signs (or
zero), for <code>extendInt="no"</code>, the default.  Otherwise, if
<code>extendInt="yes"</code>, the interval is extended on both sides, in
search of a sign change, i.e., until the search interval <code class="reqn">[l,u]</code>
satisfies <code class="reqn">f(l) \cdot f(u) \le 0</code>.
</p>
<p>If it is <em>known how</em> <code class="reqn">f</code> changes sign at the root
<code class="reqn">x_0</code>, that is, if the function is increasing or decreasing there,
<code>extendInt</code> can (and typically should) be specified as
<code>"upX"</code> (for &ldquo;upward crossing&rdquo;) or <code>"downX"</code>,
respectively.  Equivalently, define <code class="reqn">S := \pm 1</code>, to
require <code class="reqn">S = \mathrm{sign}(f(x_0 + \epsilon))</code> at the solution.  In that case, the search interval <code class="reqn">[l,u]</code>
possibly is extended to be such that <code class="reqn">S\cdot f(l)\le 0</code> and <code class="reqn">S \cdot f(u) \ge 0</code>.
</p>
<p><code>vuniroot()</code> uses a C++ subroutine based on &lsquo;<span class="file">&quot;zeroin&quot;</span>&rsquo; (from Netlib)
and algorithms given in the reference below.  They assume a
continuous function (which then is known to have at least one root in
the interval).
</p>
<p>Convergence is declared either if <code>f(x) == 0</code> or the change in
<code>x</code> for one step of the algorithm is less than <code>tol</code> (plus an
allowance for representation error in <code>x</code>).
</p>
<p>If the algorithm does not converge in <code>maxiter</code> steps, a warning
is printed and the current approximation is returned.
</p>
<p><code>f</code> will be called as <code>f(<var>x</var>, ...)</code> for a numeric value
of <var>x</var>.
</p>
<p>The argument passed to <code>f</code> has special semantics and used to be
shared between calls.  The function should not copy it.
</p>


<h3>Value</h3>

<p>A list with at least three components: <code>root</code> and <code>f.root</code>
give the location of the root and the value of the function evaluated
at that point. <code>iter</code> gives the number of
iterations used.
</p>
<p>Further components may be added in future: component <code>init.it</code>
was added in <span class="rlang"><b>R</b></span> 3.1.0.  
</p>


<h3>Source</h3>

<p>Based on &lsquo;<span class="file">zeroin.c</span>&rsquo; in <a href="https://netlib.org/c/brent.shar">https://netlib.org/c/brent.shar</a>.
</p>


<h3>References</h3>

<p>Brent, R. (1973)
<em>Algorithms for Minimization without Derivatives.</em>
Englewood Cliffs, NJ: Prentice-Hall.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for the standard single root solver
<code><a href="base.html#topic+polyroot">polyroot</a></code> for all complex roots of a polynomial;
<code><a href="stats.html#topic+optimize">optimize</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(utils) # for str

## some platforms hit zero exactly on the first step:
## if so the estimated precision is 2/3.
f &lt;- function (x, a) x - a
str(xmin &lt;- vuniroot(f, lower=c(0, 0), upper=c(1,1), tol = 0.0001, a = c(1/3,2/3)))
## same example with scalars for lower and upper -- using the n argument
str(xmin &lt;- vuniroot(f, lower=0, upper=1, tol = 0.0001, n=2, a = c(1/3,2/3)))

## handheld calculator example: fixed point of cos(.):
vuniroot(function(x) cos(x) - x, lower = -pi, upper = pi, tol = 1e-9)$root

str(vuniroot(function(x) x*(x^2-1) + .5, lower = -2, upper = 2,
            tol = 0.0001))
str(vuniroot(function(x) x*(x^2-1) + .5, lower = -2, upper = 2,
            tol = 1e-10))

## Find the smallest value x for which exp(x) &gt; 0 (numerically):
r &lt;- vuniroot(function(x) 1e80*exp(x) - 1e-300, cbind(-1000, 0), tol = 1e-15)
str(r, digits.d = 15) # around -745, depending on the platform.

exp(r$root)     # = 0, but not for r$root * 0.999...
minexp &lt;- r$root * (1 - 10*.Machine$double.eps)
exp(minexp)     # typically denormalized


##--- vuniroot() with new interval extension + checking features: --------------

f1 &lt;- function(x) (121 - x^2)/(x^2+1)
f2 &lt;- function(x) exp(-x)*(x - 12)

tools::assertCondition(vuniroot(f1, cbind(0,10)),
                       "error", verbose=TRUE)
tools::assertCondition(vuniroot(f2, cbind(0, 2)),
                       "error", verbose=TRUE)
##--&gt; error: f() .. end points not of opposite sign

## where as  'extendInt="yes"'  simply first enlarges the search interval:
u1 &lt;- vuniroot(f1, cbind(0,10),extendInt="yes", trace=1)
u2 &lt;- vuniroot(f2, cbind(0,2), extendInt="yes", trace=2)
stopifnot(all.equal(u1$root, 11, tolerance = 1e-5),
          all.equal(u2$root, 12, tolerance = 6e-6))

## The *danger* of interval extension:
## No way to find a zero of a positive function, but
## numerically, f(-|M|) becomes zero :
tools::assertCondition(u3 &lt;- vuniroot(exp, cbind(0,2), extendInt="yes", trace=TRUE),
                       "error", verbose=TRUE)

## Nonsense example (must give an error):
tools::assertCondition( vuniroot(function(x) 1, cbind(0,1), extendInt="yes"),
                       "error", verbose=TRUE)

## Convergence checking :
sinc_ &lt;- function(x) ifelse(x == 0, 1, sin(x)/x)
curve(sinc_, -6,18); abline(h=0,v=0, lty=3, col=adjustcolor("gray", 0.8))

vuniroot(sinc_, cbind(0,5), extendInt="yes", maxiter=4) #-&gt; "just" a warning


## now with  check.conv=TRUE, must signal a convergence error :

vuniroot(sinc_, cbind(0,5), extendInt="yes", maxiter=4, check.conv=TRUE)


### Weibull cumulative hazard (example origin, Ravi Varadhan):
cumhaz &lt;- function(t, a, b) b * (t/b)^a
froot &lt;- function(x, u, a, b) cumhaz(x, a, b) - u

n &lt;- 10
u &lt;- -log(runif(n))
a &lt;- 1/2
b &lt;- 1
## Find failure times
ru &lt;- vuniroot(froot, u=u, a=a, b=b, interval= cbind(rep(1.e-14,n), rep(1e4,n)),
               extendInt="yes")$root
ru2 &lt;- vuniroot(froot, u=u, a=a, b=b, interval= cbind(rep(0.01,n), rep(10,n)),
                extendInt="yes")$root
stopifnot(all.equal(ru, ru2, tolerance = 6e-6))

r1 &lt;- vuniroot(froot, u= 0.99, a=a, b=b, interval= cbind(0.01, 10),
             extendInt="up")
stopifnot(all.equal(0.99, cumhaz(r1$root, a=a, b=b)))

## An error if 'extendInt' assumes "wrong zero-crossing direction":

vuniroot(froot, u= 0.99, a=a, b=b, interval= cbind(0.1, 10), extendInt="down")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
