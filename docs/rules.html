<!DOCTYPE html><html lang="en-US"><head><title>Help for package rules</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rules}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rules-package'><p>rules: Model Wrappers for Rule-Based Models</p></a></li>
<li><a href='#c5_fit'><p>Internal function wrappers</p></a></li>
<li><a href='#committees'><p>Parameter functions for Cubist models</p></a></li>
<li><a href='#multi_predict._cubist'><p><code>multi_predict()</code> methods for rule-based models</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tidy.C5.0'><p>Turn C5.0 and rule-based models into tidy tibbles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Model Wrappers for Rule-Based Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Bindings for additional models for use with the 'parsnip'
    package.  Models include prediction rule ensembles (Friedman and
    Popescu, 2008) &lt;<a href="https://doi.org/10.1214%2F07-AOAS148">doi:10.1214/07-AOAS148</a>&gt;, C5.0 rules (Quinlan, 1992
    ISBN: 1558602380), and Cubist (Kuhn and Johnson, 2013)
    &lt;<a href="https://doi.org/10.1007%2F978-1-4614-6849-3">doi:10.1007/978-1-4614-6849-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tidymodels/rules">https://github.com/tidymodels/rules</a>, <a href="https://rules.tidymodels.org/">https://rules.tidymodels.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/rules/issues">https://github.com/tidymodels/rules/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>parsnip (&ge; 0.2.1.9004), R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dials (&ge; 0.1.1.9001), dplyr, generics (&ge; 0.1.0), purrr,
rlang, stats, stringr, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>C50, covr, Cubist, knitr, modeldata, recipes, rmarkdown,
spelling, testthat (&ge; 3.0.0), tibble, xrf (&ge; 0.2.0)</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyr, tidyverse/tidytemplate, recipes, xrf</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-08 23:14:01 UTC; emilhvitfeldt</td>
</tr>
<tr>
<td>Author:</td>
<td>Emil Hvitfeldt <a href="https://orcid.org/0000-0002-0679-1945"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Max Kuhn <a href="https://orcid.org/0000-0003-2402-136X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emil Hvitfeldt &lt;emil.hvitfeldt@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-08 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rules-package'>rules: Model Wrappers for Rule-Based Models</h2><span id='topic+rules'></span><span id='topic+rules-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Bindings for additional models for use with the 'parsnip' package. Models include prediction rule ensembles (Friedman and Popescu, 2008) <a href="https://doi.org/10.1214/07-AOAS148">doi:10.1214/07-AOAS148</a>, C5.0 rules (Quinlan, 1992 ISBN: 1558602380), and Cubist (Kuhn and Johnson, 2013) <a href="https://doi.org/10.1007/978-1-4614-6849-3">doi:10.1007/978-1-4614-6849-3</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emil Hvitfeldt <a href="mailto:emil.hvitfeldt@posit.co">emil.hvitfeldt@posit.co</a> (<a href="https://orcid.org/0000-0002-0679-1945">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Max Kuhn <a href="mailto:max@posit.co">max@posit.co</a> (<a href="https://orcid.org/0000-0003-2402-136X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tidymodels/rules">https://github.com/tidymodels/rules</a>
</p>
</li>
<li> <p><a href="https://rules.tidymodels.org/">https://rules.tidymodels.org/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/rules/issues">https://github.com/tidymodels/rules/issues</a>
</p>
</li></ul>


<hr>
<h2 id='c5_fit'>Internal function wrappers</h2><span id='topic+c5_fit'></span><span id='topic+c5_pred'></span><span id='topic+tunable.C5_rules'></span><span id='topic+cubist_fit'></span><span id='topic+get_neighbors'></span><span id='topic+tunable.cubist_rules'></span><span id='topic+xrf_fit'></span><span id='topic+xrf_pred'></span><span id='topic+tunable.rule_fit'></span>

<h3>Description</h3>

<p>These are not supported when called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c5_fit(x, y, trials = 1, minCases = 2, cost = NULL, ...)

c5_pred(object, new_data, trials = object$fit$trials["Actual"], ...)

## S3 method for class 'C5_rules'
tunable(x, ...)

cubist_fit(x, y, committees = 1, neighbors = 0, max_rules = NA, ...)

get_neighbors(x)

## S3 method for class 'cubist_rules'
tunable(x, ...)

xrf_fit(
  formula,
  data,
  max_depth = 6,
  nrounds = 15,
  eta = 0.3,
  colsample_bynode = NULL,
  colsample_bytree = NULL,
  min_child_weight = 1,
  gamma = 0,
  subsample = 1,
  validation = 0,
  early_stop = NULL,
  counts = TRUE,
  event_level = c("first", "second"),
  lambda = 0.1,
  ...
)

xrf_pred(object, new_data, lambda = object$fit$lambda, type, ...)

## S3 method for class 'rule_fit'
tunable(x, ...)
</code></pre>

<hr>
<h2 id='committees'>Parameter functions for Cubist models</h2><span id='topic+committees'></span><span id='topic+max_rules'></span>

<h3>Description</h3>

<p>Committee-based models enact a boosting-like procedure to produce ensembles.
<code>committees</code> parameter is for the number of models in the ensembles while
<code>max_rules</code> can be used to limit the number of possible rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>committees(range = c(1L, 100L), trans = NULL)

max_rules(range = c(1L, 500L), trans = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="committees_+3A_range">range</code></td>
<td>
<p>A two-element vector holding the <em>defaults</em> for the smallest and
largest possible values, respectively.</p>
</td></tr>
<tr><td><code id="committees_+3A_trans">trans</code></td>
<td>
<p>A <code>trans</code> object from the <code>scales</code> package, such as
<code>scales::log10_trans()</code> or <code>scales::reciprocal_trans()</code>. If not provided,
the default is used which matches the units used in <code>range</code>. If no
transformation, <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function with classes &quot;quant_param&quot; and &quot;param&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>committees()
committees(4:5)

max_rules()
</code></pre>

<hr>
<h2 id='multi_predict._cubist'><code>multi_predict()</code> methods for rule-based models</h2><span id='topic+multi_predict._cubist'></span><span id='topic+multi_predict._xrf'></span>

<h3>Description</h3>

<p><code>multi_predict()</code> methods for rule-based models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''_cubist''
multi_predict(object, new_data, type = NULL, neighbors = NULL, ...)

## S3 method for class ''_xrf''
multi_predict(object, new_data, type = NULL, penalty = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_predict._cubist_+3A_object">object</code></td>
<td>
<p>A <code>model_fit</code> object.</p>
</td></tr>
<tr><td><code id="multi_predict._cubist_+3A_new_data">new_data</code></td>
<td>
<p>A rectangular data object, such as a data frame.</p>
</td></tr>
<tr><td><code id="multi_predict._cubist_+3A_type">type</code></td>
<td>
<p>A single character value or <code>NULL</code>. This argument is ignored in
the method for <code style="white-space: pre;">&#8288;_cubist&#8288;</code> objects and is handled internally (since
<code>type = "numeric"</code> is always used).</p>
</td></tr>
<tr><td><code id="multi_predict._cubist_+3A_neighbors">neighbors</code></td>
<td>
<p>A numeric vector of neighbors values between zero and nine.</p>
</td></tr>
<tr><td><code id="multi_predict._cubist_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="multi_predict._cubist_+3A_penalty">penalty</code></td>
<td>
<p>Non-negative penalty values.</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+multi_predict'></span><span id='topic+tidy'></span><span id='topic+tunable'></span><span id='topic+mtry_prop'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dials</dt><dd><p><code><a href="dials.html#topic+mtry_prop">mtry_prop</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+tidy">tidy</a></code>, <code><a href="generics.html#topic+tunable">tunable</a></code></p>
</dd>
<dt>parsnip</dt><dd><p><code><a href="parsnip.html#topic+multi_predict">multi_predict</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tidy.C5.0'>Turn C5.0 and rule-based models into tidy tibbles</h2><span id='topic+tidy.C5.0'></span><span id='topic+tidy.cubist'></span><span id='topic+tidy.xrf'></span>

<h3>Description</h3>

<p>Turn C5.0 and rule-based models into tidy tibbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'C5.0'
tidy(x, trees = x$trials["Actual"], ...)

## S3 method for class 'cubist'
tidy(x, committees = x$committee, ...)

## S3 method for class 'xrf'
tidy(x, penalty = NULL, unit = c("rules", "columns"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy.C5.0_+3A_x">x</code></td>
<td>
<p>A <code>Cubist</code>, <code>C5.0</code>, or <code>xrf</code> object.</p>
</td></tr>
<tr><td><code id="tidy.C5.0_+3A_trees">trees</code></td>
<td>
<p>The number of boosting iterations to tidy (defaults to the entire
ensemble).</p>
</td></tr>
<tr><td><code id="tidy.C5.0_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="tidy.C5.0_+3A_committees">committees</code></td>
<td>
<p>The number of committees to tidy (defaults to the entire
ensemble).</p>
</td></tr>
<tr><td><code id="tidy.C5.0_+3A_penalty">penalty</code></td>
<td>
<p>A single numeric value for the <code>lambda</code> penalty value.</p>
</td></tr>
<tr><td><code id="tidy.C5.0_+3A_unit">unit</code></td>
<td>
<p>What data should be returned? For <code>unit = 'rules'</code>, each row
corresponds to a rule. For <code>unit = 'columns'</code>, each row is a predictor
column. The latter can be helpful when determining variable importance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outputs for these tidy functions are different since the model
structures are different.
</p>
<p>Let’s look at Cubist and RuleFit first, using the Ames data, then C5.0
with a different data set.
</p>


<h4>An example using the Ames data</h4>

<p>First we will fit a Cubist model and tidy it:
</p>
<div class="sourceCode r"><pre>library(tidymodels)
library(rules)
library(rlang)

data(ames, package = "modeldata")

ames &lt;- ames %&gt;% 
  mutate(Sale_Price = log10(Sale_Price)) %&gt;% 
  select(Sale_Price, Longitude, Latitude, Central_Air)

cb_fit &lt;-
  cubist_rules(committees = 10) %&gt;%
  set_engine("Cubist") %&gt;%
  fit(Sale_Price ~ ., data = ames)

cb_res &lt;- tidy(cb_fit)

cb_res
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 223 x 5
##    committee rule_num rule                                    estimate statistic
##        &lt;int&gt;    &lt;int&gt; &lt;chr&gt;                                   &lt;list&gt;   &lt;list&gt;   
##  1         1        1 ( Central_Air == 'N' ) &amp; ( Latitude &lt;=~ &lt;tibble&gt; &lt;tibble&gt; 
##  2         1        2 ( Latitude &lt;= 41.992611 ) &amp; ( Latitude~ &lt;tibble&gt; &lt;tibble&gt; 
##  3         1        3 ( Central_Air == 'N' ) &amp; ( Latitude &gt; ~ &lt;tibble&gt; &lt;tibble&gt; 
##  4         1        4 ( Latitude &lt;= 42.026997 ) &amp; ( Longitud~ &lt;tibble&gt; &lt;tibble&gt; 
##  5         1        5 ( Longitude &gt; -93.63002 ) &amp; ( Latitude~ &lt;tibble&gt; &lt;tibble&gt; 
##  6         1        6 ( Latitude &lt;= 42.035858 ) &amp; ( Longitud~ &lt;tibble&gt; &lt;tibble&gt; 
##  7         1        7 ( Latitude &lt;= 42.024029 ) &amp; ( Latitude~ &lt;tibble&gt; &lt;tibble&gt; 
##  8         1        8 ( Longitude &gt; -93.602348 ) &amp; ( Latitud~ &lt;tibble&gt; &lt;tibble&gt; 
##  9         1        9 ( Latitude &lt;= 41.991756 ) &amp; ( Longitud~ &lt;tibble&gt; &lt;tibble&gt; 
## 10         1       10 ( Latitude &gt; 42.041813 ) &amp; ( Longitude~ &lt;tibble&gt; &lt;tibble&gt; 
## # ... with 213 more rows
</pre></div>
<p>Since Cubist fits linear regressions within the data from each rule, the
coefficients are in the <code>estimate</code> column and other information are in
<code>statistic</code>:
</p>
<div class="sourceCode r"><pre>cb_res$estimate[[1]]
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 3 x 2
##   term        estimate
##   &lt;chr&gt;          &lt;dbl&gt;
## 1 (Intercept)  -509.  
## 2 Longitude      -5.05
## 3 Latitude        0.99
</pre></div>
<div class="sourceCode r"><pre>cb_res$statistic[[1]]
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 1 x 6
##   num_conditions coverage  mean   min   max error
##            &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1              3       38  4.87  4.12  5.22 0.149
</pre></div>
<p>Note that we can get the data for this rule by using
<code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> with it:
</p>
<div class="sourceCode r"><pre>rule_1_expr &lt;- parse_expr(cb_res$rule[1])
rule_1_expr
</pre></div>
<div class="sourceCode"><pre>## (Central_Air == "N") &amp; (Latitude &lt;= 42.026997) &amp; (Longitude &gt; 
##     -93.639572)
</pre></div>
<p>then use it to get the data back:
</p>
<div class="sourceCode r"><pre>filter(ames, !!rule_1_expr)
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 38 x 4
##    Sale_Price Longitude Latitude Central_Air
##         &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;      
##  1       5.04     -93.6     42.0 N          
##  2       4.74     -93.6     42.0 N          
##  3       4.75     -93.6     42.0 N          
##  4       4.54     -93.6     42.0 N          
##  5       4.64     -93.6     42.0 N          
##  6       5.22     -93.6     42.0 N          
##  7       4.80     -93.6     42.0 N          
##  8       4.99     -93.6     42.0 N          
##  9       5.09     -93.6     42.0 N          
## 10       4.89     -93.6     42.0 N          
## # ... with 28 more rows
</pre></div>
<p>Now let’s fit a RuleFit model. First, we’ll use a recipe to convert the
Central Air predictor to an indicator:
</p>
<div class="sourceCode r"><pre>xrf_reg_mod &lt;-
  rule_fit(trees = 3, penalty = .001) %&gt;%
  set_engine("xrf") %&gt;%
  set_mode("regression")
# Make dummy variables since xgboost will not

ames_rec &lt;-
  recipe(Sale_Price ~ ., data = ames) %&gt;%
  step_dummy(Central_Air) %&gt;%
  step_zv(all_predictors())

ames_processed &lt;- prep(ames_rec) %&gt;% bake(new_data = NULL)

xrf_reg_fit &lt;-
  xrf_reg_mod %&gt;%
  fit(Sale_Price ~ ., data = ames_processed)

xrf_rule_res &lt;- tidy(xrf_reg_fit, penalty = .001)

xrf_rule_res
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 8 x 3
##   rule_id       rule                                                    estimate
##   &lt;chr&gt;         &lt;chr&gt;                                                      &lt;dbl&gt;
## 1 (Intercept)   ( TRUE )                                                 16.4   
## 2 Central_Air_Y ( Central_Air_Y )                                         0.0567
## 3 Latitude      ( Latitude )                                             -0.424 
## 4 Longitude     ( Longitude )                                            -0.0694
## 5 r1_1          ( Longitude &lt;  -93.6299744 )                              0.102 
## 6 r2_3          ( Central_Air_Y &lt;  0.5 ) &amp; ( Latitude &lt;  42.0460129 )    -0.136 
## 7 r2_5          ( Latitude &gt;= 42.0460129 ) &amp; ( Longitude &lt;  -93.650901~   0.302 
## 8 r2_6          ( Latitude &gt;= 42.0460129 ) &amp; ( Longitude &gt;= -93.650901~   0.0853
</pre></div>
<p>Here, the focus is on the model coefficients produced by <code>glmnet</code>. We
can also break down the results and sort them by the original predictor
columns:
</p>
<div class="sourceCode r"><pre>tidy(xrf_reg_fit, penalty = .001, unit = "columns")
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 11 x 3
##    rule_id       term          estimate
##    &lt;chr&gt;         &lt;chr&gt;            &lt;dbl&gt;
##  1 r1_1          Longitude       0.102 
##  2 r2_3          Latitude       -0.136 
##  3 r2_5          Latitude        0.302 
##  4 r2_6          Latitude        0.0853
##  5 r2_3          Central_Air_Y  -0.136 
##  6 r2_5          Longitude       0.302 
##  7 r2_6          Longitude       0.0853
##  8 (Intercept)   (Intercept)    16.4   
##  9 Longitude     Longitude      -0.0694
## 10 Latitude      Latitude       -0.424 
## 11 Central_Air_Y Central_Air_Y   0.0567
</pre></div>



<h4>C5.0 classification models</h4>

<p>Here, we’ll use the Palmer penguin data:
</p>
<div class="sourceCode r"><pre>data(penguins, package = "modeldata")

penguins &lt;- drop_na(penguins)
</pre></div>
<p>First, let’s fit a boosted rule-based model and tidy:
</p>
<div class="sourceCode r"><pre>rule_model &lt;- 
  C5_rules(trees = 3) %&gt;% 
  fit(island ~ ., data = penguins)

rule_info &lt;- tidy(rule_model)

rule_info
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 25 x 4
##    trial rule_num rule                                                 statistic
##    &lt;int&gt;    &lt;int&gt; &lt;chr&gt;                                                &lt;list&gt;   
##  1     1        1 ( bill_length_mm &gt; 37.5 )                            &lt;tibble&gt; 
##  2     1        2 ( species == 'Chinstrap' )                           &lt;tibble&gt; 
##  3     1        3 ( body_mass_g &gt; 3200 ) &amp; ( body_mass_g &lt; 3700 ) &amp; (~ &lt;tibble&gt; 
##  4     1        4 ( flipper_length_mm &lt; 193 )                          &lt;tibble&gt; 
##  5     1        5 ( species == 'Adelie' ) &amp; ( bill_length_mm &gt; 38.299~ &lt;tibble&gt; 
##  6     1        6 ( bill_length_mm &lt; 40.799999 ) &amp; ( bill_depth_mm &gt; ~ &lt;tibble&gt; 
##  7     1        7 ( species == 'Adelie' ) &amp; ( bill_length_mm &gt; 41.599~ &lt;tibble&gt; 
##  8     1        8 ( species == 'Adelie' ) &amp; ( bill_depth_mm &gt; 18.9 ) ~ &lt;tibble&gt; 
##  9     2        1 ( species == 'Gentoo' )                              &lt;tibble&gt; 
## 10     2        2 ( body_mass_g &gt; 3700 ) &amp; ( sex == 'female' )         &lt;tibble&gt; 
## # ... with 15 more rows
</pre></div>
<div class="sourceCode r"><pre># The statistic column has the pre-computed data about the 
# data covered by the rule:
rule_info$statistic[[1]]
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 1 x 4
##   num_conditions coverage  lift class 
##            &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 
## 1              1      286  1.10 Biscoe
</pre></div>
<p>Tree-based models can also be tidied. Rather than saving the results in
a recursive tree structure, we can show the paths to each of the
terminal nodes (which is just a rule).
</p>
<p>Let’s fit a model and tidy:
</p>
<div class="sourceCode r"><pre>tree_model &lt;- 
  boost_tree(trees = 3) %&gt;% 
  set_engine("C5.0") %&gt;% 
  set_mode("classification") %&gt;% 
  fit(island ~ ., data = penguins)

tree_info &lt;- tidy(tree_model)

tree_info
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 34 x 4
##    trial  node rule                                                    statistic
##    &lt;int&gt; &lt;int&gt; &lt;chr&gt;                                                   &lt;list&gt;   
##  1     1     1 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"female\" ~ &lt;tibble&gt; 
##  2     1     2 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"female\" ~ &lt;tibble&gt; 
##  3     1     3 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"female\" ~ &lt;tibble&gt; 
##  4     1     4 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"female\" ~ &lt;tibble&gt; 
##  5     1     5 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"female\" ~ &lt;tibble&gt; 
##  6     1     6 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"female\" ~ &lt;tibble&gt; 
##  7     1     7 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"female\" ~ &lt;tibble&gt; 
##  8     1     8 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"male\" ) ~ &lt;tibble&gt; 
##  9     1     9 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"male\" ) ~ &lt;tibble&gt; 
## 10     1    10 "( species %in% c(\"Adelie\") ) &amp; ( sex == \"male\" ) ~ &lt;tibble&gt; 
## # ... with 24 more rows
</pre></div>
<div class="sourceCode r"><pre># The statistic column has the class breakdown:
tree_info$statistic[[1]]
</pre></div>
<div class="sourceCode"><pre>## # A tibble: 3 x 2
##   value     count
##   &lt;chr&gt;     &lt;dbl&gt;
## 1 Biscoe        3
## 2 Dream         1
## 3 Torgersen     0
</pre></div>
<p>Note that C5.0 models can have fractional estimates of counts in the
terminal nodes.
</p>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
