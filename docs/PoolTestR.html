<!DOCTYPE html><html lang="en-AU"><head><title>Help for package PoolTestR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PoolTestR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PoolTestR-package'><p>PoolTestR: Prevalence and Regression for Pool-Tested (Group-Tested) Data</p></a></li>
<li><a href='#ExampleData'><p>A synthetic dataset for pooled testing</p></a></li>
<li><a href='#getPrevalence'><p>Predicting Prevalence from a Mixed or Fixed Effect Logistic Regression with</p>
Presence/Absence Tests on Pooled Samples</a></li>
<li><a href='#HierPoolPrev'><p>Estimation of prevalence based on presence/absence tests on pooled samples in</p>
a hierarchical sampling frame. Uses an intercept-only random effects model to
model prevalence at population level. See PoolReg and PoolRegBayes for full
mixed-effect modelling</a></li>
<li><a href='#PoolLink'><p>Link Function for Logistic Regression with Presence/Absence Tests on Pooled Samples</p></a></li>
<li><a href='#PoolPrev'><p>Estimation of prevalence based on presence/absence tests on pooled samples</p></a></li>
<li><a href='#PoolReg'><p>Frequentist Mixed or Fixed Effect Logistic Regression with Presence/Absence</p>
Tests on Pooled Samples</a></li>
<li><a href='#PoolRegBayes'><p>Bayesian Mixed or Fixed Effect Logistic Regression with Presence/Absence</p>
Tests on Pooled Samples</a></li>
<li><a href='#SimpleExampleData'><p>A synthetic dataset for pooled testing</p></a></li>
<li><a href='#TruePrev'><p>A synthetic dataset for pooled testing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Prevalence and Regression for Pool-Tested (Group-Tested) Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An easy-to-use tool for working with presence/absence tests
    on 'pooled' or 'grouped' samples. The primary application is for
    estimating prevalence of a marker in a population based on the results
    of tests on pooled specimens.  This sampling method is often employed
    in surveillance of rare conditions in humans or animals (e.g.
    molecular xenomonitoring). The package was initially conceived as an
    R-based alternative to the molecular xenomonitoring software,
    'PoolScreen' <a href="https://sites.uab.edu/statgenetics/software/">https://sites.uab.edu/statgenetics/software/</a>. However,
    it goes further, allowing for estimates of prevalence to be adjusted
    for hierarchical sampling frames, and perform flexible mixed-effect
    regression analyses (McLure et al. Environmental Modelling and
    Software.  &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2021.105158">doi:10.1016/j.envsoft.2021.105158</a>&gt;). The package is
    currently in early stages, however more features are planned or in the
    works: e.g. adjustments for imperfect test specificity/sensitivity,
    functions for helping with optimal experimental design, and functions
    for spatial modelling.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AngusMcLure/PoolTestR">https://github.com/AngusMcLure/PoolTestR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AngusMcLure/PoolTestR/issues">https://github.com/AngusMcLure/PoolTestR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brms, dplyr, lme4 (&ge; 1.1-35.1), methods, progress, Rcpp (&ge;
0.12.0), RcppParallel (&ge; 5.0.1), rlang, rstan (&ge; 2.26.0),
rstantools (&ge; 2.3.1.1), stats, stringr, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-AU</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-05 01:08:44 UTC; caitlin</td>
</tr>
<tr>
<td>Author:</td>
<td>Angus McLure <a href="https://orcid.org/0000-0003-2551-3059"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Caitlin Cherryh <a href="https://orcid.org/0000-0001-6146-4376"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Angus McLure &lt;angus.mclure@anu.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-05 05:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='PoolTestR-package'>PoolTestR: Prevalence and Regression for Pool-Tested (Group-Tested) Data</h2><span id='topic+PoolTestR-package'></span><span id='topic+PoolTestR'></span>

<h3>Description</h3>

<p>An easy-to-use tool for working with presence/absence tests on 'pooled' or 'grouped' samples. The primary application is for estimating prevalence of a marker in a population based on the results of tests on pooled specimens. This sampling method is often employed in surveillance of rare conditions in humans or animals (e.g. molecular xenomonitoring). The package was initially conceived as an R-based alternative to the molecular xenomonitoring software, 'PoolScreen' <a href="https://sites.uab.edu/statgenetics/software/">https://sites.uab.edu/statgenetics/software/</a>. However, it goes further, allowing for estimates of prevalence to be adjusted for hierarchical sampling frames, and perform flexible mixed-effect regression analyses (McLure et al. Environmental Modelling and Software. <a href="https://doi.org/10.1016/j.envsoft.2021.105158">doi:10.1016/j.envsoft.2021.105158</a>). The package is currently in early stages, however more features are planned or in the works: e.g. adjustments for imperfect test specificity/sensitivity, functions for helping with optimal experimental design, and functions for spatial modelling.
</p>
<p>This is a package for working with presence/absence tests on pooled
or grouped samples. The primary application is for estimating prevalence of
a marker in a population based on the results of tests on pooled specimens.
This sampling method is often employed in surveillance of rare conditions in
humans or animals (e.g. livestock or xenomonitoring). The package was initially
conceived as an R-based alternative to the xenomonitoring software,
PoolScreen. However, it goes further, allowing for estimates of prevalence to
adjusted for hierarchy in sampling frames, and perform flexible (mixed effect)
regression analyses. The package is currently in early stages, however more
features are planned or in the works: e.g. adjustments for imperfect test
specificity/sensitivity, functions for helping with optimal experimental
design, and functions for spatial modelling.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Angus McLure <a href="mailto:angus.mclure@anu.edu.au">angus.mclure@anu.edu.au</a> (<a href="https://orcid.org/0000-0003-2551-3059">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Caitlin Cherryh (<a href="https://orcid.org/0000-0001-6146-4376">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Angus McLure, Ben O'Neill, Helen Mayfield, Colleen Lau, Brady McPherson (2021). PoolTestR: An R package for estimating prevalence and regression modelling for molecular xenomonitoring and other applications with pooled samples. Environmental Modelling &amp; Software, 145:105158. &lt;DOI:10.1016/j.envsoft.2021.105158&gt;
</p>
<p>Stan Development Team (2019). RStan: the R interface to Stan. R package version 2.19.2. https://mc-stan.org
</p>
<p>Paul-Christian BÃ¼rkner (2017). brms: An R Package for Bayesian Multilevel Models Using Stan. Journal of Statistical Software, 80(1), 1-28. &lt;DOI:10.18637/jss.v080.i01&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/AngusMcLure/PoolTestR">https://github.com/AngusMcLure/PoolTestR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/AngusMcLure/PoolTestR/issues">https://github.com/AngusMcLure/PoolTestR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ExampleData'>A synthetic dataset for pooled testing</h2><span id='topic+ExampleData'></span>

<h3>Description</h3>

<p>A synthetic dataset mimicking a realistic hierarchical sampling frame.
Simulated samples are taken from across three regions (A, B, and C) in which
the vectors have a low (0.5%), medium (2%), and high (4%) prevalence of
the marker of interest. Ten villages are chosen within each region, and traps
are placed at ten sites within each village. Every site is sampled once a
year over three years (0, 1, and 2). Prevalence is not uniform within each
region or over time. At baseline (year 0), prevalence varies between villages
within each region around the mean for the region, and prevalence varies
between sites within each village around the mean for the village.
Consequently though the prevalence is different for each site, two sites
within the same village are likely to have a more similar prevalence than two
sites in different villages, or two sites in different regions. On average
the prevalence is declining over time (odds ratio of 0.8 per year), however,
the growth rate varies between villages. Consequently two sites in different
villages with similar prevalence at baseline may have different prevalence by
the third year, and prevalence may go up in some villages. Each year the
traps at each site catch a negative binomial number (mean 200, dispersion 5)
of vectors. The catch size at each site and year is independent. Each year,
the catches at each site are pooled into groups of 25 with an additional pool
for any remainder (e.g. a catch of 107 vectors will be pooled into 4 pools of
25 and one pool of 7). Test results on each pool are simulated assuming the
test has perfect sensitivity and specificity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleData
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables: </p>

<dl>
<dt>NumInPool</dt><dd><p>Number of specimens in pool. Range = 1:25</p>
</dd>
<dt>Region</dt><dd><p>ID of the region the pool was taken from. &quot;A&quot;, &quot;B&quot;, or &quot;C&quot;</p>
</dd>
<dt>Village</dt><dd><p>ID of village that pool was taken from. Includes name of region e.g. &quot;B-3&quot; is village 3 from region B</p>
</dd>
<dt>Site</dt><dd><p>ID of site that pool was taken from. Includes name of region and village e.g. &quot;B-3-7&quot; is site 7 from village 3 from region B</p>
</dd>
<dt>Result</dt><dd><p>Result of test on pool; 0 = negative, 1 = positive</p>
</dd>
<dt>Year</dt><dd><p>Year of sampling. Years are 0, 1, or 2</p>
</dd> </dl>



<h3>Details</h3>

<p>The 'true' model can be summarised in formula notation as:
</p>
<p>Result ~ Region + Year + (1+Year|Village) + (1|Site)
</p>
<p>where the coefficient for Year is log(0.8), the standard deviation for
intercept random effects for village and site are both 0.5, the standard
deviation for the year random effect for village is 0.2 and the random
effects are all uncorrelated/independent.
</p>

<hr>
<h2 id='getPrevalence'>Predicting Prevalence from a Mixed or Fixed Effect Logistic Regression with
Presence/Absence Tests on Pooled Samples</h2><span id='topic+getPrevalence'></span><span id='topic+getPrevalence.glm'></span><span id='topic+getPrevalence.glmerMod'></span><span id='topic+getPrevalence.brmsfit'></span>

<h3>Description</h3>

<p>This function works somewhat like a <code>predict</code> or <code>fitted</code> generic
function returning the model predicted prevalence for a given set of data;
however, as the quantity of interest (prevalence) is neither on the response
or link scale we do not use either of these generic functions. Further, when
the model accounts for the hierarchical structure of the sampling frame (e.g.
Region/Village/Site), it is common to want to know the predicted values at
each level of sampling (e.g. Prevalence at each region, village or site) so
these are calculated automatically. Also to calculate population-level
prevalence from a mixed model, random/group effects need to marginalised out
to avoid biased estimates. This is performed automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPrevalence(model, ...)

## S3 method for class 'glm'
getPrevalence(model, newdata = NULL, level = 0.95, ...)

## S3 method for class 'glmerMod'
getPrevalence(
  model,
  newdata = NULL,
  re.form = NULL,
  all.negative.pools = "zero",
  ...
)

## S3 method for class 'brmsfit'
getPrevalence(
  model,
  newdata = NULL,
  re.form = NULL,
  robust = TRUE,
  level = 0.95,
  all.negative.pools = "zero",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPrevalence_+3A_model">model</code></td>
<td>
<p>An object returned by [PoolReg()] or [PoolRegBayes()]</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods for each class</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_newdata">newdata</code></td>
<td>
<p>The data for which prevalence needs to be estimated/predicted.
If not provided, defaults to using the data used to train the model (i.e.
returns the fitted values of the prevalence)</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_level">level</code></td>
<td>
<p>Defines the confidence level to be used for the confidence and
credible intervals. Defaults to 0.95 (i.e. 95% intervals).</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_re.form">re.form</code></td>
<td>
<p>A description of which random effects to include in the
prediction. If omitted, an attempt is made to infer from model and data
structure.</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_all.negative.pools">all.negative.pools</code></td>
<td>
<p>The kind of point estimate and interval to use when
all pools are negative. Typically ignored unless newdata is NULL. If 
<code>'zero'</code> (default), uses 0 as the point estimate and lower bound for 
the interval and <code>level</code> posterior quantile the upper bound of the 
interval. If <code>'consistent'</code>, result is the same as for the case where 
at least one pool is positive.</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_robust">robust</code></td>
<td>
<p>Logical. Option when model class is <code>brmsfit</code>. If 
<code>TRUE</code> (default) the point estimate of prevalence is the posterior 
median. If <code>FALSE</code>, the the posterior mean is used instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>re.form</code> is omitted (probably the most common use case)
<code>getPrevalence</code> will test to see if there are any random effect terms in
the model formula extracted from the <code>model</code> object. If not, it just
returns the estimates based on population effects. If there are random
effects, it tests to see if the random effect variables form a nested
hierarchical structure in the data provided. If so, in addition to the
estimates based on population effects only, it will estimate at different
levels of the nested hierarchical structure in order of increasing
granularity. For manual control you can set to NA for population effects
only, or a one-sided formula specifying the form of the random effects to
include in estimates, or a list of such objects. Any random effects omitted
will be marginalised out. For automatically detected nested hierarchical
structures this means that higher level estimates marginalise over
lower-level random effect; in particular, population level estimates will
marginalise over all random effects.
</p>


<h3>Value</h3>

<p>A <code>list</code> with at least one field <code>PopulationEffects</code> and an
additional field for every random/group effect variable. The field
<code>PopulationEffects</code> contains a <code>data.frame</code> with the prevalence
estimated based only the fixed/population effects. When the intercept is
the only fixed/population effect, this is just the population mean
(possibly adjusted for random/group effects). When there are group effects
terms, <code>getPrevalence</code> attempts to order these with respect to
'granularity' and extract the prevalence estimates for these random
effects; e.g. if the random/group effects included are there to account for
a hierarchical sampling frame with levels 'Village' and 'Site' with a
formula like <code>Result ~ Cov1 + Cov2 + (1|Village) + (1|Site)</code>, then
getPrevalence will be a list of three data frames: estimates for every
combination of covariates, estimates for every combination of covariates
and village, and estimates for every combination of covariates, village,
and site.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoolReg">PoolReg</a></code>, <code><a href="#topic+PoolRegBayes">PoolRegBayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform logistic-type regression modelling for a synthetic dataset consisting
# of pools (sizes 1, 5, or 10) taken from 4 different regions and 3 different
# years. Within each region specimens are collected at 4 different villages,
# and within each village specimens are collected at 8 different sites.


### Models in a frequentist framework
#ignoring hierarchical sampling frame within each region
Mod &lt;- PoolReg(Result ~ Region + Year,
               data = SimpleExampleData,
               poolSize = NumInPool)
summary(Mod)

#accounting hierarchical sampling frame within each region
HierMod &lt;- PoolReg(Result ~ Region + Year + (1|Village) + (1|Site),
                   data = SimpleExampleData,
                   poolSize = NumInPool)
summary(HierMod)


### Models in a Bayesian framework with default (non-informative) priors
#ignoring hierarchical sampling frame within each region

  BayesMod &lt;- PoolRegBayes(Result ~ Region + Year,
                           data = SimpleExampleData,
                           poolSize = NumInPool)
  summary(BayesMod)

  #we could also account for hierarchical sampling frame within each region but
  #note that this is more complex and slower)

  # BayesHierMod &lt;- PoolRegBayes(Result ~ Region + Year + (1|Village) + (1|Site),
  #                              data = SimpleExampleData,
  #                              poolSize = NumInPool)


### Calculate adjusted estimates of prevalence
# We use the same function for all four models, but the outputs are slightly different

#For models without hierarchical sampling structure there is an estimate of
#prevalence for every combination of population (fixed) effects: e.g. Region and
#Year
getPrevalence(Mod) #Frequentist model

  getPrevalence(BayesMod) #Bayesian model


#For models without hierarchical sampling structure, there is a prevalence
#estimate for each combination of region and year and then at each level of the
#hierarchical sampling frame (i.e. for each village in each region and each site
#in each village)
getPrevalence(HierMod)

# You can also use getPrevalence to predict prevalence for other values of the
# covariates (e.g. predict prevalence in year 4 based on linear trend on the
# logit scale)

#Making a data frame containing data make predictions on
DataFuture &lt;- unique(data.frame(Region = SimpleExampleData$Region,
                                Village = SimpleExampleData$Village,
                                Site = SimpleExampleData$Site,
                                Year = 4))

getPrevalence(Mod, newdata = DataFuture)
getPrevalence(HierMod, newdata = DataFuture)
</code></pre>

<hr>
<h2 id='HierPoolPrev'>Estimation of prevalence based on presence/absence tests on pooled samples in
a hierarchical sampling frame. Uses an intercept-only random effects model to
model prevalence at population level. See PoolReg and PoolRegBayes for full
mixed-effect modelling</h2><span id='topic+HierPoolPrev'></span>

<h3>Description</h3>

<p>Estimation of prevalence based on presence/absence tests on pooled samples in
a hierarchical sampling frame. Uses an intercept-only random effects model to
model prevalence at population level. See PoolReg and PoolRegBayes for full
mixed-effect modelling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierPoolPrev(
  data,
  result,
  poolSize,
  hierarchy,
  ...,
  prior = NULL,
  robust = TRUE,
  level = 0.95,
  verbose = FALSE,
  cores = NULL,
  iter = 2000,
  warmup = iter/2,
  chains = 4,
  control = list(adapt_delta = 0.9),
  all.negative.pools = "zero"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HierPoolPrev_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with one row for each pooled sampled and
columns for the size of the pool (i.e. the number of specimens / isolates /
insects pooled to make that particular pool), the result of the test of the
pool. It may also contain additional columns with additional information
(e.g. location where pool was taken) which can optionally be used for
splitting the data into smaller groups and calculating prevalence by group
(e.g. calculating prevalence for each location)</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_result">result</code></td>
<td>
<p>The name of column with the result of each test on each pooled
sample. The result must be stored with 1 indicating a positive test result
and 0 indicating a negative test result.</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_poolsize">poolSize</code></td>
<td>
<p>The name of the column with number of
specimens/isolates/insects in each pool</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_hierarchy">hierarchy</code></td>
<td>
<p>The name of column(s) indicating the group membership. In a
nested sampling design with multiple levels of grouping the lower-level
groups must have names/numbers that differentiate them from all other
groups at the same level. E.g. If sampling was performed at 200 sites
across 10 villages (20 site per village), then there should be 200 unique
names for the sites. If, for instance, the sites are instead numbered 1 to
20 within each village, the village identifier (e.g. A, B, C...) should be
combined with the site number to create unique identifiers for each site
(e.g. A-1, A-2... for sites in village A and B-1, B-2... for the sites in
village B etc.)</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_...">...</code></td>
<td>
<p>Optional name(s) of columns with variables to stratify the data
by. If omitted the complete dataset is used to estimate a single
prevalence. If included prevalence is estimated separately for each group
defined by these columns</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_prior">prior</code></td>
<td>
<p>List of parameters specifying the parameters for the the priors
on the population intercept and standard deviations of group-effect terms.
See details.</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_robust">robust</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the point estimate of 
prevalence is the posterior median. If <code>FALSE</code>, the posterior mean is
used instead.</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_level">level</code></td>
<td>
<p>The confidence level to be used for the confidence and credible
intervals. Defaults to 0.95 (i.e. 95% intervals)</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print progress to screen.
Defaults to false (no printing to screen)</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_cores">cores</code></td>
<td>
<p>The number of CPU cores to be used. By default one core is used</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_iter">iter</code>, <code id="HierPoolPrev_+3A_warmup">warmup</code>, <code id="HierPoolPrev_+3A_chains">chains</code></td>
<td>
<p>MCMC options for passing onto the sampling routine.
See <a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behaviour.
Defaults to default values as defined in <a href="rstan.html#topic+stan">stan</a>, except for
<code>adapt_delta</code> which is set to the more conservative value of 0.9. See
<a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_all.negative.pools">all.negative.pools</code></td>
<td>
<p>The kind of point estimate and interval to use when
all pools are negative (Bayesian estimates only). If <code>'zero'</code> 
(default), uses 0 as the point estimate and lower bound for the interval 
and <code>level</code> posterior quantile the upper bound of the interval. If 
<code>'consistent'</code>, result is the same as for the case where at least one 
pool is positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using the default value of the <code>prior</code> argument (NULL), the model
uses the following prior:
<code>list(intercept = list(nu = 3, mu = 0, sigma = 4.0),
             group_sd  = list(nu = 3, mu = 0, sigma = 2.5),
             individual_sd = FALSE)</code>
This models the prior of the linear scale intercept as t-distributed with
parameters in 'intercept' and the standard deviation of the group-level
effects as truncated (non-negative) t-distribution. 'individual_sd = FALSE'
means that this prior is for the root-sum-square of group-effect standard
deviations for models with multiple grouping levels. The default implies a
prior on population prevalence that is approximately distributed as
beta(0.5,0.5). To set custom priors, use the same nested list format. Any
omitted parameters will be replaced with the default values and additional
parameters ignored silently. For example, to change the parameters to be
equal to the defaults for intercept-only random-effect model in PoolRegBayes
you can use: <code>list(individual_sd = TRUE)</code>, which puts a prior on each
the standard deviations of each of group-level effects separately, but
doesn't change the priors used.
</p>


<h3>Value</h3>

<p>An object of class <code>HierPoolPrevOutput</code>, which inherits from 
class <code>tbl</code>. 
The output includes the following columns:
</p>
<ul>
<li><p><code>PrevBayes</code> &ndash; the (Bayesian) posterior expectation
</p>
</li>
<li><p><code>CrILow</code> and <code>CrIHigh</code> &ndash; lower and upper bounds
for credible intervals
</p>
</li>
<li><p><code>NumberOfPools</code> &ndash; number of pools
</p>
</li>
<li><p><code>NumberPositive</code> &ndash; the number of positive pools
</p>
</li>
<li><p><code>ICC</code> &ndash; the estimated intra-cluster correlation
coefficient
</p>
</li>
<li><p><code>ICC_CrILow</code> and <code>ICC_CrIHigh</code> &ndash; lower and upper
bounds for credible intervals of the estimated ICC </p>
</li></ul>

<p>The three ICC columns (<code>ICC</code>, <code>ICC_CrILow</code> and
<code>ICC_CrIHigh</code>) are matrix columns. These contain one column for each
variable included in the <code>hierarchy</code>. E.g., if the input hierarchy is
<code>c("Village", "Site")</code>, each of the three ICC matrix columns will
contain one column with results for <code>Village</code> and one column with
results for <code>Site</code>.
</p>
<p>If grouping variables are provided in <code>...</code> there will be an
additional column for each grouping variable. When there are no grouping
variables (supplied in <code>...</code>) then the output has only one row with
the prevalence estimates for the whole dataset. When grouping variables are
supplied, then there is a separate row for each group.
</p>
<p>The custom print method summarises the output data frame by representing
output variables with credible intervals (i.e., <code>PrevBayes</code>,
<code>ICC</code>) as a single column in the form <code>"X (CrILow - CrIHigh)"</code>
where <code>X</code> is the variable, <code>CrILow</code> is the lower credible
interval and <code>CrIHigh</code> is the upper credible interval. In the print
method,  prevalence <code>PrevBayes</code> is represented as a percentage (i.e.,
per 100 units).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoolPrev">PoolPrev</a></code>, <code><a href="#topic+getPrevalence">getPrevalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate prevalence for a synthetic dataset consisting of pools (sizes 1, 5,
# or 10) taken from 3 different years. Specimens are collected at 16 different
# villages, and within each village specimens are collected at 8 different
# sites.


  #Prevalence for each year:
  #ignoring hierarchical sampling frame be:
  PoolPrev(SimpleExampleData, Result, NumInPool, Year)
  #accounting hierarchical sampling frame within each region
  HierPoolPrev(SimpleExampleData, Result, NumInPool, c("Village","Site"), Year)



</code></pre>

<hr>
<h2 id='PoolLink'>Link Function for Logistic Regression with Presence/Absence Tests on Pooled Samples</h2><span id='topic+PoolLink'></span>

<h3>Description</h3>

<p>A custom link function for the <code><a href="stats.html#topic+binomial">binomial</a></code> family to be used with <code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolLink(PoolSize = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoolLink_+3A_poolsize">PoolSize</code></td>
<td>
<p>The number of specimens/isolates/insects in each pool. When used with glm, the
length must either be 1 if all the pools are the same size, but the same length
as the data otherwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>link-glm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform logistic-type regression modelling for a synthetic dataset consisting
# of pools (sizes 1, 5, or 10) taken from 4 different regions and 3 different
# years. Within each region specimens are collected at 4 different villages,
# and within each village specimens are collected at 8 different sites.


### Models in a frequentist framework
#ignoring hierarchical sampling frame within each region
Mod &lt;- PoolReg(Result ~ Region + Year,
               data = SimpleExampleData,
               poolSize = NumInPool)
summary(Mod)

#accounting hierarchical sampling frame within each region
HierMod &lt;- PoolReg(Result ~ Region + Year + (1|Village) + (1|Site),
                   data = SimpleExampleData,
                   poolSize = NumInPool)
summary(HierMod)


### Models in a Bayesian framework with default (non-informative) priors
#ignoring hierarchical sampling frame within each region

  BayesMod &lt;- PoolRegBayes(Result ~ Region + Year,
                           data = SimpleExampleData,
                           poolSize = NumInPool)
  summary(BayesMod)

  #we could also account for hierarchical sampling frame within each region but
  #note that this is more complex and slower)

  # BayesHierMod &lt;- PoolRegBayes(Result ~ Region + Year + (1|Village) + (1|Site),
  #                              data = SimpleExampleData,
  #                              poolSize = NumInPool)


### Calculate adjusted estimates of prevalence
# We use the same function for all four models, but the outputs are slightly different

#For models without hierarchical sampling structure there is an estimate of
#prevalence for every combination of population (fixed) effects: e.g. Region and
#Year
getPrevalence(Mod) #Frequentist model

  getPrevalence(BayesMod) #Bayesian model


#For models without hierarchical sampling structure, there is a prevalence
#estimate for each combination of region and year and then at each level of the
#hierarchical sampling frame (i.e. for each village in each region and each site
#in each village)
getPrevalence(HierMod)

# You can also use getPrevalence to predict prevalence for other values of the
# covariates (e.g. predict prevalence in year 4 based on linear trend on the
# logit scale)

#Making a data frame containing data make predictions on
DataFuture &lt;- unique(data.frame(Region = SimpleExampleData$Region,
                                Village = SimpleExampleData$Village,
                                Site = SimpleExampleData$Site,
                                Year = 4))

getPrevalence(Mod, newdata = DataFuture)
getPrevalence(HierMod, newdata = DataFuture)
</code></pre>

<hr>
<h2 id='PoolPrev'>Estimation of prevalence based on presence/absence tests on pooled samples</h2><span id='topic+PoolPrev'></span>

<h3>Description</h3>

<p>Estimation of prevalence based on presence/absence tests on pooled samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolPrev(
  data,
  result,
  poolSize,
  ...,
  bayesian = TRUE,
  prior = NULL,
  robust = TRUE,
  level = 0.95,
  all.negative.pools = "zero",
  reproduce.poolscreen = FALSE,
  verbose = FALSE,
  cores = NULL,
  iter = 2000,
  warmup = iter/2,
  chains = 4,
  control = list(adapt_delta = 0.98)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoolPrev_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with one row for each pooled sampled and
columns for the size of the pool (i.e. the number of specimens / isolates /
insects pooled to make that particular pool), the result of the test of the
pool. It may also contain additional columns with additional information
(e.g. location where pool was taken) which can optionally be used for
stratifying the data into smaller groups and calculating prevalence by
group (e.g. calculating prevalence for each location)</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_result">result</code></td>
<td>
<p>The name of column with the result of each test on each pooled
sample. The result must be stored with 1 indicating a positive test result
and 0 indicating a negative test result.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_poolsize">poolSize</code></td>
<td>
<p>The name of the column with number of
specimens/isolates/insects in each pool</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_...">...</code></td>
<td>
<p>Optional name(s) of columns with variables to stratify the data
by. If omitted the complete dataset is used to estimate a single
prevalence. If included, prevalence is estimated separately for each group
defined by these columns</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_bayesian">bayesian</code></td>
<td>
<p>Logical indicating whether Bayesian calculations should be
calculated. If TRUE (the default) calculates frequentist and Bayesian
estimates of prevalence, otherwise only calculates frequentist estimates
(MLE and likelihood ratio confidence intervals).</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_prior">prior</code></td>
<td>
<p>Prior for prevalence, ignored if <code>bayesian == FALSE</code>. If
NULL (the default) the prior for the prevalence is the uninformative
Jeffrey's prior. The only alternative prior is a possibly zero-inflated
beta distribution. Zero inflation allows for some prior (and posterior)
probability that the marker of interest is totally absent from the
population. The parameters for this are specified with a list with three
numeric non-negative entries named alpha, beta, and absent. For instance, a
uniform prior with no probability of true absence can be specified as
<code>prior = list(alpha = 1, beta = 1, absent = 0</code>.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_robust">robust</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the point estimate of 
prevalence is the posterior median. If <code>FALSE</code>, the posterior mean is
used instead. Applies to Bayesian estimates only and therefore ignored if 
<code>bayesian = FALSE</code>.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_level">level</code></td>
<td>
<p>Defines the confidence level to be used for the confidence and
credible intervals. Defaults to 0.95 (i.e. 95% intervals)</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_all.negative.pools">all.negative.pools</code></td>
<td>
<p>The kind of point estimate and interval to use when
all pools are negative (Bayesian estimates only). If <code>'zero'</code> 
(default), uses 0 as the point estimate and lower bound for the interval 
and <code>level</code> posterior quantile the upper bound of the interval. If 
<code>'consistent'</code>, result is the same as for the case where at least one 
pool is positive. Applies to Bayesian estimates only and therefore ignored 
if <code>bayesian == FALSE</code>.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_reproduce.poolscreen">reproduce.poolscreen</code></td>
<td>
<p>(defaults to FALSE). If TRUE this changes the way
that likelihood ratio confidence intervals are computed to be somewhat
wider and more closely match those returned by Poolscreen. We recommend
using the default (FALSE). However setting to TRUE can help to make
comparisons between PoolPrev and Poolscreen.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print progress to screen.
Defaults to false (no printing to screen). Ignored if <code>bayesian ==
FALSE</code>.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_cores">cores</code></td>
<td>
<p>The number of CPU cores to be used. By default one core is used.
Ignored if <code>bayesian == FALSE</code>.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_iter">iter</code>, <code id="PoolPrev_+3A_warmup">warmup</code>, <code id="PoolPrev_+3A_chains">chains</code></td>
<td>
<p>MCMC options for passing onto the sampling routine.
See <a href="rstan.html#topic+stan">stan</a> for details. Ignored if <code>bayesian == FALSE</code>.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behaviour.
Defaults to default values as defined in <a href="rstan.html#topic+stan">stan</a>, except for
<code>adapt_delta</code> which is set to the more conservative value of 0.98. See
<a href="rstan.html#topic+stan">stan</a> for details. Ignored if <code>bayesian == FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PoolPrevOutput</code>, which inherits from 
class <code>tbl</code>. 
The output includes the following columns:
</p>

<ul>
<li><p><code>PrevMLE</code> &ndash; (the Maximum Likelihood Estimate of prevalence)
</p>
</li>
<li><p><code>CILow</code> and <code>CIHigh</code> - lower and upper confidence
intervals using the likelihood
ratio method
</p>
</li>
<li><p><code>PrevBayes</code> &ndash; the (Bayesian) posterior expectation. Omitted
if <code>bayesian == FALSE</code>.
</p>
</li>
<li><p><code>CrILow</code> and <code>CrIHigh</code> &ndash; lower and upper bounds for
credible intervals. Omitted if <code>bayesian == FALSE</code>.
</p>
</li>
<li><p><code>ProbAbsent</code> &ndash; the posterior probability that prevalence is
exactly 0 (i.e. disease marker is absent). NA if using default
Jeffrey's prior or if <code>prior$absent == 0</code>. Omitted if
<code>bayesian == FALSE</code>.
</p>
</li>
<li><p><code>NumberOfPools</code> &ndash; number of pools
</p>
</li>
<li><p><code>NumberPositive</code> &ndash; the number of positive pools </p>
</li></ul>

<p>If grouping variables are provided in <code>...</code> there will be an
additional column for each grouping variable. When there are no grouping
variables (supplied in <code>...</code>) then the output has only one row with
the prevalence estimates for the whole dataset. When grouping variables are
supplied, then there is a separate row for each group.
</p>
<p>The custom print method summarises the output data frame by representing
the prevalence and credible intervals as a single column in the form
<code>"Prev (CLow - CHigh)"</code> where <code>Prev</code> is the prevalence,
<code>CLow</code> is the lower confidence/credible interval and <code>CHigh</code> is
the upper confidence/credible interval. In the print method, prevalence is
represented as a percentage (i.e., per 100 units)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HierPoolPrev">HierPoolPrev</a></code>, <code><a href="#topic+getPrevalence">getPrevalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Try out on a synthetic dataset consisting of pools (sizes 1, 5, or 10) taken
#from 4 different regions and 3 different years. Within each region specimens
#are collected at 4 different villages, and within each village specimens are
#collected at 8 different sites.

# Start by calculate frequentist estimates only (much faster)

#Prevalence across the whole (synthetic) dataset
PoolPrev(SimpleExampleData, Result, NumInPool, bayesian = FALSE)
#Prevalence in each Region
PoolPrev(SimpleExampleData, Result, NumInPool, Region, bayesian = FALSE)
#Prevalence for each year
PoolPrev(SimpleExampleData, Result, NumInPool, Year, bayesian = FALSE)
#Prevalence for each combination of region and year
PoolPrev(SimpleExampleData, Result, NumInPool, Region, Year, bayesian = FALSE)


  #Prevalence across the whole (synthetic) dataset, also including Bayesian Estimates - slower
  PoolPrev(SimpleExampleData, Result, NumInPool)


</code></pre>

<hr>
<h2 id='PoolReg'>Frequentist Mixed or Fixed Effect Logistic Regression with Presence/Absence
Tests on Pooled Samples</h2><span id='topic+PoolReg'></span>

<h3>Description</h3>

<p>It can be useful to do mixed effects logistic regression on the
presence/absence results from pooled samples, however one must adjust for the
size of each pool to correctly identify trends and associations. This can
done by using a custom link function [PoolTestR::PoolLink()], defined in this
package, in conjunction with using <code>glm</code> from the <code>stats</code> package
(fixed effect models) or <code>glmer</code> from the <code>lme4</code> package (mixed
effect models).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolReg(formula, data, poolSize, link = "logit", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoolReg_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> of the kind used to define models in
<code>lme4</code>, which are generalisation of the formulae used in <code>lm</code> or
<code>glm</code> that allow for random/group effects. The left-hand side of the
formula should be the name of column in <code>data</code> with the result of the
test on the pooled samples. The result must be encoded with 1 indicating a
positive test result and 0 indicating a negative test result.</p>
</td></tr>
<tr><td><code id="PoolReg_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with one row for each pooled sampled and
columns for the size of the pool (i.e. the number of specimens / isolates /
insects pooled to make that particular pool), the result of the test of the
pool and any number of columns to be used as the dependent variables in the
logistic regression</p>
</td></tr>
<tr><td><code id="PoolReg_+3A_poolsize">poolSize</code></td>
<td>
<p>The name of the column with number of
specimens/isolates/insects in each pool</p>
</td></tr>
<tr><td><code id="PoolReg_+3A_link">link</code></td>
<td>
<p>link function. There are two options ''logit'' (logistic
regression, the default) and ''cloglog'' (complementary log log
regression).</p>
</td></tr>
<tr><td><code id="PoolReg_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>stats::glm</code> or <code>lme4::glmer</code>
e.g. weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>glmerMod</code> (or <code>glm</code> if there are no
random/group effects)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPrevalence">getPrevalence</a></code>,
<code><a href="#topic+PoolRegBayes">PoolRegBayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform logistic-type regression modelling for a synthetic dataset consisting
# of pools (sizes 1, 5, or 10) taken from 4 different regions and 3 different
# years. Within each region specimens are collected at 4 different villages,
# and within each village specimens are collected at 8 different sites.


### Models in a frequentist framework
#ignoring hierarchical sampling frame within each region
Mod &lt;- PoolReg(Result ~ Region + Year,
               data = SimpleExampleData,
               poolSize = NumInPool)
summary(Mod)

#accounting hierarchical sampling frame within each region
HierMod &lt;- PoolReg(Result ~ Region + Year + (1|Village) + (1|Site),
                   data = SimpleExampleData,
                   poolSize = NumInPool)
summary(HierMod)


### Models in a Bayesian framework with default (non-informative) priors
#ignoring hierarchical sampling frame within each region

  BayesMod &lt;- PoolRegBayes(Result ~ Region + Year,
                           data = SimpleExampleData,
                           poolSize = NumInPool)
  summary(BayesMod)

  #we could also account for hierarchical sampling frame within each region but
  #note that this is more complex and slower)

  # BayesHierMod &lt;- PoolRegBayes(Result ~ Region + Year + (1|Village) + (1|Site),
  #                              data = SimpleExampleData,
  #                              poolSize = NumInPool)


### Calculate adjusted estimates of prevalence
# We use the same function for all four models, but the outputs are slightly different

#For models without hierarchical sampling structure there is an estimate of
#prevalence for every combination of population (fixed) effects: e.g. Region and
#Year
getPrevalence(Mod) #Frequentist model

  getPrevalence(BayesMod) #Bayesian model


#For models without hierarchical sampling structure, there is a prevalence
#estimate for each combination of region and year and then at each level of the
#hierarchical sampling frame (i.e. for each village in each region and each site
#in each village)
getPrevalence(HierMod)

# You can also use getPrevalence to predict prevalence for other values of the
# covariates (e.g. predict prevalence in year 4 based on linear trend on the
# logit scale)

#Making a data frame containing data make predictions on
DataFuture &lt;- unique(data.frame(Region = SimpleExampleData$Region,
                                Village = SimpleExampleData$Village,
                                Site = SimpleExampleData$Site,
                                Year = 4))

getPrevalence(Mod, newdata = DataFuture)
getPrevalence(HierMod, newdata = DataFuture)
</code></pre>

<hr>
<h2 id='PoolRegBayes'>Bayesian Mixed or Fixed Effect Logistic Regression with Presence/Absence
Tests on Pooled Samples</h2><span id='topic+PoolRegBayes'></span>

<h3>Description</h3>

<p>It can be useful to do mixed effects logistic regression on the
presence/absence results from pooled samples, however one must adjust for the
size of each pool to correctly identify trends and associations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolRegBayes(
  formula,
  data,
  poolSize,
  link = "logit",
  prior = NULL,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PoolRegBayes_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> of the kind used to define models in
<code>brms</code>, which are generalisation of the formulae used in <code>lm,
glm</code> or <code>lme4</code>. The left-hand side of the formula should be the name
of column in <code>data</code> with the result of the test on the pooled samples.
The result must be stored with 1 indicating a positive test result and 0
indicating a negative test result.</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with one row for each pooled sampled and
columns for the size of the pool (i.e. the number of specimens / isolates /
insects pooled to make that particular pool), the result of the test of the
pool and any number of columns to be used as the dependent variables in the
logistic regression.</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_poolsize">poolSize</code></td>
<td>
<p>The name of the column with number of specimens / isolates /
insects in each pool.</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_link">link</code></td>
<td>
<p>Link function. There are three options 'logit' (i.e logistic
regression, the default), 'cloglog' (complementary log-log), and
'loglogit'. The final option blends a log link function and the logit
function so that parameters are (log) prevalence/rate ratios as long as
predicted prevalence is &lt;0.8 (for details see Clark and Barr, Stat Methods
Med Res (2018) &lt;DOI:10.1177/0962280217698174&gt;)</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_prior">prior</code></td>
<td>
<p>The priors to be used for the regression parameters. Defaults to
a non-informative (normal(0,100)) prior on linear coefficients and a
zero-truncated student-t prior on the group effect standard deviations.
Custom priors must be <code>brmsprior</code> objects produced by
<code><a href="brms.html#topic+set_prior">brms::set_prior</a></code></p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_cores">cores</code></td>
<td>
<p>The number of CPU cores to be used. By default one core is used</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>brms::brms</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>brms</code> with the regression outputs.
</p>


<h3>References</h3>

<p>Clark RG, Barr M: A blended link approach to relative risk regression.
Statistical Methods in Medical Research 2018, 27(11):3325-3339.
&lt;DOI:10.1177/0962280217698174&gt;
</p>
<p>Angus McLure, Ben O'Neill, Helen Mayfield, Colleen Lau, Brady McPherson (2021).
PoolTestR: An R package for estimating prevalence and regression modelling
for molecular xenomonitoring and other applications with pooled samples.
Environmental Modelling &amp; Software, 145:105158. &lt;DOI:10.1016/j.envsoft.2021.105158&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoolReg">PoolReg</a></code>,
<code><a href="#topic+getPrevalence">getPrevalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform logistic-type regression modelling for a synthetic dataset consisting
# of pools (sizes 1, 5, or 10) taken from 4 different regions and 3 different
# years. Within each region specimens are collected at 4 different villages,
# and within each village specimens are collected at 8 different sites.


### Models in a frequentist framework
#ignoring hierarchical sampling frame within each region
Mod &lt;- PoolReg(Result ~ Region + Year,
               data = SimpleExampleData,
               poolSize = NumInPool)
summary(Mod)

#accounting hierarchical sampling frame within each region
HierMod &lt;- PoolReg(Result ~ Region + Year + (1|Village) + (1|Site),
                   data = SimpleExampleData,
                   poolSize = NumInPool)
summary(HierMod)


### Models in a Bayesian framework with default (non-informative) priors
#ignoring hierarchical sampling frame within each region

  BayesMod &lt;- PoolRegBayes(Result ~ Region + Year,
                           data = SimpleExampleData,
                           poolSize = NumInPool)
  summary(BayesMod)

  #we could also account for hierarchical sampling frame within each region but
  #note that this is more complex and slower)

  # BayesHierMod &lt;- PoolRegBayes(Result ~ Region + Year + (1|Village) + (1|Site),
  #                              data = SimpleExampleData,
  #                              poolSize = NumInPool)


### Calculate adjusted estimates of prevalence
# We use the same function for all four models, but the outputs are slightly different

#For models without hierarchical sampling structure there is an estimate of
#prevalence for every combination of population (fixed) effects: e.g. Region and
#Year
getPrevalence(Mod) #Frequentist model

  getPrevalence(BayesMod) #Bayesian model


#For models without hierarchical sampling structure, there is a prevalence
#estimate for each combination of region and year and then at each level of the
#hierarchical sampling frame (i.e. for each village in each region and each site
#in each village)
getPrevalence(HierMod)

# You can also use getPrevalence to predict prevalence for other values of the
# covariates (e.g. predict prevalence in year 4 based on linear trend on the
# logit scale)

#Making a data frame containing data make predictions on
DataFuture &lt;- unique(data.frame(Region = SimpleExampleData$Region,
                                Village = SimpleExampleData$Village,
                                Site = SimpleExampleData$Site,
                                Year = 4))

getPrevalence(Mod, newdata = DataFuture)
getPrevalence(HierMod, newdata = DataFuture)
</code></pre>

<hr>
<h2 id='SimpleExampleData'>A synthetic dataset for pooled testing</h2><span id='topic+SimpleExampleData'></span>

<h3>Description</h3>

<p>The simple synthetic dataset consisting of pools (sizes 1, 5, or 10) taken from 4 different
regions and 3 different years. Within each region specimens are collected
at 4 different villages, and within each village specimens are collected at 8
different sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimpleExampleData
</code></pre>


<h3>Format</h3>

<p>A data frame with 1152 rows and 6 variables:
</p>

<dl>
<dt>NumInPool</dt><dd><p>Number of specimens in pool. Takes values 1, 5, or 10.</p>
</dd>
<dt>Region</dt><dd><p>ID of the region the pool was taken from. &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, or &quot;D&quot;</p>
</dd>
<dt>Village</dt><dd><p>ID of village pool was taken from. Includes name of region e.g. &quot;B-3&quot; is village 3 from region B</p>
</dd>
<dt>Site</dt><dd><p>ID of site pool was taken from. Includes name of region and village e.g. &quot;B-3-7&quot; is  site 7 from village 3 from region B</p>
</dd>
<dt>Result</dt><dd><p>Result of test on pool; 0 = negative, 1 = positive</p>
</dd>
<dt>Year</dt><dd><p>Year of sampling. Years are 0, 1, or 2</p>
</dd>
</dl>


<hr>
<h2 id='TruePrev'>A synthetic dataset for pooled testing</h2><span id='topic+TruePrev'></span>

<h3>Description</h3>

<p>This <code>data.frame</code> contains the 'true' values of prevalence for each, site,
village, region and year used to generate the synthetic dataset
<code>ExampleData</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TruePrev
</code></pre>


<h3>Format</h3>

<p>A data frame with 900 rows and 7 variables: </p>

<dl>
<dt>Region</dt><dd><p>ID of the region the pool was taken from. &quot;A&quot;, &quot;B&quot;, or &quot;C&quot;</p>
</dd>
<dt>Village</dt><dd><p>ID of village pool was taken from. Includes name of region
e.g. &quot;B-3&quot; is village 3 from region B</p>
</dd>
<dt>Site</dt><dd><p>ID of sampling site pool was
taken from. Includes name of region and village e.g. &quot;B-3-7&quot; is site 7 from
village 3 from region B</p>
</dd>
<dt>Year</dt><dd><p>Year of sampling. Years are 0, 1, or 2</p>
</dd>
<dt>PrevalenceRegion</dt><dd><p>'True' average prevalence in the region (in that
year)</p>
</dd>
<dt>PrevalenceVillage</dt><dd><p>'True' average prevalence in the village
(in that year)</p>
</dd>
<dt>PrevalenceSite</dt><dd><p>'True' prevalence at that site (in
that year)</p>
</dd> </dl>



<h3>Details</h3>

<p>The 'true' model can be summarised in formula notation as:
</p>
<p>Result ~ Region + Year + (1|Village) + (0 + Year|Village) + (1|Site)
</p>
<p>where the coefficient for Year is log(0.8), the standard deviation for
intercept random effects for village and site are both 0.5, the standard
deviation for the year random effect for village is 0.2 and the random
effects are all uncorrelated/independent.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
