<!DOCTYPE html><html><head><title>Help for package PoolTestR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PoolTestR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ExampleData'><p>A synthetic dataset for pooled testing</p></a></li>
<li><a href='#getPrevalence'><p>Predicting Prevalence from a Mixed or Fixed Effect Logistic Regression with</p>
Presence/Absence Tests on Pooled Samples</a></li>
<li><a href='#HierPoolPrev'><p>Estimation of prevalence based on presence/absence tests on pooled samples in</p>
a hierarchical sampling frame</a></li>
<li><a href='#PoolLink'><p>Link Function for Logistic Regression with Presence/Absence Tests on Pooled Samples</p></a></li>
<li><a href='#PoolPrev'><p>Estimation of prevalence based on presence/absence tests on pooled samples</p></a></li>
<li><a href='#PoolReg'><p>Frequentist Mixed or Fixed Effect Logistic Regression with Presence/Absence</p>
Tests on Pooled Samples</a></li>
<li><a href='#PoolRegBayes'><p>Bayesian Mixed or Fixed Effect Logistic Regression with Presence/Absence</p>
Tests on Pooled Samples</a></li>
<li><a href='#PoolTestR-package'><p>The 'PoolTestR' package.</p></a></li>
<li><a href='#SimpleExampleData'><p>A synthetic dataset for pooled testing</p></a></li>
<li><a href='#TruePrev'><p>A synthetic dataset for pooled testing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Prevalence and Regression for Pool-Tested (Group-Tested) Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AngusMcLure/PoolTestR">https://github.com/AngusMcLure/PoolTestR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AngusMcLure/PoolTestR">https://github.com/AngusMcLure/PoolTestR</a></td>
</tr>
<tr>
<td>Description:</td>
<td>An easy-to-use tool for working with presence/absence tests on 'pooled'
    or 'grouped' samples. The primary application is for estimating prevalence of 
    a marker in a population based on the results of tests on pooled specimens.
    This sampling method is often employed in surveillance of rare conditions in
    humans or animals (e.g. molecular xenomonitoring). The package was initially
    conceived as an R-based alternative to the molecular xenomonitoring software,
    'PoolScreen' <a href="https://sites.uab.edu/statgenetics/software/">https://sites.uab.edu/statgenetics/software/</a>. However, it goes
    further, allowing for estimates of prevalence to be adjusted for hierarchical
    sampling frames, and perform flexible mixed-effect regression analyses
    (McLure et al. Environmental Modelling and Software.
    &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2021.105158">doi:10.1016/j.envsoft.2021.105158</a>&gt;). The package is currently in early stages,
    however more features are planned or in the works: e.g. adjustments for
    imperfect test specificity/sensitivity, functions for helping with optimal
    experimental design, and functions for spatial modelling.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, methods, Rcpp (&ge; 0.12.0), rstan (&ge; 2.18.1),
rstantools (&ge; 2.0.0), brms, stats, lme4, stringr, progress</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
rstan (&ge; 2.18.1), StanHeaders (&ge; 2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-AU</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-01 07:06:19 UTC; angus</td>
</tr>
<tr>
<td>Author:</td>
<td>Angus McLure <a href="https://orcid.org/0000-0003-2551-3059"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Angus McLure &lt;angus.mclure@anu.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-01 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ExampleData'>A synthetic dataset for pooled testing</h2><span id='topic+ExampleData'></span>

<h3>Description</h3>

<p>A synthetic dataset mimicking a realistic hierarchical sampling frame.
Simulated samples are taken from across three regions (A, B, and C) in which
the vectors have a low (0.5%), medium (2%), and high (4%) prevalence of
the marker of interest. Ten villages are chosen within each region, and traps
are placed at ten sites within each village. Every site is sampled once a
year over three years (0, 1, and 2). Prevalence is not uniform within each
region or over time. At baseline (year 0), prevalence varies between villages
within each region around the mean for the region, and prevalence varies
between sites within each village around the mean for the village.
Consequently though the prevalence is different for each site, two sites
within the same village are likely to have a more similar prevalence than two
sites in different villages, or two sites in different regions. On average
the prevalence is declining over time (odds ratio of 0.8 per year), however,
the growth rate varies between villages. Consequently two sites in different
villages with similar prevalence at baseline may have different prevalence by
the third year, and prevalence may go up in some villages. Each year the
traps at each site catch a negative binomial number (mean 200, dispersion 5)
of vectors. The catch size at each site and year is independent. Each year,
the catches at each site are pooled into groups of 25 with an additional pool
for any remainder (e.g. a catch of 107 vectors will be pooled into 4 pools of
25 and one pool of 7). Test results on each pool are simulated assuming the
test has perfect sensitivity and specificity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExampleData
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables: </p>

<dl>
<dt>NumInPool</dt><dd><p>Number of specimens in pool. Range = 1:25</p>
</dd>
<dt>Region</dt><dd><p>ID of the region the pool was taken from. &quot;A&quot;, &quot;B&quot;, or &quot;C&quot;</p>
</dd>
<dt>Village</dt><dd><p>ID of village that pool was taken from. Includes name of region e.g. &quot;B-3&quot; is village 3 from region B</p>
</dd>
<dt>Site</dt><dd><p>ID of site that pool was taken from. Includes name of region and village e.g. &quot;B-3-7&quot; is site 7 from village 3 from region B</p>
</dd>
<dt>Result</dt><dd><p>Result of test on pool; 0 = negative, 1 = positive</p>
</dd>
<dt>Year</dt><dd><p>Year of sampling. Years are 0, 1, or 2</p>
</dd> </dl>



<h3>Details</h3>

<p>The 'true' model can be summarised in formula notation as:
</p>
<p>Result ~ Region + Year + (1+Year|Village) + (1|Site)
</p>
<p>where the coefficient for Year is log(0.8), the standard deviation for
intercept random effects for village and site are both 0.5, the standard
deviation for the year random effect for village is 0.2 and the random
effects are all uncorrelated/independent.
</p>

<hr>
<h2 id='getPrevalence'>Predicting Prevalence from a Mixed or Fixed Effect Logistic Regression with
Presence/Absence Tests on Pooled Samples</h2><span id='topic+getPrevalence'></span>

<h3>Description</h3>

<p>This function works somewhat like a <code>predict</code> or <code>fitted</code> generic
function returning the model predicted prevalence for a given set of data;
however, as the quantity of interest (prevalence) is neither on the response
or link scale we do not use either of these generic functions. Further, when
the model accounts for the hierarchical structure of the sampling frame (e.g.
Region/Village/Site), it is common to want to know the predicted values at
each level of sampling (e.g. Prevalence at each region, village or site) so
these are calculated automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPrevalence(
  model,
  newdata = NULL,
  re.form = NULL,
  robust = FALSE,
  level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPrevalence_+3A_model">model</code></td>
<td>
<p>An object returned by [PoolReg()] or [PoolRegBayes()]</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_newdata">newdata</code></td>
<td>
<p>The data for which prevalence needs to be estimated/predicted.
If not provided, defaults to using the data used to train the model (i.e.
returns the fitted values of the prevalence)</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_re.form">re.form</code></td>
<td>
<p>A description of which random effects to include in the
prediction. If omitted, getPrevalence automatically tests to see if there
are any random effect terms. If not, it just returns the estimates based on
population effects. If there are random effects, it tests to see if the
random effect variables form a nested hierarchical structure. If so, in
addition to the estimates based on population effects only, it will
estimate at different levels of the nested hierarchical structure in order
of increasing granularity. For manual control you can set to NA for
population effects only, or a one-sided formula specifying the form of the
random effects to include in estimates, or a list of such objects.</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_robust">robust</code></td>
<td>
<p>Currently only relevant for brmsfit objects (returned by
PoolRegBayes). If <code>FALSE</code> (default) the point estimate of prevalence
is the mean over the posterior. If <code>TRUE</code>, the median over the
posterior is used instead.</p>
</td></tr>
<tr><td><code id="getPrevalence_+3A_level">level</code></td>
<td>
<p>Defines the confidence level to be used for the confidence and
credible intervals. Defaults to 0.95 (i.e. 95% intervals).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with at least one field <code>PopulationEffects</code> and an
additional field for every random/group effect variable. The field
<code>PopulationEffects</code> contains a <code>data.frame</code> with the prevalence
estimated based only the fixed/population effects. When the intercept is
the only fixed/population effect, this is just the population mean
(possibly adjusted for random/group effects). When there are group effects
terms, <code>getPrevalence</code> attempts to order these with respect to
'granularity' and extract the prevalence estimates for these random
effects; e.g. if the random/group effects included are there to account for
a hierarchical sampling frame with levels 'Village' and 'Site' with a
formula like <code>Result ~ Cov1 + Cov2 + (1|Village/Site)</code>, then
getPrevalence will be a list of three data frames: estimates for every
combination of covariates, estimates for every combination of covariates
and village, and estimates for every combination of covariates, village,
and site.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoolReg">PoolReg</a></code>,
<code><a href="#topic+PoolRegBayes">PoolRegBayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform logistic-type regression modelling for a synthetic dataset consisting
# of pools (sizes 1, 5, or 10) taken from 4 different regions and 3 different
# years. Within each region specimens are collected at 4 different villages,
# and within each village specimens are collected at 8 different sites.


### Models in a frequentist framework
#ignoring hierarchical sampling frame within each region
Mod &lt;- PoolReg(Result ~ Region + Year,
               data = SimpleExampleData,
               poolSize = NumInPool)
summary(Mod)

#accounting hierarchical sampling frame within each region
HierMod &lt;- PoolReg(Result ~ Region + Year + (1|Village/Site),
                   data = SimpleExampleData,
                   poolSize = NumInPool)
summary(HierMod)
#Extract fitted prevalence for each combination of region and year and then at
#each level of the hierarchical sampling frame (i.e. for each village in each
#region and  each site in each village)
getPrevalence(HierMod)


### Models in a Bayesian framework with default (non-informative) priors
#ignoring hierarchical sampling frame within each region

  BayesMod &lt;- PoolRegBayes(Result ~ Region + Year,
                           data = SimpleExampleData,
                           poolSize = NumInPool)
  summary(BayesMod)
  getPrevalence(BayesMod) #Extract fitted prevalence for each combination of region and year

  #accounting hierarchical sampling frame within each region
  BayesHierMod &lt;- PoolRegBayes(Result ~ Region + Year + (1|Village/Site),
                               data = SimpleExampleData,
                               poolSize = NumInPool)
  summary(BayesHierMod)
  getPrevalence(BayesHierMod)


### Calculate adjusted estimates of prevalence
# We use the same function for all four models, but the outputs are slightly different

# Extract fitted prevalence for each combination of region and year
getPrevalence(Mod)

  getPrevalence(BayesMod)


#Extract fitted prevalence for each combination of region and year and then at
#each level of the hierarchical sampling frame (i.e. for each village in each
#region and  each site in each village)
getPrevalence(HierMod)

  getPrevalence(BayesHierMod)


# You can also use getPrevalence to predict at prevalence for other values of
# the covariates (e.g. predict prevalence in year 4)

#Making a data frame containing data make predict on
DataFuture &lt;- unique(data.frame(Region = SimpleExampleData$Region,
                                Village = SimpleExampleData$Village,
                                Site = SimpleExampleData$Site,
                                Year = 4))

getPrevalence(Mod, newdata = DataFuture)
getPrevalence(HierMod, newdata = DataFuture)

  getPrevalence(BayesMod, newdata = DataFuture)
  getPrevalence(BayesHierMod, newdata = DataFuture)

</code></pre>

<hr>
<h2 id='HierPoolPrev'>Estimation of prevalence based on presence/absence tests on pooled samples in
a hierarchical sampling frame</h2><span id='topic+HierPoolPrev'></span>

<h3>Description</h3>

<p>Estimation of prevalence based on presence/absence tests on pooled samples in
a hierarchical sampling frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierPoolPrev(
  data,
  result,
  poolSize,
  hierarchy,
  ...,
  prior.alpha = 0.5,
  prior.beta = 0.5,
  prior.absent = 0,
  hyper.prior.sd = 2,
  level = 0.95,
  verbose = FALSE,
  cores = NULL,
  iter = 2000,
  warmup = iter/2,
  chains = 4,
  control = list(adapt_delta = 0.9)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierPoolPrev_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with one row for each pooled sampled and
columns for the size of the pool (i.e. the number of specimens / isolates /
insects pooled to make that particular pool), the result of the test of the
pool. It may also contain additional columns with additional information
(e.g. location where pool was taken) which can optionally be used for
splitting the data into smaller groups and calculating prevalence by group
(e.g. calculating prevalence for each location)</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_result">result</code></td>
<td>
<p>The name of column with the result of each test on each pooled
sample. The result must be stored with 1 indicating a positive test result
and 0 indicating a negative test result.</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_poolsize">poolSize</code></td>
<td>
<p>The name of the column with number of
specimens/isolates/insects in each pool</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_hierarchy">hierarchy</code></td>
<td>
<p>The name of column(s) indicating the group membership. In a
nested sampling design with multiple levels of grouping the lower-level
groups must have names/numbers that differentiate them from all other
groups at the same level. E.g. If sampling was performed at 200 sites
across 10 villages (20 site per village), then there should be 200 unique
names for the sites. If, for instance, the sites are instead numbered 1 to
20 within each village, the village identifier (e.g. A, B, C...) should be
combined with the site number to create unique identifiers for each site
(e.g. A-1, A-2... for sites in village A and B-1, B-2... for the sites in
village B etc.)</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_...">...</code></td>
<td>
<p>Optional name(s) of columns with variables to stratify the data by.
If omitted the complete dataset is used to estimate a single prevalence.
If included prevalence is estimated separately for each group defined by
these columns</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_prior.alpha">prior.alpha</code>, <code id="HierPoolPrev_+3A_prior.beta">prior.beta</code>, <code id="HierPoolPrev_+3A_prior.absent">prior.absent</code></td>
<td>
<p>The prior on the prevalence in
each group takes the form of beta distribution (with parameters alpha and
beta). The default is <code>prior.alpha = prior.beta = 1/2</code>. Another popular
uninformative choice is <code>prior.alpha = prior.beta = 1</code>, i.e. a uniform
prior. <code>prior.absent</code> is included for consistency with <code>PoolPrev</code>,
but is currently ignored</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_hyper.prior.sd">hyper.prior.sd</code></td>
<td>
<p>Scale for the half-Cauchy hyper-prior for standard deviations
of random/group effect terms. Defaults to 2, which is weakly informative since
it implies that 50% of random/group effects terms will be within a order of
magnitude of each other, and 90% of random/group effects will be within four
orders of magnitude of each other. Decrease if you think group differences are
are smaller than this, and increase if you think group differences may often
reasonably be larger than this</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_level">level</code></td>
<td>
<p>The confidence level to be used for the confidence and credible
intervals. Defaults to 0.95 (i.e. 95% intervals)</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print progress to screen.
Defaults to false (no printing to screen)</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_cores">cores</code></td>
<td>
<p>The number of CPU cores to be used. By default one core is used</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_iter">iter</code>, <code id="HierPoolPrev_+3A_warmup">warmup</code>, <code id="HierPoolPrev_+3A_chains">chains</code></td>
<td>
<p>MCMC options for passing onto the sampling
routine. See <a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
<tr><td><code id="HierPoolPrev_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behaviour.
Defaults to default values as defined in <a href="rstan.html#topic+stan">stan</a>, except for
<code>adapt_delta</code> which is set to the more conservative value of 0.9. See
<a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns:
</p>
<ul>
<li><p><code>PrevBayes</code> the (Bayesian) posterior expectation
</p>
</li>
<li><p><code>CrILow</code> and <code>CrIHigh</code> &ndash; lower and upper bounds
for credible intervals
</p>
</li>
<li><p><code>NumberOfPools</code> &ndash; number of pools
</p>
</li>
<li><p><code>NumberPositive</code> &ndash; the number of positive pools </p>
</li></ul>

<p>If grouping variables are provided in <code>...</code> there will be an additional
column for each grouping variable. When there are no grouping variables
(supplied in <code>...</code>) then the output has only one row with the
prevalence estimates for the whole dataset. When grouping variables are
supplied, then there is a separate row for each group.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoolPrev">PoolPrev</a></code>,
<code><a href="#topic+getPrevalence">getPrevalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate prevalence for a synthetic dataset consisting of pools (sizes 1, 5,
# or 10) taken from 4 different regions and 3 different years. Within each
# region specimens are collected at 4 different villages, and within each
# village specimens are collected at 8 different sites.


  #Prevalence for each combination of region and year:
  #ignoring hierarchical sampling frame within each region
  PoolPrev(SimpleExampleData, Result, NumInPool, Region, Year)
  #accounting hierarchical sampling frame within each region
  HierPoolPrev(SimpleExampleData, Result, NumInPool, c("Village","Site"), Region, Year)



</code></pre>

<hr>
<h2 id='PoolLink'>Link Function for Logistic Regression with Presence/Absence Tests on Pooled Samples</h2><span id='topic+PoolLink'></span>

<h3>Description</h3>

<p>A custom link function for the <code><a href="stats.html#topic+binomial">binomial</a></code> family to be used with <code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolLink(PoolSize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolLink_+3A_poolsize">PoolSize</code></td>
<td>
<p>The number of specimens/isolates/insects in each pool. When used with glm, the
length must either be 1 if all the pools are the same size, but the same length
as the data otherwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>link-glm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform logistic-type regression modelling for a synthetic dataset consisting
# of pools (sizes 1, 5, or 10) taken from 4 different regions and 3 different
# years. Within each region specimens are collected at 4 different villages,
# and within each village specimens are collected at 8 different sites.


### Models in a frequentist framework
#ignoring hierarchical sampling frame within each region
Mod &lt;- PoolReg(Result ~ Region + Year,
               data = SimpleExampleData,
               poolSize = NumInPool)
summary(Mod)

#accounting hierarchical sampling frame within each region
HierMod &lt;- PoolReg(Result ~ Region + Year + (1|Village/Site),
                   data = SimpleExampleData,
                   poolSize = NumInPool)
summary(HierMod)
#Extract fitted prevalence for each combination of region and year and then at
#each level of the hierarchical sampling frame (i.e. for each village in each
#region and  each site in each village)
getPrevalence(HierMod)


### Models in a Bayesian framework with default (non-informative) priors
#ignoring hierarchical sampling frame within each region

  BayesMod &lt;- PoolRegBayes(Result ~ Region + Year,
                           data = SimpleExampleData,
                           poolSize = NumInPool)
  summary(BayesMod)
  getPrevalence(BayesMod) #Extract fitted prevalence for each combination of region and year

  #accounting hierarchical sampling frame within each region
  BayesHierMod &lt;- PoolRegBayes(Result ~ Region + Year + (1|Village/Site),
                               data = SimpleExampleData,
                               poolSize = NumInPool)
  summary(BayesHierMod)
  getPrevalence(BayesHierMod)


### Calculate adjusted estimates of prevalence
# We use the same function for all four models, but the outputs are slightly different

# Extract fitted prevalence for each combination of region and year
getPrevalence(Mod)

  getPrevalence(BayesMod)


#Extract fitted prevalence for each combination of region and year and then at
#each level of the hierarchical sampling frame (i.e. for each village in each
#region and  each site in each village)
getPrevalence(HierMod)

  getPrevalence(BayesHierMod)


# You can also use getPrevalence to predict at prevalence for other values of
# the covariates (e.g. predict prevalence in year 4)

#Making a data frame containing data make predict on
DataFuture &lt;- unique(data.frame(Region = SimpleExampleData$Region,
                                Village = SimpleExampleData$Village,
                                Site = SimpleExampleData$Site,
                                Year = 4))

getPrevalence(Mod, newdata = DataFuture)
getPrevalence(HierMod, newdata = DataFuture)

  getPrevalence(BayesMod, newdata = DataFuture)
  getPrevalence(BayesHierMod, newdata = DataFuture)

</code></pre>

<hr>
<h2 id='PoolPrev'>Estimation of prevalence based on presence/absence tests on pooled samples</h2><span id='topic+PoolPrev'></span>

<h3>Description</h3>

<p>Estimation of prevalence based on presence/absence tests on pooled samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolPrev(
  data,
  result,
  poolSize,
  ...,
  prior.alpha = NULL,
  prior.beta = NULL,
  prior.absent = 0,
  level = 0.95,
  reproduce.poolscreen = FALSE,
  verbose = FALSE,
  cores = NULL,
  iter = 2000,
  warmup = iter/2,
  chains = 4,
  control = list(adapt_delta = 0.9)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolPrev_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with one row for each pooled sampled and
columns for the size of the pool (i.e. the number of specimens / isolates /
insects pooled to make that particular pool), the result of the test of the
pool. It may also contain additional columns with additional information
(e.g. location where pool was taken) which can optionally be used for
stratifying the data into smaller groups and calculating prevalence by
group (e.g. calculating prevalence for each location)</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_result">result</code></td>
<td>
<p>The name of column with the result of each test on each pooled
sample. The result must be stored with 1 indicating a positive test result
and 0 indicating a negative test result.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_poolsize">poolSize</code></td>
<td>
<p>The name of the column with number of
specimens/isolates/insects in each pool</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_...">...</code></td>
<td>
<p>Optional name(s) of columns with variables to stratify the data
by. If omitted the complete dataset is used to estimate a single
prevalence. If included, prevalence is estimated separately for each group
defined by these columns</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_prior.alpha">prior.alpha</code>, <code id="PoolPrev_+3A_prior.beta">prior.beta</code>, <code id="PoolPrev_+3A_prior.absent">prior.absent</code></td>
<td>
<p>The default prior for the
prevalence is the uninformative Jeffrey's prior, however you can also
specify a custom prior with a beta distribution (with parameters
prior.alpha and prior.beta) modified to have a point mass of zero i.e.
allowing for some prior probability that the true prevalence is exactly
zero (prior.absent). Another popular uninformative choice is
<code>prior.alpha = 1, prior.beta = 1, prior.absent = 0</code>, i.e. a uniform
prior.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_level">level</code></td>
<td>
<p>Defines the confidence level to be used for the confidence and
credible intervals. Defaults to 0.95 (i.e. 95% intervals)</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_reproduce.poolscreen">reproduce.poolscreen</code></td>
<td>
<p>(defaults to FALSE). If TRUE this changes the
way that likelihood ratio confidence intervals are computed to be somewhat
wider and more closely match those returned by Poolscreen. We recommend
using the default (FALSE). However setting to TRUE can help to make
comparisons between PoolPrev and Poolscreen.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print progress to screen.
Defaults to false (no printing to screen).</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_cores">cores</code></td>
<td>
<p>The number of CPU cores to be used. By default one core is used</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_iter">iter</code>, <code id="PoolPrev_+3A_warmup">warmup</code>, <code id="PoolPrev_+3A_chains">chains</code></td>
<td>
<p>MCMC options for passing onto the sampling
routine. See <a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
<tr><td><code id="PoolPrev_+3A_control">control</code></td>
<td>
<p>A named list of parameters to control the sampler's behaviour.
Defaults to default values as defined in <a href="rstan.html#topic+stan">stan</a>, except for
<code>adapt_delta</code> which is set to the more conservative value of 0.9. See
<a href="rstan.html#topic+stan">stan</a> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns:
</p>
<ul>
<li><p><code>PrevMLE</code> (the Maximum Likelihood Estimate of prevalence)
</p>
</li>
<li><p><code>CILow</code> and <code>CIHigh</code> - lower and upper confidence
intervals using the likelihood ratio method
</p>
</li>
<li><p><code>PrevBayes</code> the (Bayesian) posterior expectation
</p>
</li>
<li><p><code>CrILow</code> and <code>CrIHigh</code> &ndash; lower and upper bounds
for credible intervals
</p>
</li>
<li><p><code>ProbAbsent</code> the posterior probability that prevalence
is exactly 0 (i.e. disease marker is absent). NA if using
default Jeffrey's prior or if prior.absent = 0.
</p>
</li>
<li><p><code>NumberOfPools</code> &ndash; number of pools
</p>
</li>
<li><p><code>NumberPositive</code> &ndash; the number of positive pools </p>
</li></ul>

<p>If grouping variables are provided in <code>...</code> there will be an additional
column for each grouping variable. When there are no grouping variables
(supplied in <code>...</code>) then the output has only one row with the
prevalence estimates for the whole dataset. When grouping variables are
supplied, then there is a separate row for each group.
</p>

<hr>
<h2 id='PoolReg'>Frequentist Mixed or Fixed Effect Logistic Regression with Presence/Absence
Tests on Pooled Samples</h2><span id='topic+PoolReg'></span>

<h3>Description</h3>

<p>It can be useful to do mixed effects logistic regression on the
presence/absence results from pooled samples, however one must adjust for the
size of each pool to correctly identify trends and associations. This can
done by using a custom link function [PoolTestR::PoolLink()], defined in this
package, in conjunction with using <code>glm</code> from the <code>stats</code> package
(fixed effect models) or <code>glmer</code> from the <code>lme4</code> package (mixed
effect models).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolReg(formula, data, poolSize, link = "logit", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolReg_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> of the kind used to define models in
<code>lme4</code>, which are generalisation of the formulae used in <code>lm</code> or
<code>glm</code> that allow for random/group effects. The left-hand side of the
formula should be the name of column in <code>data</code> with the result of the
test on the pooled samples. The result must be encoded with 1 indicating a
positive test result and 0 indicating a negative test result.</p>
</td></tr>
<tr><td><code id="PoolReg_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with one row for each pooled sampled and
columns for the size of the pool (i.e. the number of specimens / isolates /
insects pooled to make that particular pool), the result of the test of the
pool and any number of columns to be used as the dependent variables in the
logistic regression</p>
</td></tr>
<tr><td><code id="PoolReg_+3A_poolsize">poolSize</code></td>
<td>
<p>The name of the column with number of
specimens/isolates/insects in each pool</p>
</td></tr>
<tr><td><code id="PoolReg_+3A_link">link</code></td>
<td>
<p>link function. There are two options ''logit'' (logistic
regression, the default) and ''cloglog'' (complementary log log
regression).</p>
</td></tr>
<tr><td><code id="PoolReg_+3A_...">...</code></td>
<td>
<p>Arguments to be passed on to <code>stats::glm</code> or <code>lme4::glmer</code>
e.g. weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>glmerMod</code> (or <code>glm</code> if there are no
random/group effects)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPrevalence">getPrevalence</a></code>,
<code><a href="#topic+PoolRegBayes">PoolRegBayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform logistic-type regression modelling for a synthetic dataset consisting
# of pools (sizes 1, 5, or 10) taken from 4 different regions and 3 different
# years. Within each region specimens are collected at 4 different villages,
# and within each village specimens are collected at 8 different sites.


### Models in a frequentist framework
#ignoring hierarchical sampling frame within each region
Mod &lt;- PoolReg(Result ~ Region + Year,
               data = SimpleExampleData,
               poolSize = NumInPool)
summary(Mod)

#accounting hierarchical sampling frame within each region
HierMod &lt;- PoolReg(Result ~ Region + Year + (1|Village/Site),
                   data = SimpleExampleData,
                   poolSize = NumInPool)
summary(HierMod)
#Extract fitted prevalence for each combination of region and year and then at
#each level of the hierarchical sampling frame (i.e. for each village in each
#region and  each site in each village)
getPrevalence(HierMod)


### Models in a Bayesian framework with default (non-informative) priors
#ignoring hierarchical sampling frame within each region

  BayesMod &lt;- PoolRegBayes(Result ~ Region + Year,
                           data = SimpleExampleData,
                           poolSize = NumInPool)
  summary(BayesMod)
  getPrevalence(BayesMod) #Extract fitted prevalence for each combination of region and year

  #accounting hierarchical sampling frame within each region
  BayesHierMod &lt;- PoolRegBayes(Result ~ Region + Year + (1|Village/Site),
                               data = SimpleExampleData,
                               poolSize = NumInPool)
  summary(BayesHierMod)
  getPrevalence(BayesHierMod)


### Calculate adjusted estimates of prevalence
# We use the same function for all four models, but the outputs are slightly different

# Extract fitted prevalence for each combination of region and year
getPrevalence(Mod)

  getPrevalence(BayesMod)


#Extract fitted prevalence for each combination of region and year and then at
#each level of the hierarchical sampling frame (i.e. for each village in each
#region and  each site in each village)
getPrevalence(HierMod)

  getPrevalence(BayesHierMod)


# You can also use getPrevalence to predict at prevalence for other values of
# the covariates (e.g. predict prevalence in year 4)

#Making a data frame containing data make predict on
DataFuture &lt;- unique(data.frame(Region = SimpleExampleData$Region,
                                Village = SimpleExampleData$Village,
                                Site = SimpleExampleData$Site,
                                Year = 4))

getPrevalence(Mod, newdata = DataFuture)
getPrevalence(HierMod, newdata = DataFuture)

  getPrevalence(BayesMod, newdata = DataFuture)
  getPrevalence(BayesHierMod, newdata = DataFuture)

</code></pre>

<hr>
<h2 id='PoolRegBayes'>Bayesian Mixed or Fixed Effect Logistic Regression with Presence/Absence
Tests on Pooled Samples</h2><span id='topic+PoolRegBayes'></span>

<h3>Description</h3>

<p>It can be useful to do mixed effects logistic regression on the
presence/absence results from pooled samples, however one must adjust for the
size of each pool to correctly identify trends and associations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolRegBayes(
  formula,
  data,
  poolSize,
  link = "logit",
  prior = NULL,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolRegBayes_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> of the kind used to define models in
<code>brms</code>, which are generalisation of the formulae used in <code>lm,
glm</code> or <code>lme4</code>. The left-hand side of the formula should be the name
of column in <code>data</code> with the result of the test on the pooled samples.
The result must be stored with 1 indicating a positive test result and 0
indicating a negative test result.</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with one row for each pooled sampled and
columns for the size of the pool (i.e. the number of specimens / isolates /
insects pooled to make that particular pool), the result of the test of the
pool and any number of columns to be used as the dependent variables in the
logistic regression.</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_poolsize">poolSize</code></td>
<td>
<p>The name of the column with number of specimens / isolates /
insects in each pool.</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_link">link</code></td>
<td>
<p>Link function. There are three options 'logit' (i.e logistic
regression, the default), 'cloglog' (complementary log-log), and
'loglogit'. The final option blends a log link function and the logit
function so that parameters are (log) prevalence/rate ratios as long as
predicted prevalence is &lt;0.8 (for details see Clark and Barr, Stat Methods
Med Res (2018) &lt;DOI:10.1177/0962280217698174&gt;)</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_prior">prior</code></td>
<td>
<p>The priors to be used for the regression parameters. Defaults to
a non-informative (normal(0,100)) prior on linear coefficients and a
zero-truncated student-t prior on the group effect standard deviations.
Custom priors must be <code>brmsprior</code> objects produced by
<code><a href="brms.html#topic+set_prior">brms::set_prior</a></code></p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_cores">cores</code></td>
<td>
<p>The number of CPU cores to be used. By default one core is used</p>
</td></tr>
<tr><td><code id="PoolRegBayes_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>brms::brms</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>brms</code> with the regression outputs.
</p>


<h3>References</h3>

<p>Clark RG, Barr M: A blended link approach to relative risk regression.
Statistical Methods in Medical Research 2018, 27(11):3325-3339.
&lt;DOI:10.1177/0962280217698174&gt;
</p>
<p>Angus McLure, Ben O'Neill, Helen Mayfield, Colleen Lau, Brady McPherson (2021).
PoolTestR: An R package for estimating prevalence and regression modelling
for molecular xenomonitoring and other applications with pooled samples.
Environmental Modelling &amp; Software, 145:105158. &lt;DOI:10.1016/j.envsoft.2021.105158&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PoolReg">PoolReg</a></code>,
<code><a href="#topic+getPrevalence">getPrevalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform logistic-type regression modelling for a synthetic dataset consisting
# of pools (sizes 1, 5, or 10) taken from 4 different regions and 3 different
# years. Within each region specimens are collected at 4 different villages,
# and within each village specimens are collected at 8 different sites.


### Models in a frequentist framework
#ignoring hierarchical sampling frame within each region
Mod &lt;- PoolReg(Result ~ Region + Year,
               data = SimpleExampleData,
               poolSize = NumInPool)
summary(Mod)

#accounting hierarchical sampling frame within each region
HierMod &lt;- PoolReg(Result ~ Region + Year + (1|Village/Site),
                   data = SimpleExampleData,
                   poolSize = NumInPool)
summary(HierMod)
#Extract fitted prevalence for each combination of region and year and then at
#each level of the hierarchical sampling frame (i.e. for each village in each
#region and  each site in each village)
getPrevalence(HierMod)


### Models in a Bayesian framework with default (non-informative) priors
#ignoring hierarchical sampling frame within each region

  BayesMod &lt;- PoolRegBayes(Result ~ Region + Year,
                           data = SimpleExampleData,
                           poolSize = NumInPool)
  summary(BayesMod)
  getPrevalence(BayesMod) #Extract fitted prevalence for each combination of region and year

  #accounting hierarchical sampling frame within each region
  BayesHierMod &lt;- PoolRegBayes(Result ~ Region + Year + (1|Village/Site),
                               data = SimpleExampleData,
                               poolSize = NumInPool)
  summary(BayesHierMod)
  getPrevalence(BayesHierMod)


### Calculate adjusted estimates of prevalence
# We use the same function for all four models, but the outputs are slightly different

# Extract fitted prevalence for each combination of region and year
getPrevalence(Mod)

  getPrevalence(BayesMod)


#Extract fitted prevalence for each combination of region and year and then at
#each level of the hierarchical sampling frame (i.e. for each village in each
#region and  each site in each village)
getPrevalence(HierMod)

  getPrevalence(BayesHierMod)


# You can also use getPrevalence to predict at prevalence for other values of
# the covariates (e.g. predict prevalence in year 4)

#Making a data frame containing data make predict on
DataFuture &lt;- unique(data.frame(Region = SimpleExampleData$Region,
                                Village = SimpleExampleData$Village,
                                Site = SimpleExampleData$Site,
                                Year = 4))

getPrevalence(Mod, newdata = DataFuture)
getPrevalence(HierMod, newdata = DataFuture)

  getPrevalence(BayesMod, newdata = DataFuture)
  getPrevalence(BayesHierMod, newdata = DataFuture)

</code></pre>

<hr>
<h2 id='PoolTestR-package'>The 'PoolTestR' package.</h2><span id='topic+PoolTestR-package'></span><span id='topic+PoolTestR'></span>

<h3>Description</h3>

<p>This is a package for working with presence/absence tests on pooled
or grouped samples. The primary application is for estimating prevalence of
a marker in a population based on the results of tests on pooled specimens.
This sampling method is often employed in surveillance of rare conditions in
humans or animals (e.g. livestock or xenomonitoring). The package was initially
conceived as an R-based alternative to the xenomonitoring software,
PoolScreen. However, it goes further, allowing for estimates of prevalence to
adjusted for hierarchy in sampling frames, and perform flexible (mixed effect)
regression analyses. The package is currently in early stages, however more
features are planned or in the works: e.g. adjustments for imperfect test
specificity/sensitivity, functions for helping with optimal experimental
design, and functions for spatial modelling.
</p>


<h3>References</h3>

<p>Angus McLure, Ben O'Neill, Helen Mayfield, Colleen Lau, Brady McPherson (2021). PoolTestR: An R package for estimating prevalence and regression modelling for molecular xenomonitoring and other applications with pooled samples. Environmental Modelling &amp; Software, 145:105158. &lt;DOI:10.1016/j.envsoft.2021.105158&gt;
</p>
<p>Stan Development Team (2019). RStan: the R interface to Stan. R package version 2.19.2. https://mc-stan.org
</p>
<p>Paul-Christian BÃ¼rkner (2017). brms: An R Package for Bayesian Multilevel Models Using Stan. Journal of Statistical Software, 80(1), 1-28. &lt;DOI:10.18637/jss.v080.i01&gt;
</p>

<hr>
<h2 id='SimpleExampleData'>A synthetic dataset for pooled testing</h2><span id='topic+SimpleExampleData'></span>

<h3>Description</h3>

<p>The simple synthetic dataset consisting of pools (sizes 1, 5, or 10) taken from 4 different
regions and 3 different years. Within each region specimens are collected
at 4 different villages, and within each village specimens are collected at 8
different sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimpleExampleData
</code></pre>


<h3>Format</h3>

<p>A data frame with 1152 rows and 6 variables:
</p>

<dl>
<dt>NumInPool</dt><dd><p>Number of specimens in pool. Takes values 1, 5, or 10.</p>
</dd>
<dt>Region</dt><dd><p>ID of the region the pool was taken from. &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, or &quot;D&quot;</p>
</dd>
<dt>Village</dt><dd><p>ID of village pool was taken from. Includes name of region e.g. &quot;B-3&quot; is village 3 from region B</p>
</dd>
<dt>Site</dt><dd><p>ID of site pool was taken from. Includes name of region and village e.g. &quot;B-3-7&quot; is  site 7 from village 3 from region B</p>
</dd>
<dt>Result</dt><dd><p>Result of test on pool; 0 = negative, 1 = positive</p>
</dd>
<dt>Year</dt><dd><p>Year of sampling. Years are 0, 1, or 2</p>
</dd>
</dl>


<hr>
<h2 id='TruePrev'>A synthetic dataset for pooled testing</h2><span id='topic+TruePrev'></span>

<h3>Description</h3>

<p>This <code>data.frame</code> contains the 'true' values of prevalence for each, site,
village, region and year used to generate the synthetic dataset
<code>ExampleData</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TruePrev
</code></pre>


<h3>Format</h3>

<p>A data frame with 900 rows and 7 variables: </p>

<dl>
<dt>Region</dt><dd><p>ID of the region the pool was taken from. &quot;A&quot;, &quot;B&quot;, or &quot;C&quot;</p>
</dd>
<dt>Village</dt><dd><p>ID of village pool was taken from. Includes name of region
e.g. &quot;B-3&quot; is village 3 from region B</p>
</dd>
<dt>Site</dt><dd><p>ID of sampling site pool was
taken from. Includes name of region and village e.g. &quot;B-3-7&quot; is site 7 from
village 3 from region B</p>
</dd>
<dt>Year</dt><dd><p>Year of sampling. Years are 0, 1, or 2</p>
</dd>
<dt>PrevalenceRegion</dt><dd><p>'True' average prevalence in the region (in that
year)</p>
</dd>
<dt>PrevalenceVillage</dt><dd><p>'True' average prevalence in the village
(in that year)</p>
</dd>
<dt>PrevalenceSite</dt><dd><p>'True' prevalence at that site (in
that year)</p>
</dd> </dl>



<h3>Details</h3>

<p>The 'true' model can be summarised in formula notation as:
</p>
<p>Result ~ Region + Year + (1|Village) + (0 + Year|Village) + (1|Site)
</p>
<p>where the coefficient for Year is log(0.8), the standard deviation for
intercept random effects for village and site are both 0.5, the standard
deviation for the year random effect for village is 0.2 and the random
effects are all uncorrelated/independent.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
