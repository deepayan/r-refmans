<!DOCTYPE html><html><head><title>Help for package cusp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cusp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#attitudes'><p> Multistability in political attitudes</p></a></li>
<li><a href='#cusp'><p> Fit a Cusp Catatrophe Model to Data</p></a></li>
<li><a href='#cusp-package'>
<p>Cusp Catastrophe Modeling</p></a></li>
<li><a href='#cusp.bifset'><p> compute normal/symmetry factor borders of bifurcation set of cusp catastrophe</p></a></li>
<li><a href='#cusp.extrema'><p> Locate Extrema of Cusp Catastrophe Potential Function</p></a></li>
<li><a href='#cusp.logist'><p> Fit a Logistic Surface Model to Data</p></a></li>
<li><a href='#cusp.nc'><p> Calculate the Normalizing Constant of Cobb's Cusp Density</p></a></li>
<li><a href='#cusp.nlogLike'><p> Negative log-likelihood for Cobb's cusp density</p></a></li>
<li><a href='#cusp3d'><p> Generate 3D plot of Cusp Catatrophe Model Fit</p></a></li>
<li><a href='#cusp3d.surface'><p> Generate 3D plot of the Cusp surface</p></a></li>
<li><a href='#dcusp'><p> Cobb's Cusp Distribution</p></a></li>
<li><a href='#draw.cusp.bifset'><p> Add Cusp Bifurcation Set Diagram to Existing Plot</p></a></li>
<li><a href='#oliva'><p> Synthetic cusp data set</p></a></li>
<li><a href='#plot.cusp'><p> Graphical Diagnostic Display of Cusp Catastrophe Data Fit</p></a></li>
<li><a href='#plotCuspBifurcation'><p> Display Fitted Data on Control Plane of Cusp Catastrophe.</p></a></li>
<li><a href='#plotCuspDensities'><p> Plot Cusp State Variable Densities Conditioned on Control Parameter Values</p></a></li>
<li><a href='#plotCuspResidfitted'><p> Residuals against Fitted Plot for Cusp Model Fit</p></a></li>
<li><a href='#predict.cusp'>
<p>Predict method for Cusp Model Fits</p></a></li>
<li><a href='#summary.cusp'><p> Summarizing Cusp Catastrophe Model Fits</p></a></li>
<li><a href='#vcov.cusp'><p> Calculate Variance-Covariance Matrix for a Fitted Cusp Model Object</p></a></li>
<li><a href='#zeeman'><p> Measurements from Zeeman's Catastrophe Machine</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cusp-Catastrophe Model Fitting Using Maximum Likelihood</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.6</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, utils</td>
</tr>
<tr>
<td>Author:</td>
<td>Raoul P. P. P. Grasman [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raoul Grasman &lt;rgrasman@uva.nl&gt;</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plot3D</td>
</tr>
<tr>
<td>Description:</td>
<td>Cobb's maximum likelihood method for cusp-catastrophe modeling
        (Grasman, van der Maas, and Wagenmakers (2009) &lt;<a href="https://doi.org/10.18637%2Fjss.v032.i08">doi:10.18637/jss.v032.i08</a>&gt;;
        Cobb (1981), Behavioral Science, 26(1), 75-78). Includes a cusp() function for model 
        fitting, and several utility functions for plotting, and for comparing the
        model to linear regression and logistic curve models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-28 09:43:25 UTC; r13828</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-29 07:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='attitudes'> Multistability in political attitudes  </h2><span id='topic+attitudes'></span><span id='topic+attitudeStartingValues'></span>

<h3>Description</h3>

<p> Data set reflecting bistability in political attitudes </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(attitudes)
data(attitudeStartingValues)</code></pre>


<h3>Format</h3>

<p>A data frame with 1387 observations on the following 3 variables.
</p>

<dl>
<dt><code>Orient</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Involv</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Attitude</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>

<p>The format of attitudeStartingValues is:
num [1:7]  0.153 -0.453 -0.097 -0.124 -0.227 ...
</p>


<h3>Details</h3>

<p>The data set was taken from (van der Maas, Kolstein, &amp; van der Pligt, 2003). It concerns attitudinal response 
transitions with respect to the statement &ldquo;The government must force companies to let their 
workers benefit from the profit as much as the shareholders do&rdquo;. Responses of some 1387 Dutch respondents are included who 
indicated their level of agreement with this statement on a 5 point scale (1 = total ly agree, 
5 = total ly disagree). As a normal factor political orientation (measures on a 10 point scale 
from 1 = left wing to 10 = right wing) was used. As a bifurcation factor the total score on a 
12 item political involvement scale was used. The theoretical social psychological details are 
discussed in (van der Maas et al. 2003). 
</p>
<p>The starting values provided here for a cusp analysis of the <code>attitude</code> data set give proper convergence in one run. They were found after many trial starting values that yielded improper convergence.
</p>


<h3>Source</h3>

<p>van der Maas HLJ, Kolstein R, van der Pligt J (2003). Sudden Transitions in Attitudes. 
Sociological Methods &amp; Research, 23(2), 125152.
</p>


<h3>References</h3>

<p>van der Maas HLJ, Kolstein R, van der Pligt J (2003). Sudden Transitions in Attitudes. 
Sociological Methods &amp; Research, 23(2), 125152.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(attitudes)
data(attitudeStartingValues)
## Not run: 
fit &lt;- cusp(y ~ Attitude, 
			alpha ~ Orient + Involv, 
			beta ~ Involv, 
			data = attitudes, start=attitudeStartingValues) 

## End(Not run)
## maybe str(attitudeStartingValues) ; plot(attitudeStartingValues) ...
</code></pre>

<hr>
<h2 id='cusp'> Fit a Cusp Catatrophe Model to Data </h2><span id='topic+cusp'></span><span id='topic+print.cusp'></span>

<h3>Description</h3>

<p>This function fits a cusp catatrophe model to data using the maximum likelihood method of Cobb. Both the state variable may be modelled by a linear combination of variables and design factors, as well as the normal/asymmetry factor <code>alpha</code> and bifurction/splitting factor <code>beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusp(formula, alpha, beta, data, weights, offset, ..., control =
    glm.control(), method = "cusp.fit", optim.method = "L-BFGS-B", model = TRUE,
    contrasts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cusp_+3A_formula">formula</code></td>
<td>
 <p><code><a href="stats.html#topic+formula">formula</a></code> that models the canonical state variable </p>
</td></tr>
<tr><td><code id="cusp_+3A_alpha">alpha</code></td>
<td>
 <p><code><a href="stats.html#topic+formula">formula</a></code> that models the canonical normal/asymmetry factor </p>
</td></tr>
<tr><td><code id="cusp_+3A_beta">beta</code></td>
<td>
 <p><code><a href="stats.html#topic+formula">formula</a></code> that models the canonical bifurcation/splitting factor </p>
</td></tr>
<tr><td><code id="cusp_+3A_data">data</code></td>
<td>
 <p><code><a href="base.html#topic+data.frame">data.frame</a></code> that contains all the variables named in the formulas </p>
</td></tr>
<tr><td><code id="cusp_+3A_weights">weights</code></td>
<td>
<p> vector of weights by which each data point is weighted (experimental) </p>
</td></tr>
<tr><td><code id="cusp_+3A_offset">offset</code></td>
<td>
<p> vector of offsets for the data (experimental) </p>
</td></tr>
<tr><td><code id="cusp_+3A_...">...</code></td>
<td>
<p> named arguments that are passed to <code><a href="stats.html#topic+optim">optim</a></code> </p>
</td></tr>
<tr><td><code id="cusp_+3A_control">control</code></td>
<td>
 <p><code><a href="stats.html#topic+glm.control">glm.control</a></code> object, currently unused </p>
</td></tr>
<tr><td><code id="cusp_+3A_method">method</code></td>
<td>
<p> string, currently unused </p>
</td></tr>
<tr><td><code id="cusp_+3A_optim.method">optim.method</code></td>
<td>
<p> string passed to <code>optim</code> to choose the optimization algorithm </p>
</td></tr>
<tr><td><code id="cusp_+3A_model">model</code></td>
<td>
<p> should the model matrix be returned? </p>
</td></tr>
<tr><td><code id="cusp_+3A_contrasts">contrasts</code></td>
<td>
<p> matrix of <code><a href="stats.html#topic+contrasts">contrasts</a></code>, experimental </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cusp</code> fits a cusp catastrophe model to data. Cobb's definition for the canonical form of the stochastic cusp catastrophe is the stochastic differential equation </p>
<p style="text-align: center;"><code class="reqn">dY_t = (\alpha + \beta Y_t - Y_t^3)dt + dW_t.</code>
</p>
<p> The stationary distribution of the &lsquo;behavioral&rsquo;, or &lsquo;state&rsquo; variable <code class="reqn">Y</code>, given the control parameters <code class="reqn">\alpha</code> (&lsquo;asymmetry&rsquo; or &lsquo;normal&rsquo; factor) and <code class="reqn">\beta</code> (&lsquo;bifurcation&rsquo; or &lsquo;splitting&rsquo; factor) is </p>
<p style="text-align: center;"><code class="reqn"> f(y) = \Psi \exp(\alpha y + \beta y^2/2 - y^4/4), </code>
</p>
<p> where <code class="reqn">\Psi</code> is a normalizing constant.
</p>
<p>The behavioral variable and the asymmetry and bifurcation factors are usually not directly related to the dependent and independent variables in the data set. These are therefore used to predict the state variable and control parameters:
</p>
<p style="text-align: center;"><code class="reqn">y_i = w_0 + w_1 Y_{i1} + \cdots + w_p Y_{ip}</code>
</p>

<p style="text-align: center;"><code class="reqn">\alpha_i = a_0 + a_1 X_{i1} + \cdots + a_p X_{ip}</code>
</p>

<p style="text-align: center;"><code class="reqn">\beta_i = b_0 + b_1 X_{i1} + \cdots + b_q X_{iq}</code>
</p>

<p>in which the <code class="reqn">a_j</code>'s, <code class="reqn">b_j</code>'s, and <code class="reqn">w_j</code>'s are estimated by means of maximum likelihood.
Here, the <code class="reqn">Y_{ij}</code>'s and <code class="reqn">X_{ij}</code>'s are variables constructed from variables in the data set. Variables predicting the <code class="reqn">\alpha</code>'s and <code class="reqn">\beta</code>'s need not be the same.
</p>
<p>The state variable and control parameters can be modelled by specifying a model <code><a href="stats.html#topic+formula">formula</a></code>: </p>
<p style="text-align: center;"><code class="reqn">\code{y ~ model},</code>
</p>
 <p style="text-align: center;"><code class="reqn">\code{alpha ~ model},</code>
</p>
 <p style="text-align: center;"><code class="reqn">\code{beta ~ model},</code>
</p>
<p> in which <code>model</code> can be any valid <code><a href="stats.html#topic+formula">formula</a></code> specified in terms of variables that are present in the <code>data.frame</code>.
</p>


<h3>Value</h3>


<p>List with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated coefficients </p>
</td></tr>




<tr><td><code>rank</code></td>
<td>
<p>rank of Hessian matrix </p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p><code><a href="Matrix.html#topic+qr">qr</a></code> decomposition of the Hessian matrix </p>
</td></tr>

<tr><td><code>linear.predictors</code></td>
<td>
<p>two column matrix containing the <code class="reqn">\alpha_i</code>'s and <code class="reqn">\beta_i</code>'s for each case </p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>sum of squared errors using Delay convention </p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p> AIC </p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>variance of canonical state variable </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> number of optimization iterations </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> weights provided through weights argument </p>
</td></tr>

<tr><td><code>df.residual</code></td>
<td>
<p> residual degrees of freedom </p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p> degrees of freedom of constant model for state variable </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> predicted values of state variable </p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p> convergence status given by <code>optim</code> </p>
</td></tr>

<tr><td><code>par</code></td>
<td>
<p> parameter estimates for <code>qr</code> standardized data </p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>Hessian matrix of negative log likelihood function at minimum </p>
</td></tr>
<tr><td><code>hessian.untransformed</code></td>
<td>
<p> Hessian matrix of negative log likelihood for <code>qr</code> standardized data </p>
</td></tr>

<tr><td><code>code</code></td>
<td>
<p><code><a href="stats.html#topic+optim">optim</a></code> convergence indicator </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>list with model design matrices </p>
</td></tr>

<tr><td><code>call</code></td>
<td>
<p>function call that created the object </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>list with the formulas </p>
</td></tr>

<tr><td><code>OK</code></td>
<td>
<p> logical. <code>TRUE</code> if Hessian matrix is positive definite at the minimum obtained </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data.frame </p>
</td></tr>





</table>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> See <a href="#topic+cusp-package">cusp-package</a>  </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cusp-package">cusp-package</a></code>.
</p>
<p><code><a href="#topic+summary.cusp">summary.cusp</a></code> for summaries and model assessment.
</p>
<p>The generic functions <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+effects">effects</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p><code><a href="stats.html#topic+predict">predict</a></code> for estimated values of the control parameters <code class="reqn">\alpha[i]</code> and <code class="reqn">\beta[i]</code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# example with regressors
x1 = runif(150)
x2 = runif(150)
z = Vectorize(rcusp)(1, 4*x1-2, 4*x2-1)
data &lt;- data.frame(x1, x2, z)
fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data)
print(fit)
summary(fit)
## Not run: 
plot(fit)
cusp3d(fit)

## End(Not run)

# useful use of OK
## Not run: 
while(!fit$OK)
    fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data,
            start=rnorm(fit$par)) # use different starting values

## End(Not run)
</code></pre>

<hr>
<h2 id='cusp-package'>
Cusp Catastrophe Modeling
</h2><span id='topic+cusp-package'></span>

<h3>Description</h3>

<p>Fits cusp catastrophe to data using Cobb's maximum likelihood method with a different algorithm. The package contains  utility functions for plotting, and for comparing the model to linear regression and logistic curve models. The package allows for multivariate response subspace modelling in the sense of the GEMCAT software of Oliva et al.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> cusp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2008-02-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GNU GPL v2 (or higher)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package helps fitting Cusp catastrophy models to data, as advanced in Cobb et al. (1985). The main functions are
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>cusp</code> </td><td style="text-align: left;"> Fit Cobb's Cusp catastrophe model; see example below.</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>summary.cusp</code> </td><td style="text-align: left;"> Summary statistics of cusp model fit.</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>confint.cusp</code> </td><td style="text-align: left;"> Confidence intervals for parameter estimates</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>plot.cusp</code> </td><td style="text-align: left;"> Diagnostic plots for cusp model fit</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>cusp3d</code> </td><td style="text-align: left;"> 3D graphical display of cusp model fit (experimental).</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>dcusp</code> </td><td style="text-align: left;"> Density of Cobb's cusp distribtution</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>pcusp</code> </td><td style="text-align: left;"> Cumulative probability function of Cobb's cusp distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>qcusp</code> </td><td style="text-align: left;"> Quantile function of Cobb's cusp distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rcusp</code> </td><td style="text-align: left;"> Sample from Cobb's cusp distribution.</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>cusp.logist</code> </td><td style="text-align: left;"> Fit logistic model for bifurctation testing (experimental)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Raoul Grasman &lt;rgrasman@uva.nl&gt;
</p>


<h3>References</h3>

<p>L. Cobb and S. Zacks (1985) <em>Applications of Catastrophe Theory for Statistical Modeling in the Biosciences (article)</em>, Journal of the American Statistical Association, 392:793&ndash;802.
</p>
<p>P. Hartelman (1996). <em>Stochastic Catastrophy Theory.</em> Unpublished PhD-thesis.
</p>
<p>H. L. J. van der Maas, R. Kolstein, and J van der Pligt (2003). <em>Sudden Transitions in Attitudes</em>, Sociological Methods and Research, 32:125-152.
</p>
<p>Oliva, DeSarbo, Day, and Jedidi. (1987) <em>GEMCAT : A General Multivariate Methodology for Estimating Catastrophe Models</em>, Behavioral Science, 32:121-137.
</p>
<p>R. P. P. P. Grasman, H. L. J. van der Maas, and E-J. Wagenmakers (2009). <em>Fitting the Cusp
Catastrophe in R: A cusp Package Primer.</em> Journal of Statistical Software 32(8), 1-28. URL
<a href="https://www.jstatsoft.org/v32/i08/">https://www.jstatsoft.org/v32/i08/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# fitting cusp to cusp data
x &lt;- rcusp(100, alpha=0, beta=1)
fit &lt;- cusp(y ~ x, alpha ~ 1, beta ~ 1)
print(fit)

# example with regressors
## Not run: 
x1 = runif(150)
x2 = runif(150)
z = Vectorize(rcusp)(1, 4*x1-2, 4*x2-1)
data &lt;- data.frame(x1, x2, z)
fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data)
print(fit)
summary(fit)
plot(fit)
cusp3d(fit)

## End(Not run)

# use of OK
npar &lt;- length(fit$par)
## Not run: 
while(!fit$OK) # refit if necessary until convergence is OK
    fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data, start=rnorm(npar))

## End(Not run)

## Not run: 
# example 1 from paper
data(attitudes)
data(attitudeStartingValues)
fit.attitudes &lt;- cusp(y ~ Attitude, alpha ~ Orient + Involv, beta ~ Involv,
 data = attitudes, start=attitudeStartingValues)

summary(fit.attitudes)
plot(fit.attitudes)
cusp3d(fit.attitudes, B = 0.75, Y = 1.35, theta = 170, phi = 30, Yfloor = -9)

## End(Not run)
</code></pre>

<hr>
<h2 id='cusp.bifset'> compute normal/symmetry factor borders of bifurcation set of cusp catastrophe </h2><span id='topic+cusp.bifset'></span>

<h3>Description</h3>

<p>Given bifurcation/splitting factor values this function computes the border values of the normal/symmetry factor for the bifurcation set of the cusp catastrophe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusp.bifset(beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cusp.bifset_+3A_beta">beta</code></td>
<td>
<p> values of the bifurcation/splitting factor at which the border values of the normal/symmetry factor is computed </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with columns named <code>beta</code>, <code>alpha.l</code>, <code>alpha.u</code>. The latter two columns give respectively the lower and upper border values of the normal/symmetry factor. Negative values of <code>beta</code> give <code>NaN</code> values for the normal factor.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> See <code><a href="#topic+cusp-package">cusp-package</a></code> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cusp-package">cusp-package</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    cusp.bifset(-3:3)
</code></pre>

<hr>
<h2 id='cusp.extrema'> Locate Extrema of Cusp Catastrophe Potential Function </h2><span id='topic+cusp.extrema'></span>

<h3>Description</h3>

<p>This function computes the locations of the extrema of the cusp catastrophe potential function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusp.extrema(alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cusp.extrema_+3A_alpha">alpha</code></td>
<td>
<p> (single) value of normal/symmetry factor </p>
</td></tr>
<tr><td><code id="cusp.extrema_+3A_beta">beta</code></td>
<td>
<p> (single) value of bifurcation/splitting factor </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The locations are determined by computing the solutions to the equation </p>
<p style="text-align: center;"><code class="reqn">\alpha+\beta\,X - X^3 = 0.</code>
</p>



<h3>Value</h3>

<p> Ordered vector with locations of extremes.
</p>


<h3>Note</h3>

<p> Use <code><a href="base.html#topic+Vectorize">Vectorize</a></code> to allow for array input. 
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

 <p><a href="http://www.scholarpedia.org/article/Cusp_bifurcation">http://www.scholarpedia.org/article/Cusp_bifurcation</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cusp.bifset">cusp.bifset</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    # simple use
    cusp.extrema(2,3)
    
    # using vectorize to allow for array input; 
    # returns a matrix with locations in each column
    Vectorize(cusp.extrema)(-3:3, 2)
</code></pre>

<hr>
<h2 id='cusp.logist'> Fit a Logistic Surface Model to Data </h2><span id='topic+cusp.logist'></span>

<h3>Description</h3>

<p>This function fits a logistic curve model to data using maximum likelihood under the assumption of normal errors (i.e., nonlinear least squares). Both the response variable may be modelled by a linear combination of variables and design factors, as well as the normal/asymmetry factor <code>alpha</code> and bifurction/splitting factor <code>beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusp.logist(formula, alpha, beta, data, ..., model = TRUE, x =
                 FALSE, y = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cusp.logist_+3A_formula">formula</code>, <code id="cusp.logist_+3A_alpha">alpha</code>, <code id="cusp.logist_+3A_beta">beta</code></td>
<td>
 <p><code><a href="stats.html#topic+formula">formula</a></code>s for the response variable and the regression variables (see below) </p>
</td></tr>
<tr><td><code id="cusp.logist_+3A_data">data</code></td>
<td>
 <p><code><a href="base.html#topic+data.frame">data.frame</a></code> containing <code class="reqn">n</code> observations of all the variables named in the formulas </p>
</td></tr>
<tr><td><code id="cusp.logist_+3A_...">...</code></td>
<td>
<p> named arguments that are passed to <code><a href="stats.html#topic+nlm">nlm</a></code> </p>
</td></tr>
<tr><td><code id="cusp.logist_+3A_model">model</code>, <code id="cusp.logist_+3A_x">x</code>, <code id="cusp.logist_+3A_y">y</code></td>
<td>
<p> logicals. If <code>TRUE</code> the corresponding components of the fit (the model frame, the model matrix, and the response are returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A nonlinear regression is carried out of the model
</p>
<p style="text-align: center;"><code class="reqn">y_i = \frac{1}{1+\exp(-\alpha_i/\beta_i^2)} + \epsilon_i</code>
</p>

<p>for <code class="reqn">i = 1, 2, \ldots, n</code>,
where
</p>
<p style="text-align: center;"><code class="reqn">y_i = w_0 + w_1 Y_{i1} + \cdots + w_p Y_{ip}</code>
</p>

<p style="text-align: center;"><code class="reqn">\alpha_i = a_0 + a_1 X_{i1} + \cdots + a_p X_{ip}</code>
</p>

<p style="text-align: center;"><code class="reqn">\beta_i = b_0 + b_1 X_{i1} + \cdots + b_q X_{iq}</code>
</p>

<p>in which the <code class="reqn">a_j</code>'s, and <code class="reqn">b_j</code>'s, are estimated. The <code class="reqn">Y_{ij}</code>'s are variables in the data set
and specified by <code>formula</code>; the <code class="reqn">X_{ij}</code>'s are variables in the data set and are specified in <code>alpha</code>
and <code>beta</code>. Variables in <code>alpha</code> and <code>beta</code> need not be the same. The <code class="reqn">w_j</code>'s are estimated implicitely
using concentrated likelihood methods, and are not returned explicitely.
</p>


<h3>Value</h3>

<p>List with components
</p>
<table>
<tr><td><code>minimum</code></td>
<td>
<p>Objective function value at minimum</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Coordinates of objective function minimum</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>Gradient of objective function at minimum.</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>Convergence <code>code</code> returned by <code>optim</code></p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations used by <code>optim</code></p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A named vector of estimates of <code class="reqn">a_j, b_j</code>'s</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>Estimates of <code class="reqn">\alpha_i</code>'s and <code class="reqn">\beta_i</code>'s.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Predicted values of <code class="reqn">y_i</code>'s as determined from the <code>linear.predictors</code></p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Numerical rank of matrix of predictors for <code class="reqn">\alpha_i</code>'s plus rank of matrix of predictors for <code class="reqn">\beta_i</code>'s plus rank of matrix of predictors for the <code class="reqn">y_i</code>'s.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Residual sum of squares.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Log of the likelihood at the minimum.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>Akaike's information criterion</p>
</td></tr>
<tr><td><code>rsq</code></td>
<td>
<p>R Squared (proportion of explained variance)</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Degrees of freedom for the residual</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Degrees of freedom for the Null residual</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum of squares</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Hessian matrix of objective function at the minimum if <code>hessian=TRUE</code>.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>Hessian matrix of log-likelihood function at the minimum (currently unavailable)</p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p>QR decomposition of the <code>hessian</code> matrix</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Boolean indicating if optimization convergence is proper (based on exit code <code>optim</code>, gradient, and, if <code>hessian=TRUE</code> eigen values of the hessian).</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p><code>weights</code> (currently unused)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>If requested (the default), the matrix of response variables used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If requested, the model matrix  used.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>The sum of squared deviations from the mean of the estimated <code class="reqn">y_i</code>'s.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p>Hartelman PAI (1997). <em>Stochastic Catastrophe Theory.</em> Amsterdam: University of Amsterdam, PhDthesis.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.cusp">summary.cusp</a></code> </p>

<hr>
<h2 id='cusp.nc'> Calculate the Normalizing Constant of Cobb's Cusp Density</h2><span id='topic+cusp.nc'></span><span id='topic+cusp.nc.C'></span><span id='topic+cusp.nc.c'></span><span id='topic+cusp.nc.vec'></span>

<h3>Description</h3>

<p>A family of functions that return the normalization constant for the cusp density given the values of the bifurcation and asymmetry parameters (default), or returns the moment of a specified order (<code>cusp.nc</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusp.nc(alpha, beta, mom.order = 0, ...)
cusp.nc.c(alpha, beta, ..., keep.order = TRUE) 
cusp.nc.C(alpha, beta, subdivisions = 100, rel.tol = .Machine$double.eps^0.25, 
    abs.tol = rel.tol, stop.on.error = TRUE, aux = NULL, keep.order = TRUE) 
cusp.nc.vec(alpha, beta, ..., keep.order = FALSE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cusp.nc_+3A_alpha">alpha</code></td>
<td>
<p> the asymmetry parameter in Cobb's cusp density (see <code><a href="#topic+cusp">cusp</a></code>) </p>
</td></tr>
<tr><td><code id="cusp.nc_+3A_beta">beta</code></td>
<td>
<p> the bifurcation parameter in Cobb's cusp density (see <code><a href="#topic+cusp">cusp</a></code>) </p>
</td></tr>
<tr><td><code id="cusp.nc_+3A_mom.order">mom.order</code></td>
<td>
<p> the moment order to be computed (see details below) </p>
</td></tr>
<tr><td><code id="cusp.nc_+3A_subdivisions">subdivisions</code>, <code id="cusp.nc_+3A_rel.tol">rel.tol</code>, <code id="cusp.nc_+3A_abs.tol">abs.tol</code>, <code id="cusp.nc_+3A_stop.on.error">stop.on.error</code>, <code id="cusp.nc_+3A_aux">aux</code></td>
<td>
<p> arguments used by the internal integration routine of R (see <code><a href="stats.html#topic+integrate">integrate</a></code>)</p>
</td></tr>
<tr><td><code id="cusp.nc_+3A_keep.order">keep.order</code></td>
<td>
<p>logical, that indicates wether the order of the output should be the same as the order of the input</p>
</td></tr>
<tr><td><code id="cusp.nc_+3A_...">...</code></td>
<td>
<p> extra arguments in <code>cusp.nc.c</code> that are passed to <code>cusp.nc.C</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>cusp.nc</code> returns <code class="reqn">\Psi</code> if <code>mom.order = 0</code> and <code class="reqn">\Psi</code> times the moment of order <code>mom.order</code> otherwise.
</p>
<p>The function <code>cusp.nc</code> is internally used if the C-routine symbol <code>"cuspnc"</code> is not loaded.
The functions <code>cusp.nc.c</code> and <code>cusp.nc.C</code> call this C routine, which is considerably faster than
<code>cusp.nc</code>. 
</p>
<p>These functions are not intended to be called directly by the user.
</p>


<h3>Value</h3>

<p><code>cusp.nc, cusp.nc.c, cusp.nc.vec</code> return a numeric vector of the same length as <code>alpha</code> and <code>beta</code> with normalizing constants, or the indicated moments times the normalization constant (<code>cusp.nc</code> only).
</p>
<p><code>cusp.nc.C</code> returns a list with vectors with the results obtained from <code><a href="stats.html#topic+integrate">integrate</a></code>. 
<code>cusp.nc.c</code> first sorts the input in such a way that the numerical integrals can be evaluated more quickly than in arbitrary order
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>See Also</h3>

 <p><code><a href="#topic+pcusp">pcusp</a></code>, <code><a href="#topic+dcusp">dcusp</a></code> </p>

<hr>
<h2 id='cusp.nlogLike'> Negative log-likelihood for Cobb's cusp density</h2><span id='topic+cusp.nlogLike'></span><span id='topic+cusp.nlogLike.c'></span><span id='topic+cusp.logLike'></span>

<h3>Description</h3>

<p>(Negative) log-likelihood for Cobb's cusp probability density function used by <code>cusp</code>. This function is not to be called by the user. See <code>help(cusp)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusp.nlogLike(p, y, X.alpha, X.beta = X.alpha, ..., verbose = FALSE)
cusp.nlogLike.c(p, y, X.alpha, X.beta = X.alpha, ..., verbose = FALSE)
cusp.logLike(p, x, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cusp.nlogLike_+3A_p">p</code></td>
<td>
<p> parameter vector </p>
</td></tr>
<tr><td><code id="cusp.nlogLike_+3A_x">x</code></td>
<td>
<p> vector of observed values for the state variable in the cusp (<code>cusp.nlogLike</code> only) </p>
</td></tr>
<tr><td><code id="cusp.nlogLike_+3A_y">y</code></td>
<td>
<p> design matrix predicting state values at which the likelihood is evaluated </p>
</td></tr>
<tr><td><code id="cusp.nlogLike_+3A_x.alpha">X.alpha</code></td>
<td>
<p> design matrix predicting alpha in the model </p>
</td></tr>
<tr><td><code id="cusp.nlogLike_+3A_x.beta">X.beta</code></td>
<td>
<p> design matrix predicting beta in the model </p>
</td></tr>
<tr><td><code id="cusp.nlogLike_+3A_...">...</code></td>
<td>
<p> unused extra arguments </p>
</td></tr>
<tr><td><code id="cusp.nlogLike_+3A_verbose">verbose</code></td>
<td>
<p> logical, if <code>TRUE</code> the value of the parameters are printed to the console </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cusp.nlogLike</code> is the R version of the corresponding C function wrapped by <code>cusp.nlogLike.c</code>
</p>
<p>These functions are not intended to be called directly by the user.
</p>


<h3>Value</h3>

<p>The value of the negative log-likelihood function (<code>cusp.nlogLike</code>, <code>cusp.nlogLike.c</code>), 
the value of the log-likelihood function (<code>cusp.logLike</code>).
</p>


<h3>Note</h3>

<p>The functions are not to be called by the user directly.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> See <a href="#topic+cusp-package">cusp-package</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cusp">cusp</a></code>, <a href="#topic+cusp-package">cusp-package</a> </p>

<hr>
<h2 id='cusp3d'> Generate 3D plot of Cusp Catatrophe Model Fit </h2><span id='topic+cusp3d'></span>

<h3>Description</h3>

<p>This function generates a 3D display of the fit (object) of a cusp model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusp3d(y, alpha = if (!missing(y) &amp;&amp; is.list(y)) y$lin[, "alpha"],
    beta = if (!missing(y) &amp;&amp; is.list(y)) y$lin[, "beta"], w = 0.03,
    theta = 170, phi = 35, B = 4, Y = 3, Yfloor = -15,
    np = 180, n.surface = 30, surface.plot = TRUE,
    surf.alpha = 0.75, surf.gamma = 1.5, surf.chroma = 35, surf.hue = 240,
    surf.ltheta = 0, surf.lphi = 45, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cusp3d_+3A_y">y</code></td>
<td>
<p> object returned by <code><a href="#topic+cusp">cusp</a></code> or a vector of observed state values </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_alpha">alpha</code></td>
<td>
<p> vector of normal/symmetry factor values corresponding to the state values in <code>y</code> </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_beta">beta</code></td>
<td>
<p> vector of bifurcation/splitting factor values corresponding to the state values in <code>y</code> </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_w">w</code></td>
<td>
<p> number that specifies the size of the data points plotted on the cusp surface </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_theta">theta</code>, <code id="cusp3d_+3A_phi">phi</code></td>
<td>
<p> angles defining the viewing direction. <code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_b">B</code></td>
<td>
<p> range of the splitting factor axis </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_y">Y</code></td>
<td>
<p> range of the state variable axis </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_yfloor">Yfloor</code></td>
<td>
<p> location on state variable axis where the control surface is plotted </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_np">np</code></td>
<td>
<p> factor that determines the fineness of the drawing </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_n.surface">n.surface</code></td>
<td>
<p> factor that determines the fineness of the rendered surface </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_surface.plot">surface.plot</code></td>
<td>
<p> plot the surface? </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_surf.alpha">surf.alpha</code></td>
<td>
<p> transparency level of rendered surface </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_surf.gamma">surf.gamma</code></td>
<td>
<p> factor that determines the shading of surface facets (<code>surf.gamma</code>&lt;1 deminishes shading, <code>surf.gamma</code>&gt;1 exagerates shading) </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_surf.chroma">surf.chroma</code>, <code id="cusp3d_+3A_surf.hue">surf.hue</code></td>
<td>
<p> chroma and hue of surface color (see <code><a href="grDevices.html#topic+hcl">hcl</a></code>) </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_surf.ltheta">surf.ltheta</code>, <code id="cusp3d_+3A_surf.lphi">surf.lphi</code></td>
<td>
<p> the surface is shaded as though it was being illuminated from the direction specified by azimuth <code>surf.ltheta</code> and colatitude <code>surf.lphi</code> </p>
</td></tr>
<tr><td><code id="cusp3d_+3A_...">...</code></td>
<td>
<p> named parameters that are pased to <code><a href="graphics.html#topic+persp">persp</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is experimental.
</p>


<h3>Value</h3>

<p><code>cusp3d</code> returns the viewing transformation matrix, say <code>VT</code>, a 4 x 4 matrix suitable for projecting 3D coordinates (x,y,z) into the 2D plane using homogeneous 4D coordinates (x,y,z,t). It can be used to superimpose additional graphical elements on the 3D plot, by lines() or points(), using the simple function trans3d().
</p>


<h3>Note</h3>

<p> Currently still somewhat buggy.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> See <code><a href="#topic+cusp-package">cusp-package</a></code> </p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="#topic+plot.cusp">plot.cusp</a></code>, <code><a href="#topic+cusp3d.surface">cusp3d.surface</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x1 = runif(150)
x2 = runif(150)
z = Vectorize(rcusp)(1, 4*x1-2, 4*x2-1)
data &lt;- data.frame(x1, x2, z)
fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data)

cusp3d(fit)

</code></pre>

<hr>
<h2 id='cusp3d.surface'> Generate 3D plot of the Cusp surface </h2><span id='topic+cusp3d.surface'></span>

<h3>Description</h3>

<p>This function generates a 3D display of the cusp equilibrium surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusp3d.surface(alpha = c(-5, 5), beta = c(-3, 3), y = 41, 
xlim = range(alpha), ylim = range(beta), zlim = c(-5, 4), 
xlab = expression(alpha), ylab = expression(beta), zlab = "equilibrium states", 
main = NULL, sub = NULL, phi = 20, theta = 160, 
r = sqrt(3), d = 1, scale = TRUE, expand = 1, hue = 240, 
chroma = 35, surf.alpha = 0.75, gamma = 1.5, bcol = NA, 
lcol = "gray", ltheta = 90, lphi = 70, box = TRUE, 
axes = FALSE, nticks = 5, ticktype = "simple", floor.lines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cusp3d.surface_+3A_alpha">alpha</code></td>
<td>
<p> numeric 2-vector specifying the normal/symmetry factor axis range </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_beta">beta</code></td>
<td>
<p> numeric 2-vector specifying the bifurcation/splitting factor axis range </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_y">y</code></td>
<td>
<p> numeric specifying the iso contours used to render the surface (see detais below) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_xlim">xlim</code>, <code id="cusp3d.surface_+3A_ylim">ylim</code>, <code id="cusp3d.surface_+3A_zlim">zlim</code></td>
<td>
<p> numeric 2-vectors (see <code><a href="graphics.html#topic+persp">persp</a></code>) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_xlab">xlab</code>, <code id="cusp3d.surface_+3A_ylab">ylab</code>, <code id="cusp3d.surface_+3A_zlab">zlab</code>, <code id="cusp3d.surface_+3A_main">main</code>, <code id="cusp3d.surface_+3A_sub">sub</code></td>
<td>
<p> strings (see <code><a href="graphics.html#topic+persp">persp</a></code>) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_phi">phi</code>, <code id="cusp3d.surface_+3A_theta">theta</code></td>
<td>
<p> numeric, determine viewing direction (see <code><a href="graphics.html#topic+persp">persp</a></code>) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_r">r</code></td>
<td>
<p> numeric, distance to center of the plotting box (see <code><a href="graphics.html#topic+persp">persp</a></code>) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_d">d</code></td>
<td>
<p> numeric, strength of perspective transformation (see <code><a href="graphics.html#topic+persp">persp</a></code>) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_scale">scale</code>, <code id="cusp3d.surface_+3A_expand">expand</code></td>
<td>
<p> logical, see <code><a href="graphics.html#topic+persp">persp</a></code> </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_hue">hue</code>, <code id="cusp3d.surface_+3A_chroma">chroma</code>, <code id="cusp3d.surface_+3A_surf.alpha">surf.alpha</code></td>
<td>
<p> hue, chroma and alpha (transparency) of the surface segments (see <code><a href="grDevices.html#topic+hcl">hcl</a></code>)</p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_gamma">gamma</code></td>
<td>
<p> gamma for shading of surface (see <code><a href="#topic+cusp3d">cusp3d</a></code>) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_bcol">bcol</code></td>
<td>
<p> color, <code>NA</code>, or string <code>"surface"</code>. Color of the border of each surface element; <code>NA</code> gives transparent borders; <code>"surface"</code> tries to hide the border as much as possible by giving it the same color as the surface segment. </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_lcol">lcol</code></td>
<td>
<p> color of the lines on the floor of the plotting cube </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_ltheta">ltheta</code>, <code id="cusp3d.surface_+3A_lphi">lphi</code></td>
<td>
<p> numeric, direction of illumination of the surface (similar to <code><a href="graphics.html#topic+persp">persp</a></code>)</p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_box">box</code>, <code id="cusp3d.surface_+3A_axes">axes</code>, <code id="cusp3d.surface_+3A_nticks">nticks</code>, <code id="cusp3d.surface_+3A_ticktype">ticktype</code></td>
<td>
<p> (see <code><a href="graphics.html#topic+persp">persp</a></code>) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_floor.lines">floor.lines</code></td>
<td>
<p> logical, if <code>TRUE</code> (default) iso-contours are projected on the floor of the plotting cube (revealing the bifurcation set) </p>
</td></tr>
<tr><td><code id="cusp3d.surface_+3A_...">...</code></td>
<td>
<p> extra arguments that are passed to <code><a href="graphics.html#topic+lines">lines</a></code> and <code><a href="graphics.html#topic+polygon">polygon</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>y</code> has length 1, it is interpreted as the number of contours. Otherwise it is interpreted as a vector of contour levels from which the surface must be determined. If <code>y</code> is a number, the exact range of <code>y</code> is determined by the ranges of <code>alpha</code> and <code>beta</code> through the cusp equilibrium equation below.
</p>
<p>The surface is constructed from the iso-contours of the cusp equilibrium surface that makes up the solutions to </p>
<p style="text-align: center;"><code class="reqn">\alpha + \beta*y - y^3 = 0</code>
</p>

<p>as a (multi-)function of the asymmetry variable <code class="reqn">\alpha</code> and bifurcation variable <code class="reqn">\beta</code>. For each possible solution <code class="reqn">y</code> the iso-contours are given by the equation </p>
<p style="text-align: center;"><code class="reqn">\alpha = (\beta*y - y^3)/y,</code>
</p>
<p> which are linear in <code class="reqn">\beta</code>. For each value of <code class="reqn">y</code> the values of <code class="reqn">alpha</code> are determined for the end points of the <code class="reqn">beta</code> range specified by <code>beta</code>. The two 3D coordinates (<code class="reqn">\alpha</code>, <code class="reqn">\beta</code>, <code class="reqn">y</code>) are projected onto the 2D canvas using the <code><a href="graphics.html#topic+persp">persp</a></code> transformation matrix and used for drawing the lines and polygons.
</p>


<h3>Value</h3>

<p><code>cusp3d.surface</code> returns the viewing transformation matrix, say <code>VT</code>, a 4 x 4 matrix suitable for projecting 3D coordinates (x,y,z) into the 2D plane using homogeneous 4D coordinates (x,y,z,t). It can be used to superimpose additional graphical elements on the 3D plot, by lines() or points(), using the simple function trans3d().
</p>


<h3>Note</h3>

<p>   This function is an alternative to <code><a href="#topic+cusp3d">cusp3d</a></code> which uses a different method of rendering and also plots fitted points on the surface.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> See <code><a href="#topic+cusp-package">cusp-package</a></code>, <code><a href="#topic+cusp3d">cusp3d</a></code> </p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="#topic+plot.cusp">plot.cusp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p = cusp3d.surface(chroma=40,lcol=1,surf.alpha=.95,phi=30,theta=150,
	bcol="surface",axes=TRUE,main="Cusp Equilibrium Surface")
lines(trans3d(c(5,5), c(3,3), c(-5,4), p), lty=3) # replot some of the box outlines 
lines(trans3d(c(-5,5), c(3,3), c(4,4), p), lty=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='dcusp'> Cobb's Cusp Distribution </h2><span id='topic+dcusp'></span><span id='topic+rcusp'></span><span id='topic+pcusp'></span><span id='topic+qcusp'></span>

<h3>Description</h3>

<p>Functions for the cusp distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcusp(y, alpha, beta)
pcusp(y, alpha, beta, subdivisions = 100, rel.tol = .Machine$double.eps^0.25, 
            abs.tol = rel.tol, stop.on.error = TRUE, aux = NULL, keep.order = TRUE)
qcusp(p, alpha, beta)
rcusp(n, alpha, beta) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcusp_+3A_y">y</code></td>
<td>
<p> vector of quantiles </p>
</td></tr>
<tr><td><code id="dcusp_+3A_p">p</code></td>
<td>
<p> vector of probabilities </p>
</td></tr>
<tr><td><code id="dcusp_+3A_n">n</code></td>
<td>
<p> number of observations. </p>
</td></tr>
<tr><td><code id="dcusp_+3A_alpha">alpha</code></td>
<td>
<p> normal/asymmetry factor value of cusp density </p>
</td></tr>
<tr><td><code id="dcusp_+3A_beta">beta</code></td>
<td>
<p> bifurcation/splitting factor value of cusp density </p>
</td></tr>
<tr><td><code id="dcusp_+3A_subdivisions">subdivisions</code></td>
<td>
<p>See <code><a href="#topic+cusp-package">cusp-package</a></code>.</p>
</td></tr>
<tr><td><code id="dcusp_+3A_rel.tol">rel.tol</code></td>
<td>
<p>See <code><a href="#topic+cusp-package">cusp-package</a></code>.</p>
</td></tr>
<tr><td><code id="dcusp_+3A_abs.tol">abs.tol</code></td>
<td>
<p>See <code><a href="#topic+cusp-package">cusp-package</a></code>.</p>
</td></tr>
<tr><td><code id="dcusp_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p>See <code><a href="#topic+cusp-package">cusp-package</a></code>.</p>
</td></tr>
<tr><td><code id="dcusp_+3A_aux">aux</code></td>
<td>
<p>See <code><a href="#topic+cusp-package">cusp-package</a></code>.</p>
</td></tr>
<tr><td><code id="dcusp_+3A_keep.order">keep.order</code></td>
<td>
<p> logical. If true the order of the output values is the same as those of the input values <code>y</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cusp distribution is defined by </p>
<p style="text-align: center;"><code class="reqn"> f(y) = \Psi \exp(\alpha y + \beta y^2/2 - y^4/4), </code>
</p>
<p> where <code class="reqn">\Psi</code> is the normalizing constant.
</p>
<p><code>rcusp</code> uses rejection sampling to generate samples.
</p>
<p><code>qcusp</code> implements binary search and is rather slow.
</p>


<h3>Value</h3>

 <p><code>dcusp</code> gives the density function, <code>pcusp</code> gives the distribution function, <code>qcusp</code> gives the quantile function, and <code>rcusp</code> generates observations.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> See <code><a href="#topic+cusp-package">cusp-package</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cusp-package">cusp-package</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    # evaluate density and distribution
    dcusp(0,2,3)
    pcusp(0,2,3)
    pcusp(qcusp(0.125,2,3),2,3) # = 0.125
    
    # generate cusp variates
    rcusp(100, 2, 3) 
    
    # generate cusp variates for random normal and splitting factor values
    alpha = runif(20, -3, 3)
    beta =  runif(20, -3, 3)
    Vectorize(rcusp)(1, alpha, beta)
</code></pre>

<hr>
<h2 id='draw.cusp.bifset'> Add Cusp Bifurcation Set Diagram to Existing Plot </h2><span id='topic+draw.cusp.bifset'></span>

<h3>Description</h3>

<p>Add a miniature bifurcation set for the cusp catastrophe to an existing plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.cusp.bifset(rx = par("usr")[1:2], ry = par("usr")[3:4], xpos = min(rx) + 
    0.01 * diff(rx)[1], ypos = max(ry) - 0.01 * diff(ry)[1], 
    xscale =  0.1 * diff(rx), yscale =  0.1 * diff(ry) / xscale, 
    aspect = 1, mark = 1, col = hsv(0.7, s = 0.8, alpha = 0.5), 
    border = NA, density = NA, bifurcation.set.fill = gray(0.8), 
    background = hsv(0.1, s = 0.1, alpha = 0.5), ..., X)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.cusp.bifset_+3A_rx">rx</code></td>
<td>
<p> x-axis range of the plot window </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_ry">ry</code></td>
<td>
<p> y-axis range of the plot window </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_xpos">xpos</code></td>
<td>
<p> x-axis position of drawing </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_ypos">ypos</code></td>
<td>
<p> y-axis position of drawing </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_xscale">xscale</code></td>
<td>
<p> scaling applied to drawing along x-axis </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_yscale">yscale</code></td>
<td>
<p> scaling applied to drawing along y-axis </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_aspect">aspect</code></td>
<td>
<p> aspect ratio  </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_mark">mark</code></td>
<td>
<p> 0, 1, 2, 3, or 4; indicates which part of the cusp surface should be marked </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_col">col</code></td>
<td>
<p> color used for marking a part of the cusp surface </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_border">border</code></td>
<td>
<p> color used for the marked part of the cusp surface. See <code>polygon</code> for details. </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_density">density</code></td>
<td>
<p> the density of shading lines of the marked part of the cusp surface, in lines per inch. The default value of NULL means that no shading lines are drawn. See <code>polygon</code> for details. </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_bifurcation.set.fill">bifurcation.set.fill</code></td>
<td>
<p> color for marking the bifurcation set </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_background">background</code></td>
<td>
<p> background color of the cusp surface </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_...">...</code></td>
<td>
<p> arguments passed to <code>rect</code> and <code>polygon</code> </p>
</td></tr>
<tr><td><code id="draw.cusp.bifset_+3A_x">X</code></td>
<td>
 <p><code>data.frame</code>, depricated </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly intended for internal use by <code>cusp.plot</code>.
</p>


<h3>Value</h3>

<p>No return value. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

 <p><a href="http://www.scholarpedia.org/article/Cusp_bifurcation">http://www.scholarpedia.org/article/Cusp_bifurcation</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cusp">plot.cusp</a></code>, <code><a href="graphics.html#topic+polygon">polygon</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(1:10)
draw.cusp.bifset(mark=0) # no marking

## End(Not run)
</code></pre>

<hr>
<h2 id='oliva'> Synthetic cusp data set</h2><span id='topic+oliva'></span>

<h3>Description</h3>

<p>Synthetic &lsquo;multivariate&rsquo; data from the cusp catastrophe as generated from the equations specified by Oliva et al. (1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oliva)</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 12 variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>splitting factor predictor</p>
</dd>
<dt><code>x2</code></dt><dd><p>splitting factor predictor</p>
</dd>
<dt><code>x3</code></dt><dd><p>splitting factor predictor</p>
</dd>
<dt><code>y1</code></dt><dd><p>the bifurcation  factor predictor</p>
</dd>
<dt><code>y2</code></dt><dd><p>the bifurcation  factor predictor</p>
</dd>
<dt><code>y3</code></dt><dd><p>the bifurcation  factor predictor</p>
</dd>
<dt><code>y4</code></dt><dd><p>the bifurcation  factor predictor</p>
</dd>
<dt><code>z1</code></dt><dd><p>the state factor predictor</p>
</dd>
<dt><code>z2</code></dt><dd><p>the state factor predictor</p>
</dd>
<dt><code>alpha</code></dt><dd><p>the true <code class="reqn">alpha</code>'s</p>
</dd>
<dt><code>beta</code></dt><dd><p>the true <code class="reqn">beta</code>'s</p>
</dd>
<dt><code>y</code></dt><dd><p>the true state variable values</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data in Oliva et al. (1987) are obtained from the equations
</p>
<p style="text-align: center;"><code class="reqn">\alpha_i = X_{i1} - .969\,X_{i2} - .201\,X_{i3}, </code>
</p>

<p style="text-align: center;"><code class="reqn">\beta_i  = .44\,Y_{i1} + 0.08\,Y_{i2} + .67\,Y_{i3} + .19\,Y_{i4}, </code>
</p>

<p style="text-align: center;"><code class="reqn">y_i      = -0.52\,Z_{i1} - 1.60\,Z_{i2}.</code>
</p>

<p>Here the <code class="reqn">X_{ij}</code>'s are uniformly distributed on (-2,2), and the <code class="reqn">Y_{ij}</code>'s and <code class="reqn">Z_{i1}</code> are 
uniform on (-3,3).
The states <code class="reqn">y_i</code> were then generated from the cusp density, using <code><a href="#topic+rcusp">rcusp</a></code>, with their respective 
<code class="reqn">\alpha_i</code>'s and <code class="reqn">\beta_i</code>'s as normal and splitting factors, and then <code class="reqn">Z_2</code> was computed as 
</p>
<p style="text-align: center;"><code class="reqn">Z_{i2} = (y_i + 0.52 Z_{i1} )/( 1.60).</code>
</p>



<h3>Source</h3>

<p>Oliva T, Desarbo W, Day D, Jedidi K (1987). GEMCAT: A general multivariate 
methodology for estimating catastrophe models. Behavioral Science, 32(2), 121137.
</p>


<h3>References</h3>

<p>Oliva T, Desarbo W, Day D, Jedidi K (1987). GEMCAT: A general multivariate 
methodology for estimating catastrophe models. Behavioral Science, 32(2), 121137.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oliva)
set.seed(121)
fit &lt;- cusp(y ~ z1 + z2 - 1, 
	alpha ~ x1 + x2 + x3 - 1, ~ y1 + y2 + y3 + y4 - 1, 
	data = oliva, start = rnorm(9))
summary(fit)
## Not run: 
cusp3d(fit, B=5.25, n.surf=50, theta=150) 
# B modifies the range of beta (is set here to 5.25 to make 
# sure all points lie on the surface)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.cusp'> Graphical Diagnostic Display of Cusp Catastrophe Data Fit </h2><span id='topic+plot.cusp'></span>

<h3>Description</h3>

<p>This function generates diagnostic graphical displays of fits of a cusp catastrophe model to data obtained with <code><a href="#topic+cusp">cusp</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cusp'
plot(x, what = c("all", "bifurcation", "residual", "densities"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cusp_+3A_x">x</code></td>
<td>
<p> Object returned by <code><a href="#topic+cusp">cusp</a></code> </p>
</td></tr>
<tr><td><code id="plot.cusp_+3A_what">what</code></td>
<td>
<p> 1-character string giving the type of plot desired. The following values are possible: <code>"all"</code> for a panel plot with all diagnostic plots, <code>"bifurcation"</code> for a plot of the bifurcation surface with estimated control parameter locations superimposed, &quot;residual&quot; for a plot of the residuals against fitted values, &quot;densities&quot; for a plot of density estimates conditioned on the estimated location on the bifurcation surface. </p>
</td></tr>
<tr><td><code id="plot.cusp_+3A_...">...</code></td>
<td>
<p> named arguments that are passed to lower level plotting function </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These diagnostic plots help to identify problems with the fitted model. In optimal
cases the fitted locations in the parameter plane are dispersed over regions of
qualitatively different behavior. Within each region the fitted dependent
values have a density of the appropriate shape (e.g., bimodal in the bifurcation
set).
</p>


<h3>Value</h3>

<p>No return value. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> See <code><a href="#topic+cusp-package">cusp-package</a></code> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotCuspBifurcation">plotCuspBifurcation</a></code>, <code><a href="#topic+plotCuspResidfitted">plotCuspResidfitted</a></code>, <code><a href="#topic+plotCuspDensities">plotCuspDensities</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20)
x1 = runif(150)
x2 = runif(150)
z = Vectorize(rcusp)(1, 4*x1-2, 4*x2-1)
data &lt;- data.frame(x1, x2, z)
fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data)
## Not run: 
plot(fit)

# just densities
layout(matrix(1:4,2))
plot(fit, what="densities")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCuspBifurcation'> Display Fitted Data on Control Plane of Cusp Catastrophe. </h2><span id='topic+plotCuspBifurcation'></span>

<h3>Description</h3>

<p>Displays fitted data points on the control plane of cusp catastrophe. The function takes a fit object obtained with <code>cusp</code> and generates a plot. Different diagnostic plots may be chosen, or all can be combined in a single plot (the default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCuspBifurcation(object, xlim = a + c(-0.3, 0.3), ylim = b + c(-0.1,
                 0.1), xlab = expression(alpha), ylab =
                 expression(beta), hue = 0.5 + 0.25 * tanh(object$y),
                 col = hsv(h = hue, s = 1, alpha = 0.4), cex.xlab =
                 1.55, cex.ylab = cex.xlab, axes = TRUE, box = TRUE,
                 add = FALSE, bifurcation.set.fill = gray(0.8),
                 cex.scale = 15, cex = (cex.scale/log(NROW(ab))) *
                 dens/max(dens), pch = 20)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCuspBifurcation_+3A_object">object</code></td>
<td>
<p> object returned by <code>cusp</code> </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_xlim">xlim</code></td>
<td>
<p> the x limits (x1, x2) of the plot. </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_ylim">ylim</code></td>
<td>
<p> the y limits of the plot. </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_xlab">xlab</code></td>
<td>
<p> a label for the x axis.  </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_ylab">ylab</code></td>
<td>
<p> a label for the x axis.  </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_hue">hue</code></td>
<td>
<p> hue of points (see <code>hsv</code>) </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_col">col</code></td>
<td>
<p> color used in plots </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_cex.xlab">cex.xlab</code>, <code id="plotCuspBifurcation_+3A_cex.ylab">cex.ylab</code></td>
<td>
<p> see <code><a href="graphics.html#topic+par">par</a></code> </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_axes">axes</code></td>
<td>
<p> logical. Should the axes be displayed? </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_box">box</code></td>
<td>
<p> logical. Should a box be drawn around the plot? </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_add">add</code></td>
<td>
<p> logical. Add to current plot? </p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_bifurcation.set.fill">bifurcation.set.fill</code></td>
<td>
<p> 1-character string. Color used to fill the bifurcation set (see <code><a href="grDevices.html#topic+colors">colors</a></code>).</p>
</td></tr>
<tr><td><code id="plotCuspBifurcation_+3A_cex.scale">cex.scale</code>, <code id="plotCuspBifurcation_+3A_cex">cex</code>, <code id="plotCuspBifurcation_+3A_pch">pch</code></td>
<td>
<p> see <code><a href="graphics.html#topic+par">par</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default hue of each dot is a function of the height of the cusp surface to which it is closest. This is especially usefull in the bifurcation set. Purple dots are higher than green dots.
</p>
<p>The size of the dots depends on the density of dots at its location. The higher the density the larger the dot.
</p>


<h3>Value</h3>

<p>No return value. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> See <code><a href="#topic+cusp-package">cusp-package</a></code> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cusp">plot.cusp</a></code>, <code><a href="#topic+cusp3d">cusp3d</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20)
# example with regressors
x1 = runif(150)
x2 = runif(150)
z = Vectorize(rcusp)(1, 4*x1-2, 4*x2-1)
data &lt;- data.frame(x1, x2, z)
fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data)
## Not run: 
plot(fit, what='bifurcation', box=TRUE, axes=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotCuspDensities'> Plot Cusp State Variable Densities Conditioned on Control Parameter Values</h2><span id='topic+plotCuspDensities'></span>

<h3>Description</h3>

<p>Plot density of state variables conditioned on their location on the cusp control surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCuspDensities(object, main = "Conditional density", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCuspDensities_+3A_object">object</code></td>
<td>
<p> cusp fit object returned by <code>cusp</code> </p>
</td></tr>
<tr><td><code id="plotCuspDensities_+3A_main">main</code></td>
<td>
<p> title of plot </p>
</td></tr>
<tr><td><code id="plotCuspDensities_+3A_...">...</code></td>
<td>
<p> named arguments that are passed to <code>plot</code> and <code>draw.cusp.bifset</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly intended for internal use by <code>plot.cusp</code>.
</p>


<h3>Value</h3>

<p>No return value. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cusp">plot.cusp</a></code> </p>

<hr>
<h2 id='plotCuspResidfitted'> Residuals against Fitted Plot for Cusp Model Fit </h2><span id='topic+plotCuspResidfitted'></span>

<h3>Description</h3>

<p>Plot Residuals against Fitted Values for a Cusp Model Fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCuspResidfitted(object, caption = "Residual vs Fitted", 
    xlab = paste("Fitted (", colnames(fitted(object))[1], " convention)", sep = ""), 
    ylab = "Residual", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCuspResidfitted_+3A_object">object</code></td>
<td>
<p> cusp fit object returned by <code>cusp</code> </p>
</td></tr>
<tr><td><code id="plotCuspResidfitted_+3A_caption">caption</code></td>
<td>
<p> plot caption </p>
</td></tr>
<tr><td><code id="plotCuspResidfitted_+3A_xlab">xlab</code></td>
<td>
<p> label for x-axis </p>
</td></tr>
<tr><td><code id="plotCuspResidfitted_+3A_ylab">ylab</code></td>
<td>
<p> label for y-axis </p>
</td></tr>
<tr><td><code id="plotCuspResidfitted_+3A_...">...</code></td>
<td>
<p> named arguments that are passed to <code><a href="graphics.html#topic+plot">plot</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly intended for internal use by <code>plot.cusp</code>.
</p>


<h3>Value</h3>

<p>No return value. Called for its side effect.
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cusp">plot.cusp</a></code> </p>

<hr>
<h2 id='predict.cusp'>
Predict method for Cusp Model Fits
</h2><span id='topic+predict.cusp'></span>

<h3>Description</h3>

<p>Predicted values based on a cusp model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cusp'
predict(object, newdata, se.fit = FALSE, interval =
  c("none", "confidence", "prediction"), level = 0.95, type = c("response", "terms"),
  terms = NULL, na.action = na.pass, pred.var = res.var/weights, weights = 1,
  method = c("delay", "maxwell", "expected"), keep.linear.predictors = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cusp_+3A_object">object</code></td>
<td>

<p>Object of class &quot;<code>cusp</code>&quot;
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_newdata">newdata</code></td>
<td>

<p>An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_se.fit">se.fit</code></td>
<td>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>. Not yet used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_interval">interval</code></td>
<td>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>. Not yet used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_level">level</code></td>
<td>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>. Not yet used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_type">type</code></td>
<td>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>. Not yet used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_terms">terms</code></td>
<td>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>. Not yet used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_na.action">na.action</code></td>
<td>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>. Not yet used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_pred.var">pred.var</code></td>
<td>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>. Not yet used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_weights">weights</code></td>
<td>

<p>See <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>. Not yet used.
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_method">method</code></td>
<td>

<p>Type of prediction convention to use. Can be abbreviated. (<code>expected</code> should currently not be trusted).
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_keep.linear.predictors">keep.linear.predictors</code></td>
<td>

<p>Logical. Should the linear predictors (alpha, beta, and y) be returned?
</p>
</td></tr>
<tr><td><code id="predict.cusp_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.cusp</code> produces predicted values, obtained by evaluating the regression functions from the
cusp <code>object</code> in the frame <code>newdata</code> using <code>predict.lm</code>. This results in linear
predictors for the cusp control variables <code>alpha</code>, and <code>beta</code>, and, if <code>method = "delay"</code>,
for the behavioral cusp variable <code>y</code>. These are then used to compute predicted values: If
<code>method = "delay"</code> these are the points <code class="reqn">y*</code> on the cusp surface defined by
</p>
<p style="text-align: center;"><code class="reqn">V'(y*) = \alpha + \beta y* - y*^3 = 0</code>
</p>
<p> that are closest to <code>y</code>. If <code>method = "maxwell"</code> they are
the points on the cusp surface corresponding to the minimum of the associated potential function
<code class="reqn">V(y*) = \alpha y* + 0.5 y*^2 - 0.25 y*^4</code>.
</p>


<h3>Value</h3>

<p>A vector of predictions. If <code>keep.linear.predictors</code> the return value has a <code>"data"</code> attribute
which links to <code>newdata</code> augmented with the linear predictors <code>alpha</code>, <code>beta</code>, and, if
<code>method = "delay"</code>, <code>y</code>. If <code>method = "expected"</code>, the expected value from the equilibrium
distribution of the stochastic process </p>
<p style="text-align: center;"><code class="reqn">dY_t = V'(Y_t;\alpha, \beta)dt + dW_t,</code>
</p>
<p> where <code class="reqn">W_t</code> is
a Wiener proces (aka Brownian motion) is returned. (This distribution is implemented in
<code><a href="#topic+dcusp">dcusp</a></code>.)
</p>


<h3>Note</h3>

<p>Currently <code>method = "expected"</code> should not be trusted.
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>References</h3>

<p>See <code><a href="#topic+cusp-package">cusp-package</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cusp-package">cusp-package</a></code>, <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# example with regressors
x1 = runif(150)
x2 = runif(150)
z = Vectorize(rcusp)(1, 4*x1-2, 4*x2-1)
data &lt;- data.frame(x1, x2, z)
fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data)

newdata = data.frame(x1 = runif(10), x2 = runif(10), z = 0)
predict(fit, newdata)
</code></pre>

<hr>
<h2 id='summary.cusp'> Summarizing Cusp Catastrophe Model Fits </h2><span id='topic+summary.cusp'></span><span id='topic+print.summary.cusp'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &ldquo;cusp&rdquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cusp'
summary(object, correlation = FALSE, symbolic.cor = FALSE, logist = FALSE, ...)

## S3 method for class 'summary.cusp'
print(x, digits = max(3, getOption("digits") - 3), symbolic.cor = x$symbolic.cor,
    signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cusp_+3A_object">object</code></td>
<td>
<p> Object returned by <code>cusp</code> </p>
</td></tr>
<tr><td><code id="summary.cusp_+3A_x">x</code></td>
<td>
 <p>&lsquo;<code>summary.cusp</code>&rsquo; object </p>
</td></tr>
<tr><td><code id="summary.cusp_+3A_correlation">correlation</code></td>
<td>
<p> logical; if <code>TRUE</code> the correlation matrix is returned </p>
</td></tr>
<tr><td><code id="summary.cusp_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p> logical; currently unused </p>
</td></tr>
<tr><td><code id="summary.cusp_+3A_logist">logist</code></td>
<td>
<p> logical. If <code>TRUE</code> a logistic model is fitted for cusp model assesment (see <code><a href="#topic+cusp.logist">cusp.logist</a></code> for details).</p>
</td></tr>
<tr><td><code id="summary.cusp_+3A_digits">digits</code></td>
<td>
<p> numeric; the number of significant digits to use when printing. </p>
</td></tr>
<tr><td><code id="summary.cusp_+3A_signif.stars">signif.stars</code></td>
<td>
<p> logical. If <code>TRUE</code>, significance stars are printed for each coefficient. </p>
</td></tr>
<tr><td><code id="summary.cusp_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.cusp</code> tries to be smart about formatting the coefficients, standard errors, etc. and additionally gives significance stars if <code>signif.stars</code> is <code>TRUE</code>.
</p>
<p>Correlations are printed to two decimal places (or symbolically): to see the actual correlations print <code>summary(object)$correlation</code> directly.</p>


<h3>Value</h3>

<p>The function <code>summary.cusp</code> computes and returns a list of summary statistics of the fitted linear model given in object, using the components (list elements) &ldquo;<code>call</code>&rdquo; and &ldquo;<code>terms</code>&rdquo; from its argument, plus
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>

<tr><td><code>deviance</code></td>
<td>
<p> sum of squared residuals of cusp model fit </p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p> Akaike Information Criterion for cusp model fit </p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p> contrasts used</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p> degrees of freedom for the residuals of the cusp model fit </p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p> variance of canonical state variable</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>degrees of freedom of constant model for state variable</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of optimization iterations</p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p> residuals computed by <code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code> using <code>type="deviance"</code></p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> a <code class="reqn">p \times 4</code> matrix with columns for the estimated coefficient, its standard error, t-statistic and corresponding (two-sided) p-value. Aliased coefficients are omitted.</p>
</td></tr>
<tr><td><code>aliased</code></td>
<td>
<p> named logical vector showing if the original coefficients are aliased.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p> always 1 </p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p> 3-vector containing the rank of the model matrix, residual degrees of freedom, and model degrees of freedom. </p>
</td></tr>
<tr><td><code>resid.name</code></td>
<td>
<p> string specifying the convention used in determining the residuals (i.e., &quot;Delay&quot; or &quot;Maxwell&quot;).</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p> the unscaled (dispersion = 1) estimated covariance matrix of the estimated coefficients.</p>
</td></tr>

<tr><td><code>r2lin.r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the &lsquo;fraction of variance explained&rsquo; by the linear regression model </p>
<p style="text-align: center;"><code class="reqn">w_0+w_1 Y_{i1} + \cdots + w_p Y_{ip} = \beta_0 + \beta_1 X_{i1} + \cdots + \beta_q X_{iq} + \epsilon_i,</code>
</p>
<p> where <code class="reqn">Y</code> containes all explanatory variables for the behavioral states in the cusp model, and <code class="reqn">X</code> containes all explanatory variables for the control parameters of the cusp model. This is computed from the largest canonical correlation.</p>
</td></tr>
<tr><td><code>r2lin.dev</code></td>
<td>
<p> residual sums of squares of the linear model </p>
</td></tr>
<tr><td><code>r2lin.df</code></td>
<td>
<p> degrees of freedom for the linear model </p>
</td></tr>
<tr><td><code>r2lin.logLik</code></td>
<td>
<p> value of the log-likelihood for the linear model assuming normal errors </p>
</td></tr>
<tr><td><code>r2lin.npar</code></td>
<td>
<p> number of parameters in the linear model </p>
</td></tr>
<tr><td><code>r2lin.aic</code></td>
<td>
<p> AIC for the linear model </p>
</td></tr>
<tr><td><code>r2lin.aicc</code></td>
<td>
<p> corrected AIC for the linear model </p>
</td></tr>
<tr><td><code>r2lin.bic</code></td>
<td>
<p> BIC for the linear model</p>
</td></tr>
<tr><td><code>r2log.r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the &lsquo;fraction of variance explained&rsquo; by the logistic model. See <code><a href="#topic+cusp.logist">cusp.logist</a></code> for details. </p>
</td></tr>
<tr><td><code>r2log.dev</code></td>
<td>
<p> if <code>logist = TRUE</code> residual sums of square for the logistic  model</p>
</td></tr>
<tr><td><code>r2log.df</code></td>
<td>
<p> ditto, degrees of freedom for the logistic model</p>
</td></tr>
<tr><td><code>r2log.logLik</code></td>
<td>
<p> ditto, value of log-likelihood function for the logistic model assuming normal errors. </p>
</td></tr>
<tr><td><code>r2log.npar</code></td>
<td>
<p> ditto, number of parameters for the logistic model </p>
</td></tr>
<tr><td><code>r2log.aic</code></td>
<td>
<p> ditto, AIC for logistic model </p>
</td></tr>
<tr><td><code>r2log.aicc</code></td>
<td>
<p> ditto, corrected AIC for logistic model </p>
</td></tr>
<tr><td><code>r2log.bic</code></td>
<td>
<p> ditto, BIC for logistic model </p>
</td></tr>
<tr><td><code>r2cusp.r.squared</code></td>
<td>
<p> pseudo-<code class="reqn">R^2</code>, the &lsquo;fraction of variance explained by the cusp model&rsquo;, </p>
<p style="text-align: center;"><code class="reqn">R^2 = 1 - \frac{Var(residuals_i)}{Var(y_i)}.</code>
</p>
<p> This value can be negative.</p>
</td></tr>
<tr><td><code>r2cusp.dev</code></td>
<td>
<p>residual sums of squares for cusp model</p>
</td></tr>
<tr><td><code>r2cusp.df</code></td>
<td>
<p>residual degrees of freedom for cusp model</p>
</td></tr>
<tr><td><code>r2cusp.logLik</code></td>
<td>
<p>value of the log-likelihood function for the cusp model</p>
</td></tr>
<tr><td><code>r2cusp.npar</code></td>
<td>
<p>number of parameters in the cusp model</p>
</td></tr>
<tr><td><code>r2cusp.aic</code></td>
<td>
<p>AIC for cusp model fit</p>
</td></tr>
<tr><td><code>r2cusp.aicc</code></td>
<td>
<p>corrected AIC for cusp model fit</p>
</td></tr>
<tr><td><code>r2cusp.bic</code></td>
<td>
<p>BIC for cusp model fit.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p>Cobb L, Zacks S (1985). <em>Applications of Catastrophe Theory for Statistical Modeling in the Biosciences.</em> Journal of the American Statistical Association, 80(392), 793&ndash;802.
</p>
<p>Hartelman PAI (1997). <em>Stochastic Catastrophe Theory.</em> Amsterdam: University of Amsterdam, PhDthesis.
</p>
<p>Cobb L (1998). <em>An Introduction to Cusp Surface Analysis.</em>
<br /> https://www.aetheling.com/models/cusp/Intro.htm.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cusp">cusp</a></code>, <code><a href="#topic+cusp.logist">cusp.logist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(97)
x1 = runif(150)
x2 = runif(150)
z = Vectorize(rcusp)(1, 4*x1-2, 4*x2-1)
data &lt;- data.frame(x1, x2, z)
fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data)
print(fit)
summary(fit, logist=FALSE) # set logist to TRUE to compare to logistic fit
</code></pre>

<hr>
<h2 id='vcov.cusp'> Calculate Variance-Covariance Matrix for a Fitted Cusp Model Object </h2><span id='topic+vcov.cusp'></span><span id='topic+confint.cusp'></span>

<h3>Description</h3>

<p>Returns an estimate of the variance-covariance matrix of the main parameters of a fitted cusp model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cusp'
vcov(object, ...)
## S3 method for class 'cusp'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.cusp_+3A_object">object</code></td>
<td>
<p> a fitted cusp model object. </p>
</td></tr>
<tr><td><code id="vcov.cusp_+3A_parm">parm</code></td>
<td>
<p> a specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered. </p>
</td></tr>
<tr><td><code id="vcov.cusp_+3A_level">level</code></td>
<td>
<p> the confidence level required.</p>
</td></tr>  
<tr><td><code id="vcov.cusp_+3A_...">...</code></td>
<td>
<p> additional arguments for method functions.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance-covariance matrix is estimated by the inverse of the Hessian matrix of the log-likelhood at the maximum likelihood estimate (<code>vcov</code>).
</p>
<p>Normal theory confidence intervals are computed for all parameters in the cusp model object using <code>vcov</code> to obtain the standard errors (<code>confint</code>).
</p>


<h3>Value</h3>

<p>The variance-covariance matrix (<code>vcov</code>).
</p>
<p>A matrix (or vector) with columns giving lower and upper confidence limits for each parameter. These will be labelled as (1-level)/2 and 1 - (1-level)/2 in 
</p>


<h3>Author(s)</h3>

<p> Raoul Grasman </p>


<h3>References</h3>

<p> Seber, Wild (2005) Nonlinear regression. New York: Wiley</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="#topic+cusp">cusp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x1 = runif(150)
x2 = runif(150)
z = Vectorize(rcusp)(1, 4*x1-2, 4*x2-1)
data &lt;- data.frame(x1, x2, z)
fit &lt;- cusp(y ~ z, alpha ~ x1+x2, beta ~ x1+x2, data)

vcov(fit)
</code></pre>

<hr>
<h2 id='zeeman'> Measurements from Zeeman's Catastrophe Machine</h2><span id='topic+zeeman'></span><span id='topic+zeeman1'></span><span id='topic+zeeman2'></span><span id='topic+zeeman3'></span>

<h3>Description</h3>

<p> Data sets with measurements from different physical instances of Zeeman's Catastrophe Machine</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(zeeman1)
data(zeeman2)
data(zeeman3)
</code></pre>


<h3>Format</h3>

<p>A data frame with 150/198/282 observations on the following 3 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a control plane variable that are manipulable by the experimentalist</p>
</dd>
<dt><code>y</code></dt><dd><p>a control plane variable that are manipulable by the experimentalist</p>
</dd>
<dt><code>z</code></dt><dd><p>the state variable of the machine: the shortest distance to the longitudinal axis of the machine</p>
</dd>
</dl>



<h3>Details</h3>

<p>The behavior Zeeman's catastrophe machine is archetypal for the Cusp catastrophe. 
This device consists of a wheel is tethered by an elastic chord to a fixed point. 
Another elastic, also attached to the wheel is moved about in the &lsquo;control plane&rsquo; 
area opposite to the fixed point. The shortest distance between the strap point on the 
wheel and the axis defined by the fixed point and the control plane is recorded as a 
function of the position in the control plane. (In the original machine the angle 
between this axis and the line through the wheel center and the strap point is used.) 
See <a href="http://www.math.stonybrook.edu/~tony/whatsnew/column/catastrophe-0600/cusp4.html">http://www.math.stonybrook.edu/~tony/whatsnew/column/catastrophe-0600/cusp4.html</a> 
for a vivid demonstration. These data sets were obtained from 3 different physical 
instances of this machine, made by different people.
</p>
<p>Measurements were made by systematically sampling different points in the control plane.
</p>
<p>See vignette for example analysis with all three data sets.
</p>
<p>For pictures of the machines, see
</p>

<dl>
<dt>Zeeman catastrophy machine 1</dt><dd><p><a href="https://purl.oclc.org/net/rgrasman/cusp/zeeman1">https://purl.oclc.org/net/rgrasman/cusp/zeeman1</a></p>
</dd>
<dt>Zeeman catastrophy machine 2</dt><dd><p><a href="https://purl.oclc.org/net/rgrasman/cusp/zeeman2">https://purl.oclc.org/net/rgrasman/cusp/zeeman2</a></p>
</dd>
<dt>Zeeman catastrophy machine 3</dt><dd><p><a href="https://purl.oclc.org/net/rgrasman/cusp/zeeman3">https://purl.oclc.org/net/rgrasman/cusp/zeeman3</a></p>
</dd>
</dl>



<h3>Source</h3>


<dl>
<dt><code>zeeman1</code></dt><dd><p> is due to Noemi Schuurman</p>
</dd>
<dt><code>zeeman2</code></dt><dd><p> is due to Karin Visser </p>
</dd>
<dt><code>zeeman3</code></dt><dd><p> is due to Mats Nagel &amp; Joris ?</p>
</dd>
</dl>

<p>See <a href="https://sites.google.com/site/zeemanmachine/data-repository">https://sites.google.com/site/zeemanmachine/data-repository</a>
</p>


<h3>References</h3>

<p>Zeeman (1976).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(zeeman1)
data(zeeman2)
data(zeeman3)
## Not run: 
fit &lt;- cusp(y~z, alpha~x+y, beta~x+y, data=zeeman1)
plot(fit)
cusp3d(fit, surf.hue = 40, theta=215, phi=37.5, B=5.25)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
