<!DOCTYPE html><html lang="en"><head><title>Help for package manifestoR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {manifestoR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#manifestoR-package'><p>manifestoR: Access and Process Data and Documents of the Manifesto Project</p></a></li>
<li><a href='#aggregate_pers'><p>Aggregate category percentages in groups</p></a></li>
<li><a href='#aggregate_pers_cee'><p>Aggregate cee-categories to main categories</p></a></li>
<li><a href='#attach_year'><p>Compute year from date variable in MPDS</p></a></li>
<li><a href='#clarity_dimensions'><p>Default programmatic clarity dimensions from</p>
Giebler/Lacewell/Regel/Werner 2015.</a></li>
<li><a href='#codes'><p>Access the codes of a Manifesto Document or Corpus</p></a></li>
<li><a href='#count_codes'><p>Count the codings from a ManifestoDocument</p></a></li>
<li><a href='#formatids'><p>Format ids for web API queries</p></a></li>
<li><a href='#formatmpds'><p>Format the main data set</p></a></li>
<li><a href='#formatpartiesds'><p>Format the parties data set</p></a></li>
<li><a href='#franzmann_kaiser'><p>Left-Right Scores based on Franzmann &amp; Kaiser Method</p></a></li>
<li><a href='#get_mpdb'><p>Download content from the Manifesto Database</p></a></li>
<li><a href='#get_viacache'><p>Get API results via cache</p></a></li>
<li><a href='#iff'><p>Apply a function if and only if test is TRUE</p></a></li>
<li><a href='#issue_attention_diversity'><p>Issue Attention Diversity</p></a></li>
<li><a href='#ManifestoAvailability'><p>Manifesto Availability Information class</p></a></li>
<li><a href='#ManifestoCorpus'><p>Manifesto Corpus class</p></a></li>
<li><a href='#ManifestoDocument'><p>Manifesto Document</p></a></li>
<li><a href='#ManifestoDocumentMeta'><p>Manifesto Document Metadata</p></a></li>
<li><a href='#ManifestoSource'><p>Data Source for Manifesto Corpus</p></a></li>
<li><a href='#median_voter'><p>Median Voter position</p></a></li>
<li><a href='#mp_availability'><p>Availability information for election programmes</p></a></li>
<li><a href='#mp_bootstrap'><p>Compute bootstrap distributions for scaling functions</p></a></li>
<li><a href='#mp_check_for_corpus_update'><p>Check for Updates of Corpus in Manifesto Project DB</p></a></li>
<li><a href='#mp_cite'><p>Print Manifesto Corpus citation information</p></a></li>
<li><a href='#mp_clarity'><p>Programmatic clarity measures (PC)</p></a></li>
<li><a href='#mp_codebook'><p>Access to the Codebook for the Manifesto Project Main Dataset</p></a></li>
<li><a href='#mp_coreversions'><p>List the available versions of the Manifesto Project's Main Dataset</p></a></li>
<li><a href='#mp_corpus'><p>Get documents from the Manifesto Corpus Database</p></a></li>
<li><a href='#mp_corpusversions'><p>List the available versions of the Manifesto Project's Corpus</p></a></li>
<li><a href='#mp_dedication'><p>Print manifestoR package dedication</p></a></li>
<li><a href='#mp_emptycache'><p>Empty the manifestoR's cache</p></a></li>
<li><a href='#mp_interpolate'><p>Interpolate values within election periods</p></a></li>
<li><a href='#mp_load_cache'><p>Load manifestoR's cache</p></a></li>
<li><a href='#mp_maindataset'><p>Access the Manifesto Project's Main Dataset</p></a></li>
<li><a href='#mp_metadata'><p>Get meta data for election programmes</p></a></li>
<li><a href='#mp_nicheness'><p>Party nicheness measures</p></a></li>
<li><a href='#mp_parties'><p>Access to the Parties Lists for the Manifesto Project Data</p></a></li>
<li><a href='#mp_rmps'><p>Relative measure of party size (RMPS)</p></a></li>
<li><a href='#mp_save_cache'><p>Save manifestoR's cache</p></a></li>
<li><a href='#mp_scale'><p>Scaling annotated manifesto documents</p></a></li>
<li><a href='#mp_setapikey'><p>Set the API key for the Manifesto Documents Database.</p></a></li>
<li><a href='#mp_use_corpus_version'><p>Use a specific version of the Manifesto Project Corpus</p></a></li>
<li><a href='#mp_view_originals'><p>View original documents from the Manifesto Corpus Database</p></a></li>
<li><a href='#mpdb_api_request'><p>Manifesto Project DB API request</p></a></li>
<li><a href='#na_replace'><p>Replace NAs in vector with fixed value</p></a></li>
<li><a href='#null_to_na'><p>Convert NULL to NA</p></a></li>
<li><a href='#prefix'><p>Prefix a string of text</p></a></li>
<li><a href='#readManifesto'><p>Reader for <code>ManifestoSource</code></p></a></li>
<li><a href='#recode_cee_codes'><p>Process CMP codings</p></a></li>
<li><a href='#rep.data.frame'><p>Replicates cases in a data.frame</p></a></li>
<li><a href='#rescale'><p>Simple linear rescaling of positions</p></a></li>
<li><a href='#rile'><p>RILE</p></a></li>
<li><a href='#scale_weighted'><p>Scaling functions</p></a></li>
<li><a href='#split_belgium'><p>Split Belgium party system into separate groups</p></a></li>
<li><a href='#v4_categories'><p>Lists of categories and category relations</p></a></li>
<li><a href='#vanilla'><p>Vanilla Scaling by Gabel &amp; Huber</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Access and Process Data and Documents of the Manifesto Project</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-16</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides access to coded election programmes from the Manifesto
    Corpus and to the Manifesto Project's Main Dataset and routines to analyse this
    data. The Manifesto Project <a href="https://manifesto-project.wzb.eu">https://manifesto-project.wzb.eu</a> collects and
    analyses election programmes across time and space to measure the political
    preferences of parties. The Manifesto Corpus contains the collected and
    annotated election programmes in the Corpus format of the package 'tm' to enable
    easy use of text processing and text mining functionality. Specific functions
    for scaling of coded political texts are included.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), NLP (&ge; 0.1-3), tm (&ge; 0.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, methods, magrittr, httr (&ge; 1.0.0), jsonlite (&ge;
0.9.12), functional (&ge; 0.6), zoo (&ge; 1.7-11), psych,
base64enc, htmlwidgets (&ge; 0.6), DT (&ge; 0.2), htmltools, purrr
(&ge; 0.2.4), readr (&ge; 1.2.0), dplyr (&ge; 0.7.5), tidyselect (&ge;
1.0.0), tibble (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 1.0.2), R.rsp, haven (&ge;
1.0.0), readxl (&ge; 1.0.0), devtools (&ge; 1.7.0), formatR, highr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Collate:</td>
<td>manifestoR-package.r manifestoR-defunct.R globals.R
pipe_helpers.R cache.R db_api.R corpus.R manifesto.R codes.R
scaling_general.R scaling_rile.R scaling_functions.R
issue_attention.R nicheness.R clarity.R scaling_bootstrap.R
dataset.R codebook.R parties.R dedication.R</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ManifestoProject/manifestoR">https://github.com/ManifestoProject/manifestoR</a>,
<a href="https://manifesto-project.wzb.eu/">https://manifesto-project.wzb.eu/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ManifestoProject/manifestoR/issues">https://github.com/ManifestoProject/manifestoR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-16 16:41:05 UTC; gitlab-runner</td>
</tr>
<tr>
<td>Author:</td>
<td>Jirka Lewandowski [aut],
  Nicolas Merz [aut],
  Sven Regel [aut, cre],
  Pola Lehmann [ctb],
  Paul Muscat [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sven Regel &lt;sven.regel@wzb.eu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-16 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='manifestoR-package'>manifestoR: Access and Process Data and Documents of the Manifesto Project</h2><span id='topic+manifestoR'></span><span id='topic+manifestoR-package'></span>

<h3>Description</h3>

<p>Provides access to coded election programmes from the Manifesto Corpus and to the Manifesto Project's Main Dataset and routines to analyse this data. The Manifesto Project <a href="https://manifesto-project.wzb.eu">https://manifesto-project.wzb.eu</a> collects and analyses election programmes across time and space to measure the political preferences of parties. The Manifesto Corpus contains the collected and annotated election programmes in the Corpus format of the package 'tm' to enable easy use of text processing and text mining functionality. Specific functions for scaling of coded political texts are included.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sven Regel <a href="mailto:sven.regel@wzb.eu">sven.regel@wzb.eu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jirka Lewandowski <a href="mailto:jirka.lewandowski@wzb.eu">jirka.lewandowski@wzb.eu</a>
</p>
</li>
<li><p> Nicolas Merz <a href="mailto:nicolas.merz@wzb.eu">nicolas.merz@wzb.eu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Pola Lehmann <a href="mailto:pola.lehmann@wzb.eu">pola.lehmann@wzb.eu</a> [contributor]
</p>
</li>
<li><p> Paul Muscat <a href="mailto:paul.muscat@wzb.eu">paul.muscat@wzb.eu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ManifestoProject/manifestoR">https://github.com/ManifestoProject/manifestoR</a>
</p>
</li>
<li> <p><a href="https://manifesto-project.wzb.eu/">https://manifesto-project.wzb.eu/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ManifestoProject/manifestoR/issues">https://github.com/ManifestoProject/manifestoR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aggregate_pers'>Aggregate category percentages in groups</h2><span id='topic+aggregate_pers'></span>

<h3>Description</h3>

<p><code>aggregate_pers</code> is a general function to aggregate percentage variables by creating a new
variable holding the sum. If a variable with the name for the aggregate
already exists and if it is part of the 'overwrite' parameter, it is
overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_pers(
  data,
  groups = v5_v4_aggregation_relations(),
  na.rm = FALSE,
  keep = FALSE,
  overwrite = names(groups),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_pers_+3A_data">data</code></td>
<td>
<p>dataset to use in aggregation</p>
</td></tr>
<tr><td><code id="aggregate_pers_+3A_groups">groups</code></td>
<td>
<p>(named) list of variable name vectors to aggregate to a new one
(as given in the name); see default value for an example of the format</p>
</td></tr>
<tr><td><code id="aggregate_pers_+3A_na.rm">na.rm</code></td>
<td>
<p>passed on to <code><a href="base.html#topic+sum">sum</a></code></p>
</td></tr>
<tr><td><code id="aggregate_pers_+3A_keep">keep</code></td>
<td>
<p>keep variables that were aggregated in result?</p>
</td></tr>
<tr><td><code id="aggregate_pers_+3A_overwrite">overwrite</code></td>
<td>
<p>Names of the variables that are allowed to be overwritten by
aggregate. Defaults to all aggregate variable names.</p>
</td></tr>
<tr><td><code id="aggregate_pers_+3A_verbose">verbose</code></td>
<td>
<p>show messages in case of possibly problematic side effects</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_pers_cee">aggregate_pers_cee</a></code>
</p>

<hr>
<h2 id='aggregate_pers_cee'>Aggregate cee-categories to main categories</h2><span id='topic+aggregate_pers_cee'></span>

<h3>Description</h3>

<p>Adds the code frequencies in a dataset of the 4 digit per-variables (per1011 to per7062 - mostly used in codings
of Central and Eastern European countries) to the main categories in the coding scheme (3 digits).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_pers_cee(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_pers_cee_+3A_data">data</code></td>
<td>
<p>dataset to use in aggregation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper of <code><a href="#topic+aggregate_pers">aggregate_pers</a></code> using <code>cee_aggregation_relations</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate_pers">aggregate_pers</a></code>
</p>

<hr>
<h2 id='attach_year'>Compute year from date variable in MPDS</h2><span id='topic+attach_year'></span>

<h3>Description</h3>

<p>Compute year from date variable in MPDS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_year(mpds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attach_year_+3A_mpds">mpds</code></td>
<td>
<p>a dataframe in format of Manifesto Project Main Dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>input data with year variable attached
</p>

<hr>
<h2 id='clarity_dimensions'>Default programmatic clarity dimensions from 
Giebler/Lacewell/Regel/Werner 2015.</h2><span id='topic+clarity_dimensions'></span>

<h3>Description</h3>

<p>Default programmatic clarity dimensions from 
Giebler/Lacewell/Regel/Werner 2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clarity_dimensions()
</code></pre>


<h3>References</h3>

<p>Giebler/Lacewell/Regel/Werner (2015). Mass, Catch-all, or 
Programmatic? Toward an Empirical Classification of Party Types. Manuscript.
</p>

<hr>
<h2 id='codes'>Access the codes of a Manifesto Document or Corpus</h2><span id='topic+codes'></span><span id='topic+codes.ManifestoDocument'></span><span id='topic+codes.ManifestoCorpus'></span><span id='topic+codes+3C-'></span><span id='topic+codes+3C-.ManifestoDocument'></span><span id='topic+code_layers'></span>

<h3>Description</h3>

<p>With the accessor the codes of a Manifesto Document can be
read and modified. The codes of a Manifesto Corpus can only be read,
modification needs to be done document-wise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codes(x, layer = "cmp_code")

## S3 method for class 'ManifestoDocument'
codes(x, layer = "cmp_code")

## S3 method for class 'ManifestoCorpus'
codes(x, layer = "cmp_code")

codes(x, layer = "cmp_code") &lt;- value

## S3 replacement method for class 'ManifestoDocument'
codes(x, layer = "cmp_code") &lt;- value

code_layers(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="codes_+3A_x">x</code></td>
<td>
<p>document or corpus to get the codes from</p>
</td></tr>
<tr><td><code id="codes_+3A_layer">layer</code></td>
<td>
<p>layer of codings to access, defaults to cmp_code, alternative: eu_code</p>
</td></tr>
<tr><td><code id="codes_+3A_value">value</code></td>
<td>
<p>new codes</p>
</td></tr>
</table>

<hr>
<h2 id='count_codes'>Count the codings from a ManifestoDocument</h2><span id='topic+count_codes'></span>

<h3>Description</h3>

<p>Count the codings from a ManifestoDocument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_codes(
  doc,
  code_layers = c("cmp_code"),
  with_eu_codes = "auto",
  prefix = "per",
  relative = TRUE,
  include_codes = if ("cmp_code" %in% code_layers) {
     v4_categories()
 } else {
   
     c()
 },
  aggregate_v5_subcategories = TRUE,
  drop_codes = if ("cmp_code" %in% code_layers) {
     c("H")
 } else {
     c()
 }
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_codes_+3A_doc">doc</code></td>
<td>
<p>ManifestoDocument, ManifestoCorpus or vector of codes</p>
</td></tr>
<tr><td><code id="count_codes_+3A_code_layers">code_layers</code></td>
<td>
<p>vector of names of code layers to use, defaults to cmp_code; Caution:
The layer eu_code is handled separately in the parameter with_eu_codes due to its
different logic</p>
</td></tr>
<tr><td><code id="count_codes_+3A_with_eu_codes">with_eu_codes</code></td>
<td>
<p>Whether to include special EU code layer; by default (&quot;auto&quot;) taken
from the document's metadata</p>
</td></tr>
<tr><td><code id="count_codes_+3A_prefix">prefix</code></td>
<td>
<p>prefix for naming the count/percentage columns in the resulting data.frame</p>
</td></tr>
<tr><td><code id="count_codes_+3A_relative">relative</code></td>
<td>
<p>If true, percentages are returned, absolute counts else; the percentages
are calculated after the exclusion of the categories provided in 'drop_codes'</p>
</td></tr>
<tr><td><code id="count_codes_+3A_include_codes">include_codes</code></td>
<td>
<p>Vector of categories that should be included even if they are not
present in the data; the value of the created variables then defaults to 0.0 (or NA if
no codes are present at all); in contrast to 'drop_codes' this only adds variables
for possibly missing categories but does not remove any; Defaults to 'v4_categories()' if
'code_layers' parameter contains 'cmp_code'</p>
</td></tr>
<tr><td><code id="count_codes_+3A_aggregate_v5_subcategories">aggregate_v5_subcategories</code></td>
<td>
<p>if TRUE, for handbook version 5 subcategories, the aggregate
category's count/percentage is computed as well</p>
</td></tr>
<tr><td><code id="count_codes_+3A_drop_codes">drop_codes</code></td>
<td>
<p>Vector of categories that should be excluded even if they are
present in the data; Defaults to 'c(&quot;H&quot;)' if 'code_layers' parameter contains 'cmp_code'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with onw row and the counts/percentages as columns
</p>

<hr>
<h2 id='formatids'>Format ids for web API queries</h2><span id='topic+formatids'></span>

<h3>Description</h3>

<p>Formats a data.frame of ids such that it can be used for querying
the Manifesto Project Database. That is, it must have non-NA-fields
party and date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatids(ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatids_+3A_ids">ids</code></td>
<td>
<p>ids data.frame, information used: party, date, edate</p>
</td></tr>
</table>

<hr>
<h2 id='formatmpds'>Format the main data set</h2><span id='topic+formatmpds'></span>

<h3>Description</h3>

<p>Creates the format that is visible to the R user
from the internal data.frames files (in cache or from the API)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatmpds(mpds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatmpds_+3A_mpds">mpds</code></td>
<td>
<p>A data.frame with a main data set version to be formatted</p>
</td></tr>
</table>

<hr>
<h2 id='formatpartiesds'>Format the parties data set</h2><span id='topic+formatpartiesds'></span>

<h3>Description</h3>

<p>Creates the format that is visible to the R user
from the internal data.frames files (in cache or from the API)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatpartiesds(partiesds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatpartiesds_+3A_partiesds">partiesds</code></td>
<td>
<p>A data.frame with a parties dataset to be formatted</p>
</td></tr>
</table>

<hr>
<h2 id='franzmann_kaiser'>Left-Right Scores based on Franzmann &amp; Kaiser Method</h2><span id='topic+franzmann_kaiser'></span><span id='topic+read_fk_issue_structure'></span><span id='topic+fk_smoothing'></span>

<h3>Description</h3>

<p>Computes left-right scores based on the Franzmann &amp; Kaiser Method (see
reference below). The issue structures are not calculated from scratch but
taken as given from Franzmann 2009 (or later updates). Note that they 
are not available for the entire Manifesto Project Dataset, but only for a 
subset of countries and elections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>franzmann_kaiser(
  data,
  basevalues = TRUE,
  smoothing = TRUE,
  vars = grep("per\\d{3}$", names(data), value = TRUE),
  issue_structure = read_fk_issue_structure(mean_presplit = mean_presplit),
  party_system_split = split_belgium,
  mean_presplit = TRUE,
  ...
)

read_fk_issue_structure(
  path = system.file("extdata", "fk_issue_structure_2019.csv", package = "manifestoR"),
  mean_presplit = TRUE,
  format_version = 2
)

fk_smoothing(data, score_name, use_period_length = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="franzmann_kaiser_+3A_data">data</code></td>
<td>
<p>A data.frame with cases to be scaled, variables named &quot;per...&quot;</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_basevalues">basevalues</code></td>
<td>
<p>flag for transforming data to be relative to the minimum</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_smoothing">smoothing</code></td>
<td>
<p>flag for using smoothing</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_vars">vars</code></td>
<td>
<p>Variables/Categories to use for computation of score. Defaults to all
available handbook version 4 categories.</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_issue_structure">issue_structure</code></td>
<td>
<p>issue structure to use for Franzmann &amp; Kaiser method, default 
to most recent bundled version (for details see <code>read_fk_issue_structure</code>)</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_party_system_split">party_system_split</code></td>
<td>
<p>function to recode the country variable to re-partition
party systems. Defaults to splitting Belgium into two halfs as done in Franzmann 2009</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_mean_presplit">mean_presplit</code></td>
<td>
<p>if TRUE, for Belgium as a whole (before the split into two
party systems) the mean of the issue weights is used (which is equal to taking
the mean of the output values, since all subsequent transformations are linear). This step
is required to replicate the Franzmann 2009 dataset. If the issue structures already
contain values for Belgium as a whole they are overwritten by the newly generated ones.</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_...">...</code></td>
<td>
<p>passed on to <code>fk_smoothing</code> and <code>party_system_split</code></p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_path">path</code></td>
<td>
<p>path from were to read issue structures (as csv data file). Defaults
to the most recent file bundled in the manifestoR package.</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_format_version">format_version</code></td>
<td>
<p>can be 1 or 2 to switch between different structural versions 
of the issue structures file (1 for files containing &quot;structure&quot;-columns, 
2 for files containing &quot;per&quot;-columns)</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_score_name">score_name</code></td>
<td>
<p>name of variable with LR Score values to be smoothed</p>
</td></tr>
<tr><td><code id="franzmann_kaiser_+3A_use_period_length">use_period_length</code></td>
<td>
<p>whether to use electoral period length in weighting</p>
</td></tr>
</table>


<h3>References</h3>

<p>Franzmann, Simon/Kaiser, Andre (2006): Locating Political Parties in Policy Space. A Reanalysis of Party Manifesto Data, Party Politics, 12:2, 163-188
</p>
<p>Franzmann, Simon (2009): The Change of Ideology: How the Left-Right Cleavage transforms into Issue Competition. An Analysis of Party Systems using Party Manifesto Data. PhD Thesis. Cologne.
</p>

<hr>
<h2 id='get_mpdb'>Download content from the Manifesto Database</h2><span id='topic+get_mpdb'></span>

<h3>Description</h3>

<p>Internal implementation. For more convenient access and caching use one of 
<code><a href="#topic+mp_corpus">mp_corpus</a></code>, 
<code><a href="#topic+mp_availability">mp_availability</a></code>,  
<code><a href="#topic+mp_maindataset">mp_maindataset</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mpdb(type, parameters = c(), versionid = NULL, apikey = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mpdb_+3A_type">type</code></td>
<td>
<p>string of <code>"meta", "text", "original", "main", "versions"</code> 
to indicate type of content to get</p>
</td></tr>
<tr><td><code id="get_mpdb_+3A_parameters">parameters</code></td>
<td>
<p>content filter parameters specific to type</p>
</td></tr>
<tr><td><code id="get_mpdb_+3A_versionid">versionid</code></td>
<td>
<p>character string specifying the corpus version to use, either
a name or tag as in the respective columns of the value of
<code><a href="#topic+mp_corpusversions">mp_corpusversions</a></code> and the API</p>
</td></tr>
<tr><td><code id="get_mpdb_+3A_apikey">apikey</code></td>
<td>
<p>API key to use, defaults to <code>NULL</code>, which means the key 
currently stored in the variable <code>apikey</code> of the
environment <code>mp_globalenv</code> is used.</p>
</td></tr>
</table>

<hr>
<h2 id='get_viacache'>Get API results via cache</h2><span id='topic+get_viacache'></span>

<h3>Description</h3>

<p>Get API results via cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_viacache(type, ids = c(), cache = TRUE, versionid = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_viacache_+3A_type">type</code></td>
<td>
<p>type of objects to get (metadata, documents, ...) as a string. Types
are defined as constants in globals.R</p>
</td></tr>
<tr><td><code id="get_viacache_+3A_ids">ids</code></td>
<td>
<p>identifiers of objects to get. Depending on the type a data.frame or vector of identifiers.</p>
</td></tr>
<tr><td><code id="get_viacache_+3A_cache">cache</code></td>
<td>
<p>whether to use (TRUE) or bypass (FALSE) cache, defaults to TRUE</p>
</td></tr>
<tr><td><code id="get_viacache_+3A_versionid">versionid</code></td>
<td>
<p>string identifier of version to use</p>
</td></tr>
<tr><td><code id="get_viacache_+3A_...">...</code></td>
<td>
<p>additional parameters handed over to get_mpdb</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internal to manifestoR and not designed for use from
other namespaces
</p>

<hr>
<h2 id='iff'>Apply a function if and only if test is TRUE</h2><span id='topic+iff'></span><span id='topic+iffn'></span>

<h3>Description</h3>

<p>otherwise return input value unchanged
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iff(obj, test, fun, ...)

iffn(obj, test, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iff_+3A_obj">obj</code></td>
<td>
<p>object to apply test and fun to</p>
</td></tr>
<tr><td><code id="iff_+3A_test">test</code></td>
<td>
<p>logical or function to apply to test</p>
</td></tr>
<tr><td><code id="iff_+3A_fun">fun</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="iff_+3A_...">...</code></td>
<td>
<p>passed on to test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>iffn is ... if and only if test is FALSE
</p>

<hr>
<h2 id='issue_attention_diversity'>Issue Attention Diversity</h2><span id='topic+issue_attention_diversity'></span>

<h3>Description</h3>

<p>Effective number of Manifesto Issues suggested by Zac Greene. When using the measure please cite Greene 2015 (see reference below)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>issue_attention_diversity(
  data,
  method = "shannon",
  prefix = "per",
  include_variables = paste0(prefix, setdiff(v4_categories(), "uncod")),
  aggregate_categories = list(c(101, 102), c(104, 105), c(107, 109), c(108, 110), c(203,
    204), c(301, 302), c(406, 407), c(409, 414), c(504, 505), c(506, 507), c(601, 602),
    c(603, 604), c(607, 608), c(701, 702))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="issue_attention_diversity_+3A_data">data</code></td>
<td>
<p>a data.frame in format of Manifesto Project Main Dataset</p>
</td></tr>
<tr><td><code id="issue_attention_diversity_+3A_method">method</code></td>
<td>
<p>entropy measure used for the effective number of manifesto issues. Possible options are &quot;shannon&quot; for Shannon's H and &quot;herfindahl&quot; for the Herfindahl-Index.</p>
</td></tr>
<tr><td><code id="issue_attention_diversity_+3A_prefix">prefix</code></td>
<td>
<p>Prefix of variable names to use (usually &quot;per&quot;)</p>
</td></tr>
<tr><td><code id="issue_attention_diversity_+3A_include_variables">include_variables</code></td>
<td>
<p>names of variables to include</p>
</td></tr>
<tr><td><code id="issue_attention_diversity_+3A_aggregate_categories">aggregate_categories</code></td>
<td>
<p>list of category groups to aggregate into one issue. Default to selection used in Greene 2015</p>
</td></tr>
</table>


<h3>References</h3>

<p>Greene, Z. (2015). Competing on the Issues How Experience in Government and Economic Conditions Influence the Scope of Parties' Policy Messages. Party Politics.
</p>

<hr>
<h2 id='ManifestoAvailability'>Manifesto Availability Information class</h2><span id='topic+ManifestoAvailability'></span>

<h3>Description</h3>

<p>Objects returned by <code><a href="#topic+mp_availability">mp_availability</a></code>.
</p>


<h3>Details</h3>

<p>ManifestoAvailability objects are data.frames with variables <code>party</code>
and <code>date</code> identifying the requested manifestos as in the Manifesto
Project's Main Datasets. The additional variables specify whether a machine 
readable document is available (<code>manifestos</code>, &quot;Documents found&quot;),
whether digital CMP coding annotations are available (<code>annotations</code>,
&quot;Coded Documents found&quot;), whether an orignal PDF is available
(<code>originals</code>, &quot;Originals found&quot;), or whether an english translation
for the (digitally annotated) machine-readable document is available
(<code>translation_en</code>, &quot;English Translations found&quot;).
</p>
<p>Additional a ManifestoAvailability object has attributes <code>query</code>, containing
the original id set which was queried, <code>corpus_version</code>, specifying the
Corpus version ID used for the query, and <code>date</code> with the timestamp of the query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
wanted &lt;- data.frame(party=c(41320, 41320), date=c(200909, 200509))
mp_availability(wanted)

## End(Not run)
</code></pre>

<hr>
<h2 id='ManifestoCorpus'>Manifesto Corpus class</h2><span id='topic+ManifestoCorpus'></span>

<h3>Description</h3>

<p>Objects of this class are returned by <code><a href="#topic+mp_corpus">mp_corpus</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ManifestoCorpus(csource = ManifestoJSONSource())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ManifestoCorpus_+3A_csource">csource</code></td>
<td>
<p>a <code><a href="#topic+ManifestoJSONSource">ManifestoJSONSource</a></code>, see <code><a href="tm.html#topic+Source">Source</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>tm</code> <code><a href="tm.html#topic+Corpus">Corpus</a></code> storing <code><a href="#topic+ManifestoDocument">ManifestoDocument</a>s</code>
</p>
<p>For usage and structure of the stored documents see
<code><a href="#topic+ManifestoDocument">ManifestoDocument</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: corpus &lt;- mp_corpus(subset(mp_maindataset(), countryname == "Russia"))
</code></pre>

<hr>
<h2 id='ManifestoDocument'>Manifesto Document</h2><span id='topic+ManifestoDocument'></span>

<h3>Description</h3>

<p>A ManifestoDocument represents a document from the Manifesto Corpus and contains
text, coding and meta information.
ManifestoDocument objects need not be constructed manually but are the content
of the <code><a href="#topic+ManifestoCorpus">ManifestoCorpus</a></code> objects downloaded from the Manifesto
Corpus Database API via <code><a href="#topic+mp_corpus">mp_corpus</a></code>. 
</p>
<p><code>ManifestoDocument</code>s subclass the <code><a href="tm.html#topic+TextDocument">TextDocument</a></code> class
from the package <code>tm</code>. Hence they can be and usually are collected in a <code>tm</code>
<code><a href="tm.html#topic+Corpus">Corpus</a></code> to interface easily with text mining and other linguistic
analysis functions. <code>manifestoR</code> uses the subclass
<code><a href="#topic+ManifestoCorpus">ManifestoCorpus</a></code> of <code>tm</code>s <code><a href="tm.html#topic+Corpus">Corpus</a></code>, but
<code>ManifestoDocument</code>s can be stored in any kind of <code>Corpus</code>.
</p>
<p>As in <code>tm</code> any ManifestoDocument has metadata which can be accessed and
modified via the <code>meta</code> function, as well as content, accessible via
<code>content</code>. Additionally, via <code><a href="#topic+codes">codes</a>()</code>, the coding of the
(quasi-)sentence ccording to the CMP category scheme can be accessed 
(and modified). The CMP category scheme can be found online at
<a href="https://manifesto-project.wzb.eu/coding_schemes/mp_v4">https://manifesto-project.wzb.eu/coding_schemes/mp_v4</a> (version 4)
or <a href="https://manifesto-project.wzb.eu/coding_schemes/mp_v5">https://manifesto-project.wzb.eu/coding_schemes/mp_v5</a> (version 5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ManifestoDocument(
  content = data.frame(),
  id = character(0),
  meta = ManifestoDocumentMeta()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ManifestoDocument_+3A_content">content</code></td>
<td>
<p>data.frame of text and codes for the ManifestoDocument to be constructed.
There can be multiple columns of codes, but by default the accessor method <code><a href="#topic+codes">codes</a></code>
searches for the column named &quot;cmp_code&quot;.</p>
</td></tr>
<tr><td><code id="ManifestoDocument_+3A_id">id</code></td>
<td>
<p>an id to identify the Document</p>
</td></tr>
<tr><td><code id="ManifestoDocument_+3A_meta">meta</code></td>
<td>
<p>an object of class <code><a href="#topic+ManifestoDocumentMeta">ManifestoDocumentMeta</a></code> containing the metadata for this document</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, a ManifestoDocument is a <code>data.frame</code> with a row for
every quasi-sentence and the columns <code>text</code> and <code>code</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
corpus &lt;- mp_corpus(subset(mp_maindataset(), countryname == "New Zealand"))
doc &lt;- corpus[[1]]
print(doc)

## End(Not run)
</code></pre>

<hr>
<h2 id='ManifestoDocumentMeta'>Manifesto Document Metadata</h2><span id='topic+ManifestoDocumentMeta'></span>

<h3>Description</h3>

<p>Manifesto Document Metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ManifestoDocumentMeta(meta = list(), id = character(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ManifestoDocumentMeta_+3A_meta">meta</code></td>
<td>
<p>a named list with tag-value pairs of document meta information</p>
</td></tr>
<tr><td><code id="ManifestoDocumentMeta_+3A_id">id</code></td>
<td>
<p>a character giving a unique identifier for the text document</p>
</td></tr>
</table>

<hr>
<h2 id='ManifestoSource'>Data Source for Manifesto Corpus</h2><span id='topic+ManifestoSource'></span><span id='topic+ManifestoJSONSource'></span>

<h3>Description</h3>

<p>Data Source for Manifesto Corpus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ManifestoSource(texts)

ManifestoJSONSource(
  texts = list(manifesto_id = c(), items = c()),
  query_meta = data.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ManifestoSource_+3A_texts">texts</code></td>
<td>
<p>texts of the manifesto documents</p>
</td></tr>
<tr><td><code id="ManifestoSource_+3A_query_meta">query_meta</code></td>
<td>
<p>metadata to attach to document by joining on manifesto_id</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally for constructing <code><a href="#topic+ManifestoCorpus">ManifestoCorpus</a></code> objects.
</p>

<hr>
<h2 id='median_voter'>Median Voter position</h2><span id='topic+median_voter'></span><span id='topic+median_voter_single'></span>

<h3>Description</h3>

<p>The position of the median voter, calculated after Kim and Fording (1998; 2003),
with possible adjustment after McDonald 2002.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_voter(
  positions,
  voteshares = "pervote",
  scale = "rile",
  groups = c("country", "edate"),
  na.rm.voteshares = FALSE,
  na.rm.positions = FALSE,
  ...
)

median_voter_single(
  positions,
  voteshares,
  adjusted = FALSE,
  scalemin = -100,
  scalemax = 100,
  na.rm.voteshares = FALSE,
  na.rm.positions = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="median_voter_+3A_positions">positions</code></td>
<td>
<p>either a vector of values or (possible only for <code>median_voter</code>) a data.frame containing a column as
named in argument scale (default: rile) and one as named in argument voteshares (default: pervote);</p>
</td></tr>
<tr><td><code id="median_voter_+3A_voteshares">voteshares</code></td>
<td>
<p>either a vector of values or (possible only for <code>median_voter</code>) the name of a column in the data.frame
<code>positions</code> that contains the vote shares</p>
</td></tr>
<tr><td><code id="median_voter_+3A_scale">scale</code></td>
<td>
<p>variable of which to compute the median voter position (default: rile)</p>
</td></tr>
<tr><td><code id="median_voter_+3A_groups">groups</code></td>
<td>
<p>names of grouping variables to use for aggregation, default
results in one median voter position per election</p>
</td></tr>
<tr><td><code id="median_voter_+3A_na.rm.voteshares">na.rm.voteshares</code></td>
<td>
<p>remove observations where voteshares is NA (default: FALSE)</p>
</td></tr>
<tr><td><code id="median_voter_+3A_na.rm.positions">na.rm.positions</code></td>
<td>
<p>remove observations where positions is NA (default: FALSE)</p>
</td></tr>
<tr><td><code id="median_voter_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+median_voter_single">median_voter_single</a></code></p>
</td></tr>
<tr><td><code id="median_voter_+3A_adjusted">adjusted</code></td>
<td>
<p>flag for adjustment after McDonald 2002</p>
</td></tr>
<tr><td><code id="median_voter_+3A_scalemin">scalemin</code></td>
<td>
<p>The minimum of the scale of the positions, used for computing the voter position intervals</p>
</td></tr>
<tr><td><code id="median_voter_+3A_scalemax">scalemax</code></td>
<td>
<p>The maximum of the scale of the positions, used for computing the voter position intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>median_voter</code> is able to compute the median voter positions for multiple
elections at once, while <code>median_voter_single</code> treats data as coming from
a single election.
</p>
<p>calculated according to the formula
by Kim and Fording (1998; 2003)
</p>
<p style="text-align: center;"><code class="reqn">m = L + \frac{K-C}{F} W</code>
</p>

<p>Where m is the median voter position, L is lower end of the interval
containing the median, K is 0.5*sum(voteshare), C is the cumulative
vote share up to but not including the interval containing the median,
F is the vote share in the interval containing the median
and W is the width of the interval containing the median.
</p>
<p>Different parties with the same left-right position 
(e.g. alliances) are treated as one party with the cumulative vote share.
</p>
<p>In the adjusted formula the midpoint is &quot;mirrored&quot; from the midpoint of
the other side: &quot;Rather than assuming the party's voters are so widely
dispersed, this variable assumes they are spread in a symmetrical
interval around the party's position. For example, for a leftmost
party at -15 and a 0 midpoint between it and an adjacent party on the
right, we assume the left boundary of that party's voters is -30.&quot; (McDonald 2002)
</p>


<h3>References</h3>

<p>Kim, Heemin and Richard C. Fording (1998). &quot;Voter ideology in
western democracies, 1946-1989&quot;. In: European Journal of Political Research
33.1, 73-97. doi: 10.1111/1475-6765.00376.
</p>
<p>Kim, Heemin and Richard C. Fording (2003). &quot;Voter ideology in Western
democracies: An update&quot;. In: European Journal of Political Research 42.1,
95-105.
</p>
<p>McDonald, Michael D. (2002). Median Voters: 1950-1995.
url: www2.binghamton.edu/political-science/research/MedianVoter.doc
</p>

<hr>
<h2 id='mp_availability'>Availability information for election programmes</h2><span id='topic+mp_availability'></span>

<h3>Description</h3>

<p>Availability information for election programmes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_availability(ids, apikey = NULL, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_availability_+3A_ids">ids</code></td>
<td>
<p>Information on which documents to get. This can either be a
list of partys (as ids) and dates of elections as given to
<code><a href="#topic+mp_metadata">mp_metadata</a></code> or a <code>ManifestoMetadata</code> object
(<code>data.frame</code>) as returned by <code><a href="#topic+mp_metadata">mp_metadata</a></code>.
Alternatively, ids can be a logical expression specifying a subset of
the Manifesto Project's main dataset. It will be evaluated within the
data.frame returned by <code><a href="#topic+mp_maindataset">mp_maindataset</a></code> such that all its
variables and functions thereof can be used in the expression.</p>
</td></tr>
<tr><td><code id="mp_availability_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_availability_+3A_cache">cache</code></td>
<td>
<p>Boolean flag indicating whether to use locally cached data if
available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+ManifestoAvailability">ManifestoAvailability</a></code>
containing availability information. Can be treated as a
<code>data.frame</code> and contains detailed availability information
per document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mp_availability(countryname == "New Zealand")

wanted &lt;- data.frame(party=c(41320, 41320), date=c(200909, 200509))
mp_availability(wanted)

## End(Not run)
</code></pre>

<hr>
<h2 id='mp_bootstrap'>Compute bootstrap distributions for scaling functions</h2><span id='topic+mp_bootstrap'></span>

<h3>Description</h3>

<p>Bootstrapping of distributions of scaling functions as described by
Benoit, Mikhaylov, and Laver (2009). Given a dataset with percentages of CMP
categories, for each case the distribution of categories is resampled from
a multinomial distribution and the scaling function computed for the resampled
values. Arbitrary statistics of the resulting bootstrap distribution can be
returned, such as standard deviation, quantiles, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_bootstrap(
  data,
  fun = rile,
  col_filter = "^per(\\d{3}|\\d{4}|uncod)$",
  statistics = list(sd),
  N = 1000,
  ignore_na = TRUE,
  rescale = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_bootstrap_+3A_data">data</code></td>
<td>
<p>A data.frame with cases to be scaled and bootstrapped</p>
</td></tr>
<tr><td><code id="mp_bootstrap_+3A_fun">fun</code></td>
<td>
<p>function of a data row the bootstraped distribution of which is of interest</p>
</td></tr>
<tr><td><code id="mp_bootstrap_+3A_col_filter">col_filter</code></td>
<td>
<p>Regular expression matching the column names that should be
permuted for the resampling (usually and by default the handbook <code>v4_categories</code> 
(plus <code>cee_categories</code>) per variables)</p>
</td></tr>
<tr><td><code id="mp_bootstrap_+3A_statistics">statistics</code></td>
<td>
<p>A list (!) of statistics to be computed from the bootstrap
distribution; defaults to standard deviation (<code><a href="stats.html#topic+sd">sd</a></code>). Must be
functions or numbers, where numbers are interpreted as quantiles.</p>
</td></tr>
<tr><td><code id="mp_bootstrap_+3A_n">N</code></td>
<td>
<p>number of resamples to use for bootstrap distribution</p>
</td></tr>
<tr><td><code id="mp_bootstrap_+3A_ignore_na">ignore_na</code></td>
<td>
<p>if TRUE (default), for each observation drop silently the columns 
that have an NA value for the permutation</p>
</td></tr>
<tr><td><code id="mp_bootstrap_+3A_rescale">rescale</code></td>
<td>
<p>if TRUE (default), rescale the permuted values after the permutation 
to the sum of the values of the col_filter columns instead of 100</p>
</td></tr>
<tr><td><code id="mp_bootstrap_+3A_...">...</code></td>
<td>
<p>more arguments passed on to <code>fun</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Benoit, K., Laver, M., &amp; Mikhaylov, S. (2009). Treating Words as Data with Error: Uncertainty in Text Statements of Policy Positions. American Journal of Political Science, 53(2), 495-513. http://doi.org/10.1111/j.1540-5907.2009.00383.x
</p>

<hr>
<h2 id='mp_check_for_corpus_update'>Check for Updates of Corpus in Manifesto Project DB</h2><span id='topic+mp_check_for_corpus_update'></span><span id='topic+mp_which_corpus_version'></span><span id='topic+mp_which_dataset_versions'></span><span id='topic+mp_update_cache'></span>

<h3>Description</h3>

<p><code>mp_check_for_copus_update</code> checks if the currently cached version of corpus text and metadata
is older than the most recent version available via the Manifesto Project
DB API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_check_for_corpus_update(apikey = NULL, only_stable = TRUE)

mp_which_corpus_version(cache_env = mp_cache())

mp_which_dataset_versions(cache_env = mp_cache())

mp_update_cache(apikey = NULL, only_stable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_check_for_corpus_update_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_check_for_corpus_update_+3A_only_stable">only_stable</code></td>
<td>
<p>Consider only for versions marked as stable by the Manifesto
Projec Team, defaults to TRUE</p>
</td></tr>
<tr><td><code id="mp_check_for_corpus_update_+3A_cache_env">cache_env</code></td>
<td>
<p>Cache environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mp_update_cache</code> checks if a new corpus version is available and loads
the new version via: <code><a href="#topic+mp_use_corpus_version">mp_use_corpus_version</a></code>. That is, 
the internal cache of manifestoR will automatically be updated to newer version
and all future calls to the API will request for the newer version.
Note that updating/downgrading the corpus version after having already
downloaded translated manifestos is not yet implemented and will result in
an error message.
</p>
<p>Note that this versioning applies to the corpus' texts and metadata, and not the
versions of the core dataset. For this see <code><a href="#topic+mp_coreversions">mp_coreversions</a></code>
</p>


<h3>Value</h3>

<p><code>mp_update_cache</code> returns a list with a boolean
<code>update_available</code> and <code>versionid</code>,
a character string identifying the most recent online version available
</p>
<p><code>mp_which_corpus_version</code> returns the current version id of the
corpus and metadata stored in the cache
</p>
<p><code>mp_which_dataset_versions</code> returns the names of the main dataset
versions which are in the cache, i.e. have been downloaded
</p>
<p><code>mp_update_cache</code> returns the character identifier of the version updated to
</p>

<hr>
<h2 id='mp_cite'>Print Manifesto Corpus citation information</h2><span id='topic+mp_cite'></span>

<h3>Description</h3>

<p>Print Manifesto Corpus citation information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_cite(
  corpus_version = mp_which_corpus_version(),
  core_versions = mp_which_dataset_versions(),
  apikey = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_cite_+3A_corpus_version">corpus_version</code></td>
<td>
<p>corpus version for which citation should be printed</p>
</td></tr>
<tr><td><code id="mp_cite_+3A_core_versions">core_versions</code></td>
<td>
<p>core version for which citation should be printed</p>
</td></tr>
<tr><td><code id="mp_cite_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='mp_clarity'>Programmatic clarity measures (PC)</h2><span id='topic+mp_clarity'></span>

<h3>Description</h3>

<p>Computes party clarity measures suggested by 
Giebler/Lacewell/Regel/Werner 2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_clarity(
  data,
  weighting_kind = "manifesto",
  weighting_source = NULL,
  auto_rescale_weight = TRUE,
  auto_rescale_variables = TRUE,
  dimensions = clarity_dimensions()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_clarity_+3A_data">data</code></td>
<td>
<p>a dataframe in format of Manifesto Project Main Dataset</p>
</td></tr>
<tr><td><code id="mp_clarity_+3A_weighting_kind">weighting_kind</code></td>
<td>
<p>manifesto or election-specific weighting of the dimensions</p>
</td></tr>
<tr><td><code id="mp_clarity_+3A_weighting_source">weighting_source</code></td>
<td>
<p>name of variable with party importance (likely its importance within an election) weighting (can be rmps, pervote)</p>
</td></tr>
<tr><td><code id="mp_clarity_+3A_auto_rescale_weight">auto_rescale_weight</code></td>
<td>
<p>rescale party importance weighting within elections to 0-1</p>
</td></tr>
<tr><td><code id="mp_clarity_+3A_auto_rescale_variables">auto_rescale_variables</code></td>
<td>
<p>rescale dimension variables to 0-1</p>
</td></tr>
<tr><td><code id="mp_clarity_+3A_dimensions">dimensions</code></td>
<td>
<p>dimensions to be used, must be in the format of the return value of <code><a href="#topic+clarity_dimensions">clarity_dimensions</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of clarity values
</p>


<h3>References</h3>

<p>Giebler, Heiko, Onawa Promise Lacewell, Sven Regel and Annika Werner. 2015. 
Niedergang oder Wandel? Parteitypen und die Krise der repraesentativen Demokratie. 
In Steckt die Demokratie in der Krise?, ed. Wolfgang Merkel, 181-219. Wiesbaden: Springer VS.
</p>

<hr>
<h2 id='mp_codebook'>Access to the Codebook for the Manifesto Project Main Dataset</h2><span id='topic+mp_codebook'></span><span id='topic+mp_describe_code'></span><span id='topic+mp_view_codebook'></span>

<h3>Description</h3>

<p>These functions provide access to machine- and human-readable versions
of the Codebook (variable descriptions) of the Manifesto Project
Main Dataset, as can be found in PDF form under https://manifesto-project.wzb.eu/datasets .
As of this manifestoR release only the content-analytical variables (categories)
are accessible. Note also that the codebook contains only condensed descriptions
of the categories. For detailed information on coding instructions, you can refer
to the different handbook versions under https://manifesto-project.wzb.eu/information/documents/handbooks .
Only codebooks from version MPDS2017b on are accessible via the API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_codebook(version = "current", cache = TRUE, chapter = "categories")

mp_describe_code(
  code,
  version = "current",
  columns = c("title", "description_md"),
  print = TRUE
)

mp_view_codebook(version = "current", columns = c("type", "code", "title"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_codebook_+3A_version">version</code></td>
<td>
<p>version of the Manifesto Project Main Dataset for which the
codebook is requested. Note that only codebooks from version MPDS2017b on
are available via the API/manifestoR. Defaults to &quot;currrent&quot;, which fetches
the most recent codebook version. Must be formatted as e.g. &quot;MPDS2017b&quot;.</p>
</td></tr>
<tr><td><code id="mp_codebook_+3A_cache">cache</code></td>
<td>
<p>Whether result of API call should be cached locally (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="mp_codebook_+3A_chapter">chapter</code></td>
<td>
<p>Which part of the codebook should be returned. As of this manifestoR
release, only the content-analytical variables (parameter value &quot;categories&quot;) are accessible via the API.</p>
</td></tr>
<tr><td><code id="mp_codebook_+3A_code">code</code></td>
<td>
<p>specific code(s) (as character (vector)) to display information about.</p>
</td></tr>
<tr><td><code id="mp_codebook_+3A_columns">columns</code></td>
<td>
<p>Information to display about each variable. Given as a vector of
selected column names from: &quot;type&quot;, &quot;domain_code&quot;, &quot;domain_name&quot;, &quot;code&quot;, &quot;variable_name&quot;,
&quot;title&quot;, &quot;description_md&quot;, &quot;label&quot;</p>
</td></tr>
<tr><td><code id="mp_codebook_+3A_print">print</code></td>
<td>
<p>if TRUE (default), print the information, but as the function also returns invisible a tibble
containing the information, you can set print to FALSE for alternative uses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mp_codebook</code> returns the codebook as a <code>tibble</code>, ideal for further automatic processing.
</p>
<p><code>mp_describe_code</code> pretty prints with information about the requested code(s), ideal for quick interactive use,
but also returns invisible the code(s) information as a <code>tibble</code>
</p>
<p><code>mp_view_codebook</code> displays a searchable table version of the codebook
in the Viewer pane.
</p>

<hr>
<h2 id='mp_coreversions'>List the available versions of the Manifesto Project's Main Dataset</h2><span id='topic+mp_coreversions'></span>

<h3>Description</h3>

<p>List the available versions of the Manifesto Project's Main Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_coreversions(apikey = NULL, cache = TRUE, kind = "main")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_coreversions_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_coreversions_+3A_cache">cache</code></td>
<td>
<p>Boolean flag indicating whether to use locally cached data if
available.</p>
</td></tr>
<tr><td><code id="mp_coreversions_+3A_kind">kind</code></td>
<td>
<p>one of &quot;main&quot; (default) or &quot;south_america&quot; to discriminate the Main Dataset
and the South America Dataset. &quot;south_america&quot; is nowadays deprecated as the South
American Dataset has been integrated into the Main Dataset from version 2023a onwards.
Using &quot;south_america&quot; will still return past South American Dataset versions but also 
as the most recent version a reference to an empty dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the available versions of the corpus, see <code><a href="#topic+mp_corpusversions">mp_corpusversions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mp_coreversions()
</code></pre>

<hr>
<h2 id='mp_corpus'>Get documents from the Manifesto Corpus Database</h2><span id='topic+mp_corpus'></span><span id='topic+mp_corpus_df'></span><span id='topic+mp_corpus_df_bilingual'></span>

<h3>Description</h3>

<p>Documents are downloaded from the Manifesto Project Corpus Database. If 
CMP coding annotations are available, they are attached to the documents,
otherwise raw texts are provided. The documents are cached in the working
memory to ensure internal consistency, enable offline use and
reduce online traffic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_corpus(
  ids,
  apikey = NULL,
  cache = TRUE,
  codefilter = NULL,
  codefilter_layer = "cmp_code",
  translation = NULL,
  as_tibble = FALSE,
  tibble_metadata = "simplified"
)

mp_corpus_df(
  ids,
  apikey = NULL,
  cache = TRUE,
  codefilter = NULL,
  codefilter_layer = "cmp_code",
  translation = NULL,
  tibble_metadata = "simplified"
)

mp_corpus_df_bilingual(
  ids,
  apikey = NULL,
  cache = TRUE,
  codefilter = NULL,
  codefilter_layer = "cmp_code",
  translation = "en",
  tibble_metadata = "simplified"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_corpus_+3A_ids">ids</code></td>
<td>
<p>Information on which documents to get. This can either be a
list of partys (as ids) and dates of elections as given to
<code><a href="#topic+mp_metadata">mp_metadata</a></code> or a <code>ManifestoMetadata</code> object
(<code>data.frame</code>) as returned by <code><a href="#topic+mp_metadata">mp_metadata</a></code>.
Alternatively, ids can be a logical expression specifying a subset of
the Manifesto Project's main dataset. It will be evaluated within the
data.frame returned by <code><a href="#topic+mp_maindataset">mp_maindataset</a></code> such that all its
variables and functions thereof can be used in the expression.</p>
</td></tr>
<tr><td><code id="mp_corpus_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_corpus_+3A_cache">cache</code></td>
<td>
<p>Boolean flag indicating whether to use locally cached data if
available.</p>
</td></tr>
<tr><td><code id="mp_corpus_+3A_codefilter">codefilter</code></td>
<td>
<p>A vector of CMP codes to filter the documents: only quasi-sentences
with the codes specified in <code>codefilter</code> are returned. If <code>NULL</code>,
no filtering is applied</p>
</td></tr>
<tr><td><code id="mp_corpus_+3A_codefilter_layer">codefilter_layer</code></td>
<td>
<p>layer to which the codefilter should apply, defaults to cmp_code</p>
</td></tr>
<tr><td><code id="mp_corpus_+3A_translation">translation</code></td>
<td>
<p>A string containing the two digit ISO code of a translation language
that should be used for the text instead of the original document language.
Defaults to <code>NULL</code>, resulting in the original language of a document. For
documents that are already originally in the requested translation language, it
returns the original text. English would be &quot;en&quot;.</p>
</td></tr>
<tr><td><code id="mp_corpus_+3A_as_tibble">as_tibble</code></td>
<td>
<p>Boolean flag indicating whether to return a tibble/data.frame object
instead of a ManifestoCorpus object, for backward compatibility defaults to FALSE</p>
</td></tr>
<tr><td><code id="mp_corpus_+3A_tibble_metadata">tibble_metadata</code></td>
<td>
<p>A string specifing the handling of document-level metadata when
using 'as_tibble' = TRUE. It can be one of the following values:
&quot;none&quot; = no metadata,
&quot;simplified&quot; = basic metadata (&quot;manifesto_id&quot;, &quot;party&quot;, &quot;date&quot;, &quot;language&quot;, &quot;annotations&quot;, &quot;translation_en&quot;),
&quot;all&quot; = all metadata,
defaults to &quot;simplified&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'mp_corpus_df' is a shorthand for getting the documents of the Manifesto Corpus
as a tibble/data.frame object instead of a ManifestoCorpus object. It takes
the same parameters as 'mp_corpus'
(it is equivalent to <code>mp_corpus(..., as_tibble = TRUE)</code>).
See <code><a href="#topic+mp_save_cache">mp_save_cache</a></code> for ensuring reproducibility by
saving cache and version identifier to the hard drive.
See <code><a href="#topic+mp_update_cache">mp_update_cache</a></code> for updating the locally saved content with
the most recent version from the Manifesto Project Database API.
</p>
<p>'mp_corpus_df_bilingual' is a shorthand for getting the original text and the english
translations (or in case further translation languages become available also other
translation languages than english) from the Manifesto Corpus as a tibble/data.frame
object. The original text ends up in the &quot;text&quot; column and the english translation in
&quot;text_en&quot; (or more abstract in case of further translation languages in a column
named &quot;text_&lt;two digit ISO language code&gt;&quot;). It accepts the same additional parameters
as 'mp_corpus_df'.
</p>


<h3>Value</h3>

<p>an object of <code><a href="tm.html#topic+Corpus">Corpus</a></code>'s subclass
<code><a href="#topic+ManifestoCorpus">ManifestoCorpus</a></code> holding the available of the requested documents
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
corpus &lt;- mp_corpus(party == 61620 &amp; rile &gt; 10)

wanted &lt;- data.frame(party=c(41320, 41320), date=c(200909, 201309))
mp_corpus(wanted)

mp_corpus(subset(mp_maindataset(), countryname == "France"))

partially_available &lt;- data.frame(party=c(41320, 41320), date=c(200909, 200509))
mp_corpus(partially_available)

corpus_df &lt;- mp_corpus(party == 61620 &amp; rile &gt; 10, as_tibble = TRUE)
corpus_df &lt;- mp_corpus_df(party == 61620 &amp; rile &gt; 10)
corpus_df &lt;- mp_corpus_df(party == 61620 &amp; rile &gt; 10, tibble_metadata = "all")

mp_corpus(wanted, translation = "en")
mp_corpus_df(wanted, translation = "en")

mp_corpus_df_bilingual(wanted, translation = "en")

## End(Not run)
</code></pre>

<hr>
<h2 id='mp_corpusversions'>List the available versions of the Manifesto Project's Corpus</h2><span id='topic+mp_corpusversions'></span>

<h3>Description</h3>

<p>The Manifesto Project Database API assigns a new version code whenever changes
to the corpus texts or metadata are made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_corpusversions(apikey = NULL, only_stable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_corpusversions_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_corpusversions_+3A_only_stable">only_stable</code></td>
<td>
<p>Consider only for versions marked as stable by the Manifesto
Project Team, defaults to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function always bypasses the cache.
</p>


<h3>Value</h3>

<p>a data.table with the available version ids (name, tag)
</p>

<hr>
<h2 id='mp_dedication'>Print manifestoR package dedication</h2><span id='topic+mp_dedication'></span>

<h3>Description</h3>

<p>Print manifestoR package dedication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_dedication()
</code></pre>


<h3>Value</h3>

<p><code>mp_dedication</code> returns the package dedication
</p>

<hr>
<h2 id='mp_emptycache'>Empty the manifestoR's cache</h2><span id='topic+mp_emptycache'></span>

<h3>Description</h3>

<p>Empty the manifestoR's cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_emptycache()
</code></pre>

<hr>
<h2 id='mp_interpolate'>Interpolate values within election periods</h2><span id='topic+mp_interpolate'></span>

<h3>Description</h3>

<p>As the Manifesto Project's variables are collected election-wise, values
for the time/years in between elections are not naturally available.
<code>mp_interpolate</code> allows to approximate them by several methods from
the abjacent observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_interpolate(
  df,
  vars = "(^rile$)|(^per((\\d{3}(_\\d)?)|\\d{4})$)",
  by = "year",
  approx = zoo::na.approx,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_interpolate_+3A_df">df</code></td>
<td>
<p>a data.frame with observations to be interpolated</p>
</td></tr>
<tr><td><code id="mp_interpolate_+3A_vars">vars</code></td>
<td>
<p>a regular expression matching the names of the variables to be interpolated</p>
</td></tr>
<tr><td><code id="mp_interpolate_+3A_by">by</code></td>
<td>
<p>increment of the interpolation sequence, passed to <code><a href="base.html#topic+seq.Date">seq.Date</a></code></p>
</td></tr>
<tr><td><code id="mp_interpolate_+3A_approx">approx</code></td>
<td>
<p>Interpolation function, defaults to zoo's <code>na.approx</code></p>
</td></tr>
<tr><td><code id="mp_interpolate_+3A_...">...</code></td>
<td>
<p>Further arguments, passed on to approx</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mp_interpolate(mp_maindataset(), method = "constant")
mp_interpolate(mp_maindataset(), approx = na.spline, maxgap = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='mp_load_cache'>Load manifestoR's cache</h2><span id='topic+mp_load_cache'></span>

<h3>Description</h3>

<p>Load a cache from a variable or file to manifestoR's current working
environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_load_cache(cache = NULL, file = "mp_cache.RData")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_load_cache_+3A_cache">cache</code></td>
<td>
<p>an environment that should function as manifestoR's new cache.
If this is NULL, the environment is loaded from the file specified by argument file.</p>
</td></tr>
<tr><td><code id="mp_load_cache_+3A_file">file</code></td>
<td>
<p>a file name from where the cache environment should be loaded</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mp_load_cache() ## loads cache from file "mp_cache.RData"
</code></pre>

<hr>
<h2 id='mp_maindataset'>Access the Manifesto Project's Main Dataset</h2><span id='topic+mp_maindataset'></span><span id='topic+mp_southamerica_dataset'></span>

<h3>Description</h3>

<p>Gets the Manifesto Project's Main Dataset from the project's web API or
the local cache, if it was already downloaded before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_maindataset(
  version = "current",
  south_america = FALSE,
  download_format = NULL,
  apikey = NULL,
  cache = TRUE
)

mp_southamerica_dataset(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_maindataset_+3A_version">version</code></td>
<td>
<p>Specify the version of the dataset you want to access. Use
&quot;current&quot; to obtain the most recent, or use
<code><a href="#topic+mp_coreversions">mp_coreversions</a></code> for a list of available
versions.</p>
</td></tr>
<tr><td><code id="mp_maindataset_+3A_south_america">south_america</code></td>
<td>
<p>flag whether to download corresponding South America dataset
instead of Main Dataset. This parameter deprecated as the previously separated South
America Dataset has been integrated into the Main Dataset from version 2023a onwards.
To allow for backward compatibilty old South American Datasets can still be accessed
but querying for the most recent South American Dataset will result in an empty dataset.</p>
</td></tr>
<tr><td><code id="mp_maindataset_+3A_download_format">download_format</code></td>
<td>
<p>Download format. If not NULL, instead of the dataset
being returned as an R data.frame, a file path to a temporary file in the specified
binary format is returned. Can be one of <code>c("dta", "xlsx", "sav")</code>. With
the &quot;dta&quot; option, labeled columns can be obtained.</p>
</td></tr>
<tr><td><code id="mp_maindataset_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_maindataset_+3A_cache">cache</code></td>
<td>
<p>Boolean flag indicating whether to use locally cached data if
available.</p>
</td></tr>
<tr><td><code id="mp_maindataset_+3A_...">...</code></td>
<td>
<p>all arguments of <code>mp_southamerica_data</code> are passed on to <code>mp_maindataset</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mp_southamerica_dataset</code> is a shorthand for getting the Manifesto
Project's South America Dataset (it is equivalent to 
<code>mp_maindataset(..., south_america = TRUE)</code>). It is nowadays deprecated, for 
details see explanation in 'south_america' parameter documentation.
</p>


<h3>Value</h3>

<p>The Manifesto Project Main Dataset with classes <code>data.frame</code> and
<code><a href="dplyr.html#topic+tbl_df">tbl_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mpds &lt;- mp_maindataset()
head(mpds)
median(subset(mpds, countryname == "Switzerland")$rile, na.rm = TRUE)

## End(Not run)
## Not run: 
mp_maindataset(download_format = "dta") %&gt;% read_dta() ## requires package haven

## End(Not run)
</code></pre>

<hr>
<h2 id='mp_metadata'>Get meta data for election programmes</h2><span id='topic+mp_metadata'></span>

<h3>Description</h3>

<p>Get meta data for election programmes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_metadata(ids, apikey = NULL, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_metadata_+3A_ids">ids</code></td>
<td>
<p>list of partys (as ids) and dates of elections, paired. Dates must
be given either in the <code>date</code> or the <code>edate</code> variable,
formatted in the way they are in the main data set in this package
(date: as.numeric, YYYYMM, edate: as.Date()), see <code><a href="#topic+mp_maindataset">mp_maindataset</a></code>
Alternatively, ids can be a logical expression specifying a subset of
the Manifesto Project's main dataset. It will be evaluated within the
data.frame returned by <code><a href="#topic+mp_maindataset">mp_maindataset</a></code> such that all its
variables and functions thereof can be used in the expression.</p>
</td></tr>
<tr><td><code id="mp_metadata_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_metadata_+3A_cache">cache</code></td>
<td>
<p>Boolean flag indicating whether to use locally cached data if
available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meta data contain information on the available documents for a given party
and election date. This information comprises links to the text as well as
original documents if available, language, versions checksums and more.
</p>


<h3>Value</h3>

<p>an object of class <code>ManifestoMetadata</code>, subclassing <code>data.frame</code>
as well as <code><a href="dplyr.html#topic+tbl_df">tbl_df</a></code> and containing the requested
metadata in rows per election programme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mp_metadata(party == 21221)

wanted &lt;- data.frame(party=c(41320, 41320), date=c(200909, 200509))
mp_metadata(wanted)

## End(Not run)
</code></pre>

<hr>
<h2 id='mp_nicheness'>Party nicheness measures</h2><span id='topic+mp_nicheness'></span><span id='topic+nicheness_meyer_miller'></span><span id='topic+nicheness_bischof'></span>

<h3>Description</h3>

<p>Computes party nicheness measures suggested by Bischof 2015 and Meyer and Miller 2013.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_nicheness(data, method = "bischof", ...)

nicheness_meyer_miller(
  data,
  groups = meyer_miller_2013_policy_dimensions(),
  transform = NULL,
  smooth = FALSE,
  weights = "pervote",
  party_system_normalization = TRUE,
  only_non_zero = TRUE
)

nicheness_bischof(
  data,
  out_variables = c("party", "date", "specialization", "nicheness", "nicheness_two"),
  groups = bischof_issue_groups(),
  diversification_bounds = c(0, rep(1/length(groups), length(groups)) %&gt;% {
     -(. *
    log(.))
 } %&gt;% sum()),
  smooth = function(x) {
     (x + lag(x, default = first(first(x))))/2
 }
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_nicheness_+3A_data">data</code></td>
<td>
<p>a dataframe or matrix in format of Manifesto Project Main Dataset</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_method">method</code></td>
<td>
<p>choose between bischof and meyermiller</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_...">...</code></td>
<td>
<p>parmaeters passed on to specialized functions for differnet methods</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_groups">groups</code></td>
<td>
<p>groups of issues to determine niches/policy dimensions; formatted as named lists
variable names. For Meyer &amp; Miller: Defaults to adapted version of Baeck et. al 2010 Policy dimensions
(without industry, as used in the original paper by Meyer &amp; Miller). For Bischof: defaults
to issue groups used in the Bischof 2015 paper</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_transform">transform</code></td>
<td>
<p>transform to apply to each of the group indicators. Can be a function,
character &quot;bischof&quot; to apply log(x + 1), or NULL for no transformation.</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_smooth">smooth</code></td>
<td>
<p>Smoothing of policy dimension values before nicheness computation, as suggested
and used by Bischof 2015</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_weights">weights</code></td>
<td>
<p>vector of the length nrow(data) or the name of a variable in data; is used to
weight mean party system position and nicheness; defaults to &quot;pervote&quot; as in Meyer &amp; Miller 2013</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_party_system_normalization">party_system_normalization</code></td>
<td>
<p>normalize nicheness result within election (substract weighted mean nicheness)</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_only_non_zero">only_non_zero</code></td>
<td>
<p>When dividing by the number of policy dimensions used for nicheness
estimation, ignore dimensions that are zero for all parties (election-wise)</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_out_variables">out_variables</code></td>
<td>
<p>names of variables to return in data.frame. Can be any
from the input or that are generated during the computation of Bischof's nicheness
measure. See details for a list.</p>
</td></tr>
<tr><td><code id="mp_nicheness_+3A_diversification_bounds">diversification_bounds</code></td>
<td>
<p>Bounds of the range of the diversification measure
(Shannon's entropy $s_p$ in Bischof 2015), used for inversion and normalization;
default to the theoretical bounds of the entropy of a distribution on 5 discrete
elements. If &quot;empirical&quot;, the empirical max and min of the diversification measure
are used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of possible outputs of <code>nicheness_bischof</code>:
</p>
<p>diversification: Shannon's entropy $s_p$ in Bischof 2015
</p>
<p>max_divers: used maximum for diversification
</p>
<p>min_divers: used minimum for diversification
</p>
<p>specialization: inverted diversification
</p>
<p>specialization_stand: standardized specialization
</p>
<p>nicheness: nicheness according to Meyer &amp; Miller 2013 without vote share weighting
</p>
<p>nicheness_stand: standardized nicheness
</p>
<p>nicheness_two: sum of nicheness_stand and specialization_stand as proposed by Bischof 2015
</p>


<h3>References</h3>

<p>Bischof, D. (2015). Towards a Renewal of the Niche Party Concept Parties, Market Shares and Condensed Offers. Party Politics.
</p>
<p>Meyer, T.M., &amp; Miller, B. (2013). The Niche Party Concept and Its Measurement. Party Politics 21(2): 259-271.
</p>
<p>Baeck, H., Debus, M., &amp; Dumont, P. (2010). Who gets what in coalition governments? Predictors of portfolio
allocation in parliamentary democracies. European Journal of Political Research 50(4): 441-478.
</p>

<hr>
<h2 id='mp_parties'>Access to the Parties Lists for the Manifesto Project Data</h2><span id='topic+mp_parties'></span>

<h3>Description</h3>

<p>These functions provide access to machine-readable versions
of the List of Parties of the Manifesto Project Data as can be found in CSV form 
under https://manifesto-project.wzb.eu/datasets .
Note: the list of parties is not available for all of the past datasets. You can check the 
availability by going to the datasets page and check for specific datasets whether they have 
party lists in the following formats &quot;List – Short (CSV)&quot; or &quot;List – Long (CSV)&quot; available. 
There you can also find the codebooks with details for these list of parties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_parties(
  version = "current",
  apikey = NULL,
  cache = TRUE,
  list_form = "short"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_parties_+3A_version">version</code></td>
<td>
<p>version of the Manifesto Project Main Dataset for which the
list of parties is requested. Note: the list of parties is not available for all of the past datasets. 
Defaults to &quot;current&quot;, which fetches the most recent version. Must be formatted as e.g. &quot;MPDS2023a&quot;.</p>
</td></tr>
<tr><td><code id="mp_parties_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_parties_+3A_cache">cache</code></td>
<td>
<p>Whether result of API call should be cached locally (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="mp_parties_+3A_list_form">list_form</code></td>
<td>
<p>Whether the result should be the short or the long version (defaults to &quot;short&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mp_parties</code> returns the list of parties as a <code>tibble</code>, ideal for further automatic processing.
</p>

<hr>
<h2 id='mp_rmps'>Relative measure of party size (RMPS)</h2><span id='topic+mp_rmps'></span>

<h3>Description</h3>

<p>Computes the relative measure of party size as suggested by 
Giebler/Lacewell/Regel/Werner 2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_rmps(data, adapt_zeros = TRUE, ignore_na = TRUE, threshold_sum = 75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_rmps_+3A_data">data</code></td>
<td>
<p>a numerical vector with vote shares</p>
</td></tr>
<tr><td><code id="mp_rmps_+3A_adapt_zeros">adapt_zeros</code></td>
<td>
<p>a boolean to switch on the conversion of zero values to 0.01 
to avoid issues concerning division by zero</p>
</td></tr>
<tr><td><code id="mp_rmps_+3A_ignore_na">ignore_na</code></td>
<td>
<p>a boolean to switch on ignoring NA entries, otherwise having NA entries
will lead to only NA values in the result</p>
</td></tr>
<tr><td><code id="mp_rmps_+3A_threshold_sum">threshold_sum</code></td>
<td>
<p>the threshold of the sum of all vote shares for allowing the calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hint: In a dataset with multiple elections the usage of the function
might require to calculate the measure per election (eg. using group_by)
</p>


<h3>Value</h3>

<p>a vector of rmps values
</p>


<h3>References</h3>

<p>Giebler, Heiko, Onawa Promise Lacewell, Sven Regel and Annika Werner. 2015. 
Niedergang oder Wandel? Parteitypen und die Krise der repraesentativen Demokratie. 
In Steckt die Demokratie in der Krise?, ed. Wolfgang Merkel, 181-219. Wiesbaden: Springer VS.
</p>

<hr>
<h2 id='mp_save_cache'>Save manifestoR's cache</h2><span id='topic+mp_save_cache'></span>

<h3>Description</h3>

<p>Saves manifestoR's cache to the file system. This function can and should be
used to store downloaded snapshots of the Manifesto Project Corpus Database
to your local hard drive. They can then be loaded via <code><a href="#topic+mp_load_cache">mp_load_cache</a></code>.
Caching data in the file system ensures reproducibility of the scripts and
analyses, enables offline use of the data and reduces unnecessary traffic
and waiting times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_save_cache(file = "mp_cache.RData")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_save_cache_+3A_file">file</code></td>
<td>
<p>a file from which to load the cache environment</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mp_save_cache() ## save to "mp_cache.RData" in current working directory
</code></pre>

<hr>
<h2 id='mp_scale'>Scaling annotated manifesto documents</h2><span id='topic+mp_scale'></span><span id='topic+document_scaling'></span><span id='topic+corpus_scaling'></span>

<h3>Description</h3>

<p>Since scaling functions such as <code><a href="#topic+scale_weighted">scale_weighted</a></code> only apply to
data.frames with code percentages, the function <code>mp_scale</code> makes them
applies them to a <code>ManifestoCorpus</code> or <code>ManifestoDocument</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_scale(
  data,
  scalingfun = rile,
  scalingname = as.character(substitute(scalingfun)),
  recode_v5_to_v4 = (scalingname %in% c("rile", "logit_rile")),
  ...
)

document_scaling(
  scalingfun,
  returndf = FALSE,
  scalingname = "scaling",
  recode_v5_to_v4 = FALSE,
  ...
)

corpus_scaling(
  scalingfun,
  scalingname = "scaling",
  recode_v5_to_v4 = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_scale_+3A_data">data</code></td>
<td>
<p><code>ManifestoDocument</code> or <code>ManifestoCorpus</code> with coding
annotations or a data.frame with category percentages</p>
</td></tr>
<tr><td><code id="mp_scale_+3A_scalingfun">scalingfun</code></td>
<td>
<p>a scaling function, i.e. a function that takes a data.frame with
category percentages and returns scaled positions, e.g. <code><a href="#topic+scale_weighted">scale_weighted</a></code>.</p>
</td></tr>
<tr><td><code id="mp_scale_+3A_scalingname">scalingname</code></td>
<td>
<p>the name of the scale which will be used as a column name when a data.frame is produced</p>
</td></tr>
<tr><td><code id="mp_scale_+3A_recode_v5_to_v4">recode_v5_to_v4</code></td>
<td>
<p>recode handbook version 5 scheme to version 4 before scaling; this
parameter is only relevant if data is a ManifestoDocument or ManifestoCorpus, but not for 
data.frames with code percentages</p>
</td></tr>
<tr><td><code id="mp_scale_+3A_...">...</code></td>
<td>
<p>further arguments passed on to the scaling function <code>scalingfun</code>,
or <code><a href="#topic+count_codes">count_codes</a></code></p>
</td></tr>
<tr><td><code id="mp_scale_+3A_returndf">returndf</code></td>
<td>
<p>if this flag is TRUE, a data.frame with category percentage values,
scaling result and, if available party and date is returned by the returned function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>

<hr>
<h2 id='mp_setapikey'>Set the API key for the Manifesto Documents Database.</h2><span id='topic+mp_setapikey'></span>

<h3>Description</h3>

<p>If you do not have an API key for the Manifesto Documents Database,
you can create one via your profile page on 
<a href="https://manifesto-project.wzb.eu">https://manifesto-project.wzb.eu</a>.
If you do not have an account, you can register on the webpage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_setapikey(key.file = NULL, key = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_setapikey_+3A_key.file">key.file</code></td>
<td>
<p>file name containing the API key</p>
</td></tr>
<tr><td><code id="mp_setapikey_+3A_key">key</code></td>
<td>
<p>new API key</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key is read from the file specified in <code>key.file</code>. If this
argument is <code>NULL</code>, the key given in the argument <code>key</code> is used.
</p>

<hr>
<h2 id='mp_use_corpus_version'>Use a specific version of the Manifesto Project Corpus</h2><span id='topic+mp_use_corpus_version'></span>

<h3>Description</h3>

<p>The internal cache of manifestoR will be updated to the specified version
and all future calls to the API will request for the specified version. Note
that this versioning applies to the corpus' texts and metadata, and not the
versions of the core dataset. For this see <code><a href="#topic+mp_coreversions">mp_coreversions</a></code>.
Also note that updating/downgrading the corpus version after having already
downloaded translated manifestos is not yet implemented and will result in
an error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_use_corpus_version(versionid, apikey = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_use_corpus_version_+3A_versionid">versionid</code></td>
<td>
<p>character id of the version to use (as received from API and
<code><a href="#topic+mp_corpusversions">mp_corpusversions</a></code>)</p>
</td></tr>
<tr><td><code id="mp_use_corpus_version_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='mp_view_originals'>View original documents from the Manifesto Corpus Database</h2><span id='topic+mp_view_originals'></span>

<h3>Description</h3>

<p>Original documents are opened in the system's browser window. All original
documents are stored on the Manifesto Project Website and the URLs opened
are all from this site.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_view_originals(ids, maxn = 5, apikey = NULL, cache = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mp_view_originals_+3A_ids">ids</code></td>
<td>
<p>Information on which originals to view This can either be a
list of partys (as ids) and dates of elections as given to
<code><a href="#topic+mp_metadata">mp_metadata</a></code> or a <code>ManifestoMetadata</code> object
(<code>data.frame</code>) as returned by <code><a href="#topic+mp_metadata">mp_metadata</a></code>.
Alternatively, ids can be a logical expression specifying a subset of
the Manifesto Project's main dataset. It will be evaluated within the
data.frame returned by <code><a href="#topic+mp_maindataset">mp_maindataset</a></code> such that all its
variables and functions thereof can be used in the expression.</p>
</td></tr>
<tr><td><code id="mp_view_originals_+3A_maxn">maxn</code></td>
<td>
<p>maximum number of documents to open simultaneously in browser,
defaults to 5.</p>
</td></tr>
<tr><td><code id="mp_view_originals_+3A_apikey">apikey</code></td>
<td>
<p>API key to use. Defaults to <code>NULL</code>, resulting in using
the API key set via <code><a href="#topic+mp_setapikey">mp_setapikey</a></code>.</p>
</td></tr>
<tr><td><code id="mp_view_originals_+3A_cache">cache</code></td>
<td>
<p>Boolean flag indicating whether to use locally cached data if
available. The original documents themselves are not cached locally,
but the metadata required to find them is.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mp_view_originals(party == 41320 &amp; date == 200909)

## End(Not run)
</code></pre>

<hr>
<h2 id='mpdb_api_request'>Manifesto Project DB API request</h2><span id='topic+mpdb_api_request'></span>

<h3>Description</h3>

<p>gets the requested url and passes HTTP header error codes on to raise R
errors with the same text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpdb_api_request(file, body)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpdb_api_request_+3A_file">file</code></td>
<td>
<p>file to request below apiroot url</p>
</td></tr>
<tr><td><code id="mpdb_api_request_+3A_body">body</code></td>
<td>
<p>body text of the posted request: should contain the parameters
as specified by the Manifesto Project Database API</p>
</td></tr>
</table>

<hr>
<h2 id='na_replace'>Replace NAs in vector with fixed value</h2><span id='topic+na_replace'></span>

<h3>Description</h3>

<p>Replace NAs in vector with fixed value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_replace(vec, value = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na_replace_+3A_vec">vec</code></td>
<td>
<p>vector to replace NAs in</p>
</td></tr>
<tr><td><code id="na_replace_+3A_value">value</code></td>
<td>
<p>value to inject for NA</p>
</td></tr>
</table>

<hr>
<h2 id='null_to_na'>Convert NULL to NA</h2><span id='topic+null_to_na'></span>

<h3>Description</h3>

<p>Convert NULL to NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_to_na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="null_to_na_+3A_x">x</code></td>
<td>
<p>element</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA if the element is NULL, the element otherwise
</p>

<hr>
<h2 id='prefix'>Prefix a string of text</h2><span id='topic+prefix'></span>

<h3>Description</h3>

<p>Convenience function to use with magrittr
wraps <code><a href="base.html#topic+paste0">paste0</a></code>, hence vectorised as <code><a href="base.html#topic+paste0">paste0</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prefix(text, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prefix_+3A_text">text</code></td>
<td>
<p>goes to the end, rest</p>
</td></tr>
<tr><td><code id="prefix_+3A_...">...</code></td>
<td>
<p>goes to the front.</p>
</td></tr>
</table>

<hr>
<h2 id='readManifesto'>Reader for <code><a href="#topic+ManifestoSource">ManifestoSource</a></code></h2><span id='topic+readManifesto'></span>

<h3>Description</h3>

<p>Reader for <code><a href="#topic+ManifestoSource">ManifestoSource</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readManifesto(elem, language, id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readManifesto_+3A_elem">elem</code></td>
<td>
<p>a named list with the component <code>content</code></p>
</td></tr>
<tr><td><code id="readManifesto_+3A_language">language</code></td>
<td>
<p>is ignored</p>
</td></tr>
<tr><td><code id="readManifesto_+3A_id">id</code></td>
<td>
<p>a character giving a unique identifier for the created text document</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally for constructing <code><a href="#topic+ManifestoCorpus">ManifestoCorpus</a></code> objects.
For the general mechanism refer to <code>tm</code>s <code><a href="tm.html#topic+Reader">Reader</a></code>
documentation.
</p>

<hr>
<h2 id='recode_cee_codes'>Process CMP codings</h2><span id='topic+recode_cee_codes'></span><span id='topic+aggregate_cee_codes'></span><span id='topic+recode_v5_to_v4'></span>

<h3>Description</h3>

<p>Several functions to process the CMP codings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_cee_codes(x)

aggregate_cee_codes(x)

recode_v5_to_v4(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recode_cee_codes_+3A_x">x</code></td>
<td>
<p>Vector of codes, ManifestoDocument or ManifestoCorpus</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>recode_cee_codes</code> recode the sub-categories used
in coding several manifestos in Central and Eastern Europe (4 digits) to
the main categories in the coding scheme (3 digits).
</p>
<p><code>recode_v5_to_v4</code> recode the CMP codings according to
the more specialized Coding Handbook Version 5 to the more general
categories of Handbook Version 4. Codes 202.2, 605.2 and 703.2 are
converted to a 000, while all other subcategory codes with an appended
dot and fourth digit are aggregated to the corresponding three-digit 
main category.
</p>

<hr>
<h2 id='rep.data.frame'>Replicates cases in a data.frame</h2><span id='topic+rep.data.frame'></span>

<h3>Description</h3>

<p>Replicates cases in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
rep(x, times = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rep.data.frame_+3A_x">x</code></td>
<td>
<p>data.frame to replicate</p>
</td></tr>
<tr><td><code id="rep.data.frame_+3A_times">times</code></td>
<td>
<p>number of replications</p>
</td></tr>
<tr><td><code id="rep.data.frame_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with cases replicated
</p>

<hr>
<h2 id='rescale'>Simple linear rescaling of positions</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>Simple linear rescaling of positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(pos, newmin = -1, newmax = 1, oldmin = min(pos), oldmax = max(pos))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_+3A_pos">pos</code></td>
<td>
<p>position data to be rescaled</p>
</td></tr>
<tr><td><code id="rescale_+3A_newmin">newmin</code></td>
<td>
<p>indicates the minimum of the new scale (default is -1)</p>
</td></tr>
<tr><td><code id="rescale_+3A_newmax">newmax</code></td>
<td>
<p>indicates the maximum of the new scale (default is +1)</p>
</td></tr>
<tr><td><code id="rescale_+3A_oldmin">oldmin</code></td>
<td>
<p>indicates the minimum of the existing scale. Can be used to rescale from a known theoretical scale (e.g. -100). If left empty the empirical minimum is used.</p>
</td></tr>
<tr><td><code id="rescale_+3A_oldmax">oldmax</code></td>
<td>
<p>indicates the maximum of the existing. See above.</p>
</td></tr>
</table>

<hr>
<h2 id='rile'>RILE</h2><span id='topic+rile'></span><span id='topic+logit_rile'></span>

<h3>Description</h3>

<p>Computes the RILE or other bipolar linear scaling measures for each case in a
data.frame or ManifestoCorpus or for a ManifestoDocument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rile(x)

logit_rile(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rile_+3A_x">x</code></td>
<td>
<p>A data.frame with cases to be scaled, variables named &quot;per...&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='scale_weighted'>Scaling functions</h2><span id='topic+scale_weighted'></span><span id='topic+scale_logit'></span><span id='topic+scale_bipolar'></span><span id='topic+scale_ratio_1'></span><span id='topic+scale_ratio_2'></span>

<h3>Description</h3>

<p>Scaling functions take a data.frame of variables with information about
political parties/text and position the cases on a scale, i.e. output a
vector of values. For applying scaling functions directly to text documents,
refer to <code><a href="#topic+mp_scale">mp_scale</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_weighted(
  data,
  vars = grep("per((\\d{3}(_\\d)?)|\\d{4}|(uncod))$", names(data), value = TRUE),
  weights = 1
)

scale_logit(data, pos, neg, N = data[, "total"], zero_offset = 0.5, ...)

scale_bipolar(data, pos, neg, ...)

scale_ratio_1(data, pos, neg, ...)

scale_ratio_2(data, pos, neg, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_weighted_+3A_data">data</code></td>
<td>
<p>A data.frame with cases to be scaled</p>
</td></tr>
<tr><td><code id="scale_weighted_+3A_vars">vars</code></td>
<td>
<p>variable names that should contribute to the linear combination;
defaults to all CMP category percentage variables in the Manifesto Project's Main Dataset</p>
</td></tr>
<tr><td><code id="scale_weighted_+3A_weights">weights</code></td>
<td>
<p>weights of the linear combination in the same order as 'vars'.</p>
</td></tr>
<tr><td><code id="scale_weighted_+3A_pos">pos</code></td>
<td>
<p>variable names that should contribute to the numerator (&quot;positively&quot;)</p>
</td></tr>
<tr><td><code id="scale_weighted_+3A_neg">neg</code></td>
<td>
<p>variable names that should contribute to the denominator (&quot;negatively&quot;)</p>
</td></tr>
<tr><td><code id="scale_weighted_+3A_n">N</code></td>
<td>
<p>vector of numbers of quasi sentences to convert percentages to counts</p>
</td></tr>
<tr><td><code id="scale_weighted_+3A_zero_offset">zero_offset</code></td>
<td>
<p>Constant to be added to prevent 0/0 and log(0); defaults to 0.5 (smaller than any possible non-zero count)</p>
</td></tr>
<tr><td><code id="scale_weighted_+3A_...">...</code></td>
<td>
<p>further parameters passed on to <code><a href="#topic+scale_weighted">scale_weighted</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scale_weighted</code> scales the data as a weighted sum of the variable values
</p>
<p>If variable names used for the definition of the scale
are not present in the data frame they are assumed to be 0.
<code>scale_weighted</code> scales the data as a weighted sum of the category percentages
</p>
<p><code>scale_logit</code> scales the data on a logit scale as described by Lowe et al. (2011).
</p>
<p><code>scale_bipolar</code> scales the data by adding up the variable
values in pos and substracting the variable values in neg.
</p>
<p><code>scale_ratio_1</code> scales the data taking the ratio of the difference of the sum of the variable
values in pos and the sum of the variable values in neg to the sum of the variable values in pos and neg 
as suggested by Kim and Fording (1998) and by Laver &amp; Garry (2000).
</p>
<p><code>scale_ratio_2</code> scales the data taking the ratio of the sum of the variable
values in pos and the sum of the variable values in neg.
</p>


<h3>References</h3>

<p>Lowe, W., Benoit, K., Mikhaylov, S., &amp; Laver, M. (2011). Scaling Policy Preferences from Coded Political Texts. Legislative Studies Quarterly, 36(1), 123-155.
</p>
<p>Kim, H., &amp; Fording, R. C. (1998). Voter ideology in western democracies, 1946-1989. European Journal of Political Research, 33(1), 73-97.
</p>
<p>Laver, M., &amp; Garry, J. (2000). Estimating Policy Positions from Political Texts. American Journal of Political Science, 44(3), 619-634.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mp_scale">mp_scale</a></code>
</p>

<hr>
<h2 id='split_belgium'>Split Belgium party system into separate groups</h2><span id='topic+split_belgium'></span>

<h3>Description</h3>

<p>Recodes the country variable of a dataset to 218 (Flanders parties)
and 219 (Wallonia parties) from 21 for Belgium
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_belgium(
  data,
  wallonia_parties = c(21111, 21322, 21422, 21423, 21425, 21426, 21522, 21911),
  brussels_parties = c(21424, 21912),
  belgium_parties = c(21320, 21420, 21520),
  flanders_parties = c(21112, 21221, 21321, 21330, 21421, 21430, 21521, 21913, 21914,
    21915, 21916, 21917),
  presplit_countrycode = 21,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_belgium_+3A_data">data</code></td>
<td>
<p>data.frame in format of the Manifesto Project's Main Dataset</p>
</td></tr>
<tr><td><code id="split_belgium_+3A_wallonia_parties">wallonia_parties</code></td>
<td>
<p>Party codes for the Wallonia half</p>
</td></tr>
<tr><td><code id="split_belgium_+3A_brussels_parties">brussels_parties</code></td>
<td>
<p>Party codes for Brussel specific parties, are recoded to NA</p>
</td></tr>
<tr><td><code id="split_belgium_+3A_belgium_parties">belgium_parties</code></td>
<td>
<p>Party codes for complete system, coded as presplit_countrycode</p>
</td></tr>
<tr><td><code id="split_belgium_+3A_flanders_parties">flanders_parties</code></td>
<td>
<p>Party codes for the Flanders half</p>
</td></tr>
<tr><td><code id="split_belgium_+3A_presplit_countrycode">presplit_countrycode</code></td>
<td>
<p>Country code for the belgium_parties</p>
</td></tr>
<tr><td><code id="split_belgium_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='v4_categories'>Lists of categories and category relations</h2><span id='topic+v4_categories'></span><span id='topic+v5_categories'></span><span id='topic+cee_categories'></span><span id='topic+v5_v4_aggregation_relations'></span><span id='topic+cee_aggregation_relations'></span><span id='topic+rile_r'></span><span id='topic+rile_l'></span>

<h3>Description</h3>

<p>Code numbers of the Manifesto Project's category scheme. For documentation
see <a href="https://manifesto-project.wzb.eu/datasets">https://manifesto-project.wzb.eu/datasets</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v4_categories()

v5_categories(include_parents = TRUE)

cee_categories()

v5_v4_aggregation_relations()

cee_aggregation_relations()

rile_r()

rile_l()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="v4_categories_+3A_include_parents">include_parents</code></td>
<td>
<p>include v5-categories that have subcategories</p>
</td></tr>
</table>

<hr>
<h2 id='vanilla'>Vanilla Scaling by Gabel &amp; Huber</h2><span id='topic+vanilla'></span>

<h3>Description</h3>

<p>Computes scores based on the Vanilla method suggested by Gabel &amp; Huber. 
A factor analysis identifies the dominant dimension in the data. 
Factor scores using the regression method are then considered as party positions on this dominant dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanilla(
  data,
  vars = grep("per\\d{3}$", names(data), value = TRUE),
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vanilla_+3A_data">data</code></td>
<td>
<p>A data.frame with cases to be scaled, variables named &quot;per...&quot;</p>
</td></tr>
<tr><td><code id="vanilla_+3A_vars">vars</code></td>
<td>
<p>variable names that should be used for the scaling (usually the variables per101,per102,...)</p>
</td></tr>
<tr><td><code id="vanilla_+3A_invert">invert</code></td>
<td>
<p>invert scores (to change the direction of the dimension to facilitate comparison with other indices) (default is FALSE)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gabel, M. J., &amp; Huber, J. D. (2000). Putting Parties in Their Place: Inferring Party Left-Right Ideological Positions from Party Manifestos Data. American Journal of Political Science, 44(1), 94-103.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
