<!DOCTYPE html><html lang="en"><head><title>Help for package cctools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cctools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cctools-package'><p>Tools for the continuous convolution trick in nonparametric estimation</p></a></li>
<li><a href='#cckde'><p>Continuous convolution density estimator</p></a></li>
<li><a href='#cont_conv'><p>Continuous convolution</p></a></li>
<li><a href='#dusb'><p>Uniform scaled beta distribution</p></a></li>
<li><a href='#expand_as_numeric'><p>Numeric model matrix for continuous convolution</p></a></li>
<li><a href='#expand_names'><p>Expands names for expand_as_numeric</p></a></li>
<li><a href='#expand_vec'><p>Expand a vector like expand_as_numeric</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for the Continuous Convolution Trick in Nonparametric
Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the uniform scaled beta distribution and
  the continuous convolution kernel density estimator.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp (&ge; 0.12.5), qrng</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-19 18:58:00 UTC; n5</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Nagler [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Nagler &lt;thomas.nagler@tum.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-19 19:33:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='cctools-package'>Tools for the continuous convolution trick in nonparametric estimation</h2><span id='topic+cctools-package'></span><span id='topic+cctools'></span>

<h3>Description</h3>

<p>Implements the uniform scaled beta distribution <code><a href="#topic+dusb">dusb()</a></code>, a generic function
for continuous convolution <code><a href="#topic+cont_conv">cont_conv()</a></code>, and the continuous convolution
kernel density estimator <code><a href="#topic+cckde">cckde()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>References</h3>

<p>Nagler, T. (2017). <em>A generic approach to nonparametric function
estimation with mixed data.</em> <a href="https://arxiv.org/pdf/1704.07457.pdf">arXiv:1704.07457</a>
</p>

<hr>
<h2 id='cckde'>Continuous convolution density estimator</h2><span id='topic+cckde'></span><span id='topic+dcckde'></span><span id='topic+predict.cckde'></span>

<h3>Description</h3>

<p>The continuous convolution kernel density estimator is defined as the
classical kernel density estimator based on continuously convoluted data (see
<code><a href="#topic+cont_conv">cont_conv()</a></code>). <code><a href="#topic+cckde">cckde()</a></code> fits the estimator (including bandwidth selection),
<code><a href="#topic+dcckde">dcckde()</a></code> and <code><a href="#topic+predict.cckde">predict.cckde()</a></code> can be used to evaluate the estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cckde(x, bw = NULL, mult = 1, theta = 0, nu = 5, ...)

dcckde(x, object)

## S3 method for class 'cckde'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cckde_+3A_x">x</code></td>
<td>
<p>a matrix or data frame containing the data (or evaluation points).</p>
</td></tr>
<tr><td><code id="cckde_+3A_bw">bw</code></td>
<td>
<p>vector of bandwidth parameter; if <code>NULL</code>, the bandwidths are
selected automatically by likelihood cross validation.</p>
</td></tr>
<tr><td><code id="cckde_+3A_mult">mult</code></td>
<td>
<p>bandwidth multiplier; either a positive number or a vector of
such. Each bandwidth parameter is multiplied with the corresponding
multiplier.</p>
</td></tr>
<tr><td><code id="cckde_+3A_theta">theta</code></td>
<td>
<p>scale parameter of the USB distribution (see, <code><a href="#topic+dusb">dusb()</a></code>).</p>
</td></tr>
<tr><td><code id="cckde_+3A_nu">nu</code></td>
<td>
<p>smoothness parameter of the USB distribution (see, <code><a href="#topic+dusb">dusb()</a></code>).
The estimator uses the Epanechnikov kernel for smoothing and the USB
distribution for continuous convolution (default parameters correspond to
the uniform distribution on <code class="reqn">[-0.5, 0.5]</code>.</p>
</td></tr>
<tr><td><code id="cckde_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="cckde_+3A_object">object</code></td>
<td>
<p><code>cckde</code> object.</p>
</td></tr>
<tr><td><code id="cckde_+3A_newdata">newdata</code></td>
<td>
<p>matrix or data frame containing evaluation points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a variable should be treated as ordered discrete, declare it as
<code><a href="base.html#topic+ordered">ordered()</a></code>, factors are expanded into discrete dummy codings.
</p>


<h3>References</h3>

<p>Nagler, T. (2017). <em>A generic approach to nonparametric function
estimation with mixed data.</em> <a href="https://arxiv.org/pdf/1704.07457.pdf">arXiv:1704.07457</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dummy data with discrete variables
dat &lt;- data.frame(
    F1 = factor(rbinom(10, 4, 0.1), 0:4),
    Z1 = ordered(rbinom(10, 5, 0.5), 0:5),
    Z2 = ordered(rpois(10, 1), 0:10),
    X1 = rnorm(10),
    X2 = rexp(10)
)

fit &lt;- cckde(dat)  # fit estimator
dcckde(dat, fit)   # evaluate density
predict(fit, dat)  # equivalent

</code></pre>

<hr>
<h2 id='cont_conv'>Continuous convolution</h2><span id='topic+cont_conv'></span>

<h3>Description</h3>

<p>Applies the continuous convolution trick, i.e. adding continuous noise to all
discrete variables. If a variable should be treated as discrete, declare it
as <code><a href="base.html#topic+ordered">ordered()</a></code> (passed to <code><a href="#topic+expand_as_numeric">expand_as_numeric()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont_conv(x, theta = 0, nu = 5, quasi = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cont_conv_+3A_x">x</code></td>
<td>
<p>data; numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="cont_conv_+3A_theta">theta</code></td>
<td>
<p>scale parameter of the USB distribution (see, <code><a href="#topic+dusb">dusb()</a></code>).</p>
</td></tr>
<tr><td><code id="cont_conv_+3A_nu">nu</code></td>
<td>
<p>smoothness parameter of the USB distribution (see, <code><a href="#topic+dusb">dusb()</a></code>). The
estimator uses the Epanechnikov kernel for smoothing and the USB for
continuous convolution (default parameters correspond to the <code class="reqn">U[-0.5,
  0.5]</code> distribution).</p>
</td></tr>
<tr><td><code id="cont_conv_+3A_quasi">quasi</code></td>
<td>
<p>logical indicating whether quasi random numbers sholuld be used
(<code><a href="qrng.html#topic+ghalton">qrng::ghalton()</a></code>); only works for <code>theta = 0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The UPSB distribution (<code><a href="#topic+dusb">dusb()</a></code>) is used as the noise distribution.
Discrete variables are assumed to be integer-valued.
</p>


<h3>Value</h3>

<p>A data frame with noise added to each discrete variable (ordered
columns).
</p>


<h3>References</h3>

<p>Nagler, T. (2017). <em>A generic approach to nonparametric function
estimation with mixed data.</em> <a href="https://arxiv.org/pdf/1704.07457.pdf">arXiv:1704.07457</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dummy data with discrete variables
dat &lt;- data.frame(
    F1 = factor(rbinom(10, 4, 0.1), 0:4),
    Z1 = ordered(rbinom(10, 5, 0.5), 0:5),
    Z2 = ordered(rpois(10, 1), 0:10),
    X1 = rnorm(10),
    X2 = rexp(10)
)

pairs(dat)
pairs(expand_as_numeric(dat))  # expanded variables without noise
pairs(cont_conv(dat))          # continuously convoluted data

</code></pre>

<hr>
<h2 id='dusb'>Uniform scaled beta distribution</h2><span id='topic+dusb'></span><span id='topic+rusb'></span>

<h3>Description</h3>

<p>The uniform scaled beta (USB) distribution describes the distribution of
the random variable
</p>
<p style="text-align: center;"><code class="reqn">U_{b, \nu} = U + \theta(B - 0.5),</code>
</p>

<p>where <code class="reqn">U</code> is a <code class="reqn">U[-0.5, 0.5]</code> random variable, <code class="reqn">B</code> is a
<code class="reqn">Beta(\nu, \nu)</code> random variable, and <code class="reqn">theta &gt; 0, \nu &gt;= 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dusb(x, theta = 0, nu = 5)

rusb(n, theta = 0, nu = 5, quasi = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dusb_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dusb_+3A_theta">theta</code></td>
<td>
<p>scale parameter of the USB distribution.</p>
</td></tr>
<tr><td><code id="dusb_+3A_nu">nu</code></td>
<td>
<p>smoothness parameter of the USB distribution.</p>
</td></tr>
<tr><td><code id="dusb_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dusb_+3A_quasi">quasi</code></td>
<td>
<p>logical indicating whether quasi random numbers
(<code><a href="qrng.html#topic+ghalton">qrng::ghalton()</a></code>) should be used for generating uniforms (which are then
transformed by the quantile function)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nagler, T. (2017). <em>A generic approach to nonparametric function
estimation with mixed data.</em> <a href="https://arxiv.org/pdf/1704.07457.pdf">arXiv:1704.07457</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot distribution
sq &lt;- seq(-0.8, 0.8, by = 0.01)
plot(sq, dusb(sq), type = "l")
lines(sq, dusb(sq, theta = 0.25), col = 2)
lines(sq, dusb(sq, theta = 0.25, nu = 10), col = 3)

# simulate from the distribution
x &lt;- rusb(100, theta = 0.3, nu = 0)

</code></pre>

<hr>
<h2 id='expand_as_numeric'>Numeric model matrix for continuous convolution</h2><span id='topic+expand_as_numeric'></span>

<h3>Description</h3>

<p>Turns ordered variables into integers and expands factors as binary dummy
codes. <code><a href="#topic+cont_conv">cont_conv()</a></code> additionally adds noise to discrete variables, but this is only
useful for estimation. <code>[cc_prepare()]</code> can be used to evaluate an already
fitted estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_as_numeric(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_as_numeric_+3A_x">x</code></td>
<td>
<p>a vector or data frame with numeric, ordered, or factor columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix containing the expanded variables. It has additional
type <code>expanded_as_numeric</code> and <code>attr(, "i_disc")</code> cntains the indices of
discrete variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dummy data with discrete variables
dat &lt;- data.frame(
    F1 = factor(rbinom(100, 4, 0.1), 0:4),
    Z1 = as.ordered(rbinom(100, 5, 0.5)),
    Z2 = as.ordered(rpois(100, 1)),
    X1 = rnorm(100),
    X2 = rexp(100)
)

pairs(dat)
pairs(expand_as_numeric(dat))  # expanded variables without noise
pairs(cont_conv(dat))          # continuously convoluted data

</code></pre>

<hr>
<h2 id='expand_names'>Expands names for expand_as_numeric</h2><span id='topic+expand_names'></span>

<h3>Description</h3>

<p>Expands each element according to the factor expansions of columns in
<code><a href="#topic+expand_as_numeric">expand_as_numeric()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_names_+3A_x">x</code></td>
<td>
<p>as in <code><a href="#topic+expand_as_numeric">expand_as_numeric()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>ncol(expand_as_numeric(x))</code>.
</p>

<hr>
<h2 id='expand_vec'>Expand a vector like expand_as_numeric</h2><span id='topic+expand_vec'></span>

<h3>Description</h3>

<p>Expands each element according to the factor expansions of columns in
<code><a href="#topic+expand_as_numeric">expand_as_numeric()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_vec(y, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_vec_+3A_y">y</code></td>
<td>
<p>a vector of length 1 or <code>ncol(x)</code>.</p>
</td></tr>
<tr><td><code id="expand_vec_+3A_x">x</code></td>
<td>
<p>as in <code><a href="#topic+expand_as_numeric">expand_as_numeric()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>ncol(expand_as_numeric(x))</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
