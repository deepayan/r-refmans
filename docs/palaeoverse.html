<!DOCTYPE html><html><head><title>Help for package palaeoverse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {palaeoverse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#axis_geo'><p>Add an axis with a geological timescale</p></a></li>
<li><a href='#bin_lat'><p>Assign fossil occurrences to latitudinal bins</p></a></li>
<li><a href='#bin_space'><p>Assign fossil occurrences to spatial bins</p></a></li>
<li><a href='#bin_time'><p>Assign fossil occurrences to time bins</p></a></li>
<li><a href='#group_apply'><p>Apply a function over grouping(s) of data</p></a></li>
<li><a href='#GTS2012'><p>Geological Timescale 2012</p></a></li>
<li><a href='#GTS2020'><p>Geological Timescale 2020</p></a></li>
<li><a href='#interval_key'><p>Example dataset: Interval key for the look_up function</p></a></li>
<li><a href='#lat_bins'><p>Generate latitudinal bins</p></a></li>
<li><a href='#look_up'><p>Look up geological intervals and assign geological stages</p></a></li>
<li><a href='#palaeorotate'><p>Palaeorotate fossil occurrences</p></a></li>
<li><a href='#palaeoverse-package'><p>palaeoverse: Prepare and Explore Data for Palaeobiological Analyses</p></a></li>
<li><a href='#phylo_check'><p>Check phylogeny tip names</p></a></li>
<li><a href='#reefs'><p>Example dataset: Phanerozoic reefs from the PaleoReefs Database</p></a></li>
<li><a href='#tax_check'><p>Taxonomic spell check</p></a></li>
<li><a href='#tax_expand_lat'><p>Generate pseudo-occurrences from latitudinal range data</p></a></li>
<li><a href='#tax_expand_time'><p>Generate pseudo-occurrences from temporal range data</p></a></li>
<li><a href='#tax_range_space'><p>Calculate the geographic range of fossil taxa</p></a></li>
<li><a href='#tax_range_time'><p>Calculate the temporal range of fossil taxa</p></a></li>
<li><a href='#tax_unique'><p>Filter occurrences to unique taxa</p></a></li>
<li><a href='#tetrapods'><p>Example dataset: Early tetrapod data from the Paleobiology Database</p></a></li>
<li><a href='#time_bins'><p>Generate time bins</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Prepare and Explore Data for Palaeobiological Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality to support data preparation and exploration for
  palaeobiological analyses, improving code reproducibility and accessibility. The
  wider aim of 'palaeoverse' is to bring the palaeobiological community together 
  to establish agreed standards. The package currently includes functionality for 
  data cleaning, binning (time and space), exploration, summarisation and 
  visualisation. Reference datasets (i.e. Geological Time Scales <a href="https://stratigraphy.org/chart">https://stratigraphy.org/chart</a>)
  and auxiliary functions are also provided. Details can be found in:
  Jones et al., (2023) &lt;<a href="https://doi.org/10.1111%2F2041-210X.14099">doi:10.1111/2041-210X.14099</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, methods, curl, ape, sf, stringdist,
geosphere, h3jsr (&ge; 1.3.0), httr, pbapply</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0), vdiffr (&ge; 1.0.0),
paleotree, phytools, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://palaeoverse.palaeoverse.org">https://palaeoverse.palaeoverse.org</a>,
<a href="https://github.com/palaeoverse-community/palaeoverse">https://github.com/palaeoverse-community/palaeoverse</a>,
<a href="https://palaeoverse.org">https://palaeoverse.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/palaeoverse-community/palaeoverse/issues">https://github.com/palaeoverse-community/palaeoverse/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-16 21:04:44 UTC; lewis</td>
</tr>
<tr>
<td>Author:</td>
<td>Lewis A. Jones <a href="https://orcid.org/0000-0003-3902-8986"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  William Gearty <a href="https://orcid.org/0000-0003-0076-3262"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bethany J. Allen <a href="https://orcid.org/0000-0003-0282-6407"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kilian Eichenseer <a href="https://orcid.org/0000-0002-0477-8878"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Christopher D. Dean
    <a href="https://orcid.org/0000-0001-6471-6903"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Sofia Galvan <a href="https://orcid.org/0000-0002-3092-4314"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Miranta Kouvari <a href="https://orcid.org/0000-0002-5442-6221"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Pedro L. Godoy <a href="https://orcid.org/0000-0003-4519-5094"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Cecily Nicholl <a href="https://orcid.org/0000-0003-2860-2604"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Lucas Buffan <a href="https://orcid.org/0000-0002-2353-1432"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Erin M. Dillon <a href="https://orcid.org/0000-0003-0249-027X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Joseph T. Flannery-Sutherland
    <a href="https://orcid.org/0000-0001-8232-6773"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  A. Alessandro Chiarenza
    <a href="https://orcid.org/0000-0001-5525-6730"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lewis A. Jones &lt;LewisAlan.Jones@uvigo.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-17 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='axis_geo'>Add an axis with a geological timescale</h2><span id='topic+axis_geo'></span><span id='topic+axis_geo_phylo'></span>

<h3>Description</h3>

<p><code>axis_geo</code> behaves similarly to <code><a href="graphics.html#topic+axis">axis</a></code> in that it
adds an axis to the specified side of a base R plot. The main difference is
that it also adds a geological timescale between the plot and the axis. The
default scale includes international epochs from the the Geological Timescale
2020 (<code><a href="#topic+GTS2020">GTS2020</a></code>). However, international stages, periods, eras,
and eons are also available. Interval data hosted by
<a href="https://macrostrat.org">Macrostrat</a> are also available (see
<code><a href="#topic+time_bins">time_bins</a></code>). A custom interval dataset can also be used (see
Details below). The appearance of the axis is highly customisable (see Usage
below), with the intent that plots will be publication-ready.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_geo(
  side = 1,
  intervals = "epoch",
  height = 0.05,
  fill = NULL,
  lab = TRUE,
  lab_col = NULL,
  lab_size = 1,
  rot = 0,
  abbr = TRUE,
  center_end_labels = TRUE,
  skip = c("Quaternary", "Holocene", "Late Pleistocene"),
  bord_col = "black",
  lty = par("lty"),
  lwd = par("lwd"),
  bkgd = "grey90",
  neg = FALSE,
  exact = FALSE,
  round = FALSE,
  tick_at = NULL,
  tick_labels = TRUE,
  phylo = FALSE,
  root.time = NULL,
  ...
)

axis_geo_phylo(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis_geo_+3A_side">side</code></td>
<td>
<p><code>integer</code>. Which side to add the axis to (<code>1</code>: bottom,
the default; <code>2</code>: left; <code>3</code>: top; <code>4</code>: right).</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_intervals">intervals</code></td>
<td>
<p>The interval information to use to plot the axis: either A)
a <code>character</code> string indicating a rank of intervals from the built-in
<code><a href="#topic+GTS2020">GTS2020</a></code>, B) a <code>character</code> string indicating a
<code>data.frame</code> hosted by <a href="https://macrostrat.org">Macrostrat</a> (see
<code><a href="#topic+time_bins">time_bins</a></code>), or C) a custom <code>data.frame</code> of time interval
boundaries (see Details). A list of strings or data.frames can be supplied
to add multiple time scales to the same side of the plot (see Details).</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_height">height</code></td>
<td>
<p><code>numeric</code>. The relative height (or width if <code>side</code> is
<code>2</code> or <code>4</code>) of the scale. This is relative to the height (if
<code>side</code> is <code>1</code> or <code>3</code>) or width (if <code>side</code> is <code>2</code>
or <code>4</code>) of the plot.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_fill">fill</code></td>
<td>
<p><code>character</code>. The fill colour of the boxes. The default is to
use the <code>colour</code> or <code>color</code> column included in <code>intervals</code>.
If a custom dataset is provided with <code>intervals</code> without a
<code>colour</code> or <code>color</code> column and without specifying <code>fill</code>, a
greyscale will be used. Custom fill colours can be provided with this
option (overriding the <code>colour</code> or <code>color</code> column) and will be
recycled if/as necessary.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_lab">lab</code></td>
<td>
<p><code>logical</code>. Should interval labels be included?</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_lab_col">lab_col</code></td>
<td>
<p><code>character</code>. The colour of the labels. The default is to
use the <code>font</code> or <code>lab_color</code> column included in
<code>intervals</code>. If a custom dataset is provided with <code>intervals</code>
without a <code>font</code> or <code>lab_color</code> column and without
specifying <code>lab_col</code>, all labels will be black. Custom label colours
can be provided with this option (overriding the <code>font</code> or
<code>lab_color</code> column) and will be recycled if/as necessary.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_lab_size">lab_size</code></td>
<td>
<p><code>numeric</code>. The size of the labels (see <code>cex</code> in
<code><a href="graphics.html#topic+par">graphics parameters</a></code>).</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_rot">rot</code></td>
<td>
<p><code>numeric</code>. The amount of counter-clockwise rotation to add to
the labels (in degrees). Note, labels for axes added to the left or right
sides are already rotated 90 degrees.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_abbr">abbr</code></td>
<td>
<p><code>logical</code>. Should labels be abbreviated? This only works
if the data has an <code>abbr</code> column, otherwise the <code>name</code> column
will be used regardless of this setting.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_center_end_labels">center_end_labels</code></td>
<td>
<p><code>logical</code>. Should labels be centered within the
visible range of intervals at the ends of the axis?</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_skip">skip</code></td>
<td>
<p>A <code>character</code> vector of interval names indicating which
intervals should not be labeled. If <code>abbr</code> is <code>TRUE</code>, this can
also include interval abbreviations. Quaternary, Holocene, and Late
Pleistocene are skipped by default. Set to NULL if this is not desired.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_bord_col">bord_col</code></td>
<td>
<p><code>character</code>. The border colour of the interval boxes.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_lty">lty</code></td>
<td>
<p><code>character</code>. Line type (see <code>lty</code> in
<code><a href="graphics.html#topic+par">graphics parameters</a></code>). This value (or the last
value if this is a list) will also be passed to
<code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_lwd">lwd</code></td>
<td>
<p><code>numeric</code>. Line width (see <code>lwd</code> in
<code><a href="graphics.html#topic+par">graphics parameters</a></code>).</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_bkgd">bkgd</code></td>
<td>
<p><code>character</code>. The colour of the background of the scale
when no intervals are being shown.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_neg">neg</code></td>
<td>
<p><code>logical</code>. Set this to <code>TRUE</code> if your x-axis is using
negative values. If the entire axis is already negative, this will be set
to <code>TRUE</code> for you.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_exact">exact</code></td>
<td>
<p><code>logical</code>. Set this to <code>TRUE</code> if you want axis tick
marks and numeric tick labels placed at the interval boundaries. If
<code>TRUE</code>, this overrides <code>tick_at</code> and <code>tick_labels</code>.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_round">round</code></td>
<td>
<p><code>integer</code>. Number of decimal places to which exact axis
labels should be rounded (using <code><a href="base.html#topic+round">round</a></code>). If no value is
specified, the exact values will be used. Trailing zeros are always
removed. <code>tick_at</code> and <code>tick_labels</code> can be used to include
labels with trailing zeros.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_tick_at">tick_at</code></td>
<td>
<p>A <code>numeric</code> vector specifying custom points at which tick
marks are to be drawn on the axis. If specified, this is passed directly to
<code><a href="graphics.html#topic+axis">axis</a></code>. If <code>phylo</code> is <code>TRUE</code>, these values
are converted as necessary for the phylogenetic axis limits. If this is set
to <code>NULL</code> (the default) tick mark locations are computed automatically
(see <code><a href="graphics.html#topic+axTicks">axTicks</a></code>).</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_tick_labels">tick_labels</code></td>
<td>
<p>Either a) a <code>logical</code> value specifying whether
(numerical) annotations should be made at the tick marks specified by
<code>tick_at</code>, or b) a custom <code>character</code> or <code>expression</code> vector
of labels to be placed at the tick marks. If <code>tick_at</code> is specified,
this argument is passed directly to <code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_phylo">phylo</code></td>
<td>
<p><code>logical</code>. Is the base plot a phylogeny generated by
<code><a href="ape.html#topic+plot.phylo">plot.phylo</a></code>, <code><a href="phytools.html#topic+plotTree">plotTree</a></code>,
<code><a href="phytools.html#topic+plotSimmap">plotSimmap</a></code>, etc?</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_root.time">root.time</code></td>
<td>
<p><code>numeric</code>. If <code>phylo</code> is <code>TRUE</code>, this is the
time assigned to the root node of the tree. By default, this is taken from
the <code>root.time</code> element of the plotted tree.</p>
</td></tr>
<tr><td><code id="axis_geo_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed directly to
<code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a custom <code>data.frame</code> is provided (with <code>intervals</code>), it should
consist of at least 3 columns of data. See <code><a href="#topic+GTS2020">GTS2020</a></code> for an
example.
</p>

<ul>
<li><p> The <code>interval_name</code> column (<code>name</code> is also allowed) lists
the names of each time interval. These will be used as labels if no
abbreviations are provided.
</p>
</li>
<li><p> The <code>max_ma</code> column (<code>max_age</code> is also allowed) lists the
oldest boundary of each time interval. Values should always be
positive.
</p>
</li>
<li><p> The <code>min_ma</code> column (<code>min_age</code> is also allowed) lists the
youngest boundary of each time interval. Values should always be
positive.
</p>
</li>
<li><p> The <code>abbr</code> column is optional and lists abbreviations that may
be used as labels.
</p>
</li>
<li><p> The <code>colour</code> column (<code>color</code> is also allowed) is also
optional and lists a colour for the background for each time interval
(see the Color Specification section
<code><a href="graphics.html#topic+par">here</a></code>).
</p>
</li>
<li><p> The <code>font</code> (<code>lab_color</code> is also allowed) column is
also optional and lists a colour for the label for each time interval
(see the Color Specification section
<code><a href="graphics.html#topic+par">here</a></code>).
</p>
</li></ul>

<p><code>intervals</code> may also be a list if multiple time scales should be added
to a single side of the plot. In this case, <code>height</code>, <code>fill</code>,
<code>lab</code>, <code>lab_col</code>, <code>lab_size</code>, <code>rot</code>, <code>abbr</code>,
<code>center_end_labels</code>, <code>skip</code>, <code>bord_col</code>, <code>lty</code>, and
<code>lwd</code> can also be lists. If these lists are not as long as
<code>intervals</code>, the elements will be recycled. If individual values
(or vectors, e.g. for <code>skip</code>) are used for these parameters, they will
be applied to all time scales (and recycled as necessary). If multiple scales
are requested they will be added sequentially outwards starting from the plot
border. The axis will always be placed on the outside of the last scale.
</p>
<p>If you would like to use intervals from the Geological Time Scale 2012
(<code><a href="#topic+GTS2012">GTS2012</a></code>), you can use <code><a href="#topic+time_bins">time_bins</a></code> and supply the
returned <code>data.frame</code> to the <code>intervals</code> argument.
</p>
<p><code>axis_geo_phylo(...)</code> is shorthand for
<code>axis_geo(..., phylo = TRUE)</code>.
</p>


<h3>Value</h3>

<p>No return value. Function is used for its side effect, which is to
add an axis of the geological timescale to an already existing plot.
</p>


<h3>Authors</h3>

<p>William Gearty &amp; Kilian Eichenseer
</p>


<h3>Reviewer</h3>

<p>Lewis A. Jones
</p>


<h3>Examples</h3>

<pre><code class='language-R'># track user par
oldpar &lt;- par(no.readonly = TRUE)
# single scale on bottom
par(mar = c(6.1, 4.1, 4.1, 2.1)) # modify margin
plot(0:100, axes = FALSE, xlim = c(100, 0), ylim = c(100, 0),
     xlab = NA, ylab = "Depth (m)")
box()
axis(2)
axis_geo(side = 1, intervals = "period")
# the line argument here depends on the absolute size of the plot
title(xlab = "Time (Ma)", line = 4)

# stack multiple scales, abbreviate only one set of labels
par(mar = c(7.1, 4.1, 4.1, 2.1)) # further expand bottom margin
plot(0:100, axes = FALSE, xlim = c(100, 0), ylim = c(100, 0),
     xlab = NA, ylab = "Depth (m)")
box()
axis(2)
axis_geo(side = 1, intervals = list("epoch", "period"),
    abbr = list(TRUE, FALSE))
# the line argument here depends on the absolute size of the plot
title(xlab = "Time (Ma)", line = 6)

# scale with MacroStrat intervals
par(mar = c(6.1, 4.1, 4.1, 2.1)) # modify margin
plot(0:30, axes = FALSE, xlim = c(30, 0), ylim = c(30, 0),
     xlab = NA, ylab = "Depth (m)")
box()
axis(2)
axis_geo(side = 1, intervals = "North American land mammal ages")
# the line argument here depends on the absolute size of the plot
title(xlab = "Time (Ma)", line = 4)

# scale with custom intervals
intervals &lt;- data.frame(min_ma = c(0, 10, 25, 32),
                        max_ma = c(10, 25, 32, 40),
                        interval_name = c("A", "B", "C", "D"))
par(mar = c(6.1, 4.1, 4.1, 2.1)) # modify margin
plot(0:40, axes = FALSE, xlim = c(40, 0), ylim = c(40, 0),
     xlab = NA, ylab = "Depth (m)")
box()
axis(2)
axis_geo(side = 1, intervals = intervals)
# the line argument here depends on the absolute size of the plot
title(xlab = "Time (Ma)", line = 4)


# scale with phylogeny
library(phytools)
data(mammal.tree)
plot(mammal.tree)
axis_geo_phylo()
title(xlab = "Time (Ma)", line = 4)


# scale with fossil phylogeny
library(paleotree)
data(RaiaCopesRule)
plot(ceratopsianTreeRaia)
axis_geo_phylo()
title(xlab = "Time (Ma)", line = 4)

# reset user par
par(oldpar)

</code></pre>

<hr>
<h2 id='bin_lat'>Assign fossil occurrences to latitudinal bins</h2><span id='topic+bin_lat'></span>

<h3>Description</h3>

<p>A function to assign fossil occurrences to user-specified latitudinal bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_lat(occdf, bins, lat = "lat", boundary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_lat_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of the fossil occurrences you
wish to bin. This dataframe should contain a column with the
latitudinal coordinates of occurrence data.</p>
</td></tr>
<tr><td><code id="bin_lat_+3A_bins">bins</code></td>
<td>
<p><code>dataframe</code>. A dataframe of the bins that you wish to
allocate fossil occurrences to, such as that returned by
<code><a href="#topic+lat_bins">lat_bins()</a></code>. This dataframe must
contain at least the following named columns: &quot;bin&quot;, &quot;max&quot; and &quot;min&quot;.</p>
</td></tr>
<tr><td><code id="bin_lat_+3A_lat">lat</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the input latitude (e.g. &quot;lat&quot; or &quot;p_lat&quot;). This column should contain
numerical values. Defaults to &quot;lat&quot;.</p>
</td></tr>
<tr><td><code id="bin_lat_+3A_boundary">boundary</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, occurrences
falling on the boundaries of latitudinal bins will be duplicated and
assigned to both bins.
If <code>FALSE</code>, occurrences will be binned into the upper bin
only (i.e. highest row number).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of the original input <code>occdf</code> with appended
columns containing respective latitudinal bin information.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Sofia Galvan
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load occurrence data
occdf &lt;- tetrapods
# Generate latitudinal bins
bins &lt;- lat_bins(size = 10)
# Bin data
occdf &lt;- bin_lat(occdf = occdf, bins = bins, lat = "lat")

</code></pre>

<hr>
<h2 id='bin_space'>Assign fossil occurrences to spatial bins</h2><span id='topic+bin_space'></span>

<h3>Description</h3>

<p>A function to assign fossil occurrences (or localities) to spatial
bins/samples using a hexagonal equal-area grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_space(
  occdf,
  lng = "lng",
  lat = "lat",
  spacing = 100,
  sub_grid = NULL,
  return = FALSE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_space_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of the fossil occurrences (or
localities) you wish to bin. This dataframe should contain the decimal
degree coordinates of your occurrences, and they should be of
class <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="bin_space_+3A_lng">lng</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the input longitude (e.g. &quot;lng&quot; or &quot;p_lng&quot;).</p>
</td></tr>
<tr><td><code id="bin_space_+3A_lat">lat</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the input latitude (e.g. &quot;lat&quot; or &quot;p_lat&quot;).</p>
</td></tr>
<tr><td><code id="bin_space_+3A_spacing">spacing</code></td>
<td>
<p><code>numeric</code>. The desired spacing between the center of
adjacent cells. This value should be provided in kilometres.</p>
</td></tr>
<tr><td><code id="bin_space_+3A_sub_grid">sub_grid</code></td>
<td>
<p><code>numeric</code>. For an optional sub-grid, the desired
spacing between the center of adjacent cells in the sub-grid.
This value should be provided in kilometres.
See details for information on sub-grid usage.</p>
</td></tr>
<tr><td><code id="bin_space_+3A_return">return</code></td>
<td>
<p><code>logical</code>. Should the equal-area grid information and
polygons be returned?</p>
</td></tr>
<tr><td><code id="bin_space_+3A_plot">plot</code></td>
<td>
<p><code>logical</code>. Should the occupied cells of the equal-area grid
be plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assigns fossil occurrence data into
equal-area grid cells using discrete hexagonal grids via the
<code><a href="h3jsr.html#topic+h3jsr">h3jsr</a></code> package. This package relies on
<a href="https://h3geo.org/docs/">Uber's H3</a> library, a geospatial indexing system
that partitions the world into hexagonal cells. In H3, 16 different
resolutions are available
(<a href="https://h3geo.org/docs/core-library/restable/">see here</a>). In the
implementation of the <code>bin_space()</code> function, the resolution is defined by
the user-input <code>spacing</code> which represents the distance between the centroid
of adjacent cells. Using this distance, the function identifies which
resolution is most similar to the input <code>spacing</code>, and uses this resolution.
</p>
<p>Additional functionality allows the user to simultaneously assign occurrence
data to equal-area grid cells of a finer-scale grid (i.e. a ‘sub-grid’)
within the primary grid via the <code>sub_grid</code> argument. This might be desirable
for users to evaluate the differences in the amount of area occupied by
occurrences within their primary grid cells. This functionality also allows
the user to easily rarefy across sub-grid cells within primary cells to
further standardise spatial sampling (see example for basic implementation).
</p>
<p>Note: prior to implementation, coordinate reference system (CRS) for input
data is defined as EPSG:4326 (World Geodetic System
1984). The user should transform their data accordingly if this is
not appropriate. If you are unfamiliar with working with geographic data,
we highly recommend checking out <a href="https://r.geocompx.org/index.html">Geocomputation with R</a>.
</p>


<h3>Value</h3>

<p>If the <code>return</code> argument is set to <code>FALSE</code>, a dataframe is
returned of the original input <code>occdf</code> with cell information. If <code>return</code> is
set to <code>TRUE</code>, a list is returned with both the input <code>occdf</code> and grid
information and polygons.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Bethany Allen &amp; Kilian Eichenseer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get internal data
data("reefs")

# Reduce data for plotting
occdf &lt;- reefs[1:250, ]

# Bin data using a hexagonal equal-area grid
ex1 &lt;- bin_space(occdf = occdf, spacing = 500, plot = TRUE)

# Bin data using a hexagonal equal-area grid and sub-grid
ex2 &lt;- bin_space(occdf = occdf, spacing = 1000, sub_grid = 250, plot = TRUE)

# EXAMPLE: rarefy
# Load data
occdf &lt;- tetrapods[1:250, ]

# Assign to spatial bin
occdf &lt;- bin_space(occdf = occdf, spacing = 1000, sub_grid = 250)

# Get unique bins
bins &lt;- unique(occdf$cell_ID)

# n reps
n &lt;- 10

# Rarefy data across sub-grid grid cells
# Returns a list with each element a bin with respective mean genus richness
df &lt;- lapply(bins, function(x) {
  # subset occdf for respective grid cell
  tmp &lt;- occdf[which(occdf$cell_ID == x), ]

  # Which sub-grid cells are there within this bin?
  sub_bin &lt;- unique(tmp$cell_ID_sub)

  # Sample 1 sub-grid cell n times
  s &lt;- sample(sub_bin, size = n, replace = TRUE)

  # Count the number of unique genera within each sub_grid cell for each rep
  counts &lt;- sapply(s, function(i) {
    # Number of unique genera within each sample
    length(unique(tmp[which(tmp$cell_ID_sub == i), ]$genus))
  })

  # Mean richness across subsamples
  mean(counts)
})
</code></pre>

<hr>
<h2 id='bin_time'>Assign fossil occurrences to time bins</h2><span id='topic+bin_time'></span>

<h3>Description</h3>

<p>A function to assign fossil occurrences to specified time bins based on
different approaches commonly applied in palaeobiology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_time(occdf, bins, method = "mid", reps = 100, fun = dunif, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_time_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of the fossil occurrences you
wish to bin. This dataframe should contain the following named columns:
&quot;max_ma&quot; and &quot;min_ma&quot;. These columns should contain <code>numeric</code> values. If
required, <code>numeric</code> ages can be generated from interval names via the
<code><a href="#topic+look_up">look_up()</a></code> function.</p>
</td></tr>
<tr><td><code id="bin_time_+3A_bins">bins</code></td>
<td>
<p><code>dataframe</code>. A dataframe of the bins that you wish to
allocate fossil occurrences to such as that returned by
<code><a href="#topic+time_bins">time_bins()</a></code>. This dataframe must
contain at least the following named columns: &quot;bin&quot;, &quot;max_ma&quot; and
&quot;min_ma&quot;. Columns &quot;max_ma&quot; and &quot;min_ma&quot; must be <code>numeric</code> values.</p>
</td></tr>
<tr><td><code id="bin_time_+3A_method">method</code></td>
<td>
<p><code>character</code>. The method desired for binning fossil
occurrences. Currently, five methods exist in this function: &quot;mid&quot;,
&quot;majority&quot;, &quot;all&quot;, &quot;random&quot;, and &quot;point&quot;. See Details for a description
of each.</p>
</td></tr>
<tr><td><code id="bin_time_+3A_reps">reps</code></td>
<td>
<p><code>numeric</code>. A non-negative <code>numeric</code> specifying the number
of replications for sampling. This argument is only useful in the case of
the &quot;random&quot; or &quot;point&quot; method being specified in the <code>method</code> argument.
Defaults to 100.</p>
</td></tr>
<tr><td><code id="bin_time_+3A_fun">fun</code></td>
<td>
<p><code>function</code>. A probability density function from the
stats package such as <a href="stats.html#topic+dunif">dunif</a> or <a href="stats.html#topic+dnorm">dnorm</a>.
This argument is only useful if the &quot;point&quot; method is specified in the
<code>method</code> argument.</p>
</td></tr>
<tr><td><code id="bin_time_+3A_...">...</code></td>
<td>
<p>Additional arguments available in the called function (<code>fun</code>).
These arguments may be required for function arguments without default
values, or if you wish to overwrite the default argument value (see
example). <code>x</code> input values are generated internally based
on the age range of the fossil occurrence and should not be manually
provided. Note that <code>x</code> input values range between 0 and 1, and
function arguments should therefore be scaled to be within these bounds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Five approaches (methods) exist in the <code>bin_time()</code> function for
assigning occurrences to time bins:
</p>

<ul>
<li><p> Midpoint: The &quot;mid&quot; method is the simplest approach and uses the midpoint
of the fossil occurrence age range to bin the occurrence.
</p>
</li>
<li><p> Majority: The &quot;majority&quot; method bins an occurrence into the bin which it
most overlaps with. As part of this implementation, the majority
percentage overlap of the occurrence is also calculated and returned as
an additional column in <code>occdf</code>. If desired, these percentages can be
used to further filter an occurrence dataset.
</p>
</li>
<li><p> All: The &quot;all&quot; method bins an occurrence into every bin its age range
covers. For occurrences with age ranges of more than one bin, the
occurrence row is duplicated. Each occurrence is assigned an ID in the
column <code>occdf$id</code> so that duplicates can be tracked. Additionally,
<code>occdf$n_bins</code> records the number of bins each occurrence appears within.
</p>
</li>
<li><p> Random: The &quot;random&quot; method randomly samples X amount of bins (with
replacement) from the bins that the fossil occurrence age range covers
with equal probability regardless of bin length. The <code>reps</code> argument
determines the number of times the sample process is repeated. All
replications are stored as individual elements within the returned list
with an appended <code>bin_assignment</code> and <code>bin_midpoint</code> column to the
original input <code>occdf</code>. If desired, users can easily bind this list using
<code>do.call(rbind, x)</code>.
</p>
</li>
<li><p> Point: The &quot;point&quot; method randomly samples X (<code>reps</code>) amount of point age
estimates from the age range of the fossil occurrence. Sampling follows a
user-input probability density function such
as <a href="stats.html#topic+dnorm">dnorm</a> (see example 5). Users should also provide any
additional arguments for the probability density function (see <code>...</code>).
However, <code>x</code> (vector of quantiles) values should not be provided as these
values are input from the age range of each occurrence. These
values range between 0 and 1, and therefore function arguments should be
scaled to be within these bounds. The <code>reps</code> argument determines the
number of times the sample process is repeated. All replications are
stored as individual elements within the returned list with an appended
<code>bin_assignment</code> and <code>point_estimates</code> column to the original input
<code>occdf</code>. If desired, users can easily bind this list using
<code>do.call(rbind, x)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>For methods &quot;mid&quot;, &quot;majority&quot; and &quot;all&quot;, a <code>dataframe</code> of the
original input <code>occdf</code> with the following appended columns is returned:
occurrence id (<code>id</code>), number of bins that the occurrence age range covers
(<code>n_bins</code>), bin assignment (<code>bin_assignment</code>), and bin midpoint
(<code>bin_midpoint</code>). In the case of the &quot;majority&quot; method, an additional
column of the majority percentage overlap (<code>overlap_percentage</code>) is also
appended. For the &quot;random&quot; and &quot;point&quot; method, a <code>list</code> is returned
(of length reps) with each element a copy of the <code>occdf</code> and appended
columns (random: <code>bin_assignment</code> and <code>bin_midpoint</code>; point:
<code>bin_assignment</code> and <code>point_estimates</code>).
</p>


<h3>Developer(s)</h3>

<p>Christopher D. Dean &amp; Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>William Gearty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Grab internal tetrapod data
occdf &lt;- tetrapods[1:100, ]
bins &lt;- time_bins()

#Assign via midpoint age of fossil occurrence data
ex1 &lt;- bin_time(occdf = occdf, bins = bins, method = "mid")

#Assign to all bins that age range covers
ex2 &lt;- bin_time(occdf = occdf, bins = bins, method = "all")

#Assign via majority overlap based on fossil occurrence age range
ex3 &lt;- bin_time(occdf = occdf, bins = bins, method = "majority")

#Assign randomly to overlapping bins based on fossil occurrence age range
ex4 &lt;- bin_time(occdf = occdf, bins = bins, method = "random", reps = 5)

#Assign point estimates following a normal distribution
ex5 &lt;- bin_time(occdf = occdf, bins = bins, method = "point", reps = 5,
                fun = dnorm, mean = 0.5, sd = 0.25)
</code></pre>

<hr>
<h2 id='group_apply'>Apply a function over grouping(s) of data</h2><span id='topic+group_apply'></span>

<h3>Description</h3>

<p>A function to apply <code>palaeoverse</code> functionality across subsets (groups) of
data, delineated using one or more variables. Functions which receive a
<code>data.frame</code> as input (e.g. <code>nrow</code>, <code>ncol</code>, <code>lengths</code>, <code>unique</code>) may also be
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_apply(occdf, group, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_apply_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of fossil occurrences or taxa,
as relevant to the desired function.
This dataframe must contain the grouping variables and the necessary
variables for the function you wish to call (see function-specific
documentation for required columns).</p>
</td></tr>
<tr><td><code id="group_apply_+3A_group">group</code></td>
<td>
<p><code>character</code>. A vector of column names, specifying the
desired subgroups (e.g. &quot;collection_no&quot;, &quot;stage_bin&quot;). Supplying more than
one grouping variable will produce an output containing subgroups for each
unique combination of values.</p>
</td></tr>
<tr><td><code id="group_apply_+3A_fun">fun</code></td>
<td>
<p><code>function</code>. The function you wish to apply to
<code>occdf</code>. See details for compatible functions.</p>
</td></tr>
<tr><td><code id="group_apply_+3A_...">...</code></td>
<td>
<p>Additional arguments available in the called
function. These arguments may be required for function arguments
without default values, or if you wish to overwrite the default argument
value (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>group_apply</code> applies functions to subgroups of data within a
supplied dataset, enabling the separate analysis of occurrences or taxa from
different time intervals, spatial regions, or trait values. The function
serves as a wrapper around <code>palaeoverse</code> functions. Other functions which
can be applied to a <code>data.frame</code> (e.g. <code>nrow</code>, <code>ncol</code>, <code>lengths</code>,
<code>unique</code>) may also be used.
<br />
<br />
All <code>palaeoverse</code> functions which require a dataframe input can be used in
conjunction with the <code>group_apply</code> function. However, this is unnecessary
for many functions (e.g. <code><a href="#topic+bin_time">bin_time</a></code>) as groups do not need to
be partitioned before binning. This list provides
users with <code>palaeoverse</code> functions that might be interesting to apply across
group(s):
</p>

<ul>
<li> <p><code><a href="#topic+tax_unique">tax_unique</a></code>: return the number of unique taxa per grouping
variable.
</p>
</li>
<li> <p><code><a href="#topic+tax_range_time">tax_range_time</a></code>: return the temporal range of taxa per
grouping variable.
</p>
</li>
<li> <p><code><a href="#topic+tax_range_space">tax_range_space</a></code>: return the geographic range of taxa per
grouping variable.
</p>
</li>
<li> <p><code><a href="#topic+tax_check">tax_check</a></code>: return potential spelling variations of the
same taxon per grouping variable. Note: <code>verbose</code> needs to be set to FALSE.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> of the outputs from the selected function, with
appended column(s) indicating the user-defined groups. If a single vector
is returned via the called function, it will be transformed to a
<code>data.frame</code> with the column name equal to the input function.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones &amp; William Gearty
</p>


<h3>Reviewer(s)</h3>

<p>Kilian Eichenseer &amp; Bethany Allen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples
# Get tetrapods data
occdf &lt;- tetrapods[1:100, ]
# Remove NA data
occdf &lt;- subset(occdf, !is.na(genus))
# Count number of occurrences from each country
ex1 &lt;- group_apply(occdf = occdf, group = "cc", fun = nrow)
# Unique genera per collection with group_apply and input arguments
ex2 &lt;- group_apply(occdf = occdf,
                     group = c("collection_no"),
                     fun = tax_unique,
                     genus = "genus",
                     family = "family",
                     order = "order",
                     class = "class",
                     resolution = "genus")
# Use multiple variables (number of occurrences per collection and formation)
ex3 &lt;- group_apply(occdf = occdf,
                   group = c("collection_no", "formation"),
                   fun = nrow)
# Compute counts of occurrences per latitudinal bin
# Set up lat bins
bins &lt;- lat_bins()
# bin occurrences
occdf &lt;- bin_lat(occdf = occdf, bins = bins)
# Calculate number of occurrences per bin
ex4 &lt;- group_apply(occdf = occdf, group = "lat_bin", fun = nrow)
</code></pre>

<hr>
<h2 id='GTS2012'>Geological Timescale 2012</h2><span id='topic+GTS2012'></span>

<h3>Description</h3>

<p>A dataframe of the Geological Timescale 2012. Age data from the
<a href="https://stratigraphy.org/ICSchart/ChronostratChart2012.pdf">International Commission on Stratigraphy</a>.
Supplementary information is also included in the dataset for plotting
functionality (e.g. GTS2012 colour scheme).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GTS2012
</code></pre>


<h3>Format</h3>

<p>A data frame with 186 rows and 9 variables:
</p>

<dl>
<dt>interval_number</dt><dd><p>Index number for the temporal order of all
intervals present in the dataset.</p>
</dd>
<dt>interval_name</dt><dd><p>Names of intervals in the dataset.</p>
</dd>
<dt>rank</dt><dd><p>The temporal rank of intervals in the dataset.</p>
</dd>
<dt>max_ma</dt><dd><p>The maximum age of the interval in millions of years before
present.</p>
</dd>
<dt>mid_ma</dt><dd><p>The midpoint age of the interval in millions of years before
present.</p>
</dd>
<dt>min_ma</dt><dd><p>The minimum age of the interval in millions of years before
present.</p>
</dd>
<dt>duration_myr</dt><dd><p>The duration of the interval in millions of years.</p>
</dd>
<dt>font</dt><dd><p>Colour of font to use for plotting in conjunction with the
colour column.</p>
</dd>
<dt>colour</dt><dd><p>Colours of stages based on the <a href="https://stratigraphy.org/timescale/">ICS timescale</a>.</p>
</dd>
<dt>abbr</dt><dd><p>Standard abbreviations of interval names where appropiate.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gradstein, F.M., Ogg, J.G., Schmitz, M.D. and Ogg, G.M. eds. (2012).
Geologic Timescale 2012. Elsevier.
<br />
</p>


<h3>Source</h3>

<p>Compiled by Lewis A. Jones (2022-07-02) from the <a href="https://stratigraphy.org/ICSchart/ChronostratChart2012.pdf">ICS</a>.
</p>

<hr>
<h2 id='GTS2020'>Geological Timescale 2020</h2><span id='topic+GTS2020'></span>

<h3>Description</h3>

<p>A dataframe of the Geological Timescale 2020. Age data from the
<a href="https://stratigraphy.org/ICSchart/ChronostratChart2020-03.pdf">International Commission on Stratigraphy</a>.
Supplementary information is included in the dataset for plotting
functionality (e.g. GTS2020 colour scheme).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GTS2020
</code></pre>


<h3>Format</h3>

<p>A data frame with 189 rows and 9 variables:
</p>

<dl>
<dt>interval_number</dt><dd><p>Index number for the temporal order of all
intervals present in the dataset.</p>
</dd>
<dt>interval_name</dt><dd><p>Names of intervals in the dataset.</p>
</dd>
<dt>rank</dt><dd><p>The temporal rank of intervals in the dataset.</p>
</dd>
<dt>max_ma</dt><dd><p>The maximum age of the interval in millions of years before
present.</p>
</dd>
<dt>mid_ma</dt><dd><p>The midpoint age of the interval in millions of years before
present.</p>
</dd>
<dt>min_ma</dt><dd><p>The minimum age of the interval in millions of years before
present.</p>
</dd>
<dt>duration_myr</dt><dd><p>The duration of the interval in millions of years.</p>
</dd>
<dt>font</dt><dd><p>Colour of font to use for plotting in conjunction with the
colour column.</p>
</dd>
<dt>colour</dt><dd><p>Colours of stages based on the <a href="https://stratigraphy.org/timescale/">ICS timescale</a>.</p>
</dd>
<dt>abbr</dt><dd><p>Standard abbreviations of interval names where appropiate.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gradstein, F.M., Ogg, J.G., Schmitz, M.D. and Ogg, G.M. eds. (2020).
Geologic Timescale 2020. Elsevier.
<br />
</p>


<h3>Source</h3>

<p>Compiled by Lewis A. Jones (2022-07-02) from the <a href="https://stratigraphy.org/ICSchart/ChronostratChart2020-03.pdf">ICS</a>.
</p>

<hr>
<h2 id='interval_key'>Example dataset: Interval key for the look_up function</h2><span id='topic+interval_key'></span>

<h3>Description</h3>

<p>A table of geological intervals and the earliest and latest
corresponding international geological stages from the International
Commission on Stratigraphy (ICS). The table was compiled using
regional stratigraphies, the <a href="https://timescalefoundation.org/resources/geowhen/">GeoWhen Database</a>, temporal
information from the <a href="https://paleobiodb.org/classic/displaySearchStrataForm">Paleobiology Database</a> and the
<a href="https://stratigraphy.org/ICSchart/ChronostratChart2022-10.pdf">Geological Timescale 2022</a>.
Some assignments were made with incomplete information on
the stratigraphic provenance of intervals. The assignments in this
table should be verified before research use. They are provided here
as an example of functionality only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_key
</code></pre>


<h3>Format</h3>

<p>A data frame with 1323 rows and 3 variables:
</p>

<dl>
<dt>interval_name</dt><dd><p>Stratigraphic interval</p>
</dd>
<dt>early_stage</dt><dd><p>Earliest (oldest) geological stage which overlaps with
the interval</p>
</dd>
<dt>late_stage</dt><dd><p>Latest (youngest) geological stage which overlaps with
the interval</p>
</dd>
</dl>



<h3>Source</h3>

<p>Compiled by Kilian Eichenseer and Lewis Jones for assigning
geological stages to ccurrences from the
<a href="https://paleobiodb.org">Paleobiology Database</a>
and the <a href="https://www.paleo-reefs.pal.uni-erlangen.de/">PaleoReefs Database</a>.
</p>

<hr>
<h2 id='lat_bins'>Generate latitudinal bins</h2><span id='topic+lat_bins'></span>

<h3>Description</h3>

<p>A function to generate latitudinal bins of a given size for a user-defined
latitudinal range. If the desired size of the bins is not compatible with
the defined latitudinal range, bin size can be updated to the nearest integer
which is divisible into this range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lat_bins(size = 10, max = 90, min = -90, fit = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lat_bins_+3A_size">size</code></td>
<td>
<p><code>numeric</code>. A single numeric value defining the width of the
latitudinal bins. This value must be more than 0, and less than or equal to
90 (defaults to 10).</p>
</td></tr>
<tr><td><code id="lat_bins_+3A_max">max</code></td>
<td>
<p><code>numeric</code>. A single numeric value defining the upper limit
of the latitudinal range (defaults to 90).</p>
</td></tr>
<tr><td><code id="lat_bins_+3A_min">min</code></td>
<td>
<p><code>numeric</code>. A single numeric value defining the lower limit
of the latitudinal range (defaults to -90).</p>
</td></tr>
<tr><td><code id="lat_bins_+3A_fit">fit</code></td>
<td>
<p><code>logical</code>. Should bin size be checked to ensure that the
entire latitudinal range is covered? If <code>fit = TRUE</code>, bin size is
set to the nearest integer which is divisible by the user-input range.
If <code>fit = FALSE</code>, and bin size is not divisible into the range, the
upper part of the latitudinal range will be missing.</p>
</td></tr>
<tr><td><code id="lat_bins_+3A_plot">plot</code></td>
<td>
<p><code>logical</code>. Should a plot of the latitudinal bins be
generated?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dataframe</code> of latitudinal bins of user-defined size.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Bethany Allen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 20 degrees latitudinal bins
bins &lt;- lat_bins(size = 20)

# Generate latitudinal bins with closest fit to 13 degrees
bins &lt;- lat_bins(size = 13, fit = TRUE)

# Generate latitudinal bins for defined latitudinal range
bins &lt;- lat_bins(size = 10, max = 50, min = -50)
</code></pre>

<hr>
<h2 id='look_up'>Look up geological intervals and assign geological stages</h2><span id='topic+look_up'></span>

<h3>Description</h3>

<p>A function that uses interval names to assign either
<a href="https://stratigraphy.org/ICSchart/ChronostratChart2022-02.pdf">international geological stages</a>
and numeric ages from the International Commission on Stratigraphy (ICS), or
user-defined intervals, to fossil occurrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>look_up(
  occdf,
  early_interval = "early_interval",
  late_interval = "late_interval",
  int_key = FALSE,
  assign_with_GTS = "GTS2020",
  return_unassigned = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="look_up_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of fossil occurrences or other
geological data, with columns of class <code>character</code> specifying the
earliest and the latest possible interval associated with each occurrence.</p>
</td></tr>
<tr><td><code id="look_up_+3A_early_interval">early_interval</code></td>
<td>
<p><code>character</code>. Name of the column in <code>occdf</code> that
contains the earliest interval from which the occurrences are from. Defaults
to &quot;early_interval&quot;.</p>
</td></tr>
<tr><td><code id="look_up_+3A_late_interval">late_interval</code></td>
<td>
<p><code>character</code>. Name of the column in <code>occdf</code> that
contains the latest interval from which the occurrences are from. Defaults
to &quot;late_interval&quot;.</p>
</td></tr>
<tr><td><code id="look_up_+3A_int_key">int_key</code></td>
<td>
<p><code>dataframe</code>. A dataframe linking interval names to
international geological stage names from the ICS, or other, user-defined
intervals.
This dataframe should contain the following named columns containing
<code>character</code> values: <br />
</p>

<ul>
<li> <p><code>interval_name</code> contains the names to be matched from <code>occdf</code> <br />
</p>
</li>
<li> <p><code>early_stage</code> contains the names of the earliest stages
corresponding to the intervals <br />
</p>
</li>
<li> <p><code>late_stage</code> contains the latest stage corresponding to the
intervals <br />
</p>
</li></ul>

<p>Optionally, named <code>numeric</code> columns provide maximum and minimum ages
for the intervals: <br />
</p>

<ul>
<li> <p><code>max_ma</code>
</p>
</li>
<li> <p><code>min_ma</code>
</p>
</li></ul>

<p>If set to <code>FALSE</code> (default), stages and numerical ages can be assigned
based on one of the GTS tables (see below).</p>
</td></tr>
<tr><td><code id="look_up_+3A_assign_with_gts">assign_with_GTS</code></td>
<td>
<p><code>character</code> or <code>FALSE</code>. Allows intervals to
be searched in the <code>GTS2020</code> (default) or the <code>GTS2012</code> table. Set to
<code>FALSE</code> to disable.</p>
</td></tr>
<tr><td><code id="look_up_+3A_return_unassigned">return_unassigned</code></td>
<td>
<p><code>logical</code>. Return interval names which could
not be assigned, instead of the dataframe with assignments.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>int_key</code> is set to <code>FALSE</code> (default), this function can be used to
assign numerical ages solely based on stages from a GTS table, and to assign
stages based on GTS interval names.
</p>
<p>Instead of  geological stages, the user can supply any names in the
<code>early_stage</code> and <code>late_stage</code> column of <code>int_key</code>.
<code>assign_with_GTS</code> should then be set to <code>FALSE</code>.
</p>
<p>An exemplary <code>int_key</code> has been included within this package
(<code><a href="#topic+interval_key">interval_key</a></code>). This key works well for assigning
geological stages to many of the intervals from the
<a href="https://paleobiodb.org">Paleobiology Database</a>
and the <a href="https://www.paleo-reefs.pal.uni-erlangen.de/">PaleoReefs Database</a>.
<code>palaeoverse</code> cannot guarantee that all of
the stage assignments with the exemplary key are accurate.
The table corresponding to this key can be loaded with
<code>palaeoverse::interval_key</code>.
</p>


<h3>Value</h3>

<p>A <code>dataframe</code> of the original input <code>data</code> with the following
appended columns is returned: <code>early_stage</code> and <code>late_stage</code>, corresponding
to the earliest and latest international geological stage which
could be assigned to the occurrences based on the given interval names.
<code>interval_max_ma</code> and <code>interval_min_ma</code> return maximum and minimum interval
ages if provided in the interval key, or if they can be fetched from GTS2012
or GTS2020. A column <code>interval_mid_ma</code> is appended to provide the midpoint
ages of the intervals.
</p>


<h3>Developer(s)</h3>

<p>Kilian Eichenseer &amp; William Gearty
</p>


<h3>Reviewer(s)</h3>

<p>Lewis A. Jones &amp; Christopher D. Dean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Just use GTS2020 (default):
# create exemplary dataframe
taxdf &lt;- data.frame(name = c("A", "B", "C"),
early_interval = c("Maastrichtian", "Campanian", "Sinemurian"),
late_interval = c("Maastrichtian", "Campanian", "Bartonian"))
# assign stages and numerical ages
taxdf &lt;- look_up(taxdf)

## Use exemplary int_key
# Get internal reef data
occdf &lt;- reefs
 # assign stages and numerical ages
occdf &lt;- look_up(occdf,
                early_interval = "interval",
                late_interval = "interval",
                int_key = interval_key)

## Use exemplary int_key and return unassigned
# Get internal tetrapod data
occdf &lt;- tetrapods
# assign stages and numerical ages
occdf &lt;- look_up(occdf, int_key = palaeoverse::interval_key)
# return unassigned intervals
unassigned &lt;- look_up(occdf, int_key = palaeoverse::interval_key,
                      return_unassigned = TRUE)

## Use own key and GTS2012:
# create example data
occdf &lt;- data.frame(
  stage = c("any Permian", "first Permian stage",
            "any Permian", "Roadian"))
# create example key
interval_key &lt;- data.frame(
  interval_name = c("any Permian", "first Permian stage"),
  early_stage = c("Asselian", "Asselian"),
  late_stage = c("Changhsingian", "Asselian"))
# assign stages and numerical ages:
occdf &lt;- look_up(occdf,
                 early_interval = "stage", late_interval = "stage",
                 int_key = interval_key, assign_with_GTS = "GTS2012")

</code></pre>

<hr>
<h2 id='palaeorotate'>Palaeorotate fossil occurrences</h2><span id='topic+palaeorotate'></span>

<h3>Description</h3>

<p>A function to generate palaeocoordinates for fossil occurrence data
(i.e. reconstruct the geographic distribution of organisms'
remains at time of deposition). Each occurrence is assigned
palaeocoordinates based on its current geographic position and age
estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palaeorotate(
  occdf,
  lng = "lng",
  lat = "lat",
  age = "age",
  model = "MERDITH2021",
  method = "point",
  uncertainty = TRUE,
  round = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palaeorotate_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. Fossil occurrences to be palaeogeographically
reconstructed. <code>occdf</code> should contain columns with longitudinal and
latitudinal values, as well as age estimates. The age of rotation should be
supplied in millions of years before present.</p>
</td></tr>
<tr><td><code id="palaeorotate_+3A_lng">lng</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated as
longitude (defaults to &quot;lng&quot;).</p>
</td></tr>
<tr><td><code id="palaeorotate_+3A_lat">lat</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated as
latitude (defaults to &quot;lat&quot;).</p>
</td></tr>
<tr><td><code id="palaeorotate_+3A_age">age</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated as
the age for rotation (defaults to &quot;age&quot;).</p>
</td></tr>
<tr><td><code id="palaeorotate_+3A_model">model</code></td>
<td>
<p><code>character</code>. The name(s) of the plate rotation model(s)
to be used to reconstruct palaeocoordinates. See details for available
models.</p>
</td></tr>
<tr><td><code id="palaeorotate_+3A_method">method</code></td>
<td>
<p><code>character</code>. Method used to calculate palaeocoordinates
for fossil occurrences. Either &quot;grid&quot; to use reconstruction files,
or &quot;point&quot; (default) to use the GPlates API service. See details section
for specific details.</p>
</td></tr>
<tr><td><code id="palaeorotate_+3A_uncertainty">uncertainty</code></td>
<td>
<p><code>logical</code>. Should the uncertainty in
palaeogeographic reconstructions be returned? If set to TRUE (default), the
palaeolatitudinal range and maximum geographic distance (in km) between
output palaeocoordinates are calculated. This argument is only relevant if
more than one plate rotation model is specified in <code>model</code>.</p>
</td></tr>
<tr><td><code id="palaeorotate_+3A_round">round</code></td>
<td>
<p><code>numeric</code>. Numeric value indicating the number of decimal
places <code>lng</code>, <code>lat</code> and <code>age</code> should be rounded to. This functionality is
only relevant for the &quot;point&quot; <code>method</code>. Rounding can speed up palaeorotation
by reducing the number of unique coordinate pairs. Defaults to a value of
3. If no rounding is desired, set this value to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can generate palaeocoordinates using two different
approaches (<code>method</code>):
</p>

<ul>
<li><p> Reconstruction files: The &quot;grid&quot; <code>method</code> uses reconstruction files to
spatiotemporally link present-day geographic coordinates and age estimates
with an equal-area hexagonal grid (spacing = 100 km) rotated to the
midpoint of Phanerozoic (0&ndash;540 Ma) stratigraphic stages (Geological Time
Scale, 2020). The grid was generated using the <code><a href="h3jsr.html#topic+h3jsr">h3jsr</a></code> R
package and 'h3_resolution' 3 (see <code><a href="h3jsr.html#topic+h3_info_table">h3_info_table</a></code>). If
specific ages of rotation are required, or fine-scale spatial analyses are
being conducted, use of the &quot;point&quot; <code>method</code> (see GPlates API below) is
recommended (particularly if occurrences are close to plate boundaries). As
implemented, when using the &quot;grid&quot; <code>method</code>, coordinates within the same
grid cell will be assigned equivalent palaeocoordinates due to spatial
aggregation. However, the reconstruction files provide pre-generated
palaeocoordinates enabling efficient estimation of the past distribution of
fossil occurrences. The reconstruction files along with additional
documentation are deposited on <a href="https://zenodo.org/record/7390065">Zenodo</a>.
Note: each reconstruction file is 5&ndash;10 MB in size.
</p>
</li>
<li><p> GPlates API: The &quot;point&quot; <code>method</code> uses the <a href="https://gwsdoc.gplates.org">GPlates Web Service</a> to reconstruct palaeocoordinates for point
data. The use of this <code>method</code> is slower than the &quot;grid&quot; <code>method</code> if many
unique time intervals exist in your dataset. However, it provides
palaeocoordinates with higher precision.
</p>
</li></ul>

<p>Available models and timespan for each <code>method</code>:
</p>

<ul>
<li><p> &quot;MERDITH2021&quot; (Merdith et al., 2021)
</p>

<ul>
<li><p> 0&ndash;540 Ma (grid)
</p>
</li>
<li><p> 0&ndash;1000 Ma (point)
</p>
</li></ul>

</li>
<li><p> &quot;MULLER2016&quot; (Müller et al., 2016)
</p>

<ul>
<li><p> 0&ndash;230 Ma (grid/point)
</p>
</li></ul>

</li>
<li><p> &quot;MATTHEWS2016_pmag_ref&quot;  (Matthews et al., 2016)
</p>

<ul>
<li><p> 0&ndash;410 Ma (grid/point)
</p>
</li></ul>

</li>
<li><p> &quot;SETON2012&quot; (Seton et al., 2012)
</p>

<ul>
<li><p> 0&ndash;200 Ma (grid/point)
</p>
</li></ul>

</li>
<li><p> &quot;GOLONKA&quot; (Wright et al., 2013)
</p>

<ul>
<li><p> 0&ndash;540 Ma (grid/point)
</p>
</li></ul>

</li>
<li><p> &quot;PALEOMAP&quot; (Scotese &amp; Wright, 2018)
</p>

<ul>
<li><p> 0&ndash;540 Ma (grid)
</p>
</li>
<li><p> 0&ndash;750 Ma (point)
</p>
</li></ul>

</li></ul>

<p>Access is also provided for the following mantle reference frame models.
However, they are generally not recommended for reconstructing
palaeocoordinates.
</p>

<ul>
<li><p> &quot;MULLER2022&quot; (Müller et al., 2022)
</p>

<ul>
<li><p> 0&ndash;540 Ma (grid)
</p>
</li>
<li><p> 0&ndash;1000 Ma (point)
</p>
</li></ul>

</li>
<li><p> &quot;MULLER2019&quot; (Müller et al., 2019)
</p>

<ul>
<li><p> 0&ndash;250 Ma (grid/point)
</p>
</li></ul>

</li>
<li><p> &quot;MATTHEWS2016_mantle_ref&quot; (Matthews et al., 2016)
</p>

<ul>
<li><p> 0&ndash;410 Ma (grid/point)
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A <code>dataframe</code> containing the original input occurrence
dataframe and the reconstructed coordinates (i.e. &quot;p_lng&quot;, &quot;p_lat&quot;). The
&quot;grid&quot; <code>method</code> also returns the age of rotation (&quot;rot_age&quot;) and the
reference coordinates rotated (&quot;rot_lng&quot; and &quot;rot_lat&quot;). If only one
model is requested, a column containing the rotation model used
(&quot;rot_model&quot;) is also appended. Otherwise, the name of each model is
appended to the name of each column containing palaeocoordinates (e.g.
&quot;p_lng_GOLONKA&quot;). If <code>uncertainty</code> is set to <code>TRUE</code>, the
palaeolatitudinal range (&quot;range_p_lat&quot;) and the maximum geographic
distance (&quot;max_dist&quot;) in km between palaeocoordinates will also be
returned (the latter calculated via <code><a href="geosphere.html#topic+distGeo">distGeo</a></code>).
</p>


<h3>References</h3>


<ul>
<li><p> Matthews, K.J., Maloney, K.T., Zahirovic, S., Williams, S.E., Seton, M.,
and Müller, R.D. (2016). Global plate boundary evolution and kinematics
since the late Paleozoic. Global and Planetary Change, 146, 226-250.
<a href="https://doi.org/10.1016/j.gloplacha.2016.10.002">doi:10.1016/j.gloplacha.2016.10.002</a>.
</p>
</li>
<li><p> Merdith, A., Williams, S.E., Collins, A.S., Tetley, M.G., Mulder, J.A.,
Blades, M.L., Young, A., Armistead, S.E., Cannon, J., Zahirovic, S.,
Müller. R.D. (2021).
Extending full-plate tectonic models into deep time: Linking the
Neoproterozoic and the Phanerozoic.
Earth-Science Reviews, 214(103477). <a href="https://doi.org/10.1016/j.earscirev.2020.103477">doi:10.1016/j.earscirev.2020.103477</a>.
</p>
</li>
<li><p> Müller, R. D., Flament, N., Cannon, J., Tetley, M. G., Williams,
S. E., Cao, X., Bodur, Ö. F., Zahirovic, S., and Merdith, A. (2022).
A tectonic-rules-based mantle reference frame since 1 billion years ago –
implications for supercontinent cycles and plate–mantle system evolution,
Solid Earth, 13, 1127–1159. <a href="https://doi.org/10.5194/se-13-1127-2022">doi:10.5194/se-13-1127-2022</a>.
</p>
</li>
<li><p> Müller, R. D., Zahirovic, S., Williams, S. E., Cannon, J., Seton, M.,
Bower, D. J., Tetley, M. G., Heine, C., Le Breton, E., Liu, S.,
Russell, S. H. J., Yang, T., Leonard, J., and Gurnis, M. (2019).
A global plate model including lithospheric deformation along major rifts
and orogens since the Triassic.
Tectonics, 38(6) 1884-1907. <a href="https://doi.org/10.1029/2018TC005462">doi:10.1029/2018TC005462</a>.
</p>
</li>
<li><p> Müller R.D., Seton, M., Zahirovic, S., Williams, S.E., Matthews, K.J.,
Wright, N.M., Shephard, G.E., Maloney, K.T., Barnett-Moore, N.,
Hosseinpour, M., Bower, D.J., Cannon, J. (2016).
Ocean basin evolution and global-scale plate reorganization events since
Pangea breakup. Annual Review of Earth and Planetary Sciences 44(1),
107-138. <a href="https://doi.org/10.1146/annurev-earth-060115-012211">doi:10.1146/annurev-earth-060115-012211</a>.
</p>
</li>
<li><p> Scotese, C., &amp; Wright, N. M. (2018). PALEOMAP Paleodigital Elevation Models
(PaleoDEMs) for the
Phanerozoic. <a href="https://www.earthbyte.org/paleodem-resource-scotese-and-wright-2018/">PALEOMAP Project</a>.
</p>
</li>
<li><p> Seton, M., Müller, R.D., Zahirovic, S., Gaina, C., Torsvik, T.H.,
Shephard, G., Talsma, A., Gurnis, M., Turner, M., Maus, S., Chandler, M.
(2012). Global continental and ocean basin reconstructions since 200 Ma.
Earth-Science Reviews, 113(3-4), 212-270.
<a href="https://doi.org/10.1016/j.earscirev.2012.03.002">doi:10.1016/j.earscirev.2012.03.002</a>.
</p>
</li>
<li><p> Wright, N., Zahirovic, S., Müller, R. D., &amp; Seton, M. (2013). Towards
community-driven paleogeographic
reconstructions: integrating open-access paleogeographic and paleobiology
data with plate tectonics.
Biogeosciences, 10(3), 1529-1541. <a href="https://doi.org/10.5194/bg-10-1529-2013">doi:10.5194/bg-10-1529-2013</a>.
</p>
</li></ul>

<p>See <a href="https://gwsdoc.gplates.org/reconstruction">GPlates documentation</a>
for additional information and details.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Kilian Eichenseer, Lucas Buffan &amp; Will Gearty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Generic example with a few occurrences
occdf &lt;- data.frame(lng = c(2, -103, -66),
                lat = c(46, 35, -7),
                age = c(88, 125, 200))

#Calculate palaeocoordinates using reconstruction files
ex1 &lt;- palaeorotate(occdf = occdf, method = "grid")

#Calculate palaeocoordinates using the GPlates API
ex2 &lt;- palaeorotate(occdf = occdf, method = "point")

#Calculate uncertainity in palaeocoordinates from models
ex3 &lt;- palaeorotate(occdf = occdf,
                    method = "grid",
                    model = c("MERDITH2021",
                              "GOLONKA",
                              "PALEOMAP"),
                    uncertainty = TRUE)

#Now with some real fossil occurrence data!

#Grab some data from the Paleobiology Database
data(tetrapods)

#Assign midpoint age of fossil occurrence data for reconstruction
tetrapods$age &lt;- (tetrapods$max_ma + tetrapods$min_ma)/2

#Rotate the data
ex3 &lt;- palaeorotate(occdf = tetrapods)

#Calculate uncertainity in palaeocoordinates from models
ex4 &lt;- palaeorotate(occdf = tetrapods,
                    model = c("MERDITH2021",
                              "GOLONKA",
                              "PALEOMAP"),
                    uncertainty = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='palaeoverse-package'>palaeoverse: Prepare and Explore Data for Palaeobiological Analyses</h2><span id='topic+palaeoverse'></span><span id='topic+palaeoverse-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides functionality to support data preparation and exploration for palaeobiological analyses, improving code reproducibility and accessibility. The wider aim of 'palaeoverse' is to bring the palaeobiological community together to establish agreed standards. The package currently includes functionality for data cleaning, binning (time and space), exploration, summarisation and visualisation. Reference datasets (i.e. Geological Time Scales <a href="https://stratigraphy.org/chart">https://stratigraphy.org/chart</a>) and auxiliary functions are also provided. Details can be found in: Jones et al., (2023) <a href="https://doi.org/%2010.1111/2041-210X.14099">doi: 10.1111/2041-210X.14099</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lewis A. Jones <a href="mailto:LewisAlan.Jones@uvigo.es">LewisAlan.Jones@uvigo.es</a> (<a href="https://orcid.org/0000-0003-3902-8986">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> William Gearty <a href="mailto:willgearty@gmail.com">willgearty@gmail.com</a> (<a href="https://orcid.org/0000-0003-0076-3262">ORCID</a>)
</p>
</li>
<li><p> Bethany J. Allen <a href="mailto:Bethany.Allen@bsse.ethz.ch">Bethany.Allen@bsse.ethz.ch</a> (<a href="https://orcid.org/0000-0003-0282-6407">ORCID</a>)
</p>
</li>
<li><p> Kilian Eichenseer <a href="mailto:kilian.eichenseer@gmail.com">kilian.eichenseer@gmail.com</a> (<a href="https://orcid.org/0000-0002-0477-8878">ORCID</a>)
</p>
</li>
<li><p> Christopher D. Dean <a href="mailto:christopherdaviddean@gmail.com">christopherdaviddean@gmail.com</a> (<a href="https://orcid.org/0000-0001-6471-6903">ORCID</a>)
</p>
</li>
<li><p> Joseph T. Flannery-Sutherland <a href="mailto:jf15558@bristol.ac.uk">jf15558@bristol.ac.uk</a> (<a href="https://orcid.org/0000-0001-8232-6773">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Sofia Galvan <a href="mailto:sofia.galvan@uvigo.es">sofia.galvan@uvigo.es</a> (<a href="https://orcid.org/0000-0002-3092-4314">ORCID</a>) [contributor]
</p>
</li>
<li><p> Miranta Kouvari <a href="mailto:m.kouvari@ucl.ac.uk">m.kouvari@ucl.ac.uk</a> (<a href="https://orcid.org/0000-0002-5442-6221">ORCID</a>) [contributor]
</p>
</li>
<li><p> Pedro L. Godoy <a href="mailto:pedrolorenagodoy@gmail.com">pedrolorenagodoy@gmail.com</a> (<a href="https://orcid.org/0000-0003-4519-5094">ORCID</a>) [contributor]
</p>
</li>
<li><p> Cecily Nicholl <a href="mailto:cecily.nicholl@ucl.ac.uk">cecily.nicholl@ucl.ac.uk</a> (<a href="https://orcid.org/0000-0003-2860-2604">ORCID</a>) [contributor]
</p>
</li>
<li><p> Lucas Buffan <a href="mailto:lucas.l.buffan@gmail.com">lucas.l.buffan@gmail.com</a> (<a href="https://orcid.org/0000-0002-2353-1432">ORCID</a>) [contributor]
</p>
</li>
<li><p> Erin M. Dillon <a href="mailto:emdillon23@gmail.com">emdillon23@gmail.com</a> (<a href="https://orcid.org/0000-0003-0249-027X">ORCID</a>) [contributor]
</p>
</li>
<li><p> A. Alessandro Chiarenza <a href="mailto:a.chiarenza15@gmail.com">a.chiarenza15@gmail.com</a> (<a href="https://orcid.org/0000-0001-5525-6730">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://palaeoverse.palaeoverse.org">https://palaeoverse.palaeoverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/palaeoverse-community/palaeoverse">https://github.com/palaeoverse-community/palaeoverse</a>
</p>
</li>
<li> <p><a href="https://palaeoverse.org">https://palaeoverse.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/palaeoverse-community/palaeoverse/issues">https://github.com/palaeoverse-community/palaeoverse/issues</a>
</p>
</li></ul>


<hr>
<h2 id='phylo_check'>Check phylogeny tip names</h2><span id='topic+phylo_check'></span>

<h3>Description</h3>

<p>A function to check the list of tip names in a phylogeny against a vector of
taxon names, and if desired, to trim the phylogeny to only include taxon
names within the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo_check(tree = NULL, list = NULL, out = "full_table", sort = "presence")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo_check_+3A_tree">tree</code></td>
<td>
<p><code>phylo</code>. A phylo object containing the phylogeny.</p>
</td></tr>
<tr><td><code id="phylo_check_+3A_list">list</code></td>
<td>
<p><code>character</code>. A vector of taxon names. Binomials can be
separated with either a space or an underscore. The names should not contain
any other punctuation.</p>
</td></tr>
<tr><td><code id="phylo_check_+3A_out">out</code></td>
<td>
<p><code>character</code>. Determine whether to return either a
<code>dataframe</code> describing which taxa are included or not included in the
tree (&quot;full_table&quot;, the default), the same table but with taxa included in
both the tree and the list removed (&quot;diff_table&quot;), the counts of taxa
included and not included in the tree (&quot;counts&quot;), or the phylogeny trimmed to
only include taxa in the provided list (&quot;tree&quot;).</p>
</td></tr>
<tr><td><code id="phylo_check_+3A_sort">sort</code></td>
<td>
<p><code>character</code>. If out = &quot;full_table&quot; or out = &quot;diff_table&quot;,
sort the names by presence in the tree (&quot;presence&quot;, the default), or
alphabetically (&quot;az&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Phylogenies can be read into R from .txt or .tree files containing
the Newick formatted tree using <code><a href="ape.html#topic+read.tree">ape::read.tree()</a></code>, and can be saved as
files using <code><a href="ape.html#topic+write.tree">ape::write.tree()</a></code>. When out = &quot;tree&quot;, tips are trimmed using
<code><a href="ape.html#topic+drop.tip">ape::drop.tip()</a></code>; if your tree is not ultrametric (i.e. the tip dates are
not all the same), we recommend using <code><a href="paleotree.html#topic+fixRootTime">paleotree::fixRootTime()</a></code> to readjust
your branch lengths following pruning.
</p>


<h3>Value</h3>

<p>If out = &quot;full_table&quot;, a <code>dataframe</code> describing whether taxon
names are present in the list and/or the tree. If out = &quot;diff_table&quot;, a
<code>dataframe</code> describing which taxon names are present in the list or the
tree, but not both. If out = &quot;counts&quot;, a summary table containing the number
of taxa in the list but not the tree, in the tree but not the list, and in
both. If out = &quot;tree&quot;, a phylo object consisting of the input phylogeny
trimmed to only include the tips present in the list.
</p>


<h3>Developer(s)</h3>

<p>Bethany Allen
</p>


<h3>Reviewer(s)</h3>

<p>William Gearty &amp; Pedro Godoy
</p>


<h3>Examples</h3>

<pre><code class='language-R'># track user par
oldpar &lt;- par(no.readonly = TRUE)
#Read in example tree of ceratopsians from paleotree
library(paleotree)
data(RaiaCopesRule)
#Set smaller margins for plotting
par(mar = rep(0.5, 4))
plot(ceratopsianTreeRaia)

#Specify list of names
dinosaurs &lt;- c("Nasutoceratops_titusi", "Diabloceratops_eatoni",
"Zuniceratops_christopheri", "Psittacosaurus_major",
"Psittacosaurus_sinensis", "Avaceratops_lammersi",
"Xenoceratops_foremostensis", "Leptoceratops_gracilis",
"Triceratops_horridus", "Triceratops_prorsus")

#Table of taxon names in list, tree or both
ex1 &lt;- phylo_check(tree = ceratopsianTreeRaia, list = dinosaurs)

#Counts of taxa in list, tree or both
ex2 &lt;- phylo_check(tree = ceratopsianTreeRaia, list = dinosaurs,
                   out = "counts")

#Trim tree to tips in the list
my_ceratopsians &lt;- phylo_check(tree = ceratopsianTreeRaia, list = dinosaurs,
out = "tree")
plot(my_ceratopsians)
# reset user par
par(oldpar)
</code></pre>

<hr>
<h2 id='reefs'>Example dataset: Phanerozoic reefs from the PaleoReefs Database</h2><span id='topic+reefs'></span>

<h3>Description</h3>

<p>A dataset of Phanerozoic reef occurrences from the
<a href="https://www.paleo-reefs.pal.uni-erlangen.de">PaleoReefs Database</a> (PARED).
This example dataset includes a subset of the available data from PARED,
but can be used to demonstrate how the functions in the <code>palaeoverse</code>
package might be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reefs
</code></pre>


<h3>Format</h3>

<p>A data frame with 4363 rows and 14 variables:
</p>

<dl>
<dt>r_number</dt><dd><p>Reference number given to the particular fossil
reef in PARED</p>
</dd>
<dt>name</dt><dd><p>Reference name given to the particular fossil
reef in PARED</p>
</dd>
<dt>formation</dt><dd><p>The geological formation to which the fossil
reef belongs</p>
</dd>
<dt>system</dt><dd><p>The stratigraphic system to which the fossil
reef belongs</p>
</dd>
<dt>series</dt><dd><p>The stratigraphic series to which the fossil
reef belongs</p>
</dd>
<dt>interval</dt><dd><p>The stratigraphic interval to which the fossil
reef belongs</p>
</dd>
<dt>biota_main</dt><dd><p>The main biota present within the fossil
reef</p>
</dd>
<dt>biota_sec</dt><dd><p>The secondary biota present within the fossil
reef</p>
</dd>
<dt>lng</dt><dd><p>The modern-day longitude of the fossil reef</p>
</dd>
<dt>lat</dt><dd><p>The modern-day latitude of the fossil reef</p>
</dd>
<dt>country</dt><dd><p>The country or ocean the fossil reef is located in</p>
</dd>
<dt>authors</dt><dd><p>The authors of the publication documenting the fossil reef</p>
</dd>
<dt>title</dt><dd><p>The title of the publication documenting the fossil reef</p>
</dd>
<dt>year</dt><dd><p>The year of the publication documenting the fossil reef</p>
</dd>
</dl>



<h3>References</h3>

<p>Kiessling, W. &amp; Krause, M. C. (2022). PaleoReefs Database (PARED)
(1.0) Data set. <a href="https://doi.org/10.5281/zenodo.6037852">doi:10.5281/zenodo.6037852</a>
<br />
</p>


<h3>Source</h3>

<p>Compiled by Lewis A. Jones. Downloaded on the 25th July 2022.
<a href="https://doi.org/10.5281/zenodo.6037852">doi:10.5281/zenodo.6037852</a>
</p>

<hr>
<h2 id='tax_check'>Taxonomic spell check</h2><span id='topic+tax_check'></span>

<h3>Description</h3>

<p>A function to check for and count potential spelling variations of the same
taxon. Spelling variations are checked within alphabetical groups (default),
or within higher taxonomic groups if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tax_check(
  taxdf,
  name = "genus",
  group = NULL,
  dis = 0.05,
  start = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tax_check_+3A_taxdf">taxdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe with named columns containing
taxon names (e.g. &quot;species&quot;, &quot;genus&quot;). An optional column
containing the groups (e.g. &quot;family&quot;, &quot;order&quot;) which taxon names
belong to may also be provided (see <code>group</code> for details).
NA values or empty strings in the name and group columns (i.e. &quot;&quot; and &quot; &quot;)
are ignored.</p>
</td></tr>
<tr><td><code id="tax_check_+3A_name">name</code></td>
<td>
<p><code>character</code>. The column name of the taxon names you wish
to check (e.g. &quot;genus&quot;).</p>
</td></tr>
<tr><td><code id="tax_check_+3A_group">group</code></td>
<td>
<p><code>character</code>. The column name of the higher taxonomic
assignments in <code>taxdf</code> you wish to group by. If <code>NULL</code> (default), name
comparison will be conducted within alphabetical groups.</p>
</td></tr>
<tr><td><code id="tax_check_+3A_dis">dis</code></td>
<td>
<p><code>numeric</code>. The dissimilarity threshold: a value greater than
0 (completely dissimilar), and less than 1 (completely similar).
Potential synonyms above this threshold are not returned.
This value is set to 0.05 by default, but the user might wish to experiment
with this value for their specific data.</p>
</td></tr>
<tr><td><code id="tax_check_+3A_start">start</code></td>
<td>
<p><code>numeric</code>. The number of shared characters at the
beginning of potential synonyms that should match. Potential synonyms below
this value will not be returned. By default this value is set to 1 (i.e.
the first letter of synonyms must match).</p>
</td></tr>
<tr><td><code id="tax_check_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>. Should the results of the non-letter
character check be reported to the user? If <code>TRUE</code>, the result will only be
reported if such characters are detected in the taxon names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When higher taxonomy is provided, but some entries are missing,
comparisons will still be made within alphabetical groups of taxa which lack
higher taxonomic affiliations. The function also performs a check for
non-letter characters which are not expected to be present in
correctly-formatted taxon names. This detection may be made available to the
user via the <code>verbose</code> argument. Comparisons are performed using the
Jaro dissimilarity metric via
<code><a href="stringdist.html#topic+stringdistmatrix">stringdist::stringdistmatrix()</a></code>.
</p>
<p>As all string distance metrics rely on approximate string matching,
different metrics can produce different results. This function uses Jaro
distance as it was designed with short, typed strings in mind, but good
practice should include comparisons using multiple metrics, and ultimately
specific taxonomic vetting where possible. A more complete implementation
and workflow for cleaning taxonomic occurrence data is available in the
<code>fossilbrush</code> R package on CRAN.
</p>


<h3>Value</h3>

<p>If verbose = <code>TRUE</code> (default), a <code>list</code> with three elements. The
first element in the list (synonyms) is a <code>data.frame</code> with each row
reporting a pair of potential synonyms. The first column &quot;group&quot; contains the
higher group in which they occur (alphabetical groupings if <code>group</code> is
not provided). The second column &quot;greater&quot; contains the most common synonym
in each pair. The third column &quot;lesser&quot; contains the least common synonym in
each pair. The third and fourth column (<code>count_greater</code>, <code>count_lesser</code>)
contain the respective counts of each synonym in a pair. If no matches were
found for the filtering arguments, this element is <code>NULL</code> instead. The second
element (<code>non_letter_name</code>) is a vector of taxon names which contain
non-letter characters, or <code>NULL</code> if none were detected. The third element
(non_letter_group) is a vector of taxon groups which contain non-letter
characters, or <code>NULL</code> if none were detected. If verbose = <code>FALSE</code>, a
<code>data.frame</code> as described above is returned, or <code>NULL</code> if no matches
were found.
</p>


<h3>Reference</h3>

<p>van der Loo, M. P. J. (2014). The stringdist package for approximate string
matching. The R Journal 6, 111-122.
</p>


<h3>Developer(s)</h3>

<p>Joseph T. Flannery-Sutherland &amp; Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Lewis A. Jones, Kilian Eichenseer &amp; Christopher D. Dean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load occurrence data
data("tetrapods")
# Check taxon names alphabetically
ex1 &lt;- tax_check(taxdf = tetrapods, name = "genus", dis = 0.1)
# Check taxon names by group
ex2 &lt;- tax_check(taxdf = tetrapods, name = "genus",
                 group = "family", dis = 0.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='tax_expand_lat'>Generate pseudo-occurrences from latitudinal range data</h2><span id='topic+tax_expand_lat'></span>

<h3>Description</h3>

<p>A function to generate pseudo-occurrences for taxa based on latitudinal
ranges (e.g. the output of the 'lat' method in
<code><a href="#topic+tax_range_space">tax_range_space</a></code>).
While the resulting pseudo-occurrences should not be treated as equivalent
to actual occurrence data (e.g. like that from the Paleobiology Database),
such pseudo-occurrences may be useful for  performing statistical analyses
where the row representing a taxon must be replicated for each latitudinal
bin through which the taxon ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tax_expand_lat(taxdf, bins, max_lat = "max_lat", min_lat = "min_lat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tax_expand_lat_+3A_taxdf">taxdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of taxa (such as the
output of the 'lat' method in <code><a href="#topic+tax_range_space">tax_range_space</a></code>) with columns
containing latitudinal range data (maximum and minimum latitude). Column
names are assumed to be &quot;max_lat&quot; and &quot;min_lat&quot;, but may be updated via the
<code>max_lat</code> and <code>min_lat</code> arguments.
Each row should represent a unique taxon. Additional columns may be included
(e.g. taxon names, additional taxonomy, etc) and will be included in the
returned <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="tax_expand_lat_+3A_bins">bins</code></td>
<td>
<p><code>dataframe</code>. A dataframe of the bins that you wish to
allocate fossil occurrences to, such as that returned by
<code><a href="#topic+lat_bins">lat_bins</a></code>. This dataframe must contain at least the following
named columns: &quot;bin&quot;, &quot;max&quot; and &quot;min&quot;.</p>
</td></tr>
<tr><td><code id="tax_expand_lat_+3A_max_lat">max_lat</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be
treated as the maximum latitude of the latitudinal range (e.g. &quot;max_lat&quot;).</p>
</td></tr>
<tr><td><code id="tax_expand_lat_+3A_min_lat">min_lat</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be
treated as the minimum latitude of the latitudinal range (e.g. &quot;min_lat&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dataframe</code> where each row represents a latitudinal bin which
a taxon ranges through. The columns are identical to those in the
user-supplied data with additional columns included to identify bins. Output
will be returned in the order of supplied bins.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones &amp; William Gearty
</p>


<h3>Reviewer(s)</h3>

<p>Christopher D. Dean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bins &lt;- lat_bins()
taxdf &lt;- data.frame(name = c("A", "B", "C"),
                    max_lat = c(60, 20, -10),
                    min_lat = c(20, -40, -60))
ex &lt;- tax_expand_lat(taxdf = taxdf,
                     bins = bins,
                     max_lat = "max_lat",
                     min_lat = "min_lat")
</code></pre>

<hr>
<h2 id='tax_expand_time'>Generate pseudo-occurrences from temporal range data</h2><span id='topic+tax_expand_time'></span>

<h3>Description</h3>

<p>A function to generate interval-level pseudo-occurrences for taxa based on
temporal ranges (e.g. the output of <code><a href="#topic+tax_range_time">tax_range_time</a></code>). While the
resulting pseudo-occurrences should not be treated as equivalent to actual
occurrence data (e.g. like that from the Paleobiology Database), such
pseudo-occurrences may be useful for performing statistical analyses where
the row representing a taxon must be replicated for each interval through
which the taxon persisted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tax_expand_time(
  taxdf,
  max_ma = "max_ma",
  min_ma = "min_ma",
  scale = "GTS2020",
  rank = "stage",
  ext_orig = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tax_expand_time_+3A_taxdf">taxdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of taxa (such as that
produced by <code><a href="#topic+tax_range_time">tax_range_time</a></code>) with columns for the maximum and
minimum ages (FADs and LADs). Each row should represent a unique taxon.
Additional columns may be included (e.g. taxon names, additional taxonomy,
etc) and will be included in the returned <code>data.frame</code>. If required,
<code>numeric</code> ages can be generated from interval names via the
<code><a href="#topic+look_up">look_up</a></code> function.</p>
</td></tr>
<tr><td><code id="tax_expand_time_+3A_max_ma">max_ma</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the maximum limit (FADs) of the age range (e.g. &quot;max_ma&quot;).</p>
</td></tr>
<tr><td><code id="tax_expand_time_+3A_min_ma">min_ma</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the minimum limit (LADs) of the age range (e.g. &quot;min_ma&quot;).</p>
</td></tr>
<tr><td><code id="tax_expand_time_+3A_scale">scale</code></td>
<td>
<p><code>character</code>. Specify the desired geological timescale to
be used, either &quot;GTS2020&quot; or &quot;GTS2012&quot;.</p>
</td></tr>
<tr><td><code id="tax_expand_time_+3A_rank">rank</code></td>
<td>
<p><code>character</code>. Specify the desired stratigraphic rank. Choose
from: &quot;stage&quot;, &quot;epoch&quot;, &quot;period&quot;, &quot;era&quot;, and &quot;eon&quot;.</p>
</td></tr>
<tr><td><code id="tax_expand_time_+3A_ext_orig">ext_orig</code></td>
<td>
<p><code>logical</code>. Should two additional columns be added to
identify the intervals in which taxa originated and went extinct?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dataframe</code> where each row represents an interval during which
a taxon in the original user-supplied data persisted. The columns are
identical to those in the user-supplied data with additional columns
included to identify the intervals. If <code>ext_orig</code> is <code>TRUE</code>,
two additional columns are added to identify in which intervals taxa
originated and went extinct.
</p>


<h3>Developer(s)</h3>

<p>William Gearty &amp; Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Lewis A. Jones
</p>


<h3>Examples</h3>

<pre><code class='language-R'>taxdf &lt;- data.frame(name = c("A", "B", "C"),
                    max_ma = c(150, 60, 30),
                    min_ma = c(110, 20, 0))
ex &lt;- tax_expand_time(taxdf)
</code></pre>

<hr>
<h2 id='tax_range_space'>Calculate the geographic range of fossil taxa</h2><span id='topic+tax_range_space'></span>

<h3>Description</h3>

<p>A function to calculate the geographic range of fossil taxa from occurrence
data. The function can calculate geographic range in four ways: convex
hull, latitudinal range, maximum Great Circle Distance, and the number of
occupied equal-area hexagonal grid cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tax_range_space(
  occdf,
  name = "genus",
  lng = "lng",
  lat = "lat",
  method = "lat",
  spacing = 100,
  coords = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tax_range_space_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of fossil occurrences. This
dataframe should contain at least three columns: names of taxa, longitude
and latitude (see <code>name</code>, <code>lng</code>, and <code>lat</code> arguments).</p>
</td></tr>
<tr><td><code id="tax_range_space_+3A_name">name</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the input names (e.g. &quot;species&quot; or &quot;genus&quot;). NA data should be removed
prior to function call.</p>
</td></tr>
<tr><td><code id="tax_range_space_+3A_lng">lng</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the input longitude (e.g. &quot;lng&quot; or &quot;p_lng&quot;). NA data should be removed
prior to function call.</p>
</td></tr>
<tr><td><code id="tax_range_space_+3A_lat">lat</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the input latitude (e.g. &quot;lat&quot; or &quot;p_lat&quot;). NA data should be removed
prior to function call.</p>
</td></tr>
<tr><td><code id="tax_range_space_+3A_method">method</code></td>
<td>
<p><code>character</code>. How should geographic range be calculated
for each taxon in <code>occdf</code>? Four options exist in this function: &quot;con&quot;,
&quot;lat&quot;, &quot;gcd&quot;, and &quot;occ&quot;. See Details for a description of each.</p>
</td></tr>
<tr><td><code id="tax_range_space_+3A_spacing">spacing</code></td>
<td>
<p><code>numeric</code>. The desired spacing (in km) between the
center of adjacent grid cells. Only required if the <code>method</code> argument is
set to &quot;occ&quot;. The default is 100.</p>
</td></tr>
<tr><td><code id="tax_range_space_+3A_coords">coords</code></td>
<td>
<p><code>logical</code>. Should the output coordinates be returned for
the &quot;con&quot; and &quot;gcd&quot; <code>method</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four commonly applied approaches (Darroch et al. 2020)
are available using the <code>tax_range_space</code> function for calculating ranges:
</p>

<ul>
<li><p> Convex hull: the &quot;con&quot; method calculates the geographic range of taxa
using a convex hull for each taxon in <code>occdf</code>, and calculates the area of
the convex hull (in km<sup>2</sup>) using
<code><a href="geosphere.html#topic+areaPolygon">geosphere::areaPolygon()</a></code>. The
convex hull method works by creating a polygon that encompasses all
occurrence points of the taxon.
</p>
</li>
<li><p> Latitudinal: the &quot;lat&quot; method calculates the palaeolatitudinal
range of a taxon. It does so for each taxon in <code>occdf</code> by finding their
maximum and minimum latitudinal occurrence (from input <code>lat</code>).
The palaeolatitudinal range of each taxon is also calculated (i.e. the
difference between the minimum and maximum latitude).
</p>
</li>
<li><p> Maximum Great Circle Distance: the &quot;gcd&quot; method calculates the maximum
Great Circle Distance between occurrences for each taxon in <code>occdf</code>. It does
so using <code><a href="geosphere.html#topic+distHaversine">geosphere::distHaversine()</a></code>.
This function calculates Great Circle Distance using the Haversine method
with the radius of the Earth set to the 6378.137 km.
Great Circle Distance represents the shortest distance between two
points on the surface of a sphere. This is different from Euclidean Distance,
which represents the distance between two points on a plane.
</p>
</li>
<li><p> Occupied cells: the &quot;occ&quot; method calculates the number and proportion of
occupied equal-area grid cells. It does so using discrete hexagonal grids
via the <code><a href="h3jsr.html#topic+h3jsr">h3jsr</a></code> package. This package relies on
<a href="https://h3geo.org/docs/">Uber's H3</a> library, a geospatial indexing system
that partitions the world into hexagonal cells. In H3, 16 different
resolutions are available
(<a href="https://h3geo.org/docs/core-library/restable/">see here</a>).
In the implementation of the <code>tax_range_space()</code> function, the resolution is
defined by the user-input <code>spacing</code> which represents the distance between
the centroid of adjacent cells. Using this distance, the function identifies
which resolution is most similar to the input <code>spacing</code>, and uses this
resolution.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>dataframe</code> with method-specific columns:
</p>

<ul>
<li><p> For the &quot;con&quot; method, a <code>dataframe</code> with each unique taxa (<code>taxon</code>)
and taxon ID (<code>taxon_id</code>) by convex hull coordinate (<code>lng</code> &amp; <code>lat</code>)
combination, and area (<code>area</code>) in
km<sup>2</sup> is returned.
</p>
</li>
<li><p> For the &quot;lat&quot; method, a <code>dataframe</code> with unique taxa (<code>taxon</code>),
taxon ID (<code>taxon_id</code>), maximum latitude of occurrence (<code>max_lat</code>),
minimum latitude of occurrence (<code>min_lat</code>), and latitudinal
range (<code>range_lat</code>) is returned.
</p>
</li>
<li><p> For the &quot;gcd&quot; method, a <code>dataframe</code> with each unique taxa (<code>taxon</code>)
and taxon ID (<code>taxon_id</code>) by coordinate combination (<code>lng</code> &amp; <code>lat</code>) of the
two most distant points, and the Great Circle Distance (<code>gcd</code>) between
these points in km is returned.
</p>
</li>
<li><p> For the &quot;occ&quot; method, a <code>dataframe</code> with unique taxa (<code>taxon</code>), taxon
ID (<code>taxon_id</code>), the number of occupied cells (<code>n_cells</code>), proportion of
occupied cells from all occupied by occurrences (<code>proportional_occ</code>),
and the spacing between cells (<code>spacing</code>) in km is returned. Note: the number
of occupied cells and proportion of occupied cells is highly dependent on
the user-defined <code>spacing.</code>
For the &quot;con&quot;, &quot;lat&quot; and &quot;gcd&quot; method, values of zero indicate that the
respective taxon is a singleton (i.e. represented by only one occurrence).
</p>
</li></ul>



<h3>Reference(s)</h3>

<p>Darroch, S. A., Casey, M. M., Antell, G. S., Sweeney, A., &amp; Saupe, E. E.
(2020). High preservation potential of paleogeographic range size
distributions in deep time. The American Naturalist, 196(4), 454-471.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Bethany Allen &amp; Christopher D. Dean
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grab internal data
occdf &lt;- tetrapods[1:100, ]
# Remove NAs
occdf &lt;- subset(occdf, !is.na(genus))
# Convex hull
ex1 &lt;- tax_range_space(occdf = occdf, name = "genus", method = "con")
# Latitudinal range
ex2 &lt;- tax_range_space(occdf = occdf, name = "genus", method = "lat")
# Great Circle Distance
ex3 &lt;- tax_range_space(occdf = occdf, name = "genus", method = "gcd")
# Occupied grid cells
ex4 &lt;- tax_range_space(occdf = occdf, name = "genus",
                       method = "occ", spacing = 500)
# Convex hull with coordinates
ex5 &lt;- tax_range_space(occdf = occdf, name = "genus", method = "con",
coords = TRUE)
</code></pre>

<hr>
<h2 id='tax_range_time'>Calculate the temporal range of fossil taxa</h2><span id='topic+tax_range_time'></span>

<h3>Description</h3>

<p>A function to calculate the temporal range of fossil taxa from occurrence
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tax_range_time(
  occdf,
  name = "genus",
  min_ma = "min_ma",
  max_ma = "max_ma",
  by = "FAD",
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tax_range_time_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe of fossil occurrences containing
at least three columns: names of taxa, maximum age and minimum age
(see <code>name</code>, <code>min_ma</code>, and <code>max_ma</code> arguments).
These ages should constrain the age range of the fossil occurrence
and are assumed to be in millions of years before present.</p>
</td></tr>
<tr><td><code id="tax_range_time_+3A_name">name</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the input names, e.g. &quot;genus&quot; (default).</p>
</td></tr>
<tr><td><code id="tax_range_time_+3A_min_ma">min_ma</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the minimum limit of the age range, e.g. &quot;min_ma&quot; (default).</p>
</td></tr>
<tr><td><code id="tax_range_time_+3A_max_ma">max_ma</code></td>
<td>
<p><code>character</code>. The name of the column you wish to be treated
as the maximum limit of the age range, e.g. &quot;max_ma&quot; (default).</p>
</td></tr>
<tr><td><code id="tax_range_time_+3A_by">by</code></td>
<td>
<p><code>character</code>. How should the output be sorted?
Either: &quot;FAD&quot; (first-appearance date; default), &quot;LAD&quot; (last-appearance data),
or &quot;name&quot; (alphabetically by taxon names).</p>
</td></tr>
<tr><td><code id="tax_range_time_+3A_plot">plot</code></td>
<td>
<p><code>logical</code>. Should a plot of the ranges be generated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The temporal range(s) of taxa are calculated by extracting all
unique taxa (<code>name</code> column) from the input <code>occdf</code>, and checking their first
and last appearance. The temporal duration of each taxon is also calculated.
A plot of the temporal range of each taxon is also returned if <code>plot = TRUE</code>.
If the input data columns contain NAs, these should be removed prior to
function call.
</p>
<p>Note: this function provides output based solely on the user input data. The
true duration of a taxon is likely confounded by uncertainty in dating
occurrences, and incomplete sampling and preservation.
</p>


<h3>Value</h3>

<p>A <code>dataframe</code> containing the following columns:
unique taxa (<code>taxon</code>), taxon ID (<code>taxon_id</code>), first appearance of taxon
(<code>max_ma</code>), last appearance of taxon (<code>min_ma</code>), duration of temporal
range (<code>range_myr</code>), and number of occurrences per taxon (<code>n_occ</code>) is
returned.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Bethany Allen &amp; Christopher D. Dean
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grab internal data
occdf &lt;- tetrapods
# Remove NAs
occdf &lt;- subset(occdf, !is.na(order) &amp; order != "NO_ORDER_SPECIFIED")
# Temporal range
ex &lt;- tax_range_time(occdf = occdf, name = "order", plot = TRUE)

</code></pre>

<hr>
<h2 id='tax_unique'>Filter occurrences to unique taxa</h2><span id='topic+tax_unique'></span>

<h3>Description</h3>

<p>A function to filter a list of taxonomic occurrences to unique taxa of a
predefined resolution. Occurrences identified to a coarser taxonomic
resolution than the desired level are retained if they belong to a clade
which is not otherwise represented in the dataset (see details section for
further information). This has previously been described as &quot;cryptic
diversity&quot; (e.g. Mannion et al. 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tax_unique(
  occdf = NULL,
  binomial = NULL,
  species = NULL,
  genus = NULL,
  ...,
  name = NULL,
  resolution = "species",
  append = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tax_unique_+3A_occdf">occdf</code></td>
<td>
<p><code>dataframe</code>. A dataframe containing information on the
occurrences or taxa to filter.</p>
</td></tr>
<tr><td><code id="tax_unique_+3A_binomial">binomial</code></td>
<td>
<p><code>character</code>. The name of the column in <code>occdf</code>
containing the genus and species names of the occurrences, either in the
form &quot;genus species&quot; or &quot;genus_species&quot;.</p>
</td></tr>
<tr><td><code id="tax_unique_+3A_species">species</code></td>
<td>
<p><code>character</code>. The name of the column in <code>occdf</code>
containing the species-level identifications (i.e. the specific epithet).</p>
</td></tr>
<tr><td><code id="tax_unique_+3A_genus">genus</code></td>
<td>
<p><code>character</code>. The name of the column in <code>occdf</code>
containing the genus-level identifications.</p>
</td></tr>
<tr><td><code id="tax_unique_+3A_...">...</code></td>
<td>
<p><code>character</code>. Other named arguments specifying columns of
higher levels of taxonomy (e.g. subfamily, order, superclass). The names of
the arguments will be the column names of the output, and the values of the
arguments correspond to the columns of <code>occdf</code>. The given order of the
arguments is the order in which they are filtered. Therefore, these arguments
must be in ascending order from lowest to highest taxonomic rank (see
examples below). At least one higher level of taxonomy must be specified.</p>
</td></tr>
<tr><td><code id="tax_unique_+3A_name">name</code></td>
<td>
<p><code>character</code>. The name of the column in <code>occdf</code>
containing the taxonomic names at mixed taxonomic levels; the data column
&quot;accepted_name&quot; in a <a href="https://paleobiodb.org/#/">Paleobiology Database</a>
occurrence dataframe is of this type.</p>
</td></tr>
<tr><td><code id="tax_unique_+3A_resolution">resolution</code></td>
<td>
<p><code>character</code>. The taxonomic resolution at which to
identify unique occurrences, either &quot;species&quot; (the default) or &quot;genus&quot;.</p>
</td></tr>
<tr><td><code id="tax_unique_+3A_append">append</code></td>
<td>
<p><code>logical</code>. Should the original dataframe be returned with
the unique names appended as a new column?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Palaeobiologists usually count unique taxa by retaining only
unique occurrences identified to a given taxonomic resolution, however
this function retains occurrences identified to a coarser taxonomic
resolution which are not already represented within the dataset. For example,
consider the following set of occurrences:
</p>

<ul>
<li> <p><em>Albertosaurus sarcophagus</em>
</p>
</li>
<li> <p><em>Ankylosaurus</em> sp.
</p>
</li>
<li><p> Aves indet.
</p>
</li>
<li><p> Ceratopsidae indet.
</p>
</li>
<li><p> Hadrosauridae indet.
</p>
</li>
<li> <p><em>Ornithomimus</em> sp.
</p>
</li>
<li> <p><em>Tyrannosaurus rex</em>
</p>
</li></ul>

<p>A filter for species-level identifications would reduce the species richness
to two. However, none of these clades are nested within one another, so each
of the indeterminately identified occurrences represents at least one species
not already represented in the dataset. This function is designed to deal
with such taxonomic data, and would retain all seven 'species' in this
example.
</p>
<p>Taxonomic information is supplied within a dataframe, in which columns
provide identifications at different taxonomic levels. Occurrence
data can be filtered to retain either unique species, or unique genera. If a
species-level filter is desired, the minimum input requires either (1)
<code>binomial</code>, (2) <code>species</code> and <code>genus</code>, or (3) <code>name</code> and <code>genus</code> columns to
be entered, as well as at least one column of a higher taxonomic level.
In a standard <a href="https://paleobiodb.org/#/">Paleobiology Database</a>
occurrence dataframe, species names are only
captured in the 'accepted_name' column, so a species-level filter should use
'<code>genus</code> = &quot;genus&quot;' and '<code>name</code> = &quot;accepted_name&quot;' arguments. If a
genus-level filter is desired, the minimum input requires either (1)
<code>binomial</code> or (2) <code>genus</code> columns to be entered, as well as at least one
column of a higher taxonomic level.
</p>
<p>Missing data should be indicated with NAs, although the function can handle
common labels such as &quot;NO_FAMILY_SPECIFIED&quot; within Paleobiology Database
datasets.
</p>
<p>The function matches taxonomic names at face value, so homonyms may be
falsely filtered out.
</p>


<h3>Value</h3>

<p>A <code>dataframe</code> of taxa, with each row corresponding to a unique
&quot;species&quot; or &quot;genus&quot; in the dataset (depending on the chosen resolution).
The dataframe will include the taxonomic information provided into the
function, as well as a column providing the 'unique' names of each taxon. If
<code>append</code> is <code>TRUE</code>, the original dataframe (<code>occdf</code>) will be
returned with these 'unique' names appended as a new column. Occurrences that
are identified to a coarse taxonomic resolution and belong to a clade which
is already represented within the dataset will have their 'unique' names
listed as <code>NA</code>.
</p>


<h3>References</h3>

<p>Mannion, P. D., Upchurch, P., Carrano, M. T., and Barrett, P. M. (2011).
Testing the effect of the rock record on diversity: a multidisciplinary
approach to elucidating the generic richness of sauropodomorph dinosaurs
through time.
Biological Reviews, 86, 157-181. <a href="https://doi.org/10.1111/j.1469-185X.2010.00139.x">doi:10.1111/j.1469-185X.2010.00139.x</a>.
</p>


<h3>Developer(s)</h3>

<p>Bethany Allen &amp; William Gearty
</p>


<h3>Reviewer(s)</h3>

<p>Lewis A. Jones &amp; William Gearty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Retain unique species
occdf &lt;- tetrapods[1:100, ]
species &lt;- tax_unique(occdf = occdf, genus = "genus", family = "family",
order = "order", class = "class", name = "accepted_name")

#Retain unique genera
genera &lt;- tax_unique(occdf = occdf, genus = "genus", family = "family",
order = "order", class = "class", resolution = "genus")

#Append unique names to the original occurrences
genera_append &lt;- tax_unique(occdf = occdf, genus = "genus", family = "family",
order = "order", class = "class", resolution = "genus", append = TRUE)

#Create dataframe from lists
occdf2 &lt;- data.frame(species = c("rex", "aegyptiacus", NA), genus =
c("Tyrannosaurus", "Spinosaurus", NA), family = c("Tyrannosauridae",
"Spinosauridae", "Diplodocidae"))
dinosaur_species &lt;- tax_unique(occdf = occdf2, species = "species", genus =
"genus", family = "family")

#Retain unique genera per collection with group_apply
genera &lt;- group_apply(occdf = occdf,
                     group = c("collection_no"),
                     fun = tax_unique,
                     genus = "genus",
                     family = "family",
                     order = "order",
                     class = "class",
                     resolution = "genus")

</code></pre>

<hr>
<h2 id='tetrapods'>Example dataset: Early tetrapod data from the Paleobiology Database</h2><span id='topic+tetrapods'></span>

<h3>Description</h3>

<p>A dataset of tetrapod occurrences ranging from the Carboniferous through to
the Early Triassic, from the
<a href="https://paleobiodb.org/">Palaeobiology Database</a>. Dataset includes a
range of variables relevant to common palaeobiological analyses, relating to
identification, geography, environmental context, traits and more. Additional
information can be found <a href="https://paleobiodb.org/data1.2/">here</a>.
The downloaded data is unaltered, with the exception of removing some
superfluous variables, and can be used to demonstrate how the functions
in the palaeoverse package might be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tetrapods
</code></pre>


<h3>Format</h3>

<p>A data frame with 5270 rows and 32 variables:
</p>

<dl>
<dt>occurrence_no</dt><dd><p>Reference number given to the particular occurrence in
the Paleobiology Database</p>
</dd>
<dt>collection_no</dt><dd><p>Reference number given to the Paleobiology Database
collection (locality) that the occurrence belongs to</p>
</dd>
<dt>identified_name</dt><dd><p>Taxon name as it appears in the original
publication, which may include expressions of uncertainty (e.g. &quot;cf.&quot;,
&quot;aff.&quot;, &quot;?&quot;) or novelty (e.g. &quot;n. gen.&quot;, &quot;n. sp.&quot;)</p>
</dd>
<dt>identified_rank</dt><dd><p>The taxonomic rank, or resolution, of the identified
name</p>
</dd>
<dt>accepted_name</dt><dd><p>Taxon name once the identified name has passed through
the Paleobiology Database's internal taxonomy, which collapses synonyms,
amends binomials which have been altered (e.g. species moving to another
genus) and updates taxa which are no longer valid (e.g. <em>nomina dubia</em>)</p>
</dd>
<dt>accepted_rank</dt><dd><p>The taxonomic rank, or resolution, of the accepted
name</p>
</dd>
<dt>early_interval</dt><dd><p>The oldest (or only) time interval within which the
occurrence is thought to have been deposited</p>
</dd>
<dt>late_interval</dt><dd><p>The youngest time interval within which the occurrence
is thought to have been deposited</p>
</dd>
<dt>max_ma, min_ma</dt><dd><p>The age range given to the occurrence</p>
</dd>
<dt>phylum, class, order, family, genus</dt><dd><p>The taxa (of decreasing
taxonomic level) which the occurrence is identified as belonging to</p>
</dd>
<dt>abund_value, abund_unit</dt><dd><p>The number (and units) of fossils attributed
to the occurrence</p>
</dd>
<dt>lng, lat</dt><dd><p>The modern-day longitude and latitude of the fossil
locality</p>
</dd>
<dt>collection_name</dt><dd><p>The name of the Paleobiology Database collection
which the occurrence belongs to, typically a spatio-temporally restricted
locality</p>
</dd>
<dt>cc</dt><dd><p>The country (code) where the fossils were discovered</p>
</dd>
<dt>formation, stratgroup, member</dt><dd><p>The geological units from which the
fossils were collected</p>
</dd>
<dt>zone</dt><dd><p>The biozone which the occurrence is attributed to</p>
</dd>
<dt>lithology1</dt><dd><p>The main lithology of the beds in the section where the
fossils were collected</p>
</dd>
<dt>environment</dt><dd><p>The inferred environmental conditions in the place of
deposition</p>
</dd>
<dt>pres_mode</dt><dd><p>The mode of preservation of the fossils found in the
collection (not necessarily of that specific occurrence), which will
include information on whether they are body or trace fossils</p>
</dd>
<dt>taxon_environment</dt><dd><p>The environment within which the taxon is thought
to have lived, collated within the Paleobiology Database</p>
</dd>
<dt>motility, life_habit, diet</dt><dd><p>Various types of trait data for the
taxon, collated within the Paleobiology Database</p>
</dd>
</dl>



<h3>References</h3>

<p>Uhen MD et al. (in prep). Paleobiology Database User Guide.
<br />
</p>


<h3>Source</h3>

<p>Compiled by Bethany Allen, current version downloaded on 14th July
2022. See item descriptions for details.
</p>

<hr>
<h2 id='time_bins'>Generate time bins</h2><span id='topic+time_bins'></span>

<h3>Description</h3>

<p>A function to generate time bins for a given study interval and geological
timescale. This function is flexible in that either stage-level or higher
stratigraphic-level (e.g. period) time bins can be called, valid timescales
from <a href="https://macrostrat.org/api/defs/timescales?all">Macrostrat</a> can be
used, or a <code>data.frame</code> of a geological timescale can be provided. In
addition, near equal-length time bins can be generated by grouping
intervals together. For example, for a target bin size of 10 Myr, the
function will generate groups of bins that have a mean bin length close to
10 Myr. However, users may also want to consider grouping stages based on
other reasoning e.g. availability of outcrop (see Dean et al. 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_bins(
  interval = "Phanerozoic",
  rank = "stage",
  size = NULL,
  assign = NULL,
  scale = "GTS2020",
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_bins_+3A_interval">interval</code></td>
<td>
<p><code>character or numeric</code>. Interval name available in
<code><a href="#topic+GTS2020">GTS2020</a></code> or <code><a href="#topic+GTS2012">GTS2012</a></code>. If a single interval name
is provided, this interval is returned. If two interval names are
provided, these intervals and those existing between are returned. If a
single numeric age is provided, the interval that covers this age is
returned. If two numeric ages are provided, the intervals occurring in
the range of these ages are returned. Defaults to &quot;Phanerozoic&quot;. This
argument is ignored if <code>scale</code> is not &quot;GTS2020&quot; or &quot;GTS2012&quot;.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_rank">rank</code></td>
<td>
<p><code>character</code>. Which stratigraphic rank is desired? Choose
from: &quot;stage&quot;, &quot;epoch&quot;, &quot;period&quot;, &quot;era&quot;, and &quot;eon&quot;. This argument is
ignored if <code>scale</code> is not &quot;GTS2020&quot; or &quot;GTS2012&quot;.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_size">size</code></td>
<td>
<p><code>numeric</code>. If equal-length time bins are desired, specify
the length in millions of years (Myr) of the time bins desired.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_assign">assign</code></td>
<td>
<p><code>numeric</code>. A numeric vector of age estimates to use to
assign to requested bins. If assign is specified, a numeric vector is
returned of the midpoint age of the specified bins. Note this is the
simplified approach of assignment in <code>palaeoverse</code> included for data with
'known' point-age estimates. For a wider range of binning methods, see
<code><a href="#topic+bin_time">palaeoverse::bin_time()</a></code>.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_scale">scale</code></td>
<td>
<p><code>character</code> or <code>data.frame</code>. Specify the desired
geological timescale to be used: &quot;GTS2020&quot; (default), &quot;GTS2012&quot;, a valid
timescale from
<a href="https://macrostrat.org/api/defs/timescales?all">Macrostrat</a>, or
user-input <code>data.frame</code>. If a <code>data.frame</code> is provided, it must contain
at least the following named columns: &quot;interval_name&quot;, &quot;max_ma&quot;, and
&quot;min_ma&quot;. As such, age data should be provided in Ma.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_plot">plot</code></td>
<td>
<p><code>logical</code>. Should a plot of time bins be generated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses either the Geological Time Scale 2020,
Geological Time Scale 2012, a valid timescale from
<a href="https://macrostrat.org/api/defs/timescales?all">Macrostrat</a>, or a
user-input <code>data.frame</code> (see <code>scale</code> argument) to generate time bins.
Additional information on included Geological Time Scales and source can
be accessed via:
</p>

<ul>
<li> <p><code><a href="#topic+GTS2020">GTS2020</a></code>
</p>
</li>
<li> <p><code><a href="#topic+GTS2012">GTS2012</a></code>
</p>
</li></ul>

<p>Available interval names are accessible via the <code>interval_name</code> column
in <code>GTS2012</code> and <code>GTS2020</code>. Data of the Geological Timescale 2020 and
2012 were compiled by Lewis A. Jones (2022-07-02).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of time bins for the specified intervals or a
list with a <code>data.frame</code> of time bins and a named <code>numeric</code>
vector (bin number) of binned age estimates (midpoint of specified bins)
if <code>assign</code> is specified. By default, the time bins <code>data.frame</code>
contains the following columns: bin, interval_name, rank, max_ma, mid_ma,
min_ma, duration_myr, abbr (interval abbreviation), colour and font
(colour). If <code>size</code> is specified, the time bins <code>data.frame</code>
contains the following columns: bin, max_ma, mid_ma, min_ma,
duration_myr, grouping_rank, intervals, colour and font.
</p>


<h3>References</h3>

<p>Dean, C.D., Chiarenza, A.A. and Maidment, S.C., 2020. Formation binning: a
new method for increased temporal resolution in regional studies, applied
to the Late Cretaceous dinosaur fossil record of North America.
Palaeontology, 63(6), 881-901. <a href="https://doi.org/10.1111/pala.12492">doi:10.1111/pala.12492</a>.
</p>


<h3>Developer(s)</h3>

<p>Lewis A. Jones
</p>


<h3>Reviewer(s)</h3>

<p>Kilian Eichenseer &amp; William Gearty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Using numeric age
ex1 &lt;- time_bins(interval = 10, plot = TRUE)

#Using numeric age range
ex2 &lt;- time_bins(interval = c(50, 100), plot = TRUE)

#Using a single interval name
ex3 &lt;- time_bins(interval = c("Maastrichtian"), plot = TRUE)

#Using a range of intervals and near-equal duration bins
ex4 &lt;- time_bins(interval = c("Fortunian", "Meghalayan"),
                 size = 10, plot = TRUE)

#Assign bins based on given age estimates
ex5 &lt;- time_bins(interval = c("Fortunian", "Meghalayan"),
                 assign = c(232, 167, 33))

#Use user-input data.frame to generate near-equal length bins
scale &lt;- data.frame(interval_name = 1:5,
                    min_ma = c(0, 18, 32, 38, 45),
                    max_ma = c(18, 32, 38, 45, 53))
ex6 &lt;- time_bins(scale = scale, size = 20, plot = TRUE)

#Use North American land mammal ages from Macrostrat
ex7 &lt;- time_bins(scale = "North American land mammal ages", size = 10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
