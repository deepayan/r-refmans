<!DOCTYPE html><html><head><title>Help for package specr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {specr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_tibble.specr.object'><p>Return tibble from specr.object</p></a></li>
<li><a href='#as_tibble.specr.setup'><p>Return tibble from specr.setup object</p></a></li>
<li><a href='#as.data.frame.specr.object'><p>Return data.frame from specr.object</p></a></li>
<li><a href='#as.data.frame.specr.setup'><p>Return tibble from specr.setup object</p></a></li>
<li><a href='#example_data'><p>Example data set</p></a></li>
<li><a href='#icc_specs'><p>Compute intraclass correlation coefficient</p></a></li>
<li><a href='#plot_choices'><p>Plot how analytical choices affect results</p></a></li>
<li><a href='#plot_curve'><p>Plot ranked specification curve</p></a></li>
<li><a href='#plot_decisiontree'><p>Plot decision tree</p></a></li>
<li><a href='#plot_samplesizes'><p>Plot sample sizes</p></a></li>
<li><a href='#plot_specs'><p>Plot specification curve and analytical choices</p></a></li>
<li><a href='#plot_summary'><p>Create box plots for given analytical choices</p></a></li>
<li><a href='#plot_variance'><p>Plot variance decomposition</p></a></li>
<li><a href='#plot.specr.object'><p>Plot specification curve and analytic choices</p></a></li>
<li><a href='#plot.specr.setup'><p>Plot visualization of the specification setup</p></a></li>
<li><a href='#print.specr.object'><p>Print method for S3 class &quot;specr.object&quot;</p></a></li>
<li><a href='#print.specr.setup'><p>Print method for S3 class &quot;specr.setup&quot;</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#run_specs'><p>Estimate all specifications</p></a></li>
<li><a href='#setup'><p>Specifying analytical decisions in a specification setup</p></a></li>
<li><a href='#setup_specs'><p>Set up specifications</p></a></li>
<li><a href='#specr'><p>Fit models across all specifications</p></a></li>
<li><a href='#summarise_specs'><p>Summarise specifications</p></a></li>
<li><a href='#summary.specr.object'><p>Summarizing the Specification Curve Analysis</p></a></li>
<li><a href='#summary.specr.setup'><p>Summarizing the Specifications Setup</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Conducting and Visualizing Specification Curve Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utilities for conducting specification curve analyses (Simonsohn, Simmons &amp; Nelson (2020, &lt;<a href="https://doi.org/10.1038%2Fs41562-020-0912-z">doi:10.1038/s41562-020-0912-z</a>&gt;) or multiverse analyses (Steegen, Tuerlinckx, Gelman &amp; Vanpaemel, 2016, &lt;<a href="https://doi.org/10.1177%2F1745691616658637">doi:10.1177/1745691616658637</a>&gt;) including functions to setup, run, evaluate, and plot all specifications.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://masurp.github.io/specr/">https://masurp.github.io/specr/</a>, <a href="https://github.com/masurp/specr">https://github.com/masurp/specr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/masurp/specr/issues">https://github.com/masurp/specr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, cowplot, dplyr, furrr, future, ggplot2, ggraph, glue,
igraph, lifecycle, lme4, magrittr, methods, parallelly, purrr,
rlang, stringr, tibble, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>broom.mixed, gapminder, ggridges, knitr, lavaan, testthat,
tidyverse, performance, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-20 13:17:23 UTC; philippmasur</td>
</tr>
<tr>
<td>Author:</td>
<td>Philipp K. Masur <a href="https://orcid.org/0000-0003-3065-7305"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Michael Scharkow [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philipp K. Masur &lt;phil.masur@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-20 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_tibble.specr.object'>Return tibble from specr.object</h2><span id='topic+as_tibble.specr.object'></span>

<h3>Description</h3>

<p>Return tibble from specr.object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.object'
as_tibble(x, ...)
</code></pre>

<hr>
<h2 id='as_tibble.specr.setup'>Return tibble from specr.setup object</h2><span id='topic+as_tibble.specr.setup'></span>

<h3>Description</h3>

<p>Return tibble from specr.setup object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.setup'
as_tibble(x, ...)
</code></pre>

<hr>
<h2 id='as.data.frame.specr.object'>Return data.frame from specr.object</h2><span id='topic+as.data.frame.specr.object'></span>

<h3>Description</h3>

<p>Return data.frame from specr.object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.object'
as.data.frame(x, ...)
</code></pre>

<hr>
<h2 id='as.data.frame.specr.setup'>Return tibble from specr.setup object</h2><span id='topic+as.data.frame.specr.setup'></span>

<h3>Description</h3>

<p>Return tibble from specr.setup object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.setup'
as.data.frame(x, ...)
</code></pre>

<hr>
<h2 id='example_data'>Example data set</h2><span id='topic+example_data'></span>

<h3>Description</h3>

<p>This simulated data set can be used to explore the major function of 'specr'.
It provides variables that can be used to mimic different independent and dependent variables,
control variables, and grouping variables (for subset analyses).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_data)
</code></pre>


<h3>Format</h3>

<p>A tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data)
head(example_data)
</code></pre>

<hr>
<h2 id='icc_specs'>Compute intraclass correlation coefficient</h2><span id='topic+icc_specs'></span>

<h3>Description</h3>

<p>This function extracts intraclass correlation coefficients (ICC) from a multilevel model. It can be used to decompose the variance in the outcome variable of a specification curve analysis (e.g., the regression coefficients). This approach summarises the relative importance of analytical choices by estimating the share of variance in the outcome (e.g., the regression coefficient) that different analytical choices or combinations therefor account for. To use this approach, one needs to estimate a multilevel model that includes all analytical choices as grouping variables (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icc_specs(model, percent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icc_specs_+3A_model">model</code></td>
<td>
<p>a multilevel (i.e., mixed effects) model that captures the variances of the specification curve.</p>
</td></tr>
<tr><td><code id="icc_specs_+3A_percent">percent</code></td>
<td>
<p>a logical value indicating whether the ICC should also be printed as percentage. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="tibble.html#topic+tibble-package">tibble</a> including the grouping variable, the random effect variances, the raw intraclass correlation coefficient (ICC), and the ICC in percent.
</p>


<h3>References</h3>


<ul>
<li><p> Hox, J. J. (2010). Multilevel analysis: techniques and applications. New York: Routledge.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_variance">plot_variance()</a></code> to plot the variance decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Step 1: Run spec curve analysis
results &lt;- run_specs(df = example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = c("lm"))

# Step 2: Estimate a multilevel model without predictors
model &lt;- lme4::lmer(estimate ~ 1 + (1|x)  + (1|y), data = results)

# Step 3: Estimate intra-class correlation
icc_specs(model)

</code></pre>

<hr>
<h2 id='plot_choices'>Plot how analytical choices affect results</h2><span id='topic+plot_choices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated because the new version of specr uses a new analytic framework.
In this framework, you can plot a similar figure simply by using the generic <code>plot()</code> function.
and adding the argument <code>type = "choices"</code>.
This functions plots how analytic choices affect the obtained results (i.e., the rank within the curve). Significant results are highlighted (negative = red, positive = blue, grey = nonsignificant). This functions creates the lower panel in <code>plot_specs()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_choices(
  df,
  var = .data$estimate,
  group = NULL,
  choices = c("x", "y", "model", "controls", "subsets"),
  desc = FALSE,
  null = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_choices_+3A_df">df</code></td>
<td>
<p>a data frame resulting from <code>run_specs()</code>.</p>
</td></tr>
<tr><td><code id="plot_choices_+3A_var">var</code></td>
<td>
<p>which variable should be evaluated? Defaults to estimate (the effect sizes computed by <code><a href="#topic+run_specs">run_specs()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_choices_+3A_group">group</code></td>
<td>
<p>Should the arrangement of the curve be grouped by a particular choice?
Defaults to NULL, but can be any of the present choices (e.g., x, y, controls...)</p>
</td></tr>
<tr><td><code id="plot_choices_+3A_choices">choices</code></td>
<td>
<p>a vector specifying which analytical choices should be plotted. By default, all choices are plotted.</p>
</td></tr>
<tr><td><code id="plot_choices_+3A_desc">desc</code></td>
<td>
<p>logical value indicating whether the curve should the arranged in a descending order. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot_choices_+3A_null">null</code></td>
<td>
<p>Indicate what value represents the 'null' hypothesis (Defaults to zero).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run specification curve analysis
results &lt;- run_specs(df = example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = c("lm"),
                     controls = c("c1", "c2"),
                     subsets = list(group1 = unique(example_data$group1),
                                    group2 = unique(example_data$group2)))

# Plot simple table of choices
plot_choices(results)

# Plot only specific choices
plot_choices(results,
             choices = c("x", "y", "controls"))
</code></pre>

<hr>
<h2 id='plot_curve'>Plot ranked specification curve</h2><span id='topic+plot_curve'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated because the new version of specr uses a new analytic framework.
In this framework, you can plot a similar figure simply by using the generic <code>plot()</code> function and
adding the argument <code>type = "curve"</code>.
This function plots the a ranked specification curve. Confidence intervals can be included. Significant results are highlighted (negative = red, positive = blue, grey = nonsignificant). This functions creates the upper panel in <code>plot_specs()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_curve(
  df,
  var = .data$estimate,
  group = NULL,
  desc = FALSE,
  ci = TRUE,
  ribbon = FALSE,
  legend = FALSE,
  null = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_curve_+3A_df">df</code></td>
<td>
<p>a data frame resulting from <code>run_specs()</code>.</p>
</td></tr>
<tr><td><code id="plot_curve_+3A_var">var</code></td>
<td>
<p>which variable should be evaluated? Defaults to estimate (the effect sizes computed by <code><a href="#topic+run_specs">run_specs()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_curve_+3A_group">group</code></td>
<td>
<p>Should the arrangement of the curve be grouped by a particular choice?
Defaults to NULL, but can be any of the present choices (e.g., x, y, controls...)</p>
</td></tr>
<tr><td><code id="plot_curve_+3A_desc">desc</code></td>
<td>
<p>logical value indicating whether the curve should the arranged in a descending order. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot_curve_+3A_ci">ci</code></td>
<td>
<p>logical value indicating whether confidence intervals should be plotted.</p>
</td></tr>
<tr><td><code id="plot_curve_+3A_ribbon">ribbon</code></td>
<td>
<p>logical value indicating whether a ribbon instead should be plotted.</p>
</td></tr>
<tr><td><code id="plot_curve_+3A_legend">legend</code></td>
<td>
<p>logical value indicating whether the legend should be plotted Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot_curve_+3A_null">null</code></td>
<td>
<p>Indicate what value represents the null hypothesis (Defaults to zero)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load additional library
library(ggplot2) # for further customization of the plots

# Run specification curve analysis
results &lt;- run_specs(df = example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = c("lm"),
                     controls = c("c1", "c2"),
                     subsets = list(group1 = unique(example_data$group1),
                                    group2 = unique(example_data$group2)))

# Plot simple specification curve
plot_curve(results)

# Ribbon instead of CIs and customize further
plot_curve(results, ci = FALSE, ribbon = TRUE) +
  geom_hline(yintercept = 0) +
  geom_hline(yintercept = median(results$estimate),
             linetype = "dashed") +
  theme_linedraw()
</code></pre>

<hr>
<h2 id='plot_decisiontree'>Plot decision tree</h2><span id='topic+plot_decisiontree'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated because the new version of specr uses a new analytic framework.
In this framework, you can plot a similar figure simply by using the generic <code>plot()</code>.
This function plots a simple decision tree that is meant to help understanding how few analytical choices may results in a large number of specifications. It is somewhat useless if the final number of specifications is very high.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_decisiontree(df, label = FALSE, legend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_decisiontree_+3A_df">df</code></td>
<td>
<p>data frame resulting from <code><a href="#topic+run_specs">run_specs()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_decisiontree_+3A_label">label</code></td>
<td>
<p>Logical. Should labels be included? Defaults to FALSE. Produces only a reasonable plot if number of specifications is low.</p>
</td></tr>
<tr><td><code id="plot_decisiontree_+3A_legend">legend</code></td>
<td>
<p>Logical. Should specific decisions be identifiable. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>results &lt;- run_specs(df = example_data,
                    y = c("y1", "y2"),
                    x = c("x1", "x2"),
                    model = c("lm"),
                    controls = c("c1", "c2"))

# Basic, non-labelled decisions tree
plot_decisiontree(results)

# Labelled decisions tree
plot_decisiontree(results, label = TRUE)

# Add legend
plot_decisiontree(results, label = TRUE, legend = TRUE)
</code></pre>

<hr>
<h2 id='plot_samplesizes'>Plot sample sizes</h2><span id='topic+plot_samplesizes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated because the new version of specr uses a new analytic framework.
In this framework, you can plot a similar figure simply by using the generic <code>plot()</code>
function and adding the argument <code>type = "samplesizes"</code>. This function plots a histogram
of sample sizes per specification. It can be added to the overall specification curve
plot (see vignettes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_samplesizes(df, var = .data$estimate, group = NULL, desc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_samplesizes_+3A_df">df</code></td>
<td>
<p>a data frame resulting from <code>run_specs()</code>.</p>
</td></tr>
<tr><td><code id="plot_samplesizes_+3A_var">var</code></td>
<td>
<p>which variable should be evaluated? Defaults to estimate (the effect sizes computed by <code><a href="#topic+run_specs">run_specs()</a></code>).</p>
</td></tr>
<tr><td><code id="plot_samplesizes_+3A_group">group</code></td>
<td>
<p>Should the arrangement of the curve be grouped by a particular choice?
Defaults to NULL, but can be any of the present choices (e.g., x, y, controls...)</p>
</td></tr>
<tr><td><code id="plot_samplesizes_+3A_desc">desc</code></td>
<td>
<p>logical value indicating whether the curve should the arranged in a descending order. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load additional library
library(ggplot2) # for further customization of the plots

# run specification curve analysis
results &lt;- run_specs(df = example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = c("lm"),
                     controls = c("c1", "c2"),
                     subsets = list(group1 = unique(example_data$group1),
                                    group2 = unique(example_data$group2)))
# plot ranked bar chart of sample sizes
plot_samplesizes(results)

# add a horizontal line for the median sample size
plot_samplesizes(results) +
  geom_hline(yintercept = median(results$fit_nobs),
             color = "darkgrey",
             linetype = "dashed") +
  theme_linedraw()
</code></pre>

<hr>
<h2 id='plot_specs'>Plot specification curve and analytical choices</h2><span id='topic+plot_specs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated because the new version of specr uses a new analytic framework.
In this framework, you can plot a similar figure simply by using the generic <code>plot()</code>
function and adding the argument <code>type = "default"</code>.This function plots an entire visualization of the specification curve analysis.
The function uses the entire <a href="tibble.html#topic+tibble-package">tibble</a> that is produced by
<code>run_specs()</code> to create a standard visualization of the specification curve analysis.
Alternatively, one can also pass two separately created <a href="ggplot2.html#topic+ggplot">ggplot</a> objects
to the function. In this case, it simply combines them using <code>cowplot::plot_grid</code>.
Significant results are highlighted (negative = red, positive = blue, grey = nonsignificant).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_specs(
  df = NULL,
  plot_a = NULL,
  plot_b = NULL,
  choices = c("x", "y", "model", "controls", "subsets"),
  labels = c("A", "B"),
  rel_heights = c(2, 3),
  desc = FALSE,
  null = 0,
  ci = TRUE,
  ribbon = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_specs_+3A_df">df</code></td>
<td>
<p>a data frame resulting from <code>run_specs()</code>.</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_plot_a">plot_a</code></td>
<td>
<p>a ggplot object resulting from <code>plot_curve()</code> (or <code>plot_choices()</code> respectively).</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_plot_b">plot_b</code></td>
<td>
<p>a ggplot object resulting from <code>plot_choices()</code> (or <code>plot_curve()</code> respectively).</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_choices">choices</code></td>
<td>
<p>a vector specifying which analytical choices should be plotted. By default, all choices are plotted.</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_labels">labels</code></td>
<td>
<p>labels for the two parts of the plot</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_rel_heights">rel_heights</code></td>
<td>
<p>vector indicating the relative heights of the plot.</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_desc">desc</code></td>
<td>
<p>logical value indicating whether the curve should the arranged in
a descending order. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_null">null</code></td>
<td>
<p>Indicate what value represents the 'null' hypothesis (defaults to
zero).</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_ci">ci</code></td>
<td>
<p>logical value indicating whether confidence intervals should be
plotted.</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_ribbon">ribbon</code></td>
<td>
<p>logical value indicating whether a ribbon instead should be
plotted.</p>
</td></tr>
<tr><td><code id="plot_specs_+3A_...">...</code></td>
<td>
<p>additional arguments that can be passed to <code>plot_grid()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+plot_curve">plot_curve()</a></code> to plot only the specification curve.
</p>
</li>
<li> <p><code><a href="#topic+plot_choices">plot_choices()</a></code> to plot only the choices panel.
</p>
</li>
<li> <p><code><a href="#topic+plot_samplesizes">plot_samplesizes()</a></code> to plot a histogram of sample sizes per specification.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># load additional library
library(ggplot2) # for further customization of the plots

# run spec analysis
results &lt;- run_specs(example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = "lm",
                     controls = c("c1", "c2"),
                     subset = list(group1 = unique(example_data$group1)))

# plot results directly
plot_specs(results)

# Customize each part and then combine
p1 &lt;- plot_curve(results) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  ylim(-3, 12) +
  labs(x = "", y = "regression coefficient")

p2 &lt;- plot_choices(results) +
  labs(x = "specifications (ranked)")

plot_specs(plot_a = p1,    # arguments must be called directly!
           plot_b = p2,
           rel_height = c(2, 2))
</code></pre>

<hr>
<h2 id='plot_summary'>Create box plots for given analytical choices</h2><span id='topic+plot_summary'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated because the new version of specr uses a new analytic framework.
In this framework, you can plot a similar figure simply by using the generic <code>plot()</code> function and adding the argument <code>type = "boxplot"</code>.
This function provides a convenient way to visually investigate the effect of individual choices on the estimate of interest. It produces box-and-whisker plot(s) for each provided analytical choice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_summary(df, choices = c("x", "y", "model", "controls", "subsets"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_summary_+3A_df">df</code></td>
<td>
<p>a data frame resulting from <code>run_specs()</code>.</p>
</td></tr>
<tr><td><code id="plot_summary_+3A_choices">choices</code></td>
<td>
<p>a vector specifying which analytical choices should be plotted. By default, all choices are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summarise_specs">summarise_specs()</a></code> to investigate the affect of analytical choices in more detail.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># run spec analysis
results &lt;- run_specs(example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = "lm",
                     controls = c("c1", "c2"),
                     subset = list(group1 = unique(example_data$group1)))

# plot boxplot comparing specific choices
plot_summary(results, choices = c("subsets", "controls", "y"))
</code></pre>

<hr>
<h2 id='plot_variance'>Plot variance decomposition</h2><span id='topic+plot_variance'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated because the new version of specr uses a new analytic framework.
In this framework, you can plot a similar figure simply by using the generic <code>plot()</code>
function and adding the argument <code>type = "variance"</code>. This functions creates a simple
barplot that visually displays how much variance in the outcome (e.g., the regression coefficient)
different analytical choices or combinations therefor account for. To use this approach,
one needs to estimate a multilevel model that includes all analytical choices as
grouping variables (see examples and vignettes). This function uses <code><a href="#topic+icc_specs">icc_specs()</a></code>
to compute the intraclass correlation coefficients (ICCs), which provides the data
basis for the plot (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_variance(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_variance_+3A_model">model</code></td>
<td>
<p>a multilevel model that captures the variances of the specification curve (based on the data frame resulting from <code>run_specs</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="ggplot2.html#topic+ggplot">ggplot</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icc_specs">icc_specs()</a></code> to produce a tibble that details the variance decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Step 1: Run spec curve analysis
results &lt;- run_specs(df = example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = c("lm"))

# Step 2: Estimate multilevel model
library(lme4, quietly = TRUE)
model &lt;- lmer(estimate ~ 1 + (1|x)  + (1|y), data = results)

# Step 3: Plot model
plot_variance(model)

</code></pre>

<hr>
<h2 id='plot.specr.object'>Plot specification curve and analytic choices</h2><span id='topic+plot.specr.object'></span>

<h3>Description</h3>

<p>This function plots visualizations of the specification curve
analysis. The function requires an object of class <code>specr.object</code>, usually
the results of calling <code>specr()</code> to create a standard visualization of the
specification curve analysis. Several types of visualizations are possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.object'
plot(
  x,
  type = "default",
  var = .data$estimate,
  group = NULL,
  choices = c("x", "y", "model", "controls", "subsets"),
  labels = c("A", "B"),
  rel_heights = c(2, 3),
  desc = FALSE,
  null = 0,
  ci = TRUE,
  ribbon = FALSE,
  formula = NULL,
  print = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.specr.object_+3A_x">x</code></td>
<td>
<p>A <code>specr.object</code> object, usually resulting from calling <code>specr()</code>.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_type">type</code></td>
<td>
<p>What type of figure should be plotted? If <code>type = "default"</code>,
the standard specification curve analysis plot (the specification curve as the
upper panel and an overview of the relevant choices as the lower panel) is
created. If <code>type = "curve"</code>, only the specification curve (upper panel
of the default plot) is plotted. If <code>type = "choices"</code>, only the choice
panel (lower part of the default plot) is plotted. If <code>type = "boxplot"</code>,
an alternative visualization of differences between choices is plotted that
summarizes results per choice using box-and-whisker plot(s). If
<code>type = "samplesizes"</code>, a barplot of sample sizes per specification is
plotted.  See examples for more information.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_var">var</code></td>
<td>
<p>Which parameter should be plotted in the curve? Defaults to
<code>estimate</code>, but other parameters (e.g., p.value, fit_r.squared,...)
can be plotted too.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_group">group</code></td>
<td>
<p>Should the arrangement of the curve be grouped by a particular choice?
Defaults to NULL, but can be any of the present choices (e.g., x, y, controls...)</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_choices">choices</code></td>
<td>
<p>A vector specifying which analytic choices should be plotted.
By default, all choices (x, y, model, controls, subsets) are plotted.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_labels">labels</code></td>
<td>
<p>Labels for the two parts of the plot</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_rel_heights">rel_heights</code></td>
<td>
<p>vector indicating the relative heights of the plot.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_desc">desc</code></td>
<td>
<p>Logical value indicating whether the curve should the arranged in
a descending order. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_null">null</code></td>
<td>
<p>Indicate what value represents the 'null' hypothesis (defaults to
zero).</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_ci">ci</code></td>
<td>
<p>Logical value indicating whether confidence intervals should be
plotted.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_ribbon">ribbon</code></td>
<td>
<p>Logical value indicating whether a ribbon instead should be
plotted</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_formula">formula</code></td>
<td>
<p>In combination with <code>type = "variance"</code>, you can provide
a specific formula to extract specific variance components. The syntax of the
formula is based on <code>lme4::lmer()</code> and thus looks something like, e.g.:
<code>"estimate ~ 1 + (1|x) + (1|y)"</code> (to estimate the amount of variance
explained by different independent <code>x</code> and dependent variables <code>y</code>). All other
choices are then subsumed under residual variance. By no formula is provided,
all choices (x, y, model, controls, and subsets) that have more than one alternative
are included. See examples for further details.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_print">print</code></td>
<td>
<p>In combination with <code>type = "variance"</code>, logical value indicating
whether the intra-class correlations (i.e., percentages of variance explained by
analstical choices) should be printed or not. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.specr.object_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot</a> object that can be customized further.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Specification Curve analysis ----
# Setup specifications
specs &lt;- setup(data = example_data,
   y = c("y1", "y2"),
   x = c("x1", "x2"),
   model = "lm",
   controls = c("c1", "c2"),
   subsets = list(group1 = unique(example_data$group1),
                  group2 = unique(example_data$group2)))

# Run analysis
results &lt;- specr(specs)

# Resulting data frame with estimates
as_tibble(results)  # This will be used for plotting


# Visualizations ---
# Plot results in various ways
plot(results)                            # default
plot(results, choices = c("x", "y"))     # specific choices
plot(results, ci = FALSE, ribbon = TRUE) # exclude CI and add ribbon instead
plot(results, type = "curve")
plot(results, type = "choices")
plot(results, type = "samplesizes")
plot(results, type = "boxplot")


# Grouped plot
plot(results, group = controls)

# Alternative and specific visualizations ----
# Other variables in the resulting data set can be plotted too
plot(results,
     type = "curve",
     var = fit_r.squared,   # extract "r-square" instead of "estimate"
     ci = FALSE)

# Such a plot can also be extended (e.g., by again adding the estimates with
# confidence intervals)
library(ggplot2)
plot(results, type = "curve", var = fit_r.squared) +
  geom_point(aes(y = estimate), shape = 5) +
  labs(x = "specifications", y = "r-squared | estimate")

# We can also investigate how much variance is explained by each analytical choice
plot(results, type = "variance")

# By providing a specific formula in `lme4::lmer()`-style, we can extract specific choices
# and also include interactions between chocies
plot(results,
     type = "variance",
     formula = "estimate ~ 1 + (1|x) + (1|y) + (1|group1) + (1|x:y)")

## Combining several plots ----
# `specr` also exports the function `plot_grid()` from the package `cowplot`, which
# can be used to combine plots meaningfully
a &lt;- plot(results, "curve")
b &lt;- plot(results, "choices", choices = c("x", "y", "controls"))
c &lt;- plot(results, "samplesizes")
plot_grid(a, b, c,
          align = "v",
          axis = "rbl",
          rel_heights = c(2, 3, 1),
          ncol = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.specr.setup'>Plot visualization of the specification setup</h2><span id='topic+plot.specr.setup'></span>

<h3>Description</h3>

<p>This function plots a visual summary of the specification setup.
It requires an object of class <code>specr.setup</code>, usually
the result of calling <code>setup()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.setup'
plot(x, layout = "dendrogram", circular = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.specr.setup_+3A_x">x</code></td>
<td>
<p>A <code>specr.setup</code> object, usually resulting from calling <code>setup()</code>.</p>
</td></tr>
<tr><td><code id="plot.specr.setup_+3A_layout">layout</code></td>
<td>
<p>The type of layout to create for the garden of forking path. Defaults to &quot;dendrogram&quot;. See <code>?ggraph</code> for options.</p>
</td></tr>
<tr><td><code id="plot.specr.setup_+3A_circular">circular</code></td>
<td>
<p>Should the layout be transformed into a radial representation. Only possible for some layouts. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.specr.setup_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="ggplot2.html#topic+ggplot">ggplot</a> object that can be customized further.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
specs &lt;- setup(data = example_data,
   x = c("x1", "x2", "x3"),
   y = c("y1", "y2"),
   model = c("lm", "glm"),
   controls = "c1",
   subsets = list(group2 = unique(example_data$group2)))

plot(specs)
plot(specs, circular = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.specr.object'>Print method for S3 class &quot;specr.object&quot;</h2><span id='topic+print.specr.object'></span>

<h3>Description</h3>

<p>Print method for S3 class &quot;specr.object&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.object'
print(x, ...)
</code></pre>

<hr>
<h2 id='print.specr.setup'>Print method for S3 class &quot;specr.setup&quot;</h2><span id='topic+print.specr.setup'></span>

<h3>Description</h3>

<p>Print method for S3 class &quot;specr.setup&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.setup'
print(x, ...)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+as_tibble'></span><span id='topic+plot_grid'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>cowplot</dt><dd><p><code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
</dl>

<hr>
<h2 id='run_specs'>Estimate all specifications</h2><span id='topic+run_specs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated because the new version of specr uses different analytical framework. In this framework, you should use the function <code><a href="#topic+setup">setup()</a></code> first and then run all specifications using <code><a href="#topic+specr">specr()</a></code>.
This is the central function of the package. It runs the specification curve analysis. It takes the data frame and vectors for analytical choices related to the dependent variable, the independent variable, the type of models that should be estimated, the set of covariates that should be included (none, each individually, and all together), as well as a named list of potential subsets. The function returns a tidy tibble which includes relevant model parameters for each specification. The function <a href="broom.html#topic+tidy">tidy</a> is used to extract relevant model parameters. Exactly what tidy considers to be a model component varies across models but is usually self-evident.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_specs(
  df,
  x,
  y,
  model = "lm",
  controls = NULL,
  subsets = NULL,
  all.comb = FALSE,
  conf.level = 0.95,
  keep.results = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_specs_+3A_df">df</code></td>
<td>
<p>a data frame that includes all relevant variables</p>
</td></tr>
<tr><td><code id="run_specs_+3A_x">x</code></td>
<td>
<p>a vector denoting independent variables</p>
</td></tr>
<tr><td><code id="run_specs_+3A_y">y</code></td>
<td>
<p>a vector denoting the dependent variables</p>
</td></tr>
<tr><td><code id="run_specs_+3A_model">model</code></td>
<td>
<p>a vector denoting the model(s) that should be estimated.</p>
</td></tr>
<tr><td><code id="run_specs_+3A_controls">controls</code></td>
<td>
<p>a vector denoting which control variables should be included. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="run_specs_+3A_subsets">subsets</code></td>
<td>
<p>a named list that includes potential subsets that should be evaluated (see examples). Defaults to NULL.</p>
</td></tr>
<tr><td><code id="run_specs_+3A_all.comb">all.comb</code></td>
<td>
<p>a logical value indicating what type of combinations of the control variables should be specified. Defaults to FALSE (i.e., none, all, and each individually). If this argument is set to TRUE, all possible combinations between the control variables are specified (see examples).</p>
</td></tr>
<tr><td><code id="run_specs_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level to use for the confidence interval. Must be strictly greater than 0 and less than 1. Defaults to .95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="run_specs_+3A_keep.results">keep.results</code></td>
<td>
<p>a logical value indicating whether the complete model object should be kept. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="tibble.html#topic+tibble-package">tibble</a> that includes all specifications and a tidy summary of model components.
</p>


<h3>References</h3>


<ul>
<li><p> Simonsohn, U., Simmons, J. P., &amp; Nelson, L. D. (2019). Specification Curve: Descriptive and Inferential Statistics for all Plausible Specifications. Available at: https://doi.org/10.2139/ssrn.2694998
</p>
</li>
<li><p> Steegen, S., Tuerlinckx, F., Gelman, A., &amp; Vanpaemel, W. (2016). Increasing Transparency Through a Multiverse Analysis. Perspectives on Psychological Science, 11(5), 702-712. https://doi.org/10.1177/1745691616658637
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot_specs">plot_specs()</a></code> to visualize the results of the specification curve analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># run specification curve analysis
results &lt;- run_specs(df = example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = c("lm"),
                     controls = c("c1", "c2"),
                     subsets = list(group1 = unique(example_data$group1),
                                    group2 = unique(example_data$group2)))

# Check results frame
results

</code></pre>

<hr>
<h2 id='setup'>Specifying analytical decisions in a specification setup</h2><span id='topic+setup'></span>

<h3>Description</h3>

<p>Creates all possible specifications as a combination of
different dependent and independent variables, model types, control
variables, potential subset analyses, as well as potentially other
analytic choices. This function represents the first step in the
analytic framework implemented in the package <code>specr</code>. The resulting
class <code>specr.setup</code> then needs to be passed to the core function of
the package called <code>specr()</code>, which fits the specified models across
all specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup(
  data,
  x,
  y,
  model,
  controls = NULL,
  subsets = NULL,
  add_to_formula = NULL,
  fun1 = function(x) broom::tidy(x, conf.int = TRUE),
  fun2 = function(x) broom::glance(x),
  simplify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_+3A_data">data</code></td>
<td>
<p>The data set that should be used for the analysis</p>
</td></tr>
<tr><td><code id="setup_+3A_x">x</code></td>
<td>
<p>A vector denoting independent variables</p>
</td></tr>
<tr><td><code id="setup_+3A_y">y</code></td>
<td>
<p>A vector denoting the dependent variables</p>
</td></tr>
<tr><td><code id="setup_+3A_model">model</code></td>
<td>
<p>A vector denoting the model(s) that should be estimated.</p>
</td></tr>
<tr><td><code id="setup_+3A_controls">controls</code></td>
<td>
<p>A vector of the control variables that should be included.
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="setup_+3A_subsets">subsets</code></td>
<td>
<p>Specification of potential subsets/groups as list.  There are two ways
in which these can be specified that both start from the assumption that the
&quot;grouping&quot; variable is in the data set. The simplest way is to provide a named
vector within the list, whose name is the variable that should be used for
subsetting and whose values are the values that reflect the subsets (e.g.,
<code style="white-space: pre;">&#8288;list(group2 = c("female", "male")&#8288;</code>). In this case, the specifications will
includes &quot;all&quot;, &quot;only female&quot; and &quot;only male&quot;. Alternatively, you can also use
the <code>unique</code> function to extract that vector directly from the data set
(e.g., <code style="white-space: pre;">&#8288;list(group2 = unique(example_data$group2&#8288;</code>). Both approaches lead to the
same result. The former, however, has the advantages that one can also remove some of the
subgroups (e.g. <code style="white-space: pre;">&#8288;list(group2 = c("female")&#8288;</code>). In this case, the specifications
will include &quot;all&quot; (no subset) and &quot;only females&quot;. See examples for more details.</p>
</td></tr>
<tr><td><code id="setup_+3A_add_to_formula">add_to_formula</code></td>
<td>
<p>A string specifying aspects that should always be
included in the formula (e.g. a constant covariate, random effect structures...)</p>
</td></tr>
<tr><td><code id="setup_+3A_fun1">fun1</code></td>
<td>
<p>A function that extracts the parameters of interest from the
fitted models. Defaults to <a href="broom.html#topic+broom">tidy</a>, which works
with a large range of different models.</p>
</td></tr>
<tr><td><code id="setup_+3A_fun2">fun2</code></td>
<td>
<p>A function that extracts fit indices of interest from the models.
Defaults to <a href="broom.html#topic+broom">glance</a>, which works with a large range of
different models. Note: Different models result in different fit indices. Thus,
if you use different models within one specification curve analysis, this may not
work. In this case, you can simply set <code>fun2 = NULL</code> to not extract any fit indices.</p>
</td></tr>
<tr><td><code id="setup_+3A_simplify">simplify</code></td>
<td>
<p>Logical value indicating what type of combinations between
control variables should be included in the specification. If FALSE (default),
all combinations between the provided variables are created (none, each
individually, each combination between each variable, all variables). If
TRUE, only no covariates, each individually, and all covariates are included
as specifications (akin to the default in specr version 0.2.1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empirical results are often contingent on analytical decisions that
are equally defensible, often arbitrary, and motivated by different reasons.
This decisions may introduce bias or at least variability. To this end,
specification curve analyses  (Simonsohn et al., 2020) or multiverse
analyses (Steegen et al., 2016) refer to identifying the set of
theoretically justified, statistically valid (and potentially also non-redundant
specifications, fitting the &quot;multiverse&quot; of models represented by these
specifications and extract relevant parameters often to display the results
graphically as a so-called specification curve. This allows readers to
identify consequential specifications decisions and how they affect the results
or parameter of interest.
</p>
<p><b>Use of this function</b>
</p>
<p>A general overview is provided in the vignettes <code>vignette("specr")</code>.
It is assumed that you want to estimate the relationship between two variables
(<code>x</code> and <code>y</code>). What varies may be what variables should be used for
<code>x</code> and <code>y</code>, what model should be used to estimate the relationship,
whether the relationship should be estimated for certain subsets, and whether
different combinations of control variables should be included. This
allows to (re)produce almost any analytical decision imaginable. See examples
below for how a number of typical analytical decision can be implemented.
Afterwards you pass the resulting object of a class <code>specr.setup</code> to the
function <code>specr()</code> to run the specification curve analysis.
</p>
<p>Note, the resulting class of <code>specr.setup</code> allows to use generic functions.
Use <code>methods(class = "specr.setup")</code> for an overview on available methods and
e.g., <code>?summary.specr.setup</code> to view the dedicated help page.
</p>


<h3>Value</h3>

<p>An object of class <code>specr.setup</code> which includes all possible
specifications based on combinations of the analytic choices. The
resulting list includes a specification tibble, the data set, and additional
information about the universe of specifications. Use
<code>methods(class = "specr.setup")</code> for an overview on available methods.
</p>


<h3>References</h3>


<ul>
<li><p> Simonsohn, U., Simmons, J.P. &amp; Nelson, L.D. (2020). Specification curve analysis. <em>Nature Human Behaviour, 4</em>, 12081214. https://doi.org/10.1038/s41562-020-0912-z
</p>
</li>
<li><p> Steegen, S., Tuerlinckx, F., Gelman, A., &amp; Vanpaemel, W. (2016). Increasing Transparency Through a Multiverse Analysis. <em>Perspectives on Psychological Science, 11</em>(5), 702-712. https://doi.org/10.1177/1745691616658637
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+specr">specr()</a></code> for the second step of actually running the actual specification curve analysis
</p>
<p><code><a href="#topic+summary.specr.setup">summary.specr.setup()</a></code> for how to summarize and inspect the resulting specifications
</p>
<p><code><a href="#topic+plot.specr.setup">plot.specr.setup()</a></code> for creating a visual summary of the specification setup.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1 ----
# Setting up typical specifications
specs &lt;- setup(data = example_data,
   x = c("x1", "x2"),
   y = c("y1", "y2"),
   model = "lm",
   controls = c("c1", "c2", "c3"),
   subsets = list(group1 = c("young", "middle", "old"),
                  group2 = c("female", "male")),
   simplify = TRUE)

# Check specifications
summary(specs, rows = 18)


## Example 2 ----
# Setting up specifications for multilevel models
specs &lt;- setup(data = example_data,
   x = c("x1", "x2"),
   y = c("y1", "y2"),
   model = c("lmer"),                                   # multilevel model
   subsets = list(group1 = c("young", "old"),           # only young and old!
                  group2 = unique(example_data$group2)),# alternative specification
   controls = c("c1", "c2"),
   add_to_formula = "(1|group2)")                       # random effect in all models

# Check specifications
summary(specs)


## Example 3 ----
# Setting up specifications with a different parameter extract functions

# Create custom extract function to extract different parameter and model
tidy_99 &lt;- function(x) {
  fit &lt;- broom::tidy(x,
     conf.int = TRUE,
     conf.level = .99)         # different alpha error rate
  fit$full_model = list(x)     # include entire model fit object as list
  return(fit)
}

# Setup specs
specs &lt;- setup(data = example_data,
   x = c("x1", "x2"),
   y = c("y1", "y2"),
   model = "lm",
   fun1 = tidy_99,             # pass new function to setup
   add_to_formula = "c1 + c2") # set of covariates in all models

# Check specifications
summary(specs)
</code></pre>

<hr>
<h2 id='setup_specs'>Set up specifications</h2><span id='topic+setup_specs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function was deprecated because the new version of specr uses a new analytic framework. In this framework, you should use the function <code><a href="#topic+setup">setup()</a></code> instead.
This function creates a tibble that includes all possible specifications based the dependent and independent variables, model types, and control variables that are specified. This function simply produces a tibble of all combinations. It can be used to check the specified analytical choices. This function is called within <code><a href="#topic+run_specs">run_specs()</a></code>, which estimates all specified models based on the data that are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_specs(x, y, model, controls = NULL, all.comb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_specs_+3A_x">x</code></td>
<td>
<p>a vector denoting independent variables</p>
</td></tr>
<tr><td><code id="setup_specs_+3A_y">y</code></td>
<td>
<p>a vector denoting the dependent variables</p>
</td></tr>
<tr><td><code id="setup_specs_+3A_model">model</code></td>
<td>
<p>a vector denoting the model(s) that should be estimated.</p>
</td></tr>
<tr><td><code id="setup_specs_+3A_controls">controls</code></td>
<td>
<p>a vector of the control variables that should be included. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="setup_specs_+3A_all.comb">all.comb</code></td>
<td>
<p>a logical value indicating what type of combinations of the control variables should be specified. Defaults to FALSE (i.e., none, all, and each individually). If this argument is set to TRUE, all possible combinations between the control variables are specified (see examples).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="tibble.html#topic+tibble-package">tibble</a> that includes all possible specifications based on combinations of the analytic choices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_specs">run_specs()</a></code> to run the specification curve analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setup_specs(x = c("x1", "x2"),
            y = "y2",
            model = "lm",
            controls = c("c1", "c2"))

</code></pre>

<hr>
<h2 id='specr'>Fit models across all specifications</h2><span id='topic+specr'></span>

<h3>Description</h3>

<p>Runs the specification/multiverse analysis across specified models.
This is the central function of the package and represent the second step
in the analytic framework implemented in the package <code>specr</code>. It estimates
and returns respective parameters and estimates of models that were specified
via <code>setup()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specr(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specr_+3A_x">x</code></td>
<td>
<p>A <code>specr.setup</code> object resulting from <code>setup</code> or a tibble that
contains the relevant specifications (e.g., a tibble resulting from
<code>as_tibble(setup(...))</code>).</p>
</td></tr>
<tr><td><code id="specr_+3A_data">data</code></td>
<td>
<p>If x is not an object of &quot;specr.setup&quot; and simply a tibble, you
need to provide the data set that should be used. Defaults to NULL as it is
assumend that most users will create an object of class &quot;specr.setup&quot; that they'll
pass to <code>specr()</code>.</p>
</td></tr>
<tr><td><code id="specr_+3A_...">...</code></td>
<td>
<p>Further arguments that can be passed to <code>future_pmap</code>. This only becomes
important if parallelization is used. For example, if a custom model function is used
this involves passing <code>furrr_options</code> passing to the argument <code>.options</code>.
When a plan for parallelization is set, one can also set <code>.progress = TRUE</code>
to print a progress bar during the fitting process. See details for more information
on parallelization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Empirical results are often contingent on analytical decisions that
are equally defensible, often arbitrary, and motivated by different reasons.
This decisions may introduce bias or at least variability. To this end,
specification curve analyses  (Simonsohn et al., 2020) or multiverse
analyses (Steegen et al., 2016) refer to identifying the set of
theoretically justified, statistically valid (and potentially also non-redundant
specifications, fitting the &quot;multiverse&quot; of models represented by these
specifications and extract relevant parameters often to display the results
graphically as a so-called specification curve. This allows readers to
identify consequential specifications decisions and how they affect the results
or parameter of interest.
</p>
<p><b>Use of this function</b>
</p>
<p>A general overview is provided in the vignettes <code>vignette("specr")</code>.
Generally, you create relevant specification using the function <code>setup()</code>.
You then pass the resulting object of a class <code>specr.setup</code> to the
present function <code>specr()</code> to run the specification curve analysis.
Further note that the resulting object of class <code>specr.object</code> allows
to use several generic function such as <code>summary()</code> or <code>plot()</code>.
Use <code>methods(class = "specr.object")</code> for an overview on available
methods and e.g., <code>?plot.specr.object</code> to view the dedicated help page.
</p>
<p><b>Parallelization</b>
</p>
<p>By default, the function fits models across all specifications sequentially
(one after the other). If the data set is large, the models complex (e.g.,
large structural equation models, negative binomial models, or Bayesian models),
and the number of specifications is large, it can make sense to parallelize
these operations. One simply has to load the package <code>furrr</code> (which
in turn, builds on <code>future</code>) up front. Then parallelizing the fitting process
works as specified in the package description of <code>furr</code>/<code>future</code> by setting a
&quot;plan&quot; before running <code>specr</code> such as:
</p>
<p><code>plan(multisession, workers = 4)</code>
</p>
<p>However, there are many more ways to specifically set up the plan, including
different strategy than <code>multisession</code>. For more information, see
<code>vignette("parallelization")</code> and the
<a href="https://future.futureverse.org/reference/plan.html">reference page</a>
for <code>plan()</code>.
</p>
<p><b>Disclaimer</b>
</p>
<p>We do see a lot of value in investigating how analytical choices
affect a statistical outcome of interest. However, we strongly caution
against using specr as a tool to somehow arrive at a better estimate
compared to a single model. Running a specification curve analysis
does not make your findings any more reliable, valid or generalizable
than a single analysis. The method is meant to inform about the effects
of analytical choices on results, and not a better way to estimate a
correlation or effect.
</p>


<h3>Value</h3>

<p>An object of class <code>specr.object</code>, which includes a data frame
with all specifications their respective results along with many other useful
information about the model. Parameters are extracted via the function passed
to <code>setup</code>. By default this is <code>broom::tidy()</code> and the function
<code>broom::glance()</code>).Several other aspects and information are included in
the resulting class (e.g., number of specifications, time elapsed, subsets
included in the analyses). Use <code>methods(class = "specr.object")</code> for
an overview on available methods.
</p>


<h3>References</h3>


<ul>
<li><p> Simonsohn, U., Simmons, J.P. &amp; Nelson, L.D. (2020). Specification curve analysis. <em>Nature Human Behaviour, 4</em>, 12081214. https://doi.org/10.1038/s41562-020-0912-z
</p>
</li>
<li><p> Steegen, S., Tuerlinckx, F., Gelman, A., &amp; Vanpaemel, W. (2016). Increasing Transparency Through a Multiverse Analysis. <em>Perspectives on Psychological Science, 11</em>(5), 702-712. https://doi.org/10.1177/1745691616658637
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+setup">setup()</a></code> for the first step of setting up the specifications.
</p>
<p><code><a href="#topic+summary.specr.object">summary.specr.object()</a></code> for how to summarize and inspect the results.
</p>
<p><code><a href="#topic+plot.specr.object">plot.specr.object()</a></code> for plotting results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 ----
# Setup up typical specifications
specs &lt;- setup(data = example_data,
   y = c("y1", "y2"),
   x = c("x1", "x2"),
   model = "lm",
   controls = c("c1", "c2"),
   subsets = list(group1 = unique(example_data$group1)))

# Run analysis (not parallelized)
results &lt;- specr(specs)

# Summary of the results
summary(results)


# Example 2 ----
# Working without S3 classes
specs2 &lt;- setup(data = example_data,
    y = c("y1", "y2"),
    x = c("x1", "x2"),
    model = "lm",
    controls = "c1")

# Working with tibbles
specs_tibble &lt;- as_tibble(specs2)      # extract tibble from setup
results2 &lt;- specr(specs_tibble,
                  data = example_data) # need to provide data!

# Results (tibble instead of S3 class)
head(results2)
</code></pre>

<hr>
<h2 id='summarise_specs'>Summarise specifications</h2><span id='topic+summarise_specs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated because the new version of specr uses a new analytic framework.
In this framework, you can plot a similar figure simply by using the generic <code>plot()</code> function.
This function allows to inspect results of the specification curves by returning a comparatively simple summary of the results. This summary can be produced for various specific analytical choices and customized summary functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_specs(
  df,
  ...,
  var = .data$estimate,
  stats = list(median = median, mad = mad, min = min, max = max, q25 = function(x)
    quantile(x, prob = 0.25), q75 = function(x) quantile(x, prob = 0.75))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_specs_+3A_df">df</code></td>
<td>
<p>a data frame resulting from <code>run_specs()</code>.</p>
</td></tr>
<tr><td><code id="summarise_specs_+3A_...">...</code></td>
<td>
<p>one or more grouping variables (e.g., subsets, controls,...) that denote the available analytical choices.</p>
</td></tr>
<tr><td><code id="summarise_specs_+3A_var">var</code></td>
<td>
<p>which variable should be evaluated? Defaults to estimate (the effect sizes computed by <code><a href="#topic+run_specs">run_specs()</a></code>).</p>
</td></tr>
<tr><td><code id="summarise_specs_+3A_stats">stats</code></td>
<td>
<p>named vector or named list of summary functions (individually defined summary functions can included). If it is not named, placeholders (e.g., &quot;fn1&quot;) will be used as column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="tibble.html#topic+tibble-package">tibble</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_summary">plot_summary()</a></code> to visually investigate the affect of analytical choices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run specification curve analysis
results &lt;- run_specs(df = example_data,
                     y = c("y1", "y2"),
                     x = c("x1", "x2"),
                     model = c("lm"),
                     controls = c("c1", "c2"),
                     subsets = list(group1 = unique(example_data$group1),
                                    group2 = unique(example_data$group2)))

# overall summary
summarise_specs(results)

# Summary of specific analytical choices
summarise_specs(results,    # data frame
                x, y)       # analytical choices

# Summary of other parameters across several analytical choices
summarise_specs(results,
                subsets, controls,
                var = p.value,
                stats = list(median = median,
                             min = min,
                             max = max))

# Unnamed vector instead of named list passed to `stats`
summarise_specs(results,
                controls,
                stats = c(mean = mean,
                          median = median))

</code></pre>

<hr>
<h2 id='summary.specr.object'>Summarizing the Specification Curve Analysis</h2><span id='topic+summary.specr.object'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;specr&quot;. It provides a printed output including
technical details (e.g., cores used, duration of the fitting process, number
of specifications), a descriptive analysis of the overall specification curve,
a descriptive summary of the resulting sample sizes, and a head of the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.object'
summary(
  object,
  type = "default",
  group = NULL,
  var = .data$estimate,
  stats = list(median = median, mad = mad, min = min, max = max, q25 = function(x)
    quantile(x, prob = 0.25), q75 = function(x) quantile(x, prob = 0.75)),
  digits = 2,
  rows = 6,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.specr.object_+3A_object">object</code></td>
<td>
<p>An object of class &quot;specr&quot;, usually resulting of a call to <code>specr</code>.</p>
</td></tr>
<tr><td><code id="summary.specr.object_+3A_type">type</code></td>
<td>
<p>Different aspects can be summarized and printed. See details for alternative summaries</p>
</td></tr>
<tr><td><code id="summary.specr.object_+3A_group">group</code></td>
<td>
<p>In combination with <code>what = "curve"</code>, provide a vector of one or more variables (e.g., subsets, controls,...) that denote the available analytic choices to group summary of the estimate.</p>
</td></tr>
<tr><td><code id="summary.specr.object_+3A_var">var</code></td>
<td>
<p>In combination with <code>what = "curve"</code>, unquoted name of parameter to be summarized. Defaults to estimate.</p>
</td></tr>
<tr><td><code id="summary.specr.object_+3A_stats">stats</code></td>
<td>
<p>Named vector or named list of summary functions (individually defined summary functions can included). If it is not named, placeholders (e.g., &quot;fn1&quot;) will be used as column names.</p>
</td></tr>
<tr><td><code id="summary.specr.object_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use when printing the specification table.</p>
</td></tr>
<tr><td><code id="summary.specr.object_+3A_rows">rows</code></td>
<td>
<p>The number of rows of the specification tibble that should be printed.</p>
</td></tr>
<tr><td><code id="summary.specr.object_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printed summary of an object of class <code>specr.object</code>.
</p>


<h3>See Also</h3>

<p>The function used to create the &quot;specr.setup&quot; object: <code>setup</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup up specifications (returns object of class "specr.setup")
specs &lt;- setup(data = example_data,
   y = c("y1", "y2"),
   x = c("x1", "x2"),
   model = "lm",
   controls = c("c1", "c2"),
   subsets = list(group1 = unique(example_data$group1)))

# Run analysis (returns object of class "specr.object")
results &lt;- specr(specs)

# Default summary of the "specr.object"
summary(results)

# Summarize the specification curve descriptively
summary(results, type = "curve")

# Grouping for certain analytical decisions
summary(results,
       type = "curve",
       group = c("x", "y"))

# Using customized functions
summary(results,
        type = "curve",
       group = c("x", "group1"),
       stats = list(median = median,
                    min = min,
                    max = max))
</code></pre>

<hr>
<h2 id='summary.specr.setup'>Summarizing the Specifications Setup</h2><span id='topic+summary.specr.setup'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;specr.setup&quot;. Provides a short summary of the
created specifications (the &quot;multiverse&quot;) that lists all analytic choices, prints
the function used to extract the parameters from the model. Finally, if
<code>print.specs = TRUE</code>, it also shows the head of the actual specification grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'specr.setup'
summary(object, digits = 2, rows = 6, print.specs = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.specr.setup_+3A_object">object</code></td>
<td>
<p>An object of class &quot;specr.setup&quot;, usually, a result of a call to <code>setup</code>.</p>
</td></tr>
<tr><td><code id="summary.specr.setup_+3A_digits">digits</code></td>
<td>
<p>The number of digits to use when printing the specification table.</p>
</td></tr>
<tr><td><code id="summary.specr.setup_+3A_rows">rows</code></td>
<td>
<p>The number of rows of the specification tibble that should be printed.</p>
</td></tr>
<tr><td><code id="summary.specr.setup_+3A_print.specs">print.specs</code></td>
<td>
<p>Logical value; if <code>TRUE</code>, a head of the specification tibble
is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.specr.setup_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printed summary of an object of class <code>specr.setup</code>.
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+setup">setup()</a></code>, which creates the &quot;specr.setup&quot; object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup specifications
specs &lt;- setup(data = example_data,
  x = c("x1", "x2"),
  y = c("y1", "y2"),
  model = c("lm", "glm"),
  controls = c("c1", "c2", "c3"),
  subsets = list(group3 = unique(example_data$group3)))

# Summarize specifications
summary(specs)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
