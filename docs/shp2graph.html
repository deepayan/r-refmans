<!DOCTYPE html><html lang="en"><head><title>Help for package shp2graph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shp2graph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Degree.list'><p>Degree (In-degree and Out-degree) of nodes</p></a></li>
<li><a href='#Directed'><p>Orientate all the edges in a given edgelist</p></a></li>
<li><a href='#edgelist'><p>A designed structure to denote edges from a spatial network</p></a></li>
<li><a href='#ERN_OSM'><p>Estevan road network from OpenStreetMap (SpatialLinesDataFrame)</p></a></li>
<li><a href='#LNHP'><p>London house price and hedonic data (SpatialPointsDataFrame)</p></a></li>
<li><a href='#LNNT'><p>London Road network data (SpatialLinesDataFrame)</p></a></li>
<li><a href='#ME.simplification'><p>Simplify multiple edges in a network</p></a></li>
<li><a href='#nel2igraph'><p>Produce an &ldquo;igraph&rdquo; object</p></a></li>
<li><a href='#nodelist'><p>A designed structure to denote nodes from a spatial network</p></a></li>
<li><a href='#Nodes.coordinates'><p>Return the coordinates of nodes in a &ldquo;nodelist&rdquo;</p></a></li>
<li><a href='#nt.connect'><p>Check the connectivity of a given network</p></a></li>
<li><a href='#ORN'><p>Ontario road network data (SpatialLinesDataFrame)</p></a></li>
<li><a href='#PN.amalgamation'><p>Amalgamate edges connected by a pseudo-node</p></a></li>
<li><a href='#points2network'><p>Integrate a point data set into a network</p></a></li>
<li><a href='#ptsinnt.view'><p>Visualize the integration between a point data set and spatila network</p></a></li>
<li><a href='#readshpnw'><p>Read a network from a &ldquo;SpatialLines&rdquo; or &ldquo;SpatialLinesDataFrame&rdquo; object</p></a></li>
<li><a href='#Redef.functions'><p>A collection of functions for redefining attributes of edited edges</p></a></li>
<li><a href='#SL.extraction'><p>Extract self-loops form given network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Convert a 'SpatialLinesDataFrame' -Class Object to an
'igraph'-Class Object</td>
</tr>
<tr>
<td>Author:</td>
<td>Binbin Lu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Binbin Lu &lt;binbinlu@whu.edu.cn&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0),igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods,sp</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for converting and processing network data from a
        'SpatialLinesDataFrame' -Class object to an 'igraph'-Class object.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 11:12:05 UTC; Lenovo</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Degree.list'>Degree (In-degree and Out-degree) of nodes</h2><span id='topic+Degree.list'></span>

<h3>Description</h3>

<p>A function that returns degrees of nodes from provided &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; and &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo;; 
while in-degrees and out-degrees are returned if edges are directed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Degree.list(nodelist, edgelist, Directed=F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Degree.list_+3A_nodelist">nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="Degree.list_+3A_edgelist">edgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="Degree.list_+3A_directed">Directed</code></td>
<td>
<p>TRUE if edges are directed; FALSE, otherwise</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Lists of different contents are returned for undirected and directed edges 
respectively:
For undirected graph:
</p>
<table role = "presentation">
<tr><td><code>DegreeL</code></td>
<td>
<p>An integer vector of degrees for each node in the given
&ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;</p>
</td></tr>
</table>
<p>For directed type:
</p>
<table role = "presentation">
<tr><td><code>InDegreeL</code></td>
<td>
<p>An integer vector of In-degrees for each node 
in the given &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;</p>
</td></tr>
<tr><td><code>OutDegreeL</code></td>
<td>
<p>An integer vector of Out-degrees for each node 
in the given &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;</p>
</td></tr>  
</table>


<h3>Note</h3>

<p>This function returns differently for undirected and directed 
networks, where both In-degrees and Out-degrees are calculated for a directed network,
and only degrees are returned for an undirected networks.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='Directed'>Orientate all the edges in a given edgelist</h2><span id='topic+Directed'></span>

<h3>Description</h3>

<p>A function to orientate each edge according to the given vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Directed(edgelist, direction.v=rep(0,length(edgelist[,1])), eadf=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Directed_+3A_edgelist">edgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="Directed_+3A_direction.v">direction.v</code></td>
<td>
<p>A vector (of the length equalling to the number of edges in
the given &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo;) with values of 1 (TRUE) or 0 (FALSE), 1 (TRUE)
indicates a directed (one-way) edge, while 0 (FALSE) means an undirected (double-way) edge</p>
</td></tr>
<tr><td><code id="Directed_+3A_eadf">eadf</code></td>
<td>
<p> A data frame of attributes corresponding to all the edges;</p>
</td></tr>                             
</table>


<h3>Details</h3>

<p>Within a road network, some road segments might be one-way while the rest 
are double-way. This suitation makes it complex to define directed or undirected
edges in a graph. This function is to orientate each edge according to the given 
vector, &ldquo;direction.v&rdquo;: 1 (TRUE) indicates one-way, while 0 (FALSE) represents 
double-way. All the double-way (undirected) edges in the given &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; are 
redefined as two directed edges (e.g. a double-way (undirected) edge(nid1, nid2) is redefined 
as two one-way (directed) edges, (nid1, nid2) and (nid2, nid1)). The one-way (directed) edges 
are left in their directed forms. In other words, all the edges returned by this function will 
be directed, and used to be construct a directed graph.
</p>


<h3>Value</h3>

<p>A list consisted of:
</p>
<table role = "presentation">
<tr><td><code>newEdgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object with directed edges</p>
</td></tr>
<tr><td><code>newEadf</code></td>
<td>
<p>A data frame of attributes for the new &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='edgelist'>A designed structure to denote edges from a spatial network</h2><span id='topic+edgelist'></span>

<h3>Description</h3>

<p>&ldquo;edgelist&rdquo; is an interchange structure of edges from a spatial network into 
an &ldquo;igraph&rdquo; object. It is a three-column matrix, of which each row is 
designed as [EdgeID,NodeID(from),NodeID(to)].
</p>


<h3>Details</h3>

<p>Both &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; and &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; are interchange structures
of nodes and edges extracted from a spatial network in a &ldquo;SpatialLines&rdquo; or 
&ldquo;SpatialLinesDataFrame&rdquo; object. They are always concerned together, and returned
by the function <a href="#topic+readshpnw">readshpnw</a> as initial results for the following steps.
</p>


<h3>Note</h3>

<p>If the parameter &ldquo;Detailed&rdquo; specified in <a href="#topic+readshpnw">readshpnw</a> is TRUE, all 
the endpoints of polyines will be extracted as nodes, then the converted 
graph will have the same spatial details with the transformed &ldquo;SpatialLines&rdquo; 
or &ldquo;SpatialLinesDataFrame&rdquo; object. To retrieve the original attributes in 
the &ldquo;SpatialLinesDataFrame&rdquo; object, the original edge ID is also kept and 
the row structure will be [EdgeID,eid,NodeID(from),NodeID(to)], in which EdgeID 
refers to the new edge id while eid represents the original edge ID.  
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='ERN_OSM'>Estevan road network from OpenStreetMap (SpatialLinesDataFrame)</h2><span id='topic+ERN_OSM'></span><span id='topic+ERN_OSM_correct'></span><span id='topic+ERN_OSM.nt'></span><span id='topic+ERN_OSM_cor.nt'></span>

<h3>Description</h3>

<p>This data set is a part of Estevan road network downloaded from OpenStreetMap, 
and a version with topology errors corrected is also incorporated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ERN_OSM)
data(ERN_OSM_correct)
</code></pre>


<h3>Format</h3>

<p>Two &ldquo;SpatialLinesDataFrame&rdquo; objects named &ldquo;ERN_OSM.nt&rdquo; and &ldquo;ERN_OSM_cor.nt&rdquo;.
</p>


<h3>Source</h3>

<p><a href="https://www.openstreetmap.org/#map=14/49.1388/-102.9961">https://www.openstreetmap.org/#map=14/49.1388/-102.9961</a>
</p>


<h3>References</h3>

<p>OpenStreetMap. 2014. Estevan road network. ed. O. community.
</p>

<hr>
<h2 id='LNHP'>London house price and hedonic data (SpatialPointsDataFrame)</h2><span id='topic+LNHP'></span><span id='topic+LN.prop'></span>

<h3>Description</h3>

<p>This data set is sampled from a house price data set provided by the Nationwide 
Building Society of the UK, and combined with various hedonic variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LNHP)</code></pre>


<h3>Format</h3>

<p>A &ldquo;SpatialPointsDataFrame&rdquo; object named &ldquo;LN.prop&rdquo;.
</p>


<h3>Details</h3>

<p>In this data set, attributes are interpreted as follows:
</p>
<p>PURCHASE: sale price in GBP
</p>
<p>FLOORSZ: floor size of the property in square metres;
</p>
<p>BATH2: 1 if the property has 2 or more bathrooms, 0 otherwise; 
</p>
<p>BEDS2: 1 if the property has 2 or more bedrooms, 0 otherwise;
</p>
<p>CENTHEAT: 1 if the property has central heating, 0 otherwise;
</p>
<p>GARAGE1: 1 if the property has one or more garages, 0 otherwise;
</p>
<p>BLDPWW1: 1 if the property was built prior to 1914, 0 otherwise;
</p>
<p>BLDINTW: is 1 if the property was built between 1914 and 1939, 0 otherwise;
</p>
<p>BLD60S: 1 if the property was built between 1960 and 1969, 0 otherwise;
</p>
<p>BLD70S: 1 if the property was built between 1970 and 1979, 0 otherwise;
</p>
<p>BLD80S: 1 if the property was built between 1980 and 1989, 0 otherwise;
</p>
<p>BLD90S: 1 if the property was built between 1990 and 2000, 0 otherwise;
</p>
<p>TYPEDETCH: 1 if the property is detached (i.e. it is stand-alone), 0 otherwise; 
</p>
<p>TYPETRRD: 1 if the property is in a terrace of similar houses, 0 otherwise;
</p>
<p>TYPEFLAT: 1 if the property is a flat or apartment, 0 otherwise;
</p>
<p>PROF: percentage of the workforce in professional or managerial occupations in 
the census enumeration district in which the house is located.
</p>
<p>UNEMPLOY: percentage of unemployment in  the census enumeration district
in which the house is located. 
</p>
<p>X: X coordinate.
</p>
<p>Y: Y coordinat.
</p>


<h3>References</h3>

<p>Lu, B., M. Charlton, P. Harris &amp; A. S. Fotheringham (2014) Geographically weighted 
regression with a non-Euclidean distance metric: a case study using hedonic house 
price data. International Journal of Geographical Information Science, 28, 660-681.
</p>

<hr>
<h2 id='LNNT'>London Road network data (SpatialLinesDataFrame)</h2><span id='topic+LNNT'></span><span id='topic+LN.nt'></span>

<h3>Description</h3>

<p>The London Road network data set is produced by the UK Ordnance Survey (OS) in 2001. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LNNT)</code></pre>


<h3>Format</h3>

<p>A &ldquo;SpatialLinesDataFrame&rdquo; object named &ldquo;LN.nt&rdquo;.
</p>


<h3>Details</h3>

<p>In this data set, roads are categorized into four types (nt_RoadTyp):
</p>
<p>Mo: motorway
</p>
<p>a: A-road
</p>
<p>b: B-road
</p>
<p>Mi: minor road
</p>
<p>Speed limit for each road segment is also incoporated in the attribute &ldquo;Speed&rdquo;
(Transport for London, 2011)
</p>


<h3>References</h3>

<p>Lu, B., M. Charlton, P. Harris &amp; A. S. Fotheringham (2014) Geographically weighted 
regression with a non-Euclidean distance metric: a case study using hedonic house 
price data. International Journal of Geographical Information Science, 28, 660-681.
</p>
<p>Transport for London, (2011) Intelligent Speed Adaptation [online]. 
http://www.tfl.gov.uk/corporate/projectsandschemes/7893.aspx#For_developers. 
Available from: http://www.tfl.gov.uk/corporate/projectsandschemes/7893.aspx#For_developers.
</p>

<hr>
<h2 id='ME.simplification'>Simplify multiple edges in a network</h2><span id='topic+ME.simplification'></span>

<h3>Description</h3>

<p>A function to simplfy multiple-edge into one representative edge, where a 
multiple-edge structure refers to a set of edges sharing with the same pair of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ME.simplification(nodelist, edgelist, eadf=NULL, ea.prop=NULL, Directed=F, 
                  DegreeL=NULL, InDegreeL=NULL, OutDegreeL=NULL,Nexception=NULL,
                  Eexception=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ME.simplification_+3A_nodelist">nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object;</p>
</td></tr>
<tr><td><code id="ME.simplification_+3A_edgelist">edgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="ME.simplification_+3A_eadf">eadf</code></td>
<td>
<p> A data frame of attributes corresponding to all the edges;</p>
</td></tr>
<tr><td><code id="ME.simplification_+3A_ea.prop">ea.prop</code></td>
<td>
<p>A vector (of the length equalling to the number of edge attributes in
&ldquo;eadf&rdquo;) with values of 1, 2, 3 or 4, and each specific
value represent a function to assign the attributes of the edited edges, see also <a href="#topic+Redef.functions">Redef.functions</a>:
</p>
<p>1-&gt;sum(v)
</p>
<p>2-&gt;min(v)
</p>
<p>3-&gt;max(v)
</p>
<p>4-&gt;mean(v)
</p>
</td></tr>
<tr><td><code id="ME.simplification_+3A_directed">Directed</code></td>
<td>
<p>TRUE if edges are directed, FALSE otherwise;</p>
</td></tr>  
<tr><td><code id="ME.simplification_+3A_degreel">DegreeL</code></td>
<td>
<p>An integer vector of degrees for each node in the given
&ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored if edges are directed</p>
</td></tr>
<tr><td><code id="ME.simplification_+3A_indegreel">InDegreeL</code></td>
<td>
<p>An integer vector of In-degrees for each node 
in the given &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored 
if edges are undirected</p>
</td></tr>
<tr><td><code id="ME.simplification_+3A_outdegreel">OutDegreeL</code></td>
<td>
<p>An integer vector of Out-degrees for each node 
in the given &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored 
if edges are undirected</p>
</td></tr>
<tr><td><code id="ME.simplification_+3A_nexception">Nexception</code></td>
<td>
<p>A vector of node IDs concerned as exceptions, and all the 
edges with these nodes included won't be processed;</p>
</td></tr>
<tr><td><code id="ME.simplification_+3A_eexception">Eexception</code></td>
<td>
<p>A vector of edge IDs concerned as exceptions, and all these 
edges won't be processed;</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Two types of list returned for undirected and directed edges, respectively:
</p>
<p>For &ldquo;undirected&rdquo; edges:
</p>
<table role = "presentation">
<tr><td><code>newNodelist</code></td>
<td>
<p>New node list with multiple-edges simplified;</p>
</td></tr>
<tr><td><code>newEdgelist</code></td>
<td>
<p>New edge list with multiple-edges simplified;</p>
</td></tr>
<tr><td><code>newEadf</code></td>
<td>
<p>New attribute data frame for the returned edgelist;</p>
</td></tr>
<tr><td><code>DegreeL</code></td>
<td>
<p>New degree vector cooresponding to the newly returned node list;</p>
</td></tr>
</table>
<p>For &ldquo;directed&rdquo; network:
</p>
<table role = "presentation">
<tr><td><code>newNodelist</code></td>
<td>
<p>New node list with multiple-edges simplified;</p>
</td></tr>
<tr><td><code>newEdgelist</code></td>
<td>
<p>New edgelist with multiple-edges simplified;</p>
</td></tr>
<tr><td><code>newEadf</code></td>
<td>
<p>Data frame of attributes for the newly returned edge list;</p>
</td></tr>
<tr><td><code>InDegreeL</code></td>
<td>
<p>New In-degree vector cooresponding to the newly returned node list;</p>
</td></tr>
<tr><td><code>OutDegreeL</code></td>
<td>
<p>New Out-degree vector cooresponding to the newly returned node list;</p>
</td></tr>   
</table>


<h3>Note</h3>

<p>Edges are recognised as a structure of multiple-edge when they share the same pair
of nodes. Note that the order of the nodes should be also the same when edges are
directed.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+SL.extraction">SL.extraction</a></code>, <code><a href="#topic+PN.amalgamation">PN.amalgamation</a></code></p>

<hr>
<h2 id='nel2igraph'>Produce an &ldquo;igraph&rdquo; object</h2><span id='topic+nel2igraph'></span>

<h3>Description</h3>

<p>A function to produce an &ldquo;igraph&rdquo; object with the  &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; and 
&ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo;, which could be returned by the function <a href="#topic+readshpnw">readshpnw</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nel2igraph(nodelist, edgelist, weight = NULL, eadf = NULL, Directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nel2igraph_+3A_nodelist">nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="nel2igraph_+3A_edgelist">edgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="nel2igraph_+3A_weight">weight</code></td>
<td>
<p>A numberic vector to weight all the edges in the &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo;, 
of which the length equals to the number of edges;</p>
</td></tr>
<tr><td><code id="nel2igraph_+3A_eadf">eadf</code></td>
<td>
<p> A data frame of attributes corresponding to all the edges;</p>
</td></tr>
<tr><td><code id="nel2igraph_+3A_directed">Directed</code></td>
<td>
<p>TRUE if edges are directed, FALSE otherwise;</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>1. The weighting vector, &ldquo;weight&rdquo;, will be used as default for any weigted
calculations with edges in the &ldquo;igraph&rdquo; object.
</p>
<p>2. The coordinate of each node is attached as attributes &ldquo;X&rdquo; and &ldquo;Y&rdquo;, 
which could be retrived via the function &ldquo;<code>get.vertex.attribute</code>&rdquo; from 
the package <span class="pkg">igraph</span>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>gr</code></td>
<td>
<p>An &ldquo;igraph&rdquo; object</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ORN)
rtNEL&lt;-readshpnw(ORN.nt, ELComputed=TRUE)
#Add the edge length as the weight for graph
igr&lt;-nel2igraph(rtNEL[[2]],rtNEL[[3]],weight=rtNEL[[4]])
plot(igr, vertex.label=NA, vertex.size=2,vertex.size2=2)
#plot(ORN.nt)
</code></pre>

<hr>
<h2 id='nodelist'>A designed structure to denote nodes from a spatial network</h2><span id='topic+nodelist'></span>

<h3>Description</h3>

<p>&ldquo;nodelist&rdquo; is an interchange structure of nodes from a spatial network into 
an &ldquo;igraph&rdquo; object. It is a two-column data frame, of which each row is 
designed as [NodeID,coordinate(X,Y)].
</p>


<h3>Details</h3>

<p>Both &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; and &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; are interchange structures
of nodes and edges extracted from a spatial network in a &ldquo;SpatialLines&rdquo; or 
&ldquo;SpatialLinesDataFrame&rdquo; object. They are always concerned together, and returned
by the function <a href="#topic+readshpnw">readshpnw</a> as initial results for the following steps.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='Nodes.coordinates'>Return the coordinates of nodes in a &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;</h2><span id='topic+Nodes.coordinates'></span>

<h3>Description</h3>

<p>A function that returns the coordinates of nodes in a two-column matrix (X,Y) from
a &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nodes.coordinates(nodelist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Nodes.coordinates_+3A_nodelist">nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Nodesxy</code></td>
<td>
<p>A two-column matrix (X, Y)</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='nt.connect'>Check the connectivity of a given network</h2><span id='topic+nt.connect'></span>

<h3>Description</h3>

<p>A function to check the connectivity of a given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nt.connect(nt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nt.connect_+3A_nt">nt</code></td>
<td>
<p>A &ldquo;SpatialLines&rdquo; or &ldquo;SpatialLinesDataFrame&rdquo; object.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>In this function, all the nodes are traversed, and classified dynamically via a 
rule, that any pair of different nodes fall into a same category if they could 
be reached from each other. A map will be plotted spontaneously with differet categories 
(i.e. self-connected parts) in distinct colors. Finally, the self-connected part with
the most nodes will be returned as a new &ldquo;SpatialLinesDataFrame&rdquo; object. 
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='ORN'>Ontario road network data (SpatialLinesDataFrame)</h2><span id='topic+ORN'></span><span id='topic+ORN.nt'></span>

<h3>Description</h3>

<p>This data set is a part of Ontario road network data set downloaded from 
Ontario Ministry of Natural Resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ORN)</code></pre>


<h3>Format</h3>

<p>A &ldquo;SpatialLinesDataFrame&rdquo; object named &ldquo;ORN.nt&rdquo;.
</p>


<h3>Source</h3>

<p><a href="https://www.geographynetwork.ca/website/orn/viewer.htm">https://www.geographynetwork.ca/website/orn/viewer.htm</a>
</p>


<h3>References</h3>

<p>Peterborough, ON: Ontario Ministry of Natural Resources, Ontario Road Network. 
Available: <a href="https://www.geographynetwork.ca/website/orn/viewer.htm">https://www.geographynetwork.ca/website/orn/viewer.htm</a>, 2006, 
(Accessed Dec. 4, 2009)
</p>

<hr>
<h2 id='PN.amalgamation'>Amalgamate edges connected by a pseudo-node</h2><span id='topic+PN.amalgamation'></span><span id='topic+Minus.DegreeL'></span><span id='topic+Update.nodelist'></span><span id='topic+Update.edgelist'></span><span id='topic+extend.eadf'></span><span id='topic+is.exception'></span>

<h3>Description</h3>

<p>A function to amalgamate edges connected by a pseudo-node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PN.amalgamation(nodelist, edgelist, eadf=NULL, ea.prop=NULL, Directed=F, 
                DegreeL=NULL, InDegreeL=NULL, OutDegreeL=NULL,Nexception=NULL,
                Eexception=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PN.amalgamation_+3A_nodelist">nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object;</p>
</td></tr>
<tr><td><code id="PN.amalgamation_+3A_edgelist">edgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="PN.amalgamation_+3A_eadf">eadf</code></td>
<td>
<p> A data frame of attributes corresponding to all the edges;</p>
</td></tr>
<tr><td><code id="PN.amalgamation_+3A_ea.prop">ea.prop</code></td>
<td>
<p>A vector (of the length equalling to the number of edge attributes in
&ldquo;eadf&rdquo;) with values of 1, 2, 3 or 4, and each specific
value represent a function to assign the attributes of the edited edges, see also <a href="#topic+Redef.functions">Redef.functions</a>:
</p>
<p>1-&gt;sum(v)
</p>
<p>2-&gt;min(v)
</p>
<p>3-&gt;max(v)
</p>
<p>4-&gt;mean(v)
</p>
</td></tr>
<tr><td><code id="PN.amalgamation_+3A_directed">Directed</code></td>
<td>
<p>TRUE if edges are directed, FALSE otherwise;</p>
</td></tr>  
<tr><td><code id="PN.amalgamation_+3A_degreel">DegreeL</code></td>
<td>
<p>An integer vector of degrees for each node in the given
&ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored if edges are directed</p>
</td></tr>
<tr><td><code id="PN.amalgamation_+3A_indegreel">InDegreeL</code></td>
<td>
<p>An integer vector of In-degrees for each node 
in the given &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored 
if edges are undirected</p>
</td></tr>
<tr><td><code id="PN.amalgamation_+3A_outdegreel">OutDegreeL</code></td>
<td>
<p>An integer vector of Out-degrees for each node 
in the given &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored 
if edges are undirected</p>
</td></tr>
<tr><td><code id="PN.amalgamation_+3A_nexception">Nexception</code></td>
<td>
<p>A vector of node IDs concerned as exceptions, and all the 
edges with these nodes included won't be processed;</p>
</td></tr>
<tr><td><code id="PN.amalgamation_+3A_eexception">Eexception</code></td>
<td>
<p>A vector of edge IDs concerned as exceptions, and all these 
edges won't be processed;</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>Two types of list returned for undirected and directed edges, respectively:
</p>
<p>For &ldquo;undirected&rdquo; edges:
</p>
<table role = "presentation">
<tr><td><code>newNodelist</code></td>
<td>
<p>New node list with pseudo-nodes removed;</p>
</td></tr>
<tr><td><code>newEdgelist</code></td>
<td>
<p>New edge list with pseudo-nodes removed;</p>
</td></tr>
<tr><td><code>newEadf</code></td>
<td>
<p>New attribute data frame for the returned edgelist;</p>
</td></tr>
<tr><td><code>DegreeL</code></td>
<td>
<p>New degree vector cooresponding to the newly returned node list;</p>
</td></tr>
</table>
<p>For &ldquo;directed&rdquo; network:
</p>
<table role = "presentation">
<tr><td><code>newNodelist</code></td>
<td>
<p>New node list with pseudo-nodes removed;</p>
</td></tr>
<tr><td><code>newEdgelist</code></td>
<td>
<p>New edgelist with pseudo-nodes removed;</p>
</td></tr>
<tr><td><code>newEadf</code></td>
<td>
<p>Data frame of attributes for the newly returned edge list;</p>
</td></tr>
<tr><td><code>InDegreeL</code></td>
<td>
<p>New In-degree vector cooresponding to the newly returned node list;</p>
</td></tr>
<tr><td><code>OutDegreeL</code></td>
<td>
<p>New Out-degree vector cooresponding to the newly returned node list;</p>
</td></tr>  
</table>


<h3>Note</h3>

<p>Node in a directed network is recognised a a pseudo-node with in-degree 
and out-degree equalling to 1; while it could be a pseudo-node with degree 
equalling to 2 in a undirected network.
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+SL.extraction">SL.extraction</a></code>, <code><a href="#topic+ME.simplification">ME.simplification</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ORN)
rtNEL&lt;-readshpnw(ORN.nt, ELComputed=TRUE)
res.sl&lt;-SL.extraction(rtNEL[[2]],rtNEL[[3]])
res.me&lt;-ME.simplification(res.sl[[1]],res.sl[[2]],DegreeL=res.sl[[4]]) 
res.pn&lt;-PN.amalgamation(res.me[[1]],res.me[[2]],DegreeL=res.me[[4]])
ptcoords&lt;-Nodes.coordinates(res.pn[[1]])
#plot(ORN.nt)
#points(ptcoords, col="green")
#plot(ORN.nt)
#points(Nodes.coordinates(rtNEL[[2]]), col="red")
</code></pre>

<hr>
<h2 id='points2network'>Integrate a point data set into a network</h2><span id='topic+points2network'></span><span id='topic+Nearest.nodes'></span><span id='topic+footpoint.nodes'></span><span id='topic+Add.nodes'></span><span id='topic+virtualedge.nn'></span><span id='topic+point.in.bbox'></span>

<h3>Description</h3>

<p>A function to integrate an individual point data set into a network under different
rules (see details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2network(ntdata,pointsxy,approach=1,ELComputed=FALSE,longlat=F,
               Detailed=F, ea.prop=NULL)
</code></pre>


<h3>Arguments</h3>

                                                                   
<table role = "presentation">
<tr><td><code id="points2network_+3A_ntdata">ntdata</code></td>
<td>
<p>A &ldquo;SpatialLinesDataFrame&rdquo; or &ldquo;SpatialLines&rdquo; object</p>
</td></tr>
<tr><td><code id="points2network_+3A_pointsxy">pointsxy</code></td>
<td>
<p>A two-column matrix of point coordinates (X, Y)</p>
</td></tr>
<tr><td><code id="points2network_+3A_approach">approach</code></td>
<td>
<p>specified by an integer ranging from 1 to 4 to define the approach
for integration:
</p>
<p>1: Mapping each point to the nearest node in the network/graph
</p>
<p>2: Mapping each point to the nearest point (add them as nodes if they are not)
on the network
</p>
<p>3: Add a new edge(virtual edge) between each point and the nearest node
</p>
<p>4: Add a new edge(virtual edge) between each point and the nearest point 
</p>
</td></tr>
<tr><td><code id="points2network_+3A_elcomputed">ELComputed</code></td>
<td>
<p>If TRUE, the length of each edge will be calculated and returned</p>
</td></tr>
<tr><td><code id="points2network_+3A_longlat">longlat</code></td>
<td>
<p>If TRUE, distances on an ellipse with WGS84 parameters will be returned</p>
</td></tr>
<tr><td><code id="points2network_+3A_detailed">Detailed</code></td>
<td>
<p>If TRUE, all the vertices within the polylines of a spatial network
will be recognised as nodes; if FALSE, only two endpoints of each polyline are treated 
as nodes</p>
</td></tr>
<tr><td><code id="points2network_+3A_ea.prop">ea.prop</code></td>
<td>
<p>A vector (of the length equalling to the number of edge attributes in
in the network &ldquo;ntdata&rdquo;) with values of 1 or 0:
</p>
<p>1: the corresponding column in the data frame will be kept for 
the new network;
</p>
<p>0: the corresponding column in the data frame will not be kept.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list consisted of:
</p>
<table role = "presentation">
<tr><td><code>nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code>edgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code>CoorespondIDs</code></td>
<td>
<p>A vector of the cooresponding node ID for each point in &ldquo;pointsxy&rdquo;</p>
</td></tr>
<tr><td><code>nodexlist</code></td>
<td>
<p>A vector contains X-coordinates of all the nodes</p>
</td></tr>
<tr><td><code>nodeylist</code></td>
<td>
<p>A vector contains Y-coordinates of all the nodes</p>
</td></tr> 
<tr><td><code>Eadf</code></td>
<td>
<p>A data frame of attributes of the returned edges, of which the structure is
a data frame with [EdgeID,(attributes inherited from the input network data)]</p>
</td></tr>
<tr><td><code>VElist</code></td>
<td>
<p>A list of virtual edges if added, i.e. approaches 3 and 4 are used</p>
</td></tr>
<tr><td><code>Edgelength</code></td>
<td>
<p>If &ldquo;ELComputed&rdquo; is TRUE, lengths of all the edges will be 
returned as a numeric vector; otherwise it will be NULL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ptsinnt.view">ptsinnt.view</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ORN)
pts&lt;-spsample(ORN.nt, 100, type="random")
ptsxy&lt;-coordinates(pts)[,1:2]
ptsxy&lt;-cbind(ptsxy[,1]+0.008,ptsxy[,2]+0.008)
#Mapping each point to the nearest node in the network/graph
res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, approach=1)
ptsinnt.view(ntdata=rn, nodelist=res[[1]], pointsxy=ptsxy,
             CoorespondIDs=res[[3]])
#Mapping each point to the nearest point (add them as nodes if they are not) on 
#the network
res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, approach=2,ea.prop=rep(0,37))
ptsinnt.view(ntdata=ORN.nt, nodelist=res[[1]], pointsxy=ptsxy, CoorespondIDs=res[[3]]) 
#Add a new edge(Virtual edge) between each point and the nearest node
res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, approach=3,ea.prop=rep(0,37))
VElist&lt;-res[[7]]
ptsinnt.view(ntdata=ORN.nt, nodelist=res[[1]], pointsxy=ptsxy, CoorespondIDs=res[[3]], 
             VElist=VElist)
#Add a new edge(Virtual edge) between each point and the nearest point
res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, approach=4,ea.prop=rep(0,37))
VElist&lt;-res[[7]]
ptsinnt.view(ntdata=ORN.nt, nodelist=res[[1]], pointsxy=ptsxy, CoorespondIDs=res[[3]],
             VElist=VElist) 

## End(Not run)
</code></pre>

<hr>
<h2 id='ptsinnt.view'>Visualize the integration between a point data set and spatila network</h2><span id='topic+ptsinnt.view'></span>

<h3>Description</h3>

<p>A specific function to visualizethe integration between a point data set and spatila 
network, i.e. results returned by the function <code><a href="#topic+points2network">points2network</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ptsinnt.view(ntdata, nodelist, pointsxy, CoorespondIDs, VElist=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ptsinnt.view_+3A_ntdata">ntdata</code></td>
<td>
<p>A &ldquo;SpatialLinesDataFrame&rdquo; or &ldquo;SpatialLines&rdquo; object</p>
</td></tr>
<tr><td><code id="ptsinnt.view_+3A_nodelist">nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="ptsinnt.view_+3A_pointsxy">pointsxy</code></td>
<td>
<p>A two-column matrix of point coordinates (X, Y)</p>
</td></tr>
<tr><td><code id="ptsinnt.view_+3A_coorespondids">CoorespondIDs</code></td>
<td>
<p>A vector of the cooresponding node ID for each point in &ldquo;pointsxy&rdquo;</p>
</td></tr>
<tr><td><code id="ptsinnt.view_+3A_velist">VElist</code></td>
<td>
<p>A list of virtual edges if added, i.e. approaches 3 and 4 are used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+points2network">points2network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ORN)
#pts&lt;-spsample(ORN.nt, 100, type="random")
#ptsxy&lt;-coordinates(pts)[,1:2]
#ptsxy&lt;-cbind(ptsxy[,1]+0.008,ptsxy[,2]+0.008)
#Mapping each point to the nearest node in the network/graph
#res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, mapping.method=1)
#Visualize the results without virtual edges 
#ptsinnt.view(ntdata=ORN.nt, nodelist=res[[1]], pointsxy=ptsxy, 
#             CoorespondIDs=res[[3]])
#Visualize the results with virtual edges
#res&lt;-points2network(ntdata=ORN.nt,pointsxy=ptsxy, mapping.method=3,
#                    ea.prop=rep(0,37))
#VElist&lt;-res[[7]]
#ptsinnt.view(ntdata=ORN.nt, nodelist=res[[1]], pointsxy=ptsxy, 
#             CoorespondIDs=res[[3]], VElist=VElist)
</code></pre>

<hr>
<h2 id='readshpnw'>Read a network from a &ldquo;SpatialLines&rdquo; or &ldquo;SpatialLinesDataFrame&rdquo; object</h2><span id='topic+readshpnw'></span>

<h3>Description</h3>

<p>A function to read a spatial network from a &ldquo;SpatialLines&rdquo; or &ldquo;SpatialLinesDataFrame&rdquo; object,
and resolve it into a  &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; and &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; for the following conversion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readshpnw(ntdata, ELComputed=FALSE, longlat=FALSE, Detailed=FALSE, ea.prop=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readshpnw_+3A_ntdata">ntdata</code></td>
<td>
<p>A &ldquo;SpatialLinesDataFrame&rdquo; or &ldquo;SpatialLines&rdquo; object</p>
</td></tr>
<tr><td><code id="readshpnw_+3A_elcomputed">ELComputed</code></td>
<td>
<p>If TRUE, the length of each edge will be calculated and returned</p>
</td></tr>
<tr><td><code id="readshpnw_+3A_longlat">longlat</code></td>
<td>
<p>If TRUE, distances on an ellipse with WGS84 parameters will be returned</p>
</td></tr>
<tr><td><code id="readshpnw_+3A_detailed">Detailed</code></td>
<td>
<p>If TRUE, all the vertices within the polylines of a spatial network
will be recognised as nodes; if FALSE, only two endpoints of 
each polyline are treated as nodes</p>
</td></tr>
<tr><td><code id="readshpnw_+3A_ea.prop">ea.prop</code></td>
<td>
<p>A vector (of the length equalling to the number of edge attributes in
in the network &ldquo;ntdata&rdquo;) with values of 1 or 0:
</p>
<p>1: the corresponding column in the data frame will be kept for 
the new network;
</p>
<p>0: the corresponding column in the data frame will not be kept.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function plays the first step to convert a spatial network (in a &ldquo;SpatialLines&rdquo; 
or &ldquo;SpatialLinesDataFrame&rdquo; object) into an &ldquo;igraph&rdquo; object by returning
a &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; and &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo;. 
</p>


<h3>Value</h3>

<p>A list consisted of:
</p>
<table role = "presentation">
<tr><td><code>Detailed</code></td>
<td>
<p>TRUE if the output is under a &ldquo;Detailed&rdquo; mode;</p>
</td></tr>
<tr><td><code>nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code>edgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code>Edgelength</code></td>
<td>
<p>If &ldquo;ELComputed&rdquo; is TRUE, lengths of all the edges will be 
returned as a numeric vector; otherwise it will be NULL.</p>
</td></tr>
<tr><td><code>Eadf</code></td>
<td>
<p>A data frame of attributes of the returned edges, of which the structure is
a data frame with [EdgeID,(attributes inherited from the input network data)]</p>
</td></tr>
<tr><td><code>nodexlist</code></td>
<td>
<p>A vector contains X-coordinates of all the nodes</p>
</td></tr>
<tr><td><code>nodeylist</code></td>
<td>
<p>A vector contains Y-coordinates of all the nodes</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ORN)
rtNEL&lt;-readshpnw(ORN.nt)
nl&lt;-rtNEL[[2]]
el&lt;-rtNEL[[3]]
#Compute edge length
rtNEL&lt;-readshpnw(ORN.nt, ELComputed=TRUE)
edgelength&lt;-rtNEL[[4]]
eadf&lt;-rtNEL[[5]]
</code></pre>

<hr>
<h2 id='Redef.functions'>A collection of functions for redefining attributes of edited edges</h2><span id='topic+Redef.functions'></span>

<h3>Description</h3>

<p>A function to provide a collection of functions to redefine attributes of edited
edges in the functions <a href="#topic+PN.amalgamation">PN.amalgamation</a> and <a href="#topic+ME.simplification">ME.simplification</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Redef.functions(v, typ=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Redef.functions_+3A_v">v</code></td>
<td>
<p>An input vector for the specified function;</p>
</td></tr>
<tr><td><code id="Redef.functions_+3A_typ">typ</code></td>
<td>
<p> A value equalling to 1, 2, 3 or 4 to specify a redefinition function:
</p>
<p>1-&gt;sum(v)
</p>
<p>2-&gt;min(v)
</p>
<p>3-&gt;max(v)
</p>
<p>4-&gt;mean(v)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is easy to include more specific methods for attribute redefinition via 
incorporating the corresponding functions. In other words, you can define more 
methods by numbering them with 5, 6, etc.  
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>

<hr>
<h2 id='SL.extraction'>Extract self-loops form given network</h2><span id='topic+SL.extraction'></span>

<h3>Description</h3>

<p>A function to extract self-loops away in given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SL.extraction(nodelist, edgelist, eadf=NULL,Directed=F, DegreeL=NULL, 
              InDegreeL=NULL, OutDegreeL=NULL,Nexception=NULL,Eexception=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SL.extraction_+3A_nodelist">nodelist</code></td>
<td>
<p>A &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo; object;</p>
</td></tr>
<tr><td><code id="SL.extraction_+3A_edgelist">edgelist</code></td>
<td>
<p>An &ldquo;<a href="#topic+edgelist">edgelist</a>&rdquo; object</p>
</td></tr>
<tr><td><code id="SL.extraction_+3A_eadf">eadf</code></td>
<td>
<p> A data frame of attributes corresponding to all the edges;</p>
</td></tr>
<tr><td><code id="SL.extraction_+3A_directed">Directed</code></td>
<td>
<p>TRUE if edges are directed, FALSE otherwise;</p>
</td></tr>  
<tr><td><code id="SL.extraction_+3A_degreel">DegreeL</code></td>
<td>
<p>An integer vector of degrees for each node in the given
&ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored if edges are directed</p>
</td></tr>
<tr><td><code id="SL.extraction_+3A_indegreel">InDegreeL</code></td>
<td>
<p>An integer vector of In-degrees for each node 
in the given &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored 
if edges are undirected</p>
</td></tr>
<tr><td><code id="SL.extraction_+3A_outdegreel">OutDegreeL</code></td>
<td>
<p>An integer vector of Out-degrees for each node 
in the given &ldquo;<a href="#topic+nodelist">nodelist</a>&rdquo;, and it could be ignored 
if edges are undirected</p>
</td></tr>
<tr><td><code id="SL.extraction_+3A_nexception">Nexception</code></td>
<td>
<p>A vector of node IDs concerned as exceptions, and all the 
edges with these nodes included won't be processed;</p>
</td></tr>
<tr><td><code id="SL.extraction_+3A_eexception">Eexception</code></td>
<td>
<p>A vector of edge IDs concerned as exceptions, and all these 
edges won't be processed;</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>Two types of list returned for undirected and directed edges, respectively:
</p>
<p>For &ldquo;undirected&rdquo; edges:
</p>
<table role = "presentation">
<tr><td><code>newNodelist</code></td>
<td>
<p>New node list with self-loops removed;</p>
</td></tr>
<tr><td><code>newEdgelist</code></td>
<td>
<p>New edge list with self-loops removed;</p>
</td></tr>
<tr><td><code>newEadf</code></td>
<td>
<p>New attribute data frame for the returned edgelist;</p>
</td></tr>
<tr><td><code>DegreeL</code></td>
<td>
<p>New degree vector cooresponding to the newly returned node list;</p>
</td></tr>
</table>
<p>For &ldquo;directed&rdquo; network:
</p>
<table role = "presentation">
<tr><td><code>newNodelist</code></td>
<td>
<p>New node list with self-loops removed;</p>
</td></tr>
<tr><td><code>newEdgelist</code></td>
<td>
<p>New edgelist with self-loops removed;</p>
</td></tr>
<tr><td><code>newEadf</code></td>
<td>
<p>Data frame of attributes for the newly returned edge list;</p>
</td></tr>
<tr><td><code>InDegreeL</code></td>
<td>
<p>New In-degree vector cooresponding to the newly returned node list;</p>
</td></tr>
<tr><td><code>OutDegreeL</code></td>
<td>
<p>New Out-degree vector cooresponding to the newly returned node list;</p>
</td></tr>  
</table>


<h3>Note</h3>

<p>An edge is recognised as a structure of self-loop when it starts and ends at the 
same point (location).
</p>


<h3>Author(s)</h3>

<p>Binbin Lu <a href="mailto:binbinlu@whu.edu.cn">binbinlu@whu.edu.cn</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+PN.amalgamation">PN.amalgamation</a></code>, <code><a href="#topic+ME.simplification">ME.simplification</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
