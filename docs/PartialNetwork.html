<!DOCTYPE html><html lang="en"><head><title>Help for package PartialNetwork</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PartialNetwork}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PartialNetwork-package'><p>The PartialNetwork package</p></a></li>
<li><a href='#dvMF'><p>Density function of the von Mises-Fisher distribution</p></a></li>
<li><a href='#fit.dnetwork'><p>Fitting Network Distribution using ARD.</p></a></li>
<li><a href='#logCpvMF'><p>Normalization constant of the von Mises-Fisher distribution</p></a></li>
<li><a href='#mcmcARD'><p>Estimate network model using ARD</p></a></li>
<li><a href='#mcmcSAR'><p>Bayesian Estimator of SAR model</p></a></li>
<li><a href='#peer.avg'><p>Computing peer average value</p></a></li>
<li><a href='#plot.mcmcSAR'><p>Plotting estimation of Bayesian SAR model</p></a></li>
<li><a href='#remove.ids'><p>Removes IDs with NA in a list of adjacency matrices optimally</p></a></li>
<li><a href='#rvMF'><p>Simulation from the von Mises-Fisher distribution</p></a></li>
<li><a href='#sim.dnetwork'><p>Simulation of the distribution of the network for Breza et al. (2020)</p></a></li>
<li><a href='#sim.IV'><p>Instrument Variables for SAR model</p></a></li>
<li><a href='#sim.network'><p>Simulating network data</p></a></li>
<li><a href='#smmSAR'><p>Simulated Method of Moments (SMM) Estimator of SAR model</p></a></li>
<li><a href='#summary.mcmcSAR'><p>Summarizing Bayesian SAR Model</p></a></li>
<li><a href='#summary.smmSAR'><p>Summarizing SMM Estimation of SAR model</p></a></li>
<li><a href='#vec.to.mat'><p>Creating objects for network models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Peer Effects Using Partial Network Data</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements IV-estimator and Bayesian estimator for linear-in-means Spatial Autoregressive (SAR) model (see LeSage, 1997 &lt;<a href="https://doi.org/10.1177%2F016001769702000107">doi:10.1177/016001769702000107</a>&gt;; Lee, 2004 &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>&gt;; Bramoull√© et al., 2009 &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2008.12.021">doi:10.1016/j.jeconom.2008.12.021</a>&gt;), while assuming that only a partial information about the network structure is available. Examples are when the adjacency matrix is not fully observed or when only consistent estimation of the network formation model is available (see Boucher and Houndetoungan <a href="https://ahoundetoungan.com/files/Papers/PartialNetwork.pdf">https://ahoundetoungan.com/files/Papers/PartialNetwork.pdf</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ahoundetoungan/PartialNetwork/issues">https://github.com/ahoundetoungan/PartialNetwork/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ahoundetoungan/PartialNetwork">https://github.com/ahoundetoungan/PartialNetwork</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), Formula, formula.tools, abind, Matrix,
parallel, doParallel, foreach, doRNG</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo(&ge; 0.11.4.4.0), RcppEigen,
RcppNumerical, RcppProgress</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AER, knitr, rmarkdown, CDatanet, ggplot2, MASS</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-15 11:12:19 UTC; haache</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincent Boucher [aut],
  Aristide Houndetoungan [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aristide Houndetoungan &lt;ahoundetoungan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-15 11:50:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='PartialNetwork-package'>The PartialNetwork package</h2><span id='topic+PartialNetwork'></span><span id='topic+PartialNetwork-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">PartialNetwork</span> package implements instrumental variables (IV) and Bayesian estimators for the linear-in-mean SAR model (e.g. Bramoulle et al., 2009) when
the distribution of the network is available, but not the network itself. To make the computations faster <span class="pkg">PartialNetwork</span> uses <code>C++</code> through the <span class="pkg">Rcpp</span> package (Eddelbuettel et al., 2011).
</p>


<h3>Details</h3>

<p>Two main functions are provided to estimate the linear-in-mean SAR model using only the distribution of the network. The function
<code><a href="#topic+sim.IV">sim.IV</a></code> generates valid instruments using the distribution of the network (see Propositions 1 and 2 in Boucher and Houndetoungan (2020)). Once the instruments are constructed,
one can estimate the model using standard IV estimators. We recommend the function <a href="AER.html#topic+ivreg">ivreg</a>
from the package <span class="pkg">AER</span> (Kleiber et al., 2020). The function <a href="#topic+mcmcSAR">mcmcSAR</a> performs a Bayesian estimation based on an adaptive MCMC (Atchade and Rosenthal, 2005). In that case,
the distribution of the network acts as prior distribution for the network.<br />
The package <span class="pkg">PartialNetwork</span> also implements a network formation model based on Aggregate Relational Data (McCormick and Zheng, 2015; Breza et al., 2017). This part of the package
relies on the functions <a href="#topic+rvMF">rvMF</a>, <a href="#topic+dvMF">dvMF</a> and <a href="#topic+logCpvMF">logCpvMF</a> partly implemented in C++, but using code from <span class="pkg">movMF</span> (Hornik and Grun, 2014).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Aristide Houndetoungan <a href="mailto:ahoundetoungan@gmail.com">ahoundetoungan@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Vincent Boucher <a href="mailto:vincent.boucher@ecn.ulaval.ca">vincent.boucher@ecn.ulaval.ca</a>
</p>
</li></ul>



<h3>References</h3>

<p>Atchade, Y. F., &amp; Rosenthal, J. S., 2005, On adaptive markov chain monte carlo algorithms, <em>Bernoulli</em>, 11(5), 815-828, <a href="https://doi.org/10.3150/bj/1130077595">doi:10.3150/bj/1130077595</a>.
</p>
<p>Boucher, V., &amp; Houndetoungan, A., 2022, Estimating peer effects using partial network data, <em>Centre de recherche sur les risques les enjeux economiques et les politiques publiques</em>, <a href="https://ahoundetoungan.com/files/Papers/PartialNetwork.pdf">https://ahoundetoungan.com/files/Papers/PartialNetwork.pdf</a>.
</p>
<p>Bramoulle, Y., Djebbari, H., &amp; Fortin, B., 2009, Identification of peer effects through social networks, <em>Journal of econometrics</em>, 150(1), 41-55, <a href="https://doi.org/10.1016/j.jeconom.2008.12.021">doi:10.1016/j.jeconom.2008.12.021</a>.
</p>
<p>Breza, E., Chandrasekhar, A. G., McCormick, T. H., &amp; Pan, M., 2020, Using aggregated relational data to feasibly identify network structure without network data, <em>American Economic Review</em>, 110(8), 2454-84, <a href="https://doi.org/10.1257/aer.20170861">doi:10.1257/aer.20170861</a>
</p>
<p>Eddelbuettel, D., Francois, R., Allaire, J., Ushey, K., Kou, Q., Russel, N., ... &amp; Bates, D., 2011,
<span class="pkg">Rcpp</span>: Seamless <span class="rlang"><b>R</b></span> and <code>C++</code> integration, <em>Journal of Statistical Software</em>, 40(8), 1-18, <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>
</p>
<p>Lee, L. F., 2004, Asymptotic distributions of quasi-maximum likelihood estimators for spatial autoregressive models. Econometrica, 72(6), 1899-1925, <a href="https://doi.org/10.1111/j.1468-0262.2004.00558.x">doi:10.1111/j.1468-0262.2004.00558.x</a>
</p>
<p>LeSage, J. P. 1997, Bayesian estimation of spatial autoregressive models, <em>International regional science review</em>, 20(1-2), 113-129, <a href="https://doi.org/10.1177/016001769702000107">doi:10.1177/016001769702000107</a>.
</p>
<p>Mardia, K. V., 2014, Statistics of directional data, <em>Academic press</em>.
</p>
<p>McCormick, T. H., &amp; Zheng, T., 2015, Latent surface models for networks using Aggregated Relational Data,
<em>Journal of the American Statistical Association</em>, 110(512), 1684-1695, <a href="https://doi.org/10.1080/01621459.2014.991395">doi:10.1080/01621459.2014.991395</a>.
</p>
<p>Wood, A. T., 1994, Simulation of the von Mises Fisher distribution. <em>Communications in statistics-simulation and computation</em>, 23(1), 157-164. <a href="https://doi.org/10.1080/03610919408813161">doi:10.1080/03610919408813161</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ahoundetoungan/PartialNetwork">https://github.com/ahoundetoungan/PartialNetwork</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ahoundetoungan/PartialNetwork/issues">https://github.com/ahoundetoungan/PartialNetwork/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dvMF'>Density function of the von Mises-Fisher distribution</h2><span id='topic+dvMF'></span>

<h3>Description</h3>

<p>Density function for the von Mises-Fisher distribution
of dimension <code>p</code> with location parameter equal to <code>mu</code> and intensity parameter <code>eta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dvMF(z, theta, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dvMF_+3A_z">z</code></td>
<td>
<p>is a matrix where each row is a spherical coordinate at which the density will be evaluated.</p>
</td></tr>
<tr><td><code id="dvMF_+3A_theta">theta</code></td>
<td>
<p>is a vector of dimension <code>p</code> equal to <code class="reqn">\eta\mu</code>, where <code class="reqn">\eta</code> is the concentration parameter, and
<code class="reqn">\mu</code> the location parameter.</p>
</td></tr>
<tr><td><code id="dvMF_+3A_log.p">log.p</code></td>
<td>
<p>is logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the densities computed at each point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw 1000 vectors from vMF with parameter eta = 1 and mu = c(1,0)
z &lt;- rvMF(1000, c(1,0))

# Compute the density at z
dvMF(z, c(1,0))

# Density of c(0, 1, 0, 0) with the parameter eta = 3 and mu = c(0, 1, 0, 0)
dvMF(matrix(c(0, 1, 0, 0), nrow = 1), c(0, 3, 0, 0))
</code></pre>

<hr>
<h2 id='fit.dnetwork'>Fitting Network Distribution using ARD.</h2><span id='topic+fit.dnetwork'></span>

<h3>Description</h3>

<p><code>fit.dnetwork</code> computes the network distribution using the simulations from the posterior distribution of the
ARD network formation model. The linking probabilities are also computed for individuals without ARD.
The degrees and the gregariousness of the individuals without ARD are computed from the sample with ARD using a k-nearest neighbors method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.dnetwork(
  object,
  X = NULL,
  obsARD = NULL,
  m = NULL,
  burnin = NULL,
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.dnetwork_+3A_object">object</code></td>
<td>
<p><code>estim.ARD</code> object returned by <code><a href="#topic+mcmcARD">mcmcARD</a></code>.</p>
</td></tr>
<tr><td><code id="fit.dnetwork_+3A_x">X</code></td>
<td>
<p>(required when ARD are available for a sample of individuals) is a matrix of variables describing individuals with ARD and those without ARD. This matrix will be used to compute distance between individuals
in the k-nearest neighbors approach.
This could be the matrix of traits (see details).</p>
</td></tr>
<tr><td><code id="fit.dnetwork_+3A_obsard">obsARD</code></td>
<td>
<p>logical vector of length <code>nrow(X)</code> (number of individuals with and without ARD), where the i-th entry equal to <code>TRUE</code> if the i-th individual in <code>X</code> has ARD and <code>FALSE</code> otherwise.
If missing, <code>obsARD = rep(c(TRUE, FALSE), n1, n2)</code>, where <code>n1</code> is the number of individuals with ARD (see details).</p>
</td></tr>
<tr><td><code id="fit.dnetwork_+3A_m">m</code></td>
<td>
<p>number of neighbors used to compute the gregariousness and the degree for individuals without ARD (default value is <code>1</code>).</p>
</td></tr>
<tr><td><code id="fit.dnetwork_+3A_burnin">burnin</code></td>
<td>
<p>number of simulations from the posterior distribution used as burn-in. The network distribution will be computed
used the simulation from the iteration <code>burnin + 1</code>.</p>
</td></tr>
<tr><td><code id="fit.dnetwork_+3A_print">print</code></td>
<td>
<p>logical; if TRUE, the progression will be printed in the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of individuals provided through the arguments <code>traitARD</code> and <code>ARD</code> (when calling the function <code><a href="#topic+mcmcARD">mcmcARD</a></code>) should fit the order of individuals in
<code>X</code> and <code>obsARD</code>. Especially, the i-th row of <code>X[obsARD,]</code> should correspond to the i-th row in <code>traitARD</code> or <code>ARD</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>dnetwork</code></td>
<td>
<p>posterior mean of the network distribution.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>posterior mean of the degree.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>posterior mean of the gregariousness, nu.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
# GENERATE DATA
# Sample size
N  &lt;- 500 
n  &lt;- 300

# ARD parameters
genzeta &lt;- 1
mu      &lt;- -1.35
sigma   &lt;- 0.37
K       &lt;- 12    # number of traits
P       &lt;- 3     # Sphere dimension 

# Generate z (spherical coordinates)
genz    &lt;- rvMF(N,rep(0,P))

# Genetate nu  from a Normal distribution with parameters mu and sigma (The gregariousness)
gennu   &lt;- rnorm(N,mu,sigma)

# compute degrees
gend &lt;- N*exp(gennu)*exp(mu+0.5*sigma^2)*exp(logCpvMF(P,0) - logCpvMF(P,genzeta))

# Link probabilities
Probabilities &lt;- sim.dnetwork(gennu,gend,genzeta,genz) 

# Adjacency matrix
G &lt;- sim.network(Probabilities)

# Generate vk, the trait location
genv &lt;- rvMF(K,rep(0,P))

# set fixed some vk  distant
genv[1,] &lt;- c(1,0,0)
genv[2,] &lt;- c(0,1,0)
genv[3,] &lt;- c(0,0,1)

# eta, the intensity parameter
geneta   &lt;-abs(rnorm(K,2,1))

# Build traits matrix
densityatz      &lt;- matrix(0,N,K)
for(k in 1:K){
  densityatz[,k] &lt;- dvMF(genz,genv[k,]*geneta[k])
}

trait       &lt;- matrix(0,N,K)
NK          &lt;- floor(runif(K, 0.8, 0.95)*colSums(densityatz)/apply(densityatz, 2, max)) 
for (k in 1:K) {
  trait[,k]       &lt;- rbinom(N, 1, NK[k]*densityatz[,k]/sum(densityatz[,k]))
}

# print a percentage of people having a trait
colSums(trait)*100/N

# Build ARD
ARD         &lt;- G %*% trait

# generate b
genb        &lt;- numeric(K)
for(k in 1:K){
  genb[k]   &lt;- sum(G[,trait[,k]==1])/sum(G)
}

############ ARD Posterior distribution ################### 
# EXAMPLE 1: ARD observed for the entire population
# initialization 
d0     &lt;- exp(rnorm(N)); b0 &lt;- exp(rnorm(K)); eta0 &lt;- rep(1,K);
zeta0  &lt;- 1; z0 &lt;- matrix(rvMF(N,rep(0,P)),N); v0 &lt;- matrix(rvMF(K,rep(0,P)),K)

# We need to fix some of the vk and bk for identification (see Breza et al. (2020) for details).
vfixcolumn      &lt;- 1:6
bfixcolumn      &lt;- c(3, 5)
b0[bfixcolumn]  &lt;- genb[bfixcolumn]
v0[vfixcolumn,] &lt;- genv[vfixcolumn,]

start  &lt;- list("z" = z0, "v" = v0, "d" = d0, "b" = b0, "eta" = eta0, "zeta" = zeta0)
# MCMC ARD
out    &lt;- mcmcARD(Y = ARD, traitARD = trait, start = start, fixv = vfixcolumn,
                  consb = bfixcolumn, iteration = 5000)
                  
# fit network distribution
dist   &lt;- fit.dnetwork(out)

plot(rowSums(dist$dnetwork), gend)
abline(0, 1, col = "red")

# EXAMPLE 2: ARD observed for a sample of the population
# observed sample
selectARD   &lt;- sort(sample(1:N, n, FALSE))
traitard    &lt;- trait[selectARD,]
ARD         &lt;- ARD[selectARD,]
logicalARD  &lt;- (1:N) %in% selectARD

# initianalization 
d0     &lt;- exp(rnorm(n)); b0 &lt;- exp(rnorm(K)); eta0 &lt;- rep(1,K);
zeta0  &lt;- 1; z0 &lt;- matrix(rvMF(n,rep(0,P)),n); v0 &lt;- matrix(rvMF(K,rep(0,P)),K)

# We need to fix some of the vk and bk for identification (see Breza et al. (2020) for details).
vfixcolumn      &lt;- 1:6
bfixcolumn      &lt;- c(3, 5)
b0[bfixcolumn]  &lt;- genb[bfixcolumn]
v0[vfixcolumn,] &lt;- genv[vfixcolumn,]

start  &lt;- list("z" = z0, "v" = v0, "d" = d0, "b" = b0, "eta" = eta0, "zeta" = zeta0)
# MCMC ARD
out    &lt;- mcmcARD(Y = ARD, traitARD = traitard, start = start, fixv = vfixcolumn,
                  consb = bfixcolumn, iteration = 5000)
                  
# fit network distribution
dist   &lt;- fit.dnetwork(out, X = trait, obsARD = logicalARD, m = 1)

library(ggplot2)
ggplot(data.frame("etimated.degree" = dist$degree,
                  "true.degree"     = gend,
                  "observed"        = ifelse(logicalARD, TRUE, FALSE)),
       aes(x = etimated.degree, y = true.degree, colour = observed)) +
  geom_point()

</code></pre>

<hr>
<h2 id='logCpvMF'>Normalization constant of the von Mises-Fisher distribution</h2><span id='topic+logCpvMF'></span>

<h3>Description</h3>

<p>log of the Normalization Constant for the von Mises-Fisher distribution
of dimension <code>p</code> with intensity parameter <code>eta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logCpvMF(p, eta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logCpvMF_+3A_p">p</code></td>
<td>
<p>is the dimension of the hypersphere.</p>
</td></tr>
<tr><td><code id="logCpvMF_+3A_eta">eta</code></td>
<td>
<p>is the intensity parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the log of normalization constant of the von Mises-Fisher distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logCpvMF(2, 3.1)
</code></pre>

<hr>
<h2 id='mcmcARD'>Estimate network model using ARD</h2><span id='topic+mcmcARD'></span>

<h3>Description</h3>

<p><code>mcmcARD</code> estimates the network model proposed by Breza et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcARD(
  Y,
  traitARD,
  start,
  fixv,
  consb,
  iteration = 2000L,
  sim.d = TRUE,
  sim.zeta = TRUE,
  hyperparms = NULL,
  ctrl.mcmc = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcARD_+3A_y">Y</code></td>
<td>
<p>is a matrix of ARD. The entry (i, k) is the number of i's friends having the trait k.</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_traitard">traitARD</code></td>
<td>
<p>is the matrix of traits for individuals with ARD. The entry (i, k) is equal to 1 if i has the trait k and 0 otherwise.</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_start">start</code></td>
<td>
<p>is a list containing starting values of <code>z</code> (matrix of dimension <code class="reqn">N \times p</code>), <code>v</code> (matrix of dimension <code class="reqn">K \times p</code>),
<code>d</code> (vector of dimension <code class="reqn">N</code>), <code>b</code> (vector of dimension <code class="reqn">K</code>), <code>eta</code> (vector of dimension <code class="reqn">K</code>) and <code>zeta</code> (scalar).</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_fixv">fixv</code></td>
<td>
<p>is a vector setting which location parameters are fixed for identifiability.
These fixed positions are used to rotate the latent surface back to a common orientation at each iteration using
a Procrustes transformation (see Section Identification in Details).</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_consb">consb</code></td>
<td>
<p>is a vector of the subset of <code class="reqn">\beta_k</code> constrained to the total size (see Section Identification in Details).</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_iteration">iteration</code></td>
<td>
<p>is the number of MCMC steps to be performed.</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_sim.d">sim.d</code></td>
<td>
<p>is logical indicating whether the degree <code>d</code> will be updated in the MCMC. If <code>sim.d = FALSE</code>,
the starting value of <code>d</code> in the argument <code>start</code> is set fixed along the MCMC.</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_sim.zeta">sim.zeta</code></td>
<td>
<p>is logical indicating whether the degree <code>zeta</code> will be updated in the MCMC. If <code>sim.zeta = FALSE</code>,
the starting value of <code>zeta</code> in the argument <code>start</code> is set fixed along the MCMC.</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_hyperparms">hyperparms</code></td>
<td>
<p>is an 8-dimensional vector of hyperparameters (in this order) <code class="reqn">\mu_d</code>,  <code class="reqn">\sigma_d</code>,
<code class="reqn">\mu_b</code>, <code class="reqn">\sigma_b</code>, <code class="reqn">\alpha_{\eta}</code>, <code class="reqn">\beta_{\eta}</code>,
<code class="reqn">\alpha_{\zeta}</code> and <code class="reqn">\beta_{\zeta}</code> (see Section Model in Details).</p>
</td></tr>
<tr><td><code id="mcmcARD_+3A_ctrl.mcmc">ctrl.mcmc</code></td>
<td>
<p>is a list of MCMC controls (see Section MCMC control in Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linking probability is given by
</p>


<h4>Model</h4>

<p style="text-align: center;"><code class="reqn">P_{ij} \propto \exp(\nu_i + \nu_j + \zeta\mathbf{z}_i\mathbf{z}_j).</code>
</p>

<p>McCormick and Zheng (2015) write the likelihood of the model with respect to the spherical coordinate <code class="reqn">\mathbf{z}_i</code>,
the trait locations <code class="reqn">\mathbf{v}_k</code>, the degree <code class="reqn">d_i</code>, the fraction of ties in the network that are
made with members of group k <code class="reqn">b_k</code>, the trait intensity parameter <code class="reqn">\eta_k</code> and <code class="reqn">\zeta</code>.
The following
prior distributions are defined.
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{z}_i \sim Uniform ~ von ~ Mises-Fisher</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{v}_k \sim Uniform ~ von ~ Mises-Fisher</code>
</p>

<p style="text-align: center;"><code class="reqn">d_i \sim log-\mathcal{N}(\mu_d, \sigma_d)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_k \sim log-\mathcal{N}(\mu_b, \sigma_b)</code>
</p>

<p style="text-align: center;"><code class="reqn">\eta_k \sim Gamma(\alpha_{\eta}, \beta_{\eta})</code>
</p>

<p style="text-align: center;"><code class="reqn">\zeta \sim Gamma(\alpha_{\zeta}, \beta_{\zeta})</code>
</p>




<h4>Identification</h4>

<p>For identification, some <code class="reqn">\mathbf{v}_k</code> and <code class="reqn">b_k</code> need to be exogenously fixed around their given starting value
(see McCormick and Zheng, 2015 for more details). The parameter <code>fixv</code> can be used
to set the desired value for <code class="reqn">\mathbf{v}_k</code> while <code>fixb</code> can be used to set the desired values for <code class="reqn">b_k</code>.<br />
</p>



<h4>MCMC control</h4>

<p>During the MCMC, the jumping scales are updated following Atchade and Rosenthal (2005) in order to target the acceptance rate of each parameter to the <code>target</code> values. This
requires to set minimal and maximal jumping scales through the parameter <code>ctrl.mcmc</code>. The parameter <code>ctrl.mcmc</code> is a list which can contain the following named components.
</p>

<ul>
<li><p><code>target</code>: The default value is <code>rep(0.44, 5)</code>.
The target of every <code class="reqn">\mathbf{z}_i</code>, <code class="reqn">d_i</code>, <code class="reqn">b_k</code>, <code class="reqn">\eta_k</code> and <code class="reqn">\zeta</code> is  0.44.
</p>
</li>
<li><p><code>jumpmin</code>: The default value is <code>c(0,1,1e-7,1e-7,1e-7)*1e-5</code>.
The minimal jumping of every <code class="reqn">\mathbf{z}_i</code> is 0, every <code class="reqn">d_i</code> is <code class="reqn">10^{-5}</code>, and every <code class="reqn">b_k</code>, <code class="reqn">\eta_k</code> and <code class="reqn">\zeta</code> is <code class="reqn">10^{-12}</code>.
</p>
</li>
<li><p><code>jumpmax</code>: The default value is <code>c(100,1,1,1,1)*20</code>. The maximal jumping scale is 20 except for <code class="reqn">\mathbf{z}_i</code> which is set to 2000.
</p>
</li>
<li><p><code>print</code>: A logical value which indicates if the MCMC progression should be printed in the console. The default value is <code>TRUE</code>.
</p>
</li></ul>




<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>dimension of the sample with ARD.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of traits.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>hypersphere dimension.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>elapsed time in second.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of MCMC steps performed.</p>
</td></tr>
<tr><td><code>simulations</code></td>
<td>
<p>simulations from the posterior distribution.</p>
</td></tr>
<tr><td><code>hyperparms</code></td>
<td>
<p>return value of hyperparameters (updated and non updated).</p>
</td></tr>
<tr><td><code>accept.rate</code></td>
<td>
<p>list of acceptance rates.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>starting values.</p>
</td></tr>
<tr><td><code>ctrl.mcmc</code></td>
<td>
<p>return value of <code>ctrl.mcmc</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Sample size
  N       &lt;- 500
  
  # ARD parameters
  genzeta &lt;- 1
  mu      &lt;- -1.35
  sigma   &lt;- 0.37
  K       &lt;- 12    # number of traits
  P       &lt;- 3     # Sphere dimension
  
  
  # Generate z (spherical coordinates)
  genz    &lt;- rvMF(N,rep(0,P))
  
  # Generate nu  from a Normal distribution with parameters mu and sigma (The gregariousness)
  gennu   &lt;- rnorm(N,mu,sigma)
  
  # compute degrees
  gend &lt;- N*exp(gennu)*exp(mu+0.5*sigma^2)*exp(logCpvMF(P,0) - logCpvMF(P,genzeta))
  
  # Link probabilities
  Probabilities &lt;- sim.dnetwork(gennu,gend,genzeta,genz)
  
  # Adjacency matrix
  G &lt;- sim.network(Probabilities)
  
  # Generate vk, the trait location
  genv &lt;- rvMF(K,rep(0,P))
  
  # set fixed some vk  distant
  genv[1,] &lt;- c(1,0,0)
  genv[2,] &lt;- c(0,1,0)
  genv[3,] &lt;- c(0,0,1)
  
  # eta, the intensity parameter
  geneta   &lt;-abs(rnorm(K,2,1))
  
  # Build traits matrix
  densityatz       &lt;- matrix(0,N,K)
  for(k in 1:K){
    densityatz[,k] &lt;- dvMF(genz,genv[k,]*geneta[k])
  }
  
  trait       &lt;- matrix(0,N,K)
  NK          &lt;- floor(runif(K, 0.8, 0.95)*colSums(densityatz)/apply(densityatz, 2, max))
  for (k in 1:K) {
    trait[,k]  &lt;- rbinom(N, 1, NK[k]*densityatz[,k]/sum(densityatz[,k]))
  }
  
  # print a percentage of people having a trait
  colSums(trait)*100/N
  
  # Build ARD
  ARD         &lt;- G %*% trait
  
  # generate b
  genb        &lt;- numeric(K)
  for(k in 1:K){
    genb[k]   &lt;- sum(G[,trait[,k]==1])/sum(G)
  }
  
  ############ ARD Posterior distribution ###################
  # initialization
  d0     &lt;- exp(rnorm(N)); b0 &lt;- exp(rnorm(K)); eta0 &lt;- rep(1,K);
  zeta0  &lt;- 05; z0 &lt;- matrix(rvMF(N,rep(0,P)),N); v0 &lt;- matrix(rvMF(K,rep(0,P)),K)
  
  # We need to fix some of the vk and bk for identification (see Breza et al. (2020) for details).
  vfixcolumn      &lt;- 1:6
  bfixcolumn      &lt;- c(3, 5)
  b0[bfixcolumn]  &lt;- genb[bfixcolumn]
  v0[vfixcolumn,] &lt;- genv[vfixcolumn,]
  start  &lt;- list("z" = z0, "v" = v0, "d" = d0, "b" = b0, "eta" = eta0, "zeta" = zeta0)
  
  # MCMC
  out   &lt;- mcmcARD(Y = ARD, traitARD = trait, start = start, fixv = vfixcolumn,
                   consb = bfixcolumn, iteration = 5000)
  
  # plot simulations
  # plot d
  plot(out$simulations$d[,100], type = "l", col = "blue", ylab = "")
  abline(h = gend[100], col = "red")
  
  # plot coordinates of individuals
  i &lt;- 123 # individual 123
  {
    lapply(1:3, function(x) {
      plot(out$simulations$z[i, x,] , type = "l", ylab = "", col = "blue", ylim = c(-1, 1))
      abline(h = genz[i, x], col = "red")
    })
  }
  
  # plot coordinates of traits
  k &lt;- 8
  {
    lapply(1:3, function(x) {
      plot(out$simulations$v[k, x,] , type = "l", ylab = "", col = "blue", ylim = c(-1, 1))
      abline(h = genv[k, x], col = "red")
    })
  }
</code></pre>

<hr>
<h2 id='mcmcSAR'>Bayesian Estimator of SAR model</h2><span id='topic+mcmcSAR'></span>

<h3>Description</h3>

<p><code>mcmcSAR</code> implements the Bayesian estimator of the linear-in-mean SAR model when only the linking probabilities are available or can be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcSAR(
  formula,
  contextual,
  start,
  G0.obs,
  G0 = NULL,
  mlinks = list(),
  hyperparms = list(),
  ctrl.mcmc = list(),
  iteration = 2000L,
  data
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcSAR_+3A_formula">formula</code></td>
<td>
<p>object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | x1 + x2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables and
the listed variables after the pipe, <code>x1</code>, <code>x2</code> are the contextual observable variables. Other formulas may be
<code>y ~ x1 + x2</code> for the model without contextual effects, <code>y ~ -1 + x1 + x2 | x1 + x2</code> for the model
without intercept, or <code> y ~ x1 + x2 | x2 + x3</code> to allow the contextual variables to be different from the individual variables.</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_contextual">contextual</code></td>
<td>
<p>(optional) logical; if true, this means that all individual variables will be set as contextual variables. Set
<code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is equivalent to set formula as <code>y ~ x1 + x2 | x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_start">start</code></td>
<td>
<p>(optional) vector of starting value of the model parameter as <code class="reqn">(\beta' ~ \gamma' ~ \alpha ~ \sigma^2)'</code>,
where <code class="reqn">\beta</code> is the individual variables parameter, <code class="reqn">\gamma</code> is the contextual variables parameter, <code class="reqn">\alpha</code> is the peer effect parameter
and <code class="reqn">\sigma^2</code> the variance of the error term. If the <code>start</code> is missing, a Maximum Likelihood estimator will be used, where
the network matrix is that given through the argument <code>G0</code> (if provided) or generated from it distribution.</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_g0.obs">G0.obs</code></td>
<td>
<p>list of matrices (or simply matrix if the list contains only one matrix) indicating the part of the network data which is observed. If the (i,j)-th element
of the m-th matrix is one, then the element at the same position in the network data will be considered as observed and will not be inferred in the MCMC. In contrast,
if the (i,j)-th element of the m-th matrix is zero, the element at the same position in the network data will be considered as a starting value of the missing link which will be inferred.
<code>G0.obs</code> can also take <code>"none"</code> when no part of the network data is observed (equivalent to the case where all the entries are zeros) and <code>"all"</code> when the network data is fully
observed (equivalent to the case where all the entries are ones).</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_g0">G0</code></td>
<td>
<p>list of sub-network matrices (or simply network matrix if there is only one sub-network). <code>G0</code> is made up of starting values for the entries with missing network data and observed values for the entries with
observed network data. <code>G0</code> is optional when <code>G0.obs = "none"</code>.</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_mlinks">mlinks</code></td>
<td>
<p>list specifying the network formation model (see Section Network formation model in Details).</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_hyperparms">hyperparms</code></td>
<td>
<p>(optional) is a list of hyperparameters (see Section Hyperparameters in Details).</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_ctrl.mcmc">ctrl.mcmc</code></td>
<td>
<p>list of MCMC controls (see Section MCMC control in Details).</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_iteration">iteration</code></td>
<td>
<p>number of MCMC steps to be performed.</p>
</td></tr>
<tr><td><code id="mcmcSAR_+3A_data">data</code></td>
<td>
<p>optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If missing, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>mcmcSAR</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Outcome model</h4>

<p>The model is given by
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{y} = \mathbf{X}\beta + \mathbf{G}\mathbf{X}\gamma + \alpha \mathbf{G}\mathbf{y} + \epsilon.</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">\epsilon \sim N(0, \sigma^2).</code>
</p>

<p>The parameters to estimate in this model are the matrix <code class="reqn">\mathbf{G}</code>, the vectors <code class="reqn">\beta</code>, <code class="reqn">\gamma</code> and the scalar <code class="reqn">\alpha</code>, <code class="reqn">\sigma</code>.
Prior distributions are assumed on <code class="reqn">\mathbf{A}</code>, the adjacency matrix in which <code class="reqn">\mathbf{A}_{ij} = 1</code> if i is  connected to j and
<code class="reqn">\mathbf{A}_{ij} = 0</code> otherwise, and on <code class="reqn">\beta</code>, <code class="reqn">\gamma</code>, <code class="reqn">\alpha</code> and <code class="reqn">\sigma^2</code>.
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{A}_{ij} \sim Bernoulli(\mathbf{P}_{ij})</code>
</p>

<p style="text-align: center;"><code class="reqn">(\beta' ~ \gamma')'|\sigma^2 \sim \mathcal{N}(\mu_{\theta}, \sigma^2\Sigma_{\theta})</code>
</p>

<p style="text-align: center;"><code class="reqn">\zeta = \log\left(\frac{\alpha}{1 - \alpha}\right) \sim \mathcal{N}(\mu_{\zeta}, \sigma_{\zeta}^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma^2 \sim IG(\frac{a}{2}, \frac{b}{2})</code>
</p>

<p>where <code class="reqn">\mathbf{P}</code> is the linking probability. The linking probability is an hyperparameters that can be set fixed or updated using a network formation model.
</p>



<h4>Network formation model</h4>

<p>The linking probability can be set fixed or updated using a network formation model. Information about how <code class="reqn">\mathbf{P}</code> should be handled in in the MCMC can be set through the
argument <code>mlinks</code> which should be a list with named elements. Divers specifications of network formation model are possible. The list assigned to <code>mlist</code> should include
an element named <code>model</code>. The expected values of <code>model</code> are <code>"none"</code> (default value), <code>"logit"</code>, <code>"probit"</code>, and <code>"latent space"</code>.
</p>

<ul>
<li> <p><code>"none"</code> means that the network distribution <code class="reqn">\mathbf{P}</code> is set fixed throughout the MCMC,
</p>
</li>
<li> <p><code>"probit"</code> or <code>"logit"</code> implies that the network distribution <code class="reqn">\mathbf{P}</code> will be updated using a Probit or Logit model,
</p>
</li>
<li> <p><code>"latent spate"</code> means that <code class="reqn">\mathbf{P}</code> will be updated following Breza et al. (2020).</p>
</li></ul>



<h5>Fixed network distribution</h5>

<p>To set <code class="reqn">\mathbf{P}</code> fixed, <code>mlinks</code> could contain,
</p>

<ul>
<li> <p><code>dnetwork</code>, a list, where the m-th elements is the matrix of
link probability in the m-th sub-network.
</p>
</li>
<li> <p><code>model = "none"</code> (optional as <code>"none"</code> is the default value).
</p>
</li></ul>




<h5>Probit and Logit models</h5>

<p>For the Probit and Logit specification as network formation model, the following elements could be declared in <code>mlinks</code>.
</p>

<ul>
<li> <p><code>model = "probit"</code> or <code>model = "logit"</code>.
</p>
</li>
<li> <p><code>mlinks.formula</code> object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the Logit or Probit model. The <code>formula</code> should only specify the explanatory variables, as for example <code>~ x1 + x2</code>,
the variables <code>x1</code> and <code>x2</code> are the dyadic observable characteristics. Each variable should verify <code>length(x) == sum(N^2 - N)</code>,
where <code>N</code> is a vector of the number of individual in each sub-network. Indeed, <code>x</code> will be associated with the entries
<code class="reqn">(1, 2)</code>; <code class="reqn">(1, 3)</code>; <code class="reqn">(1, 4)</code>; ...; <code class="reqn">(2, 1)</code>; <code class="reqn">(2, 3)</code>; <code class="reqn">(2, 4)</code>; ... of the linking probability and
as so, in all the sub-networks. Functions <code><a href="#topic+mat.to.vec">mat.to.vec</a></code> and <code><a href="#topic+vec.to.mat">vec.to.mat</a></code> can be used to convert a list of dyadic variable as in matrix form to a format that suits <code>mlinks.formula</code>.
</p>
</li>
<li> <p><code>weights</code> (optional) is a vector of weights of observed entries. This is important to address the selection problem of observed entries. Default is a vector of ones.
</p>
</li>
<li> <p><code>estimates</code> (optional when a part of the network is observed) is a list containing <code>rho</code>, a vector of the estimates of the Probit or Logit
parameters, and <code>var.rho</code> the covariance matrix of the estimator. These estimates can be automatically computed when a part of the network data is available.
In this case, <code>rho</code> and the unobserved part of the network are updated without using the observed part of the network. The latter is assumed non-stochastic in the MCMC.
In addition, if <code>G0.obs = "none"</code>, <code>estimates</code> should also include <code>N</code>, a vector of the number of individuals in each sub-network.
</p>
</li>
<li> <p><code>prior</code> (optional) is a list containing <code>rho</code>, a vector of the prior beliefs on <code>rho</code>, and <code>var.rho</code> the prior covariance matrix of <code>rho</code>. This input
is relevant only when the observed part of the network is used to update <code>rho</code>, i.e. only when <code>estimates = NULL</code> (so, either <code>estimates</code> or <code>prior</code> should be <code>NULL</code>). <br />
To understand the difference between
<code>estimates</code> and <code>prior</code>, note that <code>estimates</code> includes initial estimates of <code>rho</code> and <code>var.rho</code>, meaning that the observed part of the network is not used in the MCMC
to update <code>rho</code>. In contrast, <code>prior</code> contains the prior beliefs of the user, and therefore, <code>rho</code> is updated using this prior and information from the observed part of the network.
In addition, if <code>G0.obs = "none"</code>, <code>prior</code> should also include <code>N</code>, a vector of the number of individuals in each sub-network.
</p>
</li>
<li> <p><code>mlinks.data</code> optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the dyadic observable characteristics
If missing, the variables will be taken from <code>environment(mlinks.formula)</code>, typically the environment from which <code>mcmcARD</code> is called.
</p>
</li></ul>




<h5>Latent space models</h5>

<p>The following element could be declared in <code>mlinks</code>.
</p>

<ul>
<li> <p><code>model = "latent space"</code>.
</p>
</li>
<li> <p><code>estimates</code> a list of objects of class <code>mcmcARD</code>, where the m-th element is Breza et al. (2020) estimator as returned by the function <code><a href="#topic+mcmcARD">mcmcARD</a></code>
in the m-th sub-network.
</p>
</li>
<li> <p><code>mlinks.data</code> (required only when ARD are partially observed) is a list of matrices, where the m-th element is the variable matrix to use to compute distance between individuals (could be the list of traits) in the m-th sub-network.
The distances will be used to compute gregariousness and coordinates for individuals without ARD by k-nearest neighbors approach.
</p>
</li>
<li> <p><code>obsARD</code> (required only when ARD are partially observed) is a list of logical vectors, where the i-th entry of the m-th vector indicates by <code>TRUE</code> or <code>FALSE</code> if  the i-th individual in the m-th
sub-network has ARD or not.
</p>
</li>
<li> <p><code>mARD</code> (optional, default value is <code style="white-space: pre;">&#8288;rep(1, M&#8288;</code>)) is a vector indicating the number of neighbors to use in each sub-network.
</p>
</li>
<li> <p><code>burninARD</code> (optional) set the burn-in to summarize the posterior distribution in <code>estimates</code>.
</p>
</li></ul>





<h4>Hyperparameters</h4>

<p>All the hyperparameters can be defined through the argument <code>hyperparms</code> (a list) and should be named as follow.
</p>

<ul>
<li> <p><code>mutheta</code>, the prior mean of <code class="reqn">(\beta' ~ \gamma')'|\sigma^2</code>. The default value assumes that
the prior mean is zero.
</p>
</li>
<li> <p><code>invstheta</code> as <code class="reqn">\Sigma_{\theta}^{-1}</code>. The default value is a diagonal matrix with 0.01 on the diagonal.
</p>
</li>
<li> <p><code>muzeta</code>, the prior mean of <code class="reqn">\zeta</code>. The default value is zero.
</p>
</li>
<li> <p><code>invszeta</code>, the inverse of the prior variance of <code class="reqn">\zeta</code> with default value equal to 2.
</p>
</li>
<li> <p><code>a</code> and <code>b</code> which default values equal to 4.2 and 2.2 respectively. This means for example that the prior mean of <code class="reqn">\sigma^2</code> is 1.
</p>
</li></ul>

<p>Inverses are used for the prior variance through the argument <code>hyperparms</code>  in order to allow non informative prior. Set the inverse of the prior
variance to 0 is equivalent to assume a non informative prior.
</p>



<h4>MCMC control</h4>

<p>During the MCMC, the jumping scales of <code class="reqn">\alpha</code> and <code class="reqn">\rho</code> are updated following Atchade and Rosenthal (2005) in order to target the acceptance rate to the <code>target</code> value. This
requires to set a minimal and a maximal jumping scales through the parameter <code>ctrl.mcmc</code>. The parameter <code>ctrl.mcmc</code> is a list which can contain the following named components.
</p>

<ul>
<li><p><code>target</code>: the default value is <code>c("alpha" = 0.44, "rho" = 0.234)</code>.
</p>
</li>
<li><p><code>jumpmin</code>: the default value is <code>c("alpha" = 1e-5, "rho" = 1e-5)</code>.
</p>
</li>
<li><p><code>jumpmax</code>: the default value is <code>c("alpha" = 10, "rho" = 10)</code>.
</p>
</li>
<li><p><code>print.level</code>: an integer in {0, 1, 2} that indicates if the MCMC progression should be printed in the console.
If 0, the MCMC progression is not be printed. If 1 (default value), the progression is printed and if 2,
the simulations from the posterior distribution are printed.
</p>
</li>
<li><p><code>block.max</code>: The maximal number of entries that can be updated simultaneously in <code class="reqn">\mathbf{A}</code>. It might be
more efficient to update simultaneously 2 or 3 entries (see Boucher and Houndetoungan, 2022).
</p>
</li></ul>

<p>If <code>block.max</code> &gt; 1, several entries are randomly chosen from the same row and updated simultaneously. The number of entries chosen is randomly
chosen between 1 and <code>block.max</code>. In addition, the entries are not chosen in order. For example, on the row i, the entries (i, 5) and (i, 9) can be updated simultaneously,
then the entries (i, 1), (i, 3), (i, 8), and so on.
</p>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>n.group</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>vector of each group size.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>elapsed time to run the MCMC in second.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of MCMC steps performed.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>matrix (or list of matrices) containing the simulations.</p>
</td></tr>
<tr><td><code>hyperparms</code></td>
<td>
<p>return value of <code>hyperparms</code>.</p>
</td></tr>
<tr><td><code>mlinks</code></td>
<td>
<p>return value of <code>mlinks</code>.</p>
</td></tr>
<tr><td><code>accept.rate</code></td>
<td>
<p>acceptance rates.</p>
</td></tr>
<tr><td><code>prop.net</code></td>
<td>
<p>proportion of observed network data.</p>
</td></tr>
<tr><td><code>method.net</code></td>
<td>
<p>network formation model specification.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>starting values.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>input value of <code>formula</code> and <code>mlinks.formula</code>.</p>
</td></tr>
<tr><td><code>contextual</code></td>
<td>
<p>input value of <code>contextual</code>.</p>
</td></tr>
<tr><td><code>ctrl.mcmc</code></td>
<td>
<p>return value of <code>ctrl.mcmc</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+smmSAR">smmSAR</a></code>, <code><a href="#topic+sim.IV">sim.IV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We assume that the network is fully observed 
# See our vignette for examples where the network is partially observed 
# Number of groups
M             &lt;- 50
# size of each group
N             &lt;- rep(30,M)
# individual effects
beta          &lt;- c(2,1,1.5)
# contextual effects
gamma         &lt;- c(5,-3)
# endogenous effects
alpha         &lt;- 0.4
# std-dev errors
se            &lt;- 1
# prior distribution
prior         &lt;- runif(sum(N*(N-1)))
prior         &lt;- vec.to.mat(prior, N, normalise = FALSE)
# covariates
X             &lt;- cbind(rnorm(sum(N),0,5),rpois(sum(N),7))
# true network
G0            &lt;- sim.network(prior)
# normalise
G0norm        &lt;- norm.network(G0)
# simulate dependent variable use an external package
y             &lt;- CDatanet::simsar(~ X, contextual = TRUE, Glist = G0norm,
                                  theta = c(alpha, beta, gamma, se))
y             &lt;- y$y
# dataset
dataset       &lt;- as.data.frame(cbind(y, X1 = X[,1], X2 = X[,2]))
out.none1     &lt;- mcmcSAR(formula = y ~ X1 + X2, contextual = TRUE, G0.obs = "all",
                         G0 = G0, data = dataset, iteration = 1e4)
summary(out.none1)
plot(out.none1)
plot(out.none1, plot.type = "dens")

</code></pre>

<hr>
<h2 id='peer.avg'>Computing peer average value</h2><span id='topic+peer.avg'></span>

<h3>Description</h3>

<p><code>peer.avg</code> computes peer average value using network data (as a list) and observable characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peer.avg(Glist, V, export.as.list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peer.avg_+3A_glist">Glist</code></td>
<td>
<p>the adjacency matrix or list sub-adjacency matrix.</p>
</td></tr>
<tr><td><code id="peer.avg_+3A_v">V</code></td>
<td>
<p>vector or matrix of observable characteristics.</p>
</td></tr>
<tr><td><code id="peer.avg_+3A_export.as.list">export.as.list</code></td>
<td>
<p>(optional) boolean to indicate if the output should be a list of matrices or a single matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix product <code>diag(Glist[[1]], Glist[[2]], ...) %*% V</code>, where <code>diag()</code> is the block diagonal operator.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.network">sim.network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## sub-network size
N  &lt;- c(250, 370, 120)  
## rate of friendship
p  &lt;- c(.2, .15, .18)   
## network data
u  &lt;- unlist(lapply(1: 3, function(x) rbinom(N[x]*(N[x] - 1), 1, p[x])))
G  &lt;- vec.to.mat(u, N, normalise = TRUE)

# Generate a vector y
y  &lt;- rnorm(sum(N))

# Compute G%*%y
Gy &lt;- peer.avg(Glist = G, V = y)
</code></pre>

<hr>
<h2 id='plot.mcmcSAR'>Plotting estimation of Bayesian SAR model</h2><span id='topic+plot.mcmcSAR'></span><span id='topic+print.plot.mcmcSAR'></span>

<h3>Description</h3>

<p>Plotting the simulation from the posterior distribution as well as the
density functions of Bayesian SAR model parameter. For more details about the graphical
parameter arguments, see <a href="graphics.html#topic+par">par</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcSAR'
plot(x, plot.type = "sim", burnin = NULL, which.parms = "theta", ...)

## S3 method for class 'plot.mcmcSAR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mcmcSAR_+3A_x">x</code></td>
<td>
<p>object of class &quot;mcmcSAR&quot;, output of the function <code><a href="#topic+mcmcSAR">mcmcSAR</a></code> or object of class &quot;plot.mcmcSAR&quot;, output of the function <code><a href="#topic+plot.mcmcSAR">plot.mcmcSAR</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mcmcSAR_+3A_plot.type">plot.type</code></td>
<td>
<p>character indicating the type of plot: <code>"sim"</code> for plotting the simulation
from the posterior distribution or <code>"dens"</code> for plotting the posterior density functions.</p>
</td></tr>
<tr><td><code id="plot.mcmcSAR_+3A_burnin">burnin</code></td>
<td>
<p>number of MCMC steps which will be considered as burn-in iterations. If <code>NULL</code> (default value),
the 50% first MCMC steps performed are used as burn-in iterations.</p>
</td></tr>
<tr><td><code id="plot.mcmcSAR_+3A_which.parms">which.parms</code></td>
<td>
<p>character indicating the parameters whose the posterior distribution will be plotted: <code>"theta"</code> for
the parameters of the outcome model and <code>"rho"</code> for the parameters of the network formation model.</p>
</td></tr>
<tr><td><code id="plot.mcmcSAR_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods, such as <a href="graphics.html#topic+par">par</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>n.group</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>vector of each group size.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of MCMC steps performed.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>number of MCMC steps which will be considered as burn-in iterations.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>summary of the posterior distribution to be plotted.</p>
</td></tr>
<tr><td><code>hyperparms</code></td>
<td>
<p>return value of <code>hyperparms</code>.</p>
</td></tr>
<tr><td><code>accept.rate</code></td>
<td>
<p>acceptance rate of zeta.</p>
</td></tr>
<tr><td><code>propG0.obs</code></td>
<td>
<p>proportion of observed network data.</p>
</td></tr>
<tr><td><code>method.net</code></td>
<td>
<p>network formation model specification.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>input value of <code>formula</code>.</p>
</td></tr>
<tr><td><code>ctrl.mcmc</code></td>
<td>
<p>return value of <code>ctrl.mcmc</code>.</p>
</td></tr>
<tr><td><code>which.parms</code></td>
<td>
<p>return value of <code>which.parms</code>.</p>
</td></tr>
<tr><td><code>plot.type</code></td>
<td>
<p>type of the plot.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='remove.ids'>Removes IDs with NA in a list of adjacency matrices optimally</h2><span id='topic+remove.ids'></span>

<h3>Description</h3>

<p>The function optimally removes identifiers with NA in a list of adjacency matrices. Many combinations of rows and columns can be deleted
removing many rows and column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.ids(network, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove.ids_+3A_network">network</code></td>
<td>
<p>is a list of adjacency matrices</p>
</td></tr>
<tr><td><code id="remove.ids_+3A_ncores">ncores</code></td>
<td>
<p>is the number of cores to be used to run the program in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of adjacency matrices without missing values and a list of vectors of retained indeces
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(1:25, 5)
A[1, 1] &lt;- NA
A[4, 2] &lt;- NA
remove.ids(A)

B &lt;- matrix(1:100, 10)
B[1, 1] &lt;- NA
B[4, 2] &lt;- NA
B[2, 4] &lt;- NA
B[,8]   &lt;-NA
remove.ids(B)
</code></pre>

<hr>
<h2 id='rvMF'>Simulation from the von Mises-Fisher distribution</h2><span id='topic+rvMF'></span>

<h3>Description</h3>

<p>Random generation for the von Mises-Fisher distribution
of dimension <code>p</code> with location parameter <code>mu</code> and intensity parameter <code>eta</code>
(see Wood, 1994; Mardia, 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvMF(size, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rvMF_+3A_size">size</code></td>
<td>
<p>is the number of simulations.</p>
</td></tr>
<tr><td><code id="rvMF_+3A_theta">theta</code></td>
<td>
<p>is the parameter as <code>eta*mu</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix whose each row is a random draw from the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw 10 vectors from vMF with parameters eta = 1 and mu = c(1,0)
rvMF(10,c(1,0))

# Draw 10 vectors from vMF with parameters eta = sqrt(14) and mu proportional to (2,1,3)
rvMF(10,c(2,1,3))

# Draw from the vMF distribution with mean direction proportional to c(1, -1)
# and concentration parameter 3
rvMF(10, 3 * c(1, -1) / sqrt(2))
</code></pre>

<hr>
<h2 id='sim.dnetwork'>Simulation of the distribution of the network for Breza et al. (2020)</h2><span id='topic+sim.dnetwork'></span>

<h3>Description</h3>

<p>Compute the distribution of the network following  McCormick and Zheng (2015) and Breza et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.dnetwork(nu, d, zeta, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.dnetwork_+3A_nu">nu</code></td>
<td>
<p>is the vector of gregariousness.</p>
</td></tr>
<tr><td><code id="sim.dnetwork_+3A_d">d</code></td>
<td>
<p>is the vector of degrees.</p>
</td></tr>
<tr><td><code id="sim.dnetwork_+3A_zeta">zeta</code></td>
<td>
<p>is a scale parameter that captures the influence of the latent positions on the link probabilities.</p>
</td></tr>
<tr><td><code id="sim.dnetwork_+3A_z">z</code></td>
<td>
<p>is a matrix where each row is a spherical coordinate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of linking probabilities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.network">sim.network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N       &lt;- 500 
zeta    &lt;- 1

# Generate the spherical coordinates
z       &lt;- rvMF(N, c(0, 0, 0))

# Genetate the gregariousness
nu      &lt;- rnorm(N, -1.35, 0.37)

# Generate degrees
d       &lt;- runif(N, 0, 45)

dist    &lt;- sim.dnetwork(nu, d, zeta, z)
</code></pre>

<hr>
<h2 id='sim.IV'>Instrument Variables for SAR model</h2><span id='topic+sim.IV'></span>

<h3>Description</h3>

<p><code>sim.IV</code> generates Instrument Variables (IV) for linear-in-mean SAR models using only the distribution of the network. See Propositions 1 and 2 of Boucher and Houndetoungan (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.IV(
  dnetwork,
  X,
  y = NULL,
  replication = 1L,
  power = 1L,
  exp.network = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.IV_+3A_dnetwork">dnetwork</code></td>
<td>
<p>network matrix of list of sub-network matrices, where the (i, j)-th position is the probability that i be connected to j.</p>
</td></tr>
<tr><td><code id="sim.IV_+3A_x">X</code></td>
<td>
<p>matrix of the individual observable characteristics.</p>
</td></tr>
<tr><td><code id="sim.IV_+3A_y">y</code></td>
<td>
<p>(optional) the endogenous variable as a vector.</p>
</td></tr>
<tr><td><code id="sim.IV_+3A_replication">replication</code></td>
<td>
<p>(optional, default = 1) is the number of repetitions (see details).</p>
</td></tr>
<tr><td><code id="sim.IV_+3A_power">power</code></td>
<td>
<p>(optional, default = 1) is the number of powers of the interaction matrix used to generate the instruments (see details).</p>
</td></tr>
<tr><td><code id="sim.IV_+3A_exp.network">exp.network</code></td>
<td>
<p>(optional, default = FALSE) indicates if simulated network should be exported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bramoulle et al. (2009) show that one can use <code class="reqn">GX</code>, <code class="reqn">G^2X</code>, ..., <code class="reqn">G^P X</code> as instruments for <code class="reqn">Gy</code>, where <code class="reqn">P</code> is the maximal power desired.
<code>sim.IV</code> generate approximation of those instruments, based on Propositions 1 and 2 in Boucher and Houndetoungan (2020) (see also below).
The argument <code>power</code> is the maximal power desired.<br />
When <code class="reqn">Gy</code> and the instruments <code class="reqn">GX</code>, <code class="reqn">G^2X</code>, ..., <code class="reqn">G^P X</code> are not observed,
Boucher and Houndetoungan (2022) show that we can use one drawn from the distribution of the network in order to approximate <code class="reqn">Gy</code>, but that
the same draw should not be used to approximate the instruments. Thus, each component in the function's output gives
<code>G1y</code> and <code>G1X</code> computed with the same network and <code>G2X</code> computed with another network, which can be used in order to approximate the instruments.
This process can be replicated several times and the argument <code>replication</code> can be used to set the number of replications desired.
</p>


<h3>Value</h3>

<p>list of <code>replication</code> components. Each component is a list containing <code>G1y</code> (if the argument <code>y</code> was provided), <code>G1</code> (if <code>exp.network = TRUE</code>), <code>G2</code> (if <code>exp.network = TRUE</code>) , <code>G1X</code>, and
<code>G2X</code> where <code>G1</code> and <code>G2</code> are independent draws of network from the distribution (see details).
</p>
<table role = "presentation">
<tr><td><code>G1y</code></td>
<td>
<p>is an approximation of <code class="reqn">Gy</code>.</p>
</td></tr>
<tr><td><code>G1X</code></td>
<td>
<p>is an approximation of <code class="reqn">G^pX</code>
with the same network draw as that used in <code>G1y</code>. <code>G1X</code> is an array of dimension <code class="reqn">N \times K \times power</code>, where <code class="reqn">K</code> is the number of column in
<code>X</code>. For any <code class="reqn">p \in \{1, 2, ..., power\}</code>, the approximation of <code class="reqn">G^pX</code>
is given by <code>G1X[,,p]</code>.</p>
</td></tr>
<tr><td><code>G2X</code></td>
<td>
<p>is an approximation of <code class="reqn">G^pX</code>
with a different different network. <code>G2X</code> is an array of dimension <code class="reqn">N \times K \times power</code>.
For any <code class="reqn">p \in \{1, 2, ..., power\}</code>, the approximation of <code class="reqn">G^pX</code>
is given by <code>G2X[,,p]</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mcmcSAR">mcmcSAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(AER)
# Number of groups
M             &lt;- 30
# size of each group
N             &lt;- rep(50,M)
# individual effects
beta          &lt;- c(2,1,1.5) 
# endogenous effects
alpha         &lt;- 0.4
# std-dev errors
se            &lt;- 2 
# prior distribution
prior         &lt;- runif(sum(N*(N-1)))
prior         &lt;- vec.to.mat(prior, N, normalise = FALSE)
# covariates
X             &lt;- cbind(rnorm(sum(N),0,5),rpois(sum(N),7))
# true network
G0            &lt;- sim.network(prior)
# normalise 
G0norm        &lt;- norm.network(G0)
# simulate dependent variable use an external package
y             &lt;- CDatanet::simsar(~ X, contextual = FALSE, Glist = G0norm, 
                                     theta = c(alpha, beta, se))
y             &lt;- y$y
# generate instruments 
instr         &lt;- sim.IV(prior, X, y, replication = 1, power = 1)

GY1c1         &lt;- instr[[1]]$G1y       # proxy for Gy (draw 1)
GXc1          &lt;- instr[[1]]$G1X[,,1]  # proxy for GX (draw 1)
GXc2          &lt;- instr[[1]]$G2X[,,1]  # proxy for GX (draw 2)
# build dataset
# keep only instrument constructed using a different draw than the one used to proxy Gy
dataset           &lt;- as.data.frame(cbind(y, X, GY1c1, GXc1, GXc2)) 
colnames(dataset) &lt;- c("y","X1","X2","G1y", "G1X1", "G1X2", "G2X1", "G2X2") 

# Same draws
out.iv1           &lt;- ivreg(y ~ X1 + X2 + G1y | X1 + X2 + G1X1 + G1X2, data = dataset)
summary(out.iv1)

# Different draws
out.iv2           &lt;- ivreg(y ~ X1 + X2 + G1y | X1 + X2 + G2X1 + G2X2, data = dataset)
summary(out.iv2)

</code></pre>

<hr>
<h2 id='sim.network'>Simulating network data</h2><span id='topic+sim.network'></span>

<h3>Description</h3>

<p>Simulating network data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.network(dnetwork, normalise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.network_+3A_dnetwork">dnetwork</code></td>
<td>
<p>is a list of sub-network matrices, where the (i, j)-th position of the m-th matrix is the probability that i be connected to j, with i and j individuals from the m-th network.</p>
</td></tr>
<tr><td><code id="sim.network_+3A_normalise">normalise</code></td>
<td>
<p>boolean takes <code>TRUE</code> if the returned matrices should be row-normalized and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of (row-normalized) adjacency matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.dnetwork">sim.dnetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## sub-network size
N         &lt;- c(250, 370, 120)  
## distribution
dnetwork  &lt;- lapply(N, function(x) matrix(runif(x^2), x))
## network
G         &lt;- sim.network(dnetwork)
</code></pre>

<hr>
<h2 id='smmSAR'>Simulated Method of Moments (SMM) Estimator of SAR model</h2><span id='topic+smmSAR'></span>

<h3>Description</h3>

<p><code>smmSAR</code> implements the Simulated Method of Moments (SMM) estimator of the linear-in-mean SAR model when only the linking probabilities are available or can be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smmSAR(
  formula,
  contextual = FALSE,
  fixed.effects = FALSE,
  dnetwork,
  W = "identity",
  smm.ctr = list(R = 30L, iv.power = 2L, opt.tol = 1e-04, smoother = FALSE, print =
    FALSE),
  cond.var = TRUE,
  data
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smmSAR_+3A_formula">formula</code></td>
<td>
<p>object of class <a href="stats.html#topic+formula">formula</a>: a symbolic description of the model. The <code>formula</code> should be as for example <code>y ~ x1 + x2 | gy | gx1 + gx2</code>
where <code>y</code> is the endogenous vector, the listed variables before the pipe, <code>x1</code>, <code>x2</code> are the individual exogenous variables, <code>gy</code> is the average of <code>y</code> among friends, and
<code>gx1</code>, <code>gx2</code> are the contextual observed variables. If <code>gy</code> is observed and <code>gx1</code>, <code>gx2</code> are not, the formula should be
<code>y ~ x1 + x2 | gy</code>. If <code>gy</code> is not observed and <code>gx1</code>, <code>gx2</code> are, the formula should be <code>y ~ x1 + x2 || gx1 + gx2</code>. If <code>gy</code>, <code>gx1</code>, and <code>gx2</code> are not observed, the
the formula should simply be <code>y ~ x1 + x2</code>.</p>
</td></tr>
<tr><td><code id="smmSAR_+3A_contextual">contextual</code></td>
<td>
<p>logical; if true, this means that all individual variables will be set as contextual variables. In contrast <code><a href="#topic+mcmcSAR">mcmcSAR</a></code>,
<code>formula</code> as <code>y ~ x1 + x2</code> and <code>contextual</code> as <code>TRUE</code> is not equivalent to set formula as <code>y ~ x1 + x2 || gx1 + gx2</code>. <code>formula = y ~ x1 + x2</code> means that <code>gy</code>, <code>gx1</code>, and <code>gx2</code>
are not observed and <code>contextual = TRUE</code> means that the estimated model includes contextual effects.</p>
</td></tr>
<tr><td><code id="smmSAR_+3A_fixed.effects">fixed.effects</code></td>
<td>
<p>logical; if true, group heterogeneity is included as fixed effects.</p>
</td></tr>
<tr><td><code id="smmSAR_+3A_dnetwork">dnetwork</code></td>
<td>
<p>a list, where the m-th elements is the matrix of link probability in the m-th sub-network.</p>
</td></tr>
<tr><td><code id="smmSAR_+3A_w">W</code></td>
<td>
<p>is the weighted-matrix in the objective function of the SMM.</p>
</td></tr>
<tr><td><code id="smmSAR_+3A_smm.ctr">smm.ctr</code></td>
<td>
<p>is the list of some control parameters (see details).</p>
</td></tr>
<tr><td><code id="smmSAR_+3A_cond.var">cond.var</code></td>
<td>
<p>logical; if true the estimator variance conditional on <code>dnetwork</code> will be computed.</p>
</td></tr>
<tr><td><code id="smmSAR_+3A_data">data</code></td>
<td>
<p>optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If missing, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>smmSAR</code> is called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>smm.ctr</code> is the list of some control parameters such as:
</p>

<ul>
<li> <p><code>R</code> numbers of draws R (in the package, we assume S = 1 and T = 1);
</p>
</li>
<li> <p><code>iv.power</code> number of powers of the network matrix <code>G</code> to be used to construct instruments;
</p>
</li>
<li> <p><code>opt.tol</code> optimization tolerance that will be used in <a href="stats.html#topic+optimize">optimize</a>;
</p>
</li>
<li> <p><code>smoother</code> (logical) which indicates if draws should be performed using the smoother simulator;
</p>
</li>
<li> <p><code>h</code> bandwith of the smoother (required if <code>smoother = TRUE</code>);
</p>
</li>
<li> <p><code>print</code> (logical) indicates if the optimization process should be printed step by step.
</p>
</li></ul>



<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>n.group</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>vector of each group size.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>elapsed time to run the SMM in second.</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>vector of estimated parameters.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>input value of <code>formula</code>.</p>
</td></tr>
<tr><td><code>contextual</code></td>
<td>
<p>input value of <code>contextual</code>.</p>
</td></tr>
<tr><td><code>fixed.effects</code></td>
<td>
<p>input value of <code>fixed.effects</code>.</p>
</td></tr>
<tr><td><code>smm.ctr</code></td>
<td>
<p>input value of <code>smm.ctr</code>.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>other details of the model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Number of groups
M        &lt;- 100
# size of each group
N        &lt;- rep(30,M)
# covariates
X        &lt;- cbind(rnorm(sum(N),0,5),rpois(sum(N),7))
# network formation model parameter
rho      &lt;- c(-0.8, 0.2, -0.1)
# individual effects
beta     &lt;- c(2, 1, 1.5, 5, -3)
# endogenous effects
alpha    &lt;- 0.4
# std-dev errors
se       &lt;- 1
# network
tmp      &lt;- c(0, cumsum(N))
X1l      &lt;- lapply(1:M, function(x) X[c(tmp[x] + 1):tmp[x+1],1])
X2l      &lt;- lapply(1:M, function(x) X[c(tmp[x] + 1):tmp[x+1],2])
dist.net &lt;- function(x, y) abs(x - y)
X1.mat   &lt;- lapply(1:M, function(m) {
  matrix(kronecker(X1l[[m]], X1l[[m]], FUN = dist.net), N[m])})
X2.mat   &lt;- lapply(1:M, function(m) {
  matrix(kronecker(X2l[[m]], X2l[[m]], FUN = dist.net), N[m])})
Xnet     &lt;- as.matrix(cbind("Const" = 1,
                            "dX1"   = mat.to.vec(X1.mat),
                            "dX2"   = mat.to.vec(X2.mat)))
ynet     &lt;- Xnet %*% rho
ynet     &lt;- c(1*((ynet + rlogis(length(ynet))) &gt; 0))
G0       &lt;- vec.to.mat(ynet, N, normalise = FALSE)
# normalise
G0norm   &lt;- norm.network(G0)
# Matrix GX
GX       &lt;- peer.avg(G0norm, X)
# simulate dependent variable use an external package
y        &lt;- CDatanet::simsar(~ X, contextual = TRUE, Glist = G0norm,
                             theta = c(alpha, beta, se))
Gy       &lt;- y$Gy
y        &lt;- y$y
# build dataset
dataset           &lt;- as.data.frame(cbind(y, X, Gy, GX))
colnames(dataset) &lt;- c("y","X1","X2", "Gy", "GX1", "GX2")
nNet      &lt;- nrow(Xnet) # network formation model sample size
Aobs      &lt;- sample(1:nNet, round(0.3*nNet)) # We observed 30%
# We can estimate rho using the gml function from the stats package
logestim  &lt;- glm(ynet[Aobs] ~ -1 + Xnet[Aobs,], family = binomial(link = "logit"))
slogestim &lt;- summary(logestim)
rho.est   &lt;- logestim$coefficients
rho.var   &lt;- slogestim$cov.unscaled # we also need the covariance of the estimator

d.logit     &lt;- lapply(1:M, function(x) {
  out       &lt;- 1/(1 + exp(-rho.est[1] - rho.est[2]*X1.mat[[x]] -
                            rho.est[3]*X2.mat[[x]]))
  diag(out) &lt;- 0
  out})
smm.logit   &lt;- smmSAR(y ~ X1 + X2, dnetwork = d.logit, contextual = TRUE,
                      smm.ctr  = list(R = 100L, print = TRUE), data = dataset)
summary(smm.logit, dnetwork = d.logit, data = dataset)

</code></pre>

<hr>
<h2 id='summary.mcmcSAR'>Summarizing Bayesian SAR Model</h2><span id='topic+summary.mcmcSAR'></span><span id='topic+print.summary.mcmcSAR'></span><span id='topic+print.mcmcSAR'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>mcmcSAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcSAR'
summary(object, alpha = 0.95, plot.type = NULL, burnin = NULL, ...)

## S3 method for class 'summary.mcmcSAR'
print(x, ...)

## S3 method for class 'mcmcSAR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mcmcSAR_+3A_object">object</code></td>
<td>
<p>an object of class &quot;mcmcSAR&quot;, output of the function <code><a href="#topic+mcmcSAR">mcmcSAR</a></code>.</p>
</td></tr>
<tr><td><code id="summary.mcmcSAR_+3A_alpha">alpha</code></td>
<td>
<p>(optional, default = 0.95), the significance level of parameter.</p>
</td></tr>
<tr><td><code id="summary.mcmcSAR_+3A_plot.type">plot.type</code></td>
<td>
<p>(optional) a character that indicate if the simulations from the posterior distribution should be printed
(if <code>plot.type = "sim"</code>) or if the posterior distribution densities should be plotted (<code>plot.type = "dens"</code>). The plots can also
done using the method <a href="graphics.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="summary.mcmcSAR_+3A_burnin">burnin</code></td>
<td>
<p>is the number of MCMC steps which will be considered as burn-in iterations. If <code>NULL</code> (default value),
the 50% first MCMC steps performed are used as burn-in iterations.</p>
</td></tr>
<tr><td><code id="summary.mcmcSAR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.mcmcSAR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.mcmcSAR&quot; or &quot;mcmcSAR, output of the functions <code><a href="#topic+summary.mcmcSAR">summary.mcmcSAR</a></code> and
<code><a href="#topic+print.summary.mcmcSAR">print.summary.mcmcSAR</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is smart and allows all the possible arguments with the functions <a href="base.html#topic+summary">summary</a>,
<a href="graphics.html#topic+plot">plot</a>, <a href="graphics.html#topic+par">par</a>... such as <code>col</code>, <code>lty</code>, <code>mfrow</code>... <code>summary.mcmcSAR</code>,
<code>print.summary.mcmcSAR</code> and <code>print.mcmcSAR</code> can be called by <code>summary</code> or <code>print</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>n.group</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>vector of each group size.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>number of MCMC steps performed.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>number of MCMC steps which will be considered as burn-in iterations.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>matrix (or list of matrices) containing the simulations.</p>
</td></tr>
<tr><td><code>hyperparms</code></td>
<td>
<p>return value of <code>hyperparms</code>.</p>
</td></tr>
<tr><td><code>accept.rate</code></td>
<td>
<p>acceptance rate of zeta.</p>
</td></tr>
<tr><td><code>prop.net</code></td>
<td>
<p>proportion of observed network data.</p>
</td></tr>
<tr><td><code>method.net</code></td>
<td>
<p>network formation model specification.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>input value of <code>formula</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>significance level of parameter.</p>
</td></tr>
<tr><td><code>ctrl.mcmc</code></td>
<td>
<p>return value of <code>ctrl.mcmc</code>.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.smmSAR'>Summarizing SMM Estimation of SAR model</h2><span id='topic+summary.smmSAR'></span><span id='topic+print.summary.smmSAR'></span><span id='topic+print.smmSAR'></span>

<h3>Description</h3>

<p>Summary and print methods for the class <code>smmSAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smmSAR'
summary(object, .fun, .args, sim = 30, ncores = 1, dnetwork, data, ...)

## S3 method for class 'summary.smmSAR'
print(x, ...)

## S3 method for class 'smmSAR'
print(x, dnetwork, .fun, .args, sim = NULL, ncores = 1, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.smmSAR_+3A_object">object</code></td>
<td>
<p>an object of class &quot;smmSAR&quot;, output of the function <code><a href="#topic+smmSAR">smmSAR</a></code>.</p>
</td></tr>
<tr><td><code id="summary.smmSAR_+3A_.fun">.fun</code>, <code id="summary.smmSAR_+3A_.args">.args</code></td>
<td>
<p>are used to simulate from the distribution of <code>dnetwork</code>. <code>.fun</code> is the simulator function
where <code>.args</code> is a list of its arguments. Typically <code>do.call(.fun, .args)</code> is supposed to simulate one <code>dnetwork</code> from
the distribution.</p>
</td></tr>
<tr><td><code id="summary.smmSAR_+3A_sim">sim</code></td>
<td>
<p>the number of simulations of <code>dnetwork</code>.</p>
</td></tr>
<tr><td><code id="summary.smmSAR_+3A_ncores">ncores</code></td>
<td>
<p>the number of cores to be used for the simulation. Use a lot of cores for fast simulations.</p>
</td></tr>
<tr><td><code id="summary.smmSAR_+3A_dnetwork">dnetwork</code></td>
<td>
<p>a list, where the m-th elements is the matrix of link probability in the m-th sub-network.</p>
</td></tr>
<tr><td><code id="summary.smmSAR_+3A_data">data</code></td>
<td>
<p>optional data frame, list or environment (or object coercible by <a href="base.html#topic+as.data.frame">as.data.frame</a> to a data frame) containing the variables
in the model. If missing, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>smmSAR</code> is called.</p>
</td></tr>
<tr><td><code id="summary.smmSAR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.smmSAR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.smmSAR&quot; or &quot;smmSAR&quot;, output of the functions <code><a href="#topic+summary.smmSAR">summary.smmSAR</a></code> or
<code><a href="#topic+smmSAR">smmSAR</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table role = "presentation">
<tr><td><code>n.group</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>vector of each group size.</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>vector of estimated parameters.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>input value of <code>formula</code>.</p>
</td></tr>
<tr><td><code>contextual</code></td>
<td>
<p>input value of <code>contextual</code>.</p>
</td></tr>
<tr><td><code>fixed.effects</code></td>
<td>
<p>input value of <code>fixed.effects</code>.</p>
</td></tr>
<tr><td><code>smm.ctr</code></td>
<td>
<p>input value of <code>smm.ctr</code>.</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>other details of the model.</p>
</td></tr>
</table>

<hr>
<h2 id='vec.to.mat'>Creating objects for network models</h2><span id='topic+vec.to.mat'></span><span id='topic+mat.to.vec'></span><span id='topic+norm.network'></span>

<h3>Description</h3>

<p><code>vec.to.mat</code> creates a list of square matrices from a given vector.
The elements of the generated matrices are taken from the vector and placed column-wise (ie. the first column is filled up before filling the second column) and from the first matrix of the list to the last matrix of the list.
The diagonal of the generated matrices are zeros.
<code>mat.to.vec</code> creates a vector from a given list of square matrices .
The elements of the generated vector are taken from column-wise and from the first matrix of the list to the last matrix of the list, while dropping the diagonal entry.
<code>norm.network</code> row-normalizes matrices in a given list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec.to.mat(u, N, normalise = FALSE, byrow = FALSE)

mat.to.vec(W, ceiled = FALSE, byrow = FALSE)

norm.network(W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec.to.mat_+3A_u">u</code></td>
<td>
<p>numeric vector to convert.</p>
</td></tr>
<tr><td><code id="vec.to.mat_+3A_n">N</code></td>
<td>
<p>vector of sub-network sizes  such that <code>length(u) == sum(N*(N - 1))</code>.</p>
</td></tr>
<tr><td><code id="vec.to.mat_+3A_normalise">normalise</code></td>
<td>
<p>Boolean takes <code>TRUE</code> if the returned matrices should be row-normalized and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="vec.to.mat_+3A_byrow">byrow</code></td>
<td>
<p>Boolean takes <code>TRUE</code> is entries in the matrices should be taken by row and <code>FALSE</code> if they should be taken by column.</p>
</td></tr>
<tr><td><code id="vec.to.mat_+3A_w">W</code></td>
<td>
<p>matrix or list of matrices to convert.</p>
</td></tr>
<tr><td><code id="vec.to.mat_+3A_ceiled">ceiled</code></td>
<td>
<p>Boolean takes <code>TRUE</code> if the given matrices should be ceiled before conversion and <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code>sum(N*(N - 1))</code> or list of <code>length(N)</code> square matrices. The sizes of the matrices are <code style="white-space: pre;">&#8288;N[1], N[2], ...&#8288;</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.network">sim.network</a></code>, <code><a href="#topic+sim.dnetwork">sim.dnetwork</a></code>, <code><a href="#topic+peer.avg">peer.avg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a list of adjacency matrices
## sub-network size
N &lt;- c(250, 370, 120)  
## rate of friendship
p &lt;- c(.2, .15, .18)   
## network data
u &lt;- unlist(lapply(1: 3, function(x) rbinom(N[x]*(N[x] - 1), 1, p[x])))
W &lt;- vec.to.mat(u, N)

# Convert G into a list of row-normalized matrices
G &lt;- norm.network(W)

# recover u
v &lt;- mat.to.vec(G, ceiled = TRUE)
all.equal(u, v)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
