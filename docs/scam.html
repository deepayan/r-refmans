<!DOCTYPE html><html><head><title>Help for package scam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#scam-package'>
<p>Shape Constrained Additive Models</p></a></li>
<li><a href='#anova.scam'><p>Approximate hypothesis tests related to  SCAM fits</p></a></li>
<li><a href='#bfgs_gcv.ubre'><p> Multiple Smoothing Parameter Estimation by GCV/UBRE</p></a></li>
<li><a href='#check.analytical'><p>Checking the analytical gradient of the GCV/UBRE score</p></a></li>
<li><a href='#derivative.scam'><p>Derivative of the univariate smooth model terms</p></a></li>
<li><a href='#formula.scam'><p>SCAM formula</p></a></li>
<li><a href='#gcv.ubre_grad'><p>The GCV/UBRE score value and its gradient</p></a></li>
<li><a href='#linear.functional.terms'><p>Linear functionals of a smooth in GAMs</p></a></li>
<li><a href='#logLik.scam'><p>Log likelihood for a fitted SCAM, for AIC</p></a></li>
<li><a href='#marginal.matrices.tescv.ps'><p>Constructs marginal model matrices for &quot;tescv&quot; and &quot;tescx&quot; bivariate smooths in case of B-splines basis functions for both unconstrained marginal smooths</p></a></li>
<li><a href='#marginal.matrices.tesmi1.ps'><p>Constructs marginal model matrices for &quot;tesmi1&quot; and &quot;tesmd1&quot; bivariate smooths in case of B-splines basis functions</p>
for both unconstrained marginal smooths</a></li>
<li><a href='#marginal.matrices.tesmi2.ps'><p>Constructs marginal model matrices for &quot;tesmi2&quot; and &quot;tesmd2&quot; bivariate smooths in case of B-splines basis functions</p>
for both unconstrained marginal smooths</a></li>
<li><a href='#plot.scam'><p>SCAM plotting</p></a></li>
<li><a href='#Predict.matrix.mpi.smooth'><p>Predict matrix method functions for SCAMs</p></a></li>
<li><a href='#predict.scam'><p>Prediction from fitted SCAM model</p></a></li>
<li><a href='#print.scam'><p>Print a SCAM object</p></a></li>
<li><a href='#qq.scam'><p>QQ plots for scam model residuals</p></a></li>
<li><a href='#residuals.scam'><p>SCAM residuals</p></a></li>
<li><a href='#scam'><p>Shape constrained additive models (SCAM) and integrated smoothness selection</p></a></li>
<li><a href='#scam.check'><p>Some diagnostics for a fitted scam object</p></a></li>
<li><a href='#scam.control'><p>Setting SCAM fitting defaults</p></a></li>
<li><a href='#scam.fit'><p>Newton-Raphson method to fit SCAM</p></a></li>
<li><a href='#shape.constrained.smooth.terms'><p>Shape preserving smooth terms in SCAM</p></a></li>
<li><a href='#smooth.construct.cv.smooth.spec'><p>Constructor for concave P-splines in SCAMs</p></a></li>
<li><a href='#smooth.construct.cx.smooth.spec'><p>Constructor for convex P-splines in SCAMs</p></a></li>
<li><a href='#smooth.construct.mdcv.smooth.spec'><p>Constructor for monotone decreasing and concave P-splines in SCAMs</p></a></li>
<li><a href='#smooth.construct.mdcx.smooth.spec'><p>Constructor for monotone decreasing and convex P-splines in SCAMs</p></a></li>
<li><a href='#smooth.construct.micv.smooth.spec'><p>Constructor for monotone increasing and concave P-splines in SCAMs</p></a></li>
<li><a href='#smooth.construct.micx.smooth.spec'><p>Constructor for monotone increasing and convex P-splines in SCAMs</p></a></li>
<li><a href='#smooth.construct.mifo.smooth.spec'><p>Constructor for monotone increasing SCOP-splines with an additional 'finish at zero' constraint</p></a></li>
<li><a href='#smooth.construct.miso.smooth.spec'><p>Constructor for monotone increasing SCOP-splines with an additional 'start at zero' constraint</p></a></li>
<li><a href='#smooth.construct.mpd.smooth.spec'><p>Constructor for monotone decreasing P-splines in SCAMs</p></a></li>
<li><a href='#smooth.construct.mpi.smooth.spec'><p>Constructor for monotone increasing P-splines in SCAMs</p></a></li>
<li><a href='#smooth.construct.po.smooth.spec'><p>Constructor for SCOP-splines with positivity constraint</p></a></li>
<li><a href='#smooth.construct.tecvcv.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to double concavity constraint</p></a></li>
<li><a href='#smooth.construct.tecxcv.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to mixed constraints: convexity constraint wrt the first covariate and concavity wrt the second one</p></a></li>
<li><a href='#smooth.construct.tecxcx.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to double convexity constraint</p></a></li>
<li><a href='#smooth.construct.tedecv.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to mixed constraints: monotone decreasing constraint wrt the first covariate and concavity wrt the second one</p></a></li>
<li><a href='#smooth.construct.tedecx.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to mixed constraints: monotone decreasing constraint wrt the first covariate and convexity wrt the second one</p></a></li>
<li><a href='#smooth.construct.tedmd.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to double monotone decreasing</p>
constraint</a></li>
<li><a href='#smooth.construct.tedmi.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to double monotone increasing</p>
constraint</a></li>
<li><a href='#smooth.construct.temicv.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to mixed constraints: monotone increasing constraint wrt the first covariate and concavity wrt the second one</p></a></li>
<li><a href='#smooth.construct.temicx.smooth.spec'><p>Tensor product smoothing constructor for bivariate function subject to mixed constraints: monotone increasing constraint wrt the first covariate and convexity wrt the second one</p></a></li>
<li><a href='#smooth.construct.tescv.smooth.spec'><p>Tensor product smoothing constructor for a bivariate function concave</p>
in the second covariate</a></li>
<li><a href='#smooth.construct.tescx.smooth.spec'><p>Tensor product smoothing constructor for a bivariate function convex</p>
in the second covariate</a></li>
<li><a href='#smooth.construct.tesmd1.smooth.spec'><p>Tensor product smoothing constructor for a bivariate function monotone decreasing</p>
in the first covariate</a></li>
<li><a href='#smooth.construct.tesmd2.smooth.spec'><p>Tensor product smoothing constructor for a bivariate function monotone decreasing</p>
in the second covariate</a></li>
<li><a href='#smooth.construct.tesmi1.smooth.spec'><p>Tensor product smoothing constructor for a bivariate function monotone increasing</p>
in the first covariate</a></li>
<li><a href='#smooth.construct.tesmi2.smooth.spec'><p>Tensor product smoothing constructor for a bivariate function monotone increasing</p>
in the second covariate</a></li>
<li><a href='#smooth.construct.tismd.smooth.spec'><p>Tensor product interaction with decreasing constraint along the first</p>
covariate and unconstrained along the second covariate
</p></a></li>
<li><a href='#smooth.construct.tismi.smooth.spec'><p>Tensor product interaction with increasing constraint along the first</p>
covariate and unconstrained along the second covariate
</p></a></li>
<li><a href='#summary.scam'><p>Summary for a SCAM fit</p></a></li>
<li><a href='#vis.scam'><p>Visualization of SCAM objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Natalya Pya &lt;nat.pya@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Natalya Pya &lt;nat.pya@gmail.com&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Shape Constrained Additive Models</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-23</td>
</tr>
<tr>
<td>Description:</td>
<td>Generalized additive models under shape
        constraints on the component functions of the linear predictor.       
        Models can include multiple shape-constrained (univariate
        and bivariate) and unconstrained terms. Routines of the 
        package 'mgcv' are used to set up the model matrix, print, 
        and plot the results. Multiple smoothing parameter 
        estimation by the Generalized Cross Validation or similar.
        See Pya and Wood (2015) &lt;<a href="https://doi.org/10.1007%2Fs11222-013-9448-7">doi:10.1007/s11222-013-9448-7</a>&gt; 
        for an overview. A broad selection of shape-constrained 
        smoothers, linear functionals of smooths with shape constraints,
        and Gaussian models with AR1 residuals. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), mgcv (&ge; 1.8-2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, graphics, Matrix, splines</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nlme</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 08:26:25 UTC; natalya</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='scam-package'>
Shape Constrained Additive Models
</h2><span id='topic+scam-package'></span>

<h3>Description</h3>

<p><code>scam</code> provides functions for generalized additive modelling under shape constraints on the component functions of the linear predictor of the GAM. Models can contain multiple univariate and bivariate shape constrained terms, unconstrained terms and parametric terms. A wide variety of shape constrained smooths covered in <code><a href="#topic+shape.constrained.smooth.terms">shape.constrained.smooth.terms</a></code> are provided.
</p>
<p>The model set-up is similar to that of <code>gam()</code> of the package <code>mgcv</code>, so unconstrained smooths of one or more variables of the <code>mgcv</code> can be included in SCAMs. User-defined smooths can be added as well. SCAM is estimated by penalized log likelihood maximization and provides automatic smoothness selection by minimizing generalized cross validation or similar. A Bayesian approach is used to obtain a covariance matrix of the model coefficients and credible intervals for each smooth. Linear functionals of smooth functions with shape constraints, parametric model terms, simple linear random effects terms, bivariate interaction smooths with increasing/decreasing constraints (smooth ANOVA), and identity link Gaussian models with AR1 residuals are supported.
</p>


<h3>Details</h3>



<p><code>scam</code> provides generalized additive modelling under shape constraints functions <code><a href="#topic+scam">scam</a></code>, <code><a href="#topic+summary.scam">summary.scam</a></code>, <code><a href="#topic+plot.scam">plot.scam</a></code>, <code><a href="#topic+scam.check">scam.check</a></code>, <code><a href="#topic+predict.scam">predict.scam</a></code>, <code><a href="#topic+anova.scam">anova.scam</a></code>, and <code><a href="#topic+vis.scam">vis.scam</a></code>. These are based on the functions of the unconstrained GAM of the package <code>mgcv</code> and are similar in use.  
</p>
<p>The use of <code>scam()</code> is much like the use of <code>gam()</code>, except that within a <code>scam</code> model formula, shape constrained smooths of one or two predictors can be specified using <code>s</code> terms with a type of shape constraints used specified as a letter character string of the argument <code>bs</code>, e.g. <code>s(x, bs="mpi")</code> for smooth subject to increasing constraint. See <code><a href="#topic+shape.constrained.smooth.terms">shape.constrained.smooth.terms</a></code> for a complete overview of what is available. scam model estimation is performed by penalized likelihood maximization, with smoothness selection by GCV, UBRE/AIC criteria. See <code><a href="#topic+scam">scam</a></code>, <code><a href="#topic+linear.functional.terms">linear.functional.terms</a></code> for a short discussion of model specification and some examples. See <code><a href="#topic+scam">scam</a></code> arguments <code>optimizer</code> and <code>optim.method</code>, and <code><a href="#topic+scam.control">scam.control</a></code> for detailed control of scam model fitting. For checking and visualization, see <code><a href="#topic+scam.check">scam.check</a></code>, <code><a href="#topic+plot.scam">plot.scam</a></code>, <code><a href="#topic+qq.scam">qq.scam</a></code> and <code><a href="#topic+vis.scam">vis.scam</a></code>. For extracting fitting results, see <code><a href="#topic+summary.scam">summary.scam</a></code> and <code><a href="#topic+anova.scam">anova.scam</a></code>.
</p>
<p>A Bayesian approach to smooth modelling is used to obtain covariance matrix of the model coefficients and credible intervals for each smooth. <code>Vp</code> element of the fitted object of class <code>scam</code> returns the Bayesian covariance matrix, <code>Ve</code> returns the frequentist estimated covariance matrix for the parameter estimators. The 
frequentist estimated covariance matrix for the reparametrized parameter estimators (obtained using the delta method) is returned in <code>Ve.t</code>, which is particularly useful for testing individual smooth
terms for equality to the zero function (not so useful for CI's as smooths are usually biased).
<code>Vp.t</code> returns the Bayesian covariance matrix for the reparametrized parameters. Frequentist approximations can be used for hypothesis testing based on model comparison; see <code><a href="#topic+anova.scam">anova.scam</a></code> and <code><a href="#topic+summary.scam">summary.scam</a></code> for info on hypothesis testing.
</p>
<p>For a complete list of functions type <code>library(help=scam)</code>.
</p>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt; based partly on <code>mgcv</code> by Simon Wood
</p>
<p>Maintainer: Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood S.N. (2017) Generalized Additive Models: An Introduction with R (2nd edition). Chapman and Hall/CRC Press
</p>
<p>Wood, S.N. (2008) Fast stable direct fitting and smoothness selection for generalized
additive models. Journal of the Royal Statistical Society (B) 70(3):495-518 
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood 
and marginal likelihood estimation of semiparametric generalized linear 
models. Journal of the Royal Statistical Society (B) 73(1):3-36
</p>
<p>The package was part supported by EPSRC grants EP/I000917/1, EP/K005251/1 and the Science Committee of the Ministry of Science and Education of the Republic of Kazakhstan grant #2532/GF3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for scam 
</code></pre>

<hr>
<h2 id='anova.scam'>Approximate hypothesis tests related to  SCAM fits</h2><span id='topic+anova.scam'></span><span id='topic+print.anova.scam'></span>

<h3>Description</h3>

<p>Performs hypothesis tests relating to one or more fitted <code>scam</code> objects.
The function is a clone of <code>anova.gam</code> of the <code>mgcv</code> package. 
</p>
<p>The documentation below is similar to that of object <code><a href="mgcv.html#topic+anova.gam">anova.gam</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
anova(object, ..., dispersion = NULL, test = NULL,
                    freq = FALSE,p.type=0)
## S3 method for class 'anova.scam'
print(x, digits = max(3, getOption("digits") - 3),...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="anova.scam_+3A_object">object</code>, <code id="anova.scam_+3A_...">...</code></td>
<td>
<p> fitted model objects of class <code>scam</code> as produced by <code>scam()</code>.</p>
</td></tr>
<tr><td><code id="anova.scam_+3A_x">x</code></td>
<td>
<p>an <code>anova.scam</code> object produced by a single model call to <code>anova.scam()</code>.</p>
</td></tr> 
<tr><td><code id="anova.scam_+3A_dispersion">dispersion</code></td>
<td>
<p> a value for the dispersion parameter: not normally used.</p>
</td></tr>
<tr><td><code id="anova.scam_+3A_test">test</code></td>
<td>
<p>what sort of test to perform for a multi-model call. One of
<code>"Chisq"</code>, <code>"F"</code> or <code>"Cp"</code>. </p>
</td></tr>
<tr><td><code id="anova.scam_+3A_freq">freq</code></td>
<td>
<p>whether to use frequentist or Bayesian approximations for parametric term 
p-values. See <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code> for details.</p>
</td></tr>
<tr><td><code id="anova.scam_+3A_p.type">p.type</code></td>
<td>
<p>selects exact test statistic to use for single smooth term p-values. See
<code><a href="#topic+summary.scam">summary.scam</a></code> for details.</p>
</td></tr>
<tr><td><code id="anova.scam_+3A_digits">digits</code></td>
<td>
<p>number of digits to use when printing output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> see <code><a href="mgcv.html#topic+anova.gam">anova.gam</a></code> for details.
</p>


<h3>Value</h3>

<p>In the multi-model case <code>anova.scam</code> produces output identical to
<code><a href="stats.html#topic+anova.glm">anova.glm</a></code>, which it in fact uses.
</p>
<p>In the single model case an object of class <code>anova.scam</code> is produced,
which is in fact an object returned from <code><a href="#topic+summary.scam">summary.scam</a></code>.
</p>
<p><code>print.anova.scam</code> simply produces tabulated output.
</p>


<h3>WARNING</h3>

<p> If models 'a' and 'b' differ only in terms with no un-penalized components then 
p values from anova(a,b) are unreliable, and usually much too low.
</p>
<p>Default P-values will usually be wrong for parametric terms penalized using &lsquo;paraPen&rsquo;: use freq=TRUE
to obtain better p-values when the penalties are full rank and represent conventional random effects.
</p>
<p>For a single model, interpretation is similar to drop1, not anova.lm.
</p>


<h3>Author(s)</h3>

<p> Simon N. Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a> </p>


<h3>References</h3>

<p>Scheipl, F., Greven, S. and Kuchenhoff, H. (2008) Size and power of tests for a zero random effect variance or polynomial 
regression in additive and linear mixed models. Comp. Statist. Data Anal. 52, 3283-3299
</p>
<p>Wood, S.N. (2013a) On p-values for smooth components of an extended generalized additive model. Biometrika 100:221-228
</p>
<p>Wood, S.N. (2013b) A simple test for random effects in regression models. Biometrika 100:1005-1010
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+scam">scam</a></code>, <code><a href="#topic+predict.scam">predict.scam</a></code>,
<code><a href="#topic+scam.check">scam.check</a></code>, <code><a href="#topic+summary.scam">summary.scam</a></code>, <code><a href="mgcv.html#topic+anova.gam">anova.gam</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scam)
set.seed(0)
fac &lt;- rep(1:4,20)
x1 &lt;- runif(80)*5
x2 &lt;- runif(80,-1,2)
x3 &lt;- runif(80, 0, 1)
y &lt;- fac+log(x1)/5
y &lt;- y + exp(-1.3*x2) +rnorm(80)*0.1
fac &lt;- factor(fac)
b &lt;- scam(y ~ fac+s(x1,bs="mpi")+s(x2,bs="mpd")+s(x3))

b1 &lt;- scam(y ~ fac+s(x1,bs="mpi")+s(x2,bs="mpd"))
anova(b,b1,test="F")

## b2 &lt;- scam(y ~ fac +s(x1)+s(x2)+te(x1,x2))

</code></pre>

<hr>
<h2 id='bfgs_gcv.ubre'> Multiple Smoothing Parameter Estimation by GCV/UBRE</h2><span id='topic+bfgs_gcv.ubre'></span>

<h3>Description</h3>

<p>Function to efficiently estimate smoothing parameters of SCAM by GCV/UBRE score optimization.
The procedure is outer to the model fitting by the Newton-Raphson method. 
The function uses the BFGS method where the Hessian matrix is updated iteratively at each step.
Backtracking is included to satisfy the sufficient decrease condition.
</p>
<p>The function is not normally called directly, but rather service routines for <code><a href="#topic+scam">scam</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfgs_gcv.ubre(fn=gcv.ubre_grad, rho, ini.fd=TRUE, G, env,
            n.pen=length(rho), typx=rep(1,n.pen), typf=1, control) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfgs_gcv.ubre_+3A_fn">fn</code></td>
<td>
<p>GCV/UBRE Function which returs the GCV/UBRE value and its derivative wrt log smoothing parameter.</p>
</td></tr>
<tr><td><code id="bfgs_gcv.ubre_+3A_rho">rho</code></td>
<td>
<p>log of the initial values of the smoothing parameters.</p>
</td></tr>
<tr><td><code id="bfgs_gcv.ubre_+3A_ini.fd">ini.fd</code></td>
<td>
<p>If TRUE, a finite difference to the Hessian is used to find the initial 
inverse Hessian, otherwise the initial 
inverse Hessian is a diagonal matrix &lsquo;100*I&rsquo;.</p>
</td></tr>
<tr><td><code id="bfgs_gcv.ubre_+3A_g">G</code></td>
<td>
<p>A list of items needed to fit a SCAM.</p>
</td></tr>

<tr><td><code id="bfgs_gcv.ubre_+3A_env">env</code></td>
<td>
<p>Get the enviroment for the model coefficients, their derivatives and the smoothing parameter.</p>
</td></tr>
<tr><td><code id="bfgs_gcv.ubre_+3A_n.pen">n.pen</code></td>
<td>
<p>Smoothing parameter dimension.</p>
</td></tr>
<tr><td><code id="bfgs_gcv.ubre_+3A_typx">typx</code></td>
<td>
<p>A vector whose component is a positive scalar specifying the typical magnitude of sp.</p>
</td></tr>
<tr><td><code id="bfgs_gcv.ubre_+3A_typf">typf</code></td>
<td>
<p>A positive scalar estimating the magnitude of the gcv near the minimum.</p>
</td></tr>
<tr><td><code id="bfgs_gcv.ubre_+3A_control">control</code></td>
<td>
<p>Control option list as returned by <code><a href="#topic+scam.control">scam.control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with the following items:
</p>
<table>
<tr><td><code>gcv.ubre</code></td>
<td>
<p>The optimal value of GCV/UBRE.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>The best value of the log smoothing parameter.</p>
</td></tr>
<tr><td><code>dgcv.ubre</code></td>
<td>
<p>The gradient of the GCV/UBRE.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of iterations taken until convergence.</p>
</td></tr>
<tr><td><code>conv.bfgs</code></td>
<td>
<p>Convergence information indicating why the BFGS terminated (given below).</p>
</td></tr>
<tr><td><code>termcode</code></td>
<td>
<p> An integer code indicating why the optimization process
terminated.
</p>
<p>1: relative gradient is close to zero, current iterate 
probably is a solution.
</p>
<p>2: scaled distance between last two steps less than &lsquo;steptol&rsquo;, current iterate 
probably is a local minimizer, but it's possible that the algorithm is making very slow progress, 
or &lsquo;steptol&rsquo; is too large.
</p>
<p>3: last global step failed to locate a point lower than
estimate.  Either estimate is an approximate
local minimum of the function or <code>steptol</code> is too
small.
</p>
<p>4: iteration limit exceeded.
</p>
<p>5: five consecutive steps of length <code>maxNstep</code> have been taken, it's possible that &lsquo;maxstep&rsquo; is too small.
</p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p>A list of elements returned by the fitting procedure <code>scam.fit</code> for an optimal value of the smoothing parameter.</p>
</td></tr>
<tr><td><code>dgcv.ubre.check</code></td>
<td>
<p>If <code>check.analytical=TRUE</code> this is the finite-difference approximation of the gradient calculated by
<code><a href="#topic+gcv.ubre_grad">gcv.ubre_grad</a></code>, otherwise <code>NULL</code>.</p>
</td></tr> 
<tr><td><code>check.grad</code></td>
<td>
<p>If <code>check.analytical=TRUE</code> this is the relative difference (in 
and finite differenced derivatives calculated by <code><a href="#topic+gcv.ubre_grad">gcv.ubre_grad</a></code>, otherwise <code>NULL</code>.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood and marginal likelihood estimation of semiparametric generalized 
linear models. Journal of the Royal Statistical Society: Series B. 73(1): 1&ndash;34
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scam">scam</a></code>
</p>

<hr>
<h2 id='check.analytical'>Checking the analytical gradient of the GCV/UBRE score
</h2><span id='topic+check.analytical'></span>

<h3>Description</h3>

<p>This function calculates the finite-difference approximation of the GCV/UBRE gradient for the fitted 
model and compares it with the analytical gradient. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.analytical(object, data, del=1e-6,control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.analytical_+3A_object">object</code></td>
<td>
<p>A fitted <code>scam</code> object.</p>
</td></tr>
<tr><td><code id="check.analytical_+3A_data">data</code></td>
<td>
<p>An original data frame or list containing the model response variable and covariates.</p>
</td></tr>
<tr><td><code id="check.analytical_+3A_del">del</code></td>
<td>
<p>A positive scalar (default is 1e-6) giving an increment for finite difference approximation.</p>
</td></tr> 
<tr><td><code id="check.analytical_+3A_control">control</code></td>
<td>
<p>Control option list as returned by <code><a href="#topic+scam.control">scam.control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with the following items:
</p>
<table>
<tr><td><code>dgcv.ubre.fd</code></td>
<td>
<p>The finite-difference approximation of the gradient.</p>
</td></tr>
<tr><td><code>check.grad</code></td>
<td>
<p>The relative difference in percentage between the analytical
and finite differenced derivatives.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scam">scam</a></code>
</p>

<hr>
<h2 id='derivative.scam'>Derivative of the univariate smooth model terms
</h2><span id='topic+derivative.scam'></span>

<h3>Description</h3>

<p>Function to get derivatives of the smooth model terms (currently only of the univariate smooths).
Analytical derivatives for SCOP-splines (shape constrained P-splines), finite difference approximation is used for all others                                   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative.scam(object,smooth.number=1,deriv=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivative.scam_+3A_object">object</code></td>
<td>
<p>fitted scam object</p>
</td></tr> 
<tr><td><code id="derivative.scam_+3A_smooth.number">smooth.number</code></td>
<td>
<p>ordered number of the smooth model term (1,2,...), ordered as in the formula, which derivative is needed to be calculated.</p>
</td></tr>
<tr><td><code id="derivative.scam_+3A_deriv">deriv</code></td>
<td>
<p>either 1 if the 1st derivative is required, or 2 if the 2nd</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>d</code></td>
<td>
<p>values of the derivative of the smooth term.</p>
</td></tr> 
<tr><td><code>se.d</code></td>
<td>
<p>standard errors of the derivative.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scam">scam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 set.seed(2)
n &lt;- 200
x1 &lt;- runif(n)*4-1;
f1 &lt;- exp(4*x1)/(1+exp(4*x1)) # monotone increasing smooth
x2 &lt;- sort(runif(n)*3-1)      # decreasing smooth
f2 &lt;- exp(-1.3*x2)
f &lt;- f1+ f2 
y &lt;- f+ rnorm(n)*0.2
## fit model, results, and plot...
b &lt;- scam(y~ s(x1,k=20,bs="mpi")+s(x2,k=15,bs="mpd"))

d1 &lt;- derivative.scam(b,smooth.number=1,deriv=1)

par(mfrow=c(1,2))

xx &lt;- sort(x1,index=TRUE)
plot(xx$x,d1$d[xx$ix],type="l",xlab=expression(x[1]),
     ylab=expression(df[1]/dx[1]))

d2 &lt;- derivative.scam(b,smooth.number=2,deriv=1)

xx &lt;- sort(x2,index=TRUE)
plot(xx$x,d2$d[xx$ix],type="l",xlab=expression(x[2]),
     ylab=expression(df[2]/dx[2]))

</code></pre>

<hr>
<h2 id='formula.scam'>SCAM formula</h2><span id='topic+formula.scam'></span>

<h3>Description</h3>

<p> Description of <code><a href="#topic+scam">scam</a></code> formula (see <code>gam</code> of the <code>mgcv</code> package for Details), and how to extract it from a fitted <code>scam</code> object.
</p>
<p>The function is a clone of <code>formula.gam</code> of the <code>mgcv</code> package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
formula(x,...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="formula.scam_+3A_x">x</code></td>
<td>
<p> fitted model objects of class <code>scam</code> as produced by <code>scam()</code>.</p>
</td></tr>
<tr><td><code id="formula.scam_+3A_...">...</code></td>
<td>
<p>un-used in this case</p>
</td></tr> 
</table>


<h3>Details</h3>

<p> see <code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code> for details.
</p>


<h3>Value</h3>

<p> Returns the model formula, <code>x$formula</code>. Provided so that <code>anova</code> methods
print an appropriate description of the model.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+scam">scam</a></code></p>

<hr>
<h2 id='gcv.ubre_grad'>The GCV/UBRE score value and its gradient
</h2><span id='topic+gcv.ubre_grad'></span>

<h3>Description</h3>

<p>For the estimation of the SCAM smoothing parameters the GCV/UBRE score is optimized outer to the Newton-Raphson 
procedure of the model fitting. 
This function returns the value of the GCV/UBRE score  and calculates its first derivative 
with respect to the log smoothing parameter using the method of Wood (2009).
</p>
<p>The function is not normally called directly, but rather service routines for <code><a href="#topic+bfgs_gcv.ubre">bfgs_gcv.ubre</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcv.ubre_grad(rho, G, env, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcv.ubre_grad_+3A_rho">rho</code></td>
<td>
<p>log of the initial values of the smoothing parameters.</p>
</td></tr>
<tr><td><code id="gcv.ubre_grad_+3A_g">G</code></td>
<td>
<p>a list of items needed to fit a SCAM.</p>
</td></tr>
<tr><td><code id="gcv.ubre_grad_+3A_env">env</code></td>
<td>
<p>Get the enviroment for the model coefficients, their derivatives and the smoothing parameter.</p>
</td></tr>
<tr><td><code id="gcv.ubre_grad_+3A_control">control</code></td>
<td>
<p>A list of fit control parameters as returned by <code>scam.control</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned with the following items:
</p>
<table>
<tr><td><code>dgcv.ubre</code></td>
<td>
<p>The value of GCV/UBRE gradient.</p>
</td></tr>
<tr><td><code>gcv.ubre</code></td>
<td>
<p>The GCV/UBRE score value.</p>
</td></tr>
<tr><td><code>scale.est</code></td>
<td>
<p>The value of the scale estimate.</p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p>The elements of the fitting procedure <code>monogam.fit</code> for a given value of the smoothing parameter.</p>
</td></tr>
<tr><td><code>dgcv.ubre.check</code></td>
<td>
<p>If <code>check.analytical=TRUE</code> this returns the finite-difference approximation of the gradient.</p>
</td></tr>
<tr><td><code>check.grad</code></td>
<td>
<p>If <code>check.analytical=TRUE</code> this returns the relative difference (in 
and finite differenced derivatives.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press.
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood and marginal likelihood estimation of semiparametric generalized 
linear models. Journal of the Royal Statistical Society: Series B. 73(1): 1&ndash;34
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scam">scam</a></code>, <code><a href="#topic+scam.fit">scam.fit</a></code>, <code><a href="#topic+bfgs_gcv.ubre">bfgs_gcv.ubre</a></code>
</p>

<hr>
<h2 id='linear.functional.terms'>Linear functionals of a smooth in GAMs</h2><span id='topic+linear.functional.terms'></span><span id='topic+function.predictors'></span><span id='topic+signal.regression'></span>

<h3>Description</h3>

<p>Since <code>scam</code> uses the model setup  of <code>gam</code> of the <code>mgcv</code> package, in the same way as in <code>gam</code> <code><a href="#topic+scam">scam</a></code> allows the response variable to depend on linear 
functionals of smooth terms in the s with additional shape constraints.
</p>
<p>See <code>linear.functional.terms(mgcv)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
###########################################
## similar to a "signal" regression 
## example from mgcv() ...
###########################################
library(scam)
## decreasing smooth...
set.seed(4)
rf &lt;- function(x=seq(-1,3,length=100)) {
## generates random functions...
  m &lt;- ceiling(runif(1)*5) ## number of components
  f &lt;- x*0;
  mu &lt;- runif(m,min(x),max(x)); sig &lt;- (runif(m)+.5)*(max(x)-min(x))/10
  for (i in 1:m) f &lt;- f+ dnorm(x,mu[i],sig[i])
  f
}

## simulate 200 functions and store in rows of L...
L &lt;- matrix(NA,200,100) 
for (i in 1:200) L[i,] &lt;- rf()  ## simulate the functional predictors

x &lt;- seq(-1,3,length=100) ## evaluation points
f2 &lt;- function(x) { ## the coefficient function
     -4*exp(4*x)/(1+exp(4*x))  
}
f &lt;- f2(x) 
plot(x,f ,type="l")
y &lt;- L%*%f + rnorm(200)*20 ## simulated response data
X &lt;- matrix(x,200,100,byrow=TRUE) 

b &lt;- scam(y~s(X,by=L,k=20,bs="mpdBy")) 
par(mfrow=c(1,2))
plot(b,shade=TRUE);lines(x,f,col=2); 
## compare with gam() of mgcv package...
g &lt;- gam(y~s(X,by=L,k=20)) 
plot(g,shade=TRUE);lines(x,f,col=2)


## increasing smooth....
L &lt;- matrix(NA,200,100) 
for (i in 1:200) L[i,] &lt;- rf()  ## simulate the functional predictors
x &lt;- seq(-1,3,length=100) ## evaluation points
f2 &lt;- function(x) { ## the coefficient function
     4*exp(4*x)/(1+exp(4*x))  
}
f &lt;- f2(x) 
plot(x,f ,type="l")
y &lt;- L%*%f + rnorm(200)*20 ## simulated response data
X &lt;- matrix(x,200,100,byrow=TRUE) 
b &lt;- scam(y~s(X,by=L,k=20,bs="mpiBy")) 
par(mfrow=c(1,2))
plot(b,shade=TRUE);lines(x,f,col=2); 
## compare with unconstrained fit...
g &lt;- scam(y~s(X,by=L,k=20)) 
plot(g,shade=TRUE);lines(x,f,col=2)


## convex smooth...
 ## simulate 200 functions and store in rows of L...
set.seed(4)
L &lt;- matrix(NA,200,100) 
for (i in 1:200) L[i,] &lt;- rf(x=sort(2*runif(100)-1))  ## simulate the functional predictors

x &lt;- sort(runif(100,-1,1)) ## evaluation points
f2 &lt;- function(x){4*x^2 } ## the coefficient function
f &lt;- f2(x) 
plot(x,f ,type="l")
y &lt;- L%*%f + rnorm(200)*30 ## simulated response data
X &lt;- matrix(x,200,100,byrow=TRUE) 

b &lt;- scam(y~s(X,by=L,k=20,bs="cxBy")) 
par(mfrow=c(1,2))
plot(b,shade=TRUE);lines(x,f,col=2); 

g &lt;- scam(y~s(X,by=L,k=20)) 
plot(g,shade=TRUE);lines(x,f,col=2)

 
## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.scam'>Log likelihood for a fitted SCAM, for AIC
</h2><span id='topic+logLik.scam'></span><span id='topic+AIC.scam'></span>

<h3>Description</h3>

<p>Function to extract the log-likelihood for a fitted <code>scam</code>
model (fitted by penalized likelihood maximization). 
Used by <code>AIC</code>.
</p>
<p>The function is a clone of <code>logLik.gam</code> of the <code>mgcv</code> package. 
</p>
<p>The documentation below is similar to that of object <code><a href="mgcv.html#topic+logLik.gam">logLik.gam</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
logLik(object,...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="logLik.scam_+3A_object">object</code></td>
<td>
<p> fitted model objects of class <code>scam</code> as produced by <code>scam()</code>.</p>
</td></tr>
<tr><td><code id="logLik.scam_+3A_...">...</code></td>
<td>
<p>unused in this case</p>
</td></tr> 
</table>


<h3>Details</h3>

<p> see <code><a href="mgcv.html#topic+logLik.gam">logLik.gam</a></code> for details.
</p>


<h3>Value</h3>

<p>Standard <code>logLik</code> object: see <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>References</h3>

<p>Hastie and Tibshirani, 1990, Generalized Additive Models.
</p>
<p>Wood, S.N. (2008) Fast stable direct fitting and smoothness selection for
generalized additive models. J.R.Statist. Soc. B 70(3):495-518
</p>


<h3>See Also</h3>

  <p><code><a href="stats.html#topic+AIC">AIC</a></code>
</p>

<hr>
<h2 id='marginal.matrices.tescv.ps'>Constructs marginal model matrices for &quot;tescv&quot; and &quot;tescx&quot; bivariate smooths in case of B-splines basis functions for both unconstrained marginal smooths 
</h2><span id='topic+marginal.matrices.tescv.ps'></span>

<h3>Description</h3>

<p>This function returns the marginal model matrices and the list of penalty matrices
for the tensor product bivariate smooth with the single concavity or convexity restriction 
along the second covariate. The marginal smooth functions of both covariates are constructed using the B-spline basis functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.matrices.tescv.ps(x, z, xk, zk, m, q1, q2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.matrices.tescv.ps_+3A_x">x</code></td>
<td>
<p>A numeric vector of the values of the first covariate at which to evaluate the B-spline marginal functions.
The values in <code>x</code> must be between <code>xk[m[1]+2]</code> and
<code>xk[length(xk) - m[1] - 1]</code>.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tescv.ps_+3A_z">z</code></td>
<td>
<p>A numeric vector of the values of the second covariate at which to evaluate the B-spline marginal functions.
The values in <code>z</code> must be between <code>zk[m[2]+2]</code> and
<code>zk[length(zk) - m[2] - 1]</code>.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tescv.ps_+3A_xk">xk</code></td>
<td>
<p>A numeric vector of knot positions for the first covariate, <code>x</code>,  with non-decreasing values.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tescv.ps_+3A_zk">zk</code></td>
<td>
<p>A numeric vector of knot positions for the second covariate,<code>z</code>, with non-decreasing values.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tescv.ps_+3A_m">m</code></td>
<td>
<p>A pair of two numbers where <code>m[i]+1</code> denotes the order of the basis of the <code class="reqn">i^{th}</code> marginal smooth
(e.g. <code>m[i] = 2</code> for a cubic spline.)</p>
</td></tr> 
<tr><td><code id="marginal.matrices.tescv.ps_+3A_q1">q1</code></td>
<td>
<p>A number denoting the basis dimension of the first marginal smooth.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tescv.ps_+3A_q2">q2</code></td>
<td>
<p>A number denoting the basis dimension of the second marginal smooth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is not called directly, but is rather used internally by 
the constructor
</p>
<p><code><a href="#topic+smooth.construct.tescv.smooth.spec">smooth.construct.tescv.smooth.spec</a></code> and <code><a href="#topic+smooth.construct.tescx.smooth.spec">smooth.construct.tescx.smooth.spec</a></code> . 
</p>


<h3>Value</h3>

<table>
<tr><td><code>X1</code></td>
<td>
<p>Marginal model matrix for the first unconstrained marginal smooth.</p>
</td></tr>
<tr><td><code>X2</code></td>
<td>
<p>Marginal model matrix for the second monotonic marginal smooth.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>A list of penalty matrices for this tensor product smooth.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tescv.smooth.spec">smooth.construct.tescv.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.tescx.smooth.spec">smooth.construct.tescx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+marginal.matrices.tesmi1.ps">marginal.matrices.tesmi1.ps</a></code>,
<code><a href="#topic+smooth.construct.tesmd1.smooth.spec">smooth.construct.tesmd1.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.tesmd2.smooth.spec">smooth.construct.tesmd2.smooth.spec</a></code>
</p>

<hr>
<h2 id='marginal.matrices.tesmi1.ps'>Constructs marginal model matrices for &quot;tesmi1&quot; and &quot;tesmd1&quot; bivariate smooths in case of B-splines basis functions 
for both unconstrained marginal smooths 
</h2><span id='topic+marginal.matrices.tesmi1.ps'></span>

<h3>Description</h3>

<p>This function returns the marginal model matrices and the list of penalty matrices
for the tensor product bivariate smooth with the single monotone increasing or decreasing restriction along the first covariate. The 
marginal smooth functions of both covariates are constructed using the B-spline basis functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.matrices.tesmi1.ps(x, z, xk, zk, m, q1, q2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.matrices.tesmi1.ps_+3A_x">x</code></td>
<td>
<p>A numeric vector of the values of the first covariate at which to evaluate the B-spline marginal functions.
The values in <code>x</code> must be between <code>xk[m[1]+2]</code> and
<code>xk[length(xk) - m[1] - 1]</code>.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi1.ps_+3A_z">z</code></td>
<td>
<p>A numeric vector of the values of the second covariate at which to evaluate the B-spline marginal functions.
The values in <code>z</code> must be between <code>zk[m[2]+2]</code> and
<code>zk[length(zk) - m[2] - 1]</code>.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi1.ps_+3A_xk">xk</code></td>
<td>
<p>A numeric vector of knot positions for the first covariate, <code>x</code>,  with non-decreasing values.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi1.ps_+3A_zk">zk</code></td>
<td>
<p>A numeric vector of knot positions for the second covariate,<code>z</code>, with non-decreasing values.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi1.ps_+3A_m">m</code></td>
<td>
<p>A pair of two numbers where <code>m[i]+1</code> denotes the order of the basis of the <code class="reqn">i^{th}</code> marginal smooth
(e.g. <code>m[i] = 2</code> for a cubic spline.)</p>
</td></tr> 
<tr><td><code id="marginal.matrices.tesmi1.ps_+3A_q1">q1</code></td>
<td>
<p>A number denoting the basis dimension of the first marginal smooth.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi1.ps_+3A_q2">q2</code></td>
<td>
<p>A number denoting the basis dimension of the second marginal smooth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is not called directly, but is rather used internally by 
the constructor 
</p>
<p><code><a href="#topic+smooth.construct.tesmi1.smooth.spec">smooth.construct.tesmi1.smooth.spec</a></code> and <code><a href="#topic+smooth.construct.tesmd1.smooth.spec">smooth.construct.tesmd1.smooth.spec</a></code> . 
</p>


<h3>Value</h3>

<table>
<tr><td><code>X1</code></td>
<td>
<p>Marginal model matrix for the first monotonic marginal smooth.</p>
</td></tr>
<tr><td><code>X2</code></td>
<td>
<p>Marginal model matrix for the second unconstrained marginal smooth.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>A list of penalty matrices for this tensor product smooth.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tesmi1.smooth.spec">smooth.construct.tesmi1.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.tesmi2.smooth.spec">smooth.construct.tesmi2.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+marginal.matrices.tesmi2.ps">marginal.matrices.tesmi2.ps</a></code>,
<code><a href="#topic+smooth.construct.tesmd1.smooth.spec">smooth.construct.tesmd1.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.tesmd2.smooth.spec">smooth.construct.tesmd2.smooth.spec</a></code>
</p>

<hr>
<h2 id='marginal.matrices.tesmi2.ps'>Constructs marginal model matrices for &quot;tesmi2&quot; and &quot;tesmd2&quot; bivariate smooths in case of B-splines basis functions 
for both unconstrained marginal smooths 
</h2><span id='topic+marginal.matrices.tesmi2.ps'></span>

<h3>Description</h3>

<p>This function returns the marginal model matrices and the list of penalty matrices
for the tensor product bivariate smooth with the single monotone increasing or decreasing restriction 
along the second covariate. The marginal smooth functions of both covariates are constructed using the 
B-spline basis functions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal.matrices.tesmi2.ps(x, z, xk, zk, m, q1, q2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal.matrices.tesmi2.ps_+3A_x">x</code></td>
<td>
<p>A numeric vector of the values of the first covariate at which to evaluate the B-spline marginal functions.
The values in <code>x</code> must be between <code>xk[m[1]+2]</code> and
<code>xk[length(xk) - m[1] - 1]</code>.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi2.ps_+3A_z">z</code></td>
<td>
<p>A numeric vector of the values of the second covariate at which to evaluate the B-spline marginal functions.
The values in <code>z</code> must be between <code>zk[m[2]+2]</code> and
<code>zk[length(zk) - m[2] - 1]</code>.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi2.ps_+3A_xk">xk</code></td>
<td>
<p>A numeric vector of knot positions for the first covariate, <code>x</code>,  with non-decreasing values.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi2.ps_+3A_zk">zk</code></td>
<td>
<p>A numeric vector of knot positions for the second covariate,<code>z</code>, with non-decreasing values.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi2.ps_+3A_m">m</code></td>
<td>
<p>A pair of two numbers where <code>m[i]+1</code> denotes the order of the basis of the <code class="reqn">i^{th}</code> marginal smooth
(e.g. <code>m[i] = 2</code> for a cubic spline.)</p>
</td></tr> 
<tr><td><code id="marginal.matrices.tesmi2.ps_+3A_q1">q1</code></td>
<td>
<p>A number denoting the basis dimension of the first marginal smooth.</p>
</td></tr>
<tr><td><code id="marginal.matrices.tesmi2.ps_+3A_q2">q2</code></td>
<td>
<p>A number denoting the basis dimension of the second marginal smooth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is not called directly, but is rather used internally by the constructor
</p>
<p><code><a href="#topic+smooth.construct.tesmi2.smooth.spec">smooth.construct.tesmi2.smooth.spec</a></code> and 
<code><a href="#topic+smooth.construct.tesmd2.smooth.spec">smooth.construct.tesmd2.smooth.spec</a></code> . 
</p>


<h3>Value</h3>

<table>
<tr><td><code>X1</code></td>
<td>
<p>Marginal model matrix for the first unconstrained marginal smooth.</p>
</td></tr>
<tr><td><code>X2</code></td>
<td>
<p>Marginal model matrix for the second monotonic marginal smooth.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>A list of penalty matrices for this tensor product smooth.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tesmi1.smooth.spec">smooth.construct.tesmi1.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.tesmi2.smooth.spec">smooth.construct.tesmi2.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+marginal.matrices.tesmi1.ps">marginal.matrices.tesmi1.ps</a></code>,
<code><a href="#topic+smooth.construct.tesmd1.smooth.spec">smooth.construct.tesmd1.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.tesmd2.smooth.spec">smooth.construct.tesmd2.smooth.spec</a></code>
</p>

<hr>
<h2 id='plot.scam'>SCAM plotting
</h2><span id='topic+plot.scam'></span>

<h3>Description</h3>

<p>The function is a clone of the <code>plot.gam</code> of the <code>mgcv</code> package with the differences
in the construction of the Bayesian confidence intervals of the shape constrained smooth terms. The function
takes a fitted <code>scam</code> object produced by <code>scam()</code> and plots the 
component smooth functions that make it up, on the scale of the linear
predictor. Optionally produces term plots for parametric model components
as well.
</p>
<p>Note: The fitted shape constrained smooth functions are centred when plotted, which is done in order to be in line with plots of unconstrained smooths (as in gam()). Although 'zeroed intercept' constraints are applied to deal with identifiability of the scop-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
plot(x,residuals=FALSE,rug=TRUE,se=TRUE,pages=0,select=NULL,scale=-1,
         n=100,n2=40,pers=FALSE,theta=30,phi=30,jit=FALSE,xlab=NULL,
         ylab=NULL,main=NULL,ylim=NULL,xlim=NULL,too.far=0.1,
         all.terms=FALSE,shade=FALSE,shade.col="gray80",
         shift=0,trans=I,seWithMean=FALSE,unconditional = FALSE, 
         by.resids = FALSE,scheme=0,...)
</code></pre>


<h3>Arguments</h3>

<p>The list of the arguments is the same as in <code>plot.gam</code> of the <code>mgcv</code> package.
</p>
<table>
<tr><td><code id="plot.scam_+3A_x">x</code></td>
<td>
<p> a fitted <code>gam</code> object as produced by <code>gam()</code>.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_residuals">residuals</code></td>
<td>
<p>If <code>TRUE</code> then partial residuals are added to plots of 1-D smooths. If <code>FALSE</code> 
then no residuals are added. If this is an array of the correct length then it is used as the array of 
residuals to be used for producing partial residuals. If <code>TRUE</code> then the
residuals are the working residuals from the IRLS iteration weighted by the
IRLS weights. Partial residuals for a smooth term are the
residuals that would be obtained by dropping the term concerned from the model, while leaving all other 
estimates fixed (i.e. the estimates for the term plus the residuals).</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_rug">rug</code></td>
<td>
<p> when TRUE (default) then the covariate to which the plot applies is displayed as a rug plot
at the foot of each plot of a 1-d smooth, and the locations of the
covariates are plotted as points on the contour plot representing a 2-d
smooth.</p>
</td></tr> 
<tr><td><code id="plot.scam_+3A_se">se</code></td>
<td>
<p> when TRUE (default) upper and lower lines are added to the
1-d plots at 2 standard errors
above and below the estimate of the smooth being plotted while for
2-d plots, surfaces at +1 and -1 standard errors are contoured
and overlayed on the contour plot for the estimate. If a
positive number is supplied then this number is multiplied by
the standard errors when calculating standard error curves or
surfaces. See also <code>shade</code>, below. </p>
</td></tr>
<tr><td><code id="plot.scam_+3A_pages">pages</code></td>
<td>
<p> (default 0) the number of pages over which to spread the output. For example, 
if <code>pages=1</code> then all terms will be plotted on one page with the layout performed automatically. 
Set to 0 to have the routine leave all graphics settings as they are. </p>
</td></tr>
<tr><td><code id="plot.scam_+3A_select">select</code></td>
<td>
<p>Allows the  plot for a single model term to be selected for printing. e.g. if you just want the plot for the second smooth term set <code>select=2</code>. </p>
</td></tr>
<tr><td><code id="plot.scam_+3A_scale">scale</code></td>
<td>
<p> set to -1 (default) to have the same y-axis scale for each plot, and to 0 for a 
different y axis for each plot. Ignored if <code>ylim</code> supplied.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_n">n</code></td>
<td>
<p> number of points used for each 1-d plot - for a nice smooth plot this needs to be several times the estimated 
degrees of freedom for the smooth. Default value 100.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_n2">n2</code></td>
<td>
<p>Square root of number of points used to grid estimates of 2-d
functions for contouring.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_pers">pers</code></td>
<td>
<p>Set to <code>TRUE</code> if you want perspective plots for 2-d
terms.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_theta">theta</code></td>
<td>
<p>One of the perspective plot angles.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_phi">phi</code></td>
<td>
<p>The other perspective plot angle.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_jit">jit</code></td>
<td>
<p>Set to TRUE if you want rug plots for 1-d terms to be jittered.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_xlab">xlab</code></td>
<td>
<p>If supplied then this will be used as the x label for all plots.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_ylab">ylab</code></td>
<td>
<p>If supplied then this will be used as the y label for all plots.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_main">main</code></td>
<td>
<p>Used as title (or z axis label) for plots if supplied.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_ylim">ylim</code></td>
<td>
<p>If supplied then this pair of numbers are used as the y limits for each plot.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_xlim">xlim</code></td>
<td>
<p>If supplied then this pair of numbers are used as the x limits for each plot.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_too.far">too.far</code></td>
<td>
<p>If greater than 0 then this is used to determine when a location is too
far from data to be plotted when plotting 2-D smooths. This is useful since smooths tend to go wild away from data.
The data are scaled into the unit square before deciding what to exclude, and <code>too.far</code> is a distance 
within the unit square.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_all.terms">all.terms</code></td>
<td>
<p>if set to <code>TRUE</code> then the partial effects of parametric
model components are also plotted, via a call to <code><a href="stats.html#topic+termplot">termplot</a></code>. Only
terms of order 1 can be plotted in this way.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_shade">shade</code></td>
<td>
<p>Set to <code>TRUE</code> to produce shaded regions as confidence bands
for smooths (not avaliable for parametric terms, which are plotted using <code>termplot</code>).</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_shade.col">shade.col</code></td>
<td>
<p>define the color used for shading confidence bands.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_shift">shift</code></td>
<td>
<p>constant to add to each smooth (on the scale of the linear
predictor) before plotting. Can be useful for some diagnostics, or with <code>trans</code>.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_trans">trans</code></td>
<td>
<p>function to apply to each smooth  (after any shift), before
plotting. <code>shift</code> and <code>trans</code> are occasionally useful as a means for
getting plots on the response scale, when the model consists only of a single smooth.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_sewithmean">seWithMean</code></td>
<td>
<p>if <code>TRUE</code> the component smooths are shown with confidence 
intervals that include the uncertainty about the overall mean. If <code>FALSE</code> then the 
uncertainty relates purely to the centred smooth itself. An extension of the argument
presented in Nychka (1988) suggests that <code>TRUE</code> results in better coverage performance,
and this is also suggested by simulation.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_unconditional">unconditional</code></td>
<td>
<p> if <code>TRUE</code> then the smoothing parameter uncertainty
corrected covariance matrix is used to compute uncertainty
bands, if available. Otherwise the bands treat the smoothing
parameters as fixed.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_by.resids">by.resids</code></td>
<td>
<p>Should partial residuals be plotted for terms with <code>by</code> variables? 
Usually the answer is no, they would be meaningless.</p>
</td></tr>
<tr><td><code id="plot.scam_+3A_scheme">scheme</code></td>
<td>
<p>Integer (0,1 or 2) or integer vector selecting a plotting scheme for each plot. 
<code>scheme == 0</code> produces a smooth curve with dashed curves 
indicating 2 standard error bounds. <code>scheme == 1</code> illustrates the error bounds using a shaded
region. For <code>scheme==0</code>, contour plots are produced for 2-d smooths with the x-axes labelled with the first covariate
name and the y axis with the second covariate name. For 2-d smooths <code>scheme==1</code> produces a perspective plot, while <code>scheme==2</code> produces a heatmap, with overlaid contours. </p>
</td></tr>
<tr><td><code id="plot.scam_+3A_...">...</code></td>
<td>
<p> other graphics parameters to pass on to plotting commands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function generates plots.
</p>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt; based on the <code>plot.gam</code> of the <code>mgcv</code> by Simon Wood
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+scam">scam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulating data...
require(scam)
n &lt;- 200
set.seed(1)
x0 &lt;- rep(1:4,50)
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained smooth term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # monotone increasing smooth
x3 &lt;- runif(n)*5;
f3 &lt;- -log(x3)/5  # monotone decreasing smooth
f &lt;- f1+f2+f3
y &lt;- 2*x0 + f + rnorm(n)*.3
x0 &lt;- factor(x0)

## fit the model and plot ...
b &lt;- scam(y~x0+s(x1,k=15,bs="cr")+s(x2,k=30,bs="mpi")+s(x3,k=30,bs="mpd"))
plot(b,pages=1,residuals=TRUE,all.terms=TRUE,shade=TRUE,shade.col=3)    

## same with EFS and BFGS methods for smoothing parameter and models coefficients estimations...
b &lt;- scam(y~x0+s(x1,k=15,bs="cr")+s(x2,k=30,bs="mpi")+s(x3,k=30,bs="mpd"),optimizer=c("efs","bfgs"))
plot(b,pages=1,residuals=TRUE,all.terms=TRUE,shade=TRUE,shade.col=3)    

## Not run: 
 ## example with 2-d plots...
 ## simulating data...
   set.seed(2)
   n &lt;- 30
   x0 &lt;- rep(1:9,100)
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(runif(n))
   x3 &lt;- runif(n*n, 0, 1)
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
       { f[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i]))+2*sin(pi*x2[j])}
   f1 &lt;- as.vector(t(f))
   f2 &lt;- x3*0
   e &lt;- rnorm(length(f1))*.1
   y &lt;- 2*x0 + f1 + f2 + e
   x0 &lt;- factor(x0)
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x0=x0,x1=x11,x2=x22,x3=x3,y=y)
## fit model  and plot ...
   b &lt;- scam(y~x0+s(x1,x2,k=c(10,10),bs=c("tesmd1","ps"),m=2)+s(x3),data=dat,optimizer="efs")
   op &lt;- par(mfrow=c(2,2))
   plot(b,all.terms=TRUE)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data",pch=19,cex=.3)
   par(op) 
   
## and use of schemes...
   op &lt;- par(mfrow=c(2,2))
   plot(b,all.terms=TRUE,scheme=1)
   par(op)
   op &lt;- par(mfrow=c(2,2))
   plot(b,all.terms=TRUE,scheme=c(2,1))
   par(op)

  
## End(Not run)
</code></pre>

<hr>
<h2 id='Predict.matrix.mpi.smooth'>Predict matrix method functions for SCAMs
</h2><span id='topic+Predict.matrix.mpi.smooth'></span><span id='topic+Predict.matrix.mpd.smooth'></span><span id='topic+Predict.matrix.cx.smooth'></span><span id='topic+Predict.matrix.cv.smooth'></span><span id='topic+Predict.matrix.micx.smooth'></span><span id='topic+Predict.matrix.micv.smooth'></span><span id='topic+Predict.matrix.mdcx.smooth'></span><span id='topic+Predict.matrix.mdcv.smooth'></span><span id='topic+Predict.matrix.po.smooth'></span><span id='topic+Predict.matrix.miso.smooth'></span><span id='topic+Predict.matrix.mifo.smooth'></span><span id='topic+Predict.matrix.tedmd.smooth'></span><span id='topic+Predict.matrix.tedmi.smooth'></span><span id='topic+Predict.matrix.tesmd1.smooth'></span><span id='topic+Predict.matrix.tesmd2.smooth'></span><span id='topic+Predict.matrix.tesmi1.smooth'></span><span id='topic+Predict.matrix.tesmi2.smooth'></span><span id='topic+Predict.matrix.temicx.smooth'></span><span id='topic+Predict.matrix.temicv.smooth'></span><span id='topic+Predict.matrix.tedecx.smooth'></span><span id='topic+Predict.matrix.tedecv.smooth'></span><span id='topic+Predict.matrix.tescx.smooth'></span><span id='topic+Predict.matrix.tescv.smooth'></span><span id='topic+Predict.matrix.tecvcv.smooth'></span><span id='topic+Predict.matrix.tecxcv.smooth'></span><span id='topic+Predict.matrix.tecxcx.smooth'></span><span id='topic+Predict.matrix.mpdBy.smooth'></span><span id='topic+Predict.matrix.mpiBy.smooth'></span><span id='topic+Predict.matrix.cxBy.smooth'></span><span id='topic+Predict.matrix.cvBy.smooth'></span><span id='topic+Predict.matrix.micxBy.smooth'></span><span id='topic+Predict.matrix.micvBy.smooth'></span><span id='topic+Predict.matrix.mdcxBy.smooth'></span><span id='topic+Predict.matrix.mdcvBy.smooth'></span><span id='topic+Predict.matrix.tismi.smooth'></span><span id='topic+Predict.matrix.tismd.smooth'></span>

<h3>Description</h3>

<p>The various built in smooth classes for use with <code><a href="#topic+scam">scam</a></code> have associate 
<code><a href="mgcv.html#topic+Predict.matrix">Predict.matrix</a></code> method functions to enable prediction from the fitted model. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpi.smooth'
Predict.matrix(object, data)
## S3 method for class 'miso.smooth'
Predict.matrix(object, data)
## S3 method for class 'mifo.smooth'
Predict.matrix(object, data)
## S3 method for class 'mpd.smooth'
Predict.matrix(object, data)
## S3 method for class 'cv.smooth'
Predict.matrix(object, data)
## S3 method for class 'cx.smooth'
Predict.matrix(object, data)
## S3 method for class 'micx.smooth'
Predict.matrix(object, data)
## S3 method for class 'micv.smooth'
Predict.matrix(object, data)
## S3 method for class 'mdcx.smooth'
Predict.matrix(object, data)
## S3 method for class 'mdcv.smooth'
Predict.matrix(object, data)
## S3 method for class 'po.smooth'
Predict.matrix(object, data)
## S3 method for class 'mpdBy.smooth'
Predict.matrix(object, data)
## S3 method for class 'mpiBy.smooth'
Predict.matrix(object, data)
## S3 method for class 'cxBy.smooth'
Predict.matrix(object, data)
## S3 method for class 'cvBy.smooth'
Predict.matrix(object, data)
## S3 method for class 'mdcxBy.smooth'
Predict.matrix(object, data)
## S3 method for class 'mdcvBy.smooth'
Predict.matrix(object, data)
## S3 method for class 'micxBy.smooth'
Predict.matrix(object, data)
## S3 method for class 'micvBy.smooth'
Predict.matrix(object, data)
## S3 method for class 'tedmd.smooth'
Predict.matrix(object, data)
## S3 method for class 'tedmi.smooth'
Predict.matrix(object, data)
## S3 method for class 'tesmd1.smooth'
Predict.matrix(object, data)
## S3 method for class 'tesmd2.smooth'
Predict.matrix(object, data)
## S3 method for class 'tesmi1.smooth'
Predict.matrix(object, data)
## S3 method for class 'tesmi2.smooth'
Predict.matrix(object, data)
## S3 method for class 'temicx.smooth'
Predict.matrix(object, data)
## S3 method for class 'temicv.smooth'
Predict.matrix(object, data)
## S3 method for class 'tedecx.smooth'
Predict.matrix(object, data)
## S3 method for class 'tedecv.smooth'
Predict.matrix(object, data)
## S3 method for class 'tescx.smooth'
Predict.matrix(object, data)
## S3 method for class 'tescv.smooth'
Predict.matrix(object, data)
## S3 method for class 'tecvcv.smooth'
Predict.matrix(object, data)
## S3 method for class 'tecxcv.smooth'
Predict.matrix(object, data)
## S3 method for class 'tecxcx.smooth'
Predict.matrix(object, data)
## S3 method for class 'tismi.smooth'
Predict.matrix(object, data)
## S3 method for class 'tismd.smooth'
Predict.matrix(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Predict.matrix.mpi.smooth_+3A_object">object</code></td>
<td>
<p>A smooth object, usually generated by a <code>smooth.construct</code> method having 
processed a smooth specification object generated by an <code>s</code> term in a 
<code><a href="#topic+scam">scam</a></code> formula.</p>
</td></tr>
<tr><td><code id="Predict.matrix.mpi.smooth_+3A_data">data</code></td>
<td>
<p>A data frame containing the values of the named covariates at which the smooth term is to be 
evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix mapping the coefficients for the smooth term to its values at the supplied data values. 
</p>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press.
</p>

<hr>
<h2 id='predict.scam'>Prediction from fitted SCAM model</h2><span id='topic+predict.scam'></span>

<h3>Description</h3>

 
<p>This function is a clone of the <code>mgcv</code> library code <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> with some modifications 
to adopt shape preserving smooth terms.
It takes a fitted <code>scam</code> object produced by <code>scam()</code> 
and produces predictions given a new set of values for the model covariates 
or the original values used for the model fit. Predictions can be accompanied
by standard errors, based on the posterior distribution of the model
coefficients. 
</p>
<p>It now alows prediction outside the range of knots, and use linear extrapolation in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
predict(object,newdata,type="link",se.fit=FALSE,terms=NULL,exclude=NULL,
    block.size=NULL,newdata.guaranteed=FALSE,na.action=na.pass,...)

</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="predict.scam_+3A_object">object</code></td>
<td>
<p> a fitted <code>scam</code> object as produced by <code>scam()</code>.
</p>
</td></tr>
<tr><td><code id="predict.scam_+3A_newdata">newdata</code></td>
<td>
<p> A data frame or list containing the values of the model covariates at which predictions
are required. If this is not provided then predictions corresponding to the
original data are returned. If <code>newdata</code> is provided then
it should contain all the variables needed for prediction: a
warning is generated if not. </p>
</td></tr> 
<tr><td><code id="predict.scam_+3A_type">type</code></td>
<td>
<p> When this has the value <code>"link"</code> (default) the linear predictor (possibly with
associated standard errors) is returned. When <code>type="terms"</code> each component of the 
linear predictor is returned seperately (possibly with standard errors): this includes 
parametric model components, followed by each smooth component, but excludes
any offset and any intercept. <code>type="iterms"</code> is the same, except that any standard errors 
returned for unconstrained smooth components will include the uncertainty about the intercept/overall mean.  When 
<code>type="response"</code> predictions 
on the scale of the response are returned (possibly with approximate
standard errors). When <code>type="lpmatrix"</code> then a matrix is returned
which yields the values of the linear predictor (minus any offset) when
postmultiplied by the
parameter vector (in this case <code>se.fit</code> is ignored). The latter
option is most useful for getting variance estimates for quantities derived from
the model: for example integrated quantities, or derivatives of smooths. A
linear predictor matrix can also be used to implement approximate prediction
outside <code>R</code> (see example code, below). </p>
</td></tr>
<tr><td><code id="predict.scam_+3A_se.fit">se.fit</code></td>
<td>
<p> when this is TRUE (not default) standard error estimates are returned for each prediction.</p>
</td></tr>
<tr><td><code id="predict.scam_+3A_terms">terms</code></td>
<td>
<p>if <code>type=="terms"</code> then only results for the terms given in this array
will be returned.</p>
</td></tr>
<tr><td><code id="predict.scam_+3A_exclude">exclude</code></td>
<td>
<p>if <code>type=="terms"</code> or <code>type="iterms"</code> then terms (smooth or parametric) named
in this array will not be returned. Otherwise any smooth terms named in this
array will be set to zero. If <code>NULL</code> then no terms are excluded.</p>
</td></tr>
<tr><td><code id="predict.scam_+3A_block.size">block.size</code></td>
<td>
<p>maximum number of predictions to process per call to underlying
code: larger is quicker, but more memory intensive. Set to &lt; 1 to use total number
of predictions as this.</p>
</td></tr>
<tr><td><code id="predict.scam_+3A_newdata.guaranteed">newdata.guaranteed</code></td>
<td>
<p>Set to <code>TRUE</code> to turn off all checking of
<code>newdata</code> except for sanity of factor levels: this can speed things up
for large prediction tasks, but <code>newdata</code> must be complete, with no
<code>NA</code> values for predictors required in the model. </p>
</td></tr>
<tr><td><code id="predict.scam_+3A_na.action">na.action</code></td>
<td>
<p>what to do about <code>NA</code> values in <code>newdata</code>. With the
default <code>na.pass</code>, any row of <code>newdata</code> containing <code>NA</code> values
for required predictors, gives rise to <code>NA</code> predictions (even if the term concerned has no
<code>NA</code> predictors). <code>na.exclude</code> or <code>na.omit</code> result in the
dropping of <code>newdata</code> rows, if they contain any <code>NA</code> values for
required predictors. If <code>newdata</code> is missing then <code>NA</code> handling is 
determined from <code>object$na.action</code>.</p>
</td></tr>
<tr><td><code id="predict.scam_+3A_...">...</code></td>
<td>
<p> other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> for details.
</p>


<h3>Value</h3>

<p> If <code>type=="lpmatrix"</code> then a matrix is returned which will
give a vector of linear predictor values (minus any offest) at the supplied covariate
values, when applied to the model coefficient vector. 
Otherwise, if <code>se.fit</code> is <code>TRUE</code> then a 2 item list is returned with items (both arrays) <code>fit</code>
and <code>se.fit</code> containing predictions and associated standard error estimates, otherwise an 
array of predictions is returned. The dimensions of the returned arrays depends on whether 
<code>type</code> is <code>"terms"</code> or not: if it is then the array is 2 dimensional with each 
term in the linear predictor separate, otherwise the array is 1 dimensional and contains the 
linear predictor/predicted values (or corresponding s.e.s). The linear predictor returned termwise will 
not include the offset or the intercept.
</p>
<p><code>newdata</code> can be a data frame, list or model.frame: if it's a model frame
then all variables must be supplied.
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt; based partly on <code>mgcv</code> by Simon Wood
</p>


<h3>References</h3>

<p>Chambers and Hastie (1993) Statistical Models in S. Chapman &amp; Hall.
</p>
<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press.
</p>
<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+scam">scam</a></code>, <code><a href="#topic+plot.scam">plot.scam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(scam)
set.seed(2)
n &lt;- 200
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # monotone increasing smooth
f &lt;- f1+f2
y &lt;- f+rnorm(n)*0.2
dat &lt;- data.frame(x1=x1,x2=x2,y=y)
b &lt;- scam(y~s(x1,k=15,bs="cr")+s(x2,k=30,bs="mpi"),data=dat)

newd &lt;- data.frame(x1=seq(-3,3,length.out=20),x2=seq(-1,3,length.out=20))
pred &lt;- predict(b,newd)
pred
predict(b,newd,type="terms",se=TRUE)

## prediction on the original data...
pr &lt;- predict(b,type="terms")
x&lt;-sort(x1,index=TRUE)
old.par &lt;- par(mfrow=c(2,2))
plot(x$x,(pr[,1])[x$ix],type="l",col=3,xlab="x1")
z&lt;-sort(x2,index=TRUE)
plot(z$x,(pr[,2])[z$ix],type="l",col=3,xlab="x2")
plot(b,select=1,scale=0,se=FALSE)
plot(b,select=2,scale=0,se=FALSE)
par(old.par)

## linear extrapolation with predict.scam()...
set.seed(3)
n &lt;- 100
x &lt;- sort(runif(n)*3-1)
f &lt;- exp(-1.3*x)
y &lt;- rpois(n,exp(f))
dat &lt;- data.frame(x=x,y=y)
b &lt;- scam(y~s(x,k=15,bs="mpd"),family=poisson(link="log"),data=dat)
newd &lt;- data.frame(x=c(2.3,2.7,3.2))
fe &lt;- predict(b,newd,type="link",se=TRUE)
ylim&lt;- c(min(y,exp(fe$fit)),max(y,exp(fe$fit)))
plot(c(x,newd[[1]]),c(y,NA,NA,NA),ylim=ylim,ylab="y",xlab="x")
lines(c(x,newd[[1]]),c(b$fitted,exp(fe$fit)),col=3)

## prediction on the original data...
pr &lt;- predict(b)
plot(x,y)
lines(x,exp(pr),col=3)


## Gaussian model ....
## simulating data...
 set.seed(2)
 n &lt;- 200
 x &lt;- sort(runif(n)*4-1)
 f &lt;- exp(4*x)/(1+exp(4*x)) # monotone increasing smooth
 y &lt;- f+rnorm(n)*0.1
 dat &lt;- data.frame(x=x,y=y)
 b &lt;- scam(y~ s(x,k=25,bs="mpi"),data=dat)
 newd &lt;- data.frame(x=c(3.2,3.3,3.6))
 fe &lt;- predict(b,newd)
 plot(c(x,newd[[1]]),c(y,NA,NA,NA),ylab="y",xlab="x")
 lines(c(x,newd[[1]]),c(b$fitted,fe),col=3)

### passing observed data + new data...
 newd &lt;- data.frame(x=c(x,3.2,3.3,3.6))
 fe &lt;- predict(b,newd,se=TRUE)
 plot(newd[[1]],c(y,NA,NA,NA),ylab="y",xlab="x")
 lines(newd[[1]],fe$fit,col=2)
 lines(newd[[1]],fe$fit+2*fe$se.fit,col=3)
 lines(newd[[1]],fe$fit-2*fe$se.fit,col=4)

## prediction with CI...
 newd &lt;- data.frame(x=seq(-1.2,3.5,length.out=100))
 fe &lt;- predict(b,newd,se=TRUE)
 ylim&lt;- c(min(y,fe$se.fit),max(y,fe$se.fit))
 plot(newd[[1]],fe$fit,type="l",ylim=ylim,ylab="y",xlab="x")
 lines(newd[[1]],fe$fit+2*fe$se.fit,lty=2)
 lines(newd[[1]],fe$fit-2*fe$se.fit,lty=2)
 
## prediction on the original data...
pr &lt;- predict(b)
plot(x,y)
lines(x,pr,col=3)

## bivariate example...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n));  x2 &lt;- sort(runif(n)*4-1)
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- 2*sin(pi*x1[i]) +exp(4*x2[j])/(1+exp(4*x2[j]))
   f &lt;- as.vector(t(f));  
   y &lt;- f+rnorm(length(f))*0.1
   x11 &lt;-  matrix(0,n,n); x11[,1:n] &lt;- x1;  x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tesmi2"),data=dat,optimizer="efs")
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE);   plot(b,pers=TRUE,theta = 80, phi = 40)

   n.out &lt;- 20
   xp &lt;- seq(0,1.4,length.out=n.out) 
   zp &lt;- seq(-1,3.4,length.out=n.out)
   xp1 &lt;-  matrix(0,n.out,n.out);   xp1[,1:n.out] &lt;- xp
   xp1 &lt;- as.vector(t(xp1));   xp2 &lt;- rep(zp,n.out)
   newd &lt;- data.frame(x1=xp1,x2=xp2)
   fe &lt;- predict(b,newd)
   fc &lt;- t(matrix(fe,n.out,n.out))
   persp(xp,zp,fc,expand= 0.85,ticktype = "simple",xlab="x1",
     ylab="x2",zlab="f^",main="", theta = 80, phi = 40)


## obtaining a 'prediction matrix'...
newd &lt;- data.frame(x1=c(-2,-1),x2=c(0,1))
Xp &lt;- predict(b,newdata=newd,type="lpmatrix")
fv &lt;- Xp%*% b$beta.t
fv
 
## End(Not run)
</code></pre>

<hr>
<h2 id='print.scam'>Print a SCAM object
</h2><span id='topic+print.scam'></span>

<h3>Description</h3>

<p>The default print method for a <code>scam</code> object. The code is a clone of <code>print.gam</code>
of the <code>mgcv</code> package with a slight simplification since only two methods of smoothing parameter 
selection (by GCV or UBRE) was implemented for <code>scam</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scam_+3A_x">x</code></td>
<td>
<p> fitted model objects of class <code>scam</code> as produced by <code>scam()</code>.</p>
</td></tr>
<tr><td><code id="print.scam_+3A_...">...</code></td>
<td>
<p> other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As for <code>mgcv(gam)</code> prints out the family, model formula, effective degrees of freedom for each smooth term, 
and optimized value of the smoothness selection criterion used.
</p>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt; 
</p>


<h3>References</h3>

<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press.
</p>


<h3>See Also</h3>

   <p><code><a href="#topic+scam">scam</a></code>, <code><a href="#topic+summary.scam">summary.scam</a></code></p>

<hr>
<h2 id='qq.scam'>QQ plots for scam model residuals</h2><span id='topic+qq.scam'></span>

<h3>Description</h3>

<p>Takes a fitted <code>scam</code> object produced by <code>scam()</code> and produces
QQ plots of its residuals (conditional on the fitted model
coefficients and scale parameter). This is an adapted short version of <code>qq.gam()</code> of <code>mgcv</code> package of Simon N Wood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq.scam(object, rep=0, level=.9,s.rep=10,
       type=c("deviance","pearson","response"),
       pch=".", rl.col=3, rep.col="gray80", ...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="qq.scam_+3A_object">object</code></td>
<td>
<p> a fitted <code>scam</code> object as produced by <code>scam()</code> (or a <code>glm</code> object).</p>
</td></tr>
<tr><td><code id="qq.scam_+3A_rep">rep</code></td>
<td>
<p>How many replicate datasets to generate to simulate quantiles
of the residual distribution.  <code>0</code> results in an efficient
simulation free method for direct calculation, if this is possible for
the object family.</p>
</td></tr>
<tr><td><code id="qq.scam_+3A_level">level</code></td>
<td>
<p>If simulation is used for the quantiles, then reference intervals can be provided for the QQ-plot, this specifies the level. 
0 or less for no intervals, 1 or more to simply plot the QQ plot for each replicate generated.</p>
</td></tr>
<tr><td><code id="qq.scam_+3A_s.rep">s.rep</code></td>
<td>
<p>how many times to randomize uniform quantiles to data under direct computation.</p>
</td></tr>
<tr><td><code id="qq.scam_+3A_type">type</code></td>
<td>
<p>what sort of residuals should be plotted?  See
<code><a href="#topic+residuals.scam">residuals.scam</a></code>.</p>
</td></tr>
<tr><td><code id="qq.scam_+3A_pch">pch</code></td>
<td>
<p>plot character to use. 19 is good.</p>
</td></tr>
<tr><td><code id="qq.scam_+3A_rl.col">rl.col</code></td>
<td>
<p>color for the reference line on the plot.</p>
</td></tr>
<tr><td><code id="qq.scam_+3A_rep.col">rep.col</code></td>
<td>
<p>color for reference bands or replicate reference plots.</p>
</td></tr>
<tr><td><code id="qq.scam_+3A_...">...</code></td>
<td>
<p>extra graphics parameters to pass to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>QQ-plots of the the model residuals can be produced in one of two ways. The cheapest method generates reference quantiles by 
associating a quantile of the uniform distribution with each datum, and feeding these uniform quantiles into the quantile function associated with each datum. The resulting quantiles are then used in place of each datum to generate approximate quantiles of residuals.
The residual quantiles are averaged over <code>s.rep</code> randomizations of the uniform quantiles to data. 
</p>
<p>The second method is to use direct simulatation. For each replicate, data are simulated from the fitted model, and the corresponding residuals computed. This is repeated <code>rep</code> times.
Quantiles are readily obtained from the empirical distribution of residuals so obtained. From this method reference bands are also computable.  
</p>
<p>Even if <code>rep</code> is set to zero, the routine will attempt to simulate quantiles if no quantile function is available for the family. If no random deviate generating function family is available (e.g. for the quasi families), then a normal QQ-plot is produced. The routine conditions on the fitted model coefficents and the scale parameter estimate. 
</p>
<p>The plots are very similar to those proposed in Ben and Yohai (2004), but are substantially cheaper to produce (the interpretation of residuals for binary data in Ben and Yohai is not recommended).  
</p>


<h3>Author(s)</h3>

<p> Simon N. Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a>
</p>
<p>Natalya Pya <a href="mailto:nat.pya@gmail.com">nat.pya@gmail.com</a> adapted for usage with <code>scam</code>
</p>


<h3>References</h3>

<p>N.H. Augustin, E-A Sauleaub, S.N. Wood (2012) On quantile quantile plots for generalized linear models
Computational Statistics &amp; Data Analysis. 56(8), 2404-2409.
</p>
<p>M.G. Ben and V.J. Yohai (2004) JCGS 13(1), 36-47.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+scam">scam</a></code></p>

<hr>
<h2 id='residuals.scam'>SCAM residuals</h2><span id='topic+residuals.scam'></span>

<h3>Description</h3>

<p>This function is a clone of the <code>mgcv</code> library code <code><a href="mgcv.html#topic+residuals.gam">residuals.gam</a></code>.
It returns residuals for a fitted <code>scam</code> model
object. Pearson, deviance, working and response residuals are
available. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
residuals(object, type = c("deviance", "pearson","scaled.pearson", 
                        "working", "response"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.scam_+3A_object">object</code></td>
<td>
<p> a <code>scam</code> fitted model object. </p>
</td></tr>
<tr><td><code id="residuals.scam_+3A_type">type</code></td>
<td>
<p>the type of residuals wanted. </p>
</td></tr>
<tr><td><code id="residuals.scam_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See  <code>residuals.gam</code> for details.
</p>


<h3>Value</h3>

<p> An array of residuals.
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt; 
</p>


<h3>See Also</h3>

   <p><code><a href="#topic+scam">scam</a></code></p>

<hr>
<h2 id='scam'>Shape constrained additive models (SCAM) and integrated smoothness selection</h2><span id='topic+scam'></span>

<h3>Description</h3>

<p>This function fits a SCAM to data. Various shape constrained smooths (SCOP-splines), including univariate smooths subject to monotonicity, convexity, or monotonicity plus convexity, bivariate smooths with double or single monotonicity  are available as model terms. See <code><a href="#topic+shape.constrained.smooth.terms">shape.constrained.smooth.terms</a></code> for a complete overview of what is available. Smoothness selection is estimated as part of the fitting. Confidence/credible intervals are available for each smooth term.    
</p>
<p>The shaped constrained smooths have been added to the <code>gam()</code> in package <code>mgcv</code> setup using the <code>smooth.construct</code> function.  The routine calls a <code>gam()</code> function for the model set up, but there are separate functions for the model fitting, <code><a href="#topic+scam.fit">scam.fit</a></code>, and smoothing parameter selection, <code><a href="#topic+bfgs_gcv.ubre">bfgs_gcv.ubre</a></code>. Any smooth available in the <code>mgcv</code> can be taken as a model term for SCAM. User-defined smooths can be included as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scam(formula, family = gaussian(), data = list(), gamma = 1, 
      sp = NULL, weights = NULL, offset = NULL,optimizer=c("bfgs","newton"), 
      optim.method=c("Nelder-Mead","fd"),scale = 0, knots=NULL,
      not.exp=FALSE, start= NULL, etastart=NULL,mustart= NULL,
      control=list(),AR1.rho=0, AR.start=NULL,drop.unused.levels=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scam_+3A_formula">formula</code></td>
<td>
<p>A SCAM formula.  
This is exactly like the formula for a GAM (see <code>formula.gam</code> of the <code>mgcv</code> library) except that shape constrained smooth terms,
can be added in the expression of the form, e.g., 
<code>s(x1,k=12,bs="mpi",by=z),</code>  where <code>bs</code> indicates the basis to use for the constrained smooth (increasing in this case): 
the built in options for the shape constrained smooths are described in <br /> 
<code><a href="#topic+shape.constrained.smooth.terms">shape.constrained.smooth.terms</a></code>, 
</p>
</td></tr> 
<tr><td><code id="scam_+3A_family">family</code></td>
<td>
<p>A family object specifying the distribution and link to use in
fitting etc. See <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+family">family</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="scam_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the model response variable and 
covariates required by the formula. By default the variables are taken 
from 
<code>environment(formula)</code>: typically the environment from 
which <code>gam</code> is called.</p>
</td></tr> 
<tr><td><code id="scam_+3A_gamma">gamma</code></td>
<td>
<p>A constant multiplier to inflate the model degrees of freedom in the GCV or UBRE/AIC score.</p>
</td></tr>
<tr><td><code id="scam_+3A_sp">sp</code></td>
<td>
<p>A vector of smoothing parameters can be provided here. Smoothing parameters must be supplied in the order that 
the smooth terms appear in the model formula. The default <code>sp=NULL</code> indicates that smoothing parameters should be estimated.
If <code>length(sp)</code> does not correspond to the number of underlying smoothing parameters or negative values supplied then
the vector is ignored and all the smoothing parameters will be estimated.</p>
</td></tr>
<tr><td><code id="scam_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data.</p>
</td></tr>
<tr><td><code id="scam_+3A_offset">offset</code></td>
<td>
<p>Used to supply a model offset for use in fitting. Note that this offset will always be completely ignored when predicting, unlike an offset 
included in <code>formula</code>. This conforms to the behaviour of <code>lm</code>, <code>glm</code> and <code>gam</code>.</p>
</td></tr>
<tr><td><code id="scam_+3A_optimizer">optimizer</code></td>
<td>
<p>An array specifying the numerical optimization methods 
to optimize the smoothing parameter estimation criterion (specified in the first 
element  of <code>optimizer</code>) and to use to estimate the model coefficients
(specified in the second element of <code>optimizer</code>). For the model coefficients
estimation there are two alternatives: &quot;newton&quot; (default) and &quot;bfgs&quot; methods.
For the smoothing parameter selection the available methods are &quot;bfgs&quot; (default)
for the built in to <code>scam</code> package routine <code><a href="#topic+bfgs_gcv.ubre">bfgs_gcv.ubre</a></code>, &quot;optim&quot;, &quot;nlm&quot;, 
&quot;nlm.fd&quot; (based on finite-difference approximation of the derivatives), &quot;efs&quot;. 
&quot;efs&quot; for the extended Fellner Schall method of Wood and Fasiolo (2017) 
(rather than minimizing REML as in <code>gam(mgcv)</code> this minimizes the GCV/UBRE criterion)
Note that 'bfgs' method for the coefficient estimation works only with 'efs'.</p>
</td></tr>
<tr><td><code id="scam_+3A_optim.method">optim.method</code></td>
<td>
<p>In case of <code>optimizer="optim"</code> this specifies the numerical method to be used in <code>optim</code>
in the first element, the second element of <code>optim.method</code> indicates whether the finite difference
approximation should be used (&quot;fd&quot;) or analytical gradient (&quot;grad&quot;). The default is <code>optim.method=c("Nelder-Mead","fd")</code>.</p>
</td></tr>
<tr><td><code id="scam_+3A_scale">scale</code></td>
<td>
<p>If this is positive then it is taken as the known scale parameter of the exponential family distribution.
Negative value indicates that the scale paraemter is unknown. 0 indicates that the scale parameter is 1  for Poisson and binomial
and unknown otherwise. This conforms to the behaviour of <code>gam</code>.</p>
</td></tr> 
<tr><td><code id="scam_+3A_knots">knots</code></td>
<td>
<p>An optional list containing user specified knot values to be used for basis construction. Different terms can use different numbers of knots.</p>
</td></tr>
<tr><td><code id="scam_+3A_not.exp">not.exp</code></td>
<td>
<p>if <code>TRUE</code> then <code>notExp()</code> function will be used in place of <code>exp</code> (default value) in positivity ensuring beta parameters re-parameterization.</p>
</td></tr>
<tr><td><code id="scam_+3A_start">start</code></td>
<td>
<p>Initial values for the model coefficients.</p>
</td></tr>
<tr><td><code id="scam_+3A_etastart">etastart</code></td>
<td>
<p>Initial values for the linear predictor.</p>
</td></tr>
<tr><td><code id="scam_+3A_mustart">mustart</code></td>
<td>
<p>Initial values for the expected values.</p>
</td></tr>
<tr><td><code id="scam_+3A_control">control</code></td>
<td>
<p>A list of fit control parameters to replace defaults returned by <code><a href="#topic+scam.control">scam.control</a></code>.
Values not set assume default values.</p>
</td></tr>
<tr><td><code id="scam_+3A_ar1.rho">AR1.rho</code></td>
<td>
<p>The AR1 correlation parameter. An AR1 error model can be used for the residuals of Gaussian-identity link models. Standardized residuals (approximately uncorrelated under correct model) returned in
<code>std.rsd</code> if non-zero. </p>
</td></tr>
<tr><td><code id="scam_+3A_ar.start">AR.start</code></td>
<td>
<p>logical variable of same length as data, <code>TRUE</code> at first observation of an independent section of AR1 correlation. Very first observation in data frame does not need this. If <code>NULL</code> (default) then there are no breaks in AR1 correlaion.</p>
</td></tr>
<tr><td><code id="scam_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>as with <code>gam</code> by default unused levels are dropped from factors before fitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A shape constrained additive model (SCAM) is a generalized linear model (GLM) 
in which the linear predictor is given by strictly parametric components plus a sum of smooth functions of the covariates where
some of the functions are assumed to be shape constrained. For example,
</p>
<p style="text-align: center;"><code class="reqn">\log(E(Y_i)) = X_i^*b+f_1(x_{1i})+m_2(x_{2i})+f_3(x_{3i})</code>
</p>

<p>where the independent response variables <code class="reqn">Y_i</code> follow Poisson distribution with <code>log</code> link function,
<code class="reqn">f_1</code>, <code class="reqn">m_2</code>, and <code class="reqn">f_3</code> are smooth functions of the corresponding covariates, and <code class="reqn">m_2</code> 
is subject to monotone increasing constraint.  
</p>
<p>Available shape constrained smooths are decsribed in <code><a href="#topic+shape.constrained.smooth.terms">shape.constrained.smooth.terms</a></code>.
</p>
<p>Residual auto-correlation with a simple AR1 correlation structure can be dealt with, for Gaussian models with identity link. Currently, the AR1 correlation parameter should be supplied (rather than estimated) in <code>AR1.rho</code>. <code>AR.start</code> input argument (logical) allows to set independent sections of AR1 correlation. Standardized residuals (approximately uncorrelated under correct model) are returned in <code>std.rsd</code> if <code>AR1.rho</code> is non zero. Use <code>acf(model$std.rsd)</code> for computing and plotting estimates of the autocorrelation function to check correlation.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>"scam"</code> with the following elements (this agrees with <code>gamObject</code>):
</p>
<table>
<tr><td><code>aic</code></td>
<td>
<p>AIC of the fitted model: the degrees of freedom used to calculate this are the effective degrees of freedom of the model, and the likelihood is evaluated at the maximum of the penalized likelihood, not at the MLE.</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>Array whose elements indicate which model term (listed in
<code>pterms</code>) each parameter relates to: applies only to non-smooth terms.</p>
</td></tr>
<tr><td><code>bfgs.info</code></td>
<td>
<p>If <code>optimizer[1]="bfgs"</code>, a list of convergence diagnostics relating to the BFGS method of smoothing parameter selection. The items are: 
<code>conv</code>, indicates why the BFGS algorithm of the smoothness selection terminated; <code>iter</code>, number of iterations of the BFGS taken to get convergence; <code>grad</code>, the gradient of the GCV/UBRE score at 
convergence; <code>score.hist</code>, the succesive values of the score up until convergence.</p>
</td></tr> 
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the coefficients of the fitted model. Parametric
coefficients are  first, followed  by coefficients for each
spline term in turn.</p>
</td></tr>
<tr><td><code>coefficients.t</code></td>
<td>
<p>the parametrized coefficients of the fitted model (exponentiated for the monotonic smooths).</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>indicates whether or not the iterative fitting method converged.</p>
</td></tr> 
<tr><td><code>CPU.time</code></td>
<td>
<p>indicates the real and CPU time (in seconds) taken by the fitting process in case of unknown smoothing parameters</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the original supplied data argument. Only included if the <code>scam</code> argument
<code>keepData</code> is set to <code>TRUE</code> (default is <code>FALSE</code>).</p>
</td></tr> 
<tr><td><code>deviance</code></td>
<td>
<p>model deviance (not penalized deviance).</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>null degrees of freedom.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>effective residual degrees of freedom of the model.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>estimated degrees of freedom for each model parameter. Penalization
means that many of these are less than 1.</p>
</td></tr>
<tr><td><code>edf1</code></td>
<td>
<p>alternative estimate of edf.</p>
</td></tr>
<tr><td><code>efs.info</code></td>
<td>
<p>If <code>optimizer[1]="efs"</code>, a list of convergence diagnostics relating to the extended Fellner Schall method fot smoothing parameter selection. The items are: 
<code>conv</code>, indicates why the efs algorithm of the smoothness selection terminated; <code>iter</code>, number of iterations of the efs taken to get convergence; <code>score.hist</code>, the succesive values of the score up until convergence. </p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>family object specifying distribution and link used.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted model predictions of expected value for each
datum.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the model formula.</p>
</td></tr>
<tr><td><code>gcv.ubre</code></td>
<td>
<p>the minimized GCV or UBRE score.</p>
</td></tr>
<tr><td><code>dgcv.ubre</code></td>
<td>
<p>the gradient of the GCV or UBRE score.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations of the Newton-Raphson method taken to get convergence.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>fitted model prediction of link function of
expected value for  each datum.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>"GCV"</code> or <code>"UBRE"</code>, depending on the fitting criterion used.</p>
</td></tr>
<tr><td><code>min.edf</code></td>
<td>
<p>Minimum possible degrees of freedom for whole model.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>model frame containing all variables needed in original model fit.</p>
</td></tr>
<tr><td><code>nlm.info</code></td>
<td>
<p>If <code>optimizer[1]="nlm"</code> or <code>optimizer[1]="nlm.fd"</code>, a list of convergence diagnostics relating to the BFGS method of smoothing parameter selection. The items are: 
<code>conv</code>, indicates why the BFGS algorithm of the smoothness selection terminated; <code>iter</code>, number of iterations of
BFGS taken to get convergence; <code>grad</code>, the gradient of the GCV/UBRE score at 
convergence.</p>
</td></tr> 
<tr><td><code>not.exp</code></td>
<td>
<p>if <code>TRUE</code> then <code>notExp()</code> function will be used in place of <code>exp</code> (default value) in positivity ensuring beta parameters re-parameterization.</p>
</td></tr>
<tr><td><code>nsdf</code></td>
<td>
<p>number of parametric, non-smooth, model terms including the
intercept.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>deviance for single parameter model.</p>
</td></tr> 
<tr><td><code>offset</code></td>
<td>
<p>model offset.</p>
</td></tr>
<tr><td><code>optim.info</code></td>
<td>
<p>If <code>optimizer[1]="optim"</code>, a list of convergence diagnostics relating to the BFGS method of smoothing parameter selection. The items are: 
<code>conv</code>, indicates why the BFGS algorithm of the smoothness selection terminated; <code>iter</code>, number of iterations of
BFGS taken to get convergence; <code>optim.method</code>, the numerical optimization method used.</p>
</td></tr> 
<tr><td><code>prior.weights</code></td>
<td>
<p>prior weights on observations.</p>
</td></tr> 
<tr><td><code>pterms</code></td>
<td>
<p><code>terms</code> object for strictly parametric part of model.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Factor R from QR decomposition of weighted model matrix, unpivoted to be in same column order as model matrix.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the working residuals for the fitted model.</p>
</td></tr>
<tr><td><code>scale.estimated</code></td>
<td>
<p><code>TRUE</code> if the scale parameter was estimated, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code>sig2</code></td>
<td>
<p>estimated or supplied variance/scale parameter.</p>
</td></tr>
<tr><td><code>smooth</code></td>
<td>
<p>list of smooth objects, containing the basis information for each term in the 
model formula in the order in which they appear. These smooth objects are returned by
the <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> objects.</p>
</td></tr>
<tr><td><code>sp</code></td>
<td>
<p>estimated smoothing parameters for the model. These are the underlying smoothing
parameters, subject to optimization.</p>
</td></tr>
<tr><td><code>std.rsd</code></td>
<td>
<p>Standardized residuals (approximately uncorrelated under correct model) if <code>AR1.rho</code> non zero </p>
</td></tr>
<tr><td><code>termcode</code></td>
<td>
<p>an integer indicating why the optimization process of the smoothness selection
terminated (see <code><a href="#topic+bfgs_gcv.ubre">bfgs_gcv.ubre</a></code>).</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p><code>terms</code> object of <code>model</code> model frame.</p>
</td></tr>
<tr><td><code>trA</code></td>
<td>
<p>trace of the influence matrix, total number of the estimated degrees of freedom (<code>sum(edf)</code>).</p>
</td></tr>
<tr><td><code>var.summary</code></td>
<td>
<p>A named list of summary information on the predictor variables. See <code><a href="mgcv.html#topic+gamObject">gamObject</a></code>.</p>
</td></tr>
<tr><td><code>Ve</code></td>
<td>
<p>frequentist estimated covariance matrix for the parameter
estimators.</p>
</td></tr>
<tr><td><code>Vp</code></td>
<td>
<p>estimated covariance matrix for the parameters. This is a Bayesian
posterior covariance matrix that results from adopting a particular Bayesian
model of the smoothing process.</p>
</td></tr>
<tr><td><code>Ve.t</code></td>
<td>
<p>frequentist estimated covariance matrix for the reparametrized parameter
estimators obtained using the delta method. Particularly useful for testing whether terms are zero. Not so
useful for CI's as smooths are usually biased.</p>
</td></tr>
<tr><td><code>Vp.t</code></td>
<td>
<p>estimated covariance matrix for the reparametrized parameters obtained using the delta method. 
Paricularly useful for creating credible/confidence intervals.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>final weights used in the Newton-Raphson iteration.</p>
</td></tr>
<tr><td><code>cmX</code></td>
<td>
<p>column means of the model matrix (with elements corresponding to smooths set to zero).</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>contrasts associated with a factor.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>levels of a factor variable used in the model.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>response data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt; based partly on <code>mgcv</code> by Simon Wood
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood 
and marginal likelihood estimation of semiparametric generalized linear 
models. Journal of the Royal Statistical Society (B) 73(1):3-36
</p>
<p>Wood S.N. (2017) Generalized Additive Models: An Introduction with R (2nd edition). Chapman
and Hall/CRC Press
</p>
<p>Wood, S.N. (2006) On confidence intervals for generalized additive models based on penalized regression splines. Australian and New Zealand Journal of Statistics. 48(4): 445-464.
</p>
<p>Wood, S.N. and M. Fasiolo (2017) A generalized Fellner-Schall method for smoothing
parameter optimization with application to Tweedie location, scale and shape models.
Biometrics 73 (4), 1071-1081
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scam-package">scam-package</a></code>, <code><a href="#topic+shape.constrained.smooth.terms">shape.constrained.smooth.terms</a></code>, 
<code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="mgcv.html#topic+s">s</a></code>,
<code><a href="#topic+plot.scam">plot.scam</a></code>, <code><a href="#topic+summary.scam">summary.scam</a></code>, <code><a href="#topic+scam.check">scam.check</a></code>, <code><a href="#topic+predict.scam">predict.scam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##=============================
## Gaussian model, two smooth terms: unconstrained and increasing...
 ## simulating data...
require(scam)
set.seed(4)
n &lt;- 200
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # monotone increasing smooth
y &lt;- f1+f2 +rnorm(n)*.5
dat &lt;- data.frame(x1=x1,x2=x2,y=y)
## fit model, get results, and plot...
b &lt;- scam(y~s(x1,bs="cr")+s(x2,bs="mpi"),data=dat)
b
summary(b)
plot(b,pages=1,shade=TRUE)

##===============================
## Gaussian model, two smooth terms: increasing and mixed (decreasing and convex)...
 ## simulating data...
set.seed(4)
n &lt;- 200
x1 &lt;- runif(n)*4-1;
f1 &lt;- exp(4*x1)/(1+exp(4*x1)) # increasing smooth
x2 &lt;- runif(n)*3-1;
f2 &lt;- exp(-3*x2)/15  # decreasing and convex smooth
y &lt;- f1+f2 + rnorm(n)*.4
dat &lt;- data.frame(x1=x1,x2=x2,y=y)
  ## fit model, results, and plot...
b &lt;- scam(y~ s(x1,bs="mpi")+s(x2, bs="mdcx"),data=dat)
summary(b)
plot(b,pages=1,scale=0,shade=TRUE)

##=================================
## Not run: 
## using the extended Fellner-Schall method for smoothing parameter selection...
b0 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer="efs")
summary(b0)

## using the extended Fellner-Schall method for smoothing parameter selection, 
## and BFGS for model coefficient estimation...
b0 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer=c("efs","bfgs"))
summary(b0)

## using optim() for smoothing parameter selection...
b1 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer="optim")
summary(b1)

b2 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer="optim",
           optim.method=c("BFGS","fd"))
summary(b2)

## using nlm()...
b3 &lt;- scam(y~ s(x1,bs="mpi")+s(x2,bs="mdcx"),data=dat,optimizer="nlm")
summary(b3)

## End(Not run)

##===================================
## Poisson model ....
 ## simulating data...
set.seed(2)
n &lt;- 200
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # monotone increasing smooth
f &lt;- f1+f2
y &lt;- rpois(n,exp(f))
dat &lt;- data.frame(x1=x1,x2=x2,y=y)
  ## fit model, get results, and plot...
b &lt;- scam(y~s(x1,bs="cr")+s(x2,bs="mpi"),
      family=poisson(link="log"),data=dat,optimizer=c("efs","bfgs"))
summary(b)
plot(b,pages=1,shade=TRUE)
scam.check(b)


## Gamma model...
   ## simulating data...
set.seed(6)
n &lt;- 300
x1 &lt;- runif(n)*6-3
f1 &lt;- 1.5*sin(1.5*x1) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- 1.5/(1+exp(-10*(x2+.75)))+1.5/(1+exp(-5*(x2-.75))) # increasing smooth
x3 &lt;- runif(n)*6-3;
f3 &lt;- 3*exp(-x3^2)  # unconstrained term
f &lt;- f1+f2+f3
y &lt;- rgamma(n,shape=1,scale=exp(f))
dat &lt;- data.frame(x1=x1,x2=x2,x3=x3,y=y)
   ## fit model, get results, and plot...
b &lt;- scam(y~s(x1,bs="ps")+s(x2,k=15,bs="mpi")+s(x3,bs="ps"),
          family=Gamma(link="log"),data=dat,optimizer=c("efs","bfgs"))
b
summary(b)
par(mfrow=c(2,2))
plot(b,shade=TRUE)

## Not run: 
## bivariate example...
 ## simulating data...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(runif(n))
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
       { f1[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i]))+2*sin(pi*x2[j])}
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*.2
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model  and plot ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs=c("tesmd1","ps")),data=dat,optimizer="efs")
   summary(b)
   old.par &lt;- par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data",pch=".",cex=3)
   par(old.par)

## example with random effect smoother...
   set.seed(2)
   n &lt;- 200
   x1 &lt;- runif(n)*6-3
   f1 &lt;- 3*exp(-x1^2) # unconstrained term
   x2 &lt;- runif(n)*4-1;
   f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # increasing smooth
   f &lt;- f1+f2
   a &lt;- factor(sample(1:10,200,replace=TRUE))   
   Xa &lt;- model.matrix(~a-1)    # random main effects
   y &lt;- f + Xa%*%rnorm(length(levels(a)))*.5 + rnorm(n)*.4    
   dat &lt;- data.frame(x1=x1,x2=x2,y=y,a=a)
   ## fit model and plot...
   b &lt;- scam(y~s(x1,bs="cr")+s(x2,bs="mpi")+s(a,bs="re"), data=dat)
   summary(b)
   scam.check(b)
   plot(b,pages=1,shade=TRUE)

## example with AR1 errors...
set.seed(8)
n &lt;- 500
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # increasing smooth
f &lt;- f1+f2
e &lt;- rnorm(n,0,sd=2)
for (i in 2:n) e[i] &lt;- .6*e[i-1] + e[i]
y &lt;- f + e
dat &lt;- data.frame(x1=x1,x2=x2,y=y)  
b &lt;- scam(y~s(x1,bs="cr")+s(x2,k=25,bs="mpi"),
            data=dat, AR1.rho=.6, optimizer="efs")
b
## Raw residuals still show correlation...
acf(residuals(b)) 
## But standardized are now fine...
x11()
acf(b$std.rsd)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='scam.check'>Some diagnostics for a fitted scam object
</h2><span id='topic+scam.check'></span>

<h3>Description</h3>

<p>Takes a fitted <code>scam</code> object produced by <code>scam()</code> and produces some diagnostic information
about the fitting procedure and results. This function is almost the same as <code><a href="mgcv.html#topic+gam.check">gam.check</a></code> of the <code>mgcv</code> library. The default is to produce four residual plots and some information about the
convergence of the smoothness selection optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scam.check(b,type=c("deviance","pearson","response"),old.style=FALSE, pch=".",
                       rep=0, level=.9, rl.col=3, rep.col="gray80",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scam.check_+3A_b">b</code></td>
<td>
<p> a fitted <code>scam</code> object as produced by <code>scam()</code>.</p>
</td></tr>
<tr><td><code id="scam.check_+3A_old.style">old.style</code></td>
<td>
<p>produces qq-norm plots as it was in scam versions &lt; 1.2-15 when set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scam.check_+3A_type">type</code></td>
<td>
<p>type of residuals, see <code><a href="#topic+residuals.scam">residuals.scam</a></code>, used in
all plots.</p>
</td></tr>
<tr><td><code id="scam.check_+3A_rep">rep</code>, <code id="scam.check_+3A_level">level</code>, <code id="scam.check_+3A_rep.col">rep.col</code></td>
<td>

<p>arguments passed to <code><a href="#topic+qq.scam">qq.scam</a>()</code> when <code>old.style</code> is
<code>FALSE</code> (default).</p>
</td></tr> 
<tr><td><code id="scam.check_+3A_rl.col">rl.col</code></td>
<td>
<p>color for the reference line on the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="scam.check_+3A_pch">pch</code></td>
<td>
<p>plot character to use for the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="scam.check_+3A_...">...</code></td>
<td>
<p>extra graphics parameters to pass to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As for <code>mgcv(gam)</code> plots 4 standard diagnostic plots, and some other
convergence diagnostics. The
printed information relates to the optimization process used to select smoothing
parameters.
</p>


<h3>Author(s)</h3>

<p>Natalya Pya <a href="mailto:nat.pya@gmail.com">nat.pya@gmail.com</a> based partly on <code>mgcv</code> by Simon N Wood
</p>


<h3>References</h3>

<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press.
</p>


<h3>See Also</h3>

  <p><code><a href="#topic+scam">scam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
library(scam)
set.seed(2)
n &lt;- 200
x1 &lt;- runif(n)*4-1;
f1 &lt;- exp(4*x1)/(1+exp(4*x1)) # monotone increasing smooth
x2 &lt;- runif(n)*3-1;
f2 &lt;- exp(-3*x2)/15  # monotone decreasing and convex smooth
f &lt;- f1+f2
y &lt;- f+ rnorm(n)*0.2
dat &lt;- data.frame(x1=x1,x2=x2,y=y)
b &lt;- scam(y~ s(x1,k=25,bs="mpi",m=2)+s(x2,k=25,bs="mdcx",m=2),
    family=gaussian(link="identity"),data=dat)
plot(b,pages=1)
scam.check(b)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='scam.control'>Setting SCAM fitting defaults</h2><span id='topic+scam.control'></span>

<h3>Description</h3>

<p> This is an internal function of package <code>scam</code> which allows 
control of the numerical options for fitting a SCAM. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scam.control(maxit = 200, maxHalf=30, devtol.fit=1e-7, steptol.fit=1e-7,
            keepData=FALSE,efs.lspmax=15,efs.tol=.1, nlm=list(),optim=list(),
            bfgs=list(), trace =FALSE, print.warn=FALSE) 
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="scam.control_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of IRLS iterations to perform used in <code><a href="#topic+scam.fit">scam.fit</a></code>.</p>
</td></tr>
<tr><td><code id="scam.control_+3A_maxhalf">maxHalf</code></td>
<td>
<p>If a step of  the BFGS optimization method leads 
to a worse penalized deviance, then the step length of the model coefficients is halved. This is
the number of halvings to try before giving up used in <code><a href="#topic+bfgs_gcv.ubre">bfgs_gcv.ubre</a></code>.</p>
</td></tr>
<tr><td><code id="scam.control_+3A_devtol.fit">devtol.fit</code></td>
<td>
<p>A positive scalar giving the convergence control for the model fitting algorithm in <code><a href="#topic+scam.fit">scam.fit</a></code>.</p>
</td></tr>
<tr><td><code id="scam.control_+3A_steptol.fit">steptol.fit</code></td>
<td>
<p>A positive scalar giving the tolerance at which the scaled distance between
two successive iterates is considered close enough to zero to terminate the model fitting algorithm in <code><a href="#topic+scam.fit">scam.fit</a></code>.</p>
</td></tr>
<tr><td><code id="scam.control_+3A_keepdata">keepData</code></td>
<td>
<p>Should a copy of the original <code>data</code> argument be kept in the <code>scam</code> 
object?</p>
</td></tr>
<tr><td><code id="scam.control_+3A_efs.lspmax">efs.lspmax</code></td>
<td>
<p>maximum log smoothing parameters to allow under extended Fellner Schall
smoothing parameter optimization.</p>
</td></tr>
<tr><td><code id="scam.control_+3A_efs.tol">efs.tol</code></td>
<td>
<p>change in GCV to count as negligible when testing for EFS convergence. If the
step is small and the last 3 steps led to a GCV change smaller than this, then stop.</p>
</td></tr>
<tr><td><code id="scam.control_+3A_nlm">nlm</code></td>
<td>
<p>list of control parameters to pass to <code><a href="stats.html#topic+nlm">nlm</a></code> if this is
used for outer estimation of smoothing parameters (not default). </p>
</td></tr>
<tr><td><code id="scam.control_+3A_optim">optim</code></td>
<td>
<p>list of control parameters to pass to <code><a href="stats.html#topic+optim">optim</a></code> if this
is used for outer estimation of smoothing parameters (not default).</p>
</td></tr>
<tr><td><code id="scam.control_+3A_bfgs">bfgs</code></td>
<td>
<p>list of control parameters to pass to default BFGS optimizer
used for outer estimation of log smoothing parameters.</p>
</td></tr>
<tr><td><code id="scam.control_+3A_trace">trace</code></td>
<td>
<p>turns on or off some de-bugging information.</p>
</td></tr>
<tr><td><code id="scam.control_+3A_print.warn">print.warn</code></td>
<td>
<p> when set to <code>FALSE</code> turns off printing warning messages for step halving under non-finite exponentiated coefficients,  non-finite deviance and/or if <code>mu</code> or <code>eta</code> are out of bounds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Outer iteration is used to estimate smoothing parameters of SCAM by GCV/UBRE score optimization. The default procedure is the built-in BFGS method which is controlled by the list <code>bfgs</code> with the following elements: <code>steptol.bfgs</code> (default 1e-7) is the relative convergence tolerance; 
<code>gradtol.bfgs</code> (default 6.0554*1e-6) is a tolerance at which the gradient is considered to be close enougth to 0 to terminate the BFGS algorithm; 
<code>maxNstep</code> is a positive scalar which gives the maximum allowable step length (default 5);
<code>maxHalf</code> gives the maximum number of step halving in &quot;backtracking&quot; to permit before giving up(default 30);
<code>check.analytical</code> is logical whether the analytical gradient of GCV/UBRE should be checked numerically (default <code>FALSE</code>);
<code>del</code> is an increment for finite differences when checking analytical gradients (default 1e-4). 
</p>
<p>If outer iteration using <code>nlm</code> is used for fitting, then the control list <code>nlm</code> stores control arguments
for calls to routine <code>nlm</code>. As in <code>gam.control</code> the list has the following named elements: <code>ndigit</code> is the number
of significant digits in the GCV/UBRE score; <code>gradtol</code> is the tolerance used to judge convergence of the gradient of the GCV/UBRE score to zero 
(default 1e-6); <code>stepmax</code> is the maximum allowable log smoothing parameter step (default 2);
<code>steptol</code> is the minimum allowable step length (default 1e-4); 
<code>iterlim</code> is the maximum number of optimization steps allowed (default 200);
<code>check.analyticals</code> indicates whether the built in exact derivative calculations should be checked numerically (default <code>FALSE</code>).
Any of these which are not supplied and named in the list are set to their default values.
</p>
<p>Outer iteration using <code>optim</code> is controlled using list <code>optim</code>, which currently has one element: <code>factr</code>
which takes default value 1e7.
</p>


<h3>Author(s)</h3>

<p> Natalya Pya Arnqvist <a href="mailto:nat.pya@gmail.com">nat.pya@gmail.com</a>  based partly on <code><a href="mgcv.html#topic+gam.control">gam.control</a></code> by Simon Wood</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood 
and marginal likelihood estimation of semiparametric generalized linear 
models. Journal of the Royal Statistical Society (B) 73(1):3-36
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scam">scam</a></code>, <code><a href="#topic+scam.fit">scam.fit</a></code>, <code><a href="mgcv.html#topic+gam.control">gam.control</a></code> </p>

<hr>
<h2 id='scam.fit'>Newton-Raphson method to fit SCAM</h2><span id='topic+scam.fit'></span>

<h3>Description</h3>

<p>This routine estimates SCAM coefficients given log smoothing parameters using the Newton-Raphson method.
The estimation of the smoothing parameters by the GCV/UBRE score optimization is outer to the model fitting. Routine 
<code><a href="#topic+gcv.ubre_grad">gcv.ubre_grad</a></code> evaluates the first derivatives of the smoothness selection scores with respect to the 
log smoothing parameters. Routine <code><a href="#topic+bfgs_gcv.ubre">bfgs_gcv.ubre</a></code> estimates the smoothing parameters using the BFGS method. 
</p>
<p>The function is not normally called directly, but rather service routines for <code><a href="#topic+scam">scam</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scam.fit(G,sp, etastart=NULL, mustart=NULL, env=env, 
              null.coef=rep(0,ncol(G$X)), control=scam.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scam.fit_+3A_g">G</code></td>
<td>
<p>A list of items needed to fit a SCAM.</p>
</td></tr>
<tr><td><code id="scam.fit_+3A_sp">sp</code></td>
<td>
<p>The vector of smoothing parameters.</p>
</td></tr>


<tr><td><code id="scam.fit_+3A_etastart">etastart</code></td>
<td>
<p>Initial values for the linear predictor.</p>
</td></tr>
<tr><td><code id="scam.fit_+3A_mustart">mustart</code></td>
<td>
<p>Initial values for the expected values.</p>
</td></tr>
<tr><td><code id="scam.fit_+3A_env">env</code></td>
<td>
<p>Get the enviroment for the model coefficients, their derivatives and the smoothing parameter.</p>
</td></tr>
<tr><td><code id="scam.fit_+3A_null.coef">null.coef</code></td>
<td>
<p>coefficients for a null model, needed for an ability to check for immediate divergence.</p>
</td></tr>
<tr><td><code id="scam.fit_+3A_control">control</code></td>
<td>
<p>A list of fit control parameters returned by <code>scam.control</code>. It includes: <code>maxit</code>, a positive scalar which gives the maximum number of iterations for Newton's method; <code>devtol.fit</code>, a scalar giving the tolerance at which the relative penalized deviance is considered to be close enougth to 0 to terminate the algorithm;
<code>steptol.fit</code>, a scalar giving the tolerance at which the scaled distance between two successive iterates is considered close enough to zero to terminate the algorithm; 
<code>trace</code> turns on or off some de-bugging information;
<code>print.warn</code>, when set to <code>FALSE</code> turns off printing warning messages for step halving under non-finite exponentiated coefficients,  non-finite deviance and/or if <code>mu</code> or <code>eta</code> are out of bounds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine applies step halving to any step that increases the
penalized deviance substantially.
</p>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Wood, S.N. (2008) Fast stable direct fitting and smoothness selection for
generalized additive models. Journal of the Royal Statistical Society (B) 70(3):495-518
</p>
<p>Wood, S.N. (2011) Fast stable restricted maximum likelihood 
and marginal likelihood estimation of semiparametric generalized linear 
models. Journal of the Royal Statistical Society (B) 73(1):3-36
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scam">scam</a></code></p>

<hr>
<h2 id='shape.constrained.smooth.terms'>Shape preserving smooth terms in SCAM</h2><span id='topic+shape.constrained.smooth.terms'></span>

<h3>Description</h3>

<p>As in <code>mgcv(gam)</code>, shape preserving smooth terms are specified in a <code><a href="#topic+scam">scam</a></code> formula using <code><a href="mgcv.html#topic+s">s</a></code> 
terms. All the shape constrained smooth terms (SCOP-splines) are constructed using the B-splines basis proposed by Eilers and Marx (1996) with a discrete penalty on the basis coefficients.
</p>
<p>The univariate single penalty built-in shape constrained smooth classes are summarized as follows.
</p>

<ul>
<li><p> Monotone increasing SCOP-splines: <code>bs="mpi"</code>. To achieve monotone increasing smooths this reparameterizes the coefficients so that they form an increasing sequence. 
</p>
<p>For details see <code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>. 
</p>
</li>
<li><p> Monotone decreasing SCOP-splines: <code>bs="mpd"</code>. To achieve monotone decreasing smooths this reparameterizes the coefficients 
so that they form a decreasing sequence. A first order difference penalty applied to the basis coefficients starting with the 
second is used for the monotone increasing and decreasing cases.
</p>
</li>
<li><p> Convex SCOP-splines: <code>bs="cx"</code>. This reparameterizes the coefficients so that the second order differences of the basis coefficients are greater than zero. 
</p>
<p>For details see <code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>. 
</p>
</li>
<li><p> Concave SCOP-splines: <code>bs="cv"</code>. This reparameterizes the coefficients so that the second order differences of the basis coefficients are less than zero.
</p>
<p>For details see <code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>. 
</p>
</li>
<li><p> Increasing and convex SCOP-splines: <code>bs="micx"</code>. This reparameterizes the coefficients 
so that the first and the second order differences of the basis coefficients are greater than zero. 
For details see 
<code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>.
</p>
</li>
<li><p> Increasing and concave SCOP-splines: <code>bs="micv"</code>. This reparameterizes the coefficients 
so that the first order differences of the basis coefficients are greater than zero while the second order difference
are less than zero.
</p>
</li>
<li><p> Decreasing and convex SCOP-splines: <code>bs="mdcx"</code>. This reparameterizes the coefficients 
so that the first order differences of the basis coefficients are less than zero while the second order difference
are greater. 
For details see <code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>.
</p>
</li>
<li><p> Decreasing and concave SCOP-splines: <code>bs="mdcv"</code>. This reparameterizes the coefficients 
so that the first and the second order differences of the basis coefficients are less than zero.
</p>
</li>
<li><p> Increasing with an additional 'finish-at-zero' constraint SCOP-splines: <code>bs="mifo"</code>. This sets the last <code>(m+1)</code> spline coefficients to zero. According to the B-spline basis functions properties, the value of the spline, <code>f(x)</code>, is determined by <code>m+2</code> non-zero basis functions, and only <code>m+1</code> B-splines are non-zero at knots. Only <code>m+2</code> B-splines are non-zero on any <code>(k_i, k_{i+1})</code>, and the sum of these <code>m+2</code> basis functions is 1. 
</p>
<p>For details see <code><a href="#topic+smooth.construct.mifo.smooth.spec">smooth.construct.mifo.smooth.spec</a></code>. 
</p>
</li>
<li><p> Increasing with an additional 'start-at-zero' constraint SCOP-spline: <code>bs="miso"</code>. This sets the first <code>(m+1)</code> spline coefficients to zero. According to the B-spline basis functions properties, the value of the spline, <code>f(x)</code>, is determined by <code>m+2</code> non-zero basis functions, and only <code>m+1</code> B-splines are non-zero at knots. Only <code>m+2</code> B-splines are non-zero on any <code>(k_i, k_{i+1})</code>, and the sum of these <code>m+2</code> basis functions is 1. 
</p>
<p>For details see <code><a href="#topic+smooth.construct.miso.smooth.spec">smooth.construct.miso.smooth.spec</a></code>. 
</p>
</li>
<li><p> SCOP-spline with positivity constraint: <code>bs="po"</code>. This reparameterizes the coefficients so that there are positive. For details see <code><a href="#topic+smooth.construct.po.smooth.spec">smooth.construct.po.smooth.spec</a></code>. 
</p>
</li>
<li><p> Decreasing/increasing SCOP-splines used with numeric 'by' variable: <code>bs="mpdBy"</code>, <code>bs="mpiBy"</code>. These work similar to <code>mpd.smooth.spec</code>, <code>mpi.smooth.spec</code>,  but without applying an identifiability constraint ('zero intercept' constraint). Use when the smooth term has a numeric <code>by</code> variable  that takes more than one value.
For details see <code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>, <code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>. 
</p>
</li>
<li><p> Convex/concave SCOP-splines used with numeric 'by' variable: <code>bs="cxdBy"</code>, <code>bs="cvBy"</code>. These work similar to <code>cx.smooth.spec</code>, <code>cv.smooth.spec</code>,  but without applying an identifiability constraint ('zero intercept' constraint). Use when the smooth term has a numeric <code>by</code> variable  that takes more than one value.
</p>
<p>For details see <code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>. 
</p>
</li>
<li><p> Decreasing/increasing and convex/concave SCOP-splines used with numeric 'by' variable: <code>bs="mdcxBy"</code>, <code>bs="mdcvBy"</code>, <code>bs="micxBy"</code>, <code>bs="micvBy"</code>. 
</p>
<p>These work similar to <code>mdcx.smooth.spec</code>, <code>mdcv.smooth.spec</code>, <code>micx.smooth.spec</code>, <br />
<code>micv.smooth.spec</code>, but without applying an identifiability constraint ('zero intercept' constraint). Use when the smooth term has a numeric <code>by</code> variable  that takes more than one value.
For details see <code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>. 
</p>
</li></ul>

<p>For all types of the mixed constrained smoothing a first order difference penalty applied to the basis coefficients starting with the third one is used. Centring ('sum-to-zero') constraint has been applied to univariate SCOP-splines subject to monotonicity (convexity) constraints after implementing the 'zero intercept' identifiability constraint. This is achieved by dropping the first (constant) column of the spline model matrix and subtracting the corresponding column means from the elements of the remaining columns afterwards. 'Sum-to-zero' constraint orthogonalized the smooth to the model intercept term, thus avoiding confounding with the intercept. The standard errors of the estimated intercept become lower with the centring constraint.
</p>
<p>Using the concept of the tensor product spline bases bivariate smooths under monotonicity constraint where monotonicity may be 
assumed on only one of the covariates (single monotonicity) or both of them (double monotonicity) are added as the smooth terms 
of the SCAM. Bivariate B-spline is constructed by expressing the coefficients of one of the marginal univariate 
B-spline bases as the B-spline of the other covariate. Double or single monotonicity is achieved by the corresponding 
re-parametrization of the bivariate basis coefficients to satisfy the sufficient conditions formulated in terms of the first 
order differences of the coefficients. The following explains the built in bivariate shape constrained smooth classes.
</p>

<ul>
<li><p> Double monotone increasing SCOP-splines: <code>bs="tedmi"</code>. 
</p>
<p>See <code><a href="#topic+smooth.construct.tedmi.smooth.spec">smooth.construct.tedmi.smooth.spec</a></code> for details.
</p>
</li>
<li><p> Double monotone decreasing SCOP-splines: <code>bs="tedmd"</code>. 
</p>
</li>
<li><p> Single monotone increasing SCOP-splines along the first covariate direction: <code>bs="tesmi1"</code>. 
</p>
</li>
<li><p> Single monotone increasing SCOP-splines along the second covariate direction: <code>bs="tesmi2"</code>. 
</p>
</li>
<li><p> Single monotone decreasing SCOP-splines along the first covariate direction: <code>bs="tesmd1"</code>. 
</p>
</li>
<li><p> Single monotone decreasing SCOP-splines along the second covariate direction: <code>bs="tesmd2"</code>. 
</p>
</li>
<li><p> SCOP-splines with double concavity constraint: <code>bs="tecvcv"</code>.
</p>
<p>See <code><a href="#topic+smooth.construct.tecvcv.smooth.spec">smooth.construct.tecvcv.smooth.spec</a></code> for details.
</p>
</li>
<li><p> SCOP-splines with double convexity constraint: <code>bs="tecxcx"</code>. 
</p>
<p>See <code><a href="#topic+smooth.construct.tecxcx.smooth.spec">smooth.construct.tecxcx.smooth.spec</a></code> for details.
</p>
</li>
<li><p> SCOP-splines with convexity wrt the first covariate and
concavity wrt the second covariate: <code>bs="tecxcv"</code>. See <code><a href="#topic+smooth.construct.tecxcv.smooth.spec">smooth.construct.tecxcv.smooth.spec</a></code> for details.
</p>
</li>
<li><p> Decreasing along the first covariate and
concave along the second covariate SCOP-splines: <code>bs="tedecv"</code>. 
See <code><a href="#topic+smooth.construct.tedecv.smooth.spec">smooth.construct.tedecv.smooth.spec</a></code> for details.
</p>
</li>
<li><p> Decreasing along the first covariate and convex along the second covariate SCOP-splines: <code>bs="tedecx"</code>. 
See <code><a href="#topic+smooth.construct.tedecx.smooth.spec">smooth.construct.tedecx.smooth.spec</a></code> for details.
</p>
</li>
<li><p> Increasing along the first covariate and concave along the second covariate SCOP-splines: <code>bs="temicv"</code>. 
See <code><a href="#topic+smooth.construct.temicv.smooth.spec">smooth.construct.temicv.smooth.spec</a></code> for details.
</p>
</li>
<li><p> Increasing along the first covariate and convex along the second covariate SCOP-splines: <code>bs="temicx"</code>. 
See <code><a href="#topic+smooth.construct.temicx.smooth.spec">smooth.construct.temicx.smooth.spec</a></code> for details.
</p>
</li>
<li><p> Convex along the second covariate SCOP-splines: <code>bs="tescx"</code>. 
</p>
<p>See <code><a href="#topic+smooth.construct.tescx.smooth.spec">smooth.construct.tescx.smooth.spec</a></code> for details.      
</p>
</li>
<li><p> Concave along the second covariate SCOP-splines: <code>bs="tescv"</code>. 
</p>
<p>See <code><a href="#topic+smooth.construct.tescv.smooth.spec">smooth.construct.tescv.smooth.spec</a></code> for details.
</p>
</li>
<li><p> Tensor product interaction with increasing constraint along the first
covariate and unconstrained along the second covariate: <code>bs="tismi"</code>. 
</p>
<p>See <code><a href="#topic+smooth.construct.tismi.smooth.spec">smooth.construct.tismi.smooth.spec</a></code> for details.
</p>
</li>
<li><p> Tensor product interaction with decreasing constraint along the first
covariate and unconstrained along the second covariate: <code>bs="tismd"</code>. 
</p>
<p>See <code><a href="#topic+smooth.construct.tismd.smooth.spec">smooth.construct.tismd.smooth.spec</a></code> for details.
</p>
</li></ul>

<p>Double penalties for the shape constrained tensor product smooths are obtained from the penalties of the marginal smooths. For the bivariate SCOP-splines with monotonicity (convexity) constraints along one covariate, the 'sum-to-zero' constraints are applied after dropping the first columns of the model matrix of the constrained marginal smooth. The basis for the unconstrained marginal must be non-negative over the region where the marginal monotonicity (convexity) is to hold. For the bivariate interaction smooths <code>"tismi"</code>  and <code>"tismd"</code> the following identifiability steps are implemented: i) dropped the first column of the <code>"mpi"</code> (<code>"mpd"</code>) marginals, ii) applied 'sum-to-zero' constraints to the marginals and to the unconstrained B-spline basis, iii) tensor product constructed. The 'sum-to-zero' constraint is applied to the final tensor product model matrix afters removing its first column when constructing bivariate SCOP-splines with double monotonicity (convexity). These result in faster convergence of the optimization routines and more stable intercept estimates.
</p>
<p>Also linear functionals of smooths with shape constraints (increasing/decreasing and convex/concave) are 
supported. See <code><a href="#topic+linear.functional.terms">linear.functional.terms</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Natalya Pya <a href="mailto:nat.pya@gmail.com">nat.pya@gmail.com</a>
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>
<p>Eilers, P.H.C. and B.D. Marx (1996) Flexible Smoothing with B-splines and Penalties. 
Statistical Science, 11(2):89-121
</p>
<p>Wood S.N. (2017) Generalized Additive Models: An Introduction with R (2nd edition). Chapman
and Hall/CRC Press
</p>
<p>Wood, S.N. (2006) Low rank scale invariant tensor product smooths for
generalized additive mixed models. Biometrics 62(4):1025-1036
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.tedmi.smooth.spec">smooth.construct.tedmi.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.tesmi1.smooth.spec">smooth.construct.tesmi1.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.tesmi2.smooth.spec">smooth.construct.tesmi2.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.tesmd1.smooth.spec">smooth.construct.tesmd1.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.tesmd2.smooth.spec">smooth.construct.tesmd2.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.tismi.smooth.spec">smooth.construct.tismi.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.tismd.smooth.spec">smooth.construct.tismd.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for scam 
</code></pre>

<hr>
<h2 id='smooth.construct.cv.smooth.spec'>Constructor for concave P-splines in SCAMs
</h2><span id='topic+smooth.construct.cv.smooth.spec'></span><span id='topic+smooth.construct.cvBy.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to concavity constraint which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using concave P-splines. This smooth is specified via model terms such as 
<code>s(x,k,bs="cv",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>cvBy.smooth.spec</code> works similar to <code>cv.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>cvBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="cvBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="cv")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'cvBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.cv.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.cv.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.cv.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"cv.smooth"</code>, <code>"cvBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## Concave P-splines example 
  ## simulating data...
   require(scam)
   set.seed(1)
   n &lt;- 100
   x &lt;- sort(2*runif(n)-1)
   f &lt;- -4*x^2
   y &lt;- f + rnorm(n)*0.45
   dat &lt;- data.frame(x=x,y=y)
   b &lt;- scam(y~s(x,k=15,bs="cv"),family=gaussian,data=dat,not.exp=FALSE)
   ## fit unconstrained model...
   b1 &lt;- scam(y~s(x,k=15,bs="cr"),family=gaussian, data=dat,not.exp=FALSE)
   ## plot results ...
   plot(x,y,xlab="x",ylab="y",cex=.5)
   lines(x,f)      ## the true function
   lines(x,b$fitted,col=2)  ## constrained fit 
   lines(x,b1$fitted,col=3) ## unconstrained fit 

## Poisson version...
   y &lt;- rpois(n,15*exp(f))
   dat &lt;- data.frame(x=x,y=y)
   ## fit model ...
   b &lt;- scam(y~s(x,k=15,bs="cv"),family=poisson(link="log"),data=dat,not.exp=FALSE)

   ## fit unconstrained model...
   b1&lt;-scam(y~s(x,k=15,bs="cr"),family=poisson(link="log"), data=dat,not.exp=FALSE)
   ## plot results ...
   plot(x,y,xlab="x",ylab="y",cex=.5)
   lines(x,15*exp(f))      ## the true function
   lines(x,b$fitted,col=2)  ## constrained fit 
   lines(x,b1$fitted,col=3) ## unconstrained fit 

## plotting on log scale...
   plot(x,log(15*exp(f)),type="l",cex=.5)      ## the true function
   lines(x,log(b$fitted),col=2)  ## constrained fit 
   lines(x,log(b1$fitted),col=3) ## unconstrained fit 

## 'by' factor example... 
  set.seed(9)
  n &lt;- 400
  x &lt;- sort(runif(n,-.5,.5))
  f1 &lt;- -.7*x+cos(x)-3
  f2 &lt;- -20*x^2 
  par(mfrow=c(1,2))
  plot(x,f1,type="l");plot(x,f2,type="l")
  e &lt;- rnorm(n, 0, 1.5)
  fac &lt;- as.factor(sample(1:2,n,replace=TRUE))
  fac.1 &lt;- as.numeric(fac==1)
  fac.2 &lt;- as.numeric(fac==2)
  y &lt;- f1*fac.1 + f2*fac.2 + e 
  dat &lt;- data.frame(y=y,x=x,fac=fac,f1=f1,f2=f2)
  b2 &lt;- scam(y ~ fac+s(x,by=fac,bs="cv"),data=dat,optimizer="efs")  
  plot(b2,pages=1,scale=0,shade=TRUE)
  summary(b2)
  x11()
  vis.scam(b2,theta=50,color="terrain")

 ## numeric 'by' variable example... 
 set.seed(6)
 n &lt;- 100
 x &lt;- sort(2*runif(n)-1)
 z &lt;- runif(n,-2,3)
 f &lt;- -4*x^2
 y &lt;- f*z + rnorm(n)*0.6
 dat &lt;- data.frame(x=x,z=z,y=y)
 b &lt;- scam(y~s(x,k=15,by=z,bs="cvBy"),data=dat)
 summary(b)
 par(mfrow=c(1,2))
 plot(b,shade=TRUE)
 ## unconstrained fit...
 b1 &lt;- scam(y~s(x,k=15,by=z),data=dat)
 plot(b1,shade=TRUE)
 summary(b1)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.cx.smooth.spec'>Constructor for convex P-splines in SCAMs
</h2><span id='topic+smooth.construct.cx.smooth.spec'></span><span id='topic+smooth.construct.cxBy.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to convexity constraint which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using convex P-splines. This smooth is specified via model terms such as
<code>s(x,k,bs="cx",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>cxBy.smooth.spec</code> works similar to <code>cx.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>cxBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="cxBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="cx")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cx.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'cxBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.cx.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.cx.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.cx.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"cx.smooth"</code>, <code>"cxBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 
## Convex SCOP-splines example... 
  ## simulating data...
  require(scam)
  set.seed(16)
  n &lt;- 100
  x &lt;- sort(2*runif(n)-1)
  f &lt;- 4*x^2
  y &lt;- f + rnorm(n)*0.4
  dat &lt;- data.frame(x=x,y=y)
  b &lt;- scam(y~s(x,k=15,bs="cx"),family=gaussian,data=dat)
  ## unconstrained fit...
  b1 &lt;- scam(y~s(x,k=15),family=gaussian, data=dat)
  ## plot results ...
  plot(x,y,xlab="x",ylab="y")
  lines(x,f)      ## the true function
  lines(x,b$fitted,col=2)  ## constrained fit 
  lines(x,b1$fitted,col=3) ## unconstrained fit 

## Poisson version...
  set.seed(18)
  y &lt;- rpois(n,exp(f))
  dat &lt;- data.frame(x=x,y=y)
  ## fit shape constrained model ...
  b &lt;- scam(y~s(x,k=15,bs="cx"),family=poisson(link="log"),data=dat,optimizer="efs")
  ## unconstrained fit... 
  b1 &lt;- scam(y~s(x,k=15),family=poisson(link="log"), data=dat,optimizer="efs")
  ## plot results ...
  plot(x,y,xlab="x",ylab="y")
  lines(x,exp(f))      ## the true function
  lines(x,b$fitted,col=2)  ## constrained fit 
  lines(x,b1$fitted,col=3) ## unconstrained fit 

## 'by' factor example... 
  set.seed(9)
  n &lt;- 400
  x &lt;- sort(runif(n,-.5,.5))
  f1 &lt;- .7*x-cos(x)+3
  f2 &lt;- 20*x^2 
  par(mfrow=c(1,2))
  plot(x,f1,type="l");plot(x,f2,type="l")
  e &lt;- rnorm(n, 0, 1.5)
  fac &lt;- as.factor(sample(1:2,n,replace=TRUE))
  fac.1 &lt;- as.numeric(fac==1)
  fac.2 &lt;- as.numeric(fac==2)
  y &lt;- f1*fac.1 + f2*fac.2 + e 
  dat &lt;- data.frame(y=y,x=x,fac=fac,f1=f1,f2=f2)
  b2 &lt;- scam(y ~ fac+s(x,by=fac,bs="cx"),data=dat,optimizer="efs")  
  plot(b2,pages=1,scale=0)
  summary(b2)
  x11()
  vis.scam(b2,theta=50,color="terrain")

 ## numeric 'by' variable example... 
 set.seed(6)
 n &lt;- 100
 x &lt;- sort(2*runif(n)-1)
 z &lt;- runif(n,-2,3)
 f &lt;- 4*x^2
 y &lt;- f*z + rnorm(n)*.6
 dat &lt;- data.frame(x=x,z=z,y=y)
 b &lt;- scam(y~s(x,k=15,by=z,bs="cxBy"),data=dat)
 summary(b)
 par(mfrow=c(1,2))
 plot(b,shade=TRUE)
 ## unconstrained fit...
 b1 &lt;- scam(y~s(x,k=15,by=z),data=dat)
 plot(b1,shade=TRUE)
 summary(b1)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.mdcv.smooth.spec'>Constructor for monotone decreasing and concave P-splines in SCAMs
</h2><span id='topic+smooth.construct.mdcv.smooth.spec'></span><span id='topic+smooth.construct.mdcvBy.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to both monotone decreasing and concavity constraints which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using mixed constrained P-splines. This smooth is specified via model terms such as 
<code>s(x,k,bs="mdcv",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>mdcvBy.smooth.spec</code> works similar to <code>mdcv.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>mdcvBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="mdcvBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="mdcv")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdcv.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'mdcvBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.mdcv.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.mdcv.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.mdcv.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"mdcv.smooth"</code>, <code>"mdcvBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt; 
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
## Monotone decreasing and concave SCOP-splines example 
  ## simulating data...
   require(scam)
   set.seed(2)
   n &lt;- 100
   x &lt;- sort(runif(n))
   f &lt;- -x^4
   y &lt;- f+rnorm(n)*.2
   dat &lt;- data.frame(x=x,y=y)
 ## fit model ...
   b &lt;- scam(y~s(x,bs="mdcv"),family=gaussian(),data=dat)

 ## fit unconstrained model ...
   b1 &lt;- scam(y~s(x,bs="ps"),family=gaussian(),data=dat)
 ## plot results ...
   plot(x,y,xlab="x",ylab="y",cex=.5)
   lines(x,f)          ## the true function
   lines(x,b$fitted.values,col=2) ## mixed constrained fit 
   lines(x,b1$fitted.values,col=3) ## unconstrained fit 

  
 ## numeric 'by' variable example... 
 set.seed(6)
 n &lt;- 100
 x &lt;- sort(runif(n))
 z &lt;- runif(n,-2,3)
 f &lt;- -x^4
 y &lt;- f*z + rnorm(n)*0.4
 dat &lt;- data.frame(x=x,z=z,y=y)
 b &lt;- scam(y~s(x,k=15,by=z,bs="mdcvBy"),data=dat)
 summary(b)
 par(mfrow=c(1,2))
 plot(b,shade=TRUE)
 ## unconstrained fit...
 b1 &lt;- scam(y~s(x,k=15,by=z),data=dat)
 plot(b1,shade=TRUE)
 summary(b1)

  
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.mdcx.smooth.spec'>Constructor for monotone decreasing and convex P-splines in SCAMs
</h2><span id='topic+smooth.construct.mdcx.smooth.spec'></span><span id='topic+smooth.construct.mdcxBy.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to both monotone decreasing and convexity constraints which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using mixed constrained P-splines. This smooth is specified via model terms such as 
<code>s(x,k,bs="mdcx",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>mdcxBy.smooth.spec</code> works similar to <code>mdcx.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>mdcxBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="mdcxBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="mdcx")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdcx.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'mdcxBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.mdcx.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.mdcx.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.mdcx.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"mdcx.smooth"</code>, <code>"mdcxBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## Monotone decreasing and convex SCOP-splines example 
  ## simulating data...
   require(scam)
   set.seed(2)
   n &lt;- 100
   x &lt;- sort(runif(n)*3-1)
   f &lt;- (x-3)^6/1000 # monotone decreasing and convex smooth
   y &lt;- f+rnorm(n)*.4
   dat &lt;- data.frame(x=x,y=y)
   ## fit model ...
   b &lt;- scam(y~s(x,k=15,bs="mdcx"),family=gaussian(link="identity"),data=dat)
   ## fit unconstrained model ...
   b1 &lt;- scam(y~s(x,k=15,bs="ps"),family=gaussian(link="identity"),data=dat)
   ## plot results ...
   plot(x,y,xlab="x",ylab="y")
   lines(x,f)           ## the true function
   lines(x,b$fitted.values,col=2)  ## mixed constrained fit 
   lines(x,b1$fitted.values,col=3) ## unconstrained fit 

 ## numeric 'by' variable example... 
 set.seed(6)
 n &lt;- 100
 x &lt;- sort(runif(n)*3-1)
 z &lt;- runif(n,-2,3)
 f &lt;- (x-3)^6/1000 
 y &lt;- f*z + rnorm(n)*.4
 dat &lt;- data.frame(x=x,z=z,y=y)
 b &lt;- scam(y~s(x,k=15,by=z,bs="mdcxBy"),data=dat)
 summary(b)
 par(mfrow=c(1,2))
 plot(b,shade=TRUE)
 ## unconstrained fit...
 b1 &lt;- scam(y~s(x,k=15,by=z),data=dat)
 plot(b1,shade=TRUE)
 summary(b1)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.micv.smooth.spec'>Constructor for monotone increasing and concave P-splines in SCAMs
</h2><span id='topic+smooth.construct.micv.smooth.spec'></span><span id='topic+smooth.construct.micvBy.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to both monotone increasing and concavity constraints which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using mixed constrained P-splines. This smooth is specified via model terms such as 
<code>s(x,k,bs="micv",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>micvBy.smooth.spec</code> works similar to <code>micv.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>micvBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="micvBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="micv")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'micv.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'micvBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.micv.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.micv.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.micv.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"micv.smooth"</code>, <code>"micvBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## Monotone increasing and concave SCOP-splines example 
  ## simulating data...
   set.seed(3)
   n &lt;- 100
   x &lt;- sort(runif(n)*99+1)
   f &lt;- log(x)/2
   y &lt;- f+rnorm(n)*.3
   dat &lt;- data.frame(x=x,y=y)
   ## fit model ...
   b &lt;- scam(y~s(x,k=15,bs="micv"), data=dat)
   summary(b)
   # fit unconstrained model ...
   b1 &lt;- scam(y~s(x,k=15,bs="ps"),data=dat)
   ## plot results ...
   plot(x,y,xlab="x",ylab="y",cex=.5)
   lines(x,f)           ## the true function
   lines(x,b$fitted.values,col=2)  ## mixed constrained fit 
   lines(x,b1$fitted.values,col=3) ## unconstrained fit 

 ## numeric 'by' variable example... 
 set.seed(3)
 n &lt;- 100
 x &lt;- sort(runif(n)*99+1)
 f &lt;- log(x)/2
 z &lt;- runif(n,-2,3)
 y &lt;- f*z + rnorm(n)*0.3
 dat &lt;- data.frame(x=x,z=z,y=y)
 b &lt;- scam(y~s(x,k=15,by=z,bs="micvBy")-1,data=dat)
 summary(b)
 par(mfrow=c(1,2))
 plot(b,shade=TRUE)
 ## unconstrained fit...
 b1 &lt;- scam(y~s(x,k=15,by=z)-1,data=dat)
 plot(b1,shade=TRUE)
 summary(b1)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.micx.smooth.spec'>Constructor for monotone increasing and convex P-splines in SCAMs
</h2><span id='topic+smooth.construct.micx.smooth.spec'></span><span id='topic+smooth.construct.micxBy.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to both monotone increasing and convexity constraints which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using the mixed constrained P-splines. This smooth is specified via model terms such as
<code>s(x,k,bs="micx",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>micxBy.smooth.spec</code> works similar to <code>micx.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>micxBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="micvBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="micx")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'micx.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'micxBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.micx.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.micx.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.micx.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"micx.smooth"</code>, <code>"micxBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## Monotone increasing and convex SCOP-splines example 
  ## simulating data...
   set.seed(1)
   n &lt;- 100
   x &lt;- runif(n)*2
   f &lt;- 5*x^2/8
   y &lt;- rpois(n,exp(f))
   dat &lt;- data.frame(x=x,y=y)
   ## fit model ...
   b &lt;- scam(y~s(x,bs="micx"),family=poisson,data=dat)
   ## fit unconstrained model ...
   b1 &lt;- scam(y~s(x,bs="cr"),family=poisson,data=dat)
   ## plot results ...
   plot(x,y,xlab="x",ylab="y",cex=.5)
   x1 &lt;- sort(x,index=TRUE)
   lines(x1$x,exp(f)[x1$ix])      ## the true function
   lines(x1$x,b$fitted.values[x1$ix],col=2)  ## mixed constrained fit 
   lines(x1$x,b1$fitted.values[x1$ix],col=3) ## unconstrained fit 

## numeric 'by' variable example... 
 set.seed(10)
 n &lt;- 100
 x &lt;- runif(n)*2
 f &lt;- x^2
 z &lt;- runif(n,-2,3)
 y &lt;- f*z + rnorm(n)*0.4
 dat &lt;- data.frame(x=x,z=z,y=y)
 b &lt;- scam(y~s(x,by=z,bs="micxBy"),data=dat)
 summary(b)
 par(mfrow=c(1,2))
 plot(b,shade=TRUE)
 ## unconstrained fit...
 b1 &lt;- scam(y~s(x,by=z),data=dat)
 plot(b1,shade=TRUE)
 summary(b1)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.mifo.smooth.spec'>Constructor for monotone increasing SCOP-splines with an additional 'finish at zero' constraint
</h2><span id='topic+smooth.construct.mifo.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to a monotone increasing constraint plus the smooths should pass through zero at the right-end point of the covariate range. This is similar to the <code>pc</code> argument to  <code>s</code> in  <code>mgcv(gam)</code> when <code>pc=max(x)</code>, where <code>x</code> is a covariate.
The smooth is built by the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 'Zero intercept' identifiability constraints used for univariate SCOP-splines are substituted with a 'finish at zero' constraint here. This smooth is specified via model terms such as 
<code>s(x,k,bs="mifo",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mifo.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.mifo.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.mifo.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.mifo.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor is not called directly, but as with <code>gam(mgcv)</code> is used internally. 
</p>
<p>A 'finish at zero' constraint is achieved by setting the last (m+1) spline coefficients to zero. According to the B-spline basis functions properties, the value of the spline, <code>f(x)</code>, is determined by <code>m+2</code> non-zero basis functions, and only <code>m+1</code> B-splines are non-zero at knots. Only <code>m+2</code> B-splines are non-zero on any <code>[k_i, k_{i+1})</code>, and the sum of these <code>m+2</code> basis functions is 1.
</p>
<p>If the knots of the spline are not supplied, then they are placed evenly throughout the covariate values with an exception of the <code>m</code> inner knots preceeding the last inner knot that are joined with that last knot. This is done in order to avoid an otherwise plateau fit at the right-end region. If the knots are supplied, then the number of supplied knots should be <code>k+m+2</code>, and the range of the middle <code>k-m</code> knots must include all the covariate values.
</p>
<p>Note: when a plateau region is expected at the righ-end covariate region, the smooth might result in some decrease when approaching to zero.  
</p>


<h3>Value</h3>

<p> An object of class <code>"mifo.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.miso.smooth.spec">smooth.construct.miso.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, <code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  ## Monotone increasing SCOP-spline examples with a finish at zero constraint...
  set.seed(53)
  n &lt;- 100;x &lt;- runif(n);z &lt;- runif(n)
  pc &lt;- max(x)
  y &lt;- exp(3*x)/10-exp(3*pc)/10 + z*(1-z)*5 + rnorm(100)*.4
  m1 &lt;- scam(y~s(x,bs='mifo')+s(z)) #,knots=knots) 
  plot(m1,pages=1,scale=0)
  summary(m1)
  newd&lt;- data.frame(x=pc,z=0)
  predict(m1,newd, type='terms')


</code></pre>

<hr>
<h2 id='smooth.construct.miso.smooth.spec'>Constructor for monotone increasing SCOP-splines with an additional 'start at zero' constraint
</h2><span id='topic+smooth.construct.miso.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to a monotone increasing constraint plus the smooths should pass through zero at the left-end point of the covariate range. This is similar to the <code>pc</code> argument to  <code>s</code> in  <code>mgcv(gam)</code> when <code>pc=min(x)</code>, where <code>x</code> is a covariate.
The smooth is built by the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 'Zero intercept' identifiability constraints used for univariate SCOP-splines are substituted with a 'start at zero' constraint here. This smooth is specified via model terms such as 
<code>s(x,k,bs="miso",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miso.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.miso.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.miso.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.miso.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor is not called directly, but as with <code>gam(mgcv)</code> is used internally. 
</p>
<p>A 'start at zero' constraint is achieved by setting the first (m+1) spline coefficients to zero. According to the B-spline basis functions properties, the value of the spline, <code>f(x)</code>, is determined by <code>m+2</code> non-zero basis functions, and only <code>m+1</code> B-splines are non-zero at knots. Only <code>m+2</code> B-splines are non-zero on any <code>[k_i, k_{i+1})</code>, and the sum of these <code>m+2</code> basis functions is 1.
</p>
<p>If the knots of the spline are not supplied, then they are placed evenly throughout the covariate values with an exception of the <code>m</code> inner knots following the first inner knot that are joined with that first knot. This is done in order to avoid an otherwise plateau fit at the left-end region. If the knots are supplied, then the number of supplied knots should be <code>k+m+2</code>, and the range of the middle <code>k-m</code> knots must include all the covariate values.
</p>


<h3>Value</h3>

<p> An object of class <code>"miso.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.mifo.smooth.spec">smooth.construct.mifo.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, <code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
  ## Monotone increasing SCOP-spline examples with a start at zero constraint...
  ## passing through 0 at -1...
  require(scam)
  set.seed(7)
  n &lt;- 100;
  x &lt;- c(-1,runif(n-1)*4-1); ## starting at -1 for a function to be zero at a start
  z &lt;- runif(n)
  y &lt;- exp(4*x)/(1+exp(4*x)) -0.01798621+ z*(1-z)*5 + rnorm(100)*.4
  m1 &lt;- scam(y~s(x,bs='miso')+s(z)) 
  plot(m1,pages=1)
  newd&lt;- data.frame(x=-1,z=0)
  predict(m1,newd, type='terms')


## Not run: 
  ## passing through 0 at 0...
  set.seed(53)
  n &lt;- 100;
  x &lt;- c(0,runif(n-1)); ## starting at 0 for a function to be zero at a start
  z &lt;- runif(n)
  y &lt;- exp(3*x)/10-.1 + z*(1-z)*5 + rnorm(100)*.4
  m2 &lt;- scam(y~s(x,bs='miso')+s(z)) 
  plot(m2,pages=1)
  newd&lt;- data.frame(x=0,z=0)
  predict(m2,newd, type='terms')

    
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.mpd.smooth.spec'>Constructor for monotone decreasing P-splines in SCAMs
</h2><span id='topic+smooth.construct.mpd.smooth.spec'></span><span id='topic+smooth.construct.mpdBy.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to monotone decreasing constraints which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using monotonic P-splines. This smooth is specified via model terms such as 
<code>s(x,k,bs="mpd",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>mpdBy.smooth.spec</code> works similar to <code>mpd.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>mpdBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="mpdBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="mpd")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpd.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'mpdBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.mpd.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.mpd.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.mpd.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"mpd.smooth"</code>, <code>"mpdBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpi.smooth.spec">smooth.construct.mpi.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
## Monotone decreasing SCOP-splines example... 
  ## simulating data...
   require(scam)
   set.seed(3)
   n &lt;- 100
   x &lt;- runif(n)*3-1
   f &lt;- exp(-1.3*x)
   y &lt;- rpois(n,exp(f))
   dat &lt;- data.frame(x=x,y=y)
 ## fit model ...
   b &lt;- scam(y~s(x,k=15,bs="mpd"),family=poisson(link="log"),
       data=dat)
 ## unconstrained model fit for comparison...
   b1 &lt;- scam(y~s(x,k=15,bs="ps"),family=poisson(link="log"),
         data=dat)
 ## plot results ...
   plot(x,y,xlab="x",ylab="y",cex=.5)
   x1 &lt;- sort(x,index=TRUE)
   lines(x1$x,exp(f)[x1$ix])      ## the true function
   lines(x1$x,b$fitted.values[x1$ix],col=2)  ## decreasing fit 
   lines(x1$x,b1$fitted.values[x1$ix],col=3) ## unconstrained fit 

 ## 'by' factor example... 
 set.seed(3)
 n &lt;- 400
 x &lt;- runif(n, 0, 1)
 ## all three smooths are decreasing...
 f1 &lt;- -log(x *5) 
 f2 &lt;-  -exp(2 * x) + 4
 f3 &lt;-  -5* sin(x)
 e &lt;- rnorm(n, 0, 2)
 fac &lt;- as.factor(sample(1:3,n,replace=TRUE))
 fac.1 &lt;- as.numeric(fac==1)
 fac.2 &lt;- as.numeric(fac==2)
 fac.3 &lt;- as.numeric(fac==3)
 y &lt;- f1*fac.1 + f2*fac.2 + f3*fac.3 + e 
 dat &lt;- data.frame(y=y,x=x,fac=fac,f1=f1,f2=f2,f3=f3)
 b2 &lt;- scam(y ~ fac+s(x,by=fac,bs="mpd"),data=dat)  
 plot(b2,pages=1,scale=0,shade=TRUE)
 summary(b2)
 vis.scam(b2,theta=120,color="terrain")

 ## comparing with unconstrained fit...
 b3 &lt;- scam(y ~ fac+s(x,by=fac),data=dat) 
 x11()
 plot(b3,pages=1,scale=0,shade=TRUE)
 summary(b3)

 ## Note that since in scam() as in mgcv::gam() when using factor 'by' variables, 'centering'
 ## constraints are applied to the smooths, which usually means that the 'by'
 ## factor variable should be included as a parametric term, as well. 


## numeric 'by' variable example...
set.seed(3)
n &lt;- 100
x &lt;- sort(runif(n,-1,2))
z &lt;- runif(n,-2,3)
f &lt;- exp(-1.3*x)
y &lt;- f*z + rnorm(n)*0.4
dat &lt;- data.frame(x=x,y=y,z=z)
b &lt;- scam(y~s(x,k=15,by=z,bs="mpdBy"),data=dat,optimizer="efs")
plot(b,shade=TRUE)
summary(b)
## unconstrained fit...
b1 &lt;- scam(y~s(x,k=15,by=z),data=dat)
plot(b1,shade=TRUE)
summary(b1)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.mpi.smooth.spec'>Constructor for monotone increasing P-splines in SCAMs
</h2><span id='topic+smooth.construct.mpi.smooth.spec'></span><span id='topic+smooth.construct.mpiBy.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating smooths subject to a monotone increasing constraint which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using monotonic P-splines. This smooth is specified via model terms such as 
<code>s(x,k,bs="mpi",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p><code>mpiBy.smooth.spec</code> works similar to <code>mpi.smooth.spec</code> but without applying an identifiability constraint ('zero intercept' constraint). <code>mpiBy.smooth.spec</code> should be used when the smooth term has a numeric <code>by</code> variable  that takes more than one value. In such cases, the smooth terms are fully identifiable without a 'zero intercept' constraint, so they are left unconstrained. This smooth is specified as 
<code>s(x,by=z,bs="mpiBy")</code>. See an example below.
</p>
<p>However  a factor <code>by</code> variable requires identifiability constraints, so <code>s(x,by=fac,bs="mpi")</code> is used in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpi.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'mpiBy.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.mpi.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.mpi.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.mpi.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor is not called directly, but as with <code>gam(mgcv)</code> is used internally. 
</p>
<p>If the knots of the spline are not supplied, then they are placed evenly throughout the covariate values. If the knots are supplied, then the number of supplied knots should be <code>k+m+2</code>, and the range of the middle <code>k-m</code> knots must include all the covariate values.
</p>


<h3>Value</h3>

<p> An object of class <code>"mpi.smooth"</code>, <code>"mpiBy.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, 
<code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Monotone increasing P-splines example 
  ## simulating data...
   require(scam)
   set.seed(12)
   n &lt;- 100
   x &lt;- runif(n)*4-1
   f &lt;- 4*exp(4*x)/(1+exp(4*x))
   y &lt;- rpois(n,exp(f))
   dat &lt;- data.frame(x=x,y=y)
 ## fit model ...
   b &lt;- scam(y~s(x,k=15,bs="mpi"),family=poisson(link="log"),
       data=dat)
 ## fit unconstrained model...
   b1 &lt;- scam(y~s(x,k=15,bs="ps"),family=poisson(link="log"),
         data=dat)
 ## plot results ...
   plot(x,y,xlab="x",ylab="y")
   x1 &lt;- sort(x,index=TRUE)
   lines(x1$x,exp(f)[x1$ix])      ## the true function
   lines(x1$x,b$fitted.values[x1$ix],col=2)  ## monotone fit 
   lines(x1$x,b1$fitted.values[x1$ix],col=3) ## unconstrained fit 

## example with supplied knots...
   knots &lt;- list(x=c (-1.5,  -1.2, -.99, -.97, -.7, -.5, -.3, 0, 0.7,  
           0.9,1.1, 1.22,1.5,2.2,2.77,2.93,2.99, 3.2,3.6))
   b2 &lt;- scam(y~s(x,k=15,bs="mpi"),knots=knots, 
          family=poisson(link="log"), data=dat)
   summary(b2)
   plot(b2,shade=TRUE)

## Not run: 
## example with two terms...
   set.seed(0)
   n &lt;- 200
   x1 &lt;- runif(n)*6-3
   f1 &lt;- 3*exp(-x1^2) # unconstrained term
   x2 &lt;- runif(n)*4-1;
   f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # monotone increasing smooth
   f &lt;- f1+f2
   y &lt;- f+rnorm(n)*.7
   dat &lt;- data.frame(x1=x1,x2=x2,y=y)
   knots &lt;- list(x1=c(-4,-3.5,-2.99,-2.7,-2.5,-1.9,-1.1,-.9,-.3,0.3,.8,1.2,1.9,2.3,
2.7,2.99,3.5,4.1,4.5), x2=c(-1.5,-1.2,-1.1, -.89,-.69,-.5,-.3,0,0.7, 
0.9,1.1,1.22,1.5,2.2,2.77,2.99,3.1, 3.2,3.6))
   b3 &lt;- scam(y~s(x1,k=15)+s(x2,bs="mpi", k=15), 
         knots=knots,data=dat)
   summary(b3)
   plot(b3,pages=1,shade=TRUE)
## setting knots for f(x2) only...
   knots &lt;- list(x2=c(-1.5,-1.2,-1.1, -.89,-.69,-.5,-.3,
   0,0.7,0.9,1.1,1.22,1.5,2.2,2.77,2.99,3.1, 3.2,3.6))
   b4 &lt;- scam(y~s(x1,k=15,bs="bs")+s(x2,bs="mpi",k=15),
       knots=knots,data=dat)
   summary(b4)
   plot(b4,pages=1,shade=TRUE)

## 'by' factor example... 
 set.seed(10)
 n &lt;- 400
 x &lt;- runif(n, 0, 1)
 ## all three smooths are increasing...
 f1 &lt;- log(x *5) 
 f2 &lt;-  exp(2*x) - 4
 f3 &lt;-  5* sin(x)
 e &lt;- rnorm(n, 0, 2)
 fac &lt;- as.factor(sample(1:3,n,replace=TRUE))
 fac.1 &lt;- as.numeric(fac==1)
 fac.2 &lt;- as.numeric(fac==2)
 fac.3 &lt;- as.numeric(fac==3)
 y &lt;- f1*fac.1 + f2*fac.2 + f3*fac.3 + e 
 dat &lt;- data.frame(y=y,x=x,fac=fac,f1=f1,f2=f2,f3=f3)
 b5 &lt;- scam(y ~ fac+s(x,by=fac,bs="mpi"),data=dat)  
 plot(b5,pages=1,scale=0,shade=TRUE)
 summary(b5)
 vis.scam(b5,theta=50,color="terrain")

 ## comparing with unconstrained fit...
 b6 &lt;- scam(y ~ fac+s(x,by=fac),data=dat) 
 x11()
 plot(b6,pages=1,scale=0,shade=TRUE)
 summary(b6)
 vis.scam(b6,theta=50,color="terrain")

 ## Note that since in scam() as in mgcv::gam() when using factor 'by' variables, 'centering'
 ## constraints are applied to the smooths, which usually means that the 'by'
 ## factor variable should be included as a parametric term, as well. 


## numeric 'by' variable example...
 set.seed(3)
 n &lt;- 200
 x &lt;- sort(runif(n,-1,2))
 z &lt;- runif(n,-2,3)
 f &lt;- exp(1.3*x)-5
 y &lt;- f*z + rnorm(n)*2
 dat &lt;- data.frame(x=x,y=y,z=z)
 b &lt;- scam(y~s(x,by=z,bs="mpiBy"),data=dat)
 plot(b,shade=TRUE)
 summary(b)
 ## unconstrained fit...
 b1 &lt;- scam(y~s(x,k=15,by=z),data=dat)
 plot(b1,shade=TRUE)
 summary(b1)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.po.smooth.spec'>Constructor for SCOP-splines with positivity constraint
</h2><span id='topic+smooth.construct.po.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating univariate smooths subject to a positivity constraint which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed using monotonic P-splines. This smooth is specified via model terms suach as 
<code>s(x,k,bs="po",m=2)</code>, 
where <code>k</code> denotes the basis dimension and <code>m+1</code> is the order of the B-spline basis.
</p>
<p>Note: Models that include this smooth should not have an intercept. See examples below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'po.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.po.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.po.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the data required by this term,
with names given by <code>object$term</code>. The <code>by</code> variable is the last element.</p>
</td></tr>
<tr><td><code id="smooth.construct.po.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots supplied for basis setup.  
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> An object of class <code>"po.smooth"</code>. 
</p>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.mpd.smooth.spec">smooth.construct.mpd.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.cv.smooth.spec">smooth.construct.cv.smooth.spec</a></code>,
</p>
<p><code><a href="#topic+smooth.construct.cx.smooth.spec">smooth.construct.cx.smooth.spec</a></code>,
<code><a href="#topic+smooth.construct.mdcv.smooth.spec">smooth.construct.mdcv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.mdcx.smooth.spec">smooth.construct.mdcx.smooth.spec</a></code>, <code><a href="#topic+smooth.construct.micv.smooth.spec">smooth.construct.micv.smooth.spec</a></code>, 
</p>
<p><code><a href="#topic+smooth.construct.micx.smooth.spec">smooth.construct.micx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
##  SCOP-splines example with positivity constraint... 
  ## simulating data...
## Not run: 
   require(scam)
   set.seed(3)
   n &lt;- 100
   x &lt;- seq(-3,3,length.out=100)
   f &lt;- dnorm(x) 
   y &lt;- f + rnorm(n)*0.1  
   b &lt;- scam(y~s(x,bs="po")-1)
  
   b1 &lt;- scam(y~s(x)) ## unconstrained model
   plot(x,y)
   lines(x,f)
   lines(x,fitted(b),col=2)
   lines(x,fitted(b1),col=3)

  ## two-term example...
  set.seed(3)
  n &lt;- 200
  x1 &lt;- seq(-3,3,length.out=n)
  f1 &lt;- 3*exp(-x1^2) ## positively constrained smooth
  x2 &lt;- runif(n)*3-1;
  f2 &lt;- exp(4*x2)/(1+exp(4*x2)) ## increasing smooth 
  f &lt;- f1+f2
  y &lt;- f+rnorm(n)*0.3
  dat &lt;- data.frame(x1=x1,x2=x2,y=y)
  ## fit model, results, and plot...
  b2 &lt;- scam(y~s(x1,bs="po")+s(x2,bs="mpi")-1,data=dat)
  summary(b2)
  plot(b2,pages=1)

  b3 &lt;- scam(y~s(x1,bs="ps")+s(x2,bs="ps"),data=dat) ## unconstrained model
  summary(b3)
  plot(b3,pages=1) 
 
## End(Not run) 
</code></pre>

<hr>
<h2 id='smooth.construct.tecvcv.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to double concavity constraint
</h2><span id='topic+smooth.construct.tecvcv.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to double concavity constraint, i.e. concavity constraint wrt both the first and the second covariates. This is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tecvcv",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tecvcv.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tecvcv.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tecvcv.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tecvcv.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tecvcv.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.temicx.smooth.spec">smooth.construct.temicx.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tedecx.smooth.spec">smooth.construct.tedecx.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.tecxcx.smooth.spec">smooth.construct.tecxcx.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tecxcv.smooth.spec">smooth.construct.tecxcv.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tecvcv' example 
  ## simulating data...
   set.seed(3)
   n &lt;- 30
   x1 &lt;- sort(2*runif(n)-1)
   x2 &lt;- sort(2*runif(n)-1)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f1[i,j] &lt;- -4*(x1[i]^2+x2[j]^2)       
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*.05
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tecvcv"), data=dat)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b, theta=30,phi=40)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;- seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- -4*(x1[i]^2+x2[j]^2)     
   persp(x1,x2,f1,theta = 30, phi = 40)  
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tecxcv.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to mixed constraints: convexity constraint wrt the first covariate and concavity wrt the second one
</h2><span id='topic+smooth.construct.tecxcv.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to mixed constraints, convexity constraint wrt the first covariate and concavity wrt the second one. This is built by the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tecxcv",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tecxcv.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tecxcv.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tecxcv.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tecxcv.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tecxcv.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.tedecv.smooth.spec">smooth.construct.tedecv.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tedecx.smooth.spec">smooth.construct.tedecx.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.tecvcv.smooth.spec">smooth.construct.tecvcv.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tecxcx.smooth.spec">smooth.construct.tecxcx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tecxcv' example 
  ## simulating data...
   set.seed(5)
   n &lt;- 30
   x1 &lt;- sort(2*runif(n)-1)
   x2 &lt;- sort(2*runif(n)-1)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f1[i,j] &lt;- 2*x1[i]^2 - 4*x2[j]^2  
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*.05
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tecxcv"), data=dat)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b,theta=30,phi=40)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;- seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- 2*x1[i]^2 - 4*x2[j]^2      
   persp(x1,x2,f1,theta = 30, phi = 40)  
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tecxcx.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to double convexity constraint
</h2><span id='topic+smooth.construct.tecxcx.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to double convexity constraint, convexity constraint wrt both the first and the second covariates. This is built by the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tecxcx",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tecxcx.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tecxcx.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tecxcx.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tecxcx.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tecxcx.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.tedecv.smooth.spec">smooth.construct.tedecv.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tedecx.smooth.spec">smooth.construct.tedecx.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.tecvcv.smooth.spec">smooth.construct.tecvcv.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tecxcv.smooth.spec">smooth.construct.tecxcv.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tecxcx' example 
  ## simulating data...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(2*runif(n)-1)
   x2 &lt;- sort(2*runif(n)-1)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
       { f1[i,j] &lt;- 2*(x1[i]^2 + x2[j]^2)}  
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*.05
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tecxcx"), data=dat)
   summary(b)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b,theta=20,phi=20)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;- seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- 2*(x1[i]^2 + x2[j]^2)
   persp(x1,x2,f1,theta = 30, phi = 40)  
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tedecv.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to mixed constraints: monotone decreasing constraint wrt the first covariate and concavity wrt the second one
</h2><span id='topic+smooth.construct.tedecv.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to mixed constraints, monotone decreasing constraint wrt the first covariate and concavity wrt the second one, which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tedecv",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tedecv.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tedecv.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tedecv.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tedecv.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tedecv.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.temicx.smooth.spec">smooth.construct.temicx.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tedecx.smooth.spec">smooth.construct.tedecx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tedecv' example 
  ## simulating data...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(2*runif(n)-1)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
       { f1[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i]))- 4*x2[j]^2}        
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*0.1
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tedecv",m=2), data=dat)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b, theta=30)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;- seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i]))- 4*x2[j]^2   
   persp(x1,x2,f1,theta = 30, phi = 40)  
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tedecx.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to mixed constraints: monotone decreasing constraint wrt the first covariate and convexity wrt the second one
</h2><span id='topic+smooth.construct.tedecx.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to mixed constraints, monotone decreasing constraint wrt the first covariate and convexity wrt the second one, which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tedecx",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tedecx.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tedecx.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tedecx.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tedecx.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tedecx.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.tedecv.smooth.spec">smooth.construct.tedecv.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tedecx' example 
  ## simulating data...

   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(2*runif(n)-1)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f1[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i])) + 2*x2[j]^2  
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*0.05
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tedecx",m=2), not.exp=TRUE, data=dat)
## b1 &lt;- scam(y~s(x1,bs="mpd",m=2)+s(x2,bs="cx",m=2), data=dat)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b,theta=20,phi=20)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;- seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i])) + 2*x2[j]^2    
   persp(x1,x2,f1,theta = 30, phi = 40)  
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tedmd.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to double monotone decreasing
constraint 
</h2><span id='topic+smooth.construct.tedmd.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to double monotone decreasing constraints which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tedmd",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>
<p>From <code>scam</code> version 1.2-15, the sum-to-zero contraint is now applied to all bivariate SCOP-splines after imposing the scop-constraints (including scop identifiability constraint). This simply shifts the smooth vertically, leaving the shape of the smooths unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tedmd.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tedmd.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tedmd.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tedmd.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tedmd.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmi.smooth.spec">smooth.construct.tedmi.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tedmd' example 
  ## simulating data...
   require(scam)
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(runif(n))
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
       { f1[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i]))-2*exp(x2[j]-0.5)}
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*0.1
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tedmd"), data=dat)
   summary(b)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 80, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tedmi.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to double monotone increasing
constraint 
</h2><span id='topic+smooth.construct.tedmi.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to double monotone increasing constraints which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tedmi",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tedmi.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tedmi.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tedmi.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tedmi.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tedmi.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tedmi' example 
  ## simulating data...
   set.seed(1)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(runif(n))
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
       { f1[i,j] &lt;- exp(4*x1[i])/(1+exp(4*x1[i]))+2*exp(x2[j]-0.5)}
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*0.1
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tedmi"), data=dat,optimizer="efs")
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.temicv.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to mixed constraints: monotone increasing constraint wrt the first covariate and concavity wrt the second one
</h2><span id='topic+smooth.construct.temicv.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to mixed constraints, monotone increasing constraint wrt the first covariate and concavity wrt the second one, which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="temicv",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'temicv.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.temicv.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.temicv.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.temicv.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"temicv.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.temicx.smooth.spec">smooth.construct.temicx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `temicv' example 
  ## simulating data...
   set.seed(4)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(2*runif(n)-1)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f1[i,j] &lt;- exp(4*x1[i])/(1+exp(4*x1[i])) - 4*x2[j]^2    
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*0.1
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="temicv"), data=dat)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b, theta=30, phi = 40)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;- seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- exp(4*x1[i])/(1+exp(4*x1[i])) - 4*x2[j]^2
   persp(x1,x2,f1,theta = 30, phi = 40)  
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.temicx.smooth.spec'>Tensor product smoothing constructor for bivariate function subject to mixed constraints: monotone increasing constraint wrt the first covariate and convexity wrt the second one
</h2><span id='topic+smooth.construct.temicx.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths subject to mixed constraints, monotone increasing constraint wrt the first covariate and convexity wrt the second one, which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths which are represented using the B-spline basis functions.  
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="temicx",m=c(2,2))</code>, 
where <code>q1</code> and <code>q2</code> denote the basis dimensions for the marginal smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'temicx.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.temicx.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.temicx.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.temicx.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"temicx.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tedmd.smooth.spec">smooth.construct.tedmd.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `temicx' example 
  ## simulating data...
   set.seed(1)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(2*runif(n)-1) 
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f1[i,j] &lt;- exp(4*x1[i])/(1+exp(4*x1[i])) + 2*x2[j]^2 
   f &lt;- as.vector(t(f1))
   y &lt;- f+rnorm(length(f))*0.1
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="temicx",m=2), data=dat)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b,theta = 30, phi = 40)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;-  seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- exp(4*x1[i])/(1+exp(4*x1[i])) + 2*x2[j]^2 
   persp(x1,x2,f1,theta = 30, phi = 40)  
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tescv.smooth.spec'>Tensor product smoothing constructor for a bivariate function concave
in the second covariate
</h2><span id='topic+smooth.construct.tescv.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths concave in the second covariate which is built by the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty
marginal smooths. This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tescv",m=c(2,2))</code>, 
where the basis for the first marginal smooth is specified in the second element of <code>bs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tescv.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tescv.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tescv.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tescv.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tescv.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.temicv.smooth.spec">smooth.construct.temicv.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.temicx.smooth.spec">smooth.construct.temicx.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tedecv.smooth.spec">smooth.construct.tedecv.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.tedecx.smooth.spec">smooth.construct.tedecx.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tescx.smooth.spec">smooth.construct.tescx.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tescv' example 
  ## simulating data...
   set.seed(5)
   n &lt;- 30
   x1 &lt;- sort(runif(n))
   x2 &lt;- sort(2*runif(n)-1)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f1[i,j] &lt;- sin(2*x1[i]) - 4*x2[j]^2
   f1 &lt;- as.vector(t(f1))
   f &lt;- (f1-min(f1))/(max(f1)-min(f1))
   y &lt;- f+rnorm(length(f))*0.1
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tescv",m=2),
            family=gaussian(), data=dat)
## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE, theta = 50, phi = 20) 
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b, theta = 50, phi = 20)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;-  seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- sin(2*x1[i]) - 4*x2[j]^2
   persp(x1,x2,f1,theta = 50, phi = 20)  
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tescx.smooth.spec'>Tensor product smoothing constructor for a bivariate function convex
in the second covariate
</h2><span id='topic+smooth.construct.tescx.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths convex in the second covariate which is built by the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty
marginal smooths. This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tescx",m=c(2,2))</code>, 
where the basis for the first marginal smooth is specified in the second element of <code>bs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tescx.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tescx.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tescx.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tescx.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tescx.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.temicv.smooth.spec">smooth.construct.temicv.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.temicx.smooth.spec">smooth.construct.temicx.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tedecv.smooth.spec">smooth.construct.tedecv.smooth.spec</a></code>
<code><a href="#topic+smooth.construct.tedecx.smooth.spec">smooth.construct.tedecx.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tescv.smooth.spec">smooth.construct.tescv.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tescx' example 
  ## simulating data...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n))
   x2 &lt;- sort(2*runif(n)-1)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f1[i,j] &lt;- sin(x1[i]) + 2*x2[j]^2 
   f1 &lt;- as.vector(t(f1))
   f &lt;- (f1-min(f1))/(max(f1)-min(f1))
   y &lt;- f+rnorm(length(f))*0.1
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
   ## fit model ...
   b &lt;- scam(y~s(x1,x2,k=c(10,10),bs="tescx",m=2),
            family=gaussian(), data=dat)
   ## plot results ...
   par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE, theta = 50, phi = 20) 
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   x11()
   vis.scam(b, theta = 50, phi = 20)
   ## plotting the truth...
   x11()
   x1 &lt;- seq(min(x1),max(x1),length.out=30)
   x2 &lt;-  seq(min(x2),max(x2),length.out=30)
   f1 &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) f1[i,j] &lt;- sin(x1[i]) + 2*x2[j]^2 
   persp(x1,x2,f1,theta = 50, phi = 20) 
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tesmd1.smooth.spec'>Tensor product smoothing constructor for a bivariate function monotone decreasing
in the first covariate
</h2><span id='topic+smooth.construct.tesmd1.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths monotone decreasing in the first covariate which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty marginal smooths. 
This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tesmd1",m=2)</code>. 
The default basis for the second marginal smooth is P-spline. Cyclic cubic regression spline (<code>"cc"</code>) is implemented in addition to the P-spline. See an example below on how to call for it.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tesmd1.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tesmd1.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tesmd1.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tesmd1.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tesmd1.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
<tr><td><code>margin.bs</code></td>
<td>
<p>A two letter character string indicating the (penalized) smoothing basis to use for the second unconstrained marginal smooth. (eg <code>"ps"</code> for P-splines).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tesmd2.smooth.spec">smooth.construct.tesmd2.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tesmd1' example 
  ## simulating data...
   require(scam)
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1); x2 &lt;- sort(runif(n))
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i]))+2*sin(pi*x2[j])
   f &lt;- as.vector(t(f))
   y &lt;- f+rnorm(length(f))*.2
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,bs="tesmd1",k=10),data=dat)
## plot results ...
   old.par &lt;- par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   par(old.par)
   vis.scam(b,theta=40,phi=20)

## example with cyclic cubic regression spline along the second covariate...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1); x2 &lt;- sort(runif(n))
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- -exp(4*x1[i])/(1+exp(4*x1[i]))+sin(2*pi*x2[j])
   f &lt;- as.vector(t(f))
   y &lt;- f+rnorm(length(f))*.2
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b1 &lt;- scam(y~s(x1,x2,bs="tesmd1",xt=list("cc"),k=10), data=dat)
## plot results ...
   old.par &lt;- par(mfrow=c(2,2))
   plot(b1,se=TRUE)
   plot(b1,pers=TRUE,theta = 30, phi = 40)
   plot(y,b1$fitted.values,xlab="Simulated data",ylab="Fitted data")
   par(old.par)
   vis.scam(b1,theta=40,phi=20)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tesmd2.smooth.spec'>Tensor product smoothing constructor for a bivariate function monotone decreasing
in the second covariate
</h2><span id='topic+smooth.construct.tesmd2.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths monotone decreasing in the second covariate which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty
marginal smooths. This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tesmd2",m=c(2,2))</code>. The default basis for the first marginal smooth is P-spline. Cyclic cubic regression spline (<code>"cc"</code>) is implemented in addition to the P-spline. See an example below on how to call for it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tesmd2.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tesmd2.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tesmd2.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tesmd2.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tesmd2.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
<tr><td><code>margin.bs</code></td>
<td>
<p>A two letter character string indicating the (penalized) smoothing basis to use for the first unconstrained marginal smooth. (eg <code>"ps"</code> for P-splines).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tesmd1.smooth.spec">smooth.construct.tesmd1.smooth.spec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tesmd2' example 
  ## simulating data...
   require(scam)
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)); x2 &lt;- sort(runif(n)*4-1)
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- 2*sin(pi*x1[i])-exp(4*x2[j])/(1+exp(4*x2[j]))
   f &lt;- as.vector(t(f))
   y &lt;- f+rnorm(length(f))*.2
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,bs="tesmd2",k=10),data=dat)
## plot results ...
   old.par &lt;- par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,scheme=1,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   par(old.par)
   vis.scam(b,theta = 40, phi = 20)

## example with cyclic cubic regression spline along the 1st covariate...
   set.seed(4)
   n &lt;- 30
   x1 &lt;- sort(runif(n)); x2 &lt;- sort(runif(n)*4-1) 
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- sin(2*pi*x1[i])-exp(4*x2[j])/(1+exp(4*x2[j]))
   f &lt;- as.vector(t(f))
   y &lt;- f+rnorm(length(f))*.2
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b1 &lt;- scam(y~s(x1,x2,bs="tesmd2",xt=list("cc"),k=10), data=dat)
## plot results ...
   old.par &lt;-par(mfrow=c(2,2))
   plot(b1,se=TRUE)
   plot(b1,scheme=1,theta = 30, phi = 40)
   plot(y,b1$fitted.values,xlab="Simulated data",ylab="Fitted data")
   par(old.par)
   vis.scam(b1,theta=40,phi=20)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tesmi1.smooth.spec'>Tensor product smoothing constructor for a bivariate function monotone increasing
in the first covariate
</h2><span id='topic+smooth.construct.tesmi1.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths monotone increasing in the first covariate which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty
marginal smooths. This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tesmi1",m=2)</code>.
The basis for the second marginal smooth can be specified as a two letter character string  of the argument <code>xt</code> (eg <code>xt="cc"</code> to specify cyclic cubic regression spline). See example below. The default basis for the second marginal smooth is P-spline. Cyclic cubic regression spline (<code>"cc"</code>) is implemented in addition to the P-spline. See an example below on how to call for it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tesmi1.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tesmi1.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tesmi1.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tesmi1.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tesmi1.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
<tr><td><code>margin.bs</code></td>
<td>
<p>A two letter character string indicating the (penalized) smoothing basis to use for the second unconstrained marginal smooth. (eg <code>"cc"</code> for cyclic cubic regression spline).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tesmi2.smooth.spec">smooth.construct.tesmi2.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
## tensor product `tesmi1' example... 
  ## simulating data...
   require(scam)
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(runif(n))
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- exp(4*x1[i])/(1+exp(4*x1[i]))+2*sin(pi*x2[j])
   f &lt;- as.vector(t(f))
   y &lt;- f+rnorm(length(f))*.3
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,bs="tesmi1",k=c(10,10)), data=dat)
## plot results ...
   old.par&lt;- par(mfrow=c(2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE,theta = 30, phi = 40)
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   par(old.par)
   vis.scam(b,theta=40,phi=20)

## example with cyclic cubic regression spline along the second covariate...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)*4-1)
   x2 &lt;- sort(runif(n))
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- exp(4*x1[i])/(1+exp(4*x1[i]))+sin(2*pi*x2[j])
   f &lt;- as.vector(t(f))
   y &lt;- f+rnorm(length(f))*.2
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b1 &lt;- scam(y~s(x1,x2,bs="tesmi1",xt=list("cc"),k=10), data=dat)
## plot results ...
   old.par&lt;- par(mfrow=c(2,2))
   plot(b1,se=TRUE)
   plot(b1,pers=TRUE,theta = 30, phi = 40)
   plot(y,b1$fitted.values,xlab="Simulated data",ylab="Fitted data")
   par(old.par)
   vis.scam(b1,theta=40,phi=20)

 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tesmi2.smooth.spec'>Tensor product smoothing constructor for a bivariate function monotone increasing
in the second covariate
</h2><span id='topic+smooth.construct.tesmi2.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate smooths monotone increasing in the second covariate which is built by 
the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>. 
It is constructed from a pair of single penalty
marginal smooths. This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tesmi2",m=c(2,2))</code>. The default basis for the first marginal smooth is P-spline. Cyclic cubic regression spline (<code>"cc"</code>) is implemented in addition to the P-spline. See an example below on how to call for it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tesmi2.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tesmi2.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tesmi2.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tesmi2.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tesmi2.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
<tr><td><code>margin.bs</code></td>
<td>
<p>A two letter character string indicating the (penalized) smoothing basis to use for the first unconstrained marginal smooth. (eg <code>"cc"</code> for cyclic cubic regression spline).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt;
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tesmi1.smooth.spec">smooth.construct.tesmi1.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## tensor product `tesmi2' example 
  ## simulating data...
   require(scam)
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)); x2 &lt;- sort(runif(n)*4-1)
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- 2*sin(pi*x1[i]) +exp(4*x2[j])/(1+exp(4*x2[j]))
   f &lt;- as.vector(t(f))
   y &lt;- f+rnorm(length(f))*.3
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b &lt;- scam(y~s(x1,x2,bs="tesmi2",k=c(10,10)),data=dat)
## plot results ...
   old.par &lt;- par(mfrow=c(2,2),mar=c(4,4,2,2))
   plot(b,se=TRUE)
   plot(b,pers=TRUE, theta = 50, phi = 20) 
   plot(y,b$fitted.values,xlab="Simulated data",ylab="Fitted data")
   par(old.par)
   vis.scam(b,theta=50,phi=20)

## example with cyclic cubic regression spline along the 1st covariate...
   set.seed(2)
   n &lt;- 30
   x1 &lt;- sort(runif(n)); x2 &lt;- sort(runif(n)*4-1) 
   f &lt;- matrix(0,n,n)
   for (i in 1:n) for (j in 1:n) 
        f[i,j] &lt;- sin(2*pi*x1[i])+ exp(4*x2[j])/(1+exp(4*x2[j]))
   f &lt;- as.vector(t(f))
   y &lt;- f+rnorm(length(f))*.3
   x11 &lt;-  matrix(0,n,n)
   x11[,1:n] &lt;- x1
   x11 &lt;- as.vector(t(x11))
   x22 &lt;- rep(x2,n)
   dat &lt;- list(x1=x11,x2=x22,y=y)
## fit model ...
   b1 &lt;- scam(y~s(x1,x2,bs="tesmi2",xt=list("cc"),k=10), data=dat)
## plot results ...
   old.par &lt;- par(mfrow=c(2,2))
   plot(b1,se=TRUE)
   plot(b1,pers=TRUE,theta = 50, phi = 20)
   plot(y,b1$fitted.values,xlab="Simulated data",ylab="Fitted data")
   par(old.par)
   vis.scam(b1,theta=40,phi=20)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tismd.smooth.spec'>Tensor product interaction with decreasing constraint along the first
covariate and unconstrained along the second covariate
</h2><span id='topic+smooth.construct.tismd.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate interaction smooths with decreasing constraint in the first covariate,
appropriate when the main effects (and any lower interactions) are also present.
It is built by the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>, and constructed from a pair of single penalty marginal smooths. This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tismd")</code>.
See example below.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tismd.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tismd.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tismd.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tismd.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some cases, it is helpful to consider models with a main-effects + interactions structure, for example,
</p>
<p style="text-align: center;"><code class="reqn">f_1(x)  + f_2(z) + f_3(x,z)</code>
</p>

<p>where <code class="reqn">f_1</code> and <code class="reqn">f_2</code> are smooth &lsquo;main effects&rsquo; and <code class="reqn">f_3</code> is a smooth &lsquo;interaction&rsquo; subject to decreasing constraint wrt <code class="reqn">x</code> (<code class="reqn">f_1</code> can be subject to decreasing constraint). 
</p>
<p>Constructing such functional ANOVA decomposition recognises the fact that the tensor produc basis construction is exactly the same as the construction used for any interaction in a linear model. <code>tismd</code> produce tensor product interactions with decreasing constraint along the first covariate from which the main effects have been excluded, under the assumption that they will be included separately. For example, the <code>~ s(x) + s(z) + s(x,z,bs="tismd")</code> would produce the above main effects + interaction structure. Specifically, the marginal smooths of a tensor product, <code>tismd</code>, are subject to identifiability constraints before constructing the tensor product basis. This results in the interaction smooths that do not include the corresponding main effects. <code>tismd</code> apply SCOP identifiability constraints to the first marginal and sum-to-zero constraints to the second unconstrained marginal. See Wood (2017, section 5.6.3) for ANOVA decompositions of unconstrained smooths.
</p>


<h3>Value</h3>

<p>An object of class <code>"tismd.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
<tr><td><code>margin.bs</code></td>
<td>
<p>A two letter character string indicating the (penalized) smoothing basis to use for the second unconstrained marginal smooth. (eg <code>"cc"</code> for cyclic cubic regression spline).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya <a href="mailto:nat.pya@gmail.com">nat.pya@gmail.com</a>
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Wood S.N. (2017) Generalized Additive Models: An Introduction with R (2nd edition). Chapman
and Hall/CRC Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tesmd1.smooth.spec">smooth.construct.tesmd1.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tismi.smooth.spec">smooth.construct.tismi.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
## tensor product `tismd' example... 
  ## simulating data...
require(scam)
test &lt;- function(x,z){
  -exp(4*x)/(1+exp(4*x))-2*sin(pi*z)-(x+1)^0.6*z
}
set.seed(7)
n &lt;- 600
x &lt;- runif(n)*4-1
z &lt;- runif(n)
xs &lt;- seq(-1,3,length=30); zs &lt;- seq(0,1,length=30)
pr &lt;- data.frame(x=rep(xs,30),z=rep(zs,rep(30,30)))
truth &lt;- matrix(test(pr$x,pr$z),30,30)
f &lt;- test(x,z)
y &lt;- f + rnorm(n)*0.3
bi &lt;- scam(y~ ti(x)+ti(z)+ s(x,z,bs="tismd"))
summary(bi)
old.par &lt;- par(mfrow=c(2,2))
persp(xs,zs,truth);title("truth")
vis.scam(bi);title("tismd")

## fitting with "tesmd1" instead...
bc &lt;- scam(y~s(x,z,bs="tesmd1"))
vis.scam(bc);title("tesmd1")
par(old.par)

plot(bi,pages=1,scheme=2)
plot(bi,select=3,scheme=1,zlim=c(-3,3))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.tismi.smooth.spec'>Tensor product interaction with increasing constraint along the first
covariate and unconstrained along the second covariate
</h2><span id='topic+smooth.construct.tismi.smooth.spec'></span>

<h3>Description</h3>

<p>This is a special method function
for creating tensor product bivariate interaction smooths with increasing constraint in the first covariate,
appropriate when the main effects (and any lower interactions) are also present.
It is built by the <code>mgcv</code> constructor function for smooth terms, <code>smooth.construct</code>, and constructed from a pair of single penalty marginal smooths. This tensor product is specified by model terms such as <code>s(x1,x2,k=c(q1,q2),bs="tismi")</code>.
See example below. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tismi.smooth.spec'
smooth.construct(object, data, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.tismi.smooth.spec_+3A_object">object</code></td>
<td>
<p>A smooth specification object, generated by an <code>s</code> term in a GAM formula.</p>
</td></tr> 
<tr><td><code id="smooth.construct.tismi.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list containing the values of the elements of <code>object$term</code>,
with names given by <code>object$term</code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.tismi.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>An optional list containing the knots corresponding to <code>object$term</code>. 
If it is <code>NULL</code> then the knot locations are generated automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some cases, it is helpful to consider models with a main-effects + interactions structure, for example,
</p>
<p style="text-align: center;"><code class="reqn">f_1(x)  + f_2(z) + f_3(x,z)</code>
</p>

<p>where <code class="reqn">f_1</code> and <code class="reqn">f_2</code> are smooth &lsquo;main effects&rsquo; and <code class="reqn">f_3</code> is a smooth &lsquo;interaction&rsquo; subject to increasing constraint wrt <code class="reqn">x</code> (<code class="reqn">f_1</code> can be subject to increasing constraint). 
</p>
<p>Constructing such functional ANOVA decomposition recognises the fact that the tensor produc basis construction is exactly the same as the construction used for any interaction in a linear model. <code>tismi</code> produce tensor product interactions with increasing constraint along the first covariate from which the main effects have been excluded, under the assumption that they will be included separately. For example, the <code>~ s(x) + s(z) + s(x,z,bs="tismi")</code> would produce the above main effects + interaction structure. Specifically, the marginal smooths of a tensor product, <code>tismi</code>, are subject to identifiability constraints before constructing the tensor product basis. This results in the interaction smooths that do not include the corresponding main effects. <code>tismi</code> apply SCOP identifiability constraints to the first marginal and sum-to-zero constraints to the second unconstrained marginal. See Wood (2017, section 5.6.3) for ANOVA decompositions of unconstrained smooths.
</p>


<h3>Value</h3>

<p>An object of class <code>"tismi.smooth"</code>. In addition to the usual 
elements of a smooth class documented under <code>smooth.construct</code> of the <code>mgcv</code> library, 
this object contains:
</p>
<table>
<tr><td><code>p.ident</code></td>
<td>
<p>A vector of 0's and 1's for model parameter identification: 
1's indicate parameters which will be exponentiated, 0's - otherwise.</p>
</td></tr>
<tr><td><code>Zc</code></td>
<td>
<p>A matrix of identifiability constraints.</p>
</td></tr>
<tr><td><code>margin.bs</code></td>
<td>
<p>A two letter character string indicating the (penalized) smoothing basis to use for the second unconstrained marginal smooth. (eg <code>"cc"</code> for cyclic cubic regression spline).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Natalya Pya <a href="mailto:nat.pya@gmail.com">nat.pya@gmail.com</a>
</p>


<h3>References</h3>

<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Wood S.N. (2017) Generalized Additive Models: An Introduction with R (2nd edition). Chapman
and Hall/CRC Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.construct.tismd.smooth.spec">smooth.construct.tismd.smooth.spec</a></code>
</p>
<p><code><a href="#topic+smooth.construct.tesmi1.smooth.spec">smooth.construct.tesmi1.smooth.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
## tensor product `tismi' example... 
require(scam)
test &lt;- function(x,z){
  exp(4*x)/(1+exp(4*x))+2*sin(pi*z)+(x+1)^0.6*z
}

set.seed(7)
n &lt;- 600
x &lt;- runif(n)*4-1
z &lt;- runif(n)
xs &lt;- seq(-1,3,length=30); zs &lt;- seq(0,1,length=30)
pr &lt;- data.frame(x=rep(xs,30),z=rep(zs,rep(30,30)))
truth &lt;- matrix(test(pr$x,pr$z),30,30)
f &lt;- test(x,z)
y &lt;- f + rnorm(n)*0.3
bi &lt;- scam(y~ ti(x)+ti(z)+ s(x,z,bs="tismi"))
summary(bi)
old.par &lt;- par(mfrow=c(2,2))
persp(xs,zs,truth);title("truth")
vis.scam(bi);title("tismi")

## fitting with "tesmi1"...
bc &lt;- scam(y~s(x,z,bs="tesmi1"))
vis.scam(bc);title("tesmi1")
par(old.par)

plot(bi,pages=1,scheme=2)
plot(bi,select=3,scheme=1,zlim=c(-5,5)) 

 
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.scam'>Summary for a SCAM fit
</h2><span id='topic+summary.scam'></span><span id='topic+print.summary.scam'></span>

<h3>Description</h3>

<p>Takes a fitted <code>scam</code> object produced by <code>scam()</code> and produces various useful
summaries from it. The same code as in <code>summary.gam</code> of the <code>mgcv</code> package is used here with slight modifications
to accept the exponentiated parameters of the shape constrained smooth terms and the corresponding covariance matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scam'
summary(object, dispersion=NULL, freq=FALSE, ...)

## S3 method for class 'summary.scam'
print(x,digits = max(3, getOption("digits") - 3), 
                  signif.stars = getOption("show.signif.stars"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.scam_+3A_object">object</code></td>
<td>
<p>a fitted <code>scam</code> object as produced by <code>scam()</code>.</p>
</td></tr>
<tr><td><code id="summary.scam_+3A_x">x</code></td>
<td>
<p>a <code>summary.scam</code> object produced by <code>summary.scam()</code>.</p>
</td></tr> 
<tr><td><code id="summary.scam_+3A_dispersion">dispersion</code></td>
<td>
<p>A known dispersion parameter. <code>NULL</code> to use estimate or
default (e.g. 1 for Poisson).</p>
</td></tr>
<tr><td><code id="summary.scam_+3A_freq">freq</code></td>
<td>
<p>By default p-values for individual terms are calculated using the Bayesian estimated 
covariance matrix of the parameter estimators. If this is set to TRUE then
the frequentist covariance matrix of the parameters is used instead. </p>
</td></tr>
<tr><td><code id="summary.scam_+3A_digits">digits</code></td>
<td>
<p>controls number of digits printed in output.</p>
</td></tr>
<tr><td><code id="summary.scam_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Should significance stars be printed alongside output.</p>
</td></tr>
<tr><td><code id="summary.scam_+3A_...">...</code></td>
<td>
<p> other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.scam</code> produces the same list of summary information for a fitted <code>scam</code> object as in the 
unconstrained case <code>summary.gam</code> except for the last element <code>BFGS termination condition</code>. 
</p>
<table>
<tr><td><code>p.coeff</code></td>
<td>
<p>is an array of estimates of the strictly parametric model coefficients.</p>
</td></tr>
<tr><td><code>p.t</code></td>
<td>
<p>is an array of the <code>p.coeff</code>'s divided by their standard errors.</p>
</td></tr>
<tr><td><code>p.pv</code></td>
<td>
<p>is an array of p-values for the null hypothesis that the corresponding parameter is zero. 
Calculated with reference to the t distribution with the estimated residual
degrees of freedom for the model fit if the dispersion parameter has been
estimated, and the standard normal if not.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The number of smooth terms in the model.</p>
</td></tr>
<tr><td><code>chi.sq</code></td>
<td>
<p>An array of test statistics for assessing the significance of
model smooth terms. See details.</p>
</td></tr>
<tr><td><code>s.pv</code></td>
<td>
<p>An array of approximate p-values for the null hypotheses that each
smooth term is zero. Be warned, these are only approximate.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>array of standard error estimates for all parameter estimates.</p>
</td></tr>
<tr><td><code>r.sq</code></td>
<td>
<p>The adjusted r-squared for the model. Defined as the proportion of variance explained, where original variance and 
residual variance are both estimated using unbiased estimators. This quantity can be negative if your model is worse than a one 
parameter constant model, and can be higher for the smaller of two nested models! Note that proportion null deviance 
explained is probably more appropriate for non-normal errors.</p>
</td></tr>
<tr><td><code>dev.expl</code></td>
<td>
<p>The proportion of the null deviance explained by the model.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>array of estimated degrees of freedom for the model terms.</p>
</td></tr>
<tr><td><code>residual.df</code></td>
<td>
<p>estimated residual degrees of freedom.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of data.</p>
</td></tr>
<tr><td><code>gcv</code></td>
<td>
<p>minimized GCV score for the model, if GCV used.</p>
</td></tr>
<tr><td><code>ubre</code></td>
<td>
<p>minimized UBRE score for the model, if UBRE used.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>estimated (or given) scale parameter.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family used.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original scam formula.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the scale parameter.</p>
</td></tr>
<tr><td><code>pTerms.df</code></td>
<td>
<p>the degrees of freedom associated with each parameteric term
(excluding the constant).</p>
</td></tr>
<tr><td><code>pTerms.chi.sq</code></td>
<td>
<p>a Wald statistic for testing the null hypothesis that the
each parametric term is zero.</p>
</td></tr>
<tr><td><code>pTerms.pv</code></td>
<td>
<p>p-values associated with the tests that each term is
zero. For penalized fits these are approximate. The reference distribution 
is an appropriate chi-squared when the
scale parameter is known, and is based on an F when it is not.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>The estimated covariance matrix of the parameters (or
estimators if <code>freq=TRUE</code>), divided
by scale parameter.</p>
</td></tr>
<tr><td><code>cov.scaled</code></td>
<td>
<p>The estimated covariance matrix of the parameters
(estimators if <code>freq=TRUE</code>).</p>
</td></tr>
<tr><td><code>p.table</code></td>
<td>
<p>significance table for parameters</p>
</td></tr>
<tr><td><code>s.table</code></td>
<td>
<p>significance table for smooths</p>
</td></tr>
<tr><td><code>pTerms.table</code></td>
<td>
<p>significance table for parametric model terms</p>
</td></tr>
<tr><td><code>BFGS termination condition</code></td>
<td>
<p>the value of the maximum component of the scaled GCV/UBRE gradient used as stopping 
condition. This value is printed if 
the termination code of the BFGS optimization process is not &lsquo;1&rsquo; (not full convergence)
(see <code><a href="#topic+bfgs_gcv.ubre">bfgs_gcv.ubre</a></code>for details)</p>
</td></tr>
</table>


<h3>WARNING </h3>

<p> The p-values are approximate.
</p>


<h3>Author(s)</h3>

<p>Natalya Pya &lt;nat.pya@gmail.com&gt; based on <code>mgcv</code> by Simon Wood
</p>


<h3>References</h3>

<p>Wood S.N. (2006) <em>Generalized Additive Models: An Introduction with R</em>. Chapman and Hall/CRC Press.
</p>
<p>Pya, N. and Wood, S.N. (2015) Shape constrained additive models. Statistics and Computing, 25(3), 543-559
</p>
<p>Pya, N. (2010) Additive models with shape constraints. PhD thesis. University of Bath. Department of Mathematical Sciences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scam">scam</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
## simulating data...
require(scam)
n &lt;- 200
set.seed(1)
x1 &lt;- runif(n)*6-3
f1 &lt;- 3*exp(-x1^2) # unconstrained smooth term
x2 &lt;- runif(n)*4-1;
f2 &lt;- exp(4*x2)/(1+exp(4*x2)) # monotone increasing smooth
x3 &lt;- runif(n)*5;
f3 &lt;- -log(x3)/5  # monotone decreasing smooth
f &lt;- f1+f2+f3
y &lt;- f + rnorm(n)*.3
dat &lt;- data.frame(x1=x1,x2=x2,x3=x3,y=y)
## fit model ...
b &lt;- scam(y~s(x1,k=15,bs="cr",m=2)+s(x2,k=30,bs="mpi",m=2)+s(x3,k=30,bs="mpd",m=2),
     data=dat)

summary(b)
plot(b,pages=1,shade=TRUE)  
 
## End(Not run)  
</code></pre>

<hr>
<h2 id='vis.scam'>Visualization of SCAM objects</h2><span id='topic+vis.scam'></span><span id='topic+persp'></span>

<h3>Description</h3>

<p> Produces perspective or contour plot views of <code>scam</code> model
predictions.
The code is a clone of <code>vis.gam</code> of the <code>mgcv</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis.scam(x,view=NULL,cond=list(),n.grid=30,too.far=0,col=NA,
        color="heat",contour.col=NULL,se=-1,type="link",
        plot.type="persp",zlim=NULL,nCol=50,...)
</code></pre>


<h3>Arguments</h3>

<p>The documentation below is the same as in documentation object <code><a href="mgcv.html#topic+vis.gam">vis.gam</a></code>.
</p>
<table>
<tr><td><code id="vis.scam_+3A_x">x</code></td>
<td>
<p>a <code>scam</code> object, produced by <code>scam()</code></p>
</td></tr>
<tr><td><code id="vis.scam_+3A_view">view</code></td>
<td>
<p>an array containing the names of the two main effect terms to be displayed on the 
x and y dimensions of the plot. If omitted the first two suitable terms
will be used.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_cond">cond</code></td>
<td>
<p>a named list of the values to use for the other predictor terms
(not in <code>view</code>). Variables omitted from this list will have the closest observed value to the median 
for continuous variables, or the most commonly occuring level for factors. Parametric matrix variables have 
all the entries in each column set to the observed column entry closest to the column median.
</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_n.grid">n.grid</code></td>
<td>
<p>The number of grid nodes in each direction used for calculating the 
plotted surface.</p>
</td></tr> 
<tr><td><code id="vis.scam_+3A_too.far">too.far</code></td>
<td>
<p> plot grid nodes that are too far from the points defined by the variables given in <code>view</code> 
can be excluded from the plot. <code>too.far</code> determines what is too far. The grid is scaled into the unit 
square along with the <code>view</code> variables and then grid nodes more than <code>too.far</code> from the predictor variables 
are excluded.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_col">col</code></td>
<td>
<p>The colours for the facets of the plot. If this is <code>NA</code> then if <code>se</code>&gt;0 the facets are transparent, 
otherwise the colour scheme specified in <code>color</code> is used. If <code>col</code> is not <code>NA</code> then it is used as the facet 
colour.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_color">color</code></td>
<td>
<p> the colour scheme to use for plots when <code>se</code>&lt;=0. One of <code>"topo"</code>, <code>"heat"</code>, <code>"cm"</code>, 
<code>"terrain"</code>, <code>"gray"</code> or <code>"bw"</code>. Schemes <code>"gray"</code> and
<code>"bw"</code> also modify the colors used when <code>se</code>&gt;0.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_contour.col">contour.col</code></td>
<td>
<p>sets the colour of contours when using <code>plot.type="contour"</code>. Default scheme used if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_se">se</code></td>
<td>
<p>if less than or equal to zero then only the predicted surface is plotted, but if greater than zero, then 3 
surfaces are plotted, one at the predicted values minus <code>se</code> standard errors, one at the predicted values and one at
the predicted values plus <code>se</code> standard errors.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_type">type</code></td>
<td>
<p><code>"link"</code> to plot on linear predictor scale and <code>"response"</code> to plot on the response scale.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_plot.type">plot.type</code></td>
<td>
<p>one of <code>"contour"</code> or <code>"persp"</code>.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_zlim">zlim</code></td>
<td>
<p>a two item array giving the lower and upper limits for the z-axis
scale. <code>NULL</code> to choose automatically.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_ncol">nCol</code></td>
<td>
<p>The number of colors to use in color schemes.</p>
</td></tr>
<tr><td><code id="vis.scam_+3A_...">...</code></td>
<td>
<p>other options to pass on to <code><a href="#topic+persp">persp</a></code>,
<code><a href="graphics.html#topic+image">image</a></code> or <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simply produces a plot.</p>


<h3>Author(s)</h3>

<p>Simon Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+persp">persp</a></code>, <code><a href="mgcv.html#topic+vis.gam">vis.gam</a></code>,  and <code><a href="#topic+scam">scam</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scam)

# Example with factor variable
set.seed(0)
fac&lt;-rep(1:4,20)
x &lt;- runif(80)*5;
y &lt;- fac+log(x)/5+rnorm(80)*0.1
fac &lt;- factor(fac)
b &lt;- scam(y~fac+s(x,bs="mpi"))

vis.scam(b,theta=-35,color="heat") # factor example

# Example with "by" variable

z&lt;-rnorm(80)*0.4   
y&lt;-as.numeric(fac)+log(x)*z+rnorm(80)*0.1
b&lt;-scam(y~fac+s(x,by=z))
g &lt;- gam(y~fac+s(x,by=z))

vis.scam(b,theta=-35,color="terrain",cond=list(z=1)) # by variable example
vis.scam(b,view=c("z","x"),theta= 65) # plot against by variable
## compare with gam(mgcv)...
vis.gam(g,theta=-35,color="terrain",cond=list(z=1)) # by variable example
vis.gam(g,view=c("z","x"),theta= 65) # plot against by variable

## all three smooths are increasing...
set.seed(2)
n &lt;- 400
x &lt;- runif(n, 0, 1)
f1 &lt;- log(x *5)
f2 &lt;-  exp(2 * x) - 4
f3 &lt;-  5* sin(x)
e &lt;- rnorm(n, 0, 2)
fac &lt;- as.factor(sample(1:3,n,replace=TRUE))
fac.1 &lt;- as.numeric(fac==1)
fac.2 &lt;- as.numeric(fac==2)
fac.3 &lt;- as.numeric(fac==3)
y &lt;- f1*fac.1 + f2*fac.2 + f3*fac.3 + e 
dat &lt;- data.frame(y=y,x=x,fac=fac,f1=f1,f2=f2,f3=f3)

b1 &lt;- scam(y ~ s(x,by=fac,bs="mpi"),data=dat,optimizer="efs")
plot(b1,pages=1,scale=0,shade=TRUE)
summary(b1)
vis.scam(b1,theta=-40,color="terrain",cond=list(z=1))

## note that the preceding, b1, fit is the same as....
b2 &lt;- scam(y ~ s(x,by=as.numeric(fac==1),bs="mpi")+s(x,by=as.numeric(fac==2),bs="mpi")+
    s(x,by=as.numeric(fac==3),bs="mpi"),data=dat,optimizer="efs")
summary(b2)

## Note that as in gam() when using factor 'by' variables, centering
## constraints are applied to the smooths, which usually means that the 'by'
## variable should be included as a parametric term, as well. 
## The difference with scam() is that here a 'zero intercept' constraint is 
## applied in place of 'centering' (although scam's fitted smooths are centred for plotting).
## compare with the gam() fits..  
g1 &lt;- gam(y ~ fac+s(x,by=fac),data=dat)
g2 &lt;- gam(y ~ s(x,by=fac),data=dat)
summary(g1)
summary(g2)
plot(g1,pages=1,scale=0,shade=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
