<!DOCTYPE html><html><head><title>Help for package corHMM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {corHMM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ancRECON'><p>Ancestral state reconstruction</p></a></li>
<li><a href='#ConvertPhangornReconstructions'><p>Convert phangorn reconstruction to a vector</p></a></li>
<li><a href='#corDISC'><p>Correlated evolution binary traits</p></a></li>
<li><a href='#corHMM'><p>Hidden Rates Model</p></a></li>
<li><a href='#examples'><p>Example datasets</p></a></li>
<li><a href='#fitCorrelationTest'><p>Test for correlation</p></a></li>
<li><a href='#getFullMat'><p>Combines several rate class index matrices</p></a></li>
<li><a href='#getStateMat4Dat'><p>Produce an index matrix and legend from a dataset</p></a></li>
<li><a href='#makeSimmap'><p>Simulate a character history</p></a></li>
<li><a href='#plotMKmodel'><p>Plot a Markov model</p></a></li>
<li><a href='#plotRECON'><p>Plot ancestral state reconstructions</p></a></li>
<li><a href='#rayDISC'><p>Evolution of categorical traits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Hidden Markov Models of Character Evolution</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeremy Beaulieu &lt;jmbeauli@uark.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>ape, nloptr, GenSA</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>expm, numDeriv, corpcor, MASS, nnet, phangorn, parallel,
viridis, Rmpfr, igraph, phytools</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits hidden Markov models of discrete character evolution which allow different transition rate classes on different portions of a phylogeny. Beaulieu et al (2013) &lt;<a href="https://doi.org/10.1093%2Fsysbio%2Fsyt034">doi:10.1093/sysbio/syt034</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-10 21:16:55 UTC; jeremybeaulieu</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy Beaulieu [aut, cre],
  Brian O'Meara [aut],
  Jeffrey Oliver [aut],
  James Boyko [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-13 22:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='ancRECON'>Ancestral state reconstruction</h2><span id='topic+ancRECON'></span>

<h3>Description</h3>

<p>Infers ancestral states based on a set of model parameters</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancRECON(phy,data, p, method=c("joint", "marginal", "scaled"),
rate.cat, ntraits=NULL, rate.mat=NULL,
model="ARD", root.p=NULL, get.likelihood=FALSE, get.tip.states = FALSE, collapse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancRECON_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_data">data</code></td>
<td>
<p>a data matrix containing species information (see Details).</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_p">p</code></td>
<td>
<p>a vector of transition rates to be used to estimate ancestral states.</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_method">method</code></td>
<td>
<p>method used to calculate ancestral states at internal nodes. Can be one of: &quot;joint&quot;, &quot;marginal&quot;, or &quot;scaled&quot; (see Details).</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_rate.cat">rate.cat</code></td>
<td>
<p>specifies the number of rate categories in the HRM.</p>
</td></tr> 
<tr><td><code id="ancRECON_+3A_ntraits">ntraits</code></td>
<td>
<p>currently, this is automaticall detected and can always be set to NULL.</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_rate.mat">rate.mat</code></td>
<td>
<p>a user-supplied rate matrix index of parameters to be optimized.</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_model">model</code></td>
<td>
<p>specifies the underlying model if a rate.mat is not provided (&quot;ER&quot;, SYM&quot;, or &quot;ARD&quot;).</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_root.p">root.p</code></td>
<td>
<p>a vector used to fix the probabilities at the root, but &ldquo;yang&rdquo; and &ldquo;maddfitz&rdquo; can also be supplied to use the method of Yang (2006) and FitzJohn et al (2009) respectively (see details).</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_get.likelihood">get.likelihood</code></td>
<td>
<p>a logical indicating whether to obtain the likelihood of the rates and states. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_get.tip.states">get.tip.states</code></td>
<td>
<p>a logical indicating whether just tip reconstructions should be output. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ancRECON_+3A_collapse">collapse</code></td>
<td>
<p>a boolean indicating whether to collapse multiple character combinations into only the observed states. For example, if true a two character dataset contained (0,0), (1,0), and (1,1), this would be collapsed into 1,2,3. However, if set to false it would 1,2,4. In combination with a custom rate matrix this allows for the estimation of transitions between the unobserved character combination. The default is <code>TRUE</code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>This is a stand alone function for computing the marginal, joint, or scaled likelihoods of internal nodes for a given set of transition rates. Like all other functions contained in corHMM, the tree does not have to be bifurcating in order for analyses to be carried out. IMPORTANT: If the corDISC, corHMM, and rayDISC functions are used they automatically provide a tree with the likeliest states as internal node labels. This function is intended for circumstances where the user would like to reconstruct states based on rates estimated elsewhere (e.g. BayesTraits, Mesquite, <code>ape</code>).
</p>
<p>The algorithm based on Pupko et al. (2000, 2002) is used to calculate the <code>joint</code> estimates of ancestral states. The <code>marginal</code> method was originally implemented based on a description of an algorithm by Yang (2006). The basic idea is that the tree is rerooted on each internal node, with the marginal likelihood being the probabilities of observing the tips states given that the focal node is the root. However, this takes a ton of time as the number of nodes increase. But, importantly, this does not work easily when the model contains asymmetric rates. Here, we use the same dynamic programming algorithm as Mesquite (Maddison and Maddison, 2011), which is time linear with the number of species and calculates the marginal probability at a node using an additional up and down pass of the tree.  If <code>scaled</code>, the function uses the same algorithm from ace(). Note that the <code>scaled</code> method of ace() is simply the conditional likelihoods of observing everything at or above the focal node and these should NOT be used for ancestral state estimation.
</p>
<p>The user can fix the root state probabilities by supplying a vector to <code>root.p</code>. For example, in the two trait case, if the hypothesis is that the root is 00, then the root vector would be <code>root.p=c(1,0,0,0)</code> for state combinations 00, 01, 10, and 11, respectively. If analyzing a binary or multistate character, the order of root.p is the same order as the traits &ndash; e.g., for states 1, 2, 3, a <code>root.p=c(0,1,0)</code> would fix the root to be in state 2. If the user supplies the flag <code>root.p</code>=&ldquo;yang&rdquo;, then the estimated transition rates are used to set the weights at the root (see pg. 124 Yang 2006), whereas specifying <code>root.p</code>=&ldquo;maddfitz&rdquo; employs the same procedure described by Maddison et al. (2007) and FitzJohn et al. (2009). Note that the default <code>root.p=NULL</code> assumes equal weighting among all possible states. 
</p>
<p>Setting get.likelihood=TRUE will provide the user the joint likelihood of the rates and states.
</p>


<h3>Value</h3>

<table>
<tr><td><code>$lik.tip.states</code></td>
<td>
<p>A matrix of the reconstructed tip values. If the number of rate.cats is greater than 2 then the probability that each observed state is in a particular hidden state is given.</p>
</td></tr>
<tr><td><code>$lik.anc.states</code></td>
<td>
<p>For <code>joint</code>, a vector of likeliest states at internal nodes and tips. For either <code>marginal</code> or <code>$scaled</code>, a matrix of the probabilities of each state for each internal node are returned.</p>
</td></tr>
<tr><td><code>$info.anc.states</code></td>
<td>
<p>A vector containing the amount of information (in bits) that the tip states and model gives to each node. See Boyko and Beaulieu (2021).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu and Jeffrey C. Oliver</p>


<h3>References</h3>

<p>FitzJohn, R.G., W.P. Maddison, and S.P. Otto. 2009. Estimating trait-dependent speciation and extinction rates from incompletely resolved phylogenies. Systematic Biology 58:595-611.
</p>
<p>Maddison, W.P. and D.R. Maddison. 2011. Mesquite: a modular system for evolutionary analysis. Version 2.75 http://mesquiteproject.org
</p>
<p>Pupko, T., I. Pe'er, R. Shamir, and D. Graur. 2000. A fast algorithm for joint reconstruction of ancestral amino-acid sequences. Molecular Biology and Evolution 17:890-896.
</p>
<p>Pupko, T., I. Pe'er, D. Graur, M. Hasegawa, and N Friedman N. 2002. A branch-and-bound algorithm for the inference of ancestral amino-acid sequences when the replacement rate varies among sites: application to the evolution of five gene families. Bioinformatics 18:1116-1123.
</p>
<p>Yang, Z. 2006. Computational Molecular Evolution. London:Oxford.
</p>
<p>Boyko, J. D., and J. M. Beaulieu. 2021. Generalized hidden Markov models for phylogenetic comparative datasets. Methods in Ecology and Evolution 12:468-478.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates)
phy &lt;- multi2di(primates[[1]])
data &lt;- primates[[2]]
MK_3state &lt;- corHMM(phy = phy, data = data, rate.cat = 1)

# # one way to get the parameters from your corHMM object in the correct order
p &lt;- sapply(1:max(MK_3state$index.mat, na.rm = TRUE), function(x) 
	na.omit(c(MK_3state$solution))[na.omit(c(MK_3state$index.mat) == x)][1])

# using custom params
states_1 &lt;- ancRECON(phy = phy, data = MK_3state$data, p = p, method = "marginal", 
	rate.cat &lt;- MK_3state$rate.cat, ntraits = NULL, rate.mat = MK_3state$index.mat, 
	root.p = MK_3state$root.p)


</code></pre>

<hr>
<h2 id='ConvertPhangornReconstructions'>Convert phangorn reconstruction to a vector</h2><span id='topic+ConvertPhangornReconstructions'></span>

<h3>Description</h3>

<p>Converts a character reconstruction from phangorn into a vector of tip and node states. Nodes where there are equal weights among states, ties are broken at random.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvertPhangornReconstructions(x, site = 1, best = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConvertPhangornReconstructions_+3A_x">x</code></td>
<td>
<p>The phyDat object that contains a character reconstruction from phangorn</p>
</td></tr>
<tr><td><code id="ConvertPhangornReconstructions_+3A_site">site</code></td>
<td>
<p>The character number to convert into a vector</p>
</td></tr>
<tr><td><code id="ConvertPhangornReconstructions_+3A_best">best</code></td>
<td>
<p>A logical indicating whether the state that maximizes some function (likelihood, parsimony, etc.) is to be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a vector that contains the best tips and node state from a phangorn reconstruction.
</p>

<hr>
<h2 id='corDISC'>Correlated evolution binary traits</h2><span id='topic+corDISC'></span>

<h3>Description</h3>

<p>Fits a model of correlated evolution between two or three binary traits</p>


<h3>Usage</h3>

<pre><code class='language-R'>corDISC(phy,data, ntraits=2, rate.mat=NULL, model=c("ER","SYM","ARD"), 
node.states=c("joint", "marginal", "scaled", "none"), lewis.asc.bias=FALSE, p=NULL, 
root.p=NULL, ip=NULL, lb=0, ub=100, diagn=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corDISC_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="corDISC_+3A_data">data</code></td>
<td>
<p>a data matrix containing species information (see Details).</p>
</td></tr>
<tr><td><code id="corDISC_+3A_ntraits">ntraits</code></td>
<td>
<p>specifies the number of traits to be included in the analysis.</p>
</td></tr>
<tr><td><code id="corDISC_+3A_rate.mat">rate.mat</code></td>
<td>
<p>a user-supplied rate matrix index of parameters to be optimized.</p>
</td></tr>
<tr><td><code id="corDISC_+3A_model">model</code></td>
<td>
<p>specifies the underlying model.</p>
</td></tr> 
<tr><td><code id="corDISC_+3A_node.states">node.states</code></td>
<td>
<p>method used to calculate ancestral states at internal nodes (see Details).</p>
</td></tr>
<tr><td><code id="corDISC_+3A_lewis.asc.bias">lewis.asc.bias</code></td>
<td>
<p>a logical indicating whether the ascertainment bias correction of Lewis et al. 2001 should be used. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="corDISC_+3A_p">p</code></td>
<td>
<p>a vector of transition rates. Allows the user to calculate the likelihood given a specified set of parameter values to specified as fixed and calculate the likelihood.</p>
</td></tr>
<tr><td><code id="corDISC_+3A_root.p">root.p</code></td>
<td>
<p>a vector used to fix the probabilities at the root, but &ldquo;yang&rdquo; and &ldquo;maddfitz&rdquo; can also be supplied to use the method of Yang (2006) and FitzJohn et al (2009) respectively (see details).</p>
</td></tr>
<tr><td><code id="corDISC_+3A_ip">ip</code></td>
<td>
<p>initial values used for the likelihood search. Can be a single value or a vector of unique values for each parameter. The default is <code>ip=1</code>.</p>
</td></tr>
<tr><td><code id="corDISC_+3A_lb">lb</code></td>
<td>
<p>lower bound for the likelihood search. The default is <code>lb=0</code>.</p>
</td></tr>
<tr><td><code id="corDISC_+3A_ub">ub</code></td>
<td>
<p>upper bound for the likelihood search. The default is <code>ub=100</code>.</p>
</td></tr>
<tr><td><code id="corDISC_+3A_diagn">diagn</code></td>
<td>
<p>logical indicating whether diagnostic tests should be performed. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>__THIS FUNCTION IS NO LONGER NECESSARY AS IT IS NOW ENTIRELY SUBSUMED WITHIN__ <code>corHMM</code> (see _Generalized corHMM_ vignette). But we still provide it for those that are more comfortable using it than exploring the new <code>corHMM</code> function. As before, <code>corDISC</code> takes a tree and a trait file and estimates transition rates and ancestral states for two or three binary characters (see Pagel 1994). Note, however, that rayDISC can be used to evaluate the same models as in corDISC, with the major difference being that, with rayDISC, the rate matrix would have to be manipulated using <code>rate.mat.maker</code> in order to remove parameters associated with dual transitions. With corDISC, the input phylogeny need not be bifurcating as the algorithm is implemented to handle multifucations. Polytomies are allowed by generalizing Felsenstein's (1981) pruning algorithm to be the product of the probability of observing the tip states of n descendant nodes, rather than two, as in the completely bifurcating case. For the trait file, the first column of the trait file must contain the species labels to match to the tree, with the second column onwards corresponding to the binary traits of interest. 
</p>
<p>The user can fix the root state probabilities by supplying a vector to <code>root.p</code>. For example, in the two trait case, if the hypothesis is that the root is 00, then the root vector would be <code>root.p=c(1,0,0,0)</code> for state combinations 00, 01, 10, and 11, respectively. If the user supplies the flag <code>root.p</code>=&ldquo;yang&rdquo;, then the estimated transition rates are used to set the weights at the root (see pg. 124 Yang 2006), whereas specifying <code>root.p</code>=&ldquo;maddfitz&rdquo; employs the same procedure described by Maddison et al. (2007) and FitzJohn et al. (2009). Note that the default <code>root.p=NULL</code> assumes equal weighting among all possible states.
</p>
<p>We also note that scoring information that is missing for a species can be incorporated in the analysis by including an NA for that particular trait. corDISC will then set the trait vector so that the tip vector will reflect the probabilities that are compatible with our observations. For example, if the scoring for trait 1 is missing, but trait 2 is scored as 0, then the tip vector would be (1,0,1,0), for state combinations 00, 01, 10, and 11 respectively, given our observation that trait 2 is scored 0 (for a good discussion see Felsenstein 2004, pg. 255).
</p>


<h3>Value</h3>

<p><code>corDISC</code> returns an object of class <code>corDISC</code>. This is a list with elements:
</p>
<table>
<tr><td><code>$loglik</code></td>
<td>
<p>the maximum negative log-likelihood.</p>
</td></tr>
<tr><td><code>$AIC</code></td>
<td>
<p>Akaike information criterion.</p>
</td></tr>
<tr><td><code>$AICc</code></td>
<td>
<p>Akaike information criterion corrected for sample size.</p>
</td></tr>
<tr><td><code>$ntraits</code></td>
<td>
<p>The number of traits specified.</p>
</td></tr>
<tr><td><code>$solution</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of the transition rates.</p>
</td></tr>
<tr><td><code>$solution.se</code></td>
<td>
<p>a matrix containing the approximate standard errors of the transition rates. The standard error is calculated as the square root of the diagonal of the inverse of the Hessian matrix.</p>
</td></tr>
<tr><td><code>$index.mat</code></td>
<td>
<p>The indices of the parameters being estimated are returned. The numbers correspond to the row in the <code>eigvect</code> and can useful for identifying the parameters that are causing the objective function to be at a saddlepoint.</p>
</td></tr>
<tr><td><code>$lewis.asc.bias</code></td>
<td>
<p>The setting describing whether or not the Lewis ascertainment bias correction was used.</p>
</td></tr>
<tr><td><code>$opts</code></td>
<td>
<p>Internal settings of the likelihood search</p>
</td></tr>
<tr><td><code>$data</code></td>
<td>
<p>User-supplied dataset.</p>
</td></tr>
<tr><td><code>$phy</code></td>
<td>
<p>User-supplied tree.</p>
</td></tr>
<tr><td><code>$states</code></td>
<td>
<p>The likeliest states at each internal node.</p>
</td></tr>
<tr><td><code>$tip.states</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>$iterations</code></td>
<td>
<p>The number of iterations used by the optimization routine.</p>
</td></tr>
<tr><td><code>$eigval</code></td>
<td>
<p>The eigenvalues from the decomposition of the Hessian of the likelihood function. If any <code>eigval&lt;0</code> then one or more parameters were not optimized during the likelihood search</p>
</td></tr>
<tr><td><code>$eigvect</code></td>
<td>
<p>The eigenvectors from the decomposition of the Hessian of the likelihood function is returned</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu</p>


<h3>References</h3>

<p>Beaulieu J.M., and M.J. Donoghue 2013. Fruit evolution and diversification in campanulid angiosperms. Evolution, 67:3132-3144.
</p>
<p>Felsenstein, J. 1981. A likelihood approach to character weighting and what it tells us about parsimony and compatibility. Biological Journal of the Linnean Society 16: 183-196.
</p>
<p>Felsenstein J. 2004. Inferring phylogenies. Sunderland MA: Sinauer Associates.
</p>
<p>FitzJohn, R.G., W.P. Maddison, and S.P. Otto. 2009. Estimating trait-dependent speciation and extinction rates from incompletely resolved phylogenies. Systematic Biology 58:595-611.
</p>
<p>Lewis, P.O. 2001. A likelihood approach to estimating phylogeny from discrete morphological character data. Systematic Biology 50:913-925.
</p>
<p>Maddison, W.P., P.E. Midford, and S.P. Otto. 2007. Estimating a binary characters effect on speciation and extinction. Systematic Biology 56:701-710.
</p>
<p>Pagel, M. 1994. Detecting correlated evolution on phylogenies: a general method for the comparative analysis of discrete characters. Proceedings of the Royal Society, B. 255:37-45.
</p>

<hr>
<h2 id='corHMM'>Hidden Rates Model</h2><span id='topic+corHMM'></span>

<h3>Description</h3>

<p>Estimates hidden rates underlying the evolution of a binary character</p>


<h3>Usage</h3>

<pre><code class='language-R'>corHMM(phy, data, rate.cat, rate.mat=NULL, model = "ARD", node.states = "marginal", 
fixed.nodes=FALSE, p=NULL, root.p="yang", ip=NULL, nstarts=0, n.cores=1, 
get.tip.states = FALSE, lewis.asc.bias = FALSE, collapse = TRUE, lower.bound = 1e-9, 
upper.bound = 100, opts=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corHMM_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_data">data</code></td>
<td>
<p>a data.frame containing species information. The first column must be species names matching the phylogeny. Additional columns contain discrete character data.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_rate.cat">rate.cat</code></td>
<td>
<p>specifies the number of rate categories (see Details).</p>
</td></tr>
<tr><td><code id="corHMM_+3A_rate.mat">rate.mat</code></td>
<td>
<p>a user-supplied index of parameters to be optimized.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_model">model</code></td>
<td>
<p>One of &quot;ARD&quot;, &quot;SYM&quot;, or &quot;ER&quot;. ARD: all rates differ. SYM: rates between any two states do not differ. ER: all rates are equal.</p>
</td></tr> 
<tr><td><code id="corHMM_+3A_node.states">node.states</code></td>
<td>
<p>method used to calculate ancestral states at internal nodes (see Details).</p>
</td></tr>
<tr><td><code id="corHMM_+3A_fixed.nodes">fixed.nodes</code></td>
<td>
<p>specifies that states for nodes in the phylogeny are assumed fixed. These are supplied as node labels in the &ldquo;phylo&rdquo; object.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_p">p</code></td>
<td>
<p>a vector of transition rates. Allows the user to calculate the likelihood given a specified set of parameter values to specified as fixed and calculate the likelihood.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_root.p">root.p</code></td>
<td>
<p>a vector used to fix the probabilities at the root, but &ldquo;yang&rdquo; and &ldquo;maddfitz&rdquo; can also be supplied to use the method of Yang (2006) and FitzJohn et al (2009) respectively (see details).</p>
</td></tr>
<tr><td><code id="corHMM_+3A_ip">ip</code></td>
<td>
<p>initial values used for the likelihood search. Can be a single value or a vector of unique values for each parameter. The default is <code>ip=1</code>.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_nstarts">nstarts</code></td>
<td>
<p>the number of random restarts to be performed. The default is <code>nstarts=0</code>.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_n.cores">n.cores</code></td>
<td>
<p>the number of processor cores to spread out the random restarts.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_get.tip.states">get.tip.states</code></td>
<td>
<p>a boolean indicating whether tip reconstructions should be output. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_lewis.asc.bias">lewis.asc.bias</code></td>
<td>
<p>a boolean indicating whether to correct for observing a dataset that is not univariate. The default is <code>FALSE</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="corHMM_+3A_collapse">collapse</code></td>
<td>
<p>a boolean indicating whether to collapse multiple character combinations into only the observed states. For example, if true a two character dataset contained (0,0), (1,0), and (1,1), this would be collapsed into 1,2,3. However, if set to false it would 1,2,4. In combination with a custom rate matrix this allows for the estimation of transitions between the unobserved character combination. The default is <code>TRUE</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="corHMM_+3A_lower.bound">lower.bound</code></td>
<td>
<p>lower bound for the likelihood search. The default is <code>lower.bound=1e-9</code>.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_upper.bound">upper.bound</code></td>
<td>
<p>upper bound for the likelihood search. The default is <code>upper.bound=100</code>.</p>
</td></tr>
<tr><td><code id="corHMM_+3A_opts">opts</code></td>
<td>
<p>options to pass to nloptr. default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a tree and a trait file and estimates transition rates and ancestral states for any number of discrete characters using a Markov model with or without &quot;hidden&quot; states. Users are advised to read the _Generalized corHMM_ vignette for details on how to make full use of <code>corHMM</code>'s new functionality. In general, these models describe evolution as discrete transitions between observed states. If rate.class &gt; 1, then the model is a hidden Markov model (HMM; also known as a hidden rates model (HRM)). The HRM is a generalization of the covarion model that allows different rate classes to be treated as &quot;hidden&quot; states. Essentially a hidden Markov model allows for multiple processes to describe the evolution of your observed character. This could be another (hidden) state or a large group of them. Regardless of the reason, an HMM is saying that not all observed characters are expected to act the same way. 
</p>
<p>The first column of the input data must be species names (as in the previous version), but there can be any number of data columns. If your dataset does have 2 or more columns of trait information, each column is taken to describe a separate character. The separation of character and state is an important one because corHMM will automatically remove dual transitions from your model. For example, say you had 3 characters each with 2 states (0 or 1), but only three of these combinations were ever observed 0_0_1, 0_1_0, or 1_0_0. With dual transitions disallowed, it is impossible to move between these combinations because it would mean simultaneously losing and gaining a state (0_0_1 -&gt; 0_0_0 -&gt; 0_1_0 in one step.) One way around this is to provide a custom rate matrix to corHMM where transitions are allowed between these states. However, this is also a case where it would seem appropriate to code the data as a single character with 3 states.
</p>
<p>Ambiguities (polymorphic taxa or taxa missing data) are assigned likelihoods following Felsenstein (2004, p. 255). Taxa with missing data are coded &ldquo;?&rdquo; with all states observed at a tip. Polymorphic taxa are coded with states separated by an &ldquo;&amp;&rdquo;. For example, if a trait has four states and taxonA is observed to be in state 1 and 3, the character would be coded as &ldquo;1&amp;3&rdquo;. corHMM then uses this information to assign a likelihood of 1.0 to both states. Missing data are treated as ambiguous for all states, thus all states for taxa missing data are assigned a likelihood of 1.0. For example, for a four-state character (i.e. DNA), a taxon missing data will have likelihoods of all four states equal to 1.0 [e.g. L(A)=1.0, L(C)=1.0, L(G)=1.0, L(T)=1.0].
</p>
<p>The likelihood function is maximized using the bounded subplex optimization routine implemented in the R package <code>nloptr</code>, which provides a common interface to NLopt, an open-source library for nonlinear optimization. In the former case, however, it is recommended that <code>nstarts</code> is set to a large value (e.g. 100) to ensure that the maximum likelihood solution is found. Users can set <code>n.cores</code> to parse the random restarts onto multiple processors.
</p>
<p>The user can fix the root state probabilities by supplying a vector to <code>root.p</code>. For example, if the hypothesis is that the root is 0_S in a model with two hidden rates, then the root vector would be <code>root.p=c(1,0,0,0)</code> for state combinations 0_S, 1_S, 0_F, and 1_F, respectively. If the user supplies the flag <code>root.p</code>=&ldquo;NULL&rdquo;, then there is equal weighting among all possible states in the  model. If the user supplies the flag <code>root.p</code>=&ldquo;yang&rdquo;, then the estimated transition rates are used to set the weights at the root (see pg. 124 Yang 2006), whereas specifying <code>root.p</code>=&ldquo;maddfitz&rdquo; employs the same procedure described by Maddison et al. (2007) and FitzJohn et al. (2009). Note that the default <code>root.p="yang"</code>.
</p>
<p>Ancestral states can be estimated using marginal, joint, scaled, or none approaches. Marginal gives the likelihood of state at each node, integrating over the states at other nodes. Joint gives the optimal state at each node for the entire tree at once (it can only return the most likely state, i.e. it is not a probability like the marginal reconstruction). Scaled is included for compatibility with ape's ace() function. None suppresses calculation of ancestral states, which can dramatically speed up calculations if you're comparing models but make plotting difficult.
</p>


<h3>Value</h3>

<p><code>corHMM</code> returns an object of class <code>corHMM</code>. This is a list with elements:
</p>
<table>
<tr><td><code>$loglik</code></td>
<td>
<p>the maximum negative log-likelihood.</p>
</td></tr>
<tr><td><code>$AIC</code></td>
<td>
<p>Akaike information criterion.</p>
</td></tr>
<tr><td><code>$AICc</code></td>
<td>
<p>Akaike information criterion corrected for sample size.</p>
</td></tr>
<tr><td><code>$rate.cat</code></td>
<td>
<p>The number of rate categories specified.</p>
</td></tr>
<tr><td><code>$solution</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of the transition rates. Note that the rate classes are ordered from slowest (R1) to fastest (Rn) with respect to state 0.</p>
</td></tr>
<tr><td><code>$index.mat</code></td>
<td>
<p>The indices of the parameters being estimated are returned. This also is a way to allow the estimation of transition rates for parameters not oberved in the dataset. Say you have 2 traits X and Y, where the combinations 00, 01, and 11 are observed (10 is not). A 4 by 4 index matrix could be used to force 10 into the model.</p>
</td></tr>
<tr><td><code>$data</code></td>
<td>
<p>User-supplied dataset.</p>
</td></tr>
<tr><td><code>$data.legend</code></td>
<td>
<p>User-supplied dataset with an extra column of trait values corresponding to how corHMM calls the user data.</p>
</td></tr>
<tr><td><code>$phy</code></td>
<td>
<p>User-supplied tree.</p>
</td></tr>
<tr><td><code>$states</code></td>
<td>
<p>The likeliest states at each internal node. The state and rates reconstructed at internal nodes are in the order of the column headings of the rates matrix.</p>
</td></tr>
<tr><td><code>$tip.states</code></td>
<td>
<p>The likeliest state at each tip. The state and rates reconstructed at the tips are in the order of the column headings of the rates matrix.</p>
</td></tr>
<tr><td><code>$states.info</code></td>
<td>
<p>a vector containing the amount of information (in bits) that the tip states and model gives to each node.</p>
</td></tr>
<tr><td><code>$iterations</code></td>
<td>
<p>The number of iterations used by the optimization routine.</p>
</td></tr>
<tr><td><code>$root.p</code></td>
<td>
<p>The root prior used in model estimation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeremy M. Beaulieu and James D. Boyko</p>


<h3>References</h3>

<p>Beaulieu J.M., B.C. O'Meara, and M.J. Donoghue. 2013. Identifying hidden rate changes in the evolution of a binary morphological character: the evolution of plant habit in campanulid angiosperms. Systematic Biology 62:725-737.
</p>
<p>Boyko, J. D., and J. M. Beaulieu. 2021. Generalized hidden Markov models for phylogenetic comparative datasets. Methods in Ecology and Evolution 12:468-478.
</p>
<p>Felsenstein, J. 1981. A likelihood approach to character weighting and what it tells us about parsimony and compatibility. Biological Journal of the Linnean Society 16: 183-196.
</p>
<p>Felsenstein J. 2004. Inferring phylogenies. Sunderland MA: Sinauer Associates.
</p>
<p>FitzJohn, R.G., W.P. Maddison, and S.P. Otto. 2009. Estimating trait-dependent speciation and extinction rates from incompletely resolved phylogenies. Systematic Biology 58:595-611.
</p>
<p>Maddison, W.P., P.E. Midford, and S.P. Otto. 2007. Estimating a binary characters effect on speciation and extinction. Systematic Biology 56:701-710.
</p>
<p>Pagel, M. 1994. Detecting correlated evolution on phylogenies: a gneeral method for the comparative analysis of discrete characters. Proc. R. Soc. Lond. B 255:37-45.
</p>
<p>Yang, Z. 2006. Computational Molecular Evolution. Oxford Press:London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates)
phy &lt;- multi2di(primates[[1]])
data &lt;- primates[[2]]
MK_3state &lt;- corHMM(phy = phy, data = data, rate.cat = 1)
MK_3state

</code></pre>

<hr>
<h2 id='examples'>Example datasets</h2><span id='topic+primates'></span><span id='topic+primates.paint'></span><span id='topic+rayDISC.example'></span>

<h3>Description</h3>

<p>Example files for running various functions in <code>corHMM</code>. The &ldquo;primates&rdquo; dataset comes from the example files provided by BayesTraits, though here we only include a single tree with branch lengths scaled to time. The &ldquo;primates.paint&rdquo; dataset is the same, but with the tree painted according to hypothetical regimes. Finally, the &ldquo;rayDISC.example&rdquo; dataset provides an example on how polymorphic data can be coded for <code>rayDISC</code>.  
</p>


<h3>Format</h3>

<p>a list object that contains a tree of class &ldquo;phylo&rdquo; and a dataframe that contains the trait data</p>


<h3>References</h3>

<p>Pagel, M., and A. Meade. 2006. Bayesian analysis of correlated evolution of discrete characters by reversible-jump Markov chain Monte Carlo. American Naturalist 167:808-825.
</p>

<hr>
<h2 id='fitCorrelationTest'>Test for correlation</h2><span id='topic+fitCorrelationTest'></span>

<h3>Description</h3>

<p>Automatically fits a set of independent and dependent models to test for correlation between characters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fitCorrelationTest(phy, data, simplified_models=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitCorrelationTest_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="fitCorrelationTest_+3A_data">data</code></td>
<td>
<p>a data.frame containing species information. The first column must be species names matching the phylogeny. Additional columns contain discrete character data.</p>
</td></tr>
<tr><td><code id="fitCorrelationTest_+3A_simplified_models">simplified_models</code></td>
<td>
<p>A boolean which indicates whether to include simplified independent and dependent models (currently only works for two binary-state characters; see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically fit a set of multi-rate independent and dependent models (with default corHMM options) to drastically reduce false support for correlation. Currently, the simplified models are only available for two binary-state characters, but it is straightforward for users to use the tools available in corHMM to create model structures specific to their questions when the datasets are more complex. 
</p>
<p>The correlation between two characters is often interpreted as evidence that there exists a significant and biologically important relationship between them. However, Maddison and FitzJohn (2015) recently pointed out that in certain situations find evidence of correlated evolution between two categorical characters is often spurious, particularly, when the dependent relationship stems from a single replicate deep in time. In Boyko and Beaulieu (in prep) we showed that there is, in fact, a statistical solution to the problem posed by Maddison and FitzJohn (2015) naturally embedded within the expanded model space afforded by the hidden Markov model (HMM) framework. 
</p>
<p>The problem of single unreplicated evolutionary events manifests itself as rate heterogeneity within our models and that this is the source of the false correlation. Therefore, we argue that this problem is better understood as model misspecification rather than a failure of comparative methods to account for phylogenetic pseudoreplication. We utilize HMMs to develop a multi-rate independent model which, when implemented, drastically reduces support for correlation.
</p>


<h3>Value</h3>

<p><code>fitCorrelationTest</code> returns an object of class <code>corhmm_list</code>. This is a list with elements:
</p>
<table>
<tr><td><code>$independent_model_fit</code></td>
<td>
<p>A corHMM object of the standard independent model ala Pagel (1994).</p>
</td></tr>
<tr><td><code>$correlated_model_fit</code></td>
<td>
<p>A corHMM object of the standard dependent model ala Pagel (1994).</p>
</td></tr>
<tr><td><code>$hidden_Markov_independent_model_fit</code></td>
<td>
<p>A corHMM object of the hidden Markov independent model which allows for rate heterogeneity independent of the focal character.</p>
</td></tr>
<tr><td><code>$hidden_Markov_correlated_model_fit.cat</code></td>
<td>
<p>A corHMM object of the hidden Markov dependent model which allows for rate heterogeneity independent of the focal character as well as correlation between characters.</p>
</td></tr>
<tr><td><code>$simplified_*</code></td>
<td>
<p>If simplified was set to TRUE, then the function will also return simplified versions of the above models. These models have fewer parameters than the above models while still being either dependent or independent models.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James D. Boyko</p>


<h3>References</h3>

<p>Maddison W.P., FitzJohn R.G. 2015. The Unsolved Challenge to Phylogenetic Correlation Tests for Categorical Characters. Syst Biol. 64:127-136.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates)
phy &lt;- multi2di(primates[[1]])
data &lt;- primates[[2]]
# not run because of long run times
#corr_test_fits &lt;- fitCorrelationTest(phy = phy, data = data, simplified_models = TRUE)
#corr_test_fits

</code></pre>

<hr>
<h2 id='getFullMat'>Combines several rate class index matrices</h2><span id='topic+getFullMat'></span><span id='topic+getRateCatMat'></span><span id='topic+equateStateMatPars'></span><span id='topic+dropStateMatPars'></span>

<h3>Description</h3>

<p>Combines several index matrices which describe transitions between observed states into output a single index matrix for use in corHMM</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFullMat(StateMats, RateClassMat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFullMat_+3A_statemats">StateMats</code></td>
<td>
<p>A list of index matrices describing transitions between observed states. Each unique number from 1 to n, will be independently estimated. Values of 0 are not estimated. Matrix entries of the same value are estimated to be the same rate.</p>
</td></tr>
<tr><td><code id="getFullMat_+3A_rateclassmat">RateClassMat</code></td>
<td>
<p>An optional index matrix which describes how StateMats are related to one another. This will be a matrix of size: length(StateMats) by length(StateMats). By default, all transitions between StateMats are allowed and independently estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the final step in creating a custom hidden Markov model. It takes a list of index matrices (StateMats) which describe different ways that the observed states are related to one another and creates a single matrix to describe the model. The matrices are combined following Eq. 2 of Tarasov (2019). getFullMat is part of several functions which help the user efficiently create custom index matrices. Often, it will be more practical to begin constructing a custom model with <code>getRateMat4Dat</code>. 
</p>
<p>getStateMat will generate an index matrix of size n by n in which all transitions between the n states are allowed and independently estimated. That index matrix can then be manipulated by dropStateMatPars and equateStateMatPars. dropStateMatPars will drop specific rates from an index matrix. dropStateMatPars requires an index matrix and a vector of which rates should be dropped. equateStateMatPars will equates rates within an index matrix. equateStateMatPars requires an index matrix and a list of vectors each element of which should correspond to two or more rates to be equated.
</p>


<h3>Value</h3>

<p>Returns an index matrix.
</p>


<h3>Author(s)</h3>

<p>James D. Boyko</p>


<h3>References</h3>

<p>Boyko, J. D., and J. M. Beaulieu. 2021. Generalized hidden Markov models for phylogenetic comparative datasets. Methods in Ecology and Evolution 12:468-478.
</p>
<p>Tarasov, S. 2019. Integration of Anatomy Ontologies and Evo-Devo Using Structured Markov Models Suggests a New Framework for Modeling Discrete Phenotypic Traits. Systematic Biology, 68(5) 698-716. doi:10.1093/sysbio/syz005
</p>


<h3>See Also</h3>

<p><code>getRateMat4Dat</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates)
phy &lt;- primates[[1]]
phy &lt;- multi2di(phy)
data &lt;- primates[[2]]
# create a legend and rate mat from a multi-character dataset.
LegendAndRateMat &lt;- getStateMat4Dat(data)
rate.mat &lt;- LegendAndRateMat$rate.mat
legend &lt;- LegendAndRateMat$legend

# To create a hidden markov model first define your rate classes (state-dependent processes)
# R1 will be a manually created SYM model
R1 &lt;- equateStateMatPars(rate.mat, c(1:6))
# R2 will only allow transitions between 1 and 2
R2 &lt;- dropStateMatPars(rate.mat, c(3,4))
# R1 and R2 will transtion at equal rates (i.e. the parameter process will be ER)
P &lt;- getRateCatMat(2)
P &lt;- equateStateMatPars(P, c(1,2))
# combine our state-dependnet processes and parameter process
HMM &lt;- getFullMat(list(R1, R2), P)

# This can now be used in a corHMM model
CustomModel &lt;- corHMM(phy = phy, data = data, rate.cat = 2, rate.mat = HMM, node.states = "none")

</code></pre>

<hr>
<h2 id='getStateMat4Dat'>Produce an index matrix and legend from a dataset</h2><span id='topic+getStateMat4Dat'></span>

<h3>Description</h3>

<p>Takes a dataset to produce an index matrix that corresponds to a single state-dependent process (i.e. a single rate category) and a legend which matches input data to the rows and columns of the index matrix and corHMM solution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStateMat4Dat(data, model = "ARD", dual = FALSE, collapse = TRUE, indep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStateMat4Dat_+3A_data">data</code></td>
<td>
<p>A data matrix containing species information in the same format as the main <code>corHMM</code> function: column[,1] is species names, column[,2:n] are the discrete states.</p>
</td></tr>
<tr><td><code id="getStateMat4Dat_+3A_model">model</code></td>
<td>
<p>One of &quot;ARD&quot;, &quot;SYM&quot;, or &quot;ER&quot;. ARD: all rates differ. SYM: rates between any two states do not differ. ER: all rates are equal.</p>
</td></tr>
<tr><td><code id="getStateMat4Dat_+3A_dual">dual</code></td>
<td>
<p>A boolean indicating whether or not to include dual transitions.</p>
</td></tr>
<tr><td><code id="getStateMat4Dat_+3A_collapse">collapse</code></td>
<td>
<p>a boolean indicating whether to collapse multiple character combinations into only the observed states. For example, if true a two character dataset contained (0,0), (1,0), and (1,1), this would be collapsed into 1,2,3. However, if set to false it would 1,2,4. In combination with a custom rate matrix this allows for the estimation of transitions between the unobserved character combination. The default is <code>TRUE</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="getStateMat4Dat_+3A_indep">indep</code></td>
<td>
<p>A boolean indicating whether or not to return an independent or correlated model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will generate an index matrix based on user provided data. It provides a useful starting point for further modifications using <code>dropStateMatPars</code>, <code>equateStateMatPars</code>, and <code>getFullMat</code>. If more than a single column of data is given double transitions between characters are disallowed. For example, if character 1 is the presence or absence of limbs, and character 2 is the presence or absence of fingers, then the transition from absence of limbs and fingers to presence of limbs and fingers is automatically disallowed. This is consistent with Pagel's (1994) model of correlated character evolution. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>$legend</code></td>
<td>
<p>A named vector. The elements of the vector are all the unique state combinations in the user data. The names of the vector are the state number assigned to each combination.</p>
</td></tr>
<tr><td><code>$rate.mat</code></td>
<td>
<p>A rate index matrix describing a single rate class.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James D. Boyko</p>


<h3>References</h3>

<p>Pagel, M. 1994. Detecting correlated evolution on phylogenies: a gneeral method for the comparative analysis of discrete characters. Proc. R. Soc. Lond. B 255:37-45.
</p>


<h3>See Also</h3>

<p><code>getFullmat</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates)
phy &lt;- primates[[1]]
phy &lt;- multi2di(phy)
data &lt;- primates[[2]]
# create a legend and rate mat from a multi-character dataset.
LegendAndRateMat &lt;- getStateMat4Dat(data)
rate.mat &lt;- LegendAndRateMat$rate.mat
legend &lt;- LegendAndRateMat$legend

</code></pre>

<hr>
<h2 id='makeSimmap'>Simulate a character history</h2><span id='topic+makeSimmap'></span>

<h3>Description</h3>

<p>Produces a character history given some of the outputs of a corHMM object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSimmap(tree, data, model, rate.cat, root.p="yang", nSim=1, nCores=1, fix.node=NULL,
fix.state=NULL, parsimony = FALSE, max.attempt = 1000, collapse=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSimmap_+3A_tree">tree</code></td>
<td>
<p>A phylogeny of class phylo.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_data">data</code></td>
<td>
<p>a data.frame containing species information. The first column must be species names matching the phylogeny. Additional columns contain discrete character data.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_model">model</code></td>
<td>
<p>The transition rate matrix.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_rate.cat">rate.cat</code></td>
<td>
<p>The number of rate categories.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_root.p">root.p</code></td>
<td>
<p>The root prior to begin the sampling at the root. Currently only &quot;yang&quot; allowed.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_nsim">nSim</code></td>
<td>
<p>The number of simmaps to be simulated.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_ncores">nCores</code></td>
<td>
<p>The number of cores to be used.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_fix.node">fix.node</code></td>
<td>
<p>A vector specifying node numbers to be fixed. Also possible to fix tips if using a hidden Markov model. Tips are in the order of tree$tip.label.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_fix.state">fix.state</code></td>
<td>
<p>Specifies which states to fix the nodes. States are specified according to position in the rate matrix. E.g. If I had binary observed characters 0/1 and two hidden rate classes A/B and wanted to fix a node as 1B, I would set this to 4.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_parsimony">parsimony</code></td>
<td>
<p>A boolean indicating whether node states should be based on conditional likelihood (per Bollback 2006), or if they should be consistent with a parsimonious model (if TRUE). Parsimony states are evaluted by dividing the rates present in the variable, <code>model</code>, by 1000 and evaluating the conditional likelihood of each state. However, by lowering the rates we can approximate a parsimony reconstruction (Steel and Penny 2000).</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_max.attempt">max.attempt</code></td>
<td>
<p>A numeric value indicating the maximum number of attempts to create a possible path between an initial and final state on a branch. When the maximum value is reached we use the Floyd-Walsh algorithm to produce the shortest path between the two states and divide the branch into equal segments.</p>
</td></tr>
<tr><td><code id="makeSimmap_+3A_collapse">collapse</code></td>
<td>
<p>a boolean indicating whether to collapse multiple character combinations into only the observed states. For example, if true a two character dataset contained (0,0), (1,0), and (1,1), this would be collapsed into 1,2,3. However, if set to false it would 1,2,4. In combination with a custom rate matrix this allows for the estimation of transitions between the unobserved character combination. The default is <code>TRUE</code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>This function will generate a character history given a model and dataset. It has a similar structure to the simmap generated in phytools and follows the methods of Bollback (2006). If using hidden states, then it is necessary to reconstruct the tip probabilities as well as the node probabilities (i.e. get.tip.states must be <code>TRUE</code> when running <code>corHMM</code>). We chose not to implement any new plotting functions, instead <code>makeSimmap</code> produces a simmap object which is formatted so it can used with other R packages such as phytools (Revell, 2012). For additional capabilities, options, and biological examples we refer readers to the detailed _Generalized corHMM_ vignette.
</p>


<h3>Value</h3>

<p>A list of simmaps.
</p>


<h3>Author(s)</h3>

<p>James D. Boyko</p>


<h3>References</h3>

<p>Boyko, J. D., and J. M. Beaulieu. 2021. Generalized hidden Markov models for phylogenetic comparative datasets. Methods in Ecology and Evolution 12:468-478.
</p>
<p>Bollback, J. P. 2006. SIMMAP: stochastic character mapping of discrete traits on phylogenies. BMC Bioinformatics 7:88.
</p>
<p>Revell, L. J. 2012. phytools: an R package for phylogenetic comparative biology (and other things). Methods in Ecology and Evolution, 3(2), 217-223.
</p>
<p>Steel, M., and D. Penny. 2000. Parsimony, Likelihood, and the Role of Models in Molecular Phylogenetics. Molecular Biology and Evolution 17:839-850.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates)
phy &lt;- primates[[1]]
phy &lt;- multi2di(phy)
data &lt;- primates[[2]]

##run corhmm
MK &lt;- corHMM(phy, data, 1)

##get simmap from corhmm solution
model &lt;- MK$solution
simmap &lt;- makeSimmap(tree=phy, data=data, model=model, rate.cat=1, nSim=1, nCores=1)

## we import phytools plotSimmap for plotting
# library(phytools)
# plotSimmap(simmap[[1]])

</code></pre>

<hr>
<h2 id='plotMKmodel'>Plot a Markov model</h2><span id='topic+plotMKmodel'></span>

<h3>Description</h3>

<p>Plots a diagram of a Markov model from the output of corHMM or a custom index matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMKmodel(corhmm.obj, rate.cat = NULL, display = "column", color = c("blue", "red"), 
arrow.scale = 1, text.scale = 1, vertex.scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMKmodel_+3A_corhmm.obj">corhmm.obj</code></td>
<td>
<p>an object of class corHMM or matrix.</p>
</td></tr>
<tr><td><code id="plotMKmodel_+3A_rate.cat">rate.cat</code></td>
<td>
<p>if using a custom matrix then the number of rate categories must be indicated.</p>
</td></tr>
<tr><td><code id="plotMKmodel_+3A_display">display</code></td>
<td>
<p>the structure of the plot. one of &quot;column&quot;, &quot;square&quot;, or &quot;row&quot;.</p>
</td></tr>
<tr><td><code id="plotMKmodel_+3A_color">color</code></td>
<td>
<p>Either, 1. a vector of 2 colors to create a gradient from low transition rates (first element) to high transition rates (second element), or 2. &quot;col.blind&quot; which will use the color pallete &quot;plasma&quot; from viridis.</p>
</td></tr>
<tr><td><code id="plotMKmodel_+3A_arrow.scale">arrow.scale</code></td>
<td>
<p>determines the size of the arrows for the Markov diagram.</p>
</td></tr>
<tr><td><code id="plotMKmodel_+3A_text.scale">text.scale</code></td>
<td>
<p>determines the size of the text for the plotted matrix.</p>
</td></tr> 
<tr><td><code id="plotMKmodel_+3A_vertex.scale">vertex.scale</code></td>
<td>
<p>determines the size of the text for the Markov diagram.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Plots Markov models in a ball and stick type diagram next to its corresponding matrix. If plotting a hidden rates model it will produce a compound plot describing how the different rate classes are related to one another. If the input is a <code>corHMM</code> result then arrows are colored by relative rate. If the input is a custom matrix arrows are colored by the paramater index.
</p>


<h3>Value</h3>

<p>Returns a ball and stick diagram of the input model.  
</p>


<h3>Author(s)</h3>

<p>James D. Boyko</p>


<h3>References</h3>

<p>Boyko, J. D., and J. M. Beaulieu. 2021. Generalized hidden Markov models for phylogenetic comparative datasets. Methods in Ecology and Evolution 12:468-478.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates)
phy &lt;- primates[[1]]
phy &lt;- multi2di(phy)
data &lt;- primates[[2]]
# create a legend and rate mat from a multi-character dataset.
LegendAndRateMat &lt;- getStateMat4Dat(data)
rate.mat &lt;- LegendAndRateMat$rate.mat
legend &lt;- LegendAndRateMat$legend

# To create a hidden markov model first define your rate classes (state-dependent processes)
# R1 will be a manually created SYM model
R1 &lt;- equateStateMatPars(rate.mat, c(1:6))
# R2 will only allow transitions between 1 and 2
R2 &lt;- dropStateMatPars(rate.mat, c(3,4))
# R1 and R2 will transtion at equal rates (i.e. the parameter process will be ER)
P &lt;- getRateCatMat(2)
P &lt;- equateStateMatPars(P, c(1,2))
# combine our state-dependnet processes and parameter process
HMM &lt;- getFullMat(list(R1, R2), P)
# plot the input
plotMKmodel(HMM, rate.cat = 2)

# This can now be used in a corHMM model
CustomModel &lt;- corHMM(phy = phy, data = data, rate.cat = 2, rate.mat = HMM, node.states = "none")
# plot the output
plotMKmodel(CustomModel)

</code></pre>

<hr>
<h2 id='plotRECON'>Plot ancestral state reconstructions</h2><span id='topic+plotRECON'></span>

<h3>Description</h3>

<p>Plots maximum likelihood ancestral state estimates on tree</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRECON(phy, likelihoods, piecolors=NULL, cex=0.5, pie.cex=0.25, file=NULL, 
height=11, width=8.5, show.tip.label=TRUE, title=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRECON_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_likelihoods">likelihoods</code></td>
<td>
<p>likelihoods for ancestral states (see Details).</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_piecolors">piecolors</code></td>
<td>
<p>a vector of colors for states.</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_cex">cex</code></td>
<td>
<p>specifies the size of the font for labels (if used).</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_pie.cex">pie.cex</code></td>
<td>
<p>specifies the size of the symbols to plot on tree.</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_file">file</code></td>
<td>
<p>filename to which a pdf is saved.</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_height">height</code></td>
<td>
<p>height of plot.</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_width">width</code></td>
<td>
<p>width of plot.</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_show.tip.label">show.tip.label</code></td>
<td>
<p>a logical indicating whether to draw tip labels to tree.  The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_title">title</code></td>
<td>
<p>an optional title for the plot.</p>
</td></tr>
<tr><td><code id="plotRECON_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the plot device</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Plots ancestral state estimates on provided tree.  The <code>likelihoods</code> can be the <code>states</code> of an object of class <code>rayDISC</code> or class <code>corDISC</code>, or the <code>lik.anc</code> of an object of class <code>ace</code> (from the <code>ape</code> package).
</p>


<h3>Value</h3>

<p>A plot indicating the maximum likelihood ancestral states at each internal node. 
</p>


<h3>Author(s)</h3>

<p>Jeffrey C. Oliver</p>


<h3>See Also</h3>

<p><code><a href="#topic+corDISC">corDISC</a></code>, <code><a href="#topic+rayDISC">rayDISC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rayDISC.example)
## Perform ancestral state estimation, using a single rate of evolution and marginal 
## reconstruction of ancestral states
recon &lt;- rayDISC(rayDISC.example$tree,rayDISC.example$trait,model="ER",
node.states="marginal")
## Plot reconstructions on tree
plotRECON(rayDISC.example$tree,recon$states,title="rayDISC Example")

</code></pre>

<hr>
<h2 id='rayDISC'>Evolution of categorical traits</h2><span id='topic+rayDISC'></span><span id='topic+dev.raydisc'></span>

<h3>Description</h3>

<p>Fits a model of evolution for categorical traits, allowing for multi-state characters, polymorphisms, missing data, and incompletely resolved trees</p>


<h3>Usage</h3>

<pre><code class='language-R'>rayDISC(phy,data, ntraits=1, charnum=1, rate.mat=NULL, model=c("ER","SYM","ARD"),
node.states=c("joint", "marginal", "scaled", "none"), state.recon=c("subsequently"), 
lewis.asc.bias=FALSE, p=NULL, root.p="yang", ip=NULL, lb=1e-9, ub=100, verbose=TRUE, 
diagn=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rayDISC_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree, in <code>ape</code> &ldquo;phylo&rdquo; format.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_data">data</code></td>
<td>
<p>a data matrix containing species information (see Details).</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_ntraits">ntraits</code></td>
<td>
<p>specifies the number of traits to included in the analysis.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_charnum">charnum</code></td>
<td>
<p>specified the character to analyze.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_rate.mat">rate.mat</code></td>
<td>
<p>a user-supplied rate matrix index of parameters to be optimized.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_model">model</code></td>
<td>
<p>specifies the underlying model.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_node.states">node.states</code></td>
<td>
<p>method used to calculate ancestral states at internal nodes.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_state.recon">state.recon</code></td>
<td>
<p>whether to reconstruct states jointly with the rates or subsequent to the rates being optimized.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_lewis.asc.bias">lewis.asc.bias</code></td>
<td>
<p>a logical indicating whether the ascertainment bias correction of Lewis et al. 2001 should be used. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_p">p</code></td>
<td>
<p>a vector of transition rates. Allows the user to calculate the likelihood given a specified set of parameter values to specified as fixed and calculate the likelihood.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_root.p">root.p</code></td>
<td>
<p>a vector used to fix the probabilities at the root, but &ldquo;yang&rdquo; and &ldquo;maddfitz&rdquo; can also be supplied to use the method of Yang (2006) and FitzJohn et al (2009), respectively (see details).</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_ip">ip</code></td>
<td>
<p>initial values used for the likelihood search. Can be a single value or a vector of unique values for each parameter. The default is <code>ip=1</code>.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_lb">lb</code></td>
<td>
<p>lower bound for the likelihood search. The default is <code>lb=0</code>.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_ub">ub</code></td>
<td>
<p>upper bound for the likelihood search. The default is <code>ub=100</code>.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating whether progress should be printed to the screen.</p>
</td></tr>
<tr><td><code id="rayDISC_+3A_diagn">diagn</code></td>
<td>
<p>logical indicating whether diagnostic tests should be performed. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>__THIS FUNCTION IS NO LONGER NECESSARY AS IT IS NOW ENTIRELY SUBSUMED WITHIN__ <code>corHMM</code> (see _Generalized corHMM_ vignette). But we still provide it for those that are more comfortable using it than exploring the new <code>corHMM</code> function. As before, <code>rayDISC</code> takes a tree and a trait file and estimates transition rates and ancestral states for binary or multistate characters. The first column of the trait file must contain the species labels to match to the tree, with the second, third, fourth, and so on, corresponding to the traits of interest. Use the <code>charnum</code> variable to select the trait for analysis. Also, the input phylogeny need not be bifurcating as the algorithm is implemented to handle multifucations. Polytomies are allowed by generalizing Felsenstein's (1981) pruning algorithm to be the product of the probability of observing the tip states of n descendant nodes, rather than two, as in the completely bifurcating case.
</p>
<p>The user can fix the root state probabilities by supplying a vector to the <code>root.p</code>. If the user supplies the flag <code>root.p</code>=&ldquo;yang&rdquo;, then the estimated transition rates are used to set the weights at the root (see pg. 124 Yang 2006), whereas specifying <code>root.p</code>=&ldquo;maddfitz&rdquo; employs the same procedure described by Maddison et al. (2007) and FitzJohn et al. (2009). Note that the default <code>root.p=NULL</code> assumes equal weighting among all possible states.
</p>
<p>Ambiguities (polymorphic taxa or taxa missing data) are assigned likelihoods following Felsenstein (2004, p. 255). Taxa with missing data are coded &ldquo;?&rdquo; with all states observed at a tip. Polymorphic taxa are coded with states separated by an &ldquo;&amp;&rdquo;. For example, if a trait has four states and taxonA is observed to be in state 1 and 3, the character would be coded as &ldquo;1&amp;3&rdquo;. corHMM then uses this information to assign a likelihood of 1.0 to both states. Missing data are treated as ambiguous for all states, thus all states for taxa missing data are assigned a likelihood of 1.0. For example, for a four-state character (i.e. DNA), a taxon missing data will have likelihoods of all four states equal to 1.0 [e.g. L(A)=1.0, L(C)=1.0, L(G)=1.0, L(T)=1.0].
</p>
<p>In all ancestral state reconstruction implementations, the rates are first estimated, and subsequently, the MLE estimates of the rates are used to determine either the state probabilities (i.e., marginal or &quot;scaled&quot;) or maximum likelihood states at nodes. This is the default &ndash; i.e., the state.recon=&quot;subsequently&quot; argument. However, for this function only, we also allow for both rates and states to be estimated jointly. This can be done with state.recon=&quot;estimate&quot;. We also allow for a hypothesis about states at all or even some nodes to help fixed, with the rates (and in some cases some of the states) being estimated. This is state.recon=&quot;given&quot;. For more information please see Vignette &quot;Getting Likelihoods From Reconstructions&quot;.
</p>


<h3>Value</h3>

<p><code>rayDISC</code> returns an object of class <code>rayDISC</code>. This is a list with elements:
</p>
<table>
<tr><td><code>$loglik</code></td>
<td>
<p>the maximum negative log-likelihood.</p>
</td></tr>
<tr><td><code>$AIC</code></td>
<td>
<p>Akaike information criterion.</p>
</td></tr>
<tr><td><code>$AICc</code></td>
<td>
<p>Akaike information criterion corrected for sample size.</p>
</td></tr>
<tr><td><code>$ntraits</code></td>
<td>
<p>The number of traits specified.</p>
</td></tr>
<tr><td><code>$solution</code></td>
<td>
<p>a matrix containing the maximum likelihood estimates of the transition rates.</p>
</td></tr>
<tr><td><code>$solution.se</code></td>
<td>
<p>a matrix containing the approximate standard errors of the transition rates. The standard error is calculated as the square root of the diagonal of the inverse of the Hessian matrix.</p>
</td></tr>
<tr><td><code>$index.mat</code></td>
<td>
<p>The indices of the parameters being estimated are returned. The numbers correspond to the row in the <code>eigvect</code> and can useful for identifying the parameters that are causing the objective function to be at a saddlepoint.</p>
</td></tr>
<tr><td><code>$lewis.asc.bias</code></td>
<td>
<p>The setting describing whether or not the Lewis ascertainment bias correction was used.</p>
</td></tr>
<tr><td><code>$opts</code></td>
<td>
<p>Internal settings of the likelihood search.</p>
</td></tr>
<tr><td><code>$data</code></td>
<td>
<p>User-supplied dataset.</p>
</td></tr>
<tr><td><code>$phy</code></td>
<td>
<p>User-supplied tree.</p>
</td></tr>
<tr><td><code>$states</code></td>
<td>
<p>The likeliest states at each internal node.</p>
</td></tr>
<tr><td><code>$tip.states</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code>$iterations</code></td>
<td>
<p>The number of iterations used by the optimization routine.</p>
</td></tr>
<tr><td><code>$eigval</code></td>
<td>
<p>The eigenvalues from the decomposition of the Hessian of the likelihood function. If any <code>eigval&lt;0</code> then one or more parameters were not optimized during the likelihood search.</p>
</td></tr>
<tr><td><code>$eigvect</code></td>
<td>
<p>The eigenvectors from the decomposition of the Hessian of the likelihood function is returned.</p>
</td></tr>
<tr><td><code>$bound.hit</code></td>
<td>
<p>A logical for diagnosing if rate parameters were constrained by <code>lb</code> or <code>ub</code> values during optimization.</p>
</td></tr>
<tr><td><code>$message.tree</code></td>
<td>
<p>A list of taxa which were listed in the data matrix, but were not present in the passed <code>phylo</code> object. These taxa will be excluded from the analysis. <code>message.tree</code> is null if all taxa in data are included in tree.</p>
</td></tr>
<tr><td><code>$message.data</code></td>
<td>
<p>A list of taxa which were present in the passed <code>phylo</code> object, but lacked data in the passed data matrix. These taxa will be coded as missing data (all states equally likely). <code>message.data</code> is null if all taxa in tree have entries in data matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey C. Oliver and Jeremy M. Beaulieu</p>


<h3>References</h3>

<p>Felsenstein, J. 1981. A likelihood approach to character weighting and what it tells us about parsimony and compatibility. Biological Journal of the Linnean Society 16: 183-196.
</p>
<p>Felsenstein J. 2004. Inferring phylogenies. Sunderland MA: Sinauer Associates.
</p>
<p>FitzJohn, R.G., W.P. Maddison, and S.P. Otto. 2009. Estimating trait-dependent speciation and extinction rates from incompletely resolved phylogenies. Systematic Biology 58:595-611.
</p>
<p>Lewis, P.O. 2001. A likelihood approach to estimating phylogeny from discrete morphological character data. Systematic Biology 50:913-925.
</p>
<p>Maddison, W.P., P.E. Midford, and S.P. Otto. 2007. Estimating a binary characters effect on speciation and extinction. Systematic Biology 56:701-710.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotRECON">plotRECON</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Example 1
data(rayDISC.example)
## Perform ancestral state estimation, using an asymmetric model of evolution and marginal
## reconstruction of ancestral states
recon &lt;- rayDISC(rayDISC.example$tree,rayDISC.example$trait,model="ARD",
node.states="marginal")

## Plot reconstructions on tree
plotRECON(rayDISC.example$tree,recon$states)

### Example 2
## Perform ancestral state estimation on second character, using a single-rate model of
## evolution, marginal reconstruction of ancestral states, and setting the lower bound for
## parameter estimates to 0.01
recon &lt;- rayDISC(rayDISC.example$tree,rayDISC.example$trait,charnum=2,model="ER",
node.states="marginal",lb=0.01)

### Example 3
## Perform ancestral state estimation on third character, using a single-rate model of
## evolution and joint reconstruction of ancestral states
recon &lt;- rayDISC(rayDISC.example$tree,rayDISC.example$trait,charnum=3,
model="ER",node.states="joint")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
