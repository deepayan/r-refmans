<!DOCTYPE html><html><head><title>Help for package eufmdis.adapt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eufmdis.adapt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_availability'><p>Check if list items are empty</p></a></li>
<li><a href='#cleanup_names'><p>Clean up a vector of column names</p></a></li>
<li><a href='#compute_p_value'><p>Compute p value for freedom from disease sample</p></a></li>
<li><a href='#compute_sample_size'><p>Compute sample size for freedom from disease</p></a></li>
<li><a href='#compute_sample_size_vectorised'><p>Compute sample size for freedom from disease (vectorised)</p></a></li>
<li><a href='#create_diag_control'><p>Data analysis for diagnostic samples during the control phase</p></a></li>
<li><a href='#create_long_data_frame'><p>Reshape wide data frame with combined column names</p></a></li>
<li><a href='#discumulate_data'><p>Inverse of Cumulative Sum</p></a></li>
<li><a href='#format_numbers_DT'><p>Safe wrapper for DT::formatCurrency</p>
Wrapper for <code>DT::formatCurrency</code> that returns NULL when the input table
is <code>NULL</code> (instead of throwing an error).</a></li>
<li><a href='#import_data_file'><p>Import data from csv file in Shiny App</p></a></li>
<li><a href='#plot_barchart'><p>Plot bar chart with error bars</p></a></li>
<li><a href='#plot_barchart_euros'><p>Plot bar chart with error bars an Euro notation</p></a></li>
<li><a href='#plot_distribution'><p>Plot the distribution of a variable</p></a></li>
<li><a href='#plot_time_series'><p>Plot graph of a time series with daily error margin</p></a></li>
<li><a href='#run_adapt'><p>Run ADAPT Shiny App</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyse 'EuFMDiS' Output Files via a Shiny App</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Ian Kopacka [aut, cre],
  Tatiana Marschik [aut],
  Elena Sassu [aut],
  Annette Nigsch [aut],
  Food and Agriculture Organization of the United Nations (FAO) [cph,
    fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ian Kopacka &lt;ian.kopacka@ages.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyses 'EuFMDiS' output files in a Shiny App. The distributions of 
  relevant output parameters are described in form of tables (quantiles) and plots. 
  The App is called using eufmdis.adapt::run_adapt().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, rlang, grDevices, magrittr, dplyr,
tibble, tidyselect, ggplot2, shiny, shinydashboard,
shinyWidgets, htmltools, DT</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 12:42:35 UTC; ian30</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-12 06:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_availability'>Check if list items are empty</h2><span id='topic+check_availability'></span>

<h3>Description</h3>

<p>The function argument is a list of data frames that are required for some
subsequent analysis. If any of the data frames are empty (i.e. the data
have not been uploaded to the app), a message is returned as HTML code
listing the names of the required data frames (= names of list items).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_availability(list_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_availability_+3A_list_data">list_data</code></td>
<td>
<p>Named list of data frames</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the ADAPT app, individual analyses can only be performed if the
necessary output files are uploaded. If certain files are not uploaded,
the app produces empty data frames. In the app, the function
<code>check_availability()</code> is used with the necessary data frames to check if they
have been uploaded and displays a message of the form &quot;To generate this
analysis, please upload the following reports: x, y&quot; otherwise.
</p>


<h3>Value</h3>

<p>Possibly empty HTML text, listing names of required data frames.
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>

<hr>
<h2 id='cleanup_names'>Clean up a vector of column names</h2><span id='topic+cleanup_names'></span>

<h3>Description</h3>

<p>The function takes a vector of column names as an argument and returns a
cleaned up version of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanup_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanup_names_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following changes are made:
- names are converted to lower case
- dots are replaced by underscores
- underscores in the beginning and end of a string are removed
- multiple underscores are replaced by a single one
</p>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>

<hr>
<h2 id='compute_p_value'>Compute p value for freedom from disease sample</h2><span id='topic+compute_p_value'></span>

<h3>Description</h3>

<p>Compute the probability of drawing no positives in a sample of n items
from a Population of N containing n_dis positives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_p_value(N, n, n_dis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_p_value_+3A_n">N</code></td>
<td>
<p>Integer; size of the population</p>
</td></tr>
<tr><td><code id="compute_p_value_+3A_n">n</code></td>
<td>
<p>Integer; size of the sample</p>
</td></tr>
<tr><td><code id="compute_p_value_+3A_n_dis">n_dis</code></td>
<td>
<p>Integer; number of positives in the population</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability is computed using the hypergeometric distribution. This
function is used in <code><a href="#topic+compute_sample_size">compute_sample_size</a></code>.
</p>


<h3>Value</h3>

<p>Returns the probability of not finding any positives in the sample
as a numeric between 0 and 1
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_sample_size">compute_sample_size</a></code>
</p>

<hr>
<h2 id='compute_sample_size'>Compute sample size for freedom from disease</h2><span id='topic+compute_sample_size'></span>

<h3>Description</h3>

<p>Compute sample size for a one stage freedom from disease survey for given
Population size, design prevalence and accuracy, assuming a perfect
diagnostic test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_sample_size(N, prev, accuracy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_sample_size_+3A_n">N</code></td>
<td>
<p>Integer containing the Size of the population</p>
</td></tr>
<tr><td><code id="compute_sample_size_+3A_prev">prev</code></td>
<td>
<p>Numeric between 0 and 1; design prevalence</p>
</td></tr>
<tr><td><code id="compute_sample_size_+3A_accuracy">accuracy</code></td>
<td>
<p>Numeric between 0 and 1; accuracy of the survey (i.e.
detection probability)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function finds the optimal sample size using a bisection method.
</p>


<h3>Value</h3>

<p>Sample size (integer).
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>

<hr>
<h2 id='compute_sample_size_vectorised'>Compute sample size for freedom from disease (vectorised)</h2><span id='topic+compute_sample_size_vectorised'></span>

<h3>Description</h3>

<p>Compute sample size for a one stage freedom from disease survey for given
Population size, design prevalence and accuracy, assuming a perfect
diagnostic test. Vectorised version of <code><a href="#topic+compute_sample_size">compute_sample_size</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_sample_size_vectorised(N, prev, accuracy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_sample_size_vectorised_+3A_n">N</code></td>
<td>
<p>Integer vector containing the population sizes</p>
</td></tr>
<tr><td><code id="compute_sample_size_vectorised_+3A_prev">prev</code></td>
<td>
<p>Numeric between 0 and 1; design prevalence</p>
</td></tr>
<tr><td><code id="compute_sample_size_vectorised_+3A_accuracy">accuracy</code></td>
<td>
<p>Numeric between 0 and 1; accuracy of the survey (i.e.
detection probability)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses vapply to vectorise <code><a href="#topic+compute_sample_size">compute_sample_size</a></code> over the
population size <code>N</code>. <code>prev</code> and <code>accuracy</code> must be scalars.
For the sake of efficiency, the sample size is only computed once for every
different value of <code>N</code>, even if they apper multiple times in the vector.
</p>


<h3>Value</h3>

<p>Sample size (integer vector).
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_sample_size">compute_sample_size</a></code>
</p>

<hr>
<h2 id='create_diag_control'>Data analysis for diagnostic samples during the control phase</h2><span id='topic+create_diag_control'></span>

<h3>Description</h3>

<p>Function to perform the data analysis, necessary for the analysis of the
diagnostic samples during the control phase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_diag_control(
  herd_summary,
  farm_summary,
  par_diag_control_ffd_prev,
  par_diag_control_ffd_certainty,
  par_diag_control_edta,
  par_diag_control_serum,
  par_diag_control_bulk_milk,
  par_diag_control_lesions_smrum,
  par_diag_control_lesions_pigs,
  par_diag_control_lesions_cattle,
  rel_cols_farm_summary_dc,
  rel_cols_herd_summary_dc,
  herd_types_dairy,
  herd_types_small_ruminants,
  herd_types_pigs,
  herd_types_cattle
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_diag_control_+3A_herd_summary">herd_summary</code></td>
<td>
<p>Data frame; EuFMDIS output file &quot;Herd summary&quot;</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_farm_summary">farm_summary</code></td>
<td>
<p>Data frame; EuFMDIS output file &quot;Farm summary&quot;</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_par_diag_control_ffd_prev">par_diag_control_ffd_prev</code></td>
<td>
<p>numeric between 0 and 100; design
prevalence for the computation of the sample size according to freedom from
disease</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_par_diag_control_ffd_certainty">par_diag_control_ffd_certainty</code></td>
<td>
<p>numeric between 0 and 100; desired
accuracy for the computation of the sample size according to freedom from
disease</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_par_diag_control_edta">par_diag_control_edta</code></td>
<td>
<p>positive integer; Number of blood samples (EDTA)
per symptomatic suspect holding</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_par_diag_control_serum">par_diag_control_serum</code></td>
<td>
<p>positive integer; Number of blood samples
(serum) per symptomatic suspect holding</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_par_diag_control_bulk_milk">par_diag_control_bulk_milk</code></td>
<td>
<p>positive integer; Number of bulk milk
samples per dairy farm</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_par_diag_control_lesions_smrum">par_diag_control_lesions_smrum</code></td>
<td>
<p>positive integer; Number of acute
lesion samples for small ruminants per farm</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_par_diag_control_lesions_pigs">par_diag_control_lesions_pigs</code></td>
<td>
<p>positive integer; Number of acute
lesion samples for pigs per farm</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_par_diag_control_lesions_cattle">par_diag_control_lesions_cattle</code></td>
<td>
<p>positive integer; Number of acute
lesion samples for cattle per farm</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_rel_cols_farm_summary_dc">rel_cols_farm_summary_dc</code></td>
<td>
<p>character vector of column names of the
data frame <code>farm_summary</code> that are required for the analysis</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_rel_cols_herd_summary_dc">rel_cols_herd_summary_dc</code></td>
<td>
<p>character vector of column names of the
data frame <code>herd_summary</code> that are required for the analysis</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_herd_types_dairy">herd_types_dairy</code></td>
<td>
<p>character vector listing the different herd types
that are associated with dairy herds</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_herd_types_small_ruminants">herd_types_small_ruminants</code></td>
<td>
<p>character vector listing the different
herd types that are associated with small ruminant herds</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_herd_types_pigs">herd_types_pigs</code></td>
<td>
<p>character vector listing the different herd types
that are associated with pig herds</p>
</td></tr>
<tr><td><code id="create_diag_control_+3A_herd_types_cattle">herd_types_cattle</code></td>
<td>
<p>character vector listing the different herd types
that are associated with cattle herds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally to prepare the input data for the output
(tables and plots) in the sub menu &quot;Diagnostic tests control phase&quot; of the
ADAPT App.
</p>


<h3>Value</h3>

<p>Returns an aggregated data frame with one line per simulation run.
The data frame contains auxilliary variables needed to appriximate the
number of diagnostic samples required during the control phase as well as
the estimated values for number of bulk milk samples (n_bulk_milk), acute
lesions (n_acute_lesion), swabs (n_swabs), blood samples for edta analysis
(n_blood_edta) and serum analysis (n_blood_serum).
</p>

<hr>
<h2 id='create_long_data_frame'>Reshape wide data frame with combined column names</h2><span id='topic+create_long_data_frame'></span>

<h3>Description</h3>

<p>The function identifies columns whose name contains a combination of two
categorical characteristics (e.g. farm type and output parameter), splits
them up and reshapes the data to a long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_long_data_frame(dat, categories, name_categories, starts_with = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_long_data_frame_+3A_dat">dat</code></td>
<td>
<p>Data frame with combined column names (e.g. <code>type_A_farms</code>,
<code>type_B_farms</code>, <code>type_A_animals</code>, <code>type_B_animals</code>)</p>
</td></tr>
<tr><td><code id="create_long_data_frame_+3A_categories">categories</code></td>
<td>
<p>Character vector of possible values of categories in the
column names (e.g. <code>c("type_A", "type_B")</code>)</p>
</td></tr>
<tr><td><code id="create_long_data_frame_+3A_name_categories">name_categories</code></td>
<td>
<p>Character; name of the newly created column that
contains the categories in the long data frame</p>
</td></tr>
<tr><td><code id="create_long_data_frame_+3A_starts_with">starts_with</code></td>
<td>
<p>Logical; Flag indicating how the combined columns should
be identified. <code>starts_with = TRUE</code> enforces a stricter search mode
where only columns are considered whose name starts with the given string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function looks for combined columns based on the category names provided
in the argument <code>categories</code>. Two modes of searching are possible:
<code>starts_with = FALSE</code> (=default) looks for all columns whose name
contains the strings in <code>categories</code>, whereas <code>starts_with = TRUE</code>
only includes columns whose name starts with the string. Relevant
combinations of #' values that are not found in the wide data frame are
filled with <code>NA</code> in the ling data frame.
</p>


<h3>Value</h3>

<p>A long data frame where the combined columns have been split up
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>

<hr>
<h2 id='discumulate_data'>Inverse of Cumulative Sum</h2><span id='topic+discumulate_data'></span>

<h3>Description</h3>

<p>Computes the inverse of the <code>cumsum</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discumulate_data(value_cum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discumulate_data_+3A_value_cum">value_cum</code></td>
<td>
<p>numeric vector; usually the result of cumulating values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>value_cum</code>
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>

<hr>
<h2 id='format_numbers_DT'>Safe wrapper for DT::formatCurrency
Wrapper for <code>DT::formatCurrency</code> that returns NULL when the input table
is <code>NULL</code> (instead of throwing an error).</h2><span id='topic+format_numbers_DT'></span>

<h3>Description</h3>

<p>Safe wrapper for DT::formatCurrency
Wrapper for <code>DT::formatCurrency</code> that returns NULL when the input table
is <code>NULL</code> (instead of throwing an error).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_numbers_DT(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_numbers_DT_+3A_x">x</code></td>
<td>
<p>A table object created from <code>DT::datatable()</code></p>
</td></tr>
<tr><td><code id="format_numbers_DT_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>DT::formatCurrency</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Behaves the same output as <code>DT::formatCurrency</code> except when
<code>x</code> is <code>NULL</code>. Then <code>NULL</code> is returned and no error is thrown.
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>

<hr>
<h2 id='import_data_file'>Import data from csv file in Shiny App</h2><span id='topic+import_data_file'></span>

<h3>Description</h3>

<p>The function is used in the ADAPT app to import data from uploaded csv files
into a data frame. Only relevant columns are returned, the column names are
matched and unified, so that data produced by different versions of the
EuFMDiS software can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_data_file(
  pattern,
  names_files,
  paths_files,
  def_columns,
  transpose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_data_file_+3A_pattern">pattern</code></td>
<td>
<p>Character string containing a regular expression to identify
the correct file by its name.</p>
</td></tr>
<tr><td><code id="import_data_file_+3A_names_files">names_files</code></td>
<td>
<p>Character vector of file names as they were uploaded (=
file name on the original file system from which they were uploaded)</p>
</td></tr>
<tr><td><code id="import_data_file_+3A_paths_files">paths_files</code></td>
<td>
<p>Character vector of file names + absolute paths of the
files in the local hard drive to which they were uploaded. Each entry of
<code>paths_files</code> corresponds to an entry of <code>names_files</code>. They must
have the same length.</p>
</td></tr>
<tr><td><code id="import_data_file_+3A_def_columns">def_columns</code></td>
<td>
<p>Data frame of meta information containing the possible
column names in the different versions of the EuFMDiS output files. The data
frame must contain columns <code>Datensatz</code> (name of the relevant data frame;
this corresponds to values used in <code>pattern</code>), <code>Name_Parameter</code>
(the unified column name in the generated return value) and columns
containing possible variations of the name in the different versions of
EuFMDiS. Each column contains the notation in one version of EuFMDiS; the
column names must begin with the string <code>Spalte</code></p>
</td></tr>
<tr><td><code id="import_data_file_+3A_transpose">transpose</code></td>
<td>
<p>Logical flag (default = FALSE). COntrols whether the data
frame should be transposed prior to any data manipulation/extraction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing the columns defined in <code>def_columns</code> for
the relevant <code>Datensatz</code> according to the argument <code>pattern</code>.
</p>

<hr>
<h2 id='plot_barchart'>Plot bar chart with error bars</h2><span id='topic+plot_barchart'></span>

<h3>Description</h3>

<p>Creates a bar chart with error bars using <code>ggplot2::geom_col</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_barchart(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_barchart_+3A_x">x</code></td>
<td>
<p>Data frame with columns <code>par</code> or <code>parameter</code> containing
the name of the parameter, <code>q2.5</code> or <code>q2_5</code> for the 2.5 percentiles
(i.e. the lower values for the error bars), <code>median</code> for the median
values (i.e. the height of the bars) and <code>q97.5</code> or <code>q97_5</code> for
the 97.5 percentiles (i.e. the upper values for the error bars).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>ggplot</code> and prints it to the
graphics device.
</p>

<hr>
<h2 id='plot_barchart_euros'>Plot bar chart with error bars an Euro notation</h2><span id='topic+plot_barchart_euros'></span>

<h3>Description</h3>

<p>Creates a bar chart with error bars using <code>ggplot2::geom_col</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_barchart_euros(x, country)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_barchart_euros_+3A_x">x</code></td>
<td>
<p>Data frame with columns <code>par</code> or <code>parameter</code> containing
the name of the parameter, <code>q2.5</code> or <code>q2_5</code> for the 2.5 percentiles
(i.e. the lower values for the error bars), <code>median</code> for the median
values (i.e. the height of the bars) and <code>q97.5</code> or <code>q97_5</code> for
the 97.5 percentiles (i.e. the upper values for the error bars).</p>
</td></tr>
<tr><td><code id="plot_barchart_euros_+3A_country">country</code></td>
<td>
<p>Character to be displayed in the Plot title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>ggplot</code> and prints it to the
graphics device.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_barchart">plot_barchart</a></code>
</p>

<hr>
<h2 id='plot_distribution'>Plot the distribution of a variable</h2><span id='topic+plot_distribution'></span>

<h3>Description</h3>

<p>Creates a histogram of the value along with a horizontal boxplot above it
to show the distribution of a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_distribution(x, parameter, main = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_distribution_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="plot_distribution_+3A_parameter">parameter</code></td>
<td>
<p>Character to use as label of the x-axis</p>
</td></tr>
<tr><td><code id="plot_distribution_+3A_main">main</code></td>
<td>
<p>(optional) character to use as plot title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Creates a plot.
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>

<hr>
<h2 id='plot_time_series'>Plot graph of a time series with daily error margin</h2><span id='topic+plot_time_series'></span>

<h3>Description</h3>

<p>Creates a line plot with a shaded polygon showing daily error margins
(uncertainty ranges)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_time_series(x, parameter, main = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_time_series_+3A_x">x</code></td>
<td>
<p>Data frame with columns <code>day</code> containing the counter for the
time steps (=days), <code>q025</code> for the 2.5 percentiles
(i.e. the lower values for the error margin), <code>median</code> for the median
values (i.e. the values for the line plot) and <code>q975</code> for the 97.5
percentiles (i.e. the upper values for the error margin).</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_parameter">parameter</code></td>
<td>
<p>Character to use as label of the y-axis</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_main">main</code></td>
<td>
<p>(optional) character to use as plot title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Creates a plot.
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>

<hr>
<h2 id='run_adapt'>Run ADAPT Shiny App</h2><span id='topic+run_adapt'></span>

<h3>Description</h3>

<p>This function runs the Shiny App &quot;ADAPT&quot; to analyse 'EuFMDiS' output files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_adapt()
</code></pre>


<h3>Details</h3>

<p>Upload the relevant csv output files via the &quot;Upload files&quot; dialog to
trigger the analysis.
</p>


<h3>Value</h3>

<p>no return value; starts a Shiny app
</p>


<h3>Author(s)</h3>

<p>Ian Kopacka
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
    run_adapt()
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
