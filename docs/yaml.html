<!DOCTYPE html><html lang="en"><head><title>Help for package yaml</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {yaml}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.yaml'><p> Convert an R object into a YAML string</p></a></li>
<li><a href='#read_yaml'><p>Read a YAML file</p></a></li>
<li><a href='#verbatim_logical'>
<p>Alternative logical handler</p></a></li>
<li><a href='#write_yaml'><p>Write a YAML file</p></a></li>
<li><a href='#yaml.load'><p> Convert a YAML string into R objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods to Convert R Data to YAML and Back</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-22</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.10</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit</td>
</tr>
<tr>
<td>Author:</td>
<td>Shawn P Garbett [aut], Jeremy Stephens [aut, cre], Kirill Simonov [aut], Yihui Xie [ctb],
  Zhuoer Dong [ctb], Hadley Wickham [ctb], Jeffrey Horner [ctb], reikoch [ctb],
  Will Beasley [ctb], Brendan O'Connor [ctb], Gregory R. Warnes [ctb],
  Michael Quinn [ctb], Zhian N. Kamvar [ctb], Charlie Gao [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shawn Garbett &lt;shawn.garbett@vumc.org&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the 'libyaml' 'YAML' 1.1 parser and emitter
  (<a href="https://pyyaml.org/wiki/LibYAML">https://pyyaml.org/wiki/LibYAML</a>) for R.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vubiostat/r-yaml/">https://github.com/vubiostat/r-yaml/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vubiostat/r-yaml/issues">https://github.com/vubiostat/r-yaml/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-22 15:44:18 UTC; garbetsp</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-26 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.yaml'> Convert an R object into a YAML string </h2><span id='topic+as.yaml'></span>

<h3>Description</h3>

<p>Convert an R object into a YAML string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.yaml(x, line.sep = c("\n", "\r\n", "\r"), indent = 2, omap = FALSE,
          column.major = TRUE, unicode = TRUE, precision = getOption('digits'),
          indent.mapping.sequence = FALSE, handlers = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.yaml_+3A_x">x</code></td>
<td>
<p> the object to be converted </p>
</td></tr>
<tr><td><code id="as.yaml_+3A_line.sep">line.sep</code></td>
<td>
<p> the line separator character(s) to use </p>
</td></tr>
<tr><td><code id="as.yaml_+3A_indent">indent</code></td>
<td>
<p> the number of spaces to use for indenting </p>
</td></tr>
<tr><td><code id="as.yaml_+3A_omap">omap</code></td>
<td>
<p> determines whether or not to convert a list to a YAML omap; see Details </p>
</td></tr>
<tr><td><code id="as.yaml_+3A_column.major">column.major</code></td>
<td>
<p> determines how to convert a data.frame; see Details </p>
</td></tr>
<tr><td><code id="as.yaml_+3A_unicode">unicode</code></td>
<td>
<p> determines whether or not to allow unescaped unicode characters in output </p>
</td></tr>
<tr><td><code id="as.yaml_+3A_precision">precision</code></td>
<td>
<p> number of significant digits to use when formatting numeric values </p>
</td></tr>
<tr><td><code id="as.yaml_+3A_indent.mapping.sequence">indent.mapping.sequence</code></td>
<td>
<p> determines whether or not to indent sequences in mapping context </p>
</td></tr>
<tr><td><code id="as.yaml_+3A_handlers">handlers</code></td>
<td>
<p> named list of custom handler functions for R objects; see Details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you set the <code>omap</code> option to TRUE, as.yaml will create ordered maps
(or omaps) instead of normal maps.
</p>
<p>The <code>column.major</code> option determines how a data frame is converted. If TRUE, the data
frame is converted into a map of sequences where the name of each column is a key. If FALSE,
the data frame is converted into a sequence of maps, where each element in the sequence is a
row.  You'll probably almost always want to leave this as TRUE (which is the default),
because using <code><a href="#topic+yaml.load">yaml.load</a></code> on the resulting string returns an object which is
much more easily converted into a data frame via <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
<p>You can specify custom handler functions via the <code>handlers</code> argument.
This argument must be a named list of functions, where the names are R object
class names (i.e., 'numeric', 'data.frame', 'list', etc).  The function(s)
you provide will be passed one argument (the R object) and can return any R
object.  The returned object will be emitted normally.
</p>
<p>Character vectors that have a class of &lsquo;verbatim&rsquo; will not be quoted
in the output YAML document except when the YAML specification requires it.
This means that you cannot do anything that would result in an invalid YAML
document, but you can emit strings that would otherwise be quoted.  This is
useful for changing how logical vectors are emitted (see below for example).
</p>
<p>Character vectors that have an attribute of &lsquo;quoted&rsquo; will be wrapped
in double quotes (see below for example).
</p>
<p>You can specify YAML tags for R objects by setting the &lsquo;tag&rsquo; attribute
to a character vector of length 1.  If you set a tag for a vector, the tag
will be applied to the YAML sequence as a whole, unless the vector has only 1
element.  If you wish to tag individual elements, you must use a list of
1-length vectors, each with a tag attribute.  Likewise, if you set a tag for
an object that would be emitted as a YAML mapping (like a data frame or a
named list), it will be applied to the mapping as a whole.  Tags can be used
in conjunction with YAML deserialization functions like
<code><a href="#topic+yaml.load">yaml.load</a></code> via custom handlers, however, if you set an internal
tag on an incompatible data type (like &ldquo;!seq 1.0&rdquo;), errors will occur
when you try to deserialize the document.
</p>


<h3>Value</h3>

<p>Returns a YAML string which can be loaded using <code><a href="#topic+yaml.load">yaml.load</a></code> or copied into
a file for external use.
</p>


<h3>Author(s)</h3>

<p> Jeremy Stephens &lt;jeremy.f.stephens@vumc.org&gt; </p>


<h3>References</h3>

<p>YAML: http://yaml.org
</p>
<p>YAML omap type: http://yaml.org/type/omap.html
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+yaml.load">yaml.load</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.yaml(1:10)
  as.yaml(list(foo=1:10, bar=c("test1", "test2")))
  as.yaml(list(foo=1:10, bar=c("test1", "test2")), indent=3)
  as.yaml(list(foo=1:10, bar=c("test1", "test2")), indent.mapping.sequence=TRUE)
  as.yaml(data.frame(a=1:10, b=letters[1:10], c=11:20))
  as.yaml(list(a=1:2, b=3:4), omap=TRUE)
  as.yaml("multi\nline\nstring")
  as.yaml(function(x) x + 1)
  as.yaml(list(foo=list(list(x = 1, y = 2), list(x = 3, y = 4))))

  # custom handler
  as.yaml(Sys.time(), handlers = list(
    POSIXct = function(x) format(x, "%Y-%m-%d")
  ))

  # custom handler with verbatim output to change how logical vectors are
  # emitted
  as.yaml(c(TRUE, FALSE), handlers = list(
    logical = verbatim_logical))

  # force quotes around a string
  port_def &lt;- "80:80"
  attr(port_def, "quoted") &lt;- TRUE
  x &lt;- list(ports = list(port_def))
  as.yaml(x)

  # custom tag for scalar
  x &lt;- "thing"
  attr(x, "tag") &lt;- "!thing"
  as.yaml(x)

  # custom tag for sequence
  x &lt;- 1:10
  attr(x, "tag") &lt;- "!thing"
  as.yaml(x)

  # custom tag for mapping
  x &lt;- data.frame(a = letters[1:5], b = letters[6:10])
  attr(x, "tag") &lt;- "!thing"
  as.yaml(x)

  # custom tag for each element in a list
  x &lt;- list(1, 2, 3)
  attr(x[[1]], "tag") &lt;- "!a"
  attr(x[[2]], "tag") &lt;- "!b"
  attr(x[[3]], "tag") &lt;- "!c"
  as.yaml(x)
</code></pre>

<hr>
<h2 id='read_yaml'>Read a YAML file</h2><span id='topic+read_yaml'></span>

<h3>Description</h3>

<p>Read a YAML document from a file and create an R object from it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  read_yaml(file, fileEncoding = "UTF-8", text, error.label, readLines.warn=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_yaml_+3A_file">file</code></td>
<td>
<p>either a character string naming a file or a <a href="base.html#topic+connection">connection</a>
open for writing</p>
</td></tr>
<tr><td><code id="read_yaml_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>character string: if non-empty declares the
encoding used on a file (not a connection) so the character data can
be re-encoded.  See <code><a href="base.html#topic+file">file</a></code>.</p>
</td></tr>
<tr><td><code id="read_yaml_+3A_text">text</code></td>
<td>
<p>character string: if <code>file</code> is not supplied and this is,
then data are read from the value of <code>text</code> via a text connection.
Notice that a literal string can be used to include (small) data sets
within R code.</p>
</td></tr>
<tr><td><code id="read_yaml_+3A_error.label">error.label</code></td>
<td>
<p>a label to prepend to error messages (see Details).</p>
</td></tr>
<tr><td><code id="read_yaml_+3A_readlines.warn">readLines.warn</code></td>
<td>
<p>logical (default:TRUE) suppress warnings from readLines used inside read_yaml</p>
</td></tr>
<tr><td><code id="read_yaml_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="#topic+yaml.load">yaml.load</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenient wrapper for <code><a href="#topic+yaml.load">yaml.load</a></code> and is a
nicer alternative to <code><a href="#topic+yaml.load_file">yaml.load_file</a></code>.
</p>
<p>You can specify a label to be prepended to error messages via the
<code>error.label</code> argument.  If <code>error.label</code> is missing,
<code>read_yaml</code> will make an educated guess for the value of
<code>error.label</code> by either using the specified filename (when <code>file</code>
is a character vector) or using the description of the supplied connection
object (via the <code>summary</code> function).  If <code>text</code> is used, the
default value of <code>error.label</code> will be <code>NULL</code>.
</p>


<h3>Value</h3>

<p>If the root YAML object is a map, a named list or list with an attribute of 'keys' is
returned.  If the root object is a sequence, a list or vector is returned, depending
on the contents of the sequence.  A vector of length 1 is returned for single objects.
</p>


<h3>Author(s)</h3>

<p>Jeremy Stephens &lt;jeremy.f.stephens@vumc.org&gt;</p>


<h3>References</h3>

<p>YAML: http://yaml.org
</p>
<p>libyaml: https://pyyaml.org/wiki/LibYAML
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yaml.load">yaml.load</a></code>, <code><a href="#topic+write_yaml">write_yaml</a></code>, <code><a href="#topic+yaml.load_file">yaml.load_file</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # reading from a file connection
  filename &lt;- tempfile()
  cat("test: data\n", file = filename)
  con &lt;- file(filename, "r")
  read_yaml(con)
  close(con)

  # using a filename to specify input file
  read_yaml(filename)

## End(Not run)

  # reading from a character vector
  read_yaml(text="- hey\n- hi\n- hello")
</code></pre>

<hr>
<h2 id='verbatim_logical'>
Alternative logical handler
</h2><span id='topic+verbatim_logical'></span>

<h3>Description</h3>

<p>A yaml handler function that causes logical vectors to emit 
<code>true</code>/<code>false</code> instead of <code>yes</code>/<code>no</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbatim_logical(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verbatim_logical_+3A_x">x</code></td>
<td>

<p>logical vector to convert to <code>true</code>/<code>false</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pass this function to <code><a href="#topic+as.yaml">as.yaml()</a></code> as part of the
<code>handler</code> argument list like <code>list(logical = verbatim_logical)</code>.
</p>


<h3>Value</h3>

<p>Returns a vector of strings of either <code>true</code> or <code>false</code> of class
<code>verbatim</code>.
</p>


<h3>Author(s)</h3>

<p>Charles Dupont and James Goldie (jimjam-slam)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.yaml">as.yaml</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vector &lt;- c(TRUE, FALSE, TRUE)

as.yaml(vector, handlers=list(logical=verbatim_logical))
</code></pre>

<hr>
<h2 id='write_yaml'>Write a YAML file</h2><span id='topic+write_yaml'></span>

<h3>Description</h3>

<p>Write the YAML representation of an R object to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  write_yaml(x, file, fileEncoding = "UTF-8", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_yaml_+3A_x">x</code></td>
<td>
<p>the object to be converted</p>
</td></tr>
<tr><td><code id="write_yaml_+3A_file">file</code></td>
<td>
<p>either a character string naming a file or a <a href="base.html#topic+connection">connection</a>
open for writing</p>
</td></tr>
<tr><td><code id="write_yaml_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>character string: if non-empty declares the
encoding to be used on a file (not a connection) so the character data can
be re-encoded as they are written.  See <code><a href="base.html#topic+file">file</a></code>.</p>
</td></tr>
<tr><td><code id="write_yaml_+3A_...">...</code></td>
<td>
<p>arguments to <code><a href="#topic+as.yaml">as.yaml</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>file</code> is a non-open connection, an attempt is made to open it
and then close it after use.
</p>
<p>This function is a convenient wrapper around <code><a href="#topic+as.yaml">as.yaml</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jeremy Stephens &lt;jeremy.f.stephens@vumc.org&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.yaml">as.yaml</a></code>, <code><a href="#topic+read_yaml">read_yaml</a></code>, <code><a href="#topic+yaml.load_file">yaml.load_file</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # writing to a file connection
  filename &lt;- tempfile()
  con &lt;- file(filename, "w")
  write_yaml(data.frame(a=1:10, b=letters[1:10], c=11:20), con)
  close(con)

  # using a filename to specify output file
  write_yaml(data.frame(a=1:10, b=letters[1:10], c=11:20), filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='yaml.load'> Convert a YAML string into R objects </h2><span id='topic+yaml.load'></span><span id='topic+yaml.load_file'></span>

<h3>Description</h3>

<p>Parse a YAML string and return R objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  yaml.load(string, as.named.list = TRUE, handlers = NULL, error.label = NULL,
            eval.expr = getOption("yaml.eval.expr", FALSE),
            merge.precedence = c("order", "override"), merge.warning = FALSE)
  yaml.load_file(input, error.label, readLines.warn=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yaml.load_+3A_string">string</code></td>
<td>
<p> the YAML string to be parsed </p>
</td></tr>
<tr><td><code id="yaml.load_+3A_as.named.list">as.named.list</code></td>
<td>
<p> whether or not to return a named list for maps (TRUE by default) </p>
</td></tr>
<tr><td><code id="yaml.load_+3A_handlers">handlers</code></td>
<td>
<p> named list of custom handler functions for YAML types (see Details) </p>
</td></tr>
<tr><td><code id="yaml.load_+3A_input">input</code></td>
<td>
<p> a filename or connection; if <code>input</code> is a filename, that file must be encoded in UTF-8 </p>
</td></tr>
<tr><td><code id="yaml.load_+3A_error.label">error.label</code></td>
<td>
<p> a label to prepend to error messages (see Details) </p>
</td></tr>
<tr><td><code id="yaml.load_+3A_eval.expr">eval.expr</code></td>
<td>
<p> whether or not to evaluate expressions found in the YAML document (see Details) </p>
</td></tr>
<tr><td><code id="yaml.load_+3A_merge.precedence">merge.precedence</code></td>
<td>
<p> behavior of precedence during map merges (see Details) </p>
</td></tr>
<tr><td><code id="yaml.load_+3A_merge.warning">merge.warning</code></td>
<td>
<p> whether or not to warn about ignored key/value pairs during map merges </p>
</td></tr>
<tr><td><code id="yaml.load_+3A_readlines.warn">readLines.warn</code></td>
<td>
<p>logical (default:TRUE) suppress warnings from readLines used inside read_yaml</p>
</td></tr>
<tr><td><code id="yaml.load_+3A_...">...</code></td>
<td>
<p> arguments to pass to yaml.load </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>yaml.load</code> to load a YAML string.  For files and connections, use
<code>yaml.load_file</code>, which calls <code>yaml.load</code> with the contents of the specified
file or connection.
</p>
<p>Sequences of uniform data (e.g. a sequence of integers) are converted into vectors.  If
the sequence is not uniform, it's returned as a list. Maps are converted into named lists
by default, and all the keys in the map are converted to strings.  If you don't want the
keys to be coerced into strings, set <code>as.named.list</code> to FALSE.  When it's FALSE, a
list will be returned with an additional attribute named 'keys', which is a list of the
un-coerced keys in the map (in the same order as the main list).
</p>
<p>You can specify custom handler functions via the <code>handlers</code> argument.  This argument
must be a named list of functions, where the names are the YAML types (i.e., 'int', 'float',
'seq', etc).  The functions you provide will be passed one argument.  Custom
handler functions for string types (all types except sequence and map) will receive a
character vector of length 1.  Custom sequence functions will be passed a list of objects.
Custom map functions will be passed the object that the internal map handler creates, which
is either a named list or a list with a 'keys' attribute (depending on <code>as.named.list</code>).
ALL functions you provide must return an object.  See the examples for custom handler use.
</p>
<p>You can specify a label to be prepended to error messages via the
<code>error.label</code> argument.  When using <code>yaml.load_file</code>, you can
either set the <code>error.label</code> argument explicitly or leave it missing.
If missing, <code>yaml.load_file</code> will make an educated guess for the value
of <code>error.label</code> by either using the specified filename (when
<code>input</code> is a character vector) or using the description of the supplied
connection object (via the <code>summary</code> function).  You can explicity set
<code>error.label</code> to <code>NULL</code> if you don't want to use this functionality.
</p>
<p>There is a built-in handler that will evaluate expressions that are tagged
with the &lsquo;!expr&rsquo; tag.  Currently this handler is disabled by default
for security reasons.  If a &lsquo;!expr&rsquo; tag exists and this is set to
FALSE a warning will occur. Alternately, you can set the option named
&lsquo;yaml.eval.expr&rsquo; via the <code>options</code> function to turn on
evaluation.
</p>
<p>The <code>merge.precedence</code> parameter controls how merge keys are handled.
The YAML merge key specification is not specific about how key/value
conflicts are resolved during map merges.  As a result, various YAML library
implementations vary in merge key behavior (notably Python and Ruby).  This
package's default behavior (when <code>merge.precedence</code> is &lsquo;order&rsquo;)
is to give precedence to key/value pairs that appear first.  If you set
<code>merge.precedence</code> to &lsquo;override&rsquo;, natural map key/value pairs
will override any duplicate keys found in merged maps, regardless of order.
This is the default behavior in Python's YAML library.
</p>
<p>This function uses the YAML parser provided by libyaml, which conforms to the YAML 1.1
specification.
</p>


<h3>Value</h3>

<p>If the root YAML object is a map, a named list or list with an attribute of 'keys' is
returned.  If the root object is a sequence, a list or vector is returned, depending
on the contents of the sequence.  A vector of length 1 is returned for single objects.
</p>


<h3>Author(s)</h3>

<p> Jeremy Stephens &lt;jeremy.f.stephens@vumc.org&gt; </p>


<h3>References</h3>

<p>YAML: http://yaml.org
</p>
<p>libyaml: https://pyyaml.org/wiki/LibYAML
</p>
<p>YAML merge specification: http://yaml.org/type/merge.html
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.yaml">as.yaml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  yaml.load("- hey\n- hi\n- hello")
  yaml.load("foo: 123\nbar: 456")
  yaml.load("- foo\n- bar\n- 3.14")
  yaml.load("foo: bar\n123: 456", as.named.list = FALSE)

## Not run: 
  # reading from a file (uses readLines internally)
  filename &lt;- tempfile()
  cat("foo: 123", file=filename, sep="\n")
  yaml.load_file(filename)

## End(Not run)

  # custom scalar handler
  my.float.handler &lt;- function(x) { as.numeric(x) + 123 }
  yaml.load("123.456", handlers=list("float#fix"=my.float.handler))

  # custom sequence handler
  yaml.load("- 1\n- 2\n- 3", handlers=list(seq=function(x) { as.integer(x) + 3 }))

  # custom map handler
  yaml.load("foo: 123", handlers=list(map=function(x) { x$foo &lt;- x$foo + 123; x }))

  # handling custom types
  yaml.load("!sqrt 555", handlers=list(sqrt=function(x) { sqrt(as.integer(x)) }))
  yaml.load("!foo\n- 1\n- 2", handlers=list(foo=function(x) { as.integer(x) + 1 }))
  yaml.load("!bar\none: 1\ntwo: 2", handlers=list(bar=function(x) { x$one &lt;- "one"; x }))

  # loading R expressions
  # NOTE: this will not be done by default in the near future
  doc &lt;- yaml.load("inc: !expr function(x) x + 1", eval.expr=TRUE)
  doc$inc(1)

  # adding a label to error messages
  try(yaml.load("*", error.label = "foo"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
