<!DOCTYPE html><html><head><title>Help for package cmdfun</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cmdfun}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.check_valid_command_path'><p>Checks path is valid</p></a></li>
<li><a href='#.check_valid_util'><p>Checks for valid members of subdirectory</p></a></li>
<li><a href='#cmd_args_all'><p>Return all named arguments and arguments passed as dots from parent function call</p></a></li>
<li><a href='#cmd_args_dots'><p>return function dots from parent function as named list</p></a></li>
<li><a href='#cmd_args_named'><p>Return all named arguments from parent function call</p></a></li>
<li><a href='#cmd_error_if_missing'><p>Check that file(s) exist, error if not</p></a></li>
<li><a href='#cmd_file_combn'><p>Generates list of expected output files</p></a></li>
<li><a href='#cmd_file_expect'><p>Creates list of paths by file extension &amp; checks they exist</p></a></li>
<li><a href='#cmd_help_flags_similar'><p>Suggest alternative name by minimizing Levenshtein edit distance between valid and invalid arguments</p></a></li>
<li><a href='#cmd_help_flags_suggest'><p>Error &amp; Suggest different flag name to user</p></a></li>
<li><a href='#cmd_help_parse_flags'><p>Parses commandline help options to return vector of valid flag names</p></a></li>
<li><a href='#cmd_install_check'><p>Wrapper function for checking an install</p></a></li>
<li><a href='#cmd_install_is_valid'><p>Macro for constructing boolean check for valid path</p></a></li>
<li><a href='#cmd_list_drop'><p>Drop entries from list of flags by name, name/value pair, or index</p></a></li>
<li><a href='#cmd_list_drop_named'><p>Drop items by name from list</p></a></li>
<li><a href='#cmd_list_interp'><p>Convert list of function arguments to list of command flags</p></a></li>
<li><a href='#cmd_list_keep'><p>keep entries from list of flags by name, name/value pair, or index</p></a></li>
<li><a href='#cmd_list_keep_named'><p>Keep items by name from list</p></a></li>
<li><a href='#cmd_list_to_flags'><p>Convert flag list to vector of command flags</p></a></li>
<li><a href='#cmd_path_search'><p>Macro for constructing target path validators</p></a></li>
<li><a href='#cmd_ui_file_exists'><p>Checks if file exists, returns pretty status message</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Framework for Building Interfaces to Shell Commands</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Writing interfaces to command line software is cumbersome. 
    'cmdfun' provides a framework for building function calls to seamlessly 
    interface with shell commands by allowing lazy evaluation of command line arguments. 
    'cmdfun' also provides methods for handling user-specific paths to tool installs or secrets like API keys. 
    Its focus is to equally serve package builders who wish to wrap command line software, and to help analysts stay inside 
    R when they might usually leave to execute non-R software.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, purrr, R.utils, rlang, testthat, usethis, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cli, covr, knitr, processx, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://snystrom.github.io/cmdfun/">https://snystrom.github.io/cmdfun/</a>,
<a href="https://github.com/snystrom/cmdfun">https://github.com/snystrom/cmdfun</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/snystrom/cmdfun">https://github.com/snystrom/cmdfun</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-02 14:16:21 UTC; snystrom</td>
</tr>
<tr>
<td>Author:</td>
<td>Spencer Nystrom <a href="https://orcid.org/0000-0003-1000-1579"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Spencer Nystrom &lt;nystromdev@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-10 09:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='.check_valid_command_path'>Checks path is valid</h2><span id='topic+.check_valid_command_path'></span>

<h3>Description</h3>

<p>Not meant to be called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_valid_command_path(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_valid_command_path_+3A_path">path</code></td>
<td>
<p>path to file or directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expanded system path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type == "unix" &amp; file.exists("~/bin")) {
# will return /full/path/to/home/bin, or error if path doesn't exist
.check_valid_command_path("~/bin")
}
</code></pre>

<hr>
<h2 id='.check_valid_util'>Checks for valid members of subdirectory</h2><span id='topic+.check_valid_util'></span>

<h3>Description</h3>

<p>Not meant to be called directly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_valid_util(util, utils = NULL, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_valid_util_+3A_util">util</code></td>
<td>
<p>name of target located in path</p>
</td></tr>
<tr><td><code id=".check_valid_util_+3A_utils">utils</code></td>
<td>
<p>name of supported targets in path</p>
</td></tr>
<tr><td><code id=".check_valid_util_+3A_path">path</code></td>
<td>
<p>path to directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>safe path to util, or error if util does not exist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type == "unix") {
# this will return /full/path/to/bin
# or return an error for all values of util that are not "ls" and "pwd"
# or error if "ls" does not exist in "/bin"
.check_valid_util("ls", utils = c("ls", "pwd"), "/bin")

## Not run: 
# This will throw error
.check_valid_util("badUtil", utils = c("ls", "pwd"), "/bin")

## End(Not run)
}
</code></pre>

<hr>
<h2 id='cmd_args_all'>Return all named arguments and arguments passed as dots from parent function call</h2><span id='topic+cmd_args_all'></span>

<h3>Description</h3>

<p>Return all named arguments and arguments passed as dots from parent function call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_args_all(keep = NULL, drop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_args_all_+3A_keep">keep</code></td>
<td>
<p>name of arguments to keep</p>
</td></tr>
<tr><td><code id="cmd_args_all_+3A_drop">drop</code></td>
<td>
<p>name of arguments to drop (NOTE: keep or drop are mutually exclusive settings)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of all arguments passed to parent
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theFunction &lt;- function(arg1, ...) { cmd_args_all() }
theArgs &lt;-  theFunction(arg1 = "test", example = "hello")
</code></pre>

<hr>
<h2 id='cmd_args_dots'>return function dots from parent function as named list</h2><span id='topic+cmd_args_dots'></span>

<h3>Description</h3>

<p>return function dots from parent function as named list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_args_dots(keep = NULL, drop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_args_dots_+3A_keep">keep</code></td>
<td>
<p>name of arguments to keep</p>
</td></tr>
<tr><td><code id="cmd_args_dots_+3A_drop">drop</code></td>
<td>
<p>name of arguments to drop (NOTE: keep or drop are mutually exclusive settings)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of kwargs from ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theFunction &lt;- function(...) { cmd_args_dots() }
theDots &lt;-  theFunction(example = "hello", boolFlag = TRUE, vectorFlag = c(1,2,3))
</code></pre>

<hr>
<h2 id='cmd_args_named'>Return all named arguments from parent function call</h2><span id='topic+cmd_args_named'></span>

<h3>Description</h3>

<p>Return all named arguments from parent function call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_args_named(keep = NULL, drop = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_args_named_+3A_keep">keep</code></td>
<td>
<p>name of arguments to keep</p>
</td></tr>
<tr><td><code id="cmd_args_named_+3A_drop">drop</code></td>
<td>
<p>name of arguments to drop (NOTE: keep or drop are mutually exclusive settings)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of all defined function arguments from parent
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theFunction &lt;- function(arg1, ...) { cmd_args_named() }
theNamedArgs &lt;-  theFunction(arg1 = "test", example = "hello")
</code></pre>

<hr>
<h2 id='cmd_error_if_missing'>Check that file(s) exist, error if not</h2><span id='topic+cmd_error_if_missing'></span>

<h3>Description</h3>

<p>Check that file(s) exist, error if not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_error_if_missing(files)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_error_if_missing_+3A_files">files</code></td>
<td>
<p>list or vector of paths to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing or error message for each missing file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmd_error_if_missing(tempdir())
## Not run: 
# Throws error if file doesn't exist
cmd_error_if_missing(file.path(tempdir(), "notreal"))

## End(Not run)
</code></pre>

<hr>
<h2 id='cmd_file_combn'>Generates list of expected output files</h2><span id='topic+cmd_file_combn'></span>

<h3>Description</h3>

<p>See documentation of cmd_file_expect() for more details about how this works
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_file_combn(prefix, ext, outdir = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_file_combn_+3A_prefix">prefix</code></td>
<td>
<p>file name to be given each ext. If a character vector, must be equal length of ext or shorter</p>
</td></tr>
<tr><td><code id="cmd_file_combn_+3A_ext">ext</code></td>
<td>
<p>file extension (no &quot;.&quot;, ie &quot;txt&quot;, &quot;html&quot;)</p>
</td></tr>
<tr><td><code id="cmd_file_combn_+3A_outdir">outdir</code></td>
<td>
<p>optional directory where files should exist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of file paths by each ext or prefix (whichever is longer)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Makes list for many file types of same prefix
# ie myFile.txt, myFile.html, myFile.xml
cmd_file_combn("myFile", c("txt", "html", "xml"))

# Makes list for many files of same type
# ie myFile1.txt, myFile2.txt, myFile3.txt
cmd_file_combn(c("myFile1", "myFile2", "myFile3"), "txt")

</code></pre>

<hr>
<h2 id='cmd_file_expect'>Creates list of paths by file extension &amp; checks they exist</h2><span id='topic+cmd_file_expect'></span>

<h3>Description</h3>

<p>Ext or prefix can be a vector or single character. The shorter value will be
propagated across all values of the other. See Examples for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_file_expect(prefix, ext, outdir = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_file_expect_+3A_prefix">prefix</code></td>
<td>
<p>name of file prefix for each extension.</p>
</td></tr>
<tr><td><code id="cmd_file_expect_+3A_ext">ext</code></td>
<td>
<p>vector of file extensions</p>
</td></tr>
<tr><td><code id="cmd_file_expect_+3A_outdir">outdir</code></td>
<td>
<p>directory the files will be inside</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If files are not found, throws an error
</p>


<h3>Value</h3>

<p>vector of valid file paths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Expects many file types of same prefix
# ie myFile.txt, myFile.html, myFile.xml
cmd_file_expect("myFile", c("txt", "html", "xml"))

# Expects many files of same type
# ie myFile1.txt, myFile2.txt, myFile3.txt
cmd_file_expect(c("myFile1", "myFile2", "myFile3"), "txt")

# Expects many files with each prefix and each extension
# ie myFile1.txt, myFile1.html, myFile2.txt, myFile2.html
cmd_file_expect(c("myFile1", "myFile2"), c("txt", "html"))


## End(Not run)


</code></pre>

<hr>
<h2 id='cmd_help_flags_similar'>Suggest alternative name by minimizing Levenshtein edit distance between valid and invalid arguments</h2><span id='topic+cmd_help_flags_similar'></span>

<h3>Description</h3>

<p>Suggest alternative name by minimizing Levenshtein edit distance between valid and invalid arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_help_flags_similar(
  command_flag_names,
  flags,
  .fun = NULL,
  distance_cutoff = 3L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_help_flags_similar_+3A_command_flag_names">command_flag_names</code></td>
<td>
<p>character vector of valid names (can be output of <code><a href="#topic+cmd_help_parse_flags">cmd_help_parse_flags</a></code>)</p>
</td></tr>
<tr><td><code id="cmd_help_flags_similar_+3A_flags">flags</code></td>
<td>
<p>a vector names correspond to values to be checked against <code>command_flag_names</code></p>
</td></tr>
<tr><td><code id="cmd_help_flags_similar_+3A_.fun">.fun</code></td>
<td>
<p>optional function to apply to <code>command_flag_names</code> and <code>flags</code>
before checking their values. If using a function to rename flags after
<code>cmd_list_interp</code>, use that same function here. Can be useful for parsing help
lines into R-friendly variable names for user-convenience. Can be function
or <code>rlang</code>-style formula definition (ie <code>.fun = ~{foo(.x)}</code> is the same as
<code>.fun = function(x){foo(x)}</code>). Note: if command_flag_names need additional
parsing after <code><a href="#topic+cmd_help_parse_flags">cmd_help_parse_flags</a></code>, it is best to do that
preprocessing before passing them to this function.</p>
</td></tr>
<tr><td><code id="cmd_help_flags_similar_+3A_distance_cutoff">distance_cutoff</code></td>
<td>
<p>Levenshtein edit distance beyond which to suggest
??? instead of most similar argument (default = 3). Setting this too
liberally will result in nonsensical suggestions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector where names are names from <code>flags</code> and their values are the suggested best match from <code>command_flag_names</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># with a flagsList, need to pass names()
flagsList &lt;- list("output" = "somevalue", "missplld" = "anotherValue")
cmd_help_flags_similar(c("output", "misspelled"), names(flagsList))

command_flags &lt;- c("long-flag-name")
flags &lt;- c("long_flag_naee")
cmd_help_flags_similar(command_flags, flags, .fun = ~{gsub("-", "_", .x)})

# returns NULL if no errors
cmd_help_flags_similar(c("test"), "test")
</code></pre>

<hr>
<h2 id='cmd_help_flags_suggest'>Error &amp; Suggest different flag name to user</h2><span id='topic+cmd_help_flags_suggest'></span>

<h3>Description</h3>

<p>Error &amp; Suggest different flag name to user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_help_flags_suggest(suggest_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_help_flags_suggest_+3A_suggest_names">suggest_names</code></td>
<td>
<p>named character vector, names correspond to original
value, values correspond to suggested replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>error message suggesting alternatives to user
</p>


<h3>Examples</h3>

<pre><code class='language-R'>user_flags &lt;- list("output", "inpt")
valid_flags &lt;- c("output", "input")
suggestions &lt;- cmd_help_flags_similar(valid_flags, user_flags)
## Not run: 
# Throws error
cmd_help_flags_suggest(suggestions)

## End(Not run)
</code></pre>

<hr>
<h2 id='cmd_help_parse_flags'>Parses commandline help options to return vector of valid flag names</h2><span id='topic+cmd_help_parse_flags'></span>

<h3>Description</h3>

<p>When using cmdfun to write lazy shell wrappers, the user can easily mistype
a commandline flag since there is not text completion. Some programs behave
unexpectedly when flags are typed incorrectly, and for this reason return uninformative error messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_help_parse_flags(help_lines, split_newline = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_help_parse_flags_+3A_help_lines">help_lines</code></td>
<td>
<p><code>character</code> vector containing the output of &quot;command
&ndash;help&quot;, or similar output. Optional: pass either <code>stdout</code>, or <code>stderr</code> output from
processx::run(), must set <code>processx = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cmd_help_parse_flags_+3A_split_newline">split_newline</code></td>
<td>
<p><code>logical(1)</code> if set to TRUE will split string on &quot;\n&quot; before
parsing (useful when parsing output from <code>processx</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cmd_help_parse_flags</code> tries to grab flags from &ndash;help documentation which
can be used for error checking. It will try to parse flags following &quot;-&quot; or
&quot;&ndash;&quot; while ignoring hyphenated words in help text. Although this should cover
most use-cases, it may be necessary to write a custom help-text parser for
nonstandard tools. Inspect this output <strong>carefully</strong> before proceeding. Most
often, characters are leftover at the <strong>end</strong> of parsed names, which will
require additional parsing.
</p>


<h3>Value</h3>

<p>character vector of flag names parsed from help text
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmd_help_flags_similar">cmd_help_flags_similar</a></code> <code><a href="#topic+cmd_help_flags_suggest">cmd_help_flags_suggest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type == "unix" &amp; file.exists("/bin/tar")) {
# below are two examples parsing the --help method of GNU tar 

# with processx
if (require(processx)) {
out &lt;- processx::run("tar", "--help", error_on_status = FALSE)
fn_flags &lt;- cmd_help_parse_flags(out$stdout, split_newline = TRUE)
}

# with system2
lines &lt;- system2("tar", "--help", stderr = TRUE)
fn_flags &lt;- cmd_help_parse_flags(lines)

# NOTE: some of the "tar" flags contain the extra characters: "\[", "\)", and ";"
# ie "one-top-level\[" which should be "one-top-level"
# These can be additionally parsed using
gsub("[\\[;\\)]", "", fn_flags)
}

</code></pre>

<hr>
<h2 id='cmd_install_check'>Wrapper function for checking an install</h2><span id='topic+cmd_install_check'></span>

<h3>Description</h3>

<p>This function can be lightly wrapped by package builders to build a user-friendly install checking function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_install_check(path_search, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_install_check_+3A_path_search">path_search</code></td>
<td>
<p><code>function</code> output of <code>cmd_path_search()</code></p>
</td></tr>
<tr><td><code id="cmd_install_check_+3A_path">path</code></td>
<td>
<p>user-override path to check (identical to <code>path</code> argument of <code>cmd_path_search()</code> output)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pretty printed message indicating whether files exits or not. Green check = Yes, red X = No.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
path_search &lt;- cmd_path_search(default = "/bin", utils = "ls")
cmd_install_check(path_search)

## End(Not run)
</code></pre>

<hr>
<h2 id='cmd_install_is_valid'>Macro for constructing boolean check for valid path</h2><span id='topic+cmd_install_is_valid'></span>

<h3>Description</h3>

<p>Macro for constructing boolean check for valid path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_install_is_valid(path_search, util = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_install_is_valid_+3A_path_search">path_search</code></td>
<td>
<p>function output of <code>cmd_path_search()</code> <strong>NOTE:</strong> When
passing the function, do not pass as: <code>fun()</code>, but <code>fun</code> to avoid evaluation.</p>
</td></tr>
<tr><td><code id="cmd_install_is_valid_+3A_util">util</code></td>
<td>
<p>value to pass to <code>util</code> argument of <code>path_search</code>, allows
building individual functions for each util (if passing one of each),
or for simultaneously checking all utils if setting <code>util = TRUE</code>. Will
cause error if <code>util = TRUE</code> but no utils are defined. <strong>NOTE:</strong> There is
no error checking for whether <code>util</code> is set correctly during the build
process, so ensure correct spelling, etc. to avoid cryptic failures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function returning TRUE or FALSE if a valid install is detected.
With arguments: <code>path</code> (a path to install location), <code>util</code> an optional <code>character(1)</code> to
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type == "unix") {
search &lt;- cmd_path_search(option_name = "bin_path", default_path = "/bin/")
valid_install &lt;- cmd_install_is_valid(search)
# Returns TRUE if "/bin/" exists
valid_install()
# Returns FALSE if "bad/path/" doesn't exist
valid_install("bad/path/")

# Also works with options
search_option_only &lt;- cmd_path_search(option_name = "bin_path")
valid_install2 &lt;- cmd_install_is_valid(search_option_only)
options(bin_path = "/bin/")
valid_install2()

# Setting util = TRUE will check that all utils are also installed
search_with_utils &lt;- cmd_path_search(default_path = "/bin", utils = c("ls", "pwd"))
valid_install_all &lt;- cmd_install_is_valid(search_with_utils, util = TRUE)
valid_install_all()
}
</code></pre>

<hr>
<h2 id='cmd_list_drop'>Drop entries from list of flags by name, name/value pair, or index</h2><span id='topic+cmd_list_drop'></span>

<h3>Description</h3>

<p>Drop entries from list of flags by name, name/value pair, or index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_list_drop(flags, drop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_list_drop_+3A_flags">flags</code></td>
<td>
<p>named list output of cmd_list_interp</p>
</td></tr>
<tr><td><code id="cmd_list_drop_+3A_drop">drop</code></td>
<td>
<p>vector of flag entries to drop. Pass a character vector
to drop flags by name. Pass a named vector to drop flags by name/value
pairs. Pass a numeric vector to drop by position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>flags list with values in drop removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exFlags &lt;- list("flag1" = 2, "flag2" = "someText")
cmd_list_drop(exFlags, "flag1")
# will drop flag2 because its name and value match 'drop' vector
cmd_list_drop(exFlags, c("flag2" = "someText"))
# Will drop "flag1" by position index
cmd_list_drop(exFlags, 1)

# won't drop flag2 because its value isn't 'someText'
exFlags2 &lt;- list("flag1" = 2, "flag2" = "otherText")
cmd_list_drop(exFlags, c("flag2" = "someText"))
</code></pre>

<hr>
<h2 id='cmd_list_drop_named'>Drop items by name from list</h2><span id='topic+cmd_list_drop_named'></span>

<h3>Description</h3>

<p>A pipe-friendly wrapper around <code>list[!(names(list) %in% names)]</code>
This function is slightly faster than using <code><a href="#topic+cmd_list_drop">cmd_list_drop()</a></code> to drop items
by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_list_drop_named(list, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_list_drop_named_+3A_list">list</code></td>
<td>
<p>an R list</p>
</td></tr>
<tr><td><code id="cmd_list_drop_named_+3A_names">names</code></td>
<td>
<p>vector of names to drop</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list removing items defined by names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmd_list_drop_named(list("a" = 1, "b" = 2), "a")
</code></pre>

<hr>
<h2 id='cmd_list_interp'>Convert list of function arguments to list of command flags</h2><span id='topic+cmd_list_interp'></span>

<h3>Description</h3>

<p>Function also handles error checking to ensure args contain valid data types,
and looks for common usage mistakes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_list_interp(args, flag_lookup = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_list_interp_+3A_args">args</code></td>
<td>
<p>named list output from get*Args family of functions.</p>
</td></tr>
<tr><td><code id="cmd_list_interp_+3A_flag_lookup">flag_lookup</code></td>
<td>
<p>optional named vector used to convert args to command flags</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list structure is more amenable to manipulation by package developers for
advanced use before evaluating them to the command flags vector with
cmd_list_to_flags().
</p>


<h3>Value</h3>

<p>named list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theFunction &lt;- function(...){cmd_args_all()}
theArgs &lt;- theFunction(arg1 = "value", arg2 = TRUE)
flagList &lt;- cmd_list_interp(theArgs)
flags &lt;- cmd_list_to_flags(flagList)
</code></pre>

<hr>
<h2 id='cmd_list_keep'>keep entries from list of flags by name, name/value pair, or index</h2><span id='topic+cmd_list_keep'></span>

<h3>Description</h3>

<p>keep entries from list of flags by name, name/value pair, or index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_list_keep(flags, keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_list_keep_+3A_flags">flags</code></td>
<td>
<p>named list output of cmd_list_interp</p>
</td></tr>
<tr><td><code id="cmd_list_keep_+3A_keep">keep</code></td>
<td>
<p>vector of flag entries to keep. Pass a character vector
to keep flags by name. Pass a named vector to keep flags by name/value
pairs. Pass a numeric vector to keep by position.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>flags list with values not in keep removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exFlags &lt;- list("flag1" = 2, "flag2" = "someText")
cmd_list_keep(exFlags, "flag1")
# will keep flag2 because its name and value match 'keep' vector
cmd_list_keep(exFlags, c("flag2" = "someText"))
# Will keep "flag1" by position index
cmd_list_keep(exFlags, 1)

# won't keep flag2 because its value isn't 'someText'
exFlags2 &lt;- list("flag1" = 2, "flag2" = "otherText")
cmd_list_keep(exFlags, c("flag2" = "someText"))
</code></pre>

<hr>
<h2 id='cmd_list_keep_named'>Keep items by name from list</h2><span id='topic+cmd_list_keep_named'></span>

<h3>Description</h3>

<p>A pipe-friendly wrapper around <code style="white-space: pre;">&#8288;list[(names(list) %in% names]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_list_keep_named(list, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_list_keep_named_+3A_list">list</code></td>
<td>
<p>an R list</p>
</td></tr>
<tr><td><code id="cmd_list_keep_named_+3A_names">names</code></td>
<td>
<p>vector of names to keep</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is slightly faster than using <code><a href="#topic+cmd_list_keep">cmd_list_keep()</a></code> to keep items
by name.
</p>


<h3>Value</h3>

<p>list keeping only items defined by names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmd_list_keep_named(list("a" = 1, "b" = 2), "a")
</code></pre>

<hr>
<h2 id='cmd_list_to_flags'>Convert flag list to vector of command flags</h2><span id='topic+cmd_list_to_flags'></span>

<h3>Description</h3>

<p>Convert flag list to vector of command flags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_list_to_flags(flagList, prefix = "-", sep = ",")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_list_to_flags_+3A_flaglist">flagList</code></td>
<td>
<p>output from cmd_list_interp(). A named list where names
correspond to flags and members correspond to the value for the flag.</p>
</td></tr>
<tr><td><code id="cmd_list_to_flags_+3A_prefix">prefix</code></td>
<td>
<p>flag prefix, usually &quot;-&quot; or &quot;&ndash;&quot;.</p>
</td></tr>
<tr><td><code id="cmd_list_to_flags_+3A_sep">sep</code></td>
<td>
<p>separator to use if flag has a vector of values (default: NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of parsed commandline flags followed by their values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theFunction &lt;- function(...){cmd_args_all()}
theArgs &lt;- theFunction(arg1 = "value", arg2 = TRUE)
flagList &lt;- cmd_list_interp(theArgs)
flags &lt;- cmd_list_to_flags(flagList)
</code></pre>

<hr>
<h2 id='cmd_path_search'>Macro for constructing target path validators</h2><span id='topic+cmd_path_search'></span>

<h3>Description</h3>

<p>A common pattern in designing shell interfaces is to ask the user to give an
absolute path to the target shell utility. It is common to pass this
information from the user to R by using either R environment variables
defined in .Renviron, using options (set with option(), and got with
getOption()), having the user explicitly pass the path in the function call,
or failing this, using a default install path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_path_search(
  environment_var = NULL,
  option_name = NULL,
  default_path = NULL,
  utils = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_path_search_+3A_environment_var">environment_var</code></td>
<td>
<p>name of R environment variable defining target path. Can be set in .Renviron.</p>
</td></tr>
<tr><td><code id="cmd_path_search_+3A_option_name">option_name</code></td>
<td>
<p>name of user-configurable option (called by getOption) which will hold path to target</p>
</td></tr>
<tr><td><code id="cmd_path_search_+3A_default_path">default_path</code></td>
<td>
<p>default install path of target. Can contain shell
specials like &quot;~&quot; which will be expanded at runtime (as opposed to build time of the search function).</p>
</td></tr>
<tr><td><code id="cmd_path_search_+3A_utils">utils</code></td>
<td>
<p>optional character vector containing names of valid utils inside
target path, used to populate error checking for valid install.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Another common use-case involves software packages with many tools packaged
in a single directory, and the user may want to call one or many utilities
within this common structure.
</p>
<p>For example, the software &quot;coolpackage&quot; is installed in &quot;~/coolpackage&quot;, and
has two programs: &quot;tool1&quot;, and &quot;tool2&quot; found in &quot;~/coolpackage/tool1&quot; and
~/coolpackage/tool2&quot;, respectively.
</p>
<p>To design an interface to coolpackage, this function can automate checking
and validation for not only the package, but for each desired utility in the
package.
</p>
<p>The hierarchy of path usage is: user-defined &gt; option_name &gt; environment_var &gt; default_path
</p>


<h3>Value</h3>

<p>function that returns a valid path to tool or optional utility.
</p>
<p>The returned path_search function takes as input a path or util. where path
is a user override path for the supported tool. If the user-defined path is
invalid, this will always throw an error and not search the defined defaults.
</p>
<p>util must be found within the target path, but does not have to be present in
the original &quot;utils&quot; call. The user will be warned if this is the case. If
<code>util</code> is set to <code>TRUE</code> will return all paths to utilities without checking
the install. This can be used for writing user-facing install checkers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (.Platform$OS.type == "unix") {
bin_checker &lt;- cmd_path_search(default_path = "/bin", utils = c("ls", "pwd"))
# returns path to bin
bin_checker()
# returns path to bin/ls
bin_checker(util = "ls")
}
</code></pre>

<hr>
<h2 id='cmd_ui_file_exists'>Checks if file exists, returns pretty status message</h2><span id='topic+cmd_ui_file_exists'></span>

<h3>Description</h3>

<p>Checks if file exists, returns pretty status message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmd_ui_file_exists(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmd_ui_file_exists_+3A_file">file</code></td>
<td>
<p>path to file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ui_done or ui_oops printed to terminal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cmd_ui_file_exists("/path/to/file.txt")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
