<!DOCTYPE html><html><head><title>Help for package datetimeoffset</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {datetimeoffset}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_datetimeoffset'><p>Coerce to &quot;datetimeoffset&quot; objects</p></a></li>
<li><a href='#datetime_at_tz'><p>Change time zones while preserving UTC time</p></a></li>
<li><a href='#datetime_cast'><p>Widen/narrow datetime precision</p></a></li>
<li><a href='#datetime_precision'><p>Datetime precision</p></a></li>
<li><a href='#datetimeoffset'><p>Datetime object with optional UTC offsets and/or timezones</p></a></li>
<li><a href='#datetimeoffset_utilities'><p>Various &quot;datetimeoffset&quot; object utilities</p></a></li>
<li><a href='#datetimeoffset-invalid'><p>Invalid datetimeoffset datetimes</p></a></li>
<li><a href='#fill_tz'><p>Fill in missing time zones and/or UTC offsets</p></a></li>
<li><a href='#format'><p>Convert datetime objects to character</p></a></li>
<li><a href='#from_datetimeoffset'><p>Convert to other datetime objects</p></a></li>
<li><a href='#getset_utc_offsets'><p>Get/set UTC offset strings</p></a></li>
<li><a href='#getters'><p>Get datetime components</p></a></li>
<li><a href='#mode_tz'><p>Get most common time zone</p></a></li>
<li><a href='#setters'><p>Set datetime components</p></a></li>
<li><a href='#subsecond'><p>Subsecond helper getter/setter</p></a></li>
<li><a href='#weekdays.datetimeoffset'><p>Additional datetime extractors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Datetimes with Optional UTC Offsets and/or Heterogeneous Time
Zones</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Supports import/export for a number of datetime string standards 
    and R datetime classes often including
    lossless re-export of     
    any original reduced precision including 'ISO 8601' <a href="https://en.wikipedia.org/wiki/ISO_8601">https://en.wikipedia.org/wiki/ISO_8601</a> and 
    'pdfmark' <a href="https://opensource.adobe.com/dc-acrobat-sdk-docs/library/pdfmark/">https://opensource.adobe.com/dc-acrobat-sdk-docs/library/pdfmark/</a> datetime strings.
    Supports local/global datetimes with optional UTC offsets and/or (possibly heterogeneous) time zones
    with up to nanosecond precision.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://trevorldavis.com/R/datetimeoffset/dev/">https://trevorldavis.com/R/datetimeoffset/dev/</a>,
<a href="https://github.com/trevorld/r-datetimeoffset">https://github.com/trevorld/r-datetimeoffset</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trevorld/r-datetimeoffset">https://github.com/trevorld/r-datetimeoffset</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>clock, methods, purrr (&ge; 1.0.0), vctrs (&ge; 0.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lubridate (&ge; 1.9.0), nanotime (&ge; 0.3.7), knitr, parttime,
rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-11 04:03:57 UTC; trevorld</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor L Davis <a href="https://orcid.org/0000-0001-6341-4639"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor L Davis &lt;trevor.l.davis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-11 05:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_datetimeoffset'>Coerce to &quot;datetimeoffset&quot; objects</h2><span id='topic+as_datetimeoffset'></span><span id='topic+as_datetimeoffset.datetimeoffset'></span><span id='topic+as_datetimeoffset.Date'></span><span id='topic+as_datetimeoffset.default'></span><span id='topic+as_datetimeoffset.integer'></span><span id='topic+as_datetimeoffset.numeric'></span><span id='topic+as_datetimeoffset.POSIXt'></span><span id='topic+as_datetimeoffset.character'></span><span id='topic+as_datetimeoffset.nanotime'></span><span id='topic+as_datetimeoffset.partial_time'></span><span id='topic+as_datetimeoffset.clock_year_month_day'></span><span id='topic+as_datetimeoffset.clock_year_month_weekday'></span><span id='topic+as_datetimeoffset.clock_iso_year_week_day'></span><span id='topic+as_datetimeoffset.clock_year_quarter_day'></span><span id='topic+as_datetimeoffset.clock_year_day'></span><span id='topic+as_datetimeoffset.clock_naive_time'></span><span id='topic+as_datetimeoffset.clock_sys_time'></span><span id='topic+as_datetimeoffset.clock_zoned_time'></span>

<h3>Description</h3>

<p><code>as_datetimeoffset()</code> coerces to <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_datetimeoffset(x, ...)

## S3 method for class 'datetimeoffset'
as_datetimeoffset(x, ...)

## S3 method for class 'Date'
as_datetimeoffset(x, tz = NA_character_, ...)

## Default S3 method:
as_datetimeoffset(x, ...)

## S3 method for class 'integer'
as_datetimeoffset(x, ...)

## S3 method for class 'numeric'
as_datetimeoffset(x, ...)

## S3 method for class 'POSIXt'
as_datetimeoffset(x, ...)

## S3 method for class 'character'
as_datetimeoffset(x, tz = NA_character_, ...)

## S3 method for class 'nanotime'
as_datetimeoffset(x, tz = "GMT", ...)

## S3 method for class 'partial_time'
as_datetimeoffset(x, ...)

## S3 method for class 'clock_year_month_day'
as_datetimeoffset(x, ...)

## S3 method for class 'clock_year_month_weekday'
as_datetimeoffset(x, ...)

## S3 method for class 'clock_iso_year_week_day'
as_datetimeoffset(x, ...)

## S3 method for class 'clock_year_quarter_day'
as_datetimeoffset(x, ...)

## S3 method for class 'clock_year_day'
as_datetimeoffset(x, ...)

## S3 method for class 'clock_naive_time'
as_datetimeoffset(x, ...)

## S3 method for class 'clock_sys_time'
as_datetimeoffset(x, ...)

## S3 method for class 'clock_zoned_time'
as_datetimeoffset(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_datetimeoffset_+3A_x">x</code></td>
<td>
<p>An R object that can reasonably be coerced to a <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> object
such as a string in pdfmark date or ISO 8601 datetime formats
or something with an <code><a href="base.html#topic+as.POSIXct">as.POSIXct()</a></code> method.</p>
</td></tr>
<tr><td><code id="as_datetimeoffset_+3A_...">...</code></td>
<td>
<p>Further arguments to certain methods.</p>
</td></tr>
<tr><td><code id="as_datetimeoffset_+3A_tz">tz</code></td>
<td>
<p>Time zone to use for the conversion.
Ignored by <code>as_datetimeoffset.Date()</code>.
Generally need not be a single value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ISO 8601 examples
as_datetimeoffset("2020-05-15")
as_datetimeoffset("20200515")
as_datetimeoffset("2020-05-15T08:23:16")
as_datetimeoffset("20200515T082316")
as_datetimeoffset("2020-05-15T08:23:16.003Z")
as_datetimeoffset("20200515T082316Z")
as_datetimeoffset("2020-05-15T08:23:16+03:30")
as_datetimeoffset("20200515T082316+0330")

# Misc supported `as.POSIXlt()` `tryFormats` examples
as_datetimeoffset("2020/05/15 08:23:16")

# pdfmark datetime examples
as_datetimeoffset("D:20200515")
as_datetimeoffset("D:20200515082316")
as_datetimeoffset("D:20200515082316+03'30'")

as_datetimeoffset(Sys.time())
</code></pre>

<hr>
<h2 id='datetime_at_tz'>Change time zones while preserving UTC time</h2><span id='topic+datetime_at_tz'></span><span id='topic+datetime_at_tz.datetimeoffset'></span><span id='topic+datetime_at_tz.clock_zoned_time'></span><span id='topic+datetime_at_tz.POSIXt'></span><span id='topic+datetime_at_tz.default'></span>

<h3>Description</h3>

<p><code>datetime_at_tz()</code> changes time zones while preserving UTC time (instead of clock time).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datetime_at_tz(x, tz = "", ...)

## S3 method for class 'datetimeoffset'
datetime_at_tz(
  x,
  tz = "",
  ...,
  ambiguous = "error",
  nonexistent = "error",
  fill = NA_character_
)

## S3 method for class 'clock_zoned_time'
datetime_at_tz(x, tz = "", ...)

## S3 method for class 'POSIXt'
datetime_at_tz(x, tz = "", ...)

## Default S3 method:
datetime_at_tz(x, tz = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datetime_at_tz_+3A_x">x</code></td>
<td>
<p>A datetime object.</p>
</td></tr>
<tr><td><code id="datetime_at_tz_+3A_tz">tz</code></td>
<td>
<p>The target timezone to change to.</p>
</td></tr>
<tr><td><code id="datetime_at_tz_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="datetime_at_tz_+3A_ambiguous">ambiguous</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone is ambiguous.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
<tr><td><code id="datetime_at_tz_+3A_nonexistent">nonexistent</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone doesn't exist.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
<tr><td><code id="datetime_at_tz_+3A_fill">fill</code></td>
<td>
<p>If timezone and UTC offset info is missing what
timezone to assume.  See <code><a href="#topic+fill_tz">fill_tz()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A datetime object.  The UTC time should be the same but with a different time zone.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_tz">set_tz()</a></code> changes time zones while preserving clock time (instead of UTC time).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(all(c("America/Los_Angeles", "America/New_York") %in% OlsonNames())) {
  dt0 &lt;- as_datetimeoffset("2020-01-01T01:01[America/Los_Angeles]")
  dt &lt;- datetime_at_tz(dt0, "America/New_York")
  print(dt)
  dt &lt;- datetime_at_tz(as.POSIXct(dt0), "America/New_York")
  print(dt)
  dt &lt;- datetime_at_tz(clock::as_zoned_time(dt0), "America/New_York")
  print(dt)

  # Can also use `lubridate::with_tz()`
  if (requireNamespace("lubridate")) {
    dt &lt;- lubridate::with_tz(dt0, "America/New_York")
    print(dt)
  }
}
</code></pre>

<hr>
<h2 id='datetime_cast'>Widen/narrow datetime precision</h2><span id='topic+datetime_cast'></span><span id='topic+datetime_narrow'></span><span id='topic+datetime_narrow.datetimeoffset'></span><span id='topic+datetime_narrow.clock_calendar'></span><span id='topic+datetime_narrow.clock_time_point'></span><span id='topic+datetime_narrow.POSIXt'></span><span id='topic+datetime_widen'></span><span id='topic+datetime_widen.datetimeoffset'></span><span id='topic+datetime_widen.clock_calendar'></span><span id='topic+datetime_widen.clock_time_point'></span><span id='topic+datetime_widen.POSIXt'></span><span id='topic+datetime_cast.default'></span>

<h3>Description</h3>

<p><code>datetime_widen()</code> sets a floor on the minimum &quot;precision&quot; in the datetime vector
by setting any missing elements to their minimum possible value.
<code>datetime_narrow()</code> sets a cap on the maximum &quot;precision&quot; by setting
any more precise elements missing.
<code>datetime_cast()</code> sets the precision exactly by calling both
<code>datetime_narrow()</code> and <code>datetime_widen()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datetime_narrow(x, precision, ...)

## S3 method for class 'datetimeoffset'
datetime_narrow(x, precision, ...)

## S3 method for class 'clock_calendar'
datetime_narrow(x, precision, ...)

## S3 method for class 'clock_time_point'
datetime_narrow(
  x,
  precision,
  ...,
  method = c("floor", "round", "ceiling", "cast")
)

## S3 method for class 'POSIXt'
datetime_narrow(
  x,
  precision,
  ...,
  method = c("floor", "round", "ceiling"),
  nonexistent = "error",
  ambiguous = x
)

datetime_widen(x, precision, ...)

## S3 method for class 'datetimeoffset'
datetime_widen(
  x,
  precision,
  ...,
  year = 0L,
  month = 1L,
  day = 1L,
  hour = 0L,
  minute = 0L,
  second = 0L,
  nanosecond = 0L,
  na_set = FALSE
)

## S3 method for class 'clock_calendar'
datetime_widen(x, precision, ...)

## S3 method for class 'clock_time_point'
datetime_widen(x, precision, ...)

## S3 method for class 'POSIXt'
datetime_widen(x, precision, ...)

datetime_cast(x, precision, ...)

## Default S3 method:
datetime_cast(x, precision, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datetime_cast_+3A_x">x</code></td>
<td>
<p>A datetime vector.  Either <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code>, a &quot;clock&quot; &quot;calendar&quot;, or a &quot;clock&quot; &quot;time point&quot;.</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_precision">precision</code></td>
<td>
<p>Precision to narrow/widen to.  Either &quot;missing&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;, or &quot;nanosecond&quot;.</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_...">...</code></td>
<td>
<p>Used by some methods.
The default method for <code>datetime_cast()</code> will pass this to both <code>datetime_narrow()</code> and <code>datetime_widen()</code>.</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_method">method</code></td>
<td>
<p>Depending on the class either &quot;floor&quot;, &quot;ceiling&quot;, &quot;round&quot;, and/or &quot;cast&quot;.</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_nonexistent">nonexistent</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone doesn't exist.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_ambiguous">ambiguous</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone is ambiguous.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_year">year</code></td>
<td>
<p>If missing what year to assume</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_month">month</code></td>
<td>
<p>If missing what month to assume</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_day">day</code></td>
<td>
<p>If missing what day to assume</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_hour">hour</code></td>
<td>
<p>If missing what hour to assume</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_minute">minute</code></td>
<td>
<p>If missing what minute to assume</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_second">second</code></td>
<td>
<p>If missing what second to assume</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_nanosecond">nanosecond</code></td>
<td>
<p>If missing what nanosecond to assume</p>
</td></tr>
<tr><td><code id="datetime_cast_+3A_na_set">na_set</code></td>
<td>
<p>If <code>TRUE</code> widen the &quot;missing&quot; datetimes as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A datetime vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dts &lt;- as_datetimeoffset(c(NA_character_, "2020", "2020-04-10", "2020-04-10T10:10"))
  datetime_precision(dts)
  datetime_narrow(dts, "day")
  datetime_widen(dts, "day")
  datetime_cast(dts, "day")

  datetime_widen(datetimeoffset(2020L), "day", month = 6, day = 15)

  # vectorized "precision" is allowed
  datetime_narrow(as_datetimeoffset(Sys.time()),
                  c("year", "day", "second"))
  datetime_widen(NA_datetimeoffset_, c("year", "day", "second"), na_set = TRUE)

  library("clock")
  ymd &lt;- year_month_day(1918, 11, 11, 11)
  datetime_narrow(ymd, "day")
  datetime_narrow(ymd, "second") # already narrower than "second"
  datetime_widen(ymd, "second")
  datetime_widen(ymd, "day") # already wider than "day"

  ## Not run: 
    # comparable {clock} calendar methods throw an error in certain cases
    clock::calendar_narrow(ymd, "second") # already narrower than "second"
    clock::calendar_widen(ymd, "day") # already wider than "day"
  
## End(Not run)

  nt &lt;- as_naive_time(ymd)
  datetime_narrow(nt, "day")
  datetime_narrow(nt, "second")
  datetime_widen(nt, "second")
  datetime_widen(nt, "day")
  datetime_cast(nt, "day") # same as clock::time_point_floor(nt, "day")
  datetime_cast(nt, "day", method = "cast") # same as clock::time_point_cast(nt, "day")
</code></pre>

<hr>
<h2 id='datetime_precision'>Datetime precision</h2><span id='topic+datetime_precision'></span><span id='topic+datetime_precision.datetimeoffset'></span><span id='topic+datetime_precision.clock_calendar'></span><span id='topic+datetime_precision.clock_time_point'></span><span id='topic+datetime_precision.clock_zoned_time'></span><span id='topic+datetime_precision.nanotime'></span><span id='topic+precision_to_int'></span>

<h3>Description</h3>

<p><code>datetime_precision()</code> returns the &quot;precision&quot; of a datetime vector's datetimes.
<code>precision_to_int()</code> converts the precision to an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datetime_precision(x, ...)

## S3 method for class 'datetimeoffset'
datetime_precision(x, range = FALSE, unspecified = FALSE, ...)

## S3 method for class 'clock_calendar'
datetime_precision(x, ...)

## S3 method for class 'clock_time_point'
datetime_precision(x, ...)

## S3 method for class 'clock_zoned_time'
datetime_precision(x, ...)

## S3 method for class 'nanotime'
datetime_precision(x, ...)

precision_to_int(precision)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datetime_precision_+3A_x">x</code></td>
<td>
<p>A datetime vector.  Either <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code>, a &quot;clock&quot; &quot;calendar&quot;, or a &quot;clock&quot; &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="datetime_precision_+3A_...">...</code></td>
<td>
<p>Used by some S3 methods.</p>
</td></tr>
<tr><td><code id="datetime_precision_+3A_range">range</code></td>
<td>
<p>If <code>TRUE</code> return just the minimum and maximum &quot;precision&quot;.</p>
</td></tr>
<tr><td><code id="datetime_precision_+3A_unspecified">unspecified</code></td>
<td>
<p>If <code>TRUE</code> use the smallest non-missing component's as the precision even
if there is a missing value for a larger component.</p>
</td></tr>
<tr><td><code id="datetime_precision_+3A_precision">precision</code></td>
<td>
<p>A datetime precision (as returned by <code>datetime_precision()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>datetime_precision()</code> returns a character vector of precisions.
Depending on the object either &quot;missing&quot;, &quot;year&quot;, &quot;quarter&quot;, &quot;month&quot;, &quot;week&quot;,
&quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;, &quot;millisecond&quot;, &quot;microsecond&quot;, or &quot;nanosecond&quot;.
<code>precision_to_int()</code> returns an integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dts &lt;- as_datetimeoffset(c("2020", "2020-04-10", "2020-04-10T10:10"))
  datetime_precision(dts)
  datetime_precision(dts, range = TRUE)

  dt &lt;- datetimeoffset(2020, NA_integer_, 10)
  datetime_precision(dt)
  datetime_precision(dt, unspecified = TRUE)

  precision_to_int("year") &lt; precision_to_int("day")

  library("clock")
  datetime_precision(year_month_day(1918, 11, 11))
  datetime_precision(sys_time_now())
  datetime_precision(zoned_time_now(Sys.timezone()))
</code></pre>

<hr>
<h2 id='datetimeoffset'>Datetime object with optional UTC offsets and/or timezones</h2><span id='topic+datetimeoffset'></span>

<h3>Description</h3>

<p><code>datetimeoffset()</code> creates a datetime with possible UTC offset object.
It can be used to represent datetimes with possible UTC offsets
(without necessarily any knowledge of the time zone).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datetimeoffset(
  year = NA_integer_,
  month = NA_integer_,
  day = NA_integer_,
  hour = NA_integer_,
  minute = NA_integer_,
  second = NA_integer_,
  nanosecond = NA_integer_,
  subsecond_digits = NA_integer_,
  hour_offset = NA_integer_,
  minute_offset = NA_integer_,
  tz = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datetimeoffset_+3A_year">year</code></td>
<td>
<p>Year (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_month">month</code></td>
<td>
<p>Month (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_day">day</code></td>
<td>
<p>Day (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_hour">hour</code></td>
<td>
<p>Hour (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_minute">minute</code></td>
<td>
<p>Minute (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_second">second</code></td>
<td>
<p>Second (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_nanosecond">nanosecond</code></td>
<td>
<p>Nanosecond (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_subsecond_digits">subsecond_digits</code></td>
<td>
<p>Number of digits used by fractional seconds (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_hour_offset">hour_offset</code></td>
<td>
<p>UTC offset in hours (integer, optional)</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_minute_offset">minute_offset</code></td>
<td>
<p>UTC offset in minutes (integer, optional).
Will be coerced to a non-negative value.</p>
</td></tr>
<tr><td><code id="datetimeoffset_+3A_tz">tz</code></td>
<td>
<p>Time zone (character, optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vctrs</code> record with class <code>datetimeoffset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  datetimeoffset(2020)
  datetimeoffset(2020, 5)
  datetimeoffset(2020, 5, 15)
  datetimeoffset(2020, 5, 15, 8)
  datetimeoffset(2020, 5, 15, 8, 23)
  datetimeoffset(2020, 5, 15, 8, 23, 16) # local time with unknown timezone
  if ("US/Pacific" %in% OlsonNames())
    datetimeoffset(2020, 5, 15, 8, 23, 16, tz = "US/Pacific")
  datetimeoffset(2020, 5, 15, 8, 23, 16, tz = "GMT")
  datetimeoffset(2020, 5, 15, 8, 23, 16, hour_offset = -7)
  datetimeoffset(2020, 5, 15, 8, 23, 16, hour_offset = -7, minute_offset = 30)
</code></pre>

<hr>
<h2 id='datetimeoffset_utilities'>Various &quot;datetimeoffset&quot; object utilities</h2><span id='topic+datetimeoffset_utilities'></span><span id='topic+is_datetimeoffset'></span><span id='topic+NA_datetimeoffset_'></span><span id='topic+datetimeoffset_now'></span>

<h3>Description</h3>

<p><code>is_datetimeoffset()</code> tests whether a datetime object is of the &quot;datetimeoffset&quot; class.
<code>NA_datetimeoffset_</code> provides a &quot;missing&quot; &quot;datetimeoffset&quot; object.
<code>datetimeoffset_now()</code> returns the current time in the corresponding time zone(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_datetimeoffset(x)

NA_datetimeoffset_

datetimeoffset_now(tz = Sys.timezone())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datetimeoffset_utilities_+3A_x">x</code></td>
<td>
<p>An object to be tested</p>
</td></tr>
<tr><td><code id="datetimeoffset_utilities_+3A_tz">tz</code></td>
<td>
<p>Time zone(s)</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>datetimeoffset</code> (inherits from <code>vctrs_rcrd</code>, <code>vctrs_vctr</code>) of length 1.
</p>


<h3>Value</h3>

<p><code>is_datetimeoffset()</code> returns a logical vector.
<code>datetimeoffset_now()</code> returns a <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  is_datetimeoffset(as_datetimeoffset(Sys.time()))
  is_datetimeoffset(Sys.time())

  is.na(NA_datetimeoffset_)
  is.na(as_datetimeoffset(""))

  if (all(c("America/Los_Angeles", "America/New_York") %in% OlsonNames()))
    datetimeoffset_now(c("America/Los_Angeles", "America/New_York"))

</code></pre>

<hr>
<h2 id='datetimeoffset-invalid'>Invalid datetimeoffset datetimes</h2><span id='topic+datetimeoffset-invalid'></span><span id='topic+invalid_detect.datetimeoffset'></span><span id='topic+invalid_resolve.datetimeoffset'></span><span id='topic+invalid_any.datetimeoffset'></span><span id='topic+invalid_count.datetimeoffset'></span><span id='topic+invalid_remove.datetimeoffset'></span>

<h3>Description</h3>

<p><code>invalid_detect()</code> detects invalid datetimes.
<code>invalid_any()</code> returns TRUE if any datetimes are invalid.
<code>invalid_count()</code> returns number of invalid datetimes.
<code>invalid_remove()</code> removes invalid datetimes.
<code>invalid_resolve()</code> resolves invalid datetimes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datetimeoffset'
invalid_detect(x)

## S3 method for class 'datetimeoffset'
invalid_resolve(x, ..., invalid = "NA", nonexistent = "NA")

## S3 method for class 'datetimeoffset'
invalid_any(x)

## S3 method for class 'datetimeoffset'
invalid_count(x)

## S3 method for class 'datetimeoffset'
invalid_remove(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datetimeoffset-invalid_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> object.</p>
</td></tr>
<tr><td><code id="datetimeoffset-invalid_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="datetimeoffset-invalid_+3A_invalid">invalid</code></td>
<td>
<p>Invalid date resolution strategy.  See <code><a href="clock.html#topic+clock-invalid">clock::invalid_resolve()</a></code>.</p>
</td></tr>
<tr><td><code id="datetimeoffset-invalid_+3A_nonexistent">nonexistent</code></td>
<td>
<p>Nonexistent (because of DST spring forward) time resolution strategy.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>datetimeoffset()</code> datetimes can be considered invalid for three main reasons:
</p>

<ol>
<li><p> An invalid &quot;calendar date&quot; such as <code>"2020-02-30"</code> (there are less than 30 days in February).
</p>
</li>
<li><p> A &quot;nonexistent&quot; datetime due to a Daylight Savings Time &quot;spring forward&quot; such as <code>"2020-03-08T02:59:59[America/Los_Angeles]"</code>
</p>
</li>
<li><p> Incorrect UTC offsets such as <code>"2020-03-08T01:59:59-08[America/New_York]"</code> (that particular Eastern time has a UTC offset of <code>-05</code>)
</p>
</li></ol>



<h3>Value</h3>

<p><code>invalid_detect()</code>, <code>invalid_remove()</code>, and <code>invalid_resolve()</code> return <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> vectors.
<code>invalid_count()</code> returns an integer and <code>invalid_any()</code> returns a logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># invalid date because April only has 30 days
dts &lt;- c("2019-04-30T03:30:00", "2019-04-31T02:30:00")
dts &lt;- as_datetimeoffset(dts)
clock::invalid_detect(dts)
clock::invalid_any(dts)
clock::invalid_count(dts)
clock::invalid_remove(dts)
clock::invalid_resolve(dts)
clock::invalid_resolve(dts, invalid = "previous")
clock::invalid_resolve(dts, invalid = "previous-day")

# non-existent time because of DST "spring forward"
if ("America/Los_Angeles" %in% OlsonNames()) {
  dt &lt;- as_datetimeoffset("2020-03-08T02:59:59[America/Los_Angeles]")
  print(clock::invalid_detect(dt))
  clock::invalid_resolve(dt, nonexistent = "roll-forward")
}

# incorrect UTC offsets
if ("America/New_York" %in% OlsonNames()) {
  dt &lt;- as_datetimeoffset("2020-03-08T01:59:59-08[America/New_York]")
  print(clock::invalid_detect(dt))
  clock::invalid_resolve(dt)
}
</code></pre>

<hr>
<h2 id='fill_tz'>Fill in missing time zones and/or UTC offsets</h2><span id='topic+fill_tz'></span><span id='topic+fill_utc_offsets'></span>

<h3>Description</h3>

<p><code>fill_tz()</code> fills in missing time zones.
<code>fill_utc_offsets()</code> fills in missing UTC offsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_tz(x, tz = "")

fill_utc_offsets(x, ambiguous = "NA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_tz_+3A_x">x</code></td>
<td>
<p>A datetime object</p>
</td></tr>
<tr><td><code id="fill_tz_+3A_tz">tz</code></td>
<td>
<p>Timezone used to fill in missing time zones</p>
</td></tr>
<tr><td><code id="fill_tz_+3A_ambiguous">ambiguous</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone is ambiguous.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A datetime object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dts &lt;- as_datetimeoffset(c("2020-01-01T01:01:01", "2020-01-01T01:01:01Z"))
fill_tz(dts, "UTC")
fill_tz(dts, Sys.timezone())
clock::as_sys_time(dts)
clock::as_sys_time(fill_tz(dts, "UTC"))
clock::as_zoned_time(dts)
clock::as_zoned_time(fill_tz(dts, ""))

if ("America/New_York" %in% OlsonNames()) {
  # non-ambiguous UTC offsets
  dt &lt;- as_datetimeoffset("2020-11-01T12:30:00[America/New_York]")
  cat("unfilled: ", get_utc_offsets(dt), "\n")
  dt &lt;- fill_utc_offsets(dt)
  cat("filled: ", get_utc_offsets(dt), "\n")

  # ambiguous UTC offsets due to DST
  dt0 &lt;- as_datetimeoffset("2020-11-01T01:30:00[America/New_York]")
  dt &lt;- fill_utc_offsets(dt0)
  cat('`ambiguous = "NA"` (default): ', get_utc_offsets(dt), "\n")
  dt &lt;- fill_utc_offsets(dt0, ambiguous = "earliest")
  cat('`ambiguous = "earliest"`: ', get_utc_offsets(dt), "\n")
  dt &lt;- fill_utc_offsets(dt0, ambiguous = "latest")
  cat('`ambiguos = "latest"`: ', get_utc_offsets(dt), "\n")
}
</code></pre>

<hr>
<h2 id='format'>Convert datetime objects to character</h2><span id='topic+format'></span><span id='topic+format.datetimeoffset'></span><span id='topic+format_iso8601'></span><span id='topic+format_pdfmark'></span><span id='topic+format_edtf'></span><span id='topic+format_exiftool'></span><span id='topic+format_strftime'></span><span id='topic+format_nanotime'></span>

<h3>Description</h3>

<p><code>format()</code> returns a datetime string
with as much <strong>known</strong> information possible (RFC 3339 with de facto standard time zone extension).
<code>format_iso8601()</code> returns an ISO 8601 datetime string.
<code>format_pdfmark()</code> returns a pdfmark datetime string with as much <strong>known</strong> information possible.
<code>format_strftime()</code> allows <code><a href="base.html#topic+strptime">base::strftime()</a></code> style formatting.
<code>format_nanotime()</code> allows CCTZ style formatting.
<code>format_edtf()</code> returns an Extended Date Time Format (EDTF) string.
<code>format_exiftool()</code> returns the date/time string expected by <code>exiftool</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datetimeoffset'
format(x, ...)

format_iso8601(
  x,
  offsets = TRUE,
  precision = NULL,
  sep = ":",
  mode = c("normal", "xmp"),
  ...
)

format_pdfmark(x, prefix = "D:")

format_edtf(x, offsets = TRUE, precision = NULL, usetz = FALSE, ...)

format_exiftool(x, mode = c("normal", "xmp", "pdf"), ...)

format_strftime(
  x,
  format = "%Y-%m-%d %H:%M:%S",
  tz = get_tz(x),
  usetz = FALSE,
  fill = mode_tz(x)
)

format_nanotime(
  x,
  format = "%Y-%m-%dT%H:%M:%E9S%Ez",
  tz = get_tz(x),
  fill = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> object.</p>
</td></tr>
<tr><td><code id="format_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="format_+3A_offsets">offsets</code></td>
<td>
<p>Include the UTC offsets in the formatting</p>
</td></tr>
<tr><td><code id="format_+3A_precision">precision</code></td>
<td>
<p>The amount of precision: either &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;,
&quot;decisecond&quot;, &quot;centisecond&quot;, &quot;millisecond&quot;,
&quot;hundred microseconds&quot;, &quot;ten microseconds&quot;, &quot;microsecond&quot;,
&quot;hundred nanoseconds&quot;, &quot;ten nanoseconds&quot;, or &quot;nanosecond&quot;.
If <code>NULL</code> then full precision for the object is shown.</p>
</td></tr>
<tr><td><code id="format_+3A_sep">sep</code></td>
<td>
<p>UTC offset separator.  Either &quot;:&quot; or &quot;&quot;.</p>
</td></tr>
<tr><td><code id="format_+3A_mode">mode</code></td>
<td>
<p>If <code>mode = "xmp"</code> only output valid XMP metadata datetime values.
If <code>mode = "pdf"</code> only output supported PDF docinfo datetime values.</p>
</td></tr>
<tr><td><code id="format_+3A_prefix">prefix</code></td>
<td>
<p>Prefix to use.  Either <code>"D:"</code> (default) or <code>""</code>.</p>
</td></tr>
<tr><td><code id="format_+3A_usetz">usetz</code></td>
<td>
<p>Include the time zone in the formatting</p>
</td></tr>
<tr><td><code id="format_+3A_format">format</code></td>
<td>
<p>For <code>format_strftime()</code> see <code><a href="base.html#topic+strptime">base::strftime()</a></code>.
For <code>format_nanotime()</code> see <a href="https://github.com/google/cctz/blob/6e09ceb/include/time_zone.h#L197">https://github.com/google/cctz/blob/6e09ceb/include/time_zone.h#L197</a>.</p>
</td></tr>
<tr><td><code id="format_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used for the conversion.
Can be a length greater than one.</p>
</td></tr>
<tr><td><code id="format_+3A_fill">fill</code></td>
<td>
<p>If timezone and UTC offset info is missing what
timezone to assume.  See <code><a href="#topic+fill_tz">fill_tz()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # ISO 8601 datetimes
  format_iso8601(as_datetimeoffset("2020-05"))
  format_iso8601(as_datetimeoffset("2020-05-10 20:15"))
  format_iso8601(as_datetimeoffset("2020-05-10 20:15:05-07"))
  if (requireNamespace("lubridate"))
    lubridate::format_ISO8601(as_datetimeoffset("2020-05-10 20:15:05-07"))

  # pdfmark datetimes
  format_pdfmark(as_datetimeoffset("2020-05"))
  format_pdfmark(as_datetimeoffset("2020-05-10 20:15"))
  format_pdfmark(as_datetimeoffset("2020-05-10 20:15:05-07"))

  # strftime style formatting
  dt &lt;- as_datetimeoffset("2020-05-10 20:15")
  format_strftime(dt)
  format_strftime(dt, format = "%c")

  # CCTZ style formatting
  if (requireNamespace("nanotime")) {
    dt &lt;- as_datetimeoffset(Sys.time())
    format_nanotime(dt, format = "%F %H:%M:%E7S %Ez") # SQL Server datetimeoffset
  }

  # EDTF style formatting
  format_edtf(as_datetimeoffset("2020-05"))
  format_edtf(as_datetimeoffset("2020-05-10T20:15:05-07"))
  dt &lt;- datetimeoffset(2020, NA_integer_, 10)
  format_edtf(dt)

  # `exiftool` formatting
  format_exiftool(as_datetimeoffset("2020:05:10"))
  format_exiftool(as_datetimeoffset("2020:05:10 20:15"))
  format_exiftool(as_datetimeoffset("2020:05:10 20:15:05-07:00"))
</code></pre>

<hr>
<h2 id='from_datetimeoffset'>Convert to other datetime objects</h2><span id='topic+from_datetimeoffset'></span><span id='topic+as.Date.datetimeoffset'></span><span id='topic+as.POSIXct.datetimeoffset'></span><span id='topic+as_date_time.datetimeoffset'></span><span id='topic+as.POSIXlt.datetimeoffset'></span><span id='topic+as_year_quarter_day.datetimeoffset'></span><span id='topic+as_zoned_time.datetimeoffset'></span>

<h3>Description</h3>

<p>We register S3 methods to convert <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> objects to
other R datetime objects:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datetimeoffset'
as.Date(x, ...)

## S3 method for class 'datetimeoffset'
as.POSIXct(x, tz = mode_tz(x), ..., fill = "")

## S3 method for class 'datetimeoffset'
as_date_time(x, zone = mode_tz(x), ..., fill = NA_character_)

## S3 method for class 'datetimeoffset'
as.POSIXlt(x, tz = mode_tz(x), ..., fill = "")

## S3 method for class 'datetimeoffset'
as_year_quarter_day(x, ..., start = NULL)

## S3 method for class 'datetimeoffset'
as_zoned_time(
  x,
  zone = mode_tz(x),
  ...,
  ambiguous = "error",
  nonexistent = "error",
  fill = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_datetimeoffset_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> object</p>
</td></tr>
<tr><td><code id="from_datetimeoffset_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="from_datetimeoffset_+3A_tz">tz</code>, <code id="from_datetimeoffset_+3A_zone">zone</code></td>
<td>
<p>What time zone to assume</p>
</td></tr>
<tr><td><code id="from_datetimeoffset_+3A_fill">fill</code></td>
<td>
<p>If timezone and UTC offset info is missing what
timezone to assume.  See <code><a href="#topic+fill_tz">fill_tz()</a></code>.</p>
</td></tr>
<tr><td><code id="from_datetimeoffset_+3A_start">start</code></td>
<td>
<p>The month to start the fiscal year in.
See <code><a href="clock.html#topic+as_year_quarter_day">clock::as_year_quarter_day()</a></code>.</p>
</td></tr>
<tr><td><code id="from_datetimeoffset_+3A_ambiguous">ambiguous</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone is ambiguous.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
<tr><td><code id="from_datetimeoffset_+3A_nonexistent">nonexistent</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone doesn't exist.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We register S3 methods for the following:
</p>

<ul>
<li> <p><code><a href="base.html#topic+as.Date">as.Date()</a></code> and <code><a href="clock.html#topic+as_date">clock::as_date()</a></code> returns the &quot;local&quot; date as a <code><a href="base.html#topic+Dates">base::Date()</a></code> object
</p>
</li>
<li> <p><code><a href="base.html#topic+as.POSIXct">as.POSIXct()</a></code> and <code><a href="clock.html#topic+as_date_time">clock::as_date_time()</a></code> returns the &quot;local&quot; datetime as a <code><a href="base.html#topic+DateTimeClasses">base::POSIXct()</a></code> object
</p>
</li>
<li> <p><code><a href="base.html#topic+as.POSIXlt">as.POSIXlt()</a></code> returns the &quot;local&quot; datetime as a <code><a href="base.html#topic+DateTimeClasses">base::POSIXlt()</a></code> object
</p>
</li>
<li> <p><code><a href="nanotime.html#topic+nanotime">nanotime::as.nanotime()</a></code> returns the &quot;global&quot; datetime as a <code><a href="nanotime.html#topic+nanotime">nanotime::nanotime()</a></code> object
</p>
</li>
<li> <p><code><a href="parttime.html#topic+as.parttime">parttime::as.parttime()</a></code> returns the &quot;local&quot; datetime as a <code><a href="parttime.html#topic+parttime">parttime::parttime()</a></code> object
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_year_month_day">clock::as_year_month_day()</a></code> returns a <code><a href="clock.html#topic+year_month_day">clock::year_month_day()</a></code> calendar
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_year_month_weekday">clock::as_year_month_weekday()</a></code> returns a <code><a href="clock.html#topic+year_month_weekday">clock::year_month_weekday()</a></code> calendar
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_iso_year_week_day">clock::as_iso_year_week_day()</a></code> returns a <code><a href="clock.html#topic+iso_year_week_day">clock::iso_year_week_day()</a></code> calendar
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_year_quarter_day">clock::as_year_quarter_day()</a></code> returns a <code><a href="clock.html#topic+year_quarter_day">clock::year_quarter_day()</a></code> calendar
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_year_day">clock::as_year_day()</a></code> returns a <code><a href="clock.html#topic+year_day">clock::year_day()</a></code> calendar
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_naive_time">clock::as_naive_time()</a></code> returns a &quot;clock&quot; naive-time
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_sys_time">clock::as_sys_time()</a></code> returns a &quot;clock&quot; sys-time
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_zoned_time">clock::as_zoned_time()</a></code> returns a &quot;clock&quot; zoned-time
</p>
</li>
<li> <p><code><a href="clock.html#topic+as_weekday">clock::as_weekday()</a></code> returns a <code><a href="clock.html#topic+weekday">clock::weekday()</a></code> object
</p>
</li></ul>



<h3>Value</h3>

<p>A datetime object vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # {base}
  today &lt;- as_datetimeoffset(Sys.Date())
  now &lt;- as_datetimeoffset(Sys.time())

  as.Date(today)
  as.Date(now)
  as.POSIXct(now)
  as.POSIXlt(now)

  # {clock}
  clock::as_date(today)
  clock::as_date_time(now)

  clock::as_year_month_day(now)
  clock::as_year_month_weekday(now)
  clock::as_iso_year_week_day(now)
  clock::as_year_quarter_day(now)
  clock::as_year_day(now)

  clock::as_naive_time(now)
  clock::as_sys_time(now)
  clock::as_zoned_time(now)

  clock::as_weekday(now)

  if (requireNamespace("nanotime")) {
    nanotime::as.nanotime(now)
  }

  if (requireNamespace("parttime")) {
    parttime::as.parttime(now)
  }
</code></pre>

<hr>
<h2 id='getset_utc_offsets'>Get/set UTC offset strings</h2><span id='topic+getset_utc_offsets'></span><span id='topic+get_utc_offsets'></span><span id='topic+set_utc_offsets'></span>

<h3>Description</h3>

<p><code>get_utc_offsets()</code> and <code>set_utc_offsets()</code> gets/sets UTC offset strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_utc_offsets(x, sep = ":")

set_utc_offsets(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getset_utc_offsets_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> object</p>
</td></tr>
<tr><td><code id="getset_utc_offsets_+3A_sep">sep</code></td>
<td>
<p>Separator between hour and minute offsets.  Either &quot;:&quot; or &quot;&quot;.</p>
</td></tr>
<tr><td><code id="getset_utc_offsets_+3A_value">value</code></td>
<td>
<p>Replace UTC offset string</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_utc_offsets()</code> returns a character string of UTC offset info.
<code>set_utc_offsets()</code> returns a datetime (whose UTC offset info has been set).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_hour_offset">get_hour_offset()</a></code>, <code><a href="#topic+set_hour_offset">set_hour_offset()</a></code>, <code><a href="#topic+get_minute_offset">get_minute_offset()</a></code>, and <code><a href="#topic+set_minute_offset">set_minute_offset()</a></code>
allow getting/setting the separate individual hour/minute offset components with integers.
<code><a href="#topic+fill_utc_offsets">fill_utc_offsets()</a></code> fills any missing UTC offsets using non-missing time zones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dt &lt;- as_datetimeoffset("2020-01-01T01:01")
  get_utc_offsets(dt)
  dt &lt;- set_utc_offsets(dt, "-07:00")
  get_utc_offsets(dt)
  dt &lt;- set_utc_offsets(dt, "+0800")
  get_utc_offsets(dt)
  dt &lt;- set_utc_offsets(dt, "+00")
  get_utc_offsets(dt)
  dt &lt;- set_utc_offsets(dt, NA_character_)
  get_utc_offsets(dt)
</code></pre>

<hr>
<h2 id='getters'>Get datetime components</h2><span id='topic+getters'></span><span id='topic+get_year.datetimeoffset'></span><span id='topic+get_month.datetimeoffset'></span><span id='topic+get_day.datetimeoffset'></span><span id='topic+get_hour.datetimeoffset'></span><span id='topic+get_minute.datetimeoffset'></span><span id='topic+get_second.datetimeoffset'></span><span id='topic+get_nanosecond.datetimeoffset'></span><span id='topic+get_subsecond_digits'></span><span id='topic+get_subsecond_digits.datetimeoffset'></span><span id='topic+get_subsecond_digits.default'></span><span id='topic+get_hour_offset'></span><span id='topic+get_hour_offset.datetimeoffset'></span><span id='topic+get_hour_offset.default'></span><span id='topic+get_hour_offset.POSIXt'></span><span id='topic+get_minute_offset'></span><span id='topic+get_minute_offset.datetimeoffset'></span><span id='topic+get_minute_offset.default'></span><span id='topic+get_minute_offset.POSIXt'></span><span id='topic+get_tz'></span><span id='topic+get_tz.datetimeoffset'></span><span id='topic+get_tz.POSIXt'></span><span id='topic+get_tz.clock_zoned_time'></span><span id='topic+get_tz.default'></span>

<h3>Description</h3>

<p>Getter methods for <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datetimeoffset'
get_year(x)

## S3 method for class 'datetimeoffset'
get_month(x)

## S3 method for class 'datetimeoffset'
get_day(x)

## S3 method for class 'datetimeoffset'
get_hour(x)

## S3 method for class 'datetimeoffset'
get_minute(x)

## S3 method for class 'datetimeoffset'
get_second(x)

## S3 method for class 'datetimeoffset'
get_nanosecond(x)

get_subsecond_digits(x)

## S3 method for class 'datetimeoffset'
get_subsecond_digits(x)

## Default S3 method:
get_subsecond_digits(x)

get_hour_offset(x)

## S3 method for class 'datetimeoffset'
get_hour_offset(x)

## Default S3 method:
get_hour_offset(x)

## S3 method for class 'POSIXt'
get_hour_offset(x)

get_minute_offset(x)

## S3 method for class 'datetimeoffset'
get_minute_offset(x)

## Default S3 method:
get_minute_offset(x)

## S3 method for class 'POSIXt'
get_minute_offset(x)

get_tz(x)

## S3 method for class 'datetimeoffset'
get_tz(x)

## S3 method for class 'POSIXt'
get_tz(x)

## S3 method for class 'clock_zoned_time'
get_tz(x)

## Default S3 method:
get_tz(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getters_+3A_x">x</code></td>
<td>
<p>A datetime object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We implement <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> support for the following S3 methods from <code>clock</code>:
</p>

<ul>
<li> <p><code>get_year()</code>
</p>
</li>
<li> <p><code>get_month()</code>
</p>
</li>
<li> <p><code>get_day()</code>
</p>
</li>
<li> <p><code>get_hour()</code>
</p>
</li>
<li> <p><code>get_minute()</code>
</p>
</li>
<li> <p><code>get_second()</code>
</p>
</li>
<li> <p><code>get_nanosecond()</code>
</p>
</li></ul>

<p>We also implemented new S3 getter methods:
</p>

<ul>
<li> <p><code>get_subsecond_digits()</code>
</p>
</li>
<li> <p><code>get_hour_offset()</code>
</p>
</li>
<li> <p><code>get_minute_offset()</code>
</p>
</li>
<li> <p><code>get_tz()</code>
</p>
</li></ul>

<p>We also implement <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> support for the following S3 methods from <code>lubridate</code>:
</p>

<ul>
<li> <p><code>year()</code>
</p>
</li>
<li> <p><code>month()</code>
</p>
</li>
<li> <p><code>mday()</code>
</p>
</li>
<li> <p><code>hour()</code>
</p>
</li>
<li> <p><code>minute()</code>
</p>
</li>
<li> <p><code>second()</code>
</p>
</li>
<li> <p><code>tz()</code>
</p>
</li>
<li> <p><code>date()</code>
</p>
</li></ul>



<h3>Value</h3>

<p>The component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("clock")
if ("Europe/Paris" %in% OlsonNames()) {
  dt &lt;- as_datetimeoffset("1918-11-11T11:11:11.1234+00:00[Europe/Paris]")
} else {
  dt &lt;- as_datetimeoffset("1918-11-11T11:11:11.1234")
}
get_year(dt)
get_month(dt)
get_day(dt)
get_hour(dt)
get_minute(dt)
get_second(dt)
get_nanosecond(dt)
get_subsecond_digits(dt)
get_hour_offset(dt)
get_minute_offset(dt)
get_tz(dt)
if (require("lubridate")) {
  paste0(year(dt), "-", month(dt), "-", day(dt),
         "T", hour(dt), ":", minute(dt), ":", second(dt),
         "[", tz(dt), "]")
}
</code></pre>

<hr>
<h2 id='mode_tz'>Get most common time zone</h2><span id='topic+mode_tz'></span><span id='topic+mode_tz.datetimeoffset'></span><span id='topic+mode_tz.default'></span>

<h3>Description</h3>

<p>'mode_tz()' gets the most common time zone
in the datetime object.  If a tie we use the time zone used first.
Intended for use when coercing from a datetime object that supports
multiple heterogeneous time zones to a datetime object that
only supports one time zone
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mode_tz(x, ...)

## S3 method for class 'datetimeoffset'
mode_tz(x, tz = "", ...)

## Default S3 method:
mode_tz(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mode_tz_+3A_x">x</code></td>
<td>
<p>A datetime object.</p>
</td></tr>
<tr><td><code id="mode_tz_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="mode_tz_+3A_tz">tz</code></td>
<td>
<p>A timezone string to use for missing time zones.
&quot;&quot; will be treated as equivalent to <code>Sys.timezone()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Timezone string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  dt &lt;- as_datetimeoffset(Sys.time())
  print(mode_tz(dt))
  if (all(c("America/Los_Angeles", "America/New_York") %in% OlsonNames())) {
    dt &lt;- as_datetimeoffset("2020-01-01",
                             tz = c("America/Los_Angeles", "America/New_York"))
    print(mode_tz(dt))

    print(Sys.timezone()) # timezone to be used for missing time zones
    dt &lt;- as_datetimeoffset("2020-01-01",
                             tz = c("America/New_York", NA_character_, NA_character_))
    print(mode_tz(dt))
  }
</code></pre>

<hr>
<h2 id='setters'>Set datetime components</h2><span id='topic+setters'></span><span id='topic+set_year.datetimeoffset'></span><span id='topic+set_month.datetimeoffset'></span><span id='topic+set_day.datetimeoffset'></span><span id='topic+set_hour.datetimeoffset'></span><span id='topic+set_minute.datetimeoffset'></span><span id='topic+set_second.datetimeoffset'></span><span id='topic+set_nanosecond.datetimeoffset'></span><span id='topic+set_subsecond_digits'></span><span id='topic+set_subsecond_digits.datetimeoffset'></span><span id='topic+set_hour_offset'></span><span id='topic+set_hour_offset.datetimeoffset'></span><span id='topic+set_minute_offset'></span><span id='topic+set_minute_offset.datetimeoffset'></span><span id='topic+set_tz'></span><span id='topic+set_tz.datetimeoffset'></span><span id='topic+set_tz.clock_zoned_time'></span><span id='topic+set_tz.default'></span>

<h3>Description</h3>

<p>Setter methods for <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datetimeoffset'
set_year(x, value, ..., na_set = FALSE)

## S3 method for class 'datetimeoffset'
set_month(x, value, ..., na_set = FALSE)

## S3 method for class 'datetimeoffset'
set_day(x, value, ..., na_set = FALSE)

## S3 method for class 'datetimeoffset'
set_hour(x, value, ..., na_set = FALSE)

## S3 method for class 'datetimeoffset'
set_minute(x, value, ..., na_set = FALSE)

## S3 method for class 'datetimeoffset'
set_second(x, value, ..., na_set = FALSE)

## S3 method for class 'datetimeoffset'
set_nanosecond(x, value, ..., na_set = FALSE, digits = NULL)

set_subsecond_digits(x, value, ...)

## S3 method for class 'datetimeoffset'
set_subsecond_digits(x, value, ..., na_set = FALSE)

set_hour_offset(x, value, ...)

## S3 method for class 'datetimeoffset'
set_hour_offset(x, value, ..., na_set = FALSE)

set_minute_offset(x, value, ...)

## S3 method for class 'datetimeoffset'
set_minute_offset(x, value, ..., na_set = FALSE)

set_tz(x, value, ...)

## S3 method for class 'datetimeoffset'
set_tz(x, value, ..., na_set = FALSE)

## S3 method for class 'clock_zoned_time'
set_tz(x, value, ..., nonexistent = "error", ambiguous = "error")

## Default S3 method:
set_tz(x, value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setters_+3A_x">x</code></td>
<td>
<p>A datetime object.</p>
</td></tr>
<tr><td><code id="setters_+3A_value">value</code></td>
<td>
<p>The replacement value.  For <code>set_day()</code> this can also be &quot;last&quot;.</p>
</td></tr>
<tr><td><code id="setters_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="setters_+3A_na_set">na_set</code></td>
<td>
<p>If <code>TRUE</code> set component for <code>NA</code> datetimes (making them no longer <code>NA</code>)</p>
</td></tr>
<tr><td><code id="setters_+3A_digits">digits</code></td>
<td>
<p>If <code>NULL</code> do not update the <code>subsecond_digits</code> field.
Otherwise an integer vector (<code>1L</code> through <code>9L</code> or <code>NA_integer_</code>)
to update the <code>subsecond_digits</code> field with.</p>
</td></tr>
<tr><td><code id="setters_+3A_nonexistent">nonexistent</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone doesn't exist.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
<tr><td><code id="setters_+3A_ambiguous">ambiguous</code></td>
<td>
<p>What to do when the &quot;clock time&quot; in the new time zone is ambiguous.
See <code><a href="clock.html#topic+as-zoned-time-naive-time">clock::as_zoned_time.clock_naive_time()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We implement <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> support for the following S3 methods from <code>clock</code>:
</p>

<ul>
<li> <p><code>set_year()</code>
</p>
</li>
<li> <p><code>set_month()</code>
</p>
</li>
<li> <p><code>set_day()</code>
</p>
</li>
<li> <p><code>set_hour()</code>
</p>
</li>
<li> <p><code>set_minute()</code>
</p>
</li>
<li> <p><code>set_second()</code>
</p>
</li>
<li> <p><code>set_nanosecond()</code>
</p>
</li></ul>

<p>We also implemented new S3 setter methods:
</p>

<ul>
<li> <p><code>set_hour_offset()</code>
</p>
</li>
<li> <p><code>set_minute_offset()</code>
</p>
</li>
<li> <p><code>set_tz()</code> (changes system time but not clock time)
</p>
</li></ul>

<p>We also implement <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> support for the following S4 methods from <code>lubridate</code>:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;year&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;month&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;day&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;hour&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;minute&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;second&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;date&lt;-()&#8288;</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A datetime object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("clock")
dt &lt;- NA_datetimeoffset_
dt &lt;- set_year(dt, 1918L, na_set = TRUE)
dt &lt;- set_month(dt, 11L)
dt &lt;- set_day(dt, 11L)
dt &lt;- set_hour(dt, 11L)
dt &lt;- set_minute(dt, 11L)
dt &lt;- set_second(dt, 11L)
dt &lt;- set_nanosecond(dt, 123456789L)
dt &lt;- set_subsecond_digits(dt, 4L)
dt &lt;- set_hour_offset(dt, 0L)
dt &lt;- set_minute_offset(dt, 0L)
dt &lt;- set_tz(dt, "Europe/Paris")
format(dt)

if (require("lubridate")) {
  dt &lt;- datetimeoffset(0L)
  year(dt) &lt;- 1918L
  month(dt) &lt;- 11L
  day(dt) &lt;- 11L
  hour(dt) &lt;- 11L
  minute(dt) &lt;- 11L
  second(dt) &lt;- 11L
  if (packageVersion("lubridate") &gt; '1.8.0' &amp;&amp;
      "Europe/Paris" %in% OlsonNames()) {
    tz(dt) &lt;- "Europe/Paris"
  }
  format(dt)
}
</code></pre>

<hr>
<h2 id='subsecond'>Subsecond helper getter/setter</h2><span id='topic+subsecond'></span><span id='topic+get_millisecond.datetimeoffset'></span><span id='topic+set_millisecond.datetimeoffset'></span><span id='topic+get_microsecond.datetimeoffset'></span><span id='topic+set_microsecond.datetimeoffset'></span><span id='topic+get_subsecond'></span><span id='topic+get_subsecond.datetimeoffset'></span><span id='topic+set_subsecond'></span><span id='topic+set_subsecond.datetimeoffset'></span>

<h3>Description</h3>

<p>Helper getter/setter methods for the subseconds (aka fractional seconds) of <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datetimeoffset'
get_millisecond(x)

## S3 method for class 'datetimeoffset'
set_millisecond(x, value, ..., na_set = FALSE, digits = 3L)

## S3 method for class 'datetimeoffset'
get_microsecond(x)

## S3 method for class 'datetimeoffset'
set_microsecond(x, value, ..., na_set = FALSE, digits = 6L)

get_subsecond(x, ...)

## S3 method for class 'datetimeoffset'
get_subsecond(x, digits = get_subsecond_digits(x), ...)

set_subsecond(x, value, digits = 1L, ...)

## S3 method for class 'datetimeoffset'
set_subsecond(x, value, digits = 1L, ..., na_set = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsecond_+3A_x">x</code></td>
<td>
<p>A datetime object.</p>
</td></tr>
<tr><td><code id="subsecond_+3A_value">value</code></td>
<td>
<p>The replacement value.  For <code>set_day()</code> this can also be &quot;last&quot;.</p>
</td></tr>
<tr><td><code id="subsecond_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="subsecond_+3A_na_set">na_set</code></td>
<td>
<p>If <code>TRUE</code> set component for <code>NA</code> datetimes (making them no longer <code>NA</code>)</p>
</td></tr>
<tr><td><code id="subsecond_+3A_digits">digits</code></td>
<td>
<p>If <code>NULL</code> do not update the <code>subsecond_digits</code> field.
Otherwise an integer vector (<code>1L</code> through <code>9L</code> or <code>NA_integer_</code>)
to update the <code>subsecond_digits</code> field with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> objects represent subseconds with two fields:
</p>

<ol>
<li><p> Nanoseconds (as an integer)
</p>
</li>
<li><p> Number of subsecond digits (as an integer)
</p>
</li></ol>

<p>One can explicitly get/set these fields with
</p>

<ul>
<li> <p><code>get_nanosecond()</code> / <code>set_nanosecond()</code>
</p>
</li>
<li> <p><code>get_subsecond_digits()</code> / <code>set_subsecond_digits()</code>
</p>
</li></ul>

<p>We implement <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> support for the following S3 methods from <code>clock</code>:
</p>

<ul>
<li> <p><code>get_millisecond()</code>
</p>
</li>
<li> <p><code>get_microsecond()</code>
</p>
</li>
<li> <p><code>set_millisecond()</code> (note sets any non-zero microsecond/nanosecond elements to zero)
</p>
</li>
<li> <p><code>set_microsecond()</code> (note sets any non-zero nanosecond elements to zero)
</p>
</li></ul>

<p>We implement the following new S3 methods:
</p>

<ul>
<li> <p><code>get_subsecond()</code>
</p>
</li>
<li> <p><code>set_subsecond()</code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>get_millisecond()</code>, <code>get_microsecond()</code>, and <code>get_subsecond()</code> returns an integer vector.
<code>set_millisecond()</code>, <code>set_microsecond()</code>, and <code>set_subsecond()</code> returns a datetime vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("clock")
dt &lt;- as_datetimeoffset("2020-01-01T10:10:10.123456789")
format(dt)
get_millisecond(dt)
get_microsecond(dt)
get_subsecond(dt, 1L)
get_subsecond(dt, 7L)

set_microsecond(dt, 123456L)
set_millisecond(dt, 123L)
set_subsecond(dt, 12L, digits = 2L)
set_subsecond(dt, 12L, digits = 3L)

</code></pre>

<hr>
<h2 id='weekdays.datetimeoffset'>Additional datetime extractors</h2><span id='topic+weekdays.datetimeoffset'></span><span id='topic+months.datetimeoffset'></span><span id='topic+quarters.datetimeoffset'></span><span id='topic+julian.datetimeoffset'></span>

<h3>Description</h3>

<p>Additional datetime extractors for <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datetimeoffset'
weekdays(x, abbreviate = FALSE)

## S3 method for class 'datetimeoffset'
months(x, abbreviate = FALSE)

## S3 method for class 'datetimeoffset'
quarters(x, ...)

## S3 method for class 'datetimeoffset'
julian(x, origin = as.Date("1970-01-01"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weekdays.datetimeoffset_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> datetime</p>
</td></tr>
<tr><td><code id="weekdays.datetimeoffset_+3A_abbreviate">abbreviate</code></td>
<td>
<p>Logical vector for whether the names should be abbreviated</p>
</td></tr>
<tr><td><code id="weekdays.datetimeoffset_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="weekdays.datetimeoffset_+3A_origin">origin</code></td>
<td>
<p>Length one datetime of origin</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We implement <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> support for the following S3 methods from <code>base</code>:
</p>

<ul>
<li> <p><code>weekdays()</code>
</p>
</li>
<li> <p><code>months()</code>
</p>
</li>
<li> <p><code>quarters()</code>
</p>
</li>
<li> <p><code>julian()</code>
</p>
</li></ul>

<p>There is also <code><a href="#topic+datetimeoffset">datetimeoffset()</a></code> support for the following methods from <code>lubridate</code>:
</p>

<ul>
<li> <p><code>isoyear()</code> and <code>epiyear()</code>
</p>
</li>
<li> <p><code>quarter()</code> and <code>semester()</code>
</p>
</li>
<li> <p><code>week()</code>, <code>isoweek()</code>, and <code>epiweek()</code>
</p>
</li>
<li> <p><code>wday()</code> and <code style="white-space: pre;">&#8288;wday&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code>qday()</code> and <code style="white-space: pre;">&#8288;qday&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code>yday()</code> and <code style="white-space: pre;">&#8288;yday&lt;-()&#8288;</code>
</p>
</li>
<li> <p><code>am()</code> and <code>pm()</code>
</p>
</li>
<li> <p><code>days_in_month()</code>
</p>
</li>
<li> <p><code>dst()</code>
</p>
</li>
<li> <p><code>leap_year()</code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>weekdays()</code>, <code>months()</code>, <code>quarters()</code>, <code>julian()</code> return character vectors.
See <code><a href="base.html#topic+weekday.POSIXt">base::weekdays()</a></code> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dto &lt;- datetimeoffset_now()
print(dto)
weekdays(dto)
months(dto)
quarters(dto)
julian(dto)

if (require("lubridate")) {
  cat("`isoyear(dto)`: ", isoyear(dto), "\n")
  cat("`epiyear(dto)`: ", epiyear(dto), "\n")
  cat("`semester(dto)`: ", semester(dto), "\n")
  cat("`quarter(dto)`: ", quarter(dto), "\n")
  cat("`week(dto)`: ", week(dto), "\n")
  cat("`isoweek(dto)`: ", isoweek(dto), "\n")
  cat("`epiweek(dto)`: ", epiweek(dto), "\n")
  cat("`wday(dto)`: ", wday(dto), "\n")
  cat("`qday(dto)`: ", qday(dto), "\n")
  cat("`yday(dto)`: ", yday(dto), "\n")
  cat("`am(dto)`: ", am(dto), "\n")
  cat("`pm(dto)`: ", pm(dto), "\n")
  cat("`days_in_month(dto)`: ", days_in_month(dto), "\n")
  cat("`dst(dto)`: ", dst(dto), "\n")
  cat("`leap_year(dto)`: ", leap_year(dto), "\n")
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
