<!DOCTYPE html><html><head><title>Help for package CondCopulas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CondCopulas}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bCond.estParamCopula'><p>Estimation of the conditional parameters of a parametric conditional</p>
copula with discrete conditioning events.</a></li>
<li><a href='#bCond.pobs'><p>Computing the pseudo-observations in case of discrete</p>
conditioning events</a></li>
<li><a href='#bCond.simpA.CKT'><p>Function for testing the simplifying assumption with</p>
data-driven box-type conditioning events</a></li>
<li><a href='#bCond.simpA.param'><p>Test of the assumption that a conditional copulas does not vary</p>
through a list of discrete conditioning events</a></li>
<li><a href='#bCond.treeCKT'><p>Construct a binary tree for the modeling the conditional Kendall's tau</p></a></li>
<li><a href='#CKT.estimate'><p>Estimation of conditional Kendall's tau</p>
between two variables X1 and X2 given Z = z</a></li>
<li><a href='#CKT.fit.GLM'><p>Estimation of conditional Kendall's taus by penalized GLM</p></a></li>
<li><a href='#CKT.fit.nNets'><p>Estimation of conditional Kendall's taus by model averaging of neural networks</p></a></li>
<li><a href='#CKT.fit.randomForest'><p>Fit a Random Forest that can be used for the estimation of conditional Kendall's tau.</p></a></li>
<li><a href='#CKT.fit.tree'><p>Estimation of conditional Kendall's taus using a classification tree</p></a></li>
<li><a href='#CKT.hCV.l1out'><p>Choose the bandwidth for kernel estimation of</p>
conditional Kendall's tau using cross-validation</a></li>
<li><a href='#CKT.kendallReg.fit'><p>Fit Kendall's regression, a GLM-type model for conditional Kendall's tau</p></a></li>
<li><a href='#CKT.KendallReg.LambdaCV'><p>Kendall's regression: choice of the penalization parameter by K-folds cross-validation</p></a></li>
<li><a href='#CKT.kernel'><p>Estimation of conditional Kendall's tau using kernel smoothing</p></a></li>
<li><a href='#CKT.predict.kNN'><p>Prediction of conditional Kendall's tau using nearest neighbors</p></a></li>
<li><a href='#CKT.predict.nNets'><p>Predict the values of conditional Kendall's tau</p>
using Model Averaging of Neural Networks</a></li>
<li><a href='#CKTmatrix.kernel'><p>Estimate the conditional Kendall's tau matrix</p>
at different conditioning points</a></li>
<li><a href='#computeKernelMatrix'><p>Computing the kernel matrix</p></a></li>
<li><a href='#computeMatrixSignPairs'><p>Compute the matrix of signs of pairs</p></a></li>
<li><a href='#conv_treeCKT'><p>Converting to matrix of indicators / matrix of conditional Kendall's tau</p></a></li>
<li><a href='#datasetPairs'><p>Construct a dataset of pairs of observations for the estimation</p>
of conditional Kendall's tau</a></li>
<li><a href='#estimateCondCDF_matrix'><p>Compute kernel-based conditional marginal (univariate) cdfs</p></a></li>
<li><a href='#estimateCondCDF_vec'><p>Compute kernel-based conditional marginal (univariate) cdfs</p></a></li>
<li><a href='#estimateCondQuantiles'><p>Compute kernel-based conditional quantiles</p></a></li>
<li><a href='#estimateNPCondCopula'><p>Compute a kernel-based estimator of the conditional copula</p></a></li>
<li><a href='#estimateParCondCopula'><p>Estimation of parametric conditional copulas</p></a></li>
<li><a href='#simpA.kendallReg'><p>Test of the simplifying assumption using the constancy</p>
of conditional Kendall's tau</a></li>
<li><a href='#simpA.NP'><p>Nonparametric testing of the simplifying assumption</p></a></li>
<li><a href='#simpA.param'><p>Semiparametric testing of the simplifying assumption</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation and Inference for Conditional Copula Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-22</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Provides functions for the estimation of conditional copulas models,
    various estimators of conditional Kendall's tau
    (proposed in Derumigny and Fermanian (2019a, 2019b, 2020)
    &lt;<a href="https://doi.org/10.1515%2Fdemo-2019-0016">doi:10.1515/demo-2019-0016</a>&gt;,
    &lt;<a href="https://doi.org/10.1016%2Fj.csda.2019.01.013">doi:10.1016/j.csda.2019.01.013</a>&gt;,
    &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2020.104610">doi:10.1016/j.jmva.2020.104610</a>&gt;),
    and test procedures for the simplifying assumption
    (proposed in Derumigny and Fermanian (2017) &lt;<a href="https://doi.org/10.1515%2Fdemo-2017-0011">doi:10.1515/demo-2017-0011</a>&gt;
    and Derumigny, Fermanian and Min (2022) &lt;<a href="https://doi.org/10.1002%2Fcjs.11742">doi:10.1002/cjs.11742</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, knitr, rmarkdown, ggplot2, mvtnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>VineCopula, pbapply, glmnet, ordinalNet, tree, nnet,
data.tree, statmod, wdm</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AlexisDerumigny/CondCopulas/issues">https://github.com/AlexisDerumigny/CondCopulas/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AlexisDerumigny/CondCopulas">https://github.com/AlexisDerumigny/CondCopulas</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-26 15:23:59 UTC; aderumigny</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexis Derumigny <a href="https://orcid.org/0000-0002-6163-8097"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jean-David Fermanian
    <a href="https://orcid.org/0000-0001-5960-5555"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb, ths],
  Aleksey Min <a href="https://orcid.org/0000-0001-6928-4556"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Rutger van der Spek [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexis Derumigny &lt;a.f.f.derumigny@tudelft.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-26 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bCond.estParamCopula'>Estimation of the conditional parameters of a parametric conditional
copula with discrete conditioning events.</h2><span id='topic+bCond.estParamCopula'></span>

<h3>Description</h3>

<p>By Sklar's theorem, any conditional distribution function
can be written as
</p>
<p style="text-align: center;"><code class="reqn">F_{1,2|A}(x_1, x_2) = c_{1,2|A}(F_{1|A}(x_1), F_{2,A}(x_2)),</code>
</p>

<p>where <code class="reqn">A</code> is an event and
<code class="reqn">c_{1,2|A}</code> is a copula depending on the event <code class="reqn">A</code>.
In this function, we assume that we have a partition <code class="reqn">A_1,... A_p</code>
of the probability space, and that for each <code class="reqn">k=1,...,p</code>,
the conditional copula is parametric according to the following model
</p>
<p style="text-align: center;"><code class="reqn">c_{1,2|Ak} = c_{\theta(Ak)},</code>
</p>

<p>for some parameter <code class="reqn">\theta(Ak)</code> depending on the realized event <code class="reqn">Ak</code>.
This function uses canonical maximum likelihood to estimate
<code class="reqn">\theta(Ak)</code> and the corresponding copulas <code class="reqn">c_{1,2|Ak}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bCond.estParamCopula(U1, U2, family, partition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bCond.estParamCopula_+3A_u1">U1</code></td>
<td>
<p>vector of <code>n</code> conditional pseudo-observations
of the first conditioned variable.</p>
</td></tr>
<tr><td><code id="bCond.estParamCopula_+3A_u2">U2</code></td>
<td>
<p>vector of <code>n</code> conditional pseudo-observations
of the second conditioned variable.</p>
</td></tr>
<tr><td><code id="bCond.estParamCopula_+3A_family">family</code></td>
<td>
<p>the family of conditional copulas
used for each conditioning event <code class="reqn">A_k</code>. If not of length <code class="reqn">p</code>,
it is recycled to match the number of events <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="bCond.estParamCopula_+3A_partition">partition</code></td>
<td>
<p>matrix of size <code>n * p</code>,
where <code>p</code> is the number of conditioning events that are considered.
partition[i,j] should be the indicator of whether the <code>i</code>-th observation
belongs or not to the <code>j</code>-th conditioning event</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of size <code>p</code> containing the <code>p</code> conditional copulas
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2017).
About tests of the “simplifying” assumption for conditional copulas.
Dependence Modeling, 5(1), 154-197.
<a href="https://doi.org/10.1515/demo-2017-0011">doi:10.1515/demo-2017-0011</a>
</p>
<p>Derumigny, A., &amp; Fermanian, J. D. (2022)
Conditional empirical copula processes and generalized dependence measures
Electronic Journal of Statistics, 16(2), 5692-5719.
<a href="https://doi.org/10.1214/22-EJS2075">doi:10.1214/22-EJS2075</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bCond.pobs">bCond.pobs</a></code> for the computation
of (conditional) pseudo-observations in this framework.
</p>
<p><code><a href="#topic+bCond.simpA.param">bCond.simpA.param</a></code> for a test of the simplifying assumption
that all these conditional copulas are equal
(assuming they all belong to the same parametric family).
<code><a href="#topic+bCond.simpA.CKT">bCond.simpA.CKT</a></code> for a test of the simplifying assumption
that all these conditional copulas are equal,
based on the equality of conditional Kendall's tau.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 800
Z = stats::runif(n = n)
CKT = 0.2 * as.numeric(Z &lt;= 0.3) +
  0.5 * as.numeric(Z &gt; 0.3 &amp; Z &lt;= 0.5) +
  - 0.8 * as.numeric(Z &gt; 0.5)
simCopula = VineCopula::BiCopSim(N = n,
  par = VineCopula::BiCopTau2Par(CKT, family = 1), family = 1)
X1 = simCopula[,1]
X2 = simCopula[,2]
partition = cbind(Z &lt;= 0.3, Z &gt; 0.3 &amp; Z &lt;= 0.5, Z &gt; 0.5)
condPseudoObs = bCond.pobs(X = cbind(X1, X2), partition = partition)

estimatedCondCopulas = bCond.estParamCopula(
  U1 = condPseudoObs[,1], U2 = condPseudoObs[,2],
  family = 1, partition = partition)
print(estimatedCondCopulas)
# Comparison with the true conditional parameters: 0.2, 0.5, -0.8.


</code></pre>

<hr>
<h2 id='bCond.pobs'>Computing the pseudo-observations in case of discrete
conditioning events</h2><span id='topic+bCond.pobs'></span>

<h3>Description</h3>

<p>Let <code class="reqn">A_1, ..., A_p</code> be <code class="reqn">p</code> events forming a partition of
a probability space and <code class="reqn">X_1, ..., X_d</code> be <code class="reqn">d</code> random variables.
Assume that we observe <code class="reqn">n</code> i.i.d. replications of <code class="reqn">(X_1, ..., X_d)</code>,
and that for each <code class="reqn">i=1, ..., d</code>,
</p>
<p style="text-align: center;"><code class="reqn">V_{i,j|A} = F_{X_j | A_k}(X_{i,j} | A_k),</code>
</p>

<p>we also know which of the <code class="reqn">A_k</code> was realized.
This function computes the pseudo-observations
where <code class="reqn">k</code> is such that the event <code class="reqn">A_k</code>
is realized for the <code class="reqn">i</code>-th observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bCond.pobs(X, partition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bCond.pobs_+3A_x">X</code></td>
<td>
<p>matrix of size <code>n * d</code> observations of conditioned variables.</p>
</td></tr>
<tr><td><code id="bCond.pobs_+3A_partition">partition</code></td>
<td>
<p>matrix of size <code>n * p</code>,
where <code>p</code> is the number of conditioning events that are considered.
partition[i,k] should be the indicator of whether the <code>i</code>-th observation
belongs or not to the <code>k</code>-th conditioning event.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size <code>n * d</code>
containing the conditional pseudo-observations <code class="reqn">V_{i,j|A}</code>.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2017).
About tests of the “simplifying” assumption for conditional copulas.
Dependence Modeling, 5(1), 154-197.
<a href="https://doi.org/10.1515/demo-2017-0011">doi:10.1515/demo-2017-0011</a>
</p>
<p>Derumigny, A., &amp; Fermanian, J. D. (2022)
Conditional empirical copula processes and generalized dependence measures
Electronic Journal of Statistics, 16(2), 5692-5719.
<a href="https://doi.org/10.1214/22-EJS2075">doi:10.1214/22-EJS2075</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bCond.estParamCopula">bCond.estParamCopula</a></code> for the estimation
of a (conditional) parametric copula model in this framework.
</p>
<p><code><a href="#topic+bCond.treeCKT">bCond.treeCKT</a></code> that provides a binary tree
based on conditional Kendall's tau
and that can be used to derive relevant conditioning events.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 800
Z = stats::runif(n = n)
CKT = 0.2 * as.numeric(Z &lt;= 0.3) +
  0.5 * as.numeric(Z &gt; 0.3 &amp; Z &lt;= 0.5) +
  - 0.8 * as.numeric(Z &gt; 0.5)
simCopula = VineCopula::BiCopSim(N = n,
  par = VineCopula::BiCopTau2Par(CKT, family = 1), family = 1)
X1 = simCopula[,1]
X2 = simCopula[,2]
partition = cbind(Z &lt;= 0.3, Z &gt; 0.3 &amp; Z &lt;= 0.5, Z &gt; 0.5)
condPseudoObs = bCond.pobs(X = cbind(X1, X2),
                           partition = partition)

</code></pre>

<hr>
<h2 id='bCond.simpA.CKT'>Function for testing the simplifying assumption with
data-driven box-type conditioning events</h2><span id='topic+bCond.simpA.CKT'></span>

<h3>Description</h3>

<p>This function takes in parameter the matrix of (observations) of the
conditioned variables and either <code>matrixInd</code>, a matrix of indicator variables
describing which events occur for which observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bCond.simpA.CKT(
  XI,
  XJ = NULL,
  matrixInd = NULL,
  minCut = 0,
  minProb = 0.01,
  minSize = minProb * nrow(XI),
  nPoints_xJ = 10,
  type.quantile = 7,
  verbose = 2,
  methodTree = "doSplit",
  propTree = 0.5,
  methodPvalue = "bootNP",
  nBootstrap = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bCond.simpA.CKT_+3A_xi">XI</code></td>
<td>
<p>matrix of size n*p of observations of the conditioned variables.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_xj">XJ</code></td>
<td>
<p>matrix of size n*(d-p) containing observations of the conditioning vector.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_matrixind">matrixInd</code></td>
<td>
<p>a matrix of indexes of size (n, N.boxes) describing
for each observation i to which box ( = event) it belongs.
</p>
<p>If it is <code>NULL</code>, then a tree will be estimated to provide relevant boxes
(by using <code><a href="#topic+bCond.treeCKT">bCond.treeCKT</a>()</code>)
and then converting to a <code>matrixInd</code> by <code><a href="#topic+treeCKT2matrixInd">treeCKT2matrixInd</a>()</code>.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_mincut">minCut</code></td>
<td>
<p>minimum difference in probabilities that is necessary to cut.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_minprob">minProb</code></td>
<td>
<p>minimum probability of being in one of the node.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_minsize">minSize</code></td>
<td>
<p>minimum number of observations in each node.
This is an alternative to minProb and has priority over it.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_npoints_xj">nPoints_xJ</code></td>
<td>
<p>number of points in the grid that are considered
when choosing the point for splitting the tree.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_type.quantile">type.quantile</code></td>
<td>
<p>way of computing the quantiles,
see <code>stats::<a href="stats.html#topic+quantile">quantile</a>()</code>.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_verbose">verbose</code></td>
<td>
<p>control the text output of the procedure.
If <code>verbose = 0</code>, suppress all output.
If <code>verbose = 2</code>, the progress of the computation
is printed during the computation.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_methodtree">methodTree</code></td>
<td>
<p>method for constructing the tree
</p>

<ul>
<li> <p><code>doSplit</code> some part of the data is used for constructing the tree
and the other part for constructing the test statistic
using the boxes defined by the estimated tree.
The share of the data used for construction the tree is controlled by
the parameter <code>propTree</code>.
</p>
</li>
<li> <p><code>noSplit</code> all of the data is used for
both the tree and the test statistic on it.
Note that p-values obtained by this method have an upward bias
due to the lack of independence between these two steps.
</p>
</li></ul>

<p>Only used if <code>matrixInd</code> is not provided.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_proptree">propTree</code></td>
<td>
<p>share of observations used to build the tree
(the rest of the observations are used for the computation of the p-value).
Only used if <code>matrixInd</code> is not provided.</p>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_methodpvalue">methodPvalue</code></td>
<td>
<p>method for computing the p-value </p>

<ul>
<li> <p><code>covMatrix</code> by computation of the covariance matrix of
the random vector <code class="reqn">(\tau_{i,k|X_J \in A_j}, 1\leq,i,k\leq p, 1\leq j \leq m)</code>.
</p>
</li>
<li> <p><code>bootNP</code> by the usual non-parametric bootstrap
</p>
</li>
<li> <p><code>bootInd</code> by the independent bootstrap
</p>
</li></ul>
</td></tr>
<tr><td><code id="bCond.simpA.CKT_+3A_nbootstrap">nBootstrap</code></td>
<td>
<p>number of bootstrap replications
(Only used if <code>methodPvalue</code> is not <code>covMatrix</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following components </p>

<ul>
<li> <p><code>p.value</code> the estimated p-value.
</p>
</li>
<li> <p><code>stat</code> the test statistic.
</p>
</li>
<li> <p><code>treeCKT</code> the estimated tree if <code>matrixInd</code> is not provided.
</p>
</li>
<li> <p><code>vec_statB</code> the vector of bootstrapped statistics
if <code>methodPvalue</code> is not <code>covMatrix</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexis Derumigny, Jean-David Fermanian and Aleksey Min
</p>


<h3>References</h3>

<p>Derumigny, A., Fermanian, J. D., &amp; Min, A. (2022).
Testing for equality between conditional copulas
given discretized conditioning events.
Canadian Journal of Statistics.
<a href="https://doi.org/10.1002/cjs.11742">doi:10.1002/cjs.11742</a>
</p>
<p>Derumigny, A., &amp; Fermanian, J. D. (2022)
Conditional empirical copula processes and generalized dependence measures
Electronic Journal of Statistics, 16(2), 5692-5719.
<a href="https://doi.org/10.1214/22-EJS2075">doi:10.1214/22-EJS2075</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bCond.simpA.param">bCond.simpA.param</a></code> for a test of this simplifying assumption
in a parametric framework.
</p>
<p><code><a href="#topic+bCond.treeCKT">bCond.treeCKT</a></code> provides the binary tree that is used in this function
(if <code>matrixInd</code> is not provided).
</p>
<p>Tests of the simplifying assumption for conditional copulas with a continuous
conditioning variable:
</p>

<ul>
<li> <p><code><a href="#topic+simpA.NP">simpA.NP</a></code> in a nonparametric setting
</p>
</li>
<li> <p><code><a href="#topic+simpA.param">simpA.param</a></code> in a (semi)parametric setting,
where the conditional copula belongs to a parametric family,
but the conditional margins are estimated arbitrarily through
kernel smoothing
</p>
</li>
<li> <p><code><a href="#topic+simpA.kendallReg">simpA.kendallReg</a></code>: test based on the constancy of
conditional Kendall's tau
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 200
XJ = MASS::mvrnorm(n = n, mu = c(3,3), Sigma = rbind(c(1, 0.2), c(0.2, 1)))
XI = matrix(nrow = n, ncol = 2)
high_XJ1 = which(XJ[,1] &gt; 4)
XI[high_XJ1, ]  = MASS::mvrnorm(n = length(high_XJ1), mu = c(10,10),
                                Sigma = rbind(c(1, 0.8), c(0.8, 1)))
XI[-high_XJ1, ] = MASS::mvrnorm(n = n - length(high_XJ1), mu = c(8,8),
                                Sigma = rbind(c(1, -0.2), c(-0.2, 1)))

result = bCond.simpA.CKT(XI = XI, XJ = XJ, minSize = 10, verbose = 2,
                         methodTree = "doSplit", nBootstrap = 4)
print(result$p.value)
result2 = bCond.simpA.CKT(XI = XI, XJ = XJ, minSize = 10, verbose = 2,
                          methodTree = "noSplit", nBootstrap = 4)
print(result2$p.value)


</code></pre>

<hr>
<h2 id='bCond.simpA.param'>Test of the assumption that a conditional copulas does not vary
through a list of discrete conditioning events</h2><span id='topic+bCond.simpA.param'></span>

<h3>Description</h3>

<p>Test of the assumption that a conditional copulas does not vary
through a list of discrete conditioning events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bCond.simpA.param(
  X1,
  X2,
  partition,
  family,
  testStat = "T2c_tau",
  typeBoot = "boot.NP",
  nBootstrap = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bCond.simpA.param_+3A_x1">X1</code></td>
<td>
<p>vector of <code>n</code> observations of the first conditioned variable.</p>
</td></tr>
<tr><td><code id="bCond.simpA.param_+3A_x2">X2</code></td>
<td>
<p>vector of <code>n</code> observations of the second conditioned variable.</p>
</td></tr>
<tr><td><code id="bCond.simpA.param_+3A_partition">partition</code></td>
<td>
<p>matrix of size <code>n * p</code>,
where <code>p</code> is the number of conditioning events that are considered.
partition[i,j] should be the indicator of whether the <code>i</code>-th observation
belongs or not to the <code>j</code>-th conditioning event.</p>
</td></tr>
<tr><td><code id="bCond.simpA.param_+3A_family">family</code></td>
<td>
<p>family of parametric copulas used</p>
</td></tr>
<tr><td><code id="bCond.simpA.param_+3A_teststat">testStat</code></td>
<td>
<p>test statistic used. Possible choices are
</p>

<ul>
<li> <p><code>T2c_par</code> <code class="reqn">\sum_{box} (\theta_0 - \theta(box))^2</code>
</p>
</li>
<li> <p><code>T2c_tau</code> Same as above, except that the copula family is now parametrized
by its Kendall's tau instead of its natural parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bCond.simpA.param_+3A_typeboot">typeBoot</code></td>
<td>
<p>type of bootstrap used</p>
</td></tr>
<tr><td><code id="bCond.simpA.param_+3A_nbootstrap">nBootstrap</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>true_stat</code>:
the value of the test statistic computed on the whole sample
</p>
</li>
<li> <p><code>vect_statB</code>:
a vector of length <code>nBootstrap</code> containing the bootstrapped
test statistics.
</p>
</li>
<li> <p><code>p_val</code>: the p-value of the test.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2017).
About tests of the “simplifying” assumption for conditional copulas.
Dependence Modeling, 5(1), 154-197.
<a href="https://doi.org/10.1515/demo-2017-0011">doi:10.1515/demo-2017-0011</a>
</p>
<p>Derumigny, A., &amp; Fermanian, J. D. (2022)
Conditional empirical copula processes and generalized dependence measures
Electronic Journal of Statistics, 16(2), 5692-5719.
<a href="https://doi.org/10.1214/22-EJS2075">doi:10.1214/22-EJS2075</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bCond.estParamCopula">bCond.estParamCopula</a></code> for the estimation
of a (conditional) parametric copula model in this framework.
</p>
<p><code><a href="#topic+bCond.simpA.CKT">bCond.simpA.CKT</a></code> for a test of the simplifying assumption
that all these conditional copulas are equal,
based on the equality of conditional Kendall's tau
(i.e. without any parametric assumption).
</p>
<p>Tests of the simplifying assumption for conditional copulas with a continuous
conditioning variable:
</p>

<ul>
<li> <p><code><a href="#topic+simpA.NP">simpA.NP</a></code> in a nonparametric setting
</p>
</li>
<li> <p><code><a href="#topic+simpA.param">simpA.param</a></code> in a (semi)parametric setting,
where the conditional copula belongs to a parametric family,
but the conditional margins are estimated arbitrarily through
kernel smoothing
</p>
</li>
<li> <p><code><a href="#topic+simpA.kendallReg">simpA.kendallReg</a></code>: test based on the constancy of
conditional Kendall's tau
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>n = 800
Z = stats::runif(n = n)
CKT = 0.2 * as.numeric(Z &lt;= 0.3) +
  0.5 * as.numeric(Z &gt; 0.3 &amp; Z &lt;= 0.5) +
  + 0.3 * as.numeric(Z &gt; 0.5)
family = 3
simCopula = VineCopula::BiCopSim(N = n,
  par = VineCopula::BiCopTau2Par(CKT, family = family), family = family)
X1 = simCopula[,1]
X2 = simCopula[,2]
partition = cbind(Z &lt;= 0.3, Z &gt; 0.3 &amp; Z &lt;= 0.5, Z &gt; 0.5)

result = bCond.simpA.param(X1 = X1, X2 = X2, testStat = "T2c_tau",
  partition = partition, family = family, typeBoot = "boot.paramInd")
print(result$p_val)

n = 800
Z = stats::runif(n = n)
CKT = 0.1
family = 3
simCopula = VineCopula::BiCopSim(N = n,
  par = VineCopula::BiCopTau2Par(CKT, family = family), family = family)
X1 = simCopula[,1]
X2 = simCopula[,2]
partition = cbind(Z &lt;= 0.3, Z &gt; 0.3 &amp; Z &lt;= 0.5, Z &gt; 0.5)

result = bCond.simpA.param(X1 = X1, X2 = X2,
  partition = partition, family = family, typeBoot = "boot.NP")
print(result$p_val)


</code></pre>

<hr>
<h2 id='bCond.treeCKT'>Construct a binary tree for the modeling the conditional Kendall's tau</h2><span id='topic+bCond.treeCKT'></span>

<h3>Description</h3>

<p>This function takes in parameter two matrices of observations:
the first one contains the observations of <code>XI</code> (the conditioned variables)
and the second on contains the observations of <code>XJ</code> (the conditioning variables).
The goal of this procedure is to find which of the variables in <code>XJ</code>
have important influence on the dependence between the components of <code>XI</code>,
(measured by the Kendall's tau).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bCond.treeCKT(
  XI,
  XJ,
  minCut = 0,
  minProb = 0.01,
  minSize = minProb * nrow(XI),
  nPoints_xJ = 10,
  type.quantile = 7,
  verbose = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bCond.treeCKT_+3A_xi">XI</code></td>
<td>
<p>matrix of size n*p of observations of the conditioned variables.</p>
</td></tr>
<tr><td><code id="bCond.treeCKT_+3A_xj">XJ</code></td>
<td>
<p>matrix of size n*(d-p) containing observations of the conditioning vector.</p>
</td></tr>
<tr><td><code id="bCond.treeCKT_+3A_mincut">minCut</code></td>
<td>
<p>minimum difference in probabilities that is necessary to cut.</p>
</td></tr>
<tr><td><code id="bCond.treeCKT_+3A_minprob">minProb</code></td>
<td>
<p>minimum probability of being in one of the node.</p>
</td></tr>
<tr><td><code id="bCond.treeCKT_+3A_minsize">minSize</code></td>
<td>
<p>minimum number of observations in each node.
This is an alternative to minProb and has priority over it.</p>
</td></tr>
<tr><td><code id="bCond.treeCKT_+3A_npoints_xj">nPoints_xJ</code></td>
<td>
<p>number of points in the grid that are considered
when choosing the point for splitting the tree.</p>
</td></tr>
<tr><td><code id="bCond.treeCKT_+3A_type.quantile">type.quantile</code></td>
<td>
<p>way of computing the quantiles,
see <code>stats::<a href="stats.html#topic+quantile">quantile</a>()</code>.</p>
</td></tr>
<tr><td><code id="bCond.treeCKT_+3A_verbose">verbose</code></td>
<td>
<p>control the text output of the procedure.
If <code>verbose = 0</code>, suppress all output.
If <code>verbose = 2</code>, the progress of the computation
is printed during the computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object return by this function is a binary tree. Each leaf of this tree
correspond to one event (or, equivalently, one subset of <code class="reqn">R^{dim(XJ)}</code>),
and the conditional Kendall's tau conditionally to it.
</p>


<h3>Value</h3>

<p>the estimated tree using the data 'XI, XJ'.
</p>


<h3>References</h3>

<p>Derumigny, A., Fermanian, J. D., &amp; Min, A. (2022).
Testing for equality between conditional copulas
given discretized conditioning events.
Canadian Journal of Statistics.
<a href="https://doi.org/10.1002/cjs.11742">doi:10.1002/cjs.11742</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bCond.simpA.CKT">bCond.simpA.CKT</a></code> for a test of the simplifying assumption
that all these conditional Kendall's tau are equal.
</p>
<p><code><a href="#topic+treeCKT2matrixInd">treeCKT2matrixInd</a></code> for converting this tree to a matrix of indicators
of each event. <code><a href="#topic+matrixInd2matrixCKT">matrixInd2matrixCKT</a></code> for getting the matrix of estimated
conditional Kendall's taus for each event.
</p>
<p><code><a href="#topic+CKT.estimate">CKT.estimate</a></code> for the estimation of
pointwise conditional Kendall's tau,
i.e. assuming a continuous conditioning variable <code class="reqn">Z</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 200
XJ = MASS::mvrnorm(n = n, mu = c(3,3), Sigma = rbind(c(1, 0.2), c(0.2, 1)))
XI = matrix(nrow = n, ncol = 2)
high_XJ1 = which(XJ[,1] &gt; 4)
XI[high_XJ1, ]  = MASS::mvrnorm(n = length(high_XJ1), mu = c(10,10),
                                Sigma = rbind(c(1, 0.8), c(0.8, 1)))
XI[-high_XJ1, ] = MASS::mvrnorm(n = n - length(high_XJ1), mu = c(8,8),
                                Sigma = rbind(c(1, -0.2), c(-0.2, 1)))

result = bCond.treeCKT(XI = XI, XJ = XJ, minSize = 50, verbose = 2)

# Number of observations in the first two children
print(length(data.tree::GetAttribute(result$children[[1]], "condObs")))
print(length(data.tree::GetAttribute(result$children[[2]], "condObs")))


</code></pre>

<hr>
<h2 id='CKT.estimate'>Estimation of conditional Kendall's tau
between two variables X1 and X2 given Z = z</h2><span id='topic+CKT.estimate'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal of this function is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
In other words, conditional Kendall's tau is the difference
between the probabilities of observing concordant and discordant pairs
from the conditional law of </p>
<p style="text-align: center;"><code class="reqn">(X_1, X_2) | Z=z.</code>
</p>

<p>This function can use different estimators for conditional Kendall's tau,
see the description of the parameter <code>methodEstimation</code>
for a complete list of possibilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.estimate(
  observedX1, observedX2, observedZ,
  newZ = observedZ, methodEstimation, h,
  listPhi = if(methodEstimation == "kendallReg")
               {list( function(x){return(x)}   ,
                      function(x){return(x^2)} ,
                      function(x){return(x^3)} )
               } else {list(identity)} ,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.estimate_+3A_observedx1">observedX1</code></td>
<td>
<p>a vector of <code class="reqn">n</code> observations of the first variable</p>
</td></tr>
<tr><td><code id="CKT.estimate_+3A_observedx2">observedX2</code></td>
<td>
<p>a vector of <code class="reqn">n</code> observations of the second variable</p>
</td></tr>
<tr><td><code id="CKT.estimate_+3A_observedz">observedZ</code></td>
<td>
<p>a vector of <code class="reqn">n</code> observations of the conditioning variable,
or a matrix with <code class="reqn">n</code> rows of observations of the conditioning vector
(if <code class="reqn">Z</code> is multivariate).</p>
</td></tr>
<tr><td><code id="CKT.estimate_+3A_newz">newZ</code></td>
<td>
<p>the new values for the conditioning variable <code class="reqn">Z</code>
at which the conditional Kendall's tau should be estimated.
</p>

<ul>
<li><p> If <code>observedZ</code> is a vector,
then <code>newZ</code> must be a vector as well.
</p>
</li>
<li><p> If <code>observedZ</code> is a matrix,
then <code>newZ</code> must be a matrix as well, with the same number of columns
( = the dimension of <code class="reqn">Z</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="CKT.estimate_+3A_methodestimation">methodEstimation</code></td>
<td>
<p>method for estimating the conditional Kendall's tau.
Possible estimation methods are:
</p>

<ul>
<li> <p><code>"kernel"</code>: kernel smoothing,
as described in (Derumigny, &amp; Fermanian (2019a))
</p>
</li>
<li> <p><code>"kendallReg"</code>: regression-type model,
as described in (Derumigny, &amp; Fermanian (2020))
</p>
</li>
<li> <p><code>"tree"</code>, <code>"randomForest"</code>,
<code>"logit"</code>, and <code>"neuralNetwork"</code>:
use the relationship between conditional Kendall's tau
and classification problems to use the respective classification algorithms
for the estimation of conditional Kendall's tau,
as described in (Derumigny, &amp; Fermanian (2019b))
</p>
</li></ul>
</td></tr>
<tr><td><code id="CKT.estimate_+3A_h">h</code></td>
<td>
<p>the bandwidth</p>
</td></tr>
<tr><td><code id="CKT.estimate_+3A_listphi">listPhi</code></td>
<td>
<p>the list of transformations to be applied
to the conditioning variable <code class="reqn">Z</code>
(in case of regression-type models).</p>
</td></tr>
<tr><td><code id="CKT.estimate_+3A_...">...</code></td>
<td>
<p>other parameters passed to the estimating functions
<code><a href="#topic+CKT.fit.tree">CKT.fit.tree</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.GLM">CKT.fit.GLM</a></code>, <code><a href="#topic+CKT.fit.nNets">CKT.fit.nNets</a></code>,
<code><a href="#topic+CKT.predict.kNN">CKT.predict.kNN</a></code>, <code><a href="#topic+CKT.kernel">CKT.kernel</a></code>
and <code><a href="#topic+CKT.kendallReg.fit">CKT.kendallReg.fit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector of estimated conditional Kendall's tau
at each of the observations of <code>newZ</code>.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019a).
A classification point-of-view about conditional Kendall’s tau.
Computational Statistics &amp; Data Analysis, 135, 70-94.
<a href="https://doi.org/10.1016/j.csda.2019.01.013">doi:10.1016/j.csda.2019.01.013</a>
</p>
<p>Derumigny, A., &amp; Fermanian, J. D. (2019b).
On kernel-based estimation of conditional Kendall’s tau:
finite-distance bounds and asymptotic behavior.
Dependence Modeling, 7(1), 292-321.
<a href="https://doi.org/10.1515/demo-2019-0016">doi:10.1515/demo-2019-0016</a>
</p>
<p>Derumigny, A., &amp; Fermanian, J. D. (2020).
On Kendall’s regression.
Journal of Multivariate Analysis, 178, 104610.
<a href="https://doi.org/10.1016/j.jmva.2020.104610">doi:10.1016/j.jmva.2020.104610</a>
</p>


<h3>See Also</h3>

<p>the specialized functions for estimating
conditional Kendall's tau for each method:
<code><a href="#topic+CKT.fit.tree">CKT.fit.tree</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.GLM">CKT.fit.GLM</a></code>, <code><a href="#topic+CKT.fit.nNets">CKT.fit.nNets</a></code>,
<code><a href="#topic+CKT.predict.kNN">CKT.predict.kNN</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.kernel">CKT.kernel</a></code> and <code><a href="#topic+CKT.kendallReg.fit">CKT.kendallReg.fit</a></code>.
</p>
<p>See also the nonparametric estimator of conditional copula models
<code><a href="#topic+estimateNPCondCopula">estimateNPCondCopula</a></code>,
and the parametric estimators of conditional copula models
<code><a href="#topic+estimateParCondCopula">estimateParCondCopula</a></code>.
</p>
<p>In the case where <code class="reqn">Z</code> is discrete
or in the case of discrete conditioning events, see
<code><a href="#topic+bCond.treeCKT">bCond.treeCKT</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 300
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2,10,by = 0.1)
h = 0.1
estimatedCKT_tree &lt;- CKT.estimate(
  observedX1 = X1, observedX2 = X2, observedZ = Z,
  newZ = newZ,
  methodEstimation = "tree", h = h)

estimatedCKT_rf &lt;- CKT.estimate(
  observedX1 = X1, observedX2 = X2, observedZ = Z,
  newZ = newZ,
  methodEstimation = "randomForest", h = h)

estimatedCKT_GLM &lt;- CKT.estimate(
  observedX1 = X1, observedX2 = X2, observedZ = Z,
  newZ = newZ,
  methodEstimation = "logit", h = h,
  listPhi = list(function(x){return(x)}, function(x){return(x^2)},
                 function(x){return(x^3)}) )

estimatedCKT_kNN &lt;- CKT.estimate(
  observedX1 = X1, observedX2 = X2, observedZ = Z,
  newZ = newZ,
  methodEstimation = "nearestNeighbors", h = h,
  number_nn = c(50,80, 100, 120,200),
  partition = 4
  )

estimatedCKT_nNet &lt;- CKT.estimate(
  observedX1 = X1, observedX2 = X2, observedZ = Z,
  newZ = newZ,
  methodEstimation = "neuralNetwork", h = h,
  )

estimatedCKT_kernel &lt;- CKT.estimate(
  observedX1 = X1, observedX2 = X2, observedZ = Z,
  newZ = newZ,
  methodEstimation = "kernel", h = h,
  )

estimatedCKT_kendallReg &lt;- CKT.estimate(
   observedX1 = X1, observedX2 = X2, observedZ = Z,
   newZ = newZ,
   methodEstimation = "kendallReg", h = h)

# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in other colors)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
   type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_tree, col = "red")
lines(newZ, estimatedCKT_rf, col = "blue")
lines(newZ, estimatedCKT_GLM, col = "green")
lines(newZ, estimatedCKT_kNN, col = "purple")
lines(newZ, estimatedCKT_nNet, col = "coral")
lines(newZ, estimatedCKT_kernel, col = "skyblue")
lines(newZ, estimatedCKT_kendallReg, col = "darkgreen")

</code></pre>

<hr>
<h2 id='CKT.fit.GLM'>Estimation of conditional Kendall's taus by penalized GLM</h2><span id='topic+CKT.fit.GLM'></span><span id='topic+CKT.predict.GLM'></span>

<h3>Description</h3>

<p>The function <code>CKT.fit.GLM</code> fits a regression model for the
conditional Kendall's tau <code class="reqn">\tau_{1,2|Z}</code>
between two variables <code class="reqn">X_1</code> and <code class="reqn">X_2</code>
conditionally to some predictors <code class="reqn">Z</code>.
More precisely, this function fits the model
</p>
<p style="text-align: center;"><code class="reqn">\tau_{1,2|Z} =
2 * \Lambda( \beta_0 + \beta_1 \phi_1(Z) + ... + \beta_p \phi_p(Z) )</code>
</p>

<p>for a link function <code class="reqn">\Lambda</code>,
and <code class="reqn">p</code> real-valued functions <code class="reqn">\phi_1, ..., \phi_p</code>.
The function <code>CKT.predict.GLM</code> predicts the values of
conditional Kendall's tau for some values of the conditioning variable <code class="reqn">Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.fit.GLM(
  datasetPairs,
  designMatrix = datasetPairs[, 2:(ncol(datasetPairs) - 3), drop = FALSE],
  link = "logit",
  ...
)

CKT.predict.GLM(fit, newZ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.fit.GLM_+3A_datasetpairs">datasetPairs</code></td>
<td>
<p>the matrix of pairs and corresponding values of the kernel
as provided by <code><a href="#topic+datasetPairs">datasetPairs</a></code>.</p>
</td></tr>
<tr><td><code id="CKT.fit.GLM_+3A_designmatrix">designMatrix</code></td>
<td>
<p>the matrix of predictor to be used for the fitting of the model.
It should have the same number of rows as the <code>datasetPairs</code>.</p>
</td></tr>
<tr><td><code id="CKT.fit.GLM_+3A_link">link</code></td>
<td>
<p>link function, can be one of
<code>logit</code>, <code>probit</code>, <code>cloglog</code>, <code>cauchit</code>).</p>
</td></tr>
<tr><td><code id="CKT.fit.GLM_+3A_...">...</code></td>
<td>
<p>other parameters passed to
<code>ordinalNet::<a href="ordinalNet.html#topic+ordinalNet">ordinalNet</a>()</code>.</p>
</td></tr>
<tr><td><code id="CKT.fit.GLM_+3A_fit">fit</code></td>
<td>
<p>result of a call to <code>CKT.fit.GLM</code></p>
</td></tr>
<tr><td><code id="CKT.fit.GLM_+3A_newz">newZ</code></td>
<td>
<p>new matrix of observations of the conditioning vector <code class="reqn">Z</code>,
with the same number of variables and same names as the <code>designMatrix</code>
that was used to fit the GLM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CKT.fit.GLM</code> returns the fitted GLM,
an object with S3 class <code>ordinalNet</code>.
</p>
<p><code>CKT.predict.GLM</code> returns
a vector of (predicted) conditional Kendall's taus of the same size
as the number of rows of the matrix <code>newZ</code>.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
A classification point-of-view about conditional Kendall’s tau.
Computational Statistics &amp; Data Analysis, 135, 70-94.
(Algorithm 2)
<a href="https://doi.org/10.1016/j.csda.2019.01.013">doi:10.1016/j.csda.2019.01.013</a>
</p>


<h3>See Also</h3>

<p>See also other estimators of conditional Kendall's tau:
<code><a href="#topic+CKT.fit.tree">CKT.fit.tree</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.nNets">CKT.fit.nNets</a></code>, <code><a href="#topic+CKT.predict.kNN">CKT.predict.kNN</a></code>,
<code><a href="#topic+CKT.kernel">CKT.kernel</a></code>, <code><a href="#topic+CKT.kendallReg.fit">CKT.kendallReg.fit</a></code>,
and the more general wrapper <code><a href="#topic+CKT.estimate">CKT.estimate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 400
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = 2*plogis(-1 + 0.8*Z - 0.1*Z^2) - 1
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
designMatrix = cbind(datasetP[,2], datasetP[,2]^2)
fitCKT_GLM &lt;- CKT.fit.GLM(
  datasetPairs = datasetP, designMatrix = designMatrix,
  maxiterOut = 10, maxiterIn = 5)
print(coef(fitCKT_GLM))
# These are rather close to the true coefficients -1, 0.8, -0.1
# used to generate the data above.

newZ = seq(2,10,by = 0.1)
estimatedCKT_GLM = CKT.predict.GLM(
  fit = fitCKT_GLM, newZ = cbind(newZ, newZ^2))

# Comparison between true Kendall's tau (in red)
# and estimated Kendall's tau (in black)
trueConditionalTau = 2*plogis(-1 + 0.8*newZ - 0.1*newZ^2) - 1
plot(newZ, trueConditionalTau , col="red",
   type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_GLM)

</code></pre>

<hr>
<h2 id='CKT.fit.nNets'>Estimation of conditional Kendall's taus by model averaging of neural networks</h2><span id='topic+CKT.fit.nNets'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal of this function is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
In other words, conditional Kendall's tau is the difference
between the probabilities of observing concordant and discordant pairs
from the conditional law of </p>
<p style="text-align: center;"><code class="reqn">(X_1, X_2) | Z=z.</code>
</p>

<p>This function estimates conditional Kendall's tau using
<strong>neural networks</strong>. This is possible by the relationship between
estimation of conditional Kendall's tau and classification problems
(see Derumigny and Fermanian (2019)): estimation of conditional Kendall's tau
is equivalent to the prediction of concordance in the space of pairs
of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.fit.nNets(
  datasetPairs,
  designMatrix = datasetPairs[, 2:(ncol(datasetPairs) - 3), drop = FALSE],
  vecSize = rep(3, times = 10),
  nObs_per_NN = 0.9 * nrow(designMatrix),
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.fit.nNets_+3A_datasetpairs">datasetPairs</code></td>
<td>
<p>the matrix of pairs and corresponding values of the kernel
as provided by <code><a href="#topic+datasetPairs">datasetPairs</a></code>.</p>
</td></tr>
<tr><td><code id="CKT.fit.nNets_+3A_designmatrix">designMatrix</code></td>
<td>
<p>the matrix of predictor to be used for the fitting of the tree</p>
</td></tr>
<tr><td><code id="CKT.fit.nNets_+3A_vecsize">vecSize</code></td>
<td>
<p>vector with the number of neurons for each network</p>
</td></tr>
<tr><td><code id="CKT.fit.nNets_+3A_nobs_per_nn">nObs_per_NN</code></td>
<td>
<p>number of observations used for each neural network.</p>
</td></tr>
<tr><td><code id="CKT.fit.nNets_+3A_verbose">verbose</code></td>
<td>
<p>a number indicated what to print
</p>

<ul>
<li> <p><code>0</code>: nothing printed at all.
</p>
</li>
<li> <p><code>1</code>: a message is printed at the convergence of each neural network.
</p>
</li>
<li> <p><code>2</code>: details are printed for each optimization of each network.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CKT.fit.nNets</code> returns a list of the fitted neural networks
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
A classification point-of-view about conditional Kendall’s tau.
Computational Statistics &amp; Data Analysis, 135, 70-94.
(Algorithm 7)
<a href="https://doi.org/10.1016/j.csda.2019.01.013">doi:10.1016/j.csda.2019.01.013</a>
</p>


<h3>See Also</h3>

<p>See also other estimators of conditional Kendall's tau:
<code><a href="#topic+CKT.fit.tree">CKT.fit.tree</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.GLM">CKT.fit.GLM</a></code>, <code><a href="#topic+CKT.predict.kNN">CKT.predict.kNN</a></code>,
<code><a href="#topic+CKT.kernel">CKT.kernel</a></code>, <code><a href="#topic+CKT.kendallReg.fit">CKT.kendallReg.fit</a></code>,
and the more general wrapper <code><a href="#topic+CKT.estimate">CKT.estimate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2,10,by = 0.1)
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)

fitCKT_nets &lt;- CKT.fit.nNets(datasetPairs = datasetP)
estimatedCKT_nNets &lt;- CKT.predict.nNets(
  fit = fitCKT_nets, newZ = matrix(newZ, ncol = 1))

# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
   type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_nNets, col = "red")


</code></pre>

<hr>
<h2 id='CKT.fit.randomForest'>Fit a Random Forest that can be used for the estimation of conditional Kendall's tau.</h2><span id='topic+CKT.fit.randomForest'></span><span id='topic+CKT.predict.randomForest'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal of this function is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
In other words, conditional Kendall's tau is the difference
between the probabilities of observing concordant and discordant pairs
from the conditional law of </p>
<p style="text-align: center;"><code class="reqn">(X_1, X_2) | Z=z.</code>
</p>

<p>These functions estimate and predict conditional Kendall's tau using a
<strong>random forest</strong>. This is possible by the relationship between
estimation of conditional Kendall's tau and classification problems
(see Derumigny and Fermanian (2019)): estimation of conditional Kendall's tau
is equivalent to the prediction of concordance in the space of pairs
of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.fit.randomForest(
  datasetPairs,
  designMatrix = data.frame(x = datasetPairs[, 2:(ncol(datasetPairs) - 3)]),
  n,
  nTree = 10,
  mindev = 0.008,
  mincut = 0,
  nObs_per_Tree = ceiling(0.8 * n),
  nVar_per_Tree = ceiling(0.8 * (ncol(datasetPairs) - 4)),
  verbose = FALSE,
  nMaxDepthAllowed = 10
)

CKT.predict.randomForest(fit, newZ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.fit.randomForest_+3A_datasetpairs">datasetPairs</code></td>
<td>
<p>the matrix of pairs and corresponding values of the kernel
as provided by <code><a href="#topic+datasetPairs">datasetPairs</a></code>.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_designmatrix">designMatrix</code></td>
<td>
<p>the matrix of predictor to be used for the fitting of the tree</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_n">n</code></td>
<td>
<p>the original sample size of the dataset</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_ntree">nTree</code></td>
<td>
<p>number of trees of the Random Forest.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_mindev">mindev</code></td>
<td>
<p>a factor giving the minimum deviation for a node to be splitted.
See <code>tree::<a href="tree.html#topic+tree.control">tree.control</a>()</code> for more details.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_mincut">mincut</code></td>
<td>
<p>the minimum number of observations (of pairs) in a node
See <code>tree::<a href="tree.html#topic+tree.control">tree.control</a>()</code> for more details.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_nobs_per_tree">nObs_per_Tree</code></td>
<td>
<p>number of observations kept in each tree.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_nvar_per_tree">nVar_per_Tree</code></td>
<td>
<p>number of variables kept in each tree.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, a message is printed after fitting each tree.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_nmaxdepthallowed">nMaxDepthAllowed</code></td>
<td>
<p>the maximum number of errors of type
&quot;the tree cannot be fitted&quot; or &quot;is too deep&quot; before stopping the procedure.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_fit">fit</code></td>
<td>
<p>result of a call to <code>CKT.fit.randomForest</code>.</p>
</td></tr>
<tr><td><code id="CKT.fit.randomForest_+3A_newz">newZ</code></td>
<td>
<p>new matrix of observations, with the same number of variables.
and same names as the <code>designMatrix</code> that was used to fit the Random Forest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two components
</p>

<ul>
<li> <p><code>list_tree</code> a list of size <code>nTree</code>
composed of all the fitted trees.
</p>
</li>
<li> <p><code>list_variables</code> a list of size <code>nTree</code>
composed of the (predictor) variables for each tree.
</p>
</li></ul>

<p><code>CKT.predict.randomForest</code> returns
a vector of (predicted) conditional Kendall's taus of the same size
as the number of rows of the newZ.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
A classification point-of-view about conditional Kendall’s tau.
Computational Statistics &amp; Data Analysis, 135, 70-94.
(Algorithm 4)
<a href="https://doi.org/10.1016/j.csda.2019.01.013">doi:10.1016/j.csda.2019.01.013</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
est_RF = CKT.fit.randomForest(datasetPairs = datasetP, n = N,
  mindev = 0.008)

newZ = seq(1,10,by = 0.1)
prediction = CKT.predict.randomForest(fit = est_RF,
   newZ = data.frame(x=newZ))
# Comparison between true Kendall's tau (in red)
# and estimated Kendall's tau (in black)
plot(newZ, prediction, type = "l", ylim = c(-1,1))
lines(newZ, -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2), col="red")

</code></pre>

<hr>
<h2 id='CKT.fit.tree'>Estimation of conditional Kendall's taus using a classification tree</h2><span id='topic+CKT.fit.tree'></span><span id='topic+CKT.predict.tree'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal of this function is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
In other words, conditional Kendall's tau is the difference
between the probabilities of observing concordant and discordant pairs
from the conditional law of </p>
<p style="text-align: center;"><code class="reqn">(X_1, X_2) | Z=z.</code>
</p>

<p>These functions estimate and predict conditional Kendall's tau using a
<strong>classification tree</strong>. This is possible by the relationship between
estimation of conditional Kendall's tau and classification problems
(see Derumigny and Fermanian (2019)): estimation of conditional Kendall's tau
is equivalent to the prediction of concordance in the space of pairs
of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.fit.tree(datasetPairs, mindev = 0.008, mincut = 0)

CKT.predict.tree(fit, newZ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.fit.tree_+3A_datasetpairs">datasetPairs</code></td>
<td>
<p>the matrix of pairs and corresponding values of the kernel
as provided by <code><a href="#topic+datasetPairs">datasetPairs</a></code>.</p>
</td></tr>
<tr><td><code id="CKT.fit.tree_+3A_mindev">mindev</code></td>
<td>
<p>a factor giving the minimum deviation for a node to be splitted.
See <code>tree::<a href="tree.html#topic+tree.control">tree.control</a>()</code> for more details.</p>
</td></tr>
<tr><td><code id="CKT.fit.tree_+3A_mincut">mincut</code></td>
<td>
<p>the minimum number of observations (of pairs) in a node
See <code>tree::<a href="tree.html#topic+tree.control">tree.control</a>()</code> for more details.</p>
</td></tr>
<tr><td><code id="CKT.fit.tree_+3A_fit">fit</code></td>
<td>
<p>result of a call to <code>CKT.fit.tree</code></p>
</td></tr>
<tr><td><code id="CKT.fit.tree_+3A_newz">newZ</code></td>
<td>
<p>new matrix of observations, with the same number of variables.
and same names as the <code>designMatrix</code> that was used to fit the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CKT.fit.tree</code> returns the fitted tree.
</p>
<p><code>CKT.predict.tree</code> returns
a vector of (predicted) conditional Kendall's taus of the same size
as the number of rows of <code>newZ</code>.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
A classification point-of-view about conditional Kendall’s tau.
Computational Statistics &amp; Data Analysis, 135, 70-94.
(Section 3.2)
<a href="https://doi.org/10.1016/j.csda.2019.01.013">doi:10.1016/j.csda.2019.01.013</a>
</p>


<h3>See Also</h3>

<p>See also other estimators of conditional Kendall's tau:
<code><a href="#topic+CKT.fit.nNets">CKT.fit.nNets</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.GLM">CKT.fit.GLM</a></code>, <code><a href="#topic+CKT.predict.kNN">CKT.predict.kNN</a></code>,
<code><a href="#topic+CKT.kernel">CKT.kernel</a></code>, <code><a href="#topic+CKT.kendallReg.fit">CKT.kendallReg.fit</a></code>,
and the more general wrapper <code><a href="#topic+CKT.estimate">CKT.estimate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
est_Tree = CKT.fit.tree(datasetPairs = datasetP, mindev = 0.008)
print(est_Tree)

newZ = seq(1,10,by = 0.1)
prediction = CKT.predict.tree(fit = est_Tree, newZ = data.frame(x=newZ))
# Comparison between true Kendall's tau (in red)
# and estimated Kendall's tau (in black)
plot(newZ, prediction, type = "l", ylim = c(-1,1))
lines(newZ, -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2), col="red")

</code></pre>

<hr>
<h2 id='CKT.hCV.l1out'>Choose the bandwidth for kernel estimation of
conditional Kendall's tau using cross-validation</h2><span id='topic+CKT.hCV.l1out'></span><span id='topic+CKT.hCV.Kfolds'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal here is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
For this, a kernel-based estimator is used, as described in
(Derumigny &amp; Fermanian (2019)).
These functions aims at finding the best bandwidth <code>h</code> among a given
<code>range_h</code> by cross-validation. They use either:
</p>

<ul>
<li> <p><strong>leave-one-out</strong> cross-validation:
function <code>CKT.hCV.l1out</code>
</p>
</li>
<li><p> or <strong>K-folds</strong> cross-validation:
function <code>CKT.hCV.Kfolds</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>CKT.hCV.l1out(
  observedX1,
  observedX2,
  observedZ,
  range_h,
  matrixSignsPairs = NULL,
  nPairs = 10 * length(observedX1),
  typeEstCKT = "wdm",
  kernel.name = "Epa",
  progressBar = TRUE,
  verbose = FALSE
)

CKT.hCV.Kfolds(
  observedX1,
  observedX2,
  observedZ,
  ZToEstimate,
  range_h,
  matrixSignsPairs = NULL,
  typeEstCKT = "wdm",
  kernel.name = "Epa",
  Kfolds = 5,
  progressBar = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.hCV.l1out_+3A_observedx1">observedX1</code></td>
<td>
<p>a vector of <code>n</code> observations of the first variable</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_observedx2">observedX2</code></td>
<td>
<p>a vector of <code>n</code> observations of the second variable</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_observedz">observedZ</code></td>
<td>
<p>observedZ vector of observed values of Z.
If Z is multivariate, then this is a matrix whose rows correspond
to the observations of Z</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_range_h">range_h</code></td>
<td>
<p>vector containing possible values for the bandwidth.</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_matrixsignspairs">matrixSignsPairs</code></td>
<td>
<p>square matrix of signs of all pairs,
produced by <code><a href="#topic+computeMatrixSignPairs">computeMatrixSignPairs</a>(observedX1, observedX2)</code>.
Only needed if <code>typeEstCKT</code> is not the default 'wdm'.</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_npairs">nPairs</code></td>
<td>
<p>number of pairs used in the cross-validation criteria.</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_typeestckt">typeEstCKT</code></td>
<td>
<p>type of estimation of the conditional Kendall's tau.</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_kernel.name">kernel.name</code></td>
<td>
<p>name of the kernel used for smoothing.
Possible choices are <code>"Gaussian"</code> (Gaussian kernel)
and <code>"Epa"</code> (Epanechnikov kernel).</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_progressbar">progressBar</code></td>
<td>
<p>if <code>TRUE</code>, a progressbar for each h is displayed
to show the progress of the computation.</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the score of each h during the procedure.</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_ztoestimate">ZToEstimate</code></td>
<td>
<p>vector of fixed conditioning values at which
the difference between the two conditional Kendall's tau should be computed.
Can also be a matrix whose lines are the conditioning vectors at which
the difference between the two conditional Kendall's tau should be computed.</p>
</td></tr>
<tr><td><code id="CKT.hCV.l1out_+3A_kfolds">Kfolds</code></td>
<td>
<p>number of subsamples used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a list with two components:
</p>

<ul>
<li> <p><code>hCV</code>: the chosen bandwidth
</p>
</li>
<li> <p><code>scores</code>: vector of the same length as range_h giving the
value of the CV criteria for each of the h tested.
Lower score indicates a better fit.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
On kernel-based estimation of conditional Kendall’s tau:
finite-distance bounds and asymptotic behavior.
Dependence Modeling, 7(1), 292-321.
Page 296, Equation (4).
<a href="https://doi.org/10.1515/demo-2019-0016">doi:10.1515/demo-2019-0016</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CKT.kernel">CKT.kernel</a></code> for the corresponding
estimator of conditional Kendall's tau by kernel smoothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 200
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2,10,by = 0.1)
range_h = 3:10

resultCV &lt;- CKT.hCV.l1out(observedX1 = X1, observedX2 = X2,
  range_h = range_h, observedZ = Z, nPairs = 100)

resultCV &lt;- CKT.hCV.Kfolds(observedX1 = X1, observedX2 = X2,
  range_h = range_h, observedZ = Z, ZToEstimate = newZ)

plot(range_h, resultCV$scores, type = "b")

</code></pre>

<hr>
<h2 id='CKT.kendallReg.fit'>Fit Kendall's regression, a GLM-type model for conditional Kendall's tau</h2><span id='topic+CKT.kendallReg.fit'></span><span id='topic+CKT.kendallReg.predict'></span>

<h3>Description</h3>

<p>The function <code>CKT.kendallReg.fit</code> fits a regression-type model for the
conditional Kendall's tau between two variables <code class="reqn">X_1</code> and <code class="reqn">X_2</code>
conditionally to some predictors Z.
More precisely, it fits the model
</p>
<p style="text-align: center;"><code class="reqn">\Lambda(\tau_{X_1, X_2 | Z = z}) = \sum_{j=1}^{p'} \beta_j \psi_j(z),</code>
</p>

<p>where <code class="reqn">\tau_{X_1, X_2 | Z = z}</code> is the conditional Kendall's tau
between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> conditionally to <code class="reqn">Z=z</code>,
<code class="reqn">\Lambda</code> is a function from <code class="reqn">]-1, 1]</code> to <code class="reqn">R</code>,
<code class="reqn">(\beta_1, \dots, \beta_p)</code> are unknown coefficients to be estimated
and <code class="reqn">\psi_1, \dots, \psi_{p'})</code> are a dictionary of functions.
To estimate <code class="reqn">beta</code>, we used the penalized estimator which is defined
as the minimizer of the following criteria
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2n'} \sum_{i=1}^{n'} [\Lambda(\hat\tau_{X_1, X_2 | Z = z_i})
- \sum_{j=1}^{p'} \beta_j \psi_j(z_i)]^2 + \lambda * |\beta|_1,</code>
</p>

<p>where the <code class="reqn">z_i</code> are a second sample (here denoted by <code>ZToEstimate</code>).
</p>
<p>The function <code>CKT.kendallReg.predict</code> predicts
the conditional Kendall's tau between two variables
<code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code> for some new
values of <code class="reqn">z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.kendallReg.fit(
  observedX1,
  observedX2,
  observedZ,
  ZToEstimate,
  designMatrixZ = cbind(ZToEstimate, ZToEstimate^2, ZToEstimate^3),
  newZ = designMatrixZ,
  h_kernel,
  Lambda = identity,
  Lambda_inv = identity,
  lambda = NULL,
  Kfolds_lambda = 10,
  l_norm = 1,
  h_lambda = h_kernel,
  ...
)

CKT.kendallReg.predict(fit, newZ, lambda = NULL, Lambda_inv = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.kendallReg.fit_+3A_observedx1">observedX1</code></td>
<td>
<p>a vector of <code>n</code> observations of the first variable <code class="reqn">X_1</code>.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_observedx2">observedX2</code></td>
<td>
<p>a vector of <code>n</code> observations of the second variable <code class="reqn">X_2</code>.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_observedz">observedZ</code></td>
<td>
<p>a vector of <code>n</code> observations of the conditioning variable,
or a matrix with <code>n</code> rows of observations of the conditioning vector
(if <code class="reqn">Z</code> is multivariate).</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_ztoestimate">ZToEstimate</code></td>
<td>
<p>the intermediary dataset of observations of <code class="reqn">Z</code>
at which the conditional Kendall's tau should be estimated.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_designmatrixz">designMatrixZ</code></td>
<td>
<p>the transformation of the <code>ZToEstimate</code> that
will be used as predictors. By default, no transformation is applied.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_newz">newZ</code></td>
<td>
<p>the new observations of the conditioning variable.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_h_kernel">h_kernel</code></td>
<td>
<p>bandwidth used for the first step of kernel smoothing.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_lambda">Lambda</code></td>
<td>
<p>the function to be applied on conditional Kendall's tau.
By default, the identity function is used.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_lambda_inv">Lambda_inv</code></td>
<td>
<p>the functional inverse of <code>Lambda</code>.
By default, the identity function is used.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_lambda">lambda</code></td>
<td>
<p>the regularization parameter. If <code>NULL</code>,
then it is chosen by K-fold cross validation.
Internally, cross-validation is performed by the function
<code><a href="#topic+CKT.KendallReg.LambdaCV">CKT.KendallReg.LambdaCV</a></code>.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_kfolds_lambda">Kfolds_lambda</code></td>
<td>
<p>the number of folds used in the cross-validation
procedure to choose <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_l_norm">l_norm</code></td>
<td>
<p>type of norm used for selection of the optimal lambda by cross-validation.
<code>l_norm=1</code> corresponds to the sum of absolute values of differences
between predicted and estimated conditional Kendall's tau
while <code>l_norm=2</code> corresponds to the sum of squares of differences.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_h_lambda">h_lambda</code></td>
<td>
<p>the smoothing bandwidth used in the cross-validation
procedure to choose <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code><a href="#topic+CKT.kernel">CKT.kernel</a></code>
for the first step (kernel-based) estimator of conditional Kendall's tau.</p>
</td></tr>
<tr><td><code id="CKT.kendallReg.fit_+3A_fit">fit</code></td>
<td>
<p>the fitted model, obtained by a call
to <code>CKT.kendallReg.fit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>CKT.kendallReg.fit</code> returns
a list with the following components:
</p>

<ul>
<li> <p><code>estimatedCKT</code>: the estimated CKT at the new data points <code>newZ</code>.
</p>
</li>
<li> <p><code>fit</code>: the fitted model, of S3 class glmnet
(see <code>glmnet::<a href="glmnet.html#topic+glmnet">glmnet</a></code> for more details).
</p>
</li>
<li> <p><code>lambda</code>: the value of the penalized parameter used.
(i.e. either the one supplied by the user or
the one determined by cross-validation)
</p>
</li></ul>

<p><code>CKT.kendallReg.predict</code> returns
the predicted values of conditional Kendall's tau.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2020).
On Kendall’s regression.
Journal of Multivariate Analysis, 178, 104610.
<a href="https://doi.org/10.1016/j.jmva.2020.104610">doi:10.1016/j.jmva.2020.104610</a>
</p>


<h3>See Also</h3>

<p>See also other estimators of conditional Kendall's tau:
<code><a href="#topic+CKT.fit.tree">CKT.fit.tree</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.nNets">CKT.fit.nNets</a></code>, <code><a href="#topic+CKT.predict.kNN">CKT.predict.kNN</a></code>,
<code><a href="#topic+CKT.kernel">CKT.kernel</a></code>, <code><a href="#topic+CKT.fit.GLM">CKT.fit.GLM</a></code>,
and the more general wrapper <code><a href="#topic+CKT.estimate">CKT.estimate</a></code>.
</p>
<p>See also the test of the simplifying assumption that a
conditional copula does not depend on the value of the
conditioning variable using the nullity of Kendall's regression
coefficients: <code><a href="#topic+simpA.kendallReg">simpA.kendallReg</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 400
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2, 10, by = 0.1)
estimatedCKT_kendallReg &lt;- CKT.kendallReg.fit(
   observedX1 = X1, observedX2 = X2, observedZ = Z,
   ZToEstimate = newZ, h_kernel = 0.07)

coef(estimatedCKT_kendallReg$fit,
     s = estimatedCKT_kendallReg$lambda)

# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
   type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_kendallReg$estimatedCKT, col = "red")



</code></pre>

<hr>
<h2 id='CKT.KendallReg.LambdaCV'>Kendall's regression: choice of the penalization parameter by K-folds cross-validation</h2><span id='topic+CKT.KendallReg.LambdaCV'></span>

<h3>Description</h3>

<p>In this model, three variables <code class="reqn">X_1</code>, <code class="reqn">X_2</code> and <code class="reqn">Z</code> are observed.
We try to model the conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> conditionally
to <code class="reqn">Z=z</code>, as follows:
</p>
<p style="text-align: center;"><code class="reqn">\Lambda(\tau_{X_1, X_2 | Z = z})
= \sum_{i=1}^{p'} \beta_i \psi_i(z),</code>
</p>

<p>where <code class="reqn">\tau_{X_1, X_2 | Z = z}</code> is the conditional Kendall's tau
between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> conditionally to <code class="reqn">Z=z</code>,
<code class="reqn">\Lambda</code> is a function from <code class="reqn">]-1, 1[]</code> to <code class="reqn">R</code>,
<code class="reqn">(\beta_1, \dots, \beta_p)</code> are unknown coefficients to be estimated
and <code class="reqn">\psi_1, \dots, \psi_{p'})</code> are a dictionary of functions.
To estimate <code class="reqn">beta</code>, we used the penalized estimator which is defined
as the minimizer of the following criteria
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2n'} \sum_{i=1}^{n'} [\Lambda(\hat\tau_{X_1, X_2 | Z = z})
- \sum_{j=1}^{p'} \beta_j \psi_j(z)]^2 + \lambda * |\beta|_1.</code>
</p>

<p>This function chooses the penalization parameter <code class="reqn">lambda</code>
by cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.KendallReg.LambdaCV(
  observedX1,
  observedX2,
  observedZ,
  ZToEstimate,
  designMatrixZ = cbind(ZToEstimate, ZToEstimate^2, ZToEstimate^3),
  typeEstCKT = 4,
  h_lambda,
  Lambda = identity,
  kernel.name = "Epa",
  Kfolds_lambda = 10,
  l_norm = 1,
  matrixSignsPairs = NULL,
  progressBars = "global"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_observedx1">observedX1</code></td>
<td>
<p>a vector of n observations of the first variable <code class="reqn">X_1</code>.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_observedx2">observedX2</code></td>
<td>
<p>a vector of n observations of the second variable <code class="reqn">X_2</code>.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_observedz">observedZ</code></td>
<td>
<p>a vector of n observations of the conditioning variable,
or a matrix with n rows of observations of the conditioning vector
(if <code class="reqn">Z</code> is multivariate).</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_ztoestimate">ZToEstimate</code></td>
<td>
<p>the new data of observations of Z at which
the conditional Kendall's tau should be estimated.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_designmatrixz">designMatrixZ</code></td>
<td>
<p>the transformation of the ZToEstimate that
will be used as predictors. By default, no transformation is applied.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_typeestckt">typeEstCKT</code></td>
<td>
<p>type of estimation of the conditional Kendall's tau.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_h_lambda">h_lambda</code></td>
<td>
<p>the smoothing bandwidth used in the cross-validation
procedure to choose <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_lambda">Lambda</code></td>
<td>
<p>the function to be applied on conditional Kendall's tau.
By default, the identity function is used.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_kernel.name">kernel.name</code></td>
<td>
<p>name of the kernel. Possible choices are
&quot;Gaussian&quot; (Gaussian kernel) and &quot;Epa&quot; (Epanechnikov kernel).</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_kfolds_lambda">Kfolds_lambda</code></td>
<td>
<p>the number of folds used in the cross-validation
procedure to choose <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_l_norm">l_norm</code></td>
<td>
<p>type of norm used for selection of the optimal lambda.
l_norm=1 corresponds to the sum of absolute values of differences
between predicted and estimated conditional Kendall's tau
while l_norm=2 corresponds to the sum of squares of differences.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_matrixsignspairs">matrixSignsPairs</code></td>
<td>
<p>the results of a call to
<code><a href="#topic+computeMatrixSignPairs">computeMatrixSignPairs</a></code> (if already computed).
If <code>NULL</code> (the default value), the <code>matrixSignsPairs</code>
will be computed again from the data.</p>
</td></tr>
<tr><td><code id="CKT.KendallReg.LambdaCV_+3A_progressbars">progressBars</code></td>
<td>
<p>should progress bars be displayed?
Possible values are
</p>

<ul>
<li> <p><code>"none"</code>: no progress bar at all.
</p>
</li>
<li> <p><code>"global"</code>: only one global progress bar (default behavior)
</p>
</li>
<li> <p><code>"eachStep"</code>: uses a global progress bar + one progress bar
for each kernel smoothing step.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>

<ul>
<li> <p><code>lambdaCV</code>: the chosen value of the
penalization parameters <code>lambda</code>.
</p>
</li>
<li> <p><code>vectorLambda</code>: a vector containing the values of
<code>lambda</code> that have been compared.
</p>
</li>
<li> <p><code>vectorMSEMean</code>: the estimated MSE for each value of
<code>lambda</code> in <code>vectorLambda</code>
</p>
</li>
<li> <p><code>vectorMSESD</code>: the estimated standard deviation of the
MSE for each <code>lambda</code>. It can be used to construct confidence
intervals for estimates of the MSE given by <code>vectorMSEMean</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2020).
On Kendall’s regression.
Journal of Multivariate Analysis, 178, 104610.
</p>


<h3>See Also</h3>

<p>the main fitting function <code><a href="#topic+CKT.kendallReg.fit">CKT.kendallReg.fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 400
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2, 10, by = 0.1)
result &lt;- CKT.KendallReg.LambdaCV(
   observedX1 = X1, observedX2 = X2, observedZ = Z,
   ZToEstimate = newZ, h_lambda = 2)

plot(x = result$vectorLambda, y = result$vectorMSEMean,
     type = "l", log = "x")

</code></pre>

<hr>
<h2 id='CKT.kernel'>Estimation of conditional Kendall's tau using kernel smoothing</h2><span id='topic+CKT.kernel'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal of this function is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
For this, a kernel-based estimator is used, as described in
(Derumigny, &amp; Fermanian (2019)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.kernel(
  observedX1,
  observedX2,
  observedZ,
  newZ,
  h,
  kernel.name = "Epa",
  methodCV = "Kfolds",
  Kfolds = 5,
  nPairs = 10 * length(observedX1),
  typeEstCKT = "wdm",
  progressBar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.kernel_+3A_observedx1">observedX1</code></td>
<td>
<p>a vector of n observations of the first variable</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_observedx2">observedX2</code></td>
<td>
<p>a vector of n observations of the second variable</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_observedz">observedZ</code></td>
<td>
<p>a vector of n observations of the conditioning variable,
or a matrix with n rows of observations of the conditioning vector</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_newz">newZ</code></td>
<td>
<p>the new data of observations of Z at which
the conditional Kendall's tau should be estimated.</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_h">h</code></td>
<td>
<p>the bandwidth used for kernel smoothing.
If this is a vector, then cross-validation is used following the method
given by argument <code>methodCV</code> to choose the best bandwidth
before doing the estimation.</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_kernel.name">kernel.name</code></td>
<td>
<p>name of the kernel used for smoothing.
Possible choices are <code>"Gaussian"</code> (Gaussian kernel)
and <code>"Epa"</code> (Epanechnikov kernel).</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_methodcv">methodCV</code></td>
<td>
<p>method used for the cross-validation.
Possible choices are <code>"leave-one-out"</code> and <code>"Kfolds"</code>.</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_kfolds">Kfolds</code></td>
<td>
<p>number of subsamples used,
if <code>methodCV = "Kfolds"</code>.</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_npairs">nPairs</code></td>
<td>
<p>number of pairs used in the cross-validation criteria,
if <code>methodCV = "leave-one-out"</code>.</p>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_typeestckt">typeEstCKT</code></td>
<td>
<p>type of estimation of the conditional Kendall's tau.
Possible choices are </p>

<ul>
<li> <p><code>1</code> and <code>3</code> produced biased estimators.
<code>2</code> does not attain the full range <code class="reqn">[-1,1]</code>.
Therefore these 3 choices are not recommended for applications on real data.
</p>
</li>
<li> <p><code>4</code> is an improved version of <code>1,2,3</code> that has less bias
and attains the full range <code class="reqn">[-1,1]</code>.
</p>
</li>
<li> <p><code>"wdm"</code> is the default version and produces the same results
as <code>4</code> when they are no ties in the data.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CKT.kernel_+3A_progressbar">progressBar</code></td>
<td>
<p>if <code>TRUE</code>, a progressbar for each h is displayed
to show the progress of the computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Choice of the bandwidth <code>h</code></strong>.
The choice of the bandwidth must be done carefully.
In the univariate case, the default kernel (Epanechnikov kernel) has a support
on <code class="reqn">[-1,1]</code>, so for a bandwidth <code>h</code>, estimation of conditional Kendall's
tau at <code class="reqn">Z=z</code> will only use points for which <code class="reqn">Z_i \in [z \pm h]</code>.
As usual in nonparametric estimation, <code>h</code> should not be too small
(to avoid having a too large variance) and should not be large
(to avoid having a too large bias).
</p>
<p>We recommend that for each <code class="reqn">z</code> for which the conditional Kendall's tau
<code class="reqn">\tau_{X_1, X_2 | Z=z}</code> is estimated, the set
<code class="reqn">\{i: Z_i \in [z \pm h] \}</code>
should contain at least 20 points and not more than 30% of the points of
the whole dataset.
Note that for a consistent estimation, as the sample size <code class="reqn">n</code> tends
to the infinity, <code>h</code> should tend to <code class="reqn">0</code> while the size of the set
<code class="reqn">\{i: Z_i \in [z \pm h]\}</code> should also tend to the infinity.
Indeed the conditioning points should be closer and closer to the point of interest <code class="reqn">z</code>
(small <code>h</code>) and more and more numerous (<code>h</code> tending to 0 slowly enough).
</p>
<p>In the multivariate case, similar recommendations can be made.
Because of the curse of dimensionality, a larger sample will be necessary to
reach the same level of precision as in the univariate case.
</p>


<h3>Value</h3>

<p>a list with two components
</p>

<ul>
<li> <p><code>estimatedCKT</code> the vector of size <code>NROW(newZ)</code>
containing the values of the estimated conditional Kendall's tau.
</p>
</li>
<li> <p><code>finalh</code> the bandwidth <code>h</code> that was finally used
for kernel smoothing (either the one specified by the user
or the one chosen by cross-validation if multiple bandwidths were given.)
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
On kernel-based estimation of conditional Kendall’s tau:
finite-distance bounds and asymptotic behavior.
Dependence Modeling, 7(1), 292-321.
<a href="https://doi.org/10.1515/demo-2019-0016">doi:10.1515/demo-2019-0016</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CKT.estimate">CKT.estimate</a></code> for other estimators
of conditional Kendall's tau.
<code><a href="#topic+CKTmatrix.kernel">CKTmatrix.kernel</a></code> for a generalization of this function
when the conditioned vector is of dimension <code>d</code>
instead of dimension <code>2</code> here.
</p>
<p>See <code><a href="#topic+CKT.hCV.l1out">CKT.hCV.l1out</a></code> for manual selection of the bandwidth <code>h</code>
by leave-one-out or K-folds cross-validation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2,10,by = 0.1)
estimatedCKT_kernel &lt;- CKT.kernel(
   observedX1 = X1, observedX2 = X2, observedZ = Z,
   newZ = newZ, h = 0.1, kernel.name = "Epa")$estimatedCKT

# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
   type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_kernel, col = "red")

</code></pre>

<hr>
<h2 id='CKT.predict.kNN'>Prediction of conditional Kendall's tau using nearest neighbors</h2><span id='topic+CKT.predict.kNN'></span>

<h3>Description</h3>

<p>Let <code class="reqn">X_1</code> and <code class="reqn">X_2</code> be two random variables.
The goal of this function is to estimate the conditional Kendall's tau
(a dependence measure) between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
for a conditioning variable <code class="reqn">Z</code>.
Conditional Kendall's tau between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">Z=z</code>
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &gt; 0 | Z_1 = Z_2 = z)</code>
</p>

<p style="text-align: center;"><code class="reqn">- P( (X_{1,1} - X_{2,1})(X_{1,2} - X_{2,2}) &lt; 0 | Z_1 = Z_2 = z),</code>
</p>

<p>where <code class="reqn">(X_{1,1}, X_{1,2}, Z_1)</code> and <code class="reqn">(X_{2,1}, X_{2,2}, Z_2)</code>
are two independent and identically distributed copies of <code class="reqn">(X_1, X_2, Z)</code>.
In other words, conditional Kendall's tau is the difference
between the probabilities of observing concordant and discordant pairs
from the conditional law of </p>
<p style="text-align: center;"><code class="reqn">(X_1, X_2) | Z=z.</code>
</p>

<p>This function estimates conditional Kendall's tau using a
<strong>nearest neighbors</strong>. This is possible by the relationship between
estimation of conditional Kendall's tau and classification problems
(see Derumigny and Fermanian (2019)): estimation of conditional Kendall's tau
is equivalent to the prediction of concordance in the space of pairs
of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.predict.kNN(
  datasetPairs,
  designMatrix = datasetPairs[, 2:(ncol(datasetPairs) - 3), drop = FALSE],
  newZ,
  number_nn,
  weightsVariables = 1,
  normLp = 2,
  constantA = 1,
  partition = NULL,
  verbose = 1,
  lengthVerbose = 100,
  methodSort = "partial.sort"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.predict.kNN_+3A_datasetpairs">datasetPairs</code></td>
<td>
<p>the matrix of pairs and corresponding values of the kernel
as provided by <code><a href="#topic+datasetPairs">datasetPairs</a></code>.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_designmatrix">designMatrix</code></td>
<td>
<p>the matrix of predictors.
They must have the same number of variables as <code>newZ</code> and
the same number of observations as <code>inputMatrix</code>,
i.e. there should be one &quot;multivariate observation&quot; of the predictor for each pair.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_newz">newZ</code></td>
<td>
<p>the matrix of predictors for which we want to
estimate the conditional Kendall's taus at these values.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_number_nn">number_nn</code></td>
<td>
<p>vector of numbers of nearest neighbors to use.
If several number of neighbors are given (local) aggregation is performed
using Lepski's method on the subset determined by the <code>partition</code>.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_weightsvariables">weightsVariables</code></td>
<td>
<p>optional argument to give
different weights <code class="reqn">w_j</code> to each variable.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_normlp">normLp</code></td>
<td>
<p>the p in the weighted p-norm <code class="reqn">|| x ||_p = \sum_j w_j * x_j^p</code>
used to determine the distance in the computation of the nearest neighbors.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_constanta">constantA</code></td>
<td>
<p>a tuning parameter that controls the adaptation.
The higher, the smoother it is; while the smaller, the least smooth it is.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_partition">partition</code></td>
<td>
<p>used only if <code>length(number_nn) &gt; 1</code>.
It is the number of subsets to consider for the local choice of the
number of nearest neighbors ; or a vector giving the id of each observations
among the subsets.
If <code>NULL</code>, only one set is used.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, this print information each <code>lengthVerbose</code> iterations</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_lengthverbose">lengthVerbose</code></td>
<td>
<p>number of iterations at each time for which progress is printed.</p>
</td></tr>
<tr><td><code id="CKT.predict.kNN_+3A_methodsort">methodSort</code></td>
<td>
<p>is the sorting method used to find the nearest neighbors.
Possible choices are
<code>ecdf</code> (uses the ecdf to order the points to find the neighbors)
and <code>partial.sort</code> uses a partial sorting algorithm.
This parameter should not matter except for the computation time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two components
</p>

<ul>
<li> <p><code>estimatedCKT</code> the estimated conditional Kendall's tau, a vector of
the same size as the number of rows in <code>newZ</code>;
</p>
</li>
<li> <p><code>vect_k_chosen</code> the locally selected number of nearest neighbors,
a vector of the same size as the number of rows in <code>newZ</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
A classification point-of-view about conditional Kendall’s tau.
Computational Statistics &amp; Data Analysis, 135, 70-94.
(Algorithm 5)
<a href="https://doi.org/10.1016/j.csda.2019.01.013">doi:10.1016/j.csda.2019.01.013</a>
</p>


<h3>See Also</h3>

<p>See also other estimators of conditional Kendall's tau:
<code><a href="#topic+CKT.fit.tree">CKT.fit.tree</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.nNets">CKT.fit.nNets</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.GLM">CKT.fit.GLM</a></code>, <code><a href="#topic+CKT.kernel">CKT.kernel</a></code>,
<code><a href="#topic+CKT.kendallReg.fit">CKT.kendallReg.fit</a></code>,
and the more general wrapper <code><a href="#topic+CKT.estimate">CKT.estimate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 800
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

newZ = seq(2,10,by = 0.1)
datasetP = datasetPairs(X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)
estimatedCKT_knn &lt;- CKT.predict.kNN(
  datasetPairs = datasetP,
  newZ = matrix(newZ,ncol = 1),
  number_nn = c(50,80, 100, 120,200),
  partition = 8)

# Comparison between true Kendall's tau (in black)
# and estimated Kendall's tau (in red)
trueConditionalTau = -0.9 + 1.8 * pnorm(newZ, mean = 5, sd = 2)
plot(newZ, trueConditionalTau , col="black",
   type = "l", ylim = c(-1, 1))
lines(newZ, estimatedCKT_knn$estimatedCKT, col = "red")

</code></pre>

<hr>
<h2 id='CKT.predict.nNets'>Predict the values of conditional Kendall's tau
using Model Averaging of Neural Networks</h2><span id='topic+CKT.predict.nNets'></span>

<h3>Description</h3>

<p>Predict the values of conditional Kendall's tau
using Model Averaging of Neural Networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKT.predict.nNets(fit, newZ, aggregationMethod = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKT.predict.nNets_+3A_fit">fit</code></td>
<td>
<p>result of a call to <code>CKT.fit.nNet</code></p>
</td></tr>
<tr><td><code id="CKT.predict.nNets_+3A_newz">newZ</code></td>
<td>
<p>new matrix of observations, with the same number of variables.
and same names as the <code>designMatrix</code> that was used to fit the neural networks.</p>
</td></tr>
<tr><td><code id="CKT.predict.nNets_+3A_aggregationmethod">aggregationMethod</code></td>
<td>
<p>the method to be used to aggregate all the predictions
together. Can be <code>"mean"</code> or <code>"median"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CKT.predict.nNets</code> returns
a vector of (predicted) conditional Kendall's taus of the same size
as the number of rows of the matrix <code>newZ</code>.
</p>

<hr>
<h2 id='CKTmatrix.kernel'>Estimate the conditional Kendall's tau matrix
at different conditioning points</h2><span id='topic+CKTmatrix.kernel'></span>

<h3>Description</h3>

<p>Assume that we are interested in a random vector <code class="reqn">(X, Z)</code>,
where <code class="reqn">X</code> is of dimension <code class="reqn">d &gt; 2</code> and <code class="reqn">Z</code> is of dimension <code class="reqn">1</code>.
We want to estimate the dependence across the elements of the conditioned vector <code class="reqn">X</code>
given <code class="reqn">Z=z</code>.
This function takes in parameter observations of <code class="reqn">(X,Z)</code>
and returns kernel-based estimators of </p>
<p style="text-align: center;"><code class="reqn">\tau_{i,j | Z=zk}</code>
</p>

<p>which is the conditional Kendall's tau between <code class="reqn">X_i</code> and <code class="reqn">X_j</code>
given to <code class="reqn">Z=zk</code>, for every conditioning point <code class="reqn">zk</code> in <code>gridZ</code>.
If the conditional Kendall's tau matrix has a block structure,
then improved estimation is possible by averaging over the kernel-based estimators of
pairwise conditional Kendall's taus.
Groups of variables composing the same blocks can be defined
using the parameter <code>blockStructure</code>, and the averaging can be set on using
the parameter <code>averaging=all</code>, or <code>averaging=diag</code>
for faster estimation by averaging only over diagonal elements of each block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CKTmatrix.kernel(
  dataMatrix,
  observedZ,
  gridZ,
  averaging = "no",
  blockStructure = NULL,
  h,
  kernel.name = "Epa",
  typeEstCKT = "wdm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CKTmatrix.kernel_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>a matrix of size <code>(n,d)</code> containing <code>n</code> observations of a
<code>d</code>-dimensional random vector <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="CKTmatrix.kernel_+3A_observedz">observedZ</code></td>
<td>
<p>vector of observed points of a conditioning variable <code class="reqn">Z</code>.
It must have the same length as the number of rows of <code>dataMatrix</code>.</p>
</td></tr>
<tr><td><code id="CKTmatrix.kernel_+3A_gridz">gridZ</code></td>
<td>
<p>points at which the conditional Kendall's tau is computed.</p>
</td></tr>
<tr><td><code id="CKTmatrix.kernel_+3A_averaging">averaging</code></td>
<td>
<p>type of averaging used for fast estimation.
Possible choices are </p>

<ul>
<li> <p><code>no</code>: no averaging;
</p>
</li>
<li> <p><code>all</code>: averaging all Kendall's taus in each block;
</p>
</li>
<li> <p><code>diag</code>: averaging along diagonal blocks elements.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CKTmatrix.kernel_+3A_blockstructure">blockStructure</code></td>
<td>
<p>list of vectors.
Each vector corresponds to one group of variables
and contains the indexes of the variables that belongs to this group.
<code>blockStructure</code> must be a partition of <code>1:d</code>,
where <code>d</code> is the number of columns in <code>dataMatrix</code>.</p>
</td></tr>
<tr><td><code id="CKTmatrix.kernel_+3A_h">h</code></td>
<td>
<p>bandwidth. It can be a real, in this case the same <code>h</code>
will be used for every element of <code>gridZ</code>.
If <code>h</code> is a vector then its elements are recycled to match the length of
<code>gridZ</code>.</p>
</td></tr>
<tr><td><code id="CKTmatrix.kernel_+3A_kernel.name">kernel.name</code></td>
<td>
<p>name of the kernel used for smoothing.
Possible choices are: <code>"Gaussian"</code> (Gaussian kernel)
and <code>"Epa"</code> (Epanechnikov kernel).</p>
</td></tr>
<tr><td><code id="CKTmatrix.kernel_+3A_typeestckt">typeEstCKT</code></td>
<td>
<p>type of estimation of the conditional Kendall's tau.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with dimensions depending on <code>averaging</code>:
</p>

<ul>
<li><p> If <code>averaging = "no"</code>:
it returns an array of dimensions <code>(n, n, length(gridZ))</code>,
containing the estimated conditional Kendall's tau matrix given <code class="reqn">Z = z</code>.
Here, <code>n</code> is the number of rows in <code>dataMatrix</code>.
</p>
</li>
<li><p> If <code>averaging = "all"</code> or <code>"diag"</code>:
it returns an array of dimensions
<code>(length(blockStructure), length(blockStructure), length(gridZ))</code>,
containing the block estimates of the conditional Kendall's tau given <code class="reqn">Z = z</code>
with ones on the diagonal.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rutger van der Spek, Alexis Derumigny
</p>


<h3>References</h3>

<p>van der Spek, R., &amp; Derumigny, A. (2022).
Fast estimation of Kendall's Tau and conditional Kendall's Tau matrices
under structural assumptions.
<a href="https://arxiv.org/abs/2204.03285">arxiv:2204.03285</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CKT.kernel">CKT.kernel</a></code> for kernel-based estimation of conditional Kendall's tau
between two variables (i.e. the equivalent of this function
when <code class="reqn">X</code> is bivariate and <code>d=2</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data simulation
n = 100
Z = runif(n)
d = 5
CKT_11 = 0.8
CKT_22 = 0.9
CKT_12 = 0.1 + 0.5 * cos(pi * Z)
data_X = matrix(nrow = n, ncol = d)
for (i in 1:n){
  CKT_matrix = matrix(data =
    c(  1      , CKT_11   , CKT_11   , CKT_12[i], CKT_12[i] ,
      CKT_11   ,   1      , CKT_11   , CKT_12[i], CKT_12[i] ,
      CKT_11   , CKT_11   ,    1     , CKT_12[i], CKT_12[i] ,
      CKT_12[i], CKT_12[i], CKT_12[i],   1      , CKT_22    ,
      CKT_12[i], CKT_12[i], CKT_12[i], CKT_22   ,   1
      ) ,
     nrow = 5, ncol = 5)
  sigma = sin(pi * CKT_matrix/2)
  data_X[i, ] = mvtnorm::rmvnorm(n = 1, sigma = sigma)
}
plot(as.data.frame.matrix(data_X))

# Estimation of CKT matrix
h = 1.06 * sd(Z) * n^{-1/5}
gridZ = c(0.2, 0.8)
estMatrixAll &lt;- CKTmatrix.kernel(
  dataMatrix = data_X, observedZ = Z, gridZ = gridZ, h = h)
# Averaging estimator
estMatrixAve &lt;- CKTmatrix.kernel(
  dataMatrix = data_X, observedZ = Z, gridZ = gridZ,
  averaging = "diag", blockStructure = list(1:3,4:5), h = h)

# The estimated CKT matrix conditionally to Z=0.2 is:
estMatrixAll[ , , 1]
# Using the averaging estimator,
# the estimated CKT between the first group (variables 1 to 3)
# and the second group (variables 4 and 5) is
estMatrixAve[1, 2, 1]

# True value (of CKT between variables in block 1 and 2 given Z = 0.2):
0.1 + 0.5 * cos(pi * 0.2)


</code></pre>

<hr>
<h2 id='computeKernelMatrix'>Computing the kernel matrix</h2><span id='topic+computeKernelMatrix'></span>

<h3>Description</h3>

<p>This function computes a matrix of dimensions <code>(length(observedX3), length(newX3))</code>,
whose element at coordinate <code>(i,j)</code> is
<code class="reqn"> K_{h}(</code><code>observedX3</code><code class="reqn">[i] - </code><code>newX3</code><code class="reqn">[j] )</code>,
where <code class="reqn">K_h(x) := K(x/h) / h</code> and <code class="reqn">K</code> is the <code>kernel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeKernelMatrix(observedX, newX, kernel, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeKernelMatrix_+3A_observedx">observedX</code></td>
<td>
<p>a numeric vector of observations of X3.
on the interval <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="computeKernelMatrix_+3A_newx">newX</code></td>
<td>
<p>a numeric vector of points of X3.</p>
</td></tr>
<tr><td><code id="computeKernelMatrix_+3A_kernel">kernel</code></td>
<td>
<p>a character string describing the kernel to be used.
Possible choices are <code>Gaussian</code>, <code>Triangular</code> and <code>Epanechnikov</code>.</p>
</td></tr>
<tr><td><code id="computeKernelMatrix_+3A_h">h</code></td>
<td>
<p>the bandwidth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix of dimensions <code>(length(observedX), length(newX))</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateCondCDF_matrix">estimateCondCDF_matrix</a></code>, <code><a href="#topic+estimateCondCDF_vec">estimateCondCDF_vec</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = MASS::mvrnorm(n = 100, mu = c(0,0), Sigma = cbind(c(1, 0.9), c(0.9, 1)))
matrixK = computeKernelMatrix(observedX = Y[,2], newX = c(0, 1, 2.5),
kernel = "Gaussian", h = 0.8)

# To have an estimator of the conditional expectation of Y1 given Y2 = 0, 1, 2.5
Y[,1] * matrixK[,1] / sum(matrixK[,1])
Y[,1] * matrixK[,2] / sum(matrixK[,2])
Y[,1] * matrixK[,3] / sum(matrixK[,3])

</code></pre>

<hr>
<h2 id='computeMatrixSignPairs'>Compute the matrix of signs of pairs</h2><span id='topic+computeMatrixSignPairs'></span>

<h3>Description</h3>

<p>Compute a matrix giving the concordance or discordance
of each pair of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMatrixSignPairs(vectorX1, vectorX2, typeEstCKT = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeMatrixSignPairs_+3A_vectorx1">vectorX1</code></td>
<td>
<p>vector of observed data (first coordinate)</p>
</td></tr>
<tr><td><code id="computeMatrixSignPairs_+3A_vectorx2">vectorX2</code></td>
<td>
<p>vector of observed data (second coordinate)</p>
</td></tr>
<tr><td><code id="computeMatrixSignPairs_+3A_typeestckt">typeEstCKT</code></td>
<td>
<p>if typeEstCKT = 2 or 4, compute the matrix whose term (i,j) is :
</p>
<p style="text-align: center;"><code class="reqn">1 \{ (X_{i,1} - X_{j,1}) * (X_{i,2} - X_{j,2}) &gt; 0 \}
 - 1 \{ (X_{i,1} - X_{j,1}) * (X_{i,2} - X_{j,2}) &lt; 0 \},</code>
</p>

<p>where <code class="reqn">1</code> is the indicator function.
</p>
<p>For <code>typeEstCKT = 1</code> (respectively <code>typeEstCKT = 3</code>)
a negatively biased (respectively positively) matrix is given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>n * n</code> matrix with the signs of each pair
of observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
N = 500
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = 0.9 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N = N , family = 3,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau) )
matrixPairs = computeMatrixSignPairs(vectorX1 = simCopula[,1],
                                     vectorX2 = simCopula[,2])

</code></pre>

<hr>
<h2 id='conv_treeCKT'>Converting to matrix of indicators / matrix of conditional Kendall's tau</h2><span id='topic+conv_treeCKT'></span><span id='topic+treeCKT2matrixInd'></span><span id='topic+matrixInd2matrixCKT'></span><span id='topic+treeCKT2matrixCKT'></span>

<h3>Description</h3>

<p>The function <code>treeCKT2matrixInd</code>
takes as input a binary tree that has been returned
by the function <code><a href="#topic+bCond.treeCKT">bCond.treeCKT</a></code>.
Since this tree describes a partition of the conditioning space,
it can be interesting to get, for a given dataset, the matrix
</p>
<p style="text-align: center;"><code class="reqn">1\{ X_{i,J} \in A_{j,J} \},</code>
</p>

<p>where each <code class="reqn">A_{j,J}</code> corresponds to a conditioning subset.
This is the so-called <code>matrixInd</code>.
Finally, it can be interesting to get the matrix of
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeCKT2matrixInd(estimatedTree, newDataXJ = NULL)

matrixInd2matrixCKT(matrixInd, newDataXI)

treeCKT2matrixCKT(estimatedTree, newDataXI = NULL, newDataXJ = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_treeCKT_+3A_estimatedtree">estimatedTree</code></td>
<td>
<p>the tree that has been estimated before,
for example by <code><a href="#topic+bCond.treeCKT">bCond.treeCKT</a></code>.</p>
</td></tr>
<tr><td><code id="conv_treeCKT_+3A_newdataxj">newDataXJ</code></td>
<td>
<p>this is a matrix of size <code>N * |J|</code>
where <code>|J|</code> is the number of conditional variables used in the tree.
By default this is <code>NULL</code> meaning that
we return the matrix for the original data
(that was used to compute the <code>estimatedTree</code>).</p>
</td></tr>
<tr><td><code id="conv_treeCKT_+3A_matrixind">matrixInd</code></td>
<td>
<p>a matrix of indexes of size (n, N.boxes) describing
for each observation i to which box ( = event) it belongs.</p>
</td></tr>
<tr><td><code id="conv_treeCKT_+3A_newdataxi">newDataXI</code></td>
<td>
<p>this is a matrix of size <code>N * |I|</code>
where <code>|I|</code> is the number of conditioned variables.
By default this is <code>NULL</code> meaning that
we return the matrix for the original data
used to compute the <code>estimatedTree</code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> The function <code>treeCKT2matrixInd</code> returns
a matrix of size <code>N * m</code> which component <code>[i,j]</code>
is </p>
<p style="text-align: center;"><code class="reqn">1\{ X_{i,J} \in A_{j,J} \}</code>
</p>
<p>.
</p>
</li>
<li><p> The function <code>matrixInd2matrixCKT</code> and <code>treeCKT2matrixCKT</code> return
a matrix of size <code>|I| * (|I|-1) * m</code> where each component corresponds
to a conditional Kendall's tau between a pair of conditional variables
conditionally to the conditioned variables in one of the boxes
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bCond.treeCKT">bCond.treeCKT</a></code> for the construction of such a binary tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 200
XJ = MASS::mvrnorm(n = n, mu = c(3,3), Sigma = rbind(c(1, 0.2), c(0.2, 1)))
XI = matrix(nrow = n, ncol = 2)
high_XJ1 = which(XJ[,1] &gt; 4)
XI[high_XJ1, ]  = MASS::mvrnorm(n = length(high_XJ1), mu = c(10,10),
                                Sigma = rbind(c(1, 0.8), c(0.8, 1)))
XI[-high_XJ1, ] = MASS::mvrnorm(n = n - length(high_XJ1), mu = c(8,8),
                                Sigma = rbind(c(1, -0.2), c(-0.2, 1)))

result = bCond.treeCKT(XI = XI, XJ = XJ, minSize = 10, verbose = 2)

treeCKT2matrixInd(result)

matrixInd2matrixCKT(treeCKT2matrixInd(result), newDataXI = XI)

treeCKT2matrixCKT(result)

</code></pre>

<hr>
<h2 id='datasetPairs'>Construct a dataset of pairs of observations for the estimation
of conditional Kendall's tau</h2><span id='topic+datasetPairs'></span>

<h3>Description</h3>

<p>In (Derumigny, &amp; Fermanian (2019)), it is described how the problem
of estimating conditional Kendall's tau can be rewritten as a
classification task for a dataset of pairs (of observations).
This function computes such a dataset, that can be then used to
estimate conditional Kendall's tau using one of the following
functions:
<code><a href="#topic+CKT.fit.tree">CKT.fit.tree</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.GLM">CKT.fit.GLM</a></code>, <code><a href="#topic+CKT.fit.nNets">CKT.fit.nNets</a></code>,
<code><a href="#topic+CKT.predict.kNN">CKT.predict.kNN</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasetPairs(
  X1,
  X2,
  Z,
  h,
  cut = 0.9,
  onlyConsecutivePairs = FALSE,
  nPairs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datasetPairs_+3A_x1">X1</code></td>
<td>
<p>vector of observations of the first conditioned variable.</p>
</td></tr>
<tr><td><code id="datasetPairs_+3A_x2">X2</code></td>
<td>
<p>vector of observations of the second conditioned variable.</p>
</td></tr>
<tr><td><code id="datasetPairs_+3A_z">Z</code></td>
<td>
<p>vector or matrix of observations of the conditioning variable(s),
of dimension <code>dimZ</code>.</p>
</td></tr>
<tr><td><code id="datasetPairs_+3A_h">h</code></td>
<td>
<p>the bandwidth. Can be a vector; in this case,
the components of <code>h</code> will be reused to match the dimension of <code>Z</code>.</p>
</td></tr>
<tr><td><code id="datasetPairs_+3A_cut">cut</code></td>
<td>
<p>the cutting level to keep a given pair or not.
Used only if no <code>nPairs</code> is provided.</p>
</td></tr>
<tr><td><code id="datasetPairs_+3A_onlyconsecutivepairs">onlyConsecutivePairs</code></td>
<td>
<p>if <code>TRUE</code>, only consecutive pairs are used.</p>
</td></tr>
<tr><td><code id="datasetPairs_+3A_npairs">nPairs</code></td>
<td>
<p>number of most relevant pairs to keep in the final datasets.
If this is different than the default <code>NULL</code>,
the cutting level <code>cut</code> is not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>(4+dimZ)</code> columns and <code>n*(n-1)/2</code> rows
if <code>onlyConsecutivePairs=FALSE</code> and else <code>(n/2)</code> rows.
It is structured in the following way:
</p>

<ul>
<li><p> column <code>1</code> contains the information
about the concordance of the pair (i,j) ;
</p>
</li>
<li><p> columns <code>2</code> to <code>1+dimZ</code> contain
the mean value of Z (the conditioning variables) ;
</p>
</li>
<li><p> column <code>2+dimZ</code> contains the value of the kernel K_h(Z_j - Z_i) ;
</p>
</li>
<li><p> column <code>3+dimZ</code> and <code>4+dimZ</code>
contain the corresponding values of i and j.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2019).
A classification point-of-view about conditional Kendall’s tau.
Computational Statistics &amp; Data Analysis, 135, 70-94.
(Algorithm 1 for all pairs and Algorithm 8
for the case of only consecutive pairs)
<a href="https://doi.org/10.1016/j.csda.2019.01.013">doi:10.1016/j.csda.2019.01.013</a>
</p>


<h3>See Also</h3>

<p>the functions that require such a dataset of pairs
to do the estimation of conditional Kendall's tau:
<code><a href="#topic+CKT.fit.tree">CKT.fit.tree</a></code>, <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>,
<code><a href="#topic+CKT.fit.GLM">CKT.fit.GLM</a></code>, <code><a href="#topic+CKT.fit.nNets">CKT.fit.nNets</a></code>,
<code><a href="#topic+CKT.predict.kNN">CKT.predict.kNN</a></code>, and <code><a href="#topic+CKT.fit.randomForest">CKT.fit.randomForest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
N = 500
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = 0.9 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N = N , family = 3,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau) )
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

datasetP = datasetPairs(
X1 = X1, X2 = X2, Z = Z, h = 0.07, cut = 0.9)

</code></pre>

<hr>
<h2 id='estimateCondCDF_matrix'>Compute kernel-based conditional marginal (univariate) cdfs</h2><span id='topic+estimateCondCDF_matrix'></span>

<h3>Description</h3>

<p>This function computes an estimate of the conditional (marginal) cdf
of X1 given a conditioning variable X3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateCondCDF_matrix(observedX1, newX1, matrixK3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateCondCDF_matrix_+3A_observedx1">observedX1</code></td>
<td>
<p>a sample of observations of X1 of size <code>n</code></p>
</td></tr>
<tr><td><code id="estimateCondCDF_matrix_+3A_newx1">newX1</code></td>
<td>
<p>a sample of new points for the variable X1, of size <code>p1</code></p>
</td></tr>
<tr><td><code id="estimateCondCDF_matrix_+3A_matrixk3">matrixK3</code></td>
<td>
<p>a matrix of kernel values of dimension <code>(p3, n)</code>
<code class="reqn">\big(K_h(X3[i] - U3[j])\big)_{i,j}</code>
such as given by <code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is supposed to be used with <code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a></code>.
Assume that we observe a sample <code class="reqn">(X_{i,1}, X_{i,3}), i=1, \dots, n</code>.
We want to estimate the conditional cdf of <code class="reqn">X_1</code> given <code class="reqn">X_3 = x_3</code>
at point <code class="reqn">x_1</code> using the following kernel-based estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat P(X_1 \le x_1 | X_3 = x_3)
:= \frac{\sum_{l=1}^n 1 \{X_{l,1} \leq x_1 \} K_h(X_{l,3} - x_3)}
{\sum_{l=1}^n K_h(X_{l,3} - x_3)},</code>
</p>

<p>for every <code class="reqn">x_1</code> in <code>newX1</code> and every <code class="reqn">x_3</code> in <code>newX3</code>.
The <code>matrixK3</code> should be a matrix of the values <code class="reqn">K_h(X_{l,3} - x_3)</code>
such as the one produced by
<code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a>(observedX3, newX3, kernel, h)</code>.
</p>


<h3>Value</h3>

<p>A matrix of dimensions <code>(p1 = length(newX), p3 = length(matrixK3[,1]))</code>
of estimators <code class="reqn">\hat P(X_1 \leq x_1 | X_3 = x_3)</code> for every possible choices
of <code class="reqn">(x_1, x_3)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = MASS::mvrnorm(n = 100, mu = c(0,0), Sigma = cbind(c(1, 0.9), c(0.9, 1)))
newY1 = seq(-1, 1, by = 0.5)
newY2 = c(0, 1, 2)
matrixK = computeKernelMatrix(observedX = Y[,2], newX = newY2,
  kernel = "Gaussian", h = 0.8)
# In this matrix, there are the estimated conditionl cdf at points given by newY1
# conditionally to the points given by newY2.
matrixCondCDF = estimateCondCDF_matrix(observedX1 = Y[,1],
  newX1 = newY1, matrixK)
matrixCondCDF

</code></pre>

<hr>
<h2 id='estimateCondCDF_vec'>Compute kernel-based conditional marginal (univariate) cdfs</h2><span id='topic+estimateCondCDF_vec'></span>

<h3>Description</h3>

<p>This function computes an estimate of the conditional (marginal) cdf
of X1 given a conditioning variable X3.
This function is supposed to be used with <code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a></code>.
Assume that we observe a sample <code class="reqn">(X_{i,1}, X_{i,3}), i=1, \dots, n</code>.
We want to estimate the conditional cdf of <code class="reqn">X_1</code> given <code class="reqn">X_3 = x_3</code>
at point <code class="reqn">x_1</code> using the following kernel-based estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat P(X_1 \leq x_1 | X_3 = x_3)
:= \frac{\sum_{l=1}^n 1 \{X_{l,1} \leq x_1 \} K_h(X_{l,3} - x_3)}
{\sum_{l=1}^n K_h(X_{l,3} - x_3)},</code>
</p>

<p>for every couple <code class="reqn">(x_{j,1}, x_{j,3})</code> where
<code class="reqn">x_{j,1}</code> in <code>newX1</code> and <code class="reqn">x_{j,3}</code> in <code>newX3</code>.
The <code>matrixK3</code> should be a matrix of the values <code class="reqn">K_h(X_{l,3} - x_3)</code>
such as the one produced by
<code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a>(observedX3, newX3, kernel, h)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateCondCDF_vec(observedX1, newX1, matrixK3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateCondCDF_vec_+3A_observedx1">observedX1</code></td>
<td>
<p>a sample of observations of X1 of size n</p>
</td></tr>
<tr><td><code id="estimateCondCDF_vec_+3A_newx1">newX1</code></td>
<td>
<p>a sample of new points for the variable X1, of size p1</p>
</td></tr>
<tr><td><code id="estimateCondCDF_vec_+3A_matrixk3">matrixK3</code></td>
<td>
<p>a matrix of kernel values of dimension (p2 , n)
<code class="reqn">\big(K_h(X3[i] - U3[j])\big)_{i,j}</code>
such as given by <code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a vector of length <code>newX1</code> of estimators
<code class="reqn">\hat P(X_1 \leq x_1 | X_3 = x_3)</code>
for every couple <code class="reqn">(x_{j,1}, x_{j,3})</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = MASS::mvrnorm(n = 100, mu = c(0,0), Sigma = cbind(c(1, 0.9), c(0.9, 1)))
newY1 = seq(-1, 1, by = 0.5)
newY2 = newY1
matrixK = computeKernelMatrix(observedX = Y[,2], newX = newY2,
  kernel = "Gaussian", h = 0.8)
vecCondCDF = estimateCondCDF_vec(observedX1 = Y[,1],
  newX1 = newY1, matrixK)
vecCondCDF

</code></pre>

<hr>
<h2 id='estimateCondQuantiles'>Compute kernel-based conditional quantiles</h2><span id='topic+estimateCondQuantiles'></span>

<h3>Description</h3>

<p>This function is supposed to be used with <code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a></code>.
Assume that we observe a sample <code class="reqn">(X_{i,1}, X_{i,3}), i=1, \dots, n</code>.
We want to estimate the conditional quantiles of <code class="reqn">X_1</code> given <code class="reqn">X_3 = x_3</code>
at point <code class="reqn">u_1</code> using the following kernel-based estimator
</p>
<p style="text-align: center;"><code class="reqn">\hat Q(u_1 | X_3 = x_3) := \hat P^{(-1)}(u_1 \leq x_1 | X_3 = x_3),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat P(X_1 \leq x_1 | X_3 = x_3)
:= \frac{\sum_{l=1}^n 1 \{X_(l,1) \leq x_1 \} K_h(X_(l,3) - x_3)}
{\sum_{l=1}^n K_h(X_(l,3) - x_3)},</code>
</p>

<p>for every <code class="reqn">u_1</code> in <code>probsX1</code> and every <code class="reqn">x_3</code> in <code>newX3</code>.
The <code>matrixK3</code> should be a matrix of the values <code class="reqn">K_h(X_(l,3) - x_3)</code>
such as the one produced by
<code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a>(observedX3, newX3, kernel, h)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateCondQuantiles(observedX1, probsX1, matrixK3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateCondQuantiles_+3A_observedx1">observedX1</code></td>
<td>
<p>a sample of observations of X1 of size n</p>
</td></tr>
<tr><td><code id="estimateCondQuantiles_+3A_probsx1">probsX1</code></td>
<td>
<p>a sample of probabilities at which we want to compute
the quantiles for the variable X1, of size p1</p>
</td></tr>
<tr><td><code id="estimateCondQuantiles_+3A_matrixk3">matrixK3</code></td>
<td>
<p>a matrix of kernel values of dimension (p2 , n)
<code class="reqn">\big(K_h(X3[i] - U3[j])\big)_{i,j}</code>
such as given by <code><a href="#topic+computeKernelMatrix">computeKernelMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimensions <code>(p1,p2)</code> whose (i,j) entry is <code class="reqn">\hat Q(u_1 | X_3 = x_3)</code>
with <code class="reqn">u_1</code> = <code>probsX1[i]</code> and <code class="reqn">x_3</code> = <code>newX3[j]</code>,
where <code>newX3[j]</code> is the vector that was used to construct <code>matrixK3</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = MASS::mvrnorm(n = 100, mu = c(0,0), Sigma = cbind(c(1, 0.9), c(0.9, 1)))
matrixK = computeKernelMatrix(observedX = Y[,2] , newX = c(0, 1, 2.5),
  kernel = "Gaussian", h = 0.8)
matrixnp = estimateCondQuantiles(observedX1 = Y[,2],
  probsX1 = c(0.3, 0.5) , matrixK3 = matrixK)
matrixnp

</code></pre>

<hr>
<h2 id='estimateNPCondCopula'>Compute a kernel-based estimator of the conditional copula</h2><span id='topic+estimateNPCondCopula'></span>

<h3>Description</h3>

<p>Assuming that we observe a sample <code class="reqn">(X_{i,1}, X_{i,2}, X_{i,3}), i=1, \dots, n</code>,
this function returns a array
<code class="reqn">\hat C_{1,2|3}(u_1, u_2 | X_3 = x_3)</code>
for each choice of (u_1, u_2, x_3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateNPCondCopula(
  observedX1,
  observedX2,
  observedX3,
  U1_,
  U2_,
  newX3,
  kernel,
  h
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateNPCondCopula_+3A_observedx1">observedX1</code></td>
<td>
<p>a vector of observations of size n</p>
</td></tr>
<tr><td><code id="estimateNPCondCopula_+3A_observedx2">observedX2</code></td>
<td>
<p>a vector of observations of size n</p>
</td></tr>
<tr><td><code id="estimateNPCondCopula_+3A_observedx3">observedX3</code></td>
<td>
<p>a vector of observations of size n</p>
</td></tr>
<tr><td><code id="estimateNPCondCopula_+3A_u1_">U1_</code></td>
<td>
<p>a vector of numbers in [0, 1]</p>
</td></tr>
<tr><td><code id="estimateNPCondCopula_+3A_u2_">U2_</code></td>
<td>
<p>a vector of numbers in [0, 1]</p>
</td></tr>
<tr><td><code id="estimateNPCondCopula_+3A_newx3">newX3</code></td>
<td>
<p>a vector of new values for the conditioning variable X3</p>
</td></tr>
<tr><td><code id="estimateNPCondCopula_+3A_kernel">kernel</code></td>
<td>
<p>a character string describing the kernel to be used.
Possible choices are <code>Gaussian</code>, <code>Triangular</code> and <code>Epanechnikov</code>.</p>
</td></tr>
<tr><td><code id="estimateNPCondCopula_+3A_h">h</code></td>
<td>
<p>the bandwidth to use in the estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimension <code>(length(U1_, U2_, newX3))</code>
whose element in position (i, j, k) is
<code class="reqn">\hat C_{1,2|3}(u_1, u_2 | X_3 = x_3)</code>
where <code class="reqn">u_1</code> = U1_[i], <code class="reqn">u_2</code> = U2_[j] and <code class="reqn">x_3</code> = newX3[k]
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2017).
About tests of the “simplifying” assumption for conditional copulas.
Dependence Modeling, 5(1), 154-197.
<a href="https://doi.org/10.1515/demo-2017-0011">doi:10.1515/demo-2017-0011</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateParCondCopula">estimateParCondCopula</a></code> for estimating a conditional
copula in a parametric setting ( = where the conditional copula is assumed to
belong to a parametric class).
<code><a href="#topic+simpA.NP">simpA.NP</a></code> for a test that this conditional copula is
constant with respect to the value <code class="reqn">x_3</code> of the conditioning variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
N = 500
X3 = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = 0.9 * pnorm(X3, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 3,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

# We do the estimation
grid = c(0.2, 0.4, 0.6, 0.8)
arrayEst = estimateNPCondCopula(observedX1 = X1,
  observedX2 = X2, observedX3 = X3,
  U1_ = grid, U2_ = grid, newX3 = c(2, 5, 7),
  kernel = "Gaussian", h = 0.8)
arrayEst

</code></pre>

<hr>
<h2 id='estimateParCondCopula'>Estimation of parametric conditional copulas</h2><span id='topic+estimateParCondCopula'></span><span id='topic+estimateParCondCopula_ZIJ'></span>

<h3>Description</h3>

<p>The function <code>estimateParCondCopula</code> computes an estimate
of the conditional parameters in a conditional parametric copula model, i.e.
</p>
<p style="text-align: center;"><code class="reqn">C_{X_1, X_2 | X_3 = x_3} = C_{\theta(x_3)},</code>
</p>

<p>for some parametric family <code class="reqn">(C_\theta)</code>, some conditional
parameter <code class="reqn">\theta(x_3)</code>, and a three-dimensional random
vector <code class="reqn">(X_1, X_2, X_3)</code>. Remember that <code class="reqn">C_{X_1,X_2 | X_3 = x_3}</code>
denotes the conditional copula of <code class="reqn">X_1</code> and <code class="reqn">X_2</code> given <code class="reqn">X_3 = x_3</code>.
</p>
<p>The function <code>estimateParCondCopula_ZIJ</code> is an auxiliary function
that is called when conditional pseudos-observations are already
available when one wants to estimate a parametric conditional copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateParCondCopula(
  observedX1,
  observedX2,
  observedX3,
  newX3,
  family,
  method = "mle",
  h
)

estimateParCondCopula_ZIJ(Z1_J, Z2_J, observedX3, newX3, family, method, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateParCondCopula_+3A_observedx1">observedX1</code></td>
<td>
<p>a vector of <code>n</code> observations
of the first conditioned variable</p>
</td></tr>
<tr><td><code id="estimateParCondCopula_+3A_observedx2">observedX2</code></td>
<td>
<p>a vector of <code>n</code> observations
of the second conditioned variable</p>
</td></tr>
<tr><td><code id="estimateParCondCopula_+3A_observedx3">observedX3</code></td>
<td>
<p>a vector of <code>n</code> observations
of the conditioning variable</p>
</td></tr>
<tr><td><code id="estimateParCondCopula_+3A_newx3">newX3</code></td>
<td>
<p>a vector of new observations of <code class="reqn">X3</code></p>
</td></tr>
<tr><td><code id="estimateParCondCopula_+3A_family">family</code></td>
<td>
<p>an integer indicating the parametric family of copulas to be used,
following the conventions of the package <code>VineCopula</code>.</p>
</td></tr>
<tr><td><code id="estimateParCondCopula_+3A_method">method</code></td>
<td>
<p>the method of estimation of the conditional parameters.
Can be <code>"mle"</code> for maximum likelihood estimation
or <code>"itau"</code> for estimation by inversion of Kendall's tau.</p>
</td></tr>
<tr><td><code id="estimateParCondCopula_+3A_h">h</code></td>
<td>
<p>bandwidth to be chosen</p>
</td></tr>
<tr><td><code id="estimateParCondCopula_+3A_z1_j">Z1_J</code></td>
<td>
<p>the conditional pseudos-observations of the first variable,
i.e. <code class="reqn">\hat F_{1|J}( x_{i,1} | x_J = x_{i,J})</code> for <code class="reqn">i=1,\dots, n</code>.</p>
</td></tr>
<tr><td><code id="estimateParCondCopula_+3A_z2_j">Z2_J</code></td>
<td>
<p>the conditional pseudos-observations of the second variable,
i.e. <code class="reqn">\hat F_{2|J}( x_{i,2} | x_J = x_{i,J})</code> for <code class="reqn">i=1,\dots, n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code>length(newX3)</code> containing
the estimated conditional copula parameters for each value of <code>newX3</code>.
</p>


<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2017).
About tests of the “simplifying” assumption for conditional copulas.
Dependence Modeling, 5(1), 154-197.
<a href="https://doi.org/10.1515/demo-2017-0011">doi:10.1515/demo-2017-0011</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateNPCondCopula">estimateNPCondCopula</a></code> for estimating a conditional
copula in a nonparametric setting ( = without parametric assumption on the
conditional copula).
<code><a href="#topic+simpA.param">simpA.param</a></code> for a test that this conditional copula is
constant with respect to the value <code class="reqn">x_3</code> of the conditioning variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We simulate from a conditional copula
N = 500

X3 = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = 0.9 * pnorm(X3, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(
    N=N , family = 1, par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

gridnewX3 = seq(2, 8, by = 1)
conditionalTauNewX3 = 0.9 * pnorm(gridnewX3, mean = 5, sd = 2)

vecEstimatedThetas = estimateParCondCopula(
  observedX1 = X1, observedX2 = X2, observedX3 = X3,
  newX3 = gridnewX3, family = 1, h = 0.1)

# Estimated conditional parameters
vecEstimatedThetas
# True conditional parameters
VineCopula::BiCopTau2Par(1 , conditionalTauNewX3 )

# Estimated conditional Kendall's tau
VineCopula::BiCopPar2Tau(1 , vecEstimatedThetas )
# True conditional Kendall's tau
conditionalTauNewX3


</code></pre>

<hr>
<h2 id='simpA.kendallReg'>Test of the simplifying assumption using the constancy
of conditional Kendall's tau</h2><span id='topic+simpA.kendallReg'></span>

<h3>Description</h3>

<p>This function computes Kendall's regression, a regression-like
model for conditional Kendall's tau. More precisely, it fits the model
</p>
<p style="text-align: center;"><code class="reqn">\Lambda(\tau_{X_1, X_2 | Z = z}) = \sum_{j=1}^{p'} \beta_j \psi_j(z),</code>
</p>

<p>where <code class="reqn">\tau_{X_1, X_2 | Z = z}</code> is the conditional Kendall's tau
between <code class="reqn">X_1</code> and <code class="reqn">X_2</code> conditionally to <code class="reqn">Z=z</code>,
<code class="reqn">\Lambda</code> is a function from <code class="reqn">]-1, 1]</code> to <code class="reqn">R</code>,
<code class="reqn">(\beta_1, \dots, \beta_p)</code> are unknown coefficients to be estimated
and <code class="reqn">\psi_1, \dots, \psi_{p'})</code> are a dictionary of functions.
Then, this function tests the assumption
</p>
<p style="text-align: center;"><code class="reqn">\beta_2 = \beta_3 = ... = \beta_{p'} = 0,</code>
</p>

<p>where the coefficient corresponding to the intercept is removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpA.kendallReg(
  X1,
  X2,
  Z,
  vectorZToEstimate = NULL,
  listPhi = list(function(x) {
     return(x)
 }, function(x) {
     return(x^2)
 },
    function(x) {
     return(x^3)
 }),
  typeEstCKT = 4,
  h_kernel,
  Lambda = function(x) {
     return(x)
 },
  Lambda_deriv = function(x) {
     return(1)
 },
  lambda = NULL,
  h_lambda = h_kernel,
  Kfolds_lambda = 5,
  l_norm = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpA.kendallReg_+3A_x1">X1</code></td>
<td>
<p>vector of observations of the first conditioned variable</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_x2">X2</code></td>
<td>
<p>vector of observations of the second conditioned variable</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_z">Z</code></td>
<td>
<p>vector of observations of the conditioning variable</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_vectorztoestimate">vectorZToEstimate</code></td>
<td>
<p>vector containing the points <code class="reqn">Z'_i</code>
to be used at which the conditional Kendall's tau should be estimated.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_listphi">listPhi</code></td>
<td>
<p>the list of transformations <code class="reqn">phi</code> to be used.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_typeestckt">typeEstCKT</code></td>
<td>
<p>the type of estimation of the kernel-based estimation
of conditional Kendall's tau.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_h_kernel">h_kernel</code></td>
<td>
<p>the bandwidth used for the kernel-based estimations.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_lambda">Lambda</code></td>
<td>
<p>the function to be applied on conditional Kendall's tau.
By default, the identity function is used.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_lambda_deriv">Lambda_deriv</code></td>
<td>
<p>the derivative of the function <code>Lambda</code>.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_lambda">lambda</code></td>
<td>
<p>the penalization parameter used for Kendall's regression.
By default, cross-validation is used to find the best value of <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_h_lambda">h_lambda</code></td>
<td>
<p>bandwidth used for the smooth cross-validation
in order to get a value for <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_kfolds_lambda">Kfolds_lambda</code></td>
<td>
<p>the number of subsets used for the cross-validation
in order to get a value for <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="simpA.kendallReg_+3A_l_norm">l_norm</code></td>
<td>
<p>type of norm used for selection of the optimal lambda
by cross-validation. <code>l_norm=1</code> corresponds to the sum of
absolute values of differences between predicted and estimated
conditional Kendall's tau while <code>l_norm=2</code> corresponds to
the sum of squares of differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>statWn</code>: the value of the test statistic.
</p>
</li>
<li> <p><code>p_val</code>: the p-value of the test.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2020).
On Kendall’s regression.
Journal of Multivariate Analysis, 178, 104610.
(page 7)
<a href="https://doi.org/10.1016/j.jmva.2020.104610">doi:10.1016/j.jmva.2020.104610</a>
</p>


<h3>See Also</h3>

<p>The function to fit Kendall's regression:
<code><a href="#topic+CKT.kendallReg.fit">CKT.kendallReg.fit</a></code>.
</p>
<p>Other tests of the simplifying assumption:
</p>

<ul>
<li> <p><code><a href="#topic+simpA.NP">simpA.NP</a></code> in a nonparametric setting
</p>
</li>
<li> <p><code><a href="#topic+simpA.param">simpA.param</a></code> in a (semi)parametric setting,
where the conditional copula belongs to a parametric family,
but the conditional margins are estimated arbitrarily through
kernel smoothing
</p>
</li>
<li><p> the counterparts of these tests in the discrete conditioning setting:
<code><a href="#topic+bCond.simpA.CKT">bCond.simpA.CKT</a></code>
(test based on conditional Kendall's tau)
<code><a href="#topic+bCond.simpA.param">bCond.simpA.param</a></code>
(test assuming a parametric form for the conditional copula)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# We simulate from a conditional copula
set.seed(1)
N = 300
Z = runif(n = N, min = 0, max = 1)
conditionalTau = -0.9 + 1.8 * Z
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

result = simpA.kendallReg(
   X1, X2, Z, h_kernel = 0.03,
   listPhi = list(
     function(x){return(x)}, function(x){return(x^2)},
     function(x){return(x^3)}, function(x){return(x^4)},
     function(x){return(x^5)},
     function(x){return(cos(x))}, function(x){return(sin(x))},
     function(x){return(as.numeric(x &lt;= 0.4))},
     function(x){return(as.numeric(x &lt;= 0.6))}) )
print(result$p_val)

# We simulate from a conditional copula
set.seed(1)
N = 300
Z = runif(n = N, min = 0, max = 1)
conditionalTau = -0.3
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1])
X2 = qnorm(simCopula[,2])

result = simpA.kendallReg(
   X1, X2, Z, h_kernel = 0.03,
   listPhi = list(
     function(x){return(x)}, function(x){return(x^2)},
     function(x){return(x^3)}, function(x){return(x^4)},
     function(x){return(x^5)},
     function(x){return(cos(x))}, function(x){return(sin(x))},
     function(x){return(as.numeric(x &lt;= 0.4))},
     function(x){return(as.numeric(x &lt;= 0.6))}) )
print(result$p_val)


</code></pre>

<hr>
<h2 id='simpA.NP'>Nonparametric testing of the simplifying assumption</h2><span id='topic+simpA.NP'></span>

<h3>Description</h3>

<p>This function tests the &ldquo;simplifying assumption&rdquo; that a conditional
copula </p>
<p style="text-align: center;"><code class="reqn">C_{1,2|3}(u_1, u_2 | X_3 = x_3)</code>
</p>
<p> does not depend on the
value of the conditioning variable <code class="reqn">x_3</code> in a nonparametric setting,
where the conditional copula is estimated by kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpA.NP(
  X1,
  X2,
  X3,
  testStat,
  typeBoot = "bootNP",
  h,
  nBootstrap = 100,
  kernel.name = "Epanechnikov",
  truncVal = h,
  numericalInt = list(kind = "legendre", nGrid = 10)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpA.NP_+3A_x1">X1</code></td>
<td>
<p>vector of <code>n</code> observations of the first conditioned variable</p>
</td></tr>
<tr><td><code id="simpA.NP_+3A_x2">X2</code></td>
<td>
<p>vector of <code>n</code> observations of the second conditioned variable</p>
</td></tr>
<tr><td><code id="simpA.NP_+3A_x3">X3</code></td>
<td>
<p>vector of <code>n</code> observations  of the conditioning variable</p>
</td></tr>
<tr><td><code id="simpA.NP_+3A_teststat">testStat</code></td>
<td>
<p>name of the test statistic to be used.
Possible values are
</p>

<ul>
<li> <p><code>T1_CvM_Cs3</code>: Equation (3) of (Derumigny &amp; Fermanian, 2017) with
the simplified copula estimated by Equation (6) and the weight
<code class="reqn">w(u_1, u_2, u_3) = \hat{F}_1(u_1) \hat{F}_2(u_2) \hat{F}_3(u_3)</code>.
</p>
</li>
<li> <p><code>T1_CvM_Cs4</code>: Equation (3) of (Derumigny &amp; Fermanian, 2017) with
the simplified copula estimated by Equation (7) and the weight
<code class="reqn">w(u_1, u_2, u_3) = \hat{F}_1(u_1) \hat{F}_2(u_2) \hat{F}_3(u_3)</code>.
</p>
</li>
<li> <p><code>T1_KS_Cs3</code>: Equation (4) of (Derumigny &amp; Fermanian, 2017) with
the simplified copula estimated by Equation (6).
</p>
</li>
<li> <p><code>T1_KS_Cs4</code>: Equation (4) of (Derumigny &amp; Fermanian, 2017) with
the simplified copula estimated by Equation (7).
</p>
</li>
<li> <p><code>tilde_T0_CvM</code>: Equation (10) of (Derumigny &amp; Fermanian, 2017).
</p>
</li>
<li> <p><code>tilde_T0_KS</code>: Equation (9) of (Derumigny &amp; Fermanian, 2017).
</p>
</li>
<li> <p><code>I_chi</code>: Equation (13) of (Derumigny &amp; Fermanian, 2017).
</p>
</li>
<li> <p><code>I_2n</code>: Equation (15) of (Derumigny &amp; Fermanian, 2017).
</p>
</li></ul>
</td></tr>
<tr><td><code id="simpA.NP_+3A_typeboot">typeBoot</code></td>
<td>
<p>the type of bootstrap to be used
(see Derumigny and Fermanian, 2017, p.165).
Possible values are
</p>

<ul>
<li> <p><code>boot.NP</code>: usual (Efron's) non-parametric bootstrap
</p>
</li>
<li> <p><code>boot.pseudoInd</code>: pseudo-independent bootstrap
</p>
</li>
<li> <p><code>boot.pseudoInd.sameX3</code>: pseudo-independent bootstrap
without resampling on <code class="reqn">X_3</code>
</p>
</li>
<li> <p><code>boot.pseudoNP</code>: pseudo-non-parametric bootstrap
</p>
</li>
<li> <p><code>boot.cond</code>: conditional bootstrap
</p>
</li></ul>
</td></tr>
<tr><td><code id="simpA.NP_+3A_h">h</code></td>
<td>
<p>the bandwidth used for kernel smoothing</p>
</td></tr>
<tr><td><code id="simpA.NP_+3A_nbootstrap">nBootstrap</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="simpA.NP_+3A_kernel.name">kernel.name</code></td>
<td>
<p>the name of the kernel</p>
</td></tr>
<tr><td><code id="simpA.NP_+3A_truncval">truncVal</code></td>
<td>
<p>the value of truncation for the integral,
i.e. the integrals are computed from <code>truncVal</code> to <code>1-truncVal</code>
instead of from 0 to 1.</p>
</td></tr>
<tr><td><code id="simpA.NP_+3A_numericalint">numericalInt</code></td>
<td>
<p>parameters to be given to
<code>statmod::<a href="statmod.html#topic+gauss.quad">gauss.quad</a></code>, including the number of
quadrature points and the type of interpolation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>true_stat</code>: the value of the test statistic
computed on the whole sample
</p>
</li>
<li> <p><code>vect_statB</code>: a vector of length <code>nBootstrap</code>
containing the bootstrapped test statistics.
</p>
</li>
<li> <p><code>p_val</code>: the p-value of the test.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2017).
About tests of the “simplifying” assumption for conditional copulas.
Dependence Modeling, 5(1), 154-197.
<a href="https://doi.org/10.1515/demo-2017-0011">doi:10.1515/demo-2017-0011</a>
</p>


<h3>See Also</h3>

<p>Other tests of the simplifying assumption:
</p>

<ul>
<li> <p><code><a href="#topic+simpA.param">simpA.param</a></code> in a (semi)parametric setting,
where the conditional copula belongs to a parametric family,
but the conditional margins are estimated arbitrarily through
kernel smoothing
</p>
</li>
<li> <p><code><a href="#topic+simpA.kendallReg">simpA.kendallReg</a></code>: test based on the constancy of
conditional Kendall's tau
</p>
</li>
<li><p> the counterparts of these tests in the discrete conditioning setting:
<code><a href="#topic+bCond.simpA.CKT">bCond.simpA.CKT</a></code>
(test based on conditional Kendall's tau)
<code><a href="#topic+bCond.simpA.param">bCond.simpA.param</a></code>
(test assuming a parametric form for the conditional copula)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 500
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1], mean = Z)
X2 = qnorm(simCopula[,2], mean = - Z)

result &lt;- simpA.NP(
   X1 = X1, X2 = X2, X3 = Z,
   testStat = "I_chi", typeBoot = "boot.pseudoInd",
   h = 0.03, kernel.name = "Epanechnikov", nBootstrap = 10)

# In practice, it is recommended to use at least nBootstrap = 100
# with nBootstrap = 200 being a good choice.

print(result$p_val)

set.seed(1)
N = 500
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = 0.8
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1], mean = Z)
X2 = qnorm(simCopula[,2], mean = - Z)

result &lt;- simpA.NP(
   X1 = X1, X2 = X2, X3 = Z,
   testStat = "I_chi", typeBoot = "boot.pseudoInd",
   h = 0.08, kernel.name = "Epanechnikov", nBootstrap = 10)
print(result$p_val)

</code></pre>

<hr>
<h2 id='simpA.param'>Semiparametric testing of the simplifying assumption</h2><span id='topic+simpA.param'></span>

<h3>Description</h3>

<p>This function tests the &ldquo;simplifying assumption&rdquo; that a conditional
copula </p>
<p style="text-align: center;"><code class="reqn">C_{1,2|3}(u_1, u_2 | X_3 = x_3)</code>
</p>
<p> does not depend on the
value of the conditioning variable <code class="reqn">x_3</code> in a semiparametric setting,
where the conditional copula is of the form
</p>
<p style="text-align: center;"><code class="reqn">C_{1,2|3}(u_1, u_2 | X_3 = x_3) = C_{\theta(x_3)}(u_1,u_2),</code>
</p>

<p>for all <code class="reqn">0 &lt;= u_1, u_2 &lt;= 1</code> and all <code class="reqn">x_3</code>.
Here, <code class="reqn">(C_\theta)</code> is a known family of copula and <code class="reqn">\theta(x_3)</code>
is an unknown conditional dependence parameter.
In this setting, the simplifying assumption can be rewritten as
<strong>&ldquo;<code class="reqn">\theta(x_3)</code> does not depend on <code class="reqn">x_3</code>, i.e. is a constant
function of <code class="reqn">x_3</code>&rdquo;</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpA.param(
  X1,
  X2,
  X3,
  family,
  testStat = "T2c",
  typeBoot = "boot.NP",
  h,
  nBootstrap = 100,
  kernel.name = "Epanechnikov",
  truncVal = h,
  numericalInt = list(kind = "legendre", nGrid = 10)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpA.param_+3A_x1">X1</code></td>
<td>
<p>vector of <code>n</code> observations of the first conditioned variable</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_x2">X2</code></td>
<td>
<p>vector of <code>n</code> observations of the second conditioned variable</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_x3">X3</code></td>
<td>
<p>vector of <code>n</code> observations  of the conditioning variable</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_family">family</code></td>
<td>
<p>the chosen family of copulas
(see the documentation of the class <code>VineCopula::<a href="VineCopula.html#topic+BiCop">BiCop</a>()</code>
for the available families).</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_teststat">testStat</code></td>
<td>
<p>name of the test statistic to be used.
The only choice implemented yet is <code>'T2c'</code>.</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_typeboot">typeBoot</code></td>
<td>
<p>the type of bootstrap to be used.
(see Derumigny and Fermanian, 2017, p.165).
Possible values are
</p>

<ul>
<li> <p><code>"boot.NP"</code>: usual (Efron's) non-parametric bootstrap
</p>
</li>
<li> <p><code>"boot.pseudoInd"</code>: pseudo-independent bootstrap
</p>
</li>
<li> <p><code>"boot.pseudoInd.sameX3"</code>: pseudo-independent bootstrap
without resampling on <code class="reqn">X_3</code>
</p>
</li>
<li> <p><code>"boot.pseudoNP"</code>: pseudo-non-parametric bootstrap
</p>
</li>
<li> <p><code>"boot.cond"</code>: conditional bootstrap
</p>
</li>
<li> <p><code>"boot.paramInd"</code>: parametric independent bootstrap
</p>
</li>
<li> <p><code>"boot.paramCond"</code>: parametric conditional bootstrap
</p>
</li></ul>
</td></tr>
<tr><td><code id="simpA.param_+3A_h">h</code></td>
<td>
<p>the bandwidth used for kernel smoothing</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_nbootstrap">nBootstrap</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_kernel.name">kernel.name</code></td>
<td>
<p>the name of the kernel</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_truncval">truncVal</code></td>
<td>
<p>the value of truncation for the integral,
i.e. the integrals are computed from <code>truncVal</code> to <code>1-truncVal</code>
instead of from 0 to 1.</p>
</td></tr>
<tr><td><code id="simpA.param_+3A_numericalint">numericalInt</code></td>
<td>
<p>parameters to be given to
<code>statmod::<a href="statmod.html#topic+gauss.quad">gauss.quad</a></code>, including the number of
quadrature points and the type of interpolation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>true_stat</code>: the value of the test statistic
computed on the whole sample
</p>
</li>
<li> <p><code>vect_statB</code>: a vector of length <code>nBootstrap</code>
containing the bootstrapped test statistics.
</p>
</li>
<li> <p><code>p_val</code>: the p-value of the test.
</p>
</li></ul>



<h3>References</h3>

<p>Derumigny, A., &amp; Fermanian, J. D. (2017).
About tests of the “simplifying” assumption for conditional copulas.
Dependence Modeling, 5(1), 154-197.
<a href="https://doi.org/10.1515/demo-2017-0011">doi:10.1515/demo-2017-0011</a>
</p>


<h3>See Also</h3>

<p>Other tests of the simplifying assumption:
</p>

<ul>
<li> <p><code><a href="#topic+simpA.NP">simpA.NP</a></code> in a nonparametric setting
</p>
</li>
<li> <p><code><a href="#topic+simpA.kendallReg">simpA.kendallReg</a></code>: test based on the constancy of
conditional Kendall's tau
</p>
</li>
<li><p> the counterparts of these tests in the discrete conditioning setting:
<code><a href="#topic+bCond.simpA.CKT">bCond.simpA.CKT</a></code>
(test based on conditional Kendall's tau)
<code><a href="#topic+bCond.simpA.param">bCond.simpA.param</a></code>
(test assuming a parametric form for the conditional copula)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We simulate from a conditional copula
set.seed(1)
N = 500
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = -0.9 + 1.8 * pnorm(Z, mean = 5, sd = 2)
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1], mean = Z)
X2 = qnorm(simCopula[,2], mean = - Z)

result &lt;- simpA.param(
   X1 = X1, X2 = X2, X3 = Z, family = 1,
   h = 0.03, kernel.name = "Epanechnikov", nBootstrap = 5)
print(result$p_val)
# In practice, it is recommended to use at least nBootstrap = 100
# with nBootstrap = 200 being a good choice.


set.seed(1)
N = 500
Z = rnorm(n = N, mean = 5, sd = 2)
conditionalTau = 0.8
simCopula = VineCopula::BiCopSim(N=N , family = 1,
    par = VineCopula::BiCopTau2Par(1 , conditionalTau ))
X1 = qnorm(simCopula[,1], mean = Z)
X2 = qnorm(simCopula[,2], mean = - Z)

result &lt;- simpA.param(
   X1 = X1, X2 = X2, X3 = Z, family = 1,
   h = 0.08, kernel.name = "Epanechnikov", nBootstrap = 5)
print(result$p_val)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
