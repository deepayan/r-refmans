<!DOCTYPE html><html><head><title>Help for package processx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {processx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#base64_decode'><p>Base64 Encoding and Decoding</p></a></li>
<li><a href='#conn_create_fd'><p>Processx connections</p></a></li>
<li><a href='#conn_create_fifo'><p>Processx FIFOs</p></a></li>
<li><a href='#conn_create_unix_socket'><p>Unix domain sockets</p></a></li>
<li><a href='#curl_fds'><p>Create a pollable object from a curl multi handle's file descriptors</p></a></li>
<li><a href='#default_pty_options'><p>Default options for pseudo terminals (ptys)</p></a></li>
<li><a href='#poll'><p>Poll for process I/O or termination</p></a></li>
<li><a href='#process'><p>External process</p></a></li>
<li><a href='#process_initialize'><p>Start a process</p></a></li>
<li><a href='#processx-package'><p>processx: Execute and Control System Processes</p></a></li>
<li><a href='#run'><p>Run external command, and wait until finishes</p></a></li>
<li><a href='#supervisor_kill'><p>Terminate all supervised processes and the supervisor process itself as</p>
well</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Execute and Control System Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>3.8.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to run system processes in the background.  It can
    check if a background process is running; wait on a background process
    to finish; get the exit status of finished processes; kill background
    processes. It can read the standard output and error of the processes,
    using non-blocking connections. 'processx' can poll a process for
    standard output or error, with a timeout. It can also poll several
    processes at once.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://processx.r-lib.org">https://processx.r-lib.org</a>, <a href="https://github.com/r-lib/processx">https://github.com/r-lib/processx</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/processx/issues">https://github.com/r-lib/processx/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ps (&ge; 1.2.0), R6, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>callr (&ge; 3.7.3), cli (&ge; 3.3.0), codetools, covr, curl,
debugme, parallel, rlang (&ge; 1.0.2), testthat (&ge; 3.0.0),
webfakes, withr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 12:01:41 UTC; gaborcsardi</td>
</tr>
<tr>
<td>Author:</td>
<td>G치bor Cs치rdi <a href="https://orcid.org/0000-0001-7098-9676"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Winston Chang [aut],
  Posit Software, PBC [cph, fnd],
  Mango Solutions [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>G치bor Cs치rdi &lt;csardi.gabor@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 12:50:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:26:17 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='base64_decode'>Base64 Encoding and Decoding</h2><span id='topic+base64_decode'></span><span id='topic+base64_encode'></span>

<h3>Description</h3>

<p>Base64 Encoding and Decoding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64_decode(x)

base64_encode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64_decode_+3A_x">x</code></td>
<td>
<p>Raw vector to encode / decode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raw vector, result of the encoding / decoding.
</p>

<hr>
<h2 id='conn_create_fd'>Processx connections</h2><span id='topic+conn_create_fd'></span><span id='topic+conn_file_name'></span><span id='topic+conn_create_pipepair'></span><span id='topic+conn_read_chars'></span><span id='topic+conn_read_chars.processx_connection'></span><span id='topic+processx_conn_read_chars'></span><span id='topic+conn_read_lines'></span><span id='topic+conn_read_lines.processx_connection'></span><span id='topic+processx_conn_read_lines'></span><span id='topic+conn_is_incomplete'></span><span id='topic+conn_is_incomplete.processx_connection'></span><span id='topic+processx_conn_is_incomplete'></span><span id='topic+conn_write'></span><span id='topic+conn_write.processx_connection'></span><span id='topic+processx_conn_write'></span><span id='topic+conn_create_file'></span><span id='topic+conn_set_stdout'></span><span id='topic+conn_set_stderr'></span><span id='topic+conn_get_fileno'></span><span id='topic+conn_disable_inheritance'></span><span id='topic+close.processx_connection'></span><span id='topic+processx_conn_close'></span><span id='topic+is_valid_fd'></span>

<h3>Description</h3>

<p>These functions are currently experimental and will change
in the future. Note that processx connections are  <em>not</em>
compatible with R's built-in connection system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conn_create_fd(fd, encoding = "", close = TRUE)

conn_file_name(con)

conn_create_pipepair(encoding = "", nonblocking = c(TRUE, FALSE))

conn_read_chars(con, n = -1)

## S3 method for class 'processx_connection'
conn_read_chars(con, n = -1)

processx_conn_read_chars(con, n = -1)

conn_read_lines(con, n = -1)

## S3 method for class 'processx_connection'
conn_read_lines(con, n = -1)

processx_conn_read_lines(con, n = -1)

conn_is_incomplete(con)

## S3 method for class 'processx_connection'
conn_is_incomplete(con)

processx_conn_is_incomplete(con)

conn_write(con, str, sep = "\n", encoding = "")

## S3 method for class 'processx_connection'
conn_write(con, str, sep = "\n", encoding = "")

processx_conn_write(con, str, sep = "\n", encoding = "")

conn_create_file(filename, read = NULL, write = NULL)

conn_set_stdout(con, drop = TRUE)

conn_set_stderr(con, drop = TRUE)

conn_get_fileno(con)

conn_disable_inheritance()

## S3 method for class 'processx_connection'
close(con, ...)

processx_conn_close(con, ...)

is_valid_fd(fd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conn_create_fd_+3A_fd">fd</code></td>
<td>
<p>Integer scalar, a Unix file descriptor.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_encoding">encoding</code></td>
<td>
<p>Encoding of the readable connection when reading.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_close">close</code></td>
<td>
<p>Whether to close the OS file descriptor when closing
the connection. Sometimes you want to leave it open, and use it again
in a <code>conn_create_fd</code> call.
Encoding to re-encode <code>str</code> into when writing.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_con">con</code></td>
<td>
<p>Processx connection object.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_nonblocking">nonblocking</code></td>
<td>
<p>Whether the pipe should be non-blocking.
For <code>conn_create_pipepair()</code> it must be a logical vector of length two,
for both ends of the pipe.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_n">n</code></td>
<td>
<p>Number of characters or lines to read. -1 means all available
characters or lines.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_str">str</code></td>
<td>
<p>Character or raw vector to write.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_sep">sep</code></td>
<td>
<p>Separator to use if <code>str</code> is a character vector. Ignored if
<code>str</code> is a raw vector.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_filename">filename</code></td>
<td>
<p>File name. For <code>conn_create_pipe()</code> on Windows, a
<code style="white-space: pre;">&#8288;\\?\pipe&#8288;</code> prefix is added to this, if it does not have such a prefix.
For <code>conn_create_pipe()</code> it can also be <code>NULL</code>, in which case a random
file name is used via <code>tempfile()</code>.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_read">read</code></td>
<td>
<p>Whether the connection is readable.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_write">write</code></td>
<td>
<p>Whethe the connection is writeable.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_drop">drop</code></td>
<td>
<p>Whether to close the original stdout/stderr, or keep it
open and return a connection to it.</p>
</td></tr>
<tr><td><code id="conn_create_fd_+3A_...">...</code></td>
<td>
<p>Extra arguments, for compatibility with the <code>close()</code>
generic, currently ignored by processx.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conn_create_fd()</code> creates a connection from a file descriptor.
</p>
<p><code>conn_file_name()</code> returns the name of the file associated with the
connection. For connections that do not refer to a file in the file
system it returns <code>NA_character()</code>. Except for named pipes on Windows,
where it returns the full name of the pipe.
</p>
<p><code>conn_create_pipepair()</code> creates a pair of connected connections, the
first one is writeable, the second one is readable.
</p>
<p><code>conn_read_chars()</code> reads UTF-8 characters from the connections. If the
connection itself is not UTF-8 encoded, it re-encodes it.
</p>
<p><code>conn_read_lines()</code> reads lines from a connection.
</p>
<p><code>conn_is_incomplete()</code> returns <code>FALSE</code> if the connection surely has no
more data.
</p>
<p><code>conn_write()</code> writes a character or raw vector to the connection.
It might not be able to write all bytes into the connection, in which
case it returns the leftover bytes in a raw vector. Call <code>conn_write()</code>
again with this raw vector.
</p>
<p><code>conn_create_file()</code> creates a connection to a file.
</p>
<p><code>conn_set_stdout()</code> set the standard output of the R process, to the
specified connection.
</p>
<p><code>conn_set_stderr()</code> set the standard error of the R process, to the
specified connection.
</p>
<p><code>conn_get_fileno()</code> return the integer file desciptor that belongs to
the connection.
</p>
<p><code>conn_disable_inheritance()</code> can be called to disable the inheritance
of all open handles. Call this function as soon as possible in a new
process to avoid inheriting the inherited handles even further.
The function is best effort to close the handles, it might still leave
some handles open. It should work for <code>stdin</code>, <code>stdout</code> and <code>stderr</code>,
at least.
</p>
<p><code>is_valid_fd()</code> returns <code>TRUE</code> if <code>fd</code> is a valid open file
descriptor. You can use it to check if the R process has standard
input, output or error. E.g. R processes running in GUI (like RGui)
might not have any of the standard streams available.
</p>
<p>If a stream is redirected to the null device (e.g. in a callr
subprocess), that is is still a valid file descriptor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_valid_fd(0L)      # stdin
is_valid_fd(1L)      # stdout
is_valid_fd(2L)      # stderr
</code></pre>

<hr>
<h2 id='conn_create_fifo'>Processx FIFOs</h2><span id='topic+conn_create_fifo'></span><span id='topic+conn_connect_fifo'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Create a FIFO for inter-process communication
Note that these functions are currently experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conn_create_fifo(
  filename = NULL,
  read = NULL,
  write = NULL,
  encoding = "",
  nonblocking = TRUE
)

conn_connect_fifo(
  filename,
  read = NULL,
  write = NULL,
  encoding = "",
  nonblocking = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conn_create_fifo_+3A_filename">filename</code></td>
<td>
<p>File name of the FIFO. On Windows it the name of the
pipe within the <code style="white-space: pre;">&#8288;\\?\pipe\&#8288;</code> namespace, either the full name, or the
part after that prefix. If <code>NULL</code>, then a random name
is used, on Unix in the R temporary directory: <code><a href="base.html#topic+tempfile">base::tempdir()</a></code>.</p>
</td></tr>
<tr><td><code id="conn_create_fifo_+3A_read">read</code></td>
<td>
<p>If <code>TRUE</code> then connect to the read end of the FIFO.
Exactly one of <code>read</code> and <code>write</code> must be set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conn_create_fifo_+3A_write">write</code></td>
<td>
<p>If <code>TRUE</code> then connect to the write end of the FIFO.
Exactly one of <code>read</code> and <code>write</code> must be set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conn_create_fifo_+3A_encoding">encoding</code></td>
<td>
<p>Encoding to assume.</p>
</td></tr>
<tr><td><code id="conn_create_fifo_+3A_nonblocking">nonblocking</code></td>
<td>
<p>Whether this should be a non-blocking FIFO.
Note that blocking FIFOs are not well tested and might not work well with
<code><a href="callr.html#topic+poll">poll()</a></code>, especially on Windows. We might remove this option in the
future and make all FIFOs non-blocking.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conn_create_fifo()</code> creates a FIFO and connects to it.
On Unix this is a proper FIFO in the file system, in the R temporary
directory. On Windows it is a named pipe.
</p>
<p>Use <code><a href="processx.html#topic+conn_file_name">conn_file_name()</a></code> to query the name of the FIFO, and
<code>conn_connect_fifo()</code> to connect to the other end.
</p>
<p><code>conn_connect_fifo()</code> connects to a FIFO created with
<code>conn_create_fifo()</code>, typically in another process. <code>filename</code> refers
to the name of the pipe on Windows.
</p>
<p>On Windows, <code>conn_connect_fifo()</code> may be successful even if the
FIFO does not exist, but then later <code>poll()</code> or read/write operations
will fail. We are planning on changing this behavior in the future,
to make <code>conn_connect_fifo()</code> fail immediately, like on Unix.
</p>


<h3>Notes</h3>



<h4>In general Unix domain sockets work better than FIFOs, so we suggest</h4>

<p>you use sockets if you can. See <code><a href="processx.html#topic+conn_create_unix_socket">conn_create_unix_socket()</a></code>.
</p>



<h4>Creating the read end of the FIFO</h4>

<p>This case is simpler. To wait for a writer to connect to the FIFO
you can use <code><a href="callr.html#topic+poll">poll()</a></code> as usual. Then use <code><a href="processx.html#topic+conn_read_chars">conn_read_chars()</a></code> or
<code><a href="processx.html#topic+conn_read_lines">conn_read_lines()</a></code> to read from the FIFO, as usual. Use
<code><a href="processx.html#topic+conn_is_incomplete">conn_is_incomplete()</a></code> <em>after</em> a read to check if there is more data,
or the writer is done.
</p>



<h4>Creating the write end of the FIFO</h4>

<p>This is somewhat trickier. Creating the (non-blocking) FIFO does not
block. However, there is no easy way to tell if a reader is connected
to the other end of the FIFO or not. On Unix you can start using
<code><a href="processx.html#topic+conn_write">conn_write()</a></code> to try to write to it, and this will succeed, until the
buffer gets full, even if there is no reader. (When the buffer is full
it will return the data that was not written, as usual.)
</p>
<p>On Windows, using <code><a href="processx.html#topic+conn_write">conn_write()</a></code> to write to a FIFO without a reader
fails with an error. This is not great, we are planning to improve it
later.
</p>
<p>Right now, one workaround for this behavior is for the reader to
connunicate to the writer process independenctly that it has connected
to the FIFO. (E.g. another FIFO in the opposite direction can do that.)
</p>



<h3>See Also</h3>

<p><a href="https://processx.r-lib.org/dev/articles/internals.html">processx internals</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example for a non-blocking FIFO

# Need to open the reading end first, otherwise Unix fails
reader &lt;- conn_create_fifo()

# Always use poll() before you read, with a timeout if you like.
# If you read before the other end of the FIFO is connected, then
# the OS (or processx?) assumes that the FIFO is done, and you cannot
# read anything.
# Now poll() tells us that there is no data yet.
poll(list(reader), 0)

writer &lt;- conn_connect_fifo(conn_file_name(reader), write = TRUE)
conn_write(writer, "hello\nthere!\n")

poll(list(reader), 1000)
conn_read_lines(reader, 1)
conn_read_chars(reader)

conn_is_incomplete(reader)

close(writer)
conn_read_chars(reader)
conn_is_incomplete(reader)

close(reader)
</code></pre>

<hr>
<h2 id='conn_create_unix_socket'>Unix domain sockets</h2><span id='topic+conn_create_unix_socket'></span><span id='topic+conn_connect_unix_socket'></span><span id='topic+conn_accept_unix_socket'></span><span id='topic+conn_unix_socket_state'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Cross platform point-to-point inter-process communication with
Unix=domain sockets, implemented via named pipes on Windows.
These connection are always bidirectional, i.e. you can read from them
and also write to them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conn_create_unix_socket(filename = NULL, encoding = "")

conn_connect_unix_socket(filename, encoding = "")

conn_accept_unix_socket(con)

conn_unix_socket_state(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conn_create_unix_socket_+3A_filename">filename</code></td>
<td>
<p>File name of the socket. On Windows it the name of the
pipe within the <code style="white-space: pre;">&#8288;\\?\pipe\&#8288;</code> namespace, either the full name, or the
part after that prefix. If <code>NULL</code>, then a random name
is used, on Unix in the R temporary directory: <code><a href="base.html#topic+tempfile">base::tempdir()</a></code>.</p>
</td></tr>
<tr><td><code id="conn_create_unix_socket_+3A_encoding">encoding</code></td>
<td>
<p>Encoding to assume when reading from the socket.</p>
</td></tr>
<tr><td><code id="conn_create_unix_socket_+3A_con">con</code></td>
<td>
<p>Connection. An error is thrown if not a socket connection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conn_create_unix_socket()</code> creates a server socket. The new socket
is listening at <code>filename</code>. See <code>filename</code> above.
</p>
<p><code>conn_connect_unix_socket()</code> creates a client socket and connects it to
a server socket.
</p>
<p><code>conn_accept_unix_socket()</code> accepts a client connection at a server
socket.
</p>
<p><code>conn_unix_socket_state()</code> returns the state of the socket. Currently it
can return: <code>"listening"</code>, <code>"connected_server"</code>, <code>"connected_client"</code>.
It is possible that other states (e.g. for a closed socket) will be added
in the future.
</p>


<h4>Notes</h4>


<ul>
<li> <p><code><a href="callr.html#topic+poll">poll()</a></code> works on sockets, but only polls for data to read, and
currently ignores the write-end of the socket.
</p>
</li>
<li> <p><code><a href="callr.html#topic+poll">poll()</a></code> also works for accepting client connections. It will return
<code>"connect"</code>is a client connection is available for a server socket.
After this you can call <code>conn_accept_unix_socket()</code> to accept the
client connection.
</p>
</li></ul>




<h3>Value</h3>

<p>A new socket connection.
</p>


<h3>See Also</h3>

<p><a href="https://processx.r-lib.org/dev/articles/internals.html">processx internals</a>
</p>

<hr>
<h2 id='curl_fds'>Create a pollable object from a curl multi handle's file descriptors</h2><span id='topic+curl_fds'></span>

<h3>Description</h3>

<p>Create a pollable object from a curl multi handle's file descriptors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_fds(fds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curl_fds_+3A_fds">fds</code></td>
<td>
<p>A list of file descriptors, as returned by
<code><a href="curl.html#topic+multi">curl::multi_fdset()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pollable object, that be used with <code><a href="callr.html#topic+poll">poll()</a></code> directly.
</p>

<hr>
<h2 id='default_pty_options'>Default options for pseudo terminals (ptys)</h2><span id='topic+default_pty_options'></span>

<h3>Description</h3>

<p>Default options for pseudo terminals (ptys)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_pty_options()
</code></pre>


<h3>Value</h3>

<p>Named list of default values of pty options.
</p>
<p>Options and default values:
</p>

<ul>
<li> <p><code>echo</code> whether to keep the echo on the terminal. <code>FALSE</code> turns echo
off.
</p>
</li>
<li> <p><code>rows</code> the (initial) terminal size, number of rows.
</p>
</li>
<li> <p><code>cols</code> the (initial) terminal size, number of columns.
</p>
</li></ul>


<hr>
<h2 id='poll'>Poll for process I/O or termination</h2><span id='topic+poll'></span>

<h3>Description</h3>

<p>Wait until one of the specified connections or processes produce
standard output or error, terminates, or a timeout occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poll(processes, ms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poll_+3A_processes">processes</code></td>
<td>
<p>A list of connection objects or<code>process</code> objects to
wait on. (They can be mixed as well.) If this is a named list, then
the returned list will have the same names. This simplifies the
identification of the processes.</p>
</td></tr>
<tr><td><code id="poll_+3A_ms">ms</code></td>
<td>
<p>Integer scalar, a timeout for the polling, in milliseconds.
Supply -1 for an infitite timeout, and 0 for not waiting at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors of length one or three.
There is one list element for each connection/process, in the same
order as in the input list. For connections the result is a single
string scalar. For processes the character vectors' elements are named
<code>output</code>, <code>error</code> and <code>process</code>. Possible values for each individual
result are: <code>nopipe</code>, <code>ready</code>, <code>timeout</code>, <code>closed</code>, <code>silent</code>.
See details about these below. <code>process</code> refers to the poll connection,
see the <code>poll_connection</code> argument of the <code>process</code> initializer.
</p>


<h3>Explanation of the return values</h3>


<ul>
<li> <p><code>nopipe</code> means that the stdout or stderr from this process was not
captured.
</p>
</li>
<li> <p><code>ready</code> means that the connection or the stdout or stderr from this
process are ready to read from. Note that end-of-file on these
outputs also triggers <code>ready</code>.
</p>
</li>
<li><p> timeout': the connections or processes are not ready to read from
and a timeout happened.
</p>
</li>
<li> <p><code>closed</code>: the connection was already closed, before the polling
started.
</p>
</li>
<li> <p><code>silent</code>: the connection is not ready to read from, but another
connection was.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Different commands to run for windows and unix
cmd1 &lt;- switch(
  .Platform$OS.type,
  "unix" = c("sh", "-c", "sleep 1; ls"),
  c("cmd", "/c", "ping -n 2 127.0.0.1 &amp;&amp; dir /b")
)
cmd2 &lt;- switch(
  .Platform$OS.type,
  "unix" = c("sh", "-c", "sleep 2; ls 1&gt;&amp;2"),
  c("cmd", "/c", "ping -n 2 127.0.0.1 &amp;&amp; dir /b 1&gt;&amp;2")
)

## Run them. p1 writes to stdout, p2 to stderr, after some sleep
p1 &lt;- process$new(cmd1[1], cmd1[-1], stdout = "|")
p2 &lt;- process$new(cmd2[1], cmd2[-1], stderr = "|")

## Nothing to read initially
poll(list(p1 = p1, p2 = p2), 0)

## Wait until p1 finishes. Now p1 has some output
p1$wait()
poll(list(p1 = p1, p2 = p2), -1)

## Close p1's connection, p2 will have output on stderr, eventually
close(p1$get_output_connection())
poll(list(p1 = p1, p2 = p2), -1)

## Close p2's connection as well, no nothing to poll
close(p2$get_error_connection())
poll(list(p1 = p1, p2 = p2), 0)

</code></pre>

<hr>
<h2 id='process'>External process</h2><span id='topic+process'></span>

<h3>Description</h3>

<p>Managing external processes from R is not trivial, and this
class aims to help with this deficiency. It is essentially a small
wrapper around the <code>system</code> base R function, to return the process
id of the started process, and set its standard output and error
streams. The process id is then used to manage the process.
</p>


<h3>Batch files</h3>

<p>Running Windows batch files (<code>.bat</code> or <code>.cmd</code> files) may be complicated
because of the <code>cmd.exe</code> command line parsing rules. For example you
cannot easily have whitespace in both the command (path) and one of the
arguments. To work around these limitations you need to start a
<code>cmd.exe</code> shell explicitly and use its <code>call</code> command. For example:
</p>
<div class="sourceCode r"><pre>process$new("cmd.exe", c("/c", "call", bat_file, "arg 1", "arg 2"))
</pre></div>
<p>This works even if <code>bat_file</code> contains whitespace characters.
For more information about this, see this processx issue:
https://github.com/r-lib/processx/issues/301
</p>
<p>The detailed parsing rules are at
https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmd
</p>
<p>A very good practical guide is at
https://ss64.com/nt/syntax-esc.html
</p>


<h3>Polling</h3>

<p>The <code>poll_io()</code> function polls the standard output and standard
error connections of a process, with a timeout. If there is output
in either of them, or they are closed (e.g. because the process exits)
<code>poll_io()</code> returns immediately.
</p>
<p>In addition to polling a single process, the <code><a href="callr.html#topic+poll">poll()</a></code> function
can poll the output of several processes, and returns as soon as any
of them has generated output (or exited).
</p>


<h3>Cleaning up background processes</h3>

<p>processx kills processes that are not referenced any more (if <code>cleanup</code>
is set to <code>TRUE</code>), or the whole subprocess tree (if <code>cleanup_tree</code> is
also set to <code>TRUE</code>).
</p>
<p>The cleanup happens when the references of the processes object are
garbage collected. To clean up earlier, you can call the <code>kill()</code> or
<code>kill_tree()</code> method of the process(es), from an <code>on.exit()</code> expression,
or an error handler:
</p>
<div class="sourceCode r"><pre>process_manager &lt;- function() {
  on.exit({
    try(p1$kill(), silent = TRUE)
    try(p2$kill(), silent = TRUE)
  }, add = TRUE)
  p1 &lt;- process$new("sleep", "3")
  p2 &lt;- process$new("sleep", "10")
  p1$wait()
  p2$wait()
}
process_manager()
</pre></div>
<p>If you interrupt <code>process_manager()</code> or an error happens then both <code>p1</code>
and <code>p2</code> are cleaned up immediately. Their connections will also be
closed. The same happens at a regular exit.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-process-new"><code>process$new()</code></a>
</p>
</li>
<li> <p><a href="#method-process-finalize"><code>process$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-process-kill"><code>process$kill()</code></a>
</p>
</li>
<li> <p><a href="#method-process-kill_tree"><code>process$kill_tree()</code></a>
</p>
</li>
<li> <p><a href="#method-process-signal"><code>process$signal()</code></a>
</p>
</li>
<li> <p><a href="#method-process-interrupt"><code>process$interrupt()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_pid"><code>process$get_pid()</code></a>
</p>
</li>
<li> <p><a href="#method-process-is_alive"><code>process$is_alive()</code></a>
</p>
</li>
<li> <p><a href="#method-process-wait"><code>process$wait()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_exit_status"><code>process$get_exit_status()</code></a>
</p>
</li>
<li> <p><a href="#method-process-format"><code>process$format()</code></a>
</p>
</li>
<li> <p><a href="#method-process-print"><code>process$print()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_start_time"><code>process$get_start_time()</code></a>
</p>
</li>
<li> <p><a href="#method-process-is_supervised"><code>process$is_supervised()</code></a>
</p>
</li>
<li> <p><a href="#method-process-supervise"><code>process$supervise()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_output"><code>process$read_output()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_error"><code>process$read_error()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_output_lines"><code>process$read_output_lines()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_error_lines"><code>process$read_error_lines()</code></a>
</p>
</li>
<li> <p><a href="#method-process-is_incomplete_output"><code>process$is_incomplete_output()</code></a>
</p>
</li>
<li> <p><a href="#method-process-is_incomplete_error"><code>process$is_incomplete_error()</code></a>
</p>
</li>
<li> <p><a href="#method-process-has_input_connection"><code>process$has_input_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-has_output_connection"><code>process$has_output_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-has_error_connection"><code>process$has_error_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-has_poll_connection"><code>process$has_poll_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_input_connection"><code>process$get_input_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_output_connection"><code>process$get_output_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_error_connection"><code>process$get_error_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_all_output"><code>process$read_all_output()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_all_error"><code>process$read_all_error()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_all_output_lines"><code>process$read_all_output_lines()</code></a>
</p>
</li>
<li> <p><a href="#method-process-read_all_error_lines"><code>process$read_all_error_lines()</code></a>
</p>
</li>
<li> <p><a href="#method-process-write_input"><code>process$write_input()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_input_file"><code>process$get_input_file()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_output_file"><code>process$get_output_file()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_error_file"><code>process$get_error_file()</code></a>
</p>
</li>
<li> <p><a href="#method-process-poll_io"><code>process$poll_io()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_poll_connection"><code>process$get_poll_connection()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_result"><code>process$get_result()</code></a>
</p>
</li>
<li> <p><a href="#method-process-as_ps_handle"><code>process$as_ps_handle()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_name"><code>process$get_name()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_exe"><code>process$get_exe()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_cmdline"><code>process$get_cmdline()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_status"><code>process$get_status()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_username"><code>process$get_username()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_wd"><code>process$get_wd()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_cpu_times"><code>process$get_cpu_times()</code></a>
</p>
</li>
<li> <p><a href="#method-process-get_memory_info"><code>process$get_memory_info()</code></a>
</p>
</li>
<li> <p><a href="#method-process-suspend"><code>process$suspend()</code></a>
</p>
</li>
<li> <p><a href="#method-process-resume"><code>process$resume()</code></a>
</p>
</li></ul>


<hr>
<a id="method-process-new"></a>



<h4>Method <code>new()</code></h4>

<p>Start a new process in the background, and then return immediately.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$new(
  command = NULL,
  args = character(),
  stdin = NULL,
  stdout = NULL,
  stderr = NULL,
  pty = FALSE,
  pty_options = list(),
  connections = list(),
  poll_connection = NULL,
  env = NULL,
  cleanup = TRUE,
  cleanup_tree = FALSE,
  wd = NULL,
  echo_cmd = FALSE,
  supervise = FALSE,
  windows_verbatim_args = FALSE,
  windows_hide_window = FALSE,
  windows_detached_process = !cleanup,
  encoding = "",
  post_process = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>command</code></dt><dd><p>Character scalar, the command to run.
Note that this argument is not passed to a shell, so no
tilde-expansion or variable substitution is performed on it.
It should not be quoted with <code><a href="base.html#topic+shQuote">base::shQuote()</a></code>. See
<code><a href="base.html#topic+normalizePath">base::normalizePath()</a></code> for tilde-expansion. If you want to run
<code>.bat</code> or <code>.cmd</code> files on Windows, make sure you read the
'Batch files' section above.</p>
</dd>
<dt><code>args</code></dt><dd><p>Character vector, arguments to the command. They will be
passed to the process as is, without a shell transforming them,
They don't need to be escaped.</p>
</dd>
<dt><code>stdin</code></dt><dd><p>What to do with the standard input. Possible values:
</p>

<ul>
<li> <p><code>NULL</code>: set to the <em>null device</em>, i.e. no standard input is
provided;
</p>
</li>
<li><p> a file name, use this file as standard input;
</p>
</li>
<li> <p><code>"|"</code>: create a (writeable) connection for stdin.
</p>
</li>
<li> <p><code>""</code> (empty string): inherit it from the main R process. If the
main R process does not have a standard input stream, e.g. in
RGui on Windows, then an error is thrown.
</p>
</li></ul>
</dd>
<dt><code>stdout</code></dt><dd><p>What to do with the standard output. Possible values:
</p>

<ul>
<li> <p><code>NULL</code>: discard it;
</p>
</li>
<li><p> A string, redirect it to this file.
Note that if you specify a relative path, it will be relative to
the current working directory, even if you specify another
directory in the <code>wd</code> argument. (See issue 324.)
</p>
</li>
<li> <p><code>"|"</code>: create a connection for it.
</p>
</li>
<li> <p><code>""</code> (empty string): inherit it from the main R process. If the
main R process does not have a standard output stream, e.g. in
RGui on Windows, then an error is thrown.
</p>
</li></ul>
</dd>
<dt><code>stderr</code></dt><dd><p>What to do with the standard error. Possible values:
</p>

<ul>
<li> <p><code>NULL</code>: discard it.
</p>
</li>
<li><p> A string, redirect it to this file.
Note that if you specify a relative path, it will be relative to
the current working directory, even if you specify another
directory in the <code>wd</code> argument. (See issue 324.)
</p>
</li>
<li> <p><code>"|"</code>: create a connection for it.
</p>
</li>
<li> <p><code>"2&gt;&amp;1"</code>: redirect it to the same connection (i.e. pipe or file)
as <code>stdout</code>. <code>"2&gt;&amp;1"</code> is a way to keep standard output and error
correctly interleaved.
</p>
</li>
<li> <p><code>""</code> (empty string): inherit it from the main R process. If the
main R process does not have a standard error stream, e.g. in
RGui on Windows, then an error is thrown.
</p>
</li></ul>
</dd>
<dt><code>pty</code></dt><dd><p>Whether to create a pseudo terminal (pty) for the
background process. This is currently only supported on Unix
systems, but not supported on Solaris.
If it is <code>TRUE</code>, then the <code>stdin</code>, <code>stdout</code> and <code>stderr</code> arguments
must be <code>NULL</code>. If a pseudo terminal is created, then processx
will create pipes for standard input and standard output. There is
no separate pipe for standard error, because there is no way to
distinguish between stdout and stderr on a pty. Note that the
standard output connection of the pty is <em>blocking</em>, so we always
poll the standard output connection before reading from it using
the <code style="white-space: pre;">&#8288;$read_output()&#8288;</code> method. Also, because <code style="white-space: pre;">&#8288;$read_output_lines()&#8288;</code>
could still block if no complete line is available, this function
always fails if the process has a pty. Use <code style="white-space: pre;">&#8288;$read_output()&#8288;</code> to
read from ptys.</p>
</dd>
<dt><code>pty_options</code></dt><dd><p>Unix pseudo terminal options, a named list. see
<code><a href="processx.html#topic+default_pty_options">default_pty_options()</a></code> for details and defaults.</p>
</dd>
<dt><code>connections</code></dt><dd><p>A list of processx connections to pass to the
child process. This is an experimental feature currently.</p>
</dd>
<dt><code>poll_connection</code></dt><dd><p>Whether to create an extra connection to the
process that allows polling, even if the standard input and
standard output are not pipes. If this is <code>NULL</code> (the default),
then this connection will be only created if standard output and
standard error are not pipes, and <code>connections</code> is an empty list.
If the poll connection is created, you can query it via
<code>p$get_poll_connection()</code> and it is also included in the response
to <code>p$poll_io()</code> and <code><a href="callr.html#topic+poll">poll()</a></code>. The numeric file descriptor of the
poll connection comes right after <code>stderr</code> (2), and the
connections listed in <code>connections</code>.</p>
</dd>
<dt><code>env</code></dt><dd><p>Environment variables of the child process. If <code>NULL</code>,
the parent's environment is inherited. On Windows, many programs
cannot function correctly if some environment variables are not
set, so we always set <code>HOMEDRIVE</code>, <code>HOMEPATH</code>, <code>LOGONSERVER</code>,
<code>PATH</code>, <code>SYSTEMDRIVE</code>, <code>SYSTEMROOT</code>, <code>TEMP</code>, <code>USERDOMAIN</code>,
<code>USERNAME</code>, <code>USERPROFILE</code> and <code>WINDIR</code>. To append new environment
variables to the ones set in the current process, specify
<code>"current"</code> in <code>env</code>, without a name, and the appended ones with
names. The appended ones can overwrite the current ones.</p>
</dd>
<dt><code>cleanup</code></dt><dd><p>Whether to kill the process when the <code>process</code>
object is garbage collected.</p>
</dd>
<dt><code>cleanup_tree</code></dt><dd><p>Whether to kill the process and its child
process tree when the <code>process</code> object is garbage collected.</p>
</dd>
<dt><code>wd</code></dt><dd><p>Working directory of the process. It must exist.
If <code>NULL</code>, then the current working directory is used.</p>
</dd>
<dt><code>echo_cmd</code></dt><dd><p>Whether to print the command to the screen before
running it.</p>
</dd>
<dt><code>supervise</code></dt><dd><p>Whether to register the process with a supervisor.
If <code>TRUE</code>, the supervisor will ensure that the process is
killed when the R process exits.</p>
</dd>
<dt><code>windows_verbatim_args</code></dt><dd><p>Whether to omit quoting the arguments
on Windows. It is ignored on other platforms.</p>
</dd>
<dt><code>windows_hide_window</code></dt><dd><p>Whether to hide the application's window
on Windows. It is ignored on other platforms.</p>
</dd>
<dt><code>windows_detached_process</code></dt><dd><p>Whether to use the
<code>DETACHED_PROCESS</code> flag on Windows. If this is <code>TRUE</code>, then
the child process will have no attached console, even if the
parent had one.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The encoding to assume for <code>stdin</code>, <code>stdout</code> and
<code>stderr</code>. By default the encoding of the current locale is
used. Note that <code>processx</code> always reencodes the output of the
<code>stdout</code> and <code>stderr</code> streams in UTF-8 currently.
If you want to read them without any conversion, on all platforms,
specify <code>"UTF-8"</code> as encoding.</p>
</dd>
<dt><code>post_process</code></dt><dd><p>An optional function to run when the process has
finished. Currently it only runs if <code style="white-space: pre;">&#8288;$get_result()&#8288;</code> is called.
It is only run once.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>R6 object representing the process.
</p>


<hr>
<a id="method-process-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>Cleanup method that is called when the <code>process</code> object is garbage
collected. If requested so in the process constructor, then it
eliminates all processes in the process's subprocess tree.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$finalize()</pre></div>


<hr>
<a id="method-process-kill"></a>



<h4>Method <code>kill()</code></h4>

<p>Terminate the process. It also terminate all of its child
processes, except if they have created a new process group (on Unix),
or job object (on Windows). It returns <code>TRUE</code> if the process
was terminated, and <code>FALSE</code> if it was not (because it was
already finished/dead when <code>processx</code> tried to terminate it).
</p>


<h5>Usage</h5>

<div class="r"><pre>process$kill(grace = 0.1, close_connections = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grace</code></dt><dd><p>Currently not used.</p>
</dd>
<dt><code>close_connections</code></dt><dd><p>Whether to close standard input, standard
output, standard error connections and the poll connection, after
killing the process.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-kill_tree"></a>



<h4>Method <code>kill_tree()</code></h4>

<p>Process tree cleanup. It terminates the process
(if still alive), together with any child (or grandchild, etc.)
processes. It uses the <em>ps</em> package, so that needs to be installed,
and <em>ps</em> needs to support the current platform as well. Process tree
cleanup works by marking the process with an environment variable,
which is inherited in all child processes. This allows finding
descendents, even if they are orphaned, i.e. they are not connected
to the root of the tree cleanup in the process tree any more.
<code style="white-space: pre;">&#8288;$kill_tree()&#8288;</code> returns a named integer vector of the process ids that
were killed, the names are the names of the processes (e.g. <code>"sleep"</code>,
<code>"notepad.exe"</code>, <code>"Rterm.exe"</code>, etc.).
</p>


<h5>Usage</h5>

<div class="r"><pre>process$kill_tree(grace = 0.1, close_connections = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>grace</code></dt><dd><p>Currently not used.</p>
</dd>
<dt><code>close_connections</code></dt><dd><p>Whether to close standard input, standard
output, standard error connections and the poll connection, after
killing the process.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-signal"></a>



<h4>Method <code>signal()</code></h4>

<p>Send a signal to the process. On Windows only the
<code>SIGINT</code>, <code>SIGTERM</code> and <code>SIGKILL</code> signals are interpreted,
and the special 0 signal. The first three all kill the process. The 0
signal returns <code>TRUE</code> if the process is alive, and <code>FALSE</code>
otherwise. On Unix all signals are supported that the OS supports,
and the 0 signal as well.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$signal(signal)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>signal</code></dt><dd><p>An integer scalar, the id of the signal to send to
the process. See <code><a href="tools.html#topic+pskill">tools::pskill()</a></code> for the list of signals.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-interrupt"></a>



<h4>Method <code>interrupt()</code></h4>

<p>Send an interrupt to the process. On Unix this is a
<code>SIGINT</code> signal, and it is usually equivalent to pressing CTRL+C at
the terminal prompt. On Windows, it is a CTRL+BREAK keypress.
Applications may catch these events. By default they will quit.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$interrupt()</pre></div>


<hr>
<a id="method-process-get_pid"></a>



<h4>Method <code>get_pid()</code></h4>

<p>Query the process id.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_pid()</pre></div>



<h5>Returns</h5>

<p>Integer scalar, the process id of the process.
</p>


<hr>
<a id="method-process-is_alive"></a>



<h4>Method <code>is_alive()</code></h4>

<p>Check if the process is alive.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$is_alive()</pre></div>



<h5>Returns</h5>

<p>Logical scalar.
</p>


<hr>
<a id="method-process-wait"></a>



<h4>Method <code>wait()</code></h4>

<p>Wait until the process finishes, or a timeout happens.
Note that if the process never finishes, and the timeout is infinite
(the default), then R will never regain control. In some rare cases,
<code style="white-space: pre;">&#8288;$wait()&#8288;</code> might take a bit longer than specified to time out. This
happens on Unix, when another package overwrites the processx
<code>SIGCHLD</code> signal handler, after the processx process has started.
One such package is parallel, if used with fork clusters, e.g.
through <code>parallel::mcparallel()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$wait(timeout = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>timeout</code></dt><dd><p>Timeout in milliseconds, for the wait or the I/O
polling.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>It returns the process itself, invisibly.
</p>


<hr>
<a id="method-process-get_exit_status"></a>



<h4>Method <code>get_exit_status()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_exit_status&#8288;</code> returns the exit code of the process if it has
finished and <code>NULL</code> otherwise. On Unix, in some rare cases, the exit
status might be <code>NA</code>. This happens if another package (or R itself)
overwrites the processx <code>SIGCHLD</code> handler, after the processx process
has started. In these cases processx cannot determine the real exit
status of the process. One such package is parallel, if used with
fork clusters, e.g. through the <code>parallel::mcparallel()</code> function.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_exit_status()</pre></div>


<hr>
<a id="method-process-format"></a>



<h4>Method <code>format()</code></h4>

<p><code>format(p)</code> or <code>p$format()</code> creates a string representation of the
process, usually for printing.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$format()</pre></div>


<hr>
<a id="method-process-print"></a>



<h4>Method <code>print()</code></h4>

<p><code>print(p)</code> or <code>p$print()</code> shows some information about the
process on the screen, whether it is running and it's process id, etc.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$print()</pre></div>


<hr>
<a id="method-process-get_start_time"></a>



<h4>Method <code>get_start_time()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_start_time()&#8288;</code> returns the time when the process was
started.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_start_time()</pre></div>


<hr>
<a id="method-process-is_supervised"></a>



<h4>Method <code>is_supervised()</code></h4>

<p><code style="white-space: pre;">&#8288;$is_supervised()&#8288;</code> returns whether the process is being tracked by
supervisor process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$is_supervised()</pre></div>


<hr>
<a id="method-process-supervise"></a>



<h4>Method <code>supervise()</code></h4>

<p><code style="white-space: pre;">&#8288;$supervise()&#8288;</code> if passed <code>TRUE</code>, tells the supervisor to start
tracking the process. If <code>FALSE</code>, tells the supervisor to stop
tracking the process. Note that even if the supervisor is disabled
for a process, if it was started with <code>cleanup = TRUE</code>, the process
will still be killed when the object is garbage collected.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$supervise(status)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>status</code></dt><dd><p>Whether to turn on of off the supervisor for this
process.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-read_output"></a>



<h4>Method <code>read_output()</code></h4>

<p><code style="white-space: pre;">&#8288;$read_output()&#8288;</code> reads from the standard output connection of the
process. If the standard output connection was not requested, then
then it returns an error. It uses a non-blocking text connection. This
will work only if <code>stdout="|"</code> was used. Otherwise, it will throw an
error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_output(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of characters or lines to read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-read_error"></a>



<h4>Method <code>read_error()</code></h4>

<p><code style="white-space: pre;">&#8288;$read_error()&#8288;</code> is similar to <code style="white-space: pre;">&#8288;$read_output&#8288;</code>, but it reads
from the standard error stream.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_error(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of characters or lines to read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-read_output_lines"></a>



<h4>Method <code>read_output_lines()</code></h4>

<p><code style="white-space: pre;">&#8288;$read_output_lines()&#8288;</code> reads lines from standard output connection
of the process. If the standard output connection was not requested,
then it returns an error. It uses a non-blocking text connection.
This will work only if <code>stdout="|"</code> was used. Otherwise, it will
throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_output_lines(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of characters or lines to read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-read_error_lines"></a>



<h4>Method <code>read_error_lines()</code></h4>

<p><code style="white-space: pre;">&#8288;$read_error_lines()&#8288;</code> is similar to <code style="white-space: pre;">&#8288;$read_output_lines&#8288;</code>, but
it reads from the standard error stream.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_error_lines(n = -1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>Number of characters or lines to read.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-is_incomplete_output"></a>



<h4>Method <code>is_incomplete_output()</code></h4>

<p><code style="white-space: pre;">&#8288;$is_incomplete_output()&#8288;</code> return <code>FALSE</code> if the other end of
the standard output connection was closed (most probably because the
process exited). It return <code>TRUE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$is_incomplete_output()</pre></div>


<hr>
<a id="method-process-is_incomplete_error"></a>



<h4>Method <code>is_incomplete_error()</code></h4>

<p><code style="white-space: pre;">&#8288;$is_incomplete_error()&#8288;</code> return <code>FALSE</code> if the other end of
the standard error connection was closed (most probably because the
process exited). It return <code>TRUE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$is_incomplete_error()</pre></div>


<hr>
<a id="method-process-has_input_connection"></a>



<h4>Method <code>has_input_connection()</code></h4>

<p><code style="white-space: pre;">&#8288;$has_input_connection()&#8288;</code> return <code>TRUE</code> if there is a connection
object for standard input; in other words, if <code>stdout="|"</code>. It returns
<code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$has_input_connection()</pre></div>


<hr>
<a id="method-process-has_output_connection"></a>



<h4>Method <code>has_output_connection()</code></h4>

<p><code style="white-space: pre;">&#8288;$has_output_connection()&#8288;</code> returns <code>TRUE</code> if there is a connection
object for standard output; in other words, if <code>stdout="|"</code>. It returns
<code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$has_output_connection()</pre></div>


<hr>
<a id="method-process-has_error_connection"></a>



<h4>Method <code>has_error_connection()</code></h4>

<p><code style="white-space: pre;">&#8288;$has_error_connection()&#8288;</code> returns <code>TRUE</code> if there is a connection
object for standard error; in other words, if <code>stderr="|"</code>. It returns
<code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$has_error_connection()</pre></div>


<hr>
<a id="method-process-has_poll_connection"></a>



<h4>Method <code>has_poll_connection()</code></h4>

<p><code style="white-space: pre;">&#8288;$has_poll_connection()&#8288;</code> return <code>TRUE</code> if there is a poll connection,
<code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$has_poll_connection()</pre></div>


<hr>
<a id="method-process-get_input_connection"></a>



<h4>Method <code>get_input_connection()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_input_connection()&#8288;</code> returns a connection object, to the
standard input stream of the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_input_connection()</pre></div>


<hr>
<a id="method-process-get_output_connection"></a>



<h4>Method <code>get_output_connection()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_output_connection()&#8288;</code> returns a connection object, to the
standard output stream of the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_output_connection()</pre></div>


<hr>
<a id="method-process-get_error_connection"></a>



<h4>Method <code>get_error_connection()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_error_conneciton()&#8288;</code> returns a connection object, to the
standard error stream of the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_error_connection()</pre></div>


<hr>
<a id="method-process-read_all_output"></a>



<h4>Method <code>read_all_output()</code></h4>

<p><code style="white-space: pre;">&#8288;$read_all_output()&#8288;</code> waits for all standard output from the process.
It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentially several <code>readLines()</code> calls.
It returns a character scalar. This will return content only if
<code>stdout="|"</code> was used. Otherwise, it will throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_all_output()</pre></div>


<hr>
<a id="method-process-read_all_error"></a>



<h4>Method <code>read_all_error()</code></h4>

<p><code style="white-space: pre;">&#8288;$read_all_error()&#8288;</code> waits for all standard error from the process.
It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentially several <code>readLines()</code> calls.
It returns a character scalar. This will return content only if
<code>stderr="|"</code> was used. Otherwise, it will throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_all_error()</pre></div>


<hr>
<a id="method-process-read_all_output_lines"></a>



<h4>Method <code>read_all_output_lines()</code></h4>

<p><code style="white-space: pre;">&#8288;$read_all_output_lines()&#8288;</code> waits for all standard output lines
from a process. It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentially several <code>readLines()</code> calls.
It returns a character vector. This will return content only if
<code>stdout="|"</code> was used. Otherwise, it will throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_all_output_lines()</pre></div>


<hr>
<a id="method-process-read_all_error_lines"></a>



<h4>Method <code>read_all_error_lines()</code></h4>

<p><code style="white-space: pre;">&#8288;$read_all_error_lines()&#8288;</code> waits for all standard error lines from
a process. It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentially several <code>readLines()</code> calls.
It returns a character vector. This will return content only if
<code>stderr="|"</code> was used. Otherwise, it will throw an error.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$read_all_error_lines()</pre></div>


<hr>
<a id="method-process-write_input"></a>



<h4>Method <code>write_input()</code></h4>

<p><code style="white-space: pre;">&#8288;$write_input()&#8288;</code> writes the character vector (separated by <code>sep</code>) to
the standard input of the process. It will be converted to the specified
encoding. This operation is non-blocking, and it will return, even if
the write fails (because the write buffer is full), or if it suceeds
partially (i.e. not the full string is written). It returns with a raw
vector, that contains the bytes that were not written. You can supply
this raw vector to <code style="white-space: pre;">&#8288;$write_input()&#8288;</code> again, until it is fully written,
and then the return value will be <code>raw(0)</code> (invisibly).
</p>


<h5>Usage</h5>

<div class="r"><pre>process$write_input(str, sep = "\n")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>str</code></dt><dd><p>Character or raw vector to write to the standard input
of the process. If a character vector with a marked encoding,
it will be converted to <code>encoding</code>.</p>
</dd>
<dt><code>sep</code></dt><dd><p>Separator to add between <code>str</code> elements if it is a
character vector. It is ignored if <code>str</code> is a raw vector.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Leftover text (as a raw vector), that was not written.
</p>


<hr>
<a id="method-process-get_input_file"></a>



<h4>Method <code>get_input_file()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_input_file()&#8288;</code> if the <code>stdin</code> argument was a filename,
this returns the absolute path to the file. If <code>stdin</code> was <code>"|"</code> or
<code>NULL</code>, this simply returns that value.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_input_file()</pre></div>


<hr>
<a id="method-process-get_output_file"></a>



<h4>Method <code>get_output_file()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_output_file()&#8288;</code> if the <code>stdout</code> argument was a filename,
this returns the absolute path to the file. If <code>stdout</code> was <code>"|"</code> or
<code>NULL</code>, this simply returns that value.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_output_file()</pre></div>


<hr>
<a id="method-process-get_error_file"></a>



<h4>Method <code>get_error_file()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_error_file()&#8288;</code> if the <code>stderr</code> argument was a filename,
this returns the absolute path to the file. If <code>stderr</code> was <code>"|"</code> or
<code>NULL</code>, this simply returns that value.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_error_file()</pre></div>


<hr>
<a id="method-process-poll_io"></a>



<h4>Method <code>poll_io()</code></h4>

<p><code style="white-space: pre;">&#8288;$poll_io()&#8288;</code> polls the process's connections for I/O. See more in
the <em>Polling</em> section, and see also the <code><a href="callr.html#topic+poll">poll()</a></code> function
to poll on multiple processes.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$poll_io(timeout)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>timeout</code></dt><dd><p>Timeout in milliseconds, for the wait or the I/O
polling.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-process-get_poll_connection"></a>



<h4>Method <code>get_poll_connection()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_poll_connetion()&#8288;</code> returns the poll connection, if the process has
one.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_poll_connection()</pre></div>


<hr>
<a id="method-process-get_result"></a>



<h4>Method <code>get_result()</code></h4>

<p><code style="white-space: pre;">&#8288;$get_result()&#8288;</code> returns the result of the post processesing function.
It can only be called once the process has finished. If the process has
no post-processing function, then <code>NULL</code> is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_result()</pre></div>


<hr>
<a id="method-process-as_ps_handle"></a>



<h4>Method <code>as_ps_handle()</code></h4>

<p><code style="white-space: pre;">&#8288;$as_ps_handle()&#8288;</code> returns a <a href="ps.html#topic+ps_handle">ps::ps_handle</a> object, corresponding to
the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$as_ps_handle()</pre></div>


<hr>
<a id="method-process-get_name"></a>



<h4>Method <code>get_name()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_name">ps::ps_name()</a></code> to get the process name.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_name()</pre></div>


<hr>
<a id="method-process-get_exe"></a>



<h4>Method <code>get_exe()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_exe">ps::ps_exe()</a></code> to get the path of the executable.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_exe()</pre></div>


<hr>
<a id="method-process-get_cmdline"></a>



<h4>Method <code>get_cmdline()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_cmdline">ps::ps_cmdline()</a></code> to get the command line.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_cmdline()</pre></div>


<hr>
<a id="method-process-get_status"></a>



<h4>Method <code>get_status()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_status">ps::ps_status()</a></code> to get the process status.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_status()</pre></div>


<hr>
<a id="method-process-get_username"></a>



<h4>Method <code>get_username()</code></h4>

<p>calls <code><a href="ps.html#topic+ps_username">ps::ps_username()</a></code> to get the username.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_username()</pre></div>


<hr>
<a id="method-process-get_wd"></a>



<h4>Method <code>get_wd()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_cwd">ps::ps_cwd()</a></code> to get the current working directory.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_wd()</pre></div>


<hr>
<a id="method-process-get_cpu_times"></a>



<h4>Method <code>get_cpu_times()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_cpu_times">ps::ps_cpu_times()</a></code> to get CPU usage data.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_cpu_times()</pre></div>


<hr>
<a id="method-process-get_memory_info"></a>



<h4>Method <code>get_memory_info()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_memory_info">ps::ps_memory_info()</a></code> to get memory data.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$get_memory_info()</pre></div>


<hr>
<a id="method-process-suspend"></a>



<h4>Method <code>suspend()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_suspend">ps::ps_suspend()</a></code> to suspend the process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$suspend()</pre></div>


<hr>
<a id="method-process-resume"></a>



<h4>Method <code>resume()</code></h4>

<p>Calls <code><a href="ps.html#topic+ps_resume">ps::ps_resume()</a></code> to resume a suspended process.
</p>


<h5>Usage</h5>

<div class="r"><pre>process$resume()</pre></div>




<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- process$new("sleep", "2")
p$is_alive()
p
p$kill()
p$is_alive()

p &lt;- process$new("sleep", "1")
p$is_alive()
Sys.sleep(2)
p$is_alive()

</code></pre>

<hr>
<h2 id='process_initialize'>Start a process</h2><span id='topic+process_initialize'></span>

<h3>Description</h3>

<p>Start a process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_initialize(
  self,
  private,
  command,
  args,
  stdin,
  stdout,
  stderr,
  pty,
  pty_options,
  connections,
  poll_connection,
  env,
  cleanup,
  cleanup_tree,
  wd,
  echo_cmd,
  supervise,
  windows_verbatim_args,
  windows_hide_window,
  windows_detached_process,
  encoding,
  post_process
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_initialize_+3A_self">self</code></td>
<td>
<p>this</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_private">private</code></td>
<td>
<p>this$private</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_command">command</code></td>
<td>
<p>Command to run, string scalar.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_args">args</code></td>
<td>
<p>Command arguments, character vector.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_stdin">stdin</code></td>
<td>
<p>Standard input, NULL to ignore.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_stdout">stdout</code></td>
<td>
<p>Standard output, NULL to ignore, TRUE for temp file.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_stderr">stderr</code></td>
<td>
<p>Standard error, NULL to ignore, TRUE for temp file.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_pty">pty</code></td>
<td>
<p>Whether we create a PTY.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_connections">connections</code></td>
<td>
<p>Connections to inherit in the child process.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_poll_connection">poll_connection</code></td>
<td>
<p>Whether to create a connection for polling.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_env">env</code></td>
<td>
<p>Environment vaiables.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_cleanup">cleanup</code></td>
<td>
<p>Kill on GC?</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_cleanup_tree">cleanup_tree</code></td>
<td>
<p>Kill process tree on GC?</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_wd">wd</code></td>
<td>
<p>working directory (or NULL)</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_echo_cmd">echo_cmd</code></td>
<td>
<p>Echo command before starting it?</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_supervise">supervise</code></td>
<td>
<p>Should the process be supervised?</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_encoding">encoding</code></td>
<td>
<p>Assumed stdout and stderr encoding.</p>
</td></tr>
<tr><td><code id="process_initialize_+3A_post_process">post_process</code></td>
<td>
<p>Post processing function.</p>
</td></tr>
</table>

<hr>
<h2 id='processx-package'>processx: Execute and Control System Processes</h2><span id='topic+processx'></span><span id='topic+processx-package'></span>

<h3>Description</h3>

<p>Tools to run system processes in the background. It can check if a background process is running; wait on a background process to finish; get the exit status of finished processes; kill background processes. It can read the standard output and error of the processes, using non-blocking connections. 'processx' can poll a process for standard output or error, with a timeout. It can also poll several processes at once.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: G치bor Cs치rdi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> (<a href="https://orcid.org/0000-0001-7098-9676">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Winston Chang
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li>
<li><p> Mango Solutions [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://processx.r-lib.org">https://processx.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/processx">https://github.com/r-lib/processx</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/processx/issues">https://github.com/r-lib/processx/issues</a>
</p>
</li></ul>


<hr>
<h2 id='run'>Run external command, and wait until finishes</h2><span id='topic+run'></span>

<h3>Description</h3>

<p><code>run</code> provides an interface similar to <code><a href="base.html#topic+system">base::system()</a></code> and
<code><a href="base.html#topic+system2">base::system2()</a></code>, but based on the <a href="callr.html#topic+process">process</a> class. This allows some
extra features, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(
  command = NULL,
  args = character(),
  error_on_status = TRUE,
  wd = NULL,
  echo_cmd = FALSE,
  echo = FALSE,
  spinner = FALSE,
  timeout = Inf,
  stdout = "|",
  stderr = "|",
  stdout_line_callback = NULL,
  stdout_callback = NULL,
  stderr_line_callback = NULL,
  stderr_callback = NULL,
  stderr_to_stdout = FALSE,
  env = NULL,
  windows_verbatim_args = FALSE,
  windows_hide_window = FALSE,
  encoding = "",
  cleanup_tree = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_command">command</code></td>
<td>
<p>Character scalar, the command to run. If you are
running <code>.bat</code> or <code>.cmd</code> files on Windows, make sure you read the
'Batch files' section in the <a href="callr.html#topic+process">process</a> manual page.</p>
</td></tr>
<tr><td><code id="run_+3A_args">args</code></td>
<td>
<p>Character vector, arguments to the command.</p>
</td></tr>
<tr><td><code id="run_+3A_error_on_status">error_on_status</code></td>
<td>
<p>Whether to throw an error if the command returns
with a non-zero status, or it is interrupted. The error classes are
<code>system_command_status_error</code> and <code>system_command_timeout_error</code>,
respectively, and both errors have class <code>system_command_error</code> as
well. See also &quot;Error conditions&quot; below.</p>
</td></tr>
<tr><td><code id="run_+3A_wd">wd</code></td>
<td>
<p>Working directory of the process. If <code>NULL</code>, the current
working directory is used.</p>
</td></tr>
<tr><td><code id="run_+3A_echo_cmd">echo_cmd</code></td>
<td>
<p>Whether to print the command to run to the screen.</p>
</td></tr>
<tr><td><code id="run_+3A_echo">echo</code></td>
<td>
<p>Whether to print the standard output and error
to the screen. Note that the order of the standard output and error
lines are not necessarily correct, as standard output is typically
buffered. If the standard output and/or error is redirected to a
file or they are ignored, then they also not echoed.</p>
</td></tr>
<tr><td><code id="run_+3A_spinner">spinner</code></td>
<td>
<p>Whether to show a reassuring spinner while the process
is running.</p>
</td></tr>
<tr><td><code id="run_+3A_timeout">timeout</code></td>
<td>
<p>Timeout for the process, in seconds, or as a <code>difftime</code>
object. If it is not finished before this, it will be killed.</p>
</td></tr>
<tr><td><code id="run_+3A_stdout">stdout</code></td>
<td>
<p>What to do with the standard output. By default it
is collected in the result, and you can also use the
<code>stdout_line_callback</code> and <code>stdout_callback</code> arguments to pass
callbacks for output. If it is the empty string (<code>""</code>), then
the child process inherits the standard output stream of the
R process. (If the main R process does not have a standard output
stream, e.g. in RGui on Windows, then an error is thrown.)
If it is <code>NULL</code>, then standard output is discarded. If it is a string
other than <code>"|"</code> and <code>""</code>, then it is taken as a file name and the
output is redirected to this file.</p>
</td></tr>
<tr><td><code id="run_+3A_stderr">stderr</code></td>
<td>
<p>What to do with the standard error. By default it
is collected in the result, and you can also use the
<code>stderr_line_callback</code> and <code>stderr_callback</code> arguments to pass
callbacks for output. If it is the empty string (<code>""</code>), then
the child process inherits the standard error stream of the
R process. (If the main R process does not have a standard error
stream, e.g. in RGui on Windows, then an error is thrown.)
If it is <code>NULL</code>, then standard error is discarded. If it is a string
other than <code>"|"</code> and <code>""</code>, then it is taken as a file name and the
standard error is redirected to this file.</p>
</td></tr>
<tr><td><code id="run_+3A_stdout_line_callback">stdout_line_callback</code></td>
<td>
<p><code>NULL</code>, or a function to call for every
line of the standard output. See <code>stdout_callback</code> and also more
below.</p>
</td></tr>
<tr><td><code id="run_+3A_stdout_callback">stdout_callback</code></td>
<td>
<p><code>NULL</code>, or a function to call for every chunk
of the standard output. A chunk can be as small as a single character.
At most one of <code>stdout_line_callback</code> and <code>stdout_callback</code> can be
non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="run_+3A_stderr_line_callback">stderr_line_callback</code></td>
<td>
<p><code>NULL</code>, or a function to call for every
line of the standard error. See <code>stderr_callback</code> and also more
below.</p>
</td></tr>
<tr><td><code id="run_+3A_stderr_callback">stderr_callback</code></td>
<td>
<p><code>NULL</code>, or a function to call for every chunk
of the standard error. A chunk can be as small as a single character.
At most one of <code>stderr_line_callback</code> and <code>stderr_callback</code> can be
non-<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="run_+3A_stderr_to_stdout">stderr_to_stdout</code></td>
<td>
<p>Whether to redirect the standard error to the
standard output. Specifying <code>TRUE</code> here will keep both in the
standard output, correctly interleaved. However, it is not possible
to deduce where pieces of the output were coming from. If this is
<code>TRUE</code>, the standard error callbacks  (if any) are never called.</p>
</td></tr>
<tr><td><code id="run_+3A_env">env</code></td>
<td>
<p>Environment variables of the child process. If <code>NULL</code>,
the parent's environment is inherited. On Windows, many programs
cannot function correctly if some environment variables are not
set, so we always set <code>HOMEDRIVE</code>, <code>HOMEPATH</code>, <code>LOGONSERVER</code>,
<code>PATH</code>, <code>SYSTEMDRIVE</code>, <code>SYSTEMROOT</code>, <code>TEMP</code>, <code>USERDOMAIN</code>,
<code>USERNAME</code>, <code>USERPROFILE</code> and <code>WINDIR</code>. To append new environment
variables to the ones set in the current process, specify
<code>"current"</code> in <code>env</code>, without a name, and the appended ones with
names. The appended ones can overwrite the current ones.</p>
</td></tr>
<tr><td><code id="run_+3A_windows_verbatim_args">windows_verbatim_args</code></td>
<td>
<p>Whether to omit the escaping of the
command and the arguments on windows. Ignored on other platforms.</p>
</td></tr>
<tr><td><code id="run_+3A_windows_hide_window">windows_hide_window</code></td>
<td>
<p>Whether to hide the window of the
application on windows. Ignored on other platforms.</p>
</td></tr>
<tr><td><code id="run_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to assume for <code>stdout</code> and
<code>stderr</code>. By default the encoding of the current locale is
used. Note that <code>processx</code> always reencodes the output of
both streams in UTF-8 currently.</p>
</td></tr>
<tr><td><code id="run_+3A_cleanup_tree">cleanup_tree</code></td>
<td>
<p>Whether to clean up the child process tree after
the process has finished.</p>
</td></tr>
<tr><td><code id="run_+3A_...">...</code></td>
<td>
<p>Extra arguments are passed to <code>process$new()</code>, see
<a href="callr.html#topic+process">process</a>. Note that you cannot pass <code>stout</code> or <code>stderr</code> here,
because they are used internally by <code>run()</code>. You can use the
<code>stdout_callback</code>, <code>stderr_callback</code>, etc. arguments to manage
the standard output and error, or the <a href="callr.html#topic+process">process</a> class directly
if you need more flexibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>run</code> supports
</p>

<ul>
<li><p> Specifying a timeout for the command. If the specified time has
passed, and the process is still running, it will be killed
(with all its child processes).
</p>
</li>
<li><p> Calling a callback function for each line or each chunk of the
standard output and/or error. A chunk may contain multiple lines, and
can be as short as a single character.
</p>
</li>
<li><p> Cleaning up the subprocess, or the whole process tree, before exiting.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li><p> status The exit status of the process. If this is <code>NA</code>, then the
process was killed and had no exit status.
</p>
</li>
<li><p> stdout The standard output of the command, in a character scalar.
</p>
</li>
<li><p> stderr The standard error of the command, in a character scalar.
</p>
</li>
<li><p> timeout Whether the process was killed because of a timeout.
</p>
</li></ul>



<h3>Callbacks</h3>

<p>Some notes about the callback functions. The first argument of a
callback function is a character scalar (length 1 character), a single
output or error line. The second argument is always the <a href="callr.html#topic+process">process</a>
object. You can manipulate this object, for example you can call
<code style="white-space: pre;">&#8288;$kill()&#8288;</code> on it to terminate it, as a response to a message on the
standard output or error.
</p>


<h3>Error conditions</h3>

<p><code>run()</code> throws error condition objects if the process is interrupted,
timeouts or fails (if <code>error_on_status</code> is <code>TRUE</code>):
</p>

<ul>
<li><p> On interrupt, a condition with classes <code>system_command_interrupt</code>,
<code>interrupt</code>, <code>condition</code> is signalled. This can be caught with
<code>tryCatch(..., interrupt = ...)</code>.
</p>
</li>
<li><p> On timeout, a condition with classes <code>system_command_timeout_error</code>,
<code>system_command_error</code>, <code>error</code>, <code>condition</code> is thrown.
</p>
</li>
<li><p> On error (if <code>error_on_status</code> is <code>TRUE</code>), an error with classes
<code>system_command_status_error</code>, <code>system_command_error</code>, <code>error</code>,
<code>condition</code> is thrown.
</p>
</li></ul>

<p>All of these conditions have the fields:
</p>

<ul>
<li> <p><code>message</code>: the error message,
</p>
</li>
<li> <p><code>stderr</code>: the standard error of the process, or the standard output
of the process if <code>stderr_to_stdout</code> was <code>TRUE</code>.
</p>
</li>
<li> <p><code>call</code>: the captured call to <code>run()</code>.
</p>
</li>
<li> <p><code>echo</code>: the value of the <code>echo</code> argument.
</p>
</li>
<li> <p><code>stderr_to_stdout</code>: the value of the <code>stderr_to_stdout</code> argument.
</p>
</li>
<li> <p><code>status</code>: the exit status for <code>system_command_status_error</code> errors.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# This works on Unix systems
run("ls")
system.time(run("sleep", "10", timeout = 1, error_on_status = FALSE))
system.time(
  run(
    "sh", c("-c", "for i in 1 2 3 4 5; do echo $i; sleep 1; done"),
    timeout = 2, error_on_status = FALSE
  )
)


# This works on Windows systems, if the ping command is available
run("ping", c("-n", "1", "127.0.0.1"))
run("ping", c("-n", "6", "127.0.0.1"), timeout = 1,
    error_on_status = FALSE)

</code></pre>

<hr>
<h2 id='supervisor_kill'>Terminate all supervised processes and the supervisor process itself as
well</h2><span id='topic+supervisor_kill'></span>

<h3>Description</h3>

<p>On Unix the supervisor sends a <code>SIGTERM</code> signal to all supervised
processes, and gives them five seconds to quit, before sending a
<code>SIGKILL</code> signal. Then the supervisor itself terminates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supervisor_kill()
</code></pre>


<h3>Details</h3>

<p>Windows is similar, but instead of <code>SIGTERM</code>, a console CTRL+C interrupt
is sent first, then a <code>WM_CLOSE</code> message is sent to the windows of the
supervised processes, if they have windows.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
