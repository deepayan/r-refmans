<!DOCTYPE html><html><head><title>Help for package PlackettLuce</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PlackettLuce}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PlackettLuce-package'><p>Plackett-Luce Models for Rankings</p></a></li>
<li><a href='#adjacency'><p>Create an Adjacency Matrix for a set of Rankings</p></a></li>
<li><a href='#aggregate'><p>Aggregate Rankings</p></a></li>
<li><a href='#beans'><p>Preferred Bean Varieties in Nicaragua</p></a></li>
<li><a href='#choices'><p>Choices Object</p></a></li>
<li><a href='#complete'><p>Complete Orderings with the Missing Redundant Rank</p></a></li>
<li><a href='#connectivity'><p>Check Connectivity of Rankings</p></a></li>
<li><a href='#decode'><p>Decode Orderings using a Key to Item Names</p></a></li>
<li><a href='#fitted.PlackettLuce'><p>Fitted Probabilities for PlackettLuce Objects</p></a></li>
<li><a href='#group'><p>Group Rankings</p></a></li>
<li><a href='#itempar.PlackettLuce'><p>Extract Item Parameters of Plackett-Luce Models</p></a></li>
<li><a href='#nascar'><p>Results from 2002 NASCAR Season</p></a></li>
<li><a href='#PlackettLuce'><p>Fit a Plackett-Luce Model</p></a></li>
<li><a href='#PlackettLuce-deprecated'><p>Deprecated functions in package <span class="pkg">PlackettLuce</span></p></a></li>
<li><a href='#pladmm'><p>Fit a Plackett-Luce Model with Linear Predictor for Log-worth</p></a></li>
<li><a href='#plfit'><p>PlackettLuce Wrapper for Model-based Recursive Partitioning</p></a></li>
<li><a href='#pltree'><p>Plackett-Luce Trees</p></a></li>
<li><a href='#pltree-summaries'><p>Plackett-Luce Tree Summaries</p></a></li>
<li><a href='#preflib'><p>Read Preflib Election Data Files</p></a></li>
<li><a href='#pudding'><p>Paired Comparisons of Chocolate Pudding</p></a></li>
<li><a href='#qvcalc.PlackettLuce'><p>Quasi Variances for Model Coefficients</p></a></li>
<li><a href='#rankings'><p>Rankings Object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#simulate.PlackettLuce'><p>Simulate from <code>PlackettLuce</code> fitted objects</p></a></li>
<li><a href='#summaries'><p>Plackett-Luce Model Summaries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Plackett-Luce Models for Rankings</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hturner.github.io/PlackettLuce/">https://hturner.github.io/PlackettLuce/</a>,
<a href="https://github.com/hturner/PlackettLuce">https://github.com/hturner/PlackettLuce</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hturner/PlackettLuce/issues">https://github.com/hturner/PlackettLuce/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to prepare rankings data and fit the Plackett-Luce model
    jointly attributed to Plackett (1975) &lt;<a href="https://doi.org/10.2307%2F2346567">doi:10.2307/2346567</a>&gt; and Luce
    (1959, ISBN:0486441369). The standard Plackett-Luce model is generalized
    to accommodate ties of any order in the ranking. Partial rankings, in which
    only a subset of items are ranked in each ranking, are also accommodated in
    the implementation. Disconnected/weakly connected networks implied by the
    rankings may be handled by adding pseudo-rankings with a hypothetical item.
    Optionally, a multivariate normal prior may be set on the log-worth
    parameters and ranker reliabilities may be incorporated as proposed by
    Raman and Joachims (2014) &lt;<a href="https://doi.org/10.1145%2F2623330.2623654">doi:10.1145/2623330.2623654</a>&gt;. Maximum a
    posteriori estimation is used when priors are set. Methods are provided to
    estimate standard errors or quasi-standard errors for inference as well as
    to fit Plackett-Luce trees. See the package website or vignette for further
    details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>CVXR, Matrix, igraph, matrixStats, methods, partykit,
psychotools, psychotree, R6, RSpectra, qvcalc, sandwich, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocStyle, BayesMallows, BradleyTerry2, PLMIX, ROlogit,
StatRank, bookdown, covr, hyper2, kableExtra, knitr, lbfgs,
gnm, pmr, prefmod, rmarkdown, survival, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-16 13:47:09 UTC; heather</td>
</tr>
<tr>
<td>Author:</td>
<td>Heather Turner <a href="https://orcid.org/0000-0002-1256-3375"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ioannis Kosmidis <a href="https://orcid.org/0000-0003-1556-0302"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  David Firth <a href="https://orcid.org/0000-0003-0302-2312"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jacob van Etten <a href="https://orcid.org/0000-0001-7554-2558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Heather Turner &lt;ht@heatherturner.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-16 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='PlackettLuce-package'>Plackett-Luce Models for Rankings</h2><span id='topic+PlackettLuce-package'></span>

<h3>Description</h3>

<p>Plackett-Luce provides functions to prepare rankings data in order to fit
the Plackett-Luce model or Plackett-Luce trees. The implementation can handle
ties, sub-rankings and rankings that imply disconnected or weakly connected
preference networks. Methods are provided for summary and inference.
</p>


<h3>Details</h3>

<p>The main function in the package is the model-fitting function
<code><a href="#topic+PlackettLuce">PlackettLuce</a></code> and the help file for that function provides
details of the Plackett-Luce model, which is extended here to accommodate
ties.
</p>
<p>Rankings data must be passed to <code>PlackettLuce</code> in a specific form, see
<code><a href="#topic+rankings">rankings</a></code> for more details. Other functions for handling
rankings include <code>choices</code> to express the rankings as
choices from alternatives; <code>adjacency</code> to create an adjacency matrix of
wins and losses implied by the rankings and <code>connectivity</code> to check the
connectivity of the underlying preference network.
</p>
<p>Several methods are available to inspect fitted Plackett-Luce models, help
files are available for less common methods or where arguments may be
specified: <code><a href="stats.html#topic+coef">coef</a></code>, <code>deviance</code>, <code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="#topic+itempar">itempar</a></code>, <code>logLik</code>, <code>print</code>,
<code><a href="#topic+qvcalc">qvcalc</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p>PlackettLuce also provides the function <code>pltree</code> to fit a Plackett-Luce
tree i.e. a tree that partitions the rankings by covariate values,
identifying subgroups with different sets of worth parameters for the items.
In this case <code><a href="#topic+group">group</a></code> must be used to prepare the data.
</p>
<p>Several data sets are provided in the package: <code><a href="#topic+beans">beans</a></code>,
<code><a href="#topic+nascar">nascar</a></code>, <code><a href="#topic+pudding">pudding</a></code>. The help files for these give
further illustration of preparing rankings data for modelling. The
<code><a href="#topic+read.soc">read.soc</a></code> function enables further example data sets of
&quot;Strict Orders - Complete List&quot; format (i.e. complete rankings with no ties)
to be downloaded from <a href="https://www.preflib.org/">PrefLib</a>.
</p>
<p>A full explanation of the methods with illustrations using the package data
sets is given in the vignette,
<code>vignette("Overview", package = "PlackettLuce")</code>.
</p>

<hr>
<h2 id='adjacency'>Create an Adjacency Matrix for a set of Rankings</h2><span id='topic+adjacency'></span>

<h3>Description</h3>

<p>Convert a set of rankings to an adjacency matrix summarising wins
and losses between pairs of items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency(object, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacency_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+rankings">rankings</a></code> object, or an object that can be
coerced by <code>as.rankings</code>.</p>
</td></tr>
<tr><td><code id="adjacency_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights for the rankings.</p>
</td></tr>
<tr><td><code id="adjacency_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <code>"rankings"</code> object based on N items, the adjacency matrix is an
N by N matrix, with element (i, j) being the number of times item i wins over
item j. For example, in the ranking \1\ &gt; \3, 4\ &gt; \2\,
item 1 wins over items 2, 3, and 4, and items 3 and 4 win over item 2.
</p>
<p>If <code>weights</code> is specified, the values in the adjacency matrix are the
weighted counts.
</p>


<h3>Value</h3>

<p>An N by N matrix, where N is the number of items that can be ranked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(2, 1, 2, 1, 2,
              3, 2, 0, 0, 1,
              1, 0, 2, 2, 3), nrow = 3, byrow = TRUE)
X &lt;- as.rankings(X)
adjacency(X)

adjacency(X, weights = c(1, 1, 2))

</code></pre>

<hr>
<h2 id='aggregate'>Aggregate Rankings</h2><span id='topic+aggregate'></span><span id='topic+aggregate.rankings'></span><span id='topic+as.aggregated_rankings'></span><span id='topic++5B.aggregated_rankings'></span><span id='topic+freq'></span>

<h3>Description</h3>

<p>Aggregate rankings, returning an <code>"aggregated_rankings"</code> object of the
unique rankings and their frequencies. The frequencies can be extracted via
the function <code>freq()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rankings'
aggregate(x, freq = NULL, ...)

as.aggregated_rankings(x, ...)

## S3 method for class 'aggregated_rankings'
x[i, j, ..., drop = FALSE, as.aggregated_rankings = TRUE]

freq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+rankings">&quot;rankings&quot;</a></code> object for <code>aggregate()</code>; an
object that can be coerced to a <code>"aggregated_rankings"</code> object for
<code>as.aggregated_rankings()</code>, otherwise an <code>"aggregated_rankings"</code> object.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_freq">freq</code></td>
<td>
<p>A vector of frequencies for rankings that have been previously
aggregated.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_i">i</code></td>
<td>
<p>indices specifying rankings to extract, as for <code><a href="Matrix.html#topic++5B">[</a></code>.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_j">j</code></td>
<td>
<p>indices specifying items to extract, as for <code><a href="Matrix.html#topic++5B">[</a></code>.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> return single row/column matrices as a vector.</p>
</td></tr>
<tr><td><code id="aggregate_+3A_as.aggregated_rankings">as.aggregated_rankings</code></td>
<td>
<p>if <code>TRUE</code> create an
<code>"aggregated_rankings"</code> object from the indexed rankings. Otherwise index
the underlying matrix of ranks and return in a data frame with the
corresponding frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>"aggregated_rankings"</code>, with columns
</p>
<table>
<tr><td><code>ranking</code></td>
<td>
<p> A <code><a href="#topic+rankings">&quot;rankings&quot;</a></code> object of the unique rankings.</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>The corresponding frequencies.</p>
</td></tr>
</table>
<p>Methods are available for <code><a href="base.html#topic+rbind">rbind()</a></code> and <code><a href="base.html#topic+as.matrix">as.matrix()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+preflib">preflib()</a></code> for an object that can be coerced to an
<code>"aggregated_rankings"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a rankings object with duplicated rankings
R &lt;- matrix(c(1, 2, 0, 0,
              0, 1, 2, 3,
              2, 1, 1, 0,
              1, 2, 0, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")
R &lt;- as.rankings(R)

# aggregate the rankings
A &lt;- aggregate(R)

# subsetting applies to the rankings, e.g. first two unique rankings
A[1:2]

# (partial) rankings of items 2 to 4 only
A[, 2:4]

# convert to a matrix
as.matrix(A)

# frequencies are automatically used as weights by PlackettLuce()
mod &lt;- PlackettLuce(A)
mod$weights
</code></pre>

<hr>
<h2 id='beans'>Preferred Bean Varieties in Nicaragua</h2><span id='topic+beans'></span>

<h3>Description</h3>

<p>This is a subset of data from trials of bean varieties
(<em>Phaseolus vulgaris</em> L.)
in Nicaragua over five growing seasons. Farmers were asked to try three
varieties of bean from a total of ten varieties and to rank them in order of
preference. In addition, for each variety the farmers were asked to compare
each trial variety to the local variety and state whether they considered it
to be better or worse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beans
</code></pre>


<h3>Format</h3>

<p>A data frame with 842 records and 14 variables:
</p>

<dl>
<dt><code>variety_a</code></dt><dd><p>The name of variety A in the comparison.</p>
</dd>
<dt><code>variety_b</code></dt><dd><p>The name of variety B in the comparison.</p>
</dd>
<dt><code>variety_c</code></dt><dd><p>The name of variety C in the comparison.</p>
</dd>
<dt><code>best</code></dt><dd><p>The variety the farmer ranked in first place (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>worst</code></dt><dd><p>The variety the farmer ranked in last place (&quot;A&quot;,
&quot;B&quot; or &quot;C&quot;).</p>
</dd>
<dt><code>var_a</code></dt><dd><p>How the farmer ranked variety A compared to the local
variety (&quot;Worse&quot; or &quot;Better&quot;).</p>
</dd>
<dt><code>var_b</code></dt><dd><p>How the farmer ranked variety B compared to the local
variety (&quot;Worse&quot; or &quot;Better&quot;).</p>
</dd>
<dt><code>var_c</code></dt><dd><p>How the farmer ranked variety C compared to the local
variety (&quot;Worse&quot; or &quot;Better&quot;).</p>
</dd>
<dt><code>season</code></dt><dd><p>A factor specifying the growing season (&quot;Po - 15&quot;,
&quot;Ap - 15&quot;, &quot;Pr - 16&quot;, &quot;Po - 16&quot;, &quot;Ap - 16&quot;.</p>
</dd>
<dt><code>year</code></dt><dd><p>The year of planting.</p>
</dd>
<dt><code>maxTN</code></dt><dd><p>The maximum temperature at night during the
vegetative cycle (degrees Celsius).</p>
</dd>
<dt><code>lon</code></dt><dd><p>The geographic coordinate longitude (X axis) for where
the plot was established.</p>
</dd>
<dt><code>lat</code></dt><dd><p>The geographic coordinate latitude (Y axis) for where
the plot was established.</p>
</dd>
<dt><code>planting_date</code></dt><dd><p>A Date, specifying the start date of
planting the trial.</p>
</dd>
</dl>



<h3>Details</h3>

<p>There are three crop seasons in Central America:
</p>

<dl>
<dt>Primera</dt><dd><p>May - August.</p>
</dd>
<dt>Postrera</dt><dd><p>September - October.</p>
</dd>
<dt>Apante</dt><dd><p>November - January.</p>
</dd>
</dl>

<p>Beans can be planted near the beginning of each season, though are most
commonly planted in the Postrera or Apante seasons.
</p>


<h3>Source</h3>

<p>van Etten, J. et al. (2019) <em>PNAS</em>, <b>116</b> (10), 4194&ndash;4199,
<a href="https://doi.org/10.1073/pnas.1813720116">doi:10.1073/pnas.1813720116</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Consider the best and worst rankings. These give the variety the
# farmer thought was best or worst, coded as A, B or C for the
# first, second or third variety assigned to the farmer
# respectively.
data(beans)
head(beans[c("best", "worst")], 2)

# Fill in the missing item
beans$middle &lt;- complete(beans[c("best", "worst")],
                         items = c("A", "B", "C"))
head(beans[c("best", "middle", "worst")], 2)

# This gives an ordering of the three varieties the farmer was
# given. The names of these varieties are stored in separate
# columns
varieties &lt;- beans[c("variety_a", "variety_b", "variety_c")]
head(varieties, 2)

# Use these names to decode the orderings of order 3
order3 &lt;- decode(beans[c("best", "middle", "worst")],
                 items = beans[c("variety_a", "variety_b", "variety_c")],
                 code = c("A", "B", "C"))

# Now consider the paired comparisons agains the local variety
head(beans[c("var_a", "var_b", "var_c")], 2)

# Convert these results to a vector and get the corresponding trial variety
outcome &lt;- unlist(beans[c("var_a", "var_b", "var_c")])
trial_variety &lt;- unlist(beans[c("variety_a", "variety_b", "variety_c")])

# Create a data frame of the implied orderings of order 2
order2 &lt;- data.frame(Winner = ifelse(outcome == "Worse",
                                     "Local", trial_variety),
                     Loser = ifelse(outcome == "Worse",
                                    trial_variety, "Local"),
                     stringsAsFactors = FALSE, row.names = NULL)
head(order2, 2)

# Finally combine the rankings of order 2 and order 3
R &lt;- rbind(as.rankings(order3, input = "orderings"),
           as.rankings(order2, input = "orderings"))
head(R)
tail(R)
</code></pre>

<hr>
<h2 id='choices'>Choices Object</h2><span id='topic+choices'></span>

<h3>Description</h3>

<p>Convert a set of rankings to a list of choices, alternatives, and
rankings. The choices and the corresponding alternatives make up the
exchangeable part of the Plackett-Luce with ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choices(rankings, names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choices_+3A_rankings">rankings</code></td>
<td>
<p>a <code>"<a href="#topic+rankings">rankings</a>"</code> object, or an object that can be
coerced by <code>as.rankings</code>.</p>
</td></tr>
<tr><td><code id="choices_+3A_names">names</code></td>
<td>
<p>logical: if <code>TRUE</code> use the object names in the returned
<code>"choices"</code> object, else use object indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of class <code>"choices"</code> with elements:
</p>
<table>
<tr><td><code>choices</code></td>
<td>
<p> A list where each element represents the set of items
chosen for a single rank in the ranking.</p>
</td></tr>
<tr><td><code>alternatives</code></td>
<td>
<p> A list where each element represents the set of items
to choose from for a single rank in the ranking.</p>
</td></tr>
<tr><td><code>ranking</code></td>
<td>
<p> A list where each element represents the ranking that the
choice belongs to.</p>
</td></tr>
</table>
<p>The list stores the number of choices and the names of the objects as the
attributes <code>"nchoices"</code> and <code>"objects"</code> respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")

actual_choices &lt;- choices(R, names = TRUE)
actual_choices[1:6,]

coded_choices &lt;- choices(R, names = FALSE)
coded_choices[1:2,]
as.data.frame(coded_choices)[1:2,]
attr(coded_choices, "objects")

</code></pre>

<hr>
<h2 id='complete'>Complete Orderings with the Missing Redundant Rank</h2><span id='topic+complete'></span>

<h3>Description</h3>

<p>Given orderings with one rank missing, complete the ordering by assigning
the remaining item(s) to the final rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete(orderings, items)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_+3A_orderings">orderings</code></td>
<td>
<p>A data frame of orderings with one rank missing.</p>
</td></tr>
<tr><td><code id="complete_+3A_items">items</code></td>
<td>
<p>A vector of item names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the missing items, which will be a list if there are
any ties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Orderings of 3 items, when only the best and worst are recorded
orderings &lt;- data.frame(best = c("A", "B", "A"),
                        worst = c("C", "C", NA))
orderings$middle &lt;- complete(orderings, items = c("A", "B", "C"))
</code></pre>

<hr>
<h2 id='connectivity'>Check Connectivity of Rankings</h2><span id='topic+connectivity'></span>

<h3>Description</h3>

<p>Check the connectivity of the network underlying a set of rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectivity(x, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectivity_+3A_x">x</code></td>
<td>
<p>an adjacency matrix as returned by <code><a href="#topic+adjacency">adjacency</a></code>, a
<code>"<a href="#topic+rankings">rankings</a>"</code> object, or an object that can be coerced
by <code>as.rankings</code>.</p>
</td></tr>
<tr><td><code id="connectivity_+3A_verbose">verbose</code></td>
<td>
<p>logical, if <code>TRUE</code>, a message is given if the network
is not strongly connected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ranked items are connected in a directed graph according to the implied
wins and loses between pairs of items. The wins and losses can be
summarised as an adjacency matrix using <code><a href="#topic+adjacency">adjacency</a></code>. From this
adjacency matrix, the graph is inferred and it is checked for
connectivity. A message is given if the network is not strongly connected,
i.e. with at least one win and one loss between all partitions of the network
into two groups. Features of clusters in the network are returned - if
the network is strongly connected, all items belong to the same cluster.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>membership</code></td>
<td>
<p>a labelled vector of indices specifying membership of
clusters in the network of items</p>
</td></tr>
<tr><td><code>csize</code></td>
<td>
<p>the sizes of clusters in the network of items</p>
</td></tr>
<tr><td><code>no</code></td>
<td>
<p>the number of clusters in the network of items</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## weakly connected network:
## one win between two clusters
X &lt;- matrix(c(1, 2, 0, 0,
              2, 1, 3, 0,
              0, 0, 1, 2,
              0, 0, 2, 1), ncol = 4, byrow = TRUE)
X &lt;- as.rankings(X)
res &lt;- connectivity(X)
res$membership
## keep items in cluster 1
na.omit(X[,res$membership == 1])

## two weakly connected items:
## item 1 always loses; item 4 only wins against item 1
X &lt;- matrix(c(4, 1, 2, 3,
              0, 2, 1, 3), nr = 2, byrow = TRUE)
X &lt;- as.rankings(X)
res &lt;- connectivity(X)
res$membership

## item 1 always wins; item 4 always loses
X &lt;- matrix(c(1, 2, 3, 4,
              1, 3, 2, 4), nr = 2, byrow = TRUE)
res &lt;- connectivity(as.rankings(X))
res$membership

## all in separate clusters: always 1 &gt; 2 &gt; 3 &gt; 4
## also miscoded rankings and redundant ranking
X &lt;- matrix(c(1, 2, 3, 4,
              1, 0, 2, 3,
              1, 1, 2, 0,
              1, 0, 3, 4,
              2, 2, 0, 4,
              0, 0, 3, 0,
              2, 4, 0, 0), ncol = 4, byrow = TRUE)
res &lt;- connectivity(as.rankings(X))
res$membership

</code></pre>

<hr>
<h2 id='decode'>Decode Orderings using a Key to Item Names</h2><span id='topic+decode'></span>

<h3>Description</h3>

<p>Decode orderings by replacing numeric or character coded values with item
names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode(orderings, items, code = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_+3A_orderings">orderings</code></td>
<td>
<p>A data frame of coded orderings.</p>
</td></tr>
<tr><td><code id="decode_+3A_items">items</code></td>
<td>
<p>A data frame of the items in each ranking, or a vector of
common items.</p>
</td></tr>
<tr><td><code id="decode_+3A_code">code</code></td>
<td>
<p>(Optional) a vector giving the key to the code. If missing,
<code>names(items)</code> is used for a character code, while <code>seq(items)</code> is used
for a numeric code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the coded values replaced by the item names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># orderings of up to 3 items coded as A, B, C
orderings &lt;- data.frame(Rank1 = c("A", "B"),
                        Rank2 = c("C", "A"),
                        Rank3 = c("B", NA),
                        stringsAsFactors = FALSE)
items &lt;- data.frame(A = c("banana", "apple"),
                    B = c("orange", "pear"),
                    C = c("apple", NA),
                    stringsAsFactors = FALSE)
decode(orderings, items)

# orderings with ties of up to 3 items, coded 1:3
orderings &lt;- data.frame(Rank1 = c(1, 3),
                        Rank2 = I(list(c(2, 3), 2)),
                        Rank3 = c(NA, 1),
                        stringsAsFactors = FALSE)
items &lt;- data.frame(A = c("banana", "apple"),
                    B = c("orange", "pear"),
                    C = c("apple", "orange"),
                    stringsAsFactors = FALSE)
decode(orderings, items)

# same items in each comparison
items &lt;- c(A = "banana", B = "orange", C = "pear")
decode(orderings, items)
</code></pre>

<hr>
<h2 id='fitted.PlackettLuce'>Fitted Probabilities for PlackettLuce Objects</h2><span id='topic+fitted.PlackettLuce'></span><span id='topic+fitted.pltree'></span>

<h3>Description</h3>

<p>Fitted probabilities for all choice/alternative combinations in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PlackettLuce'
fitted(object, aggregate = TRUE, free = TRUE, ...)

## S3 method for class 'pltree'
fitted(object, aggregate = TRUE, free = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.PlackettLuce_+3A_object">object</code></td>
<td>
<p>an object as returned by
<code><a href="#topic+PlackettLuce">PlackettLuce</a></code> or <code><a href="#topic+pltree">pltree</a></code>.</p>
</td></tr>
<tr><td><code id="fitted.PlackettLuce_+3A_aggregate">aggregate</code></td>
<td>
<p>logical; if <code>TRUE</code> observations of the same choice from
the same set of alternatives are aggregated.</p>
</td></tr>
<tr><td><code id="fitted.PlackettLuce_+3A_free">free</code></td>
<td>
<p>logical; if <code>TRUE</code> only free choices are included, i.e.
choices of one item from a set of one item are excluded.</p>
</td></tr>
<tr><td><code id="fitted.PlackettLuce_+3A_...">...</code></td>
<td>
<p>further arguments, currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>choices</code></td>
<td>
<p>The selected item(s).</p>
</td></tr>
<tr><td><code>alternatives</code></td>
<td>
<p>The set of item(s) that the choice was made from.</p>
</td></tr>
<tr><td><code>ranking</code></td>
<td>
<p>The ranking(s) including this choice.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The weighted count of rankings including this
choice (equal to the ranking weight if <code>aggregate = FALSE</code>.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>The fitted probability of making this choice.</p>
</td></tr>
</table>
<p>If <code>object</code> was a <code>"pltree"</code> object, the list has an
additional element, <code>node</code>, specifying which node the ranking
corresponds to.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+choices">choices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")

mod &lt;- PlackettLuce(R)
fit &lt;- fitted(mod)
fit
</code></pre>

<hr>
<h2 id='group'>Group Rankings</h2><span id='topic+group'></span><span id='topic+as.grouped_rankings'></span><span id='topic+as.grouped_rankings.paircomp'></span><span id='topic++5B.grouped_rankings'></span><span id='topic+format.grouped_rankings'></span>

<h3>Description</h3>

<p>Create an object of class <code>"grouped_rankings"</code> which associates a
group index with an object of class <code>"rankings"</code>. This allows the
rankings to be linked to covariates with group-specific values as the basis
for model-based recursive partitioning, see <code><a href="#topic+pltree">pltree</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group(x, index, ...)

as.grouped_rankings(x, ...)

## S3 method for class 'paircomp'
as.grouped_rankings(x, ...)

## S3 method for class 'grouped_rankings'
x[i, j, ..., drop = TRUE, as.grouped_rankings = TRUE]

## S3 method for class 'grouped_rankings'
format(x, max = 2L, width = 20L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+rankings">&quot;rankings&quot;</a></code> object for <code>group()</code>; an
object that can be coerced to a <code>"grouped_rankings"</code> object for
<code>as.grouped_rankings()</code>, otherwise a <code>"grouped_rankings"</code> object.</p>
</td></tr>
<tr><td><code id="group_+3A_index">index</code></td>
<td>
<p>a numeric vector of length equal to the number of rankings
specifying the subject for each ranking.</p>
</td></tr>
<tr><td><code id="group_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="#topic+as.rankings">as.rankings</a></code>
by <code>grouped_rankings</code> or <code>as.grouped_rankings</code>; unused by
<code>format</code>.</p>
</td></tr>
<tr><td><code id="group_+3A_i">i</code></td>
<td>
<p>indices specifying groups to extract, may be any data type accepted
by <code><a href="Matrix.html#topic++5B">[</a></code>.</p>
</td></tr>
<tr><td><code id="group_+3A_j">j</code></td>
<td>
<p>indices specifying items to extract, as for <code><a href="Matrix.html#topic++5B">[</a></code>.</p>
</td></tr>
<tr><td><code id="group_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> return single row/column matrices as a vector.</p>
</td></tr>
<tr><td><code id="group_+3A_as.grouped_rankings">as.grouped_rankings</code></td>
<td>
<p>if <code>TRUE</code> return a grouped_rankings object,
otherwise return a matrix/vector.</p>
</td></tr>
<tr><td><code id="group_+3A_max">max</code></td>
<td>
<p>the maximum number of rankings to format per subject.</p>
</td></tr>
<tr><td><code id="group_+3A_width">width</code></td>
<td>
<p>the maximum width in number of characters to format each
ranking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"grouped_rankings"</code>, which is a vector of
of group IDs with the following attributes:
</p>
<table>
<tr><td><code>rankings</code></td>
<td>
<p> The <code>"rankings"</code> object.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p> An index match each ranking to each group ID.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p> A matrix with items ordered from last to first place, for each
ranking. </p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p> The rankings matrix with the ranks replaced by the size of the
chosen set for free choices and zero for forced choices. </p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p> A list with elements of the adjacency matrix that are incremented
by each ranking. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pltree">pltree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ungrouped rankings (5 rankings, 4 items)
R &lt;- as.rankings(matrix(c(1, 2, 0, 0,
                          0, 2, 1, 0,
                          0, 0, 1, 2,
                          2, 1, 0, 0,
                          0, 1, 2, 3), ncol = 4, byrow = TRUE))
length(R)
R

# group rankings (first three in group 1, next two in group 2)
G &lt;- group(R, c(1, 1, 1, 2, 2))
length(G)

## by default up to 2 rankings are shown per group, "..." indicates if
## there are further rankings
G
print(G, max = 1)

## select rankings from group 1
G[1,]

## exclude item 3 from ranking
G[, -3]

## rankings from group 2, excluding item 3
## - note group 2 becomes the first group
G[2, -3]

## index underlying rankings without creating new grouped_rankings object
G[2, -3, as.grouped_rankings = FALSE]
</code></pre>

<hr>
<h2 id='itempar.PlackettLuce'>Extract Item Parameters of Plackett-Luce Models</h2><span id='topic+itempar.PlackettLuce'></span><span id='topic+itempar.pltree'></span><span id='topic+itempar.PLADMM'></span>

<h3>Description</h3>

<p>Methods for <code><a href="psychotools.html#topic+itempar">itempar</a></code> to extract the item
parameters (worth or log-worth) from a Plackett-Luce model or tree.
In the case of a tree, item parameters are extracted for each terminal node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PlackettLuce'
itempar(object, ref = NULL, alias = TRUE, vcov = TRUE, log = FALSE, ...)

## S3 method for class 'pltree'
itempar(object, ...)

## S3 method for class 'PLADMM'
itempar(object, ref = NULL, alias = TRUE, vcov = TRUE, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itempar.PlackettLuce_+3A_object">object</code></td>
<td>
<p>a fitted model object as returned by
<code><a href="#topic+PlackettLuce">PlackettLuce</a></code>,  <code><a href="#topic+pladmm">pladmm</a></code>, or <code><a href="#topic+pltree">pltree</a></code>.</p>
</td></tr>
<tr><td><code id="itempar.PlackettLuce_+3A_ref">ref</code></td>
<td>
<p>a vector of labels or position indices of item parameters which
should be used as restriction/for normalization. If <code>NULL</code>
(the default), all items are used with a zero sum (<code>log = TRUE</code>) or
unit sum (<code>log = FALSE</code>) constraint.</p>
</td></tr>
<tr><td><code id="itempar.PlackettLuce_+3A_alias">alias</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), the aliased parameter is
included in the return vector (and in the variance-covariance matrix if
<code>vcov = TRUE</code>). If <code>FALSE</code>, it is removed. If the restriction given
in ref depends on several parameters, the first parameter of the restriction
specified is (arbitrarily) chosen to be removed if alias is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="itempar.PlackettLuce_+3A_vcov">vcov</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default), the (transformed)
variance-covariance matrix of the item parameters is attached as attribute
<code>vcov</code>. If <code>FALSE</code>, a <code>NA</code>-matrix is attached.</p>
</td></tr>
<tr><td><code id="itempar.PlackettLuce_+3A_log">log</code></td>
<td>
<p>logical. Whether to return log-abilities (<code>TRUE</code>) or
abilities (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="itempar.PlackettLuce_+3A_...">...</code></td>
<td>
<p>further arguments which are currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"itempar"</code>, see
<code><a href="psychotools.html#topic+itempar">itempar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")

mod &lt;- PlackettLuce(R)
coef(mod)

# equivalent to default coefficients, i.e. log abilities
itempar(mod, ref= 1, log = TRUE)

# abilities, normalized so abilities for apple and pear sum to 1
itempar(mod, ref = 1:2)

</code></pre>

<hr>
<h2 id='nascar'>Results from 2002 NASCAR Season</h2><span id='topic+nascar'></span>

<h3>Description</h3>

<p>This is an example dataset from <cite>Hunter 2004</cite> recording the results of
36 car races in the 2002 NASCAR season in the United States. Each record is
an ordering of the drivers according to their finishing position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nascar
</code></pre>


<h3>Format</h3>

<p>A matrix with 36 rows corresponding to the races and 43 columns
corresponding to the positions. The columns contain the ID for the driver
that came first to last place respectively. The <code>"drivers"</code>
attribute contains the names of the 87 drivers.
</p>


<h3>References</h3>

<p>Hunter, D. R. (2004) MM algorithms for generalized Bradley-Terry models.
<em>The Annals of Statistics</em>, <b>32(1)</b>, 384&ndash;406.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# convert orderings to rankings
nascar[1:2, ]
R &lt;- as.rankings(nascar, input = "orderings",
                 items = attr(nascar, "drivers"))
R[1:2, 1:4, as.rankings = FALSE]
format(R[1:2], width = 60)

# fit model as in Hunter 2004, excluding drivers that only lose
keep &lt;- seq_len(83)
R2 &lt;- R[, keep]
mod &lt;- PlackettLuce(R2, npseudo = 0)

# show coefficients as in Table 2 of Hunter 2004
avRank &lt;- apply(R, 2, function(x) mean(x[x &gt; 0]))
coefs &lt;- round(coef(mod)[order(avRank[keep])], 2)
head(coefs, 3)
tail(coefs, 3)
</code></pre>

<hr>
<h2 id='PlackettLuce'>Fit a Plackett-Luce Model</h2><span id='topic+PlackettLuce'></span>

<h3>Description</h3>

<p>Fit a Plackett-Luce model to a set of rankings. The rankings may be partial
(each ranking completely ranks a subset of the items) and include ties of
arbitrary order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlackettLuce(
  rankings,
  npseudo = 0.5,
  normal = NULL,
  gamma = NULL,
  adherence = NULL,
  weights = freq(rankings),
  na.action = getOption("na.action"),
  start = NULL,
  method = c("iterative scaling", "BFGS", "L-BFGS"),
  epsilon = 1e-07,
  steffensen = 0.1,
  maxit = c(500, 10),
  trace = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlackettLuce_+3A_rankings">rankings</code></td>
<td>
<p>a <code>"<a href="#topic+rankings">rankings</a>"</code> object, or an object that can be
coerced by <code>as.rankings</code>.  An <code><a href="#topic+aggregate">&quot;aggregated_rankings&quot;</a></code>
object can be used to specify rankings and weights simultaneously.
A <code>"<a href="#topic+grouped_rankings">grouped_rankings</a>"</code> object should be used when estimating
adherence for rankers with multiple rankings per ranker.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_npseudo">npseudo</code></td>
<td>
<p>when using pseudodata: the number of wins and losses to add
between each object and a hypothetical reference object.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_normal">normal</code></td>
<td>
<p>a optional list with elements named <code>mu</code> and <code>Sigma</code>
specifying the mean and covariance matrix of a multivariate normal prior on
the <em>log</em> worths.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_gamma">gamma</code></td>
<td>
<p>a optional list with elements named <code>shape</code> and <code>rate</code>
specifying parameters of a gamma prior on adherence parameters for each
ranker (use <code>grouped_rankings</code> to group multiple rankings by ranker).
The short-cut <code>TRUE</code> may be used to specify a Gamma(10, 10) prior. If
<code>NULL</code> (or <code>FALSE</code>), adherence is fixed to <code>adherence</code> for
all rankers.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_adherence">adherence</code></td>
<td>
<p>an optional vector of adherence values for each ranker. If
missing, adherence is fixed to 1 for all rankers. If <code>gamma</code> is not
<code>NULL</code>, this specifies the starting values for the adherence.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights for each ranking.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_na.action">na.action</code></td>
<td>
<p>a function to handle any missing rankings, see
<code><a href="stats.html#topic+na.omit">na.omit()</a></code>.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_start">start</code></td>
<td>
<p>starting values for the worth parameters and the tie parameters
on the raw scale (worth parameters need not be scaled to sum to 1). If
<code>normal</code> is specified, <code>exp(normal$mu)</code> is used as starting values
for the worth parameters. Coefficients from a previous fit can be passed as
the result of a call to  <code>coef.PlackettLuce</code>, or the <code>coefficients</code>
element of a <code>"PlackettLuce"</code> object.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_method">method</code></td>
<td>
<p>the method to be used for fitting: <code>"iterative scaling"</code>
(iterative scaling to sequentially update the parameter values),
<code>"BFGS"</code> (the BFGS optimisation algorithm through the
<code><a href="stats.html#topic+optim">optim</a></code> interface), <code>"L-BFGS"</code> (the limited-memory BFGS
optimisation algorithm as implemented in the <code><a href="lbfgs.html#topic+lbfgs">lbfgs</a></code>
package). Iterative scaling is used by default, unless a prior is specified
by <code>normal</code> or <code>gamma</code>, in which case the default is <code>"BFGS"</code>.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_epsilon">epsilon</code></td>
<td>
<p>the maximum absolute difference between the observed and
expected sufficient statistics for the ability parameters at convergence.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_steffensen">steffensen</code></td>
<td>
<p>a threshold defined as for <code>epsilon</code> after which to
apply Steffensen acceleration to the iterative scaling updates.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_maxit">maxit</code></td>
<td>
<p>a vector specifying the maximum number of iterations. If
<code>gamma</code> is <code>NULL</code>, only the first element is used and specifies the
maximum number of iterations of the algorithm specified by <code>method</code>. If
<code>gamma</code> is not <code>NULL</code>, a second element may be supplied to specify
the maximum number of iterations of an alternating algorithm, where
the adherence parameters are updated alternately with the other parameters.
The default is to use 10 outer iterations.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_trace">trace</code></td>
<td>
<p>logical, if <code>TRUE</code> show trace of iterations.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_verbose">verbose</code></td>
<td>
<p>logical, if <code>TRUE</code> show messages from validity checks on
the rankings.</p>
</td></tr>
<tr><td><code id="PlackettLuce_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>optim</code> or <code>lbfgs</code>.
In particular the convergence tolerance may be adjusted using e.g.
<code>control = list(reltol = 1e-10)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"PlackettLuce"</code>, which is a list containing
the following elements:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p> The matched call. </p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> The model coefficients. </p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p> The maximized log-likelihood. </p>
</td></tr>
<tr><td><code>null.loglik</code></td>
<td>
<p> The maximized log-likelihood for the null model (all
alternatives including ties have equal probability). </p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p> The residual degrees of freedom. </p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p> The residual degrees of freedom for the null model. </p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p> The rank of the model. </p>
</td></tr>
<tr><td><code>logposterior</code></td>
<td>
<p> If a prior was specified, the maximised log posterior.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p> If a gamma prior was specified, the list of parameters. </p>
</td></tr>
<tr><td><code>normal</code></td>
<td>
<p> If a normal prior was specified, the list of parameters. </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> The number of iterations run. </p>
</td></tr>
<tr><td><code>rankings</code></td>
<td>
<p> The rankings passed to <code>rankings</code>, converted to a
<code>"rankings"</code> object if necessary. </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> The weights applied to each ranking in the fitting. </p>
</td></tr>
<tr><td><code>adherence</code></td>
<td>
<p> The fixed or estimated adherence per ranker. </p>
</td></tr>
<tr><td><code>ranker</code></td>
<td>
<p> The ranker index mapping rankings to rankers (the
<code>"index"</code> attribute of <code>rankings</code> if specified as a
<code>"grouped_rankings"</code> object.)</p>
</td></tr>
<tr><td><code>ties</code></td>
<td>
<p> The observed tie orders corresponding to the estimated tie
parameters. </p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p> The convergence code: 0 for successful convergence; 1 if reached
<code>maxit</code> (outer) iterations without convergence; 2 if Steffensen
acceleration cause log-likelihood to increase; negative number if L-BFGS
algorithm failed for other reason.</p>
</td></tr>
</table>


<h3>Model definition</h3>

<p>A single ranking is given by
</p>
<p style="text-align: center;"><code class="reqn">R = \{C_1, C_2, \ldots, C_J\}</code>
</p>

<p>where the items in set <code class="reqn">C_1</code> are ranked higher than (better than) the
items in <code class="reqn">C_2</code>, and so on. If there are multiple objects in set <code class="reqn">C_j</code>
these items are tied in the ranking.
</p>
<p>For a set if items <code class="reqn">S</code>, let
</p>
<p style="text-align: center;"><code class="reqn">f(S) = \delta_{|S|}
      \left(\prod_{i \in S} \alpha_i \right)^\frac{1}{|S|}</code>
</p>

<p>where <code class="reqn">|S|</code> is the cardinality (size) of the set, <code class="reqn">\delta_n</code>
is a parameter related to the prevalence of ties of order <code class="reqn">n</code>
(with <code class="reqn">\delta_1 \equiv 1</code>), and <code class="reqn">\alpha_i</code> is a
parameter representing the worth of item <code class="reqn">i</code>.
Then under an extension of the Plackett-Luce model allowing ties up to order
<code class="reqn">D</code>, the probability of the ranking <code class="reqn">R</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\prod_{j = 1}^J \frac{f(C_j)}{
      \sum_{k = 1}^{\min(D_j, D)} \sum_{S \in {A_j \choose k}} f(S)}</code>
</p>

<p>where <code class="reqn">D_j</code> is the cardinality of <code class="reqn">A_j</code>, the set of
alternatives from which <code class="reqn">C_j</code> is chosen, and
<code class="reqn">A_j \choose k</code> is all the possible choices of <code class="reqn">k</code>
items from <code class="reqn">A_j</code>. The value of <code class="reqn">D</code> can be set to the maximum number
of tied items observed in the data, so that <code class="reqn">\delta_n = 0</code>
for <code class="reqn">n &gt; D</code>.
</p>
<p>When the worth parameters are constrained to sum to one, they represent the
probability that the corresponding item comes first in a ranking of all
items, given that first place is not tied.
</p>
<p>The 2-way tie prevalence parameter <code class="reqn">\delta_2</code> is related to
the probability that two items <em>of equal worth</em> tie for
first place, given that the first place is not a 3-way or higher tie.
Specifically, that probability is
<code class="reqn">\delta_2/(2 + \delta_2)</code>.
</p>
<p>The 3-way and higher tie-prevalence parameters are similarly interpretable,
in terms of tie probabilities among equal-worth items.
</p>
<p>When intermediate tie orders are not observed (e.g. ties of order 2
and order 4 are observed, but no ties of order 3), the maximum
likelihood estimate of the corresponding tie prevalence parameters
is zero, so these parameters are excluded from the model.
</p>


<h3>Pseudo-rankings</h3>

<p>In order for the maximum likelihood estimate of an object's worth to be
defined, the network of rankings must be strongly connected. This means that
in every possible partition of the objects into two nonempty subsets, some
object in the second set is ranked higher than some object in the first set
at least once.
</p>
<p>If the network of rankings is not strongly connected then pseudo-rankings
may be used to connect the network. This approach posits a hypothetical
object with log-worth 0 and adds <code>npseudo</code> wins and <code>npseudo</code>
losses to the set of rankings.
</p>
<p>The parameter <code>npseudo</code> is the prior strength.  With <code>npseudo = 0</code>
the MLE is the posterior mode.  As <code>npseudo</code> approaches
infinity the log-worth estimates all shrink towards 0. The default,
<code>npseudo = 0.5</code>, is sufficient to connect the network and has a weak
shrinkage effect. Even for networks that are already connected, adding
pseudo-rankings typically reduces both the bias and variance of the
estimators of the worth parameters.
</p>


<h3>Incorporating prior information on log-worths</h3>

<p>Prior information can be incorporated by using <code>normal</code> to specify a
multivariate normal prior on the <em>log</em>-worths. The log-worths are then
estimated by maximum a posteriori (MAP) estimation. Model summaries
(deviance, AIC, standard errors) are based on the log-likelihood evaluated
at the MAP estimates, resulting in a finite sample bias that should
disappear as the number of rankings increases. Inference based on these
model summaries is valid as long as the prior is considered fixed and not
tuned as part of the model.
</p>
<p>Incorporating a prior is an alternative method of penalization, therefore
<code>npseudo</code> is set to zero when a prior is specified.
</p>


<h3>Incorporating ranker adherence parameters</h3>

<p>When rankings come from different rankers, the model can be extended to
allow for varying reliability of the rankers, as proposed by Raman and
Joachims (2014). In particular, replacing <code class="reqn">f(S)</code> by
</p>
<p style="text-align: center;"><code class="reqn">h(S) = \delta_{|S|}
      \left(\prod_{i \in S} \alpha_i \right)^\frac{\eta_g}{|S|}</code>
</p>

<p>where <code class="reqn">\eta_g &gt; 0</code> is the adherence parameter for ranker
<code class="reqn">g</code>. In the standard model, all rankers are assumed to have equal
reliability, so <code class="reqn">\eta_g = 1</code> for all rankers.
Higher <code class="reqn">\eta_g = 1</code> increases the distance between item
worths, giving greater weight' to the ranker's choice. Conversely, lower
<code class="reqn">\eta_g = 1</code> shrinks the item worths towards equality so the
ranker's choice is less relevant.
</p>
<p>The adherence parameters are not estimable by maximum likelihood, since
for given item worths the maximum likelihood estimate of adherence would be
infinity for rankers that give rankings consistent with the items ordered by
worth and zero for all other rankers. Therefore it is essential to include a
prior on the adherence parameters when these are estimated rather than fixed.
Setting <code>gamma = TRUE</code> specifies the default
<code class="reqn">\Gamma(10,10)</code> prior, which has a mean of
1 and a probability of 0.99 that the adherence is between 0.37 and 2.
Alternative parameters can be specified by a list with elements <code>shape</code>
and <code>rate</code>. Setting scale and rate to a common value <code class="reqn">\theta</code>
specifies a mean of 1; <code class="reqn">\theta \ge</code> 2 will give low prior
probability to near-zero adherence; as <code class="reqn">\theta</code> increases the
density becomes more concentrated (and more symmetrical) about 1.
</p>
<p>Since the number of adherence parameters will typically be large and it is
assumed the worth and tie parameters are of primary interest, the adherence
parameters are not included in model summaries, but are included in the
returned object.
</p>


<h3>Controlling the fit</h3>

<p>For models without priors, using <code>nspseudo = 0</code> will use standard
maximum likelihood, if the network is connected (and throw an error
otherwise).
</p>
<p>The fitting algorithm is set by the <code>method</code> argument. The default
method <code>"iterative scaling"</code> is a slow but reliable approach. In
addition, this has the most control on the accuracy of the final fit, since
convergence is determined by direct comparison of the observed and expected
values of the sufficient statistics for the worth parameters, rather than a
tolerance on change in the log-likelihood.
</p>
<p>The <code>"iterative scaling"</code> algorithm is slow because it is a first order
method (does not use derivatives of the likelihood). From a set of starting
values that are 'close enough' to the final solution, the algorithm can be
accelerated using
<a href="https://en.wikipedia.org/wiki/Steffensen's_method">Steffensen's method</a>.
<code>PlackettLuce</code> attempts to apply Steffensen's acceleration when all
differences between the observed and expected values of the sufficient
statistics are less than <code>steffensen</code>. This is an ad-hoc rule defining
'close enough' and in some cases the acceleration may produce negative
worth parameters or decrease the log-likelihood. <code>PlackettLuce</code> will
only apply the update when it makes an improvement.
</p>
<p>The <code>"BFGS"</code> and <code>"L-BFGS"</code> algorithms are second order methods,
therefore can be quicker than the default method. Control parameters can be
passed on to <code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="lbfgs.html#topic+lbfgs">lbfgs</a></code>.
</p>
<p>For models with priors, the iterative scaling method cannot be used, so BFGS
is used by default.
</p>


<h3>Note</h3>

<p>As the maximum tie order increases, the number of possible choices for
each rank increases rapidly, particularly when the total number of items is
high. This means that the model will be slower to fit with higher <code class="reqn">D</code>.
In addition, due to the current implementation of the <code>vcov()</code> method,
computation of the standard errors (as by <code>summary()</code>) can take almost as
long as the model fit and may even become infeasible due to memory limits.
As a rule of thumb, for &gt; 10 items and &gt; 1000 rankings, we recommend
<code>PlackettLuce()</code> for ties up to order 4. For higher order ties, a
rank-ordered logit model, see <code><a href="ROlogit.html#topic+rologit">ROlogit::rologit()</a></code> or
generalized Mallows Model as in <code><a href="BayesMallows.html#topic+compute_mallows">BayesMallows::compute_mallows()</a></code> may be
more suitable, as they do not model tied events explicitly.
</p>


<h3>References</h3>

<p>Raman, K. and Joachims, T. (2014)  Methods for Ordinal Peer Grading.
<a href="https://arxiv.org/abs/1404.3656">arXiv:1404.3656</a>.
</p>


<h3>See Also</h3>

<p>Handling rankings: <code><a href="#topic+rankings">rankings</a></code>, <code><a href="#topic+aggregate">aggregate</a></code>,
<code><a href="#topic+group">group</a></code>, <code><a href="#topic+choices">choices</a></code>,
<code><a href="#topic+adjacency">adjacency</a></code>, <code><a href="#topic+connectivity">connectivity</a></code>.
</p>
<p>Inspect fitted Plackett-Luce models: <code><a href="stats.html#topic+coef">coef</a></code>, <code>deviance</code>,
<code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="#topic+itempar">itempar</a></code>, <code>logLik</code>, <code>print</code>,
<code><a href="#topic+qvcalc">qvcalc</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p>Fit Plackett-Luce tree: <code>pltree</code>.
</p>
<p>Example data sets: <code><a href="#topic+beans">beans</a></code>, <code><a href="#topic+nascar">nascar</a></code>,
<code><a href="#topic+pudding">pudding</a></code>, <code><a href="#topic+preflib">preflib</a></code>.
</p>
<p>Vignette: <code>vignette("Overview", package = "PlackettLuce")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Six partial rankings of four objects, 1 is top rank, e.g
# first ranking: item 1, item 2
# second ranking: item 2, item 3, item 4, item 1
# third ranking: items 2, 3, 4 tie for first place, item 1 second
R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")

# create rankings object
R &lt;- as.rankings(R)

# Standard maximum likelihood estimates
mod_mle &lt;- PlackettLuce(R, npseudo = 0)
coef(mod_mle)

# Fit with default settings
mod &lt;- PlackettLuce(R)
# log-worths are shrunk towards zero
coef(mod)

# independent N(0, 9) priors on log-worths, as in Raman and Joachims
prior &lt;- list(mu = rep(0, ncol(R)),
              Sigma = diag(rep(9, ncol(R))))
mod_normal &lt;- PlackettLuce(rankings = R, normal = prior)
# slightly weaker shrinkage effect vs pseudo-rankings,
# with less effect on tie parameters (but note small number of rankings here)
coef(mod_normal)

# estimate adherence assuming every ranking is from a separate ranker
mod_separate &lt;- PlackettLuce(rankings = R, normal = prior, gamma = TRUE)
coef(mod_separate)
# gives more weight to rankers 4 &amp; 6 which rank apple first,
# so worth of apple increased relative to banana
mod_separate$adherence

# estimate adherence based on grouped rankings
#  - assume two rankings from each ranker
G &lt;- group(R, rep(1:3, each = 2))
mod_grouped &lt;- PlackettLuce(rankings = G, normal = prior, gamma = TRUE)
coef(mod_grouped)
# first ranker is least consistent so down-weighted
mod_grouped$adherence

</code></pre>

<hr>
<h2 id='PlackettLuce-deprecated'>Deprecated functions in package <span class="pkg">PlackettLuce</span></h2><span id='topic+PlackettLuce-deprecated'></span><span id='topic+grouped_rankings'></span>

<h3>Description</h3>

<p>The functions listed below are deprecated and will be defunct in
the near future. When possible, alternative functions with similar
functionality are also mentioned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped_rankings(rankings, index, ...)
</code></pre>


<h3>grouped_rankings</h3>

<p><code>grouped_rankings()</code> has been replaced by <code><a href="#topic+group">group()</a></code>.
</p>

<hr>
<h2 id='pladmm'>Fit a Plackett-Luce Model with Linear Predictor for Log-worth</h2><span id='topic+pladmm'></span>

<h3>Description</h3>

<p>Fit a Plackett-Luce model where the log-worth is predicted by a linear
function of covariates. The rankings may be partial
(each ranking completely ranks a subset of the items), but ties are not
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pladmm(
  rankings,
  formula,
  data = NULL,
  weights = freq(rankings),
  start = NULL,
  contrasts = NULL,
  rho = 1,
  n_iter = 500,
  rtol = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pladmm_+3A_rankings">rankings</code></td>
<td>
<p>a <code>"<a href="#topic+rankings">rankings</a>"</code> object, or an object that can be
coerced by <code>as.rankings</code>. An <code><a href="#topic+aggregate">&quot;aggregated_rankings&quot;</a></code>
object can be used to specify rankings and weights simultaneously.</p>
</td></tr>
<tr><td><code id="pladmm_+3A_formula">formula</code></td>
<td>
<p>a <a href="stats.html#topic+formula">formula</a> specifying the linear model for log-worth.</p>
</td></tr>
<tr><td><code id="pladmm_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="pladmm_+3A_weights">weights</code></td>
<td>
<p>weights for the rankings.</p>
</td></tr>
<tr><td><code id="pladmm_+3A_start">start</code></td>
<td>
<p>starting values for the coefficients.</p>
</td></tr>
<tr><td><code id="pladmm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list specifying contrasts for the factors in
<code>formula</code>. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="pladmm_+3A_rho">rho</code></td>
<td>
<p>the penalty parameter in the penalized likelihood, see details.</p>
</td></tr>
<tr><td><code id="pladmm_+3A_n_iter">n_iter</code></td>
<td>
<p>the maximum number of iterations (also for inner loops).</p>
</td></tr>
<tr><td><code id="pladmm_+3A_rtol">rtol</code></td>
<td>
<p>the convergence tolerance (also for inner loops)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-worth is modelled as a linear function of item covariates:
</p>
<p style="text-align: center;"><code class="reqn">\log \alpha_i = \beta_0 + \beta_1 x_{i1} + \ldots + \beta_p x_{ip}</code>
</p>

<p>where <code class="reqn">\beta_0</code> is fixed by the constraint that
<code class="reqn">\sum_i \alpha_i = 1</code>.
</p>
<p>The parameters are estimated using an Alternating Directions Method of
Multipliers (ADMM) algorithm proposed by Yildiz (2020). ADMM alternates
between estimating the worths <code class="reqn">\alpha_i</code> and the linear
coefficients <code class="reqn">\beta_k</code>, encapsulating them in a quadratic penalty on the
likelihood:
</p>
<p style="text-align: center;"><code class="reqn">L(\boldsymbol{\beta}, \boldsymbol{\alpha}, \boldsymbol{u}) =
\mathcal{L}(\mathcal{D}|\boldsymbol{\alpha}) +
\frac{\rho}{2}||\boldsymbol{X}\boldsymbol{\beta} -
\log \boldsymbol{\alpha} + \boldsymbol{u}||^2_2 -
\frac{\rho}{2}||\boldsymbol{u}||^2_2</code>
</p>

<p>where <code class="reqn">\boldsymbol{u}</code> is a dual variable that imposes the equality
constraints (so that <code class="reqn">\log \boldsymbol{\alpha}</code> converges to
<code class="reqn">\boldsymbol{X}\boldsymbol{\beta}</code>).
</p>


<h3>Note</h3>

<p>This is a prototype function and the user interface is planned to
change in upcoming versions of PlackettLuce.
</p>


<h3>References</h3>

<p>Yildiz, I., Dy, J., Erdogmus, D., Kalpathy-Cramer, J., Ostmo, S.,
Campbell, J. P., Chiang, M. F. and Ioannidis, S. (2020) Fast and Accurate
Ranking Regression In Proceedings of the Twenty Third International
Conference on Artificial Intelligence and Statistics, <b>108</b>, 77–-88.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(prefmod)){
  data(salad)
  # data.frame of rankings for salad dressings A B C D
  # 1 = most tart, 4 = least tart
  salad[1:3,]

  # create data frame of corresponding features
  # (acetic and gluconic acid concentrations in salad dressings)
  features &lt;- data.frame(salad = LETTERS[1:4],
                         acetic = c(0.5, 0.5, 1, 0),
                         gluconic = c(0, 10, 0, 10))

  # fit Plackett-Luce model based on covariates
  res_PLADMM &lt;- pladmm(salad, ~ acetic + gluconic, data = features, rho = 8)
  ## coefficients
  coef(res_PLADMM)
  ## worth
  res_PLADMM$pi
  ## worth as predicted by linear function
  res_PLADMM$tilde_pi
  ## equivalent to
  drop(exp(res_PLADMM$x %*% coef(res_PLADMM)))

}

</code></pre>

<hr>
<h2 id='plfit'>PlackettLuce Wrapper for Model-based Recursive Partitioning</h2><span id='topic+plfit'></span>

<h3>Description</h3>

<p>This is a wrapper around <code>PlackettLuce</code> as required by
<code><a href="partykit.html#topic+mob">mob</a></code> for model-based recursive partitioning. It is
not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plfit(
  y,
  x = NULL,
  ref = 1L,
  start = NULL,
  weights = NULL,
  offset = NULL,
  ...,
  estfun = FALSE,
  object = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plfit_+3A_y">y</code></td>
<td>
<p>a <code>"<a href="#topic+grouped_rankings">grouped_rankings</a>"</code> object giving the rankings to
model.</p>
</td></tr>
<tr><td><code id="plfit_+3A_x">x</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="plfit_+3A_ref">ref</code></td>
<td>
<p>An integer or character string specifying the reference item (for
which log worth will be set to zero). If <code>NULL</code> the sum of the log worth
parameters is set to zero.</p>
</td></tr>
<tr><td><code id="plfit_+3A_start">start</code></td>
<td>
<p>starting values for the worth parameters and the tie parameters
on the raw scale (worth parameters need not be scaled to sum to 1). If
<code>normal</code> is specified, <code>exp(normal$mu)</code> is used as starting values
for the worth parameters. Coefficients from a previous fit can be passed as
the result of a call to  <code>coef.PlackettLuce</code>, or the <code>coefficients</code>
element of a <code>"PlackettLuce"</code> object.</p>
</td></tr>
<tr><td><code id="plfit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights for each ranking.</p>
</td></tr>
<tr><td><code id="plfit_+3A_offset">offset</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="plfit_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>PlackettLuce</code>.</p>
</td></tr>
<tr><td><code id="plfit_+3A_estfun">estfun</code></td>
<td>
<p>logical. If <code>TRUE</code> the empirical estimating functions
(score/gradient contributions) are returned.</p>
</td></tr>
<tr><td><code id="plfit_+3A_object">object</code></td>
<td>
<p>logical. If <code>TRUE</code> the fitted model is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> model coefficients. </p>
</td></tr>
<tr><td><code>objfun</code></td>
<td>
<p> the negative log-likelihood. </p>
</td></tr>
<tr><td><code>estfun</code></td>
<td>
<p> if <code>estfun</code> the empirical estimating functions. </p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p> if <code>object</code> the fitted model. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># rankings
R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")
R &lt;- as.rankings(R)

# group rankings into two groups
G &lt;- group(R, rep(1:2, 3))

# plfit() gives the same results as PlackettLuce()
pl &lt;- plfit(G)
pl$coefficients
-pl$objfun

mod &lt;- PlackettLuce(R)
coef(mod)
logLik(mod)
</code></pre>

<hr>
<h2 id='pltree'>Plackett-Luce Trees</h2><span id='topic+pltree'></span>

<h3>Description</h3>

<p>Recursive partitioning based on Plackett-Luce models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pltree(formula, data, worth, na.action, cluster, ref = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pltree_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fitted, of the form
<code>y ~ x1 + ... + xn</code> where <code>y</code> should be an object of class
<code><a href="#topic+grouped_rankings">grouped_rankings</a></code> and <code>x1</code>, ..., <code>xn</code> are used as
partitioning variables.</p>
</td></tr>
<tr><td><code id="pltree_+3A_data">data</code></td>
<td>
<p>An optional data object containing the variables in the model.
Either a data frame of variables in <code>formula</code> or a list of length 2 giving
data frames for variables in <code>formula</code> and in <code>worth</code>.</p>
</td></tr>
<tr><td><code id="pltree_+3A_worth">worth</code></td>
<td>
<p>A optional formula specifying a linear model for log-worth.
If <code>NULL</code>, worth is estimated separately for each item with
<code><a href="#topic+PlackettLuce">PlackettLuce()</a></code>. Otherwise, the model in each node of the tree id fitted
with <code><a href="#topic+pladmm">pladmm()</a></code>.</p>
</td></tr>
<tr><td><code id="pltree_+3A_na.action">na.action</code></td>
<td>
<p>how NAs are treated for variables in <code>formula</code>, applied
to the underlying rankings.</p>
</td></tr>
<tr><td><code id="pltree_+3A_cluster">cluster</code></td>
<td>
<p>an optional vector of cluster IDs to be employed for clustered
covariances in the parameter stability tests, see <code><a href="partykit.html#topic+mob">mob</a></code>.</p>
</td></tr>
<tr><td><code id="pltree_+3A_ref">ref</code></td>
<td>
<p>an integer or character string specifying the reference item (for
which log ability will be set to zero). If NULL the first item is used.</p>
</td></tr>
<tr><td><code id="pltree_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to <code><a href="#topic+PlackettLuce">PlackettLuce</a></code>
of <code><a href="#topic+pladmm">pladmm()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plackett-Luce trees are an application of model-based recursive partitioning
(implemented in <code><a href="partykit.html#topic+mob">mob</a></code>) to Plackett-Luce models for
rankings. The partitioning is based on ranking covariates, e.g. attributes of
the judge making the ranking, or conditions under which the ranking is made.
The response should be a <code><a href="#topic+grouped_rankings">grouped_rankings</a></code> object that groups
rankings with common covariate values. This may be included in a data frame
alongside the covariates.
</p>
<p>Most arguments of <code>PlackettLuce</code> can be passed on by <code>pltree</code>.
However, Plackett-Luce tree with fixed adherence are not implemented.
Arguably it makes more sense to estimate adherence or reliability within
the nodes of the Plackett-Luce tree.
</p>
<p>Various methods are provided for <code>"pltree"</code> objects, most of them
inherited from <code>"modelparty"</code> objects (e.g. <code>print</code>,
<code>summary</code>), or <code>"bttree"</code> objects (<code>plot</code>). The plot
method employs the <code><a href="psychotree.html#topic+node_btplot">node_btplot</a></code>
panel-generating function. The See Also
section gives details of separately documented methods.
</p>


<h3>Value</h3>

<p>An object of class <code>"pltree"</code> inheriting from <code>"bttree"</code>
and <code>"modelparty"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="psychotree.html#topic+bttree">bttree</a></code> For fitting Bradley-Terry trees
(equivalent to the Plackett-Luce model for paired comparisons without ties).
</p>
<p><code>coef</code>, <code>vcov</code>, <code>AIC</code> and <code>predict</code> methods are documented on
<code><a href="#topic+pltree-summaries">pltree-summaries</a></code>.
</p>
<p><code><a href="#topic+itempar.PlackettLuce">itempar</a></code>, extracts the abilities or item parameters
in each node of the tree using <code><a href="#topic+itempar.PlackettLuce">itempar.PlackettLuce</a></code>.
</p>
<p><code><a href="#topic+fitted.PlackettLuce">fitted</a></code>, computes probabilities for the observed
choices based on the full tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bradley-Terry example

if (require(psychotree)){
    ## Germany's Next Topmodel 2007 data
    data("Topmodel2007", package = "psychotree")
    ## convert paircomp object to grouped rankings
    R &lt;- as.grouped_rankings(Topmodel2007$preference)
    ## rankings are grouped by judge
    print(R[1:2,], max = 4)
    ## Topmodel2007[, -1] gives covariate values for each judge
    print(Topmodel2007[1:2, -1])

    ## fit partition model based on all variables except preference
    ## set npseudo = 0 as all judges rank all models
    tm_tree &lt;- pltree(R ~ ., data = Topmodel2007[, -1], minsize = 5,
                      npseudo = 0)

    ## plot shows abilities constrained to sum to 1
    plot(tm_tree, abbreviate = 1, yscale = c(0, 0.5))
    ## instead show log-abilities with Anja as reference (need to used index)
    plot(tm_tree, abbreviate = 1, worth = FALSE, ref = 6,
         yscale = c(-1.5, 2.2))

    ## log-abilities, zero sum contrast
    itempar(tm_tree, log = TRUE)
}
</code></pre>

<hr>
<h2 id='pltree-summaries'>Plackett-Luce Tree Summaries</h2><span id='topic+pltree-summaries'></span><span id='topic+coef.pltree'></span><span id='topic+vcov.pltree'></span><span id='topic+AIC.pltree'></span><span id='topic+predict.pltree'></span>

<h3>Description</h3>

<p>Obtain the coefficients, variance-covariance matrix, AIC, or predictions
from a Plackett-Luce tree fitted by <code><a href="#topic+pltree">pltree()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pltree'
coef(object, node = NULL, drop = TRUE, ...)

## S3 method for class 'pltree'
vcov(object, node = nodeids(object, terminal = TRUE), ...)

## S3 method for class 'pltree'
AIC(object, newdata = NULL, ...)

## S3 method for class 'pltree'
predict(
  object,
  newdata = NULL,
  type = c("itempar", "rank", "best", "node"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pltree-summaries_+3A_object">object</code></td>
<td>
<p>a fitted model object of class <code>"pltree"</code>.</p>
</td></tr>
<tr><td><code id="pltree-summaries_+3A_node">node</code></td>
<td>
<p>a vector of node ids specifying the nodes to summarise, by
default the ids of the terminal nodes.</p>
</td></tr>
<tr><td><code id="pltree-summaries_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> return the coefficients as a vector when only one
node is selected.</p>
</td></tr>
<tr><td><code id="pltree-summaries_+3A_...">...</code></td>
<td>
<p>additional arguments passed to
<code><a href="#topic+itempar.PlackettLuce">itempar</a></code> by <code>predict</code>, and to
<code><a href="stats.html#topic+model.frame">model.frame</a></code> by <code>AIC</code>.</p>
</td></tr>
<tr><td><code id="pltree-summaries_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to use instead of the
original data. For <code>AIC</code> this must include the response variable.</p>
</td></tr>
<tr><td><code id="pltree-summaries_+3A_type">type</code></td>
<td>
<p>the type of prediction to return for each group, one of:
<code>"itempar"</code> to give the result of <code><a href="#topic+itempar">itempar</a></code> (by default the
fitted probability of each item being ranked first out of all objects),
<code>"rank"</code> the corresponding rank, <code>"best"</code> the topped ranked item,
or <code>"node"</code> the node of the tree the group belongs to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AIC</code> computes <code class="reqn">-2L + 2p</code> where <code class="reqn">L</code> is the
joint likelihood of the observed rankings under the tree model and
<code class="reqn">p</code> is the degrees of freedom used to fit the tree model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beans)
# fit tree based on pairwise comparisons with variety B
pairB &lt;- data.frame(Winner = ifelse(beans$var_b == "Worse",
                                    "Local", beans$variety_b),
                    Loser = ifelse(beans$var_b == "Worse",
                                   beans$variety_b, "Local"),
                    stringsAsFactors = FALSE, row.names = NULL)
beans$G &lt;- as.rankings(pairB, input = "orderings",
                       index = rep(seq(nrow(beans)), 1))

mod &lt;- pltree(G ~ ., data = beans[c("G", "maxTN")])

coef(mod, node = 3)
AIC(mod)

# treat first row from each year as new data
newdata &lt;- beans[!duplicated(beans$year),]

## fitted probabilities
predict(mod, newdata)

## fitted log-abilities, with Local as reference
predict(mod, newdata, log = TRUE, ref = "Local")

## variety ranks
predict(mod, newdata, type = "rank")

## top ranked variety
predict(mod, newdata, type = "best")

## node the trial belongs to
predict(mod, newdata, type = "node")
</code></pre>

<hr>
<h2 id='preflib'>Read Preflib Election Data Files</h2><span id='topic+preflib'></span><span id='topic+read.soc'></span><span id='topic+read.soi'></span><span id='topic+read.toc'></span><span id='topic+read.toi'></span><span id='topic+as.aggregated_rankings.preflib'></span>

<h3>Description</h3>

<p>Read orderings from <code>.soc</code>, <code>.soi</code>, <code>.toc</code> or <code>.toi</code> file types storing
election data as defined by
<a href="https://www.preflib.org/">{PrefLib}: A Library for Preferences</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.soc(file)

read.soi(file)

read.toc(file)

read.toi(file)

## S3 method for class 'preflib'
as.aggregated_rankings(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preflib_+3A_file">file</code></td>
<td>
<p>An election data file, conventionally with extension <code>.soc</code>,
<code>.soi</code>, <code>.toc</code> or <code>.toi</code> according to data type.</p>
</td></tr>
<tr><td><code id="preflib_+3A_x">x</code></td>
<td>
<p>An object of class <code>"preflib"</code>.</p>
</td></tr>
<tr><td><code id="preflib_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+as.rankings">as.rankings()</a></code>: <code>freq</code>,
<code>input</code> or <code>items</code> will be ignored with a warning as they are set
automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file types supported are
</p>

<dl>
<dt>.soc</dt><dd><p>Strict Orders - Complete List</p>
</dd>
<dt>.soi</dt><dd><p>Strict Orders - Incomplete List</p>
</dd>
<dt>.toc</dt><dd><p>Orders with Ties - Complete List</p>
</dd>
<dt>.toi</dt><dd><p>Orders with Ties - Incomplete List</p>
</dd>
</dl>

<p>Note that the file types do not distinguish between types of incomplete
orderings, i.e. whether they are a complete ranking of a subset of items
(as supported by <code><a href="#topic+PlackettLuce">PlackettLuce()</a></code>) or top-<code class="reqn">n</code> rankings of <code class="reqn">n</code> items
from the full set of items (not currently supported by <code><a href="#topic+PlackettLuce">PlackettLuce()</a></code>).
</p>
<p>The numerically coded orderings and their frequencies are read into a
data frame, storing the item names as an attribute. The
<code>as.aggregated_rankings</code> method converts these to an
<code><a href="#topic+aggregate.rankings">&quot;aggregated_rankings&quot;</a></code> object with the items labelled
by the item names.
</p>
<p>A Preflib file may be corrupt, in the sense that the ordered items do not
match the named items. In this case, the file can be read in as a data
frame (with a warning) using the corresponding <code style="white-space: pre;">&#8288;read.*&#8288;</code> function, but
<code>as.aggregated_rankings</code> will throw an error.
</p>


<h3>Value</h3>

<p>A data frame of class <code>"preflib"</code> with first column <code>Freq</code>,
giving the frequency of the ranking in that row, and remaining columns
<code>Rank 1</code>, ..., <code>Rank r</code> giving the items ranked from first to
last place in that ranking. Ties are represented by vector elements in list
columns. The data frame has an attribute <code>"items"</code> giving the labels
corresponding to each item number.
</p>


<h3>Note</h3>

<p>The Netflix and cities datasets used in the examples are from
Bennet and Lanning (2007) and Caragiannis et al (2017) respectively. These
data sets require a citation for re-use.
</p>


<h3>References</h3>

<p>Mattei, N. and Walsh, T. (2013) PrefLib: A Library of Preference Data.
<em>Proceedings of Third International Conference on Algorithmic Decision
Theory (ADT 2013)</em>. Lecture Notes in Artificial Intelligence, Springer.
</p>
<p>Caragiannis, I., Chatzigeorgiou, X, Krimpas, G. A., and Voudouris, A. A.
(2017) Optimizing positional scoring rules for rank aggregation.
In <em>Proceedings of the 31st AAAI Conference on Artificial Intelligence</em>.
</p>
<p>Bennett, J. and Lanning, S. (2007) The Netflix Prize.
<em>Proceedings of The KDD Cup and Workshops</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# strict complete orderings of four films on Netflix
netflix &lt;- read.soc(system.file("extdata", "netflix.soc",
                                package = "PlackettLuce"))
head(netflix)
attr(netflix, "items")

head(as.aggregated_rankings(netflix))

# strict incomplete orderings of 6 random cities from 36 in total
cities &lt;- read.soi(system.file("extdata", "cities.soi",
                                package = "PlackettLuce"))

# complete orderings with ties of 30 skaters
skaters &lt;- read.toc(system.file("extdata", "skaters.toc",
                                package = "PlackettLuce"))

# incomplete orderings with ties: most important qualities for success
# from 20 in total
qualities &lt;- read.toi(system.file("extdata", "education_qualities.toi",
                      package = "PlackettLuce"))

# alternatively read from a url
# - can take a little while depending on speed of internet connection

## Not run: 
# incomplete orderings with ties: most important qualities for success
# from 20 in total
preflib &lt;- "https://www.preflib.org/static/data/"
qualities2 &lt;- read.toi(file.path(preflib, "education/00032-00000007.toi"))
all.equal(qualities, qualities2)

## End(Not run)
</code></pre>

<hr>
<h2 id='pudding'>Paired Comparisons of Chocolate Pudding</h2><span id='topic+pudding'></span>

<h3>Description</h3>

<p>This is an example dataset from <cite>Davidson 1970</cite> comprising paired
comparisons of chocolate pudding, with six brands in total. The responses
include tied outcomes, i.e. no preference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pudding
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 records and 6 variables:
</p>

<dl>
<dt><code>i</code></dt><dd><p>The first brand in the comparison.</p>
</dd>
<dt><code>j</code></dt><dd><p>The second brand in the comparison.</p>
</dd>
<dt><code>r_ij</code></dt><dd><p>The frequency of paired comparisons of brand i and
brand j.</p>
</dd>
<dt><code>w_ij</code></dt><dd><p>The frequency of preferences for i over j.</p>
</dd>
<dt><code>w_ji</code></dt><dd><p>The frequency of preferences for j over i.</p>
</dd>
<dt><code>t_ij</code></dt><dd><p>The frequency of no preference between i and j.</p>
</dd>
</dl>



<h3>References</h3>

<p>Davidson, R. R. (1970). On extending the Bradley-Terry model to accommodate
ties in paired comparison experiments. <em>Journal of the American
Statistical Association</em>, <b>65</b>, 317&ndash;328.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create orderings for each set of paired comparisons

# wins for brand i and wins for brand j
i_wins &lt;- data.frame(Winner = pudding$i, Loser = pudding$j)
j_wins &lt;- data.frame(Winner = pudding$j, Loser = pudding$i)

# ties: use an array list (easier with R &gt;= 3.6.0)
if (getRversion() &lt; "3.6.0"){
  n &lt;- nrow(pudding)
  ties &lt;- data.frame(Winner = array(split(pudding[c("i", "j")], 1:n), n),
                     Loser = rep(NA, 15))
} else {
  ties &lt;- data.frame(Winner = asplit(pudding[c("i", "j")], 1),
                     Loser = rep(NA, 15))
}
head(ties, 2)

# convert to rankings
R &lt;- as.rankings(rbind(i_wins, j_wins, ties),
                 input = "orderings")
head(R, 2)
tail(R, 2)

# define weights as frequencies of each ranking
w &lt;- unlist(pudding[c("w_ij", "w_ji", "t_ij")])

# fit Plackett-Luce model: limit iterations to match paper
mod &lt;- PlackettLuce(R, npseudo = 0, weights = w, maxit = 7)
</code></pre>

<hr>
<h2 id='qvcalc.PlackettLuce'>Quasi Variances for Model Coefficients</h2><span id='topic+qvcalc.PlackettLuce'></span>

<h3>Description</h3>

<p>A method for <code><a href="#topic+qvcalc">qvcalc</a></code> to compute a set of quasi variances (and
corresponding quasi standard errors) for estimated item parameters from a
Plackett-Luce model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PlackettLuce'
qvcalc(object, ref = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qvcalc.PlackettLuce_+3A_object">object</code></td>
<td>
<p>a <code>"PlackettLuce"</code> object as returned by
<code>PlackettLuce</code>.</p>
</td></tr>
<tr><td><code id="qvcalc.PlackettLuce_+3A_ref">ref</code></td>
<td>
<p>An integer or character string specifying the reference item (for
which log worth will be set to zero). If <code>NULL</code> the sum of the log worth
parameters is set to zero.</p>
</td></tr>
<tr><td><code id="qvcalc.PlackettLuce_+3A_...">...</code></td>
<td>
<p>additional arguments, currently ignored..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the method see Firth (2000), Firth (2003) or Firth and de
Menezes (2004). Quasi variances generalize and improve the accuracy of
&ldquo;floating absolute risk&rdquo; (Easton et al., 1991). This device for
economical model summary was first suggested by Ridout (1989).
</p>
<p>Ordinarily the quasi variances are positive and so their square roots
(the quasi standard errors) exist and can be used in plots, etc.
</p>


<h3>Value</h3>

<p>A list of class <code>"qv"</code>, with components
</p>
<table>
<tr><td><code>covmat</code></td>
<td>
<p>The full variance-covariance matrix for the item
parameters.</p>
</td></tr>
<tr><td><code>qvframe</code></td>
<td>
<p>A data frame with variables <code>estimate</code>, <code>SE</code>,
<code>quasiSE</code> and <code>quasiVar</code>, the last two being a quasi standard
error and quasi-variance for each parameter.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p><code>NULL</code> (dispersion is fixed to 1).</p>
</td></tr>
<tr><td><code>relerrs</code></td>
<td>
<p>Relative errors for approximating the standard errors of all
simple contrasts.</p>
</td></tr>
<tr><td><code>factorname</code></td>
<td>
<p><code>NULL</code> (not required for this method).</p>
</td></tr>
<tr><td><code>coef.indices</code></td>
<td>
<p><code>NULL</code> (not required for this method).</p>
</td></tr>
<tr><td><code>modelcall</code></td>
<td>
<p>The call to <code>PlackettLuce</code> to fit the model from which
the item parameters were estimated.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Easton, D. F, Peto, J. and Babiker, A. G. A. G. (1991) Floating absolute
risk: an alternative to relative risk in survival and case-control analysis
avoiding an arbitrary reference group. <em>Statistics in Medicine</em>
<b>10</b>, 1025&ndash;1035.
</p>
<p>Firth, D. (2000)  Quasi-variances in Xlisp-Stat and on the web.
<em>Journal of Statistical Software</em> <b>5.4</b>, 1&ndash;13.
At https://www.jstatsoft.org
</p>
<p>Firth, D. (2003) Overcoming the reference category problem in the
presentation of statistical models. <em>Sociological Methodology</em>
<b>33</b>, 1&ndash;18.
</p>
<p>Firth, D. and de Menezes, R. X. (2004)  Quasi-variances.
<em>Biometrika</em> <b>91</b>, 65&ndash;80.
</p>
<p>Menezes, R. X. de (1999)  More useful standard errors for group and factor
effects in generalized linear models.  <em>D.Phil. Thesis</em>,
Department of Statistics, University of Oxford.
</p>
<p>Ridout, M.S. (1989). Summarizing the results of fitting generalized
linear models to data from designed experiments. In: <em>Statistical
Modelling: Proceedings of GLIM89 and the 4th International
Workshop on Statistical Modelling held in Trento, Italy, July 17&ndash;21,
1989</em> (A. Decarli et al., eds.), pp 262&ndash;269. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="qvcalc.html#topic+worstErrors">worstErrors</a></code>, <code><a href="qvcalc.html#topic+plot.qv">plot.qv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Six partial rankings of four objects, 1 is top rank, e.g
# first ranking: item 1, item 2
# second ranking: item 2, item 3, item 4, item 1
# third ranking: items 2, 3, 4 tie for first place, item 1 second
R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")

mod &lt;- PlackettLuce(R)
qv &lt;- qvcalc(mod)
qv
plot(qv)
</code></pre>

<hr>
<h2 id='rankings'>Rankings Object</h2><span id='topic+rankings'></span><span id='topic+as.rankings'></span><span id='topic+as.rankings.default'></span><span id='topic+as.rankings.grouped_rankings'></span><span id='topic+as.rankings.matrix'></span><span id='topic++5B.rankings'></span><span id='topic+format.rankings'></span>

<h3>Description</h3>

<p>Create a <code>"rankings"</code> object from data or convert a matrix of rankings
or ordered items to a <code>"rankings"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankings(data, id, item, rank, aggregate = FALSE, verbose = TRUE, ...)

as.rankings(x, ..., verbose = TRUE)

## Default S3 method:
as.rankings(
  x,
  input = c("rankings", "orderings"),
  freq = NULL,
  index = NULL,
  aggregate = FALSE,
  items = NULL,
  labels = NULL,
  ...,
  verbose = TRUE
)

## S3 method for class 'grouped_rankings'
as.rankings(x, ..., verbose = TRUE)

## S3 method for class 'matrix'
as.rankings(
  x,
  input = c("rankings", "orderings"),
  freq = NULL,
  index = NULL,
  aggregate = FALSE,
  items = NULL,
  labels = NULL,
  ...,
  verbose = TRUE
)

## S3 method for class 'rankings'
x[i, j, ..., drop = TRUE, as.rankings = TRUE]

## S3 method for class 'rankings'
format(x, width = 40L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankings_+3A_data">data</code></td>
<td>
<p>a data frame with columns specified by <code>id</code>, <code>item</code> and
<code>rank</code>.</p>
</td></tr>
<tr><td><code id="rankings_+3A_id">id</code></td>
<td>
<p>an index of <code>data</code> specifying the column containing ranking
IDs.</p>
</td></tr>
<tr><td><code id="rankings_+3A_item">item</code></td>
<td>
<p>an index of <code>data</code> specifying the column containing item
IDs,</p>
</td></tr>
<tr><td><code id="rankings_+3A_rank">rank</code></td>
<td>
<p>an index of <code>data</code> specifying the column containing item
ranks.</p>
</td></tr>
<tr><td><code id="rankings_+3A_aggregate">aggregate</code></td>
<td>
<p>if <code>TRUE</code>, aggregate the rankings via
<code><a href="#topic+aggregate.rankings">aggregate()</a></code> before returning.</p>
</td></tr>
<tr><td><code id="rankings_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code> print messages when changes are made
to rankings data.</p>
</td></tr>
<tr><td><code id="rankings_+3A_...">...</code></td>
<td>
<p>further arguments passed to/from methods.</p>
</td></tr>
<tr><td><code id="rankings_+3A_x">x</code></td>
<td>
<p>for <code>as.rankings</code>, a matrix with one column per item and one
row per ranking, or an object that can be coerced to such as matrix; for
<code>[</code> and <code>format</code>, a <code>"rankings"</code> object.</p>
</td></tr>
<tr><td><code id="rankings_+3A_input">input</code></td>
<td>
<p>for <code>as.rankings</code>, whether rows in the input matrix
contain numeric <code>"rankings"</code> (dense, standard/modified competition or
fractional rankings) or <code>"orderings"</code>, i.e. the items ordered by rank.</p>
</td></tr>
<tr><td><code id="rankings_+3A_freq">freq</code></td>
<td>
<p>an optional column index (number, character or logical)
specifying a column of <code>x</code> that holds ranking frequencies, or a vector
of ranking frequencies. If provided, an <code>"aggregated_rankings"</code> object
will be returned.</p>
</td></tr>
<tr><td><code id="rankings_+3A_index">index</code></td>
<td>
<p>an optional column index (number, character or logical)
specifying a column of <code>x</code> that holds a grouping index, or a
numeric vector to for grouping. If provided, the rankings will be grouped by
<code><a href="#topic+group">group()</a></code> before returning.</p>
</td></tr>
<tr><td><code id="rankings_+3A_items">items</code></td>
<td>
<p>for <code>input = "orderings"</code>, a character vector specifying
the full set of items. Values in <code>x</code> are matched to this by value (if
character) or position (if numeric). Use <code><a href="#topic+decode">decode()</a></code> for orderings requiring
more complex decoding.</p>
</td></tr>
<tr><td><code id="rankings_+3A_labels">labels</code></td>
<td>
<p>for <code>input = "orderings"</code> an optional vector of labels for
the items, corresponding to the sorted unique values of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rankings_+3A_i">i</code></td>
<td>
<p>indices specifying rankings to extract, as for <code><a href="Matrix.html#topic++5B">[</a></code>.</p>
</td></tr>
<tr><td><code id="rankings_+3A_j">j</code></td>
<td>
<p>indices specifying items to extract, as for <code><a href="Matrix.html#topic++5B">[</a></code>.</p>
</td></tr>
<tr><td><code id="rankings_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> return single row/column matrices as a vector.</p>
</td></tr>
<tr><td><code id="rankings_+3A_as.rankings">as.rankings</code></td>
<td>
<p>if <code>TRUE</code> return a rankings object, otherwise return
a matrix/vector.</p>
</td></tr>
<tr><td><code id="rankings_+3A_width">width</code></td>
<td>
<p>the width in number of characters to format each ranking -
rankings that are too wide will be truncated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each ranking in the input data will be converted to a dense ranking, which
rank items from 1 (first place) to <code class="reqn">n_r</code> (last place). Items not ranked
should have a rank of 0 or <code>NA</code>. Tied items are given the same rank with no
rank skipped. For example 1, 0, 2, 1, ranks the first and fourth items in
first place and the third item in second place; the second item is unranked.
</p>
<p>Records in <code>data</code> with missing <code>id</code> or <code>item</code> are dropped. Duplicated items
in the rankings are resolved if possible: redundant or inconsistent ranks
are set to <code>NA</code>. Rankings with only 1 item are set to <code>NA</code> (rankings with
zero items are automatically treated as <code>NA</code>). Any issues
causing records to be removed or recoded produce a message if
<code>verbose = TRUE</code>.
</p>
<p>For <code>as.rankings</code> with <code>input = "orderings"</code>, unused ranks may be filled with
zeroes for numeric <code>x</code> or <code>NA</code>. It is only necessary to have as many columns
as ranks that are used.
</p>
<p>The method for <code>[</code> will return a reduced rankings object by default,
recoding as dense rankings and setting invalid rankings to <code>NA</code> as necessary.
To extract rows and/or columns of the rankings as a matrix or vector,
set <code>as.rankings = FALSE</code>, see examples.
</p>


<h3>Value</h3>

<p>By default, a <code>"rankings"</code> object, which is a
matrix of dense rankings with methods for several generics including
<code><a href="#topic+aggregate.rankings">aggregate</a></code>, <code>[</code>, <code>format</code>, <code><a href="base.html#topic+rbind">rbind()</a></code> and
<code><a href="base.html#topic+as.matrix">as.matrix()</a></code>.
</p>
<p>If the object is created with <code>aggregate = TRUE</code>, or ranking frequencies are
specified via <code>freq</code>, the rankings are post-processed to create an
<code>"aggregated_rankings"</code> object.
</p>
<p>If a group index is specified via <code>index</code>, the (possibly aggregated) rankings
are post-processed to create a <code>"grouped_rankings"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create rankings from data in long form

# example long form data
x &lt;- data.frame(ranking = c(rep(1:4, each = 4), 5, 5, 5),
                letter = c(LETTERS[c(1:3, 3, 1:4, 2:5, 1:2, 1)], NA,
                           LETTERS[3:5]),
                rank = c(4:1, rep(NA, 4), 3:4, NA, NA, 1, 3, 4, 2, 2, 2, 3))

# ranking 1 has different rank for same item, but order of items unambiguous
# all ranks are missing in ranking 2
# some ranks are missing in ranking 3
# ranking 4 has inconsistent ranks for two items and a rank with missing item
# ranking 5 is fine - an example of a tie
split(x, x$ranking)

# fix issues when creating rankings object
rankings(x, id = "ranking", item = "letter", rank = "rank")

# convert existing matrix of rankings

R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")
R &lt;- as.rankings(R)

# first three rankings
R[1:3,]

# exclude pear from the rankings
R[, -4]

# extract rankings 2 and 3 as numeric matrix
R[2:3, , as.rankings = FALSE]

# same as
as.matrix(R)[2:3,]

# extract rankings for item 1 as a vector
R[,1, as.rankings = FALSE]

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+itempar'></span><span id='topic+qvcalc'></span><span id='topic+str'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>psychotools</dt><dd><p><code><a href="psychotools.html#topic+itempar">itempar</a></code></p>
</dd>
<dt>qvcalc</dt><dd><p><code><a href="qvcalc.html#topic+qvcalc">qvcalc</a></code></p>
</dd>
<dt>utils</dt><dd><p><code><a href="utils.html#topic+str">str</a></code></p>
</dd>
</dl>

<hr>
<h2 id='simulate.PlackettLuce'>Simulate from <code>PlackettLuce</code> fitted objects</h2><span id='topic+simulate.PlackettLuce'></span>

<h3>Description</h3>

<p>Simulate from <code>PlackettLuce</code> fitted objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PlackettLuce'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  multinomial = FALSE,
  max_combinations = 20000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.PlackettLuce_+3A_object">object</code></td>
<td>
<p>an object representing a fitted model.</p>
</td></tr>
<tr><td><code id="simulate.PlackettLuce_+3A_nsim">nsim</code></td>
<td>
<p>number of response vectors to simulate.  Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="simulate.PlackettLuce_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number
generator should be initialised. Either <code>NULL</code> or an
integer that will be used in a call to <code>set.seed</code> before
simulating the rankings. If set, the value is saved as the
<code>seed</code> attribute of the returned value.  The default,
<code>NULL</code>, will not change the random generator state, and
return <code>.Random.seed</code> as the <code>seed</code> attribute.</p>
</td></tr>
<tr><td><code id="simulate.PlackettLuce_+3A_multinomial">multinomial</code></td>
<td>
<p>use multinomial sampling anyway? Default is
<code>FALSE</code>. see Details.</p>
</td></tr>
<tr><td><code id="simulate.PlackettLuce_+3A_max_combinations">max_combinations</code></td>
<td>
<p>a positive number. Default is
<code>20000</code>. See Details.</p>
</td></tr>
<tr><td><code id="simulate.PlackettLuce_+3A_...">...</code></td>
<td>
<p>additional optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>multinomial</code> is <code>FALSE</code> (default) and there are no
tie parameters in the object (i.e. <code>length(object$ties) == 1</code>),
then rankings are sampled by ordering exponential random variates
with rate 1 scaled by the estimated item-worth parameters
<code>object$coefficients</code> (see, Diaconis, 1988, Chapter 9D for
details).
</p>
<p>In all other cases, the current implementation uses direct
multinomial sampling, and will throw an error if there are more
than <code>max_combinations</code> combinations of items that the sampler
has to decide from. This is a hard-coded exit to prevent issues
relating to the creation of massive objects in memory.
</p>
<p>If <code>length(object$ties) &gt; 1</code> the user's setting for
<code>multinomial</code> is ignored and <code>simulate.PlackettLuce</code> operates as if
<code>multinomial</code> is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of <code><a href="#topic+rankings">rankings</a></code> objects of the same
dimension as <code>object$rankings</code>.
</p>


<h3>References</h3>

<p>Diaconis (1988). <em>Group Representations in Probability and
Statistics</em>. Institute of Mathematical Statistics Lecture Notes
11. Hayward, CA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) &lt;- c("apple", "banana", "orange", "pear")
mod &lt;- PlackettLuce(R)
simulate(mod, 5)

s1 &lt;- simulate(mod, 3, seed = 112)
s2 &lt;- simulate(mod, 2, seed = 112)

identical(s1[1:2], s2[1:2])

</code></pre>

<hr>
<h2 id='summaries'>Plackett-Luce Model Summaries</h2><span id='topic+summaries'></span><span id='topic+coef.PlackettLuce'></span><span id='topic+summary.PlackettLuce'></span><span id='topic+vcov.PlackettLuce'></span>

<h3>Description</h3>

<p>Obtain the coefficients, model summary or coefficient variance-covariance
matrix for a model fitted by <code>PlackettLuce</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PlackettLuce'
coef(object, ref = 1L, log = TRUE, type = "all", ...)

## S3 method for class 'PlackettLuce'
summary(object, ref = 1L, ...)

## S3 method for class 'PlackettLuce'
vcov(object, ref = 1L, type = c("expected", "observed"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaries_+3A_object">object</code></td>
<td>
<p>An object of class &quot;PlackettLuce&quot; as returned by
<code>PlackettLuce</code>.</p>
</td></tr>
<tr><td><code id="summaries_+3A_ref">ref</code></td>
<td>
<p>An integer or character string specifying the reference item (for
which log worth will be set to zero). If <code>NULL</code> the sum of the log worth
parameters is set to zero.</p>
</td></tr>
<tr><td><code id="summaries_+3A_log">log</code></td>
<td>
<p>A logical indicating whether to return parameters on the log scale
with the item specified by <code>ref</code> set to zero.</p>
</td></tr>
<tr><td><code id="summaries_+3A_type">type</code></td>
<td>
<p>For <code>coef</code>, the type of coefficients to return: one of
<code>"ties"</code>, <code>"worth"</code> or <code>"all"</code>. For <code>vcov</code>, the type of
Fisher information to base the estimation on: either <code>"expected"</code> or
<code>"observed"</code>.</p>
</td></tr>
<tr><td><code id="summaries_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to <code>vcov</code> by <code>summary</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, parameters are returned on the log scale, as most suited for
inference. If <code>log = FALSE</code>, the worth parameters are returned,
constrained to sum to one so that they represent the probability that
the corresponding item comes first in a ranking of all items, given that
first place is not tied.
</p>
<p>The variance-covariance matrix is returned for the worth and tie parameters
on the log scale, with the reference as specified by <code>ref</code>. For models
estimated by maximum likelihood, the variance-covariance is the inverse of
the Fisher information of the log-likelihood.
</p>
<p>For models with a normal or gamma prior, the variance-covariance is based on
the Fisher information of the log-posterior. When adherence parameters have
been estimated, the log-posterior is not linear in the parameters. In this
case there is a difference between the expected and observed Fisher
information. By default, <code>vcov</code> will return the variance-covariance
based on the expected information, but <code>type</code> gives to option to use
the observed information instead. For large samples, the difference between
these options should be small. Note that the estimation of the adherence
parameters is accounted for in the computation of the variance-covariance
matrix, but only the sub-matrix corresponding to the worth and tie
parameters is estimated.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
