<!DOCTYPE html><html><head><title>Help for package RSurveillance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSurveillance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj.risk'><p>Adjusted risk</p></a></li>
<li><a href='#adj.risk.sim'><p>Adjusted risk for simulation models</p></a></li>
<li><a href='#ap'><p>Apparent prevalence</p></a></li>
<li><a href='#binom.agresti'><p>Agresti-Coull confidence limits</p></a></li>
<li><a href='#binom.cp'><p>Clopper-Pearson exact confidence limits</p></a></li>
<li><a href='#binom.jeffreys'><p>Jeffreys confidence limits</p></a></li>
<li><a href='#disc.prior'><p>Discounted prior probability of freedom</p></a></li>
<li><a href='#epi.calc'><p>Effective probability of infection (EPI)</p></a></li>
<li><a href='#n.2stage'><p>2-stage freedom sample size</p></a></li>
<li><a href='#n.ap'><p>Sample size for apparent prevalence</p></a></li>
<li><a href='#n.binom'><p>Binomial sample size</p></a></li>
<li><a href='#n.c.freecalc'><p>Freecalc optimum sample size and cut-point number</p>
of positives</a></li>
<li><a href='#n.c.hp'><p>Hypergeometric (HerdPlus) optimum sample size and cut-point number</p>
of positives</a></li>
<li><a href='#n.freecalc'><p>Freecalc sample size for a finite population and specified cut-point number of positives</p></a></li>
<li><a href='#n.freedom'><p>Freedom sample size</p></a></li>
<li><a href='#n.hp'><p>Hypergeometric (HerdPlus) sample size for finite population and specified cut-point number of positives</p></a></li>
<li><a href='#n.hypergeo'><p>Hypergeometric sample size</p></a></li>
<li><a href='#n.pfree'><p>Sample size to achieve desired (posterior) probability of freedom</p></a></li>
<li><a href='#n.pooled'><p>Sample size for pooled testing for freedom</p></a></li>
<li><a href='#n.rb'><p>Risk-based sample size</p></a></li>
<li><a href='#n.rb.2stage.1'><p>sample size for 2-stage risk-based surveillance, risk factor at cluster level only</p></a></li>
<li><a href='#n.rb.2stage.2'><p>Sample size for 2-stage risk-based surveillance, allowing for risk factors at either or both cluster and unit level</p></a></li>
<li><a href='#n.rb.varse'><p>Risk-based sample size for varying unit sensitivity</p></a></li>
<li><a href='#n.tp'><p>Sample size for true prevalence</p></a></li>
<li><a href='#pfree.1'><p>Probability of freedom for single time period</p></a></li>
<li><a href='#pfree.calc'><p>Probability of freedom over time</p></a></li>
<li><a href='#pfree.equ'><p>Equilibrium probability of freedom</p></a></li>
<li><a href='#pstar.calc'><p>Design prevalence back-calculation</p></a></li>
<li><a href='#se.parallel'><p>Sensitivity of tests in parallel</p></a></li>
<li><a href='#se.series'><p>Sensitivity of tests in series</p></a></li>
<li><a href='#sep'><p>Population sensitivity</p></a></li>
<li><a href='#sep.binom'><p>Binomial Population sensitivity</p></a></li>
<li><a href='#sep.binom.imperfect'><p>Binomial population sensitivity for imperfect test</p></a></li>
<li><a href='#sep.exact'><p>Population sensitivity for census (all units tested)</p></a></li>
<li><a href='#sep.freecalc'><p>FreeCalc population sensitivity  for imperfect test</p></a></li>
<li><a href='#sep.hp'><p>Hypergeometric (HerdPlus) population sensitivity for imperfect test</p></a></li>
<li><a href='#sep.hypergeo'><p>Hypergeometric Population sensitivity</p></a></li>
<li><a href='#sep.passive'><p>Passive surveillance sensitivity</p></a></li>
<li><a href='#sep.pfree'><p>Population sensitivity to achieve desired (posterior) probability of freedom</p></a></li>
<li><a href='#sep.pooled'><p>Pooled population sensitivity</p></a></li>
<li><a href='#sep.prior'><p>Population sensitivity to achieve desired prior probability of freedom</p></a></li>
<li><a href='#sep.rb.bin'><p>Binomial risk-based population sensitivity</p></a></li>
<li><a href='#sep.rb.bin.varse'><p>Binomial risk-based population sensitivity for varying unit sensitivity</p></a></li>
<li><a href='#sep.rb.hypergeo'><p>Hypergeometric risk-based population sensitivity</p></a></li>
<li><a href='#sep.rb.hypergeo.varse'><p>Hypergeometric risk-based population sensitivity for varying unit sensitivity</p></a></li>
<li><a href='#sep.rb2.binom'><p>Binomial risk-based population sensitivity for 2 risk factors</p></a></li>
<li><a href='#sep.rb2.hypergeo'><p>Hypergeometric risk-based population sensitivity for 2 risk factors</p></a></li>
<li><a href='#sep.sys'><p>2-stage population sensitivity</p></a></li>
<li><a href='#sep.var.se'><p>Population sensitivity for varying unit sensitivity</p></a></li>
<li><a href='#sp.parallel'><p>Specificity of tests in parallel</p></a></li>
<li><a href='#sp.series'><p>Specficity of tests in series</p></a></li>
<li><a href='#sph.binom'><p>Binomial population specificity for imperfect test</p></a></li>
<li><a href='#sph.hp'><p>Hypergeometric population specificity calculation</p></a></li>
<li><a href='#spp'><p>Population specificity</p></a></li>
<li><a href='#sse.combined'><p>System sensitivity by combining multiple surveillance components</p></a></li>
<li><a href='#sse.rb.2stage'><p>Two-stage risk-based system sensitivity</p></a></li>
<li><a href='#tp'><p>True prevalence</p></a></li>
<li><a href='#tp.normal'><p>Normal approximation confidence limits for true prevalence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Design and Analysis of Disease Surveillance Activities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-06-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Evan Sergeant</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rohan Sadler &lt;rohan.sadler@ausvet.com.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A range of functions for the design and
    analysis of disease surveillance activities. These functions were
    originally developed for animal health surveillance activities but can be
    equally applied to aquatic animal, wildlife, plant and human health
    surveillance activities. Utilities are included for sample size calculation
    and analysis of representative surveys for disease freedom, risk-based
    studies for disease freedom and for prevalence estimation.
    This package is based on Cameron A., Conraths F., Frohlich A., Schauer B.,
    Schulz K., Sergeant E., Sonnenburg J., Staubach C. (2015). R package of 
    functions for risk-based surveillance. Deliverable 6.24, WP 6 - Decision 
    making tools for implementing risk-based surveillance, Grant Number 
    no. 310806, RISKSUR (<a href="https://www.fp7-risksur.eu/sites/default/files/documents/Deliverables/RISKSUR_%28310806%29_D6.24.pdf">https://www.fp7-risksur.eu/sites/default/files/documents/Deliverables/RISKSUR_%28310806%29_D6.24.pdf</a>). 
    Many of the 'RSurveillance' functions are incorporated into the 'epitools'
    website: Sergeant, ESG, 2019. Epitools epidemiological calculators. 
    Ausvet Pty Ltd. Available at: <a href="http://epitools.ausvet.com.au">http://epitools.ausvet.com.au</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/roStats/RSurveillance">https://github.com/roStats/RSurveillance</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>epitools, epiR, stats, mc2d</td>
</tr>
<tr>
<td>Collate:</td>
<td>'adj_risk_sim.R' 'freedom_functions_1.R'
'freedom_functions_2.R' 'n_rb2stage.R' 'prevalence_functions.R'
'risk_based_functions.R' 'sep_passive.R' 'sse_rb2stage.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-30 03:29:37 UTC; rohansadler</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-30 09:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj.risk'>Adjusted risk</h2><span id='topic+adj.risk'></span>

<h3>Description</h3>

<p>Calculates adjusted risk for given 
relative risk and population proportions. This is an intermediate calculation
in the calculation of effective probability of infection for risk-based 
surveillance activities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj.risk(rr, ppr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj.risk_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector of values corresponding to the number of risk strata)</p>
</td></tr>
<tr><td><code id="adj.risk_+3A_ppr">ppr</code></td>
<td>
<p>population proportions corresponding to 
rr values (vector of equal length to rr)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of adjusted risk values (in order corresponding to rr)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for adj.risk
adj.risk(c(5, 1), c(0.1, 0.9))
adj.risk(c(5, 3, 1), c(0.1, 0.1, 0.8))
</code></pre>

<hr>
<h2 id='adj.risk.sim'>Adjusted risk for simulation models</h2><span id='topic+adj.risk.sim'></span>

<h3>Description</h3>

<p>Calculates adjusted risk for given 
relative risk and population proportions. This is an intermediate calculation
in the calculation of effective probability of infection for risk-based 
surveillance activities. This function is similar to Adj.risk, except is 
adapted for use with multiple simulations instead of single RR values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj.risk.sim(rr, ppr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj.risk.sim_+3A_rr">rr</code></td>
<td>
<p>relative risk values (matrix of values, columns corresponding 
to the number of risk strata, rows corresponding to number of iterations for simulation )</p>
</td></tr>
<tr><td><code id="adj.risk.sim_+3A_ppr">ppr</code></td>
<td>
<p>population proportions corresponding to 
rr values (vector of equal length to columns in rr)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of adjusted risk values (in order corresponding to rr)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for adj.risk.sim
its&lt;- 10
risk.cat&lt;- 3
rr&lt;- matrix(0, nrow=its, ncol=risk.cat)
rr[,1]&lt;- mc2d::rpert(its, 5,10,20)
rr[,2]&lt;- mc2d::rpert(its, 2,3,5)
rr[,3]&lt;- 1
ppr&lt;- c(0.05, 0.2, 0.75)
adj.risk.sim(rr, ppr)
adj.risk.sim(matrix(c(5, 3, 1), nrow=1), matrix(c(0.1, 0.1, 0.8), nrow=1))
</code></pre>

<hr>
<h2 id='ap'>Apparent prevalence</h2><span id='topic+ap'></span>

<h3>Description</h3>

<p>Estimates apparent prevalence and confidence limits for
given sample size and result, assuming representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ap(x, n, type = "wilson", conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ap_+3A_x">x</code></td>
<td>
<p>number of positives in sample</p>
</td></tr>
<tr><td><code id="ap_+3A_n">n</code></td>
<td>
<p>sample size, note: either x or n can be a vector, 
but at least one must be scalar</p>
</td></tr>
<tr><td><code id="ap_+3A_type">type</code></td>
<td>
<p>method for estimating CI, one of c(&quot;normal&quot;, &quot;exact&quot;, &quot;wilson&quot;, &quot;jeffreys&quot;, &quot;agresti-coull&quot;, &quot;all&quot;),
default = &quot;wilson&quot;</p>
</td></tr>
<tr><td><code id="ap_+3A_conf">conf</code></td>
<td>
<p>level of confidence required, default = 0.95 (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either 1) if type = &quot;all&quot;, a list with 5 elements, each element
a matrix with 6 columns, x, n, proportion, lower confidence limit,
upper confidence limit, confidence level and CI method; or
2) a matrix of results for the chosen method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for ap function
n&lt;- 200
x&lt;- 25
conf&lt;- 0.95
ap(x, n)
ap(seq(10, 100, 10), 200, type = "agresti")
ap(seq(10, 100, 10), 200, type = "all")
</code></pre>

<hr>
<h2 id='binom.agresti'>Agresti-Coull confidence limits</h2><span id='topic+binom.agresti'></span>

<h3>Description</h3>

<p>Calculates Agresti-Coull confidence limits for 
a simple proportion (apparent prevalence)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom.agresti(x, n, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom.agresti_+3A_x">x</code></td>
<td>
<p>number of positives in sample</p>
</td></tr>
<tr><td><code id="binom.agresti_+3A_n">n</code></td>
<td>
<p>sample size, note: either x or n can be a vector, 
but at least one must be scalar</p>
</td></tr>
<tr><td><code id="binom.agresti_+3A_conf">conf</code></td>
<td>
<p>level of confidence required, default 0.95 (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with 6 columns, x, n, proportion, lower confidence limit,
upper confidence limit, confidence level and CI method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test binom.agresti
binom.agresti(25, 200)
binom.agresti(seq(10, 100, 10), 200)
binom.agresti(50, seq(100, 1000, 100))
</code></pre>

<hr>
<h2 id='binom.cp'>Clopper-Pearson exact confidence limits</h2><span id='topic+binom.cp'></span>

<h3>Description</h3>

<p>Calculates Clopper-Pearson exact binomial confidence limits for 
a simple proportion (apparent prevalence)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom.cp(x, n, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom.cp_+3A_x">x</code></td>
<td>
<p>number of positives in sample</p>
</td></tr>
<tr><td><code id="binom.cp_+3A_n">n</code></td>
<td>
<p>sample size, note: either x or n can be a vector, 
but at least one must be scalar</p>
</td></tr>
<tr><td><code id="binom.cp_+3A_conf">conf</code></td>
<td>
<p>level of confidence required, default = 0.95 (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with 6 columns, x, n, proportion, lower confidence limit,
upper confidence limit, confidence level and CI method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test binom.cp
binom.cp(25, 200)
binom.cp(seq(10, 100, 10), 200)
binom.cp(50, seq(100, 1000, 100))
</code></pre>

<hr>
<h2 id='binom.jeffreys'>Jeffreys confidence limits</h2><span id='topic+binom.jeffreys'></span>

<h3>Description</h3>

<p>Calculates Jeffreys confidence limits for 
a simple proportion (apparent prevalence)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom.jeffreys(x, n, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom.jeffreys_+3A_x">x</code></td>
<td>
<p>number of positives in sample</p>
</td></tr>
<tr><td><code id="binom.jeffreys_+3A_n">n</code></td>
<td>
<p>sample size, note: either x or n can be a vector, 
but at least one must be scalar</p>
</td></tr>
<tr><td><code id="binom.jeffreys_+3A_conf">conf</code></td>
<td>
<p>level of confidence required, default = 0.95 (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with 6 columns, x, n, proportion, lower confidence limit,
upper confidence limit, confidence level and CI method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># test binom.jeffreys
binom.jeffreys(25, 200)
binom.jeffreys(seq(10, 100, 10), 200)
binom.jeffreys(50, seq(100, 1000, 100))
</code></pre>

<hr>
<h2 id='disc.prior'>Discounted prior probability of freedom</h2><span id='topic+disc.prior'></span>

<h3>Description</h3>

<p>Calculates the discounted prior probability of disease freedom,
after adjusting for the probability of disease exceeding the
design prevalence during the time period of the surveillance data being analysed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc.prior(prior, p.intro)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disc.prior_+3A_prior">prior</code></td>
<td>
<p>prior probability of freedom before surveillance</p>
</td></tr>
<tr><td><code id="disc.prior_+3A_p.intro">p.intro</code></td>
<td>
<p>probability of introduction
(or of prevalence exceeding the design prevalence) during the time period
(scalar or vector equal length to prior)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of discounted prior probabilities of freedom
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for disc.prior
disc.prior(0.5, 0.01)
disc.prior(0.95, c(0.001, 0.005, 0.01, 0.02, 0.05))
disc.prior(c(0.5, 0.6, 0.7, 0.8, 0.9, 0.95), 0.01)
</code></pre>

<hr>
<h2 id='epi.calc'>Effective probability of infection (EPI)</h2><span id='topic+epi.calc'></span>

<h3>Description</h3>

<p>Calculates effective probability of infection (adjusted design prevalence)
for each risk group for risk-based surveillance activities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epi.calc(pstar, rr, ppr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epi.calc_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="epi.calc_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector of values corresponding to 
the number of risk strata)</p>
</td></tr>
<tr><td><code id="epi.calc_+3A_ppr">ppr</code></td>
<td>
<p>population proportions corresponding to rr values 
(vector of equal length to rr)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2 elements, a vector of EPI values and a vector of corresponding
adjusted risks (in corresponding order to rr)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for epi.calc
epi.calc(0.1, c(5, 1), c(0.1, 0.9))
epi.calc(0.02, c(5, 3, 1), c(0.1, 0.1, 0.8))
</code></pre>

<hr>
<h2 id='n.2stage'>2-stage freedom sample size</h2><span id='topic+n.2stage'></span>

<h3>Description</h3>

<p>Calculates sample sizes for a 2-stage representative survey
(sampling of clusters and units within clusters) for disease freedom or detection,
assuming imperfect test sensitivity, perfect test specificity and representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.2stage(H = NA, N = NA, sep.sys = 0.95, sep.c, pstar.c, pstar.u,
  se = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.2stage_+3A_h">H</code></td>
<td>
<p>population size = number of clusters or NA if not known, default = NA</p>
</td></tr>
<tr><td><code id="n.2stage_+3A_n">N</code></td>
<td>
<p>population sizes for clusters, default = NA, scalar or
vector of population sizes for clusters</p>
</td></tr>
<tr><td><code id="n.2stage_+3A_sep.sys">sep.sys</code></td>
<td>
<p>desired population sensitivity (scalar)</p>
</td></tr>
<tr><td><code id="n.2stage_+3A_sep.c">sep.c</code></td>
<td>
<p>desired cluster-level sensitivity (scalar)</p>
</td></tr>
<tr><td><code id="n.2stage_+3A_pstar.c">pstar.c</code></td>
<td>
<p>specified cluster-level design prevalence as
proportion or integer (scalar)</p>
</td></tr>
<tr><td><code id="n.2stage_+3A_pstar.u">pstar.u</code></td>
<td>
<p>specified population-level design prevalence as
proportion or integer (scalar)</p>
</td></tr>
<tr><td><code id="n.2stage_+3A_se">se</code></td>
<td>
<p>unit sensitivity (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 2 elements, the number of clusters to sample and a vector of
sample sizes per cluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of n.2stage - checked
n.2stage(NA, NA, 0.95, 0.5, 0.01, 0.1, 0.95)
n.2stage(500, NA, 0.95, 0.5, 10, 0.1, 0.95)
n.2stage(1000, c(50, 100, 200, 500, 1000, 5000, NA), 0.95, 0.5, 0.01, 0.05, 0.8)
n.2stage(1000, c(50, 100, 200, 500, 1000, 5000, NA), 0.95, 0.5, 0.01, 1, 0.8)
n.2stage(1000, c(50, 100, 200, 500, 1000, 5000, NA), 0.9, 0.95, 1, 0.1, 0.8)
</code></pre>

<hr>
<h2 id='n.ap'>Sample size for apparent prevalence</h2><span id='topic+n.ap'></span>

<h3>Description</h3>

<p>Calculates sample size for estimating apparent 
prevalence (simple proportion)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.ap(p, precision, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.ap_+3A_p">p</code></td>
<td>
<p>expected proportion, scalar or vector of values</p>
</td></tr>
<tr><td><code id="n.ap_+3A_precision">precision</code></td>
<td>
<p>absolute precision, +/- proportion equivalent to
half the width of the desired confidence interval, scalar or vector of values,
note: at least one of p and precision must be a scalar</p>
</td></tr>
<tr><td><code id="n.ap_+3A_conf">conf</code></td>
<td>
<p>level of confidence required, default = 0.95 (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of sample sizes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of n.ap
n.ap(0.5, 0.1)
n.ap(0.5, 0.1, conf=0.99)
n.ap(seq(0.1, 0.5, by = 0.1), 0.05)
n.ap(0.2, c(0.01, 0.02, 0.05, 0.1))
</code></pre>

<hr>
<h2 id='n.binom'>Binomial sample size</h2><span id='topic+n.binom'></span>

<h3>Description</h3>

<p>Calculates sample size for demonstrating freedom or
detecting disease using binomial approach and assuming
imperfect test sensitivity, perfect test specificity and
representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.binom(sep, pstar, se = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.binom_+3A_sep">sep</code></td>
<td>
<p>desired population sensitivity (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.binom_+3A_pstar">pstar</code></td>
<td>
<p>specified design prevalence (scalar or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="n.binom_+3A_se">se</code></td>
<td>
<p>unit sensitivity, default = 1 (scalar or vector of same length as sep)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sample sizes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.binom - checked
n.binom(sep=0.95, pstar=c(0.01, 0.02, 0.05, 0.1, 0.2))
n.binom(c(0.5, 0.8, 0.9, 0.95), 0.01)
</code></pre>

<hr>
<h2 id='n.c.freecalc'>Freecalc optimum sample size and cut-point number 
of positives</h2><span id='topic+n.c.freecalc'></span>

<h3>Description</h3>

<p>Calculates optimum sample size and cut-point number of positives 
to achieve specified population sensitivity, for 
given population size and other parameters, using freecalc algorithm, 
all paramaters must be scalars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.c.freecalc(N, sep = 0.95, c = 1, se, sp = 1, pstar,
  minSpH = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.c.freecalc_+3A_n">N</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="n.c.freecalc_+3A_sep">sep</code></td>
<td>
<p>target population sensitivity</p>
</td></tr>
<tr><td><code id="n.c.freecalc_+3A_c">c</code></td>
<td>
<p>The maximum allowed cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, &gt;= c is positive</p>
</td></tr>
<tr><td><code id="n.c.freecalc_+3A_se">se</code></td>
<td>
<p>test unit sensitivity</p>
</td></tr>
<tr><td><code id="n.c.freecalc_+3A_sp">sp</code></td>
<td>
<p>test unit specificity, default=1</p>
</td></tr>
<tr><td><code id="n.c.freecalc_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion or integer (number of infected units)</p>
</td></tr>
<tr><td><code id="n.c.freecalc_+3A_minsph">minSpH</code></td>
<td>
<p>minimium desired population specificity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 3 elements, a dataframe with 1 row and six columns for
the recommended sample size and corresponding values for population sensitivity (SeP),
population specificity (SpP), N, c and pstar, a vector of SeP values
and a vector of SpP values, for n = 1:N
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.c.hp
n.c.freecalc(120,0.95,c=5,se=0.9,sp=0.99,pstar=0.1, minSpH=0.9)[[1]]
n.c.freecalc(65,0.95,c=5,se=0.95,sp=0.99,pstar=0.05, minSpH=0.9)
</code></pre>

<hr>
<h2 id='n.c.hp'>Hypergeometric (HerdPlus) optimum sample size and cut-point number 
of positives</h2><span id='topic+n.c.hp'></span>

<h3>Description</h3>

<p>Calculates optimum sample size and cut-point positives 
to achieve specified population sensitivity, for 
given population size and other parameters, all paramaters must be scalars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.c.hp(N, sep = 0.95, c = 1, se, sp = 1, pstar, minSpH = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.c.hp_+3A_n">N</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="n.c.hp_+3A_sep">sep</code></td>
<td>
<p>target population sensitivity</p>
</td></tr>
<tr><td><code id="n.c.hp_+3A_c">c</code></td>
<td>
<p>The maximum allowed cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, &gt;= c is positive</p>
</td></tr>
<tr><td><code id="n.c.hp_+3A_se">se</code></td>
<td>
<p>test unit sensitivity</p>
</td></tr>
<tr><td><code id="n.c.hp_+3A_sp">sp</code></td>
<td>
<p>test unit specificity, default=1</p>
</td></tr>
<tr><td><code id="n.c.hp_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion or integer (number of infected units)</p>
</td></tr>
<tr><td><code id="n.c.hp_+3A_minsph">minSpH</code></td>
<td>
<p>minimium desired population specificity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 3 elements, a dataframe with 1 row and six columns for
the recommended sample size and corresponding values for population sensitivity (SeP),
population specificity (SpP), N, c and pstar, a vector of SeP values
and a vector of SpP values, for n = 1:N
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.c.hp
n.c.hp(65,0.95,c=5,se=0.95,sp=0.99,pstar=0.05, minSpH=0.9)[[1]]
tmp&lt;- n.c.hp(120,0.95,c=5,se=0.9,sp=0.99,pstar=0.1, minSpH=0.9)
</code></pre>

<hr>
<h2 id='n.freecalc'>Freecalc sample size for a finite population and specified cut-point number of positives</h2><span id='topic+n.freecalc'></span>

<h3>Description</h3>

<p>Calculates sample size required for a specified population sensitivity,
for a given population size, cut-point number of positives and other parameters, 
using Freecalc algorithm. All paramaters must be scalars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.freecalc(N, sep = 0.95, c = 1, se, sp = 1, pstar, minSpH = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.freecalc_+3A_n">N</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="n.freecalc_+3A_sep">sep</code></td>
<td>
<p>target population sensitivity</p>
</td></tr>
<tr><td><code id="n.freecalc_+3A_c">c</code></td>
<td>
<p>The cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, &gt;= c is positive</p>
</td></tr>
<tr><td><code id="n.freecalc_+3A_se">se</code></td>
<td>
<p>test unit sensitivity</p>
</td></tr>
<tr><td><code id="n.freecalc_+3A_sp">sp</code></td>
<td>
<p>test unit specificity, default=1</p>
</td></tr>
<tr><td><code id="n.freecalc_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion or integer (number of infected units)</p>
</td></tr>
<tr><td><code id="n.freecalc_+3A_minsph">minSpH</code></td>
<td>
<p>minimium desired population specificity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 2 elements, a dataframe with 1 row and six columns for
the recommended sample size and corresponding values for population sensitivity (SeP),
population specificity (SpP), N, c and pstar
and a dataframe of n rows with SeP and SpP values for each value of n up to the recommended value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.freecalc
n.freecalc(65,0.95,c=1,se=0.95,sp=0.99,pstar=0.05, minSpH=0.9)[[1]]
n.freecalc(65,0.95,c=2,se=0.95,sp=0.99,pstar=0.05, minSpH=0.9)[[1]]
n.freecalc(65,0.95,c=3,se=0.95,sp=0.99,pstar=0.05, minSpH=0.9)
</code></pre>

<hr>
<h2 id='n.freedom'>Freedom sample size</h2><span id='topic+n.freedom'></span>

<h3>Description</h3>

<p>Calculates sample size for demonstrating freedom or
detecting disease using the appropriate method, depending on
whether or not N provided (hypergeometric if N provided, binomial otherwise),
assuming imperfect test sensitivity, perfect test specificity
and representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.freedom(N = NA, sep = 0.95, pstar, se = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.freedom_+3A_n">N</code></td>
<td>
<p>population size, default = NA (unknown) (scalar or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="n.freedom_+3A_sep">sep</code></td>
<td>
<p>desired population sensitivity (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.freedom_+3A_pstar">pstar</code></td>
<td>
<p>specified design prevalence as proportion or integer
(scalar or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="n.freedom_+3A_se">se</code></td>
<td>
<p>unit sensitivity (scalar or vector of same length as sep)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sample sizes, NA if N is specified and n&gt;N
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.freedom - checked
n.freedom(NA, sep=0.95, pstar=0.01, se=1)
n.freedom(500, sep=0.95, pstar=0.01, se=1)
n.freedom(N=c(100, 500, 1000, 5000, 10000, 100000, NA), sep=0.95, pstar=0.01, se=1)
n.freedom(500, sep=0.95, pstar=0.01, se=c(0.5, 0.6, 0.7, 0.8, 0.9, 0.99, 1))
</code></pre>

<hr>
<h2 id='n.hp'>Hypergeometric (HerdPlus) sample size for finite population and specified cut-point number of positives</h2><span id='topic+n.hp'></span>

<h3>Description</h3>

<p>Calculates sample size to achieve specified population sensitivity with
population specificity &gt;= specified minimum value,
for given population size, cut-point number of positives and other parameters, 
all paramaters must be scalars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.hp(N, sep = 0.95, c = 1, se, sp = 1, pstar, minSpH = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.hp_+3A_n">N</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="n.hp_+3A_sep">sep</code></td>
<td>
<p>target population sensitivity</p>
</td></tr>
<tr><td><code id="n.hp_+3A_c">c</code></td>
<td>
<p>The cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, &gt;= c is positive</p>
</td></tr>
<tr><td><code id="n.hp_+3A_se">se</code></td>
<td>
<p>test unit sensitivity</p>
</td></tr>
<tr><td><code id="n.hp_+3A_sp">sp</code></td>
<td>
<p>test unit specificity, default=1</p>
</td></tr>
<tr><td><code id="n.hp_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion or integer (number of infected units)</p>
</td></tr>
<tr><td><code id="n.hp_+3A_minsph">minSpH</code></td>
<td>
<p>minimium desired population specificity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements, a dataframe with 1 row and six columns for
the recommended sample size and corresponding values for population sensitivity (SeP),
population specificity (SpP), N, c and pstar and a dataframe of n rows 
with SeP and SpP values for each value of n up to the recommended value.
Returns sample size for maximum achievable sep if it is not possible to 
achieve target sep AND SpP&gt;= minSpH.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.hp
n.hp(65,0.95,c=1,se=0.95,sp=0.99,pstar=0.05, minSpH=0.9)[[1]]
n.hp(65,0.95,c=2,se=0.95,sp=0.99,pstar=0.05, minSpH=0.9)
</code></pre>

<hr>
<h2 id='n.hypergeo'>Hypergeometric sample size</h2><span id='topic+n.hypergeo'></span>

<h3>Description</h3>

<p>Calculates sample size for demonstrating freedom or
detecting disease using hypergeometric approximation and assuming
imperfect test sensitivity, perfect test specificity and
representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.hypergeo(sep, N, d, se = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.hypergeo_+3A_sep">sep</code></td>
<td>
<p>desired population sensitivity (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.hypergeo_+3A_n">N</code></td>
<td>
<p>population size (scalar or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="n.hypergeo_+3A_d">d</code></td>
<td>
<p>expected number of infected units in population, = design prevalence*N
rounded to next integer (scalar or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="n.hypergeo_+3A_se">se</code></td>
<td>
<p>unit sensitivity, default = 1 (scalar or vector of same length as sep)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sample sizes, NA if n&gt;N
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.hypergeo - checked
n.hypergeo(0.95, N=100, d=1, se = 0.95)
n.hypergeo(sep=0.95, N=c(100, 200, 500, 1000, 10000), d=ceiling(0.01*c(100, 200, 500, 1000, 10000)))
n.hypergeo(c(0.5, 0.8, 0.9, 0.95), N=100, d=5)
n.hypergeo(0.95, N=80, d=c(1, 2, 5, 10))
n.hypergeo(0.95, N=80, d=c(1, 2, 5, 10), se = 0.8)
</code></pre>

<hr>
<h2 id='n.pfree'>Sample size to achieve desired (posterior) probability of freedom</h2><span id='topic+n.pfree'></span>

<h3>Description</h3>

<p>Calculates the sample size required to achieve a
given value for probability of disease freedom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.pfree(pfree, prior, p.intro, pstar, se, N = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.pfree_+3A_pfree">pfree</code></td>
<td>
<p>desired probability of freedom (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.pfree_+3A_prior">prior</code></td>
<td>
<p>prior probability of freedom before surveillance (scalar
or vector of same length as pfree)</p>
</td></tr>
<tr><td><code id="n.pfree_+3A_p.intro">p.intro</code></td>
<td>
<p>probability of introduction for time period (scalar
or vector of same length as pfree)</p>
</td></tr>
<tr><td><code id="n.pfree_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar
or vector of same length as pfree)</p>
</td></tr>
<tr><td><code id="n.pfree_+3A_se">se</code></td>
<td>
<p>unit sensitivity (scalar
or vector of same length as pfree)</p>
</td></tr>
<tr><td><code id="n.pfree_+3A_n">N</code></td>
<td>
<p>population size (scalar
or vector of same length as pfree)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 3 elements, the first a vector of sample sizes
and the second a corresponding vector of population sensitivity values
and the third a vector of adjusted priors
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.pfree
n.pfree(0.95, 0.5, 0.01, 0.05, 0.9)
n.pfree(0.95, 0.5, 0.01, 0.05, 0.9, N=300)
n.pfree(pfree = c(0.9, 0.95, 0.98, 0.99), prior = 0.7, 0.01, 0.01, 0.8, 1000)
n.pfree(0.95, 0.7, 0.01, 0.1, 0.96)
</code></pre>

<hr>
<h2 id='n.pooled'>Sample size for pooled testing for freedom</h2><span id='topic+n.pooled'></span>

<h3>Description</h3>

<p>Calculates sample size to achieve desired
population-level sensitivity, assuming pooled sampling
and allowing for imperfect sensitivity and specificity of the pooled test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.pooled(sep, k, pstar, pse, psp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.pooled_+3A_sep">sep</code></td>
<td>
<p>desired population sensitivity (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.pooled_+3A_k">k</code></td>
<td>
<p>pool size (constant across pools) (scalar or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="n.pooled_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="n.pooled_+3A_pse">pse</code></td>
<td>
<p>pool-level sensitivity (scalar or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="n.pooled_+3A_psp">psp</code></td>
<td>
<p>pool-level specificity (scalar or vector of same length as sep)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of sample sizes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.pooled
n.pooled(0.95, 5, 0.01, 1, 1)
n.pooled(0.95, 10, 0.1, 0.9, 1)
n.pooled(0.95, c(2, 5, 10, 20), 0.1, c(0.99, 0.98, 0.97, 0.95), 1)
</code></pre>

<hr>
<h2 id='n.rb'>Risk-based sample size</h2><span id='topic+n.rb'></span>

<h3>Description</h3>

<p>Calculates sample size for risk-based sampling 
for a single risk factor and using binomial method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.rb(pstar, rr, ppr, spr, se, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.rb_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="n.rb_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector, length equal to the number of risk strata)</p>
</td></tr>
<tr><td><code id="n.rb_+3A_ppr">ppr</code></td>
<td>
<p>population proportions corresponding to rr values 
(vector of equal length to rr)</p>
</td></tr>
<tr><td><code id="n.rb_+3A_spr">spr</code></td>
<td>
<p>planned surveillance proportion for each risk group 
(vector equal length to rr, ppr)</p>
</td></tr>
<tr><td><code id="n.rb_+3A_se">se</code></td>
<td>
<p>unit sensitivity (fixed or vector same length as rr, ppr, n)</p>
</td></tr>
<tr><td><code id="n.rb_+3A_sep">sep</code></td>
<td>
<p>required population sensitivity (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2 elements, a vector of sample sizes for each risk group
a scalar of total sample size, a vector of EPI values and a vector of
adjusted risks
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.rb
n.rb(0.1, c(5, 3, 1), c(0.1, 0.10, 0.80), c(0.5, 0.3, 0.2), 0.9, 0.95)
n.rb(0.01, c(5, 1), c(0.1, 0.9), c(0.8, 0.2), c(0.9, 0.95), 0.95)
</code></pre>

<hr>
<h2 id='n.rb.2stage.1'>sample size for 2-stage risk-based surveillance, risk factor at cluster level only</h2><span id='topic+n.rb.2stage.1'></span>

<h3>Description</h3>

<p>Calculates sample size required (clusters and units)
for a 2-stage risk-based survey with a single risk factor at the 
cluster level only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.rb.2stage.1(rr, ppr, spr, pstar.c, pstar.u, se = 1, sep.c = 0.95,
  sep.sys = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.rb.2stage.1_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector of values, corresponding 
to the number of risk strata)</p>
</td></tr>
<tr><td><code id="n.rb.2stage.1_+3A_ppr">ppr</code></td>
<td>
<p>population proportions corresponding to 
rr values (vector of equal length to rr)</p>
</td></tr>
<tr><td><code id="n.rb.2stage.1_+3A_spr">spr</code></td>
<td>
<p>planned surveillance proportions corresponding to 
rr values - the proportions of the total sample to be collected 
from each risk stratum (vector of equal length to rr).</p>
</td></tr>
<tr><td><code id="n.rb.2stage.1_+3A_pstar.c">pstar.c</code></td>
<td>
<p>cluster (herd) level design prevalence, scalar,
either proportion or integer</p>
</td></tr>
<tr><td><code id="n.rb.2stage.1_+3A_pstar.u">pstar.u</code></td>
<td>
<p>unit (animal) level design prevalence, scalar,
either proportion or integer</p>
</td></tr>
<tr><td><code id="n.rb.2stage.1_+3A_se">se</code></td>
<td>
<p>unit sensitivity of test (proportion), scalar, default = 1</p>
</td></tr>
<tr><td><code id="n.rb.2stage.1_+3A_sep.c">sep.c</code></td>
<td>
<p>desired cluster-level sensitivity (proportion), scalar, default = 0.95</p>
</td></tr>
<tr><td><code id="n.rb.2stage.1_+3A_sep.sys">sep.sys</code></td>
<td>
<p>desired population-level sensitivity (proportion), scalar, default = 0.95</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of seven elements: 1) a vector (of the same length as rr) of the 
numbers of clusters to sample from each risk stratum, 2) the total number of clusters
to be sampled, 3) a vector of EPI values for each risk stratum, 
4) a vector of adjusted risk values for each risk stratum,
5) the number of untis to be sampled per cluster
6) a vector of the total numbers of units to be sampled for each risk stratum
7) the overall total number of units to be sampled
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rr&lt;- c(5,3,1)
ppr&lt;- c(0.1, 0.2, 0.7)
spr&lt;- c(0.4, 0.4, 0.2)
n.rb.2stage.1(rr, ppr, spr, pstar.c=0.01, pstar.u=0.1, se =0.9, sep.c=0.8, sep.sys=0.95) 
n.rb.2stage.1(c(3,1), c(0.2,0.8), c(0.7,0.3),0.05, 0.1, 0.9, 0.95, 0.99)
</code></pre>

<hr>
<h2 id='n.rb.2stage.2'>Sample size for 2-stage risk-based surveillance, allowing for risk factors at either or both cluster and unit level</h2><span id='topic+n.rb.2stage.2'></span>

<h3>Description</h3>

<p>Calculates sample size required (clusters and units)
for a 2-stage risk-based survey with risk factors at either 
cluster level or unit level, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.rb.2stage.2(rr.c, ppr.c, spr.c, pstar.c, rr.u = 1, ppr.u = 1,
  spr.u = 1, pstar.u, se = 1, sep.c = 0.95, sep.sys = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.rb.2stage.2_+3A_rr.c">rr.c</code></td>
<td>
<p>relative risk values at the cluster level (vector of values, corresponding 
to the number of risk strata)</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_ppr.c">ppr.c</code></td>
<td>
<p>population proportions at the cluster level, corresponding to 
rr.c values (vector of equal length to rr.c)</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_spr.c">spr.c</code></td>
<td>
<p>planned surveillance proportions at the cluster level, corresponding to 
rr.c values - the proportions of the total sample to be collected 
from each risk stratum (vector of equal length to rr.c).</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_pstar.c">pstar.c</code></td>
<td>
<p>cluster (herd) level design prevalence, scalar,
either proportion or integer</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_rr.u">rr.u</code></td>
<td>
<p>relative risk values at the unit level (vector of values, corresponding 
to the number of risk strata)</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_ppr.u">ppr.u</code></td>
<td>
<p>population proportions at the unit level, corresponding to 
rr.u values (vector of equal length to rr.u)</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_spr.u">spr.u</code></td>
<td>
<p>planned surveillance proportions at the unit level, corresponding to 
rr.u values - the proportions of the total sample to be collected 
from each risk stratum (vector of equal length to rr.u).</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_pstar.u">pstar.u</code></td>
<td>
<p>unit (animal) level design prevalence, scalar,
either proportion or integer</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_se">se</code></td>
<td>
<p>unit sensitivity of test (proportion), scalar, default = 1</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_sep.c">sep.c</code></td>
<td>
<p>desired cluster-level sensitivity (proportion), scalar, default = 0.95</p>
</td></tr>
<tr><td><code id="n.rb.2stage.2_+3A_sep.sys">sep.sys</code></td>
<td>
<p>desired population-level sensitivity (proportion), scalar, default = 0.95</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cluster and unit level results number of clusters/units to 
sample per risk stratum, the total number of clusters or units per cluster to be sampled and
vectors of EPI and adjusted risk values for each risk stratum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rr.c&lt;- c(5,3,1)
ppr.c&lt;- c(0.1, 0.2, 0.7)
spr.c&lt;- c(0.4, 0.4, 0.2)
rr.u&lt;- c(4,1)
ppr.u&lt;- c(0.1, 0.9)
spr.u&lt;- c(1, 0)
n.rb.2stage.2(rr.c, ppr.c, spr.c, pstar.c=0.02, rr.u, ppr.u, 
  spr.u, 0.1, se=0.9, sep.c=0.5, sep.sys=0.95) 
n.rb.2stage.2(c(3,1), c(0.2,0.8), c(0.7,0.3), pstar.c=0.05, 
  pstar.u=0.1, se=0.9, sep.c=0.95, sep.sys=0.99)
</code></pre>

<hr>
<h2 id='n.rb.varse'>Risk-based sample size for varying unit sensitivity</h2><span id='topic+n.rb.varse'></span>

<h3>Description</h3>

<p>Calculates sample size for risk-based sampling 
for a single risk factor and varying unit sensitivity, 
using binomial method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.rb.varse(pstar, rr, ppr, spr, se, spr.rg, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.rb.varse_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="n.rb.varse_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector, length equal to the number of risk strata)</p>
</td></tr>
<tr><td><code id="n.rb.varse_+3A_ppr">ppr</code></td>
<td>
<p>population proportions for each risk group,
vector of same length as rr</p>
</td></tr>
<tr><td><code id="n.rb.varse_+3A_spr">spr</code></td>
<td>
<p>planned surveillance proportions for each risk group,
vector of same length as rr</p>
</td></tr>
<tr><td><code id="n.rb.varse_+3A_se">se</code></td>
<td>
<p>unit sensitivities (vector of group values)</p>
</td></tr>
<tr><td><code id="n.rb.varse_+3A_spr.rg">spr.rg</code></td>
<td>
<p>proportions of samples for each sensitivity value 
in each risk group (matrix with rows = risk groups, columns = sensitivity values),
row sums must equal 1</p>
</td></tr>
<tr><td><code id="n.rb.varse_+3A_sep">sep</code></td>
<td>
<p>required population sensitivity (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 3 elements, a matrix of sample sizes for each risk 
and sensitivity group, a vector of EPI values and a vector of 
mean sensitivity for each risk group
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.rb.varse
m&lt;- rbind(c(0.8, 0.2), c(0.5, 0.5), c(0.7, 0.3))
n.rb.varse(0.01, c(5, 3, 1), c(0.1, 0.1, 0.8), c(0.4, 0.4, 0.2), c(0.92, 0.8), m, 0.95)

m&lt;- rbind(c(0.8, 0.2), c(0.6, 0.4))
n.rb.varse(0.05, c(3, 1), c(0.2, 0.8), c(0.7, 0.3), c(0.95, 0.8), m, 0.95)

m&lt;- rbind(c(1), c(1))
n.rb.varse(0.05, c(3, 1), c(0.2, 0.8), c(0.7, 0.3), c(0.95), m, 0.99)
</code></pre>

<hr>
<h2 id='n.tp'>Sample size for true prevalence</h2><span id='topic+n.tp'></span>

<h3>Description</h3>

<p>Calculates sample size for estimating true prevalence 
using normal approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.tp(p, se, sp, precision, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.tp_+3A_p">p</code></td>
<td>
<p>estimated true prevalence (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.tp_+3A_se">se</code></td>
<td>
<p>test sensitivity (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.tp_+3A_sp">sp</code></td>
<td>
<p>test specificity (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.tp_+3A_precision">precision</code></td>
<td>
<p>absolute precision, +/- proportion equal to
half the width of the desired confidence interval (scalar or vector)</p>
</td></tr>
<tr><td><code id="n.tp_+3A_conf">conf</code></td>
<td>
<p>desired level of confidence for CI, default = 0.95 (scalar or vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of sample sizes
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for n.tp
n.tp(0.1, 0.9, 0.99, 0.05)
n.tp(0.1, 0.9, 0.99, 0.05, conf = 0.99)
n.tp(c(0.05, 0.1, 0.2, 0.3, 0.4, 0.5), 0.9, 0.99, 0.05)
n.tp(0.5, 0.9, 0.99, c(0.01, 0.02, 0.05, 0.1, 0.2))
</code></pre>

<hr>
<h2 id='pfree.1'>Probability of freedom for single time period</h2><span id='topic+pfree.1'></span>

<h3>Description</h3>

<p>Calculates the posterior probability (confidence) of disease
freedom (negative predictive value) for a single time period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfree.1(sep, p.intro, prior = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfree.1_+3A_sep">sep</code></td>
<td>
<p>population sensitivity for time period (scalar or
vector)</p>
</td></tr>
<tr><td><code id="pfree.1_+3A_p.intro">p.intro</code></td>
<td>
<p>probability of introduction for time period (scalar
or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="pfree.1_+3A_prior">prior</code></td>
<td>
<p>prior probability of freedom before surveillance (scalar
or vector of same length as sep)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with columns for sep, p.intro, discounted
prior, pfree, pfree.equ and prior.equ
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for pfree.1
pfree.1(0.8, 0.01, 0.5)
pfree.1(0.6, c(0.001, 0.005, 0.01, 0.02, 0.05), 0.5)
pfree.1(runif(10, 0.4, 0.6), 0.01, 0.5)
pfree.1(runif(10, 0.4, 0.6), runif(10, 0.005, 0.015), 0.5)
</code></pre>

<hr>
<h2 id='pfree.calc'>Probability of freedom over time</h2><span id='topic+pfree.calc'></span>

<h3>Description</h3>

<p>Calculates the probability (confidence) of disease freedom for
given prior, sep and p.intro over 1 or more time periods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfree.calc(sep, p.intro, prior = 0.5, discount.1 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfree.calc_+3A_sep">sep</code></td>
<td>
<p>population sensitivity for each time period (vector)</p>
</td></tr>
<tr><td><code id="pfree.calc_+3A_p.intro">p.intro</code></td>
<td>
<p>probability of introduction for each time period (scalar
or vector of same length as sep)</p>
</td></tr>
<tr><td><code id="pfree.calc_+3A_prior">prior</code></td>
<td>
<p>prior probability of freedom before surveillance (scalar)</p>
</td></tr>
<tr><td><code id="pfree.calc_+3A_discount.1">discount.1</code></td>
<td>
<p>logical variable whether or not to discount first time period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with columns for sep, p.intro, discounted
prior, probability of freedom, equilibrium probability of freedom
and equilibrium prior
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for pfree.calc
pfree.calc(0.8, 0.01, 0.5)
pfree.calc(0.8, 0.01, 0.5, FALSE)
pfree.calc(rep(0.6,24), 0.01, 0.5)
pfree.calc(rep(0.6,24), 0.01, 0.5, FALSE)
pfree.calc(runif(10, 0.4, 0.6), 0.01, 0.5)
pfree.calc(runif(10, 0.4, 0.6), runif(10, 0.005, 0.015), 0.5)
</code></pre>

<hr>
<h2 id='pfree.equ'>Equilibrium probability of freedom</h2><span id='topic+pfree.equ'></span>

<h3>Description</h3>

<p>Calculates equilibrium probability of disease freedom and
equilibrium prior probability of freedom, after discounting for
probability of introduction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfree.equ(sep, p.intro)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfree.equ_+3A_sep">sep</code></td>
<td>
<p>population sensitivity for time period (scalar or
vector)</p>
</td></tr>
<tr><td><code id="pfree.equ_+3A_p.intro">p.intro</code></td>
<td>
<p>probability of introduction for time period (scalar
or vector of same length as sep)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 2 vectors, equilibrium posterior probability of freedom
and equilibrium prior (discounted) probability of freedom
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of pfree.equ
pfree.equ(runif(10, 0.4, 0.6), 0.01)
pfree.equ(0.8, 0.05)
pfree.equ(rep(0.9, 6), c(0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05))
</code></pre>

<hr>
<h2 id='pstar.calc'>Design prevalence back-calculation</h2><span id='topic+pstar.calc'></span>

<h3>Description</h3>

<p>Calculates design prevalence required for given sample size and
desired population-level sensitivity, assuming
imperfect test sensitivity, perfect test specificity and
representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pstar.calc(N = NA, n, sep, se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pstar.calc_+3A_n">N</code></td>
<td>
<p>populaton size if known (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="pstar.calc_+3A_n">n</code></td>
<td>
<p>sample size (scalar or vector)</p>
</td></tr>
<tr><td><code id="pstar.calc_+3A_sep">sep</code></td>
<td>
<p>desired population sensitivity (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="pstar.calc_+3A_se">se</code></td>
<td>
<p>unit sensitivity (scalar or vector of same length as n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of design prevalence values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of pstar.calc- checked
pstar.calc(NA, 280, 0.95, 0.98)
pstar.calc(500, 250, sep=0.95, se=1)
pstar.calc(N=c(100, 500, 1000, 5000, 10000, 100000, NA), n=30, sep=0.95, se=1)
pstar.calc(500, n=30, sep=0.95, se=c(0.5, 0.6, 0.7, 0.8, 0.9, 0.99, 1))
</code></pre>

<hr>
<h2 id='se.parallel'>Sensitivity of tests in parallel</h2><span id='topic+se.parallel'></span>

<h3>Description</h3>

<p>Calculates the combined sensitivity for multiple tests
interpreted in parallel (assuming independence)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se.parallel(se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se.parallel_+3A_se">se</code></td>
<td>
<p>vector of unit sensitivity values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar of combined sensitivity, assuming independence
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for se.parallel
se.parallel(c(0.99, 0.95, 0.8))
</code></pre>

<hr>
<h2 id='se.series'>Sensitivity of tests in series</h2><span id='topic+se.series'></span>

<h3>Description</h3>

<p>Calculates the combined sensitivity for multiple tests
interpreted in series (assuming independence)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se.series(se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se.series_+3A_se">se</code></td>
<td>
<p>vector of unit sensitivity values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar of combined sensitivity, assuming independence
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for se.series
se.series(c(0.99, 0.95, 0.8))
</code></pre>

<hr>
<h2 id='sep'>Population sensitivity</h2><span id='topic+sep'></span>

<h3>Description</h3>

<p>Calculates population sensitivity using appropriate method,
depending on whether or not N provided (hypergeometric if N provided,
binomial otherwise), assuming perfect
test specificity and representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep(N = NA, n, pstar, se = 1, dig = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep_+3A_n">N</code></td>
<td>
<p>population size, NA or vector of same length as n</p>
</td></tr>
<tr><td><code id="sep_+3A_n">n</code></td>
<td>
<p>sample size (number tested), scalar or vector</p>
</td></tr>
<tr><td><code id="sep_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion or integer, scalar
or vector of same length as n</p>
</td></tr>
<tr><td><code id="sep_+3A_se">se</code></td>
<td>
<p>unit sensitivity, scalar or vector of same length as n</p>
</td></tr>
<tr><td><code id="sep_+3A_dig">dig</code></td>
<td>
<p>number of digits for rounding of results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level sensitivities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep - checked
sep(n=300, pstar=0.01, se=1)
sep(NA, 300, 0.01, 1)
sep(10000, 150, 0.02, 1)
sep(n=1:100, pstar = 0.05, se=0.95)
N&lt;- seq(30, 100, by = 5)
se&lt;- 0.95
pstar&lt;- 0.1
n&lt;- rep(30, length(N))
sep(N, n, pstar, se = se)
sep(rep(100, 10), seq(10, 100, by = 10), pstar = 1, se=0.99)
N&lt;- c(55, 134, NA, 44, 256)
n&lt;- c(15, 30, 28, 15, 33)
sep(N, n, 0.1, 0.95)
</code></pre>

<hr>
<h2 id='sep.binom'>Binomial Population sensitivity</h2><span id='topic+sep.binom'></span>

<h3>Description</h3>

<p>Calculates population sensitivity for detecting disease,
assuming imperfect test sensitivity and specificity and representative sampling,
using binomial distribution (assumes large or unknown population size and that
cut-point number of reactors for a positive result = 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.binom(n, pstar, se = 1, sp = 1, dig = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.binom_+3A_n">n</code></td>
<td>
<p>sample size = number of units tested (integer), scalar or vector</p>
</td></tr>
<tr><td><code id="sep.binom_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sep.binom_+3A_se">se</code></td>
<td>
<p>unit sensitivity of test (proportion), default = 1 (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sep.binom_+3A_sp">sp</code></td>
<td>
<p>unit specificity of test (proportion), default = 1 (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sep.binom_+3A_dig">dig</code></td>
<td>
<p>number of digits for rounding of results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of population-level sensitivities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.binom - checked
sep.binom(n=300, pstar = 0.02, se = 0.92)
tested&lt;- seq(10,100, by=10)
prev&lt;- 0.05
sens&lt;- 0.9
sep.binom(tested, prev, sens)
</code></pre>

<hr>
<h2 id='sep.binom.imperfect'>Binomial population sensitivity for imperfect test</h2><span id='topic+sep.binom.imperfect'></span>

<h3>Description</h3>

<p>Calculates population sensitivity for a large or unknown population 
and allowing for imperfect test sensitivity and specificity, 
using Binomial distribution an allowing for a variable cut-point number of 
positives to classify as positive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.binom.imperfect(n, c = 1, se, sp = 1, pstar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.binom.imperfect_+3A_n">n</code></td>
<td>
<p>sample size (scalar or vector)</p>
</td></tr>
<tr><td><code id="sep.binom.imperfect_+3A_c">c</code></td>
<td>
<p>The cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, 
&gt;= c is positive (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sep.binom.imperfect_+3A_se">se</code></td>
<td>
<p>test unit sensitivity (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sep.binom.imperfect_+3A_sp">sp</code></td>
<td>
<p>test unit specificity, default=1 (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sep.binom.imperfect_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion (scalar or vector of same length as n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level sensitivities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.imperfect.binom
sep.binom.imperfect(1:10*5, 2, 0.95, 0.98, 0.1)
sep.binom.imperfect(50, 1:5, 0.95, 0.98, 0.1)
sep.binom.imperfect(30, 2, 0.9, 0.98, 0.1)
sep.binom.imperfect(30, 1, 0.9, 0.98, 0.1)
</code></pre>

<hr>
<h2 id='sep.exact'>Population sensitivity for census (all units tested)</h2><span id='topic+sep.exact'></span>

<h3>Description</h3>

<p>Calculates population sensitivity for detecting disease
assuming imperfect test sensitivity, perfect test specificity
and a census of all units in the population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.exact(d = 1, se = 1, dig = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.exact_+3A_d">d</code></td>
<td>
<p>expected number of infected units in population (=design prevalence*N
rounded to next integer), scalar or vector of same length as se</p>
</td></tr>
<tr><td><code id="sep.exact_+3A_se">se</code></td>
<td>
<p>unit sensitivity of test (proportion), scalar or vector</p>
</td></tr>
<tr><td><code id="sep.exact_+3A_dig">dig</code></td>
<td>
<p>number of digits for rounding of results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of population-level sensitivities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.exact - checked
sep.exact(d=1, se = 0.92)
inf&lt;- 1:5
sens&lt;- 0.8
sep.exact(d=inf, se=sens)
sep.exact(se=0.8, d = ceiling(0.01*c(10, 50, 100, 250, 500)))
</code></pre>

<hr>
<h2 id='sep.freecalc'>FreeCalc population sensitivity  for imperfect test</h2><span id='topic+sep.freecalc'></span>

<h3>Description</h3>

<p>Calculates population sensitivity for a finite population 
and allowing for imperfect test sensitivity and specificity, using Freecalc method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.freecalc(N, n, c = 1, se, sp = 1, pstar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.freecalc_+3A_n">N</code></td>
<td>
<p>population size (scalar)</p>
</td></tr>
<tr><td><code id="sep.freecalc_+3A_n">n</code></td>
<td>
<p>sample size (scalar)</p>
</td></tr>
<tr><td><code id="sep.freecalc_+3A_c">c</code></td>
<td>
<p>The cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, 
&gt;= c is positive (scalar)</p>
</td></tr>
<tr><td><code id="sep.freecalc_+3A_se">se</code></td>
<td>
<p>test unit sensitivity (scalar)</p>
</td></tr>
<tr><td><code id="sep.freecalc_+3A_sp">sp</code></td>
<td>
<p>test unit specificity, default=1 (scalar)</p>
</td></tr>
<tr><td><code id="sep.freecalc_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion - assumed or target prevalence for 
detection of disease in the population (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population-level sensitivity
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of sep.freecalc
sep.freecalc(150, 30, 2, 0.9, 0.98, 0.1)
sep.freecalc(150, 30, 1, 0.9, 0.98, 0.1)

</code></pre>

<hr>
<h2 id='sep.hp'>Hypergeometric (HerdPlus) population sensitivity for imperfect test</h2><span id='topic+sep.hp'></span>

<h3>Description</h3>

<p>Calculates population sensitivity for a finite population 
and allowing for imperfect test sensitivity and specificity, 
using Hypergeometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.hp(N, n, c = 1, se, sp = 1, pstar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.hp_+3A_n">N</code></td>
<td>
<p>population size (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sep.hp_+3A_n">n</code></td>
<td>
<p>sample size (scalar or vector)</p>
</td></tr>
<tr><td><code id="sep.hp_+3A_c">c</code></td>
<td>
<p>The cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, 
&gt;= c is positive (scalar)</p>
</td></tr>
<tr><td><code id="sep.hp_+3A_se">se</code></td>
<td>
<p>test unit sensitivity (scalar)</p>
</td></tr>
<tr><td><code id="sep.hp_+3A_sp">sp</code></td>
<td>
<p>test unit specificity, default=1 (scalar)</p>
</td></tr>
<tr><td><code id="sep.hp_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence as a proportion  (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level sensitivities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of sep.hp
sep.hp(150, 1:5*10, 2, 0.9, 0.98, 0.1)
sep.hp(150, 30, 2, 0.9, 0.98, 15)
sep.hp(150, 30, 1, 0.9, 0.98, 15)
sep.hp(150, 30, 1, 0.9, 0.98, 0.1)
</code></pre>

<hr>
<h2 id='sep.hypergeo'>Hypergeometric Population sensitivity</h2><span id='topic+sep.hypergeo'></span>

<h3>Description</h3>

<p>Calculates population sensitivity for detecting disease,
assuming imperfect test sensitivity, perfect test specificity
and representative sampling,
using hypergeometric approximation (assumes known population size)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.hypergeo(N, n, d, se = 1, dig = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.hypergeo_+3A_n">N</code></td>
<td>
<p>population size, scalar or vector of same length as n</p>
</td></tr>
<tr><td><code id="sep.hypergeo_+3A_n">n</code></td>
<td>
<p>sample size (number tested), scalar or vector</p>
</td></tr>
<tr><td><code id="sep.hypergeo_+3A_d">d</code></td>
<td>
<p>expected number of infected units in population (=design prevalence*N
rounded to next integer)</p>
</td></tr>
<tr><td><code id="sep.hypergeo_+3A_se">se</code></td>
<td>
<p>unit sensitivity of test (proportion), scalar or vector of same length as n</p>
</td></tr>
<tr><td><code id="sep.hypergeo_+3A_dig">dig</code></td>
<td>
<p>number of digits for rounding of results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level sensitivities. if all n &lt;= corresponding N then 
vector is numeric, otherwise vector is character and elements where n&gt;N are recorded as such
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.hypergeo - checked
sep.hypergeo(N=100, n=50, d=1, se = 0.92)
inf&lt;- 1:5
sens&lt;- 0.8
sep.hypergeo(N=100, n=50, d=inf, se=sens)
N&lt;- c(10, 50, 100, 250, 500)
sep.hypergeo(se=0.8, N=N, n=c(5, 25, 50, 125, 250), d = ceiling(0.01*N))
</code></pre>

<hr>
<h2 id='sep.passive'>Passive surveillance sensitivity</h2><span id='topic+sep.passive'></span>

<h3>Description</h3>

<p>Estimates the population sensitivity of a passive surveillance system. 
Assumes comprehensive population coverage and samling of representative affected units 
from infected clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.passive(step.p, p.inf.u, se, N, n, pstar.c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.passive_+3A_step.p">step.p</code></td>
<td>
<p>vector or matrix of detection probabilities for each step in the detection process.
If a vector each value represents a step probability for a single calculation. If a matrix, columns
are step probabilities and rows are simulation iterations.</p>
</td></tr>
<tr><td><code id="sep.passive_+3A_p.inf.u">p.inf.u</code></td>
<td>
<p>the probability of infection in units sampled, 
equivalent to the positive predictive value of clinical signs of disease 
(for a given prior probability of infection). Either a scalar or vector with length equal 
to number of rows in step.p.</p>
</td></tr>
<tr><td><code id="sep.passive_+3A_se">se</code></td>
<td>
<p>unit sensitivity of test (proportion). Either a scalar or vector with length equal 
to number of rows in step.p.</p>
</td></tr>
<tr><td><code id="sep.passive_+3A_n">N</code></td>
<td>
<p>population size. Either a scalar or vector with length equal 
to number of rows in step.p</p>
</td></tr>
<tr><td><code id="sep.passive_+3A_n">n</code></td>
<td>
<p>number of units tested per cluster reporting suspected disease. Either a scalar or vector with length equal 
to number of rows in step.p</p>
</td></tr>
<tr><td><code id="sep.passive_+3A_pstar.c">pstar.c</code></td>
<td>
<p>cluster-level design prevalence (proportion). Either a scalar or vector with length equal 
to number of rows in step.p</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 2 elements, the estimated cluster-level and population-level sensitivities.
If step.p is a vector, values are scalars, if step.p is a matrix, values are vectors with 
length equal to the number of rows in step.p
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.passive
sep.passive(c(0.1, 0.2, 0.9, 0.99), 0.98, 0.9, 1000, 5, 0.01)
sep.passive(c(0.1, 0.5, 0.95, 0.99), 0.98, 0.9, 1000, 5, 0.01)
step.p&lt;- matrix(runif(30), nrow=10)
p.inf.u&lt;- runif(10, 0.98, 0.999)
se&lt;- mc2d::rpert(10, 0.9, 0.95, 0.98)
sep.passive(step.p, p.inf.u, se, 10000, 10, 0.02)
</code></pre>

<hr>
<h2 id='sep.pfree'>Population sensitivity to achieve desired (posterior) probability of freedom</h2><span id='topic+sep.pfree'></span>

<h3>Description</h3>

<p>Calculates the population sensitivity required to achieve a
given value for probability of disease freedom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.pfree(prior, pfree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.pfree_+3A_prior">prior</code></td>
<td>
<p>prior probability of freedom before surveillance (scalar or vector)</p>
</td></tr>
<tr><td><code id="sep.pfree_+3A_pfree">pfree</code></td>
<td>
<p>desired probability of freedom (scalar or vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level sensitivities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of sep.pfree
sep.pfree(0.5, 0.95)
sep.pfree(c(0.5, 0.6, 0.7, 0.8, 0.9, 0.95), 0.99)
sep.pfree(0.5, c(0.8, 0.9, 0.95, 0.99))
</code></pre>

<hr>
<h2 id='sep.pooled'>Pooled population sensitivity</h2><span id='topic+sep.pooled'></span>

<h3>Description</h3>

<p>Calculates population sensitivity (sep) and population specificity (spp)
assuming pooled sampling
and allowing for imperfect sensitivity and specificity of the pooled test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.pooled(r, k, pstar, pse, psp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.pooled_+3A_r">r</code></td>
<td>
<p>number of pools sampled (scalar or vector)</p>
</td></tr>
<tr><td><code id="sep.pooled_+3A_k">k</code></td>
<td>
<p>pool size (scalar or vector of same length as r)</p>
</td></tr>
<tr><td><code id="sep.pooled_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar or vector of same length as r)</p>
</td></tr>
<tr><td><code id="sep.pooled_+3A_pse">pse</code></td>
<td>
<p>pool-level sensitivity (scalar or vector of same length as r)</p>
</td></tr>
<tr><td><code id="sep.pooled_+3A_psp">psp</code></td>
<td>
<p>pool-level specificity (scalar or vector of same length as r)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2 elements, vector of sep values and vector of spp
values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.pooled
sep.pooled(60, 5, 0.01, 1, 1)
sep.pooled(4, 10, 0.1, 0.9, 1)
sep.pooled(1:10*5, 5, 0.02, 0.9, 0.99)
sep.pooled(10, 5, 0.05, c(0.8, 0.9, 0.95, 0.99), 1)
</code></pre>

<hr>
<h2 id='sep.prior'>Population sensitivity to achieve desired prior probability of freedom</h2><span id='topic+sep.prior'></span>

<h3>Description</h3>

<p>Calculates the population sensitivity required to achieve a
given value for the prior (discounted) probability of disease freedom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.prior(prior, p.intro)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.prior_+3A_prior">prior</code></td>
<td>
<p>prior probability of freedom before surveillance (scalar or vector)</p>
</td></tr>
<tr><td><code id="sep.prior_+3A_p.intro">p.intro</code></td>
<td>
<p>probability of introduction for time period (scalar or vector equal length to sep)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level sensitivities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of sep.prior
sep.prior(0.95, 0.01)
sep.prior(c(0.9, 0.95, 0.98, 0.99), 0.01)
sep.prior(0.95, c(0.001, 0.005, 0.01, 0.02, 0.05))
</code></pre>

<hr>
<h2 id='sep.rb.bin'>Binomial risk-based population sensitivity</h2><span id='topic+sep.rb.bin'></span>

<h3>Description</h3>

<p>Calculates risk-based population sensitivity with a 
single risk factor, using binomial method (assumes a large population),
allows for unit sensitivity to vary among risk strata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.rb.bin(pstar, rr, ppr, n, se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.rb.bin_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sep.rb.bin_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector of values corresponding to the number of risk strata)</p>
</td></tr>
<tr><td><code id="sep.rb.bin_+3A_ppr">ppr</code></td>
<td>
<p>population proportions corresponding to rr values 
(vector of equal length to rr)</p>
</td></tr>
<tr><td><code id="sep.rb.bin_+3A_n">n</code></td>
<td>
<p>sample size per risk category (vector same length as 
rr and ppr)</p>
</td></tr>
<tr><td><code id="sep.rb.bin_+3A_se">se</code></td>
<td>
<p>unit sensitivity, can vary among risk strata (fixed value or 
vector same length as rr, ppr, n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 3 elements, a scalar of population-level sensitivity
a vector of EPI values and a vector of corresponding adjusted risks
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.rb.bin
sep.rb.bin(0.1, c(5, 3, 1), c(0.1, 0.1, 0.8), c(5, 5, 5), 0.9)
sep.rb.bin(0.1, c(5, 1), c(0.1, 0.9), c(10, 5), c(0.95, 0.9))
sep.rb.bin(0.1, c(5, 1), c(0.1, 0.9), c(10, 5), c(0.9, 0.9))
sep.rb.bin(0.01, c(5, 1), c(0.1, 0.9), c(90, 50), c(0.9, 0.9))
</code></pre>

<hr>
<h2 id='sep.rb.bin.varse'>Binomial risk-based population sensitivity for varying unit sensitivity</h2><span id='topic+sep.rb.bin.varse'></span>

<h3>Description</h3>

<p>Calculates population sensitivity for a single risk factor 
and varying unit sensitivity using binomial method (assumes large population)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.rb.bin.varse(pstar, rr, ppr, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.rb.bin.varse_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sep.rb.bin.varse_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector of values corresponding 
to the number of risk strata)</p>
</td></tr>
<tr><td><code id="sep.rb.bin.varse_+3A_ppr">ppr</code></td>
<td>
<p>population proportions corresponding to rr values 
(vector of equal length to rr)</p>
</td></tr>
<tr><td><code id="sep.rb.bin.varse_+3A_df">df</code></td>
<td>
<p>dataframe of values for each combination of risk stratum and 
sensitivity level, 
col 1 = risk group index, col 2 = unit Se, col 3 = n 
(sample size for that risk group and unit sensitivity)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 3 elements, a scalar of population-level sensitivity
a vector of EPI values and a vector of corresponding adjusted risks
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.rb.bin.varse
rg&lt;- c(1, 1, 2, 2)
se&lt;- c(0.92, 0.85, 0.92, 0.85)
n&lt;- c(80, 30, 20, 30)
df&lt;- data.frame(rg, se, n)
sep.rb.bin.varse(0.01, c(5, 1), c(0.1, 0.9), df)

rg&lt;- c(1, 1, 2, 2)
se&lt;- c(0.95, 0.8, 0.95, 0.8)
n&lt;- c(20, 10, 10, 5)
df&lt;- data.frame(rg, se, n)
sep.rb.bin.varse(0.05, c(3, 1), c(0.2, 0.8), df)

rg&lt;- c(rep(1, 30), rep(2, 15))
se&lt;- c(rep(0.95, 20), rep(0.8, 10), rep(0.95, 10), rep(0.8, 5))
n&lt;- rep(1, 45)
df&lt;- data.frame(rg, se, n)
sep.rb.bin.varse(0.02, c(3, 1), c(0.2, 0.8), df)

rg&lt;- c(1, 2, 3, 1, 2, 3)
se&lt;- c(0.95, 0.95, 0.95, 0.8, 0.8, 0.8)
n&lt;- c(20, 10, 10, 30, 5, 5)
df&lt;- data.frame(rg, se, n)
sep.rb.bin.varse(0.01, c(5, 3, 1), c(0.1, 0.3, 0.6), df)
</code></pre>

<hr>
<h2 id='sep.rb.hypergeo'>Hypergeometric risk-based population sensitivity</h2><span id='topic+sep.rb.hypergeo'></span>

<h3>Description</h3>

<p>Calculates risk-based population sensitivity with a 
single risk factor, using the hypergeometric method 
(assuming a finite and known population size),
allows for unit sensitivity to vary among risk strata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.rb.hypergeo(pstar, rr, N, n, se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.rb.hypergeo_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sep.rb.hypergeo_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector of values corresponding 
to the number of risk strata)</p>
</td></tr>
<tr><td><code id="sep.rb.hypergeo_+3A_n">N</code></td>
<td>
<p>Population size per risk category (vector same length 
as rr and ppr)</p>
</td></tr>
<tr><td><code id="sep.rb.hypergeo_+3A_n">n</code></td>
<td>
<p>sample size per risk category (vector same length as 
rr and ppr)</p>
</td></tr>
<tr><td><code id="sep.rb.hypergeo_+3A_se">se</code></td>
<td>
<p>unit sensitivity, can vary among risk strata (fixed value or a vector the same 
length as rr, ppr, n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 3 elements, a scalar of population-level sensitivity
a vector of EPI values and a vector of corresponding adjusted risks
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.rb.bin
sep.rb.hypergeo(0.1, c(5, 3, 1), c(10, 10, 80), c(5, 5, 5), 0.9)
sep.rb.hypergeo(0.1, c(5, 1), c(15, 140), c(10, 5), c(0.95, 0.9))
sep.rb.hypergeo(0.1, c(5, 1), c(23, 180), c(10, 5), c(0.9, 0.9))
sep.rb.hypergeo(0.01, c(5, 1), c(100, 900), c(90, 50), c(0.9, 0.9))
</code></pre>

<hr>
<h2 id='sep.rb.hypergeo.varse'>Hypergeometric risk-based population sensitivity for varying unit sensitivity</h2><span id='topic+sep.rb.hypergeo.varse'></span>

<h3>Description</h3>

<p>Calculates population sensitivity for a single risk factor 
and varying unit sensitivity using hypergeometric approximation method 
(assumes known population size)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.rb.hypergeo.varse(pstar, rr, N, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.rb.hypergeo.varse_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sep.rb.hypergeo.varse_+3A_rr">rr</code></td>
<td>
<p>relative risk values (vector of values corresponding 
to the number of risk strata)</p>
</td></tr>
<tr><td><code id="sep.rb.hypergeo.varse_+3A_n">N</code></td>
<td>
<p>vector of population size for each risk group, corresponding to rr values 
(vector of equal length to rr)</p>
</td></tr>
<tr><td><code id="sep.rb.hypergeo.varse_+3A_df">df</code></td>
<td>
<p>dataframe of values for each combination of risk stratum and
sensitivity level, 
col 1 = risk group index, col 2 = unit Se, col 3 = n 
(sample size for risk group and unit sensitivity)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 5 elements, a scalar of population-level sensitivity
a vector of EPI values, a vector of corresponding Adjusted risks
a vector of sample sizes (n) per risk group and a vector of 
mean unit sensitivities per risk group
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.rb.hypergeo.varse
rg&lt;- c(1, 1, 2, 2)
se&lt;- c(0.92, 0.85, 0.92, 0.85)
n&lt;- c(80, 30, 20, 30)
df&lt;- data.frame(rg, se, n)
sep.rb.hypergeo.varse(0.01, c(5, 1), c(200, 1800), df)

rg&lt;- c(1, 1, 2, 2)
se&lt;- c(0.95, 0.8, 0.95, 0.8)
n&lt;- c(20, 10, 10, 5)
df&lt;- data.frame(rg, se, n)
sep.rb.hypergeo.varse(0.05, c(3, 1), c(100, 400), df)

rg&lt;- c(rep(1, 30), rep(2, 15))
se&lt;- c(rep(0.95, 20), rep(0.8, 10), rep(0.95, 10), rep(0.8, 5))
n&lt;- rep(1, 45)
df&lt;- data.frame(rg, se, n)
sep.rb.hypergeo.varse(0.02, c(3, 1), c(100, 400), df)

rg&lt;- c(1, 2, 3, 1, 2, 3)
se&lt;- c(0.95, 0.95, 0.95, 0.8, 0.8, 0.8)
n&lt;- c(20, 10, 10, 30, 5, 5)
df&lt;- data.frame(rg, se, n)
sep.rb.hypergeo.varse(0.01, c(5, 3, 1), c(100, 300, 600), df)
</code></pre>

<hr>
<h2 id='sep.rb2.binom'>Binomial risk-based population sensitivity for 2 risk factors</h2><span id='topic+sep.rb2.binom'></span>

<h3>Description</h3>

<p>Calculates risk-based population sensitivity for 
two risk factors, using binomial method (assumes a large population)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.rb2.binom(pstar, rr1, ppr1, rr2, ppr2, n, se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.rb2.binom_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sep.rb2.binom_+3A_rr1">rr1</code></td>
<td>
<p>relative risks for first level risk factor (vector of values corresponding 
to the number of risk strata)</p>
</td></tr>
<tr><td><code id="sep.rb2.binom_+3A_ppr1">ppr1</code></td>
<td>
<p>population proportions for first level risk factor (vector of
same length as rr1)</p>
</td></tr>
<tr><td><code id="sep.rb2.binom_+3A_rr2">rr2</code></td>
<td>
<p>relative risks for second level risk factor, 
matrix, rows = levels of rr1, cols = levels of rr2</p>
</td></tr>
<tr><td><code id="sep.rb2.binom_+3A_ppr2">ppr2</code></td>
<td>
<p>population proportions for second level 
risk factor, matrix, rows = levels of rr1, cols = levels of rr2</p>
</td></tr>
<tr><td><code id="sep.rb2.binom_+3A_n">n</code></td>
<td>
<p>matrix of number tested for each risk group 
(rows = levels of rr1, cols = levels of rr2)</p>
</td></tr>
<tr><td><code id="sep.rb2.binom_+3A_se">se</code></td>
<td>
<p>test unit sensitivity (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 4 elements, a scalar of population-level sensitivity
a matrix of EPI values, a vector of corresponding Adjusted risks for
the first risk factor and a matrix of adjusted risks for the second 
risk factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.rb2.binom
pstar&lt;- 0.01
rr1&lt;- c(3, 1)
ppr1&lt;- c(0.2, 0.8)
rr2&lt;- rbind(c(4,1), c(4,1))
ppr2&lt;- rbind(c(0.1, 0.9), c(0.3, 0.7))
se&lt;- 0.8
n&lt;- rbind(c(50, 20), c(20, 10))
sep.rb2.binom(pstar, rr1, ppr1, rr2, ppr2, n, se)
</code></pre>

<hr>
<h2 id='sep.rb2.hypergeo'>Hypergeometric risk-based population sensitivity for 2 risk factors</h2><span id='topic+sep.rb2.hypergeo'></span>

<h3>Description</h3>

<p>Calculates risk-based population sensitivity for 
two risk factors, using hypergeometric approximation method 
(assumes a known population size)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.rb2.hypergeo(pstar, rr1, rr2, N, n, se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.rb2.hypergeo_+3A_pstar">pstar</code></td>
<td>
<p>design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sep.rb2.hypergeo_+3A_rr1">rr1</code></td>
<td>
<p>relative risks for first level risk factor (vector of values corresponding 
to the number of risk strata)</p>
</td></tr>
<tr><td><code id="sep.rb2.hypergeo_+3A_rr2">rr2</code></td>
<td>
<p>relative risks for second level risk factor, 
matrix, rows = levels of rr1, cols = levels of rr2</p>
</td></tr>
<tr><td><code id="sep.rb2.hypergeo_+3A_n">N</code></td>
<td>
<p>matrix of population size for each risk group 
(rows = levels of rr1, cols = levels of rr2)</p>
</td></tr>
<tr><td><code id="sep.rb2.hypergeo_+3A_n">n</code></td>
<td>
<p>matrix of number tested (sample size) for each risk group 
(rows = levels of rr1, cols = levels of rr2)</p>
</td></tr>
<tr><td><code id="sep.rb2.hypergeo_+3A_se">se</code></td>
<td>
<p>test unit sensitivity (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 6 elements, a scalar of population-level sensitivity
a matrix of EPI values, a vector of corresponding Adjusted risks for
the first risk factor and a matrix of adjusted risks for the second risk factor,
a vector of population proportions for the first risk factor 
and a matrix of population proportions for the second risk factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.rb2.hypergeo
pstar&lt;- 0.01
rr1&lt;- c(3, 1)
rr2&lt;- rbind(c(4,1), c(4,1))
N&lt;- rbind(c(100, 500), c(300, 1000))
n&lt;- rbind(c(50, 20), c(20, 10))
se&lt;- 0.8
sep.rb2.hypergeo(pstar, rr1, rr2, N, n, se)
</code></pre>

<hr>
<h2 id='sep.sys'>2-stage population sensitivity</h2><span id='topic+sep.sys'></span>

<h3>Description</h3>

<p>Calculates population-level (system) sensitivity for representative
2-stage sampling (sampling of clusters and units within clusters),
assuming imperfect test sensitivity and perfect test specificity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.sys(H = NA, N = NA, n, pstar.c, pstar.u, se = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.sys_+3A_h">H</code></td>
<td>
<p>population size = number of clusters in the population, default = NA</p>
</td></tr>
<tr><td><code id="sep.sys_+3A_n">N</code></td>
<td>
<p>population size within clusters,
scalar or a vector of same length as n, default = NA</p>
</td></tr>
<tr><td><code id="sep.sys_+3A_n">n</code></td>
<td>
<p>sample size (vector of number tested per cluster)</p>
</td></tr>
<tr><td><code id="sep.sys_+3A_pstar.c">pstar.c</code></td>
<td>
<p>cluster (herd) level design prevalence, scalar,
either proportion or integer</p>
</td></tr>
<tr><td><code id="sep.sys_+3A_pstar.u">pstar.u</code></td>
<td>
<p>unit (animal) level design prevalence, scalar,
either proportion or integer</p>
</td></tr>
<tr><td><code id="sep.sys_+3A_se">se</code></td>
<td>
<p>unit sensitivity of test (proportion), scalar, default = 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 6 elements, 1) population level sensitivity, 2) vector of
cluster-level sensitivities, 3) N, 4) n, 5) vector of design prevalences
and 6) unit sensitivity
</p>


<h3>Note</h3>

<p>if pstar.c is not a proportion N must be provided
(and N&gt;=n)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sep.sys - checked
H&lt;- 500
N&lt;- rep(1000, 150)
N[5]&lt;- NA
n&lt;- rep(30, 150)
pstar.u&lt;- 0.1
pstar.c&lt;- 0.01
se&lt;- 0.98
sep.sys(H, N, n, pstar.c, pstar.u, se)
sep.sys(NA, N, n, 0.02, 0.05, 0.95)
N&lt;- round(runif(105)*900+100)
n&lt;- round(runif(105)*30+10)
sse&lt;- sep.sys(1000, N, n, 0.02, 0.05, 0.9)
data.frame(N, n, sse[[2]])
</code></pre>

<hr>
<h2 id='sep.var.se'>Population sensitivity for varying unit sensitivity</h2><span id='topic+sep.var.se'></span>

<h3>Description</h3>

<p>Calculates population-level sensitivity where unit sensitivity
varies and using the appropriate method, depending on whether or not N provided
(hypergeometric if N provided, binomial otherwise), assuming perfect
test specificity and representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep.var.se(N = NA, se, pstar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep.var.se_+3A_n">N</code></td>
<td>
<p>population size (number of units or clusters), N must be &gt;= length(se))
or NA if unknown</p>
</td></tr>
<tr><td><code id="sep.var.se_+3A_se">se</code></td>
<td>
<p>vector of unit sensitivity values (proportion) for each unit sampled</p>
</td></tr>
<tr><td><code id="sep.var.se_+3A_pstar">pstar</code></td>
<td>
<p>specified design prevalence (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar of population-level sensitivity
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of sep.var.se - checked
sens&lt;- c(rep(0.9, 50), rep(0.95, 100))
sep.var.se(NA, sens, 0.01)
sep.var.se(se=sens, pstar=0.01)
sep.var.se(N=500, sens, 0.01)
sep.var.se(NA, runif(150, 0.95, 0.99), 0.02)
sep.var.se(500, runif(150, 0.95, 0.99), 0.02)
</code></pre>

<hr>
<h2 id='sp.parallel'>Specificity of tests in parallel</h2><span id='topic+sp.parallel'></span>

<h3>Description</h3>

<p>Calculates the combined specificity for multiple tests
interpreted in parallel (assuming independence)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp.parallel(sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp.parallel_+3A_sp">sp</code></td>
<td>
<p>vector of unit specificity values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar of combined specificity, assuming independence
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sp.parallel
sp.parallel(c(0.99, 0.95, 0.8))
</code></pre>

<hr>
<h2 id='sp.series'>Specficity of tests in series</h2><span id='topic+sp.series'></span>

<h3>Description</h3>

<p>Calculates the combined specificity for multiple tests
interpreted in series (assuming independence)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp.series(sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp.series_+3A_sp">sp</code></td>
<td>
<p>vector of unit specificity values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar of combined specificity, assuming independence
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sp.series
sp.series(c(0.99, 0.95, 0.8))
</code></pre>

<hr>
<h2 id='sph.binom'>Binomial population specificity for imperfect test</h2><span id='topic+sph.binom'></span>

<h3>Description</h3>

<p>Calculates population specificity for a large or unknown population, 
using the Binomial distribution and adjusting for cut-point number of positives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph.binom(n, c = 1, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sph.binom_+3A_n">n</code></td>
<td>
<p>sample size (scalar or vector)</p>
</td></tr>
<tr><td><code id="sph.binom_+3A_c">c</code></td>
<td>
<p>The cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, 
&gt;= c is positive (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sph.binom_+3A_sp">sp</code></td>
<td>
<p>test unit specificity (scalar or vector of same length as n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level specificities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sph.imperfect.sp
sph.binom(30, 2, 0.98)
sph.binom(30, 1, 0.98)
sph.binom(1:5*10, 2, 0.98)
sph.binom(100, 1:5, 0.98)
sph.binom(100, 3, 95:100/100)
sph.binom(c(5, 10, 15, 20, 30, 50, 100, 200), 2, 0.98)
</code></pre>

<hr>
<h2 id='sph.hp'>Hypergeometric population specificity calculation</h2><span id='topic+sph.hp'></span>

<h3>Description</h3>

<p>Calculates population specificity for a finite population 
and imperfect test, using Hypergeometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph.hp(N, n, c = 1, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sph.hp_+3A_n">N</code></td>
<td>
<p>population size (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sph.hp_+3A_n">n</code></td>
<td>
<p>sample size (scalar or vector)</p>
</td></tr>
<tr><td><code id="sph.hp_+3A_c">c</code></td>
<td>
<p>The cut-point number of positives to classify a cluster
as positive, default=1, if positives &lt; c result is negative, 
&gt;= c is positive (scalar or vector of same length as n)</p>
</td></tr>
<tr><td><code id="sph.hp_+3A_sp">sp</code></td>
<td>
<p>test unit specificity (scalar or vector of same length as n)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level specificities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples of sph.hp
sph.hp(150, 30, 2, 0.98)
sph.hp(150, 30, 1, 0.98)
sph.hp(150, 1:5*10, 2, 0.98)
sph.hp(500, 30, 2, 95:100/100)
</code></pre>

<hr>
<h2 id='spp'>Population specificity</h2><span id='topic+spp'></span>

<h3>Description</h3>

<p>Calculates population specificity assuming representative sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp(n, sp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spp_+3A_n">n</code></td>
<td>
<p>sample size (number tested), integer, scalar or vector</p>
</td></tr>
<tr><td><code id="spp_+3A_sp">sp</code></td>
<td>
<p>unit specificity of test (proportion), scalar or vector of same length as n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of population-level specificities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for spp - checked
spp(10, 0.9)
spp(c(10, 20, 50, 100), 0.99)
spp(100, c(0.999, 0.99, 0.98, 0.95, 0.9))
</code></pre>

<hr>
<h2 id='sse.combined'>System sensitivity by combining multiple surveillance components</h2><span id='topic+sse.combined'></span>

<h3>Description</h3>

<p>Calculates overall system sensitivity for 
multiple components, accounting for lack of independence 
(overlap) between components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse.combined(C = NA, pstar.c, rr, ppr, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sse.combined_+3A_c">C</code></td>
<td>
<p>population sizes (number of clusters) for each risk group, 
NA or vector of same length as rr</p>
</td></tr>
<tr><td><code id="sse.combined_+3A_pstar.c">pstar.c</code></td>
<td>
<p>cluster level design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sse.combined_+3A_rr">rr</code></td>
<td>
<p>cluster level relative risks (vector, length 
equal to the number of risk strata)</p>
</td></tr>
<tr><td><code id="sse.combined_+3A_ppr">ppr</code></td>
<td>
<p>cluster level population proportions (optional), 
not required if C is specified (NA or vector of same length as rr)</p>
</td></tr>
<tr><td><code id="sse.combined_+3A_sep">sep</code></td>
<td>
<p>sep values for clusters in each component and 
corresponding risk group. A list with multiple elements, each element 
is a dataframe of sep values from a separate component, 
first column= clusterid, 2nd =cluster-level risk group index, 3rd col = sep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2 elements, a matrix (or vector if C not specified) 
of population-level (surveillance system) 
sensitivities (binomial and hypergeometric and adjusted vs unadjusted) and 
a matrix of adjusted and unadjusted component sensitivities for each component
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example for sse.combined (checked in excel combined components.xlsx)
C&lt;- c(300, 1200)
pstar&lt;- 0.01
rr&lt;- c(3,1)
ppr&lt;- c(0.2, 0.8)
comp1&lt;- data.frame(id=1:100, rg=c(rep(1,50), rep(2,50)), cse=rep(0.5,100)) 
comp2&lt;- data.frame(id=seq(2, 120, by=2), rg=c(rep(1,25), rep(2,35)), cse=runif(60, 0.5, 0.8))
comp3&lt;- data.frame(id=seq(5, 120, by=5), rg=c(rep(1,10), rep(2,14)), cse=runif(24, 0.7, 1))
sep&lt;- list(comp1, comp2, comp3)
sse.combined(C, pstar, rr, sep = sep)
sse.combined(C=NA, pstar, rr, ppr, sep = sep)
</code></pre>

<hr>
<h2 id='sse.rb.2stage'>Two-stage risk-based system sensitivity</h2><span id='topic+sse.rb.2stage'></span>

<h3>Description</h3>

<p>Calculates system sensitivity for 2 stage risk-based 
sampling, llowing for a single risk factor at each stage and
using either binomial or hypergeometric approxiation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sse.rb.2stage(C = NA, pstar.c, pstar.u, rr.c, ppr.c, rr.u, ppr.u,
  N = NA, n, rg, se)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sse.rb.2stage_+3A_c">C</code></td>
<td>
<p>Population size (number of clusters), NA = unknown (default)</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_pstar.c">pstar.c</code></td>
<td>
<p>cluster level design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_pstar.u">pstar.u</code></td>
<td>
<p>unit level design prevalence (scalar)</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_rr.c">rr.c</code></td>
<td>
<p>cluster level relative risks (vector with length 
corresponding to the number of risk strata), 
use rr.c = c(1,1) if risk factor does not apply</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_ppr.c">ppr.c</code></td>
<td>
<p>cluster level population proportions for risk 
categories (vector), NA if no cluster level risk factor</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_rr.u">rr.u</code></td>
<td>
<p>unit level relative risks (vector with length 
corresponding to the number of risk strata), 
use rr.u = c(1,1) if risk factor does not apply</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_ppr.u">ppr.u</code></td>
<td>
<p>unit level population proportions for each risk group (optional) 
matrix, 1 row for each cluster, columns = unit level risk groups, 
not required if N is provided</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_n">N</code></td>
<td>
<p>population size per risk group for each cluster, 
NA or matrix of N for each risk group 
for each cluster, N=NA means cluster sizes not provided</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_n">n</code></td>
<td>
<p>sample size per risk group for each cluster sampled,
matrix, 1 row for each cluster, columns = unit level risk groups</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_rg">rg</code></td>
<td>
<p>vector of cluster level risk group (index) for each cluster</p>
</td></tr>
<tr><td><code id="sse.rb.2stage_+3A_se">se</code></td>
<td>
<p>unit sensitivity for each cluster, scalar or 
vector of values for each cluster, equal in length to n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2 elements, a scalar of population-level (surveillance system) 
sensitivity and a vector of cluster-level sensitivities
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for sse.rb.2stage
pstar.c&lt;- 0.02
pstar.u&lt;- 0.1
rr.c&lt;- c(5, 1)
ppr.c&lt;- c(0.1, 0.9)
rr.u&lt;- c(3, 1)
se&lt;- 0.9
n&lt;- cbind(rep(10, 50), rep(5, 50))    
rg&lt;- c(rep(1, 30), rep(2, 20))
ppr.u&lt;- cbind(rep(0.2, 50), rep(0.8, 50))
N&lt;- cbind(rep(30, 50), rep(120, 50))
C&lt;- 500        
sse.rb.2stage(C=NA, pstar.c, pstar.u, rr.c, ppr.c, rr.u, ppr.u, N=NA, n, rg, se) 
sse.rb.2stage(C, pstar.c, pstar.u, rr.c, ppr.c, rr.u, ppr.u, N=NA, n, rg, se) 
sse.rb.2stage(C=NA, pstar.c, pstar.u, rr.c, ppr.c, rr.u, ppr.u, N, n, rg, se) 
sse.rb.2stage(C, pstar.c, pstar.u, rr.c, ppr.c, rr.u, ppr.u, N, n, rg, se) 
</code></pre>

<hr>
<h2 id='tp'>True prevalence</h2><span id='topic+tp'></span>

<h3>Description</h3>

<p>Estimates true prevalence and confidence limits for
given sample size and result, according to specified method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tp(x, n, se, sp, type = "blaker", conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tp_+3A_x">x</code></td>
<td>
<p>number of positive units (scalar)</p>
</td></tr>
<tr><td><code id="tp_+3A_n">n</code></td>
<td>
<p>sample size (no. units sampled) (scalar)</p>
</td></tr>
<tr><td><code id="tp_+3A_se">se</code></td>
<td>
<p>test sensitivity (scalar)</p>
</td></tr>
<tr><td><code id="tp_+3A_sp">sp</code></td>
<td>
<p>test specificity (scalar)</p>
</td></tr>
<tr><td><code id="tp_+3A_type">type</code></td>
<td>
<p>method for estimating CI, one of c(&quot;normal&quot;, &quot;c-p&quot;, &quot;sterne&quot;, &quot;blaker&quot;, &quot;wilson&quot;, &quot;all&quot;)</p>
</td></tr>
<tr><td><code id="tp_+3A_conf">conf</code></td>
<td>
<p>desired level of confidence for CI, default = 0.95 (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 2 elements, a matrix of apparent prevalence and 
lower and upper confidence limits
and a matrix of true prevalence and lower and upper 
confidence limits using the chosen method(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for tp
x&lt;- 20
n&lt;- 120
se&lt;- 0.9
sp&lt;- 0.99
conf&lt;- 0.95
tp(x, n, se, sp, "all")
tp(x, n, se, sp, "c-p")
tp(x, n, 0.95, 0.9, "c-p")
</code></pre>

<hr>
<h2 id='tp.normal'>Normal approximation confidence limits for true prevalence</h2><span id='topic+tp.normal'></span>

<h3>Description</h3>

<p>Estimates true prevalence and confidence limits for 
estimates based on normal approximation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tp.normal(x, n, se, sp, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tp.normal_+3A_x">x</code></td>
<td>
<p>number of positive results in sample (scalar or vector)</p>
</td></tr>
<tr><td><code id="tp.normal_+3A_n">n</code></td>
<td>
<p>sample size (scalar or vector)</p>
</td></tr>
<tr><td><code id="tp.normal_+3A_se">se</code></td>
<td>
<p>test unit sensitivity (scalar or vector)</p>
</td></tr>
<tr><td><code id="tp.normal_+3A_sp">sp</code></td>
<td>
<p>test unit specificity (scalar or vector)</p>
</td></tr>
<tr><td><code id="tp.normal_+3A_conf">conf</code></td>
<td>
<p>desired level of confidence for CI, default = 0.95 (scalar or vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 2 elements, a matrix of apparent prevalence and wilson lower and upper confidence limits
and a matrix of true prevalence and normal approximation lower and upper confidence limits
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples for tp.normal
tp.normal(25, 120, 0.9, 0.99)
tp.normal(seq(5, 25, by=5), 120, 0.9, 0.99)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
