<!DOCTYPE html><html lang="en-US"><head><title>Help for package beastt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {beastt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beastt-package'><p>The 'beastt' package.</p></a></li>
<li><a href='#calc_post_beta'><p>Calculate Posterior Beta</p></a></li>
<li><a href='#calc_post_norm'><p>Calculate Posterior Normal</p></a></li>
<li><a href='#calc_post_weibull'><p>Calculate Posterior Weibull</p></a></li>
<li><a href='#calc_power_prior_beta'><p>Calculate Power Prior Beta</p></a></li>
<li><a href='#calc_power_prior_norm'><p>Calculate Power Prior Normal</p></a></li>
<li><a href='#calc_power_prior_weibull'><p>Calculate Power Prior Weibull</p></a></li>
<li><a href='#calc_prop_scr'><p>Create a Propensity Score Object</p></a></li>
<li><a href='#ex_binary_df'><p>External Binary Control Data for Propensity Score Balancing</p></a></li>
<li><a href='#ex_norm_df'><p>External Normal Control Data for Propensity Score Balancing</p></a></li>
<li><a href='#ex_tte_df'><p>External Time-to-Event Control Data for Propensity Score Balancing</p></a></li>
<li><a href='#int_binary_df'><p>Internal Binary Data for Propensity Score Balancing</p></a></li>
<li><a href='#int_norm_df'><p>Internal Normal Data for Propensity Score Balancing</p></a></li>
<li><a href='#int_tte_df'><p>Internal Time-to-Event Control Data for Propensity Score Balancing</p></a></li>
<li><a href='#is_prop_scr'><p>Test If Propensity Score Object</p></a></li>
<li><a href='#mix_means'><p>Extract Means of Mixture Components</p></a></li>
<li><a href='#mix_sigmas'><p>Extract Standard Deviations of Mixture Components</p></a></li>
<li><a href='#plot_dist'><p>Plot Distribution</p></a></li>
<li><a href='#prop_scr_dens'><p>Density of the Propensity Score Object</p></a></li>
<li><a href='#prop_scr_hist'><p>Histogram of the Propensity Score Object</p></a></li>
<li><a href='#prop_scr_love'><p>Love Plot of the Absolute Standardized Mean Differences</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#robustify_mvnorm'><p>Robustify Multivariate Normal Distributions</p></a></li>
<li><a href='#robustify_norm'><p>Robustify Normal Distributions</p></a></li>
<li><a href='#tidy.prop_scr'><p>Tidy a(n) prop_scr object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bayesian Evaluation, Analysis, and Simulation Software Tools for
Trials</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian dynamic borrowing with covariate adjustment via inverse probability 
  weighting for simulations and data analyses in clinical trials. This makes it easy to use
  propensity score methods to balance covariate distributions between external and internal 
  data. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gsk-biostatistics.github.io/beastt/">https://gsk-biostatistics.github.io/beastt/</a>,
<a href="https://github.com/GSK-Biostatistics/beastt">https://github.com/GSK-Biostatistics/beastt</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GSK-Biostatistics/beastt/issues">https://github.com/GSK-Biostatistics/beastt/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mvtnorm, rmarkdown, spelling, testthat (&ge; 3.0.0),
tibble, vdiffr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, cobalt, distributional, dplyr, generics, ggdist, ggplot2,
methods, mixtools, purrr, Rcpp (&ge; 0.12.0), RcppParallel (&ge;
5.0.1), rlang, rstan (&ge; 2.18.1), rstantools (&ge; 2.4.0),
stringr, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 15:46:49 UTC; christinafillmore</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Fillmore
    <a href="https://orcid.org/0000-0003-0595-2302"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Ben Arancibia [aut],
  Nate Bean <a href="https://orcid.org/0000-0001-9946-0119"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Abi Terry [aut],
  GlaxoSmithKline Research &amp; Development Limited [cph, fnd],
  Trustees of Columbia University [cph] (R/stanmodels.R, configure,
    configure.win)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Fillmore &lt;christina.e.fillmore@gsk.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-24 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='beastt-package'>The 'beastt' package.</h2><span id='topic+beastt-package'></span><span id='topic+beastt'></span>

<h3>Description</h3>

<p>Inverse Probability Weighted Bayesian Dynamic Borrowing
</p>


<h3>References</h3>

<p>Stan Development Team (NA). RStan: the R interface to Stan. R package version 2.32.3. https://mc-stan.org
</p>

<hr>
<h2 id='calc_post_beta'>Calculate Posterior Beta</h2><span id='topic+calc_post_beta'></span>

<h3>Description</h3>

<p>Calculate a posterior distribution that is beta (or a mixture
of beta components). Only the relevant treatment arms from the internal
dataset should be read in (e.g., only the control arm if constructing a
posterior distribution for the control response rate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_post_beta(internal_data, response, prior)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_post_beta_+3A_internal_data">internal_data</code></td>
<td>
<p>A tibble of the internal data.</p>
</td></tr>
<tr><td><code id="calc_post_beta_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_post_beta_+3A_prior">prior</code></td>
<td>
<p>A distributional object corresponding to a beta distribution
or a mixture distribution of beta components</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given arm of an internal trial (e.g., the control arm or an
active treatment arm) of size <code class="reqn">N_I</code>, suppose the response data are binary
such that <code class="reqn">Y_i \sim \mbox{Bernoulli}(\theta)</code>, <code class="reqn">i=1,\ldots,N_I</code>. The
posterior distribution for <code class="reqn">\theta</code> is written as
</p>
<p style="text-align: center;"><code class="reqn">\pi( \theta \mid \boldsymbol{y} ) \propto \mathcal{L}(\theta \mid \boldsymbol{y}) \; \pi(\theta),</code>
</p>

<p>where <code class="reqn">\mathcal{L}(\theta \mid \boldsymbol{y})</code> is the likelihood of the
response data from the internal arm and <code class="reqn">\pi(\theta)</code> is a prior
distribution on <code class="reqn">\theta</code> (either a beta distribution or a mixture
distribution with an arbitrary number of beta components). The posterior
distribution for <code class="reqn">\theta</code> is either a beta distribution or a mixture of
beta components depending on whether the prior is a single beta
distribution or a mixture distribution.
</p>


<h3>Value</h3>

<p>distributional object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(distributional)
calc_post_beta(internal_data = filter(int_binary_df, trt == 1),
               response = y,
               prior = dist_beta(0.5, 0.5))
</code></pre>

<hr>
<h2 id='calc_post_norm'>Calculate Posterior Normal</h2><span id='topic+calc_post_norm'></span>

<h3>Description</h3>

<p>Calculate a posterior distribution that is normal (or a mixture
of normal components). Only the relevant treatment arms from the internal
dataset should be read in (e.g., only the control arm if constructing a
posterior distribution for the control mean).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_post_norm(internal_data, response, prior, internal_sd = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_post_norm_+3A_internal_data">internal_data</code></td>
<td>
<p>A tibble of the internal data.</p>
</td></tr>
<tr><td><code id="calc_post_norm_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_post_norm_+3A_prior">prior</code></td>
<td>
<p>A distributional object corresponding to a normal distribution,
a t distribution, or a mixture distribution of normal and/or t components</p>
</td></tr>
<tr><td><code id="calc_post_norm_+3A_internal_sd">internal_sd</code></td>
<td>
<p>Standard deviation of internal response data if
assumed known. It can be left as <code>NULL</code> if assumed unknown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given arm of an internal trial (e.g., the control arm or an
active treatment arm) of size <code class="reqn">N_I</code>, suppose the response data are normally
distributed such that <code class="reqn">Y_i \sim N(\theta, \sigma_I^2)</code>, <code class="reqn">i=1,\ldots,N_I</code>.
If <code class="reqn">\sigma_I^2</code> is assumed known, the posterior distribution for <code class="reqn">\theta</code>
is written as
</p>
<p style="text-align: center;"><code class="reqn">\pi( \theta \mid \boldsymbol{y}, \sigma_{I}^2 ) \propto \mathcal{L}(\theta \mid \boldsymbol{y}, \sigma_{I}^2) \; \pi(\theta),</code>
</p>

<p>where <code class="reqn">\mathcal{L}(\theta \mid \boldsymbol{y}, \sigma_{I}^2)</code> is the
likelihood of the response data from the internal arm and <code class="reqn">\pi(\theta)</code>
is a prior distribution on <code class="reqn">\theta</code> (either a normal distribution, a
<code class="reqn">t</code> distribution, or a mixture distribution with an arbitrary number of
normal and/or <code class="reqn">t</code> components). Any <code class="reqn">t</code> components of the prior for
<code class="reqn">\theta</code> are approximated with a mixture of two normal distributions.
</p>
<p>If <code class="reqn">\sigma_I^2</code> is unknown, the marginal posterior distribution for
<code class="reqn">\theta</code> is instead written as
</p>
<p style="text-align: center;"><code class="reqn">\pi( \theta \mid \boldsymbol{y} ) \propto \left\{ \int_0^\infty \mathcal{L}(\theta, \sigma_{I}^2 \mid \boldsymbol{y}) \; \pi(\sigma_{I}^2) \; d\sigma_{I}^2 \right\} \times \pi(\theta).</code>
</p>

<p>In this case, the prior for <code class="reqn">\sigma_I^2</code> is chosen to be
<code class="reqn">\pi(\sigma_{I}^2) = (\sigma_I^2)^{-1}</code> such that
<code class="reqn">\left\{ \int_0^\infty \mathcal{L}(\theta, \sigma_{I}^2 \mid \boldsymbol{y}) \; \pi(\sigma_{I}^2) \; d\sigma_{I}^2 \right\}</code>
becomes a non-standardized <code class="reqn">t</code> distribution. This integrated likelihood
is then approximated with a mixture of two normal distributions.
</p>
<p>If <code>internal_sd</code> is supplied a positive value and <code>prior</code> corresponds to a
single normal distribution, then the posterior distribution for <code class="reqn">\theta</code>
is a normal distribution. If <code>internal_sd = NULL</code> or if other types of prior
distributions are specified (e.g., mixture or t distribution), then the
posterior distribution is a mixture of normal distributions.
</p>


<h3>Value</h3>

<p>distributional object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
post_treated &lt;- calc_post_norm(internal_data = filter(int_norm_df, trt == 1),
                               response = y,
                               prior = dist_normal(50, 10),
                               internal_sd = 0.15)

</code></pre>

<hr>
<h2 id='calc_post_weibull'>Calculate Posterior Weibull</h2><span id='topic+calc_post_weibull'></span>

<h3>Description</h3>

<p>Calculate a posterior distribution for the probability of
surviving past a given analysis time(s) for time-to-event data with a
Weibull likelihood. Only the relevant treatment arms from the internal
dataset should be read in (e.g., only the control arm if constructing a
posterior distribution for the control survival probability).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_post_weibull(internal_data, response, event, prior, analysis_time, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_post_weibull_+3A_internal_data">internal_data</code></td>
<td>
<p>This can either be a propensity score object or a tibble
of the internal data.</p>
</td></tr>
<tr><td><code id="calc_post_weibull_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_post_weibull_+3A_event">event</code></td>
<td>
<p>Name of event indicator variable (1: event; 0: censored)</p>
</td></tr>
<tr><td><code id="calc_post_weibull_+3A_prior">prior</code></td>
<td>
<p>A distributional object corresponding to a multivariate normal
distribution or a mixture of 2 multivariate normals. The first element
of the mean vector and the first row/column of covariance matrix correspond
to the log-shape parameter, and the second element corresponds to the intercept
(i.e., log-inverse-scale) parameter.</p>
</td></tr>
<tr><td><code id="calc_post_weibull_+3A_analysis_time">analysis_time</code></td>
<td>
<p>Vector of time(s) when survival probabilities will be
calculated</p>
</td></tr>
<tr><td><code id="calc_post_weibull_+3A_...">...</code></td>
<td>
<p>rstan sampling option. This overrides any default options. For more
information, see <code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given arm of an internal trial (e.g., the control arm or an
active treatment arm) of size <code class="reqn">N_I</code>, suppose the response data are time to event
such that <code class="reqn">Y_i \sim \mbox{Weibull}(\alpha, \sigma)</code>, where
</p>
<p style="text-align: center;"><code class="reqn">f(y_i \mid \alpha, \sigma) = \left( \frac{\alpha}{\sigma} \right) \left( \frac{y_i}{\sigma}
  \right)^{\alpha - 1} \exp \left( -\left( \frac{y_i}{\sigma} \right)^\alpha
  \right),</code>
</p>

<p><code class="reqn">i=1,\ldots,N_I</code>. Define <code class="reqn">\boldsymbol{\theta} = \{\log(\alpha), \beta\}</code>
where <code class="reqn">\beta = -\log(\sigma)</code> is the intercept parameter of a Weibull
proportional hazards regression model. The posterior distribution for
<code class="reqn">\boldsymbol{\theta}</code> is written as
</p>
<p style="text-align: center;"><code class="reqn">\pi( \boldsymbol{\theta} \mid \boldsymbol{y}, \boldsymbol{\nu} ) \propto
  \mathcal{L}(\boldsymbol{\theta} \mid \boldsymbol{y}, \boldsymbol{\nu}) \;
  \pi(\boldsymbol{\theta}),</code>
</p>

<p>where <code class="reqn">\mathcal{L}(\boldsymbol{\theta} \mid \boldsymbol{y}, \boldsymbol{\nu}) =
  \prod_{i=1}^{N_I} f(y_i \mid \boldsymbol{\theta})^{\nu_i} S(y_i \mid \boldsymbol{\theta})^{1 - \nu_i}</code>
is the likelihood of the response data from the internal arm with event indicator
<code class="reqn">\boldsymbol{\nu}</code> and survival function <code class="reqn">S(y_i \mid \boldsymbol{\theta}) =
  1 - F(y_i \mid \boldsymbol{\theta})</code>, and <code class="reqn">\pi(\boldsymbol{\theta})</code> is a prior
distribution on <code class="reqn">\boldsymbol{\theta}</code> (either a multivariate normal distribution or a
mixture of two multivariate normal distributions). Note that the posterior distribution
for <code class="reqn">\boldsymbol{\theta}</code> does not have a closed form, and thus MCMC samples
for <code class="reqn">\log(\alpha)</code> and <code class="reqn">\beta</code> are drawn from the posterior. These MCMC
samples are used to construct samples from the posterior distribution
for the probability of surviving past the specified analysis time(s) for the
given arm.
</p>
<p>To construct a posterior distribution for the treatment difference (i.e., the
difference in survival probabilities at the specified analysis time), obtain MCMC
samples from the posterior distributions for the survival probabilities under
each arm and then subtract the control-arm samples from the treatment-arm
samples.
</p>


<h3>Value</h3>

<p>stan posterior object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
library(rstan)
mvn_prior &lt;- dist_multivariate_normal(
   mu = list(c(0.3, -2.6)),
   sigma = list(matrix(c(1.5, 0.3, 0.3, 1.1), nrow = 2)))
post_treated &lt;- calc_post_weibull(filter(int_tte_df, trt == 1),
                                  response = y,
                                  event = event,
                                  prior = mvn_prior,
                                  analysis_time = 12,
                                  warmup = 5000,
                                  iter = 15000)
# Extract MCMC samples of survival probabilities at time t=12
surv_prob_treated &lt;- as.data.frame(extract(post_treated,
                                   pars = c("survProb")))[,1]
</code></pre>

<hr>
<h2 id='calc_power_prior_beta'>Calculate Power Prior Beta</h2><span id='topic+calc_power_prior_beta'></span>

<h3>Description</h3>

<p>Calculate a (potentially inverse probability weighted) beta
power prior for the control response rate using external control data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_power_prior_beta(external_data, response, prior)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_power_prior_beta_+3A_external_data">external_data</code></td>
<td>
<p>This can either be a <code>prop_scr_obj</code> created by calling
<code>create_prop_scr()</code> or a tibble of the external data. If it is just a
tibble the weights will be assumed to be 1.</p>
</td></tr>
<tr><td><code id="calc_power_prior_beta_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_power_prior_beta_+3A_prior">prior</code></td>
<td>
<p>A beta distributional object that is the initial prior for the
control response rate before the external control data are observed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted participant-level response data from the control arm of an
external study are incorporated into an inverse probability weighted (IPW)
power prior for the control response rate <code class="reqn">\theta_C</code>. When borrowing
information from an external control arm of size <code class="reqn">N_{EC}</code>, the components
of the IPW power prior for <code class="reqn">\theta_C</code> are defined as follows:
</p>

<dl>
<dt>Initial prior:</dt><dd><p style="text-align: center;"><code class="reqn">\theta_C \sim \mbox{Beta}(\nu_0, \phi_0)</code>
</p>
</dd>
<dt>IPW likelihood of the external response data <code class="reqn">\boldsymbol{y}_E</code> with
weights <code class="reqn">\hat{\boldsymbol{a}}_0</code>:</dt><dd><p style="text-align: center;"><code class="reqn">\mathcal{L}_E(\theta_C \mid
    \boldsymbol{y}_E, \hat{\boldsymbol{a}}_0) \propto \exp \left( \sum_{i=1}^{N_{EC}}
    \hat{a}_{0i} \left[ y_i \log(\theta_C) + (1 - y_i) \log(1 - \theta_C) \right] \right)</code>
</p>
</dd>
<dt>IPW power prior:</dt><dd><p style="text-align: center;"><code class="reqn">\theta_C \mid \boldsymbol{y}_E, \hat{\boldsymbol{a}}_0
    \sim \mbox{Beta} \left( \sum_{i=1}^{N_{EC}} \hat{a}_{0i} y_i + \nu_0,
    \sum_{i=1}^{N_{EC}} \hat{a}_{0i} (1 - y_i) + \phi_0 \right)</code>
</p>
</dd>
</dl>

<p>Defining the weights <code class="reqn">\hat{\boldsymbol{a}}_0</code> to equal 1 results in a
conventional beta power prior.
</p>


<h3>Value</h3>

<p>Beta power prior object
</p>


<h3>See Also</h3>

<p>Other power prior: 
<code><a href="#topic+calc_power_prior_norm">calc_power_prior_norm</a>()</code>,
<code><a href="#topic+calc_power_prior_weibull">calc_power_prior_weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
# This function can be used directly on the data
calc_power_prior_beta(external_data = ex_binary_df,
                      response = y,
                      prior = dist_beta(0.5, 0.5))

# Or this function can be used with a propensity score object
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_binary_df, trt == 0),
                        external_df = ex_binary_df,
                        id_col = subjid,
                        model = ~ cov1 + cov2 + cov3 + cov4)

calc_power_prior_beta(ps_obj,
                      response = y,
                      prior = dist_beta(0.5, 0.5))
</code></pre>

<hr>
<h2 id='calc_power_prior_norm'>Calculate Power Prior Normal</h2><span id='topic+calc_power_prior_norm'></span>

<h3>Description</h3>

<p>Calculate a (potentially inverse probability weighted) normal
power prior using external data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_power_prior_norm(
  external_data,
  response,
  prior = NULL,
  external_sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_power_prior_norm_+3A_external_data">external_data</code></td>
<td>
<p>This can either be a <code>prop_scr_obj</code> created by calling
<code>create_prop_scr()</code> or a tibble of the external data. If it is just a
tibble the weights will be assumed to be 1. Only the external data for the
arm(s) of interest should be included in this object (e.g., external
control data if creating a power prior for the control mean)</p>
</td></tr>
<tr><td><code id="calc_power_prior_norm_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_power_prior_norm_+3A_prior">prior</code></td>
<td>
<p>Either <code>NULL</code> or a normal distributional object that is the
initial prior for the parameter of interest (e.g., control mean) before the
external data are observed</p>
</td></tr>
<tr><td><code id="calc_power_prior_norm_+3A_external_sd">external_sd</code></td>
<td>
<p>Standard deviation of external response data if assumed
known. It can be left as <code>NULL</code> if assumed unknown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted participant-level response data from an external study are
incorporated into an inverse probability weighted (IPW) power prior for the
parameter of interest <code class="reqn">\theta</code> (e.g., the control mean if borrowing
from an external control arm). When borrowing information from an external
dataset of size <code class="reqn">N_{E}</code>, the IPW likelihood of the external response
data <code class="reqn">\boldsymbol{y}_E</code> with weights <code class="reqn">\hat{\boldsymbol{a}}_0</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{L}_E(\theta \mid \boldsymbol{y}_E, \hat{\boldsymbol{a}}_0,
  \sigma_{E}^2) \propto \exp \left( -\frac{1}{2 \sigma_{E}^2}
  \sum_{i=1}^{N_{E}} \hat{a}_{0i} (y_i - \theta)^2 \right).</code>
</p>

<p>The <code>prior</code> argument should be either a distributional object with a family
type of <code>normal</code> or <code>NULL</code>, corresponding to the use of a normal initial
prior or an improper uniform initial prior (i.e., <code class="reqn">\pi(\theta) \propto
  1</code>), respectively.
</p>
<p>The <code>external_sd</code> argument can be a positive value if the external standard
deviation is assumed known or left as <code>NULL</code> otherwise. If <code>external_sd = NULL</code>, then <code>prior</code> must be <code>NULL</code> to indicate the use of an improper
uniform initial prior for <code class="reqn">\theta</code>, and an improper prior is defined
for the unknown external standard deviation such that <code class="reqn">\pi(\sigma_E^2)
  \propto (\sigma_E^2)^{-1}</code>. The details of the IPW power prior for each
case are as follows:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;external_sd = positive value&#8288;</code> (<code class="reqn">\sigma_E^2</code> known):</dt><dd><p>With
either a proper normal or an improper uniform initial prior, the IPW
weighted power prior for <code class="reqn">\theta</code> is a normal distribution.</p>
</dd>
<dt><code>external_sd = NULL</code> (<code class="reqn">\sigma_E^2</code> unknown):</dt><dd><p>With improper
priors for both <code class="reqn">\theta</code> and <code class="reqn">\sigma_E^2</code>, the marginal IPW weighted
power prior for <code class="reqn">\theta</code> after integrating over <code class="reqn">\sigma_E^2</code> is
a non-standardized <code class="reqn">t</code> distribution.</p>
</dd>
</dl>

<p>Defining the weights <code class="reqn">\hat{\boldsymbol{a}}_0</code> to equal 1 results in a
conventional normal (or <code class="reqn">t</code>) power prior if the external standard
deviation is known (unknown).
</p>


<h3>Value</h3>

<p>Normal power prior object
</p>


<h3>See Also</h3>

<p>Other power prior: 
<code><a href="#topic+calc_power_prior_beta">calc_power_prior_beta</a>()</code>,
<code><a href="#topic+calc_power_prior_weibull">calc_power_prior_weibull</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
# This function can be used directly on the data
calc_power_prior_norm(ex_norm_df,
                      response = y,
                      prior = dist_normal(50, 10),
                      external_sd = 0.15)

# Or this function can be used with a propensity score object
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                        external_df = ex_norm_df,
                        id_col = subjid,
                        model = ~ cov1 + cov2 + cov3 + cov4)
calc_power_prior_norm(ps_obj,
                      response = y,
                      prior = dist_normal(50, 10),
                      external_sd = 0.15)

</code></pre>

<hr>
<h2 id='calc_power_prior_weibull'>Calculate Power Prior Weibull</h2><span id='topic+calc_power_prior_weibull'></span>

<h3>Description</h3>

<p>Calculate an approximate (potentially inverse probability weighted)
multivariate normal power prior for the log-shape and log-inverse-scale parameters
of a Weibull likelihood for external time-to-event control data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_power_prior_weibull(
  external_data,
  response,
  event,
  intercept,
  shape,
  approximation = c("Laplace", "MCMC"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_power_prior_weibull_+3A_external_data">external_data</code></td>
<td>
<p>This can either be a <code>prop_scr_obj</code> created by calling
<code>create_prop_scr()</code> or a tibble of the external data. If it is just a
tibble the weights will be assumed to be 1. Only the external data for the
arm(s) of interest should be included in this object (e.g., external
control data if creating a power prior for the control Weibull shape and
intercept parameters)</p>
</td></tr>
<tr><td><code id="calc_power_prior_weibull_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_power_prior_weibull_+3A_event">event</code></td>
<td>
<p>Name of event indicator variable (1: event; 0: censored)</p>
</td></tr>
<tr><td><code id="calc_power_prior_weibull_+3A_intercept">intercept</code></td>
<td>
<p>Normal distributional object that is the initial prior for the
intercept (i.e., log-inverse-scale) parameter</p>
</td></tr>
<tr><td><code id="calc_power_prior_weibull_+3A_shape">shape</code></td>
<td>
<p>Integer value that is the scale of the half-normal prior
for the shape parameter</p>
</td></tr>
<tr><td><code id="calc_power_prior_weibull_+3A_approximation">approximation</code></td>
<td>
<p>Type of approximation to be used. Either <code>Laplace</code> or
<code>MCMC</code>. <code>Laplace</code> is used by default because it is faster than <code>MCMC</code>.</p>
</td></tr>
<tr><td><code id="calc_power_prior_weibull_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>rstan::sampling</code> (e.g. iter, chains).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted participant-level response data from the control arm of an
external study are incorporated into an approximated inverse probability
weighted (IPW) power prior for the parameter vector
<code class="reqn">\boldsymbol{\theta}_C = \{\log(\alpha), \beta\}</code>, where <code class="reqn">\beta = -\log(\sigma)</code>
is the intercept parameter of a Weibull proportional hazards regression model
and <code class="reqn">\alpha</code> and <code class="reqn">\sigma</code> are the Weibull shape and scale parameters,
respectively. When borrowing information from an external dataset of size <code class="reqn">N_{E}</code>,
the IPW likelihood of the external response data <code class="reqn">\boldsymbol{y}_E</code> with
event indicators <code class="reqn">\boldsymbol{\nu}_E</code> and weights <code class="reqn">\hat{\boldsymbol{a}}_0</code>
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{L}_E(\alpha, \sigma \mid \boldsymbol{y}_E, \boldsymbol{\nu}_E,
  \hat{\boldsymbol{a}}_0) \propto \prod_{i=1}^{N_E} \left\{ \left( \frac{\alpha}{\sigma} \right)
  \left( \frac{y_i}{\sigma} \right)^{\alpha - 1} \exp \left( -\left( \frac{y_i}{\sigma} \right)^\alpha
  \right) \right\}^{\hat{a}_{0i} \nu_i} \left\{ \exp \left( -\left( \frac{y_i}{\sigma} \right)^\alpha
  \right) \right\}^{\hat{a}_{0i}(1 - \nu_i)}.</code>
</p>

<p>The initial priors for the intercept parameter <code class="reqn">\beta</code> and the shape parameter
<code class="reqn">\alpha</code> are assumed to be normal and half-normal, respectively, which can
be defined using the <code>intercept</code> and <code>shape</code> arguments.
</p>
<p>The power prior for <code class="reqn">\boldsymbol{\theta}_C</code> does not have a closed form, and
thus we approximate it via a bivariate normal distribution; i.e.,
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\theta}_C \mid \boldsymbol{y}_E, \boldsymbol{\nu}_E, \hat{\boldsymbol{a}}_0
  \; \dot\sim \; \mbox{MVN} \left( \tilde{\boldsymbol{\mu}}_0, \tilde{\boldsymbol{\Sigma}}_0 \right)</code>
</p>
<p>.
If <code>approximation = Laplace</code>, then <code class="reqn">\tilde{\boldsymbol{\mu}}_0</code> is the mode vector
of the IPW power prior and <code class="reqn">\tilde{\boldsymbol{\Sigma}}_0</code> is the negative
inverse of the Hessian of the log IPW power prior evaluated at the mode. If
<code>approximation = MCMC</code>, then MCMC samples are obtained from the IPW power prior,
and <code class="reqn">\tilde{\boldsymbol{\mu}}_0</code> and <code class="reqn">\tilde{\boldsymbol{\Sigma}}_0</code>
are the estimated mean vector and covariance matrix of these MCMC samples.
Note that the Laplace approximation method is faster due to its use of
optimization instead of MCMC sampling.
</p>
<p>The first element of the mean vector and the first row/column of covariance
matrix correspond to the log-shape parameter (<code class="reqn">\log(\alpha)</code>), and the
second element corresponds to the intercept (<code class="reqn">\beta</code>, the log-inverse-scale)
parameter.
</p>


<h3>Value</h3>

<p>Multivariate Normal Distributional Object
</p>


<h3>See Also</h3>

<p>Other power prior: 
<code><a href="#topic+calc_power_prior_beta">calc_power_prior_beta</a>()</code>,
<code><a href="#topic+calc_power_prior_norm">calc_power_prior_norm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
# This function can be used directly on the data
calc_power_prior_weibull(ex_tte_df,
                         response = y,
                         event = event,
                         intercept = dist_normal(0, 10),
                         shape = 50,
                         approximation = "Laplace")

# Or this function can be used with a propensity score object
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_tte_df, trt == 0),
                        external_df = ex_tte_df,
                        id_col = subjid,
                        model = ~ cov1 + cov2 + cov3 + cov4)
calc_power_prior_weibull(ps_obj,
                         response = y,
                         event = event,
                         intercept = dist_normal(0, 10),
                         shape = 50,
                         approximation = "Laplace")

</code></pre>

<hr>
<h2 id='calc_prop_scr'>Create a Propensity Score Object</h2><span id='topic+calc_prop_scr'></span>

<h3>Description</h3>

<p>Calculate the propensity scores and ATT inverse probability
weights for participants from internal and external datasets. Only the
relevant treatment arms from each dataset should be read in (e.g., only
the control arm from each dataset if creating a hybrid control arm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_prop_scr(internal_df, external_df, id_col, model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_prop_scr_+3A_internal_df">internal_df</code></td>
<td>
<p>Internal dataset with one row per subject and all the
variables needed to run the model</p>
</td></tr>
<tr><td><code id="calc_prop_scr_+3A_external_df">external_df</code></td>
<td>
<p>External dataset with one row per subject and all the
variables needed to run the model</p>
</td></tr>
<tr><td><code id="calc_prop_scr_+3A_id_col">id_col</code></td>
<td>
<p>Name of the column in both datasets used to identify each
subject. It must be the same across datasets</p>
</td></tr>
<tr><td><code id="calc_prop_scr_+3A_model">model</code></td>
<td>
<p>Model used to calculate propensity scores</p>
</td></tr>
<tr><td><code id="calc_prop_scr_+3A_...">...</code></td>
<td>
<p>Optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the subset of participants in both the external and internal
studies for which we want to balance the covariate distributions (e.g.,
external control and internal control participants if constructing a
hybrid control arm), we define a study-inclusion propensity score for
each participant as
</p>
<p style="text-align: center;"><code class="reqn">e(x_i) = P(S_i = 1 \mid x_i),</code>
</p>

<p>where <code class="reqn">x_i</code> denotes a vector of baseline covariates for the <code class="reqn">i</code>th
participant and <code class="reqn">S_i</code> denotes the indicator that the participant is
enrolled in the internal trial (<code class="reqn">S_i = 1</code> if internal, <code class="reqn">S_i = 0</code>
if external). The estimated propensity score <code class="reqn">\hat{e}(x_i)</code> is obtained
using logistic regression.
</p>
<p>An ATT inverse probability weight is calculated for each individual as
</p>
<p style="text-align: center;"><code class="reqn">\hat{a}_{0i} = \frac{\hat{e}(x_i)}{\hat{P}(S_i = s_i | x_i)} = s_i + (1 - s_i ) \frac{\hat{e}(x_i)}{1 - \hat{e}(x_i)}.</code>
</p>

<p>In a weighted estimator, data from participants in the external study
are given a weight of <code class="reqn">\hat{e}(x_i)⁄(1 - \hat{e}(x_i))</code> whereas data
from participants in the internal trial are given a weight of 1.
</p>


<h3>Value</h3>

<p><code>prop_scr_obj</code> object, with the internal and the external data and
the propensity score and inverse probability weight calculated for each
subject.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This can be used for both continuous and binary data
library(dplyr)
# Continuous
calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
# Binary
calc_prop_scr(internal_df = filter(int_binary_df, trt == 0),
                       external_df = ex_binary_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)

</code></pre>

<hr>
<h2 id='ex_binary_df'>External Binary Control Data for Propensity Score Balancing</h2><span id='topic+ex_binary_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a binary endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_binary_df
</code></pre>


<h3>Format</h3>



<h4><code>ex_binary_df</code></h4>

<p>A data frame with 150 rows and 6 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 65 with a SD of 10</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 50% of participants having level 1</p>
</dd>
<dt>y</dt><dd><p>Response, which is binary (0 vs. 1)</p>
</dd>
</dl>



<hr>
<h2 id='ex_norm_df'>External Normal Control Data for Propensity Score Balancing</h2><span id='topic+ex_norm_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a normal endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_norm_df
</code></pre>


<h3>Format</h3>



<h4><code>ex_norm_df</code></h4>

<p>A data frame with 150 rows and 6 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 50 with a SD of 10</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 20% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 60% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>y</dt><dd><p>Response, which is normally distributed with a SD of 0.15</p>
</dd>
</dl>



<hr>
<h2 id='ex_tte_df'>External Time-to-Event Control Data for Propensity Score Balancing</h2><span id='topic+ex_tte_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a time-to-event endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_tte_df
</code></pre>


<h3>Format</h3>



<h4><code>ex_tte_df</code></h4>

<p>A data frame with 150 rows and 9 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>y</dt><dd><p>Response (observed time at which the participant either had an event or was censored)</p>
</dd>
<dt>enr_time</dt><dd><p>Enrollment time</p>
</dd>
<dt>total_time</dt><dd><p>Time from study start</p>
</dd>
<dt>event</dt><dd><p>Event indicator (1: event; 0: censored)</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 65 with a SD of 10</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 50% of participants having level 1</p>
</dd>
</dl>



<hr>
<h2 id='int_binary_df'>Internal Binary Data for Propensity Score Balancing</h2><span id='topic+int_binary_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a binary endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_binary_df
</code></pre>


<h3>Format</h3>



<h4><code>int_binary_df</code></h4>

<p>A data frame with 160 rows and 7 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 62 with an sd of 8</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 60% of participants having level 1</p>
</dd>
<dt>trt</dt><dd><p>Treatment indicator, where 0 = control and 1 = active treatment</p>
</dd>
<dt>y</dt><dd><p>Response, which is binary (0 vs. 1)</p>
</dd>
</dl>



<hr>
<h2 id='int_norm_df'>Internal Normal Data for Propensity Score Balancing</h2><span id='topic+int_norm_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a normal endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_norm_df
</code></pre>


<h3>Format</h3>



<h4><code>int_norm_df</code></h4>

<p>A data frame with 120 rows and 7 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 55 with a SD of 8</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 50% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>trt</dt><dd><p>Treatment indicator, where 0 = control and 1 = active treatment</p>
</dd>
<dt>y</dt><dd><p>Response, which is normally distributed with a SD of 0.15</p>
</dd>
</dl>



<hr>
<h2 id='int_tte_df'>Internal Time-to-Event Control Data for Propensity Score Balancing</h2><span id='topic+int_tte_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a time-to-event endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_tte_df
</code></pre>


<h3>Format</h3>



<h4><code>int_tte_df</code></h4>

<p>A data frame with 160 rows and 10 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>y</dt><dd><p>Response (observed time at which the participant either had an event or was censored)</p>
</dd>
<dt>enr_time</dt><dd><p>Enrollment time</p>
</dd>
<dt>total_time</dt><dd><p>Time from study start</p>
</dd>
<dt>event</dt><dd><p>Event indicator (1: event; 0: censored)</p>
</dd>
<dt>trt</dt><dd><p>Treatment indicator, where 0 = control and 1 = active treatment</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 62 with a SD of 8</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 60% of participants having level 1</p>
</dd>
</dl>



<hr>
<h2 id='is_prop_scr'>Test If Propensity Score Object</h2><span id='topic+is_prop_scr'></span>

<h3>Description</h3>

<p>Test If Propensity Score Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_prop_scr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_prop_scr_+3A_x">x</code></td>
<td>
<p>Object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
x &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
is_prop_scr(x)

</code></pre>

<hr>
<h2 id='mix_means'>Extract Means of Mixture Components</h2><span id='topic+mix_means'></span>

<h3>Description</h3>

<p>Extract Means of Mixture Components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix_means(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mix_means_+3A_x">x</code></td>
<td>
<p>A mixture distributional object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a distributional object that is a mixture of two or more normal
distributions is read in, the function will return a numeric object with
the means of each normal component. If the distributional object is a
mixture of two or more multivariate normal distributions, the function
will return a list with the mean vectors of each multivariate normal
component.
</p>


<h3>Value</h3>

<p>numeric or list object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
mix_norm &lt;- dist_mixture(comp1 = dist_normal(1, 10),
                         comp2 = dist_normal(1.5, 12),
                         weights = c(.5, .5))
mix_means(mix_norm)
</code></pre>

<hr>
<h2 id='mix_sigmas'>Extract Standard Deviations of Mixture Components</h2><span id='topic+mix_sigmas'></span>

<h3>Description</h3>

<p>Extract Standard Deviations of Mixture Components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mix_sigmas(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mix_sigmas_+3A_x">x</code></td>
<td>
<p>A mixture distributional object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a distributional object that is a mixture of two or more normal
distributions is read in, the function will return a numeric object with
the standard deviations of each normal component. If the distributional
object is a mixture of two or more multivariate normal distributions, the
function will return a list with the covariance matrices of each multivariate
normal component.
</p>


<h3>Value</h3>

<p>numeric or list object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
mix_norm &lt;- dist_mixture(comp1 = dist_normal(1, 10),
                         comp2 = dist_normal(1.5, 12),
                         weights = c(.5, .5))
mix_sigmas(mix_norm)
</code></pre>

<hr>
<h2 id='plot_dist'>Plot Distribution</h2><span id='topic+plot_dist'></span>

<h3>Description</h3>

<p>Plot Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dist(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_dist_+3A_...">...</code></td>
<td>
<p>Distributional object(s) to plot. When passing multiple objects
naming them will change the labels in the plot, else they will use the
distributional format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object that is the density of the provided distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
plot_dist(dist_normal(0, 1))
#Plotting Multiple
plot_dist(dist_normal(0, 1), dist_normal(10, 5))
plot_dist('Prior' = dist_normal(0, 1), 'Posterior' = dist_normal(10, 5))
</code></pre>

<hr>
<h2 id='prop_scr_dens'>Density of the Propensity Score Object</h2><span id='topic+prop_scr_dens'></span>

<h3>Description</h3>

<p>Plot overlapping density curves of the propensity scores for
both the internal and external participants, or plot external IPWs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_scr_dens(
  x,
  variable = c("propensity score", "ps", "inverse probability weight", "ipw"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_scr_dens_+3A_x">x</code></td>
<td>
<p>Propensity score object</p>
</td></tr>
<tr><td><code id="prop_scr_dens_+3A_variable">variable</code></td>
<td>
<p>Variable to plot. It must be either a propensity score
(&quot;ps&quot; or &quot;propensity score&quot;) or inverse probability weight (&quot;ipw&quot; or
&quot;inverse probability weight&quot;)</p>
</td></tr>
<tr><td><code id="prop_scr_dens_+3A_...">...</code></td>
<td>
<p>Optional arguments for <code>geom_density</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
# Plotting the Propensity Scores
prop_scr_dens(ps_obj)
# Or plotting the inverse probability weights
prop_scr_dens(ps_obj, variable = "ipw")

</code></pre>

<hr>
<h2 id='prop_scr_hist'>Histogram of the Propensity Score Object</h2><span id='topic+prop_scr_hist'></span>

<h3>Description</h3>

<p>Plot overlapping histograms of the propensity scores for both
the internal and external participants, or plot external IPWs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_scr_hist(
  x,
  variable = c("propensity score", "ps", "inverse probability weight", "ipw"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_scr_hist_+3A_x">x</code></td>
<td>
<p>Propensity score object</p>
</td></tr>
<tr><td><code id="prop_scr_hist_+3A_variable">variable</code></td>
<td>
<p>Variable to plot. It must be either a propensity score
(&quot;ps&quot; or &quot;propensity score&quot;) or inverse probability weight (&quot;ipw&quot; or
&quot;inverse probability weight&quot;)</p>
</td></tr>
<tr><td><code id="prop_scr_hist_+3A_...">...</code></td>
<td>
<p>Optional arguments for <code>geom_histogram</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
# Plotting the Propensity Scores
prop_scr_hist(ps_obj)
# Or plotting the inverse probability weights
prop_scr_hist(ps_obj, variable = "ipw")
</code></pre>

<hr>
<h2 id='prop_scr_love'>Love Plot of the Absolute Standardized Mean Differences</h2><span id='topic+prop_scr_love'></span>

<h3>Description</h3>

<p>Plot the unadjusted and IPW-adjusted absolute standardized mean
differences for each covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_scr_love(x, reference_line = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop_scr_love_+3A_x">x</code></td>
<td>
<p>Propensity score object</p>
</td></tr>
<tr><td><code id="prop_scr_love_+3A_reference_line">reference_line</code></td>
<td>
<p>Numeric value of where along the x-axis the vertical
reference line should be placed</p>
</td></tr>
<tr><td><code id="prop_scr_love_+3A_...">...</code></td>
<td>
<p>Optional options for <code>geom_point</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
# Plotting the Propensity Scores
prop_scr_love(ps_obj, reference_line = 0.1)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+glance'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='robustify_mvnorm'>Robustify Multivariate Normal Distributions</h2><span id='topic+robustify_mvnorm'></span>

<h3>Description</h3>

<p>Adds vague normal component, where the level of vagueness is controlled by
the <code>n</code> parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustify_mvnorm(prior, n, weights = c(0.5, 0.5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robustify_mvnorm_+3A_prior">prior</code></td>
<td>
<p>Multivariate Normal distributional object</p>
</td></tr>
<tr><td><code id="robustify_mvnorm_+3A_n">n</code></td>
<td>
<p>Number of theoretical participants (or events, for time-to-event data)</p>
</td></tr>
<tr><td><code id="robustify_mvnorm_+3A_weights">weights</code></td>
<td>
<p>Vector of weights, where the first number corresponds to the
informative component and the second is the vague</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In cases with a time-to-event endpoint, a robust mixture prior can be
created by adding a vague multivariate normal component to any multivariate
normal prior with mean vector <code class="reqn">\boldsymbol{\mu}</code> and covariance matrix
<code class="reqn">\boldsymbol{\Sigma}</code>. The vague component is calculated to have the
same mean vector <code class="reqn">\boldsymbol{\mu}</code> and covariance matrix equal to
<code class="reqn">\boldsymbol{\Sigma} \times n</code>, where <code>n</code> is the specified number of
theoretical events.
</p>


<h3>Value</h3>

<p>mixture distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
robustify_mvnorm(
      dist_multivariate_normal(mu = list(c(1, 0)), sigma = list(c(10, 5))),
       n = 15)
</code></pre>

<hr>
<h2 id='robustify_norm'>Robustify Normal Distributions</h2><span id='topic+robustify_norm'></span>

<h3>Description</h3>

<p>Adds vague normal component, where the level of vagueness is controlled by
the <code>n</code> parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustify_norm(prior, n, weights = c(0.5, 0.5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robustify_norm_+3A_prior">prior</code></td>
<td>
<p>Normal or Multivariate Normal distributional object</p>
</td></tr>
<tr><td><code id="robustify_norm_+3A_n">n</code></td>
<td>
<p>Number of theoretical participants (or events, for time-to-event data)</p>
</td></tr>
<tr><td><code id="robustify_norm_+3A_weights">weights</code></td>
<td>
<p>Vector of weights, where the first number corresponds to the
informative component and the second is the vague</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In cases with a normal endpoint, a robust mixture prior can be created by
adding a vague normal component to any normal prior with mean <code class="reqn">\theta</code>
and variance <code class="reqn">\sigma^2</code>.The vague component is calculated to have the
same mean <code class="reqn">\theta</code> and variance equal to <code class="reqn">\sigma^2 \times n</code>, where
<code>n</code> is the specified number of theoretical participants. If robustifying a normal
power prior that was calculated from external control data and <code>n</code> is defined as
the number of external control participants, and the vague component would
then correspond to one external control participant's worth of data.
</p>


<h3>Value</h3>

<p>mixture distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
robustify_norm(dist_normal(0,1), n = 15)
</code></pre>

<hr>
<h2 id='tidy.prop_scr'>Tidy a(n) prop_scr object</h2><span id='topic+tidy.prop_scr'></span>

<h3>Description</h3>

<p>Tidy a(n) prop_scr object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prop_scr'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy.prop_scr_+3A_x">x</code></td>
<td>
<p>a <code>prop_scr</code> obj</p>
</td></tr>
<tr><td><code id="tidy.prop_scr_+3A_...">...</code></td>
<td>
<p>Unused, included for generic consistency only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> summarizing the results of the propensity
score weighting. The tibble will have the id column of the external data,
an <code>internal</code> column to indicate all the data is external, a <code>ps</code> column
with the propensity scores and a <code>weight</code> column with the inverse
probability weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_binary_df, trt == 0),
                       external_df = ex_binary_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
tidy(ps_obj)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
