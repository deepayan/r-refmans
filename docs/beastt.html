<!DOCTYPE html><html><head><title>Help for package beastt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {beastt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_post_beta'><p>Calculate Posterior Beta</p></a></li>
<li><a href='#calc_post_norm'><p>Calculate Posterior Normal</p></a></li>
<li><a href='#calc_power_prior_beta'><p>Calculate Power Prior Beta</p></a></li>
<li><a href='#calc_power_prior_norm'><p>Calculate Power Prior Normal</p></a></li>
<li><a href='#calc_prop_scr'><p>Create a Propensity Score Object</p></a></li>
<li><a href='#ex_binary_df'><p>External Binary Control Data for Propensity Score Balancing</p></a></li>
<li><a href='#ex_norm_df'><p>External Normal Control Data for Propensity Score Balancing</p></a></li>
<li><a href='#int_binary_df'><p>Internal Binary Data for Propensity Score Balancing</p></a></li>
<li><a href='#int_norm_df'><p>Internal Normal Data for Propensity Score Balancing</p></a></li>
<li><a href='#is_prop_scr'><p>Test If Propensity Score Object</p></a></li>
<li><a href='#plot_dist'><p>Plot Distribution</p></a></li>
<li><a href='#prop_scr_dens'><p>Density of the Propensity Score Object</p></a></li>
<li><a href='#prop_scr_hist'><p>Histogram of the Propensity Score Object</p></a></li>
<li><a href='#prop_scr_love'><p>Love Plot of the Absolute Standardized Mean Differences</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#robustify_norm'><p>Robustify Normal Distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Evaluation, Analysis, and Simulation Software Tools for
Trials</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian dynamic borrowing with covariate adjustment via inverse probability 
  weighting for simulations and data analyses in clinical trials. This makes it easy to use
  propensity score methods to balance covariate distributions between external and internal 
  data. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gsk-biostatistics.github.io/beastt/">https://gsk-biostatistics.github.io/beastt/</a>,
<a href="https://github.com/GSK-Biostatistics/beastt">https://github.com/GSK-Biostatistics/beastt</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GSK-Biostatistics/beastt/issues">https://github.com/GSK-Biostatistics/beastt/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, spelling, testthat (&ge; 3.0.0), tibble</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, cobalt, dplyr, generics, ggplot2, purrr, rlang, stringr,
distributional, tidyr, ggdist, mixtools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-18 16:07:16 UTC; christinafillmore</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Fillmore
    <a href="https://orcid.org/0000-0003-0595-2302"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Ben Arancibia [aut],
  Nate Bean <a href="https://orcid.org/0000-0001-9946-0119"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  GlaxoSmithKline Research &amp; Development Limited [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Fillmore &lt;christina.e.fillmore@gsk.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-20 15:50:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_post_beta'>Calculate Posterior Beta</h2><span id='topic+calc_post_beta'></span>

<h3>Description</h3>

<p>Calculate a posterior distribution that is beta (or a mixture
of beta components). Only the relevant treatment arms from the internal
dataset should be read in (e.g., only the control arm if constructing a
posterior distribution for the control response rate).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_post_beta(internal_data, response, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_post_beta_+3A_internal_data">internal_data</code></td>
<td>
<p>This can either be a propensity score object or a tibble
of the internal data.</p>
</td></tr>
<tr><td><code id="calc_post_beta_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_post_beta_+3A_prior">prior</code></td>
<td>
<p>A distributional object corresponding to a beta distribution
or a mixture distribution of beta components</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given arm of an internal trial (e.g., the control arm or an
active treatment arm) of size <code class="reqn">N_I</code>, suppose the response data are binary
such that <code class="reqn">y_i \sim \mbox{Bernoulli}(\theta)</code>, <code class="reqn">i=1,\ldots,N_I</code>. The
posterior distribution for <code class="reqn">\theta</code> is written as
</p>
<p style="text-align: center;"><code class="reqn">\pi( \theta \mid \boldsymbol{y} ) \propto \mathcal{L}(\theta \mid \boldsymbol{y}) \; \pi(\theta),</code>
</p>

<p>where <code class="reqn">\mathcal{L}(\theta \mid \boldsymbol{y})</code> is the likelihood of the
response data from the internal arm and <code class="reqn">\pi(\theta)</code> is a prior
distribution on <code class="reqn">\theta</code> (either a beta distribution or a mixture
distribution with an arbitrary number of beta components). The posterior
distribution for <code class="reqn">\theta</code> is either a beta distribution or a mixture of
beta components depending on whether the prior is a single beta
distribution or a mixture distribution.
</p>


<h3>Value</h3>

<p>distributional object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(distributional)
calc_post_beta(internal_data = filter(int_binary_df, trt == 1),
                              response = y,
                              prior = dist_beta(0.5, 0.5))
</code></pre>

<hr>
<h2 id='calc_post_norm'>Calculate Posterior Normal</h2><span id='topic+calc_post_norm'></span>

<h3>Description</h3>

<p>Calculate a posterior distribution that is normal (or a mixture
of normal components). Only the relevant treatment arms from the internal
dataset should be read in (e.g., only the control arm if constructing a
posterior distribution for the control mean).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_post_norm(internal_data, response, prior, internal_sd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_post_norm_+3A_internal_data">internal_data</code></td>
<td>
<p>This can either be a propensity score object or a tibble
of the internal data.</p>
</td></tr>
<tr><td><code id="calc_post_norm_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_post_norm_+3A_prior">prior</code></td>
<td>
<p>A distributional object corresponding to a normal distribution,
a t distribution, or a mixture distribution of normal and/or t components</p>
</td></tr>
<tr><td><code id="calc_post_norm_+3A_internal_sd">internal_sd</code></td>
<td>
<p>Standard deviation of internal response data if
assumed known. It can be left as <code>NULL</code> if assumed unknown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given arm of an internal trial (e.g., the control arm or an
active treatment arm) of size <code class="reqn">N_I</code>, suppose the response data are normally
distributed such that <code class="reqn">y_i \sim N(\theta, \sigma_I^2)</code>, <code class="reqn">i=1,\ldots,N_I</code>.
If <code class="reqn">\sigma_I^2</code> is assumed known, the posterior distribution for <code class="reqn">\theta</code>
is written as
</p>
<p style="text-align: center;"><code class="reqn">\pi( \theta \mid \boldsymbol{y}, \sigma_{I}^2 ) \propto \mathcal{L}(\theta \mid \boldsymbol{y}, \sigma_{I}^2) \; \pi(\theta),</code>
</p>

<p>where <code class="reqn">\mathcal{L}(\theta \mid \boldsymbol{y}, \sigma_{I}^2)</code> is the
likelihood of the response data from the internal arm and <code class="reqn">\pi(\theta)</code>
is a prior distribution on <code class="reqn">\theta</code> (either a normal distribution, a
<code class="reqn">t</code> distribution, or a mixture distribution with an arbitrary number of
normal and/or <code class="reqn">t</code> components). Any <code class="reqn">t</code> components of the prior for
<code class="reqn">\theta</code> are approximated with a mixture of two normal distributions.
</p>
<p>If <code class="reqn">\sigma_I^2</code> is unknown, the marginal posterior distribution for
<code class="reqn">\theta</code> is instead written as
</p>
<p style="text-align: center;"><code class="reqn">\pi( \theta \mid \boldsymbol{y} ) \propto \left\{ \int_0^\infty \mathcal{L}(\theta, \sigma_{I}^2 \mid \boldsymbol{y}) \; \pi(\sigma_{I}^2) \; d\sigma_{I}^2 \right\} \times \pi(\theta).</code>
</p>

<p>In this case, the prior for <code class="reqn">\sigma_I^2</code> is chosen to be
<code class="reqn">\pi(\sigma_{I}^2) = (\sigma_I^2)^{-1}</code> such that
<code class="reqn">\left\{ \int_0^\infty \mathcal{L}(\theta, \sigma_{I}^2 \mid \boldsymbol{y}) \; \pi(\sigma_{I}^2) \; d\sigma_{I}^2 \right\}</code>
becomes a non-standardized <code class="reqn">t</code> distribution. This integrated likelihood
is then approximated with a mixture of two normal distributions.
</p>
<p>If <code>internal_sd</code> is supplied a positive value and <code>prior</code> corresponds to a
single normal distribution, then the posterior distribution for <code class="reqn">\theta</code>
is a normal distribution. If <code>internal_sd = NULL</code> or if other types of prior
distributions are specified (e.g., mixture or t distribution), then the
posterior distribution is a mixture of normal distributions.
</p>


<h3>Value</h3>

<p>distributional object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
post_treated &lt;- calc_post_norm(internal_data = filter(int_norm_df, trt == 1),
                               response = y,
                               prior = dist_normal(50, 10),
                               internal_sd = 0.15)

</code></pre>

<hr>
<h2 id='calc_power_prior_beta'>Calculate Power Prior Beta</h2><span id='topic+calc_power_prior_beta'></span>

<h3>Description</h3>

<p>Calculate a (potentially inverse probability weighted) beta
power prior for the control response rate using external control data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_power_prior_beta(external_data, response, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_power_prior_beta_+3A_external_data">external_data</code></td>
<td>
<p>This can either be a <code>prop_scr_obj</code> created by calling
<code>create_prop_scr()</code> or a tibble of the external data. If it is just a
tibble the weights will be assumed to be 1.</p>
</td></tr>
<tr><td><code id="calc_power_prior_beta_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_power_prior_beta_+3A_prior">prior</code></td>
<td>
<p>A beta distributional object that is the initial prior for the
control response rate before the external control data are observed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted participant-level response data from an external study are
incorporated into an inverse probability weighted (IPW) power prior for the
control response rate <code class="reqn">\theta_C</code>. When borrowing information from an
external control arm of size <code class="reqn">N_{EC}</code>, the components of the IPW power
prior for <code class="reqn">\theta_C</code> are defined as follows:
</p>

<dl>
<dt>Initial prior:</dt><dd><p><code class="reqn">\theta_C \sim \mbox{Beta}(\nu_0, \phi_0)</code></p>
</dd>
<dt>IPW likelihood of the external response data <code class="reqn">\boldsymbol{y}_E</code> with
weights <code class="reqn">\hat{\boldsymbol{a}}_0</code>:</dt><dd><p><code class="reqn">\mathcal{L}_E(\theta_C \mid
    \boldsymbol{y}_E, \hat{\boldsymbol{a}}_0) \propto \exp \left( \sum_{i=1}^{N_{EC}}
    \hat{a}_{0i} \left[ y_i \log(\theta_C) + (1 - y_i) \log(1 - \theta_C) \right] \right)</code></p>
</dd>
<dt>IPW power prior:</dt><dd><p><code class="reqn">\theta_C \mid \boldsymbol{y}_E, \hat{\boldsymbol{a}}_0
    \sim \mbox{Beta} \left( \sum_{i=1}^{N_{EC}} \hat{a}_{0i} y_i + \nu_0,
    \sum_{i=1}^{N_{EC}} \hat{a}_{0i} (1 - y_i) + \phi_0 \right)</code></p>
</dd>
</dl>

<p>Defining the weights <code class="reqn">\hat{\boldsymbol{a}}_0</code> to equal 1 results in a
conventional beta power prior.
</p>


<h3>Value</h3>

<p>Beta power prior object
</p>


<h3>See Also</h3>

<p>Other power prior: 
<code><a href="#topic+calc_power_prior_norm">calc_power_prior_norm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
# This function can be used directly on the data
calc_power_prior_beta(external_data = ex_binary_df,
  response = y,
  prior = dist_beta(0.5, 0.5))

# Or this function can be used with a propensity score object
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_binary_df, trt == 0),
  external_df = ex_binary_df,
  id_col = subjid,
  model = ~ cov1 + cov2 + cov3 + cov4)

calc_power_prior_beta(ps_obj,
  response = y,
  prior = dist_beta(0.5, 0.5))
</code></pre>

<hr>
<h2 id='calc_power_prior_norm'>Calculate Power Prior Normal</h2><span id='topic+calc_power_prior_norm'></span>

<h3>Description</h3>

<p>Calculate a (potentially inverse probability weighted) normal
power prior using external data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_power_prior_norm(
  external_data,
  response,
  prior = NULL,
  external_sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_power_prior_norm_+3A_external_data">external_data</code></td>
<td>
<p>This can either be a <code>prop_scr_obj</code> created by calling
<code>create_prop_scr()</code> or a tibble of the external data. If it is just a
tibble the weights will be assumed to be 1. Only the external data for the
arm(s) of interest should be included in this object (e.g., external
control data if creating a power prior for the control mean)</p>
</td></tr>
<tr><td><code id="calc_power_prior_norm_+3A_response">response</code></td>
<td>
<p>Name of response variable</p>
</td></tr>
<tr><td><code id="calc_power_prior_norm_+3A_prior">prior</code></td>
<td>
<p>Either <code>NULL</code> or a normal distributional object that is the
initial prior for the parameter of interest (e.g., control mean) before the
external data are observed</p>
</td></tr>
<tr><td><code id="calc_power_prior_norm_+3A_external_sd">external_sd</code></td>
<td>
<p>Standard deviation of external response data if assumed
known. It can be left as <code>NULL</code> if assumed unknown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weighted participant-level response data from an external study are
incorporated into an inverse probability weighted (IPW) power prior for the
parameter of interest <code class="reqn">\theta</code> (e.g., the control mean if borrowing
from an external control arm). When borrowing information from an external
dataset of size <code class="reqn">N_{E}</code>, the IPW likelihood of the external response
data <code class="reqn">y_E</code> with weights <code class="reqn">\hat{\boldsymbol{a}}_0</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{L}_E(\theta \mid \boldsymbol{y}_E, \hat{\boldsymbol{a}}_0,
  \sigma_{E}^2) \propto \exp \left( -\frac{1}{2 \sigma_{E}^2}
  \sum_{i=1}^{N_{E}} \hat{a}_{0i} (y_i - \theta)^2 \right).</code>
</p>

<p>The <code>prior</code> argument should be either a distributional object with a family
type of <code>normal</code> or <code>NULL</code>, corresponding to the use of a normal initial
prior or an improper uniform initial prior (i.e., <code class="reqn">\pi(\theta) \propto
  1</code>), respectively.
</p>
<p>The <code>external_sd</code> argument can be a positive value if the external standard
deviation is assumed known or left as <code>NULL</code> otherwise. If <code>external_sd = NULL</code>, then <code>prior</code> must be <code>NULL</code> to indicate the use of an improper
uniform initial prior for <code class="reqn">\theta</code>, and an improper prior is defined
for the unknown external standard deviation such that <code class="reqn">\pi(\sigma_E^2)
  \propto (\sigma_E^2)^{-1}</code>. The details of the IPW power prior for each
case are as follows:
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;external_sd = positive value&#8288;</code> (<code class="reqn">\sigma_E^2</code> known):</dt><dd><p>With
either a proper normal or an improper uniform initial prior, the IPW
weighted power prior for <code class="reqn">\theta</code> is a normal distribution.</p>
</dd>
<dt><code>external_sd = NULL</code> (<code class="reqn">\sigma_E^2</code> unknown):</dt><dd><p>With improper
priors for both <code class="reqn">\theta</code> and <code class="reqn">\sigma_E^2</code>, the marginal IPW weighted
power prior for <code class="reqn">\theta</code> after integrating over <code class="reqn">\sigma_E^2</code> is
a non-standardized <code class="reqn">t</code> distribution.</p>
</dd>
</dl>

<p>Defining the weights <code class="reqn">\hat{\boldsymbol{a}}_0</code> to equal 1 results in a
conventional normal (or <code class="reqn">t</code>) power prior if the external standard
deviation is known (unknown).
</p>


<h3>Value</h3>

<p>Normal power prior object
</p>


<h3>See Also</h3>

<p>Other power prior: 
<code><a href="#topic+calc_power_prior_beta">calc_power_prior_beta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
library(dplyr)
# This function can be used directly on the data
calc_power_prior_norm(ex_norm_df,
  response = y,
  prior = dist_normal(50, 10),
  external_sd = 0.15)

# Or this function can be used with a propensity score object
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
calc_power_prior_norm(ps_obj,
                     response = y,
                     prior = dist_normal(50, 10),
                     external_sd = 0.15)

</code></pre>

<hr>
<h2 id='calc_prop_scr'>Create a Propensity Score Object</h2><span id='topic+calc_prop_scr'></span>

<h3>Description</h3>

<p>Calculate the propensity scores and ATT inverse probability
weights for participants from internal and external datasets. Only the
relevant treatment arms from each dataset should be read in (e.g., only
the control arm from each dataset if creating a hybrid control arm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_prop_scr(internal_df, external_df, id_col, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_prop_scr_+3A_internal_df">internal_df</code></td>
<td>
<p>Internal dataset with one row per subject and all the
variables needed to run the model</p>
</td></tr>
<tr><td><code id="calc_prop_scr_+3A_external_df">external_df</code></td>
<td>
<p>External dataset with one row per subject and all the
variables needed to run the model</p>
</td></tr>
<tr><td><code id="calc_prop_scr_+3A_id_col">id_col</code></td>
<td>
<p>Name of the column in both datasets used to identify each
subject. It must be the same across datasets</p>
</td></tr>
<tr><td><code id="calc_prop_scr_+3A_model">model</code></td>
<td>
<p>Model used to calculate propensity scores</p>
</td></tr>
<tr><td><code id="calc_prop_scr_+3A_...">...</code></td>
<td>
<p>Optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the subset of participants in both the external and internal
studies for which we want to balance the covariate distributions (e.g.,
external control and internal control participants if constructing a
hybrid control arm), we define a study-inclusion propensity score for
each participant as
</p>
<p style="text-align: center;"><code class="reqn">e(x_i) = P(S_i = 1 \mid x_i),</code>
</p>

<p>where <code class="reqn">x_i</code> denotes a vector of baseline covariates for the <code class="reqn">i</code>th
participant and <code class="reqn">S_i</code> denotes the indicator that the participant is
enrolled in the internal trial (<code class="reqn">S_i = 1</code> if internal, <code class="reqn">S_i = 0</code>
if external). The estimated propensity score <code class="reqn">\hat{e}(x_i)</code> is obtained
using logistic regression.
</p>
<p>An ATT inverse probability weight is calculated for each individual as
</p>
<p style="text-align: center;"><code class="reqn">\hat{a}_{0i} = \frac{\hat{e}(x_i)}{\hat{P}(S_i = s_i | x_i)} = s_i + (1 - s_i ) \frac{\hat{e}(x_i)}{1 - \hat{e}(x_i)}.</code>
</p>

<p>In a weighted estimator, data from participants in the external study
are given a weight of <code class="reqn">\hat{e}(x_i)⁄(1 - \hat{e}(x_i))</code> whereas data
from participants in the internal trial are given a weight of 1.
</p>


<h3>Value</h3>

<p><code>prop_scr_obj</code> object, with the internal and the external data and
the propensity score and inverse probability weight calculated for each
subject.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This can be used for both continuous and binary data
library(dplyr)
# Continuous
calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
# Binary
calc_prop_scr(internal_df = filter(int_binary_df, trt == 0),
                       external_df = ex_binary_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)

</code></pre>

<hr>
<h2 id='ex_binary_df'>External Binary Control Data for Propensity Score Balancing</h2><span id='topic+ex_binary_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a binary endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_binary_df
</code></pre>


<h3>Format</h3>



<h4><code>ex_binary_df</code></h4>

<p>A data frame with 150 rows and 6 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 65 with a SD of 10</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 50% of participants having level 1</p>
</dd>
<dt>y</dt><dd><p>Response, which is binary (0 vs. 1)</p>
</dd>
</dl>



<hr>
<h2 id='ex_norm_df'>External Normal Control Data for Propensity Score Balancing</h2><span id='topic+ex_norm_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a normal endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_norm_df
</code></pre>


<h3>Format</h3>



<h4><code>ex_norm_df</code></h4>

<p>A data frame with 150 rows and 6 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 50 with a SD of 10</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 20% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 60% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>y</dt><dd><p>Response, which is normally distributed with a SD of 0.15</p>
</dd>
</dl>



<hr>
<h2 id='int_binary_df'>Internal Binary Data for Propensity Score Balancing</h2><span id='topic+int_binary_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a binary endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_binary_df
</code></pre>


<h3>Format</h3>



<h4><code>int_binary_df</code></h4>

<p>A data frame with 160 rows and 7 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 62 with an sd of 8</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 40% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 60% of participants having level 1</p>
</dd>
<dt>trt</dt><dd><p>Treatment indicator, where 0 = control and 1 = active treatment</p>
</dd>
<dt>y</dt><dd><p>Response, which is binary (0 vs. 1)</p>
</dd>
</dl>



<hr>
<h2 id='int_norm_df'>Internal Normal Data for Propensity Score Balancing</h2><span id='topic+int_norm_df'></span>

<h3>Description</h3>

<p>This is a simulated dataset used to illustrate Bayesian dynamic borrowing in
the case when borrowing from an external control arm with a normal endpoint,
where the baseline covariate distributions of the internal and external data
are balanced via inverse probability weighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_norm_df
</code></pre>


<h3>Format</h3>



<h4><code>int_norm_df</code></h4>

<p>A data frame with 120 rows and 7 columns:
</p>

<dl>
<dt>subjid</dt><dd><p>Unique subject ID</p>
</dd>
<dt>cov1</dt><dd><p>Covariate 1, which is normally distributed around 55 with a SD of 8</p>
</dd>
<dt>cov2</dt><dd><p>Covariate 2, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>cov3</dt><dd><p>Covariate 3, which is binary (0 vs. 1) with about 50% of participants having level 1</p>
</dd>
<dt>cov4</dt><dd><p>Covariate 4, which is binary (0 vs. 1) with about 30% of participants having level 1</p>
</dd>
<dt>trt</dt><dd><p>Treatment indicator, where 0 = control and 1 = active treatment</p>
</dd>
<dt>y</dt><dd><p>Response, which is normally distributed with a SD of 0.15</p>
</dd>
</dl>



<hr>
<h2 id='is_prop_scr'>Test If Propensity Score Object</h2><span id='topic+is_prop_scr'></span>

<h3>Description</h3>

<p>Test If Propensity Score Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_prop_scr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_prop_scr_+3A_x">x</code></td>
<td>
<p>Object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
x &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
is_prop_scr(x)

</code></pre>

<hr>
<h2 id='plot_dist'>Plot Distribution</h2><span id='topic+plot_dist'></span>

<h3>Description</h3>

<p>Plot Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dist(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dist_+3A_...">...</code></td>
<td>
<p>Distributional object(s) to plot. When passing multiple objects
naming them will change the labels in the plot, else they will use the
distributional format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object that is the density of the provided distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
plot_dist(dist_normal(0, 1))
#Plotting Multiple
plot_dist(dist_normal(0, 1), dist_normal(10, 5))
plot_dist('Prior' = dist_normal(0, 1), 'Posterior' = dist_normal(10, 5))
</code></pre>

<hr>
<h2 id='prop_scr_dens'>Density of the Propensity Score Object</h2><span id='topic+prop_scr_dens'></span>

<h3>Description</h3>

<p>Plot overlapping density curves of the propensity scores for
both the internal and external participants, or plot external IPWs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_scr_dens(
  x,
  variable = c("propensity score", "ps", "inverse probability weight", "ipw"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_scr_dens_+3A_x">x</code></td>
<td>
<p>Propensity score object</p>
</td></tr>
<tr><td><code id="prop_scr_dens_+3A_variable">variable</code></td>
<td>
<p>Variable to plot. It must be either a propensity score
(&quot;ps&quot; or &quot;propensity score&quot;) or inverse probability weight (&quot;ipw&quot; or
&quot;inverse probability weight&quot;)</p>
</td></tr>
<tr><td><code id="prop_scr_dens_+3A_...">...</code></td>
<td>
<p>Optional arguments for <code>geom_density</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
# Plotting the Propensity Scores
prop_scr_dens(ps_obj)
# Or plotting the inverse probability weights
prop_scr_dens(ps_obj, variable = "ipw")

</code></pre>

<hr>
<h2 id='prop_scr_hist'>Histogram of the Propensity Score Object</h2><span id='topic+prop_scr_hist'></span>

<h3>Description</h3>

<p>Plot overlapping histograms of the propensity scores for both
the internal and external participants, or plot external IPWs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_scr_hist(
  x,
  variable = c("propensity score", "ps", "inverse probability weight", "ipw"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_scr_hist_+3A_x">x</code></td>
<td>
<p>Propensity score object</p>
</td></tr>
<tr><td><code id="prop_scr_hist_+3A_variable">variable</code></td>
<td>
<p>Variable to plot. It must be either a propensity score
(&quot;ps&quot; or &quot;propensity score&quot;) or inverse probability weight (&quot;ipw&quot; or
&quot;inverse probability weight&quot;)</p>
</td></tr>
<tr><td><code id="prop_scr_hist_+3A_...">...</code></td>
<td>
<p>Optional arguments for <code>geom_histogram</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
# Plotting the Propensity Scores
prop_scr_hist(ps_obj)
# Or plotting the inverse probability weights
prop_scr_hist(ps_obj, variable = "ipw")
</code></pre>

<hr>
<h2 id='prop_scr_love'>Love Plot of the Absolute Standardized Mean Differences</h2><span id='topic+prop_scr_love'></span>

<h3>Description</h3>

<p>Plot the unadjusted and IPW-adjusted absolute standardized mean
differences for each covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_scr_love(x, reference_line = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_scr_love_+3A_x">x</code></td>
<td>
<p>Propensity score object</p>
</td></tr>
<tr><td><code id="prop_scr_love_+3A_reference_line">reference_line</code></td>
<td>
<p>Numeric value of where along the x-axis the vertical
reference line should be placed</p>
</td></tr>
<tr><td><code id="prop_scr_love_+3A_...">...</code></td>
<td>
<p>Optional options for <code>geom_point</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
ps_obj &lt;- calc_prop_scr(internal_df = filter(int_norm_df, trt == 0),
                       external_df = ex_norm_df,
                       id_col = subjid,
                       model = ~ cov1 + cov2 + cov3 + cov4)
# Plotting the Propensity Scores
prop_scr_love(ps_obj, reference_line = 0.1)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+glance'></span><span id='topic+tidy'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>

<hr>
<h2 id='robustify_norm'>Robustify Normal Distributions</h2><span id='topic+robustify_norm'></span>

<h3>Description</h3>

<p>Adds vague normal component, where the level of vagueness is controlled by
the <code>n</code> parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustify_norm(prior, n, weights = c(0.5, 0.5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robustify_norm_+3A_prior">prior</code></td>
<td>
<p>Normal distributional object</p>
</td></tr>
<tr><td><code id="robustify_norm_+3A_n">n</code></td>
<td>
<p>Number of theoretical participants</p>
</td></tr>
<tr><td><code id="robustify_norm_+3A_weights">weights</code></td>
<td>
<p>Vector of weights, where the first number corresponds to the
informative component and the second is the vague</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In cases with a normal endpoint, a robust mixture prior can be created by
adding a vague normal component to any normal prior with mean <code class="reqn">\theta</code>
and variance <code class="reqn">\sigma^2</code>.The vague component is calculated to have the
same mean <code class="reqn">\theta</code> and variance equal to <code class="reqn">\sigma^2 \times n</code>, where
<code>n</code> is the specified number of theoretical participants. If robustifying a normal
power prior that was calculated from external control data and <code>n</code> is defined as
the number of external control participants, and the vague component would
then correspond to one external control participant's worth of data.
</p>


<h3>Value</h3>

<p>mixture distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(distributional)
robustify_norm(dist_normal(0,1), n = 15)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
