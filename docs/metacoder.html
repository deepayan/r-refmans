<!DOCTYPE html><html lang="en"><head><title>Help for package metacoder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metacoder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>Run when package loads</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>magrittr forward-pipe operator</p></a></li>
<li><a href='#add_alpha'><p>add_alpha</p></a></li>
<li><a href='#all_functions'><p>Get list of usable functions</p></a></li>
<li><a href='#all_names'><p>Return names of data in [taxonomy()] or [taxmap()]</p></a></li>
<li><a href='#ambiguous_patterns'><p>Get patterns for ambiguous taxa</p></a></li>
<li><a href='#ambiguous_synonyms'><p>Get patterns for ambiguous taxa</p></a></li>
<li><a href='#apply_color_scale'><p>Covert numbers to colors</p></a></li>
<li><a href='#arrange_obs'><p>Sort user data in [taxmap()] objects</p></a></li>
<li><a href='#arrange_taxa'><p>Sort the edge list of [taxmap()] objects</p></a></li>
<li><a href='#as_id'><p>Convert a vector to database IDs</p></a></li>
<li><a href='#as_phyloseq'><p>Convert taxmap to phyloseq</p></a></li>
<li><a href='#branches'><p>Get &quot;branch&quot; taxa</p></a></li>
<li><a href='#calc_diff_abund_deseq2'><p>Differential abundance with DESeq2</p></a></li>
<li><a href='#calc_group_mean'><p>Calculate means of groups of columns</p></a></li>
<li><a href='#calc_group_median'><p>Calculate medians of groups of columns</p></a></li>
<li><a href='#calc_group_rsd'><p>Relative standard deviations of groups of columns</p></a></li>
<li><a href='#calc_group_stat'><p>Apply a function to groups of columns</p></a></li>
<li><a href='#calc_n_samples'><p>Count the number of samples</p></a></li>
<li><a href='#calc_obs_props'><p>Calculate proportions from observation counts</p></a></li>
<li><a href='#calc_prop_samples'><p>Calculate the proportion of samples</p></a></li>
<li><a href='#calc_taxon_abund'><p>Sum observation values for each taxon</p></a></li>
<li><a href='#can_be_num'><p>Test if characters can be converted to numbers</p></a></li>
<li><a href='#can_be_used_in_taxmap'><p>Check that a unknown object can be used with taxmap</p></a></li>
<li><a href='#capitalize'><p>Capitalize</p></a></li>
<li><a href='#check_class_col'><p>Check for name/index in input data</p></a></li>
<li><a href='#check_element_length'><p>Check length of graph attributes</p></a></li>
<li><a href='#check_for_pkg'><p>check for packages</p></a></li>
<li><a href='#check_option_groups'><p>Check option: groups</p></a></li>
<li><a href='#check_taxmap_data'><p>Check dataset format</p></a></li>
<li><a href='#classifications'><p>Get classifications of taxa</p></a></li>
<li><a href='#compare_groups'><p>Compare groups of samples</p></a></li>
<li><a href='#complement'><p>Find complement of sequences</p></a></li>
<li><a href='#contains'><p>dplyr select_helpers</p></a></li>
<li><a href='#convert_base'><p>Converts decimal numbers to other bases</p></a></li>
<li><a href='#correct_taxon_names'><p>Look up official names from potentially misspelled names</p></a></li>
<li><a href='#count_capture_groups'><p>Count capture groups</p></a></li>
<li><a href='#counts_to_presence'><p>Apply a function to groups of columns</p></a></li>
<li><a href='#data_used'><p>Get values of data used in expressions</p></a></li>
<li><a href='#database_list'><p>Database list</p></a></li>
<li><a href='#desc_font'><p>Description formatting in print methods</p></a></li>
<li><a href='#diverging_palette'><p>The default diverging color palette</p></a></li>
<li><a href='#DNAbin_to_char'><p>Converts DNAbin to a named character vector</p></a></li>
<li><a href='#do_calc_on_num_cols'><p>Run some function to produce new columns.</p></a></li>
<li><a href='#edge_list_depth'><p>Get distance from root of edgelist observations</p></a></li>
<li><a href='#ends_with'><p>dplyr select_helpers</p></a></li>
<li><a href='#error_font'><p>Font to indicate an error</p></a></li>
<li><a href='#everything'><p>dplyr select_helpers</p></a></li>
<li><a href='#ex_hierarchies'><p>An example hierarchies object</p></a></li>
<li><a href='#ex_hierarchy1'><p>An example Hierarchy object</p></a></li>
<li><a href='#ex_hierarchy2'><p>An example Hierarchy object</p></a></li>
<li><a href='#ex_hierarchy3'><p>An example Hierarchy object</p></a></li>
<li><a href='#ex_taxmap'><p>An example taxmap object</p></a></li>
<li><a href='#extract_tax_data'><p>Extracts taxonomy info from vectors with regex</p></a></li>
<li><a href='#fasta_headers'><p>Get line numbers of FASTA headers</p></a></li>
<li><a href='#filter_ambiguous_taxa'><p>Filter ambiguous taxon names</p></a></li>
<li><a href='#filter_obs'><p>Filter observations with a list of conditions</p></a></li>
<li><a href='#filter_taxa'><p>Filter taxa with a list of conditions</p></a></li>
<li><a href='#filtering-helpers'><p>Taxonomic filtering helpers</p></a></li>
<li><a href='#get_class_from_el'><p>Get classification for taxa in edge list</p></a></li>
<li><a href='#get_data'><p>Get data in a taxmap object by name</p></a></li>
<li><a href='#get_data_frame'><p>Get data in a taxonomy or taxmap object by name</p></a></li>
<li><a href='#get_database_name'><p>Return name of database</p></a></li>
<li><a href='#get_dataset'><p>Get a data set from a taxmap object</p></a></li>
<li><a href='#get_dots_or_list'><p>Get input from dots or list</p></a></li>
<li><a href='#get_edge_children'><p>get_edge_children</p></a></li>
<li><a href='#get_edge_parents'><p>get_edge_parents</p></a></li>
<li><a href='#get_expected_data'><p>Get a data set in as_phyloseq</p></a></li>
<li><a href='#get_node_children'><p>get_node_children</p></a></li>
<li><a href='#get_numeric_cols'><p>Get numeric columns from taxmap table</p></a></li>
<li><a href='#get_numerics'><p>Return numeric values in a character</p></a></li>
<li><a href='#get_optimal_range'><p>Find optimal range</p></a></li>
<li><a href='#get_sort_var'><p>Get a vector from a vector/list/table to be used in mapping</p></a></li>
<li><a href='#get_taxmap_cols'><p>Get a column subset</p></a></li>
<li><a href='#get_taxmap_data'><p>Get a data set from a taxmap object</p></a></li>
<li><a href='#get_taxmap_other_cols'><p>Parse the other_cols option</p></a></li>
<li><a href='#get_taxmap_table'><p>Get a table from a taxmap object</p></a></li>
<li><a href='#get_taxonomy_levels'><p>Get taxonomy levels</p></a></li>
<li><a href='#heat_tree'><p>Plot a taxonomic tree</p></a></li>
<li><a href='#heat_tree_matrix'><p>Plot a matrix of heat trees</p></a></li>
<li><a href='#hierarchies'><p>Make a set of many [hierarchy()] class objects</p></a></li>
<li><a href='#hierarchy'><p>The Hierarchy class</p></a></li>
<li><a href='#highlight_taxon_ids'><p>Highlight taxon ID column</p></a></li>
<li><a href='#hmp_otus'><p>A HMP subset</p></a></li>
<li><a href='#hmp_samples'><p>Sample information for HMP subset</p></a></li>
<li><a href='#id_classifications'><p>Get ID classifications of taxa</p></a></li>
<li><a href='#init_taxmap_data'><p>Convert 'data' input for Taxamp</p></a></li>
<li><a href='#inter_circle_gap'><p>Finds the gap/overlap of circle coordinates</p></a></li>
<li><a href='#internodes'><p>Get &quot;internode&quot; taxa</p></a></li>
<li><a href='#inverse'><p>Generate the inverse of a function</p></a></li>
<li><a href='#is_ambiguous'><p>Find ambiguous taxon names</p></a></li>
<li><a href='#is_branch'><p>Test if taxa are branches</p></a></li>
<li><a href='#is_internode'><p>Test if taxa are &quot;internodes&quot;</p></a></li>
<li><a href='#is_leaf'><p>Test if taxa are leaves</p></a></li>
<li><a href='#is_root'><p>Test if taxa are roots</p></a></li>
<li><a href='#is_stem'><p>Test if taxa are stems</p></a></li>
<li><a href='#label_bounds'><p>Bounding box coords for labels</p></a></li>
<li><a href='#layout_functions'><p>Layout functions</p></a></li>
<li><a href='#leaves'><p>Get leaf taxa</p></a></li>
<li><a href='#leaves_apply'><p>Apply function to leaves of each taxon</p></a></li>
<li><a href='#length_of_thing'><p>Check length of thing</p></a></li>
<li><a href='#limited_print'><p>Print a subset of a character vector</p></a></li>
<li><a href='#line_coords'><p>Makes coordinates for a line</p></a></li>
<li><a href='#look_for_na'><p>Look for NAs in parameters</p></a></li>
<li><a href='#lookup_tax_data'><p>Convert one or more data sets to taxmap</p></a></li>
<li><a href='#make_dada2_asv_table'><p>Make a imitation of the dada2 ASV abundance matrix</p></a></li>
<li><a href='#make_dada2_tax_table'><p>Make a imitation of the dada2 taxonomy matrix</p></a></li>
<li><a href='#make_fasta_with_u_replaced'><p>Make a temporary file U's replaced with T</p></a></li>
<li><a href='#make_plot_legend'><p>Make color/size legend</p></a></li>
<li><a href='#map_data'><p>Create a mapping between two variables</p></a></li>
<li><a href='#map_data_'><p>Create a mapping without NSE</p></a></li>
<li><a href='#map_unique'><p>Run a function on unique values of a iterable</p></a></li>
<li><a href='#matches'><p>dplyr select_helpers</p></a></li>
<li><a href='#metacoder'><p>Metacoder</p></a></li>
<li><a href='#molten_dist'><p>Get all distances between points</p></a></li>
<li><a href='#multi_sep_split'><p>Like 'strsplit', but with multiple separators</p></a></li>
<li><a href='#mutate_obs'><p>Add columns to [taxmap()] objects</p></a></li>
<li><a href='#my_print'><p>Print something</p></a></li>
<li><a href='#n_leaves'><p>Get number of leaves</p></a></li>
<li><a href='#n_leaves_1'><p>Get number of leaves</p></a></li>
<li><a href='#n_obs'><p>Count observations in [taxmap()]</p></a></li>
<li><a href='#n_obs_1'><p>Count observation assigned in [taxmap()]</p></a></li>
<li><a href='#n_subtaxa'><p>Get number of subtaxa</p></a></li>
<li><a href='#n_subtaxa_1'><p>Get number of subtaxa</p></a></li>
<li><a href='#n_supertaxa'><p>Get number of supertaxa</p></a></li>
<li><a href='#n_supertaxa_1'><p>Get number of supertaxa</p></a></li>
<li><a href='#name_font'><p>Variable name formatting in print methods</p></a></li>
<li><a href='#names_used'><p>Get names of data used in expressions</p></a></li>
<li><a href='#ncbi_sequence'><p>Downloads sequences from ids</p></a></li>
<li><a href='#ncbi_taxon_sample'><p>Download representative sequences for a taxon</p></a></li>
<li><a href='#num_range'><p>dplyr select_helpers</p></a></li>
<li><a href='#obs'><p>Get data indexes associated with taxa</p></a></li>
<li><a href='#obs_apply'><p>Apply function to observations per taxon</p></a></li>
<li><a href='#one_of'><p>dplyr select_helpers</p></a></li>
<li><a href='#parse_dada2'><p>Convert the output of dada2 to a taxmap object</p></a></li>
<li><a href='#parse_dataset'><p>Parse options specifying datasets</p></a></li>
<li><a href='#parse_edge_list'><p>Convert a table with an edge list to taxmap</p></a></li>
<li><a href='#parse_greengenes'><p>Parse Greengenes release</p></a></li>
<li><a href='#parse_heirarchies_to_taxonomy'><p>Infer edge list from hierarchies</p></a></li>
<li><a href='#parse_mothur_tax_summary'><p>Parse mothur *.tax.summary Classify.seqs output</p></a></li>
<li><a href='#parse_mothur_taxonomy'><p>Parse mothur Classify.seqs *.taxonomy output</p></a></li>
<li><a href='#parse_newick'><p>Parse a Newick file</p></a></li>
<li><a href='#parse_phylo'><p>Parse a phylo object</p></a></li>
<li><a href='#parse_phyloseq'><p>Convert a phyloseq to taxmap</p></a></li>
<li><a href='#parse_possibly_named_logical'><p>used to parse inputs to 'drop_obs' and 'reassign_obs'</p></a></li>
<li><a href='#parse_primersearch'><p>Parse EMBOSS primersearch output</p></a></li>
<li><a href='#parse_qiime_biom'><p>Parse a BIOM output from QIIME</p></a></li>
<li><a href='#parse_raw_heirarchies_to_taxonomy'><p>Infer edge list from hierarchies composed of character vectors</p></a></li>
<li><a href='#parse_rdp'><p>Parse RDP FASTA release</p></a></li>
<li><a href='#parse_seq_input'><p>Read sequences in an unknown format</p></a></li>
<li><a href='#parse_silva_fasta'><p>Parse SILVA FASTA release</p></a></li>
<li><a href='#parse_summary_seqs'><p>Parse summary.seqs output</p></a></li>
<li><a href='#parse_tax_data'><p>Convert one or more data sets to taxmap</p></a></li>
<li><a href='#parse_ubiome'><p>Converts the uBiome file format to taxmap</p></a></li>
<li><a href='#parse_unite_general'><p>Parse UNITE general release FASTA</p></a></li>
<li><a href='#polygon_coords'><p>Makes coordinates for a regular polygon</p></a></li>
<li><a href='#prefixed_print'><p>Print a object with a prefix</p></a></li>
<li><a href='#primersearch'><p>Use EMBOSS primersearch for in silico PCR</p></a></li>
<li><a href='#primersearch_is_installed'><p>Test if primersearch is installed</p></a></li>
<li><a href='#primersearch_raw'><p>Use EMBOSS primersearch for in silico PCR</p></a></li>
<li><a href='#print__character'><p>Print a character</p></a></li>
<li><a href='#print__data.frame'><p>Print a data.frame</p></a></li>
<li><a href='#print__default_'><p>Print method for unsupported</p></a></li>
<li><a href='#print__factor'><p>Print a factor</p></a></li>
<li><a href='#print__integer'><p>Print an integer</p></a></li>
<li><a href='#print__list'><p>Print a list</p></a></li>
<li><a href='#print__logical'><p>Print a logical</p></a></li>
<li><a href='#print__matrix'><p>Print a matrix</p></a></li>
<li><a href='#print__numeric'><p>Print a numeric</p></a></li>
<li><a href='#print__ordered'><p>Print a ordered factor</p></a></li>
<li><a href='#print__tbl_df'><p>Print a tibble</p></a></li>
<li><a href='#print__vector'><p>Generic vector printer</p></a></li>
<li><a href='#print_item'><p>Print a item</p></a></li>
<li><a href='#print_tree'><p>Print a text tree</p></a></li>
<li><a href='#progress_lapply'><p>lappy with progress bars</p></a></li>
<li><a href='#punc_font'><p>Punctuation formatting in print methods</p></a></li>
<li><a href='#qualitative_palette'><p>The default qualitative color palette</p></a></li>
<li><a href='#quantative_palette'><p>The default quantative color palette</p></a></li>
<li><a href='#ranks_ref'><p>Lookup-table for IDs of taxonomic ranks</p></a></li>
<li><a href='#rarefy_obs'><p>Calculate rarefied observation counts</p></a></li>
<li><a href='#read_fasta'><p>Read a FASTA file</p></a></li>
<li><a href='#read_lines_apply'><p>Apply a function to chunks of a file</p></a></li>
<li><a href='#remove_redundant_names'><p>Remove redundant parts of taxon names</p></a></li>
<li><a href='#replace_taxon_ids'><p>Replace taxon ids</p></a></li>
<li><a href='#repo_url'><p>Return github url</p></a></li>
<li><a href='#rescale'><p>Rescale numeric vector to have specified minimum and maximum.</p></a></li>
<li><a href='#rev_comp'><p>Revere complement sequences</p></a></li>
<li><a href='#reverse'><p>Reverse sequences</p></a></li>
<li><a href='#roots'><p>Get root taxa</p></a></li>
<li><a href='#run_primersearch'><p>Execute EMBOSS Primersearch</p></a></li>
<li><a href='#sample_frac_obs'><p>Sample a proportion of observations from [taxmap()]</p></a></li>
<li><a href='#sample_frac_taxa'><p>Sample a proportion of taxa from [taxonomy()] or [taxmap()]</p></a></li>
<li><a href='#sample_n_obs'><p>Sample n observations from [taxmap()]</p></a></li>
<li><a href='#sample_n_taxa'><p>Sample n taxa from [taxonomy()] or [taxmap()]</p></a></li>
<li><a href='#scale_bar_coords'><p>Make scale bar division</p></a></li>
<li><a href='#select_labels'><p>Pick labels to show</p></a></li>
<li><a href='#select_obs'><p>Subset columns in a [taxmap()] object</p></a></li>
<li><a href='#simplify'><p>List to vector of unique elements</p></a></li>
<li><a href='#split_by_level'><p>Splits a taxonomy at a specific level or rank</p></a></li>
<li><a href='#starts_with'><p>dplyr select_helpers</p></a></li>
<li><a href='#startup_msg'><p>Return startup message</p></a></li>
<li><a href='#stems'><p>Get stem taxa</p></a></li>
<li><a href='#subtaxa'><p>Get subtaxa</p></a></li>
<li><a href='#subtaxa_apply'><p>Apply function to subtaxa of each taxon</p></a></li>
<li><a href='#supertaxa'><p>Get all supertaxa of a taxon</p></a></li>
<li><a href='#supertaxa_apply'><p>Apply function to supertaxa of each taxon</p></a></li>
<li><a href='#taxa'><p>A class for multiple taxon objects</p></a></li>
<li><a href='#taxmap'><p>Taxmap class</p></a></li>
<li><a href='#taxon'><p>Taxon class</p></a></li>
<li><a href='#taxon_database'><p>Taxonomy database class</p></a></li>
<li><a href='#taxon_id'><p>Taxon ID class</p></a></li>
<li><a href='#taxon_ids'><p>Get taxon IDs</p></a></li>
<li><a href='#taxon_indexes'><p>Get taxon indexes</p></a></li>
<li><a href='#taxon_name'><p>Taxon name class</p></a></li>
<li><a href='#taxon_names'><p>Get taxon names</p></a></li>
<li><a href='#taxon_rank'><p>Taxon rank class</p></a></li>
<li><a href='#taxon_ranks'><p>Get taxon ranks</p></a></li>
<li><a href='#taxonomy'><p>Taxonomy class</p></a></li>
<li><a href='#taxonomy_table'><p>Convert taxonomy info to a table</p></a></li>
<li><a href='#text_grob_length'><p>Estimate text grob length</p></a></li>
<li><a href='#tid_font'><p>Taxon id formatting in print methods</p></a></li>
<li><a href='#to_percent'><p>Format a proportion as a printed percent</p></a></li>
<li><a href='#transform_data'><p>Transformation functions</p></a></li>
<li><a href='#transmute_obs'><p>Replace columns in [taxmap()] objects</p></a></li>
<li><a href='#unique_mapping'><p>get indexes of a unique set of the input</p></a></li>
<li><a href='#validate_regex_key_pair'><p>Check a regex-key pair</p></a></li>
<li><a href='#validate_regex_match'><p>Check that all match input</p></a></li>
<li><a href='#validate_taxmap_funcs'><p>Validate 'funcs' input for Taxamp</p></a></li>
<li><a href='#verify_color_range'><p>Verify color range parameters</p></a></li>
<li><a href='#verify_label_count'><p>Verify label count</p></a></li>
<li><a href='#verify_size'><p>Verify size parameters</p></a></li>
<li><a href='#verify_size_range'><p>Verify size range parameters</p></a></li>
<li><a href='#verify_taxmap'><p>Check that an object is a taxmap</p></a></li>
<li><a href='#verify_trans'><p>Verify transformation function parameters</p></a></li>
<li><a href='#write_greengenes'><p>Write an imitation of the Greengenes database</p></a></li>
<li><a href='#write_mothur_taxonomy'><p>Write an imitation of the Mothur taxonomy file</p></a></li>
<li><a href='#write_rdp'><p>Write an imitation of the RDP FASTA database</p></a></li>
<li><a href='#write_silva_fasta'><p>Write an imitation of the SILVA FASTA database</p></a></li>
<li><a href='#write_unite_general'><p>Write an imitation of the UNITE general FASTA database</p></a></li>
<li><a href='#zero_low_counts'><p>Replace low counts with zero</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Parsing, Manipulating, and Graphing Taxonomic
Abundance Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zachary Foster &lt;zacharyfoster1989@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Reads, plots, and manipulates large
    taxonomic data sets, like those generated from modern high-throughput
    sequencing, such as metabarcoding (i.e. amplification metagenomics, 16S
    metagenomics, etc). It provides a tree-based visualization called "heat
    trees" used to depict statistics for every taxon in a taxonomy using
    color and size. It also provides various functions to do common tasks in
    microbiome bioinformatics on data in the 'taxmap' format defined by the
    'taxa' package. The 'metacoder' package is described in the publication
    by Foster et al. (2017) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1005404">doi:10.1371/journal.pcbi.1005404</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://grunwaldlab.github.io/metacoder_documentation/">https://grunwaldlab.github.io/metacoder_documentation/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/grunwaldlab/metacoder/issues">https://github.com/grunwaldlab/metacoder/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, ggplot2, igraph, grid, taxize, seqinr, RCurl, ape,
stats, grDevices, utils, lazyeval, dplyr, magrittr, readr,
rlang, ggfittext, vegan, cowplot, GA, Rcpp, crayon, tibble, R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, zlibbioc, BiocManager, phyloseq,
phylotate, traits, biomformat, DESeq2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-11 16:17:55 UTC; fosterz</td>
</tr>
<tr>
<td>Author:</td>
<td>Zachary Foster [aut, cre],
  Niklaus Grunwald [ths],
  Kamil Slowikowski [ctb],
  Scott Chamberlain [ctb],
  Rob Gilmore [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-11 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>Run when package loads</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>Run when package loads
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>magrittr forward-pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>magrittr forward-pipe operator
</p>
<p>magrittr forward-pipe operator
</p>

<hr>
<h2 id='add_alpha'>add_alpha</h2><span id='topic+add_alpha'></span>

<h3>Description</h3>

<p>add_alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_alpha(col, alpha = 1)
</code></pre>

<hr>
<h2 id='all_functions'>Get list of usable functions</h2><span id='topic+all_functions'></span>

<h3>Description</h3>

<p>Returns the names of all functions that can be called from any environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_functions()
</code></pre>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='all_names'>Return names of data in [taxonomy()] or [taxmap()]</h2><span id='topic+all_names'></span>

<h3>Description</h3>

<p>Return the names of data that can be used with functions in the taxa
package that use [non-standard evaluation](http://adv-r.had.co.nz/Computing-on-the-language.html) (NSE),
like [filter_taxa()].
</p>
<pre>
obj$all_names(tables = TRUE, funcs = TRUE,
  others = TRUE, warn = FALSE)
all_names(obj, tables = TRUE, funcs = TRUE,
  others = TRUE, warn = FALSE)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_names_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()]) The object containing
taxon information to be queried.</p>
</td></tr>
<tr><td><code id="all_names_+3A_tables">tables</code></td>
<td>
<p>This option only applies to [taxmap()] objects. If 'TRUE',
include the names of columns of tables in 'obj$data'</p>
</td></tr>
<tr><td><code id="all_names_+3A_funcs">funcs</code></td>
<td>
<p>This option only applies to [taxmap()] objects. If 'TRUE',
include the names of user-definable functions in 'obj$funcs'.</p>
</td></tr>
<tr><td><code id="all_names_+3A_others">others</code></td>
<td>
<p>This option only applies to [taxmap()] objects. If 'TRUE',
include the names of data in 'obj$data' besides tables.</p>
</td></tr>
<tr><td><code id="all_names_+3A_builtin_funcs">builtin_funcs</code></td>
<td>
<p>This option only applies to [taxmap()] objects. If
'TRUE', include functions like [n_supertaxa()] that provide information for
each taxon.</p>
</td></tr>
<tr><td><code id="all_names_+3A_warn">warn</code></td>
<td>
<p>option only applies to [taxmap()] objects. If 'TRUE', warn if
there are duplicate names. Duplicate names make it unclear what data is
being referred to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'character'
</p>


<h3>See Also</h3>

<p>Other NSE helpers: 
<code><a href="#topic+data_used">data_used</a></code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+names_used">names_used</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the names of all data accesible by non-standard evaluation
all_names(ex_taxmap)

# Dont include the names of automatically included functions.
all_names(ex_taxmap, builtin_funcs = FALSE)

</code></pre>

<hr>
<h2 id='ambiguous_patterns'>Get patterns for ambiguous taxa</h2><span id='topic+ambiguous_patterns'></span>

<h3>Description</h3>

<p>This function stores the regex patterns for ambiguous taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ambiguous_patterns(
  unknown = TRUE,
  uncultured = TRUE,
  case_variations = FALSE,
  whole_match = FALSE,
  name_regex = "."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ambiguous_patterns_+3A_unknown">unknown</code></td>
<td>
<p>If <code>TRUE</code>, Remove taxa with names the suggest they are
placeholders for unknown taxa (e.g. &quot;unknown ...&quot;).</p>
</td></tr>
<tr><td><code id="ambiguous_patterns_+3A_uncultured">uncultured</code></td>
<td>
<p>If <code>TRUE</code>, Remove taxa with names the suggest they are
assigned to uncultured organisms (e.g. &quot;uncultured ...&quot;).</p>
</td></tr>
<tr><td><code id="ambiguous_patterns_+3A_case_variations">case_variations</code></td>
<td>
<p>If <code>TRUE</code>, include variations of letter case.</p>
</td></tr>
<tr><td><code id="ambiguous_patterns_+3A_whole_match">whole_match</code></td>
<td>
<p>If <code>TRUE</code>, add &quot;^&quot; to front and &quot;$&quot; to the back of each
pattern to indicate they are to match whole words.</p>
</td></tr>
<tr><td><code id="ambiguous_patterns_+3A_name_regex">name_regex</code></td>
<td>
<p>The regex code to match a valid character in a taxon name.
For example, &quot;[a-z]&quot; would mean taxon names can only be lower case letters.</p>
</td></tr>
</table>

<hr>
<h2 id='ambiguous_synonyms'>Get patterns for ambiguous taxa</h2><span id='topic+ambiguous_synonyms'></span>

<h3>Description</h3>

<p>This function stores the regex patterns for ambiguous taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ambiguous_synonyms(
  unknown = TRUE,
  uncultured = TRUE,
  regex = TRUE,
  case_variations = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ambiguous_synonyms_+3A_unknown">unknown</code></td>
<td>
<p>If <code>TRUE</code>, include names that suggest they are
placeholders for unknown taxa (e.g. &quot;unknown ...&quot;).</p>
</td></tr>
<tr><td><code id="ambiguous_synonyms_+3A_uncultured">uncultured</code></td>
<td>
<p>If <code>TRUE</code>, include names that suggest they are
assigned to uncultured organisms (e.g. &quot;uncultured ...&quot;).</p>
</td></tr>
<tr><td><code id="ambiguous_synonyms_+3A_regex">regex</code></td>
<td>
<p>If <code>TRUE</code>, includes regex syntax to make matching things like spaces more robust.</p>
</td></tr>
<tr><td><code id="ambiguous_synonyms_+3A_case_variations">case_variations</code></td>
<td>
<p>If <code>TRUE</code>, include variations of letter case.</p>
</td></tr>
</table>

<hr>
<h2 id='apply_color_scale'>Covert numbers to colors</h2><span id='topic+apply_color_scale'></span>

<h3>Description</h3>

<p>Convert numbers to colors.
If colors are already supplied, return the input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_color_scale(
  values,
  color_series,
  interval = NULL,
  no_color_in_palette = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_color_scale_+3A_values">values</code></td>
<td>
<p>(<code>numeric</code>) The numbers to represent as colors</p>
</td></tr>
<tr><td><code id="apply_color_scale_+3A_color_series">color_series</code></td>
<td>
<p>(<code>character</code>) Hex values or a character in <code>colors</code></p>
</td></tr>
<tr><td><code id="apply_color_scale_+3A_interval">interval</code></td>
<td>
<p>(<code>numeric</code> of length 2) The range <code>values</code> could have taken.</p>
</td></tr>
<tr><td><code id="apply_color_scale_+3A_no_color_in_palette">no_color_in_palette</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of distinct colors to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> Hex color codes.
</p>

<hr>
<h2 id='arrange_obs'>Sort user data in [taxmap()] objects</h2><span id='topic+arrange_obs'></span>

<h3>Description</h3>

<p>Sort rows of tables  or the elements of lists/vectors in the 'obj$data' list
in [taxmap()] objects. Any variable name that appears in [all_names()] can be
used as if it was a vector on its own. See [dplyr::arrange()] for the
inspiration for this function and more information. Calling the function
using the 'obj$arrange_obs(...)' style edits &quot;obj&quot; in place, unlike most R
functions. However, calling the function using the 'arrange_obs(obj, ...)'
imitates R's traditional copy-on-modify semantics, so &quot;obj&quot; would not be
changed; instead a changed version would be returned, like most R functions.
</p>
<pre>
obj$arrange_obs(data, ...)
arrange_obs(obj, data, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_obs_+3A_obj">obj</code></td>
<td>
<p>An object of type [taxmap()].</p>
</td></tr>
<tr><td><code id="arrange_obs_+3A_data">data</code></td>
<td>
<p>Dataset names, indexes, or a logical vector that indicates which datasets in
'obj$data' to sort If multiple datasets are sorted at once, then they must be the same
length.</p>
</td></tr>
<tr><td><code id="arrange_obs_+3A_...">...</code></td>
<td>
<p>One or more expressions (e.g. column names) to sort on.</p>
</td></tr>
<tr><td><code id="arrange_obs_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sort in ascending order
arrange_obs(ex_taxmap, "info", n_legs)
arrange_obs(ex_taxmap, "foods", name)

# Sort in decending order
arrange_obs(ex_taxmap, "info", desc(n_legs))

# Sort multiple datasets at once
arrange_obs(ex_taxmap, c("info", "phylopic_ids", "foods"), n_legs)

</code></pre>

<hr>
<h2 id='arrange_taxa'>Sort the edge list of [taxmap()] objects</h2><span id='topic+arrange_taxa'></span>

<h3>Description</h3>

<p>Sort the edge list and taxon list in [taxonomy()] or [taxmap()] objects. See
[dplyr::arrange()] for the inspiration for this function and more
information. Calling the function using the 'obj$arrange_taxa(...)' style
edits &quot;obj&quot; in place, unlike most R functions. However, calling the function
using the &lsquo;arrange_taxa(obj, ...)' imitates R&rsquo;s traditional copy-on-modify
semantics, so &quot;obj&quot; would not be changed; instead a changed version would be
returned, like most R functions.
</p>
<pre>
obj$arrange_taxa(...)
arrange_taxa(obj, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arrange_taxa_+3A_obj">obj</code></td>
<td>
<p>[taxonomy()] or [taxmap()]</p>
</td></tr>
<tr><td><code id="arrange_taxa_+3A_...">...</code></td>
<td>
<p>One or more expressions (e.g. column names) to sort on. Any
variable name that appears in [all_names()] can be used as if it was a
vector on its own.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxonomy()] or [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sort taxa in ascending order
arrange_taxa(ex_taxmap, taxon_names)

# Sort taxa in decending order
arrange_taxa(ex_taxmap, desc(taxon_names))

# Sort using an expression. List genera first.
arrange_taxa(ex_taxmap, taxon_ranks != "genus")

</code></pre>

<hr>
<h2 id='as_id'>Convert a vector to database IDs</h2><span id='topic+as_id'></span>

<h3>Description</h3>

<p>This is a convenience function to convert to identifiers of various  data
sources. It wraps the <code>as.*id</code> functions in <code><a href="taxize.html#topic+taxize">taxize</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_id(ids, database, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_id_+3A_ids">ids</code></td>
<td>
<p>The character or numeric vector of raw taxon IDs.</p>
</td></tr>
<tr><td><code id="as_id_+3A_database">database</code></td>
<td>
<p>The database format to convert the IDs to. Either ncbi,
itis, eol, col, tropicos, gbif, nbn, worms, natserv, bold, or wiki</p>
</td></tr>
<tr><td><code id="as_id_+3A_...">...</code></td>
<td>
<p>Passed to <code>as.*id</code> function.</p>
</td></tr>
</table>

<hr>
<h2 id='as_phyloseq'>Convert taxmap to phyloseq</h2><span id='topic+as_phyloseq'></span>

<h3>Description</h3>

<p>Convert a taxmap object to a phyloseq object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_phyloseq(
  obj,
  otu_table = NULL,
  otu_id_col = "otu_id",
  sample_data = NULL,
  sample_id_col = "sample_id",
  phy_tree = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_phyloseq_+3A_obj">obj</code></td>
<td>
<p>The taxmap object.</p>
</td></tr>
<tr><td><code id="as_phyloseq_+3A_otu_table">otu_table</code></td>
<td>
<p>The table in 'obj$data' with OTU counts. Must be one of the following:
</p>

<dl>
<dt><code>NULL</code></dt><dd><p>Look for a table named &quot;otu_table&quot; in 'obj$data' with taxon IDs, OTU IDs, and OTU counts. If it exists, use it.</p>
</dd>
<dt><code>character</code></dt><dd><p>The name of the table stored in 'obj$data' with taxon IDs, OTU IDs, and OTU counts</p>
</dd>
<dt><code>data.frame</code></dt><dd><p>A table with taxon IDs, OTU IDs, and OTU counts</p>
</dd>
<dt><code>FALSE</code></dt><dd><p>Do not include an OTU table, even if &quot;otu_table&quot; exists in 'obj$data'</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="as_phyloseq_+3A_otu_id_col">otu_id_col</code></td>
<td>
<p>The name of the column storing OTU IDs in the OTU table.</p>
</td></tr>
<tr><td><code id="as_phyloseq_+3A_sample_data">sample_data</code></td>
<td>
<p>A table containing sample data with sample IDs matching
column names in the OTU table. Must be one of the following:
</p>

<dl>
<dt><code>NULL</code></dt><dd><p>Look for a table named &quot;sample_data&quot; in 'obj$data'. If it exists, use it.</p>
</dd>
<dt><code>character</code></dt><dd><p>The name of the table stored in 'obj$data' with sample IDs</p>
</dd>
<dt><code>data.frame</code></dt><dd><p>A table with sample IDs</p>
</dd>
<dt><code>FALSE</code></dt><dd><p>Do not include a sample data table, even if &quot;sample_data&quot; exists in 'obj$data'</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="as_phyloseq_+3A_sample_id_col">sample_id_col</code></td>
<td>
<p>The name of the column storing sample IDs in the sample data table.</p>
</td></tr>
<tr><td><code id="as_phyloseq_+3A_phy_tree">phy_tree</code></td>
<td>
<p>A phylogenetic tree of class <code>ape:phylo</code> from
the <code>ape</code> package with tip labels matching OTU ids. Must be one of the following:
</p>

<dl>
<dt><code>NULL</code></dt><dd><p>Look for a tree named &quot;phy_tree&quot; in 'obj$data' with tip labels matching OTU ids. If it exists, use it.</p>
</dd>
<dt><code>character</code></dt><dd><p>The name of the tree stored in 'obj$data' with tip labels matching OTU ids.</p>
</dd>
<dt><code>ape::phylo</code></dt><dd><p>A tree with tip labels matching OTU ids.</p>
</dd>
<dt><code>FALSE</code></dt><dd><p>Do not include a tree, even if &quot;phy_tree&quot; exists in 'obj$data'</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parse example dataset
library(phyloseq)
data(GlobalPatterns)
x &lt;- parse_phyloseq(GlobalPatterns)

# Convert back to a phylseq object
as_phyloseq(x)

</code></pre>

<hr>
<h2 id='branches'>Get &quot;branch&quot; taxa</h2><span id='topic+branches'></span>

<h3>Description</h3>

<p>Return the &quot;branch&quot; taxa for a [taxonomy()] or [taxmap()] object. A branch is
anything that is not a root, stem, or leaf. Its the interior of the tree
after the first split starting from the roots. Can also be used to get the
branches of a subset of taxa.
</p>
<pre>
obj$branches(subset = NULL, value = "taxon_indexes")
branches(obj, subset = NULL, value = "taxon_indexes")</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="branches_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="branches_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes used to subset
the tree prior to determining branches. Default: All taxa in 'obj' will be
used. Any variable name that appears in [all_names()] can be used as if it
was a vector on its own. Note that branches are determined after the
filtering, so a given taxon might be a branch on the unfiltered tree, but
not a branch on the filtered tree.</p>
</td></tr>
<tr><td><code id="branches_+3A_value">value</code></td>
<td>
<p>What data to return. This is usually the name of column in a
table in 'obj$data'. Any result of [all_names()] can be used, but it
usually only makes sense to use data that corresponds to taxa 1:1, such as
[taxon_ranks()]. By default, taxon indexes are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'character'
</p>


<h3>See Also</h3>

<p>Other taxonomy indexing functions: 
<code><a href="#topic+internodes">internodes</a>()</code>,
<code><a href="#topic+leaves">leaves</a>()</code>,
<code><a href="#topic+roots">roots</a>()</code>,
<code><a href="#topic+stems">stems</a>()</code>,
<code><a href="#topic+subtaxa">subtaxa</a>()</code>,
<code><a href="#topic+supertaxa">supertaxa</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return indexes of branch taxa
branches(ex_taxmap)

# Return indexes for a subset of taxa
branches(ex_taxmap, subset = 2:17)
branches(ex_taxmap, subset = n_obs &gt; 1)

# Return something besides taxon indexes
branches(ex_taxmap, value = "taxon_names")

</code></pre>

<hr>
<h2 id='calc_diff_abund_deseq2'>Differential abundance with DESeq2</h2><span id='topic+calc_diff_abund_deseq2'></span>

<h3>Description</h3>

<p>EXPERIMENTAL: This function is still being tested and developed; use with caution. Uses the
<code><a href="DESeq2.html#topic+DESeq2-package">DESeq2-package</a></code> package to conduct differential abundance analysis of count data. Counts can
be of OTUs/ASVs or taxa. The plotting function <code><a href="#topic+heat_tree_matrix">heat_tree_matrix</a></code> is useful for
visualizing these results. See details section below for considerations on preparing data for
this analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_diff_abund_deseq2(
  obj,
  data,
  cols,
  groups,
  other_cols = FALSE,
  lfc_shrinkage = c("none", "normal", "ashr"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_diff_abund_deseq2_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_diff_abund_deseq2_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj</code> that contains data for each sample in columns.</p>
</td></tr>
<tr><td><code id="calc_diff_abund_deseq2_+3A_cols">cols</code></td>
<td>
<p>The names/indexes of columns in <code>data</code> to use. By default, all numeric columns
are used. Takes one of the following inputs: </p>
 <dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will
used.</p>
</dd> <dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes
of columns to use</p>
</dd> <dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use
the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_diff_abund_deseq2_+3A_groups">groups</code></td>
<td>
<p>A vector defining how samples are grouped into &quot;treatments&quot;. Must be the same order
and length as <code>cols</code>.</p>
</td></tr>
<tr><td><code id="calc_diff_abund_deseq2_+3A_other_cols">other_cols</code></td>
<td>
<p>If <code>TRUE</code>, preserve all columns not in <code>cols</code> in the output. If
<code>FALSE</code>, dont keep other columns. If a column names or indexes are supplied, only preserve
those columns.</p>
</td></tr>
<tr><td><code id="calc_diff_abund_deseq2_+3A_lfc_shrinkage">lfc_shrinkage</code></td>
<td>
<p>What technique to use to adjust the log fold change results for low counts.
Useful for ranking and visualizing log fold changes. Must be one of the following:
</p>

<dl>
<dt>'none'</dt><dd><p>No log fold change adjustments.</p>
</dd>
<dt>'normal'</dt><dd><p>The original DESeq2 shrinkage estimator</p>
</dd>
<dt>'ashr'</dt><dd><p>Adaptive shrinkage estimator from the <code>ashr</code> package, using a fitted mixture of normals prior.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="calc_diff_abund_deseq2_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="DESeq2.html#topic+results">results</a></code> if the <code>lfc_shrinkage</code> option is &quot;none&quot;
and to <code><a href="DESeq2.html#topic+lfcShrink">lfcShrink</a></code> otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data should be raw read counts, not rarefied, converted to proportions, or modified with any
other technique designed to correct for sample size since <code><a href="DESeq2.html#topic+DESeq2-package">DESeq2-package</a></code> is designed to be
used with count data and takes into account unequal sample size when determining differential
abundance. Warnings will be given if the data is not integers or all sample sizes are equal.
</p>


<h3>Value</h3>

<p>A tibble with at least the taxon ID of the thing tested, the groups compared, and the
DESeq2 results. The <code>log2FoldChange</code> values will be positive if <code>treatment_1</code> is more
abundant and <code>treatment_2</code>.
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parse data for plotting
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")

# Get per-taxon counts
x$data$tax_table &lt;- calc_taxon_abund(x, data = "tax_data", cols = hmp_samples$sample_id)

# Calculate difference between groups
x$data$diff_table &lt;- calc_diff_abund_deseq2(x, data = "tax_table",
                                    cols = hmp_samples$sample_id,
                                    groups = hmp_samples$body_site)
                                    
# Plot results (might take a few minutes)
heat_tree_matrix(x,
                 data = "diff_table",
                 node_size = n_obs,
                 node_label = taxon_names,
                 node_color = ifelse(is.na(padj) | padj &gt; 0.05, 0, log2FoldChange),
                 node_color_range = diverging_palette(),
                 node_color_trans = "linear",
                 node_color_interval = c(-3, 3),
                 edge_color_interval = c(-3, 3),
                 node_size_axis_label = "Number of OTUs",
                 node_color_axis_label = "Log2 fold change")



</code></pre>

<hr>
<h2 id='calc_group_mean'>Calculate means of groups of columns</h2><span id='topic+calc_group_mean'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, split columns by a
grouping factor and return row means in a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_group_mean(
  obj,
  data,
  groups,
  cols = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_group_mean_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_group_mean_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="calc_group_mean_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="calc_group_mean_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_group_mean_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="calc_group_mean_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="calc_group_mean_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")

# Calculate the means for each group
calc_group_mean(x, "tax_data", hmp_samples$sex)

# Use only some columns
calc_group_mean(x, "tax_data", hmp_samples$sex[4:20],
                cols = hmp_samples$sample_id[4:20])

# Including all other columns in ouput
calc_group_mean(x, "tax_data", groups = hmp_samples$sex,
                other_cols = TRUE)

# Inlcuding specific columns in output
calc_group_mean(x, "tax_data", groups = hmp_samples$sex,
                other_cols = 2)
calc_group_mean(x, "tax_data", groups = hmp_samples$sex,
                other_cols = "otu_id")

# Rename output columns
calc_group_mean(x, "tax_data", groups = hmp_samples$sex,
               out_names = c("Women", "Men"))
</code></pre>

<hr>
<h2 id='calc_group_median'>Calculate medians of groups of columns</h2><span id='topic+calc_group_median'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, split columns by a
grouping factor and return row medians in a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_group_median(
  obj,
  data,
  groups,
  cols = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_group_median_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_group_median_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="calc_group_median_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="calc_group_median_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_group_median_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="calc_group_median_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="calc_group_median_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")

# Calculate the medians for each group
calc_group_median(x, "tax_data", hmp_samples$sex)

# Use only some columns
calc_group_median(x, "tax_data", hmp_samples$sex[4:20],
                  cols = hmp_samples$sample_id[4:20])

# Including all other columns in ouput
calc_group_median(x, "tax_data", groups = hmp_samples$sex,
                  other_cols = TRUE)

# Inlcuding specific columns in output
calc_group_median(x, "tax_data", groups = hmp_samples$sex,
                  other_cols = 2)
calc_group_median(x, "tax_data", groups = hmp_samples$sex,
                  other_cols = "otu_id")

# Rename output columns
calc_group_median(x, "tax_data", groups = hmp_samples$sex,
                  out_names = c("Women", "Men"))
</code></pre>

<hr>
<h2 id='calc_group_rsd'>Relative standard deviations of groups of columns</h2><span id='topic+calc_group_rsd'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, split columns by a
grouping factor and return the relative standard deviation for each row in a
table. The relative standard deviation is the standard deviation divided by
the mean of a set of numbers. It is useful for comparing the variation when
magnitude of sets of number are very different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_group_rsd(
  obj,
  data,
  groups,
  cols = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_group_rsd_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_group_rsd_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="calc_group_rsd_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="calc_group_rsd_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_group_rsd_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="calc_group_rsd_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="calc_group_rsd_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")

# Calculate the RSD for each group
calc_group_rsd(x, "tax_data", hmp_samples$sex)

# Use only some columns
calc_group_rsd(x, "tax_data", hmp_samples$sex[4:20],
                cols = hmp_samples$sample_id[4:20])

# Including all other columns in ouput
calc_group_rsd(x, "tax_data", groups = hmp_samples$sex,
                other_cols = TRUE)

# Inlcuding specific columns in output
calc_group_rsd(x, "tax_data", groups = hmp_samples$sex,
                other_cols = 2)
calc_group_rsd(x, "tax_data", groups = hmp_samples$sex,
                other_cols = "otu_id")

# Rename output columns
calc_group_rsd(x, "tax_data", groups = hmp_samples$sex,
               out_names = c("Women", "Men"))
</code></pre>

<hr>
<h2 id='calc_group_stat'>Apply a function to groups of columns</h2><span id='topic+calc_group_stat'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, apply a function to
rows in groups of columns. The result of the function is used to create new
columns. This is equivalent to splitting columns of a table by a factor and
using <code>apply</code> on each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_group_stat(
  obj,
  data,
  func,
  groups = NULL,
  cols = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_group_stat_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_group_stat_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="calc_group_stat_+3A_func">func</code></td>
<td>
<p>The function to apply. It should take a vector and return a
single value. For example, <code><a href="base.html#topic+max">max</a></code> or <code><a href="base.html#topic+mean">mean</a></code> could
be used.</p>
</td></tr>
<tr><td><code id="calc_group_stat_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="calc_group_stat_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_group_stat_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="calc_group_stat_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="calc_group_stat_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")

# Apply a function to every value without grouping 
calc_group_stat(x, "tax_data", function(v) v &gt; 3)

# Calculate the means for each group
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex)

# Calculate the variation for each group
calc_group_stat(x, "tax_data", sd, groups = hmp_samples$body_site)

# Different ways to use only some columns
calc_group_stat(x, "tax_data", function(v) v &gt; 3,
                cols = c("700035949", "700097855", "700100489"))
calc_group_stat(x, "tax_data", function(v) v &gt; 3,
                cols = 4:6)
calc_group_stat(x, "tax_data", function(v) v &gt; 3,
                cols = startsWith(colnames(x$data$tax_data), "70001"))

# Including all other columns in ouput
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex,
                other_cols = TRUE)

# Inlcuding specific columns in output
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex,
                other_cols = 2)
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex,
                other_cols = "otu_id")

# Rename output columns
calc_group_stat(x, "tax_data", mean, groups = hmp_samples$sex,
               out_names = c("Women", "Men"))
</code></pre>

<hr>
<h2 id='calc_n_samples'>Count the number of samples</h2><span id='topic+calc_n_samples'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, count the number of
samples (i.e. columns) with greater than a minimum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_n_samples(
  obj,
  data,
  cols = NULL,
  groups = "n_samples",
  other_cols = FALSE,
  out_names = NULL,
  drop = FALSE,
  more_than = 0,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_n_samples_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_n_samples_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="calc_n_samples_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_n_samples_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="calc_n_samples_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="calc_n_samples_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="calc_n_samples_+3A_drop">drop</code></td>
<td>
<p>If <code>groups</code> is not used, return a vector of the results instead
of a table with one column.</p>
</td></tr>
<tr><td><code id="calc_n_samples_+3A_more_than">more_than</code></td>
<td>
<p>A sample must have greater than this value for it to be counted as present.</p>
</td></tr>
<tr><td><code id="calc_n_samples_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parse data for example
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")
                   
# Count samples with at least one read
calc_n_samples(x, data = "tax_data")

# Count samples with at least 5 reads
calc_n_samples(x, data = "tax_data", more_than = 5)

# Return a vector instead of a table
calc_n_samples(x, data = "tax_data", drop = TRUE)

# Only use some columns
calc_n_samples(x, data = "tax_data", cols = hmp_samples$sample_id[1:5])

# Return a count for each treatment
calc_n_samples(x, data = "tax_data", groups = hmp_samples$body_site)

# Rename output columns 
calc_n_samples(x, data = "tax_data", groups = hmp_samples$body_site,
               out_names = c("A", "B", "C", "D", "E"))

# Preserve other columns from input
calc_n_samples(x, data = "tax_data", other_cols = TRUE)
calc_n_samples(x, data = "tax_data", other_cols = 2)
calc_n_samples(x, data = "tax_data", other_cols = "otu_id")

</code></pre>

<hr>
<h2 id='calc_obs_props'>Calculate proportions from observation counts</h2><span id='topic+calc_obs_props'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, convert one or more
columns containing counts to proportions. This is meant to be used with
counts associated with observations (e.g. OTUs), as opposed to counts that
have already been summed per taxon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_obs_props(
  obj,
  data,
  cols = NULL,
  groups = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_obs_props_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_obs_props_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="calc_obs_props_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_obs_props_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="calc_obs_props_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="calc_obs_props_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="calc_obs_props_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")
                   
# Calculate proportions for all numeric columns
calc_obs_props(x, "tax_data")

# Calculate proportions for a subset of columns
calc_obs_props(x, "tax_data", cols = c("700035949", "700097855", "700100489"))
calc_obs_props(x, "tax_data", cols = 4:6)
calc_obs_props(x, "tax_data", cols = startsWith(colnames(x$data$tax_data), "70001"))

# Including all other columns in ouput
calc_obs_props(x, "tax_data", other_cols = TRUE)

# Inlcuding specific columns in output
calc_obs_props(x, "tax_data", cols = c("700035949", "700097855", "700100489"),
               other_cols = 2:3)
               
# Rename output columns
calc_obs_props(x, "tax_data", cols = c("700035949", "700097855", "700100489"),
               out_names = c("a", "b", "c"))
               
# Get proportions for groups of samples
calc_obs_props(x, "tax_data", groups = hmp_samples$sex)
calc_obs_props(x, "tax_data", groups = hmp_samples$sex,
               out_names = c("Women", "Men"))
</code></pre>

<hr>
<h2 id='calc_prop_samples'>Calculate the proportion of samples</h2><span id='topic+calc_prop_samples'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, calculate the
proportion of samples (i.e. columns) with greater than a minimum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_prop_samples(
  obj,
  data,
  cols = NULL,
  groups = "prop_samples",
  other_cols = FALSE,
  out_names = NULL,
  drop = FALSE,
  more_than = 0,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_prop_samples_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_prop_samples_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="calc_prop_samples_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_prop_samples_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="calc_prop_samples_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="calc_prop_samples_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="calc_prop_samples_+3A_drop">drop</code></td>
<td>
<p>If <code>groups</code> is not used, return a vector of the results instead
of a table with one column.</p>
</td></tr>
<tr><td><code id="calc_prop_samples_+3A_more_than">more_than</code></td>
<td>
<p>A sample must have greater than this value for it to be counted as present.</p>
</td></tr>
<tr><td><code id="calc_prop_samples_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parse data for example
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")
                   
# Count samples with at least one read
calc_prop_samples(x, data = "tax_data")

# Count samples with at least 5 reads
calc_prop_samples(x, data = "tax_data", more_than = 5)

# Return a vector instead of a table
calc_prop_samples(x, data = "tax_data", drop = TRUE)

# Only use some columns
calc_prop_samples(x, data = "tax_data", cols = hmp_samples$sample_id[1:5])

# Return a count for each treatment
calc_prop_samples(x, data = "tax_data", groups = hmp_samples$body_site)

# Rename output columns 
calc_prop_samples(x, data = "tax_data", groups = hmp_samples$body_site,
               out_names = c("A", "B", "C", "D", "E"))

# Preserve other columns from input
calc_prop_samples(x, data = "tax_data", other_cols = TRUE)
calc_prop_samples(x, data = "tax_data", other_cols = 2)
calc_prop_samples(x, data = "tax_data", other_cols = "otu_id")

</code></pre>

<hr>
<h2 id='calc_taxon_abund'>Sum observation values for each taxon</h2><span id='topic+calc_taxon_abund'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, sum the values in
each column for each taxon. This is useful to convert per-observation counts
(e.g. OTU counts) to per-taxon counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_taxon_abund(
  obj,
  data,
  cols = NULL,
  groups = NULL,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_taxon_abund_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="calc_taxon_abund_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="calc_taxon_abund_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="calc_taxon_abund_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="calc_taxon_abund_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="calc_taxon_abund_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for example
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")
                   
# Calculate the taxon abundance for each numeric column (i.e. sample)
calc_taxon_abund(x, "tax_data")

# Calculate the taxon abundance for a subset of columns
calc_taxon_abund(x, "tax_data", cols = 4:5)
calc_taxon_abund(x, "tax_data", cols = c("700035949", "700097855"))
calc_taxon_abund(x, "tax_data", cols = startsWith(colnames(x$data$tax_data), "70001"))

# Calculate the taxon abundance for groups of columns (e.g. treatments)
#  Note that we do not need to use the "cols" option for this since all
#  numeric columns are samples in this data. If there were numeric columns
#  that were not samples present in hmp_samples, the "cols" would be needed.
calc_taxon_abund(x, "tax_data", groups = hmp_samples$sex)
calc_taxon_abund(x, "tax_data", groups = hmp_samples$body_site)

# The above example using the "cols" option, even though not needed in this case
calc_taxon_abund(x, "tax_data", cols = hmp_samples$sample_id,
                 groups = hmp_samples$sex)
                 
# Rename the output columns
calc_taxon_abund(x, "tax_data", cols = hmp_samples$sample_id[1:10],
                 out_names = letters[1:10])
calc_taxon_abund(x, "tax_data", groups = hmp_samples$sex,
                 out_names = c("Women", "Men"))

# Geting a total for all columns 
calc_taxon_abund(x, "tax_data", cols = hmp_samples$sample_id,
                 groups = rep("total", nrow(hmp_samples)))
</code></pre>

<hr>
<h2 id='can_be_num'>Test if characters can be converted to numbers</h2><span id='topic+can_be_num'></span>

<h3>Description</h3>

<p>Makes TRUE/FALSE vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>can_be_num(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="can_be_num_+3A_input">input</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>

<hr>
<h2 id='can_be_used_in_taxmap'>Check that a unknown object can be used with taxmap</h2><span id='topic+can_be_used_in_taxmap'></span>

<h3>Description</h3>

<p>Check that a unknown object can be assigned taxon IDs and filtered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>can_be_used_in_taxmap(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="can_be_used_in_taxmap_+3A_obj">obj</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE/FALSE
</p>

<hr>
<h2 id='capitalize'>Capitalize</h2><span id='topic+capitalize'></span>

<h3>Description</h3>

<p>Make the first letter uppercase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capitalize(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capitalize_+3A_text">text</code></td>
<td>
<p>Some text</p>
</td></tr>
</table>

<hr>
<h2 id='check_class_col'>Check for name/index in input data</h2><span id='topic+check_class_col'></span>

<h3>Description</h3>

<p>Used by parse_tax_data and lookup_tax_data to check that columm/class_col is valid for the input data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_class_col(tax_data, column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_class_col_+3A_tax_data">tax_data</code></td>
<td>
<p>A table, list, or vector that contain sequence IDs, taxon
IDs, or taxon names.
* tables: The 'column' option must be used to specify which column
contains the sequence IDs, taxon IDs, or taxon names.
* lists: There must be only one item per list entry unless the 'column'
option is used to specify what item to use in each list entry.
* vectors: simply a vector of sequence IDs, taxon IDs, or taxon names.</p>
</td></tr>
<tr><td><code id="check_class_col_+3A_column">column</code></td>
<td>
<p>('character' or 'integer') The name or index of the column that
contains information used to lookup classifications. This only applies when
a table or list is supplied to 'tax_data'.</p>
</td></tr>
</table>

<hr>
<h2 id='check_element_length'>Check length of graph attributes</h2><span id='topic+check_element_length'></span>

<h3>Description</h3>

<p>Length should divind evenly into the number of taxon/parent IDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_element_length(args)
</code></pre>

<hr>
<h2 id='check_for_pkg'>check for packages</h2><span id='topic+check_for_pkg'></span>

<h3>Description</h3>

<p>check for packages, and stop if not installed.
This function was written by Scott Chamerlain, from whom I shamelessly stole
it.
</p>
<p>check for packages, and stop if not installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_for_pkg(package)

check_for_pkg(package)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_for_pkg_+3A_package">package</code></td>
<td>
<p>The name of the package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'TRUE' if package is present
</p>
<p>'TRUE' if package is present
</p>

<hr>
<h2 id='check_option_groups'>Check option: groups</h2><span id='topic+check_option_groups'></span>

<h3>Description</h3>

<p>This option is used in a few of the calculation functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_option_groups(groups, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_option_groups_+3A_groups">groups</code></td>
<td>
<p>The groups option to check</p>
</td></tr>
<tr><td><code id="check_option_groups_+3A_cols">cols</code></td>
<td>
<p>The cols option, if applicable</p>
</td></tr>
</table>

<hr>
<h2 id='check_taxmap_data'>Check dataset format</h2><span id='topic+check_taxmap_data'></span>

<h3>Description</h3>

<p>Check that the datasets in a [taxmap()] object are in the correct format.
* Checks that column names are not the names of functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_taxmap_data(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_taxmap_data_+3A_obj">obj</code></td>
<td>
<p>A [taxmap()] object</p>
</td></tr>
</table>

<hr>
<h2 id='classifications'>Get classifications of taxa</h2><span id='topic+classifications'></span>

<h3>Description</h3>

<p>Get character vector classifications of taxa in an object of type
[taxonomy()] or [taxmap()] composed of data associated with taxa. Each
classification is constructed by concatenating the data of the given taxon
and all of its supertaxa.
</p>
<pre>
obj$classifications(value = "taxon_names", sep = ";")
classifications(obj, value = "taxon_names", sep = ";")</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classifications_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()])</p>
</td></tr>
<tr><td><code id="classifications_+3A_value">value</code></td>
<td>
<p>What data to return. Any result of 'all_names(obj)' can be used,
but it usually only makes sense to data that corresponds to taxa 1:1, such
as [taxon_ranks()]. By default, taxon indexes are returned.</p>
</td></tr>
<tr><td><code id="classifications_+3A_sep">sep</code></td>
<td>
<p>('character' of length 1) The character(s) to place between
taxon IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'character'
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defualt settings returns taxon names separated by ;
classifications(ex_taxmap)

# Other values can be returned besides taxon names
classifications(ex_taxmap, value = "taxon_ids")

# The separator can also be changed
classifications(ex_taxmap, value = "taxon_ranks", sep = "||")

</code></pre>

<hr>
<h2 id='compare_groups'>Compare groups of samples</h2><span id='topic+compare_groups'></span>

<h3>Description</h3>

<p>Apply a function to compare data, usually abundance, from pairs of 
treatments/groups. By default, every pairwise combination of treatments are 
compared. A custom function can be supplied to perform the comparison. The
plotting function <code><a href="#topic+heat_tree_matrix">heat_tree_matrix</a></code> is useful for visualizing
these results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_groups(
  obj,
  data,
  cols,
  groups,
  func = NULL,
  combinations = NULL,
  other_cols = FALSE,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_groups_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="compare_groups_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj</code> that contains data for each 
sample in columns.</p>
</td></tr>
<tr><td><code id="compare_groups_+3A_cols">cols</code></td>
<td>
<p>The names/indexes of columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns
corresponding to <code>TRUE</code> values.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="compare_groups_+3A_groups">groups</code></td>
<td>
<p>A vector defining how samples are grouped into &quot;treatments&quot;. Must be the same
order and length as <code>cols</code>.</p>
</td></tr>
<tr><td><code id="compare_groups_+3A_func">func</code></td>
<td>
<p>The function to apply for each comparison. For each row in 
<code>data</code>, for each combination of groups, this function will 
receive the data for each treatment, passed as two vectors.
Therefore the function must take at least 2 arguments corresponding to the
two groups compared. The function should return a vector or list of
results of a fixed length. If named, the names will be used in the output.
The names should be consistent as well. A simple example is
<code>function(x, y) mean(x) - mean(y)</code>. By default, the following function
is used:
</p>
<pre>
function(abund_1, abund_2) {
  log_ratio &lt;- log2(median(abund_1) / median(abund_2))
  if (is.nan(log_ratio)) {
    log_ratio &lt;- 0
  }
  list(log2_median_ratio = log_ratio,
       median_diff = median(abund_1) - median(abund_2),
       mean_diff = mean(abund_1) - mean(abund_2),
       wilcox_p_value = wilcox.test(abund_1, abund_2)$p.value)
}
</pre></td></tr>
<tr><td><code id="compare_groups_+3A_combinations">combinations</code></td>
<td>
<p>Which combinations of groups to use. Must be a list 
of vectors, each containing the names of 2 groups to compare. By 
default, all pairwise combinations of groups are compared.</p>
</td></tr>
<tr><td><code id="compare_groups_+3A_other_cols">other_cols</code></td>
<td>
<p>If <code>TRUE</code>, preserve all columns not in 
<code>cols</code> in the output. If <code>FALSE</code>, dont keep other columns. 
If a column names or indexes are supplied, only preserve those columns.</p>
</td></tr>
<tr><td><code id="compare_groups_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parse data for plotting
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")

# Convert counts to proportions
x$data$otu_table &lt;- calc_obs_props(x, data = "tax_data", cols = hmp_samples$sample_id)

# Get per-taxon counts
x$data$tax_table &lt;- calc_taxon_abund(x, data = "otu_table", cols = hmp_samples$sample_id)

# Calculate difference between groups
x$data$diff_table &lt;- compare_groups(x, data = "tax_table",
                                    cols = hmp_samples$sample_id,
                                    groups = hmp_samples$body_site)

# Plot results (might take a few minutes)
heat_tree_matrix(x,
                 data = "diff_table",
                 node_size = n_obs,
                 node_label = taxon_names,
                 node_color = log2_median_ratio,
                 node_color_range = diverging_palette(),
                 node_color_trans = "linear",
                 node_color_interval = c(-3, 3),
                 edge_color_interval = c(-3, 3),
                 node_size_axis_label = "Number of OTUs",
                 node_color_axis_label = "Log2 ratio median proportions")
                 
# How to get results for only some pairs of groups
compare_groups(x, data = "tax_table",
               cols = hmp_samples$sample_id,
               groups = hmp_samples$body_site,
               combinations = list(c('Nose', 'Saliva'),
                                   c('Skin', 'Throat')))



</code></pre>

<hr>
<h2 id='complement'>Find complement of sequences</h2><span id='topic+complement'></span>

<h3>Description</h3>

<p>Find the complement of one or more sequences stored as a character
vector. This is a wrapper for <code><a href="seqinr.html#topic+comp">comp</a></code> for character
vectors instead of lists of character vectors with one value per letter.
IUPAC ambiguity code are handled and the upper/lower case is preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complement(seqs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complement_+3A_seqs">seqs</code></td>
<td>
<p>A character vector with one element per sequence.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other sequence transformations: 
<code><a href="#topic+rev_comp">rev_comp</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
complement(c("aagtgGGTGaa", "AAGTGGT"))

</code></pre>

<hr>
<h2 id='contains'>dplyr select_helpers</h2><span id='topic+contains'></span>

<h3>Description</h3>

<p>dplyr select_helpers
</p>
<p>dplyr select_helpers
</p>

<hr>
<h2 id='convert_base'>Converts decimal numbers to other bases</h2><span id='topic+convert_base'></span>

<h3>Description</h3>

<p>Converts from base 10 to other bases represented by a given set of symbols.
</p>
<p>Converts from base 10 to other bases represented by a given set of symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_base(
  numbers,
  symbols = letters,
  base = length(symbols),
  min_length = 0
)

convert_base(
  numbers,
  symbols = letters,
  base = length(symbols),
  min_length = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_base_+3A_numbers">numbers</code></td>
<td>
<p>One or more numbers to convert.</p>
</td></tr>
<tr><td><code id="convert_base_+3A_symbols">symbols</code></td>
<td>
<p>The set of symbols to use for the new base.</p>
</td></tr>
<tr><td><code id="convert_base_+3A_base">base</code></td>
<td>
<p>The base to convert to.</p>
</td></tr>
<tr><td><code id="convert_base_+3A_min_length">min_length</code></td>
<td>
<p>The minimum number of symbols in each result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>
<p>character vector
</p>

<hr>
<h2 id='correct_taxon_names'>Look up official names from potentially misspelled names</h2><span id='topic+correct_taxon_names'></span>

<h3>Description</h3>

<p>Look up official names from potentially misspelled names using Global Names
Resolver (GNR). If a result from the chosen database is present, then it is
used, otherwise the NCBI result is used and if that does not exist, then the
first result is used. Names with no match will return NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_taxon_names(names, database = "ncbi")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_taxon_names_+3A_names">names</code></td>
<td>
<p>Potentially misspelled taxon names</p>
</td></tr>
<tr><td><code id="correct_taxon_names_+3A_database">database</code></td>
<td>
<p>The database the names are being looked up for. If 'NULL', do
not consider database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of names
</p>

<hr>
<h2 id='count_capture_groups'>Count capture groups</h2><span id='topic+count_capture_groups'></span>

<h3>Description</h3>

<p>Count the number of capture groups in a regular expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_capture_groups(regex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_capture_groups_+3A_regex">regex</code></td>
<td>
<p>(<code>character</code> of length 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> of length 1
</p>


<h3>Source</h3>

<p>http://stackoverflow.com/questions/16046620/regex-to-count-the-number-of-capturing-groups-in-a-regex
</p>

<hr>
<h2 id='counts_to_presence'>Apply a function to groups of columns</h2><span id='topic+counts_to_presence'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, apply a function to
rows in groups of columns. The result of the function is used to create new
columns. This is equivalent to splitting columns of a table by a factor and
using <code>apply</code> on each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counts_to_presence(
  obj,
  data,
  threshold = 0,
  groups = NULL,
  cols = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="counts_to_presence_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="counts_to_presence_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="counts_to_presence_+3A_threshold">threshold</code></td>
<td>
<p>The value a number must be greater than to count as present.
By, default, anything above 0 is considered present.</p>
</td></tr>
<tr><td><code id="counts_to_presence_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="counts_to_presence_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="counts_to_presence_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="counts_to_presence_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="counts_to_presence_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")

# Convert count to presence/absence
counts_to_presence(x, "tax_data")

# Check if there are any reads in each group of samples
counts_to_presence(x, "tax_data", groups = hmp_samples$body_site)
</code></pre>

<hr>
<h2 id='data_used'>Get values of data used in expressions</h2><span id='topic+data_used'></span>

<h3>Description</h3>

<p>Get values available for
[non-standard evaluation](http://adv-r.had.co.nz/Computing-on-the-language.html)
in a [taxonomy()] or [taxmap()] object used in expressions. Expressions are
not evaluated and do not need to make sense.
</p>
<pre>
obj$data_used(...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_used_+3A_obj">obj</code></td>
<td>
<p>a [taxonomy()] or [taxmap()] object</p>
</td></tr>
<tr><td><code id="data_used_+3A_...">...</code></td>
<td>
<p>One or more expressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'list'
</p>


<h3>See Also</h3>

<p>Other NSE helpers: 
<code><a href="#topic+all_names">all_names</a>()</code>,
<code><a href="#topic+get_data">get_data</a>()</code>,
<code><a href="#topic+names_used">names_used</a></code>
</p>

<hr>
<h2 id='database_list'>Database list</h2><span id='topic+database_list'></span>

<h3>Description</h3>

<p>The list of known databases. Not currently used much, but will be when we add
more check for taxon IDs and taxon ranks from particular databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>database_list
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>


<h3>Details</h3>

<p>List of databases with pre-filled details, where each has the
format:
</p>

<ul>
<li><p> url: A base URL for the database source.
</p>
</li>
<li><p> description: Description of the database source.
</p>
</li>
<li><p> id regex: identifier regex.
</p>
</li></ul>



<h3>See Also</h3>

<p>[taxon_database]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>database_list
database_list$ncbi
database_list$ncbi$name
database_list$ncbi$description
database_list$ncbi$url
</code></pre>

<hr>
<h2 id='desc_font'>Description formatting in print methods</h2><span id='topic+desc_font'></span>

<h3>Description</h3>

<p>A simple wrapper to make changing the formatting of text printed easier.
This is used for non-data, formatting characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc_font(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="desc_font_+3A_text">text</code></td>
<td>
<p>What to print</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other printer fonts: 
<code><a href="#topic+error_font">error_font</a>()</code>,
<code><a href="#topic+name_font">name_font</a>()</code>,
<code><a href="#topic+punc_font">punc_font</a>()</code>,
<code><a href="#topic+tid_font">tid_font</a>()</code>
</p>

<hr>
<h2 id='diverging_palette'>The default diverging color palette</h2><span id='topic+diverging_palette'></span>

<h3>Description</h3>

<p>Returns the default color palette for diverging data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diverging_palette()
</code></pre>


<h3>Value</h3>

<p><code>character</code> of hex color codes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diverging_palette()

</code></pre>

<hr>
<h2 id='DNAbin_to_char'>Converts DNAbin to a named character vector</h2><span id='topic+DNAbin_to_char'></span>

<h3>Description</h3>

<p>Converts an object of class DNAbin (as produced by ape) to a named character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNAbin_to_char(dna_bin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DNAbin_to_char_+3A_dna_bin">dna_bin</code></td>
<td>
<p>(<code>DNAbin</code> of length 1) the input.</p>
</td></tr>
</table>

<hr>
<h2 id='do_calc_on_num_cols'>Run some function to produce new columns.</h2><span id='topic+do_calc_on_num_cols'></span>

<h3>Description</h3>

<p>For a given table in a taxmap object, run some function to produce new
columns. This function handles all of the option parsing and formatting of
the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do_calc_on_num_cols(
  obj,
  data,
  func,
  cols = NULL,
  groups = NULL,
  other_cols = FALSE,
  out_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="do_calc_on_num_cols_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="do_calc_on_num_cols_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="do_calc_on_num_cols_+3A_func">func</code></td>
<td>
<p>The function to apply. Should have the following form:
<code>function(count_table, cols = cols, groups = groups)</code> and return a table.</p>
</td></tr>
<tr><td><code id="do_calc_on_num_cols_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="do_calc_on_num_cols_+3A_groups">groups</code></td>
<td>
<p>Group multiple columns per treatment/group. This should be a
vector of group IDs (e.g. character, integer) the same length as
<code>cols</code> that defines which samples go in which group. When used, there
will be one column in the output for each unique value in <code>groups</code>.</p>
</td></tr>
<tr><td><code id="do_calc_on_num_cols_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="do_calc_on_num_cols_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>

<hr>
<h2 id='edge_list_depth'>Get distance from root of edgelist observations</h2><span id='topic+edge_list_depth'></span>

<h3>Description</h3>

<p>Gets the number of ancestors/supergroups for observations of an edge/adjacency list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_list_depth(taxa, parents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge_list_depth_+3A_taxa">taxa</code></td>
<td>
<p>(<code>character</code>) Unique taxon IDs for every possible taxon.</p>
</td></tr>
<tr><td><code id="edge_list_depth_+3A_parents">parents</code></td>
<td>
<p>(<code>character</code>) Unique taxon IDs for the supertaxa of every possible taxon.
Root taxa should have <code>NA</code> in this column.</p>
</td></tr>
</table>

<hr>
<h2 id='ends_with'>dplyr select_helpers</h2><span id='topic+ends_with'></span>

<h3>Description</h3>

<p>dplyr select_helpers
</p>
<p>dplyr select_helpers
</p>

<hr>
<h2 id='error_font'>Font to indicate an error</h2><span id='topic+error_font'></span>

<h3>Description</h3>

<p>A simple wrapper to make changing the formatting of text printed easier.
This is used for non-data, formatting characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_font(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="error_font_+3A_text">text</code></td>
<td>
<p>What to print</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other printer fonts: 
<code><a href="#topic+desc_font">desc_font</a>()</code>,
<code><a href="#topic+name_font">name_font</a>()</code>,
<code><a href="#topic+punc_font">punc_font</a>()</code>,
<code><a href="#topic+tid_font">tid_font</a>()</code>
</p>

<hr>
<h2 id='everything'>dplyr select_helpers</h2><span id='topic+everything'></span>

<h3>Description</h3>

<p>dplyr select_helpers
</p>
<p>dplyr select_helpers
</p>

<hr>
<h2 id='ex_hierarchies'>An example hierarchies object</h2><span id='topic+ex_hierarchies'></span>

<h3>Description</h3>

<p>An example hierarchies object built from the ground up.
</p>


<h3>Format</h3>

<p>A [hierarchies()] object.
</p>


<h3>Source</h3>

<p>Created from the example code in the [hierarchies()]
documentation.
</p>


<h3>See Also</h3>

<p>Other taxa-datasets: 
<code><a href="#topic+ex_hierarchy1">ex_hierarchy1</a></code>,
<code><a href="#topic+ex_hierarchy2">ex_hierarchy2</a></code>,
<code><a href="#topic+ex_hierarchy3">ex_hierarchy3</a></code>,
<code><a href="#topic+ex_taxmap">ex_taxmap</a></code>
</p>

<hr>
<h2 id='ex_hierarchy1'>An example Hierarchy object</h2><span id='topic+ex_hierarchy1'></span>

<h3>Description</h3>

<p>An example Hierarchy object built from the ground up.
</p>


<h3>Format</h3>

<p>A [hierarchy()] object with
</p>

<ul>
<li><p> name: Poaceae / rank: family / id: 4479
</p>
</li>
<li><p> name: Poa / rank: genus / id: 4544
</p>
</li>
<li><p> name: Poa annua / rank: species / id: 93036
</p>
</li></ul>

<p>Based on NCBI taxonomic classification
</p>


<h3>Source</h3>

<p>Created from the example code in the [hierarchy()]
documentation.
</p>


<h3>See Also</h3>

<p>Other taxa-datasets: 
<code><a href="#topic+ex_hierarchies">ex_hierarchies</a></code>,
<code><a href="#topic+ex_hierarchy2">ex_hierarchy2</a></code>,
<code><a href="#topic+ex_hierarchy3">ex_hierarchy3</a></code>,
<code><a href="#topic+ex_taxmap">ex_taxmap</a></code>
</p>

<hr>
<h2 id='ex_hierarchy2'>An example Hierarchy object</h2><span id='topic+ex_hierarchy2'></span>

<h3>Description</h3>

<p>An example Hierarchy object built from the ground up.
</p>


<h3>Format</h3>

<p>A [hierarchy()] object with
</p>

<ul>
<li><p> name: Felidae / rank: family / id: 9681
</p>
</li>
<li><p> name: Puma / rank: genus / id: 146712
</p>
</li>
<li><p> name: Puma concolor / rank: species / id: 9696
</p>
</li></ul>

<p>Based on NCBI taxonomic classification
</p>


<h3>Source</h3>

<p>Created from the example code in the [hierarchy()]
documentation.
</p>


<h3>See Also</h3>

<p>Other taxa-datasets: 
<code><a href="#topic+ex_hierarchies">ex_hierarchies</a></code>,
<code><a href="#topic+ex_hierarchy1">ex_hierarchy1</a></code>,
<code><a href="#topic+ex_hierarchy3">ex_hierarchy3</a></code>,
<code><a href="#topic+ex_taxmap">ex_taxmap</a></code>
</p>

<hr>
<h2 id='ex_hierarchy3'>An example Hierarchy object</h2><span id='topic+ex_hierarchy3'></span>

<h3>Description</h3>

<p>An example Hierarchy object built from the ground up.
</p>


<h3>Format</h3>

<p>A [hierarchy()] object with
</p>

<ul>
<li><p> name: Chordata / rank: phylum / id: 158852
</p>
</li>
<li><p> name: Vertebrata / rank: subphylum / id: 331030
</p>
</li>
<li><p> name: Teleostei / rank: class / id: 161105
</p>
</li>
<li><p> name: Salmonidae / rank: family / id: 161931
</p>
</li>
<li><p> name: Salmo / rank: genus / id: 161994
</p>
</li>
<li><p> name: Salmo salar / rank: species / id: 161996
</p>
</li></ul>

<p>Based on ITIS taxonomic classification
</p>


<h3>Source</h3>

<p>Created from the example code in the [hierarchy()]
documentation.
</p>


<h3>See Also</h3>

<p>Other taxa-datasets: 
<code><a href="#topic+ex_hierarchies">ex_hierarchies</a></code>,
<code><a href="#topic+ex_hierarchy1">ex_hierarchy1</a></code>,
<code><a href="#topic+ex_hierarchy2">ex_hierarchy2</a></code>,
<code><a href="#topic+ex_taxmap">ex_taxmap</a></code>
</p>

<hr>
<h2 id='ex_taxmap'>An example taxmap object</h2><span id='topic+ex_taxmap'></span>

<h3>Description</h3>

<p>An example taxmap object built from the ground up. Typically, data stored in
taxmap would be parsed from an input file, but this data set is just for
demonstration purposes.
</p>


<h3>Format</h3>

<p>A [taxmap()] object.
</p>


<h3>Source</h3>

<p>Created from the example code in the [taxmap()]
documentation.
</p>


<h3>See Also</h3>

<p>Other taxa-datasets: 
<code><a href="#topic+ex_hierarchies">ex_hierarchies</a></code>,
<code><a href="#topic+ex_hierarchy1">ex_hierarchy1</a></code>,
<code><a href="#topic+ex_hierarchy2">ex_hierarchy2</a></code>,
<code><a href="#topic+ex_hierarchy3">ex_hierarchy3</a></code>
</p>

<hr>
<h2 id='extract_tax_data'>Extracts taxonomy info from vectors with regex</h2><span id='topic+extract_tax_data'></span>

<h3>Description</h3>

<p>Convert taxonomic information in a character vector into a [taxmap()] object.
The location and identity of important information in the input is specified
using a [regular expression](https://en.wikipedia.org/wiki/Regular_expression)
with capture groups and a corresponding key. An object of type [taxmap()] is
returned containing the specified information. See the 'key' option for
accepted sources of taxonomic information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_tax_data(
  tax_data,
  key,
  regex,
  class_key = "taxon_name",
  class_regex = "(.*)",
  class_sep = NULL,
  sep_is_regex = FALSE,
  class_rev = FALSE,
  database = "ncbi",
  include_match = FALSE,
  include_tax_data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_tax_data_+3A_tax_data">tax_data</code></td>
<td>
<p>A vector from which to extract taxonomy information.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_key">key</code></td>
<td>
<p>('character') The identity of the capturing groups defined using
'regex'. The length of 'key' must be equal to the number of capturing
groups specified in 'regex'. Any names added to the terms will be used as
column names in the output. Only '&quot;info&quot;' can be used multiple times. Each
term must be one of those described below:
* 'taxon_id': A unique numeric id for a taxon for a particular 'database'
(e.g. ncbi accession number). Requires an internet connection.
* 'taxon_name': The name of a taxon (e.g. &quot;Mammalia&quot; or &quot;Homo sapiens&quot;).
Not necessarily unique, but interpretable by a particular 'database'.
Requires an internet connection.
* 'fuzzy_name': The name of a taxon, but check for misspellings first.
Only use if you think there are misspellings. Using '&quot;taxon_name&quot;' is
faster.
* 'class': A list of taxon information that constitutes the full taxonomic
classification (e.g. &quot;K_Mammalia;P_Carnivora;C_Felidae&quot;). Individual
taxa are separated by the 'class_sep' argument and the information is
parsed by the 'class_regex' and 'class_key' arguments.
* 'seq_id': Sequence ID for a particular database that is associated with a
taxonomic classification. Currently only works with the &quot;ncbi&quot; database.
* 'info': Arbitrary taxon info you want included in the output. Can be used
more than once.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_regex">regex</code></td>
<td>
<p>('character' of length 1) A regular expression with capturing
groups indicating the locations of relevant information. The identity of
the information must be specified using the 'key' argument.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_class_key">class_key</code></td>
<td>
<p>('character' of length 1) The identity of the capturing
groups defined using 'class_regex'. The length of 'class_key' must be equal
to the number of capturing groups specified in 'class_regex'. Any names
added to the terms will be used as column names in the output. Only
'&quot;info&quot;' can be used multiple times. Each term must be one of those
described below:
* 'taxon_name': The name of a taxon. Not necessarily unique.
* 'taxon_rank': The rank of the taxon. This will be used to add rank info
into the output object that can be accessed by 'out$taxon_ranks()'.
* 'info': Arbitrary taxon info you want included in the output. Can be used
more than once.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_class_regex">class_regex</code></td>
<td>
<p>('character' of length 1)
A regular expression with capturing groups indicating the locations of data
for each taxon in the 'class' term in the 'key' argument. The identity of
the information must be specified using the 'class_key' argument. The
'class_sep' option can be used to split the classification into data for
each taxon before matching. If 'class_sep' is 'NULL', each match of
'class_regex' defines a taxon in the classification.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_class_sep">class_sep</code></td>
<td>
<p>('character' of length 1)
Used with the 'class' term in the 'key' argument. The character(s) used to
separate individual taxa within a classification. After the string defined
by the 'class' capture group in 'regex' is split by 'class_sep', its
capture groups are extracted by 'class_regex' and defined by 'class_key'.
If 'NULL', every match of 'class_regex' is used instead with first
splitting by 'class_sep'.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_sep_is_regex">sep_is_regex</code></td>
<td>
<p>('TRUE'/'FALSE') Whether or not 'class_sep' should be
used as a [regular expression](https://en.wikipedia.org/wiki/Regular_expression).</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_class_rev">class_rev</code></td>
<td>
<p>('logical' of length 1)
Used with the 'class' term in the 'key' argument. If 'TRUE', the order of
taxon data in a classification is reversed to be specific to broad.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_database">database</code></td>
<td>
<p>('character' of length 1) The name of the database that
patterns given in 'parser' will apply to. Valid databases include &quot;ncbi&quot;,
&quot;itis&quot;, &quot;eol&quot;, &quot;col&quot;, &quot;tropicos&quot;, &quot;nbn&quot;, and &quot;none&quot;. '&quot;none&quot;' will cause no
database to be queried; use this if you want to not use the internet. NOTE:
Only '&quot;ncbi&quot;' has been tested extensively so far.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_include_match">include_match</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', include the part of
the input matched by 'regex' in the output object.</p>
</td></tr>
<tr><td><code id="extract_tax_data_+3A_include_tax_data">include_tax_data</code></td>
<td>
<p>('TRUE'/'FALSE') Whether or not to include 'tax_data'
as a dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of type [taxmap()]
</p>


<h3>Failed Downloads</h3>

<p>If you have invalid inputs or a download fails for
another reason, then there will be a &quot;unknown&quot; taxon ID as a placeholder
and failed inputs will be assigned to this ID. You can remove these using
[filter_taxa()] like so: 'filter_taxa(result, taxon_ids != &quot;unknown&quot;)'. Add
'drop_obs = FALSE' if you want the input data, but want to remove the
taxon.
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # For demonstration purposes, the following example dataset has all the
  # types of data that can be used, but any one of them alone would work.
  raw_data &lt;- c(
  "&gt;id:AB548412-tid:9689-Panthera leo-tax:K_Mammalia;P_Carnivora;C_Felidae;G_Panthera;S_leo",
  "&gt;id:FJ358423-tid:9694-Panthera tigris-tax:K_Mammalia;P_Carnivora;C_Felidae;G_Panthera;S_tigris",
  "&gt;id:DQ334818-tid:9643-Ursus americanus-tax:K_Mammalia;P_Carnivora;C_Felidae;G_Ursus;S_americanus"
  )

  # Build a taxmap object from classifications
  extract_tax_data(raw_data,
                   key = c(my_seq = "info", my_tid = "info", org = "info", tax = "class"),
                   regex = "^&gt;id:(.+)-tid:(.+)-(.+)-tax:(.+)$",
                   class_sep = ";", class_regex = "^(.+)_(.+)$",
                   class_key = c(my_rank = "info", tax_name = "taxon_name"))

  # Build a taxmap object from taxon ids
  # Note: this requires an internet connection
  extract_tax_data(raw_data,
                   key = c(my_seq = "info", my_tid = "taxon_id", org = "info", tax = "info"),
                   regex = "^&gt;id:(.+)-tid:(.+)-(.+)-tax:(.+)$")

  # Build a taxmap object from ncbi sequence accession numbers
  # Note: this requires an internet connection
  extract_tax_data(raw_data,
                   key = c(my_seq = "seq_id", my_tid = "info", org = "info", tax = "info"),
                   regex = "^&gt;id:(.+)-tid:(.+)-(.+)-tax:(.+)$")

  # Build a taxmap object from taxon names
  # Note: this requires an internet connection
  extract_tax_data(raw_data,
                   key = c(my_seq = "info", my_tid = "info", org = "taxon_name", tax = "info"),
                   regex = "^&gt;id:(.+)-tid:(.+)-(.+)-tax:(.+)$")

</code></pre>

<hr>
<h2 id='fasta_headers'>Get line numbers of FASTA headers</h2><span id='topic+fasta_headers'></span>

<h3>Description</h3>

<p>Get line numbers of FASTA headers without reading whole fasta file into RAM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fasta_headers(file_path, buffer_size = 1000, return_headers = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fasta_headers_+3A_file_path">file_path</code></td>
<td>
<p>(<code>character</code> of length 1) The path to a file to read.</p>
</td></tr>
<tr><td><code id="fasta_headers_+3A_buffer_size">buffer_size</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of lines in each chunk.</p>
</td></tr>
<tr><td><code id="fasta_headers_+3A_return_headers">return_headers</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code>, name the result with the headers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>

<hr>
<h2 id='filter_ambiguous_taxa'>Filter ambiguous taxon names</h2><span id='topic+filter_ambiguous_taxa'></span>

<h3>Description</h3>

<p>Filter out taxa with ambiguous names, such as &quot;unknown&quot; or &quot;uncultured&quot;.
NOTE: some parameters of this function are passed to
<code><a href="#topic+filter_taxa">filter_taxa</a></code> with the &quot;invert&quot; option set to <code>TRUE</code>.
Works the same way as <code><a href="#topic+filter_taxa">filter_taxa</a></code> for the most part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_ambiguous_taxa(
  obj,
  unknown = TRUE,
  uncultured = TRUE,
  name_regex = ".",
  ignore_case = TRUE,
  subtaxa = FALSE,
  drop_obs = TRUE,
  reassign_obs = TRUE,
  reassign_taxa = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_ambiguous_taxa_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="filter_ambiguous_taxa_+3A_unknown">unknown</code></td>
<td>
<p>If <code>TRUE</code>, Remove taxa with names the suggest they are
placeholders for unknown taxa (e.g. &quot;unknown ...&quot;).</p>
</td></tr>
<tr><td><code id="filter_ambiguous_taxa_+3A_uncultured">uncultured</code></td>
<td>
<p>If <code>TRUE</code>, Remove taxa with names the suggest they are
assigned to uncultured organisms (e.g. &quot;uncultured ...&quot;).</p>
</td></tr>
<tr><td><code id="filter_ambiguous_taxa_+3A_name_regex">name_regex</code></td>
<td>
<p>The regex code to match a valid character in a taxon name.
For example, &quot;[a-z]&quot; would mean taxon names can only be lower case letters.</p>
</td></tr>
<tr><td><code id="filter_ambiguous_taxa_+3A_ignore_case">ignore_case</code></td>
<td>
<p>If <code>TRUE</code>, dont consider the case of the text when
determining a match.</p>
</td></tr>
<tr><td><code id="filter_ambiguous_taxa_+3A_subtaxa">subtaxa</code></td>
<td>
<p>('logical' or 'numeric' of length 1) If 'TRUE', include
subtaxa of taxa passing the filter. Positive numbers indicate the number of
ranks below the target taxa to return. '0' is equivalent to 'FALSE'.
Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="filter_ambiguous_taxa_+3A_drop_obs">drop_obs</code></td>
<td>
<p>('logical')  This option only applies to [taxmap()] objects.
If 'FALSE', include observations (i.e. user-defined data in 'obj$data')
even if the taxon they are assigned to is filtered out. Observations
assigned to removed taxa will be assigned to <code>NA</code>. This option can be
either simply 'TRUE'/'FALSE', meaning that all data sets will be treated
the same, or a logical vector can be supplied with names corresponding one
or more data sets in 'obj$data'. For example, 'c(abundance = FALSE, stats =
TRUE)' would include observations whose taxon was filtered out in
'obj$data$abundance', but not in 'obj$data$stats'. See the 'reassign_obs'
option below for further complications.</p>
</td></tr>
<tr><td><code id="filter_ambiguous_taxa_+3A_reassign_obs">reassign_obs</code></td>
<td>
<p>('logical' of length 1) This option only applies to
[taxmap()] objects. If 'TRUE', observations (i.e. user-defined data in
'obj$data') assigned to removed taxa will be reassigned to the closest
supertaxon that passed the filter. If there are no supertaxa of such an
observation that passed the filter, they will be filtered out if 'drop_obs'
is 'TRUE'. This option can be either simply 'TRUE'/'FALSE', meaning that
all data sets will be treated the same, or a logical vector can be supplied
with names corresponding one or more data sets in 'obj$data'. For example,
'c(abundance = TRUE, stats = FALSE)' would reassign observations in
'obj$data$abundance', but not in 'obj$data$stats'.</p>
</td></tr>
<tr><td><code id="filter_ambiguous_taxa_+3A_reassign_taxa">reassign_taxa</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', subtaxa of removed
taxa will be reassigned to the closest supertaxon that passed the filter.
This is useful for removing intermediate levels of a taxonomy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you encounter a taxon name that represents an ambiguous taxon that is not
filtered out by this function, let us know and we will add it.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+taxmap">taxmap</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- parse_tax_data(c("Plantae;Solanaceae;Solanum;lycopersicum",
                        "Plantae;Solanaceae;Solanum;tuberosum",
                        "Plantae;Solanaceae;Solanum;unknown",
                        "Plantae;Solanaceae;Solanum;uncultured",
                        "Plantae;UNIDENTIFIED"))
filter_ambiguous_taxa(obj)

</code></pre>

<hr>
<h2 id='filter_obs'>Filter observations with a list of conditions</h2><span id='topic+filter_obs'></span>

<h3>Description</h3>

<p>Filter data in a [taxmap()] object (in 'obj$data') with a
set of conditions.  See
[dplyr::filter()] for the inspiration for this function and more
information. Calling the function using the 'obj$filter_obs(...)' style
edits &quot;obj&quot; in place, unlike most R functions. However, calling the function
using the &lsquo;filter_obs(obj, ...)' imitates R&rsquo;s traditional copy-on-modify
semantics, so &quot;obj&quot; would not be changed; instead a changed version would be
returned, like most R functions.
</p>
<pre>
obj$filter_obs(data, ..., drop_taxa = FALSE, drop_obs = TRUE,
               subtaxa = FALSE, supertaxa = TRUE, reassign_obs = FALSE)
filter_obs(obj, data, ..., drop_taxa = FALSE, drop_obs = TRUE,
           subtaxa = FALSE, supertaxa = TRUE, reassign_obs = FALSE)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_obs_+3A_obj">obj</code></td>
<td>
<p>An object of type [taxmap()]</p>
</td></tr>
<tr><td><code id="filter_obs_+3A_data">data</code></td>
<td>
<p>Dataset names, indexes, or a logical vector that indicates which datasets in
'obj$data' to filter. If multiple datasets are filterd at once, then they must be the same
length.</p>
</td></tr>
<tr><td><code id="filter_obs_+3A_...">...</code></td>
<td>
<p>One or more filtering conditions. Any variable name that appears
in [all_names()] can be used as if it was a vector on its own. Each
filtering condition can be one of two things:
* 'integer': One or more dataset indexes.
* 'logical': A 'TRUE'/'FALSE' vector of length equal to the number of
items in the dataset.</p>
</td></tr>
<tr><td><code id="filter_obs_+3A_drop_taxa">drop_taxa</code></td>
<td>
<p>('logical' of length 1) If 'FALSE', preserve taxa
even if all of their observations are filtered out. If 'TRUE', remove
taxa for which all observations were filtered out. Note that only taxa that
are unobserved due to this filtering will be removed; there might be other
taxa without observations to begin with that will not be removed.</p>
</td></tr>
<tr><td><code id="filter_obs_+3A_drop_obs">drop_obs</code></td>
<td>
<p>('logical') This only has an effect when 'drop_taxa' is
'TRUE'. When 'TRUE', observations for other data sets (i.e. not 'data')
assigned to taxa that are removed when filtering 'data' are also removed.
Otherwise, only data for taxa that are not present in all other data sets
will be removed. This option can be either simply 'TRUE'/'FALSE', meaning
that all data sets will be treated the same, or a logical vector can be
supplied with names corresponding one or more data sets in 'obj$data'. For
example, 'c(abundance = TRUE, stats = FALSE)' would remove observations in
'obj$data$abundance', but not in 'obj$data$stats'.</p>
</td></tr>
<tr><td><code id="filter_obs_+3A_subtaxa">subtaxa</code></td>
<td>
<p>('logical' or 'numeric' of length 1) This only has an effect
when 'drop_taxa' is 'TRUE'. If 'TRUE', include subtaxa of taxa passing the
filter. Positive numbers indicate the number of ranks below the target taxa
to return. '0' is equivalent to 'FALSE'. Negative numbers are equivalent to
'TRUE'.</p>
</td></tr>
<tr><td><code id="filter_obs_+3A_supertaxa">supertaxa</code></td>
<td>
<p>('logical'  or 'numeric' of length 1) This only has an
effect when 'drop_taxa' is 'TRUE'. If 'TRUE', include supertaxa of taxa
passing the filter. Positive numbers indicate the number of ranks above the
target taxa to return. '0' is equivalent to 'FALSE'. Negative numbers are
equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="filter_obs_+3A_reassign_obs">reassign_obs</code></td>
<td>
<p>('logical') This only has an effect when 'drop_taxa' is
'TRUE'. If 'TRUE', observations assigned to removed taxa will be reassigned
to the closest supertaxon that passed the filter. If there are no supertaxa
of such an observation that passed the filter, they will be filtered out if
'drop_obs' is 'TRUE'. This option can be either simply 'TRUE'/'FALSE',
meaning that all data sets will be treated the same, or a logical vector
can be supplied with names corresponding one or more data sets in
'obj$data'. For example, 'c(abundance = TRUE, stats = FALSE)' would
reassign observations in 'obj$data$abundance', but not in 'obj$data$stats'.</p>
</td></tr>
<tr><td><code id="filter_obs_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filter by row index
filter_obs(ex_taxmap, "info", 1:2)

# Filter by TRUE/FALSE
filter_obs(ex_taxmap, "info", dangerous == FALSE)
filter_obs(ex_taxmap, "info", dangerous == FALSE, n_legs &gt; 0)
filter_obs(ex_taxmap, "info", n_legs == 2)

# Remove taxa whose obserservations were filtered out
filter_obs(ex_taxmap, "info", n_legs == 2, drop_taxa = TRUE)

# Preserve other data sets while removing taxa
filter_obs(ex_taxmap, "info", n_legs == 2, drop_taxa = TRUE,
           drop_obs = c(abund = FALSE))

# When filtering taxa, do not return supertaxa of taxa that are preserved
filter_obs(ex_taxmap, "info", n_legs == 2, drop_taxa = TRUE,
           supertaxa = FALSE)

# Filter multiple datasets at once
filter_obs(ex_taxmap, c("info", "phylopic_ids", "foods"), n_legs == 2)

</code></pre>

<hr>
<h2 id='filter_taxa'>Filter taxa with a list of conditions</h2><span id='topic+filter_taxa'></span>

<h3>Description</h3>

<p>Filter taxa in a [taxonomy()] or [taxmap()] object with a series of
conditions. Any variable name that appears in [all_names()] can be used
as if it was a vector on its own. See [dplyr::filter()] for the inspiration
for this function and more information. Calling the function using the
'obj$filter_taxa(...)' style edits &quot;obj&quot; in place, unlike most R functions.
However, calling the function using the &lsquo;filter_taxa(obj, ...)' imitates R&rsquo;s
traditional copy-on-modify semantics, so &quot;obj&quot; would not be changed; instead
a changed version would be returned, like most R functions.
</p>
<pre>
filter_taxa(obj, ..., subtaxa = FALSE, supertaxa = FALSE,
  drop_obs = TRUE, reassign_obs = TRUE, reassign_taxa = TRUE,
  invert = FALSE, keep_order = TRUE)
obj$filter_taxa(..., subtaxa = FALSE, supertaxa = FALSE,
  drop_obs = TRUE, reassign_obs = TRUE, reassign_taxa = TRUE,
  invert = FALSE, keep_order = TRUE)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_taxa_+3A_obj">obj</code></td>
<td>
<p>An object of class [taxonomy()] or [taxmap()]</p>
</td></tr>
<tr><td><code id="filter_taxa_+3A_...">...</code></td>
<td>
<p>One or more filtering conditions. Any variable name that appears
in [all_names()] can be used as if it was a vector on its own. Each
filtering condition must resolve to one of three things:
* 'character': One or more taxon IDs contained in 'obj$edge_list$to'
* 'integer': One or more row indexes of 'obj$edge_list'
* 'logical': A 'TRUE'/'FALSE' vector of length equal to the number of rows
in 'obj$edge_list'
* 'NULL': ignored</p>
</td></tr>
<tr><td><code id="filter_taxa_+3A_subtaxa">subtaxa</code></td>
<td>
<p>('logical' or 'numeric' of length 1) If 'TRUE', include
subtaxa of taxa passing the filter. Positive numbers indicate the number of
ranks below the target taxa to return. '0' is equivalent to 'FALSE'.
Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="filter_taxa_+3A_supertaxa">supertaxa</code></td>
<td>
<p>('logical'  or 'numeric' of length 1) If 'TRUE', include
supertaxa of taxa passing the filter. Positive numbers indicate the number
of ranks above the target taxa to return. '0' is equivalent to 'FALSE'.
Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="filter_taxa_+3A_drop_obs">drop_obs</code></td>
<td>
<p>('logical')  This option only applies to [taxmap()] objects.
If 'FALSE', include observations (i.e. user-defined data in 'obj$data')
even if the taxon they are assigned to is filtered out. Observations
assigned to removed taxa will be assigned to <code>NA</code>. This option can be
either simply 'TRUE'/'FALSE', meaning that all data sets will be treated
the same, or a logical vector can be supplied with names corresponding one
or more data sets in 'obj$data'. For example, 'c(abundance = FALSE, stats =
TRUE)' would include observations whose taxon was filtered out in
'obj$data$abundance', but not in 'obj$data$stats'. See the 'reassign_obs'
option below for further complications.</p>
</td></tr>
<tr><td><code id="filter_taxa_+3A_reassign_obs">reassign_obs</code></td>
<td>
<p>('logical' of length 1) This option only applies to
[taxmap()] objects. If 'TRUE', observations (i.e. user-defined data in
'obj$data') assigned to removed taxa will be reassigned to the closest
supertaxon that passed the filter. If there are no supertaxa of such an
observation that passed the filter, they will be filtered out if 'drop_obs'
is 'TRUE'. This option can be either simply 'TRUE'/'FALSE', meaning that
all data sets will be treated the same, or a logical vector can be supplied
with names corresponding one or more data sets in 'obj$data'. For example,
'c(abundance = TRUE, stats = FALSE)' would reassign observations in
'obj$data$abundance', but not in 'obj$data$stats'.</p>
</td></tr>
<tr><td><code id="filter_taxa_+3A_reassign_taxa">reassign_taxa</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', subtaxa of removed
taxa will be reassigned to the closest supertaxon that passed the filter.
This is useful for removing intermediate levels of a taxonomy.</p>
</td></tr>
<tr><td><code id="filter_taxa_+3A_invert">invert</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', do NOT include the
selection. This is different than just replacing a '==' with a '!=' because
this option negates the selection after taking into account the 'subtaxa'
and 'supertaxa' options. This is useful for removing a taxon and all its
subtaxa for example.</p>
</td></tr>
<tr><td><code id="filter_taxa_+3A_keep_order">keep_order</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', keep relative order of
taxa not filtered out. For example, the result of 'filter_taxa(ex_taxmap,
1:3)' and 'filter_taxa(ex_taxmap, 3:1)' would be the same. Does not affect
dataset order, only taxon order. This is useful for maintaining order
correspondence with a dataset that has one value per taxon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxonomy()] or [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Filter by index
filter_taxa(ex_taxmap, 1:3)

# Filter by taxon ID
filter_taxa(ex_taxmap, c("b", "c", "d"))

# Fiter by TRUE/FALSE
filter_taxa(ex_taxmap, taxon_names == "Plantae", subtaxa = TRUE)
filter_taxa(ex_taxmap, n_obs &gt; 3)
filter_taxa(ex_taxmap, ! taxon_ranks %in% c("species", "genus"))
filter_taxa(ex_taxmap, taxon_ranks == "genus", n_obs &gt; 1)

# Filter by an observation characteristic
dangerous_taxa &lt;- sapply(ex_taxmap$obs("info"),
                         function(i) any(ex_taxmap$data$info$dangerous[i]))
filter_taxa(ex_taxmap, dangerous_taxa)

# Include supertaxa
filter_taxa(ex_taxmap, 12, supertaxa = TRUE)
filter_taxa(ex_taxmap, 12, supertaxa = 2)

# Include subtaxa
filter_taxa(ex_taxmap, 1, subtaxa = TRUE)
filter_taxa(ex_taxmap, 1, subtaxa = 2)

# Dont remove rows in user-defined data corresponding to removed taxa
filter_taxa(ex_taxmap, 2, drop_obs = FALSE)
filter_taxa(ex_taxmap, 2, drop_obs = c(info = FALSE))

# Remove a taxon and it subtaxa
filter_taxa(ex_taxmap, taxon_names == "Mammalia",
            subtaxa = TRUE, invert = TRUE)

</code></pre>

<hr>
<h2 id='filtering-helpers'>Taxonomic filtering helpers</h2><span id='topic+filtering-helpers'></span><span id='topic+ranks'></span><span id='topic+nms'></span><span id='topic+ids'></span>

<h3>Description</h3>

<p>Taxonomic filtering helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranks(...)

nms(...)

ids(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filtering-helpers_+3A_...">...</code></td>
<td>
<p>quoted rank names, taxonomic names, taxonomic ids, or
any of those with supported operators (See <strong>Supported Relational
Operators</strong> below)</p>
</td></tr>
</table>


<h3>How do these functions work?</h3>

<p>Each function assigns some metadata so we can more easily process
your query downstream. In addition, we check for whether you've
used any relational operators and pull those out to make downstream
processing easier
</p>
<p>The goal of these functions is to make it easy to combine queries
based on each of rank names, taxonomic names, and taxonomic ids.
</p>
<p>These are designed to be used inside of [pop()], [pick()], [span()]. Inside
of those functions, we figure out what rank names you want to filter
on, then check against a reference dataset ([ranks_ref]) to allow
ordered queries like <em>I want all taxa between Class and Genus</em>. If you
provide rank names, we just use those, then do the filtering you requested.
If you provide taxonomic names or ids we figure out what rank names you are
referring to, then we can proceed as in the previous sentence.
</p>


<h3>Supported Relational Operators</h3>


<ul>
<li><p> '&gt;' all items above rank of x
</p>
</li>
<li><p> '&gt;=' all items above rank of x, inclusive
</p>
</li>
<li><p> '&lt;' all items below rank of x
</p>
</li>
<li><p> '&lt;=' all items below rank of x, inclusive
</p>
</li></ul>



<h3>ranks</h3>

<p>Ranks can be any character string in the set of acceptable rank
names.
</p>


<h3>nms</h3>

<p>'nms' is named to avoid using 'names' which would collide with the
fxn [base::names()] in Base R. Can pass in any character taxonomic names.
</p>


<h3>ids</h3>

<p>Ids are any alphanumeric taxonomic identifier. Some database providers
use all digits, but some use a combination of digits and characters.
</p>


<h3>Note</h3>

<p>NSE is not supported at the moment, but may be in the future
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks("genus")
ranks("order", "genus")
ranks("&gt; genus")

nms("Poaceae")
nms("Poaceae", "Poa")
nms("&lt; Poaceae")

ids(4544)
ids(4544, 4479)
ids("&lt; 4479")
</code></pre>

<hr>
<h2 id='get_class_from_el'>Get classification for taxa in edge list</h2><span id='topic+get_class_from_el'></span>

<h3>Description</h3>

<p>Extracts the classification of every taxon in a list of unique taxa and their supertaxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_class_from_el(taxa, parents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_class_from_el_+3A_taxa">taxa</code></td>
<td>
<p>(<code>character</code>) Unique taxon IDs for every possible taxon.</p>
</td></tr>
<tr><td><code id="get_class_from_el_+3A_parents">parents</code></td>
<td>
<p>(<code>character</code>) Unique taxon IDs for the supertaxa of every possible taxon.
Root taxa should have <code>NA</code> in this column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of taxa IDs. Each list entry corresponds to the <code>taxa</code> supplied.
</p>

<hr>
<h2 id='get_data'>Get data in a taxmap object by name</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>Given a vector of names, return a list of data (usually lists/vectors)
contained in a [taxonomy()] or [taxmap()] object. Each item will be named by
taxon ids when possible.
</p>
<pre>
obj$get_data(name = NULL, ...)
get_data(obj, name = NULL, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data_+3A_obj">obj</code></td>
<td>
<p>A [taxonomy()] or [taxmap()]  object</p>
</td></tr>
<tr><td><code id="get_data_+3A_name">name</code></td>
<td>
<p>('character') Names of data to return. If not supplied, return
all data listed in [all_names()].</p>
</td></tr>
<tr><td><code id="get_data_+3A_...">...</code></td>
<td>
<p>Passed to [all_names()]. Used to filter what kind of data is
returned (e.g. columns in tables or function output?) if 'name' is not
supplied or what kinds are allowed if 'name' is supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'list' of vectors or lists. Each vector or list will be named by
associated taxon ids if possible.
</p>


<h3>See Also</h3>

<p>Other NSE helpers: 
<code><a href="#topic+all_names">all_names</a>()</code>,
<code><a href="#topic+data_used">data_used</a></code>,
<code><a href="#topic+names_used">names_used</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get specific values
get_data(ex_taxmap, c("reaction", "n_legs", "taxon_ranks"))

# Get all values
get_data(ex_taxmap)

</code></pre>

<hr>
<h2 id='get_data_frame'>Get data in a taxonomy or taxmap object by name</h2><span id='topic+get_data_frame'></span>

<h3>Description</h3>

<p>Given a vector of names, return a  table of the indicated data
contained in a [taxonomy()] or [taxmap()] object.
</p>
<pre>
obj$get_data_frame(name = NULL, ...)
get_data_frame(obj, name = NULL, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data_frame_+3A_obj">obj</code></td>
<td>
<p>A [taxonomy()] or [taxmap()]  object</p>
</td></tr>
<tr><td><code id="get_data_frame_+3A_name">name</code></td>
<td>
<p>('character') Names of data to return. If not supplied, return
all data listed in [all_names()].</p>
</td></tr>
<tr><td><code id="get_data_frame_+3A_...">...</code></td>
<td>
<p>Passed to [all_names()]. Used to filter what kind of data is
returned (e.g. columns in tables or function output?) if 'name' is not
supplied or what kinds are allowed if 'name' is supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This function will not work with variables in datasets in [taxmap()]
objects unless their rows correspond 1:1 with all taxa.
</p>


<h3>Value</h3>

<p>'data.frame'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get specific values
get_data_frame(ex_taxmap, c("taxon_names", "taxon_indexes", "is_stem"))


</code></pre>

<hr>
<h2 id='get_database_name'>Return name of database</h2><span id='topic+get_database_name'></span>

<h3>Description</h3>

<p>This is meant to return the name of a database when it is not known if the
input is a 'TaxonDatabase' object or a simple character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_database_name(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_database_name_+3A_input">input</code></td>
<td>
<p>Either a character vector or 'TaxonDatabase' class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the database
</p>

<hr>
<h2 id='get_dataset'>Get a data set from a taxmap object</h2><span id='topic+get_dataset'></span>

<h3>Description</h3>

<p>Get a data set from a taxmap object and complain if it does not
exist.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dataset_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="get_dataset_+3A_data">data</code></td>
<td>
<p>Dataset name, index, or a logical vector that indicates which dataset in
'obj$data' to add columns to.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Get data set by name
get_dataset(ex_taxmap, "info")

# Get data set by indeex_taxmap
get_dataset(ex_taxmap, 1)

# Get data set by T/F vector
get_dataset(ex_taxmap, startsWith(names(ex_taxmap$data), "i"))

</code></pre>

<hr>
<h2 id='get_dots_or_list'>Get input from dots or list</h2><span id='topic+get_dots_or_list'></span>

<h3>Description</h3>

<p>Get input from dots or list, but not both.
Throws an error if both are supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dots_or_list(..., .list = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dots_or_list_+3A_...">...</code></td>
<td>
<p>Dots input</p>
</td></tr>
<tr><td><code id="get_dots_or_list_+3A_.list">.list</code></td>
<td>
<p>List input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of inputs
</p>

<hr>
<h2 id='get_edge_children'>get_edge_children</h2><span id='topic+get_edge_children'></span>

<h3>Description</h3>

<p>get_edge_children
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edge_children(graph)
</code></pre>

<hr>
<h2 id='get_edge_parents'>get_edge_parents</h2><span id='topic+get_edge_parents'></span>

<h3>Description</h3>

<p>get_edge_parents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_edge_parents(graph)
</code></pre>

<hr>
<h2 id='get_expected_data'>Get a data set in as_phyloseq</h2><span id='topic+get_expected_data'></span>

<h3>Description</h3>

<p>Get a data set in as_phyloseq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_expected_data(obj, input, default, expected_class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_expected_data_+3A_obj">obj</code></td>
<td>
<p>The taxmap object</p>
</td></tr>
<tr><td><code id="get_expected_data_+3A_input">input</code></td>
<td>
<p>The input to as_phyloseq options.</p>
</td></tr>
<tr><td><code id="get_expected_data_+3A_default">default</code></td>
<td>
<p>The default name of the data set.</p>
</td></tr>
<tr><td><code id="get_expected_data_+3A_expected_class">expected_class</code></td>
<td>
<p>What the dataset is expected to be.</p>
</td></tr>
</table>

<hr>
<h2 id='get_node_children'>get_node_children</h2><span id='topic+get_node_children'></span>

<h3>Description</h3>

<p>get_node_children
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_node_children(graph, node)
</code></pre>

<hr>
<h2 id='get_numeric_cols'>Get numeric columns from taxmap table</h2><span id='topic+get_numeric_cols'></span>

<h3>Description</h3>

<p>If columns are specified by the user, parse them and check that they are numeric.
If not, return all numeric columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_numeric_cols(obj, data, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_numeric_cols_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="get_numeric_cols_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj</code>.</p>
</td></tr>
<tr><td><code id="get_numeric_cols_+3A_cols">cols</code></td>
<td>
<p>The names/indexes of columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns
corresponding to <code>TRUE</code> values.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='get_numerics'>Return numeric values in a character</h2><span id='topic+get_numerics'></span>

<h3>Description</h3>

<p>Returns just valid numeric values and ignores others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_numerics(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_numerics_+3A_input">input</code></td>
<td>
</td></tr>
</table>

<hr>
<h2 id='get_optimal_range'>Find optimal range</h2><span id='topic+get_optimal_range'></span>

<h3>Description</h3>

<p>Finds optimal max and min value using an optimality criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_optimal_range(
  max_range,
  min_range,
  resolution,
  opt_crit,
  choose_best,
  minimize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_optimal_range_+3A_max_range">max_range</code></td>
<td>
<p>(<code>numeric</code> of length 2) The min and max boundaries to the search space for
the optimal maximum value.</p>
</td></tr>
<tr><td><code id="get_optimal_range_+3A_min_range">min_range</code></td>
<td>
<p>(<code>numeric</code> of length 2) The min and max boundaries to the search space for
the optimal minimum value.</p>
</td></tr>
<tr><td><code id="get_optimal_range_+3A_resolution">resolution</code></td>
<td>
<p>(<code>numeric</code> of length 2) The number of increments in each dimension.</p>
</td></tr>
<tr><td><code id="get_optimal_range_+3A_opt_crit">opt_crit</code></td>
<td>
<p>(<code>function</code>) A function that takes two arguments, the max and min, and
returns the optimality statistic.</p>
</td></tr>
<tr><td><code id="get_optimal_range_+3A_choose_best">choose_best</code></td>
<td>
<p>(<code>function</code>) A function that takes a list of <code>opt_crit</code> outputs
and returns the index of the best one.</p>
</td></tr>
</table>

<hr>
<h2 id='get_sort_var'>Get a vector from a vector/list/table to be used in mapping</h2><span id='topic+get_sort_var'></span>

<h3>Description</h3>

<p>Get a vector from a vector/list/table to be used in mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sort_var(data, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sort_var_+3A_data">data</code></td>
<td>
<p>A vector/list/table</p>
</td></tr>
<tr><td><code id="get_sort_var_+3A_var">var</code></td>
<td>
<p>What to get.
* For tables, the names of columns can be used.
* '&quot;{{index}}&quot;' : This means to use the index of rows/items
* '&quot;{{name}}&quot;'  : This means to use row/item names.
* '&quot;{{value}}&quot;' : This means to use the values in vectors or lists. Lists</p>
</td></tr>
</table>

<hr>
<h2 id='get_taxmap_cols'>Get a column subset</h2><span id='topic+get_taxmap_cols'></span>

<h3>Description</h3>

<p>Convert logical, names, or indexes to column names and check that they exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxmap_cols(obj, data, cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_taxmap_cols_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="get_taxmap_cols_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj</code> that contains counts.</p>
</td></tr>
<tr><td><code id="get_taxmap_cols_+3A_cols">cols</code></td>
<td>
<p>The columns in the data set to use. Takes one of
the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All non-target columns will be preserved or not.</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns
corresponding to <code>TRUE</code> values.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
</dl>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other option parsers: 
<code><a href="#topic+get_taxmap_data">get_taxmap_data</a>()</code>,
<code><a href="#topic+get_taxmap_other_cols">get_taxmap_other_cols</a>()</code>,
<code><a href="#topic+get_taxmap_table">get_taxmap_table</a>()</code>,
<code><a href="#topic+verify_taxmap">verify_taxmap</a>()</code>
</p>

<hr>
<h2 id='get_taxmap_data'>Get a data set from a taxmap object</h2><span id='topic+get_taxmap_data'></span>

<h3>Description</h3>

<p>NOTE: This will be replaced by the function 'get_dataset' in the 'taxa'
package. Get a data set from a taxmap object and complain if it does not
exist. This is intended to be used to parse options in other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxmap_data(obj, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_taxmap_data_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="get_taxmap_data_+3A_data">data</code></td>
<td>
<p>Which data set to use. Can be any of the following:
</p>

<dl>
<dt>Name</dt><dd><p>The name of the data set to use.</p>
</dd>
<dt>Index</dt><dd><p>The index of the data set to use.</p>
</dd>
<dt>TRUE/FALSE vector</dt><dd><p>A TRUE/FALSE vector the same length as the
number of datasets, with exactly one TRUE corresponding to the
selected data set.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other option parsers: 
<code><a href="#topic+get_taxmap_cols">get_taxmap_cols</a>()</code>,
<code><a href="#topic+get_taxmap_other_cols">get_taxmap_other_cols</a>()</code>,
<code><a href="#topic+get_taxmap_table">get_taxmap_table</a>()</code>,
<code><a href="#topic+verify_taxmap">verify_taxmap</a>()</code>
</p>

<hr>
<h2 id='get_taxmap_other_cols'>Parse the other_cols option</h2><span id='topic+get_taxmap_other_cols'></span>

<h3>Description</h3>

<p>Parse the other_cols option used in many calculation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxmap_other_cols(obj, data, cols, other_cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_taxmap_other_cols_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="get_taxmap_other_cols_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj</code> that contains counts.</p>
</td></tr>
<tr><td><code id="get_taxmap_other_cols_+3A_cols">cols</code></td>
<td>
<p>The names/indexes of columns in <code>data</code> to use. Takes one
of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All columns will used.</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns
corresponding to <code>TRUE</code> values.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to use</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_taxmap_other_cols_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. The &quot;taxon_id&quot; column will always be preserved. Takes one of
the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All non-target columns will be preserved or not.</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns
corresponding to <code>TRUE</code> values.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
</dl>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other option parsers: 
<code><a href="#topic+get_taxmap_cols">get_taxmap_cols</a>()</code>,
<code><a href="#topic+get_taxmap_data">get_taxmap_data</a>()</code>,
<code><a href="#topic+get_taxmap_table">get_taxmap_table</a>()</code>,
<code><a href="#topic+verify_taxmap">verify_taxmap</a>()</code>
</p>

<hr>
<h2 id='get_taxmap_table'>Get a table from a taxmap object</h2><span id='topic+get_taxmap_table'></span>

<h3>Description</h3>

<p>Get a table from a taxmap object and complain if it does not exist.
This is intended to be used to parse options in other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxmap_table(obj, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_taxmap_table_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="get_taxmap_table_+3A_data">data</code></td>
<td>
<p>Which data set to use. Can be any of the following:
</p>

<dl>
<dt>Name</dt><dd><p>The name of the data set to use.</p>
</dd>
<dt>Index</dt><dd><p>The index of the data set to use.</p>
</dd>
<dt>TRUE/FALSE vector</dt><dd><p>A TRUE/FALSE vector the same length as the
number of datasets, with exactly one TRUE corresponding to the
selected data set.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A table
</p>


<h3>See Also</h3>

<p>Other option parsers: 
<code><a href="#topic+get_taxmap_cols">get_taxmap_cols</a>()</code>,
<code><a href="#topic+get_taxmap_data">get_taxmap_data</a>()</code>,
<code><a href="#topic+get_taxmap_other_cols">get_taxmap_other_cols</a>()</code>,
<code><a href="#topic+verify_taxmap">verify_taxmap</a>()</code>
</p>

<hr>
<h2 id='get_taxonomy_levels'>Get taxonomy levels</h2><span id='topic+get_taxonomy_levels'></span>

<h3>Description</h3>

<p>Return An ordered factor of taxonomy levels, such as &quot;Subkingdom&quot; and &quot;Order&quot;, in order of the
hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_taxonomy_levels()
</code></pre>

<hr>
<h2 id='heat_tree'>Plot a taxonomic tree</h2><span id='topic+heat_tree'></span><span id='topic+heat_tree.Taxmap'></span><span id='topic+heat_tree.default'></span>

<h3>Description</h3>

<p>Plots the distribution of values associated with a taxonomic classification/heirarchy.
Taxonomic classifications can have multiple roots, resulting in multiple trees on the same plot.
A tree consists of elements, element properties, conditions, and mapping properties which are
represented as parameters in the heat_tree object.
The elements (e.g. nodes, edges, lables, and individual trees) are the infrastructure of the heat tree.
The element properties (e.g. size and color) are characteristics that are manipulated by various 
data conditions and mapping properties.  The element properties can be explicitly defined or automatically generated.
The conditions are data (e.g. taxon statistics, such as abundance) represented in the taxmap/metacoder object.
The mapping properties are parameters (e.g. transformations, range, interval, and layout) used to change the 
elements/element properties and how they are used to represent (or not represent) the various conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heat_tree(...)

## S3 method for class 'Taxmap'
heat_tree(.input, ...)

## Default S3 method:
heat_tree(
  taxon_id,
  supertaxon_id,
  node_label = NA,
  edge_label = NA,
  tree_label = NA,
  node_size = 1,
  edge_size = node_size,
  node_label_size = node_size,
  edge_label_size = edge_size,
  tree_label_size = as.numeric(NA),
  node_color = "#999999",
  edge_color = node_color,
  tree_color = NA,
  node_label_color = "#000000",
  edge_label_color = "#000000",
  tree_label_color = "#000000",
  node_size_trans = "area",
  edge_size_trans = node_size_trans,
  node_label_size_trans = node_size_trans,
  edge_label_size_trans = edge_size_trans,
  tree_label_size_trans = "area",
  node_color_trans = "area",
  edge_color_trans = node_color_trans,
  tree_color_trans = "area",
  node_label_color_trans = "area",
  edge_label_color_trans = "area",
  tree_label_color_trans = "area",
  node_size_range = c(NA, NA),
  edge_size_range = c(NA, NA),
  node_label_size_range = c(NA, NA),
  edge_label_size_range = c(NA, NA),
  tree_label_size_range = c(NA, NA),
  node_color_range = quantative_palette(),
  edge_color_range = node_color_range,
  tree_color_range = quantative_palette(),
  node_label_color_range = quantative_palette(),
  edge_label_color_range = quantative_palette(),
  tree_label_color_range = quantative_palette(),
  node_size_interval = range(node_size, na.rm = TRUE, finite = TRUE),
  node_color_interval = NULL,
  edge_size_interval = range(edge_size, na.rm = TRUE, finite = TRUE),
  edge_color_interval = NULL,
  node_label_max = 500,
  edge_label_max = 500,
  tree_label_max = 500,
  overlap_avoidance = 1,
  margin_size = c(0, 0, 0, 0),
  layout = "reingold-tilford",
  initial_layout = "fruchterman-reingold",
  make_node_legend = TRUE,
  make_edge_legend = TRUE,
  title = NULL,
  title_size = 0.08,
  node_legend_title = "Nodes",
  edge_legend_title = "Edges",
  node_color_axis_label = NULL,
  node_size_axis_label = NULL,
  edge_color_axis_label = NULL,
  edge_size_axis_label = NULL,
  node_color_digits = 3,
  node_size_digits = 3,
  edge_color_digits = 3,
  edge_size_digits = 3,
  background_color = "#FFFFFF00",
  output_file = NULL,
  aspect_ratio = 1,
  repel_labels = TRUE,
  repel_force = 1,
  repel_iter = 1000,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heat_tree_+3A_...">...</code></td>
<td>
<p>(other named arguments)
Passed to the <code>igraph</code> layout function used.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_.input">.input</code></td>
<td>
<p>An object of type <code><a href="#topic+taxmap">taxmap</a></code></p>
</td></tr>
<tr><td><code id="heat_tree_+3A_taxon_id">taxon_id</code></td>
<td>
<p>The unique ids of taxa.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_supertaxon_id">supertaxon_id</code></td>
<td>
<p>The unique id of supertaxon <code>taxon_id</code> is a part of.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_label">node_label</code></td>
<td>
<p>See details on labels.
Default: no labels.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_label">edge_label</code></td>
<td>
<p>See details on labels.
Default: no labels.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_label">tree_label</code></td>
<td>
<p>See details on labels.
The label to display above each graph.
The value of the root of each graph will be used.
Default: None.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_size">node_size</code></td>
<td>
<p>See details on size.
Default: constant size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_size">edge_size</code></td>
<td>
<p>See details on size.
Default: relative to node size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_label_size">node_label_size</code></td>
<td>
<p>See details on size.
Default: relative to vertex size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_label_size">edge_label_size</code></td>
<td>
<p>See details on size.
Default: relative to edge size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_label_size">tree_label_size</code></td>
<td>
<p>See details on size.
Default: relative to graph size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_color">node_color</code></td>
<td>
<p>See details on colors.
Default: grey.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_color">edge_color</code></td>
<td>
<p>See details on colors.
Default: same as node color.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_color">tree_color</code></td>
<td>
<p>See details on colors.
The value of the root of each graph will be used.
Overwrites the node and edge color if specified.
Default: Not used.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_label_color">node_label_color</code></td>
<td>
<p>See details on colors.
Default: black.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_label_color">edge_label_color</code></td>
<td>
<p>See details on colors.
Default: black.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_label_color">tree_label_color</code></td>
<td>
<p>See details on colors.
Default: black.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_size_trans">node_size_trans</code></td>
<td>
<p>See details on transformations.
Default: <code>"area"</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_size_trans">edge_size_trans</code></td>
<td>
<p>See details on transformations. 
Default: same as <code>node_size_trans</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_label_size_trans">node_label_size_trans</code></td>
<td>
<p>See details on transformations. 
Default: same as <code>node_size_trans</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_label_size_trans">edge_label_size_trans</code></td>
<td>
<p>See details on transformations. 
Default: same as <code>edge_size_trans</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_label_size_trans">tree_label_size_trans</code></td>
<td>
<p>See details on transformations.
Default: <code>"area"</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_color_trans">node_color_trans</code></td>
<td>
<p>See details on transformations. 
Default: <code>"area"</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_color_trans">edge_color_trans</code></td>
<td>
<p>See details on transformations.
Default: same as node color transformation.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_color_trans">tree_color_trans</code></td>
<td>
<p>See details on transformations.
Default: <code>"area"</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_label_color_trans">node_label_color_trans</code></td>
<td>
<p>See details on transformations.
Default: <code>"area"</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_label_color_trans">edge_label_color_trans</code></td>
<td>
<p>See details on transformations.
Default: <code>"area"</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_label_color_trans">tree_label_color_trans</code></td>
<td>
<p>See details on transformations. 
Default: <code>"area"</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_size_range">node_size_range</code></td>
<td>
<p>See details on ranges.
Default: Optimize to balance overlaps and range size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_size_range">edge_size_range</code></td>
<td>
<p>See details on ranges.
Default: relative to node size range.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_label_size_range">node_label_size_range</code></td>
<td>
<p>See details on ranges.
Default: relative to node size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_label_size_range">edge_label_size_range</code></td>
<td>
<p>See details on ranges.
Default: relative to edge size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_label_size_range">tree_label_size_range</code></td>
<td>
<p>See details on ranges.
Default: relative to tree size.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_color_range">node_color_range</code></td>
<td>
<p>See details on ranges.
Default: Color-blind friendly palette.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_color_range">edge_color_range</code></td>
<td>
<p>See details on ranges.
Default: same as node color.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_color_range">tree_color_range</code></td>
<td>
<p>See details on ranges.
Default: Color-blind friendly palette.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_label_color_range">node_label_color_range</code></td>
<td>
<p>See details on ranges.
Default: Color-blind friendly palette.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_label_color_range">edge_label_color_range</code></td>
<td>
<p>See details on ranges.
Default: Color-blind friendly palette.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_label_color_range">tree_label_color_range</code></td>
<td>
<p>See details on ranges.
Default: Color-blind friendly palette.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_size_interval">node_size_interval</code></td>
<td>
<p>See details on intervals.
Default: The range of values in <code>node_size</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_color_interval">node_color_interval</code></td>
<td>
<p>See details on intervals.
Default: The range of values in <code>node_color</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_size_interval">edge_size_interval</code></td>
<td>
<p>See details on intervals.
Default: The range of values in <code>edge_size</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_color_interval">edge_color_interval</code></td>
<td>
<p>See details on intervals.
Default: The range of values in <code>edge_color</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_label_max">node_label_max</code></td>
<td>
<p>The maximum number of node labels.
Default: 20.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_label_max">edge_label_max</code></td>
<td>
<p>The maximum number of edge labels.
Default: 20.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_tree_label_max">tree_label_max</code></td>
<td>
<p>The maximum number of tree labels.
Default: 20.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_overlap_avoidance">overlap_avoidance</code></td>
<td>
<p>(<code>numeric</code>)
The relative importance of avoiding overlaps vs maximizing size range.
Higher numbers will cause node size optimization to avoid overlaps more.
Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_margin_size">margin_size</code></td>
<td>
<p>(<code>numeric</code> of length 2)
The horizontal and vertical margins. c(left, right, bottom, top).
Default: <code>0, 0, 0, 0</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_layout">layout</code></td>
<td>
<p>The layout algorithm used to position nodes.
See details on layouts.
Default: <code>"reingold-tilford"</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_initial_layout">initial_layout</code></td>
<td>
<p>he layout algorithm used to set the initial position
of nodes, passed as input to the <code>layout</code> algorithm.
See details on layouts.
Default: Not used.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_make_node_legend">make_node_legend</code></td>
<td>
<p>if TRUE, make legend for node size/color mappings.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_make_edge_legend">make_edge_legend</code></td>
<td>
<p>if TRUE, make legend for edge size/color mappings.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_title">title</code></td>
<td>
<p>Name to print above the graph.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_title_size">title_size</code></td>
<td>
<p>The size of the title relative to the rest of the graph.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_legend_title">node_legend_title</code></td>
<td>
<p>The title of the legend for node data. Can be 'NA'
or 'NULL' to remove the title.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_legend_title">edge_legend_title</code></td>
<td>
<p>The title of the legend for edge data. Can be 'NA'
or 'NULL' to remove the title.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_color_axis_label">node_color_axis_label</code></td>
<td>
<p>The label on the scale axis corresponding to <code>node_color</code>.
Default: The expression given to <code>node_color</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_size_axis_label">node_size_axis_label</code></td>
<td>
<p>The label on the scale axis corresponding to <code>node_size</code>.
Default: The expression given to <code>node_size</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_color_axis_label">edge_color_axis_label</code></td>
<td>
<p>The label on the scale axis corresponding to <code>edge_color</code>.
Default: The expression given to <code>edge_color</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_size_axis_label">edge_size_axis_label</code></td>
<td>
<p>The label on the scale axis corresponding to <code>edge_size</code>.
Default: The expression given to <code>edge_size</code>.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_color_digits">node_color_digits</code></td>
<td>
<p>The number of significant figures used for the numbers on the scale axis corresponding to <code>node_color</code>.
Default: 3.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_node_size_digits">node_size_digits</code></td>
<td>
<p>The number of significant figures used for the numbers on the scale axis corresponding to <code>node_size</code>.
Default: 3.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_color_digits">edge_color_digits</code></td>
<td>
<p>The number of significant figures used for the numbers on the scale axis corresponding to <code>edge_color</code>.
Default: 3.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_edge_size_digits">edge_size_digits</code></td>
<td>
<p>The number of significant figures used for the numbers on the scale axis corresponding to <code>edge_size</code>.
Default: 3.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_background_color">background_color</code></td>
<td>
<p>The background color of the plot.
Default: Transparent</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_output_file">output_file</code></td>
<td>
<p>The path to one or more files to save the plot in using <code>ggplot2::ggsave</code>. 
The type of the file will be determined by the extension given.
Default: Do not save plot.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>The aspect_ratio of the plot.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_repel_labels">repel_labels</code></td>
<td>
<p>If <code>TRUE</code> (Default), use the ggrepel package to spread out labels.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_repel_force">repel_force</code></td>
<td>
<p>The force of which overlapping labels will be repelled from eachother.</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_repel_iter">repel_iter</code></td>
<td>
<p>The number of iterations used when repelling labels</p>
</td></tr>
<tr><td><code id="heat_tree_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> print progress reports as the function runs.</p>
</td></tr>
</table>


<h3>labels</h3>

<p>The labels of nodes, edges, and trees can be added.
Node labels are centered over their node.
Edge labels are displayed over edges, in the same orientation.
Tree labels are displayed over their tree.
</p>
<p>Accepts a vector, the same length <code>taxon_id</code> or a factor of its length.
</p>


<h3>sizes</h3>

<p>The size of nodes, edges, labels, and trees can be mapped to various conditions.
This is useful for displaying statistics for taxa, such as abundance.
Only the relative size of the condition is used, not the values themselves.
The &lt;element&gt;_size_trans (transformation) parameter can be used to make the size mapping non-linear.
The &lt;element&gt;_size_range parameter can be used to proportionately change the size of an
element based on the condition mapped to that element.
The &lt;element&gt;_size_interval parameter can be used to change the limit at which a condition
will be graphically represented as the same size as the minimum/maximum &lt;element&gt;_size_range.
</p>
<p>Accepts a <code>numeric</code> vector, the same length <code>taxon_id</code> or a
factor of its length.
</p>


<h3>colors</h3>

<p>The colors of nodes, edges, labels, and trees can be mapped to various conditions.
This is useful for visually highlighting/clustering groups of taxa.
Only the relative size of the condition is used, not the values themselves.
The &lt;element&gt;_color_trans (transformation) parameter can be used to make the color mapping non-linear.
The &lt;element&gt;_color_range parameter can be used to proportionately change the color of an
element based on the condition mapped to that element.
The &lt;element&gt;_color_interval parameter can be used to change the limit at which a condition
will be graphically represented as the same color as the minimum/maximum &lt;element&gt;_color_range.
</p>
<p>Accepts a vector, the same length <code>taxon_id</code> or a factor of its length.
If a numeric vector is given, it is mapped to a color scale.
Hex values or color names can be used (e.g. <code>#000000</code> or <code>"black"</code>).
</p>
<p>Mapping Properties
</p>


<h3>transformations</h3>

<p>Before any conditions specified are mapped to an element property (color/size), they 
can be transformed to make the mapping non-linear. 
Any of the transformations listed below can be used by specifying their name.
A customized function can also be supplied to do the transformation.
</p>

<dl>
<dt>&quot;linear&quot;</dt><dd><p>Proportional to radius/diameter of node</p>
</dd>
<dt>&quot;area&quot;</dt><dd><p>circular area; better perceptual accuracy than <code>"linear"</code></p>
</dd>
<dt>&quot;log10&quot;</dt><dd><p>Log base 10 of radius</p>
</dd>
<dt>&quot;log2&quot;</dt><dd><p>Log base 2 of radius</p>
</dd>
<dt>&quot;ln&quot;</dt><dd><p>Log base e of radius</p>
</dd>
<dt>&quot;log10 area&quot;</dt><dd><p>Log base 10 of circular area</p>
</dd>
<dt>&quot;log2 area&quot;</dt><dd><p>Log base 2 of circular area</p>
</dd>
<dt>&quot;ln area&quot;</dt><dd><p>Log base e of circular area</p>
</dd>
</dl>



<h3>ranges</h3>

<p>The displayed range of colors and sizes can be explicitly defined or automatically generated.
When explicitly used, the size range will proportionately increase/decrease the size of a particular element.
Size ranges are specified by supplying a <code>numeric</code> vector with two values: the minimum and maximum.
The units used should be between 0 and 1, representing the proportion of a dimension of the graph.
Since the dimensions of the graph are determined by layout, and not always square, the value
that <code>1</code> corresponds to is the square root of the graph area (i.e. the side of a square with 
the same area as the plotted space).
Color ranges can be any number of color values as either HEX codes (e.g. <code>#000000</code>) or
color names (e.g. <code>"black"</code>).
</p>


<h3>layout</h3>

<p>Layouts determine the position of node elements on the graph.
They are implemented using the <code>igraph</code> package.
Any additional arguments passed to <code>heat_tree</code> are passed to the  <code>igraph</code>
function used.
The following <code>character</code> values are understood:
</p>

<dl>
<dt>&quot;automatic&quot;</dt><dd><p>Use <code>igraph::nicely</code>. Let <code>igraph</code> choose the layout.</p>
</dd>
<dt>&quot;reingold-tilford&quot;</dt><dd><p>Use <code>igraph::as_tree</code>. A circular tree-like layout.</p>
</dd>
<dt>&quot;davidson-harel&quot;</dt><dd><p>Use <code>igraph::with_dh</code>. A type of simulated annealing.</p>
</dd>
<dt>&quot;gem&quot;</dt><dd><p>Use <code>igraph::with_gem</code>. A force-directed layout.</p>
</dd>
<dt>&quot;graphopt&quot;</dt><dd><p>Use <code>igraph::with_graphopt</code>. A force-directed layout.</p>
</dd>
<dt>&quot;mds&quot;</dt><dd><p>Use <code>igraph::with_mds</code>. Multidimensional scaling.</p>
</dd>
<dt>&quot;fruchterman-reingold&quot;</dt><dd><p>Use <code>igraph::with_fr</code>. A force-directed layout.</p>
</dd>
<dt>&quot;kamada-kawai&quot;</dt><dd><p>Use <code>igraph::with_kk</code>. A layout based on a physical model of springs.</p>
</dd>
<dt>&quot;large-graph&quot;</dt><dd><p>Use <code>igraph::with_lgl</code>. Meant for larger graphs.</p>
</dd>
<dt>&quot;drl&quot;</dt><dd><p>Use <code>igraph::with_drl</code>. A force-directed layout.</p>
</dd>
</dl>



<h3>intervals</h3>

<p>This is the minimum and maximum of values displayed on the legend scales.
Intervals are specified by supplying a <code>numeric</code> vector with two values: the minimum and maximum.
When explicitly used, the &lt;element&gt;_&lt;property&gt;_interval will redefine the way the actual conditional values are being represented
by setting a limit for the &lt;element&gt;_&lt;property&gt;.
Any condition below the minimum &lt;element&gt;_&lt;property&gt;_interval will be graphically represented the same as a condition AT the
minimum value in the full range of conditional values.  Any value above the maximum &lt;element&gt;_&lt;property&gt;_interval will be graphically 
represented the same as a value AT the maximum value in the full range of conditional values.
By default, the minimum and maximum equals the &lt;element&gt;_&lt;property&gt;_range used to infer the value of the &lt;element&gt;_&lt;property&gt;.
Setting a custom interval is useful for making &lt;element&gt;_&lt;properties&gt; in multiple graphs correspond to the same conditions,
or setting logical boundaries (such as <code>c(0,1)</code> for proportions.
Note that this is different from the &lt;element&gt;_&lt;property&gt;_range mapping property, which determines the size/color of graphed elements.
</p>


<h3>Acknowledgements</h3>

<p>This package includes code from the R package ggrepel to handle label overlap
avoidance with permission from the author of ggrepel Kamil Slowikowski. We
included the code instead of depending on ggrepel because we are using
internal functions to ggrepel that might change in the future. We thank Kamil
Slowikowski for letting us use his code and would like to acknowledge his
implementation of the label overlap avoidance used in metacoder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parse dataset for plotting
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")
                   
# Default appearance:
#  No parmeters are needed, but the default tree is not too useful
heat_tree(x)

# A good place to start:
#  There will always be "taxon_names" and "n_obs" variables, so this is a 
#  good place to start. This will shown the number of OTUs in this case. 
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs)

# Plotting read depth:
#  To plot read depth, you first need to add up the number of reads per taxon.
#  The function `calc_taxon_abund` is good for this. 
x$data$taxon_counts &lt;- calc_taxon_abund(x, data = "tax_data")
x$data$taxon_counts$total &lt;- rowSums(x$data$taxon_counts[, -1]) # -1 = taxon_id column
heat_tree(x, node_label = taxon_names, node_size = total, node_color = total)

# Plotting multiple variables:
#  You can plot up to 4 quantative variables use node/edge size/color, but it
#  is usually best to use 2 or 3. The plot below uses node size for number of
#  OTUs and color for number of reads and edge size for number of samples
x$data$n_samples &lt;- calc_n_samples(x, data = "taxon_counts")
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = total,
          edge_color = n_samples)

# Different layouts:
#  You can use any layout implemented by igraph. You can also specify an
#  initial layout to seed the main layout with.
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          layout = "davidson-harel")
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          layout = "davidson-harel", initial_layout = "reingold-tilford")

# Axis labels:
#  You can add custom labeles to the legends
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = total,
          edge_color = n_samples, node_size_axis_label = "Number of OTUs", 
          node_color_axis_label = "Number of reads",
          edge_color_axis_label = "Number of samples")
          
# Overlap avoidance:
#  You can change how much node overlap avoidance is used.
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          overlap_avoidance = .5)
          
# Label overlap avoidance
#  You can modfiy how label scattering is handled using the `replel_force` and
# `repel_iter` options. You can turn off label scattering using the `repel_labels` option.
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          repel_force = 2, repel_iter = 20000)
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          repel_labels = FALSE)

# Setting the size of graph elements: 
#  You can force nodes, edges, and lables to be a specific size/color range instead
#  of letting the function optimize it. These options end in `_range`.
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          node_size_range = c(0.01, .1))
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          edge_color_range = c("black", "#FFFFFF"))
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          node_label_size_range = c(0.02, 0.02))

# Setting the transformation used:
#  You can change how raw statistics are converted to color/size using options
#  ending in _trans.
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          node_size_trans = "log10 area")

# Setting the interval displayed:
#  By default, the whole range of the statistic provided will be displayed.
#  You can set what range of values are displayed using options ending in `_interval`.
heat_tree(x, node_label = taxon_names, node_size = n_obs, node_color = n_obs,
          node_size_interval = c(10, 100))


</code></pre>

<hr>
<h2 id='heat_tree_matrix'>Plot a matrix of heat trees</h2><span id='topic+heat_tree_matrix'></span>

<h3>Description</h3>

<p>Plot a matrix of heat trees for showing pairwise comparisons. A larger,
labelled tree serves as a key for the matrix of smaller unlabelled trees. The
data for this function is typically created with <code><a href="#topic+compare_groups">compare_groups</a></code>,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heat_tree_matrix(
  obj,
  data,
  label_small_trees = FALSE,
  key_size = 0.6,
  seed = 1,
  output_file = NULL,
  row_label_color = diverging_palette()[3],
  col_label_color = diverging_palette()[1],
  row_label_size = 12,
  col_label_size = 12,
  ...,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heat_tree_matrix_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code> that is the output of 
<code><a href="#topic+compare_groups">compare_groups</a></code> or in the same format.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_label_small_trees">label_small_trees</code></td>
<td>
<p>If <code>TRUE</code> add labels to small trees as well as 
the key tree. Otherwise, only the key tree will be labeled.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_key_size">key_size</code></td>
<td>
<p>The size of the key tree relative to the whole graph. For
example, 0.5 means half the width/height of the graph.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_seed">seed</code></td>
<td>
<p>That random seed used to make the graphs.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_output_file">output_file</code></td>
<td>
<p>The path to one or more files to save the plot in using <code><a href="ggplot2.html#topic+ggsave">ggsave</a></code>. 
The type of the file will be determined by the extension given.
Default: Do not save plot.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_row_label_color">row_label_color</code></td>
<td>
<p>The color of the row labels on the right side of the matrix. Default:
based on the node_color_range.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_col_label_color">col_label_color</code></td>
<td>
<p>The color of the columns labels along the top of the matrix. Default:
based on the node_color_range.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_row_label_size">row_label_size</code></td>
<td>
<p>The size of the row labels on the right side of the matrix. Default: 12.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_col_label_size">col_label_size</code></td>
<td>
<p>The size of the columns labels along the top of the matrix. Default: 12.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+heat_tree">heat_tree</a></code>. Some options will be overwritten.</p>
</td></tr>
<tr><td><code id="heat_tree_matrix_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parse dataset for plotting
x &lt;- parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                    class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                    class_regex = "^(.+)__(.+)$")

# Convert counts to proportions
x$data$otu_table &lt;- calc_obs_props(x, data = "tax_data", cols = hmp_samples$sample_id)

# Get per-taxon counts
x$data$tax_table &lt;- calc_taxon_abund(x, data = "otu_table", cols = hmp_samples$sample_id)

# Calculate difference between treatments
x$data$diff_table &lt;- compare_groups(x, data = "tax_table",
                                    cols = hmp_samples$sample_id,
                                    groups = hmp_samples$body_site)

# Plot results (might take a few minutes)
heat_tree_matrix(x,
                 data = "diff_table",
                 node_size = n_obs,
                 node_label = taxon_names,
                 node_color = log2_median_ratio,
                 node_color_range = diverging_palette(),
                 node_color_trans = "linear",
                 node_color_interval = c(-3, 3),
                 edge_color_interval = c(-3, 3),
                 node_size_axis_label = "Number of OTUs",
                 node_color_axis_label = "Log2 ratio median proportions")


</code></pre>

<hr>
<h2 id='hierarchies'>Make a set of many [hierarchy()] class objects</h2><span id='topic+hierarchies'></span>

<h3>Description</h3>

<p>NOTE: This will soon be depreciated.
Make a set of many [hierarchy()] class objects.
This is just a thin wrapper over a standard list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchies(..., .list = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierarchies_+3A_...">...</code></td>
<td>
<p>Any number of object of class [hierarchy()]</p>
</td></tr>
<tr><td><code id="hierarchies_+3A_.list">.list</code></td>
<td>
<p>Any number of object of class [hierarchy()] in a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'R6Class' object of class [hierarchy()]
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>

<hr>
<h2 id='hierarchy'>The Hierarchy class</h2><span id='topic+hierarchy'></span>

<h3>Description</h3>

<p>A class containing an ordered list of [taxon()] objects that represent a
hierarchical classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarchy(..., .list = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hierarchy_+3A_...">...</code></td>
<td>
<p>Any number of object of class 'Taxon' or taxonomic names as
character strings</p>
</td></tr>
<tr><td><code id="hierarchy_+3A_.list">.list</code></td>
<td>
<p>An alternate to the '...' input. Any number of object of class
[taxon()] or character vectors in a list. Cannot be used with '...'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On initialization, taxa are sorted if they have ranks with a known
order.
</p>
<p>**Methods**
</p>

<dl>
<dt>'pop(rank_names)'</dt><dd>
<p>Remove 'Taxon' elements by rank name, taxon name or taxon ID. The
change happens in place, so you don't need to assign output to a new
object. returns self - rank_names (character) a vector of rank names
</p>
</dd>
<dt>'pick(rank_names)'</dt><dd>
<p>Select 'Taxon' elements by rank name, taxon name or taxon ID. The
change happens in place, so you don't need to assign output to a new
object. returns self - rank_names (character) a vector of rank names
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An 'R6Class' object of class 'Hierarchy'
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- taxon(
  name = taxon_name("Poaceae"),
  rank = taxon_rank("family"),
  id = taxon_id(4479)
))

(y &lt;- taxon(
  name = taxon_name("Poa"),
  rank = taxon_rank("genus"),
  id = taxon_id(4544)
))

(z &lt;- taxon(
  name = taxon_name("Poa annua"),
  rank = taxon_rank("species"),
  id = taxon_id(93036)
))

(res &lt;- hierarchy(z, y, x))

res$taxa
res$ranklist

# null taxa
x &lt;- taxon(NULL)
(res &lt;- hierarchy(x, x, x))
## similar to hierarchy(), but `taxa` slot is not empty
</code></pre>

<hr>
<h2 id='highlight_taxon_ids'>Highlight taxon ID column</h2><span id='topic+highlight_taxon_ids'></span>

<h3>Description</h3>

<p>Changes the font of a taxon ID column in a table print out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight_taxon_ids(table_text, header_index, row_indexes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="highlight_taxon_ids_+3A_table_text">table_text</code></td>
<td>
<p>The print out of the table in a character vector, one element per line.</p>
</td></tr>
<tr><td><code id="highlight_taxon_ids_+3A_header_index">header_index</code></td>
<td>
<p>The row index that contains the table column names</p>
</td></tr>
<tr><td><code id="highlight_taxon_ids_+3A_row_indexes">row_indexes</code></td>
<td>
<p>The indexes of the rows to be formatted.</p>
</td></tr>
</table>

<hr>
<h2 id='hmp_otus'>A HMP subset</h2><span id='topic+hmp_otus'></span>

<h3>Description</h3>

<p>A subset of the Human Microbiome Project abundance matrix produced by QIIME.
It contains OTU ids, taxonomic lineages, and the read counts for 50 samples.
See <code><a href="#topic+hmp_samples">hmp_samples</a></code> for the matching dataset of sample information.
</p>


<h3>Format</h3>

<p>A 1,000 x 52 tibble.
</p>


<h3>Details</h3>

<p>The 50 samples were randomly selected such that there were 10 in each of 5
treatments: &quot;Saliva&quot;, &quot;Throat&quot;, &quot;Stool&quot;, &quot;Right_Antecubital_fossa&quot;,
&quot;Anterior_nares&quot;. For each treatment, there were 5 samples from men and 5
from women.
</p>


<h3>Source</h3>

<p>Subset from data available at https://www.hmpdacc.org/hmp/HMQCP/
</p>


<h3>See Also</h3>

<p>Other hmp_data: 
<code><a href="#topic+hmp_samples">hmp_samples</a></code>
</p>

<hr>
<h2 id='hmp_samples'>Sample information for HMP subset</h2><span id='topic+hmp_samples'></span>

<h3>Description</h3>

<p>The sample information for a subset of the Human Microbiome Project data. It
contains the sample ID, sex, and body site for each sample in the abundance
matrix stored in <code><a href="#topic+hmp_otus">hmp_otus</a></code>. The &quot;sample_id&quot; column corresponds
to the column names of <code><a href="#topic+hmp_otus">hmp_otus</a></code>.
</p>


<h3>Format</h3>

<p>A 50 x 3 tibble.
</p>


<h3>Details</h3>

<p>The 50 samples were randomly selected such that there were 10 in each of 5
treatments: &quot;Saliva&quot;, &quot;Throat&quot;, &quot;Stool&quot;, &quot;Right_Antecubital_fossa&quot;,
&quot;Anterior_nares&quot;. For each treatment, there were 5 samples from men and 5
from women. &quot;Right_Antecubital_fossa&quot; was renamed to &quot;Skin&quot; and
&quot;Anterior_nares&quot; to &quot;Nose&quot;.
</p>


<h3>Source</h3>

<p>Subset from data available at https://www.hmpdacc.org/hmp/HMQCP/
</p>


<h3>See Also</h3>

<p>Other hmp_data: 
<code><a href="#topic+hmp_otus">hmp_otus</a></code>
</p>

<hr>
<h2 id='id_classifications'>Get ID classifications of taxa</h2><span id='topic+id_classifications'></span>

<h3>Description</h3>

<p>Get classification strings of taxa in an object of type [taxonomy()] or [taxmap()]
composed of taxon IDs. Each classification is constructed by concatenating
the taxon ids of the given taxon and its supertaxa.
</p>
<pre>
obj$id_classifications(sep = ";")
id_classifications(obj, sep = ";")</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id_classifications_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()])</p>
</td></tr>
<tr><td><code id="id_classifications_+3A_sep">sep</code></td>
<td>
<p>('character' of length 1) The character(s) to place between
taxon IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'character'
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get classifications of IDs for each taxon
id_classifications(ex_taxmap)

# Use a different seperator
id_classifications(ex_taxmap, sep = '|')

</code></pre>

<hr>
<h2 id='init_taxmap_data'>Convert 'data' input for Taxamp</h2><span id='topic+init_taxmap_data'></span>

<h3>Description</h3>

<p>Make sure 'data' is in the right format and complain if it is not. Then, add
a 'taxon_id' column to data with the same length as the input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_taxmap_data(self, data, input_ids, assume_equal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_taxmap_data_+3A_self">self</code></td>
<td>
<p>The newly created [taxmap()] object</p>
</td></tr>
<tr><td><code id="init_taxmap_data_+3A_data">data</code></td>
<td>
<p>The 'data' variable passed to the 'Taxmap' constructor</p>
</td></tr>
<tr><td><code id="init_taxmap_data_+3A_input_ids">input_ids</code></td>
<td>
<p>The taxon IDs for the inputs that made the taxonomy</p>
</td></tr>
<tr><td><code id="init_taxmap_data_+3A_assume_equal">assume_equal</code></td>
<td>
<p>If 'TRUE', and a data set length is the same as the
'input_ids' length, then assume that 'input_ids' applies to the data set as
well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data' variable with the right format
</p>

<hr>
<h2 id='inter_circle_gap'>Finds the gap/overlap of circle coordinates</h2><span id='topic+inter_circle_gap'></span>

<h3>Description</h3>

<p>Given a set of x, y coordinates and corresponding radii return the gap between every possible 
combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_circle_gap(x, y, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inter_circle_gap_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code> of length 1) x coordinate of center</p>
</td></tr>
<tr><td><code id="inter_circle_gap_+3A_y">y</code></td>
<td>
<p>(<code>numeric</code> of length 1) y coordinate of center</p>
</td></tr>
<tr><td><code id="inter_circle_gap_+3A_r">r</code></td>
<td>
<p>(<code>numeric</code> of length 1) The diameter of the circle.</p>
</td></tr>
</table>

<hr>
<h2 id='internodes'>Get &quot;internode&quot; taxa</h2><span id='topic+internodes'></span>

<h3>Description</h3>

<p>Return the &quot;internode&quot; taxa for a [taxonomy()] or [taxmap()] object. An
internode is any taxon with a single immediate supertaxon and a single
immediate subtaxon. They can be removed from a tree without any loss of
information on the relative relationship between remaining taxa. Can also be
used to get the internodes of a subset of taxa.
</p>
<pre>
obj$internodes(subset = NULL, value = "taxon_indexes")
internodes(obj, subset = NULL, value = "taxon_indexes")</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internodes_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="internodes_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes used to subset the tree prior to
determining internodes. Default: All taxa in 'obj' will be used. Any variable
name that appears in [all_names()] can be used as if it was a vector on its
own. Note that internodes are determined after the filtering, so a given
taxon might be a internode on the unfiltered tree, but not a internode
on the filtered tree.</p>
</td></tr>
<tr><td><code id="internodes_+3A_value">value</code></td>
<td>
<p>What data to return. This is usually the name of column in a
table in 'obj$data'. Any result of [all_names()] can be used, but it
usually only makes sense to use data that corresponds to taxa 1:1, such as
[taxon_ranks()]. By default, taxon indexes are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'character'
</p>


<h3>See Also</h3>

<p>Other taxonomy indexing functions: 
<code><a href="#topic+branches">branches</a>()</code>,
<code><a href="#topic+leaves">leaves</a>()</code>,
<code><a href="#topic+roots">roots</a>()</code>,
<code><a href="#topic+stems">stems</a>()</code>,
<code><a href="#topic+subtaxa">subtaxa</a>()</code>,
<code><a href="#topic+supertaxa">supertaxa</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return indexes of branch taxa
internodes(ex_taxmap)

# Return indexes for a subset of taxa
internodes(ex_taxmap, subset = 2:17)
internodes(ex_taxmap, subset = n_obs &gt; 1)

# Return something besides taxon indexes
internodes(ex_taxmap, value = "taxon_names")

</code></pre>

<hr>
<h2 id='inverse'>Generate the inverse of a function</h2><span id='topic+inverse'></span>

<h3>Description</h3>

<p>http://stackoverflow.com/questions/10081479/solving-for-the-inverse-of-a-function-in-r
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse(f, interval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse_+3A_f">f</code></td>
<td>
<p>(<code>function</code> with one argument) A function to derive and inverse from</p>
</td></tr>
<tr><td><code id="inverse_+3A_interval">interval</code></td>
<td>
<p>(<code>character</code> of length 2) The range of the value the inverse function can return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>function</code>) Return the inverse of the function given
</p>

<hr>
<h2 id='is_ambiguous'>Find ambiguous taxon names</h2><span id='topic+is_ambiguous'></span>

<h3>Description</h3>

<p>Find taxa with ambiguous names, such as &quot;unknown&quot; or &quot;uncultured&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_ambiguous(
  taxon_names,
  unknown = TRUE,
  uncultured = TRUE,
  name_regex = ".",
  ignore_case = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_ambiguous_+3A_taxon_names">taxon_names</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="is_ambiguous_+3A_unknown">unknown</code></td>
<td>
<p>If <code>TRUE</code>, Remove taxa with names the suggest they are
placeholders for unknown taxa (e.g. &quot;unknown ...&quot;).</p>
</td></tr>
<tr><td><code id="is_ambiguous_+3A_uncultured">uncultured</code></td>
<td>
<p>If <code>TRUE</code>, Remove taxa with names the suggest they are
assigned to uncultured organisms (e.g. &quot;uncultured ...&quot;).</p>
</td></tr>
<tr><td><code id="is_ambiguous_+3A_name_regex">name_regex</code></td>
<td>
<p>The regex code to match a valid character in a taxon name.
For example, &quot;[a-z]&quot; would mean taxon names can only be lower case letters.</p>
</td></tr>
<tr><td><code id="is_ambiguous_+3A_ignore_case">ignore_case</code></td>
<td>
<p>If <code>TRUE</code>, dont consider the case of the text when
determining a match.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you encounter a taxon name that represents an ambiguous taxon that is not
filtered out by this function, let us know and we will add it.
</p>


<h3>Value</h3>

<p>TRUE/FALSE vector corresponding to <code>taxon_names</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_ambiguous(c("unknown", "uncultured", "homo sapiens", "kfdsjfdljsdf"))

</code></pre>

<hr>
<h2 id='is_branch'>Test if taxa are branches</h2><span id='topic+is_branch'></span>

<h3>Description</h3>

<p>Test if taxa are branches in a [taxonomy()] or [taxmap()] object. Branches
are taxa in the interior of the tree that are not [roots()], [stems()], or
[leaves()].
</p>
<pre>
obj$is_branch()
is_branch(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_branch_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'logical' of length equal to the number of taxa.
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test which taxon IDs correspond to branches
is_branch(ex_taxmap)

# Filter out branches
filter_taxa(ex_taxmap, ! is_branch)

</code></pre>

<hr>
<h2 id='is_internode'>Test if taxa are &quot;internodes&quot;</h2><span id='topic+is_internode'></span>

<h3>Description</h3>

<p>Test if taxa are &quot;internodes&quot; in a [taxonomy()] or [taxmap()] object.  An
internode is any taxon with a single immediate supertaxon and a single immediate
subtaxon. They can be removed from a tree without any loss of information on
the relative relationship between remaining taxa.
</p>
<pre>
obj$is_internode()
is_internode(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_internode_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'logical' of length equal to the number of taxa.
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test for which taxon IDs correspond to internodes
is_internode(ex_taxmap)

# Filter out internodes
filter_taxa(ex_taxmap, ! is_internode)

</code></pre>

<hr>
<h2 id='is_leaf'>Test if taxa are leaves</h2><span id='topic+is_leaf'></span>

<h3>Description</h3>

<p>Test if taxa are leaves in a [taxonomy()] or [taxmap()] object. Leaves are taxa
without subtaxa, typically species.
</p>
<pre>
obj$is_leaf()
is_leaf(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_leaf_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'logical' of length equal to the number of taxa.
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test which taxon IDs correspond to leaves
is_leaf(ex_taxmap)

# Filter out leaves
filter_taxa(ex_taxmap, ! is_leaf)

</code></pre>

<hr>
<h2 id='is_root'>Test if taxa are roots</h2><span id='topic+is_root'></span>

<h3>Description</h3>

<p>Test if taxa are roots in a [taxonomy()] or [taxmap()] object. Roots are taxa
without supertaxa, typically things like &quot;Bacteria&quot;, or &quot;Life&quot;.
</p>
<pre>
obj$is_root()
is_root(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_root_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'logical' of length equal to the number of taxa.
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test for which taxon IDs correspond to roots
is_root(ex_taxmap)

# Filter out roots
filter_taxa(ex_taxmap, ! is_root)

</code></pre>

<hr>
<h2 id='is_stem'>Test if taxa are stems</h2><span id='topic+is_stem'></span>

<h3>Description</h3>

<p>Test if taxa are stems in a [taxonomy()] or [taxmap()] object. Stems are taxa
from the [roots()] taxa to the first taxon with more than one subtaxon. These
can usually be filtered out of the taxonomy without removing any information
on how the remaining taxa are related.
</p>
<pre>
obj$is_stem()
is_stem(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_stem_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'logical' of length equal to the number of taxa.
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test which taxon IDs correspond to stems
is_stem(ex_taxmap)

# Filter out stems
filter_taxa(ex_taxmap, ! is_stem)

</code></pre>

<hr>
<h2 id='label_bounds'>Bounding box coords for labels</h2><span id='topic+label_bounds'></span>

<h3>Description</h3>

<p>Given a position, size, rotation, and justification of a label, calculate the bounding box coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label_bounds(label, x, y, height, rotation, just)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="label_bounds_+3A_x">x</code></td>
<td>
<p>Horizontal position of center of text grob</p>
</td></tr>
<tr><td><code id="label_bounds_+3A_y">y</code></td>
<td>
<p>Vertical position of center of text grob</p>
</td></tr>
<tr><td><code id="label_bounds_+3A_height">height</code></td>
<td>
<p>Height of text grob</p>
</td></tr>
<tr><td><code id="label_bounds_+3A_rotation">rotation</code></td>
<td>
<p>Rotation in radians</p>
</td></tr>
<tr><td><code id="label_bounds_+3A_just">just</code></td>
<td>
<p>Justification. e.g. &quot;left-top&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='layout_functions'>Layout functions</h2><span id='topic+layout_functions'></span>

<h3>Description</h3>

<p>Functions used to determine graph layout.
Calling the function with no parameters returns available function names.
Calling the function with only the name of a function returns that function.
Supplying a name and a <code><a href="igraph.html#topic+graph">graph</a></code> object to run the layout function on the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_functions(
  name = NULL,
  graph = NULL,
  intitial_coords = NULL,
  effort = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_functions_+3A_name">name</code></td>
<td>
<p>(<code>character</code> of length 1 OR NULL) name of algorithm. Leave <code>NULL</code> to 
see all options.</p>
</td></tr>
<tr><td><code id="layout_functions_+3A_graph">graph</code></td>
<td>
<p>(<code>igraph</code>) The graph to generate the layout for.</p>
</td></tr>
<tr><td><code id="layout_functions_+3A_intitial_coords">intitial_coords</code></td>
<td>
<p>(<code>matrix</code>) Initial node layout to base new layout off of.</p>
</td></tr>
<tr><td><code id="layout_functions_+3A_effort">effort</code></td>
<td>
<p>(<code>numeric</code> of length 1) The amount of effort to put into layouts. Typically
determines the the number of iterations.</p>
</td></tr>
<tr><td><code id="layout_functions_+3A_...">...</code></td>
<td>
<p>(other arguments) Passed to igraph layout function used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name available functions, a layout functions,
or a two-column matrix depending on how arguments are provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List available function names:
layout_functions()

# Execute layout function on graph:
layout_functions("davidson-harel", igraph::make_ring(5))

</code></pre>

<hr>
<h2 id='leaves'>Get leaf taxa</h2><span id='topic+leaves'></span>

<h3>Description</h3>

<p>Return the leaf taxa for a [taxonomy()] or [taxmap()] object. Leaf taxa are taxa
with no subtaxa.
</p>
<pre>
obj$leaves(subset = NULL, recursive = TRUE, simplify = FALSE, value = "taxon_indexes")
leaves(obj, subset = NULL, recursive = TRUE, simplify = FALSE, value = "taxon_indexes")</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leaves_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="leaves_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to find leaves for.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="leaves_+3A_recursive">recursive</code></td>
<td>
<p>('logical' or 'numeric') If 'FALSE', only return the
leaves if they occur one rank below the target taxa. If 'TRUE', return all of the
leaves for each taxon. Positive numbers indicate the number of
recursions (i.e. number of ranks below the target taxon to return). '1' is
equivalent to 'FALSE'. Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="leaves_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', then combine all the results into a
single vector of unique values.</p>
</td></tr>
<tr><td><code id="leaves_+3A_value">value</code></td>
<td>
<p>What data to return. This is usually the name of column in a
table in 'obj$data'. Any result of 'all_names(obj)' can be used, but it
usually only makes sense to data that corresponds to taxa 1:1, such as
[taxon_ranks()]. By default, taxon indexes are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'character'
</p>


<h3>See Also</h3>

<p>Other taxonomy indexing functions: 
<code><a href="#topic+branches">branches</a>()</code>,
<code><a href="#topic+internodes">internodes</a>()</code>,
<code><a href="#topic+roots">roots</a>()</code>,
<code><a href="#topic+stems">stems</a>()</code>,
<code><a href="#topic+subtaxa">subtaxa</a>()</code>,
<code><a href="#topic+supertaxa">supertaxa</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return indexes of leaf taxa
leaves(ex_taxmap)

# Return indexes for a subset of taxa
leaves(ex_taxmap, subset = 2:17)
leaves(ex_taxmap, subset = taxon_names == "Plantae")

# Return something besides taxon indexes
leaves(ex_taxmap, value = "taxon_names")
leaves(ex_taxmap, subset = taxon_ranks == "genus", value = "taxon_names")

# Return a vector of all unique values
leaves(ex_taxmap, value = "taxon_names", simplify = TRUE)

# Only return leaves for their direct supertaxa
leaves(ex_taxmap, value = "taxon_names", recursive = FALSE)

</code></pre>

<hr>
<h2 id='leaves_apply'>Apply function to leaves of each taxon</h2><span id='topic+leaves_apply'></span>

<h3>Description</h3>

<p>Apply a function to the leaves of each taxon. This is similar
to using [leaves()] with [lapply()] or [sapply()].
</p>
<pre>
obj$leaves_apply(func, subset = NULL, recursive = TRUE,
  simplify = FALSE, value = "taxon_indexes", ...)
leaves_apply(obj, func, subset = NULL, recursive = TRUE,
  simplify = FALSE, value = "taxon_indexes", ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leaves_apply_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="leaves_apply_+3A_func">func</code></td>
<td>
<p>('function') The function to apply.</p>
</td></tr>
<tr><td><code id="leaves_apply_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to use.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="leaves_apply_+3A_recursive">recursive</code></td>
<td>
<p>('logical' or 'numeric') If 'FALSE', only return the
leaves if they occur one rank below the target taxa. If 'TRUE', return all of the
leaves for each taxon. Positive numbers indicate the number of
recursions (i.e. number of ranks below the target taxon to return). '1' is
equivalent to 'FALSE'. Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="leaves_apply_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', then combine all the results into a
single vector of unique values.</p>
</td></tr>
<tr><td><code id="leaves_apply_+3A_value">value</code></td>
<td>
<p>What data to give to the function. Any result of
'all_names(obj)' can be used, but it usually only makes sense to use data
that has an associated taxon id.</p>
</td></tr>
<tr><td><code id="leaves_apply_+3A_...">...</code></td>
<td>
<p>Extra arguments are passed to the function 'func'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Count number of leaves under each taxon or its subtaxa
leaves_apply(ex_taxmap, length)

# Count number of leaves under each taxon
leaves_apply(ex_taxmap, length, recursive = FALSE)

# Converting output of leaves to upper case
leaves_apply(ex_taxmap, value = "taxon_names", toupper)

# Passing arguments to the function
leaves_apply(ex_taxmap, value = "taxon_names", paste0, collapse = ", ")

</code></pre>

<hr>
<h2 id='length_of_thing'>Check length of thing</h2><span id='topic+length_of_thing'></span>

<h3>Description</h3>

<p>Check the length of an object, be it list, vector, or table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>length_of_thing(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="length_of_thing_+3A_obj">obj</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code> of length 1.
</p>

<hr>
<h2 id='limited_print'>Print a subset of a character vector</h2><span id='topic+limited_print'></span>

<h3>Description</h3>

<p>Prints the start and end values for a character vector. The number of values
printed depend on the width of the screen by default.
</p>
<p>Prints the start and end values for a character vector. The number of values
printed depend on the width of the screen by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limited_print(
  chars,
  prefix = "",
  sep = ", ",
  mid = " ... ",
  trunc_char = "[truncated]",
  max_chars = getOption("width") - nchar(prefix) - 5,
  type = "message"
)

limited_print(
  chars,
  prefix = "",
  sep = ", ",
  mid = " ... ",
  trunc_char = "[truncated]",
  max_chars = getOption("width") - nchar(prefix) - 5,
  type = "message"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="limited_print_+3A_chars">chars</code></td>
<td>
<p>('character') What to print.</p>
</td></tr>
<tr><td><code id="limited_print_+3A_prefix">prefix</code></td>
<td>
<p>('character' of length 1) What to print before
'chars', on the same line.</p>
</td></tr>
<tr><td><code id="limited_print_+3A_sep">sep</code></td>
<td>
<p>What to put between consecutive values</p>
</td></tr>
<tr><td><code id="limited_print_+3A_mid">mid</code></td>
<td>
<p>What is used to indicate omitted values</p>
</td></tr>
<tr><td><code id="limited_print_+3A_trunc_char">trunc_char</code></td>
<td>
<p>What is appended onto truncated values</p>
</td></tr>
<tr><td><code id="limited_print_+3A_max_chars">max_chars</code></td>
<td>
<p>('numeric' of length 1) The maximum number of
characters to print.</p>
</td></tr>
<tr><td><code id="limited_print_+3A_type">type</code></td>
<td>
<p>('&quot;error&quot;', '&quot;warning&quot;', '&quot;message&quot;', '&quot;cat&quot;', '&quot;print&quot;', '&quot;silent&quot;', '&quot;plain&quot;')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'NULL'
</p>
<p>'NULL'
</p>

<hr>
<h2 id='line_coords'>Makes coordinates for a line</h2><span id='topic+line_coords'></span>

<h3>Description</h3>

<p>Generates an n x 2 matrix containing x and y coordinates between 1 and 0 for the points of a 
line with a specified width in cartesian coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_coords(x1, y1, x2, y2, width)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="line_coords_+3A_x1">x1</code></td>
<td>
<p>(<code>numeric</code> of length 1) x coordinate of the center of one end</p>
</td></tr>
<tr><td><code id="line_coords_+3A_y1">y1</code></td>
<td>
<p>(<code>numeric</code> of length 1) y coordinate of the center of one end</p>
</td></tr>
<tr><td><code id="line_coords_+3A_x2">x2</code></td>
<td>
<p>(<code>numeric</code> of length 1) x coordinate of the center of the other end</p>
</td></tr>
<tr><td><code id="line_coords_+3A_y2">y2</code></td>
<td>
<p>(<code>numeric</code> of length 1) y coordinate of the center of the other end</p>
</td></tr>
<tr><td><code id="line_coords_+3A_width">width</code></td>
<td>
<p>(<code>numeric</code> of length 1) The width of the line.</p>
</td></tr>
</table>

<hr>
<h2 id='look_for_na'>Look for NAs in parameters</h2><span id='topic+look_for_na'></span>

<h3>Description</h3>

<p>Look for NAs in parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>look_for_na(taxon_ids, args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="look_for_na_+3A_args">args</code></td>
<td>
<p>(<code>character</code>) The names of arguments to verify.</p>
</td></tr>
</table>

<hr>
<h2 id='lookup_tax_data'>Convert one or more data sets to taxmap</h2><span id='topic+lookup_tax_data'></span>

<h3>Description</h3>

<p>Looks up taxonomic data from NCBI sequence IDs, taxon IDs, or taxon names
that are present in a table, list, or vector. Also can incorporate additional
associated datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup_tax_data(
  tax_data,
  type,
  column = 1,
  datasets = list(),
  mappings = c(),
  database = "ncbi",
  include_tax_data = TRUE,
  use_database_ids = TRUE,
  ask = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lookup_tax_data_+3A_tax_data">tax_data</code></td>
<td>
<p>A table, list, or vector that contain sequence IDs, taxon
IDs, or taxon names.
* tables: The 'column' option must be used to specify which column
contains the sequence IDs, taxon IDs, or taxon names.
* lists: There must be only one item per list entry unless the 'column'
option is used to specify what item to use in each list entry.
* vectors: simply a vector of sequence IDs, taxon IDs, or taxon names.</p>
</td></tr>
<tr><td><code id="lookup_tax_data_+3A_type">type</code></td>
<td>
<p>What type of information can be used to look up the
classifications. Takes one of the following values:
* '&quot;seq_id&quot;': A database sequence ID with an associated classification
(e.g. NCBI accession numbers).
* '&quot;taxon_id&quot;': A reference database taxon ID (e.g. a NCBI taxon ID)
* '&quot;taxon_name&quot;': A single taxon name (e.g. &quot;Homo sapiens&quot; or &quot;Primates&quot;)
* '&quot;fuzzy_name&quot;': A single taxon name, but check for misspellings first.
Only use if you think there are misspellings. Using '&quot;taxon_name&quot;' is
faster.</p>
</td></tr>
<tr><td><code id="lookup_tax_data_+3A_column">column</code></td>
<td>
<p>('character' or 'integer') The name or index of the column that
contains information used to lookup classifications. This only applies when
a table or list is supplied to 'tax_data'.</p>
</td></tr>
<tr><td><code id="lookup_tax_data_+3A_datasets">datasets</code></td>
<td>
<p>Additional lists/vectors/tables that should be included in
the resulting 'taxmap' object. The 'mappings' option is use to specify how
these data sets relate to the 'tax_data' and, by inference, what taxa apply
to each item.</p>
</td></tr>
<tr><td><code id="lookup_tax_data_+3A_mappings">mappings</code></td>
<td>
<p>(named 'character') This defines how the taxonomic
information in 'tax_data' applies to data in 'datasets'. This option
should have the same number of inputs as 'datasets', with values
corresponding to each dataset. The names of the character vector specify
what information in 'tax_data' is shared with info in each 'dataset', which
is specified by the corresponding values of the character vector. If there
are no shared variables, you can add 'NA' as a placeholder, but you could
just leave that data out since it is not benefiting from being in the
taxmap object. The names/values can be one of the following:
* For tables, the names of columns can be used.
* '&quot;{{index}}&quot;' : This means to use the index of rows/items
* '&quot;{{name}}&quot;'  : This means to use row/item names.
* '&quot;{{value}}&quot;' : This means to use the values in vectors or lists. Lists
will be converted to vectors using [unlist()].</p>
</td></tr>
<tr><td><code id="lookup_tax_data_+3A_database">database</code></td>
<td>
<p>('character') The name of a database to use to look up
classifications. Options include &quot;ncbi&quot;, &quot;itis&quot;, &quot;eol&quot;, &quot;col&quot;, &quot;tropicos&quot;,
and &quot;nbn&quot;.</p>
</td></tr>
<tr><td><code id="lookup_tax_data_+3A_include_tax_data">include_tax_data</code></td>
<td>
<p>('TRUE'/'FALSE') Whether or not to include 'tax_data'
as a dataset, like those in 'datasets'.</p>
</td></tr>
<tr><td><code id="lookup_tax_data_+3A_use_database_ids">use_database_ids</code></td>
<td>
<p>('TRUE'/'FALSE') Whether or not to use downloaded
database taxon ids instead of arbitrary, automatically-generated taxon ids.</p>
</td></tr>
<tr><td><code id="lookup_tax_data_+3A_ask">ask</code></td>
<td>
<p>('TRUE'/'FALSE') Whether or not to prompt the user for input.
Currently, this would only happen when looking up the taxonomy of a taxon
name with multiple matches. If 'FALSE', taxa with multiple hits are treated
as if they do not exist in the database. This might change in the future if
we can find an elegant way of handling this.</p>
</td></tr>
</table>


<h3>Failed Downloads</h3>

<p>If you have invalid inputs or a download fails for
another reason, then there will be a &quot;unknown&quot; taxon ID as a placeholder
and failed inputs will be assigned to this ID. You can remove these using
[filter_taxa()] like so: 'filter_taxa(result, taxon_ids != &quot;unknown&quot;)'. Add
'drop_obs = FALSE' if you want the input data, but want to remove the
taxon.
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Look up taxon names in vector from NCBI
  lookup_tax_data(c("homo sapiens", "felis catus", "Solanaceae"),
                  type = "taxon_name")

  # Look up taxon names in list from NCBI
  lookup_tax_data(list("homo sapiens", "felis catus", "Solanaceae"),
                  type = "taxon_name")

  # Look up taxon names in table from NCBI
  my_table &lt;- data.frame(name = c("homo sapiens", "felis catus"),
                         decency = c("meh", "good"))
  lookup_tax_data(my_table, type = "taxon_name", column = "name")

  # Look up taxon names from a different database
  lookup_tax_data(c("homo sapiens", "felis catus", "Solanaceae"),
                  type = "taxon_name", database = "ITIS")

  # Prevent asking questions for ambiguous taxon names
  lookup_tax_data(c("homo sapiens", "felis catus", "Solanaceae"),
                  type = "taxon_name", database = "ITIS", ask = FALSE)

  # Look up taxon IDs from NCBI
  lookup_tax_data(c("9689", "9694", "9643"), type = "taxon_id")

  # Look up sequence IDs from NCBI
  lookup_tax_data(c("AB548412", "FJ358423", "DQ334818"),
                  type = "seq_id")

  # Make up new taxon IDs instead of using the downloaded ones
  lookup_tax_data(c("AB548412", "FJ358423", "DQ334818"),
                  type = "seq_id", use_database_ids = FALSE)


  # --- Parsing multiple datasets at once (advanced) ---
  # The rest is one example for how to classify multiple datasets at once.

  # Make example data with taxonomic classifications
  species_data &lt;- data.frame(tax = c("Mammalia;Carnivora;Felidae",
                                     "Mammalia;Carnivora;Felidae",
                                     "Mammalia;Carnivora;Ursidae"),
                             species = c("Panthera leo",
                                         "Panthera tigris",
                                         "Ursus americanus"),
                             species_id = c("A", "B", "C"))

  # Make example data associated with the taxonomic data
  # Note how this does not contain classifications, but
  # does have a varaible in common with "species_data" ("id" = "species_id")
  abundance &lt;- data.frame(id = c("A", "B", "C", "A", "B", "C"),
                          sample_id = c(1, 1, 1, 2, 2, 2),
                          counts = c(23, 4, 3, 34, 5, 13))

  # Make another related data set named by species id
  common_names &lt;- c(A = "Lion", B = "Tiger", C = "Bear", "Oh my!")

  # Make another related data set with no names
  foods &lt;- list(c("ungulates", "boar"),
                c("ungulates", "boar"),
                c("salmon", "fruit", "nuts"))

  # Make a taxmap object with these three datasets
  x = lookup_tax_data(species_data,
                      type = "taxon_name",
                      datasets = list(counts = abundance,
                                      my_names = common_names,
                                      foods = foods),
                      mappings = c("species_id" = "id",
                                   "species_id" = "{{name}}",
                                   "{{index}}" = "{{index}}"),
                      column = "species")

  # Note how all the datasets have taxon ids now
  x$data

  # This allows for complex mappings between variables that other functions use
  map_data(x, my_names, foods)
  map_data(x, counts, my_names)

</code></pre>

<hr>
<h2 id='make_dada2_asv_table'>Make a imitation of the dada2 ASV abundance matrix</h2><span id='topic+make_dada2_asv_table'></span>

<h3>Description</h3>

<p>Attempts to save the abundance matrix stored as a table in a taxmap object in the
dada2 ASV abundance matrix format. If the taxmap object was created using
<code><a href="#topic+parse_dada2">parse_dada2</a></code>, then it should be able to replicate the format
exactly with the default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dada2_asv_table(obj, asv_table = "asv_table", asv_id = "asv_id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dada2_asv_table_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="make_dada2_asv_table_+3A_asv_table">asv_table</code></td>
<td>
<p>The name of the abundance matrix in the taxmap object to use.</p>
</td></tr>
<tr><td><code id="make_dada2_asv_table_+3A_asv_id">asv_id</code></td>
<td>
<p>The name of the column in <code>asv_table</code> with unique ASV ids or sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>matrix</code> with rows as samples and columns as ASVs
</p>


<h3>See Also</h3>

<p>Other writers: 
<code><a href="#topic+make_dada2_tax_table">make_dada2_tax_table</a>()</code>,
<code><a href="#topic+write_greengenes">write_greengenes</a>()</code>,
<code><a href="#topic+write_mothur_taxonomy">write_mothur_taxonomy</a>()</code>,
<code><a href="#topic+write_rdp">write_rdp</a>()</code>,
<code><a href="#topic+write_silva_fasta">write_silva_fasta</a>()</code>,
<code><a href="#topic+write_unite_general">write_unite_general</a>()</code>
</p>

<hr>
<h2 id='make_dada2_tax_table'>Make a imitation of the dada2 taxonomy matrix</h2><span id='topic+make_dada2_tax_table'></span>

<h3>Description</h3>

<p>Attempts to save the taxonomy information assocaited with an abundance matrix in a taxmap object
in the dada2 taxonomy matrix format. If the taxmap object was created using
<code><a href="#topic+parse_dada2">parse_dada2</a></code>, then it should be able to replicate the format exactly with the
default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dada2_tax_table(obj, asv_table = "asv_table", asv_id = "asv_id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dada2_tax_table_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="make_dada2_tax_table_+3A_asv_table">asv_table</code></td>
<td>
<p>The name of the abundance matrix in the taxmap object to use.</p>
</td></tr>
<tr><td><code id="make_dada2_tax_table_+3A_asv_id">asv_id</code></td>
<td>
<p>The name of the column in <code>asv_table</code> with unique ASV ids or sequences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character <code>matrix</code> with rows as ASVs and columns as taxonomic ranks.
</p>


<h3>See Also</h3>

<p>Other writers: 
<code><a href="#topic+make_dada2_asv_table">make_dada2_asv_table</a>()</code>,
<code><a href="#topic+write_greengenes">write_greengenes</a>()</code>,
<code><a href="#topic+write_mothur_taxonomy">write_mothur_taxonomy</a>()</code>,
<code><a href="#topic+write_rdp">write_rdp</a>()</code>,
<code><a href="#topic+write_silva_fasta">write_silva_fasta</a>()</code>,
<code><a href="#topic+write_unite_general">write_unite_general</a>()</code>
</p>

<hr>
<h2 id='make_fasta_with_u_replaced'>Make a temporary file U's replaced with T</h2><span id='topic+make_fasta_with_u_replaced'></span>

<h3>Description</h3>

<p>Make a temporary fasta file U's replaced with T without reading in whole file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_fasta_with_u_replaced(file_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_fasta_with_u_replaced_+3A_file_path">file_path</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>A path to a temporary file.
</p>

<hr>
<h2 id='make_plot_legend'>Make color/size legend</h2><span id='topic+make_plot_legend'></span>

<h3>Description</h3>

<p>Make color/size legend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_plot_legend(
  x,
  y,
  length,
  width_range,
  width_trans_range = NULL,
  width_stat_range,
  group_prefix,
  tick_size = 0.008,
  width_stat_trans = function(x) {
     x
 },
  width_title = "Size",
  width_sig_fig = 3,
  color_range,
  color_trans_range = NULL,
  color_stat_range,
  color_stat_trans = function(x) {
     x
 },
  color_title = "Color",
  color_sig_fig = 3,
  divisions = 100,
  label_count = 7,
  title = NULL,
  label_size = 0.09,
  title_size = 0.11,
  axis_label_size = 0.11,
  color_axis_label = NULL,
  size_axis_label = NULL,
  hide_size = FALSE,
  hide_color = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_plot_legend_+3A_x">x</code></td>
<td>
<p>bottom left</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_y">y</code></td>
<td>
<p>bottom left</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_length">length</code></td>
<td>
<p>(<code>numeric</code> of length 1) the length of the scale bar</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_width_range">width_range</code></td>
<td>
<p>(<code>numeric</code> of length 1 or 2) the width of the scale bar or the range</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_width_stat_range">width_stat_range</code></td>
<td>
<p>(<code>numeric</code> of length 1 or 2) The stat range to display in the size labels</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_group_prefix">group_prefix</code></td>
<td>
<p>(<code>character</code> of length 1) The prefix of the group field in the shape data returned</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_tick_size">tick_size</code></td>
<td>
<p>(<code>numeric</code> of length 1) the thickness of tick marks</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_width_stat_trans">width_stat_trans</code></td>
<td>
<p>(<code>function</code>) The transformation used to convert the statistic to size</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_width_title">width_title</code></td>
<td>
<p>(<code>character</code> of length 1) The title of the size labels.</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_width_sig_fig">width_sig_fig</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of significant figures to use in size labels.</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_color_range">color_range</code></td>
<td>
<p>(<code>character</code>) One ore more hex codes constituting a color scale.</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_color_stat_range">color_stat_range</code></td>
<td>
<p>(<code>numeric</code> of length 1 or 2) The stat range to display in the color labels</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_color_stat_trans">color_stat_trans</code></td>
<td>
<p>(<code>function</code>) The transformation used to convert the statistic to size</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_color_title">color_title</code></td>
<td>
<p>(<code>character</code> of length 1) The title of the color labels.</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_color_sig_fig">color_sig_fig</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of significant figures to use in color labels.</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_divisions">divisions</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of colors to display.</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_label_count">label_count</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of labels.</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_title">title</code></td>
<td>
<p>(<code>character</code> of length 1) The title of the legend</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_axis_label_size">axis_label_size</code></td>
<td>
<p>(<code>numeric</code> of length 1)</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_color_axis_label">color_axis_label</code></td>
<td>
<p>(<code>character</code> of length 1) The label for the color axis</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_size_axis_label">size_axis_label</code></td>
<td>
<p>(<code>character</code> of length 1) The label for the size axis</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_hide_size">hide_size</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code> hide size axis</p>
</td></tr>
<tr><td><code id="make_plot_legend_+3A_hide_color">hide_color</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code> hide color axis</p>
</td></tr>
</table>

<hr>
<h2 id='map_data'>Create a mapping between two variables</h2><span id='topic+map_data'></span>

<h3>Description</h3>

<p>Creates a named vector that maps the values of two variables associated with
taxa in a [taxonomy()] or [taxmap()] object. Both values must be named by
taxon ids.
</p>
<pre>
obj$map_data(from, to, warn = TRUE)
map_data(obj, from, to, warn = TRUE)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_data_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
<tr><td><code id="map_data_+3A_from">from</code></td>
<td>
<p>The value used to name the output. There will be one output value
for each value in 'from'. Any variable that appears in [all_names()] can be
used as if it was a variable on its own.</p>
</td></tr>
<tr><td><code id="map_data_+3A_to">to</code></td>
<td>
<p>The value returned in the output. Any variable that appears in
[all_names()] can be used as if it was a variable on its own.</p>
</td></tr>
<tr><td><code id="map_data_+3A_warn">warn</code></td>
<td>
<p>If 'TRUE', issue a warning if there are multiple unique values of
'to' for each value of 'from'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 'to' values named by values in 'from'.
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Mapping between two variables in `all_names(ex_taxmap)`
map_data(ex_taxmap, from = taxon_names, to = n_legs &gt; 0)

# Mapping with external variables
x = c("d" = "looks like a cat", "h" = "big scary cats",
      "i" = "smaller cats", "m" = "might eat you", "n" = "Meow! (Feed me!)")
map_data(ex_taxmap, from = taxon_names, to = x)

</code></pre>

<hr>
<h2 id='map_data_'>Create a mapping without NSE</h2><span id='topic+map_data_'></span>

<h3>Description</h3>

<p>Creates a named vector that maps the values of two variables associated with
taxa in a [taxonomy()] or [taxmap()] object without using Non-Standard
Evaluation (NSE). Both values must be named by taxon ids. This is the same as
[map_data()] without NSE and can be useful in some odd cases where NSE fails
to work as expected.
</p>
<pre>
obj$map_data(from, to)
map_data(obj, from, to)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_data__+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
<tr><td><code id="map_data__+3A_from">from</code></td>
<td>
<p>The value used to name the output. There will be one output value
for each value in 'from'.</p>
</td></tr>
<tr><td><code id="map_data__+3A_to">to</code></td>
<td>
<p>The value returned in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 'to' values named by values in 'from'.
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c("d" = "looks like a cat", "h" = "big scary cats",
      "i" = "smaller cats", "m" = "might eat you", "n" = "Meow! (Feed me!)")
map_data_(ex_taxmap, from = ex_taxmap$taxon_names(), to = x)

</code></pre>

<hr>
<h2 id='map_unique'>Run a function on unique values of a iterable</h2><span id='topic+map_unique'></span>

<h3>Description</h3>

<p>Runs a function on unique values of a list/vector and then reformats the
output so there is a one-to-one relationship with the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_unique(input, func, ...)

map_unique(input, func, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_unique_+3A_input">input</code></td>
<td>
<p>What to pass to <code>func</code></p>
</td></tr>
<tr><td><code id="map_unique_+3A_func">func</code></td>
<td>
<p>(<code>function</code>)</p>
</td></tr>
<tr><td><code id="map_unique_+3A_...">...</code></td>
<td>
<p>passed to <code>func</code></p>
</td></tr>
</table>

<hr>
<h2 id='matches'>dplyr select_helpers</h2><span id='topic+matches'></span>

<h3>Description</h3>

<p>dplyr select_helpers
</p>
<p>dplyr select_helpers
</p>

<hr>
<h2 id='metacoder'>Metacoder</h2><span id='topic+metacoder'></span>

<h3>Description</h3>

<p>A package for planning and analysis of amplicon metagenomics research projects.
</p>


<h3>Details</h3>

<p>The goal of the <code>metacoder</code> package is to provide a set of tools for:
</p>

<ul>
<li><p> Standardized parsing of taxonomic information from diverse resources.
</p>
</li>
<li><p> Visualization of statistics distributed over taxonomic classifications.
</p>
</li>
<li><p> Evaluating potential metabarcoding primers for taxonomic specificity.
</p>
</li>
<li><p> Providing flexible functions for analyzing taxonomic and abundance data.
</p>
</li></ul>

<p>To accomplish these goals, <code>metacoder</code> leverages resources from other R packages, interfaces with
external programs, and provides novel functions where needed to allow for entire analyses within R.
</p>


<h3>Documentation</h3>

<p>The full documentation can be found online at <a href="https://grunwaldlab.github.io/metacoder_documentation/">https://grunwaldlab.github.io/metacoder_documentation/</a>.
</p>
<p>There is also a short vignette included for offline use that can be accessed  by the following code:
</p>
<p><code>browseVignettes(package = "metacoder")</code>
</p>
<p><strong>Plotting:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+heat_tree">heat_tree</a></code>
</p>
</li>
<li> <p><code><a href="#topic+heat_tree_matrix">heat_tree_matrix</a></code>
</p>
</li></ul>

<p><strong>In silico PCR:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+primersearch">primersearch</a></code>
</p>
</li></ul>

<p><strong>Analysis:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a></code>
</p>
</li>
<li> <p><code><a href="#topic+calc_obs_props">calc_obs_props</a></code>
</p>
</li>
<li> <p><code><a href="#topic+rarefy_obs">rarefy_obs</a></code>
</p>
</li>
<li> <p><code><a href="#topic+compare_groups">compare_groups</a></code>
</p>
</li>
<li> <p><code><a href="#topic+zero_low_counts">zero_low_counts</a></code>
</p>
</li>
<li> <p><code><a href="#topic+calc_n_samples">calc_n_samples</a></code>
</p>
</li>
<li> <p><code><a href="#topic+filter_ambiguous_taxa">filter_ambiguous_taxa</a></code>
</p>
</li></ul>

<p><strong>Parsers:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+parse_greengenes">parse_greengenes</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_newick">parse_newick</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_phyloseq">parse_phyloseq</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_phylo">parse_phylo</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_rdp">parse_rdp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a></code>
</p>
</li>
<li> <p><code><a href="#topic+parse_unite_general">parse_unite_general</a></code>
</p>
</li></ul>

<p><strong>Writers:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+write_greengenes">write_greengenes</a></code>
</p>
</li>
<li> <p><code><a href="#topic+write_mothur_taxonomy">write_mothur_taxonomy</a></code>
</p>
</li>
<li> <p><code><a href="#topic+write_rdp">write_rdp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+write_silva_fasta">write_silva_fasta</a></code>
</p>
</li>
<li> <p><code><a href="#topic+write_unite_general">write_unite_general</a></code>
</p>
</li></ul>

<p><strong>Database querying:</strong>
</p>

<ul>
<li> <p><code><a href="#topic+ncbi_taxon_sample">ncbi_taxon_sample</a></code>
</p>
</li></ul>



<h3>Main classes</h3>

<p>These are the classes users would typically interact with:
</p>
<p>* [taxon]: A class used to define a single taxon. Many other classes in the
'taxa&ldquo; package include one or more objects of this class.
* : Stores one or more [taxon] objects. This is just a thin wrapper
for a list of [taxon] objects.
* [hierarchy]: A class containing an ordered list of [taxon] objects that
represent a hierarchical classification.
* [hierarchies]: A list of taxonomic classifications.  This is just a thin wrapper
for a list of [hierarchy] objects.
* [taxonomy]: A taxonomy composed of [taxon] objects organized in a tree
structure. This differs from the [hierarchies] class in how the [taxon]
objects are stored. Unlike a [hierarchies] object, each unique taxon is
stored only once and the relationships between taxa are stored in an
edgelist.
* [taxmap]: A class designed to store a taxonomy and associated
user-defined data. This class builds on the [taxonomy] class. User defined
data can be stored in the list 'obj$data', where 'obj' is a taxmap
object. Any number of user-defined lists, vectors, or tables mapped
to taxa can be manipulated in a cohesive way such that relationships
between taxa and data are preserved.
</p>


<h3>Minor classes</h3>

<p>These classes are mostly components for the larger classes above and would
not typically be used on their own.
</p>
<p>* [taxon_database]: Used to store information about taxonomy databases.
* [taxon_id]: Used to store taxon IDs, either arbitrary or from a
particular taxonomy database.
* [taxon_name]: Used to store taxon names, either arbitrary or from a
particular taxonomy database.
* [taxon_rank]: Used to store taxon ranks (e.g. species, family), either
arbitrary or from a particular taxonomy database.
</p>


<h3>Major manipulation functions</h3>

<p>These are some of the more important functions used to filter data in classes
that store multiple taxa, like [hierarchies], [taxmap], and [taxonomy].
</p>
<p>* [filter_taxa]: Filter taxa in a [taxonomy] or [taxmap] object with a
series of conditions. Relationships between remaining taxa and user-defined
data are preserved (There are many options controlling this).
* [filter_obs]: Filter user-defined data [taxmap] object with a series of
conditions. Relationships between remaining taxa and user-defined data are
preserved (There are many options controlling this);
* [sample_n_taxa]: Randomly sample taxa. Has same abilities as
[filter_taxa].
* [sample_n_obs]: Randomly sample observations. Has same abilities as
[filter_obs].
* [mutate_obs]: Add datasets or columns to datasets in the 'data' list of
[taxmap] objects.
* [pick]: Pick out specific taxa, while others are dropped in [hierarchy]
and [hierarchies] objects.
* [pop]: Pop out taxa (drop them) in [hierarchy] and [hierarchies] objects.
* [span]: Select a range of taxa, either by two names, or relational
operators in [hierarchy] and [hierarchies] objects.
</p>


<h3>Mapping functions</h3>

<p>There are lots of functions for getting information for each taxon.
</p>
<p>* [subtaxa]: Return data for the subtaxa of each taxon in an [taxonomy] or
[taxmap] object.
* [supertaxa]: Return data for the supertaxa of each taxon in an [taxonomy]
or [taxmap] object.
* [roots]: Return data for the roots of each taxon in an [taxonomy] or
[taxmap] object.
* [leaves]: Return data for the leaves of each taxon in an [taxonomy] or
[taxmap] object.
* [obs]: Return user-specific data for each taxon and all of its subtaxa in
an [taxonomy] or [taxmap] object.
</p>


<h3>The kind of classes used</h3>

<p>Note, this is mostly of interest to developers and advanced users.
</p>
<p>The classes in the 'taxa' package are mostly
[R6](https://adv-r.hadley.nz/r6.html) classes ([R6Class]). A few of the
simpler ones ( and [hierarchies]) are
[S3](https://adv-r.hadley.nz/s3.html) instead. R6 classes are different than
most R objects because they are
[mutable](https://en.wikipedia.org/wiki/Immutable_object) (e.g. A function
can change its input without returning it). In this, they are more similar
to class systems in
[object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming)
languages like python. As in other object-oriented class systems, functions
are thought to &quot;belong&quot; to classes (i.e. the data), rather than functions
existing independently of the data. For example, the function 'print' in R
exists apart from what it is printing, although it will change how it prints
based on what the class of the data is that is passed to it. In fact, a user
can make a custom print method for their own class by defining a function
called 'print.myclassname'. In contrast, the functions that operate on R6
functions are &quot;packaged&quot; with the data they operate on. For example, a print
method of an object for an R6 class might be called like
'my_data$print()' instead of 'print(my_data)'.
</p>


<h3>The two ways to call functions</h3>

<p>Note, you will need to read the previous section to fully understand this one.
</p>
<p>Since the R6 function syntax (e.g. 'my_data$print()') might be confusing to
many R users, all functions in 'taxa' also have S3 versions. For example,
the [filter_taxa()] function can be called on a [taxmap] object called
'my_obj' like 'my_obj$filter_taxa(...)' (the R6 syntax) or
'filter_taxa(my_obj, ...)' (the S3 syntax). For some functions, these two
way of calling the function can have different effect. For functions that do
not returned a modified version of the input (e.g. [subtaxa()]), the two ways have identical behavior.
However, functions like [filter_taxa()], that modify their inputs, actually
change the object passed to them as the first argument as well as returning that
object. For example,
</p>
<p>'my_obj &lt;- filter_taxa(my_obj, ...)'
</p>
<p>and
</p>
<p>'my_obj$filter_taxa(...)'
</p>
<p>and
</p>
<p>'new_obj &lt;- my_obj$filter_taxa(...)'
</p>
<p>all replace 'my_obj' with the filtered result, but
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, ...)'
</p>
<p>will not modify 'my_obj'.
</p>


<h3>Non-standard evaluation</h3>

<p>This is a rather advanced topic.
</p>
<p>Like packages such as 'ggplot2' and [dplyr], the 'taxa' package uses
non-standard evaluation to allow code
to be more readable and shorter. In effect, there are variables that only
&quot;exist&quot; inside a function call and depend on what is passed to that function
as the first parameter (usually a class object). For example, in the 'dpylr'
function [filter()], column names can be used as if they were independent
variables. See '?dpylr::filter' for examples of this. The 'taxa' package builds on this idea.
</p>
<p>For many functions that work on [taxonomy] or [taxmap] objects (e.g. [filter_taxa]),
some functions that return per-taxon information (e.g. [taxon_names()]) can
be referred to by just the name of the function. When one of these functions
are referred to by name, the function is run on the relevant object and its
value replaces the function name. For example,
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, taxon_names == &quot;Bacteria&quot;)'
</p>
<p>is identical to:
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, taxon_names(my_obj) == &quot;Bacteria&quot;)'
</p>
<p>which is identical to:
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, my_obj$taxon_names() == &quot;Bacteria&quot;)'
</p>
<p>which is identical to:
</p>
<p>'my_names &lt;- taxon_names(my_obj)'
</p>
<p>'new_obj &lt;- filter_taxa(my_obj, my_names == &quot;Bacteria&quot;)'
</p>
<p>For 'taxmap' objects, you can also use names of user defined lists, vectors,
and the names of columns in user-defined tables that are stored in the
'obj$data' list. See [filter_taxa()] for examples. You can even add your own
functions that are called by name by adding them to the 'obj$funcs' list.
For any object with functions that use non-standard evaluation, you can see
what values can be used  with [all_names()] like 'all_names(obj)'.
</p>


<h3>Dependencies and inspiration</h3>

<p>Various elements of the 'taxa' package were inspired by the [dplyr] and
[taxize] packages. This package started as parts of the 'metacoder' and
'binomen' packages. There are also many dependencies that make 'taxa'
possible.
</p>


<h3>Feedback and contributions</h3>

<p>Find a problem? Have a suggestion? Have a question? Please submit an issue
at our [GitHub repository](https://github.com/ropensci/taxa):
</p>
<p>[https://github.com/ropensci/taxa/issues](https://github.com/ropensci/taxa/issues)
</p>
<p>A GitHub account is free and easy to set up. We welcome feedback! If you
don't want to use GitHub for some reason, feel free to email us. We do
prefer posting to github since it allows others that might have the same
issue to see our conversation. It also helps us keep track of what problems
we need to address.
</p>
<p>Want to contribute code or make a change to the code? Great, thank you!
Please [fork](https://help.github.com/articles/fork-a-repo/) our GitHub
repository and submit a [pull request](https://help.github.com/articles/about-pull-requests/).
</p>


<h3>Author(s)</h3>

<p>Zachary Foster and Niklaus Grunwald
</p>

<hr>
<h2 id='molten_dist'>Get all distances between points</h2><span id='topic+molten_dist'></span>

<h3>Description</h3>

<p>Returns the distances between every possible combination of two points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>molten_dist(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="molten_dist_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code> of length 1) x coordinate</p>
</td></tr>
<tr><td><code id="molten_dist_+3A_y">y</code></td>
<td>
<p>(<code>numeric</code> of length 1) y coordinate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>

<hr>
<h2 id='multi_sep_split'>Like 'strsplit', but with multiple separators</h2><span id='topic+multi_sep_split'></span>

<h3>Description</h3>

<p>Splits items in a vector by multiple separators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_sep_split(input, split, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_sep_split_+3A_input">input</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="multi_sep_split_+3A_split">split</code></td>
<td>
<p>One or more separators to use to split 'input'</p>
</td></tr>
<tr><td><code id="multi_sep_split_+3A_...">...</code></td>
<td>
<p>Passed to [base::strsplit()]</p>
</td></tr>
</table>

<hr>
<h2 id='mutate_obs'>Add columns to [taxmap()] objects</h2><span id='topic+mutate_obs'></span>

<h3>Description</h3>

<p>Add columns to tables in 'obj$data' in [taxmap()] objects.  See
[dplyr::mutate()] for the inspiration for this function and more information.
Calling the function using the 'obj$mutate_obs(...)' style edits &quot;obj&quot; in
place, unlike most R functions. However, calling the function using the
&lsquo;mutate_obs(obj, ...)' imitates R&rsquo;s traditional copy-on-modify semantics, so
&quot;obj&quot; would not be changed; instead a changed version would be returned, like
most R functions.
</p>
<pre>
obj$mutate_obs(data, ...)
mutate_obs(obj, data, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate_obs_+3A_obj">obj</code></td>
<td>
<p>An object of type [taxmap()]</p>
</td></tr>
<tr><td><code id="mutate_obs_+3A_data">data</code></td>
<td>
<p>Dataset name, index, or a logical vector that indicates which dataset in
'obj$data' to add columns to.</p>
</td></tr>
<tr><td><code id="mutate_obs_+3A_...">...</code></td>
<td>
<p>One or more named columns to add. Newly created columns can be
referenced in the same function call. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="mutate_obs_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Add column to existing tables
mutate_obs(ex_taxmap, "info",
           new_col = "Im new",
           newer_col = paste0(new_col, "er!"))

# Create columns in a new table
mutate_obs(ex_taxmap, "new_table",
           nums = 1:10,
           squared = nums ^ 2)

# Add a new vector
mutate_obs(ex_taxmap, "new_vector", 1:10)

# Add a new list
mutate_obs(ex_taxmap, "new_list", list(1, 2))

</code></pre>

<hr>
<h2 id='my_print'>Print something</h2><span id='topic+my_print'></span>

<h3>Description</h3>

<p>The standard print function for this package. This is a wrapper to make
package-wide changes easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my_print(..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my_print_+3A_...">...</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="my_print_+3A_verbose">verbose</code></td>
<td>
<p>If <code>FALSE</code>, do not print anything.</p>
</td></tr>
</table>

<hr>
<h2 id='n_leaves'>Get number of leaves</h2><span id='topic+n_leaves'></span>

<h3>Description</h3>

<p>Get number of leaves for each taxon in an object of type
[taxonomy()] or [taxmap()]
</p>
<pre>
obj$n_leaves()
n_leaves(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_leaves_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()])</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get number of leaves for each taxon
n_leaves(ex_taxmap)

# Filter taxa based on number of leaves
filter_taxa(ex_taxmap, n_leaves &gt; 0)

</code></pre>

<hr>
<h2 id='n_leaves_1'>Get number of leaves</h2><span id='topic+n_leaves_1'></span>

<h3>Description</h3>

<p>Get number of leaves for each taxon in an object of type
[taxonomy()] or [taxmap()], not including leaves of subtaxa etc.
</p>
<pre>
obj$n_leaves_1()
n_leaves_1(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_leaves_1_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()])</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get number of leaves for each taxon
n_leaves_1(ex_taxmap)

# Filter taxa based on number of leaves
filter_taxa(ex_taxmap, n_leaves_1 &gt; 0)

</code></pre>

<hr>
<h2 id='n_obs'>Count observations in [taxmap()]</h2><span id='topic+n_obs'></span>

<h3>Description</h3>

<p>Count observations for each taxon in a data set in a [taxmap()] object. This
includes observations for the specific taxon and the observations of its
subtaxa. &quot;Observations&quot; in this sense are the items (for list/vectors) or
rows (for tables) in a dataset. By default, observations in the first data
set in the [taxmap()] object is used.  For example, if the data set is a
table, then a value of 3 for a taxon means that their are 3 rows in that
table assigned to that taxon or one of its subtaxa.
</p>
<pre>
obj$n_obs(data)
n_obs(obj, data)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_obs_+3A_obj">obj</code></td>
<td>
<p>([taxmap()])</p>
</td></tr>
<tr><td><code id="n_obs_+3A_data">data</code></td>
<td>
<p>Dataset name, index, or a logical vector that indicates which dataset in
'obj$data' to add columns to.</p>
</td></tr>
<tr><td><code id="n_obs_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'numeric'
</p>


<h3>See Also</h3>

<p>Other taxmap data functions: 
<code><a href="#topic+n_obs_1">n_obs_1</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get number of observations for each taxon in first dataset
n_obs(ex_taxmap)

# Get number of observations in a specified data set
n_obs(ex_taxmap, "info")
n_obs(ex_taxmap, "abund")

# Filter taxa using number of observations in the first table
filter_taxa(ex_taxmap, n_obs &gt; 1)

</code></pre>

<hr>
<h2 id='n_obs_1'>Count observation assigned in [taxmap()]</h2><span id='topic+n_obs_1'></span>

<h3>Description</h3>

<p>Count observations for each taxon in a data set in a [taxmap()] object. This
includes observations for the specific taxon but NOT the observations of its
subtaxa. &quot;Observations&quot; in this sense are the items (for list/vectors) or
rows (for tables) in a dataset. By default, observations in the first data
set in the [taxmap()] object is used.  For example, if the data set is a
table, then a value of 3 for a taxon means that their are 3 rows in that
table assigned to that taxon.
</p>
<pre>
obj$n_obs_1(data)
n_obs_1(obj, data)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_obs_1_+3A_obj">obj</code></td>
<td>
<p>([taxmap()])</p>
</td></tr>
<tr><td><code id="n_obs_1_+3A_data">data</code></td>
<td>
<p>Dataset name, index, or a logical vector that indicates which dataset in
'obj$data' to add columns to.</p>
</td></tr>
<tr><td><code id="n_obs_1_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'numeric'
</p>


<h3>See Also</h3>

<p>Other taxmap data functions: 
<code><a href="#topic+n_obs">n_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get number of observations for each taxon in first dataset
n_obs_1(ex_taxmap)

# Get number of observations in a specified data set
n_obs_1(ex_taxmap, "info")
n_obs_1(ex_taxmap, "abund")

# Filter taxa using number of observations in the first table
filter_taxa(ex_taxmap, n_obs_1 &gt; 0)

</code></pre>

<hr>
<h2 id='n_subtaxa'>Get number of subtaxa</h2><span id='topic+n_subtaxa'></span>

<h3>Description</h3>

<p>Get number of subtaxa for each taxon in an object of type
[taxonomy()] or [taxmap()]
</p>
<pre>
obj$n_subtaxa()
n_subtaxa(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_subtaxa_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()])</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Count number of subtaxa within each taxon
n_subtaxa(ex_taxmap)

# Filter taxa based on number of subtaxa
#  (this command removed all leaves or "tips" of the tree)
filter_taxa(ex_taxmap, n_subtaxa &gt; 0)

</code></pre>

<hr>
<h2 id='n_subtaxa_1'>Get number of subtaxa</h2><span id='topic+n_subtaxa_1'></span>

<h3>Description</h3>

<p>Get number of subtaxa for each taxon in an object of type
[taxonomy()] or [taxmap()], not including subtaxa of subtaxa etc. This does not
include subtaxa assigned to subtaxa.
</p>
<pre>
obj$n_subtaxa_1()
n_subtaxa_1(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_subtaxa_1_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()])</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Count number of immediate subtaxa in each taxon
n_subtaxa_1(ex_taxmap)

# Filter taxa based on number of subtaxa
#  (this command removed all leaves or "tips" of the tree)
filter_taxa(ex_taxmap, n_subtaxa_1 &gt; 0)

</code></pre>

<hr>
<h2 id='n_supertaxa'>Get number of supertaxa</h2><span id='topic+n_supertaxa'></span>

<h3>Description</h3>

<p>Get number of supertaxa for each taxon in an object of type
[taxonomy()] or [taxmap()].
</p>
<pre>
obj$n_supertaxa()
n_supertaxa(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_supertaxa_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()])</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Count number of supertaxa that contain each taxon
n_supertaxa(ex_taxmap)

# Filter taxa based on the number of supertaxa
#  (this command removes all root taxa)
filter_taxa(ex_taxmap, n_supertaxa &gt; 0)

</code></pre>

<hr>
<h2 id='n_supertaxa_1'>Get number of supertaxa</h2><span id='topic+n_supertaxa_1'></span>

<h3>Description</h3>

<p>Get number of immediate supertaxa (i.e. not supertaxa of supertaxa, etc) for
each taxon in an object of type [taxonomy()] or [taxmap()]. This should
always be either 1 or 0.
</p>
<pre>
obj$n_supertaxa_1()
n_supertaxa_1(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_supertaxa_1_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()])</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test for the presence of supertaxa containing each taxon
n_supertaxa_1(ex_taxmap)

# Filter taxa based on the presence of supertaxa
#  (this command removes all root taxa)
filter_taxa(ex_taxmap, n_supertaxa_1 &gt; 0)

</code></pre>

<hr>
<h2 id='name_font'>Variable name formatting in print methods</h2><span id='topic+name_font'></span>

<h3>Description</h3>

<p>A simple wrapper to make changing the formatting of text printed easier.
This is used for non-data, formatting characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_font(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_font_+3A_text">text</code></td>
<td>
<p>What to print</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other printer fonts: 
<code><a href="#topic+desc_font">desc_font</a>()</code>,
<code><a href="#topic+error_font">error_font</a>()</code>,
<code><a href="#topic+punc_font">punc_font</a>()</code>,
<code><a href="#topic+tid_font">tid_font</a>()</code>
</p>

<hr>
<h2 id='names_used'>Get names of data used in expressions</h2><span id='topic+names_used'></span>

<h3>Description</h3>

<p>Get names of available data used in expressions. This is used to find data
for use with [non-standard evaluation](http://adv-r.had.co.nz/Computing-on-the-language.html) (NSE) in
functions like [filter_taxa()]. Expressions are not evaluated and do not need
to make sense.
</p>
<pre>
obj$names_used(...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names_used_+3A_obj">obj</code></td>
<td>
<p>a [taxonomy()] or [taxmap()] object</p>
</td></tr>
<tr><td><code id="names_used_+3A_...">...</code></td>
<td>
<p>One or more expressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named 'character'
</p>


<h3>See Also</h3>

<p>Other NSE helpers: 
<code><a href="#topic+all_names">all_names</a>()</code>,
<code><a href="#topic+data_used">data_used</a></code>,
<code><a href="#topic+get_data">get_data</a>()</code>
</p>

<hr>
<h2 id='ncbi_sequence'>Downloads sequences from ids</h2><span id='topic+ncbi_sequence'></span>

<h3>Description</h3>

<p>Downloads the sequences associated with GenBank accession ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncbi_sequence(ids, batch_size = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncbi_sequence_+3A_ids">ids</code></td>
<td>
<p>(<code>character</code>) One or more accession numbers to get sequences for</p>
</td></tr>
<tr><td><code id="ncbi_sequence_+3A_batch_size">batch_size</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of sequences to request in each query.
To large of values might case failures and too small will increase time to completion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>list</code> of <code>character</code>)
</p>

<hr>
<h2 id='ncbi_taxon_sample'>Download representative sequences for a taxon</h2><span id='topic+ncbi_taxon_sample'></span>

<h3>Description</h3>

<p>Downloads a sample of sequences meant to evenly capture the diversity of a
given taxon. Can be used to get a shallow sampling of vast groups.
<strong>CAUTION:</strong> This function can make MANY queries to Genbank depending on
arguments given and can take a very long time. Choose your arguments
carefully to avoid long waits and needlessly stressing NCBI's servers. Use a
downloaded database and a parser from the <code>taxa</code> package when possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncbi_taxon_sample(
  name = NULL,
  id = NULL,
  target_rank,
  min_counts = NULL,
  max_counts = NULL,
  interpolate_min = TRUE,
  interpolate_max = TRUE,
  min_children = NULL,
  max_children = NULL,
  seqrange = "1:3000",
  getrelated = FALSE,
  fuzzy = TRUE,
  limit = 10,
  entrez_query = NULL,
  hypothetical = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncbi_taxon_sample_+3A_name">name</code></td>
<td>
<p>(<code>character</code> of length 1) The taxon to download a sample of
sequences for.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_id">id</code></td>
<td>
<p>(<code>character</code> of length 1) The taxon id to download a sample of
sequences for.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_target_rank">target_rank</code></td>
<td>
<p>(<code>character</code> of length 1) The finest taxonomic rank
at which to sample. The finest rank at which replication occurs. Must be a
finer rank than <code>taxon</code>.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_min_counts">min_counts</code></td>
<td>
<p>(named <code>numeric</code>) The minimum number of sequences to
download for each taxonomic rank. The names correspond to taxonomic ranks.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_max_counts">max_counts</code></td>
<td>
<p>(named <code>numeric</code>) The maximum number of sequences to
download for each taxonomic rank. The names correspond to taxonomic ranks.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_interpolate_min">interpolate_min</code></td>
<td>
<p>(<code>logical</code>) If <code>TRUE</code>, values supplied to
<code>min_counts</code> and <code>min_children</code> will be used to infer the values
of intermediate ranks not specified. Linear interpolation between values of
specified ranks will be used to determine values of unspecified ranks.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_interpolate_max">interpolate_max</code></td>
<td>
<p>(<code>logical</code>) If <code>TRUE</code>, values supplied to
<code>max_counts</code> and <code>max_children</code> will be used to infer the values
of intermediate ranks not specified. Linear interpolation between values of
specified ranks will be used to determine values of unspecified ranks.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_min_children">min_children</code></td>
<td>
<p>(named <code>numeric</code>) The minimum number sub-taxa of
taxa for a given rank must have for its sequences to be searched. The names
correspond to taxonomic ranks.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_max_children">max_children</code></td>
<td>
<p>(named <code>numeric</code>) The maximum number sub-taxa of
taxa for a given rank must have for its sequences to be searched. The names
correspond to taxonomic ranks.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_seqrange">seqrange</code></td>
<td>
<p>(character) Sequence range, as e.g., &quot;1:1000&quot;. This is the
range of sequence lengths to search for. So &quot;1:1000&quot; means search for
sequences from 1 to 1000 characters in length.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_getrelated">getrelated</code></td>
<td>
<p>(logical) If TRUE, gets the longest sequences of a species
in the same genus as the one searched for. If FALSE, returns nothing if no
match found.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_fuzzy">fuzzy</code></td>
<td>
<p>(logical) Whether to do fuzzy taxonomic ID search or exact
search. If <code>TRUE</code>, we use <code>xXarbitraryXx[porgn:__txid&lt;ID&gt;]</code>, but
if <code>FALSE</code>, we use <code>txid&lt;ID&gt;</code>. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_limit">limit</code></td>
<td>
<p>(<code>numeric</code>) Number of sequences to search for and return.
Max of 10,000. If you search for 6000 records, and only 5000 are found, you
will of course only get 5000 back.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_entrez_query">entrez_query</code></td>
<td>
<p>(<code>character</code>; length 1) An Entrez-format query to
filter results with. This is useful to search for sequences with specific
characteristics. The format is the same as the one used to seach genbank.
(<a href="https://www.ncbi.nlm.nih.gov/books/NBK3837/#EntrezHelp.Entrez_Searching_Options">https://www.ncbi.nlm.nih.gov/books/NBK3837/#EntrezHelp.Entrez_Searching_Options</a>)</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_hypothetical">hypothetical</code></td>
<td>
<p>(<code>logical</code>; length 1) If <code>FALSE</code>, an attempt
will be made to not return hypothetical or predicted sequences judging from
accession number prefixs (XM and XR). This can result in less than the
<code>limit</code> being returned even if there are more sequences available,
since this filtering is done after searching NCBI.</p>
</td></tr>
<tr><td><code id="ncbi_taxon_sample_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical</code>) If <code>TRUE</code>, progress messages will be
printed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# Look up 5 ITS sequences from each fungal class
data &lt;- ncbi_taxon_sample(name = "Fungi", target_rank = "class", limit = 5, 
                          entrez_query = '"internal transcribed spacer"[All Fields]')

# Look up taxonomic information for sequences
obj &lt;- lookup_tax_data(data, type = "seq_id", column = "gi_no")

# Plot information
metacoder::filter_taxa(obj, taxon_names == "Fungi", subtaxa = TRUE) %&gt;% 
  heat_tree(node_label = taxon_names, node_color = n_obs, node_size = n_obs)

</code></pre>

<hr>
<h2 id='num_range'>dplyr select_helpers</h2><span id='topic+num_range'></span>

<h3>Description</h3>

<p>dplyr select_helpers
</p>
<p>dplyr select_helpers
</p>

<hr>
<h2 id='obs'>Get data indexes associated with taxa</h2><span id='topic+obs'></span>

<h3>Description</h3>

<p>Given a [taxmap()] object, return data associated with each taxon in a
given table included in that [taxmap()] object.
</p>
<pre>
obj$obs(data, value = NULL, subset = NULL,
  recursive = TRUE, simplify = FALSE)
obs(obj, data, value = NULL, subset = NULL,
  recursive = TRUE, simplify = FALSE)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obs_+3A_obj">obj</code></td>
<td>
<p>([taxmap()]) The [taxmap()] object containing taxon information to
be queried.</p>
</td></tr>
<tr><td><code id="obs_+3A_data">data</code></td>
<td>
<p>Either the name of something in 'obj$data' that has taxon
information or a an external object with taxon information. For tables,
there must be a column named &quot;taxon_id&quot; and lists/vectors must be named by
taxon ID.</p>
</td></tr>
<tr><td><code id="obs_+3A_value">value</code></td>
<td>
<p>What data to return. This is usually the name of column in a
table in 'obj$data'. Any result of 'all_names(obj)' can be used. If the
value used has names, it is assumed that the names are taxon ids and the
taxon ids are used to look up the correct values.</p>
</td></tr>
<tr><td><code id="obs_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to find observations
for. Default: All taxa in 'obj' will be used. Any variable name that
appears in [all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="obs_+3A_recursive">recursive</code></td>
<td>
<p>('logical' or 'numeric') If 'FALSE', only return the
observation assigned to the specified input taxa, not subtaxa. If 'TRUE',
return all the observations of every subtaxa, etc. Positive numbers
indicate the number of ranks below the each taxon to get observations for
'0' is equivalent to 'FALSE'. Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="obs_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', then combine all the results into a
single vector of unique observation indexes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'simplify = FALSE', then a list of vectors of observation indexes
are returned corresponding to the 'data' argument. If 'simplify = TRUE',
then the observation indexes for all 'data' taxa are returned in a single
vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get indexes of rows corresponding to each taxon
obs(ex_taxmap, "info")

# Get only a subset of taxon indexes
obs(ex_taxmap, "info", subset = 1:2)

# Get only a subset of taxon IDs
obs(ex_taxmap, "info", subset = c("b", "c"))

# Get only a subset of taxa using logical tests
obs(ex_taxmap, "info", subset = taxon_ranks == "genus")

# Only return indexes of rows assinged to each taxon explicitly
obs(ex_taxmap, "info", recursive = FALSE)

# Lump all row indexes in a single vector
obs(ex_taxmap, "info", simplify = TRUE)

# Return values from a dataset instead of indexes
obs(ex_taxmap, "info", value = "name")

</code></pre>

<hr>
<h2 id='obs_apply'>Apply function to observations per taxon</h2><span id='topic+obs_apply'></span>

<h3>Description</h3>

<p>Apply a function to data for the observations for each taxon. This is similar
to using [obs()] with [lapply()] or [sapply()].
</p>
<pre>
obj$obs_apply(data, func, simplify = FALSE, value = NULL,
  subset = NULL, recursive = TRUE, ...)
obs_apply(obj, data, func, simplify = FALSE, value = NULL,
  subset = NULL, recursive = TRUE, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="obs_apply_+3A_obj">obj</code></td>
<td>
<p>The [taxmap()] object containing taxon information to
be queried.</p>
</td></tr>
<tr><td><code id="obs_apply_+3A_data">data</code></td>
<td>
<p>Either the name of something in 'obj$data' that has taxon
information or a an external object with taxon information. For tables,
there must be a column named &quot;taxon_id&quot; and lists/vectors must be named by
taxon ID.</p>
</td></tr>
<tr><td><code id="obs_apply_+3A_func">func</code></td>
<td>
<p>('function') The function to apply.</p>
</td></tr>
<tr><td><code id="obs_apply_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', convert lists to vectors.</p>
</td></tr>
<tr><td><code id="obs_apply_+3A_value">value</code></td>
<td>
<p>What data to give to the function. This is usually the name of
column in a table in 'obj$data'. Any result of 'all_names(obj)' can be
used, but it usually only makes sense to use columns in the dataset
specified by the 'data' option. By default, the indexes of observation in
'data' are returned.</p>
</td></tr>
<tr><td><code id="obs_apply_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to use.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="obs_apply_+3A_recursive">recursive</code></td>
<td>
<p>('logical' or 'numeric') If 'FALSE', only return the
observation assigned to the specified input taxa, not subtaxa. If 'TRUE',
return all the observations of every subtaxa, etc. Positive numbers
indicate the number of ranks below the each taxon to get observations for
'0' is equivalent to 'FALSE'. Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="obs_apply_+3A_...">...</code></td>
<td>
<p>Extra arguments are passed to the function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Find the average number of legs in each taxon
obs_apply(ex_taxmap, "info", mean, value = "n_legs", simplify = TRUE)

# One way to implement `n_obs` and find the number of observations per taxon
obs_apply(ex_taxmap, "info", length, simplify = TRUE)

</code></pre>

<hr>
<h2 id='one_of'>dplyr select_helpers</h2><span id='topic+one_of'></span>

<h3>Description</h3>

<p>dplyr select_helpers
</p>
<p>dplyr select_helpers
</p>

<hr>
<h2 id='parse_dada2'>Convert the output of dada2 to a taxmap object</h2><span id='topic+parse_dada2'></span>

<h3>Description</h3>

<p>Convert the ASV table and taxonomy table returned by dada2 into a taxmap object. An example of
the input format can be found by following the dada2 tutorial here:
shttps://benjjneb.github.io/dada2/tutorial.html
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_dada2(
  seq_table,
  tax_table,
  class_key = "taxon_name",
  class_regex = "(.*)",
  include_match = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_dada2_+3A_seq_table">seq_table</code></td>
<td>
<p>The ASV abundance matrix, with rows as samples and columns as ASV ids or
sequences</p>
</td></tr>
<tr><td><code id="parse_dada2_+3A_tax_table">tax_table</code></td>
<td>
<p>The table with taxonomic classifications for ASVs, with ASVs in rows and
taxonomic ranks as columns.</p>
</td></tr>
<tr><td><code id="parse_dada2_+3A_class_key">class_key</code></td>
<td>
<p>('character' of length 1) The identity of the capturing groups defined using
'class_regex'. The length of 'class_key' must be equal to the number of capturing groups
specified in 'class_regex'. Any names added to the terms will be used as column names in the
output. At least one '&quot;taxon_name&quot;' must be specified. Only '&quot;info&quot;' can be used multiple
times. Each term must be one of those described below: * 'taxon_name': The name of a taxon. Not
necessarily unique, but are interpretable by a particular 'database'. Requires an internet
connection. * 'taxon_rank': The rank of the taxon. This will be used to add rank info into the
output object that can be accessed by 'out$taxon_ranks()'. * 'info': Arbitrary taxon info you
want included in the output. Can be used more than once.</p>
</td></tr>
<tr><td><code id="parse_dada2_+3A_class_regex">class_regex</code></td>
<td>
<p>('character' of length 1) A regular expression with capturing groups
indicating the locations of data for each taxon in the 'class' term in the 'key' argument. The
identity of the information must be specified using the 'class_key' argument. The 'class_sep'
option can be used to split the classification into data for each taxon before matching. If
'class_sep' is 'NULL', each match of 'class_regex' defines a taxon in the classification.</p>
</td></tr>
<tr><td><code id="parse_dada2_+3A_include_match">include_match</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', include the part of the input matched by
'class_regex' in the output object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_dataset'>Parse options specifying datasets</h2><span id='topic+parse_dataset'></span>

<h3>Description</h3>

<p>Parse options specifying datasets in taxmap objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_dataset(obj, data, must_be_valid = TRUE, needed = TRUE, rm_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_dataset_+3A_obj">obj</code></td>
<td>
<p>The taxmap object.</p>
</td></tr>
<tr><td><code id="parse_dataset_+3A_data">data</code></td>
<td>
<p>The name/index of datasets in a taxmap object to use. Can also be a logical vector
of length equal to the number of datasets.</p>
</td></tr>
<tr><td><code id="parse_dataset_+3A_must_be_valid">must_be_valid</code></td>
<td>
<p>If TRUE, all datasets specified must be valid or an error occurs.</p>
</td></tr>
<tr><td><code id="parse_dataset_+3A_needed">needed</code></td>
<td>
<p>If TRUE, at least one dataset must be specified or an error occurs.</p>
</td></tr>
<tr><td><code id="parse_dataset_+3A_rm_na">rm_na</code></td>
<td>
<p>If TRUE, then invalid datasets do result in NAs in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The indexes for the datasets selected
</p>

<hr>
<h2 id='parse_edge_list'>Convert a table with an edge list to taxmap</h2><span id='topic+parse_edge_list'></span>

<h3>Description</h3>

<p>Converts a table containing an edge list into a [taxmap()] object.
An &quot;edge list&quot; is two columns in a table, where each row defines a taxon-supertaxon relationship.
The contents of the edge list will be used as taxon IDs.
The whole table will be included as a data set in the output object.
</p>
<p>Converts a table containing an edge list into a [taxmap()] object.
An &quot;edge list&quot; is two columns in a table, where each row defines a taxon-supertaxon relationship.
The contents of the edge list will be used as taxon IDs.
The whole table will be included as a data set in the output object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_edge_list(input, taxon_id, supertaxon_id, taxon_name, taxon_rank = NULL)

parse_edge_list(input, taxon_id, supertaxon_id, taxon_name, taxon_rank = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_edge_list_+3A_input">input</code></td>
<td>
<p>A table containing an edge list encoded by two columns.</p>
</td></tr>
<tr><td><code id="parse_edge_list_+3A_taxon_id">taxon_id</code></td>
<td>
<p>The name/index of the column containing the taxon IDs.</p>
</td></tr>
<tr><td><code id="parse_edge_list_+3A_supertaxon_id">supertaxon_id</code></td>
<td>
<p>The name/index of the column containing the taxon IDs for the supertaxon of the IDs in 'taxon_col'.</p>
</td></tr>
<tr><td><code id="parse_edge_list_+3A_taxon_name">taxon_name</code></td>
<td>
<p>xxx</p>
</td></tr>
<tr><td><code id="parse_edge_list_+3A_taxon_rank">taxon_rank</code></td>
<td>
<p>xxx</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>
<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_greengenes'>Parse Greengenes release</h2><span id='topic+parse_greengenes'></span>

<h3>Description</h3>

<p>Parses the greengenes database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_greengenes(tax_file, seq_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_greengenes_+3A_tax_file">tax_file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to the
greengenes taxonomy file.</p>
</td></tr>
<tr><td><code id="parse_greengenes_+3A_seq_file">seq_file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to the
greengenes sequence fasta file. This is optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The taxonomy input file has a format like:
</p>
<pre>
228054  k__Bacteria; p__Cyanobacteria; c__Synechococcophycideae; o__Synech...
844608  k__Bacteria; p__Cyanobacteria; c__Synechococcophycideae; o__Synech...
...
</pre>
<p>The optional sequence file has a format like:
</p>
<pre>
&gt;1111886
AACGAACGCTGGCGGCATGCCTAACACATGCAAGTCGAACGAGACCTTCGGGTCTAGTGGCGCACGGGTGCGTA...
&gt;1111885
AGAGTTTGATCCTGGCTCAGAATGAACGCTGGCGGCGTGCCTAACACATGCAAGTCGTACGAGAAATCCCGAGC...
...
</pre>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_heirarchies_to_taxonomy'>Infer edge list from hierarchies</h2><span id='topic+parse_heirarchies_to_taxonomy'></span>

<h3>Description</h3>

<p>Infer edge list and unique taxa from hierarchies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_heirarchies_to_taxonomy(heirarchies)
</code></pre>


<h3>Value</h3>

<p>A list of [hierarchy()] objects.
</p>

<hr>
<h2 id='parse_mothur_tax_summary'>Parse mothur *.tax.summary Classify.seqs output</h2><span id='topic+parse_mothur_tax_summary'></span>

<h3>Description</h3>

<p>Parse the '*.tax.summary' file that is returned by the 'Classify.seqs' command
in mothur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_mothur_tax_summary(file = NULL, text = NULL, table = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_mothur_tax_summary_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to the input file. 
Either &quot;file&quot;, &quot;text&quot;, or &quot;table&quot; must be used, but only one.</p>
</td></tr>
<tr><td><code id="parse_mothur_tax_summary_+3A_text">text</code></td>
<td>
<p>(<code>character</code>) An alternate input to &quot;file&quot;. The contents of 
the file as a character. Either &quot;file&quot;, &quot;text&quot;, or &quot;table&quot; must be used,
but only one.</p>
</td></tr>
<tr><td><code id="parse_mothur_tax_summary_+3A_table">table</code></td>
<td>
<p>(<code>character</code> of length 1) An already parsed data.frame or
tibble. Either &quot;file&quot;, &quot;text&quot;, or &quot;table&quot; must be used, but only one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file has a format like:
</p>
<pre>
taxlevel	 rankID	 taxon	 daughterlevels	 total	A	B	C	
0	0	Root	2	242	84	84	74	
1	0.1	Bacteria	50	242	84	84	74	
2	0.1.2	Actinobacteria	38	13	0	13	0	
3	0.1.2.3	Actinomycetaceae-Bifidobacteriaceae	10	13	0	13	0	
4	0.1.2.3.7	Bifidobacteriaceae	6	13	0	13	0	
5	0.1.2.3.7.2	Bifidobacterium_choerinum_et_rel.	8	13	0	13	0	
6	0.1.2.3.7.2.1	Bifidobacterium_angulatum_et_rel.	1	11	0	11	0	
7	0.1.2.3.7.2.1.1	unclassified	1	11	0	11	0	
8	0.1.2.3.7.2.1.1.1	unclassified	1	11	0	11	0	
9	0.1.2.3.7.2.1.1.1.1	unclassified	1	11	0	11	0	
10	0.1.2.3.7.2.1.1.1.1.1	unclassified	1	11	0	11	0	
11	0.1.2.3.7.2.1.1.1.1.1.1	unclassified	1	11	0	11	0	
12	0.1.2.3.7.2.1.1.1.1.1.1.1	unclassified	1	11	0	11	0	
6	0.1.2.3.7.2.5	Bifidobacterium_longum_et_rel.	1	2	0	2	0	
7	0.1.2.3.7.2.5.1	unclassified	1	2	0	2	0	
8	0.1.2.3.7.2.5.1.1	unclassified	1	2	0	2	0	
9	0.1.2.3.7.2.5.1.1.1	unclassified	1	2	0	2	0
</pre>
<p>or 
</p>
<pre>
taxon	total	A	B	C
"k__Bacteria";"p__Actinobacteria";"c__Actinobacteria";...	1	0	1	0
"k__Bacteria";"p__Actinobacteria";"c__Actinobacteria";...	1	0	1	0
"k__Bacteria";"p__Actinobacteria";"c__Actinobacteria";...	1	0	1	0
</pre>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_mothur_taxonomy'>Parse mothur Classify.seqs *.taxonomy output</h2><span id='topic+parse_mothur_taxonomy'></span>

<h3>Description</h3>

<p>Parse the '*.taxonomy' file that is returned by the 'Classify.seqs' command
in mothur. If confidence scores are present, they are included in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_mothur_taxonomy(file = NULL, text = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_mothur_taxonomy_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to the input file.
Either &quot;file&quot; or &quot;text&quot; must be used, but not both.</p>
</td></tr>
<tr><td><code id="parse_mothur_taxonomy_+3A_text">text</code></td>
<td>
<p>(<code>character</code>) An alternate input to &quot;file&quot;. The contents of
the file as a character. Either &quot;file&quot; or &quot;text&quot; must be used, but not both.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file has a format like:
</p>
<pre>
AY457915	Bacteria(100);Firmicutes(99);Clostridiales(99);Johnsone...
AY457914	Bacteria(100);Firmicutes(100);Clostridiales(100);Johnso...
AY457913	Bacteria(100);Firmicutes(100);Clostridiales(100);Johnso...
AY457912	Bacteria(100);Firmicutes(99);Clostridiales(99);Johnsone...
AY457911	Bacteria(100);Firmicutes(99);Clostridiales(98);Ruminoco...
</pre>
<p>or...
</p>
<pre>
AY457915	Bacteria;Firmicutes;Clostridiales;Johnsonella_et_rel.;J...
AY457914	Bacteria;Firmicutes;Clostridiales;Johnsonella_et_rel.;J...
AY457913	Bacteria;Firmicutes;Clostridiales;Johnsonella_et_rel.;J...
AY457912	Bacteria;Firmicutes;Clostridiales;Johnsonella_et_rel.;J...
AY457911	Bacteria;Firmicutes;Clostridiales;Ruminococcus_et_rel.;...
</pre>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_newick'>Parse a Newick file</h2><span id='topic+parse_newick'></span>

<h3>Description</h3>

<p>Parse a Newick file into a taxmap object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_newick(file = NULL, text = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_newick_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to the input file. Either <code>file</code> or <code>text</code> must be supplied but not both.</p>
</td></tr>
<tr><td><code id="parse_newick_+3A_text">text</code></td>
<td>
<p>(<code>character</code> of length 1) The raw text to parse. Either <code>file</code> or <code>text</code> must be supplied but not both.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file has a format like:
</p>
<pre>
(ant:17, (bat:31, cow:22):7, dog:22, (elk:33, fox:12):40);
(dog:20, (elephant:30, horse:60):20):50;
</pre>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_phylo'>Parse a phylo object</h2><span id='topic+parse_phylo'></span>

<h3>Description</h3>

<p>Parses a phylo object from the ape package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_phylo(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_phylo_+3A_obj">obj</code></td>
<td>
<p>A phylo object from the ape package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_phyloseq'>Convert a phyloseq to taxmap</h2><span id='topic+parse_phyloseq'></span>

<h3>Description</h3>

<p>Converts a phyloseq object to a taxmap object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_phyloseq(obj, class_regex = "(.*)", class_key = "taxon_name")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_phyloseq_+3A_obj">obj</code></td>
<td>
<p>A phyloseq object</p>
</td></tr>
<tr><td><code id="parse_phyloseq_+3A_class_regex">class_regex</code></td>
<td>
<p>A regular expression used to parse data in the taxon
names. There must be a capture group (a pair of parentheses) for each item
in <code>class_key</code>. See <code><a href="#topic+parse_tax_data">parse_tax_data</a></code> for examples of
how this works.</p>
</td></tr>
<tr><td><code id="parse_phyloseq_+3A_class_key">class_key</code></td>
<td>
<p>('character' of length 1) The identity of the capturing groups defined using
'class_regex'. The length of 'class_key' must be equal to the number of capturing groups
specified in 'class_regex'. Any names added to the terms will be used as column names in the
output. At least one '&quot;taxon_name&quot;' must be specified. Only '&quot;info&quot;' can be used multiple
times. Each term must be one of those described below: * 'taxon_name': The name of a taxon. Not
necessarily unique, but are interpretable by a particular 'database'. Requires an internet
connection. * 'taxon_rank': The rank of the taxon. This will be used to add rank info into the
output object that can be accessed by 'out$taxon_ranks()'. * 'info': Arbitrary taxon info you
want included in the output. Can be used more than once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A taxmap object
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parse example dataset
library(phyloseq)
data(GlobalPatterns)
x &lt;- parse_phyloseq(GlobalPatterns)

# Plot data
heat_tree(x,
          node_size = n_obs,
          node_color = n_obs,
          node_label = taxon_names,
          tree_label = taxon_names)


</code></pre>

<hr>
<h2 id='parse_possibly_named_logical'>used to parse inputs to 'drop_obs' and 'reassign_obs'</h2><span id='topic+parse_possibly_named_logical'></span>

<h3>Description</h3>

<p>used to parse inputs to 'drop_obs' and 'reassign_obs'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_possibly_named_logical(input, data, default)
</code></pre>

<hr>
<h2 id='parse_primersearch'>Parse EMBOSS primersearch output</h2><span id='topic+parse_primersearch'></span>

<h3>Description</h3>

<p>Parses the output file from EMBOSS primersearch into a data.frame with rows corresponding to 
predicted amplicons and their associated information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_primersearch(file_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_primersearch_+3A_file_path">file_path</code></td>
<td>
<p>The path to a primersearch output file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each row corresponding to amplicon data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_primersearch">run_primersearch</a></code>
</p>

<hr>
<h2 id='parse_qiime_biom'>Parse a BIOM output from QIIME</h2><span id='topic+parse_qiime_biom'></span>

<h3>Description</h3>

<p>Parses a file in BIOM format from QIIME into a taxmap object.
This also seems to work with files from MEGAN.
I have not tested if it works with other BIOM files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_qiime_biom(file, class_regex = "(.*)", class_key = "taxon_name")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_qiime_biom_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to the input file.</p>
</td></tr>
<tr><td><code id="parse_qiime_biom_+3A_class_regex">class_regex</code></td>
<td>
<p>A regular expression used to parse data in the taxon
names. There must be a capture group (a pair of parentheses) for each item
in <code>class_key</code>. See <code><a href="#topic+parse_tax_data">parse_tax_data</a></code> for examples of
how this works.</p>
</td></tr>
<tr><td><code id="parse_qiime_biom_+3A_class_key">class_key</code></td>
<td>
<p>('character' of length 1) The identity of the capturing groups defined using
'class_regex'. The length of 'class_key' must be equal to the number of capturing groups
specified in 'class_regex'. Any names added to the terms will be used as column names in the
output. At least one '&quot;taxon_name&quot;' must be specified. Only '&quot;info&quot;' can be used multiple
times. Each term must be one of those described below: * 'taxon_name': The name of a taxon. Not
necessarily unique, but are interpretable by a particular 'database'. Requires an internet
connection. * 'taxon_rank': The rank of the taxon. This will be used to add rank info into the
output object that can be accessed by 'out$taxon_ranks()'. * 'info': Arbitrary taxon info you
want included in the output. Can be used more than once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was inspired by the tutorial created by Geoffrey Zahn at 
http://geoffreyzahn.com/getting-your-otu-table-into-r/.
</p>


<h3>Value</h3>

<p>A taxmap object
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_raw_heirarchies_to_taxonomy'>Infer edge list from hierarchies composed of character vectors</h2><span id='topic+parse_raw_heirarchies_to_taxonomy'></span>

<h3>Description</h3>

<p>Infer edge list and unique taxa from hierarchies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_raw_heirarchies_to_taxonomy(heirarchies, named_by_rank = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_raw_heirarchies_to_taxonomy_+3A_named_by_rank">named_by_rank</code></td>
<td>
<p>('TRUE'/'FALSE') If  'TRUE' and the input is a list of
vectors with each vector named by ranks, include that rank info in the
output object, so it can be accessed by 'out$taxon_ranks()'. If 'TRUE',
taxa with different ranks, but the same name and location in the taxonomy,
will be considered different taxa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors.
</p>

<hr>
<h2 id='parse_rdp'>Parse RDP FASTA release</h2><span id='topic+parse_rdp'></span>

<h3>Description</h3>

<p>Parses an RDP reference FASTA file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_rdp(input = NULL, file = NULL, include_seqs = TRUE, add_species = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_rdp_+3A_input">input</code></td>
<td>
<p>(<code>character</code>) One of the following: 
</p>

<dl>
<dt>A character vector of sequences</dt><dd><p>See the example below for what this
looks like. The parser <code><a href="#topic+read_fasta">read_fasta</a></code> produces output like this.</p>
</dd>
<dt>A list of character vectors</dt><dd><p>Each vector should have one base per element.</p>
</dd>
<dt>A &quot;DNAbin&quot; object</dt><dd><p>This is the result of parsers like
<code><a href="ape.html#topic+read.FASTA">read.FASTA</a></code>.</p>
</dd>
<dt>A list of &quot;SeqFastadna&quot; objects</dt><dd><p>This is the result of parsers like
<code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code>.</p>
</dd>
</dl>
<p>Either &quot;input&quot; or &quot;file&quot; must be supplied but not both.
</p>
</td></tr>
<tr><td><code id="parse_rdp_+3A_file">file</code></td>
<td>
<p>The path to a FASTA file containing sequences to use. Either
&quot;input&quot; or &quot;file&quot; must be supplied but not both.</p>
</td></tr>
<tr><td><code id="parse_rdp_+3A_include_seqs">include_seqs</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code>, include 
sequences in the output object.</p>
</td></tr>
<tr><td><code id="parse_rdp_+3A_add_species">add_species</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code>, add the
species information to the taxonomy. In this database, the species name
often contains other information as well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file has a format like:
</p>
<pre>
&gt;S000448483 Sparassis crispa; MBUH-PIRJO&amp;ILKKA94-1587/ss5	Lineage=Root;rootrank;Fun...
ggattcccctagtaactgcgagtgaagcgggaagagctcaaatttaaaatctggcggcgtcctcgtcgtccgagttgtaa
tctggagaagcgacatccgcgctggaccgtgtacaagtctcttggaaaagagcgtcgtagagggtgacaatcccgtcttt
...
</pre>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_seq_input'>Read sequences in an unknown format</h2><span id='topic+parse_seq_input'></span>

<h3>Description</h3>

<p>Read sequences in an unknown format. This is meant to parse the sequence
input arguments of functions like <code><a href="#topic+primersearch">primersearch</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_seq_input(
  input = NULL,
  file = NULL,
  output_format = "character",
  u_to_t = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_seq_input_+3A_input">input</code></td>
<td>
<p>(<code>character</code>) One of the following: 
</p>

<dl>
<dt>A character vector of sequences</dt><dd><p>See the example below for what this
looks like. The parser <code><a href="#topic+read_fasta">read_fasta</a></code> produces output like this.</p>
</dd>
<dt>A list of character vectors</dt><dd><p>Each vector should have one base per element.</p>
</dd>
<dt>A &quot;DNAbin&quot; object</dt><dd><p>This is the result of parsers like
<code><a href="ape.html#topic+read.FASTA">read.FASTA</a></code>.</p>
</dd>
<dt>A list of &quot;SeqFastadna&quot; objects</dt><dd><p>This is the result of parsers like
<code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code>.</p>
</dd>
</dl>
<p>Either &quot;input&quot; or &quot;file&quot; must be supplied but not both.
</p>
</td></tr>
<tr><td><code id="parse_seq_input_+3A_file">file</code></td>
<td>
<p>The path to a FASTA file containing sequences to use. Either
&quot;input&quot; or &quot;file&quot; must be supplied but not both.</p>
</td></tr>
<tr><td><code id="parse_seq_input_+3A_output_format">output_format</code></td>
<td>
<p>The format of the sequences returned. Either &quot;character&quot; or &quot;DNAbin&quot;.</p>
</td></tr>
<tr><td><code id="parse_seq_input_+3A_u_to_t">u_to_t</code></td>
<td>
<p>If 'TRUE', then &quot;U&quot; in the sequence will be converted to &quot;T&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of sequences
</p>

<hr>
<h2 id='parse_silva_fasta'>Parse SILVA FASTA release</h2><span id='topic+parse_silva_fasta'></span>

<h3>Description</h3>

<p>Parses an SILVA FASTA file that can be found at
<a href="https://www.arb-silva.de/no_cache/download/archive/release_128/Exports/">https://www.arb-silva.de/no_cache/download/archive/release_128/Exports/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_silva_fasta(file = NULL, input = NULL, include_seqs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_silva_fasta_+3A_file">file</code></td>
<td>
<p>The path to a FASTA file containing sequences to use. Either
&quot;input&quot; or &quot;file&quot; must be supplied but not both.</p>
</td></tr>
<tr><td><code id="parse_silva_fasta_+3A_input">input</code></td>
<td>
<p>(<code>character</code>) One of the following: 
</p>

<dl>
<dt>A character vector of sequences</dt><dd><p>See the example below for what this
looks like. The parser <code><a href="#topic+read_fasta">read_fasta</a></code> produces output like this.</p>
</dd>
<dt>A list of character vectors</dt><dd><p>Each vector should have one base per element.</p>
</dd>
<dt>A &quot;DNAbin&quot; object</dt><dd><p>This is the result of parsers like
<code><a href="ape.html#topic+read.FASTA">read.FASTA</a></code>.</p>
</dd>
<dt>A list of &quot;SeqFastadna&quot; objects</dt><dd><p>This is the result of parsers like
<code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code>.</p>
</dd>
</dl>
<p>Either &quot;input&quot; or &quot;file&quot; must be supplied but not both.
</p>
</td></tr>
<tr><td><code id="parse_silva_fasta_+3A_include_seqs">include_seqs</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code>, include
sequences in the output object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file has a format like:
</p>
<pre> &gt;GCVF01000431.1.2369
Bacteria;Proteobacteria;Gammaproteobacteria;Oceanospiril...
CGUGCACGGUGGAUGCCUUGGCAGCCAGAGGCGAUGAAGGACGUUGUAGCCUGCGAUAAGCUCCGGUUAGGUGGCAAACA
ACCGUUUGACCCGGAGAUCUCCGAAUGGGGCAACCCACCCGUUGUAAGGCGGGUAUCACCGACUGAAUCCAUAGGUCGGU
... </pre>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_summary_seqs'>Parse summary.seqs output</h2><span id='topic+parse_summary_seqs'></span>

<h3>Description</h3>

<p>Extract statistics from the command line output of mothur command <code>summary.seqs</code> and
return the results in a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_summary_seqs(text = NULL, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_summary_seqs_+3A_text">text</code></td>
<td>
<p>The text output of <code>summary.seqs</code></p>
</td></tr>
<tr><td><code id="parse_summary_seqs_+3A_file">file</code></td>
<td>
<p>The path to saved output of <code>summary.seqs</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of statistics
</p>

<hr>
<h2 id='parse_tax_data'>Convert one or more data sets to taxmap</h2><span id='topic+parse_tax_data'></span>

<h3>Description</h3>

<p>Reads taxonomic information and associated data in tables, lists, and vectors and stores it in a
[taxmap()] object. [Taxonomic
classifications](https://en.wikipedia.org/wiki/Taxonomy_(biology)#Classifying_organisms) must be
present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_tax_data(
  tax_data,
  datasets = list(),
  class_cols = 1,
  class_sep = ";",
  sep_is_regex = FALSE,
  class_key = "taxon_name",
  class_regex = "(.*)",
  class_reversed = FALSE,
  include_match = TRUE,
  mappings = c(),
  include_tax_data = TRUE,
  named_by_rank = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_tax_data_+3A_tax_data">tax_data</code></td>
<td>
<p>A table, list, or vector that contains the names of taxa that represent
[taxonomic
classifications](https://en.wikipedia.org/wiki/Taxonomy_(biology)#Classifying_organisms).
Accepted representations of classifications include: * A list/vector or table with column(s) of
taxon names: Something like '&quot;Animalia;Chordata;Mammalia;Primates;Hominidae;Homo&quot;'. What
separator(s) is used (&quot;;&quot; in this example) can be changed with the 'class_sep' option. For
tables, the classification can be spread over multiple columns and the separator(s) will be
applied to each column, although each column could just be single taxon names with no
separator. Use the 'class_cols' option to specify which columns have taxon names. * A list in
which each entry is a classifications. For example, 'list(c(&quot;Animalia&quot;, &quot;Chordata&quot;, &quot;Mammalia&quot;,
&quot;Primates&quot;, &quot;Hominidae&quot;, &quot;Homo&quot;), ...)'. * A list of data.frames where each represents a
classification with one taxon per row. The column that contains taxon names is specified using
the 'class_cols' option. In this instance, it only makes sense to specify a single column.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_datasets">datasets</code></td>
<td>
<p>Additional lists/vectors/tables that should be included in the resulting 'taxmap'
object. The 'mappings' option is use to specify how these data sets relate to the 'tax_data'
and, by inference, what taxa apply to each item.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_class_cols">class_cols</code></td>
<td>
<p>('character' or 'integer') The names or indexes of columns that contain
classifications if the first input is a table. If multiple columns are specified, they will be
combined in the order given. Negative column indexes mean &quot;every column besides these columns&quot;.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_class_sep">class_sep</code></td>
<td>
<p>('character') One or more separators that delineate taxon names in a
classification. For example, if one column had '&quot;Homo sapiens&quot;' and another had
'&quot;Animalia;Chordata;Mammalia;Primates;Hominidae&quot;', then 'class_sep = c(&quot; &quot;, &quot;;&quot;)'. All
separators are applied to each column so order does not matter.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_sep_is_regex">sep_is_regex</code></td>
<td>
<p>('TRUE'/'FALSE') Whether or not 'class_sep' should be used as a [regular
expression](https://en.wikipedia.org/wiki/Regular_expression).</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_class_key">class_key</code></td>
<td>
<p>('character' of length 1) The identity of the capturing groups defined using
'class_regex'. The length of 'class_key' must be equal to the number of capturing groups
specified in 'class_regex'. Any names added to the terms will be used as column names in the
output. At least one '&quot;taxon_name&quot;' must be specified. Only '&quot;info&quot;' can be used multiple
times. Each term must be one of those described below: * 'taxon_name': The name of a taxon. Not
necessarily unique, but are interpretable by a particular 'database'. Requires an internet
connection. * 'taxon_rank': The rank of the taxon. This will be used to add rank info into the
output object that can be accessed by 'out$taxon_ranks()'. * 'info': Arbitrary taxon info you
want included in the output. Can be used more than once.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_class_regex">class_regex</code></td>
<td>
<p>('character' of length 1) A regular expression with capturing groups
indicating the locations of data for each taxon in the 'class' term in the 'key' argument. The
identity of the information must be specified using the 'class_key' argument. The 'class_sep'
option can be used to split the classification into data for each taxon before matching. If
'class_sep' is 'NULL', each match of 'class_regex' defines a taxon in the classification.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_class_reversed">class_reversed</code></td>
<td>
<p>If 'TRUE', then classifications go from specific to general. For example:
'Abditomys latidens : Muridae : Rodentia : Mammalia : Chordata'.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_include_match">include_match</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', include the part of the input matched by
'class_regex' in the output object.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_mappings">mappings</code></td>
<td>
<p>(named 'character') This defines how the taxonomic information in 'tax_data'
applies to data set in 'datasets'. This option should have the same number of inputs as
'datasets', with values corresponding to each data set. The names of the character vector
specify what information in 'tax_data' is shared with info in each 'dataset', which is
specified by the corresponding values of the character vector. If there are no shared
variables, you can add 'NA' as a placeholder, but you could just leave that data out since it
is not benefiting from being in the taxmap object. The names/values can be one of the
following: * For tables, the names of columns can be used. * '&quot;{{index}}&quot;' : This means to use
the index of rows/items * '&quot;{{name}}&quot;'  : This means to use row/item names. * '&quot;{{value}}&quot;' :
This means to use the values in vectors or lists. Lists will be converted to vectors using
[unlist()].</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_include_tax_data">include_tax_data</code></td>
<td>
<p>('TRUE'/'FALSE') Whether or not to include 'tax_data' as a dataset, like
those in 'datasets'.</p>
</td></tr>
<tr><td><code id="parse_tax_data_+3A_named_by_rank">named_by_rank</code></td>
<td>
<p>('TRUE'/'FALSE') If  'TRUE' and the input is a table with columns named by
ranks or a list of vectors with each vector named by ranks, include that rank info in the
output object, so it can be accessed by 'out$taxon_ranks()'. If 'TRUE', taxa with different
ranks, but the same name and location in the taxonomy, will be considered different taxa.
Cannot be used with the 'sep', 'class_regex', or 'class_key' options.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Read a vector of classifications
 my_taxa &lt;- c("Mammalia;Carnivora;Felidae",
              "Mammalia;Carnivora;Felidae",
              "Mammalia;Carnivora;Ursidae")
 parse_tax_data(my_taxa, class_sep = ";")

 # Read a list of classifications
 my_taxa &lt;- list("Mammalia;Carnivora;Felidae",
                "Mammalia;Carnivora;Felidae",
                "Mammalia;Carnivora;Ursidae")
 parse_tax_data(my_taxa, class_sep = ";")

 # Read classifications in a table in a single column
 species_data &lt;- data.frame(tax = c("Mammalia;Carnivora;Felidae",
                                    "Mammalia;Carnivora;Felidae",
                                    "Mammalia;Carnivora;Ursidae"),
                           species_id = c("A", "B", "C"))
 parse_tax_data(species_data, class_sep = ";", class_cols = "tax")

 # Read classifications in a table in multiple columns
 species_data &lt;- data.frame(lineage = c("Mammalia;Carnivora;Felidae",
                                        "Mammalia;Carnivora;Felidae",
                                        "Mammalia;Carnivora;Ursidae"),
                            species = c("Panthera leo",
                                        "Panthera tigris",
                                        "Ursus americanus"),
                            species_id = c("A", "B", "C"))
 parse_tax_data(species_data, class_sep = c(" ", ";"),
                class_cols = c("lineage", "species"))

 # Read classification tables with one column per rank
 species_data &lt;- data.frame(class = c("Mammalia", "Mammalia", "Mammalia"),
                            order = c("Carnivora", "Carnivora", "Carnivora"),
                            family = c("Felidae", "Felidae", "Ursidae"),
                            genus = c("Panthera", "Panthera", "Ursus"),
                            species = c("leo", "tigris", "americanus"),
                            species_id = c("A", "B", "C"))
  parse_tax_data(species_data, class_cols = 1:5)
  parse_tax_data(species_data, class_cols = 1:5,
                 named_by_rank = TRUE) # makes `taxon_ranks()` work

 # Classifications with extra information
 my_taxa &lt;- c("Mammalia_class_1;Carnivora_order_2;Felidae_genus_3",
              "Mammalia_class_1;Carnivora_order_2;Felidae_genus_3",
              "Mammalia_class_1;Carnivora_order_2;Ursidae_genus_3")
 parse_tax_data(my_taxa, class_sep = ";",
                class_regex = "(.+)_(.+)_([0-9]+)",
                class_key = c(my_name = "taxon_name",
                              a_rank = "taxon_rank",
                              some_num = "info"))


  # --- Parsing multiple datasets at once (advanced) ---
  # The rest is one example for how to classify multiple datasets at once.

  # Make example data with taxonomic classifications
  species_data &lt;- data.frame(tax = c("Mammalia;Carnivora;Felidae",
                                     "Mammalia;Carnivora;Felidae",
                                     "Mammalia;Carnivora;Ursidae"),
                             species = c("Panthera leo",
                                         "Panthera tigris",
                                         "Ursus americanus"),
                             species_id = c("A", "B", "C"))

  # Make example data associated with the taxonomic data
  # Note how this does not contain classifications, but
  # does have a varaible in common with "species_data" ("id" = "species_id")
  abundance &lt;- data.frame(id = c("A", "B", "C", "A", "B", "C"),
                          sample_id = c(1, 1, 1, 2, 2, 2),
                          counts = c(23, 4, 3, 34, 5, 13))

  # Make another related data set named by species id
  common_names &lt;- c(A = "Lion", B = "Tiger", C = "Bear", "Oh my!")

  # Make another related data set with no names
  foods &lt;- list(c("ungulates", "boar"),
                c("ungulates", "boar"),
                c("salmon", "fruit", "nuts"))

  # Make a taxmap object with these three datasets
  x = parse_tax_data(species_data,
                     datasets = list(counts = abundance,
                                     my_names = common_names,
                                     foods = foods),
                     mappings = c("species_id" = "id",
                                  "species_id" = "{{name}}",
                                  "{{index}}" = "{{index}}"),
                     class_cols = c("tax", "species"),
                     class_sep = c(" ", ";"))

  # Note how all the datasets have taxon ids now
  x$data

  # This allows for complex mappings between variables that other functions use
  map_data(x, my_names, foods)
  map_data(x, counts, my_names)

</code></pre>

<hr>
<h2 id='parse_ubiome'>Converts the uBiome file format to taxmap</h2><span id='topic+parse_ubiome'></span>

<h3>Description</h3>

<p>Converts the uBiome file format to taxmap. NOTE: This is experimental and might not work if
uBiome changes their format. Contact the maintainers if you encounter problems/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_ubiome(file = NULL, table = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_ubiome_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to the input file. 
Either &quot;file&quot;, or &quot;table&quot; must be used, but only one.</p>
</td></tr>
<tr><td><code id="parse_ubiome_+3A_table">table</code></td>
<td>
<p>(<code>character</code> of length 1) An already parsed data.frame or
tibble. Either &quot;file&quot;, or &quot;table&quot; must be used, but only one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file has a format like:
</p>
<pre>
 tax_name,tax_rank,count,count_norm,taxon,parent
 root,root,29393,1011911,1,
 Bacteria,superkingdom,29047,1000000,2,131567
 Campylobacter,genus,23,791,194,72294
 Flavobacterium,genus,264,9088,237,49546
</pre>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_unite_general">parse_unite_general</a>()</code>
</p>

<hr>
<h2 id='parse_unite_general'>Parse UNITE general release FASTA</h2><span id='topic+parse_unite_general'></span>

<h3>Description</h3>

<p>Parse the UNITE general release FASTA file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_unite_general(input = NULL, file = NULL, include_seqs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_unite_general_+3A_input">input</code></td>
<td>
<p>(<code>character</code>) One of the following: 
</p>

<dl>
<dt>A character vector of sequences</dt><dd><p>See the example below for what this
looks like. The parser <code><a href="#topic+read_fasta">read_fasta</a></code> produces output like this.</p>
</dd>
<dt>A list of character vectors</dt><dd><p>Each vector should have one base per element.</p>
</dd>
<dt>A &quot;DNAbin&quot; object</dt><dd><p>This is the result of parsers like
<code><a href="ape.html#topic+read.FASTA">read.FASTA</a></code>.</p>
</dd>
<dt>A list of &quot;SeqFastadna&quot; objects</dt><dd><p>This is the result of parsers like
<code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code>.</p>
</dd>
</dl>
<p>Either &quot;input&quot; or &quot;file&quot; must be supplied but not both.
</p>
</td></tr>
<tr><td><code id="parse_unite_general_+3A_file">file</code></td>
<td>
<p>The path to a FASTA file containing sequences to use. Either
&quot;input&quot; or &quot;file&quot; must be supplied but not both.</p>
</td></tr>
<tr><td><code id="parse_unite_general_+3A_include_seqs">include_seqs</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code>, include
sequences in the output object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file has a format like:
</p>
<pre>
&gt;Glomeromycota_sp|KJ484724|SH523877.07FU|reps|k__Fungi;p__Glomeromycota;c__unid...
ATAATTTGCCGAACCTAGCGTTAGCGCGAGGTTCTGCGATCAACACTTATATTTAAAACCCAACTCTTAAATTTTGTAT...
</pre>


<h3>Value</h3>

<p><code><a href="#topic+taxmap">taxmap</a></code>
</p>


<h3>See Also</h3>

<p>Other parsers: 
<code><a href="#topic+extract_tax_data">extract_tax_data</a>()</code>,
<code><a href="#topic+lookup_tax_data">lookup_tax_data</a>()</code>,
<code><a href="#topic+parse_dada2">parse_dada2</a>()</code>,
<code><a href="#topic+parse_edge_list">parse_edge_list</a>()</code>,
<code><a href="#topic+parse_greengenes">parse_greengenes</a>()</code>,
<code><a href="#topic+parse_mothur_tax_summary">parse_mothur_tax_summary</a>()</code>,
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a>()</code>,
<code><a href="#topic+parse_newick">parse_newick</a>()</code>,
<code><a href="#topic+parse_phylo">parse_phylo</a>()</code>,
<code><a href="#topic+parse_phyloseq">parse_phyloseq</a>()</code>,
<code><a href="#topic+parse_qiime_biom">parse_qiime_biom</a>()</code>,
<code><a href="#topic+parse_rdp">parse_rdp</a>()</code>,
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a>()</code>,
<code><a href="#topic+parse_tax_data">parse_tax_data</a>()</code>,
<code><a href="#topic+parse_ubiome">parse_ubiome</a>()</code>
</p>

<hr>
<h2 id='polygon_coords'>Makes coordinates for a regular polygon</h2><span id='topic+polygon_coords'></span>

<h3>Description</h3>

<p>Generates an n x 2 matrix containing x and y coordinates between 1 and 0 for the points of a 
regular polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon_coords(n = 5, x = 0, y = 0, radius = 1, angle = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polygon_coords_+3A_n">n</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of nodes in the polygon.</p>
</td></tr>
<tr><td><code id="polygon_coords_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code> of length 1) x coordinate of center</p>
</td></tr>
<tr><td><code id="polygon_coords_+3A_y">y</code></td>
<td>
<p>(<code>numeric</code> of length 1) y coordinate of center</p>
</td></tr>
<tr><td><code id="polygon_coords_+3A_radius">radius</code></td>
<td>
<p>(<code>numeric</code> of length 1) The diameter of the circle.</p>
</td></tr>
<tr><td><code id="polygon_coords_+3A_angle">angle</code></td>
<td>
<p>(<code>numeric</code> of length 1) Angle to rotate points around the center of the circle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired by (i.e. stolen from) https://gist.github.com/baptiste/2224724, which was
itself inspired from a post by William Dunlap on r-help (10/09/09)
</p>

<hr>
<h2 id='prefixed_print'>Print a object with a prefix</h2><span id='topic+prefixed_print'></span>

<h3>Description</h3>

<p>Print a object with a prefix. Uses the standard print method of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prefixed_print(x, prefix, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prefixed_print_+3A_x">x</code></td>
<td>
<p>What to print.</p>
</td></tr>
</table>

<hr>
<h2 id='primersearch'>Use EMBOSS primersearch for in silico PCR</h2><span id='topic+primersearch'></span>

<h3>Description</h3>

<p>A pair of primers are aligned against a set of sequences. A
<code><a href="#topic+taxmap">taxmap</a></code> object with two tables is returned: a table with
information for each predicted amplicon, quality of match, and predicted
amplicons, and a table with per-taxon amplification statistics. Requires the
EMBOSS tool kit (<a href="https://emboss.sourceforge.net/">https://emboss.sourceforge.net/</a>) to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primersearch(obj, seqs, forward, reverse, mismatch = 5, clone = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="primersearch_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object.</p>
</td></tr>
<tr><td><code id="primersearch_+3A_seqs">seqs</code></td>
<td>
<p>The sequences to do in silico PCR on. This can be any variable in
<code>obj$data</code> listed in <code>all_names(obj)</code> or an external variable. If
an external variable (i.e. not in <code>obj$data</code>), it must be named by
taxon IDs or have the same length as the number of taxa in <code>obj</code>.
Currently, only character vectors are accepted.</p>
</td></tr>
<tr><td><code id="primersearch_+3A_forward">forward</code></td>
<td>
<p>(<code>character</code> of length 1) The forward primer sequence</p>
</td></tr>
<tr><td><code id="primersearch_+3A_reverse">reverse</code></td>
<td>
<p>(<code>character</code> of length 1) The reverse primer sequence</p>
</td></tr>
<tr><td><code id="primersearch_+3A_mismatch">mismatch</code></td>
<td>
<p>An integer vector of length 1. The percentage of mismatches allowed.</p>
</td></tr>
<tr><td><code id="primersearch_+3A_clone">clone</code></td>
<td>
<p>If <code>TRUE</code>, make a copy of the input object and add on the results (like most R
functions). If <code>FALSE</code>, the input will be changed without saving the result, which uses less RAM.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be confusing how the primer sequence relates to the binding sites on a
reference database sequence. A simplified diagram can help. For example, if
the top strand below (5' -&gt; 3') is the database sequence, the forward primer
has the same sequence as the target region, since it will bind to the other
strand (3' -&gt; 5') during PCR and extend on the 3' end. However, the reverse
primer must bind to the database strand, so it will have to be the complement
of the reference sequence. It also has to be reversed to make it in the
standard 5' -&gt; 3' orientation. Therefore, the reverse primer must be the
reverse complement of its binding site on the reference sequence.
</p>
<pre>
Primer 1: 5' AAGTACCTTAACGGAATTATAG 3'
Primer 2: 5' GCTCCACCTACGAAACGAAT   3'
 
                               &lt;- TAAGCAAAGCATCCACCTCG 5'
5' ...AAGTACCTTAACGGAATTATAG......ATTCGTTTCGTAGGTGGAGC... 3'

3' ...TTCATGGAATTGCCTTAATATC......TAAGCAAAGCATCCACCTCG... 5'
   5' AAGTACCTTAACGGAATTATAG -&gt;
</pre>
<p>However, a database might have either the top or the bottom strand as a
reference sequence. Since one implies the sequence of the other, either is
valid, but this is another source of confusion. If we take the diagram above
and rotate it 180 degrees, it would mean the same thing, but which primer we would
want to call &quot;forward&quot; and which we would want to call &quot;reverse&quot; would
change. Databases of a single locus (e.g. Greengenes) will likely have a
convention for which strand will be present, so relative to this convention,
there is a distinct &quot;forward&quot; and &quot;reverse&quot;. However, computers dont know
about this convention, so the &quot;forward&quot; primer is whichever primer has the
same sequence as its binding region in the database (as opposed to the
reverse complement). For this reason, primersearch will redefine which primer
is &quot;forward&quot; and which is &quot;reverse&quot; based on how it binds the reference
sequence. See the example code in <code><a href="#topic+primersearch_raw">primersearch_raw</a></code> for a
demonstration of this.
</p>


<h3>Value</h3>

<p>A copy of the input <code><a href="#topic+taxmap">taxmap</a></code> object with two tables added. One table contains amplicon information with one row per predicted amplicon with the following info:
</p>
<pre>
           (f_primer)
   5' AAGTACCTTAACGGAATTATAG -&gt;        (r_primer)
                               &lt;- TAAGCAAAGCATCCACCTCG 5'
5' ...AAGTACCTTAACGGAATTATAG......ATTCGTTTCGTAGGTGGAGC... 3'
      ^                    ^      ^                  ^
   f_start              f_end   r_rtart             r_end
     
      |--------------------||----||------------------|
             f_match       amplicon       r_match  
      |----------------------------------------------|
                           product
                           
</pre>

<dl>
<dt>taxon_id:</dt><dd><p>The taxon IDs for the sequence.</p>
</dd> 
<dt>seq_index:</dt><dd><p>The index of the input sequence.</p>
</dd> 
<dt>f_primer:</dt><dd><p>The sequence of the forward primer.</p>
</dd> 
<dt>r_primer:</dt><dd><p>The sequence of the reverse primer.</p>
</dd> 
<dt>f_mismatch:</dt><dd><p>The number of mismatches on the forward primer.</p>
</dd> 
<dt>r_mismatch:</dt><dd><p>The number of mismatches on the reverse primer.</p>
</dd> 
<dt>f_start:</dt><dd><p>The start location of the forward primer.</p>
</dd> 
<dt>f_end:</dt><dd><p>The end location of the forward primer.</p>
</dd> 
<dt>r_start:</dt><dd><p>The start location of the reverse primer.</p>
</dd>  
<dt>r_end:</dt><dd><p>The end location of the reverse primer.</p>
</dd> 
<dt>f_match:</dt><dd><p>The sequence matched by the forward primer.</p>
</dd> 
<dt>r_match:</dt><dd><p>The sequence matched by the reverse primer.</p>
</dd> 
<dt>amplicon:</dt><dd><p>The sequence amplified by the primers, not including the primers.</p>
</dd> 
<dt>product:</dt><dd><p>The sequence amplified by the primers including the primers. This simulates a real PCR product.</p>
</dd> 
</dl>

<p>The other table contains per-taxon information about the PCR, with one row per taxon. It has the following columns:
</p>

<dl>
<dt>taxon_ids:</dt><dd><p>Taxon IDs.</p>
</dd>
<dt>query_count:</dt><dd><p>The number of sequences used as input.</p>
</dd>
<dt>seq_count:</dt><dd><p>The number of sequences that had at least one amplicon.</p>
</dd>
<dt>amp_count:</dt><dd><p>The number of amplicons. Might be more than one per sequence.</p>
</dd>
<dt>amplified:</dt><dd><p>If at least one sequence of that taxon had at least one amplicon.</p>
</dd>
<dt>multiple:</dt><dd><p>If at least one sequences had at least two amplicons.</p>
</dd>
<dt>prop_amplified:</dt><dd><p>The proportion of sequences with at least one amplicon.</p>
</dd>
<dt>med_amp_len:</dt><dd><p>The median amplicon length.</p>
</dd>
<dt>min_amp_len:</dt><dd><p>The minimum amplicon length.</p>
</dd>
<dt>max_amp_len:</dt><dd><p>The maximum amplicon length.</p>
</dd>
<dt>med_prod_len:</dt><dd><p>The median product length.</p>
</dd>
<dt>min_prod_len:</dt><dd><p>The minimum product length.</p>
</dd>
<dt>max_prod_len:</dt><dd><p>The maximum product length.</p>
</dd>
</dl>



<h3>Installing EMBOSS</h3>

<p>The command-line tool &quot;primersearch&quot; from the EMBOSS tool kit is needed to use this function.
How you install EMBOSS will depend on your operating system:
</p>
<p><strong>Linux:</strong>
</p>
<p>Open up a terminal and type:
</p>
<p><code>sudo apt-get install emboss</code>
</p>
<p><strong>Mac OSX:</strong>
</p>
<p>The easiest way to install EMBOSS on OSX is to use <a href="https://brew.sh/">homebrew</a>.
After installing homebrew, open up a terminal and type:
</p>
<p><code>brew install homebrew/science/emboss</code>
</p>
<p><strong>Windows:</strong>
</p>
<p>There is an installer for Windows here:
</p>
<p>ftp://emboss.open-bio.org/pub/EMBOSS/windows/mEMBOSS-6.5.0.0-setup.exe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get example FASTA file
fasta_path &lt;- system.file(file.path("extdata", "silva_subset.fa"),
                          package = "metacoder")

# Parse the FASTA file as a taxmap object
obj &lt;- parse_silva_fasta(file = fasta_path)

# Simulate PCR with primersearch
# Have to replace Us with Ts in sequences since primersearch
#   does not understand Us.
obj &lt;- primersearch(obj,
                    gsub(silva_seq, pattern = "U", replace = "T"), 
                    forward = c("U519F" = "CAGYMGCCRCGGKAAHACC"),
                    reverse = c("Arch806R" = "GGACTACNSGGGTMTCTAAT"),
                    mismatch = 10)
                           
# Plot what did not ampilify                          
obj %&gt;%
  filter_taxa(prop_amplified &lt; 1) %&gt;%
  heat_tree(node_label = taxon_names, 
            node_color = prop_amplified, 
            node_color_range = c("grey", "red", "purple", "green"),
            node_color_trans = "linear",
            node_color_axis_label = "Proportion amplified",
            node_size = n_obs,
            node_size_axis_label = "Number of sequences",
            layout = "da", 
            initial_layout = "re")
 

</code></pre>

<hr>
<h2 id='primersearch_is_installed'>Test if primersearch is installed</h2><span id='topic+primersearch_is_installed'></span>

<h3>Description</h3>

<p>Test if primersearch is installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primersearch_is_installed(must_be_installed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="primersearch_is_installed_+3A_must_be_installed">must_be_installed</code></td>
<td>
<p>(<code>logical</code> of length 1)
If <code>TRUE</code>, throw an error if primersearch is not installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code> of length 1
</p>

<hr>
<h2 id='primersearch_raw'>Use EMBOSS primersearch for in silico PCR</h2><span id='topic+primersearch_raw'></span>

<h3>Description</h3>

<p>A pair of primers are aligned against a set of sequences.
The location of the best hits, quality of match, and predicted amplicons are returned.
Requires the EMBOSS tool kit (<a href="https://emboss.sourceforge.net/">https://emboss.sourceforge.net/</a>) to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primersearch_raw(input = NULL, file = NULL, forward, reverse, mismatch = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="primersearch_raw_+3A_input">input</code></td>
<td>
<p>(<code>character</code>) One of the following: 
</p>

<dl>
<dt>A character vector of sequences</dt><dd><p>See the example below for what this
looks like. The parser <code><a href="#topic+read_fasta">read_fasta</a></code> produces output like this.</p>
</dd>
<dt>A list of character vectors</dt><dd><p>Each vector should have one base per element.</p>
</dd>
<dt>A &quot;DNAbin&quot; object</dt><dd><p>This is the result of parsers like
<code><a href="ape.html#topic+read.FASTA">read.FASTA</a></code>.</p>
</dd>
<dt>A list of &quot;SeqFastadna&quot; objects</dt><dd><p>This is the result of parsers like
<code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code>.</p>
</dd>
</dl>
<p>Either &quot;input&quot; or &quot;file&quot; must be supplied but not both.
</p>
</td></tr>
<tr><td><code id="primersearch_raw_+3A_file">file</code></td>
<td>
<p>The path to a FASTA file containing sequences to use. Either
&quot;input&quot; or &quot;file&quot; must be supplied but not both.</p>
</td></tr>
<tr><td><code id="primersearch_raw_+3A_forward">forward</code></td>
<td>
<p>(<code>character</code> of length 1) The forward primer sequence</p>
</td></tr>
<tr><td><code id="primersearch_raw_+3A_reverse">reverse</code></td>
<td>
<p>(<code>character</code> of length 1) The reverse primer sequence</p>
</td></tr>
<tr><td><code id="primersearch_raw_+3A_mismatch">mismatch</code></td>
<td>
<p>An integer vector of length 1. The percentage of mismatches allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be confusing how the primer sequence relates to the binding sites on a
reference database sequence. A simplified diagram can help. For example, if
the top strand below (5' -&gt; 3') is the database sequence, the forward primer
has the same sequence as the target region, since it will bind to the other
strand (3' -&gt; 5') during PCR and extend on the 3' end. However, the reverse
primer must bind to the database strand, so it will have to be the complement
of the reference sequence. It also has to be reversed to make it in the
standard 5' -&gt; 3' orientation. Therefore, the reverse primer must be the
reverse complement of its binding site on the reference sequence.
</p>
<pre>
Primer 1: 5' AAGTACCTTAACGGAATTATAG 3'
Primer 2: 5' GCTCCACCTACGAAACGAAT   3'
 
                               &lt;- TAAGCAAAGCATCCACCTCG 5'
5' ...AAGTACCTTAACGGAATTATAG......ATTCGTTTCGTAGGTGGAGC... 3'

3' ...TTCATGGAATTGCCTTAATATC......TAAGCAAAGCATCCACCTCG... 5'
   5' AAGTACCTTAACGGAATTATAG -&gt;
</pre>
<p>However, a database might have either the top or the bottom strand as a
reference sequence. Since one implies the sequence of the other, either is
valid, but this is another source of confusion. If we take the diagram above
and rotate it 180 degrees, it would mean the same thing, but which primer we would
want to call &quot;forward&quot; and which we would want to call &quot;reverse&quot; would
change. Databases of a single locus (e.g. Greengenes) will likely have a
convention for which strand will be present, so relative to this convention,
there is a distinct &quot;forward&quot; and &quot;reverse&quot;. However, computers dont know
about this convention, so the &quot;forward&quot; primer is whichever primer has the
same sequence as its binding region in the database (as opposed to the
reverse complement). For this reason, primersearch will redefine which primer
is &quot;forward&quot; and which is &quot;reverse&quot; based on how it binds the reference
sequence. See the example code for a demonstration of this.
</p>


<h3>Value</h3>

<p>A table with one row per predicted amplicon with the following info:
</p>
<pre>
           (f_primer)
   5' AAGTACCTTAACGGAATTATAG -&gt;        (r_primer)
                               &lt;- TAAGCAAAGCATCCACCTCG 5'
5' ...AAGTACCTTAACGGAATTATAG......ATTCGTTTCGTAGGTGGAGC... 3'
      ^                    ^      ^                  ^
   f_start              f_end   r_rtart             r_end
     
      |--------------------||----||------------------|
             f_match       amplicon       r_match  
      |----------------------------------------------|
                           product
                           
  
f_mismatch: The number of mismatches on the forward primer
r_mismatch: The number of mismatches on the reverse primer
input: The index of the input sequence
</pre>


<h3>Installing EMBOSS</h3>

<p>The command-line tool &quot;primersearch&quot; from the EMBOSS tool kit is needed to use this function.
How you install EMBOSS will depend on your operating system:
</p>
<p><strong>Linux:</strong>
</p>
<p>Open up a terminal and type:
</p>
<p><code>sudo apt-get install emboss</code>
</p>
<p><strong>Mac OSX:</strong>
</p>
<p>The easiest way to install EMBOSS on OSX is to use <a href="https://brew.sh/">homebrew</a>.
After installing homebrew, open up a terminal and type:
</p>
<p><code>brew install homebrew/science/emboss</code>
</p>
<p><strong>Windows:</strong>
</p>
<p>There is an installer for Windows here:
</p>
<p>ftp://emboss.open-bio.org/pub/EMBOSS/windows/mEMBOSS-6.5.0.0-setup.exe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Dummy test data set ###

primer_1_site &lt;- "AAGTACCTTAACGGAATTATAG"
primer_2_site &lt;- "ATTCGTTTCGTAGGTGGAGC"
amplicon &lt;- "NNNAGTGGATAGATAGGGGTTCTGTGGCGTTTGGGAATTAAAGATTAGAGANNN"
seq_1 &lt;- paste0("AA", primer_1_site, amplicon, primer_2_site, "AAAA")
seq_2 &lt;- rev_comp(seq_1)
f_primer &lt;- "ACGTACCTTAACGGAATTATAG" # Note the "C" mismatch at position 2
r_primer &lt;- rev_comp(primer_2_site)
seqs &lt;- c(a = seq_1, b = seq_2)

result &lt;- primersearch_raw(seqs, forward = f_primer, reverse = r_primer)


### Real data set ###

# Get example FASTA file
fasta_path &lt;- system.file(file.path("extdata", "silva_subset.fa"),
                          package = "metacoder")

# Parse the FASTA file as a taxmap object
obj &lt;- parse_silva_fasta(file = fasta_path)

# Simulate PCR with primersearch
pcr_result &lt;- primersearch_raw(obj$data$tax_data$silva_seq, 
                               forward = c("U519F" = "CAGYMGCCRCGGKAAHACC"),
                               reverse = c("Arch806R" = "GGACTACNSGGGTMTCTAAT"),
                               mismatch = 10)

# Add result to input table 
#  NOTE: We want to add a function to handle running pcr on a
#        taxmap object directly, but we are still trying to figure out
#        the best way to implement it. For now, do the following:
obj$data$pcr &lt;- pcr_result
obj$data$pcr$taxon_id &lt;- obj$data$tax_data$taxon_id[pcr_result$input]

# Visualize which taxa were amplified
#  This work because only amplicons are returned by `primersearch`
n_amplified &lt;- unlist(obj$obs_apply("pcr",
    function(x) length(unique(obj$data$tax_data$input[x]))))
prop_amped &lt;- n_amplified / obj$n_obs()
heat_tree(obj,
          node_label = taxon_names, 
          node_color = prop_amped, 
          node_color_range = c("grey", "red", "purple", "green"),
          node_color_trans = "linear",
          node_color_axis_label = "Proportion amplified",
          node_size = n_obs,
          node_size_axis_label = "Number of sequences",
          layout = "da", 
          initial_layout = "re")


</code></pre>

<hr>
<h2 id='print__character'>Print a character</h2><span id='topic+print__character'></span>

<h3>Description</h3>

<p>Print a character for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__character(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__character_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__character_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__character_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__character_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__character_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__character_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__data.frame'>Print a data.frame</h2><span id='topic+print__data.frame'></span>

<h3>Description</h3>

<p>Print a data.frame for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__data.frame(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__data.frame_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__data.frame_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__data.frame_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__data.frame_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__data.frame_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__data.frame_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__default_'>Print method for unsupported</h2><span id='topic+print__default_'></span>

<h3>Description</h3>

<p>Print method for unsupported classes for taxmap objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__default_(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__default__+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__default__+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__default__+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__default__+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__default__+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__default__+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__factor'>Print a factor</h2><span id='topic+print__factor'></span>

<h3>Description</h3>

<p>Print a factor for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__factor(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__factor_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__factor_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__factor_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__factor_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__factor_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__factor_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__integer'>Print an integer</h2><span id='topic+print__integer'></span>

<h3>Description</h3>

<p>Print an integer for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__integer(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__integer_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__integer_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__integer_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__integer_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__integer_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__integer_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__list'>Print a list</h2><span id='topic+print__list'></span>

<h3>Description</h3>

<p>Print a list for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__list(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__list_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__list_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__list_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__list_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__list_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__list_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__logical'>Print a logical</h2><span id='topic+print__logical'></span>

<h3>Description</h3>

<p>Print a logical for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__logical(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__logical_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__logical_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__logical_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__logical_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__logical_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__logical_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__matrix'>Print a matrix</h2><span id='topic+print__matrix'></span>

<h3>Description</h3>

<p>Print a matrix for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__matrix(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__matrix_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__matrix_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__matrix_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__matrix_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__matrix_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__matrix_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__numeric'>Print a numeric</h2><span id='topic+print__numeric'></span>

<h3>Description</h3>

<p>Print a numeric vector for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__numeric(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__numeric_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__numeric_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__numeric_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__numeric_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__numeric_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__numeric_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__ordered'>Print a ordered factor</h2><span id='topic+print__ordered'></span>

<h3>Description</h3>

<p>Print a ordered factor for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__ordered(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__ordered_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__ordered_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__ordered_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__ordered_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__ordered_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__ordered_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__tbl_df'>Print a tibble</h2><span id='topic+print__tbl_df'></span>

<h3>Description</h3>

<p>Print a table for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__tbl_df(obj, data, name, prefix, max_width, max_rows)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__tbl_df_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__tbl_df_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__tbl_df_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__tbl_df_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__tbl_df_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__tbl_df_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__vector">print__vector</a>()</code>
</p>

<hr>
<h2 id='print__vector'>Generic vector printer</h2><span id='topic+print__vector'></span>

<h3>Description</h3>

<p>Print a vector for the print method of taxmap objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print__vector(
  obj,
  data,
  name,
  prefix,
  max_width,
  max_rows,
  type = class(data)[1]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print__vector_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print__vector_+3A_data">data</code></td>
<td>
<p>Something to print</p>
</td></tr>
<tr><td><code id="print__vector_+3A_name">name</code></td>
<td>
<p>The name of the thing to print</p>
</td></tr>
<tr><td><code id="print__vector_+3A_prefix">prefix</code></td>
<td>
<p>What to put before the thing printed. Typically a space.</p>
</td></tr>
<tr><td><code id="print__vector_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width in number of characters to print</p>
</td></tr>
<tr><td><code id="print__vector_+3A_max_rows">max_rows</code></td>
<td>
<p>Maximum number of rows to print</p>
</td></tr>
<tr><td><code id="print__vector_+3A_type">type</code></td>
<td>
<p>The name of the type of vector to print (e.g. numeric).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Which print method is called is determined by its name, so changing the name
of this function will change when it is called.
</p>


<h3>See Also</h3>

<p>Other taxmap print methods: 
<code><a href="#topic+print__character">print__character</a>()</code>,
<code><a href="#topic+print__data.frame">print__data.frame</a>()</code>,
<code><a href="#topic+print__default_">print__default_</a>()</code>,
<code><a href="#topic+print__factor">print__factor</a>()</code>,
<code><a href="#topic+print__integer">print__integer</a>()</code>,
<code><a href="#topic+print__list">print__list</a>()</code>,
<code><a href="#topic+print__logical">print__logical</a>()</code>,
<code><a href="#topic+print__matrix">print__matrix</a>()</code>,
<code><a href="#topic+print__numeric">print__numeric</a>()</code>,
<code><a href="#topic+print__ordered">print__ordered</a>()</code>,
<code><a href="#topic+print__tbl_df">print__tbl_df</a>()</code>
</p>

<hr>
<h2 id='print_item'>Print a item</h2><span id='topic+print_item'></span>

<h3>Description</h3>

<p>Used to print each item in the 'taxmap' print method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_item(
  obj,
  data,
  name = NULL,
  max_rows = 3,
  max_items = 3,
  max_width = getOption("width") - 10,
  prefix = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_item_+3A_obj">obj</code></td>
<td>
<p>The taxmap object containing the thing to print</p>
</td></tr>
<tr><td><code id="print_item_+3A_data">data</code></td>
<td>
<p>The item to be printed</p>
</td></tr>
<tr><td><code id="print_item_+3A_max_rows">max_rows</code></td>
<td>
<p>('numeric' of length 1) The maximum number of rows in
tables to print.</p>
</td></tr>
<tr><td><code id="print_item_+3A_max_items">max_items</code></td>
<td>
<p>('numeric' of length 1) The maximum number of list
items to print.</p>
</td></tr>
<tr><td><code id="print_item_+3A_max_width">max_width</code></td>
<td>
<p>('numeric' of length 1) The maximum number of
characters to print.</p>
</td></tr>
<tr><td><code id="print_item_+3A_prefix">prefix</code></td>
<td>
<p>('numeric' of length 1) What to print in front of each
line.</p>
</td></tr>
</table>

<hr>
<h2 id='print_tree'>Print a text tree</h2><span id='topic+print_tree'></span>

<h3>Description</h3>

<p>Print a text-based tree of a [taxonomy()] or [taxmap()] object.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_tree_+3A_obj">obj</code></td>
<td>
<p>A <code>taxonomy</code> or <code>taxmap</code> object</p>
</td></tr>
<tr><td><code id="print_tree_+3A_value">value</code></td>
<td>
<p>What data to return. Default is taxon names. Any result of
[all_names()] can be used, but it usually only makes sense to use data with
one value per taxon, like taxon names.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>print_tree(ex_taxmap)

</code></pre>

<hr>
<h2 id='progress_lapply'>lappy with progress bars</h2><span id='topic+progress_lapply'></span>

<h3>Description</h3>

<p>Immitates lapply with optional progress bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress_lapply(X, FUN, progress = interactive(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="progress_lapply_+3A_x">X</code></td>
<td>
<p>The thing to iterate over</p>
</td></tr>
<tr><td><code id="progress_lapply_+3A_fun">FUN</code></td>
<td>
<p>The function to apply to each element</p>
</td></tr>
<tr><td><code id="progress_lapply_+3A_progress">progress</code></td>
<td>
<p>(logical of length 1) Whether or not to print a progress bar. Default is to only print a progress bar during interactive use.</p>
</td></tr>
<tr><td><code id="progress_lapply_+3A_...">...</code></td>
<td>
<p>Passed to function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='punc_font'>Punctuation formatting in print methods</h2><span id='topic+punc_font'></span>

<h3>Description</h3>

<p>A simple wrapper to make changing the formatting of text printed easier.
This is used for non-data, formatting characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>punc_font(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="punc_font_+3A_text">text</code></td>
<td>
<p>What to print</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other printer fonts: 
<code><a href="#topic+desc_font">desc_font</a>()</code>,
<code><a href="#topic+error_font">error_font</a>()</code>,
<code><a href="#topic+name_font">name_font</a>()</code>,
<code><a href="#topic+tid_font">tid_font</a>()</code>
</p>

<hr>
<h2 id='qualitative_palette'>The default qualitative color palette</h2><span id='topic+qualitative_palette'></span>

<h3>Description</h3>

<p>Returns the default color palette for qualitative data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualitative_palette()
</code></pre>


<h3>Value</h3>

<p><code>character</code> of hex color codes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qualitative_palette()

</code></pre>

<hr>
<h2 id='quantative_palette'>The default quantative color palette</h2><span id='topic+quantative_palette'></span>

<h3>Description</h3>

<p>Returns the default color palette for quantative data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantative_palette()
</code></pre>


<h3>Value</h3>

<p><code>character</code> of hex color codes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quantative_palette()

</code></pre>

<hr>
<h2 id='ranks_ref'>Lookup-table for IDs of taxonomic ranks</h2><span id='topic+ranks_ref'></span>

<h3>Description</h3>

<p>Composed of two columns:
</p>

<ul>
<li><p> rankid - the ordered identifier value. lower values mean higher rank
</p>
</li>
<li><p> ranks - all the rank names that belong to the same level, with
different variants that mean essentially the same thing
</p>
</li></ul>


<hr>
<h2 id='rarefy_obs'>Calculate rarefied observation counts</h2><span id='topic+rarefy_obs'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, rarefy counts to a constant total. This
is a wrapper around <code><a href="vegan.html#topic+rrarefy">rrarefy</a></code> that automatically detects
which columns are numeric and handles the reformatting needed to use tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rarefy_obs(
  obj,
  data,
  sample_size = NULL,
  cols = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rarefy_obs_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="rarefy_obs_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="rarefy_obs_+3A_sample_size">sample_size</code></td>
<td>
<p>The sample size counts will be rarefied to. This can be 
either a single integer or a vector of integers of equal length to the 
number of columns.</p>
</td></tr>
<tr><td><code id="rarefy_obs_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="rarefy_obs_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="rarefy_obs_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="rarefy_obs_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+zero_low_counts">zero_low_counts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")
                   
# Rarefy all numeric columns
rarefy_obs(x, "tax_data")

# Rarefy a subset of columns
rarefy_obs(x, "tax_data", cols = c("700035949", "700097855", "700100489"))
rarefy_obs(x, "tax_data", cols = 4:6)
rarefy_obs(x, "tax_data", cols = startsWith(colnames(x$data$tax_data), "70001"))

# Including all other columns in ouput
rarefy_obs(x, "tax_data", other_cols = TRUE)

# Inlcuding specific columns in output
rarefy_obs(x, "tax_data", cols = c("700035949", "700097855", "700100489"),
               other_cols = 2:3)
               
# Rename output columns
rarefy_obs(x, "tax_data", cols = c("700035949", "700097855", "700100489"),
               out_names = c("a", "b", "c"))
</code></pre>

<hr>
<h2 id='read_fasta'>Read a FASTA file</h2><span id='topic+read_fasta'></span>

<h3>Description</h3>

<p>Reads a FASTA file. This is the FASTA parser for metacoder. It simply tries
to read a FASTA file into a named character vector with minimal fuss. It does
not do any checks for valid characters etc. Other FASTA parsers you might
want to consider include <code><a href="ape.html#topic+read.FASTA">read.FASTA</a></code> or
<code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fasta(file_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_fasta_+3A_file_path">file_path</code></td>
<td>
<p>(<code>character</code> of length 1) The path to a file to read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named <code>character</code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get example FASTA file
fasta_path &lt;- system.file(file.path("extdata", "silva_subset.fa"),
                          package = "metacoder")

# Read fasta file
my_seqs &lt;- read_fasta(fasta_path)

</code></pre>

<hr>
<h2 id='read_lines_apply'>Apply a function to chunks of a file</h2><span id='topic+read_lines_apply'></span>

<h3>Description</h3>

<p>Reads a file in chunks, applies a function to each of them, and returns to results of the function calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_lines_apply(
  file_path,
  func,
  buffer_size = 1000,
  simplify = FALSE,
  skip = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_lines_apply_+3A_file_path">file_path</code></td>
<td>
<p>(<code>character</code> of length 1) The path to a file to read.</p>
</td></tr>
<tr><td><code id="read_lines_apply_+3A_func">func</code></td>
<td>
<p>(<code>function</code>) The function to run on each chunk of the file.</p>
</td></tr>
<tr><td><code id="read_lines_apply_+3A_buffer_size">buffer_size</code></td>
<td>
<p>(<code>numeric</code> of length 1) The number of lines in each chunk</p>
</td></tr>
<tr><td><code id="read_lines_apply_+3A_simplify">simplify</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code>, then the result is simplified to a vector.</p>
</td></tr>
<tr><td><code id="read_lines_apply_+3A_skip">skip</code></td>
<td>
<p>(<code>numeric</code> of length 1) Where to start reading the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> of results of <code>func</code>
</p>

<hr>
<h2 id='remove_redundant_names'>Remove redundant parts of taxon names</h2><span id='topic+remove_redundant_names'></span>

<h3>Description</h3>

<p>Remove the names of parent taxa in the beginning of their children's names in a <code>taxonomy</code> or <code>taxmap</code> object.
This is useful for removing genus names in species binomials.
</p>
<pre>
obj$remove_redundant_names()
remove_redundant_names(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_redundant_names_+3A_obj">obj</code></td>
<td>
<p>A <code>taxonomy</code> or <code>taxmap</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>taxonomy</code> or <code>taxmap</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Remove genus named from species taxa
species_data &lt;- c("Carnivora;Felidae;Panthera;Panthera leo",
                  "Carnivora;Felidae;Panthera;Panthera tigris",
                  "Carnivora;Ursidae;Ursus;Ursus americanus")
obj &lt;-  parse_tax_data(species_data, class_sep = ";")
remove_redundant_names(obj)
</code></pre>

<hr>
<h2 id='replace_taxon_ids'>Replace taxon ids</h2><span id='topic+replace_taxon_ids'></span>

<h3>Description</h3>

<p>Replace taxon ids in a [taxmap()] or [taxonomy()] object.
</p>
<pre>
obj$replace_taxon_ids(new_ids)
replace_taxon_ids(obj, new_ids)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_taxon_ids_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
<tr><td><code id="replace_taxon_ids_+3A_new_ids">new_ids</code></td>
<td>
<p>A vector of new ids, one per taxon. They must be unique and in
the same order as the corresponding ids in 'obj$taxon_ids()'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A [taxonomy()] or [taxmap()] object with new taxon ids
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Replace taxon IDs with numbers
replace_taxon_ids(ex_taxmap, seq_len(length(ex_taxmap$taxa)))

# Make taxon IDs capital letters
replace_taxon_ids(ex_taxmap, toupper(taxon_ids(ex_taxmap)))

</code></pre>

<hr>
<h2 id='repo_url'>Return github url</h2><span id='topic+repo_url'></span>

<h3>Description</h3>

<p>Return github url
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repo_url()
</code></pre>

<hr>
<h2 id='rescale'>Rescale numeric vector to have specified minimum and maximum.</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>Rescale numeric vector to have specified minimum and maximum, but allow for hard boundaries.
It is a slightly modified version of scales::rescale, incorporating scales::zero_range, both by Hadley Wickham used under the conditions of the MIT license.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(
  x,
  to = c(0, 1),
  from = range(x, na.rm = TRUE, finite = TRUE),
  hard_bounds = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>
<p>values to rescale</p>
</td></tr>
<tr><td><code id="rescale_+3A_to">to</code></td>
<td>
<p>range to scale to</p>
</td></tr>
<tr><td><code id="rescale_+3A_from">from</code></td>
<td>
<p>range of values the x could have been</p>
</td></tr>
<tr><td><code id="rescale_+3A_hard_bounds">hard_bounds</code></td>
<td>
<p>If <code>TRUE</code>, all values will be forced into the range of <code>to</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rev_comp'>Revere complement sequences</h2><span id='topic+rev_comp'></span>

<h3>Description</h3>

<p>Make the reverse complement of one or more sequences stored as a character
vector. This is a wrapper for <code><a href="seqinr.html#topic+comp">comp</a></code> for character
vectors instead of lists of character vectors with one value per letter.
IUPAC ambiguity codes are handled and the upper/lower case is preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_comp(seqs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rev_comp_+3A_seqs">seqs</code></td>
<td>
<p>A character vector with one element per sequence.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other sequence transformations: 
<code><a href="#topic+complement">complement</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rev_comp(c("aagtgGGTGaa", "AAGTGGT"))

</code></pre>

<hr>
<h2 id='reverse'>Reverse sequences</h2><span id='topic+reverse'></span>

<h3>Description</h3>

<p>Find the reverse of one or more sequences stored as a character
vector. This is a wrapper for <code><a href="base.html#topic+rev">rev</a></code> for character
vectors instead of lists of character vectors with one value per letter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse(seqs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_+3A_seqs">seqs</code></td>
<td>
<p>A character vector with one element per sequence.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other sequence transformations: 
<code><a href="#topic+complement">complement</a>()</code>,
<code><a href="#topic+rev_comp">rev_comp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
reverse(c("aagtgGGTGaa", "AAGTGGT"))

</code></pre>

<hr>
<h2 id='roots'>Get root taxa</h2><span id='topic+roots'></span>

<h3>Description</h3>

<p>Return the root taxa for a [taxonomy()] or [taxmap()] object. Can also be used to
get the roots of a subset of taxa.
</p>
<pre>
obj$roots(subset = NULL, value = "taxon_indexes")
roots(obj, subset = NULL, value = "taxon_indexes")</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roots_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="roots_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to find roots for.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="roots_+3A_value">value</code></td>
<td>
<p>What data to return. This is usually the name of column in a
table in 'obj$data'. Any result of 'all_names(obj)' can be used, but it
usually only makes sense to data that corresponds to taxa 1:1, such as
[taxon_ranks()]. By default, taxon indexes are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'character'
</p>


<h3>See Also</h3>

<p>Other taxonomy indexing functions: 
<code><a href="#topic+branches">branches</a>()</code>,
<code><a href="#topic+internodes">internodes</a>()</code>,
<code><a href="#topic+leaves">leaves</a>()</code>,
<code><a href="#topic+stems">stems</a>()</code>,
<code><a href="#topic+subtaxa">subtaxa</a>()</code>,
<code><a href="#topic+supertaxa">supertaxa</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return indexes of root taxa
roots(ex_taxmap)

# Return indexes for a subset of taxa
roots(ex_taxmap, subset = 2:17)

# Return something besides taxon indexes
roots(ex_taxmap, value = "taxon_names")

</code></pre>

<hr>
<h2 id='run_primersearch'>Execute EMBOSS Primersearch</h2><span id='topic+run_primersearch'></span>

<h3>Description</h3>

<p>Execute EMBOSS Primersearch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_primersearch(
  seq_path,
  primer_path,
  mismatch = 5,
  output_path = tempfile(),
  program_path = "primersearch",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_primersearch_+3A_seq_path">seq_path</code></td>
<td>
<p>A character vector of length 1. The path to the fasta file containing reference
sequences to search for primer matches in.</p>
</td></tr>
<tr><td><code id="run_primersearch_+3A_primer_path">primer_path</code></td>
<td>
<p>A character vector of length 1. The path to the file containing primer pairs
to match. The file should be whitespace-delimited with 3 columns: primer name, first primer
sequence, and second primer sequence.</p>
</td></tr>
<tr><td><code id="run_primersearch_+3A_mismatch">mismatch</code></td>
<td>
<p>An integer vector of length 1. The percentage of mismatches allowed.</p>
</td></tr>
<tr><td><code id="run_primersearch_+3A_output_path">output_path</code></td>
<td>
<p>A character vector of length 1. Where the output of primersearch is saved.</p>
</td></tr>
<tr><td><code id="run_primersearch_+3A_program_path">program_path</code></td>
<td>
<p>A character vector of length 1. The location of the primersearch binary.
Ideally, it should be in your system's search path.</p>
</td></tr>
<tr><td><code id="run_primersearch_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code>primersearch</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The command generated as a character vector of length 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parse_primersearch">parse_primersearch</a></code>
</p>

<hr>
<h2 id='sample_frac_obs'>Sample a proportion of observations from [taxmap()]</h2><span id='topic+sample_frac_obs'></span>

<h3>Description</h3>

<p>Randomly sample some proportion of observations from a [taxmap()]
object. Weights can be specified for observations or their taxa. See
[dplyr::sample_frac()] for the inspiration for this function. Calling the
function using the 'obj$sample_frac_obs(...)' style edits &quot;obj&quot; in place, unlike
most R functions. However, calling the function using the 'sample_frac_obs(obj,
...)&lsquo; imitates R&rsquo;s traditional copy-on-modify semantics, so &quot;obj&quot; would not
be changed; instead a changed version would be returned, like most R
functions.
</p>
<pre>
obj$sample_frac_obs(data, size, replace = FALSE,
  taxon_weight = NULL, obs_weight = NULL,
  use_supertaxa = TRUE, collapse_func = mean, ...)
sample_frac_obs(obj, data, size, replace = FALSE,
  taxon_weight = NULL, obs_weight = NULL,
  use_supertaxa = TRUE, collapse_func = mean, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_frac_obs_+3A_obj">obj</code></td>
<td>
<p>([taxmap()]) The object to sample from.</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_data">data</code></td>
<td>
<p>Dataset names, indexes, or a logical vector that indicates which datasets in
'obj$data' to sample. If multiple datasets are sample at once, then they must be the same
length.</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_size">size</code></td>
<td>
<p>('numeric' of length 1) The proportion of observations to
sample.</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_replace">replace</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', sample with
replacement.</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_taxon_weight">taxon_weight</code></td>
<td>
<p>('numeric') Non-negative sampling weights of each
taxon. If 'use_supertaxa' is 'TRUE', the weights for each taxon
in an observation's classification are supplied to 'collapse_func' to
get the observation weight. If 'obs_weight' is also specified, the two
weights are multiplied (after 'taxon_weight' for each observation is
calculated).</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_obs_weight">obs_weight</code></td>
<td>
<p>('numeric') Sampling weights of each observation.  If
'taxon_weight' is also specified, the two weights are multiplied
(after 'taxon_weight' for each observation is calculated).</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_use_supertaxa">use_supertaxa</code></td>
<td>
<p>('logical' or 'numeric' of length 1) Affects how the
'taxon_weight' is used. If 'TRUE', the weights for each taxon in
an observation's classification are multiplied to get the observation
weight. If 'FALSE' just the taxonomic level the observation is assign to it
considered. Positive numbers indicate the number of ranks above the
each taxon to use. '0' is equivalent to 'FALSE'. Negative numbers
are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_collapse_func">collapse_func</code></td>
<td>
<p>('function' of length 1) If 'taxon_weight'
option is used and 'supertaxa' is 'TRUE', the weights for each
taxon in an observation's classification are supplied to
'collapse_func' to get the observation weight. This function should
take  numeric vector and return a single number.</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_...">...</code></td>
<td>
<p>Additional options are passed to [filter_obs()].</p>
</td></tr>
<tr><td><code id="sample_frac_obs_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample half of the rows fram a table
sample_frac_obs(ex_taxmap, "info", 0.5)

# Sample multiple datasets at once
sample_frac_obs(ex_taxmap, c("info", "phylopic_ids", "foods"), 0.5)

</code></pre>

<hr>
<h2 id='sample_frac_taxa'>Sample a proportion of taxa from [taxonomy()] or [taxmap()]</h2><span id='topic+sample_frac_taxa'></span>

<h3>Description</h3>

<p>Randomly sample some proportion of taxa from a [taxonomy()] or [taxmap()]
object. Weights can be specified for taxa or the observations assigned to
them. See
[dplyr::sample_frac()] for the inspiration for this function.
</p>
<pre>
obj$sample_frac_taxa(size, taxon_weight = NULL,
  obs_weight = NULL, obs_target = NULL,
  use_subtaxa = TRUE, collapse_func = mean, ...)
sample_frac_taxa(obj, size, taxon_weight = NULL,
  obs_weight = NULL, obs_target = NULL,
  use_subtaxa = TRUE, collapse_func = mean, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_frac_taxa_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()]) The object to sample from.</p>
</td></tr>
<tr><td><code id="sample_frac_taxa_+3A_size">size</code></td>
<td>
<p>('numeric' of length 1) The proportion of taxa to sample.</p>
</td></tr>
<tr><td><code id="sample_frac_taxa_+3A_taxon_weight">taxon_weight</code></td>
<td>
<p>('numeric') Non-negative sampling weights of each
taxon. If 'obs_weight' is also specified, the two weights are
multiplied (after 'obs_weight' for each taxon is calculated).</p>
</td></tr>
<tr><td><code id="sample_frac_taxa_+3A_obs_weight">obs_weight</code></td>
<td>
<p>('numeric')  This option only applies to [taxmap()]
objects. Sampling weights of each observation. The weights for each
observation assigned to a given taxon are supplied to 'collapse_func' to
get the taxon weight. If 'use_subtaxa' is 'TRUE' then the observations
assigned to every subtaxa are also used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own. If
'taxon_weight' is also specified, the two weights are multiplied (after
'obs_weight' for each observation is calculated). 'obs_target' must be used
with this option.</p>
</td></tr>
<tr><td><code id="sample_frac_taxa_+3A_obs_target">obs_target</code></td>
<td>
<p>('character' of length 1)  This option only applies to
[taxmap()] objects. The name of the data set in 'obj$data' that values in
'obs_weight' corresponds to. Must be used when 'obs_weight' is used.</p>
</td></tr>
<tr><td><code id="sample_frac_taxa_+3A_use_subtaxa">use_subtaxa</code></td>
<td>
<p>('logical' or 'numeric' of length 1) Affects how the
'obs_weight' option is used. If 'TRUE', the weights for each taxon in an
observation's classification are multiplied to get the observation weight.
If 'TRUE' just the taxonomic level the observation is assign to it
considered. Positive numbers indicate the number of ranks below the target
taxa to return. '0' is equivalent to 'FALSE'. Negative numbers are
equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="sample_frac_taxa_+3A_collapse_func">collapse_func</code></td>
<td>
<p>('function' of length 1) If 'taxon_weight' is
used and 'supertaxa' is 'TRUE', the weights for each taxon in an
observation's classification are supplied to 'collapse_func' to get
the observation weight. This function should take  numeric vector and
return a single number.</p>
</td></tr>
<tr><td><code id="sample_frac_taxa_+3A_...">...</code></td>
<td>
<p>Additional options are passed to [filter_taxa()].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxonomy()] or [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample half of the taxa
sample_frac_taxa(ex_taxmap, 0.5, supertaxa = TRUE)

</code></pre>

<hr>
<h2 id='sample_n_obs'>Sample n observations from [taxmap()]</h2><span id='topic+sample_n_obs'></span>

<h3>Description</h3>

<p>Randomly sample some number of observations from a [taxmap()] object. Weights
can be specified for observations or the taxa they are classified by. Any
variable name that appears in [all_names()] can be used as if it was a vector
on its own. See [dplyr::sample_n()] for the inspiration for this function.
Calling the function using the 'obj$sample_n_obs(...)' style edits &quot;obj&quot; in
place, unlike most R functions. However, calling the function using the
&lsquo;sample_n_obs(obj, ...)' imitates R&rsquo;s traditional copy-on-modify semantics,
so &quot;obj&quot; would not be changed; instead a changed version would be returned,
like most R functions.
</p>
<pre>
obj$sample_n_obs(data, size, replace = FALSE,
  taxon_weight = NULL, obs_weight = NULL,
  use_supertaxa = TRUE, collapse_func = mean, ...)
sample_n_obs(obj, data, size, replace = FALSE,
  taxon_weight = NULL, obs_weight = NULL,
  use_supertaxa = TRUE, collapse_func = mean, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_n_obs_+3A_obj">obj</code></td>
<td>
<p>([taxmap()]) The object to sample from.</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_data">data</code></td>
<td>
<p>Dataset names, indexes, or a logical vector that indicates which datasets in
'obj$data' to sample. If multiple datasets are sampled at once, then they must be the same
length.</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_size">size</code></td>
<td>
<p>('numeric' of length 1) The number of observations to
sample.</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_replace">replace</code></td>
<td>
<p>('logical' of length 1) If 'TRUE', sample with
replacement.</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_taxon_weight">taxon_weight</code></td>
<td>
<p>('numeric') Non-negative sampling weights of each
taxon. If 'use_supertaxa' is 'TRUE', the weights for each taxon
in an observation's classification are supplied to 'collapse_func' to
get the observation weight. If 'obs_weight' is also specified, the two
weights are multiplied (after 'taxon_weight' for each observation is
calculated).</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_obs_weight">obs_weight</code></td>
<td>
<p>('numeric') Sampling weights of each observation.  If
'taxon_weight' is also specified, the two weights are multiplied (after
'taxon_weight' for each observation is calculated).</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_use_supertaxa">use_supertaxa</code></td>
<td>
<p>('logical' or 'numeric' of length 1) Affects how the
'taxon_weight' is used. If 'TRUE', the weights for each taxon in an
observation's classification are multiplied to get the observation weight.
Otherwise, just the taxonomic level the observation is assign to it
considered. If 'TRUE', use all supertaxa. Positive numbers indicate the
number of ranks above each taxon to use. '0' is equivalent to 'FALSE'.
Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_collapse_func">collapse_func</code></td>
<td>
<p>('function' of length 1) If 'taxon_weight' option is
used and 'supertaxa' is 'TRUE', the weights for each
taxon in an observation's classification are supplied to
'collapse_func' to get the observation weight. This function should
take  numeric vector and return a single number.</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_...">...</code></td>
<td>
<p>Additional options are passed to [filter_obs()].</p>
</td></tr>
<tr><td><code id="sample_n_obs_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 2 rows without replacement
sample_n_obs(ex_taxmap, "info", 2)
sample_n_obs(ex_taxmap, "foods", 2)

# Sample with replacement
sample_n_obs(ex_taxmap, "info", 10, replace = TRUE)

# Sample some rows for often then others
sample_n_obs(ex_taxmap, "info", 3, obs_weight = n_legs)

# Sample multiple datasets at once
sample_n_obs(ex_taxmap, c("info", "phylopic_ids", "foods"), 3)

</code></pre>

<hr>
<h2 id='sample_n_taxa'>Sample n taxa from [taxonomy()] or [taxmap()]</h2><span id='topic+sample_n_taxa'></span>

<h3>Description</h3>

<p>Randomly sample some number of taxa from a [taxonomy()] or [taxmap()] object.
Weights can be specified for taxa or the observations assigned to them. See
[dplyr::sample_n()] for the inspiration for this function.
</p>
<pre>
obj$sample_n_taxa(size, taxon_weight = NULL,
  obs_weight = NULL, obs_target = NULL,
  use_subtaxa = TRUE, collapse_func = mean, ...)
sample_n_taxa(obj, size, taxon_weight = NULL,
  obs_weight = NULL, obs_target = NULL,
  use_subtaxa = TRUE, collapse_func = mean, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_n_taxa_+3A_obj">obj</code></td>
<td>
<p>([taxonomy()] or [taxmap()]) The object to sample from.</p>
</td></tr>
<tr><td><code id="sample_n_taxa_+3A_size">size</code></td>
<td>
<p>('numeric' of length 1) The number of taxa to sample.</p>
</td></tr>
<tr><td><code id="sample_n_taxa_+3A_taxon_weight">taxon_weight</code></td>
<td>
<p>('numeric') Non-negative sampling weights of each
taxon. If 'obs_weight' is also specified, the two weights are
multiplied (after 'obs_weight' for each taxon is calculated).</p>
</td></tr>
<tr><td><code id="sample_n_taxa_+3A_obs_weight">obs_weight</code></td>
<td>
<p>('numeric')  This option only applies to [taxmap()]
objects. Sampling weights of each observation. The weights for each
observation assigned to a given taxon are supplied to 'collapse_func' to
get the taxon weight. If 'use_subtaxa' is 'TRUE' then the observations
assigned to every subtaxa are also used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own. If
'taxon_weight' is also specified, the two weights are multiplied (after
'obs_weight' for each observation is calculated). 'obs_target' must be used
with this option.</p>
</td></tr>
<tr><td><code id="sample_n_taxa_+3A_obs_target">obs_target</code></td>
<td>
<p>('character' of length 1)  This option only applies to
[taxmap()] objects. The name of the data set in 'obj$data' that values in
'obs_weight' corresponds to. Must be used when 'obs_weight' is used.</p>
</td></tr>
<tr><td><code id="sample_n_taxa_+3A_use_subtaxa">use_subtaxa</code></td>
<td>
<p>('logical' or 'numeric' of length 1) Affects how the
'obs_weight' option is used. If 'TRUE', the weights for each taxon in an
observation's classification are multiplied to get the observation weight.
If 'FALSE' just the taxonomic level the observation is assign to it
considered. Positive numbers indicate the number of ranks below the each
taxon to use. '0' is equivalent to 'FALSE'. Negative numbers are equivalent
to 'TRUE'.</p>
</td></tr>
<tr><td><code id="sample_n_taxa_+3A_collapse_func">collapse_func</code></td>
<td>
<p>('function' of length 1) If 'taxon_weight' is used and
&lsquo;supertaxa' is 'TRUE', the weights for each taxon in an observation&rsquo;s
classification are supplied to 'collapse_func' to get the observation
weight. This function should take  numeric vector and return a single
number.</p>
</td></tr>
<tr><td><code id="sample_n_taxa_+3A_...">...</code></td>
<td>
<p>Additional options are passed to [filter_taxa()].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxonomy()] or [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Randomly sample three taxa
sample_n_taxa(ex_taxmap, 3)

# Include supertaxa
sample_n_taxa(ex_taxmap, 3, supertaxa = TRUE)

# Include subtaxa
sample_n_taxa(ex_taxmap, 1, subtaxa = TRUE)

# Sample some taxa more often then others
sample_n_taxa(ex_taxmap, 3, supertaxa = TRUE,
              obs_weight = n_legs, obs_target = "info")

</code></pre>

<hr>
<h2 id='scale_bar_coords'>Make scale bar division</h2><span id='topic+scale_bar_coords'></span>

<h3>Description</h3>

<p>Make scale bar division
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_bar_coords(x1, x2, y1, y2, color, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_bar_coords_+3A_x1">x1</code></td>
<td>
<p>(<code>numeric</code> of length 1) x of top right</p>
</td></tr>
<tr><td><code id="scale_bar_coords_+3A_x2">x2</code></td>
<td>
<p>(<code>numeric</code> of length 1) x of bottom right</p>
</td></tr>
<tr><td><code id="scale_bar_coords_+3A_y1">y1</code></td>
<td>
<p>(<code>numeric</code> of length 1) y of top right</p>
</td></tr>
<tr><td><code id="scale_bar_coords_+3A_y2">y2</code></td>
<td>
<p>(<code>numeric</code> of length 1) y of bottom right</p>
</td></tr>
<tr><td><code id="scale_bar_coords_+3A_color">color</code></td>
<td>
</td></tr>
<tr><td><code id="scale_bar_coords_+3A_group">group</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>

<hr>
<h2 id='select_labels'>Pick labels to show</h2><span id='topic+select_labels'></span>

<h3>Description</h3>

<p>Pick labels to show based off a column name to sort by and a maximum number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_labels(my_data, label_max, sort_by_column, label_column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_labels_+3A_my_data">my_data</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="select_labels_+3A_label_max">label_max</code></td>
<td>
<p><code>numeric</code> of length 1</p>
</td></tr>
<tr><td><code id="select_labels_+3A_sort_by_column">sort_by_column</code></td>
<td>
<p><code>character</code> of length 1; the name of a column in <code>my_data</code></p>
</td></tr>
<tr><td><code id="select_labels_+3A_label_column">label_column</code></td>
<td>
<p><code>character</code> of length 1; the name of a column in <code>my_data</code>
containing labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> IDs of rows with labels to show
</p>

<hr>
<h2 id='select_obs'>Subset columns in a [taxmap()] object</h2><span id='topic+select_obs'></span>

<h3>Description</h3>

<p>Subsets columns in a [taxmap()] object. Takes and returns a
[taxmap()] object. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own. See
[dplyr::select()] for the inspiration for this function and more
information. Calling the function using the 'obj$select_obs(...)' style
edits &quot;obj&quot; in place, unlike most R functions. However, calling the function
using the &lsquo;select_obs(obj, ...)' imitates R&rsquo;s traditional copy-on-modify
semantics, so &quot;obj&quot; would not be changed; instead a changed version would be
returned, like most R functions.
</p>
<pre>
obj$select_obs(data, ...)
select_obs(obj, data, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_obs_+3A_obj">obj</code></td>
<td>
<p>An object of type [taxmap()]</p>
</td></tr>
<tr><td><code id="select_obs_+3A_data">data</code></td>
<td>
<p>Dataset names, indexes, or a logical vector that indicates which tables in
'obj$data' to subset columns in. Multiple tables can be subset at once.</p>
</td></tr>
<tr><td><code id="select_obs_+3A_...">...</code></td>
<td>
<p>One or more column names to return in the new object. Each can be
one of two things: </p>
 <dl>
<dt>expression with unquoted column
name</dt><dd><p>The name of a column in the dataset typed as if it was
a variable on its own.</p>
</dd> <dt>'numeric'</dt><dd><p>Indexes of columns in
the dataset</p>
</dd> </dl>
<p> To match column names with a character vector,
use 'matches(&quot;my_col_name&quot;)'. To match a logical vector, convert it to
a column index using 'which'.</p>
</td></tr>
<tr><td><code id="select_obs_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+transmute_obs">transmute_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Selecting a column by name
select_obs(ex_taxmap, "info", dangerous)

# Selecting a column by index
select_obs(ex_taxmap, "info", 3)

# Selecting a column by regular expressions
select_obs(ex_taxmap, "info", matches("^n"))

</code></pre>

<hr>
<h2 id='simplify'>List to vector of unique elements</h2><span id='topic+simplify'></span>

<h3>Description</h3>

<p>Implements the 'simplify' option in many functions like [supertaxa()].
Returns unique name-value pairs if all vectors are named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify(input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplify_+3A_input">input</code></td>
<td>
<p>A list of vectors</p>
</td></tr>
</table>

<hr>
<h2 id='split_by_level'>Splits a taxonomy at a specific level or rank</h2><span id='topic+split_by_level'></span>

<h3>Description</h3>

<p>Breaks one taxonomy into multiple, each with a root of a specified distance from the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by_level(taxa, parents, level, rank = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_by_level_+3A_taxa">taxa</code></td>
<td>
<p>(<code>character</code>) Unique taxon IDs for every possible taxon.</p>
</td></tr>
<tr><td><code id="split_by_level_+3A_parents">parents</code></td>
<td>
<p>(<code>character</code>) Unique taxon IDs for the supertaxa of every possible taxon.</p>
</td></tr>
<tr><td><code id="split_by_level_+3A_level">level</code></td>
<td>
<p>(<code>character</code> or <code>numeric</code> of length 1)</p>
</td></tr>
<tr><td><code id="split_by_level_+3A_rank">rank</code></td>
<td>
<p>(<code>character</code>) The rank designation (e.g. &quot;genus&quot;) corresponding to each observation in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of taxon id <code>character</code> vectors. 
<code>taxa</code>.
</p>

<hr>
<h2 id='starts_with'>dplyr select_helpers</h2><span id='topic+starts_with'></span>

<h3>Description</h3>

<p>dplyr select_helpers
</p>
<p>dplyr select_helpers
</p>

<hr>
<h2 id='startup_msg'>Return startup message</h2><span id='topic+startup_msg'></span>

<h3>Description</h3>

<p>Return startup message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startup_msg()
</code></pre>

<hr>
<h2 id='stems'>Get stem taxa</h2><span id='topic+stems'></span>

<h3>Description</h3>

<p>Return the stem taxa for a [taxonomy()] or a [taxmap()]
object. Stem taxa are all those from the roots to the first taxon with more
than one subtaxon.
</p>
<pre>
obj$stems(subset = NULL, simplify = FALSE,
  value = "taxon_indexes", exclude_leaves = FALSE)
stems(obj, subset = NULL, simplify = FALSE,
  value = "taxon_indexes", exclude_leaves = FALSE)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stems_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="stems_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to find stems for.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="stems_+3A_value">value</code></td>
<td>
<p>What data to return. This is usually the name of column in a
table in 'obj$data'. Any result of 'all_names(obj)' can be used, but it
usually only makes sense to data that corresponds to taxa 1:1, such as
[taxon_ranks()]. By default, taxon indexes are returned.</p>
</td></tr>
<tr><td><code id="stems_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', then combine all the results
into a single vector of unique values.</p>
</td></tr>
<tr><td><code id="stems_+3A_exclude_leaves">exclude_leaves</code></td>
<td>
<p>('logical') If 'TRUE', the do not include
taxa with no subtaxa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'character'
</p>


<h3>See Also</h3>

<p>Other taxonomy indexing functions: 
<code><a href="#topic+branches">branches</a>()</code>,
<code><a href="#topic+internodes">internodes</a>()</code>,
<code><a href="#topic+leaves">leaves</a>()</code>,
<code><a href="#topic+roots">roots</a>()</code>,
<code><a href="#topic+subtaxa">subtaxa</a>()</code>,
<code><a href="#topic+supertaxa">supertaxa</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return indexes of stem taxa
stems(ex_taxmap)

# Return indexes for a subset of taxa
stems(ex_taxmap, subset = 2:17)

# Return something besides taxon indexes
stems(ex_taxmap, value = "taxon_names")

# Return a vector instead of a list
stems(ex_taxmap, value = "taxon_names", simplify = TRUE)

</code></pre>

<hr>
<h2 id='subtaxa'>Get subtaxa</h2><span id='topic+subtaxa'></span>

<h3>Description</h3>

<p>Return data for the subtaxa of each taxon in an [taxonomy()] or [taxmap()]
object.
</p>
<pre>
obj$subtaxa(subset = NULL, recursive = TRUE,
  simplify = FALSE, include_input = FALSE, value = "taxon_indexes")
subtaxa(obj, subset = NULL, recursive = TRUE,
  simplify = FALSE, include_input = FALSE, value = "taxon_indexes")</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subtaxa_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="subtaxa_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to find subtaxa for.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="subtaxa_+3A_recursive">recursive</code></td>
<td>
<p>('logical' or 'numeric') If 'FALSE', only return the subtaxa
one rank below the target taxa. If 'TRUE', return all the subtaxa of every
subtaxa, etc. Positive numbers indicate the number of ranks below the
immediate subtaxa to return. '1' is equivalent to 'FALSE'. Negative numbers
are equivalent to 'TRUE'. Since the algorithm is optimized for traversing
all of large trees, 'numeric' values greater than 0 for this option
actually take slightly longer to compute than either TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="subtaxa_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', then combine all the results
into a single vector of unique values.</p>
</td></tr>
<tr><td><code id="subtaxa_+3A_include_input">include_input</code></td>
<td>
<p>('logical') If 'TRUE', the input taxa are
included in the output</p>
</td></tr>
<tr><td><code id="subtaxa_+3A_value">value</code></td>
<td>
<p>What data to return. This is usually the name of column in a
table in 'obj$data'. Any result of [all_names()] can be used, but it
usually only makes sense to data that corresponds to taxa 1:1, such as
[taxon_ranks()]. By default, taxon indexes are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'simplify = FALSE', then a list of vectors are returned
corresponding to the 'target' argument. If 'simplify = TRUE',
then the unique values are returned in a single vector.
</p>


<h3>See Also</h3>

<p>Other taxonomy indexing functions: 
<code><a href="#topic+branches">branches</a>()</code>,
<code><a href="#topic+internodes">internodes</a>()</code>,
<code><a href="#topic+leaves">leaves</a>()</code>,
<code><a href="#topic+roots">roots</a>()</code>,
<code><a href="#topic+stems">stems</a>()</code>,
<code><a href="#topic+supertaxa">supertaxa</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># return the indexes for subtaxa for each taxon
subtaxa(ex_taxmap)

# Only return data for some taxa using taxon indexes
subtaxa(ex_taxmap, subset = 1:3)

# Only return data for some taxa using taxon ids
subtaxa(ex_taxmap, subset = c("d", "e"))

# Only return data for some taxa using logical tests
subtaxa(ex_taxmap, subset = taxon_ranks == "genus")

# Only return subtaxa one level below
subtaxa(ex_taxmap, recursive = FALSE)

# Only return subtaxa some number of ranks below
subtaxa(ex_taxmap, recursive = 2)

# Return something besides taxon indexes
subtaxa(ex_taxmap, value = "taxon_names")
</code></pre>

<hr>
<h2 id='subtaxa_apply'>Apply function to subtaxa of each taxon</h2><span id='topic+subtaxa_apply'></span>

<h3>Description</h3>

<p>Apply a function to the subtaxa for each taxon. This is similar
to using [subtaxa()] with [lapply()] or [sapply()].
</p>
<pre>
obj$subtaxa_apply(func, subset = NULL, recursive = TRUE,
  simplify = FALSE, include_input = FALSE, value = "taxon_indexes", ...)
subtaxa_apply(obj, func, subset = NULL, recursive = TRUE,
  simplify = FALSE, include_input = FALSE, value = "taxon_indexes", ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subtaxa_apply_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="subtaxa_apply_+3A_func">func</code></td>
<td>
<p>('function') The function to apply.</p>
</td></tr>
<tr><td><code id="subtaxa_apply_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to use.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="subtaxa_apply_+3A_recursive">recursive</code></td>
<td>
<p>('logical' or 'numeric') If 'FALSE', only return the
subtaxa one rank below the target taxa. If 'TRUE', return all the
subtaxa of every subtaxa, etc. Positive numbers indicate the number of
recursions (i.e. number of ranks below the target taxon to return). '1' is
equivalent to 'FALSE'. Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="subtaxa_apply_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', then combine all the results into a
single vector of unique values.</p>
</td></tr>
<tr><td><code id="subtaxa_apply_+3A_include_input">include_input</code></td>
<td>
<p>('logical') If 'TRUE', the input taxa are included in
the output</p>
</td></tr>
<tr><td><code id="subtaxa_apply_+3A_value">value</code></td>
<td>
<p>What data to give to the function. Any result of
'all_names(obj)' can be used, but it usually only makes sense to use data
that has an associated taxon id.</p>
</td></tr>
<tr><td><code id="subtaxa_apply_+3A_...">...</code></td>
<td>
<p>Extra arguments are passed to the function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Count number of subtaxa in each taxon
subtaxa_apply(ex_taxmap, length)

# Paste all the subtaxon names for each taxon
subtaxa_apply(ex_taxmap, value = "taxon_names",
              recursive = FALSE, paste0, collapse = ", ")
</code></pre>

<hr>
<h2 id='supertaxa'>Get all supertaxa of a taxon</h2><span id='topic+supertaxa'></span>

<h3>Description</h3>

<p>Return data for supertaxa (i.e. all taxa the target
taxa are a part of) of each taxon in a [taxonomy()] or [taxmap()] object.
</p>
<pre>
obj$supertaxa(subset = NULL, recursive = TRUE,
  simplify = FALSE, include_input = FALSE,
  value = "taxon_indexes", na = FALSE)
supertaxa(obj, subset = NULL, recursive = TRUE,
  simplify = FALSE, include_input = FALSE,
  value = "taxon_indexes", na = FALSE)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supertaxa_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="supertaxa_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to find supertaxa for.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="supertaxa_+3A_recursive">recursive</code></td>
<td>
<p>('logical' or 'numeric') If 'FALSE', only return the
supertaxa one rank above the target taxa. If 'TRUE', return all the
supertaxa of every supertaxa, etc. Positive numbers indicate the number of
recursions (i.e. number of ranks above the target taxon to return). '1' is
equivalent to 'FALSE'. Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="supertaxa_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', then combine all the results into a
single vector of unique values.</p>
</td></tr>
<tr><td><code id="supertaxa_+3A_include_input">include_input</code></td>
<td>
<p>('logical') If 'TRUE', the input taxa are included in
the output</p>
</td></tr>
<tr><td><code id="supertaxa_+3A_value">value</code></td>
<td>
<p>What data to return. Any result of [all_names()] can be used, but it
usually only makes sense to use data that has an associated taxon id.</p>
</td></tr>
<tr><td><code id="supertaxa_+3A_na">na</code></td>
<td>
<p>('logical') If 'TRUE', return 'NA' where information
is not available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'simplify = FALSE', then a list of vectors are returned
corresponding to the 'subset' argument. If 'simplify = TRUE',
then unique values are returned in a single vector.
</p>


<h3>See Also</h3>

<p>Other taxonomy indexing functions: 
<code><a href="#topic+branches">branches</a>()</code>,
<code><a href="#topic+internodes">internodes</a>()</code>,
<code><a href="#topic+leaves">leaves</a>()</code>,
<code><a href="#topic+roots">roots</a>()</code>,
<code><a href="#topic+stems">stems</a>()</code>,
<code><a href="#topic+subtaxa">subtaxa</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># return the indexes for supertaxa for each taxon
supertaxa(ex_taxmap)

# Only return data for some taxa using taxon indexes
supertaxa(ex_taxmap, subset = 1:3)

# Only return data for some taxa using taxon ids
supertaxa(ex_taxmap, subset = c("d", "e"))

# Only return data for some taxa using logical tests
supertaxa(ex_taxmap, subset = taxon_ranks == "species")

# Only return supertaxa one level above
supertaxa(ex_taxmap, recursive = FALSE)

# Only return supertaxa some number of ranks above
supertaxa(ex_taxmap, recursive = 2)

# Return something besides taxon indexes
supertaxa(ex_taxmap, value = "taxon_names")
</code></pre>

<hr>
<h2 id='supertaxa_apply'>Apply function to supertaxa of each taxon</h2><span id='topic+supertaxa_apply'></span>

<h3>Description</h3>

<p>Apply a function to the supertaxa for each taxon. This is similar
to using [supertaxa()] with [lapply()] or [sapply()].
</p>
<pre>
obj$supertaxa_apply(func, subset = NULL, recursive = TRUE,
  simplify = FALSE, include_input = FALSE, value = "taxon_indexes",
  na = FALSE, ...)
supertaxa_apply(obj, func, subset = NULL, recursive = TRUE,
  simplify = FALSE, include_input = FALSE, value = "taxon_indexes",
  na = FALSE, ....)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supertaxa_apply_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object containing taxon
information to be queried.</p>
</td></tr>
<tr><td><code id="supertaxa_apply_+3A_func">func</code></td>
<td>
<p>('function') The function to apply.</p>
</td></tr>
<tr><td><code id="supertaxa_apply_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes of taxa to use.
Default: All taxa in 'obj' will be used. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="supertaxa_apply_+3A_recursive">recursive</code></td>
<td>
<p>('logical' or 'numeric') If 'FALSE', only return the
supertaxa one rank above the target taxa. If 'TRUE', return all the
supertaxa of every supertaxa, etc. Positive numbers indicate the number of
recursions (i.e. number of ranks above the target taxon to return). '1' is
equivalent to 'FALSE'. Negative numbers are equivalent to 'TRUE'.</p>
</td></tr>
<tr><td><code id="supertaxa_apply_+3A_simplify">simplify</code></td>
<td>
<p>('logical') If 'TRUE', then combine all the results into a
single vector of unique values.</p>
</td></tr>
<tr><td><code id="supertaxa_apply_+3A_include_input">include_input</code></td>
<td>
<p>('logical') If 'TRUE', the input taxa are included in
the output</p>
</td></tr>
<tr><td><code id="supertaxa_apply_+3A_value">value</code></td>
<td>
<p>What data to give to the function. Any result of
'all_names(obj)' can be used, but it usually only makes sense to use data
that has an associated taxon id.</p>
</td></tr>
<tr><td><code id="supertaxa_apply_+3A_na">na</code></td>
<td>
<p>('logical') If 'TRUE', return 'NA' where information
is not available.</p>
</td></tr>
<tr><td><code id="supertaxa_apply_+3A_...">...</code></td>
<td>
<p>Extra arguments are passed to the function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Get number of supertaxa that each taxon is contained in
supertaxa_apply(ex_taxmap, length)

# Get classifications for each taxon
# Note; this can be done with `classifications()` easier
supertaxa_apply(ex_taxmap, paste, collapse = ";", include_input = TRUE,
                value = "taxon_names")

</code></pre>

<hr>
<h2 id='taxa'>A class for multiple taxon objects</h2><span id='topic+taxa'></span>

<h3>Description</h3>

<p>Stores one or more [taxon()] objects. This is just a thin wrapper for a list
of [taxon()] objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxa(..., .list = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxa_+3A_...">...</code></td>
<td>
<p>Any number of object of class [taxon()]</p>
</td></tr>
<tr><td><code id="taxa_+3A_.list">.list</code></td>
<td>
<p>An alternate to the '...' input. Any number of object of class
[taxon()]. Cannot be used with '...'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the documentation for the class called 'taxa'. If you are looking for
the documentation for the package as a whole: [taxa-package].
</p>


<h3>Value</h3>

<p>An 'R6Class' object of class 'Taxon'
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- taxon(
  name = taxon_name("Poa annua"),
  rank = taxon_rank("species"),
  id = taxon_id(93036)
))
taxa(a, a, a)

# a null set
x &lt;- taxon(NULL)
taxa(x, x, x)

# combo non-null and null
taxa(a, x, a)
</code></pre>

<hr>
<h2 id='taxmap'>Taxmap class</h2><span id='topic+taxmap'></span>

<h3>Description</h3>

<p>A class designed to store a taxonomy and associated information. This class
builds on the [taxonomy()] class. User defined data can be stored in the list
'obj$data', where 'obj' is a taxmap object. Data that is associated with taxa
can be manipulated in a variety of ways using functions like [filter_taxa()]
and [filter_obs()]. To associate the items of lists/vectors with taxa, name
them by [taxon_ids()]. For tables, add a column named 'taxon_id' that stores
[taxon_ids()].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxmap(..., .list = NULL, data = NULL, funcs = list(), named_by_rank = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxmap_+3A_...">...</code></td>
<td>
<p>Any number of object of class [hierarchy()] or character
vectors.</p>
</td></tr>
<tr><td><code id="taxmap_+3A_.list">.list</code></td>
<td>
<p>An alternate to the '...' input. Any number of object of class
[hierarchy()] or character vectors in a list. Cannot be used with '...'.</p>
</td></tr>
<tr><td><code id="taxmap_+3A_data">data</code></td>
<td>
<p>A list of tables with data associated with the taxa.</p>
</td></tr>
<tr><td><code id="taxmap_+3A_funcs">funcs</code></td>
<td>
<p>A named list of functions to include in the class. Referring to
the names of these in functions like [filter_taxa()] will execute the
function and return the results. If the function has at least one argument,
the taxmap object is passed to it.</p>
</td></tr>
<tr><td><code id="taxmap_+3A_named_by_rank">named_by_rank</code></td>
<td>
<p>('TRUE'/'FALSE') If  'TRUE' and the input is a list of
vectors with each vector named by ranks, include that rank info in the
output object, so it can be accessed by 'out$taxon_ranks()'. If 'TRUE',
taxa with different ranks, but the same name and location in the taxonomy,
will be considered different taxa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To initialize a 'taxmap' object with associated data sets, use the parsing
functions [parse_tax_data()], [lookup_tax_data()], and [extract_tax_data()].
</p>
<p>on initialize, function sorts the taxon list based on rank (if rank
information is available), see [ranks_ref] for the reference rank names and
orders
</p>


<h3>Value</h3>

<p>An 'R6Class' object of class [taxmap()]
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The code below shows how to contruct a taxmap object from scratch.
# Typically, taxmap objects would be the output of a parsing function,
#  not created from scratch, but this is for demostration purposes.

notoryctidae &lt;- taxon(
name = taxon_name("Notoryctidae"),
rank = taxon_rank("family"),
id = taxon_id(4479)
)
notoryctes &lt;- taxon(
  name = taxon_name("Notoryctes"),
  rank = taxon_rank("genus"),
  id = taxon_id(4544)
)
typhlops &lt;- taxon(
  name = taxon_name("typhlops"),
  rank = taxon_rank("species"),
  id = taxon_id(93036)
)
mammalia &lt;- taxon(
  name = taxon_name("Mammalia"),
  rank = taxon_rank("class"),
  id = taxon_id(9681)
)
felidae &lt;- taxon(
  name = taxon_name("Felidae"),
  rank = taxon_rank("family"),
  id = taxon_id(9681)
)
felis &lt;- taxon(
  name = taxon_name("Felis"),
  rank = taxon_rank("genus"),
  id = taxon_id(9682)
)
catus &lt;- taxon(
  name = taxon_name("catus"),
  rank = taxon_rank("species"),
  id = taxon_id(9685)
)
panthera &lt;- taxon(
  name = taxon_name("Panthera"),
  rank = taxon_rank("genus"),
  id = taxon_id(146712)
)
tigris &lt;- taxon(
  name = taxon_name("tigris"),
  rank = taxon_rank("species"),
  id = taxon_id(9696)
)
plantae &lt;- taxon(
  name = taxon_name("Plantae"),
  rank = taxon_rank("kingdom"),
  id = taxon_id(33090)
)
solanaceae &lt;- taxon(
  name = taxon_name("Solanaceae"),
  rank = taxon_rank("family"),
  id = taxon_id(4070)
)
solanum &lt;- taxon(
  name = taxon_name("Solanum"),
  rank = taxon_rank("genus"),
  id = taxon_id(4107)
)
lycopersicum &lt;- taxon(
  name = taxon_name("lycopersicum"),
  rank = taxon_rank("species"),
  id = taxon_id(49274)
)
tuberosum &lt;- taxon(
  name = taxon_name("tuberosum"),
  rank = taxon_rank("species"),
  id = taxon_id(4113)
)
homo &lt;- taxon(
  name = taxon_name("homo"),
  rank = taxon_rank("genus"),
  id = taxon_id(9605)
)
sapiens &lt;- taxon(
  name = taxon_name("sapiens"),
  rank = taxon_rank("species"),
  id = taxon_id(9606)
)
hominidae &lt;- taxon(
  name = taxon_name("Hominidae"),
  rank = taxon_rank("family"),
  id = taxon_id(9604)
)
unidentified &lt;- taxon(
  name = taxon_name("unidentified")
)

tiger &lt;- hierarchy(mammalia, felidae, panthera, tigris)
cat &lt;- hierarchy(mammalia, felidae, felis, catus)
human &lt;- hierarchy(mammalia, hominidae, homo, sapiens)
mole &lt;- hierarchy(mammalia, notoryctidae, notoryctes, typhlops)
tomato &lt;- hierarchy(plantae, solanaceae, solanum, lycopersicum)
potato &lt;- hierarchy(plantae, solanaceae, solanum, tuberosum)
potato_partial &lt;- hierarchy(solanaceae, solanum, tuberosum)
unidentified_animal &lt;- hierarchy(mammalia, unidentified)
unidentified_plant &lt;- hierarchy(plantae, unidentified)

info &lt;- data.frame(stringsAsFactors = FALSE,
                   name = c("tiger", "cat", "mole", "human", "tomato", "potato"),
                   n_legs = c(4, 4, 4, 2, 0, 0),
                   dangerous = c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE))

abund &lt;- data.frame(code = rep(c("T", "C", "M", "H"), 2),
                    sample_id = rep(c("A", "B"), each = 2),
                    count = c(1,2,5,2,6,2,4,0),
                    taxon_index = rep(1:4, 2))

phylopic_ids &lt;- c("e148eabb-f138-43c6-b1e4-5cda2180485a",
                  "12899ba0-9923-4feb-a7f9-758c3c7d5e13",
                  "11b783d5-af1c-4f4e-8ab5-a51470652b47",
                  "9fae30cd-fb59-4a81-a39c-e1826a35f612",
                  "b6400f39-345a-4711-ab4f-92fd4e22cb1a",
                  "63604565-0406-460b-8cb8-1abe954b3f3a")

foods &lt;- list(c("mammals", "birds"),
              c("cat food", "mice"),
              c("insects"),
              c("Most things, but especially anything rare or expensive"),
              c("light", "dirt"),
              c("light", "dirt"))

reaction &lt;- function(x) {
  ifelse(x$data$info$dangerous,
         paste0("Watch out! That ", x$data$info$name, " might attack!"),
         paste0("No worries; its just a ", x$data$info$name, "."))
}

ex_taxmap &lt;- taxmap(tiger, cat, mole, human, tomato, potato,
                    data = list(info = info,
                                phylopic_ids = phylopic_ids,
                                foods = foods,
                                abund = abund),
                    funcs = list(reaction = reaction))
</code></pre>

<hr>
<h2 id='taxon'>Taxon class</h2><span id='topic+taxon'></span>

<h3>Description</h3>

<p>A class used to define a single taxon. Most other classes in the taxa package
include one or more objects of this class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxon(name, rank = NULL, id = NULL, authority = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_+3A_name">name</code></td>
<td>
<p>a TaxonName object [taxon_name()] or character string. if character
passed in, we'll coerce to a TaxonName object internally, required</p>
</td></tr>
<tr><td><code id="taxon_+3A_rank">rank</code></td>
<td>
<p>a TaxonRank object [taxon_rank()] or character string. if character
passed in, we'll coerce to a TaxonRank object internally, required</p>
</td></tr>
<tr><td><code id="taxon_+3A_id">id</code></td>
<td>
<p>a TaxonId object [taxon_id()], numeric/integer, or character string.
if numeric/integer/character passed in, we'll coerce to a TaxonId object
internally, required</p>
</td></tr>
<tr><td><code id="taxon_+3A_authority">authority</code></td>
<td>
<p>(character) a character string, optional</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that there is a special use case of this function - you can
pass 'NULL' as the first parameter to get an empty 'taxon' object. It makes
sense to retain the original behavior where nothing passed in to the first
parameter leads to an error, and thus creating a 'NULL' taxon is done very
explicitly.
</p>


<h3>Value</h3>

<p>An 'R6Class' object of class 'Taxon'
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- taxon(
  name = taxon_name("Poa annua"),
  rank = taxon_rank("species"),
  id = taxon_id(93036)
))
x$name
x$rank
x$id

# a null taxon object
taxon(NULL)
## with all NULL objects from the other classes
taxon(
  name = taxon_name(NULL),
  rank = taxon_rank(NULL),
  id = taxon_id(NULL)
)
</code></pre>

<hr>
<h2 id='taxon_database'>Taxonomy database class</h2><span id='topic+taxon_database'></span>

<h3>Description</h3>

<p>Used to store information about taxonomy databases. This is typically used to
store where taxon information came from in [taxon()] objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxon_database(name = NULL, url = NULL, description = NULL, id_regex = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_database_+3A_name">name</code></td>
<td>
<p>(character) name of the database</p>
</td></tr>
<tr><td><code id="taxon_database_+3A_url">url</code></td>
<td>
<p>(character) url for the database</p>
</td></tr>
<tr><td><code id="taxon_database_+3A_description">description</code></td>
<td>
<p>(character) description of the database</p>
</td></tr>
<tr><td><code id="taxon_database_+3A_id_regex">id_regex</code></td>
<td>
<p>(character) id regex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'R6Class' object of class 'TaxonDatabase'
</p>


<h3>See Also</h3>

<p>[database_list]
</p>
<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a database entry
(x &lt;- taxon_database(
  "ncbi",
  "http://www.ncbi.nlm.nih.gov/taxonomy",
  "NCBI Taxonomy Database",
  "*"
))
x$name
x$url

# use pre-created database objects
database_list
database_list$ncbi
</code></pre>

<hr>
<h2 id='taxon_id'>Taxon ID class</h2><span id='topic+taxon_id'></span>

<h3>Description</h3>

<p>Used to store taxon IDs, either arbitrary or from a taxonomy database. This
is typically used to store taxon IDs in [taxon()] objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxon_id(id, database = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_id_+3A_id">id</code></td>
<td>
<p>(character/integer/numeric) a taxonomic id, required</p>
</td></tr>
<tr><td><code id="taxon_id_+3A_database">database</code></td>
<td>
<p>(database) database class object, optional</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'R6Class' object of class 'TaxonId'
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- taxon_id(12345))
x$id
x$database

(x &lt;- taxon_id(
  12345,
  database_list$ncbi
))
x$id
x$database

# a null taxon_name object
taxon_name(NULL)
</code></pre>

<hr>
<h2 id='taxon_ids'>Get taxon IDs</h2><span id='topic+taxon_ids'></span>

<h3>Description</h3>

<p>Return the taxon IDs in a [taxonomy()] or [taxmap()] object.
They are in the order they appear in the edge list.
</p>
<pre>
obj$taxon_ids()
taxon_ids(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_ids_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the taxon IDs for each taxon
taxon_ids(ex_taxmap)

# Filter using taxon IDs
filter_taxa(ex_taxmap, ! taxon_ids %in% c("c", "d"))

</code></pre>

<hr>
<h2 id='taxon_indexes'>Get taxon indexes</h2><span id='topic+taxon_indexes'></span>

<h3>Description</h3>

<p>Return the taxon indexes in a [taxonomy()] or [taxmap()] object.
They are the indexes of the edge list rows.
</p>
<pre>
obj$taxon_indexes()
taxon_indexes(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_indexes_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the indexes for each taxon
taxon_indexes(ex_taxmap)

# Use in another function (stupid example; 1:5 would work too)
filter_taxa(ex_taxmap, taxon_indexes &lt; 5)

</code></pre>

<hr>
<h2 id='taxon_name'>Taxon name class</h2><span id='topic+taxon_name'></span>

<h3>Description</h3>

<p>Used to store the name of taxa. This is typically used to
store where taxon names in [taxon()] objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxon_name(name, database = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_name_+3A_name">name</code></td>
<td>
<p>(character) a taxonomic name. required</p>
</td></tr>
<tr><td><code id="taxon_name_+3A_database">database</code></td>
<td>
<p>(character) database class object, optional</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'R6Class' object of class 'TaxonName'
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(poa &lt;- taxon_name("Poa"))
(undef &lt;- taxon_name("undefined"))
(sp1 &lt;- taxon_name("species 1"))
(poa_annua &lt;- taxon_name("Poa annua"))
(x &lt;- taxon_name("Poa annua L."))

x$name
x$database

(x &lt;- taxon_name(
  "Poa annua",
  database_list$ncbi
))
x$rank
x$database

# a null taxon_name object
taxon_name(NULL)
</code></pre>

<hr>
<h2 id='taxon_names'>Get taxon names</h2><span id='topic+taxon_names'></span>

<h3>Description</h3>

<p>Return the taxon names in a [taxonomy()] or [taxmap()] object.
They are in the order they appear in the edge list.
</p>
<pre>
obj$taxon_names()
taxon_names(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_names_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_ranks">taxon_ranks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the names for each taxon
taxon_names(ex_taxmap)

# Filter by taxon name
filter_taxa(ex_taxmap, taxon_names == "Felidae", subtaxa = TRUE)

</code></pre>

<hr>
<h2 id='taxon_rank'>Taxon rank class</h2><span id='topic+taxon_rank'></span>

<h3>Description</h3>

<p>Stores the rank of a taxon. This is typically used to store where taxon
information came from in [taxon()] objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxon_rank(name, database = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_rank_+3A_name">name</code></td>
<td>
<p>(character) rank name. required</p>
</td></tr>
<tr><td><code id="taxon_rank_+3A_database">database</code></td>
<td>
<p>(character) database class object, optional</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'R6Class' object of class 'TaxonRank'
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxonomy">taxonomy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>taxon_rank("species")
taxon_rank("genus")
taxon_rank("kingdom")

(x &lt;- taxon_rank(
  "species",
  database_list$ncbi
))
x$rank
x$database

# a null taxon_name object
taxon_name(NULL)
</code></pre>

<hr>
<h2 id='taxon_ranks'>Get taxon ranks</h2><span id='topic+taxon_ranks'></span>

<h3>Description</h3>

<p>Return the taxon ranks in a [taxonomy()] or [taxmap()] object.
They are in the order taxa appear in the edge list.
</p>
<pre>
obj$taxon_ranks()
taxon_ranks(obj)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxon_ranks_+3A_obj">obj</code></td>
<td>
<p>The [taxonomy()] or [taxmap()] object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other taxonomy data functions: 
<code><a href="#topic+classifications">classifications</a>()</code>,
<code><a href="#topic+id_classifications">id_classifications</a>()</code>,
<code><a href="#topic+is_branch">is_branch</a>()</code>,
<code><a href="#topic+is_internode">is_internode</a>()</code>,
<code><a href="#topic+is_leaf">is_leaf</a>()</code>,
<code><a href="#topic+is_root">is_root</a>()</code>,
<code><a href="#topic+is_stem">is_stem</a>()</code>,
<code><a href="#topic+map_data">map_data</a>()</code>,
<code><a href="#topic+map_data_">map_data_</a>()</code>,
<code><a href="#topic+n_leaves">n_leaves</a>()</code>,
<code><a href="#topic+n_leaves_1">n_leaves_1</a>()</code>,
<code><a href="#topic+n_subtaxa">n_subtaxa</a>()</code>,
<code><a href="#topic+n_subtaxa_1">n_subtaxa_1</a>()</code>,
<code><a href="#topic+n_supertaxa">n_supertaxa</a>()</code>,
<code><a href="#topic+n_supertaxa_1">n_supertaxa_1</a>()</code>,
<code><a href="#topic+taxon_ids">taxon_ids</a>()</code>,
<code><a href="#topic+taxon_indexes">taxon_indexes</a>()</code>,
<code><a href="#topic+taxon_names">taxon_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get ranks for each taxon
taxon_ranks(ex_taxmap)

# Filter by rank
filter_taxa(ex_taxmap, taxon_ranks == "family", supertaxa = TRUE)

</code></pre>

<hr>
<h2 id='taxonomy'>Taxonomy class</h2><span id='topic+taxonomy'></span>

<h3>Description</h3>

<p>Stores a taxonomy composed of [taxon()] objects organized in a tree
structure. This differs from the [hierarchies()] class in how the [taxon()]
objects are stored. Unlike [hierarchies()], each taxon is only stored once
and the relationships between taxa are stored in an [edge
list](https://en.wikipedia.org/wiki/Adjacency_list).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxonomy(..., .list = NULL, named_by_rank = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxonomy_+3A_...">...</code></td>
<td>
<p>Any number of object of class [hierarchy()] or character
vectors.</p>
</td></tr>
<tr><td><code id="taxonomy_+3A_.list">.list</code></td>
<td>
<p>An alternate to the '...' input. Any number of object of class
[hierarchy()] or character vectors in a list. Cannot be used with '...'.</p>
</td></tr>
<tr><td><code id="taxonomy_+3A_named_by_rank">named_by_rank</code></td>
<td>
<p>('TRUE'/'FALSE') If  'TRUE' and the input is a list of
vectors with each vector named by ranks, include that rank info in the
output object, so it can be accessed by 'out$taxon_ranks()'. If 'TRUE',
taxa with different ranks, but the same name and location in the taxonomy,
will be considered different taxa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'R6Class' object of class 'Taxonomy'
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+hierarchies">hierarchies</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a>()</code>,
<code><a href="#topic+taxa">taxa</a>()</code>,
<code><a href="#topic+taxmap">taxmap</a>()</code>,
<code><a href="#topic+taxon">taxon</a>()</code>,
<code><a href="#topic+taxon_database">taxon_database</a>()</code>,
<code><a href="#topic+taxon_id">taxon_id</a>()</code>,
<code><a href="#topic+taxon_name">taxon_name</a>()</code>,
<code><a href="#topic+taxon_rank">taxon_rank</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Making a taxonomy object with vectors
taxonomy(c("mammalia", "felidae", "panthera", "tigris"),
         c("mammalia", "felidae", "panthera", "leo"),
         c("mammalia", "felidae", "felis", "catus"))

# Making a taxonomy object from scratch
#   Note: This information would usually come from a parsing function.
#         This is just for demonstration.
x &lt;- taxon(
  name = taxon_name("Notoryctidae"),
  rank = taxon_rank("family"),
  id = taxon_id(4479)
)
y &lt;- taxon(
  name = taxon_name("Notoryctes"),
  rank = taxon_rank("genus"),
  id = taxon_id(4544)
)
z &lt;- taxon(
  name = taxon_name("Notoryctes typhlops"),
  rank = taxon_rank("species"),
  id = taxon_id(93036)
)

a &lt;- taxon(
  name = taxon_name("Mammalia"),
  rank = taxon_rank("class"),
  id = taxon_id(9681)
)
b &lt;- taxon(
  name = taxon_name("Felidae"),
  rank = taxon_rank("family"),
  id = taxon_id(9681)
)

cc &lt;- taxon(
  name = taxon_name("Puma"),
  rank = taxon_rank("genus"),
  id = taxon_id(146712)
)
d &lt;- taxon(
  name = taxon_name("Puma concolor"),
  rank = taxon_rank("species"),
  id = taxon_id(9696)
)

m &lt;- taxon(
  name = taxon_name("Panthera"),
  rank = taxon_rank("genus"),
  id = taxon_id(146712)
)
n &lt;- taxon(
  name = taxon_name("Panthera tigris"),
  rank = taxon_rank("species"),
  id = taxon_id(9696)
)

(hier1 &lt;- hierarchy(z, y, x, a))
(hier2 &lt;- hierarchy(cc, b, a, d))
(hier3 &lt;- hierarchy(n, m, b, a))

(hrs &lt;- hierarchies(hier1, hier2, hier3))

ex_taxonomy &lt;- taxonomy(hier1, hier2, hier3)
</code></pre>

<hr>
<h2 id='taxonomy_table'>Convert taxonomy info to a table</h2><span id='topic+taxonomy_table'></span>

<h3>Description</h3>

<p>Convert per-taxon information, like taxon names, to a table of taxa (rows) by
ranks (columns).
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="taxonomy_table_+3A_obj">obj</code></td>
<td>
<p>A <code>taxonomy</code> or <code>taxmap</code> object</p>
</td></tr>
<tr><td><code id="taxonomy_table_+3A_subset">subset</code></td>
<td>
<p>Taxon IDs, TRUE/FALSE vector, or taxon indexes to find
supertaxa for. Default: All leaves will be used. Any variable name that
appears in [all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="taxonomy_table_+3A_value">value</code></td>
<td>
<p>What data to return. Default is taxon names. Any result of
[all_names()] can be used, but it usually only makes sense to use data with
one value per taxon, like taxon names.</p>
</td></tr>
<tr><td><code id="taxonomy_table_+3A_use_ranks">use_ranks</code></td>
<td>
<p>Which ranks to use. Must be one of the following:
* 'NULL' (the default): If there is rank information, use the ranks that
appear in the lineage with the most ranks. Otherwise, assume the number of
supertaxa corresponds to rank and use placeholders for the rank column names
in the output.
* 'TRUE': Use the ranks that appear in the lineage with the most ranks. An
error will occur if no rank information is available.
* 'FALSE': Assume the number of supertaxa corresponds to rank and use
placeholders for the rank column names in the output. Do not use included
rank information.
* 'character': The names of the ranks to use. Requires included rank information.
* 'numeric': The &quot;depth&quot; of the ranks to use. These are equal to 'n_supertaxa' + 1.</p>
</td></tr>
<tr><td><code id="taxonomy_table_+3A_add_id_col">add_id_col</code></td>
<td>
<p>If 'TRUE', include a taxon ID column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble of taxa (rows) by ranks (columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a table of taxon names
taxonomy_table(ex_taxmap)

# Use a differnt value
taxonomy_table(ex_taxmap, value = "taxon_ids")

# Return a subset of taxa
taxonomy_table(ex_taxmap, subset = taxon_ranks == "genus")

# Use arbitrary ranks names based on depth
taxonomy_table(ex_taxmap, use_ranks = FALSE)

</code></pre>

<hr>
<h2 id='text_grob_length'>Estimate text grob length</h2><span id='topic+text_grob_length'></span>

<h3>Description</h3>

<p>Estimate the printed length of 'resizingTextGrob' text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_grob_length(text, rot = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="text_grob_length_+3A_text">text</code></td>
<td>
<p><code>character</code> The text to be printed</p>
</td></tr>
<tr><td><code id="text_grob_length_+3A_rot">rot</code></td>
<td>
<p>The rotation in radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated length of the printed text as a multiple of its text size (height)
</p>

<hr>
<h2 id='tid_font'>Taxon id formatting in print methods</h2><span id='topic+tid_font'></span>

<h3>Description</h3>

<p>A simple wrapper to make changing the formatting of text printed easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tid_font(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tid_font_+3A_text">text</code></td>
<td>
<p>What to print</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other printer fonts: 
<code><a href="#topic+desc_font">desc_font</a>()</code>,
<code><a href="#topic+error_font">error_font</a>()</code>,
<code><a href="#topic+name_font">name_font</a>()</code>,
<code><a href="#topic+punc_font">punc_font</a>()</code>
</p>

<hr>
<h2 id='to_percent'>Format a proportion as a printed percent</h2><span id='topic+to_percent'></span>

<h3>Description</h3>

<p>Format a proportion as a printed percent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_percent(prop, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_percent_+3A_prop">prop</code></td>
<td>
<p>The proportion</p>
</td></tr>
<tr><td><code id="to_percent_+3A_digits">digits</code></td>
<td>
<p>a positive integer indicating how many significant digits
are to be used for
numeric and complex <code>x</code>.  The default, <code>NULL</code>, uses
<code><a href="base.html#topic+getOption">getOption</a>("digits")</code>.  This is a suggestion: enough decimal
places will be used so that the smallest (in magnitude) number has
this many significant digits, and also to satisfy <code>nsmall</code>.
(For more, notably the interpretation for complex numbers see
<code><a href="base.html#topic+signif">signif</a></code>.)</p>
</td></tr>
<tr><td><code id="to_percent_+3A_...">...</code></td>
<td>
<p>passed to 'format'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>

<hr>
<h2 id='transform_data'>Transformation functions</h2><span id='topic+transform_data'></span>

<h3>Description</h3>

<p>Functions used by plotting functions to transform data.
Calling the function with no parameters returns available function names.
Calling with just the function name returns the transformation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_data(func = NULL, data = NULL, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_data_+3A_func">func</code></td>
<td>
<p>(<code>character</code>) Name of transformation to apply.</p>
</td></tr>
<tr><td><code id="transform_data_+3A_data">data</code></td>
<td>
<p>(<code>numeric</code>) Data to transform</p>
</td></tr>
<tr><td><code id="transform_data_+3A_inverse">inverse</code></td>
<td>
<p>(<code>logical</code> of length 1) If <code>TRUE</code>, return the inverse of the selected function.</p>
</td></tr>
</table>

<hr>
<h2 id='transmute_obs'>Replace columns in [taxmap()] objects</h2><span id='topic+transmute_obs'></span>

<h3>Description</h3>

<p>Replace columns of tables in 'obj$data' in [taxmap()] objects. See
[dplyr::transmute()] for the inspiration for this function and more
information. Calling the function using the 'obj$transmute_obs(...)' style
edits &quot;obj&quot; in place, unlike most R functions. However, calling the function
using the &lsquo;transmute_obs(obj, ...)' imitates R&rsquo;s traditional copy-on-modify
semantics, so &quot;obj&quot; would not be changed; instead a changed version would be
returned, like most R functions.
</p>
<pre>
obj$transmute_obs(data, ...)
transmute_obs(obj, data, ...)</pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transmute_obs_+3A_obj">obj</code></td>
<td>
<p>An object of type [taxmap()]</p>
</td></tr>
<tr><td><code id="transmute_obs_+3A_data">data</code></td>
<td>
<p>Dataset name, index, or a logical vector that indicates which dataset in
'obj$data' to use.</p>
</td></tr>
<tr><td><code id="transmute_obs_+3A_...">...</code></td>
<td>
<p>One or more named columns to add. Newly created columns can be
referenced in the same function call. Any variable name that appears in
[all_names()] can be used as if it was a vector on its own.</p>
</td></tr>
<tr><td><code id="transmute_obs_+3A_target">target</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type [taxmap()]
</p>


<h3>See Also</h3>

<p>Other taxmap manipulation functions: 
<code><a href="#topic+arrange_obs">arrange_obs</a>()</code>,
<code><a href="#topic+arrange_taxa">arrange_taxa</a>()</code>,
<code><a href="#topic+filter_obs">filter_obs</a>()</code>,
<code><a href="#topic+filter_taxa">filter_taxa</a>()</code>,
<code><a href="#topic+mutate_obs">mutate_obs</a>()</code>,
<code><a href="#topic+sample_frac_obs">sample_frac_obs</a>()</code>,
<code><a href="#topic+sample_frac_taxa">sample_frac_taxa</a>()</code>,
<code><a href="#topic+sample_n_obs">sample_n_obs</a>()</code>,
<code><a href="#topic+sample_n_taxa">sample_n_taxa</a>()</code>,
<code><a href="#topic+select_obs">select_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Replace columns in a table with new columns
transmute_obs(ex_taxmap, "info", new_col = paste0(name, "!!!"))

</code></pre>

<hr>
<h2 id='unique_mapping'>get indexes of a unique set of the input</h2><span id='topic+unique_mapping'></span>

<h3>Description</h3>

<p>get indexes of a unique set of the input
</p>
<p>Get indexes of a unique set of the input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_mapping(input)

unique_mapping(input)
</code></pre>

<hr>
<h2 id='validate_regex_key_pair'>Check a regex-key pair</h2><span id='topic+validate_regex_key_pair'></span>

<h3>Description</h3>

<p>Checks that the number of capture groups in the regex matches the length of the key.
Checks that only certain values of <code>key</code> can appear more that once.
Adds names to keys that will be used for column names in the output of <code>extract_taxonomy</code>.
Uses non-standard evaluation to get the name of input variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_regex_key_pair(regex, key, multiple_allowed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_regex_key_pair_+3A_regex">regex</code></td>
<td>
<p>(<code>character</code>)
A regex with capture groups</p>
</td></tr>
<tr><td><code id="validate_regex_key_pair_+3A_key">key</code></td>
<td>
<p>(<code>character</code>)
A key corresponding to <code>regex</code></p>
</td></tr>
<tr><td><code id="validate_regex_key_pair_+3A_multiple_allowed">multiple_allowed</code></td>
<td>
<p>(<code>character</code>)
Values of <code>key_options</code> that can appear more than once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the result of <code><a href="base.html#topic+match.arg">match.arg</a></code> on the key.
</p>

<hr>
<h2 id='validate_regex_match'>Check that all match input</h2><span id='topic+validate_regex_match'></span>

<h3>Description</h3>

<p>Ensure that all of a character vector matches a regex.
Inputs that do not match are excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_regex_match(input, regex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_regex_match_+3A_input">input</code></td>
<td>
<p>(<code>character</code>)</p>
</td></tr>
<tr><td><code id="validate_regex_match_+3A_regex">regex</code></td>
<td>
<p>(<code>character</code> of length 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> Parts of <code>input</code> matching <code>regex</code>
</p>

<hr>
<h2 id='validate_taxmap_funcs'>Validate 'funcs' input for Taxamp</h2><span id='topic+validate_taxmap_funcs'></span>

<h3>Description</h3>

<p>Make sure 'funcs' is in the right format and complain if it is not.
NOTE: This currently does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_taxmap_funcs(funcs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_taxmap_funcs_+3A_funcs">funcs</code></td>
<td>
<p>The 'funcs' variable passed to the 'Taxmap' constructor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'funcs' variable with the right format
</p>

<hr>
<h2 id='verify_color_range'>Verify color range parameters</h2><span id='topic+verify_color_range'></span>

<h3>Description</h3>

<p>Verify color range parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_color_range(args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_color_range_+3A_args">args</code></td>
<td>
<p>(<code>character</code>) The names of arguments to verify.</p>
</td></tr>
</table>

<hr>
<h2 id='verify_label_count'>Verify label count</h2><span id='topic+verify_label_count'></span>

<h3>Description</h3>

<p>Verify label count
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_label_count(args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_label_count_+3A_args">args</code></td>
<td>
<p>(<code>character</code>) The names of arguments to verify.</p>
</td></tr>
</table>

<hr>
<h2 id='verify_size'>Verify size parameters</h2><span id='topic+verify_size'></span>

<h3>Description</h3>

<p>Verify size parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_size(args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_size_+3A_args">args</code></td>
<td>
<p>(<code>character</code>) The names of arguments to verify.</p>
</td></tr>
</table>

<hr>
<h2 id='verify_size_range'>Verify size range parameters</h2><span id='topic+verify_size_range'></span>

<h3>Description</h3>

<p>Verify size range parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_size_range(args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_size_range_+3A_args">args</code></td>
<td>
<p>(<code>character</code>) The names of arguments to verify.</p>
</td></tr>
</table>

<hr>
<h2 id='verify_taxmap'>Check that an object is a taxmap</h2><span id='topic+verify_taxmap'></span>

<h3>Description</h3>

<p>Check that an object is a taxmap
This is intended to be used to parse options in other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_taxmap(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_taxmap_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other option parsers: 
<code><a href="#topic+get_taxmap_cols">get_taxmap_cols</a>()</code>,
<code><a href="#topic+get_taxmap_data">get_taxmap_data</a>()</code>,
<code><a href="#topic+get_taxmap_other_cols">get_taxmap_other_cols</a>()</code>,
<code><a href="#topic+get_taxmap_table">get_taxmap_table</a>()</code>
</p>

<hr>
<h2 id='verify_trans'>Verify transformation function parameters</h2><span id='topic+verify_trans'></span>

<h3>Description</h3>

<p>Verify transformation function parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_trans(args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="verify_trans_+3A_args">args</code></td>
<td>
<p>(<code>character</code>) The names of arguments to verify.</p>
</td></tr>
</table>

<hr>
<h2 id='write_greengenes'>Write an imitation of the Greengenes database</h2><span id='topic+write_greengenes'></span>

<h3>Description</h3>

<p>Attempts to save taxonomic and sequence information of a taxmap object in the
Greengenes output format. If the taxmap object was created using
<code><a href="#topic+parse_greengenes">parse_greengenes</a></code>, then it should be able to replicate the
format exactly with the default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_greengenes(
  obj,
  tax_file = NULL,
  seq_file = NULL,
  tax_names = obj$get_data("taxon_names")[[1]],
  ranks = obj$get_data("gg_rank")[[1]],
  ids = obj$get_data("gg_id")[[1]],
  sequences = obj$get_data("gg_seq")[[1]]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_greengenes_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="write_greengenes_+3A_tax_file">tax_file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to save the
taxonomy file.</p>
</td></tr>
<tr><td><code id="write_greengenes_+3A_seq_file">seq_file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to save the
sequence fasta file. This is optional.</p>
</td></tr>
<tr><td><code id="write_greengenes_+3A_tax_names">tax_names</code></td>
<td>
<p>(<code>character</code> named by taxon ids) The names of taxa</p>
</td></tr>
<tr><td><code id="write_greengenes_+3A_ranks">ranks</code></td>
<td>
<p>(<code>character</code> named by taxon ids) The ranks of taxa</p>
</td></tr>
<tr><td><code id="write_greengenes_+3A_ids">ids</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Sequence ids</p>
</td></tr>
<tr><td><code id="write_greengenes_+3A_sequences">sequences</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Sequences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The taxonomy output file has a format like:
</p>
<pre>
228054  k__Bacteria; p__Cyanobacteria; c__Synechococcophycideae; o__Synech...
844608  k__Bacteria; p__Cyanobacteria; c__Synechococcophycideae; o__Synech...
...
</pre>
<p>The optional sequence file has a format like:
</p>
<pre>
&gt;1111886 
AACGAACGCTGGCGGCATGCCTAACACATGCAAGTCGAACGAGACCTTCGGGTCTAGTGGCGCACGGGTGCGTA...
&gt;1111885 
AGAGTTTGATCCTGGCTCAGAATGAACGCTGGCGGCGTGCCTAACACATGCAAGTCGTACGAGAAATCCCGAGC...
...
</pre>


<h3>See Also</h3>

<p>Other writers: 
<code><a href="#topic+make_dada2_asv_table">make_dada2_asv_table</a>()</code>,
<code><a href="#topic+make_dada2_tax_table">make_dada2_tax_table</a>()</code>,
<code><a href="#topic+write_mothur_taxonomy">write_mothur_taxonomy</a>()</code>,
<code><a href="#topic+write_rdp">write_rdp</a>()</code>,
<code><a href="#topic+write_silva_fasta">write_silva_fasta</a>()</code>,
<code><a href="#topic+write_unite_general">write_unite_general</a>()</code>
</p>

<hr>
<h2 id='write_mothur_taxonomy'>Write an imitation of the Mothur taxonomy file</h2><span id='topic+write_mothur_taxonomy'></span>

<h3>Description</h3>

<p>Attempts to save taxonomic information of a taxmap object in the
mothur '*.taxonomy' format. If the taxmap object was created using
<code><a href="#topic+parse_mothur_taxonomy">parse_mothur_taxonomy</a></code>, then it should be able to replicate the format
exactly with the default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_mothur_taxonomy(
  obj,
  file,
  tax_names = obj$get_data("taxon_names")[[1]],
  ids = obj$get_data("sequence_id")[[1]],
  scores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_mothur_taxonomy_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="write_mothur_taxonomy_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to save the
sequence fasta file. This is optional.</p>
</td></tr>
<tr><td><code id="write_mothur_taxonomy_+3A_tax_names">tax_names</code></td>
<td>
<p>(<code>character</code> named by taxon ids) The names of taxa</p>
</td></tr>
<tr><td><code id="write_mothur_taxonomy_+3A_ids">ids</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Sequence ids</p>
</td></tr>
<tr><td><code id="write_mothur_taxonomy_+3A_scores">scores</code></td>
<td>
<p>(<code>numeric</code> named by taxon ids)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output file has a format like:
</p>
<pre>
AY457915	Bacteria(100);Firmicutes(99);Clostridiales(99);Johnsone...
AY457914	Bacteria(100);Firmicutes(100);Clostridiales(100);Johnso...
AY457913	Bacteria(100);Firmicutes(100);Clostridiales(100);Johnso...
AY457912	Bacteria(100);Firmicutes(99);Clostridiales(99);Johnsone...
AY457911	Bacteria(100);Firmicutes(99);Clostridiales(98);Ruminoco...
</pre>
<p>or...
</p>
<pre>
AY457915	Bacteria;Firmicutes;Clostridiales;Johnsonella_et_rel.;J...
AY457914	Bacteria;Firmicutes;Clostridiales;Johnsonella_et_rel.;J...
AY457913	Bacteria;Firmicutes;Clostridiales;Johnsonella_et_rel.;J...
AY457912	Bacteria;Firmicutes;Clostridiales;Johnsonella_et_rel.;J...
AY457911	Bacteria;Firmicutes;Clostridiales;Ruminococcus_et_rel.;...
</pre>


<h3>See Also</h3>

<p>Other writers: 
<code><a href="#topic+make_dada2_asv_table">make_dada2_asv_table</a>()</code>,
<code><a href="#topic+make_dada2_tax_table">make_dada2_tax_table</a>()</code>,
<code><a href="#topic+write_greengenes">write_greengenes</a>()</code>,
<code><a href="#topic+write_rdp">write_rdp</a>()</code>,
<code><a href="#topic+write_silva_fasta">write_silva_fasta</a>()</code>,
<code><a href="#topic+write_unite_general">write_unite_general</a>()</code>
</p>

<hr>
<h2 id='write_rdp'>Write an imitation of the RDP FASTA database</h2><span id='topic+write_rdp'></span>

<h3>Description</h3>

<p>Attempts to save taxonomic and sequence information of a taxmap object in the
RDP FASTA format. If the taxmap object was created using
<code><a href="#topic+parse_rdp">parse_rdp</a></code>, then it should be able to replicate the format
exactly with the default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_rdp(
  obj,
  file,
  tax_names = obj$get_data("taxon_names")[[1]],
  ranks = obj$get_data("rdp_rank")[[1]],
  ids = obj$get_data("rdp_id")[[1]],
  info = obj$get_data("seq_name")[[1]],
  sequences = obj$get_data("rdp_seq")[[1]]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_rdp_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="write_rdp_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to save the
sequence fasta file. This is optional.</p>
</td></tr>
<tr><td><code id="write_rdp_+3A_tax_names">tax_names</code></td>
<td>
<p>(<code>character</code> named by taxon ids) The names of taxa</p>
</td></tr>
<tr><td><code id="write_rdp_+3A_ranks">ranks</code></td>
<td>
<p>(<code>character</code> named by taxon ids) The ranks of taxa</p>
</td></tr>
<tr><td><code id="write_rdp_+3A_ids">ids</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Sequence ids</p>
</td></tr>
<tr><td><code id="write_rdp_+3A_info">info</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Info associated with
sequences. In the example output shown here, this field corresponds to
&quot;Sparassis crispa; MBUH-PIRJO&amp;ILKKA94-1587/ss5&quot;</p>
</td></tr>
<tr><td><code id="write_rdp_+3A_sequences">sequences</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Sequences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output file has a format like:
</p>
<pre>
&gt;S000448483 Sparassis crispa; MBUH-PIRJO&amp;ILKKA94-1587/ss5	Lineage=Root;rootrank;Fun...
ggattcccctagtaactgcgagtgaagcgggaagagctcaaatttaaaatctggcggcgtcctcgtcgtccgagttgtaa
tctggagaagcgacatccgcgctggaccgtgtacaagtctcttggaaaagagcgtcgtagagggtgacaatcccgtcttt
...
</pre>


<h3>See Also</h3>

<p>Other writers: 
<code><a href="#topic+make_dada2_asv_table">make_dada2_asv_table</a>()</code>,
<code><a href="#topic+make_dada2_tax_table">make_dada2_tax_table</a>()</code>,
<code><a href="#topic+write_greengenes">write_greengenes</a>()</code>,
<code><a href="#topic+write_mothur_taxonomy">write_mothur_taxonomy</a>()</code>,
<code><a href="#topic+write_silva_fasta">write_silva_fasta</a>()</code>,
<code><a href="#topic+write_unite_general">write_unite_general</a>()</code>
</p>

<hr>
<h2 id='write_silva_fasta'>Write an imitation of the SILVA FASTA database</h2><span id='topic+write_silva_fasta'></span>

<h3>Description</h3>

<p>Attempts to save taxonomic and sequence information of a taxmap object in the
SILVA FASTA format. If the taxmap object was created using
<code><a href="#topic+parse_silva_fasta">parse_silva_fasta</a></code>, then it should be able to replicate the format
exactly with the default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_silva_fasta(
  obj,
  file,
  tax_names = obj$get_data("taxon_names")[[1]],
  other_names = obj$get_data("other_name")[[1]],
  ids = obj$get_data("ncbi_id")[[1]],
  start = obj$get_data("start_pos")[[1]],
  end = obj$get_data("end_pos")[[1]],
  sequences = obj$get_data("silva_seq")[[1]]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_silva_fasta_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="write_silva_fasta_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to save the
sequence fasta file. This is optional.</p>
</td></tr>
<tr><td><code id="write_silva_fasta_+3A_tax_names">tax_names</code></td>
<td>
<p>(<code>character</code> named by taxon ids) The names of taxa</p>
</td></tr>
<tr><td><code id="write_silva_fasta_+3A_other_names">other_names</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Alternate names
of taxa. Will be added after the primary name.</p>
</td></tr>
<tr><td><code id="write_silva_fasta_+3A_ids">ids</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Sequence ids</p>
</td></tr>
<tr><td><code id="write_silva_fasta_+3A_start">start</code></td>
<td>
<p>(<code>character</code>) The start position of the
sequence.</p>
</td></tr>
<tr><td><code id="write_silva_fasta_+3A_end">end</code></td>
<td>
<p>(<code>character</code>) The end position of the
sequence.</p>
</td></tr>
<tr><td><code id="write_silva_fasta_+3A_sequences">sequences</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Sequences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output file has a format like:
</p>
<pre>
&gt;GCVF01000431.1.2369 Bacteria;Proteobacteria;Gammaproteobacteria;Oceanospiril...
CGUGCACGGUGGAUGCCUUGGCAGCCAGAGGCGAUGAAGGACGUUGUAGCCUGCGAUAAGCUCCGGUUAGGUGGCAAACA
ACCGUUUGACCCGGAGAUCUCCGAAUGGGGCAACCCACCCGUUGUAAGGCGGGUAUCACCGACUGAAUCCAUAGGUCGGU
...
</pre>


<h3>See Also</h3>

<p>Other writers: 
<code><a href="#topic+make_dada2_asv_table">make_dada2_asv_table</a>()</code>,
<code><a href="#topic+make_dada2_tax_table">make_dada2_tax_table</a>()</code>,
<code><a href="#topic+write_greengenes">write_greengenes</a>()</code>,
<code><a href="#topic+write_mothur_taxonomy">write_mothur_taxonomy</a>()</code>,
<code><a href="#topic+write_rdp">write_rdp</a>()</code>,
<code><a href="#topic+write_unite_general">write_unite_general</a>()</code>
</p>

<hr>
<h2 id='write_unite_general'>Write an imitation of the UNITE general FASTA database</h2><span id='topic+write_unite_general'></span>

<h3>Description</h3>

<p>Attempts to save taxonomic and sequence information of a taxmap object in the
UNITE general FASTA format. If the taxmap object was created using
<code><a href="#topic+parse_unite_general">parse_unite_general</a></code>, then it should be able to replicate the format
exactly with the default settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_unite_general(
  obj,
  file,
  tax_names = obj$get_data("taxon_names")[[1]],
  ranks = obj$get_data("unite_rank")[[1]],
  sequences = obj$get_data("unite_seq")[[1]],
  seq_name = obj$get_data("organism")[[1]],
  ids = obj$get_data("unite_id")[[1]],
  gb_acc = obj$get_data("acc_num")[[1]],
  type = obj$get_data("unite_type")[[1]]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_unite_general_+3A_obj">obj</code></td>
<td>
<p>A taxmap object</p>
</td></tr>
<tr><td><code id="write_unite_general_+3A_file">file</code></td>
<td>
<p>(<code>character</code> of length 1) The file path to save the
sequence fasta file. This is optional.</p>
</td></tr>
<tr><td><code id="write_unite_general_+3A_tax_names">tax_names</code></td>
<td>
<p>(<code>character</code> named by taxon ids) The names of taxa</p>
</td></tr>
<tr><td><code id="write_unite_general_+3A_ranks">ranks</code></td>
<td>
<p>(<code>character</code> named by taxon ids) The ranks of taxa</p>
</td></tr>
<tr><td><code id="write_unite_general_+3A_sequences">sequences</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Sequences</p>
</td></tr>
<tr><td><code id="write_unite_general_+3A_seq_name">seq_name</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Name of sequences.
Usually a taxon name.</p>
</td></tr>
<tr><td><code id="write_unite_general_+3A_ids">ids</code></td>
<td>
<p>(<code>character</code> named by taxon ids) UNITE sequence ids</p>
</td></tr>
<tr><td><code id="write_unite_general_+3A_gb_acc">gb_acc</code></td>
<td>
<p>(<code>character</code> named by taxon ids) Genbank accession
numbers</p>
</td></tr>
<tr><td><code id="write_unite_general_+3A_type">type</code></td>
<td>
<p>(<code>character</code> named by taxon ids) What type of sequence it
is. Usually &quot;rep&quot; or &quot;ref&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output file has a format like:
</p>
<pre>
&gt;Glomeromycota_sp|KJ484724|SH523877.07FU|reps|k__Fungi;p__Glomeromycota;c__unid...
ATAATTTGCCGAACCTAGCGTTAGCGCGAGGTTCTGCGATCAACACTTATATTTAAAACCCAACTCTTAAATTTTGTAT...
...
</pre>


<h3>See Also</h3>

<p>Other writers: 
<code><a href="#topic+make_dada2_asv_table">make_dada2_asv_table</a>()</code>,
<code><a href="#topic+make_dada2_tax_table">make_dada2_tax_table</a>()</code>,
<code><a href="#topic+write_greengenes">write_greengenes</a>()</code>,
<code><a href="#topic+write_mothur_taxonomy">write_mothur_taxonomy</a>()</code>,
<code><a href="#topic+write_rdp">write_rdp</a>()</code>,
<code><a href="#topic+write_silva_fasta">write_silva_fasta</a>()</code>
</p>

<hr>
<h2 id='zero_low_counts'>Replace low counts with zero</h2><span id='topic+zero_low_counts'></span>

<h3>Description</h3>

<p>For a given table in a <code><a href="#topic+taxmap">taxmap</a></code> object, convert all counts
below a minimum number to zero. This is useful for effectively removing
&quot;singletons&quot;, &quot;doubletons&quot;, or other low abundance counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_low_counts(
  obj,
  data,
  min_count = 2,
  use_total = FALSE,
  cols = NULL,
  other_cols = FALSE,
  out_names = NULL,
  dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero_low_counts_+3A_obj">obj</code></td>
<td>
<p>A <code><a href="#topic+taxmap">taxmap</a></code> object</p>
</td></tr>
<tr><td><code id="zero_low_counts_+3A_data">data</code></td>
<td>
<p>The name of a table in <code>obj$data</code>.</p>
</td></tr>
<tr><td><code id="zero_low_counts_+3A_min_count">min_count</code></td>
<td>
<p>The minimum number of counts needed for a count to remain
unchanged. Any could less than this will be converted to a zero. For
example, <code>min_count = 2</code> would remove singletons.</p>
</td></tr>
<tr><td><code id="zero_low_counts_+3A_use_total">use_total</code></td>
<td>
<p>If <code>TRUE</code>, the <code>min_count</code> applies to the total
count for each row (e.g. OTU counts for all samples), rather than each cell
in the table. For example <code>use_total = TRUE, min_count = 10</code> would
convert all counts of any row to zero if the total for all counts in that
row was less than 10.</p>
</td></tr>
<tr><td><code id="zero_low_counts_+3A_cols">cols</code></td>
<td>
<p>The columns in <code>data</code> to use. By
default, all numeric columns are used. Takes one of the following inputs:
</p>

<dl>
<dt>TRUE/FALSE:</dt><dd><p>All/No columns will used.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to use</p>
</dd> <dt>Numeric vector:</dt><dd><p>The indexes of
columns to use</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Use the columns corresponding to <code>TRUE</code> values.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="zero_low_counts_+3A_other_cols">other_cols</code></td>
<td>
<p>Preserve in the output non-target columns present in the
input data. New columns will always be on the end. The &quot;taxon_id&quot; column
will be preserved in the front. Takes one of the following inputs:
</p>

<dl>
<dt>NULL:</dt><dd><p>No columns will be added back, not even the taxon id column.</p>
</dd>
<dt>TRUE/FALSE:</dt><dd><p>All/None of the non-target columns will be preserved.</p>
</dd>
<dt>Character vector:</dt><dd><p>The names of columns to preserve</p>
</dd>
<dt>Numeric vector:</dt><dd><p>The indexes of columns to preserve</p>
</dd>
<dt>Vector of TRUE/FALSE of length equal to the number of columns:</dt><dd><p>Preserve the columns corresponding to <code>TRUE</code> values.</p>
</dd></dl>
</td></tr>
<tr><td><code id="zero_low_counts_+3A_out_names">out_names</code></td>
<td>
<p>The names of count columns in the output. Must be the same
length and order as <code>cols</code> (or <code>unique(groups)</code>, if <code>groups</code> is used).</p>
</td></tr>
<tr><td><code id="zero_low_counts_+3A_dataset">dataset</code></td>
<td>
<p>DEPRECIATED. use &quot;data&quot; instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>See Also</h3>

<p>Other calculations: 
<code><a href="#topic+calc_diff_abund_deseq2">calc_diff_abund_deseq2</a>()</code>,
<code><a href="#topic+calc_group_mean">calc_group_mean</a>()</code>,
<code><a href="#topic+calc_group_median">calc_group_median</a>()</code>,
<code><a href="#topic+calc_group_rsd">calc_group_rsd</a>()</code>,
<code><a href="#topic+calc_group_stat">calc_group_stat</a>()</code>,
<code><a href="#topic+calc_n_samples">calc_n_samples</a>()</code>,
<code><a href="#topic+calc_obs_props">calc_obs_props</a>()</code>,
<code><a href="#topic+calc_prop_samples">calc_prop_samples</a>()</code>,
<code><a href="#topic+calc_taxon_abund">calc_taxon_abund</a>()</code>,
<code><a href="#topic+compare_groups">compare_groups</a>()</code>,
<code><a href="#topic+counts_to_presence">counts_to_presence</a>()</code>,
<code><a href="#topic+rarefy_obs">rarefy_obs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Parse data for examples
x = parse_tax_data(hmp_otus, class_cols = "lineage", class_sep = ";",
                   class_key = c(tax_rank = "taxon_rank", tax_name = "taxon_name"),
                   class_regex = "^(.+)__(.+)$")
                   
# Default use
zero_low_counts(x, "tax_data")

# Use only a subset of columns
zero_low_counts(x, "tax_data", cols = c("700035949", "700097855", "700100489"))
zero_low_counts(x, "tax_data", cols = 4:6)
zero_low_counts(x, "tax_data", cols = startsWith(colnames(x$data$tax_data), "70001"))

# Including all other columns in ouput
zero_low_counts(x, "tax_data", other_cols = TRUE)

# Inlcuding specific columns in output
zero_low_counts(x, "tax_data", cols = c("700035949", "700097855", "700100489"),
                other_cols = 2:3)
               
# Rename output columns
zero_low_counts(x, "tax_data", cols = c("700035949", "700097855", "700100489"),
                out_names = c("a", "b", "c"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
