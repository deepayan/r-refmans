<!DOCTYPE html><html><head><title>Help for package fastTopics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastTopics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compare_fits'><p>Summarize and Compare Model Fits</p></a></li>
<li><a href='#de_analysis'><p>Differential Expression Analysis using a Topic Model</p></a></li>
<li><a href='#embedding_plot_2d'><p>PCA, t-SNE and UMAP Plots</p></a></li>
<li><a href='#fit_multinom_model'><p>Fit Simple Multinomial Model</p></a></li>
<li><a href='#fit_poisson_nmf'><p>Fit Non-negative Matrix Factorization to Count Data</p></a></li>
<li><a href='#fit_topic_model'><p>Simple Interface for Fitting a Multinomial Topic Model</p></a></li>
<li><a href='#loadings_plot'><p>Loadings Plot</p></a></li>
<li><a href='#loglik_poisson_nmf'><p>NMF and Topic Model Likelihoods and Deviances</p></a></li>
<li><a href='#merge_topics'><p>Combine Topics in Multinomial Topic Model</p></a></li>
<li><a href='#multinom2poisson'><p>Recover Poisson NMF Fit from Multinomial Topic Model Fit</p></a></li>
<li><a href='#pbmc_facs'><p>Mixture of 10 FACS-purified PBMC Single-Cell RNA-seq data</p></a></li>
<li><a href='#pca_from_topics'><p>Low-dimensional Embeddings from Poisson NMF or Multinomial Topic Model</p></a></li>
<li><a href='#plot_loglik_vs_rank'><p>Plot Log-Likelihood Versus Rank</p></a></li>
<li><a href='#plot_progress'><p>Plot Progress of Model Fitting Over Time</p></a></li>
<li><a href='#poisson2multinom'><p>Recover Multinomial Topic Model Fit from Poisson NMF fit</p></a></li>
<li><a href='#predict.poisson_nmf_fit'><p>Predict Methods for Poisson NMF and Multinomial Topic Model</p></a></li>
<li><a href='#run_homer'><p>Perform HOMER Motif Enrichment Analysis using DE Genomic Positions</p></a></li>
<li><a href='#select.poisson_nmf_fit'><p>Extract or Re-order Data Rows in Poisson NMF or Multinomial Topic Model Fit</p></a></li>
<li><a href='#simulate_count_data'><p>Simulate Count Data from Poisson NMF Model</p></a></li>
<li><a href='#simulate_poisson_gene_data'><p>Simulate Gene Expression Data from Poisson NMF or Multinomial</p>
Topic Model</a></li>
<li><a href='#simulate_toy_gene_data'><p>Simulate Toy Gene Expression Data</p></a></li>
<li><a href='#structure_plot'><p>Structure Plot</p></a></li>
<li><a href='#summary.poisson_nmf_fit'><p>Summarize Poisson NMF or Multinomial Topic Model Fit</p></a></li>
<li><a href='#volcano_plot'><p>Volcano Plots for Visualizing Results of Differential Expression Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-163</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Algorithms for Fitting Topic Models and Non-Negative Matrix
Factorizations to Count Data</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stephenslab/fastTopics">https://github.com/stephenslab/fastTopics</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stephenslab/fastTopics/issues">https://github.com/stephenslab/fastTopics/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements fast, scalable optimization algorithms for
    fitting topic models ("grade of membership" models) and
    non-negative matrix factorizations to count data. The methods
    exploit the special relationship between the multinomial topic
    model (also, "probabilistic latent semantic indexing") and Poisson
    non-negative matrix factorization. The package provides tools to
    compare, annotate and visualize model fits, including functions to
    efficiently create "structure plots" and identify key features in
    topics. The 'fastTopics' package is a successor to the 'CountClust'
    package. Note that the 'fastTopicis' package on GitHub has more 
    vignettes illustrating application to single-cell RNA-seq data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Copyright:</td>
<td>inst/COPYRIGHTS</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, utils, methods, stats, Matrix, gtools, quadprog,
irlba, dplyr, Rtsne, uwot, ashr, Rcpp (&ge; 1.0.1), RcppParallel
(&ge; 4.4.1), parallel, progress, pbapply, ggplot2 (&ge; 3.3.0),
ggrepel (&ge; 0.9.0), cowplot, plotly, htmlwidgets</td>
</tr>
<tr>
<td>Suggests:</td>
<td>NNLM, Ternary, testthat, knitr, rmarkdown, RhpcBLASctl</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, RcppArmadillo</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://stephenslab.github.io/nnlm-drat">https://stephenslab.github.io/nnlm-drat</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-15 18:33:14 UTC; pcarbo</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Carbonetto [aut, cre],
  Kevin Luo [aut],
  Kushal Dey [aut],
  Joyce Hsiao [ctb],
  Abhishek Sarkar [ctb],
  Anthony Hung [ctb],
  Xihui Lin [ctb],
  Paul C. Boutros [ctb],
  Minzhe Wang [ctb],
  Tracy Ke [ctb],
  Matthew Stephens [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Carbonetto &lt;peter.carbonetto@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-15 23:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='compare_fits'>Summarize and Compare Model Fits</h2><span id='topic+compare_fits'></span>

<h3>Description</h3>

<p>Create a table summarizing the results of fitting one
or more Poisson non-negative matrix factorizations or multinomial
topic models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_fits(fits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_fits_+3A_fits">fits</code></td>
<td>
<p>An object of class <code>"poisson_nmf_fit"</code> or
<code>"multinom_topic_model_fit"</code>, or a non-empty, named list in
which all list elements are Poisson NMF model fits or all
multinomial topic model fits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per element of <code>fits</code>, and
with the following columns:
</p>
<table>
<tr><td><code>k</code></td>
<td>
<p>The rank of the matrix factorization.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The log-likelihood (either Poisson NMF or multinomial topic
model likelihood) achieved at the last model fitting update.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>For Poisson NMF model fits only, the deviance achieved
at the last model fitting update.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>The maximum residual of the Karush-Kuhn-Tucker (KKT)
system achieved at the last model fitting update; small values
indicate that the solution is close to a local maximum, or
stationary point, of the likelihood.</p>
</td></tr>
<tr><td><code>loglik.diff</code></td>
<td>
<p>The improvement in the log-likelihood relative
to the model fit with the smallest log-likelihood.</p>
</td></tr>
<tr><td><code>dev.diff</code></td>
<td>
<p>The improvement in the deviance relative to the
model fit with the largest deviance.</p>
</td></tr>
<tr><td><code>nonzeros.f</code></td>
<td>
<p>The rate of nonzeros in the factors matrix, as
determined by <code>control$zero.threshold</code>.</p>
</td></tr>
<tr><td><code>nonzeros.l</code></td>
<td>
<p>The rate of nonzeros in the loadings matrix, as
determined by <code>control$zero.threshold</code>.</p>
</td></tr>
<tr><td><code>numiter</code></td>
<td>
<p>The number of loadings and/or factor updates
performed.</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p>The total runtime (in s) of the model fitting
updates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>,
<code><a href="#topic+fit_topic_model">fit_topic_model</a></code>
</p>

<hr>
<h2 id='de_analysis'>Differential Expression Analysis using a Topic Model</h2><span id='topic+de_analysis'></span><span id='topic+de_analysis_control_default'></span>

<h3>Description</h3>

<p>Implements methods for differential expression
analysis using a topic model. These methods are motivated by gene
expression studies, but could have other uses, such as identifying
&ldquo;key words&rdquo; for topics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>de_analysis(
  fit,
  X,
  s = rowSums(X),
  pseudocount = 0.01,
  fit.method = c("scd", "em", "mu", "ccd", "glm"),
  shrink.method = c("ash", "none"),
  lfc.stat = "le",
  control = list(),
  verbose = TRUE,
  ...
)

de_analysis_control_default()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="de_analysis_+3A_fit">fit</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;, or an n x k matrix of topic
proportions, where k is the number of topics. (The elements in each
row of this matrix should sum to 1.) If a Poisson NMF fit is
provided as input, the corresponding multinomial topic model fit is
automatically recovered using <code><a href="#topic+poisson2multinom">poisson2multinom</a></code>.</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_x">X</code></td>
<td>
<p>The n x m counts matrix. It can be a sparse matrix (class
<code>"dgCMatrix"</code>) or dense matrix (class <code>"matrix"</code>).</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_s">s</code></td>
<td>
<p>A numeric vector of length n determining how the rates are
scaled in the Poisson models. See &ldquo;Details&rdquo; for guidance on
the choice of <code>s</code>.</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_pseudocount">pseudocount</code></td>
<td>
<p>Observations with this value are added to the
counts matrix to stabilize maximum-likelihood estimation.</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_fit.method">fit.method</code></td>
<td>
<p>Method used to fit the Poisson models. Note that
<code>fit.method = "glm"</code> is the slowest method, and is mainly used
for testing.</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_shrink.method">shrink.method</code></td>
<td>
<p>Method used to stabilize the posterior mean
LFC estimates.  When <code>shrink.method = "ash"</code>, the &quot;adaptive
shrinkage&quot; method implemented in the &lsquo;ashr&rsquo; package is used to
compute posterior. When <code>shrink.method = "none"</code>, no
stabilization is performed, and the &ldquo;raw&rdquo; posterior mean LFC
estimates are returned.</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_lfc.stat">lfc.stat</code></td>
<td>
<p>The log-fold change statistics returned:
<code>lfc.stat = "vsnull"</code>, the log-fold change relative to the
null; <code>lfc.stat = "le"</code>, the &ldquo;least extreme&rdquo; LFC; or a
topic name or number, in which case the LFC is defined relative to
the selected topic. See &ldquo;Details&rdquo; for more detailed
explanations of these choices.</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_control">control</code></td>
<td>
<p>A list of parameters controlling behaviour of
the optimization and Monte Carlo algorithms. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_verbose">verbose</code></td>
<td>
<p>When <code>verbose = TRUE</code>, progress information is
printed to the console.</p>
</td></tr>
<tr><td><code id="de_analysis_+3A_...">...</code></td>
<td>
<p>When <code>shrink.method = "ash"</code>, these are
additional arguments passed to <code><a href="ashr.html#topic+ash">ash</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods are based on the Poisson model
</p>
<p style="text-align: center;"><code class="reqn">x_i ~ Poisson(\lambda_i),</code>
</p>
<p> in which the Poisson rates are
</p>
<p style="text-align: center;"><code class="reqn">\lambda_i = \sum_{j=1}^k s_i l_{ij} f_j,</code>
</p>
<p> the <code class="reqn">l_{ik}</code>
are the topic proportions and the <code class="reqn">f_j</code> are the unknowns to be
estimated. This model is applied separately to each column of
<code>X</code>. When <code class="reqn">s_i</code> (specified by input argument <code>s</code>) is
equal the total count in row i (this is the default), the Poisson
model will closely approximate a binomial model of the count data,
and the unknowns <code class="reqn">f_j</code> will approximate binomial
probabilities. (The Poisson approximation to the binomial is most
accurate when the total counts <code>rowSums(X)</code> are large and the
unknowns <code class="reqn">f_j</code> are small.) Other choices for <code>s</code> are
possible, and implement different normalization schemes.
</p>
<p>To allow for some flexibility, <code>de_analysis</code> allows for the
log-fold change to be measured in several ways.
</p>
<p>One option is to compare against the probability under the null
model: <code class="reqn">LFC(j) = log2(f_j/f_0)</code>, where <code class="reqn">f_0</code> is the single
parameter in the Poisson model <code class="reqn">x_i ~ Poisson(\lambda_i)</code> with
rates <code class="reqn">\lambda_i = s_i f_0</code>. This LFC definition is chosen with
<code>lfc.stat = "vsnull"</code>.
</p>
<p>Another option is to compare against a chosen topic, k: <code class="reqn">LFC(j)
= log2(f_j/f_k)</code>. By definition, <code class="reqn">LFC(k)</code> is zero, and
statistics such as z-scores and p-values for topic k are set to
<code>NA</code>. This LFC definition is selected by setting
<code>lfc.stat = k</code>.
</p>
<p>A final option (which is the default) computes the &ldquo;least
extreme&rdquo; LFC, defined as <code class="reqn">LFC(j) = log2(f_j/f_k)</code> such that
<code class="reqn">k</code> is the topic other than <code class="reqn">j</code> that gives the ratio
<code class="reqn">f_j/f_k</code> closest to 1. This option is chosen with
<code>lfc.stat = "le"</code>.
</p>
<p>We recommend setting <code>shrink.method = "ash"</code>, which uses the
&ldquo;adaptive shrinkage&rdquo; method (Stephens, 2016) to improve
accuracy of the posterior mean estimates and z-scores. We follow
the settings used in <code>lfcShrink</code> from the &lsquo;DESeq2&rsquo;
package, with <code>type = "ashr"</code>.
</p>
<p>Note that all LFC statistics are defined using the base-2 logarithm
following the conventioned used in differential expression
analysis.
</p>
<p>The <code>control</code> argument is a list in which any of the
following named components will override the default optimization
algorithm settings (as they are defined by
<code>de_analysis_control_default</code>):
</p>

<dl>
<dt><code>numiter</code></dt><dd><p>Maximum number of iterations performed in
fitting the Poisson models. When <code>fit.method = "glm"</code>, this is
passed as argument <code>maxit</code> to the <code>glm</code> function.</p>
</dd>
<dt><code>minval</code></dt><dd><p>A small, positive number. All topic
proportions less than this value and greater than <code>1 - minval</code>
are set to this value.</p>
</dd>
<dt><code>tol</code></dt><dd><p>Controls the convergence tolerance for fitting
the Poisson models. When <code>fit.method = "glm"</code>, this is passed
as argument <code>epsilon</code> to function <code>glm</code>.</p>
</dd>
<dt><code>conf.level</code></dt><dd><p>The size of the highest posterior density
(HPD) intervals. Should be a number greater than 0 and less than 1.</p>
</dd>
<dt><code>ns</code></dt><dd><p>Number of Monte Carlo samples simulated by
random-walk MCMC for estimating posterior LFC quantities.</p>
</dd>
<dt><code>rw</code></dt><dd><p>The standard deviation of the normal density used
to propose new states in the random-walk MCMC.</p>
</dd>
<dt><code>eps</code></dt><dd><p>A small, non-negative number added to the terms
inside the logarithms to avoid computing logarithms of zero.</p>
</dd>
<dt><code>nc</code></dt><dd><p>Number of threads used in the multithreaded
computations. Note that the multithreading relies on forking hence
is not available on Windows; will return an error on Windows unless
<code>nc = 1</code>. See <code><a href="parallel.html#topic+mclapply">mclapply</a></code> for
details. Also note that if R is installed with a multithreading
numerical linear algebra library (e.g., OpenBLAS), for best
performance the number of threads used by the linear algebra
library should be set to 1 (i.e., no multithreading). This can be
controlled for example using the RhpcBLASctl package.</p>
</dd>
<dt><code>nsplit</code></dt><dd><p>The number of data splits used in the
multithreaded computations (only relevant when <code>nc &gt; 1</code>). More
splits increase the granularity of the progress bar, but can also
slow down the mutithreaded computations by introducing more
overhead in the call to <code><a href="pbapply.html#topic+pblapply">pblapply</a></code>.</p>
</dd></dl>



<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>The log-fold change maximum-likelihood estimates.</p>
</td></tr>
<tr><td><code>postmean</code></td>
<td>
<p>Posterior mean LFC estimates.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>Lower limits of estimated HPD intervals. Note that
these are not updated by the shrinkage step.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>Upper limits of estimated HPD intervals. Note that
these are not updated by the shrinkage step.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z-scores for posterior mean LFC estimates.</p>
</td></tr>
<tr><td><code>lpval</code></td>
<td>
<p>-log10 two-tailed p-values obtained from the
z-scores. When <code>shrink.method = "ash"</code>, this is <code>NA</code>, and
the s-values are returned instead (see below).</p>
</td></tr>
<tr><td><code>svalue</code></td>
<td>
<p>s-values returned by
<code><a href="ashr.html#topic+ash">ash</a></code>. s-values are analogous to q-values, but
based on the local false sign rate; see Stephens (2016).</p>
</td></tr>
<tr><td><code>lfsr</code></td>
<td>
<p>When <code>shrink.method = "ash"</code> only, this output
contains the estimated local false sign rates.</p>
</td></tr>
<tr><td><code>ash</code></td>
<td>
<p>When <code>shrink.method = "ash"</code> only, this output
contains the <code><a href="ashr.html#topic+ash">ash</a></code> return value (after removing
the <code>"data"</code>, <code>"result"</code> and <code>"call"</code> list
elements).</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Maximum-likelihood estimates of the Poisson model
parameters.</p>
</td></tr>
<tr><td><code>f0</code></td>
<td>
<p>Maximum-likelihood estimates of the null model
parameters.</p>
</td></tr>
<tr><td><code>ar</code></td>
<td>
<p>A vector containing the Metropolis acceptance ratios
from each MCMC run.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Stephens, M. (2016). False discovery rates: a new deal.
<em>Biostatistics</em> <b>18</b>(2), kxw041.
doi: <a href="https://doi.org/10.1093/biostatistics/kxw041">10.1093/biostatistics/kxw041</a>
</p>
<p>Zhu, A., Ibrahim, J. G. and Love, M. I. (2019). Heavy-tailed prior
distributions for sequence count data: removing the noise and
preserving large differences. <em>Bioinformatics</em> <b>35</b>(12),
2084–2092.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform a differential expression (DE) analysis using the previously
# fitted multinomial topic model. Note that the de_analysis call could
# take several minutes to complete.

set.seed(1)
data(pbmc_facs)
de &lt;- de_analysis(pbmc_facs$fit,pbmc_facs$counts)

# Compile the DE analysis results for topic 4 into a table, and
# rank the genes by the posterior mean log-fold change, limiting to
# DE genes identified with low lfsr ("local false sign rate").
k &lt;- 4
dat &lt;- data.frame(postmean = de$postmean[,k],
                  z        = de$z[,k],
                  lfsr     = de$lfsr[,k])
rownames(dat) &lt;- with(pbmc_facs$genes,paste(symbol,ensembl,sep = "_"))
dat &lt;- subset(dat,lfsr &lt; 0.01)
dat &lt;- dat[order(dat$postmean,decreasing = TRUE),]

# Genes at the top of this ranking are genes that are much more
# highly expressed in the topic compared to other topics.
head(dat,n = 10)

# The genes at the bottom of the ranking are genes that are much less
# expressed in the topic.
tail(dat,n = 10)

# Create a volcano plot from the DE results for topic 4.
volcano_plot(de,k = k,ymax = 50,labels = pbmc_facs$genes$symbol)


</code></pre>

<hr>
<h2 id='embedding_plot_2d'>PCA, t-SNE and UMAP Plots</h2><span id='topic+embedding_plot_2d'></span><span id='topic+embedding_plot_2d_ggplot_call'></span><span id='topic+pca_plot'></span><span id='topic+tsne_plot'></span><span id='topic+umap_plot'></span><span id='topic+pca_hexbin_plot'></span><span id='topic+pca_hexbin_plot_ggplot_call'></span>

<h3>Description</h3>

<p>Visualize the structure of the Poisson NMF loadings or
the multinomial topic model topic proportions by projection onto
a 2-d surface. <code>plot_hexbin_plot</code> is most useful for
visualizing the PCs of a data set with thousands of samples or
more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embedding_plot_2d(
  fit,
  Y,
  fill = "loading",
  k,
  fill.label,
  ggplot_call = embedding_plot_2d_ggplot_call,
  plot_grid_call = function(plots) do.call(plot_grid, plots)
)

embedding_plot_2d_ggplot_call(
  Y,
  fill,
  fill.type = c("loading", "numeric", "factor", "none"),
  fill.label,
  font.size = 9
)

pca_plot(
  fit,
  Y,
  pcs = 1:2,
  n = 10000,
  fill = "loading",
  k,
  fill.label,
  ggplot_call = embedding_plot_2d_ggplot_call,
  plot_grid_call = function(plots) do.call(plot_grid, plots),
  ...
)

tsne_plot(
  fit,
  Y,
  n = 2000,
  fill = "loading",
  k,
  fill.label,
  ggplot_call = embedding_plot_2d_ggplot_call,
  plot_grid_call = function(plots) do.call(plot_grid, plots),
  ...
)

umap_plot(
  fit,
  Y,
  n = 2000,
  fill = "loading",
  k,
  fill.label,
  ggplot_call = embedding_plot_2d_ggplot_call,
  plot_grid_call = function(plots) do.call(plot_grid, plots),
  ...
)

pca_hexbin_plot(
  fit,
  Y,
  pcs = 1:2,
  bins = 40,
  breaks = c(0, 1, 10, 100, 1000, Inf),
  ggplot_call = pca_hexbin_plot_ggplot_call,
  ...
)

pca_hexbin_plot_ggplot_call(Y, bins, breaks, font.size = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embedding_plot_2d_+3A_fit">fit</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_y">Y</code></td>
<td>
<p>The n x 2 matrix containing the 2-d embedding, where n is
the number of rows in <code>fit$L</code>. If not provided, the embedding
will be computed automatically.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_fill">fill</code></td>
<td>
<p>The quantity to map onto the fill colour of the points
in the PCA plot. Set <code>fill = "loading"</code> to vary the fill
colour according to the loadings (or topic proportions) of the
select topiced or topics. Alternatively, <code>fill</code> may be set to a
data vector with one entry per row of <code>fit$L</code>, in which case
the data are mapped to the fill colour of the points. When
<code>fill = "none"</code>, the fill colour is not varied.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_k">k</code></td>
<td>
<p>The dimensions or topics selected by number or name. When
<code>fill = "loading"</code>, one plot is created per selected dimension
or topic; when <code>fill = "loading"</code> and <code>k</code> is not
specified, all dimensions or topics are plotted.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_fill.label">fill.label</code></td>
<td>
<p>The label used for the fill colour legend.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_ggplot_call">ggplot_call</code></td>
<td>
<p>The function used to create the plot. Replace
<code>embedding_plot_2d_ggplot_call</code> or <code>pca_hexbin_plot_ggplot_call</code>
with your own function to customize the appearance of the plot.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_plot_grid_call">plot_grid_call</code></td>
<td>
<p>When <code>fill = "loading"</code> and multiple
topics (<code>k</code>) are selected, this is the function used to
arrange the plots into a grid using <code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code>.
It should be a function accepting a single argument, <code>plots</code>,
a list of <code>ggplot</code> objects.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_fill.type">fill.type</code></td>
<td>
<p>The type of variable mapped to fill colour. The
fill colour is not varied when <code>fill.type = "none"</code>.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_font.size">font.size</code></td>
<td>
<p>Font size used in plot.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_pcs">pcs</code></td>
<td>
<p>The two principal components (PCs) to be plotted,
specified by name or number.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_n">n</code></td>
<td>
<p>The maximum number of points to plot. If <code>n</code> is less
than the number of rows of <code>fit$L</code>, the rows are subsampled at
random. This argument is ignored if <code>Y</code> is provided.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+pca_from_topics">pca_from_topics</a></code>, <code><a href="#topic+tsne_from_topics">tsne_from_topics</a></code> or
<code><a href="#topic+umap_from_topics">umap_from_topics</a></code>. These additional arguments are only
used if <code>Y</code> is not provided.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_bins">bins</code></td>
<td>
<p>Number of bins used to create hexagonal 2-d
histogram. Passed as the &ldquo;bins&rdquo; argument to
<code><a href="ggplot2.html#topic+stat_bin_hex">stat_bin_hex</a></code>.</p>
</td></tr>
<tr><td><code id="embedding_plot_2d_+3A_breaks">breaks</code></td>
<td>
<p>To produce the hexagonal histogram, the counts are
subdivided into intervals based on <code>breaks</code>. Passed as the
&ldquo;breaks&rdquo; argument to <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a lightweight interface primarily intended to
expedite creation of plots for visualizing the loadings or topic
proportions; most of the heavy lifting is done by
&lsquo;ggplot2&rsquo;. The 2-d embedding itself is computed by invoking
<code><a href="#topic+pca_from_topics">pca_from_topics</a></code>, <code><a href="#topic+tsne_from_topics">tsne_from_topics</a></code> or
<code><a href="#topic+umap_from_topics">umap_from_topics</a></code>. For more control over the plot's
appearance, the plot can be customized by modifying the
<code>ggplot_call</code> and <code>plot_grid_call</code> arguments.
</p>
<p>An effective 2-d visualization may also require some fine-tunning
of the settings, such as the t-SNE &ldquo;perplexity&rdquo;, or the
number of samples included in the plot. The PCA, UMAP, t-SNE
settings can be controlled by the additional arguments
(...). Alternatively, a 2-d embedding may be pre-computed, and
passed as argument <code>Y</code>.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca_from_topics">pca_from_topics</a></code>,
<code><a href="#topic+tsne_from_topics">tsne_from_topics</a></code>,
<code><a href="#topic+umap_from_topics">umap_from_topics</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
data(pbmc_facs)

# Get the Poisson NMF and multinomial topic models fitted to the
# PBMC data.
fit1 &lt;- multinom2poisson(pbmc_facs$fit)
fit2 &lt;- pbmc_facs$fit

# Plot the first two PCs of the loadings matrix (for the
# multinomial topic model, "fit2", the loadings are the topic
# proportions).
subpop &lt;- pbmc_facs$samples$subpop
p1 &lt;- pca_plot(fit1,k = 1)
p2 &lt;- pca_plot(fit2)
p3 &lt;- pca_plot(fit2,fill = "none")
p4 &lt;- pca_plot(fit2,pcs = 3:4,fill = "none")
p5 &lt;- pca_plot(fit2,fill = fit2$L[,1])
p6 &lt;- pca_plot(fit2,fill = subpop)
p7 &lt;- pca_hexbin_plot(fit1)
p8 &lt;- pca_hexbin_plot(fit2)


# Plot the loadings using t-SNE.
p1 &lt;- tsne_plot(fit1,k = 1)
p2 &lt;- tsne_plot(fit2)
p3 &lt;- tsne_plot(fit2,fill = subpop)

# Plot the loadings using UMAP.
p1 &lt;- umap_plot(fit1,k = 1)
p2 &lt;- umap_plot(fit2)
p3 &lt;- umap_plot(fit2,fill = subpop)


</code></pre>

<hr>
<h2 id='fit_multinom_model'>Fit Simple Multinomial Model</h2><span id='topic+fit_multinom_model'></span>

<h3>Description</h3>

<p>Fit a simple multinomial model for count data, in
which each sample (<em>i.e.</em>, a row of the data matrix <code>X</code>)
is assigned to a cluster. Under this simple multinomial model,
<code class="reqn">x_{ij}</code> assigned to cluster <code class="reqn">k</code> is multinomial with sample
size <code class="reqn">s_i = x_{i1} + ... + x_{im}</code> and multinomial
probabilities <code class="reqn">p_{1k}, ..., p_{mk}</code>. This is a special case of
the multinomial topic model in which all the mixture proportions
are either 0 or 1. The maximum-likelihood estimates (MLEs) of the
multinomial probabilities have a closed-form solution; no
iterative algorithm is needed to fit this simple model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_multinom_model(cluster, X, verbose = c("none", "detailed"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_multinom_model_+3A_cluster">cluster</code></td>
<td>
<p>A factor specifying a grouping, or clustering, of
the rows of <code>X</code>; e.g., the &ldquo;cluster&rdquo; output from
<code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>
</td></tr>
<tr><td><code id="fit_multinom_model_+3A_x">X</code></td>
<td>
<p>The n x m matrix of counts; all entries of X should be
non-negative. It can be a sparse matrix (class <code>"dgCMatrix"</code>)
or dense matrix (class <code>"matrix"</code>), with some exceptions (see
&lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="fit_multinom_model_+3A_verbose">verbose</code></td>
<td>
<p>This is passed as the &ldquo;verbose&rdquo; argument in
the call to <code><a href="#topic+init_poisson_nmf">init_poisson_nmf</a></code>.</p>
</td></tr>
<tr><td><code id="fit_multinom_model_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+init_poisson_nmf">init_poisson_nmf</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multinomial topic model fit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_topic_model">fit_topic_model</a></code>
</p>

<hr>
<h2 id='fit_poisson_nmf'>Fit Non-negative Matrix Factorization to Count Data</h2><span id='topic+fit_poisson_nmf'></span><span id='topic+fit_poisson_nmf_control_default'></span><span id='topic+init_poisson_nmf'></span><span id='topic+init_poisson_nmf_from_clustering'></span>

<h3>Description</h3>

<p>Approximate the input matrix <code>X</code> by the
non-negative matrix factorization <code>tcrossprod(L,F)</code>, in which
the quality of the approximation is measured by a
&ldquo;divergence&rdquo; criterion; equivalently, optimize the
likelihood under a Poisson model of the count data, <code>X</code>, in
which the Poisson rates are given by <code>tcrossprod(L,F)</code>.
Function <code>fit_poisson_nmf</code> runs a specified number of
coordinate-wise updates to fit the L and F matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_poisson_nmf(
  X,
  k,
  fit0,
  numiter = 100,
  update.factors = seq(1, ncol(X)),
  update.loadings = seq(1, nrow(X)),
  method = c("scd", "em", "mu", "ccd"),
  init.method = c("topicscore", "random"),
  control = list(),
  verbose = c("progressbar", "detailed", "none")
)

fit_poisson_nmf_control_default()

init_poisson_nmf(
  X,
  F,
  L,
  k,
  init.method = c("topicscore", "random"),
  beta = 0.5,
  betamax = 0.99,
  control = list(),
  verbose = c("detailed", "none")
)

init_poisson_nmf_from_clustering(X, clusters, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_poisson_nmf_+3A_x">X</code></td>
<td>
<p>The n x m matrix of counts; all entries of X should be
non-negative. It can be a sparse matrix (class <code>"dgCMatrix"</code>)
or dense matrix (class <code>"matrix"</code>), with some exceptions (see
&lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_k">k</code></td>
<td>
<p>An integer 2 or greater giving the matrix rank. This
argument should only be specified if the initial fit (<code>fit0</code>
or <code>F, L</code>) is not provided.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_fit0">fit0</code></td>
<td>
<p>The initial model fit. It should be an object of class
&ldquo;poisson_nmf_fit&rdquo;, such as an output from
<code>init_poisson_nmf</code>, or from a previous call to
<code>fit_poisson_nmf</code>.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_numiter">numiter</code></td>
<td>
<p>The number of updates of the factors and loadings to
perform.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_update.factors">update.factors</code></td>
<td>
<p>A numeric vector specifying which factors
(rows of <code>F</code>) to update. By default, all factors are
updated. Note that the rows that are not updated may still change
by rescaling. When <code>NULL</code>, all factors are fixed. This option
is only implemented for <code>method = "em"</code> and <code>method =
"scd"</code>. If another method is selected, the default setting of
<code>update.factors</code> must be used.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_update.loadings">update.loadings</code></td>
<td>
<p>A numeric vector specifying which loadings
(rows of <code>L</code>) to update. By default, all loadings are
updated. Note that the rows that are not updated may still change
by rescaling. When <code>NULL</code>, all loadings are fixed. This option
is only implemented for <code>method = "em"</code> and <code>method =
"scd"</code>. If another method is selected, the default setting of
<code>update.loadings</code> must be used.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_method">method</code></td>
<td>
<p>The method to use for updating the factors and
loadings. Four methods are implemented: multiplicative updates,
<code>method = "mu"</code>; expectation maximization (EM), <code>method =
"em"</code>; sequential co-ordinate descent (SCD), <code>method = "scd"</code>;
and cyclic co-ordinate descent (CCD), <code>method = "ccd"</code>. See
&lsquo;Details&rsquo; for a detailed description of these methods.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_init.method">init.method</code></td>
<td>
<p>The method used to initialize the factors and
loadings. When <code>init.method = "random"</code>, the factors and
loadings are initialized uniformly at random; when
<code>init.method = "topicscore"</code>, the factors are initialized
using the (very fast) Topic SCORE algorithm (Ke &amp; Wang, 2017), and
the loadings are initialized by running a small number of SCD
updates. This input argument is ignored if initial estimates of the
factors and loadings are already provided via input <code>fit0</code>, or
inputs <code>F</code> and <code>L</code>.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_control">control</code></td>
<td>
<p>A list of parameters controlling the behaviour of
the optimization algorithm (and the Topic SCORE algorithm if it
is used to initialize the model parameters). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_verbose">verbose</code></td>
<td>
<p>When <code>verbose = "detailed"</code>, information about
the algorithm's progress is printed to the console at each
iteration; when <code>verbose = "progressbar"</code>, a progress bar is
shown; and when <code>verbose = "none"</code>, no progress information is
printed. See the description of the &ldquo;progress&rdquo; return value
for an explanation of <code>verbose = "detailed"</code> console
output. (Note that some columns of the &ldquo;progress&rdquo; data frame
are not shown in the console output.)</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_f">F</code></td>
<td>
<p>An optional argument giving is the initial estimate of the
factors (also known as &ldquo;basis vectors&rdquo;). It should be an m x
k matrix, where m is the number of columns in the counts matrix
<code>X</code>, and k &gt; 1 is the rank of the matrix factorization
(equivalently, the number of &ldquo;topics&rdquo;). All entries of
<code>F</code> should be non-negative. When <code>F</code> and <code>L</code> are not
provided, input argument <code>k</code> should be specified instead.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_l">L</code></td>
<td>
<p>An optional argument giving the initial estimate of the
loadings (also known as &ldquo;activations&rdquo;). It should be an n x k
matrix, where n is the number of rows in the counts matrix
<code>X</code>, and k &gt; 1 is the rank of the matrix factorization
(equivalently, the number of &ldquo;topics&rdquo;). All entries of
<code>L</code> should be non-negative. When <code>F</code> and <code>L</code> are not
provided, input argument <code>k</code> should be specified instead.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_beta">beta</code></td>
<td>
<p>Initial setting of the extrapolation parameter. This is
<code class="reqn">beta</code> in Algorithm 3 of Ang &amp; Gillis (2019).</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_betamax">betamax</code></td>
<td>
<p>Initial setting for the upper bound on the
extrapolation parameter. This is <code class="reqn">\bar{\gamma}</code> in Algorithm 3
of Ang &amp; Gillis (2019).</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_clusters">clusters</code></td>
<td>
<p>A factor specifying a grouping, or clustering, of
the rows of <code>X</code>.</p>
</td></tr>
<tr><td><code id="fit_poisson_nmf_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>init_poisson_nmf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Poisson non-negative matrix factorization (Lee &amp; Seung,
2001), counts <code class="reqn">x_{ij}</code> in the <code class="reqn">n \times m</code> matrix, <code class="reqn">X</code>,
are modeled by the Poisson distribution: </p>
<p style="text-align: center;"><code class="reqn">x_{ij} \sim
\mathrm{Poisson}(\lambda_{ij}).</code>
</p>
<p> Each Poisson rate,
<code class="reqn">\lambda_{ij}</code>, is a linear combination of parameters
<code class="reqn">f_{jk} \geq 0, l_{ik} \geq 0</code> to be fitted to the data:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{ij} = \sum_{k=1}^K l_{ik} f_{jk},</code>
</p>
<p> in which <code class="reqn">K</code>
is a user-specified tuning parameter specifying the rank of the
matrix factorization. Function <code>fit_poisson_nmf</code> computes
maximum-likelihood estimates (MLEs) of the parameters. For
additional mathematical background, and an explanation of how
Poisson NMF is connected to topic modeling, see the vignette:
<code>vignette(topic = "relationship",package = "fastTopics")</code>.
</p>
<p>Using this function requires some care; only minimal argument
checking is performed, and error messages may not be helpful.
</p>
<p>The EM and multiplicative updates are simple and fast, but can be
slow to converge to a stationary point. When <code>control$numiter
= 1</code>, the EM and multiplicative updates are mathematically
equivalent to the multiplicative updates, and therefore share the
same convergence properties. However, the implementation of the EM
updates is quite different; in particular, the EM updates are more
suitable for sparse counts matrices. The implementation of the
multiplicative updates is adapted from the MATLAB code by Daichi
Kitamura <a href="http://d-kitamura.net">http://d-kitamura.net</a>.
</p>
<p>Since the multiplicative updates are implemented using standard
matrix operations, the speed is heavily dependent on the
BLAS/LAPACK numerical libraries used. In particular, using
optimized implementations such as OpenBLAS or Intel MKL can result
in much improved performance of the multiplcative updates.
</p>
<p>The cyclic co-ordinate descent (CCD) and sequential co-ordinate
descent (SCD) updates adopt the same optimization strategy, but
differ in the implementation details. In practice, we have found
that the CCD and SCD updates arrive at the same solution when
initialized &ldquo;sufficiently close&rdquo; to a stationary point. The
CCD implementation is adapted from the C++ code developed by
Cho-Jui Hsieh and Inderjit Dhillon, which is available for download
at <a href="https://www.cs.utexas.edu/~cjhsieh/nmf/">https://www.cs.utexas.edu/~cjhsieh/nmf/</a>. The SCD
implementation is based on version 0.4-3 of the &lsquo;NNLM&rsquo;
package.
</p>
<p>An additional re-scaling step is performed after each update to
promote numerical stability.
</p>
<p>We use three measures of progress for the model fitting: (1)
improvement in the log-likelihood (or deviance), (2) change in the
model parameters, and (3) the residuals of the Karush-Kuhn-Tucker
(KKT) first-order conditions. As the iterates approach a stationary
point of the loss function, the change in the model parameters
should be small, and the residuals of the KKT system should vanish.
Use <code><a href="#topic+plot_progress">plot_progress</a></code> to plot the improvement in the
solution over time.
</p>
<p>See <code><a href="#topic+fit_topic_model">fit_topic_model</a></code> for additional guidance on model
fitting, particularly for large or complex data sets.
</p>
<p>The <code>control</code> argument is a list in which any of the
following named components will override the default optimization
algorithm settings (as they are defined by
<code>fit_poisson_nmf_control_default</code>):
</p>

<dl>
<dt><code>numiter</code></dt><dd><p>Number of &ldquo;inner loop&rdquo; iterations to
run when performing and update of the factors or loadings. This
must be set to 1 for <code>method = "mu"</code> and <code>method =
  "ccd"</code>.</p>
</dd>
<dt><code>nc</code></dt><dd><p>Number of RcppParallel threads to use for the
updates. When <code>nc</code> is <code>NA</code>, the number of threads is
determined by calling
<code><a href="RcppParallel.html#topic+defaultNumThreads">defaultNumThreads</a></code>. This setting is
ignored for the multiplicative upates (<code>method = "mu"</code>).</p>
</dd>
<dt><code>minval</code></dt><dd><p>A small, positive constant used to safeguard
the multiplicative updates. The safeguarded updates are implemented
as <code>F &lt;- pmax(F1,minval)</code> and <code>L &lt;- pmax(L1,minval)</code>,
where <code>F1</code> and <code>L1</code> are the factors and loadings matrices
obtained by applying an update. This is motivated by Theorem 1 of
Gillis &amp; Glineur (2012). Setting <code>minval = 0</code> is allowed, but
some methods are not guaranteed to converge to a stationary point
without this safeguard, and a warning will be given in this case.</p>
</dd>
<dt><code>extrapolate</code></dt><dd><p>When <code>extrapolate = TRUE</code>, the
extrapolation scheme of Ang &amp; Gillis (2019) is used.</p>
</dd>
<dt><code>extrapolate.reset</code></dt><dd><p>To promote better numerical
stability of the extrapolated updates, they are &ldquo;reset&rdquo;
every so often. This parameter determines the number of iterations
to wait before resetting.</p>
</dd>
<dt><code>beta.increase</code></dt><dd><p>When the extrapolated update improves
the solution, scale the extrapolation parameter by this amount.</p>
</dd>
<dt><code>beta.reduce</code></dt><dd><p>When the extrapolaaed update does not
improve the solution, scale the extrapolation parameter by this
amount.</p>
</dd>
<dt><code>betamax.increase</code></dt><dd><p>When the extrapolated update
improves the solution, scale the extrapolation parameter by this
amount.</p>
</dd>
<dt><code>eps</code></dt><dd><p>A small, non-negative number that is added to the
terms inside the logarithms to sidestep computing logarithms of
zero. This prevents numerical problems at the cost of introducing a
small inaccuracy in the solution. Increasing this number may lead
to faster convergence but possibly a less accurate solution.</p>
</dd>
<dt><code>zero.threshold</code></dt><dd><p>A small, non-negative number used to
determine which entries of the solution are exactly zero. Any
entries that are less than or equal to <code>zero.threshold</code> are
considered to be exactly zero.</p>
</dd></dl>

<p>An additional setting, <code>control$init.numiter</code>, controls the
number of sequential co-ordinate descent (SCD) updates that are
performed to initialize the loadings matrix when <code>init.method
= "topicscore"</code>.
</p>


<h3>Value</h3>

<p><code>init_poisson_nmf</code> and <code>fit_poisson_nmf</code> both
return an object capturing the optimization algorithm state (for
<code>init_poisson_nmf</code>, this is the initial state). It is a list
with the following elements:
</p>
<table>
<tr><td><code>F</code></td>
<td>
<p>A matrix containing the current best estimates of the
factors.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>A matrix containing the current best estimates of the
loadings.</p>
</td></tr>
<tr><td><code>Fn</code></td>
<td>
<p>A matrix containing the non-extrapolated factor estimates.
If extrapolation is not used, <code>Fn</code> and <code>F</code> will be the
same.</p>
</td></tr>
<tr><td><code>Ln</code></td>
<td>
<p>A matrix containing the non-extrapolated estimates of the
loadings. If extrapolation is not used, <code>Ln</code> and <code>L</code> will
be the same.</p>
</td></tr>
<tr><td><code>Fy</code></td>
<td>
<p>A matrix containing the extrapolated factor estimates. If
the extrapolation scheme is not used, <code>Fy</code> and <code>F</code> will
be the same.</p>
</td></tr>
<tr><td><code>Ly</code></td>
<td>
<p>A matrix containing the extrapolated estimates of the
loadings. If extrapolation is not used, <code>Ly</code> and <code>L</code> will
be the same.</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>Value of the objective (&ldquo;loss&rdquo;) function
computed at the current best estimates of the factors and
loadings.</p>
</td></tr>
<tr><td><code>loss.fnly</code></td>
<td>
<p>Value of the objective (&ldquo;loss&rdquo;) function
computed at the extrapolated solution for the loadings (<code>Ly</code>)
and the non-extrapolated solution for the factors (<code>Fn</code>). This
is used internally to implement the extrapolated updates.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of the most recently completed iteration.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>The extrapolation parameter, <code class="reqn">beta</code> in Algorithm 3
of Ang &amp; Gillis (2019).</p>
</td></tr>
<tr><td><code>betamax</code></td>
<td>
<p>Upper bound on the extrapolation parameter. This is
<code class="reqn">\bar{\gamma}</code> in Algorithm 3 of Ang &amp; Gillis (2019).</p>
</td></tr>
<tr><td><code>beta0</code></td>
<td>
<p>The setting of the extrapolation parameter at the
last iteration that improved the solution.</p>
</td></tr>
<tr><td><code>progress</code></td>
<td>
<p>A data frame containing detailed information about
the algorithm's progress. The data frame should have <code>numiter</code>
rows. The columns of the data frame are: &ldquo;iter&rdquo;, the
iteration number; &ldquo;loglik&rdquo;, the Poisson NMF log-likelihood
at the current best factor and loading estimates;
&ldquo;loglik.multinom&rdquo;, the multinomial topic model
log-likelihood at the current best factor and loading estimates;
&ldquo;dev&rdquo;, the deviance at the current best factor and loading
estimates; &ldquo;res&rdquo;, the maximum residual of the
Karush-Kuhn-Tucker (KKT) first-order optimality conditions at the
current best factor and loading estimates; &ldquo;delta.f&rdquo;, the
largest change in the factors matrix; &ldquo;delta.l&rdquo;, the largest
change in the loadings matrix; &ldquo;nonzeros.f&rdquo;, the proportion
of entries in the factors matrix that are nonzero;
&ldquo;nonzeros.l&rdquo;, the proportion of entries in the loadings
matrix that are nonzero; &ldquo;extrapolate&rdquo;, which is 1 if
extrapolation is used, otherwise it is 0; &ldquo;beta&rdquo;, the
setting of the extrapolation parameter; &ldquo;betamax&rdquo;, the
setting of the extrapolation parameter upper bound; and
&ldquo;timing&rdquo;, the elapsed time in seconds (recorded using
<code><a href="base.html#topic+proc.time">proc.time</a></code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ang, A. and Gillis, N. (2019). Accelerating nonnegative matrix
factorization algorithms using extrapolation. <em>Neural
Computation</em> <b>31</b>, 417–439.
</p>
<p>Cichocki, A., Cruces, S. and Amari, S. (2011). Generalized
alpha-beta divergences and their application to robust nonnegative
matrix factorization. <em>Entropy</em> <b>13</b>, 134–170.
</p>
<p>Gillis, N. and Glineur, F. (2012). Accelerated multiplicative
updates and hierarchical ALS algorithms for nonnegative matrix
factorization. <em>Neural Computation</em> <code>24</code>, 1085–1105.
</p>
<p>Hsieh, C.-J. and Dhillon, I. (2011). Fast coordinate descent
methods with variable selection for non-negative matrix
factorization. In <em>Proceedings of the 17th ACM SIGKDD
international conference on Knowledge discovery and data mining</em>,
p. 1064-1072
</p>
<p>Lee, D. D. and Seung, H. S. (2001). Algorithms for non-negative
matrix factorization. In <em>Advances in Neural Information
Processing Systems</em> <b>13</b>, 556–562.
</p>
<p>Lin, X. and Boutros, P. C. (2018). Optimization and expansion of
non-negative matrix factorization. <em>BMC Bioinformatics</em>
<b>21</b>, 7.
</p>
<p>Ke, Z. &amp; Wang, M. (2017). A new SVD approach to optimal topic
estimation. <em>arXiv</em> <a href="https://arxiv.org/abs/1704.07016">https://arxiv.org/abs/1704.07016</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_topic_model">fit_topic_model</a></code>, <code><a href="#topic+plot_progress">plot_progress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a (sparse) 80 x 100 counts matrix.
library(Matrix)
set.seed(1)
X &lt;- simulate_count_data(80,100,k = 3,sparse = TRUE)$X

# Remove columns (words) that do not appear in any row (document).
X &lt;- X[,colSums(X &gt; 0) &gt; 0]

# Run 10 EM updates to find a good initialization.
fit0 &lt;- fit_poisson_nmf(X,k = 3,numiter = 10,method = "em")

# Fit the Poisson NMF model by running 50 EM updates.
fit_em &lt;- fit_poisson_nmf(X,fit0 = fit0,numiter = 50,method = "em")

# Fit the Poisson NMF model by running 50 extrapolated SCD updates.
fit_scd &lt;- fit_poisson_nmf(X,fit0 = fit0,numiter = 50,method = "scd",
                           control = list(extrapolate = TRUE))

# Compare the two fits.
fits &lt;- list(em = fit_em,scd = fit_scd)
compare_fits(fits)
plot_progress(fits,y = "loglik")
plot_progress(fits,y = "res")

# Recover the topic model. After this step, the L matrix contains the
# mixture proportions ("loadings"), and the F matrix contains the
# word frequencies ("factors").
fit_multinom &lt;- poisson2multinom(fit_scd)

</code></pre>

<hr>
<h2 id='fit_topic_model'>Simple Interface for Fitting a Multinomial Topic Model</h2><span id='topic+fit_topic_model'></span>

<h3>Description</h3>

<p>Fits a multinomial topic model to the count data,
hiding most of the complexities of model fitting. The default
optimization settings used here are intended to work well in a wide
range of data sets, although some fine-tuning may be needed for
more difficult cases. For full control, use <code>fit_poisson_nmf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_topic_model(
  X,
  k,
  numiter.main = 100,
  numiter.refine = 100,
  method.main = "em",
  method.refine = "scd",
  init.method = c("topicscore", "random"),
  control.init = list(),
  control.main = list(numiter = 4),
  control.refine = list(numiter = 4, extrapolate = TRUE),
  verbose = c("progressbar", "detailed", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_topic_model_+3A_x">X</code></td>
<td>
<p>The n x m matrix of counts; all entries of X should be
non-negative. It can be a sparse matrix (class <code>"dgCMatrix"</code>)
or dense matrix (class <code>"matrix"</code>).</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_k">k</code></td>
<td>
<p>The number of topics. Must be 2 or greater.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_numiter.main">numiter.main</code></td>
<td>
<p>Number of updates of the factors and loadings
to perform in the main model fitting step. Should be 1 or more.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_numiter.refine">numiter.refine</code></td>
<td>
<p>Number of updates of the factors and loadings
to perform in the model refinement step.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_method.main">method.main</code></td>
<td>
<p>The method to use for updating the factors and
loadings in the main model fitting step. Passed as argument
&quot;method&quot; to <code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_method.refine">method.refine</code></td>
<td>
<p>The method to use for updating the factors in
evthe model refinement step. Passed as argument &quot;method&quot;
to <code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_init.method">init.method</code></td>
<td>
<p>The method used to initialize the factors and
loadings. See <code><a href="#topic+init_poisson_nmf">init_poisson_nmf</a></code> for details.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_control.init">control.init</code></td>
<td>
<p>A list of parameters controlling the behaviour
of the optimization and Topic SCORE method in the call to
<code>init_poisson_nmf</code>. This is passed as argument &quot;control&quot; to
<code>init_poisson_nmf</code>.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_control.main">control.main</code></td>
<td>
<p>A list of parameters controlling the behaviour
of the optimization in the main model fitting step. This is passed
as argument &quot;control&quot; to <code>fit_poisson_nmf</code>.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_control.refine">control.refine</code></td>
<td>
<p>A list of parameters controlling the
behaviour of the of the optimization algorithm in the model
refinement step. This is passed as argument &quot;control&quot; to
<code>fit_poisson_nmf</code>.</p>
</td></tr>
<tr><td><code id="fit_topic_model_+3A_verbose">verbose</code></td>
<td>
<p>When <code>verbose = "progressbar"</code> or <code>verbose
= "detailed"</code>, information about the progress of the model fitting
is printed to the console. See <code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code> for
more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default settings, the model fitting is
accomplished in four steps: (1) initialize the Poisson NMF model
fit (<code>init_poisson_nmf</code>); (2) perform the main model fitting
step by running 100 EM updates using <code>fit_poisson_nmf</code>; (3)
refine the fit by running 100 extrapolated SCD updates, again using
<code>fit_poisson_nmf</code>; and (4) recover the multinomial topic model
by calling <code>poisson2multinom</code>.
</p>
<p>This two-stage fitting approach is based on our findings that the
EM algorithm initially makes rapid progress toward a solution, but
its convergence slows considerably as the iterates approach a
solution. Close to a solution, we have found that other algorithms
make much more rapid progress than EM; in particularly, we found
that the extrapolated SCD updates usually performed best). For
larger data sets, more updates in the main model fitting and
refinement steps may be needed to obtain a good fit.
</p>
<p>For larger data sets, more than 200 updates may be needed to obtain
a good fit.
</p>


<h3>Value</h3>

<p>A multinomial topic model fit; see
<code><a href="#topic+poisson2multinom">poisson2multinom</a></code> and <code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>
for details. Note that outputted likelihoods and deviances in
<code>progress</code> are evaluated with respect to the equivalent
Poisson NMF model.
</p>


<h3>References</h3>

<p>Dey, K. K., Hsiao, C. J. and Stephens, M. (2017). Visualizing the
structure of RNA-seq expression data using grade of membership
models. <em>PLoS Genetics</em> <b>13</b>, e1006599.
</p>
<p>Blei, D. M., Ng, A. Y. and Jordan, M. I. (2003). Latent Dirichlet
allocation. <em>Journal of Machine Learning Research</em> <b>3</b>,
993-1022.
</p>
<p>Hofmann, T. (1999). Probabilistic latent semantic indexing. In
<em>Proceedings of the 22nd International ACM SIGIR Conference</em>,
50-57. doi:10.1145/312624.312649
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init_poisson_nmf">init_poisson_nmf</a></code>,
<code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>,
<code><a href="#topic+poisson2multinom">poisson2multinom</a></code>,
<code><a href="#topic+fit_multinom_model">fit_multinom_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
set.seed(1)
X &lt;- simulate_count_data(80,100,k = 3,sparse = TRUE)$X
fit &lt;- fit_topic_model(X,k = 3)
print(summary(fit))

</code></pre>

<hr>
<h2 id='loadings_plot'>Loadings Plot</h2><span id='topic+loadings_plot'></span><span id='topic+loadings_plot_ggplot_call'></span>

<h3>Description</h3>

<p>Generate one or more barcharts to visualize the
relationship between the loadings or mixture proportions and a
selected categorical variable (a factor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadings_plot(
  fit,
  x,
  k,
  ggplot_call = loadings_plot_ggplot_call,
  plot_grid_call = function(plots) do.call(plot_grid, plots)
)

loadings_plot_ggplot_call(dat, topic.label, font.size = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadings_plot_+3A_fit">fit</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;.</p>
</td></tr>
<tr><td><code id="loadings_plot_+3A_x">x</code></td>
<td>
<p>A categorical variable represented as a
<code><a href="base.html#topic+factor">factor</a></code>. It should have the same number of elements as
the number of rows in <code>fit$L</code>.</p>
</td></tr>
<tr><td><code id="loadings_plot_+3A_k">k</code></td>
<td>
<p>The topic, or topics, selected by number or name. When not
specified, all topics are plotted.</p>
</td></tr>
<tr><td><code id="loadings_plot_+3A_ggplot_call">ggplot_call</code></td>
<td>
<p>The function used to create the plot. Replace
<code>loadings_plot_ggplot_call</code> with your own function to
customize the appearance of the plot.</p>
</td></tr>
<tr><td><code id="loadings_plot_+3A_plot_grid_call">plot_grid_call</code></td>
<td>
<p>When multiple topics are selected, this is
the function used to arrange the plots into a grid using
<code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code>. It should be a function accepting
a single argument, <code>plots</code>, a list of <code>ggplot</code> objects.</p>
</td></tr>
<tr><td><code id="loadings_plot_+3A_dat">dat</code></td>
<td>
<p>A data frame passed as input to
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, containing, at a minimum, columns
&ldquo;x&rdquo; and &ldquo;loading&rdquo;.</p>
</td></tr>
<tr><td><code id="loadings_plot_+3A_topic.label">topic.label</code></td>
<td>
<p>The name or number of the topic being plotted.
Only used to determine the plot title.</p>
</td></tr>
<tr><td><code id="loadings_plot_+3A_font.size">font.size</code></td>
<td>
<p>Font size used in plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a lightweight interface primarily intended to
expedite creation of boxplots for investigating relationships
between topics and a categorical variables of interest without
having to spend a great deal of time worrying about the plotting
settings; most of the &ldquo;heavy lifting&rdquo; is done by
&lsquo;ggplot2&rsquo; (specifically, function
<code><a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a></code> in the &lsquo;ggplot2&rsquo;
package). For more control over the plot's appearance, the plot can
be customized by modifying the <code>ggplot_call</code> and
<code>plot_grid_call</code> arguments.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>

<hr>
<h2 id='loglik_poisson_nmf'>NMF and Topic Model Likelihoods and Deviances</h2><span id='topic+loglik_poisson_nmf'></span><span id='topic+loglik_multinom_topic_model'></span><span id='topic+deviance_poisson_nmf'></span><span id='topic+cost'></span>

<h3>Description</h3>

<p>Compute log-likelihoods and deviances for assessing
fit of a topic model or a non-negative matrix factorization (NMF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_poisson_nmf(X, fit, e = 1e-08)

loglik_multinom_topic_model(X, fit, e = 1e-08)

deviance_poisson_nmf(X, fit, e = 1e-08)

cost(X, A, B, e = 1e-08, family = c("poisson", "multinom"), version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_poisson_nmf_+3A_x">X</code></td>
<td>
<p>The n x m matrix of counts or pseudocounts. It can be a
sparse matrix (class <code>"dgCMatrix"</code>) or dense matrix (class
<code>"matrix"</code>).</p>
</td></tr>
<tr><td><code id="loglik_poisson_nmf_+3A_fit">fit</code></td>
<td>
<p>A Poisson NMF or multinomial topic model fit, such as an
output from <code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code> or
<code><a href="#topic+fit_topic_model">fit_topic_model</a></code>.</p>
</td></tr>
<tr><td><code id="loglik_poisson_nmf_+3A_e">e</code></td>
<td>
<p>A small, non-negative number added to the terms inside the
logarithms to avoid computing logarithms of zero. This prevents
numerical problems at the cost of introducing a very small
inaccuracy in the computation.</p>
</td></tr>
<tr><td><code id="loglik_poisson_nmf_+3A_a">A</code></td>
<td>
<p>The n x k matrix of loadings. It should be a dense matrix.</p>
</td></tr>
<tr><td><code id="loglik_poisson_nmf_+3A_b">B</code></td>
<td>
<p>The k x m matrix of factors. It should be a dense matrix.</p>
</td></tr>
<tr><td><code id="loglik_poisson_nmf_+3A_family">family</code></td>
<td>
<p>If <code>model = "poisson"</code>, the loss function values
corresponding to the Poisson non-negative matrix factorization are
computed; if <code>model = "multinom"</code>, the multinomial topic model
loss function values are returned.</p>
</td></tr>
<tr><td><code id="loglik_poisson_nmf_+3A_version">version</code></td>
<td>
<p>When <code>version == "R"</code>, the computations are
performed entirely in R; when <code>version == "Rcpp"</code>, an Rcpp
implementation is used. The R version is typically faster when
<code>X</code> is a dense matrix, whereas the Rcpp version is faster and
more memory-efficient when <code>X</code> is a large, sparse matrix. When
not specified, the most suitable version is called depending on
whether <code>X</code> is dense or sparse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>cost</code> computes loss functions proportional
to the negative log-likelihoods, and is mainly for internal use to
quickly compute log-likelihoods and deviances; it should not be
used directly unless you know what you are doing. In particular,
little argument checking is performed by <code>cost</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with one entry per row of <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a small counts matrix.
set.seed(1)
out &lt;- simulate_count_data(10,20,3)
X   &lt;- out$X
fit &lt;- out[c("F","L")]
class(fit) &lt;- c("poisson_nmf_fit","list")

# Compute the Poisson log-likelihoods and deviances.
data.frame(loglik   = loglik_poisson_nmf(X,fit),
           deviance = deviance_poisson_nmf(X,fit))

# Compute multinomial log-likelihoods.
loglik_multinom_topic_model(X,fit)

</code></pre>

<hr>
<h2 id='merge_topics'>Combine Topics in Multinomial Topic Model</h2><span id='topic+merge_topics'></span>

<h3>Description</h3>

<p>Combine two or more topics in a multinomial topic
model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_topics(fit, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_topics_+3A_fit">fit</code></td>
<td>
<p>A multinomial topic model fit.</p>
</td></tr>
<tr><td><code id="merge_topics_+3A_k">k</code></td>
<td>
<p>The names or numbers of the topics to be combined. Two or
more topics should be chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixture proportions are combined by summation, and factors
are combined by averaging.
</p>


<h3>Value</h3>

<p>A multinomial topic model fit.
</p>

<hr>
<h2 id='multinom2poisson'>Recover Poisson NMF Fit from Multinomial Topic Model Fit</h2><span id='topic+multinom2poisson'></span>

<h3>Description</h3>

<p>This function recovers parameter estimates of the
Poisson non-negative matrix factorization (NMF) given parameter
estimates for a multinomial topic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom2poisson(fit, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinom2poisson_+3A_fit">fit</code></td>
<td>
<p>An object of class &ldquo;multinom_topic_model_fit&rdquo;,
such as an output from <code>poisson2multinom</code>. If a Poisson NMF
fit is provided (that is, an object of class
&ldquo;poisson_nmf_fit&rdquo;), the fit object is immediately returned
&ldquo;as is&rdquo;.</p>
</td></tr>
<tr><td><code id="multinom2poisson_+3A_x">X</code></td>
<td>
<p>Optional n x m matrix of counts, or pseudocounts. It can
be a sparse matrix (class <code>"dgCMatrix"</code>) or dense matrix
(class <code>"matrix"</code>). This only needs to be provided if the
document sizes <code>fit$s</code> are not available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is the list <code>fit</code>, in which matrices
<code>fit$F</code> and <code>fit$L</code> specify the factors and loadings in
the Poisson non-negative matrix factorization; specifically,
the counts matrix is modeled by the low-rank matrix product
<code>tcrossprod(fit$L,fit$F)</code>.
</p>

<hr>
<h2 id='pbmc_facs'>Mixture of 10 FACS-purified PBMC Single-Cell RNA-seq data</h2><span id='topic+pbmc_facs'></span>

<h3>Description</h3>

<p>These data are a selection of the reference
transcriptome profiles generated via single-cell RNA sequencing
(RNA-seq) of 10 bead-enriched subpopulations of PBMCs (Donor A),
described in Zheng <em>et al</em> (2017). The data are unique
molecular identifier (UMI) counts for 16,791 genes in 3,774 cells.
(Genes with no expression in any of the cells were removed.) Since
the majority of the UMI counts are zero, they are efficiently
stored as a 3,774 x 16,791 sparse matrix. These data are used in
the vignette illustrating how 'fastTopics' can be used to analyze to
single-cell RNA-seq data. Data for a separate set of 1,000 cells is
provided as a &ldquo;test set&rdquo; to evaluate out-of-sample predictions.
</p>


<h3>Format</h3>

<p><code>pbmc_facs</code> is a list with the following elements:
</p>

<dl>
<dt>counts</dt><dd><p>3,774 x 16,791 sparse matrix of UMI counts, with
rows corresponding to samples (cells) and columns corresponding to
genes. It is an object of class <code>"dgCMatrix"</code>).</p>
</dd>
<dt>counts_test</dt><dd><p>UMI counts for an additional test set of 100
cells.</p>
</dd>
<dt>samples</dt><dd><p>Data frame containing information about the
samples, including cell barcode and source FACS population
(&ldquo;celltype&rdquo; and &ldquo;facs_subpop&rdquo;).</p>
</dd>
<dt>samples_test</dt><dd><p>Sample information for the additional test
set of 100 cells.</p>
</dd>
<dt>genes</dt><dd><p>Data frame containing information and the genes,
including gene symbol and Ensembl identifier.</p>
</dd>
<dt>fit</dt><dd><p>Poisson non-negative matrix factorization (NMF) fitted
to the UMI count data <code>counts</code>, with rank <code>k = 6</code>. See
the vignette how the Poisson NMF model fitting was performed.</p>
</dd>
<dt>de</dt><dd><p>Result of calling 
<code>de_analysis(fit,counts,pseudocount = 0.1,
    control = list(ns = 1e4,nc = 4))</code>
after first setting the seed to 1, <code>set.seed(1)</code>.</p>
</dd></dl>



<h3>Source</h3>

<p><a href="https://www.10xgenomics.com/resources/datasets">https://www.10xgenomics.com/resources/datasets</a>
</p>


<h3>References</h3>

<p>G. X. Y. Zheng <em>et al</em> (2017). Massively parallel digital
transcriptional profiling of single cells. <em>Nature Communications</em>
<b>8</b>, 14049. doi: <a href="https://doi.org/10.1038/ncomms14049">10.1038/ncomms14049</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
data(pbmc_facs)
cat(sprintf("Number of cells: %d\n",nrow(pbmc_facs$counts)))
cat(sprintf("Number of genes: %d\n",ncol(pbmc_facs$counts)))
cat(sprintf("Proportion of counts that are non-zero: %0.1f%%.\n",
            100*mean(pbmc_facs$counts &gt; 0)))

</code></pre>

<hr>
<h2 id='pca_from_topics'>Low-dimensional Embeddings from Poisson NMF or Multinomial Topic Model</h2><span id='topic+pca_from_topics'></span><span id='topic+tsne_from_topics'></span><span id='topic+umap_from_topics'></span>

<h3>Description</h3>

<p>Lightweight interface for rapidly producing
low-dimensional embeddings from matrix factorizations or
multinomial topic models. The defaults used are more suitable for
producing embeddings from matrix factorizations or topic models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_from_topics(fit, dims = 2, center = TRUE, scale. = FALSE, ...)

tsne_from_topics(
  fit,
  dims = 2,
  pca = FALSE,
  normalize = FALSE,
  perplexity = 100,
  theta = 0.1,
  max_iter = 1000,
  eta = 200,
  check_duplicates = FALSE,
  verbose = TRUE,
  ...
)

umap_from_topics(
  fit,
  dims = 2,
  n_neighbors = 30,
  metric = "euclidean",
  scale = "none",
  pca = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_from_topics_+3A_fit">fit</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_dims">dims</code></td>
<td>
<p>The number of dimensions in the embedding. In
<code>tsne_from_topics</code>, this is passed as argument &ldquo;dims&rdquo;
to <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>. In <code>umap_from_topics</code>, this is
passed as argument &ldquo;n_components&rdquo; to
<code><a href="uwot.html#topic+umap">umap</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_center">center</code></td>
<td>
<p>A logical value indicating whether columns of
<code>fit$L</code> should be zero-centered before performing PCA; passed
as argument &ldquo;center&rdquo; to <code><a href="stats.html#topic+prcomp">prcomp</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_scale.">scale.</code></td>
<td>
<p>A logical value indicating whether columns of
<code>fit$L</code> should be scaled to have unit variance prior to
performing PCA; passed as argument &ldquo;scale.&rdquo; to
<code><a href="stats.html#topic+prcomp">prcomp</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code> or
<code><a href="uwot.html#topic+umap">umap</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_pca">pca</code></td>
<td>
<p>Whether to perform a PCA processing step in t-SNE or
UMAP; passed as argument &ldquo;pca&rdquo; to <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>
or <code><a href="uwot.html#topic+umap">umap</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize the data prior to running
t-SNE; passed as argument &ldquo;normalize&rdquo; to
<code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_perplexity">perplexity</code></td>
<td>
<p>t-SNE perplexity parameter, passed as argument
&ldquo;perplexity&rdquo; to <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>. The perplexity
is automatically revised if it is too large; see
<code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code> for more information.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_theta">theta</code></td>
<td>
<p>t-SNE speed/accuracy trade-off parameter; passed as
argument &ldquo;theta&rdquo; to <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of t-SNE iterations; passed as
argument &ldquo;max_iter&rdquo; to <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_eta">eta</code></td>
<td>
<p>t-SNE learning rate parameter; passed as argument
&ldquo;eta&rdquo; to <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_check_duplicates">check_duplicates</code></td>
<td>
<p>When <code>check_duplicates = TRUE</code>, checks
whether there are duplicate rows in <code>fit$L</code>; passed as argument
&ldquo;check_duplicates&rdquo; to <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose = TRUE</code>, progress updates are
printed; passed as argument &ldquo;verbose&rdquo; to
<code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code> or <code><a href="uwot.html#topic+umap">umap</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>Number of nearest neighbours in manifold
approximation; passed as argument &ldquo;n_neighbors&rdquo; to
<code><a href="uwot.html#topic+umap">umap</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_metric">metric</code></td>
<td>
<p>Distance matrix used to find nearest neighbors;
passed as argument &ldquo;metric&rdquo; to
<code><a href="uwot.html#topic+umap">umap</a></code>.</p>
</td></tr>
<tr><td><code id="pca_from_topics_+3A_scale">scale</code></td>
<td>
<p>Scaling to apply to <code>fit$L</code>; passed as argument
&ldquo;scale&rdquo; to <code><a href="uwot.html#topic+umap">umap</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that since <code>tsne_from_topics</code> and
<code>umap_from_topics</code> use nonlinear transformations of the data,
distances between points are generally less interpretable than a
linear transformation obtained by, say, PCA.
</p>


<h3>Value</h3>

<p>An n x d matrix containing the embedding, where n is the
number of rows of <code>fit$L</code>, and <code>d = dims</code>.
</p>


<h3>References</h3>

<p>Kobak, D. and Berens, P. (2019). The art of using t-SNE for
single-cell transcriptomics. <em>Nature Communications</em> <b>10</b>,
5416. doi: <a href="https://doi.org/10.1038/s41467-019-13056-x">10.1038/s41467-019-13056-x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca_plot">pca_plot</a></code>, <code><a href="#topic+tsne_plot">tsne_plot</a></code>,
<code><a href="#topic+umap_plot">umap_plot</a></code>, <code><a href="stats.html#topic+prcomp">prcomp</a></code>,
<code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code>, <code><a href="uwot.html#topic+umap">umap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(cowplot)
set.seed(1)
data(pbmc_facs)

# Get the Poisson NMF and multinomial topic model fit to the PBMC data.
fit1 &lt;- multinom2poisson(pbmc_facs$fit)
fit2 &lt;- pbmc_facs$fit
fit2 &lt;- poisson2multinom(fit1)

# Compute the first two PCs of the loadings matrix (for the topic
# model, fit2, the loadings are the topic proportions).
Y1 &lt;- pca_from_topics(fit1)
Y2 &lt;- pca_from_topics(fit2)
subpop &lt;- pbmc_facs$samples$subpop
quickplot(Y1[,1],Y1[,2],color = subpop) + theme_cowplot()
quickplot(Y2[,1],Y2[,2],color = subpop) + theme_cowplot()

# Compute a 2-d embedding of the loadings using t-SNE.

Y1 &lt;- tsne_from_topics(fit1)
Y2 &lt;- tsne_from_topics(fit2)
quickplot(Y1[,1],Y1[,2],color = subpop) + theme_cowplot()
quickplot(Y2[,1],Y2[,2],color = subpop) + theme_cowplot()


# Compute a 2-d embedding of the loadings using UMAP.

Y1 &lt;- umap_from_topics(fit1)
Y2 &lt;- umap_from_topics(fit2)
quickplot(Y1[,1],Y1[,2],color = subpop) + theme_cowplot()
quickplot(Y2[,1],Y2[,2],color = subpop) + theme_cowplot()


</code></pre>

<hr>
<h2 id='plot_loglik_vs_rank'>Plot Log-Likelihood Versus Rank</h2><span id='topic+plot_loglik_vs_rank'></span><span id='topic+loglik_vs_rank_ggplot_call'></span>

<h3>Description</h3>

<p>Create a plot showing the improvement in the
log-likelihood as the rank of the matrix factorization or the
number of topics (&ldquo;k&rdquo;) increases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_loglik_vs_rank(fits, ggplot_call = loglik_vs_rank_ggplot_call)

loglik_vs_rank_ggplot_call(dat, font.size = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_loglik_vs_rank_+3A_fits">fits</code></td>
<td>
<p>A list with 2 more list elements, in which each list
element is an object of class <code>"poisson_nmf_fit"</code> or
<code>"multinom_topic_model_fit"</code>. If two or more fits share the
same rank, or number of topics, the largest log-likelihood is
plotted.</p>
</td></tr>
<tr><td><code id="plot_loglik_vs_rank_+3A_ggplot_call">ggplot_call</code></td>
<td>
<p>The function used to create the plot. Replace
<code>loglik_vs_rank_ggplot_call</code> with your own function to
customize the appearance of the plot.</p>
</td></tr>
<tr><td><code id="plot_loglik_vs_rank_+3A_dat">dat</code></td>
<td>
<p>A data frame passed as input to
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, containing, at a minimum, columns
&ldquo;x&rdquo; and &ldquo;y&rdquo;.</p>
</td></tr>
<tr><td><code id="plot_loglik_vs_rank_+3A_font.size">font.size</code></td>
<td>
<p>Font size used in plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>

<hr>
<h2 id='plot_progress'>Plot Progress of Model Fitting Over Time</h2><span id='topic+plot_progress'></span>

<h3>Description</h3>

<p>Create a plot showing improvement in one or more
Poisson NMF or multinomial topic model fits over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_progress(
  fits,
  x = c("timing", "iter"),
  y = c("loglik", "dev", "res"),
  add.point.every = 20,
  colors = c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00",
    "#CC79A7"),
  linetypes = "solid",
  linesizes = 0.5,
  shapes = 19,
  fills = "white",
  e = 0.01,
  theme = function() theme_cowplot(12)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_progress_+3A_fits">fits</code></td>
<td>
<p>An object of class <code>"poisson_nmf_fit"</code> or
<code>"multinom_topic_model_fit"</code>, or a non-empty, named list in
which each all list elements are objects of class
<code>"poisson_nmf_fit"</code> or all objects of class
<code>"multinom_topic_model_fit"</code>.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_x">x</code></td>
<td>
<p>Choose <code>"timing"</code> to plot improvement in the solution
over time, or choose <code>"iter"</code> to plot improvement in the
solution per iteration.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_y">y</code></td>
<td>
<p>Column of the &quot;progress&quot; data frame used to assess
progress of the Poisson NMF optimization method(s). Should be one
of <code>"loglik"</code> (Poisson NMF or multinomial topic model
log-likelihood), <code>"dev"</code> (deviance) or <code>"res"</code> (maximum
residual of KKT conditions). The deviance is only valid for Poisson
NMF model fits.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_add.point.every">add.point.every</code></td>
<td>
<p>A positive integer giving the iteration
interval for drawing points on the progress curves. Set to
<code>Inf</code> to prevent points from being drawn on the plot.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_colors">colors</code></td>
<td>
<p>Colours used to draw progress curves; passed as the
<code>values</code> input to <code><a href="ggplot2.html#topic+scale_color_manual">scale_color_manual</a></code>.
If fewer colours than &quot;fits&quot; are given, the colours are recycled.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_linetypes">linetypes</code></td>
<td>
<p>Line types used to draw progress curves; passed as
the <code>values</code> input to <code><a href="ggplot2.html#topic+scale_linetype_manual">scale_linetype_manual</a></code>.
If fewer line types than &ldquo;fits&rdquo; are given, the line types are
recycled.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_linesizes">linesizes</code></td>
<td>
<p>Line sizes used to draw progress curves; passed as
the <code>values</code> input to <code><a href="ggplot2.html#topic+scale_size_manual">scale_size_manual</a></code>.
If fewer line sizes than &ldquo;fits&rdquo; are given, the line sizes are
recycled.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_shapes">shapes</code></td>
<td>
<p>Shapes used to draw points at the selected
iterations; passed as the <code>values</code> input to
<code><a href="ggplot2.html#topic+scale_shape_manual">scale_shape_manual</a></code>. If fewer shapes than
&ldquo;fits&rdquo; are given, the shapes are recycled.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_fills">fills</code></td>
<td>
<p>Fill colours used to draw points at the selected
iterations; passed as the <code>values</code> input to
<code><a href="ggplot2.html#topic+scale_fill_manual">scale_fill_manual</a></code>. If fewer fill colours
than &ldquo;fits&rdquo; are given, the fill colours are recycled.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_e">e</code></td>
<td>
<p>A small, positive number added to the vertical axis (for
<code>y = "loglik"</code> and <code>y = "dev"</code> only) so that the
logarithmic scale does not over-emphasize very small differences.</p>
</td></tr>
<tr><td><code id="plot_progress_+3A_theme">theme</code></td>
<td>
<p>The &lsquo;ggplot2&rsquo; &ldquo;theme&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The horizontal axis shows the recorded runtime (in s), and
the vertical axis shows some quantity measuring the quality of the
fit: the log-likelihood, deviance or maximum residual of the
Karush-Kuhn-Tucker (KKT) first-order optimality conditions. To
better visualize log-likelihoods and deviances, log-likelihood and
deviance differences are shown on the logarithmic scale.
Differences are calculated with respect to the best value achieved
over all the fits compared.
</p>
<p>Note that only minimal argument checking is performed.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>
</p>

<hr>
<h2 id='poisson2multinom'>Recover Multinomial Topic Model Fit from Poisson NMF fit</h2><span id='topic+poisson2multinom'></span>

<h3>Description</h3>

<p>This function recovers parameter estimates of the
multinomial topic model given parameter estimates for a Poisson
non-negative matrix factorization (NMF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson2multinom(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poisson2multinom_+3A_fit">fit</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo;, such as an
output from <code>fit_poisson_nmf</code>. It does not make sense for a
multinomial topic model to have less than two topics, so an error
will be reported when k &lt; 2, where k is the rank of the matrix
factorization. If a multinomial topic model fit is provided (that
is, an object of class &ldquo;multinom_topic_model_fit&rdquo;), the fit
object is immediately returned &ldquo;as is&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is the list <code>fit</code>, in which
<code>fit$F</code> and <code>fit$L</code> are the parameters of the multinomial
topic model; specifically, <code>fit$L[i,]</code> gives the topic
probabilities for sample or document i, and <code>fit$F[,k]</code> gives
the term probabilities for topic k. An additional vector
<code>fit$s</code> of length n is returned giving the &quot;size factors&quot;.
</p>

<hr>
<h2 id='predict.poisson_nmf_fit'>Predict Methods for Poisson NMF and Multinomial Topic Model</h2><span id='topic+predict.poisson_nmf_fit'></span><span id='topic+predict.multinom_topic_model_fit'></span>

<h3>Description</h3>

<p>Predict loadings based on previously fit Poisson NMF,
or predict topic proportions based on previously fit multinomial
topic model. This can be thought of as projecting data points onto
a previously estimated set of factors <code>fit$F</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poisson_nmf_fit'
predict(object, newdata, numiter = 20, ...)

## S3 method for class 'multinom_topic_model_fit'
predict(object, newdata, numiter = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.poisson_nmf_fit_+3A_object">object</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;.</p>
</td></tr>
<tr><td><code id="predict.poisson_nmf_fit_+3A_newdata">newdata</code></td>
<td>
<p>An optional counts matrix. If omitted, the loadings
estimated in the original data are returned.</p>
</td></tr>
<tr><td><code id="predict.poisson_nmf_fit_+3A_numiter">numiter</code></td>
<td>
<p>The number of updates to perform.</p>
</td></tr>
<tr><td><code id="predict.poisson_nmf_fit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A loadings matrix with one row for each data point and one
column for each topic or factor. For
<code>predict.multinom_topic_model_fit</code>, the output can also be
interpreted as a matrix of estimated topic proportions, in which
<code>L[i,j]</code> is the proportional contribution of topic j to data
point i.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate a 175 x 1,200 counts matrix.
set.seed(1)
dat &lt;- simulate_count_data(175,1200,k = 3)

# Split the data into training and test sets.
train &lt;- dat$X[1:100,]
test &lt;- dat$X[101:175,]

# Fit a Poisson non-negative matrix factorization using the
# training data.
fit &lt;- init_poisson_nmf(train,F = dat$F,init.method = "random")
fit &lt;- fit_poisson_nmf(train,fit0 = fit)

# Compare the estimated loadings in the training data against the
# loadings used to simulate these data.
Ltrain &lt;- predict(fit)
plot(dat$L[1:100,],Ltrain,pch = 20,col = "darkblue")
abline(a = 0,b = 1,col = "magenta",lty = "dotted",
       xlab = "true",ylab = "estimated")

# Next, predict loadings in unseen (test) data points, and compare
# these predictions against the loadings that were used to simulate
# the test data.
Ltest &lt;- predict(fit,test)
plot(dat$L[101:175,],Ltest,pch = 20,col = "darkblue",
     xlab = "true",ylab = "estimated")
abline(a = 0,b = 1,col = "magenta",lty = "dotted")

# Simulate a 175 x 1,200 counts matrix.
set.seed(1)
dat &lt;- simulate_multinom_gene_data(175,1200,k = 3)

# Split the data into training and test sets.
train &lt;- dat$X[1:100,]
test &lt;- dat$X[101:175,]

# Fit a topic model using the training data.
fit &lt;- init_poisson_nmf(train,F = dat$F,init.method = "random")
fit &lt;- fit_poisson_nmf(train,fit0 = fit)
fit &lt;- poisson2multinom(fit)

# Compare the estimated topic proportions in the training data against
# the topic proportions used to simulate these data.
Ltrain &lt;- predict(fit)
plot(dat$L[1:100,],Ltrain,pch = 20,col = "darkblue")
abline(a = 0,b = 1,col = "magenta",lty = "dotted",
       xlab = "true",ylab = "estimated")

# Next, predict loadings in unseen (test) data points, and compare
# these predictions against the loadings that were used to simulate
# the test data.
Ltest &lt;- predict(fit,test)
plot(dat$L[101:175,],Ltest,pch = 20,col = "darkblue",
     xlab = "true",ylab = "estimated")
abline(a = 0,b = 1,col = "magenta",lty = "dotted")


</code></pre>

<hr>
<h2 id='run_homer'>Perform HOMER Motif Enrichment Analysis using DE Genomic Positions</h2><span id='topic+run_homer'></span>

<h3>Description</h3>

<p>Run HOMER motif finding algorithm
(<code>findMotifsGenome.pl</code>) to identify motifs enriched for
differentially expressed (DE) genomic positions. See
<a href="http://homer.ucsd.edu">http://homer.ucsd.edu</a> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_homer(
  de,
  k,
  positions,
  genome = "hg19",
  subset = function(postmean, lpval, lfsr, rank, quantile) lfsr &lt; 0.05,
  homer.exec = "findMotifsGenome.pl",
  out.dir = tempdir(),
  homer.options = "-len 8,10,12 -size 200 -mis 2 -S 25 -p 1 -h",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_homer_+3A_de">de</code></td>
<td>
<p>An object of class &ldquo;topic_model_de_analysis&rdquo;,
usually the result of running <code><a href="#topic+de_analysis">de_analysis</a></code>.</p>
</td></tr>
<tr><td><code id="run_homer_+3A_k">k</code></td>
<td>
<p>Use the DE analysis results for this topic.</p>
</td></tr>
<tr><td><code id="run_homer_+3A_positions">positions</code></td>
<td>
<p>A table of genomic positions corresponding to rows
of the <code>de_analysis</code> results. Specifically, it should a data
frame with four columns: &ldquo;chr&rdquo;, chromosome name or number;
&ldquo;start&rdquo;, start position of genomic feature; &ldquo;end&rdquo;,
end position of genomic feature; and &ldquo;name&rdquo;, the name of the
genomic feature. If not specified, the genomic positions will be
extracted from the row names of <code>de$postmean</code>, in which the
row names are expected to be of the form <code>chr_start_end</code>. The
genomic positions will be written to a BED file (see
<a href="https://genome.ucsc.edu/FAQ/FAQformat.html">https://genome.ucsc.edu/FAQ/FAQformat.html</a> for more
information about BED files).</p>
</td></tr>
<tr><td><code id="run_homer_+3A_genome">genome</code></td>
<td>
<p>The genome parameter passed to
<code>findMotifsGenome.pl</code>.</p>
</td></tr>
<tr><td><code id="run_homer_+3A_subset">subset</code></td>
<td>
<p>Describe input argument &quot;subset&quot; here.</p>
</td></tr>
<tr><td><code id="run_homer_+3A_homer.exec">homer.exec</code></td>
<td>
<p>The name or file path of the HOMER
<code>findMotifsGenome.pl</code> excutable.</p>
</td></tr>
<tr><td><code id="run_homer_+3A_out.dir">out.dir</code></td>
<td>
<p>The positions BED file and HOMER results are written
to this directory.</p>
</td></tr>
<tr><td><code id="run_homer_+3A_homer.options">homer.options</code></td>
<td>
<p>Character string used to override default
<code>findMotifsGenome.pl</code> options.</p>
</td></tr>
<tr><td><code id="run_homer_+3A_verbose">verbose</code></td>
<td>
<p>When <code>verbose = TRUE</code>, progress information is
printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the motif enrichment results. It
is created from the <code>knownResults.txt</code> HOMER output.
</p>


<h3>References</h3>

<p>Heinz, S., Benner, C., Spann, N., Bertolino, E., Lin, Y. C., Laslo,
P., Cheng, J. X., Murre, C., Singh, H. and Glass, C. K. (2010).
Simple combinations of lineage-determining transcription factors
prime cis-regulatory elements required for macrophage and B cell
identities. <em>Molecular Cell</em> <b>38</b>, 576-589.
</p>

<hr>
<h2 id='select.poisson_nmf_fit'>Extract or Re-order Data Rows in Poisson NMF or Multinomial Topic Model Fit</h2><span id='topic+select.poisson_nmf_fit'></span><span id='topic+select'></span><span id='topic+select.multinom_topic_model_fit'></span><span id='topic+select_loadings'></span>

<h3>Description</h3>

<p>This function can be used to extract estimates for a
subset of the count data, or to re-order the rows of the loadings
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poisson_nmf_fit'
select(.data, loadings, ...)

## S3 method for class 'multinom_topic_model_fit'
select(.data, loadings, ...)

select_loadings(.data, loadings, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.poisson_nmf_fit_+3A_.data">.data</code></td>
<td>
<p>Poisson NMF or Multinomial Topic Model fit; that is,
an object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;, such as an output from
<code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code> or <code><a href="#topic+fit_topic_model">fit_topic_model</a></code>.</p>
</td></tr>
<tr><td><code id="select.poisson_nmf_fit_+3A_loadings">loadings</code></td>
<td>
<p>Indices (names or numbers) giving data rows to
keep. If not specified, all rows are kept.</p>
</td></tr>
<tr><td><code id="select.poisson_nmf_fit_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the generic select function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Poisson NMF or multinomial topic model fit containing the
selected data rows only.
</p>

<hr>
<h2 id='simulate_count_data'>Simulate Count Data from Poisson NMF Model</h2><span id='topic+simulate_count_data'></span>

<h3>Description</h3>

<p>Simulate a counts matrix <code>X</code> such that
<code>X[i,j]</code> is Poisson with rate (mean) <code>Y[i,j]</code>, where
<code>Y = tcrossprod(L,F)</code>, <code>L</code> is an n x k loadings
(&ldquo;activations&rdquo;) matrix, and <code>F</code> is an m x k factors
(&ldquo;basis vectors&rdquo;) matrix. The entries of matrix <code>L</code> are
drawn uniformly at random between zero and <code>lmax</code>, and the
entries of matrix <code>F</code> are drawn uniformly at random between 0
and <code>fmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_count_data(n, m, k, fmax = 1, lmax = 1, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_count_data_+3A_n">n</code></td>
<td>
<p>Number of rows in simulated count matrix. The number of
rows should be at least 2.</p>
</td></tr>
<tr><td><code id="simulate_count_data_+3A_m">m</code></td>
<td>
<p>Number of columns in simulated count matrix. The number of
columns should be at least 2.</p>
</td></tr>
<tr><td><code id="simulate_count_data_+3A_k">k</code></td>
<td>
<p>Number of factors, or &ldquo;topics&rdquo;, used to determine
Poisson rates. The number of topics should be 1 or more.</p>
</td></tr>
<tr><td><code id="simulate_count_data_+3A_fmax">fmax</code></td>
<td>
<p>Factors are drawn uniformly at random between zero and
<code>fmax</code>.</p>
</td></tr>
<tr><td><code id="simulate_count_data_+3A_lmax">lmax</code></td>
<td>
<p>Loadings are drawn uniformly at random between zero and
<code>lmax</code>.</p>
</td></tr>
<tr><td><code id="simulate_count_data_+3A_sparse">sparse</code></td>
<td>
<p>If <code>sparse = TRUE</code>, convert the counts matrix to
a sparse matrix in compressed, column-oriented format; see
<code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that only minimal argument checking is performed. This
function is mainly used to simulate small data sets for the examples
and package tests.
</p>


<h3>Value</h3>

<p>The return value is a list containing the counts matrix
<code>X</code> and the factorization, <code>F</code> and <code>L</code>, used to
generate the counts.
</p>

<hr>
<h2 id='simulate_poisson_gene_data'>Simulate Gene Expression Data from Poisson NMF or Multinomial
Topic Model</h2><span id='topic+simulate_poisson_gene_data'></span><span id='topic+simulate_multinom_gene_data'></span>

<h3>Description</h3>

<p>Simulate count data from a Poisson NMF model or
multinomial topic model, in which topics represent &ldquo;gene
expression programs&rdquo;, and gene expression programs are
characterized by different rates of expression. The way in which
the counts are simulated is modeled after gene expression studies
in which expression is measured by single-cell RNA sequencing
(&ldquo;RNA-seq&rdquo;) techniques: each row of the counts matrix
corresponds a gene expression profile, each column corresponds to a
gene, and each matrix element is a &ldquo;read count&rdquo;, or
&ldquo;UMI count&rdquo;, measuring expression level. Factors are
simulated so as to capture realistic changes in gene expression
across different cell types. See &ldquo;Details&rdquo; for the procedure
used to simulate factors, loadings and counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_poisson_gene_data(n, m, k, s, p = 1, sparse = FALSE)

simulate_multinom_gene_data(n, m, k, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_poisson_gene_data_+3A_n">n</code></td>
<td>
<p>Number of rows in the simulated count matrix. Should be at
least 2.</p>
</td></tr>
<tr><td><code id="simulate_poisson_gene_data_+3A_m">m</code></td>
<td>
<p>Number of columns in the simulated count matrix. Should be
at least 2.</p>
</td></tr>
<tr><td><code id="simulate_poisson_gene_data_+3A_k">k</code></td>
<td>
<p>Number of factors, or &ldquo;topics&rdquo;, used to generate
the data. Should be 2 or more.</p>
</td></tr>
<tr><td><code id="simulate_poisson_gene_data_+3A_s">s</code></td>
<td>
<p>Vector of &ldquo;size factors&rdquo;; each row of the loadings
matrix <code>L</code> is scaled by the entries of <code>s</code> before
generating the counts. This should be a vector of length n
containing only positive values.</p>
</td></tr>
<tr><td><code id="simulate_poisson_gene_data_+3A_p">p</code></td>
<td>
<p>Probability that <code>F[i,j]</code> is equal to the mean rate.
Smaller values of <code>p</code> will result in more factors that are the
same across topics.</p>
</td></tr>
<tr><td><code id="simulate_poisson_gene_data_+3A_sparse">sparse</code></td>
<td>
<p>If <code>sparse = TRUE</code>, convert the counts matrix to
a sparse matrix in compressed, column-oriented format; see
<code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here we describe the process for generating the n x k
loadings matrix <code>L</code> and the m x k factors matrix <code>F</code>.
</p>
<p>Each row of the <code>L</code> matrix is generated in the following
manner: (1) the number of nonzero mixture proportions is <code class="reqn">1
  \le n \le k</code>, with probability proportional to <code class="reqn">2^{-n}</code>;
(2) the indices of the nonzero mixture proportions are sampled
uniformly at random; and (3) the nonzero mixture proportions are
sampled from the Dirichlet distribution with <code class="reqn">\alpha = 1</code> (so
that all topics are equally likely).
</p>
<p>Each row of the factors matrix are generated according to the
following procedure: (1) generate <code class="reqn">u = |r| - 5</code>, where <code class="reqn">r ~
  N(0,2)</code>; (2) for each topic <code class="reqn">k</code>, generate the Poisson rates as
<code class="reqn">exp(max(t,-5))</code>, where <code class="reqn">t ~ 0.95 * N(u,s/10) + 0.05 *
  N(u,s)</code>, and <code class="reqn">s = exp(-u/8)</code>. Factors can be interpreted as
Poisson rates or multinomial probabilities, so that individual
counts can be viewed as being generated from a weighted mixture
of &ldquo;topics&rdquo; with different rates or probabilities.
</p>
<p>Once the loadings and factors have been generated, the counts are
simulated from either the Poisson NMF or multinomial topic model:
for the former, <code>X[i,j]</code> is Poisson with rate <code>Y[i,j]</code>,
where <code>Y = tcrossprod(L,F)</code>; for the latter, <code>X[i,]</code> is
multinomial with size <code>s[i]</code> and with class probabilities
<code>P[i,]</code>, where <code>P = tcrossprod(L,F)</code>. For the multinomial
model only, the sizes <code>s</code> are randomly generated as <code>s =
  10^rnorm(n,3,0.2)</code>.
</p>
<p>Note that only minimal argument checking is performed;
the function is mainly used to test implementation of the
topic-model-based differential count analysis.
</p>


<h3>Value</h3>

<p><code>simulate_poisson_gene_data</code> returns a list containing
the counts matrix <code>X</code>, and the size factors <code>s</code> and
factorization, <code>F</code>, <code>L</code>, used to generate the counts.
<code>simulate_multinom_gene_data</code> returns a list containing the
counts matrix <code>X</code>, and the mixture proportions <code>L</code> and
factors (gene probabilities, or relative gene expression levels)
<code>F</code> used to generate the counts.
</p>

<hr>
<h2 id='simulate_toy_gene_data'>Simulate Toy Gene Expression Data</h2><span id='topic+simulate_toy_gene_data'></span>

<h3>Description</h3>

<p>Simulate gene expression data (UMI counts) under a
toy expression model. Samples (expression profiles) are drawn
from a multinomial topic model in which topics are &quot;gene programs&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_toy_gene_data(n, m, k, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_toy_gene_data_+3A_n">n</code></td>
<td>
<p>The number of samples (gene expression profiles) to
simulate.</p>
</td></tr>
<tr><td><code id="simulate_toy_gene_data_+3A_m">m</code></td>
<td>
<p>The number of counts (genes) to simulate.</p>
</td></tr>
<tr><td><code id="simulate_toy_gene_data_+3A_k">k</code></td>
<td>
<p>The number of topics (&quot;gene programs&quot;) used to simulate
the data.</p>
</td></tr>
<tr><td><code id="simulate_toy_gene_data_+3A_s">s</code></td>
<td>
<p>A scalar specifying the total expression of each sample;
it specifies the &quot;size&quot; parameter in the calls to
<code><a href="stats.html#topic+rmultinom">rmultinom</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mixture proportions are generated as follows. With
probability 0.9, one proportion is one, or close to one, and the
remaining are zero, or close to zero; that is, the counts are
primarily generated from a single gene program. Otherwise (wtth
probability 0.1), the mixture proportions are roughly equal.
</p>
<p>Gene frequencies are drawn uniformly at random from [0,1].
</p>


<h3>Value</h3>

<p>The return value is a list containing the counts matrix
<code>X</code>, and the gene frequencies <code>F</code> and mixture proportions
<code>L</code> used to generate the counts.
</p>

<hr>
<h2 id='structure_plot'>Structure Plot</h2><span id='topic+structure_plot'></span><span id='topic+structure_plot_default_embed_method'></span><span id='topic+plot.poisson_nmf_fit'></span><span id='topic+plot.multinom_topic_model_fit'></span><span id='topic+structure_plot_ggplot_call'></span>

<h3>Description</h3>

<p>Create a &ldquo;Structure plot&rdquo; from a multinomial topic
model fit. The Structure plot represents the estimated topic
proportions of each sample in a stacked bar chart, with bars of
different colors representing different topics. Consequently,
samples that have similar topic proportions have similar amounts
of each color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structure_plot(
  fit,
  topics,
  grouping,
  loadings_order = "embed",
  n = 2000,
  colors,
  gap = 1,
  embed_method = structure_plot_default_embed_method,
  ggplot_call = structure_plot_ggplot_call,
  ...
)

structure_plot_default_embed_method(fit, ...)

## S3 method for class 'poisson_nmf_fit'
plot(x, ...)

## S3 method for class 'multinom_topic_model_fit'
plot(x, ...)

structure_plot_ggplot_call(dat, colors, ticks = NULL, font.size = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structure_plot_+3A_fit">fit</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;. If a Poisson NMF fit is provided
as input, the corresponding multinomial topic model fit is
automatically recovered using <code><a href="#topic+poisson2multinom">poisson2multinom</a></code>.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_topics">topics</code></td>
<td>
<p>Top-to-bottom ordering of the topics in the Structure
plot; <code>topics[1]</code> is shown on the top, <code>topics[2]</code> is
shown next, and so on. If the ordering of the topics is not
specified, the topics are automatically ordered so that the topics
with the greatest total &ldquo;mass&rdquo; are at shown at the bottom of
the plot. The topics may be specified by number or by name.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_grouping">grouping</code></td>
<td>
<p>Optional categorical variable (a factor) with one
entry for each row of the loadings matrix <code>fit$L</code> defining a
grouping of the samples (rows). The samples (rows) are arranged
along the horizontal axis according to this grouping, then within
each group according to <code>loadings_order</code>. If
<code>grouping</code> is not a factor, an attempt is made to convert it
to a factor using <code>as.factor</code>. Note that if
<code>loadings_order</code> is specified manually, <code>grouping</code> should
be the groups for the rows of <code>fit$L</code> <em>before</em> reordering.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_loadings_order">loadings_order</code></td>
<td>
<p>Ordering of the rows of the loadings matrix
<code>fit$L</code> along the horizontal axis the Structure plot (after
they have been grouped). If <code>loadings_order = "embed"</code>, the
ordering is generated automatically from a 1-d embedding,
separately for each group. The rows may be specified by number or
by name. Note that <code>loadings_order</code> may include all the rows
of <code>fit$L</code>, or a subset.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_n">n</code></td>
<td>
<p>The maximum number of samples (rows of the loadings matrix
<code>fit$L</code>) to include in the plot. Typically there is little to
no benefit in including large number of samples in the Structure
plot due to screen resolution limits. Ignored if
<code>loadings_order</code> is provided.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_colors">colors</code></td>
<td>
<p>Colors used to draw topics in Structure plot.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_gap">gap</code></td>
<td>
<p>The horizontal spacing between groups. Ignored if
<code>grouping</code> is not provided.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_embed_method">embed_method</code></td>
<td>
<p>The function used to compute an 1-d embedding
from a loadings matrix <code>fit$L</code>; only used if
<code>loadings_order = "embed"</code>. The function must accept the
multinomial topic model fit as its first input (&ldquo;fit&rdquo;) and
additional arguments may be passed (...). The output should be a
named numeric vector with one entry per row of <code>fit$L</code>, and
the names of the entries should be the same as the row names of
<code>fit$L</code>.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_ggplot_call">ggplot_call</code></td>
<td>
<p>The function used to create the plot. Replace
<code>structure_plot_ggplot_call</code> with your own function to
customize the appearance of the plot.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>structure_plot</code>
(for the <code>plot</code> method) or <code>embed_method</code> (for
function <code>structure_plot</code>).</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;. If a Poisson NMF fit is provided
as input, the corresponding multinomial topic model fit is
automatically recovered using <code><a href="#topic+poisson2multinom">poisson2multinom</a></code>.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_dat">dat</code></td>
<td>
<p>A data frame passed as input to
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, containing, at a minimum, columns
&ldquo;sample&rdquo;, &ldquo;topic&rdquo; and &ldquo;prop&rdquo;: the
&ldquo;sample&rdquo; column contains the positions of the samples (rows
of the L matrix) along the horizontal axis; the &ldquo;topic&rdquo;
column is a topic (a column of L); and the &ldquo;prop&rdquo; column is
the topic proportion for the respective sample.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_ticks">ticks</code></td>
<td>
<p>The placement of the group labels along the horizontal
axis, and their names. For data that are not grouped, use
<code>ticks = NULL</code>.</p>
</td></tr>
<tr><td><code id="structure_plot_+3A_font.size">font.size</code></td>
<td>
<p>Font size used in plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name &ldquo;Structure plot&rdquo; comes from its widespread
use in population genetics to visualize the results of the
Structure software (Rosenberg <em>et al</em>, 2002).
</p>
<p>For most uses of the Structure plot in population genetics, there
is usually some grouping of the samples (e.g., assignment to
pre-defined populations) that guides arrangement of the samples
along the horizontal axis in the bar chart. In other applications,
such as analysis of gene expression data, a pre-defined grouping
may not always be available. Therefore, a &ldquo;smart&rdquo;
arrangement of the samples is, by default, generated automatically
by performing a 1-d embedding of the samples.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>References</h3>

<p>Dey, K. K., Hsiao, C. J. and Stephens, M. (2017). Visualizing the
structure of RNA-seq expression data using grade of membership
models. <em>PLoS Genetics</em> <b>13</b>, e1006599.
</p>
<p>Rosenberg, N. A., Pritchard, J. K., Weber, J. L., Cann, H. M.,
Kidd, K. K., Zhivotovsky, L. A. and Feldman, M. W. (2002). Genetic
structure of human populations. <em>Science</em> <b>298</b>,
2381–2385.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
data(pbmc_facs)

# Get the multinomial topic model fitted to the
# PBMC data.
fit &lt;- pbmc_facs$fit

# Create a Structure plot without labels. The samples (rows of L) are
# automatically arranged along the x-axis using t-SNE to highlight the
# structure in the data.
p1 &lt;- structure_plot(fit)

# Create a Structure plot with the FACS cell-type labels. Within each
# group (cell-type), the cells (rows of L) are automatically arranged
# using t-SNE.
subpop &lt;- pbmc_facs$samples$subpop
p2 &lt;- structure_plot(fit,grouping = subpop)

# Next, we apply some customizations to improve the plot: (1) use the
# "topics" argument to specify the order in which the topic
# proportions are stacked on top of each other; (2) use the "gap"
# argrument to increase the whitespace between the groups; (3) use "n"
# to decrease the number of rows of L included in the Structure plot;
# and (4) use "colors" to change the colors used to draw the topic
# proportions.
topic_colors &lt;- c("skyblue","forestgreen","darkmagenta",
                  "dodgerblue","gold","darkorange")
p3 &lt;- structure_plot(fit,grouping = pbmc_facs$samples$subpop,gap = 20,
                     n = 1500,topics = c(5,6,1,4,2,3),colors = topic_colors)

# In this example, we use UMAP instead of t-SNE to arrange the
# cells in the Structure plot. Note that this can be accomplished in
# a different way by overriding the default setting of
# "embed_method".
y &lt;- drop(umap_from_topics(fit,dims = 1))
p4 &lt;- structure_plot(fit,loadings_order = order(y),grouping = subpop,
                     gap = 40,colors = topic_colors)

# We can also use PCA to arrange the cells.
y &lt;- drop(pca_from_topics(fit,dims = 1))
p5 &lt;- structure_plot(fit,loadings_order = order(y),grouping = subpop,
                     gap = 40,colors = topic_colors)

# In this final example, we plot a random subset of 400 cells, and
# arrange the cells randomly along the horizontal axis of the
# Structure plot.
p6 &lt;- structure_plot(fit,loadings_order = sample(3744,400),gap = 10,
                     grouping = subpop,colors = topic_colors)


</code></pre>

<hr>
<h2 id='summary.poisson_nmf_fit'>Summarize Poisson NMF or Multinomial Topic Model Fit</h2><span id='topic+summary.poisson_nmf_fit'></span><span id='topic+summary.multinom_topic_model_fit'></span><span id='topic+print.summary.poisson_nmf_fit'></span><span id='topic+print.summary.multinom_topic_model_fit'></span>

<h3>Description</h3>

<p><code>summary</code> method for the &ldquo;poisson_nmf_fit&rdquo;
and &ldquo;multinom_topic_model_fit&rdquo; classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poisson_nmf_fit'
summary(object, ...)

## S3 method for class 'multinom_topic_model_fit'
summary(object, ...)

## S3 method for class 'summary.poisson_nmf_fit'
print(x, show.mixprops = FALSE, show.topic.reps = FALSE, ...)

## S3 method for class 'summary.multinom_topic_model_fit'
print(
  x,
  show.size.factors = FALSE,
  show.mixprops = FALSE,
  show.topic.reps = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.poisson_nmf_fit_+3A_object">object</code></td>
<td>
<p>An object of class &ldquo;poisson_nmf_fit&rdquo; or
&ldquo;multinom_topic_model_fit&rdquo;. The former is usually the result
of calling <code><a href="#topic+fit_poisson_nmf">fit_poisson_nmf</a></code>; the latter is usually the
result of calling <code><a href="#topic+fit_topic_model">fit_topic_model</a></code> or
<code><a href="#topic+poisson2multinom">poisson2multinom</a></code>.</p>
</td></tr>
<tr><td><code id="summary.poisson_nmf_fit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the generic <code>summary</code>
or <code>print.summary</code> method.</p>
</td></tr>
<tr><td><code id="summary.poisson_nmf_fit_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;summary.poisson_nmf_fit&rdquo;,
usually a result of a call to <code>summary.poisson_nmf_fit</code>.</p>
</td></tr>
<tr><td><code id="summary.poisson_nmf_fit_+3A_show.mixprops">show.mixprops</code></td>
<td>
<p>If <code>TRUE</code>, print a summary of the mixture
proportions.</p>
</td></tr>
<tr><td><code id="summary.poisson_nmf_fit_+3A_show.topic.reps">show.topic.reps</code></td>
<td>
<p>If <code>TRUE</code>, print a summary of the topic
representatives.</p>
</td></tr>
<tr><td><code id="summary.poisson_nmf_fit_+3A_show.size.factors">show.size.factors</code></td>
<td>
<p>If <code>TRUE</code>, print a summary of the
size factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>summary.poisson_nmf_fit</code> and
<code>summary.multinom_topic_model_fit</code> compute and return a list
of statistics summarizing the model fit. The returned list
includes some or all of the following elements:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>The number of rows in the counts matrix, typically the
number of samples.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The number of columns in the counts matrix, typically the
number of observed counts per sample.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The rank of the Poisson NMF or the number of topics.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>A vector of length n giving the &quot;size factor&quot; estimates;
these estimates should be equal, or close to, the total counts in
each row of the counts matrix.</p>
</td></tr>
<tr><td><code>numiter</code></td>
<td>
<p>The number of loadings and/or factor updates
performed.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The Poisson NMF log-likelihood.</p>
</td></tr>
<tr><td><code>loglik.multinom</code></td>
<td>
<p>The multinomial topic model log-likelihood.</p>
</td></tr>
<tr><td><code>dev</code></td>
<td>
<p>The Poisson NMF deviance.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>The maximum residual of the Karush-Kuhn-Tucker (KKT)
first-order optimality conditions. This can be used to assess
convergence of the updates to a (local) solution.</p>
</td></tr>
<tr><td><code>mixprops</code></td>
<td>
<p>Matrix giving a high-level summary of the
mixture proportions, in which rows correspond to topics, and
columns are ranges of mixture proportionss.</p>
</td></tr>
<tr><td><code>topic.reps</code></td>
<td>
<p>A matrix in which the ith row gives the mixture
proportions for the sample &quot;most representative&quot; of topic i; by
&quot;most representative&quot;, we mean the row (or sample) with the highest
proportion of counts drawn from the topic i.</p>
</td></tr>
</table>

<hr>
<h2 id='volcano_plot'>Volcano Plots for Visualizing Results of Differential Expression Analysis</h2><span id='topic+volcano_plot'></span><span id='topic+plot.topic_model_de_analysis'></span><span id='topic+volcano_plotly'></span><span id='topic+volcano_plot_do_label_default'></span><span id='topic+volcano_plot_ggplot_call'></span><span id='topic+volcano_plot_ly_call'></span>

<h3>Description</h3>

<p>Create a &ldquo;volcano&rdquo; plot to visualize the
results of a differential count analysis using a topic model. Here,
the volcano plot is a scatterplot in which the posterior mean
log-fold change (LFC), estimated by running the methods implemented
in <code><a href="#topic+de_analysis">de_analysis</a></code>, is plotted against the estimated
z-score. Variations on this volcano plot may also be created, for
example by showing f0 (the null-model estimates) instead of the
z-scores. Use <code>volcano_plotly</code> to create an interactive
volcano plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volcano_plot(
  de,
  k,
  labels,
  y = c("z", "f0"),
  do.label = volcano_plot_do_label_default,
  ymin = 1e-06,
  ymax = Inf,
  max.overlaps = Inf,
  plot.title = paste("topic", k),
  ggplot_call = volcano_plot_ggplot_call
)

## S3 method for class 'topic_model_de_analysis'
plot(x, ...)

volcano_plotly(
  de,
  k,
  file,
  labels,
  y = c("z", "f0"),
  ymin = 1e-06,
  ymax = Inf,
  width = 500,
  height = 500,
  plot.title = paste("topic", k),
  plot_ly_call = volcano_plot_ly_call
)

volcano_plot_do_label_default(lfc, y)

volcano_plot_ggplot_call(dat, y, plot.title, max.overlaps = Inf, font.size = 9)

volcano_plot_ly_call(dat, y, plot.title, width, height)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volcano_plot_+3A_de">de</code></td>
<td>
<p>An object of class &ldquo;topic_model_de_analysis&rdquo;,
usually an output from <code><a href="#topic+de_analysis">de_analysis</a></code>. It is better to
run <code>de_analysis</code> with <code>shrink.method = "ash"</code> so that
the points in the volcano plot can be coloured by their local false
sign rate (lfsr).</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_k">k</code></td>
<td>
<p>The topic, selected by number or name.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_labels">labels</code></td>
<td>
<p>Character vector specifying how the points in the
volcano plot are labeled. This should be a character vector with
one entry per LFC estimate (row of <code>de$postmean</code>). When not
specified, the row names of <code>de$postmean</code> are used. When
available. labels are added to the plot using
<code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_y">y</code></td>
<td>
<p>A vector of the same length as <code>lfc</code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_do.label">do.label</code></td>
<td>
<p>The function used to deetermine which LFC estimates
to label. Replace <code>volcano_plot_do_label_default</code> with your
own function to customize the labeling of points in the volcano
plot.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_ymin">ymin</code></td>
<td>
<p>Y-axis values less than <code>ymin</code> are shown as
<code>ymin</code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_ymax">ymax</code></td>
<td>
<p>Y-axis values greater than <code>ymax</code> are shown as
<code>ymax</code>. When <code>y = "z"</code>, setting <code>ymax</code> to a finite
value can improve the volcano plot when some z-scores are much
larger (in magnitude) than others.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_max.overlaps">max.overlaps</code></td>
<td>
<p>Argument passed to
<code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_plot.title">plot.title</code></td>
<td>
<p>The title of the plot.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_ggplot_call">ggplot_call</code></td>
<td>
<p>The function used to create the plot. Replace
<code>volcano_plot_ggplot_call</code> with your own function to customize
the appearance of the plot.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_x">x</code></td>
<td>
<p>An object of class &ldquo;topic_model_de_analysis&rdquo;,
usually an output from <code><a href="#topic+de_analysis">de_analysis</a></code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>volcano_plot</code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_file">file</code></td>
<td>
<p>Save the interactive volcano plot to this HTML
file using <code><a href="htmlwidgets.html#topic+saveWidget">saveWidget</a></code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_width">width</code></td>
<td>
<p>Width of the plot in pixels. Passed as argument
&ldquo;width&rdquo; to <code><a href="plotly.html#topic+plot_ly">plot_ly</a></code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_height">height</code></td>
<td>
<p>Height of the plot in pixels. Passed as argument
&ldquo;height&rdquo; to <code><a href="plotly.html#topic+plot_ly">plot_ly</a></code>.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_plot_ly_call">plot_ly_call</code></td>
<td>
<p>The function used to create the plot. Replace
<code>volcano_plot_ly_call</code> with your own function to customize
the appearance of the interactive plot.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_lfc">lfc</code></td>
<td>
<p>A vector of log-fold change estimates.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_dat">dat</code></td>
<td>
<p>A data frame passed as input to
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, containing, at a minimum, columns
&ldquo;f0&rdquo;, &ldquo;postmean&rdquo;, &ldquo;y&rdquo;, &ldquo;lfsr&rdquo; and
&ldquo;label&rdquo;.</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_font.size">font.size</code></td>
<td>
<p>Font size used in plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interactive volcano plots can be created using the
&lsquo;plotly&rsquo; package. The &ldquo;hover text&rdquo; shows the label
and detailed LFC statistics.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object or a <code>plotly</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+de_analysis">de_analysis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See help(de_analysis) for examples.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
