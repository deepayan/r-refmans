<!DOCTYPE html><html lang="en"><head><title>Help for package drcarlate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {drcarlate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ATEDGP'><p>Simulates the data for ATE estimators</p></a></li>
<li><a href='#ATEJLTZ'><p>ATEJLTZ runs the code for ATE estimator</p></a></li>
<li><a href='#ATEOutput'><p>Computes linear, nonparametric and regularized ATE estimator</p></a></li>
<li><a href='#ATETrueValue'><p>Calculates the true ATE effect.</p></a></li>
<li><a href='#CovAdptRnd'><p>Generate treatment assignment under various CARs</p></a></li>
<li><a href='#data_table'>
<p>Data used to reproduce Table 5 results in Jiang et. al. (2022)</p></a></li>
<li><a href='#feasiblePostLassoMatTool'><p>Feasible Post Lasso Mat Tool</p></a></li>
<li><a href='#FuncDGP'><p>Generate Data for LATE</p></a></li>
<li><a href='#JLTZ'><p>Reproduce the results of the Jiang et al. (2022)</p></a></li>
<li><a href='#LinearLogit'><p>Linear Regression or Logit Regression</p></a></li>
<li><a href='#LogisticReg'><p>Logistic Regression Function</p></a></li>
<li><a href='#norminv'><p>Inverse of the normal cumulative distribution function (cdf)</p></a></li>
<li><a href='#Output'><p>Computes All the Estimators</p></a></li>
<li><a href='#pihat'><p>Compute Estimated Treatment Assignment Probabilities</p></a></li>
<li><a href='#splinebasis'><p>For each column of an input matrix, elements which are less than the median of that column are set to 0, leaving the rest of the elements unchanged</p></a></li>
<li><a href='#stanE'><p>Compute the Estimated Standard Error of the Input Estimator</p></a></li>
<li><a href='#tau'><p>Compute Estimated LATE</p></a></li>
<li><a href='#TrueValue'><p>Calculate the True LATE tau.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Improving Estimation Efficiency in CAR with Imperfect Compliance</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a list of functions for replicating the results of the Monte Carlo simulations and empirical application of Jiang et al. (2022). 
    In particular, we provide corresponding functions for generating the three types of random data described in this paper, as well as all the estimation strategies. 
    Detailed information about the data generation process and estimation strategy can be found in Jiang et al. (2022)  &lt;<a href="https://doi.org/10.48550%2FarXiv.2201.13004">doi:10.48550/arXiv.2201.13004</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>pracma, MASS, stringr, splus2R, glmnet, stats, purrr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-11 15:14:03 UTC; mingxin_zhang</td>
</tr>
<tr>
<td>Author:</td>
<td>Liang Jiang [aut, cph],
  Oliver B. Linton [aut, cph],
  Haihan Tang [aut, cph],
  Yichong Zhang [aut, cph],
  Mingxin Zhang [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mingxin Zhang &lt;21110680035@m.fudan.edu.cn&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-12 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ATEDGP'>Simulates the data for ATE estimators</h2><span id='topic+ATEDGP'></span>

<h3>Description</h3>

<p>ATEDGP is the version of FuncDGP under full compliance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATEDGP(dgptype, rndflag, n, g, pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ATEDGP_+3A_dgptype">dgptype</code></td>
<td>
<p>A scalar. 1, 2, 3 (Almost the same as 1-3 in the paper except that it does not have the DGP for D(1) or D(0)).</p>
</td></tr>
<tr><td><code id="ATEDGP_+3A_rndflag">rndflag</code></td>
<td>
<p>A scalar. method of covariate-adaptive randomization. 1-SRS; 2-WEI; 3-BCD; 4-SBR.</p>
</td></tr>
<tr><td><code id="ATEDGP_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="ATEDGP_+3A_g">g</code></td>
<td>
<p>Number of strata. The authors set g = 4 in the Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="ATEDGP_+3A_pi">pi</code></td>
<td>
<p>A g x 1 vector. Targeted assignment probabilities across strata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ATEDGP returns a list containing 7 nx1 vectors named Y, X, S, A, Y1, Y0 and D.
These seven vectors are the same as defined in Jiang et al. (2022).
Note that vector X does not contain the constant term.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ATEDGP(dgptype = 1, rndflag = 1, n = 200, g = 4, pi = c(0.5, 0.5, 0.5, 0.5))
</code></pre>

<hr>
<h2 id='ATEJLTZ'>ATEJLTZ runs the code for ATE estimator</h2><span id='topic+ATEJLTZ'></span>

<h3>Description</h3>

<p>ATEJLTZ is the version of JLTZ under full compliance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATEJLTZ(iMonte, dgptype, n, g, pi, iPert, iq = 0.05, iridge = 0.001, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ATEJLTZ_+3A_imonte">iMonte</code></td>
<td>
<p>A scalar. Monte Carlo sizes.</p>
</td></tr>
<tr><td><code id="ATEJLTZ_+3A_dgptype">dgptype</code></td>
<td>
<p>A scalar. The value can be string 1, 2, or 3,
respectively corresponding to the three DGP schemes in the paper (See Jiang et al. (2022) for DGP details).</p>
</td></tr>
<tr><td><code id="ATEJLTZ_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="ATEJLTZ_+3A_g">g</code></td>
<td>
<p>Number of strata. The authors set g=4 in Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="ATEJLTZ_+3A_pi">pi</code></td>
<td>
<p>Targeted assignment probability across strata.</p>
</td></tr>
<tr><td><code id="ATEJLTZ_+3A_ipert">iPert</code></td>
<td>
<p>A scalar. iPert = 0 means size. Otherwise means power: iPert is the perturbation of false null.</p>
</td></tr>
<tr><td><code id="ATEJLTZ_+3A_iq">iq</code></td>
<td>
<p>A scalar. Size of hypothesis testing. The authors set iq = 0.05 in Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="ATEJLTZ_+3A_iridge">iridge</code></td>
<td>
<p>A scalar. The penalization parameter in ridge regression.</p>
</td></tr>
<tr><td><code id="ATEJLTZ_+3A_seed">seed</code></td>
<td>
<p>A scalar. The random seed, the authors set seed = 1 in Jiang et al. (2022).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table summarizing the estimated results, mProd.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# size, iPert = 0
ATEJLTZ(iMonte = 10, dgptype = 1, n = 200, g = 4,
    pi = c(0.5, 0.5, 0.5, 0.5), iPert = 0, iq = 0.05, iridge = 0.001)

# power, iPert = 1
ATEJLTZ(iMonte = 10, dgptype = 1, n = 200, g = 4,
    pi = c(0.5, 0.5, 0.5, 0.5), iPert = 1, iq = 0.05, iridge = 0.001)
    
</code></pre>

<hr>
<h2 id='ATEOutput'>Computes linear, nonparametric and regularized ATE estimator</h2><span id='topic+ATEOutput'></span>

<h3>Description</h3>

<p>ATEOutput is the version of Output under full compliance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATEOutput(ii, tau, dgptype, rndflag, n, g, pi, iPert, iq, iridge)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ATEOutput_+3A_ii">ii</code></td>
<td>
<p>Monte Carlo index.</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_tau">tau</code></td>
<td>
<p>A scalar. The simulated true LATE effect.</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_dgptype">dgptype</code></td>
<td>
<p>A Scalar. 1, 2, 3 (See Jiang et al. (2022) for DGP details).</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_rndflag">rndflag</code></td>
<td>
<p>Method of CAR (covariate-adaptive randomizations).
Its value can be 1, 2, 3 or4. 1-SRS; 2-WEI; 3-BCD; 4-SBR.
See Jiang et al. (2022) for more details about CAR.</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_g">g</code></td>
<td>
<p>Number of strata. The authors set g=4 in Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_pi">pi</code></td>
<td>
<p>Targeted assignment probability across strata.</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_ipert">iPert</code></td>
<td>
<p>A scalar. iPert =0 means size. Otherwise means power: iPert is the perturbation of false null.</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_iq">iq</code></td>
<td>
<p>Size of hypothesis testing. We set iq = 0.05.</p>
</td></tr>
<tr><td><code id="ATEOutput_+3A_iridge">iridge</code></td>
<td>
<p>A scalar. The penalization parameter in ridge regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing four matrices named vtauhat, vsighat, vstat and vdeci respectively.
vtauhat is a 1x4 vector: (1) L (2) NL (3) R(dgp = 1 or 2) (4) R(dgp = 3).
vsighat is a 1x4 vector: unscaled standard errors for vtauhat.
vstat is a 1x4 vector: test statistic.
vdeci is a 1x4 logical vector: if applicable, 1 means rejecting the null. 0 means not rejecting the null.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ATEOutput(ii = 1, tau = 0.9122762, dgptype = 1,
        rndflag = 4, n = 2000, g = 4, pi = c(0.5,0.5,0.5,0.5),
        iPert = 1, iq = 0.05, iridge = 0.001)
        

</code></pre>

<hr>
<h2 id='ATETrueValue'>Calculates the true ATE effect.</h2><span id='topic+ATETrueValue'></span>

<h3>Description</h3>

<p>ATETrueValue is the version of TrueValue under full compliance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATETrueValue(dgptype, vIdx, n, g, pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ATETrueValue_+3A_dgptype">dgptype</code></td>
<td>
<p>A scalar. The value can be string 1, 2, or 3,
respectively corresponding to the three DGP schemes in the paper (See Jiang et al. (2022) for DGP details).</p>
</td></tr>
<tr><td><code id="ATETrueValue_+3A_vidx">vIdx</code></td>
<td>
<p>A 1xR vector. The authors set vIdx=[1 2 3 4] in Jiang et al. (2022). Every number declares the method of covariate-adaptive randomization.
1-SRS; 2-WEI; 3-BCD; 4-SBR.</p>
</td></tr>
<tr><td><code id="ATETrueValue_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="ATETrueValue_+3A_g">g</code></td>
<td>
<p>Number of strata. The authors set g=4 in Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="ATETrueValue_+3A_pi">pi</code></td>
<td>
<p>Targeted assignment probability across strata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 1xR vector. Simulated true ATE effect.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ATETrueValue(dgptype = 1, vIdx = c(1,2,3,4), n = 100, g = 4, pi = c(0.5,0.5,0.5,0.5))
 ATETrueValue(dgptype = 2, vIdx = c(1,2,3,4), n = 100, g = 4, pi = c(0.5,0.5,0.5,0.5))
 ATETrueValue(dgptype = 3, vIdx = c(1,2,3,4), n = 100, g = 4, pi = c(0.5,0.5,0.5,0.5))
 
</code></pre>

<hr>
<h2 id='CovAdptRnd'>Generate treatment assignment under various CARs</h2><span id='topic+CovAdptRnd'></span>

<h3>Description</h3>

<p>Generate treatment assignment under various CARs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovAdptRnd(rndflag, S, pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CovAdptRnd_+3A_rndflag">rndflag</code></td>
<td>
<p>Index of the assignment rule. 1 for SRS; 2 for WEI; 3 for BCD; 4 for SBR</p>
</td></tr>
<tr><td><code id="CovAdptRnd_+3A_s">S</code></td>
<td>
<p>A nx1 vector.</p>
</td></tr>
<tr><td><code id="CovAdptRnd_+3A_pi">pi</code></td>
<td>
<p>Targeted assignment probability across strata. It should be a vector with the length of max(S),
It should be noted that the treatment assignment process is independent of pi when rndflag == 2 or 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nx1 treatment assignment vector generated according to the specified method.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CovAdptRnd(rndflag = 1, S = matrix(sample(1:4,100,TRUE)), pi = c(0.5, 0.5, 0.5, 0.5))
CovAdptRnd(rndflag = 2, S = matrix(sample(1:4,100,TRUE)), pi = c(0.5, 0.5, 0.5, 0.5))
CovAdptRnd(rndflag = 3, S = matrix(sample(1:4,100,TRUE)), pi = c(0.5, 0.5, 0.5, 0.5))
CovAdptRnd(rndflag = 4, S = matrix(sample(1:4,100,TRUE)), pi = c(0.5, 0.5, 0.5, 0.5))

</code></pre>

<hr>
<h2 id='data_table'>
Data used to reproduce Table 5 results in Jiang et. al. (2022)
</h2><span id='topic+data_table'></span>

<h3>Description</h3>

<p>Data used to reproduce Table 5 results in Jiang et. al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_table")</code></pre>


<h3>Format</h3>

<p>A data frame with 2159 observations on the following 69 variables.
</p>

<dl>
<dt><code>X1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X4</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X5</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X6</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X7</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X8</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X9</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X10</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X11</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X12</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X13</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X14</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X15</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X16</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X17</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X18</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X19</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X20</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X21</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X22</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X23</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X24</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X25</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X26</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X27</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X28</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X29</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X30</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X31</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X32</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X33</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X34</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X35</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X36</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X37</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X38</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X39</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X40</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X41</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X42</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X43</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X44</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X45</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X46</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X47</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X48</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X49</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X50</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X51</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X52</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X53</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X54</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X55</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X56</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X57</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X58</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X59</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X60</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X61</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X62</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X63</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X64</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X65</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X66</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X67</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X68</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>X69</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>

<hr>
<h2 id='feasiblePostLassoMatTool'>Feasible Post Lasso Mat Tool</h2><span id='topic+feasiblePostLassoMatTool'></span>

<h3>Description</h3>

<p>Under the condition of high dimensional data,
the function first selects covariables through lasso regression,
then performs logit regression or linear regression according to the caller's requirements,
and finally returns the adjusted Lasso regression coefficient vector.
This function has been slightly adapted for this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feasiblePostLassoMatTool(
  x,
  y,
  MaxIter = 30,
  UpsTol = 1e-06,
  beta0 = c(),
  clusterVar = c(),
  Dist = "normal",
  link = "identity",
  glmTol = 1e-08,
  initScale = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feasiblePostLassoMatTool_+3A_x">x</code></td>
<td>
<p>A nxk Matrix.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_y">y</code></td>
<td>
<p>A nx1 vector.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_maxiter">MaxIter</code></td>
<td>
<p>Maximum iteration. The default value is 30.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_upstol">UpsTol</code></td>
<td>
<p>Upper limit of tolerance. The default value is 1e-6.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_beta0">beta0</code></td>
<td>
<p>NULL.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_clustervar">clusterVar</code></td>
<td>
<p>NULL.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_dist">Dist</code></td>
<td>
<p>The default value is normal.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_link">link</code></td>
<td>
<p>Link can be identity or logit.
This determines the method used for regression with the selected write variable after lasso.
See Jiang et al. (2022) for more details.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_glmtol">glmTol</code></td>
<td>
<p>Maximum tolerance in GLM. The default value is 1e-8.</p>
</td></tr>
<tr><td><code id="feasiblePostLassoMatTool_+3A_initscale">initScale</code></td>
<td>
<p>Initial scale, the default value is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kx1 cector, the coefficients b.
</p>


<h3>References</h3>

<p>Belloni, A., Chernozhukov, V., Fernández-Val, I. and Hansen, C. (2017), Program Evaluation and Causal Inference With High-Dimensional Data. Econometrica, 85: 233-298. https://doi.org/10.3982/ECTA12723
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
# Notice that when we set dgptype = 3, FuncDGP will generate a high dimensional data for us.
DGP &lt;- FuncDGP(dgptype = 3, rndflag = 1, n = 10000, g = 4, pi = c(0.5, 0.5, 0.5, 0.5))
X &lt;- DGP$X
Y &lt;- DGP$Y
A &lt;- DGP$A
S &lt;- DGP$S
D &lt;- DGP$D
feasiblePostLassoMatTool(x = X[S==1 &amp; A==0,], y = Y[S==1 &amp; A==0,])
feasiblePostLassoMatTool(x = X[S==1 &amp; A==0,], y = D[S==1 &amp; A==0,], link = "logit")


</code></pre>

<hr>
<h2 id='FuncDGP'>Generate Data for LATE</h2><span id='topic+FuncDGP'></span>

<h3>Description</h3>

<p>Generate data according to one of the three DGPs in Jiang et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FuncDGP(dgptype, rndflag, n, g, pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FuncDGP_+3A_dgptype">dgptype</code></td>
<td>
<p>A Scalar. 1, 2, 3 (See Jiang et al. (2022) for DGP details)</p>
</td></tr>
<tr><td><code id="FuncDGP_+3A_rndflag">rndflag</code></td>
<td>
<p>A Scalar. Declare the method of covariate-adaptive randomization. 1-SRS; 2-WEI; 3-BCD; 4-SBR.</p>
</td></tr>
<tr><td><code id="FuncDGP_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="FuncDGP_+3A_g">g</code></td>
<td>
<p>Number of strata. The authors set g=4 in the Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="FuncDGP_+3A_pi">pi</code></td>
<td>
<p>Targeted assignment probability across strata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FuncDGP returns a list containing 9 nx1 vectors named Y, X, S, A, Y1, Y0, D1, D0 and D.
These nine vectors are the same as defined in Jiang et al. (2022).
Note that vector X does not contain the constant term.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FuncDGP(dgptype = 1, rndflag = 1, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 1, rndflag = 2, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 1, rndflag = 3, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 1, rndflag = 4, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))

FuncDGP(dgptype = 2, rndflag = 1, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 2, rndflag = 2, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 2, rndflag = 3, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 2, rndflag = 4, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))

FuncDGP(dgptype = 3, rndflag = 1, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 3, rndflag = 2, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 3, rndflag = 3, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
FuncDGP(dgptype = 3, rndflag = 4, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
</code></pre>

<hr>
<h2 id='JLTZ'>Reproduce the results of the Jiang et al. (2022)</h2><span id='topic+JLTZ'></span>

<h3>Description</h3>

<p>Helps the user reproduce the results of the data simulation section of Jiang et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JLTZ(iMonte, dgptype, n, g, pi, iPert, iq = 0.05, iridge = 0.001, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JLTZ_+3A_imonte">iMonte</code></td>
<td>
<p>A scalar. Monte Carlo sizes.</p>
</td></tr>
<tr><td><code id="JLTZ_+3A_dgptype">dgptype</code></td>
<td>
<p>A scalar. The value can be string 1, 2, or 3,
respectively corresponding to the three random data generation methods in the paper (See Jiang et al. (2022) for DGP details).</p>
</td></tr>
<tr><td><code id="JLTZ_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="JLTZ_+3A_g">g</code></td>
<td>
<p>Number of strata. We set g=4 in Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="JLTZ_+3A_pi">pi</code></td>
<td>
<p>Targeted assignment probability across strata.</p>
</td></tr>
<tr><td><code id="JLTZ_+3A_ipert">iPert</code></td>
<td>
<p>A scalar. iPert = 0 means size. Otherwise means power: iPert is the perturbation of false null.</p>
</td></tr>
<tr><td><code id="JLTZ_+3A_iq">iq</code></td>
<td>
<p>A scalar. Size of hypothesis testing. The authors set iq = 0.05.</p>
</td></tr>
<tr><td><code id="JLTZ_+3A_iridge">iridge</code></td>
<td>
<p>A scalar. The penalization parameter in ridge regression.</p>
</td></tr>
<tr><td><code id="JLTZ_+3A_seed">seed</code></td>
<td>
<p>A scalar. The random seed, the authors set seed = 1 in Jiang et al. (2022).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table summarizing the estimated results, mProd.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# size, iPert = 0
JLTZ(iMonte = 10, dgptype = 1, n = 200, g = 4,
    pi = c(0.5, 0.5, 0.5, 0.5), iPert = 0, iq = 0.05, iridge = 0.001, seed = 1)

# power, iPert = 1
JLTZ(iMonte = 10, dgptype = 1, n = 200, g = 4,
    pi = c(0.5, 0.5, 0.5, 0.5), iPert = 1, iq = 0.05, iridge = 0.001, seed = 1)

</code></pre>

<hr>
<h2 id='LinearLogit'>Linear Regression or Logit Regression</h2><span id='topic+LinearLogit'></span>

<h3>Description</h3>

<p>LinearLogit generates estimated pseudo true values for parametric models.
Different estimation strategies are adopted according to different values of modelflag.
See Jiang et al. (2022) for more details about different strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinearLogit(Y, D, A, X, S, s, modelflag, iridge)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LinearLogit_+3A_y">Y</code></td>
<td>
<p>The outcome vector. A nx1 vector.</p>
</td></tr>
<tr><td><code id="LinearLogit_+3A_d">D</code></td>
<td>
<p>A nx1 vector.</p>
</td></tr>
<tr><td><code id="LinearLogit_+3A_a">A</code></td>
<td>
<p>The treatment assignment. A nx1 vector.</p>
</td></tr>
<tr><td><code id="LinearLogit_+3A_x">X</code></td>
<td>
<p>Extra covariate matrix, A nxK matrix without constant.</p>
</td></tr>
<tr><td><code id="LinearLogit_+3A_s">S</code></td>
<td>
<p>The strata variable.</p>
</td></tr>
<tr><td><code id="LinearLogit_+3A_s">s</code></td>
<td>
<p>A particular stratum.</p>
</td></tr>
<tr><td><code id="LinearLogit_+3A_modelflag">modelflag</code></td>
<td>
<p>Its value ranges from characters 1, 2, and 3, respectively declaring different estimation strategies.
1-L; 2-NL; 3-R.</p>
</td></tr>
<tr><td><code id="LinearLogit_+3A_iridge">iridge</code></td>
<td>
<p>A scalar. The penalization parameter in ridge regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta_0s, theta_1s, beta_0s, beta_1s are estimated coefficients vectors.
The dimension is Kx1 if modelflag = 1; (K+1)x1 if modelflag = 2 or 3.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' set.seed(1)
DGP &lt;- FuncDGP(dgptype = 3, rndflag = 1, n = 10000, g = 4, pi = c(0.5, 0.5, 0.5, 0.5))
X &lt;- DGP$X
Y &lt;- DGP$Y
A &lt;- DGP$A
S &lt;- DGP$S
D &lt;- DGP$D
LinearLogit(Y = Y, D = D, A = A, X = X, S = S, s = 1, modelflag = 1, iridge = 0.001)
LinearLogit(Y = Y, D = D, A = A, X = X, S = S, s = 2, modelflag = 2, iridge = 0.001)
LinearLogit(Y = Y, D = D, A = A, X = X, S = S, s = 3, modelflag = 3, iridge = 0.001)
LinearLogit(Y = Y, D = D, A = A, X = X, S = S, s = 4, modelflag = 3, iridge = 0.001)

</code></pre>

<hr>
<h2 id='LogisticReg'>Logistic Regression Function</h2><span id='topic+LogisticReg'></span>

<h3>Description</h3>

<p>Logestic CDF(cumulative distribution function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogisticReg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LogisticReg_+3A_x">x</code></td>
<td>
<p>A nx1 matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y A nx1 matrix.
y equals to exp(x)/(1+exp(x)) if y is not NA and 0 else.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- pracma::rand(5,1)
y &lt;- LogisticReg(x = x)

</code></pre>

<hr>
<h2 id='norminv'>Inverse of the normal cumulative distribution function (cdf)</h2><span id='topic+norminv'></span>

<h3>Description</h3>

<p>Returns the inverse cdf for the normal distribution with mean MU and standard deviation SIGMA at P value
Reference: https://rdrr.io/github/maxto/qapi/src/R/stats.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norminv(p, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norminv_+3A_p">p</code></td>
<td>
<p>probability value in range 0-1</p>
</td></tr>
<tr><td><code id="norminv_+3A_mu">mu</code></td>
<td>
<p>mean value</p>
</td></tr>
<tr><td><code id="norminv_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- c(0.003,0.026,0.015,-0.009,-0.014,-0.024,0.015,0.066,-0.014,0.039)
norminv(0.01,mean(xx),sd(xx))
</code></pre>

<hr>
<h2 id='Output'>Computes All the Estimators</h2><span id='topic+Output'></span>

<h3>Description</h3>

<p>Output is an integrated function that computes all the estimates (including NA, TSLS, L, NL, F, NP, R) used in Jiang et al. (2022).
See the paper for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Output(ii, tau, dgptype, rndflag, n, g, pi, iPert, iq, iridge)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Output_+3A_ii">ii</code></td>
<td>
<p>Monte Carlo index.</p>
</td></tr>
<tr><td><code id="Output_+3A_tau">tau</code></td>
<td>
<p>A scalar. The simulated true LATE effect.</p>
</td></tr>
<tr><td><code id="Output_+3A_dgptype">dgptype</code></td>
<td>
<p>A Scalar. 1, 2, 3 (See Jiang et al. (2022) for DGP details).</p>
</td></tr>
<tr><td><code id="Output_+3A_rndflag">rndflag</code></td>
<td>
<p>Method of CAR (covariate-adaptive randomizations).
Its value can be 1, 2, 3 or4. 1-SRS; 2-WEI; 3-BCD; 4-SBR.
See Jiang et al. (2022) for more details about CAR.</p>
</td></tr>
<tr><td><code id="Output_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="Output_+3A_g">g</code></td>
<td>
<p>Number of strata. The authors set g=4 in Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="Output_+3A_pi">pi</code></td>
<td>
<p>Targeted assignment probability across strata.</p>
</td></tr>
<tr><td><code id="Output_+3A_ipert">iPert</code></td>
<td>
<p>A scalar. iPert =0 means size. Otherwise means power: iPert is the perturbation of false null.</p>
</td></tr>
<tr><td><code id="Output_+3A_iq">iq</code></td>
<td>
<p>Size of hypothesis testing. The authors set iq = 0.05 in Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="Output_+3A_iridge">iridge</code></td>
<td>
<p>A scalar. The penalization parameter in ridge regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing four matrices named vtauhat, vsighat, vstat and vdeci respectively.
vtauhat is a 1x8 vector: (1) NA (2) LP (3) LG (4) F (5) NP (6) R (when dgp = 3) (7) 2SLS (8) R (when dgp = 1 or 2).
vsighat is a 1x8 vector: unscaled standard errors for vtauhat.
vstat is a 1x8 vector: test statistic.
vdeci is a 1x8 logical vector: if applicable, 1 means rejecting the null. 0 means not rejecting the null.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Output(ii = 1, tau = 0.9122762, dgptype = 1,
       rndflag = 4, n = 2000, g = 4, pi = c(0.5,0.5,0.5,0.5),
       iPert = 1, iq = 0.05, iridge = 0.001)
</code></pre>

<hr>
<h2 id='pihat'>Compute Estimated Treatment Assignment Probabilities</h2><span id='topic+pihat'></span>

<h3>Description</h3>

<p>Pihat computes the targeted treatment assignment probabilities across all strata in Jiang et al. (2022) and stacks them in an nx1 vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pihat(A, S, stratnum = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pihat_+3A_a">A</code></td>
<td>
<p>A nx1 vector.</p>
</td></tr>
<tr><td><code id="pihat_+3A_s">S</code></td>
<td>
<p>A nx1 vector.</p>
</td></tr>
<tr><td><code id="pihat_+3A_stratnum">stratnum</code></td>
<td>
<p>A nx1 vector about the unique strara numbers, the default value is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nx1 cector, each element corresponds to the targeted treatment assignment probabilities across all strata in Jiang et al. (2022).
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DGP &lt;-FuncDGP(dgptype = 1,rndflag = 2,n = 100,g = 4,pi = c(0.5, 0.5, 0.5, 0.5))
A &lt;- DGP[["A"]]
S &lt;- DGP[["S"]]
pihat(A = A, S = S)

</code></pre>

<hr>
<h2 id='splinebasis'>For each column of an input matrix, elements which are less than the median of that column are set to 0, leaving the rest of the elements unchanged</h2><span id='topic+splinebasis'></span>

<h3>Description</h3>

<p>For each column of an input matrix, elements which are less than the median of that column are set to 0, leaving the rest of the elements unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splinebasis(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splinebasis_+3A_x">X</code></td>
<td>
<p>The extra covariates, a n x K matrix. No constant included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>H A n x K matrix. All elements of the X that are less than
the median of their corresponding columns are set to 0, leaving the rest unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pracma)
X &lt;- rand(4,4)
H &lt;- splinebasis(X = X)

</code></pre>

<hr>
<h2 id='stanE'>Compute the Estimated Standard Error of the Input Estimator</h2><span id='topic+stanE'></span>

<h3>Description</h3>

<p>stanE Computes the estimated standard error of the input estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanE(muY1, muY0, muD1, muD0, A, S, Y, D, tauhat, stratnum = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stanE_+3A_muy1">muY1</code></td>
<td>
<p>A nx1 vector of hat{mu}^Y(A=1)s.</p>
</td></tr>
<tr><td><code id="stanE_+3A_muy0">muY0</code></td>
<td>
<p>A nx1 vector of hat{mu}^Y(A=0)s.</p>
</td></tr>
<tr><td><code id="stanE_+3A_mud1">muD1</code></td>
<td>
<p>A nx1 vector of hat{mu}^D(A=1)s.</p>
</td></tr>
<tr><td><code id="stanE_+3A_mud0">muD0</code></td>
<td>
<p>A nx1 vector of hat{mu}^D(A=0)s.</p>
</td></tr>
<tr><td><code id="stanE_+3A_a">A</code></td>
<td>
<p>A nx1 vector. Each of its elements is the treatment assignment of the corresponding observation.</p>
</td></tr>
<tr><td><code id="stanE_+3A_s">S</code></td>
<td>
<p>A nx1 vector. Each of its elements is the stratum of corresponding observation.</p>
</td></tr>
<tr><td><code id="stanE_+3A_y">Y</code></td>
<td>
<p>A nx1 vector. Each of its elements is the observed outcome of interest of corresponding observation.</p>
</td></tr>
<tr><td><code id="stanE_+3A_d">D</code></td>
<td>
<p>A nx1 vector. Each of its elements is is a binary random variable indicating whether the individual i received treatment (Di = 1) or not (Di = 0) in the actual study.</p>
</td></tr>
<tr><td><code id="stanE_+3A_tauhat">tauhat</code></td>
<td>
<p>A scalar. LATE estimate.</p>
</td></tr>
<tr><td><code id="stanE_+3A_stratnum">stratnum</code></td>
<td>
<p>A scalar. Number of stratum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar. The estimated standard deviation in Jiang et al. (2022).
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DGP &lt;- FuncDGP(dgptype = 1, rndflag = 1, n = 200, g = 4, pi = c(0.5,0.5,0.5,0.5))
muY1 &lt;- DGP[["Y1"]]
muY0 &lt;- DGP[["Y0"]]
muD1 &lt;- DGP[["D1"]]
muD0 &lt;- DGP[["D0"]]
A &lt;- DGP[["A"]]
S &lt;- DGP[["S"]]
Y &lt;- DGP[["Y"]]
D &lt;- DGP[["D"]]
tauhat &lt;- tau(muY1, muY0, muD1, muD0, A, S, Y, D)
stanE(muY1, muY0, muD1, muD0, A, S, Y, D, tauhat)

</code></pre>

<hr>
<h2 id='tau'>Compute Estimated LATE</h2><span id='topic+tau'></span>

<h3>Description</h3>

<p>Computes the estimated LATE in Jiang et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau(muY1, muY0, muD1, muD0, A, S, Y, D, stratnum = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tau_+3A_muy1">muY1</code></td>
<td>
<p>A nx1 vector of hat{mu}^Y(A=1)s.</p>
</td></tr>
<tr><td><code id="tau_+3A_muy0">muY0</code></td>
<td>
<p>A nx1 vector of hat{mu}^Y(A=0)s.</p>
</td></tr>
<tr><td><code id="tau_+3A_mud1">muD1</code></td>
<td>
<p>A nx1 vector of hat{mu}^D(A=1)s.</p>
</td></tr>
<tr><td><code id="tau_+3A_mud0">muD0</code></td>
<td>
<p>A nx1 vector of hat{mu}^D(A=0)s.</p>
</td></tr>
<tr><td><code id="tau_+3A_a">A</code></td>
<td>
<p>A nx1 vector. Each of its elements is the treatment assignment of the corresponding observation.</p>
</td></tr>
<tr><td><code id="tau_+3A_s">S</code></td>
<td>
<p>A nx1 vector. Each of its elements is the stratum of corresponding observation.</p>
</td></tr>
<tr><td><code id="tau_+3A_y">Y</code></td>
<td>
<p>A nx1 vector. Each of its elements is the observed outcome of interest of corresponding observation.</p>
</td></tr>
<tr><td><code id="tau_+3A_d">D</code></td>
<td>
<p>A nx1 vector. Each of its elements is is a binary random variable indicating whether the individual i received treatment (Di = 1) or not (Di = 0) in the actual study.</p>
</td></tr>
<tr><td><code id="tau_+3A_stratnum">stratnum</code></td>
<td>
<p>A nx1 vector about the unique strata numbers, the default value is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar. LATE estimate.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DGP &lt;- FuncDGP(dgptype = 1, rndflag = 1, n = 200, g = 4, pi = c(0.5, 0.5, 0.5, 0.5))
muY1 &lt;- DGP[["Y1"]]
muY0 &lt;- DGP[["Y0"]]
muD1 &lt;- DGP[["D1"]]
muD0 &lt;- DGP[["D0"]]
A &lt;- DGP[["A"]]
S &lt;- DGP[["S"]]
Y &lt;- DGP[["Y"]]
D &lt;- DGP[["D"]]
tau(muY1, muY0, muD1, muD0, A, S, Y, D)


</code></pre>

<hr>
<h2 id='TrueValue'>Calculate the True LATE tau.</h2><span id='topic+TrueValue'></span>

<h3>Description</h3>

<p>Calculate the true LATE tau in Jiang et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TrueValue(dgptype, vIdx, n, g, pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TrueValue_+3A_dgptype">dgptype</code></td>
<td>
<p>A scalar. The value can be string 1, 2, or 3,
respectively corresponding to the three random data generation methods in the paper (See Jiang et al. (2022)for DGP details)</p>
</td></tr>
<tr><td><code id="TrueValue_+3A_vidx">vIdx</code></td>
<td>
<p>A 1xR vector. The authors set vIdx=[1 2 3 4]. Every number declares the method of covariate-adaptive randomization
which simulates the LATE across different CAR schemes: 1-SRS; 2-WEI; 3-BCD; 4-SBR.</p>
</td></tr>
<tr><td><code id="TrueValue_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="TrueValue_+3A_g">g</code></td>
<td>
<p>Number of strata. The authors set g=4 in Jiang et al. (2022).</p>
</td></tr>
<tr><td><code id="TrueValue_+3A_pi">pi</code></td>
<td>
<p>Targeted assignment probability across strata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two vectors named tau and mPort.
tau is a 1xR vector which Simulated true LATE effect, mPort is a 3xR vector.
The 1st row of mPort: the LATE of never takers across varies CAR schemes,
the 2nd row of mPort: the LATE of compilers across varies CAR schemes,
the 3rd row of mPort: the LATE of always takers across varies CAR schemes.
</p>


<h3>References</h3>

<p>Jiang L, Linton O B, Tang H, Zhang Y. Improving estimation efficiency via regression-adjustment in covariate-adaptive randomizations with imperfect compliance [J]. 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 TrueValue(dgptype = 1, vIdx = c(1,2,3,4), n=100, g = 4, pi = c(0.5,0.5,0.5,0.5))
 TrueValue(dgptype = 2, vIdx = c(1,2,3,4), n=100, g = 4, pi = c(0.5,0.5,0.5,0.5))
 TrueValue(dgptype = 3, vIdx = c(1,2,3,4), n=100, g = 4, pi = c(0.5,0.5,0.5,0.5))
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
