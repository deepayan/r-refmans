<!DOCTYPE html><html lang="en"><head><title>Help for package ISS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ISS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dag_test_FS'><p>dag_test_FS</p></a></li>
<li><a href='#dag_test_Holm'><p>dag_test_Holm</p></a></li>
<li><a href='#dag_test_ISS'><p>dag_test_ISS</p></a></li>
<li><a href='#dag_test_MG'><p>dag_test_MG</p></a></li>
<li><a href='#get_boundary_points'><p>get_boundary_points</p></a></li>
<li><a href='#get_DAG'><p>get_DAG</p></a></li>
<li><a href='#get_p_classification'><p>get_p_classification</p></a></li>
<li><a href='#get_p_Gaussian'><p>get_p_Gaussian</p></a></li>
<li><a href='#get_p_subGaussian'><p>get_p_subGaussian</p></a></li>
<li><a href='#get_p_subGaussian_NM'><p>get_p_subGaussian_NM</p></a></li>
<li><a href='#get_p_value'><p>get_p_value</p></a></li>
<li><a href='#ISS'><p>ISS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Isotonic Subgroup Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Methodology for subgroup selection in the context of isotonic regression including methods for sub-Gaussian errors, classification, homoscedastic Gaussian errors and quantile regression. See the documentation of ISS(). Details can be found in the paper by Müller, Reeve, Cannings and Samworth (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2305.04852">doi:10.48550/arXiv.2305.04852</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, stats, Rdpack (&ge; 0.7)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-06 12:18:47 UTC; manuel</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel M. Müller [aut, cre],
  Henry W. J. Reeve [aut],
  Timothy I. Cannings [aut],
  Richard J. Samworth [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel M. Müller &lt;mm2559@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-06 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dag_test_FS'>dag_test_FS</h2><span id='topic+dag_test_FS'></span>

<h3>Description</h3>

<p>Implements the fixed sequence testing procedure of familywise error rate control. The sequence is given through ordering elements of <code>p_order</code> increasingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag_test_FS(p_order, p, alpha, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag_test_FS_+3A_p_order">p_order</code></td>
<td>
<p>a numeric vector or matrix with one column whose order determines the sequence of tests.</p>
</td></tr>
<tr><td><code id="dag_test_FS_+3A_p">p</code></td>
<td>
<p>a numeric vector taking values in (0, 1] such that <code>length(p) == nrow(p_order)</code> if p_order is a matrix (or <code>length(p) == length(p_order)</code> if p_order is a numeric vector).</p>
</td></tr>
<tr><td><code id="dag_test_FS_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value in (0, 1] specifying the Type I error rate.</p>
</td></tr>
<tr><td><code id="dag_test_FS_+3A_decreasing">decreasing</code></td>
<td>
<p>a boolean value determining whether the order of p_order should be understood in decreasing order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean vector of the same length as <code>p</code> with each element being <code>TRUE</code> if the corresponding hypothesis is rejected and <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_order &lt;- c(0.5, 0, 1)
p &lt;- c(0.01, 0.1, 0.05)
alpha &lt;- 0.05
dag_test_FS(p_order, p, alpha, decreasing = TRUE)

</code></pre>

<hr>
<h2 id='dag_test_Holm'>dag_test_Holm</h2><span id='topic+dag_test_Holm'></span>

<h3>Description</h3>

<p>Given a vector of p-values, each concerning a row in the matrix X0,
<code>dag_test_Holm()</code> first applies Holm's method to the p-values and then also rejects
hypotheses corresponding to points coordinate-wise greater or equal to any
point whose hypothesis has been rejected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag_test_Holm(X0, p, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag_test_Holm_+3A_x0">X0</code></td>
<td>
<p>a numeric matrix giving points corresponding to hypotheses.</p>
</td></tr>
<tr><td><code id="dag_test_Holm_+3A_p">p</code></td>
<td>
<p>a numeric vector taking values in (0, 1] such that <code>length(p) == nrow(X0)</code>.</p>
</td></tr>
<tr><td><code id="dag_test_Holm_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value in (0, 1] specifying the Type I error rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean vector of the same length as <code>p</code> with each element being <code>TRUE</code> if the corresponding hypothesis is rejected and <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X0 &lt;- rbind(c(0.5, 0.5), c(0.8, 0.9), c(0.4, 0.6))
p &lt;- c(0.01, 0.1, 0.05)
alpha &lt;- 0.05
dag_test_Holm(X0, p, alpha)

</code></pre>

<hr>
<h2 id='dag_test_ISS'>dag_test_ISS</h2><span id='topic+dag_test_ISS'></span>

<h3>Description</h3>

<p>Implements the DAG testing procedure given in Algorithm 1 by Müller et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag_test_ISS(X0, p, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag_test_ISS_+3A_x0">X0</code></td>
<td>
<p>a numeric matrix giving points corresponding to hypotheses.</p>
</td></tr>
<tr><td><code id="dag_test_ISS_+3A_p">p</code></td>
<td>
<p>a numeric vector taking values in (0, 1] such that <code>length(p) == nrow(X0)</code>.</p>
</td></tr>
<tr><td><code id="dag_test_ISS_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value in (0, 1] specifying the Type I error rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean vector of the same length as <code>p</code> with each element being <code>TRUE</code> if the corresponding hypothesis is rejected and <code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Müller MM, Reeve HWJ, Cannings TI, Samworth RJ (2023).
&ldquo;Isotonic subgroup selection.&rdquo;
<em>arXiv preprint arXiv:2305.04852</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X0 &lt;- rbind(c(0.5, 0.6), c(0.8, 0.9), c(0.9, 0.8))
p &lt;- c(0.02, 0.025, 0.1)
alpha &lt;- 0.05
dag_test_ISS(X0, p, alpha)

</code></pre>

<hr>
<h2 id='dag_test_MG'>dag_test_MG</h2><span id='topic+dag_test_MG'></span>

<h3>Description</h3>

<p>Implements the graph-testing procedures proposed by
Meijer and Goeman (2015) for one-way logical relationships.
Here implemented for the specific application to isotonic subgroup selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag_test_MG(
  X0,
  p,
  alpha,
  version = c("all", "any"),
  leaf_weights,
  sparse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dag_test_MG_+3A_x0">X0</code></td>
<td>
<p>a numeric matrix giving points corresponding to hypotheses.</p>
</td></tr>
<tr><td><code id="dag_test_MG_+3A_p">p</code></td>
<td>
<p>a numeric vector taking values in (0, 1] such that <code>length(p) == nrow(X0)</code>.</p>
</td></tr>
<tr><td><code id="dag_test_MG_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value in (0, 1] specifying the Type I error rate.</p>
</td></tr>
<tr><td><code id="dag_test_MG_+3A_version">version</code></td>
<td>
<p>either <code>"all"</code>
for the all-parent version of the procedure or <code>"any"</code> for the any-parent version of the procedure.</p>
</td></tr>
<tr><td><code id="dag_test_MG_+3A_leaf_weights">leaf_weights</code></td>
<td>
<p>optional weights for the leaf nodes. Would have to be a numeric vector
of the same length as there are leaf nodes in the DAG (resp. polytree, see <code>sparse</code>) induced by <code>X0</code>.</p>
</td></tr>
<tr><td><code id="dag_test_MG_+3A_sparse">sparse</code></td>
<td>
<p>a logical value specifying whether <code>X0</code> should be used to
induce a DAG (<code>FALSE</code>) or a polytree (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean vector of the same length as <code>p</code> with each element being <code>TRUE</code> if the corresponding hypothesis is rejected and <code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Meijer RJ, Goeman JJ (2015).
&ldquo;A multiple testing method for hypotheses structured in a directed acyclic graph.&rdquo;
<em>Biometrical Journal</em>, <b>57</b>(1), 123&ndash;143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X0 &lt;- rbind(c(0.5, 0.6), c(0.8, 0.9), c(0.9, 0.8))
p &lt;- c(0.02, 0.025, 0.1)
alpha &lt;- 0.05
dag_test_MG(X0, p, alpha)
dag_test_MG(X0, p, alpha, version = "any")
dag_test_MG(X0, p, alpha, sparse = TRUE)

</code></pre>

<hr>
<h2 id='get_boundary_points'>get_boundary_points</h2><span id='topic+get_boundary_points'></span>

<h3>Description</h3>

<p>Given a set of points, returns the minimal subset with the same upper hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boundary_points(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_boundary_points_+3A_x">X</code></td>
<td>
<p>a numeric matrix with one point per row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of the same number of columns as <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rbind(c(0, 1), c(1, 0), c(1, 0), c(1, 1))
get_boundary_points(X)

</code></pre>

<hr>
<h2 id='get_DAG'>get_DAG</h2><span id='topic+get_DAG'></span>

<h3>Description</h3>

<p>This function is used to construct the induced DAG, induced polyforest and
reverse topological orderings thereof from a numeric matrix <code>X0</code>. See
Definition 2 in Müller et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_DAG(X0, sparse = FALSE, twoway = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_DAG_+3A_x0">X0</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="get_DAG_+3A_sparse">sparse</code></td>
<td>
<p>logical. Either the induced DAG (<code>FALSE</code>) or the induced
polyforest (<code>TRUE</code>) is constructed.</p>
</td></tr>
<tr><td><code id="get_DAG_+3A_twoway">twoway</code></td>
<td>
<p>logical. If <code>FALSE</code>, only leaves, parents, ancestors
and reverse topological ordering are returned. If TRUE, then roots, children
and descendants are also provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with named elements giving the leaves, parents, ancestors and
reverse topological ordering and additionally, if <code>twoway == TRUE</code>, the
roots, children and descendants, of the constructed graph.
</p>


<h3>References</h3>

<p>Müller MM, Reeve HWJ, Cannings TI, Samworth RJ (2023).
&ldquo;Isotonic subgroup selection.&rdquo;
<em>arXiv preprint arXiv:2305.04852</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rbind(
  c(0.2, 0.8), c(0.2, 0.8), c(0.1, 0.7),
  c(0.2, 0.1), c(0.3, 0.5), c(0.3, 0)
)
get_DAG(X0 = X)
get_DAG(X0 = X, sparse = TRUE, twoway = TRUE)

</code></pre>

<hr>
<h2 id='get_p_classification'>get_p_classification</h2><span id='topic+get_p_classification'></span>

<h3>Description</h3>

<p>Calculate the p-value in Definition 21 of Müller et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_p_classification(X, y, x0, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_p_classification_+3A_x">X</code></td>
<td>
<p>a numeric matrix specifying the covariates.</p>
</td></tr>
<tr><td><code id="get_p_classification_+3A_y">y</code></td>
<td>
<p>a numeric vector with <code>length(y) == nrow(X)</code> and <code>all((y &gt;= 0) &amp; (y &lt;= 1))</code> specifying the responses.</p>
</td></tr>
<tr><td><code id="get_p_classification_+3A_x0">x0</code></td>
<td>
<p>a numeric vector specifying the point of interest, such that
<code>length(x0) == ncol(X)</code>.</p>
</td></tr>
<tr><td><code id="get_p_classification_+3A_tau">tau</code></td>
<td>
<p>a single numeric value in [0,1) specifying the threshold of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value in (0, 1].
</p>


<h3>References</h3>

<p>Müller MM, Reeve HWJ, Cannings TI, Samworth RJ (2023).
&ldquo;Isotonic subgroup selection.&rdquo;
<em>arXiv preprint arXiv:2305.04852</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 100
d &lt;- 2
X &lt;- matrix(runif(d * n), ncol = d)
eta &lt;- function(x) sum(x)
X_eta &lt;- apply(X, MARGIN = 1, FUN = function(x) 1 / (1 + exp(-eta(x))))
y &lt;- as.numeric(runif(n) &lt; X_eta)
get_p_classification(X, y, x0 = c(1, 1), tau = 0.6)
get_p_classification(X, y, x0 = c(1, 1), tau = 0.9)
</code></pre>

<hr>
<h2 id='get_p_Gaussian'>get_p_Gaussian</h2><span id='topic+get_p_Gaussian'></span>

<h3>Description</h3>

<p>Calculate the p-value in Definition 19 of Müller et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_p_Gaussian(X, y, x0, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_p_Gaussian_+3A_x">X</code></td>
<td>
<p>a numeric matrix specifying the covariates.</p>
</td></tr>
<tr><td><code id="get_p_Gaussian_+3A_y">y</code></td>
<td>
<p>a numeric vector with <code>length(y) == nrow(X)</code> specifying the
responses.</p>
</td></tr>
<tr><td><code id="get_p_Gaussian_+3A_x0">x0</code></td>
<td>
<p>a numeric vector specifying the point of interest, such that
<code>length(x0) == ncol(X)</code>.</p>
</td></tr>
<tr><td><code id="get_p_Gaussian_+3A_tau">tau</code></td>
<td>
<p>a single numeric value specifying the threshold of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value in (0, 1].
</p>


<h3>References</h3>

<p>Müller MM, Reeve HWJ, Cannings TI, Samworth RJ (2023).
&ldquo;Isotonic subgroup selection.&rdquo;
<em>arXiv preprint arXiv:2305.04852</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 100
d &lt;- 2
X &lt;- matrix(runif(d * n), ncol = d)
eta &lt;- function(x) sum(x)
y &lt;- apply(X, MARGIN = 1, FUN = eta) + rnorm(n, sd = 1)
get_p_Gaussian(X, y, x0 = c(1, 1), tau = 1)
get_p_Gaussian(X, y, x0 = c(1, 1), tau = -1)


</code></pre>

<hr>
<h2 id='get_p_subGaussian'>get_p_subGaussian</h2><span id='topic+get_p_subGaussian'></span>

<h3>Description</h3>

<p>Calculate the p-value in Definition 1 of Müller et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_p_subGaussian(X, y, x0, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_p_subGaussian_+3A_x">X</code></td>
<td>
<p>a numeric matrix specifying the covariates.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_+3A_y">y</code></td>
<td>
<p>a numeric vector with <code>length(y) == nrow(X)</code> specifying the
responses.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_+3A_x0">x0</code></td>
<td>
<p>a numeric vector specifying the point of interest, such that
<code>length(x0) == ncol(X)</code>.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_+3A_sigma2">sigma2</code></td>
<td>
<p>a single positive numeric value specifying the variance parameter.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_+3A_tau">tau</code></td>
<td>
<p>a single numeric value specifying the threshold of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value in (0, 1].
</p>


<h3>References</h3>

<p>Müller MM, Reeve HWJ, Cannings TI, Samworth RJ (2023).
&ldquo;Isotonic subgroup selection.&rdquo;
<em>arXiv preprint arXiv:2305.04852</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 100
d &lt;- 2
X &lt;- matrix(runif(d*n), ncol = d)
eta &lt;- function(x) sum(x)
y &lt;- apply(X, MARGIN = 1, FUN = eta) + rnorm(n, sd = 0.5)
get_p_subGaussian(X, y, x0 = c(1, 1), sigma2 = 0.25, tau = 1)
get_p_subGaussian(X, y, x0 = c(1, 1), sigma2 = 0.25, tau = 3)
</code></pre>

<hr>
<h2 id='get_p_subGaussian_NM'>get_p_subGaussian_NM</h2><span id='topic+get_p_subGaussian_NM'></span>

<h3>Description</h3>

<p>Calculate the p-value in Definition 18 of Müller et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_p_subGaussian_NM(X, y, x0, sigma2, tau, rho = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_p_subGaussian_NM_+3A_x">X</code></td>
<td>
<p>a numeric matrix specifying the covariates.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_NM_+3A_y">y</code></td>
<td>
<p>a numeric vector with <code>length(y) == nrow(X)</code> specifying the
responses.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_NM_+3A_x0">x0</code></td>
<td>
<p>a numeric vector specifying the point of interest, such that
<code>length(x0) == ncol(X)</code>.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_NM_+3A_sigma2">sigma2</code></td>
<td>
<p>a single positive numeric value specifying the variance parameter.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_NM_+3A_tau">tau</code></td>
<td>
<p>a single numeric value specifying the threshold of interest.</p>
</td></tr>
<tr><td><code id="get_p_subGaussian_NM_+3A_rho">rho</code></td>
<td>
<p>a single positive numeric value serving as hyperparameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value in (0, 1].
</p>


<h3>References</h3>

<p>Müller MM, Reeve HWJ, Cannings TI, Samworth RJ (2023).
&ldquo;Isotonic subgroup selection.&rdquo;
<em>arXiv preprint arXiv:2305.04852</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 100
d &lt;- 2
X &lt;- matrix(runif(d * n), ncol = d)
eta &lt;- function(x) sum(x)
y &lt;- apply(X, MARGIN = 1, FUN = eta) + rnorm(n, sd = 0.5)
get_p_subGaussian_NM(X, y, x0 = c(1, 1), sigma2 = 0.25, tau = 3)
get_p_subGaussian_NM(X, y, x0 = c(1, 1), sigma2 = 0.25, tau = 1)
get_p_subGaussian_NM(X, y, x0 = c(1, 1), sigma2 = 0.25, tau = 1, rho = 2)


</code></pre>

<hr>
<h2 id='get_p_value'>get_p_value</h2><span id='topic+get_p_value'></span>

<h3>Description</h3>

<p>A wrapper function used to call the correct function for calculating the p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_p_value(
  p_value_method = c("sub-Gaussian-normalmixture", "sub-Gaussian", "Gaussian",
    "classification", "quantile"),
  X,
  y,
  x0,
  tau,
  sigma2,
  rho = 1/2,
  theta = 1/2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_p_value_+3A_p_value_method">p_value_method</code></td>
<td>
<p>one of <code>c("sub-Gaussian", "sub-Gaussian-normalmixture", "Gaussian", "classification", "quantile")</code> specifying
which p-value construction should be used. See Definitions 1, 18, 19 and 21 and Lemma 24 by Müller et al. (2023) respectively.
For <code>p_value_method == "quantile"</code>, the version with the p-value from Definition 19 is implemented.</p>
</td></tr>
<tr><td><code id="get_p_value_+3A_x">X</code></td>
<td>
<p>a numeric matrix specifying the covariates.</p>
</td></tr>
<tr><td><code id="get_p_value_+3A_y">y</code></td>
<td>
<p>a numeric vector with <code>length(y) == nrow(X)</code> specifying the responses.</p>
</td></tr>
<tr><td><code id="get_p_value_+3A_x0">x0</code></td>
<td>
<p>a numeric vector specifying the point of interest, such that <code>length(x0) == ncol(X)</code>.</p>
</td></tr>
<tr><td><code id="get_p_value_+3A_tau">tau</code></td>
<td>
<p>a single numeric value specifying the threshold of interest.</p>
</td></tr>
<tr><td><code id="get_p_value_+3A_sigma2">sigma2</code></td>
<td>
<p>a single positive numeric value specifying the variance parameter (required only if <code>p_value_method %in% c("sub-Gaussian", "sub-Gaussian-normalmixture"</code>).</p>
</td></tr>
<tr><td><code id="get_p_value_+3A_rho">rho</code></td>
<td>
<p>a single positive numeric value serving as hyperparameter (required only if <code>p_value_method == "sub-Gaussian-normalmixture"</code>).</p>
</td></tr>
<tr><td><code id="get_p_value_+3A_theta">theta</code></td>
<td>
<p>a single numeric value in (0, 1) specifying the quantile of interest when <code>p_value_method == "quantile"</code>. Defaults to 1/2, i.e.~the median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value in (0, 1].
</p>


<h3>References</h3>

<p>Müller MM, Reeve HWJ, Cannings TI, Samworth RJ (2023).
&ldquo;Isotonic subgroup selection.&rdquo;
<em>arXiv preprint arXiv:2305.04852</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 100
d &lt;- 2
X &lt;- matrix(runif(d * n), ncol = d)
eta &lt;- function(x) sum(x)
X_eta &lt;- apply(X, MARGIN = 1, FUN = function(x) 1 / (1 + exp(-eta(x))))
y &lt;- as.numeric(runif(n) &lt; X_eta)
get_p_value(p_value_method = "classification", X, y, x0 = c(1, 1), tau = 0.6)
get_p_value(p_value_method = "classification", X, y, x0 = c(1, 1), tau = 0.9)

X_eta &lt;- apply(X, MARGIN = 1, FUN = eta)
y &lt;- X_eta + rcauchy(n)
get_p_value(p_value_method = "quantile", X, y, x0 = c(1, 1), tau = 1/2)
get_p_value(p_value_method = "quantile", X, y, x0 = c(1, 1), tau = 3)
get_p_value(p_value_method = "quantile", X, y, x0 = c(1, 1), tau = 3, theta = 0.95)

</code></pre>

<hr>
<h2 id='ISS'>ISS</h2><span id='topic+ISS'></span>

<h3>Description</h3>

<p>The function implements the combination of p-value calculation and familywise
error rate control through DAG testing procedures described in Müller et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISS(
  X,
  y,
  tau,
  alpha = 0.05,
  m = nrow(X),
  p_value = c("sub-Gaussian-normalmixture", "sub-Gaussian", "Gaussian", "classification",
    "quantile"),
  sigma2,
  rho = 1/2,
  FWER_control = c("ISS", "Holm", "MG all", "MG any", "split", "split oracle"),
  minimal = FALSE,
  split_proportion = 1/2,
  eta = NA,
  theta = 1/2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISS_+3A_x">X</code></td>
<td>
<p>a numeric matrix specifying the covariates.</p>
</td></tr>
<tr><td><code id="ISS_+3A_y">y</code></td>
<td>
<p>a numeric vector with <code>length(y) == nrow(X)</code> specifying the responses.</p>
</td></tr>
<tr><td><code id="ISS_+3A_tau">tau</code></td>
<td>
<p>a single numeric value specifying the threshold of interest.</p>
</td></tr>
<tr><td><code id="ISS_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value in (0, 1] specifying the Type I error rate.</p>
</td></tr>
<tr><td><code id="ISS_+3A_m">m</code></td>
<td>
<p>an integer value between 1 and <code>nrow(X)</code> specifying the size of
the subsample of <code>X</code> at which the hypotheses should be tested.</p>
</td></tr>
<tr><td><code id="ISS_+3A_p_value">p_value</code></td>
<td>
<p>one of <code>c("sub-Gaussian", "sub-Gaussian-normalmixture", "Gaussian", "classification", "quantile")</code> specifying
which p-value construction should be used. See Definitions 1, 18, 19 and 21 and Lemma 24 by Müller et al. (2023) respectively.
For <code>p_value == "quantile"</code>, the version with the p-value from Definition 19 is implemented.</p>
</td></tr>
<tr><td><code id="ISS_+3A_sigma2">sigma2</code></td>
<td>
<p>a single positive numeric value specifying the variance parameter (only needed if <code>p_value %in% c("sub-Gaussian", "sub-Gaussian-normalmixture")</code>).</p>
</td></tr>
<tr><td><code id="ISS_+3A_rho">rho</code></td>
<td>
<p>a single positive numeric value serving as hyperparameter (only used if <code>p_value == "sub-Gaussian-normalmixture"</code>).</p>
</td></tr>
<tr><td><code id="ISS_+3A_fwer_control">FWER_control</code></td>
<td>
<p>one of <code>c("ISS", "Holm", "MG all", "MG any", "split", "split oracle")</code>, specifying how the
familywise error rate is controlled. The first corresponds to Algorithm 1 by Müller et al. (2023),
the second is Holm's procedure, the two starting with &quot;MG&quot; correspond to the procedures by Meijer and Goeman (2015)
for one-way logical relationships, and the final two containing &quot;split&quot; to the sample splitting techniques in Appendix B of Müller et al. (2023).</p>
</td></tr>
<tr><td><code id="ISS_+3A_minimal">minimal</code></td>
<td>
<p>a logical value determining whether the output should be reduced to the minimal number of points leading to the same selected set.</p>
</td></tr>
<tr><td><code id="ISS_+3A_split_proportion">split_proportion</code></td>
<td>
<p>when <code>FWER_control %in% c("split", "split oracle")</code>, the number of data points in the first split of the data is <code>ceiling(split_proportion * nrow(X))</code>.</p>
</td></tr>
<tr><td><code id="ISS_+3A_eta">eta</code></td>
<td>
<p>when <code>FWER_control == "split oracle"</code>, this parameter needs to be used to provide the true regression function, which should take a vector of covariates as inputs and output a single numeric value.</p>
</td></tr>
<tr><td><code id="ISS_+3A_theta">theta</code></td>
<td>
<p>a single numeric value in (0, 1) specifying the quantile of interest when <code>p_value_method == "quantile"</code>. Defaults to 1/2, i.e.~the median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix giving the points in <code>X</code> determined to lie in the <code>tau</code>-superlevel set of the regression function with probability at least 1 - <code>alpha</code> or, if <code>minimal == TRUE</code>, a subset of points thereof that have the same upper hull.
</p>


<h3>References</h3>

<p>Meijer RJ, Goeman JJ (2015).
&ldquo;A multiple testing method for hypotheses structured in a directed acyclic graph.&rdquo;
<em>Biometrical Journal</em>, <b>57</b>(1), 123&ndash;143.<br /><br /> Müller MM, Reeve HWJ, Cannings TI, Samworth RJ (2023).
&ldquo;Isotonic subgroup selection.&rdquo;
<em>arXiv preprint arXiv:2305.04852v2</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 2
n &lt;- 1000
m &lt;- 100
sigma2 &lt;- (1 / 4)^2
tau &lt;- 0.5
alpha &lt;- 0.05

X &lt;- matrix(runif(n * d), nrow = n)
eta_X &lt;- apply(X, MARGIN = 1, max)
y &lt;- eta_X + rnorm(n, sd = sqrt(sigma2))
X_rej &lt;- ISS(X = X, y = y, tau = tau, alpha = alpha, m = m, sigma2 = sigma2)

if (d == 2) {
  plot(0, type = "n", xlim = c(0, 1), ylim = c(0, 1), xlab = NA, ylab = NA)
  for (i in 1:nrow(X_rej)) {
    rect(
      xleft = X_rej[i, 1], xright = 1, ybottom = X_rej[i, 2], ytop = 1,
      border = NA, col = "indianred"
    )
  }

  points(X, pch = 16, cex = 0.5, col = "gray")
  points(X[1:m, ], pch = 16, cex = 0.5, col = "black")
  lines(x = c(0, tau), y = c(tau, tau), lty = 2)
  lines(x = c(tau, tau), y = c(tau, 0), lty = 2)

  legend(
    x = "bottomleft",
    legend = c(
      "superlevel set boundary",
      "untested covariate points",
      "tested covariate points",
      "selected set"
    ),
    col = c("black", "gray", "black", "indianred"),
    lty = c(2, NA, NA, NA),
    lwd = c(1, NA, NA, NA),
    pch = c(NA, 16, 16, NA),
    fill = c(NA, NA, NA, "indianred"),
    border = c(NA, NA, NA, "indianred")
  )
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
