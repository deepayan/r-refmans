<!DOCTYPE html><html><head><title>Help for package algaeClassify</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {algaeClassify}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accum'><p>Split a dataframe column with binomial name into genus and species columns.</p>
Plots change in species richness over time, generates species accumulation curve, and
compares SAC against simulated idealized curve assuming all unique taxa have equal probability
of being sampled at any point in the time series. (author Dietmar Straile)</a></li>
<li><a href='#algaebase_genus_search'><p>Search algaebase for information about a genus of phytoplankton</p></a></li>
<li><a href='#algaebase_output_parse'><p>Helper function for parsing output from algaebase</p></a></li>
<li><a href='#algaebase_search_df'><p>Search algaebase for information about a list of phytoplankton names</p></a></li>
<li><a href='#algaebase_species_search'><p>Retrieve taxonomic information from the algaebase online database (www.algaebase.org) based on a user-specified genus and species name . This function requires a valid API key for algaebase.</p></a></li>
<li><a href='#bestmatch'><p>fuzzy partial matching between a scientific name and a list of possible matches</p></a></li>
<li><a href='#csrTraits'><p>Database of functional traits for MFG classification, derived from Rimet et al. 2019</p></a></li>
<li><a href='#date_mat'><p>Transform a phytoplankton timeseries into a matrix of abundances for ordination</p></a></li>
<li><a href='#genus_search_itis'><p>Wrapper function for several functions in ritis::</p>
Searches ITIS database for matches to a genus name</a></li>
<li><a href='#genus_species_extract'><p>Split a dataframe column with binomial name into genus and species columns.</p></a></li>
<li><a href='#get_apikey'><p>Get value of algaebase API key from Environment variable</p>
Return an error if variable not set.</a></li>
<li><a href='#get_apikey_fromfile'><p>Get value of algaebase API key from a file</p></a></li>
<li><a href='#gnr_simple'><p>Wrapper function for taxize::gnr_resolve()</p>
checks species names against a variety of online databases
supports fuzzy partial matching</a></li>
<li><a href='#gnr_simple_df'><p>Wrapper function to apply gnr_simple across a data.frame or list of species names</p></a></li>
<li><a href='#itis_search_df'><p>Wrapper function for applying genus_search_itis and species_search_itis</p>
to a whole data.frame containing scientific names</a></li>
<li><a href='#lakegeneva'><p>example dataset from lake Geneva, Switzerland</p></a></li>
<li><a href='#mean_naomit'><p>Compute mean value while ignoring NA's</p></a></li>
<li><a href='#mfg_csr_convert'><p>Returns a CSR classification based on Morphofunctional group (MFG).</p>
Correspondence based on Salmaso et al. 2015 and Reynolds et al. 1988</a></li>
<li><a href='#mfg_csr_convert_df'><p>Returns a CSR classification based on Morphofunctional group (MFG).</p>
Correspondence based on Salmaso et al. 2015 and Reynolds et al. 1988</a></li>
<li><a href='#mfg_csr_library'><p>MFG-CSR correspondence based on CSR-trait relationships in Reynolds et al. 1988</p>
and MFG-trait relationships in Salmaso et al. 2015</a></li>
<li><a href='#mfgTraits'><p>Functional Trait Database derived from Rimet et al.</p></a></li>
<li><a href='#phyto_ts_aggregate'><p>Aggregate phytoplankton timeseries based on abundance. Up to 3 grouping variables can be given:</p>
e.g. genus, species, stationid, depth range.
If no abundance var is given, will aggregate to presence/absence of grouping vars.</a></li>
<li><a href='#sampeff'><p>Visually assess change in sampling effort over time (author: Dietmar Straile)</p></a></li>
<li><a href='#set_algaebase_apikey_header'><p>Add algaebase API key to curl handle</p></a></li>
<li><a href='#species_mfg_library'><p>Trait-based MFG classifications for common Eurasion/North American phytoplankton species.</p>
See accompanying manuscript for sources</a></li>
<li><a href='#species_search_itis'><p>Wrapper function for several functions in ritis::</p>
Searches ITIS database for matches to a binomial scientific name
outputs matches, current accepted names, synonyms, and higher taxonomy</a></li>
<li><a href='#species_to_mfg'><p>Conversion of a single genus and species name to a single MFG. Uses species.mfg.library</p></a></li>
<li><a href='#species_to_mfg_df'><p>Wrapper function to apply species_phyto_convert() across a data.frame</p></a></li>
<li><a href='#traitranges'><p>surface/volume ratio and max linear dimension criteria for CSR</p>
From Reynolds 1988 and Reynolds 2006</a></li>
<li><a href='#traits_to_csr'><p>Assign phytoplankton species to CSR functional groups, based on surface to volume ratio and</p>
maximum linear dimension ranges proposed by Reynolds et al. 1988;2006</a></li>
<li><a href='#traits_to_csr_df'><p>Add CSR functional group classifications to a dataframe of phytoplankton species, based on surface to volume ratio and</p>
maximum linear dimension ranges proposed by Reynolds et al. 1988;2006</a></li>
<li><a href='#traits_to_mfg'><p>Assign MFG based on binary functional traits and taxonomy (Class and Order)</p></a></li>
<li><a href='#traits_to_mfg_df'><p>Assign morphofunctional groups to a dataframe of functional traits and higher taxonomy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools to Standardize Phytoplankton Taxonomic Data and Perform
Functional Group Classifications</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Vijay Patil [aut, cre],
  Torsten Seltmann [aut],
  Nico Salmaso [aut],
  Orlane Anneville [aut],
  Marc Lajeunesse [aut],
  Dietmar Straile [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vijay Patil &lt;vpatil@usgs.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions that facilitate the use of accepted taxonomic nomenclature, collection of
	functional trait data, and assignment of functional group classifications to phytoplankton
	species. Possible classifications include Morpho-functional group (MFG; Salmaso et al. 2015 
	&lt;<a href="https://doi.org/10.1111%2Ffwb.12520">doi:10.1111/fwb.12520</a>&gt;) and CSR (Reynolds 1988; Functional morphology and the 
	adaptive strategies of phytoplankton. In C.D. Sandgren (ed). Growth and reproductive 
	strategies of freshwater phytoplankton, 388-433. Cambridge University Press, New York). 
	Versions 2.0.0 and later includes new functions for querying the 
	algaebase online taxonomic database (www.algaebase.org), however these functions require
	a valid API key that must be acquired from the algaebase admin. 
	Note that none of the algaeClassify authors are affiliated with algaebase in any way. Taxonomic 
	names can also be checked against a variety of taxonomic databases using 
	the geographic name resolution service (GNRS) via wrapper functions for the taxize package, 
	with convenient output format and unlikely names for phytoplankton taxa removed. In addition,
	currently accepted and outdated synonyms, and higher taxonomy, can be extracted for lists of 
	species from the ITIS database using wrapper functions for the ritis package.
	The algaeClassify package is a product of the GEISHA (Global Evaluation of the Impacts of 
	Storms on freshwater Habitat and Structure of phytoplankton Assemblages), funded by CESAB 
    (Centre for Synthesis and Analysis of Biodiversity) and the USGS John Wesley Powell Center for
	Synthesis and Analysis, with data and other support provided by members of GLEON 
	(Global Lake Ecology Observation Network). 
	DISCLAIMER: This software has been approved for release by the 
	U.S. Geological Survey (USGS). Although the software has been subjected to rigorous review, 
	the USGS reserves the right to update the software as needed pursuant to further analysis and 
	review. No warranty, expressed or implied, is made by the USGS or the U.S. Government as to the 
	functionality of the software and related material nor shall the fact of release constitute 
	any such warranty. Furthermore, the software is released on condition that neither the USGS 
	nor the U.S. Government shall be held liable for any damages resulting from its authorized 
	or unauthorized use.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.5066/F7S46Q3F">https://doi.org/10.5066/F7S46Q3F</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>lubridate, stats, taxize, ritis, curl, jsonlite, methods,
RCurl</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 23:53:21 UTC; vpatil</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-12 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='accum'>Split a dataframe column with binomial name into genus and species columns.
Plots change in species richness over time, generates species accumulation curve, and
compares SAC against simulated idealized curve assuming all unique taxa have equal probability
of being sampled at any point in the time series. (author Dietmar Straile)</h2><span id='topic+accum'></span>

<h3>Description</h3>

<p>Split a dataframe column with binomial name into genus and species columns.
Plots change in species richness over time, generates species accumulation curve, and
compares SAC against simulated idealized curve assuming all unique taxa have equal probability
of being sampled at any point in the time series. (author Dietmar Straile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accum(
  b_data,
  phyto_name = "phyto_name",
  column = NA,
  n = 100,
  save.pdf = FALSE,
  lakename = "",
  datename = "date_dd_mm_yy",
  dateformat = "%d-%m-%y"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accum_+3A_b_data">b_data</code></td>
<td>
<p>Name of data.frame object</p>
</td></tr>
<tr><td><code id="accum_+3A_phyto_name">phyto_name</code></td>
<td>
<p>Character string: field containing phytoplankton id (species, genus, etc.)</p>
</td></tr>
<tr><td><code id="accum_+3A_column">column</code></td>
<td>
<p>column name or number for field containing abundance (biomass,biovol, etc.).
Can be NA if the dataset only contains a species list for each sampling date.</p>
</td></tr>
<tr><td><code id="accum_+3A_n">n</code></td>
<td>
<p>number of simulations for randomized ideal species accumulation curve</p>
</td></tr>
<tr><td><code id="accum_+3A_save.pdf">save.pdf</code></td>
<td>
<p>TRUE/FALSE- should plots be displayed or saved to a pdf?</p>
</td></tr>
<tr><td><code id="accum_+3A_lakename">lakename</code></td>
<td>
<p>optional character string for adding lake name to pdf output</p>
</td></tr>
<tr><td><code id="accum_+3A_datename">datename</code></td>
<td>
<p>character string name of b_data field containing date</p>
</td></tr>
<tr><td><code id="accum_+3A_dateformat">dateformat</code></td>
<td>
<p>character string: posix format for datename column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a two panel plot with trends in richness on top, and cumulative richness vs. simulated
accumulation curve on bottom
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
#example dataset with 50 rows
head(lakegeneva)

accum(b_data=lakegeneva,column='biovol_um3_ml',n=10,save.pdf=FALSE)
</code></pre>

<hr>
<h2 id='algaebase_genus_search'>Search algaebase for information about a genus of phytoplankton</h2><span id='topic+algaebase_genus_search'></span>

<h3>Description</h3>

<p>Search algaebase for information about a genus of phytoplankton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algaebase_genus_search(
  genus = NULL,
  apikey = NULL,
  handle = NULL,
  higher = TRUE,
  print.full.json = FALSE,
  newest.only = TRUE,
  long = FALSE,
  exact.matches.only = TRUE,
  return.higher.only = FALSE,
  api_file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algaebase_genus_search_+3A_genus">genus</code></td>
<td>
<p>genus name as character string</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_apikey">apikey</code></td>
<td>
<p>valid key for algaebase API as character string</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_handle">handle</code></td>
<td>
<p>curl handle with API key. Will be created if not present.</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_higher">higher</code></td>
<td>
<p>boolean should higher taxonomy be included in output?</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_print.full.json">print.full.json</code></td>
<td>
<p>boolean returns raw json output if TRUE. Default is FALSE (return R data frame)</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_newest.only">newest.only</code></td>
<td>
<p>boolean should results be limited to the most recent matching entry in algaebase?</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_long">long</code></td>
<td>
<p>boolean return long output including full species name and authorship, and entry date from algaebase.</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_exact.matches.only">exact.matches.only</code></td>
<td>
<p>boolean should results be limited to exact matches?</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_return.higher.only">return.higher.only</code></td>
<td>
<p>boolean should output only included higher taxonomy?</p>
</td></tr>
<tr><td><code id="algaebase_genus_search_+3A_api_file">api_file</code></td>
<td>
<p>path to text file containing a valid API key</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame that may include: accepted.name (currently accepted synonym if different from input name), input.name (name supplied by user), input.match (1 if exact match, else 0), currently.accepted (1=TRUE/0=FALSE), genus.only (1=genus search/0=genus+species search),higher taxonomy (kingdom,phylum,class,order,family), genus, species (always NA for genus search), infraspecies name (always NA for genus search), long.name (includes author and date if given), taxonomic.status (currently accepted, synonym, or unverified), taxon.rank (taxonomic rank of accepted name (genus, species, infraspecies), mod.date (date when entry was last modified in algaebase).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: algaebase_genus_search("Anabaena") #not run.

</code></pre>

<hr>
<h2 id='algaebase_output_parse'>Helper function for parsing output from algaebase</h2><span id='topic+algaebase_output_parse'></span>

<h3>Description</h3>

<p>Helper function for parsing output from algaebase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algaebase_output_parse(x, field.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algaebase_output_parse_+3A_x">x</code></td>
<td>
<p>list object containing output from an algaebase query</p>
</td></tr>
<tr><td><code id="algaebase_output_parse_+3A_field.name">field.name</code></td>
<td>
<p>character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>selected output variable as character vector
</p>

<hr>
<h2 id='algaebase_search_df'>Search algaebase for information about a list of phytoplankton names</h2><span id='topic+algaebase_search_df'></span>

<h3>Description</h3>

<p>Search algaebase for information about a list of phytoplankton names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algaebase_search_df(
  df,
  apikey = NULL,
  handle = NULL,
  genus.only = FALSE,
  genus.name = "genus",
  species.name = "species",
  higher = TRUE,
  print.full.json = FALSE,
  long = FALSE,
  exact.matches.only = TRUE,
  api_file = NULL,
  sleep.time = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algaebase_search_df_+3A_df">df</code></td>
<td>
<p>data frame containing columns with genus and species names</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_apikey">apikey</code></td>
<td>
<p>valid key for algaebase API as character string</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_handle">handle</code></td>
<td>
<p>curl handle with API key. Will be created if not present.</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_genus.only">genus.only</code></td>
<td>
<p>boolean: should searches be based solely on the genus name?</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_genus.name">genus.name</code></td>
<td>
<p>name of data.frame column that contains genus names</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_species.name">species.name</code></td>
<td>
<p>name of data.frame column that contains species names</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_higher">higher</code></td>
<td>
<p>boolean should higher taxonomy be included in output?</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_print.full.json">print.full.json</code></td>
<td>
<p>boolean returns raw json output if TRUE. Default is FALSE (return R data frame)</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_long">long</code></td>
<td>
<p>boolean return long output including full species name and authorship, and entry date from algaebase.</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_exact.matches.only">exact.matches.only</code></td>
<td>
<p>boolean should results be limited to exact matches?</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_api_file">api_file</code></td>
<td>
<p>path to text file containing a valid API key</p>
</td></tr>
<tr><td><code id="algaebase_search_df_+3A_sleep.time">sleep.time</code></td>
<td>
<p>delay between algaebase queries (in seconds). Should be at least 1 second if querying more than 10 names at once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame that may include: accepted.name (currently accepted synonym if different from input name), input.name (name supplied by user), input.match (1 if exact match, else 0), currently.accepted (1=TRUE/0=FALSE), genus.only (1=genus search/0=genus+species search),higher taxonomy (kingdom,phylum,class,order,family), genus, species (always NA for genus search), infraspecies name (always NA for genus search), long.name (includes author and date if given), taxonomic.status (currently accepted, synonym, or unverified), taxon.rank (taxonomic rank of accepted name (genus, species, infraspecies), mod.date (date when entry was last modified in algaebase).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(lakegeneva)
#example dataset with 50 rows

new.lakegeneva &lt;- genus_species_extract(lakegeneva,'phyto_name')
lakegeneva.algaebase&lt;-algaebase_search_df(new.lakegeneva[1:10,],higher=TRUE,long=TRUE)
head(lakegeneva.algaebase)
## End(Not run)

</code></pre>

<hr>
<h2 id='algaebase_species_search'>Retrieve taxonomic information from the algaebase online database (www.algaebase.org) based on a user-specified genus and species name . This function requires a valid API key for algaebase.</h2><span id='topic+algaebase_species_search'></span>

<h3>Description</h3>

<p>Retrieve taxonomic information from the algaebase online database (www.algaebase.org) based on a user-specified genus and species name . This function requires a valid API key for algaebase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algaebase_species_search(
  genus,
  species,
  apikey = NULL,
  handle = NULL,
  higher = TRUE,
  print.full.json = FALSE,
  newest.only = TRUE,
  long = FALSE,
  exact.matches.only = TRUE,
  api_file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="algaebase_species_search_+3A_genus">genus</code></td>
<td>
<p>genus name as character string</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_species">species</code></td>
<td>
<p>species name as character string</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_apikey">apikey</code></td>
<td>
<p>valid key for algaebase API as character string</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_handle">handle</code></td>
<td>
<p>curl handle with API key. Will be created if not present.</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_higher">higher</code></td>
<td>
<p>boolean should higher taxonomy be included in output?</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_print.full.json">print.full.json</code></td>
<td>
<p>boolean returns raw json output if TRUE. Default is FALSE (return R data frame)</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_newest.only">newest.only</code></td>
<td>
<p>boolean should results be limited to the most recent matching entry in algaebase?</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_long">long</code></td>
<td>
<p>boolean return long output including full species name and authorship, and entry date from algaebase.</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_exact.matches.only">exact.matches.only</code></td>
<td>
<p>boolean should results be limited to exact matches?</p>
</td></tr>
<tr><td><code id="algaebase_species_search_+3A_api_file">api_file</code></td>
<td>
<p>path to text file containing a valid API key</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame that may include: accepted.name (currently accepted synonym if different from input name), input.name (name supplied by user), input.match (1 if exact match, else 0), currently.accepted (1=TRUE/0=FALSE), genus.only (1=genus search/0=genus+species search),higher taxonomy (kingdom,phylum,class,order,family), genus, species (always NA for genus search), infraspecies name (always NA for genus search), long.name (includes author and date if given), taxonomic.status (currently accepted, synonym, or unverified), taxon.rank (taxonomic rank of accepted name (genus, species, infraspecies), mod.date (date when entry was last modified in algaebase).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: algaebase_species_search("Anabaena flos-aquae") #not run


</code></pre>

<hr>
<h2 id='bestmatch'>fuzzy partial matching between a scientific name and a list of possible matches</h2><span id='topic+bestmatch'></span>

<h3>Description</h3>

<p>fuzzy partial matching between a scientific name and a list of possible matches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestmatch(enteredName, possibleNames, maxErr = 3, trunc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestmatch_+3A_enteredname">enteredName</code></td>
<td>
<p>Character string with name to check</p>
</td></tr>
<tr><td><code id="bestmatch_+3A_possiblenames">possibleNames</code></td>
<td>
<p>Character vector of possible matches</p>
</td></tr>
<tr><td><code id="bestmatch_+3A_maxerr">maxErr</code></td>
<td>
<p>maximum number of different bits allowed for a partial match</p>
</td></tr>
<tr><td><code id="bestmatch_+3A_trunc">trunc</code></td>
<td>
<p>TRUE/FALSE. if true and no match, retry with last three letters truncated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string with the best match, or 'multiplePartialMatches'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>possibleMatches=c('Viburnum edule','Viburnum acerifolia')
bestmatch(enteredName='Viburnum edulus',possibleNames=possibleMatches)
</code></pre>

<hr>
<h2 id='csrTraits'>Database of functional traits for MFG classification, derived from Rimet et al. 2019</h2><span id='topic+csrTraits'></span>

<h3>Description</h3>

<p>Database of functional traits for MFG classification, derived from Rimet et al. 2019
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mfgTraits)
</code></pre>


<h3>Format</h3>

<p>A data frame with columns:
</p>

<dl>
<dt>phyto_name</dt><dd><p>binomial scientific name</p>
</dd>
<dt>genus</dt><dd><p>genus name</p>
</dd>
<dt>species</dt><dd><p>species name</p>
</dd>
<dt>SAV</dt><dd><p>surface area:volume ratio</p>
</dd>
<dt>MLD</dt><dd><p>maximum linear dimension (micrometers)</p>
</dd>
<dt>MSV</dt><dd><p>product of SAV and MLD; unitless</p>
</dd>
<dt>volume.um3</dt><dd><p>cell or colony biovolume</p>
</dd>
<dt>surface.area.um2</dt><dd><p>biological unit (cell or colony) surface area accounting for mucilage</p>
</dd>
<dt>Colonial</dt><dd><p>1/0 indicates colonial growth form</p>
</dd>
<dt>Number.of.cells.per.colony</dt><dd><p>literature-based average colony abundance</p>
</dd>
<dt>Geometrical.shape.of.the.colony</dt><dd><p>Shape descriptions. See Rimet et al. 2019 for abbreviations</p>
</dd>
<dt>traitCSR</dt><dd><p>CSR classification using traits_to_CSR function and criteria from Reynolds 2006</p>
</dd>
</dl>


<hr>
<h2 id='date_mat'>Transform a phytoplankton timeseries into a matrix of abundances for ordination</h2><span id='topic+date_mat'></span>

<h3>Description</h3>

<p>Transform a phytoplankton timeseries into a matrix of abundances for ordination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_mat(
  phyto.df,
  abundance.var = "biovol_um3_ml",
  summary.type = "abundance",
  taxa.name = "phyto_name",
  date.name = "date_dd_mm_yy",
  format = "%d-%m-%y",
  time.agg = c("day", "month", "year", "monthyear"),
  fun = mean_naomit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_mat_+3A_phyto.df">phyto.df</code></td>
<td>
<p>Name of data.frame object</p>
</td></tr>
<tr><td><code id="date_mat_+3A_abundance.var">abundance.var</code></td>
<td>
<p>Character string: field containing abundance data.
Can be NA if the dataset only contains a species list for each sampling date.</p>
</td></tr>
<tr><td><code id="date_mat_+3A_summary.type">summary.type</code></td>
<td>
<p>'abundance' for a matrix of aggregated abundance,'presence.absence'
for 1 (present) and 0 (absent).</p>
</td></tr>
<tr><td><code id="date_mat_+3A_taxa.name">taxa.name</code></td>
<td>
<p>Character string: field containing taxonomic identifiers.</p>
</td></tr>
<tr><td><code id="date_mat_+3A_date.name">date.name</code></td>
<td>
<p>Character string: field containing date.</p>
</td></tr>
<tr><td><code id="date_mat_+3A_format">format</code></td>
<td>
<p>Character string: POSIX format string for formatting date column.</p>
</td></tr>
<tr><td><code id="date_mat_+3A_time.agg">time.agg</code></td>
<td>
<p>Character string: time interval for aggregating abundance. default is day.</p>
</td></tr>
<tr><td><code id="date_mat_+3A_fun">fun</code></td>
<td>
<p>function for aggregation. default is mean, excluding NA's.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of phytoplankton abundance, with taxa in rows and time in columns.
If time.agg = 'monthyear', returns a 3dimensional matrix (taxa,month,year).
If abundance.var = NA, matrix cells will be 1 for present, 0 for absent
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
#example dataset with 50 rows

geneva.mat1&lt;-date_mat(lakegeneva,time.agg='month',summary.type='presence.absence')
geneva.mat2&lt;-date_mat(lakegeneva,time.agg='month',summary.type='abundance')

geneva.mat1
geneva.mat2
</code></pre>

<hr>
<h2 id='genus_search_itis'>Wrapper function for several functions in ritis::
Searches ITIS database for matches to a genus name</h2><span id='topic+genus_search_itis'></span>

<h3>Description</h3>

<p>Wrapper function for several functions in ritis::
Searches ITIS database for matches to a genus name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genus_search_itis(genus, higher = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genus_search_itis_+3A_genus">genus</code></td>
<td>
<p>Character string. genus name to search for in ITIS</p>
</td></tr>
<tr><td><code id="genus_search_itis_+3A_higher">higher</code></td>
<td>
<p>Boolean. If TRUE, add higher taxonomic classifications to output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>input data.frame with matches, current accepted names, synonyms, and higher taxonomy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genus='Anabaena'
genus_search_itis(genus,higher=FALSE)
</code></pre>

<hr>
<h2 id='genus_species_extract'>Split a dataframe column with binomial name into genus and species columns.</h2><span id='topic+genus_species_extract'></span>

<h3>Description</h3>

<p>Split a dataframe column with binomial name into genus and species columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genus_species_extract(phyto.df, phyto.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genus_species_extract_+3A_phyto.df">phyto.df</code></td>
<td>
<p>Name of data.frame object</p>
</td></tr>
<tr><td><code id="genus_species_extract_+3A_phyto.name">phyto.name</code></td>
<td>
<p>Character string: field in phyto.df containing species name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with new character fields 'genus' and 'species'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
#example dataset with 50 rows

head(lakegeneva) #need to split the phyto_name column
new.lakegeneva=genus_species_extract(lakegeneva,'phyto_name')

head(new.lakegeneva)
</code></pre>

<hr>
<h2 id='get_apikey'>Get value of algaebase API key from Environment variable
Return an error if variable not set.</h2><span id='topic+get_apikey'></span>

<h3>Description</h3>

<p>Get value of algaebase API key from Environment variable
Return an error if variable not set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_apikey()
</code></pre>


<h3>Value</h3>

<p>api key as character string (invisibly)
</p>

<hr>
<h2 id='get_apikey_fromfile'>Get value of algaebase API key from a file</h2><span id='topic+get_apikey_fromfile'></span>

<h3>Description</h3>

<p>Get value of algaebase API key from a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_apikey_fromfile(keyfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_apikey_fromfile_+3A_keyfile">keyfile</code></td>
<td>
<p>path to text file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>api key as character string (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: apikey&lt;-get_apikey_fromfile("keyfile.txt")
</code></pre>

<hr>
<h2 id='gnr_simple'>Wrapper function for taxize::gnr_resolve()
checks species names against a variety of online databases
supports fuzzy partial matching</h2><span id='topic+gnr_simple'></span>

<h3>Description</h3>

<p>Provides convienent output with a single result, using a variety 
of criteria for the best match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnr_simple(
  name,
  sourceid = NULL,
  topscore = TRUE,
  numhits = TRUE,
  canonical = TRUE,
  with_context = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnr_simple_+3A_name">name</code></td>
<td>
<p>character string binomial scientific name to resolve</p>
</td></tr>
<tr><td><code id="gnr_simple_+3A_sourceid">sourceid</code></td>
<td>
<p>integer with data source id from taxize::gnr_datasources()</p>
</td></tr>
<tr><td><code id="gnr_simple_+3A_topscore">topscore</code></td>
<td>
<p>boolean. Should the best match be returned based on score?</p>
</td></tr>
<tr><td><code id="gnr_simple_+3A_numhits">numhits</code></td>
<td>
<p>boolean. Should the best match be returned based on 
the number of sources with a match?</p>
</td></tr>
<tr><td><code id="gnr_simple_+3A_canonical">canonical</code></td>
<td>
<p>If TRUE, names do not include authorship or date</p>
</td></tr>
<tr><td><code id="gnr_simple_+3A_with_context">with_context</code></td>
<td>
<p>If TRUE, Match scores are weighted for taxonomic consistency</p>
</td></tr>
<tr><td><code id="gnr_simple_+3A_...">...</code></td>
<td>
<p>Other parameters passed to taxize::gnr_resolve()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new data.frame with name matches, column indicating an exact match,
scores, and number of hits (matches) from different data sources in gnr_resolve()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#use taxize::gnr_datasources() to see all possible data sources for name checking.
name&lt;-"Aphanazomenon flos-aquae"
#sourceid=3 for ITIS database,195 for Algaebase
gnr_simple(name,sourceid=3) #search for ITIS matches
gnr_simple(name,sourceid=NULL) #search for matches from any source
</code></pre>

<hr>
<h2 id='gnr_simple_df'>Wrapper function to apply gnr_simple across a data.frame or list of species names</h2><span id='topic+gnr_simple_df'></span>

<h3>Description</h3>

<p>Provides convienent output with a row per name. To streamline merging with
original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnr_simple_df(
  df,
  name.column,
  sourceid = NA,
  topscore = TRUE,
  numhits = TRUE,
  canonical = TRUE,
  with_context = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnr_simple_df_+3A_df">df</code></td>
<td>
<p>data.frame containing names to check</p>
</td></tr>
<tr><td><code id="gnr_simple_df_+3A_name.column">name.column</code></td>
<td>
<p>integer or character string with column name containing
species names</p>
</td></tr>
<tr><td><code id="gnr_simple_df_+3A_sourceid">sourceid</code></td>
<td>
<p>integer with data source id from taxize::gnr_datasources()</p>
</td></tr>
<tr><td><code id="gnr_simple_df_+3A_topscore">topscore</code></td>
<td>
<p>boolean. Should the best match be returned based on score?</p>
</td></tr>
<tr><td><code id="gnr_simple_df_+3A_numhits">numhits</code></td>
<td>
<p>boolean. Should the best match be returned based on
the number of sources with a match?</p>
</td></tr>
<tr><td><code id="gnr_simple_df_+3A_canonical">canonical</code></td>
<td>
<p>If TRUE, names do not include authorship or date</p>
</td></tr>
<tr><td><code id="gnr_simple_df_+3A_with_context">with_context</code></td>
<td>
<p>If TRUE, Match scores are weighted for taxonomic consistency</p>
</td></tr>
<tr><td><code id="gnr_simple_df_+3A_...">...</code></td>
<td>
<p>Other parameters passed to taxize::gnr_resolve()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new data.frame original names (orig.name), 1/0 flag for an exact match,
the best match (matched.name), and other output from gnr_simple().
scores, and number of hits (matches) from different data sources in
gnr_resolve()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
#example dataset with 50 rows

new.lakegeneva &lt;- genus_species_extract(lakegeneva[1,],'phyto_name')
new.lakegeneva$genus_species &lt;- trimws(paste(new.lakegeneva$genus,
new.lakegeneva$species))

#checking for matches from all GNRS sources:
lakegeneva.namematches &lt;- gnr_simple_df(new.lakegeneva,"genus_species")
lakegeneva.namematches
</code></pre>

<hr>
<h2 id='itis_search_df'>Wrapper function for applying genus_search_itis and species_search_itis
to a whole data.frame containing scientific names</h2><span id='topic+itis_search_df'></span>

<h3>Description</h3>

<p>Wrapper function for applying genus_search_itis and species_search_itis
to a whole data.frame containing scientific names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itis_search_df(df, namecol = NA, higher = FALSE, genus.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itis_search_df_+3A_df">df</code></td>
<td>
<p>data.frame containing names to check</p>
</td></tr>
<tr><td><code id="itis_search_df_+3A_namecol">namecol</code></td>
<td>
<p>integer or character string with column name containing
species or genus names</p>
</td></tr>
<tr><td><code id="itis_search_df_+3A_higher">higher</code></td>
<td>
<p>Boolean. If TRUE, add higher taxonomic classifications to output</p>
</td></tr>
<tr><td><code id="itis_search_df_+3A_genus.only">genus.only</code></td>
<td>
<p>boolean If TRUE, search for matches with just the genus name using genus_search_itis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with submitted names (orig.name), matched names (matched.name),
1/0 flag indicating that original name is currently accepted (orig.name.accepted),
1/0 flag indicating if search was genus_only (for distinguishing genus_search_itis
and species_search_itis results), synonyms if any, and higher taxonomy (if
higher=TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
#example dataset

new.lakegeneva &lt;- genus_species_extract(lakegeneva[1,],'phyto_name')
new.lakegeneva$genus_species &lt;- trimws(paste(new.lakegeneva$genus,
new.lakegeneva$species))
#checking for genus-only name matches in ITIS, and extracting higher taxonomy
#flagging names with imperfect or no matches

lakegeneva.genus.itischeck &lt;-
         itis_search_df(new.lakegeneva,"genus_species")
         lakegeneva.genus.itischeck
</code></pre>

<hr>
<h2 id='lakegeneva'>example dataset from lake Geneva, Switzerland</h2><span id='topic+lakegeneva'></span>

<h3>Description</h3>

<p>example dataset from lake Geneva, Switzerland
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lakegeneva)
</code></pre>


<h3>Format</h3>

<p>A data frame with columns:
</p>

<dl>
<dt>lake</dt><dd><p>lake name</p>
</dd>
<dt>phyto_name</dt><dd><p>phytoplankton species name</p>
</dd>
<dt>month</dt><dd><p>month of sampling</p>
</dd>
<dt>year</dt><dd><p>year of sampling</p>
</dd>
<dt>date_dd_mm_yy</dt><dd><p>date of sampling</p>
</dd>
<dt>biovol_um3_ml</dt><dd><p>biovolume</p>
</dd>
</dl>


<hr>
<h2 id='mean_naomit'>Compute mean value while ignoring NA's</h2><span id='topic+mean_naomit'></span>

<h3>Description</h3>

<p>Compute mean value while ignoring NA's
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_naomit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_naomit_+3A_x">x</code></td>
<td>
<p>A numeric vector that may contain NA's</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
#example dataset with 50 rows

mean_naomit(lakegeneva$biovol_um3_ml)
</code></pre>

<hr>
<h2 id='mfg_csr_convert'>Returns a CSR classification based on Morphofunctional group (MFG).
Correspondence based on Salmaso et al. 2015 and Reynolds et al. 1988</h2><span id='topic+mfg_csr_convert'></span>

<h3>Description</h3>

<p>Returns a CSR classification based on Morphofunctional group (MFG).
Correspondence based on Salmaso et al. 2015 and Reynolds et al. 1988
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfg_csr_convert(mfg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfg_csr_convert_+3A_mfg">mfg</code></td>
<td>
<p>Character string with MFG name, following Salmaso et al. 2015</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with values 'C','S','R','CR','SC','SR', or NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mfg_csr_convert("11a-NakeChlor")
</code></pre>

<hr>
<h2 id='mfg_csr_convert_df'>Returns a CSR classification based on Morphofunctional group (MFG).
Correspondence based on Salmaso et al. 2015 and Reynolds et al. 1988</h2><span id='topic+mfg_csr_convert_df'></span>

<h3>Description</h3>

<p>Returns a CSR classification based on Morphofunctional group (MFG).
Correspondence based on Salmaso et al. 2015 and Reynolds et al. 1988
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfg_csr_convert_df(phyto.df, mfg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfg_csr_convert_df_+3A_phyto.df">phyto.df</code></td>
<td>
<p>dataframe containing a character field containing MFG classifications</p>
</td></tr>
<tr><td><code id="mfg_csr_convert_df_+3A_mfg">mfg</code></td>
<td>
<p>Character string with MFG name, following Salmaso et al. 2015</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with an additional field named CSR, containing CSR classifications or NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lakegeneva)
lakegeneva&lt;-genus_species_extract(lakegeneva,'phyto_name')
lakegeneva&lt;-species_to_mfg_df(lakegeneva)
lakegeneva&lt;-mfg_csr_convert_df(lakegeneva,mfg='MFG')
head(lakegeneva)
</code></pre>

<hr>
<h2 id='mfg_csr_library'>MFG-CSR correspondence based on CSR-trait relationships in Reynolds et al. 1988
and MFG-trait relationships in Salmaso et al. 2015</h2><span id='topic+mfg_csr_library'></span>

<h3>Description</h3>

<p>MFG-CSR correspondence based on CSR-trait relationships in Reynolds et al. 1988
and MFG-trait relationships in Salmaso et al. 2015
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mfg_csr_library)
</code></pre>


<h3>Format</h3>

<p>A data frame with columns:
</p>

<dl>
<dt>MFG</dt><dd><p>full MFG name from Salmaso et al. 2015</p>
</dd>
<dt>CSR</dt><dd><p>CSR classification including intermediate classes</p>
</dd>
</dl>


<hr>
<h2 id='mfgTraits'>Functional Trait Database derived from Rimet et al.</h2><span id='topic+mfgTraits'></span>

<h3>Description</h3>

<p>Functional Trait Database derived from Rimet et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mfgTraits)
</code></pre>


<h3>Format</h3>

<p>A data frame with columns:
</p>

<dl>
<dt>phyto_name</dt><dd><p>binomial scientific name</p>
</dd>
<dt>genus</dt><dd><p>genus name</p>
</dd>
<dt>species</dt><dd><p>species name</p>
</dd>
<dt>Mobility.apparatus</dt><dd><p>1/0 indicates presence/absence of flagella or motility</p>
</dd>
<dt>Size</dt><dd><p>character values 'large' or 'small'; based on 35 micrometer max linear dimension</p>
</dd>
<dt>Colonial</dt><dd><p>1/0 indicates typical colonial growth form or not</p>
</dd>
<dt>Filament</dt><dd><p>1/0 indicates filamentous growth form or not</p>
</dd>
<dt>Centric</dt><dd><p>1/0 indicates diatoms with centric growth form</p>
</dd>
<dt>Gelatinous</dt><dd><p>1/0 indicates presence/absence of mucilage</p>
</dd>
<dt>Aerotopes</dt><dd><p>1/0 indicates presence/absence of aerotopes</p>
</dd>
<dt>Class</dt><dd><p>Taxonomic class</p>
</dd>
<dt>Order</dt><dd><p>Taxonomic order</p>
</dd>
<dt>MFG.fromtraits</dt><dd><p>MFG classification using traits_to_mfg function</p>
</dd>
</dl>


<hr>
<h2 id='phyto_ts_aggregate'>Aggregate phytoplankton timeseries based on abundance. Up to 3 grouping variables can be given:
e.g. genus, species, stationid, depth range.
If no abundance var is given, will aggregate to presence/absence of grouping vars.</h2><span id='topic+phyto_ts_aggregate'></span>

<h3>Description</h3>

<p>Aggregate phytoplankton timeseries based on abundance. Up to 3 grouping variables can be given:
e.g. genus, species, stationid, depth range.
If no abundance var is given, will aggregate to presence/absence of grouping vars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyto_ts_aggregate(
  phyto.data,
  DateVar = "date_dd_mm_yy",
  SummaryType = c("abundance", "presence.absence"),
  AbundanceVar = "biovol_um3_ml",
  GroupingVar1 = "phyto_name",
  GroupingVar2 = NA,
  GroupingVar3 = NA,
  remove.rare = FALSE,
  fun = sum,
  format = "%d-%m-%y"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyto_ts_aggregate_+3A_phyto.data">phyto.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_datevar">DateVar</code></td>
<td>
<p>character string: field name for date variable. character or POSIX data.</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_summarytype">SummaryType</code></td>
<td>
<p>'abundance' for a matrix of aggregated abundance,'presence.absence'
for 1 (present) and 0 (absent).</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_abundancevar">AbundanceVar</code></td>
<td>
<p>character string with field name containing abundance data
Can be NA if data is only a species list and aggregated presence/absence is desired.</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_groupingvar1">GroupingVar1</code></td>
<td>
<p>character string: field name for first grouping variable. defaults to spp.</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_groupingvar2">GroupingVar2</code></td>
<td>
<p>character string: name of additional grouping var field</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_groupingvar3">GroupingVar3</code></td>
<td>
<p>character string: name of additional grouping var field</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_remove.rare">remove.rare</code></td>
<td>
<p>TRUE/FALSE. If TRUE, removes all instances of GroupingVar1 that occur &lt; 5
of time periods.</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_fun">fun</code></td>
<td>
<p>function used to aggregate abundance based on grouping variables</p>
</td></tr>
<tr><td><code id="phyto_ts_aggregate_+3A_format">format</code></td>
<td>
<p>character string: format for DateVar POSIXct conversion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with grouping vars, date_dd_mm_yy, and abundance or presence/absence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
lakegeneva&lt;-genus_species_extract(lakegeneva,'phyto_name')
lg.genera=phyto_ts_aggregate(lakegeneva,SummaryType='presence.absence',
                             GroupingVar1='genus')
head(lg.genera)
</code></pre>

<hr>
<h2 id='sampeff'>Visually assess change in sampling effort over time (author: Dietmar Straile)</h2><span id='topic+sampeff'></span>

<h3>Description</h3>

<p>Visually assess change in sampling effort over time (author: Dietmar Straile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampeff(
  b_data,
  column,
  save.pdf = F,
  lakename = "",
  datecolumn = "date_dd_mm_yy",
  dateformat = "%d-%m-%y"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampeff_+3A_b_data">b_data</code></td>
<td>
<p>Name of data.frame object</p>
</td></tr>
<tr><td><code id="sampeff_+3A_column">column</code></td>
<td>
<p>column name or number for field containing abundance (biomass,biovol, etc.)
can be NA for presence absence</p>
</td></tr>
<tr><td><code id="sampeff_+3A_save.pdf">save.pdf</code></td>
<td>
<p>TRUE/FALSE Should the output plot be saved to a file? defaults to FALSE</p>
</td></tr>
<tr><td><code id="sampeff_+3A_lakename">lakename</code></td>
<td>
<p>Character string for labeling output plot</p>
</td></tr>
<tr><td><code id="sampeff_+3A_datecolumn">datecolumn</code></td>
<td>
<p>Character String or number specifying dataframe field with date information</p>
</td></tr>
<tr><td><code id="sampeff_+3A_dateformat">dateformat</code></td>
<td>
<p>Character string specifying POSIX data format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a time-series plot of minimum relative abundance over time. This should change 
systematically with counting effort.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
#example dataset with 50 rows

sampeff(lakegeneva,column=6) #column 6 contains biovolume
</code></pre>

<hr>
<h2 id='set_algaebase_apikey_header'>Add algaebase API key to curl handle</h2><span id='topic+set_algaebase_apikey_header'></span>

<h3>Description</h3>

<p>Add algaebase API key to curl handle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_algaebase_apikey_header(apikey = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_algaebase_apikey_header_+3A_apikey">apikey</code></td>
<td>
<p>character string with valid key</p>
</td></tr>
</table>


<h3>Value</h3>

<p>curl handle object
</p>

<hr>
<h2 id='species_mfg_library'>Trait-based MFG classifications for common Eurasion/North American phytoplankton species.
See accompanying manuscript for sources</h2><span id='topic+species_mfg_library'></span>

<h3>Description</h3>

<p>Trait-based MFG classifications for common Eurasion/North American phytoplankton species.
See accompanying manuscript for sources
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(species_mfg_library)
</code></pre>


<h3>Format</h3>

<p>A data frame with columns:
</p>

<dl>
<dt>genus</dt><dd><p>genus name</p>
</dd>
<dt>species</dt><dd><p>species name</p>
</dd>
<dt>MFG</dt><dd><p>corresponding MFG classification based on Salmaso et al. 2015</p>
</dd>
<dt>source</dt><dd><p>literature or online source for MFG classification</p>
</dd>
</dl>



<h3>References</h3>

<p>Algaebase <a href="https://www.algaebase.org">https://www.algaebase.org</a>
</p>
<p>Phycokey <a href="http://www.cfb.unh.edu/phycokey/phycokey.htm">http://www.cfb.unh.edu/phycokey/phycokey.htm</a>
</p>
<p>Western Diatoms of North America <a href="https://diatoms.org">https://diatoms.org</a>
</p>
<p>CyanoDB 2 <a href="http://www.cyanodb.cz/">http://www.cyanodb.cz/</a>
</p>
<p>Nordic Microalgae <a href="http://nordicmicroalgae.org">http://nordicmicroalgae.org</a>
</p>
<p>Phytopedia <a href="https://www.eoas.ubc.ca/research/phytoplankton/">https://www.eoas.ubc.ca/research/phytoplankton/</a>
</p>
<p>Kapustin, D., Sterlyagova, I. and Patova, E., 2019. Morphology of Chrysastrella paradoxa stomatocysts from the Subpolar Urals (Russia) with comments on related morphotypes. Phytotaxa, 402(6), pp.295-300.
</p>

<hr>
<h2 id='species_search_itis'>Wrapper function for several functions in ritis::
Searches ITIS database for matches to a binomial scientific name
outputs matches, current accepted names, synonyms, and higher taxonomy</h2><span id='topic+species_search_itis'></span>

<h3>Description</h3>

<p>Wrapper function for several functions in ritis::
Searches ITIS database for matches to a binomial scientific name
outputs matches, current accepted names, synonyms, and higher taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_search_itis(genspp, higher = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species_search_itis_+3A_genspp">genspp</code></td>
<td>
<p>Character string. Binomial scientific name with space between genus
and species.</p>
</td></tr>
<tr><td><code id="species_search_itis_+3A_higher">higher</code></td>
<td>
<p>Boolean. If TRUE, add higher taxonomic classifications to output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with submitted name (orig.name), matched name (matched.name),
1/0 flag indicating that original name is currently accepted (orig.name.accepted),
1/0 flag indicating if search was genus_only (for distinguishing genus_search_itis
and species_search_itis results), synonyms if any, and higher taxonomy (if
higher=TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>species="Aphanizomenon flosaquae"
species_search_itis(species,higher=FALSE)
</code></pre>

<hr>
<h2 id='species_to_mfg'>Conversion of a single genus and species name to a single MFG. Uses species.mfg.library</h2><span id='topic+species_to_mfg'></span>

<h3>Description</h3>

<p>Conversion of a single genus and species name to a single MFG. Uses species.mfg.library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_to_mfg(genus, species = "", flag = 1, mfgDbase = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species_to_mfg_+3A_genus">genus</code></td>
<td>
<p>Character string: genus name</p>
</td></tr>
<tr><td><code id="species_to_mfg_+3A_species">species</code></td>
<td>
<p>Character string: species name</p>
</td></tr>
<tr><td><code id="species_to_mfg_+3A_flag">flag</code></td>
<td>
<p>Resolve ambiguous mfg: 1 = return(NA),2= manual selection</p>
</td></tr>
<tr><td><code id="species_to_mfg_+3A_mfgdbase">mfgDbase</code></td>
<td>
<p>data.frame of species MFG classifications. Defaults to the supplied species.mfg.library data object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with MFG classification and diagnostic information.
ambiguous.mfg=1 if multiple possible mfg matches
genus.classification=1 if no exact match was found with genus + species name
partial.match=1 if mfg was based on fuzzy matching of taxonomic name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>species_to_mfg('Scenedesmus','bijuga')
#returns "11a-NakeChlor"
</code></pre>

<hr>
<h2 id='species_to_mfg_df'>Wrapper function to apply species_phyto_convert() across a data.frame</h2><span id='topic+species_to_mfg_df'></span>

<h3>Description</h3>

<p>Wrapper function to apply species_phyto_convert() across a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_to_mfg_df(phyto.df, flag = 1, mfgDbase = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species_to_mfg_df_+3A_phyto.df">phyto.df</code></td>
<td>
<p>Name of data.frame. Must have character fields named 'genus' and 'species'</p>
</td></tr>
<tr><td><code id="species_to_mfg_df_+3A_flag">flag</code></td>
<td>
<p>Resolve ambiguous MFG: 1 = return(NA), 2 = manual selection</p>
</td></tr>
<tr><td><code id="species_to_mfg_df_+3A_mfgdbase">mfgDbase</code></td>
<td>
<p>specify library of species to MFG associations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>input data.frame with a new character column of MFG classifications
and diagnostic information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lakegeneva)
#example dataset with 50 rows

new.lakegeneva &lt;- genus_species_extract(lakegeneva,'phyto_name')
new.lakegeneva &lt;- species_to_mfg_df(new.lakegeneva)
head(new.lakegeneva)
</code></pre>

<hr>
<h2 id='traitranges'>surface/volume ratio and max linear dimension criteria for CSR
From Reynolds 1988 and Reynolds 2006</h2><span id='topic+traitranges'></span>

<h3>Description</h3>

<p>surface/volume ratio and max linear dimension criteria for CSR
From Reynolds 1988 and Reynolds 2006
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(traitranges)
</code></pre>


<h3>Format</h3>

<p>A data frame with columns:
</p>

<dl>
<dt>Measurement</dt><dd><p>measurement type</p>
</dd>
<dt>C.min</dt><dd><p>minimum value for C</p>
</dd>
<dt>S.min</dt><dd><p>minimum value for S</p>
</dd>
<dt>R.min</dt><dd><p>minimum value for R</p>
</dd>
<dt>C.max</dt><dd><p>maximum value for C</p>
</dd>
<dt>S.max</dt><dd><p>maximum value for S</p>
</dd>
<dt>R.max</dt><dd><p>maximum value for R</p>
</dd>
<dt>units</dt><dd><p>units of measurement</p>
</dd>
<dt>source</dt><dd><p>source for criteria</p>
</dd>
</dl>


<hr>
<h2 id='traits_to_csr'>Assign phytoplankton species to CSR functional groups, based on surface to volume ratio and
maximum linear dimension ranges proposed by Reynolds et al. 1988;2006</h2><span id='topic+traits_to_csr'></span>

<h3>Description</h3>

<p>Assign phytoplankton species to CSR functional groups, based on surface to volume ratio and
maximum linear dimension ranges proposed by Reynolds et al. 1988;2006
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traits_to_csr(
  sav,
  msv,
  msv.source = "Reynolds 2006",
  traitrange = algaeClassify::traitranges
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traits_to_csr_+3A_sav">sav</code></td>
<td>
<p>numeric estimate of cell or colony surface area /volume ratio</p>
</td></tr>
<tr><td><code id="traits_to_csr_+3A_msv">msv</code></td>
<td>
<p>numeric product of surface area/volume ratio and maximum linear dimension</p>
</td></tr>
<tr><td><code id="traits_to_csr_+3A_msv.source">msv.source</code></td>
<td>
<p>character string with reference source for distinguishing criteria</p>
</td></tr>
<tr><td><code id="traits_to_csr_+3A_traitrange">traitrange</code></td>
<td>
<p>data frame with trait criteria for c,s,r groups. The included table
can be replaced with user-defined criteria if desired. Measurements are:
Surface area/volume ratio (sav), maximum linear dimension (mld) and mld*sav (msv).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string with one of 5 return values: C,CR,S,R, or SR.
CR and SR groups reflect overlap between criteria for the 3 main groups.
</p>


<h3>See Also</h3>

<p>&lt;https://powellcenter.usgs.gov/geisha&gt; for project information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
traits_to_csr(sav=0.2,msv=10,msv.source='Reynolds 2006',traitrange=traitranges)


</code></pre>

<hr>
<h2 id='traits_to_csr_df'>Add CSR functional group classifications to a dataframe of phytoplankton species, based on surface to volume ratio and
maximum linear dimension ranges proposed by Reynolds et al. 1988;2006</h2><span id='topic+traits_to_csr_df'></span>

<h3>Description</h3>

<p>Add CSR functional group classifications to a dataframe of phytoplankton species, based on surface to volume ratio and
maximum linear dimension ranges proposed by Reynolds et al. 1988;2006
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traits_to_csr_df(
  df,
  sav,
  msv,
  msv.source = "Reynolds 2006",
  traitrange = algaeClassify::traitranges
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traits_to_csr_df_+3A_df">df</code></td>
<td>
<p>name of dataframe</p>
</td></tr>
<tr><td><code id="traits_to_csr_df_+3A_sav">sav</code></td>
<td>
<p>character string with name of column that contains surface to volume ratio values</p>
</td></tr>
<tr><td><code id="traits_to_csr_df_+3A_msv">msv</code></td>
<td>
<p>character string with name of column that contains maximum linear dimension * surface to volume ratio values</p>
</td></tr>
<tr><td><code id="traits_to_csr_df_+3A_msv.source">msv.source</code></td>
<td>
<p>character string with reference source for distinguishing criteria</p>
</td></tr>
<tr><td><code id="traits_to_csr_df_+3A_traitrange">traitrange</code></td>
<td>
<p>data frame with trait criteria for c,s,r groups. The included table
can be replaced with user-defined criteria if desired. Measurements are:
Surface area/volume ratio (sav), maximum linear dimension (mld) and mld*sav (msv).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string with one of 5 return values: C,CR,S,SR, or R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
csr.df&lt;-data.frame(msv=10,sav=1)

csr.df$CSR&lt;-traits_to_csr_df(csr.df,'msv','sav')

print(csr.df)
</code></pre>

<hr>
<h2 id='traits_to_mfg'>Assign MFG based on binary functional traits and taxonomy (Class and Order)</h2><span id='topic+traits_to_mfg'></span>

<h3>Description</h3>

<p>Assign MFG based on binary functional traits and taxonomy (Class and Order)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traits_to_mfg(
  flagella = NA,
  size = NA,
  colonial = NA,
  filament = NA,
  centric = NA,
  gelatinous = NA,
  aerotopes = NA,
  class = NA,
  order = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traits_to_mfg_+3A_flagella">flagella</code></td>
<td>
<p>1 if flagella are present, 0 if they are absent.</p>
</td></tr>
<tr><td><code id="traits_to_mfg_+3A_size">size</code></td>
<td>
<p>Character string: 'large' or 'small'. Classification criteria is left to the user.</p>
</td></tr>
<tr><td><code id="traits_to_mfg_+3A_colonial">colonial</code></td>
<td>
<p>1 if typically colonial growth form, 0 if typically unicellular.</p>
</td></tr>
<tr><td><code id="traits_to_mfg_+3A_filament">filament</code></td>
<td>
<p>1 if dominant growth form is filamentous, 0 if not.</p>
</td></tr>
<tr><td><code id="traits_to_mfg_+3A_centric">centric</code></td>
<td>
<p>1 if diatom with centric growth form, 0 if not. NA for  non-diatoms.</p>
</td></tr>
<tr><td><code id="traits_to_mfg_+3A_gelatinous">gelatinous</code></td>
<td>
<p>1 mucilagenous sheath is typically present, 0 if not.</p>
</td></tr>
<tr><td><code id="traits_to_mfg_+3A_aerotopes">aerotopes</code></td>
<td>
<p>1 if aerotopes allowing buoyancy regulation are typically present, 0 if not.</p>
</td></tr>
<tr><td><code id="traits_to_mfg_+3A_class">class</code></td>
<td>
<p>Character string: The taxonomic class of the species</p>
</td></tr>
<tr><td><code id="traits_to_mfg_+3A_order">order</code></td>
<td>
<p>Character string: The taxonomic order of the species</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of the species' morphofunctional group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>traits_to_mfg(flagella = 1,size = "large",colonial = 1,filament = 0,centric = NA,gelatinous = 0,
               aerotopes = 0,class = "Euglenophyceae",order = "Euglenales")
</code></pre>

<hr>
<h2 id='traits_to_mfg_df'>Assign morphofunctional groups to a dataframe of functional traits and higher taxonomy</h2><span id='topic+traits_to_mfg_df'></span>

<h3>Description</h3>

<p>Assign morphofunctional groups to a dataframe of functional traits and higher taxonomy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traits_to_mfg_df(
  dframe,
  arg.names = c("flagella", "size", "colonial", "filament", "centric", "gelatinous",
    "aerotopes", "class", "order")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traits_to_mfg_df_+3A_dframe">dframe</code></td>
<td>
<p>An R dataframe containing functional trait information and higher taxonomy</p>
</td></tr>
<tr><td><code id="traits_to_mfg_df_+3A_arg.names">arg.names</code></td>
<td>
<p>Character string of column names corresponding to arguments for traits_to_mfg()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing morpho-functional group (MFG) designations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create a two-row example dataframe of functional traits
func.dframe=data.frame(flagella=1,size=c("large","small"),colonial=0,filament=0,centric=NA,
                       gelatinous=0,aerotopes=0,class="Euglenophyceae",order="Euglenales",
                       stringsAsFactors=FALSE)

#check the dataframe
print(func.dframe)

#run the function to produce a two-element character vector
func.dframe$MFG&lt;-traits_to_mfg_df(func.dframe,c("flagella","size","colonial",
                                 "filament","centric","gelatinous",
                                 "aerotopes","class","order"))

print(func.dframe)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
