<!DOCTYPE html><html><head><title>Help for package untb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {untb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+.count'><p>Add two count objects</p></a></li>
<li><a href='#alonso'><p>Various functions from Alonso and McKane 2004</p></a></li>
<li><a href='#bci'><p>Barro Colorado Island (BCI) dataset</p></a></li>
<li><a href='#butterflies'><p>abundance data for butterflies</p></a></li>
<li><a href='#caruso'><p>Dataset due to Caruso</p></a></li>
<li><a href='#census'><p>Construct, coerce, and test for a census object</p></a></li>
<li><a href='#copepod'><p>Copepod data supplied by Phil Pugh</p></a></li>
<li><a href='#count'><p>Construct, coerce, and test for a count object</p></a></li>
<li><a href='#display.untb'><p>Animation of neutral ecological drift</p></a></li>
<li><a href='#etienne'><p>Etienne's sampling formula</p></a></li>
<li><a href='#expected.abundance'><p>Expected abundances under the neutral model</p></a></li>
<li><a href='#extractor'><p>Extract rows of a database in count form</p></a></li>
<li><a href='#fisher'><p>Various functionality to implement Fisher's logseries</p></a></li>
<li><a href='#ghats'><p>Tree counts in 1-ha plots from the Western Ghats mountains (South India)</p></a></li>
<li><a href='#isolate'><p>Randomly select a subset of an ecosystem</p></a></li>
<li><a href='#logkda'><p>Etienne's K(D,A)</p></a></li>
<li><a href='#logS1'><p>logarithms of Stirling numbers of the first kind</p></a></li>
<li><a href='#no.of.ind'><p>Ecosystem diagnostics</p></a></li>
<li><a href='#optimal.params.gst'><p> Estimation of local immigration using GST(k) statistics</p></a></li>
<li><a href='#optimal.params.sloss'><p> Estimation of neutral community parameters using a two-stage maximum-likelihood procedure</p></a></li>
<li><a href='#optimal.prob'><p>Returns an estimate of the fundamental biodiversity number</p></a></li>
<li><a href='#phi'><p>Hubbell's phi</p></a></li>
<li><a href='#plot.count'><p>Abundance curves</p></a></li>
<li><a href='#preston'><p>Preston diagram of an ecosystem</p></a></li>
<li><a href='#print.preston'><p>Print and plot objects of class Preston</p></a></li>
<li><a href='#print.summary.count'><p>Print method for summary objects</p></a></li>
<li><a href='#rand.neutral'><p>Random neutral ecosystem</p></a></li>
<li><a href='#sahfos'><p>Biodiversity dataset provided by SAHFOS</p></a></li>
<li><a href='#saunders'><p>Dataset due to Saunders</p></a></li>
<li><a href='#simpson'><p>Simpson's diversity index</p></a></li>
<li><a href='#species.count'><p>Ecosystem diagnostics for output of untb()</p></a></li>
<li><a href='#spitale'><p>Counts of diatom species in springs of the Adamello-Brenta Nature Park</p></a></li>
<li><a href='#summary.count'><p>Summary methods for count and census objects</p></a></li>
<li><a href='#theta.prob'><p>Posterior probabilities for theta</p></a></li>
<li><a href='#untb'><p>Ecological drift simulation under the Unified Neutral</p>
Theory of Biodiversity</a></li>
<li><a href='#untb-package'>
<p>Unified neutral theory of biodiversity</p></a></li>
<li><a href='#vallade'><p>Various functions from Vallade and Houchmandzadeh</p></a></li>
<li><a href='#volkov'><p>Expected frequency of species</p></a></li>
<li><a href='#zsm'><p>Zero sum multinomial distribution as derived by McKane</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ecological Drift under the UNTB</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7-7</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>PARI/GP &gt;= 2.3.0 [strongly recommended for
logkda()]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Brobdingnag (&ge; 1.1-8), partitions (&ge; 1.9-14), polynom</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Hubbell's Unified Neutral Theory of Biodiversity.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/untb">https://github.com/RobinHankin/untb</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/untb/issues">https://github.com/RobinHankin/untb/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 00:03:15 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 02:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2B.count'>Add two count objects</h2><span id='topic++2B.count'></span><span id='topic++2B.census'></span>

<h3>Description</h3>

<p>Adds two count objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'count'
a + b
## S3 method for class 'census'
a + b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.count_+3A_a">a</code>, <code id="+2B2B.count_+3A_b">b</code></td>
<td>
<p>objects of class <code>count</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider count objects <code>a</code> and <code>b</code>.  Then <code>a+b</code> is a
count object that records the number of each species in <code>a</code> and
<code>b</code> combined.  It is as though the organisms in the surveys were
pooled.
</p>
<p>Census objects are coerced to count objects, added, then the result
coerced to a count object.
</p>
<p>The operation is commutative and associative.
</p>
<p>One might think that the addition method should use the <a href="https://CRAN.R-project.org/package=frab"><span class="pkg">frab</span></a>
package, but this would not account for extinct species.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin, based on an R-help tip from Gabor Grothendiek</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- count(c(dogs=4,pigs=0,slugs=5))
b &lt;- count(c(slugs=4,hogs=1,frogs=19))

a+b

</code></pre>

<hr>
<h2 id='alonso'>Various functions from Alonso and McKane 2004</h2><span id='topic+alonso.eqn6'></span><span id='topic+alonso.eqn11'></span><span id='topic+alonso.eqn12'></span>

<h3>Description</h3>

<p>Various functions from Alonso and McKane 2004 dealing with analytical
solutions of a neutral model of biodiversity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alonso.eqn6(JM, n, theta)
alonso.eqn11(J, n, theta)
alonso.eqn12(J, n, theta, give=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alonso_+3A_j">J</code>, <code id="alonso_+3A_jm">JM</code></td>
<td>
<p>Size of the community and metacommunity respectively</p>
</td></tr>
<tr><td><code id="alonso_+3A_n">n</code></td>
<td>
<p>Abundance</p>
</td></tr>
<tr><td><code id="alonso_+3A_theta">theta</code></td>
<td>
<p>Biodiversity constant</p>
</td></tr>
<tr><td><code id="alonso_+3A_give">give</code></td>
<td>
<p>In function <code>alonso.eqn12()</code>, Boolean with default
<code>FALSE</code> meaning to return the value of the integral, and
<code>TRUE</code> meaning to return the full output of <code>integrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notation follows that of Alonso and McKane 2004
</p>


<h3>Note</h3>

<p>Function <code>alonso.eqn6()</code> is identical to function
<code>vallade.eqn5()</code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>D. Alonso and A. J. McKane 2004.  &ldquo;Sampling
Hubbell's neutral model of biodiversity&rdquo;, Ecology Letters 7:901-910</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- 100
plot(1:J , alonso.eqn11(J,n=1:J,
theta=5),log="y",type="l",xlab="n",ylab=expression(S(n)),main="Eqns
11 and 12 of Alonso and McKane")
points(1:J , alonso.eqn12(J,n=1:J, theta=5),type="l",lty=2)
legend("topright",legend=c("equation 11","equation 12"),lty=1:2)
</code></pre>

<hr>
<h2 id='bci'>Barro Colorado Island (BCI) dataset</h2><span id='topic+bci'></span><span id='topic+BCI'></span>

<h3>Description</h3>

<p>The BCI dataset contains location and species identity for all 10cm
dbh (diameter at breast height) trees on Barro Colorado Island,
currently for years 1981-1983, 1985, 1990, 1995, 2000, and 2005.  The
subset of interest here is the abundances for each of the 252 species
recorded.
</p>
<p>The BCI dataset is not included in the <span class="pkg">untb</span> package, because its
licence appears to be inconsistent with the GPL.
</p>
<p>It is discussed here because it was used as an example dataset in
Hankin 2007.
</p>


<h3>Source</h3>

<p><code>http://www.stri.org/english/research/facilities/terrestrial/barro_colorado/index.php</code>
</p>


<h3>References</h3>


<ul>
<li><p> R. Condit, S. P. Hubbell and R. B. Foster 2005. <em>Barro
Colorado Forest Census Plot Data</em> 
</p>
</li>
<li><p> S. P. Hubbell 2001.  &ldquo;The Unified Neutral Theory of
Biodiversity&rdquo;.  Princeton University Press.
</p>
</li>
<li><p> R. K. S. Hankin 2007.  &ldquo;Introducing <b>untb</b>, an R
package for simulating ecological drift under the unified neutral
theory of biodiversity&rdquo;.  <em>Journal of Statistical Software</em>,
volume 22, issue 12
</p>
</li></ul>


<hr>
<h2 id='butterflies'>abundance data for butterflies</h2><span id='topic+butterflies'></span><span id='topic+butterfly'></span>

<h3>Description</h3>

<p>A dataset of class &ldquo;count&rdquo; showing the abundance of several
butterfly species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(butterflies)</code></pre>


<h3>Format</h3>

<p>A table with names of different butterfly species, and entries
corresponding to the respective numbers of individuals.
</p>


<h3>References</h3>

<p>Texas Birding and Naturalist Web
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(butterflies)
plot(butterflies, uncertainty=TRUE)

</code></pre>

<hr>
<h2 id='caruso'>Dataset due to Caruso</h2><span id='topic+oribatid'></span><span id='topic+Oribatid'></span><span id='topic+caruso'></span><span id='topic+Caruso'></span>

<h3>Description</h3>

<p>A dataframe in standard format due to Migliorini and Caruso presenting
observations of oribatid mites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(caruso)</code></pre>


<h3>Format</h3>

<p>Dataset <code>caruso</code> is a data frame with 194 observations on 5
variables.  Each row corresponds to a species; the observations (rows)
are the species abundances in each of 5 habitats.
</p>
<p>Following Migliorini et al 2002, the habitats were:
</p>

<ul>
<li><p> a pure beech woodland (&lsquo;<code>Beech</code>&rsquo;)
</p>
</li>
<li><p> a coppice woodland (&lsquo;<code>Coppice</code>&rsquo;)
</p>
</li>
<li><p> grassland (&lsquo;<code>Grassland</code>&rsquo;)
</p>
</li>
<li><p> heathland (&lsquo;<code>Heathland</code>&rsquo;)
</p>
</li>
<li> <p>&lsquo;Biancana&rsquo; badlands (&lsquo;<code>Biancana</code>&rsquo;)
</p>
</li></ul>



<h3>Details</h3>

<p>Oribatid mites are rather small and very interesting free living soil
microarthropods.  They have a huge species diversity with populations
characterised by highly aggregated distributions over multiple spatial
scales ranging from a few centimetres to hundreds of meters.
</p>
<p>Within each habitat, several soil samples were collected (five randomly
located replicates per each month: see the paper Migliorini et
al. 2002). So, actually, that is a network of small samples that make a
single large sample.
</p>
<p>The five study areas of this data set belong to five habitats that are
very typical of that Mediterranean region.  These five areas also
belong to a rather homogeneous biogeographical region (southern
Tuscany).  On the ground of what is known on the biology and community
patterns of Oribatida, several a-priori hypotheses can be made on
expected changes in the diversity of their assemblages and immigration
rates respectively between and within the five areas.  For instance,
under the Neutral Model one might expect that the Beech forest should
have the highest Theta and an immigration rate of about 1, while one
might expect the opposite for the Biancana (a very arid habitat, a kind
of gariga/garrigue with very patchy vegetation).
</p>


<h3>Note</h3>

<p>Executing <code>optimal.params.sloss(caruso)</code> does not return
useful output.  The reason for this is unknown.</p>


<h3>Source</h3>

<p>Data kindly supplied by Tancredi Caruso
</p>


<h3>References</h3>


<ul>
<li><p> T. Caruso and others 2007. &ldquo;The Berger-Parker index as
an effective tool for monitoring the biodiversity of disturbed
soils: a case study on Mediterranean oribatid (Acari: Oribatida)
assemblages&rdquo;. <em>Biodiversity Conservation</em>, 16:3277-3285
</p>
</li>
<li><p> M. Migliorini, A. Petrioli, and F. Bernini 2002.
&ldquo;Comparative analysis of two edaphic zoocoenoses (Oribatid
mites and Carabid beetles) in five habitats of the
&lsquo;Pietraporciana&rsquo; and &lsquo;Lucciolabella&rsquo; Nature Reserves
(Orcia Valley, central Italy)&rdquo;.  <em>Acta Oecologica</em>, 23:361-374
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+extractor">extractor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(caruso)

summary(count(caruso[,1]))


</code></pre>

<hr>
<h2 id='census'>Construct, coerce, and test for a census object</h2><span id='topic+census'></span><span id='topic+as.census'></span><span id='topic+is.census'></span>

<h3>Description</h3>

<p>In package <span class="pkg">untb</span>, ecosystem data is held in one of two preferred
forms: census data and count data.  Function <code>as.census()</code> coerces
to census format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>census(a)
as.census(a)
is.census(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="census_+3A_a">a</code></td>
<td>
<p>Ecosystem data.  In function <code>as.census()</code>, if a table,
interpret as species count data; otherwise, interpret as census data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>census</dfn> object is a list of individuals in the form of an
unnamed vector whose elements indicate the individuals' species;
compare <dfn>count</dfn> objects.
</p>
<p>An object of class &ldquo;census&rdquo; is also an unordered factor.  The
levels are always in alphabetical order.
</p>
<p>Function <code>census()</code> takes an object of class &ldquo;count&rdquo; and
returns an object of class &ldquo;census&rdquo;.  This function is not
really intended for the end user.
</p>
<p>Function <code>as.census()</code> coerces to class &ldquo;count&rdquo; then
returns <code>census()</code> of the result.
</p>


<h3>Value</h3>

<p>Returns an object of class &ldquo;census&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+count">count</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
jj &lt;- c(dogs=4,pigs=10,slugs=0,fish=1)

x &lt;- census(jj)   # slugs appear as zero abundance
extant(x)  # slugs gone

x+x   # count method for census objects: order of elements lost


as.census(jj)  # probably NOT what you meant

a &lt;- c(rep("oak",5) ,rep("ash",2),rep("elm",3),rep("xx",4))
# note that "a" is a plain vector here.
as.census(a)
</code></pre>

<hr>
<h2 id='copepod'>Copepod data supplied by Phil Pugh</h2><span id='topic+copepod'></span><span id='topic+ostracod'></span>

<h3>Description</h3>

<p>A dataset of copepod (resp: ostracod) abundances supplied by Dr Phil
Pugh of the National Oceanography Centre, Southampton
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(copepod)
data(ostracod)
</code></pre>


<h3>Format</h3>

<p>A table with names of different copepod (resp: ostracod) species,
and entries corresponding to the numbers of individuals of each
species.
</p>


<h3>Source</h3>

<p>Kindly supplied by Southampton Oceanography Centre.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(copepod)
optimize(f=theta.likelihood,interval=c(10,100), maximum=TRUE,
S=no.of.spp(copepod), J=no.of.ind(copepod), give.log=TRUE)

data(ostracod)
preston(ostracod)

</code></pre>

<hr>
<h2 id='count'>Construct, coerce, and test for a count object</h2><span id='topic+count'></span><span id='topic+as.count'></span><span id='topic+is.count'></span>

<h3>Description</h3>

<p>In package <span class="pkg">untb</span>, ecosystem data is held in one of two preferred
forms: census data and count data.  Function <code>count</code> creates an
object of class &ldquo;count&rdquo;, and <code>as.count()</code> coerces to this
class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.count(a,add="")
count(a)
is.count(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_+3A_a">a</code></td>
<td>
<p>Ecosystem data.  In function <code>as.count()</code>, if a table,
interpret as species count data; otherwise, interpret as census
data.  Special dispensation is made for single rows of a dataframe</p>
</td></tr>
<tr><td><code id="count_+3A_add">add</code></td>
<td>
<p>In function <code>as.count()</code>, character argument with
default <code>""</code> (empty string) meaning to leave the species
names unchanged.  A non-empty string is prepended
to the species names using <code>paste()</code>.  This is useful if the
species names are integers because the display can become confusing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <dfn>count</dfn> object is a list of species together with
their abundance.  It also has class &ldquo;table&rdquo;; compare
&ldquo;census&rdquo; objects.
</p>
<p>An object of class &ldquo;count&rdquo; is a table sorted from most to least
abundant species.  The singletons are thus tabulated last.
</p>
<p>Function <code>count()</code> takes a vector, the elements of which are
interpreted as abundances.  If any of the elements are named, the
names are interpreted as species names (unnamed elements are given the
null name).  If the vector is unnamed, then the species names are
upper case letters, with the first element being named
&ldquo;<code>A</code>&rdquo;, the second &ldquo;<code>B</code>&rdquo;, and so on; this
behaviour is inherited from <code>as.table()</code>.  Note that this means
that the species names are not necessarily in alphabetical order.
From version 1.6-9, zero elements are interpreted as zero abundance
species (ie extinct).
</p>
<p>To access or change species names, use <code>names(x)</code> and
<code>names(x) &lt;- v</code> respectively.
</p>
<p>Function <code>as.count()</code> coerces its argument to count form.
</p>


<h3>Value</h3>

<p>Returns an object of class &ldquo;count&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+census">census</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 



a &lt;- c(rep("oak",5) ,rep("ash",2),rep("elm",3),rep("xx",4))
as.count(a)




data(saunders)
as.count(saunders[1,-(1:150)])

jj &lt;- sample(1:5,5,replace=TRUE)
as.count(jj)
as.count(jj,add="spp.")

</code></pre>

<hr>
<h2 id='display.untb'>Animation of neutral ecological drift</h2><span id='topic+display.untb'></span>

<h3>Description</h3>

<p>Displays an ongoing simulation of neutral ecological drift using nice
colours and a simple animation technique.  <strong>Does not work as
intended in RStudio: use base R</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>display.untb(start, gens=100, prob.of.mutate = 0, cex=3, individually
= TRUE, ask = FALSE, flash = FALSE, delay = 0, cols=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="display.untb_+3A_start">start</code></td>
<td>
<p>Starting ecosystem; coerced to class census.  Usually,
pass an object of class count; see examples.  To start
with a monoculture of size 10, use <code>start=rep(1,10)</code> and to
start with a system of maximal diversity (ie all singletons), use
<code>start=1:10</code></p>
</td></tr>
<tr><td><code id="display.untb_+3A_gens">gens</code></td>
<td>
<p>Number of generations to simulate</p>
</td></tr>
<tr><td><code id="display.untb_+3A_prob.of.mutate">prob.of.mutate</code></td>
<td>
<p>Probability of mutation.  The default of zero
corresponds to <code class="reqn">\theta=0</code> and this means that any
ecosystem will eventually become a monoculture (it is particularly
instructive to watch this happen, especially with a starting
ecosystem of maximal diversity<code class="reqn">\mbox{---}</code>but be warned,
this can take a long time, especially for ecosystems with a large
number of individuals).  Nonzero values mean that a nontrivial
dominance-diversity curve will eventuate, although this too can take
a long time to happen.  Try a nonzero value of <code>prob.of.mutate</code>
with monoculture start (use <code>individually=FALSE</code> for such
experiments)</p>
</td></tr>
<tr><td><code id="display.untb_+3A_cex">cex</code></td>
<td>
<p>The size of the dots used for plotting, defaulting to 3</p>
</td></tr>
<tr><td><code id="display.untb_+3A_individually">individually</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning
that a timestep means the death of a single individual and the
simultaneous birth of a new individual; and <code>FALSE</code> meaning
that a timestep refers to every individual in the system</p>
</td></tr>
<tr><td><code id="display.untb_+3A_ask">ask</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to display the
generations autonomously, and <code>TRUE</code> meaning to wait for the
user to hit the &ldquo;return&rdquo; before proceeding</p>
</td></tr>
<tr><td><code id="display.untb_+3A_flash">flash</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to indicate the site
of a death/birth with a flashing ring; and default <code>FALSE</code>
meaning to omit the flashing ring.  Use <code>TRUE</code> for pedagogic
purposes, possibly with <code>ask</code> set to <code>TRUE</code>, or a nonzero
<code>delay</code>. This option only kicks in if <code>individually</code> is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="display.untb_+3A_delay">delay</code></td>
<td>
<p>Time delay between generations in seconds; meaningful
whatever the value of <code>flash</code> and <code>individually</code></p>
</td></tr>
<tr><td><code id="display.untb_+3A_cols">cols</code></td>
<td>
<p>A vector of colours with default <code>NULL</code> meaning to
choose them randomly.  Useful for printing stills from a
movie</p>
</td></tr>
<tr><td><code id="display.untb_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plot()</code> and <code>points()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>S. P. Hubbell 2001.  &ldquo;The Unified Neutral Theory of Biodiversity&rdquo;.
Princeton University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(butterflies)
display.untb(start=butterflies,prob=0, gens=1e2)
</code></pre>

<hr>
<h2 id='etienne'>Etienne's sampling formula</h2><span id='topic+etienne'></span><span id='topic+Etienne'></span><span id='topic+optimal.params'></span>

<h3>Description</h3>

<p>Function <code>etienne()</code> returns the probability of a given dataset
given <code>theta</code> and <code>m</code> according to the Etienne's sampling
formula.  Function <code>optimal.params()</code> returns the maximum likelihood
estimates for <code>theta</code> and <code>m</code> using numerical optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etienne(theta, m, D, log.kda = NULL, give.log = TRUE, give.like = TRUE)
optimal.params(D, log.kda = NULL, start = NULL, give = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etienne_+3A_theta">theta</code></td>
<td>
<p>Fundamental biodiversity parameter</p>
</td></tr>
<tr><td><code id="etienne_+3A_m">m</code></td>
<td>
<p>Immigration probability</p>
</td></tr>
<tr><td><code id="etienne_+3A_d">D</code></td>
<td>
<p>Dataset; a count object</p>
</td></tr>
<tr><td><code id="etienne_+3A_log.kda">log.kda</code></td>
<td>
<p>The KDA as defined in equation A11 of Etienne 2005.
See details section</p>
</td></tr>
<tr><td><code id="etienne_+3A_give.log">give.log</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return
the logarithm of the value</p>
</td></tr>
<tr><td><code id="etienne_+3A_give.like">give.like</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return
the likelihood and <code>FALSE</code> meaning to return the probability</p>
</td></tr>
<tr><td><code id="etienne_+3A_start">start</code></td>
<td>
<p>In function <code>optimal.params()</code>, the start point for
the optimization routine <code class="reqn">(\theta,m)</code>.</p>
</td></tr>
<tr><td><code id="etienne_+3A_give">give</code></td>
<td>
<p>In function <code>optimal.params()</code>, Boolean, with
<code>TRUE</code> meaning to return all output of the optimization
routine, and default <code>FALSE</code> meaning to return just the point
estimate</p>
</td></tr>
<tr><td><code id="etienne_+3A_...">...</code></td>
<td>
<p>In function <code>optimal.params()</code>, further arguments
passed to <code>optim()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>etienne()</code> is just Etienne's formula 6:
</p>
<p style="text-align: center;"><code class="reqn">P[D|\theta,m,J]=
    \frac{J!}{\prod_{i=1}^Sn_i\prod_{j=1}^J{\Phi_j}!}
    \frac{\theta^S}{(\theta)_J}\times
    \sum_{A=S}^J\left(K(D,A)
       \frac{(\theta)_J}{(\theta)_A}
       \frac{I^A}{(I)_J}
       \right)</code>
</p>

<p>where <code class="reqn">\log K(D,A)</code> is given by function <code>logkda()</code> (qv).  It
might be useful to know the (trivial) identity for the Pochhammer symbol
[written <code class="reqn">(z)_n</code>] documented in <code>theta.prob.Rd</code>.  For
convenience, Etienne's Function <code>optimal.params()</code> uses
<code>optim()</code> to return the maximum likelihood estimate for
<code class="reqn">\theta</code> and <code class="reqn">m</code>.
</p>
<p>Compare function <code>optimal.theta()</code>, which is restricted to no
dispersal limitation, ie <code class="reqn">m=1</code>.
</p>
<p>Argument <code>log.kda</code> is optional: this is the <code class="reqn">K(D,A)</code> as defined
in equation A11 of Etienne 2005; it is computationally expensive to
calculate.  If it is supplied, the functions documented here will not
have to calculate it from scratch: this can save a considerable amount
of time
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>R. S. Etienne 2005. &ldquo;A new sampling formula for
biodiversity&rdquo;.  <em>Ecology letters</em> 8:253-260</p>


<h3>See Also</h3>

<p><code><a href="#topic+logkda">logkda</a></code>,<code><a href="#topic+optimal.theta">optimal.theta</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(butterflies)
## Not run: optimal.params(butterflies)  #takes too long without PARI/GP


#Now the one from Etienne 2005, supplementary online info:

zoo &lt;- count(c(pigs=1, dogs=1, cats=2, frogs=3, bats=5, slugs=8))
l &lt;- logkda.R(zoo, use.brob=TRUE)  # Use logkda() if pari/gp is available
optimal.params(zoo, log.kda=l)  #compare his answer of 7.047958 and 0.22635923.

</code></pre>

<hr>
<h2 id='expected.abundance'>Expected abundances under the neutral model</h2><span id='topic+expected.abundance'></span>

<h3>Description</h3>

<p>Returns a vector of expected abundances of the i-th ranked species under
the neutral model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected.abundance(J, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expected.abundance_+3A_j">J</code></td>
<td>
<p>Size of the ecosystem</p>
</td></tr>
<tr><td><code id="expected.abundance_+3A_theta">theta</code></td>
<td>
<p>Biodiversity parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>count</code>.  Species names (capital
letters) are assigned by function <code>count()</code>. 
</p>


<h3>Note</h3>

<p>Function is very slow even for moderate J. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>S. P. Hubbell 2001.  &ldquo;The Unified Neutral Theory of Biodiversity&rdquo;.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rand.neutral">rand.neutral</a></code>,<code><a href="#topic+count">count</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>expected.abundance(J=10,theta=3)

sum(expected.abundance(J=10,theta=3))  #should be 10
</code></pre>

<hr>
<h2 id='extractor'>Extract rows of a database in count form</h2><span id='topic+extractor'></span>

<h3>Description</h3>

<p>Extracts rows of a data frame and, if there is one row only, coerces
to a count object, preserving the species names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractor(x, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractor_+3A_x">x</code></td>
<td>
<p>A data frame with column headings being species names</p>
</td></tr>
<tr><td><code id="extractor_+3A_index">index</code></td>
<td>
<p>A vector of indices to extract</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>index</code> is length one, the numbers are interpreted as species
counts, and the output is coerced to a <code>count</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(saunders)
plot(extant(extractor(saunders,1)))
</code></pre>

<hr>
<h2 id='fisher'>Various functionality to implement Fisher's logseries</h2><span id='topic+fisher'></span><span id='topic+fisher.ecosystem'></span><span id='topic+fishers.alpha'></span>

<h3>Description</h3>

<p>Various functions connected to Fisher's logseries including creation of
synthetic datasets and estimation of Fisher's alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishers.alpha(N, S, give=FALSE)
fisher.ecosystem(N, S, nmax, alpha=NULL, c=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher_+3A_n">N</code></td>
<td>
<p>Size of the ecosystem.  In the case of
<code>fisher.ecosystem()</code>, the expected size of the ecosystem</p>
</td></tr>
<tr><td><code id="fisher_+3A_s">S</code></td>
<td>
<p>Number of species in ecosystem</p>
</td></tr>
<tr><td><code id="fisher_+3A_alpha">alpha</code></td>
<td>
<p>In function <code>fisher.ecosystem()</code>, Fisher's
<code class="reqn">\alpha</code>.   If not supplied, it will be calculated from
<code>N</code> and <code>S</code>.</p>
</td></tr>
<tr><td><code id="fisher_+3A_give">give</code></td>
<td>
<p>In function <code>fishers.alpha()</code>, Boolean variable with
default <code>FALSE</code> meaning to return alpha, and <code>TRUE</code>
meaning to return a list containing <code>x</code> and <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="fisher_+3A_nmax">nmax</code></td>
<td>
<p>In function <code>fisher.ecosystem()</code>, the maximum number
of species abundance classes to consider</p>
</td></tr>
<tr><td><code id="fisher_+3A_c">c</code></td>
<td>
<p>In function <code>fisher.ecosystem()</code>, the rare species
advantage term</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>fishers.alpha()</code> solves for <code class="reqn">\alpha</code> given
<code class="reqn">N</code> and <code class="reqn">S</code>, as per Fisher's table 9, p55.
</p>
<p>Given <code class="reqn">N</code> and <code class="reqn">S</code> (or <code class="reqn">\alpha</code>), function
<code>fisher.ecosystem()</code> generates a Fisherian ecosystem
with expected size <code class="reqn">N</code> and expected species count <code class="reqn">S</code>.  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>R. A. Fisher and A. S. Corbet and C. B. Williams 1943. &ldquo;The
relation between the number of species and the number of individuals in
a random sample of an animal population&rdquo;, <em>Journal of Animal
Ecology</em>, volume 12, pp 42&ndash;58
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fishers.alpha(N=100000,S=100)
#compare the Table value:
  100000/10^3.95991
</code></pre>

<hr>
<h2 id='ghats'>Tree counts in 1-ha plots from the Western Ghats mountains (South India)</h2><span id='topic+ghats'></span>

<h3>Description</h3>

<p>Tree species counts are given in 50 one-hectare sampling plots (species
by sample matrix).  This only includes trees over 10 cm dbh (diameter at
breast height) and species labels (row names) are numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ghats)</code></pre>


<h3>Format</h3>

<p>Data frame displaying 304 species counts over 50 one-hectare plots.
</p>


<h3>Source</h3>

<p>Ecological Archives E088-149-A1.
<a href="http://www.esapubs.org/Archive/ecol/E088/149/appendix-A.htm">http://www.esapubs.org/Archive/ecol/E088/149/appendix-A.htm</a>
</p>


<h3>References</h3>

<p>Francois Munoz, Pierre Couteron, B. R. Ramesh, and Rampal S. Etienne
2007.  &ldquo;Estimating parameters of neutral communities: from one
single large to several small samples.&rdquo;  <em>Ecology</em> 88(10):2482-2488.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ghats)
# Rank-abundance picture of plot 1 (column 1 in ghats)
plot(extant(count(ghats[,1])))

#histogram of optimal theta across the 50 plots:
hist(apply(ghats,2,optimal.theta),col='gray')

</code></pre>

<hr>
<h2 id='isolate'>Randomly select a subset of an ecosystem</h2><span id='topic+isolate'></span>

<h3>Description</h3>

<p>Return an ecosystem comprised of individuals randomly sampled from a
metacommunity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolate(a, size = no.of.ind(a), replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isolate_+3A_a">a</code></td>
<td>
<p>Ecosystem data</p>
</td></tr>
<tr><td><code id="isolate_+3A_size">size</code></td>
<td>
<p>Number of individuals to sample</p>
</td></tr>
<tr><td><code id="isolate_+3A_replace">replace</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to
sample individuals from the metacommunity with replacement and
<code>FALSE</code> meaning to sample without replacement.  See details
section</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting argument <code>replace</code> to default <code>TRUE</code> is much
faster.
</p>
<p>The canonical example is given by Leigh et al 1993, in which islands
were isolated from the mainland by rising waters.  The trees on the
islands were held to be a randomly drawn sample from the metacommunity.
</p>
<p>Given that the usual usage of this function is to generate a plausible
ecosystem under such a scenario, one would have a hard time justifying
the use of <code>replace=TRUE</code> as it allows (for example) a singleton
metacommunity species to have multiple representatives in the returned
ecosystem.
</p>
<p>However, for large metacommunities and small subsamples, the distinction
between <code>replace=TRUE</code> and <code>replace=FALSE</code> is small.
</p>


<h3>Value</h3>

<p>Returns a <code>count</code> object
</p>


<h3>Note</h3>

<p>If <code>replace=FALSE</code>, the returned count object includes extinct
species.  Use <code>extant(isolate(...))</code> to return only extant species
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>E. G. Leigh and others 1993. &ldquo;The decline of tree
diversity on newly isolated tropical islands: a test of a null
hypothesis and some implications&rdquo;.  Evolutionary Ecology, 7:76-102</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rand.neutral(1000,10)
no.of.spp(a)
no.of.spp(isolate(a))
</code></pre>

<hr>
<h2 id='logkda'>Etienne's K(D,A)</h2><span id='topic+logkda'></span><span id='topic+logkda.a11'></span><span id='topic+logkda.R'></span><span id='topic+logkda.pari'></span><span id='topic+logkda.polyn'></span><span id='topic+logkda_pari_unix'></span><span id='topic+logkda_pari_windows'></span>

<h3>Description</h3>

<p>Calculates Etienne's <code class="reqn">K(D,A)</code> using a variety of different methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logkda.R(a, use.brob=TRUE)
logkda.a11(a)
logkda.pari(a, numerical=TRUE, gp_binary = "gp")
logkda.polyn(a)
logkda(a, method="pari", ...)
logkda_pari_unix(a, numerical, pari_string, gp_binary)
logkda_pari_windows(a, numerical, pari_string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logkda_+3A_a">a</code></td>
<td>
<p>Count object</p>
</td></tr>
<tr><td><code id="logkda_+3A_use.brob">use.brob</code></td>
<td>
<p>In function <code>logkda.R()</code>, Boolean, with default
<code>TRUE</code> meaning to use Brobdingnagian numbers for the
calculation.  This is slower but allows one to analyze larger
datasets</p>
</td></tr>
<tr><td><code id="logkda_+3A_numerical">numerical</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to coerce
to a numerical vector (thereby losing precision), and <code>FALSE</code>
meaning to return the string produced by pari/gp</p>
</td></tr>
<tr><td><code id="logkda_+3A_method">method</code></td>
<td>
<p>In function <code>logkda()</code>, a string specifying which
method to use.  Takes <code>R</code>, <code>a11</code>, or <code>pari</code></p>
</td></tr>
<tr><td><code id="logkda_+3A_pari_string">pari_string</code>, <code id="logkda_+3A_gp_binary">gp_binary</code></td>
<td>
<p>configuration variables (not intended to
be changed by the user)</p>
</td></tr>
<tr><td><code id="logkda_+3A_...">...</code></td>
<td>
<p>In function <code>logkda()</code>, further arguments which are
passed to the other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user should use function <code>logkda()</code>, which is a wrapper for
the other functions.  Note that the default method, <code>pari</code>,
requires the pari/gp system to be installed.  This is the
preferred option because it is much faster than the other methods.
</p>
<p>Functions <code>logkda.R()</code> and <code>logkda.pari()</code> calculate
<code class="reqn">K(D,A)</code> using the method appearing in Etienne (2005), supplementary
online material; they use <span class="rlang"><b>R</b></span> and pari/gp respectively.
Function <code>logkda.a11</code> is a direct implementation of formula A11
in Etienne (2005).  The formula is
</p>
<p style="text-align: center;"><code class="reqn">
  K(D,A)=
  \sum_{\left\{a_1,\ldots,a_S|\sum a_i=A\right\}}
  \prod_{i=1}^S\frac{
    \overline{s}\left(n_i, a_i\right)
    \overline{s}\left(a_i,   1\right) }{
  \overline{s}\left(n_i,1\right)}</code>
</p>

<p>where <code class="reqn">\overline{s}\left(n_i,a_i\right)</code> are Stirling numbers of
the first kind (see <code>logS1</code>).
</p>
<p>Function <code>logkda.pari()</code> dispatches to either
<code>logkda_pari_unix()</code> or <code>logkda_pari_windows()</code> but the
windows function is not guaranteed to work.
</p>


<h3>Note</h3>

<p>If <code>method</code> takes its default value of &ldquo;<code>pari</code>&rdquo;, and
<code>pari/gp</code> is not installed (the test is <code>gp --version</code>),
then the method is changed to <code>R</code> and a warning given.
</p>
<p>Function <code>logkda.a11()</code> is included because the computational
method is a direct transcription of formula A11; it is very slow.
</p>
<p>Function <code>logkda.pari()</code> is a wrapper for
<code>.logkda.pari.windows()</code> or <code>.logkda.pari.unix()</code>.  It uses
&ldquo;<code>if(R.Version()$os == 'windows')</code>&rdquo; to check for windows
operating systems.
</p>
<p>It would be nice to use gp2c (rather than gp)
but I can't make the &ldquo;<code>-g</code>&rdquo; flag work properly; and I had
to hack <code>gp2c-run</code> to make it call gp with the
<code>-q</code> flag
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin; <code>logkda()</code> is an <span class="rlang"><b>R</b></span> transliteration of
<code>pari/gp</code> code appearing in Etienne 2005 (supplementary online
material) due to Chave.
</p>
<p>Function <code>logkda.polyn()</code> provided by Francois Munoz.
</p>
<p>Function <code>.logkda.pari.windows()</code> provided by Andrea Manica and
Francois Munoz.
</p>


<h3>References</h3>

<p>R. S. Etienne 2005. &ldquo;A New Sampling Formula for Neutral
Biodiversity&rdquo;.  <em>Ecology Letters</em>, volume 8, pp253&ndash;260.
<code>doi: 10.111/j.1461-0248.2004.00717.x</code>
</p>
<p>C. Batut and K. Belabas and D. Bernardi and H. Cohen and M. Olivier
2000.  &ldquo;User's guide to PARI/GP&rdquo;.  <a href="http://www.parigp-home.de/">http://www.parigp-home.de/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+etienne">etienne</a></code>,<code><a href="#topic+logS1">logS1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- count(c(dogs=7,pigs=3,crabs=1,hogs=1,slugs=1))

## Not run: logkda(a)

logkda.R(a)
logkda.R(a, use.brob=FALSE)
logkda.a11(a)
# All four should be the same up to numerical errors

</code></pre>

<hr>
<h2 id='logS1'>logarithms of Stirling numbers of the first kind</h2><span id='topic+logS1'></span><span id='topic+logS1vect'></span>

<h3>Description</h3>

<p>Natural logarithms of Stirling numbers of the first kind, used by
function <code>logkda.a11()</code> (dataset <code>logS1</code>) and function
<code>logkda.polyn()</code> (dataset <code>logS1vect</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logS1</code></pre>


<h3>Format</h3>

<p>Dataset <code>logS1</code> is a 100-by-100 matrix of logs of Stirling numbers
of the first kind; <code>logS1vect</code> is a vector of length 499500
</p>


<h3>Source</h3>

<p>Calculated by Maple
</p>


<h3>See Also</h3>

<p><code><a href="#topic+etienne">etienne</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>exp(logS1[1:5,1:5])
</code></pre>

<hr>
<h2 id='no.of.ind'>Ecosystem diagnostics</h2><span id='topic+no.of.ind'></span><span id='topic+no.of.spp'></span><span id='topic+no.of.singletons'></span><span id='topic+no.of.extinct'></span><span id='topic+maximal.abundance'></span><span id='topic+singletons'></span><span id='topic+extinct'></span><span id='topic+extant'></span>

<h3>Description</h3>

<p>Ecosystem diagnostics such as species count, individual count, number of
singletons, etc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>no.of.ind(x)
no.of.spp(x, include.extinct=FALSE)
no.of.singletons(x)
no.of.extinct(x)
maximal.abundance(x)
singletons(x)
extinct(x)
extant(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="no.of.ind_+3A_x">x</code></td>
<td>
<p>Ecosystem vector; is coerced to class <code>count</code></p>
</td></tr>
<tr><td><code id="no.of.ind_+3A_include.extinct">include.extinct</code></td>
<td>
<p>In function <code>no.of.spp()</code>, Boolean
argument with <code>TRUE</code> meaning to include extinct species (ie
species with an abundance of zero), and default <code>FALSE</code>
meaning to return the number of extant species</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li>
<p>Function <code>no.of.spp()</code> returns the number of species in an
ecosystem object, treating extinct species in line with argument
<code>include.extinct</code>
</p>
</li>
<li>
<p>Function <code>no.of.ind()</code> returns the number of individuals
</p>
</li>
<li>
<p>Function <code>no.of.singletons()</code> returns the number of singletons
</p>
</li>
<li>
<p>Function <code>no.of.extinct()</code> returns the number of extinct species
</p>
</li>
<li>
<p>Function <code>maximal.abundance()</code> returns the abundance of the most
abundant species
</p>
</li>
<li>
<p>Function <code>singletons()</code> returns a <code>count</code> object containing
only the singletons: each abundance is one
</p>
</li>
<li>
<p>Function <code>extinct()</code> returns a <code>count</code> object containing
only the extinct species: each abundance is zero
</p>
</li>
<li>
<p>Function <code>extant()</code> returns a <code>count</code> object containing
only the extant species: each abundance is greater than zero
</p>
</li></ul>



<h3>Note</h3>

<p>It is sometimes useful to include species with an abundance of
zero when, for example, taking a single row of the Saunders dataframe.
</p>
<p>The default for <code>include.extinct</code> is <code>FALSE</code> because this is
required for (eg) <code>optimal.theta()</code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>S. P. Hubbell.  &ldquo;The Unified Neutral Theory of Biodiversity&rdquo;.
Princeton University Press, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(butterflies)
no.of.spp(butterflies)
no.of.ind(butterflies)

jj1 &lt;- count(c(dogs=7,pigs=3,crabs=0,slugs=1))
jj2 &lt;- count(c(squid=0,dogs=3,bugs=0))
jj3 &lt;- count(c(bugs=3,rats=0,crabs=3,cats=0))

extinct(jj1 + jj2) 
extinct(jj3)               #rats and cats
extant(jj3)                #bugs and crabs

singletons(jj1)
singletons(jj2)           # empty 
singletons(jj1 + jj3)     # slugs

</code></pre>

<hr>
<h2 id='optimal.params.gst'> Estimation of local immigration using GST(k) statistics</h2><span id='topic+optimal.params.gst'></span><span id='topic+GST.k'></span><span id='topic+I.k'></span>

<h3>Description</h3>

<p>Functions <code>optimal.params.gst()</code>, <code>GST.k()</code> and <code>I.k()</code>
apply to count data collected over a network of community samples k
(species by sample matrix).  A theoretical relationship between
<code>GST(k)</code> statistics and local immigration numbers <code>I(k)</code>, in
the context of a spatially-implicit neutral community model (Munoz et
al 2008), is used to provide <code>GST(k)</code> and <code>I(k)</code> statistics
any sample k.
</p>
<p>If requested, <code>optimal.params.gst()</code> further provides the user with
confidence bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal.params.gst(D, exact = TRUE, ci = FALSE, cint = c(0.025, 0.975), nbres = 100)
GST.k(D, exact = TRUE)
I.k(D, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal.params.gst_+3A_d">D</code></td>
<td>
<p> A data table including species counts in a network of
community samples (columns) </p>
</td></tr>
<tr><td><code id="optimal.params.gst_+3A_exact">exact</code></td>
<td>
<p> If <code>TRUE</code>, exact similarity statistics are
calculated (sampling without replacement) while, if false, approximate
statistics (sampling with replacement) are considered (see Munoz et al
2008 for further statistical discussion)</p>
</td></tr>
<tr><td><code id="optimal.params.gst_+3A_ci">ci</code></td>
<td>
<p> Specifies whether bootstraps confidence intervals of
immigration estimates are to be calculated</p>
</td></tr>
<tr><td><code id="optimal.params.gst_+3A_cint">cint</code></td>
<td>
<p> Bounds of the confidence interval, if <code>ci = TRUE</code></p>
</td></tr> 
<tr><td><code id="optimal.params.gst_+3A_nbres">nbres</code></td>
<td>
<p> Number of rounds of the bootstrap procedure for
confidence interval calculation, if ci = T</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>GST</code></td>
<td>
<p>A vector of 0 to 1 <code>GST(k)</code> numbers (specific output of <code>GST.k</code>)</p>
</td></tr>
<tr><td><code>nk</code></td>
<td>
<p>Number of individuals within samples (length = number of samples)</p>
</td></tr>
<tr><td><code>distrib</code></td>
<td>
<p>Species counts of the merged dataset (output of <code>GST.k</code> and <code>I.k</code>)</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>Immigration estimates (output of <code>I.k</code> and <code>optimal.params.gst</code>)</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Corresponding immigration rates (output of <code>I.k</code> and
<code>optimal.params.gst</code>).  Specific outputs of <code>optimal.params.gst</code> when ci = T (bootstrap procedure)</p>
</td></tr>
<tr><td><code>Ici</code></td>
<td>
<p>Confidence interval of <code>I(k)</code></p>
</td></tr>
<tr><td><code>mci</code></td>
<td>
<p>Confidence interval of <code>m(k)</code></p>
</td></tr>
<tr><td><code>Iboot</code></td>
<td>
<p>Table of bootstrapped values of <code>I(k)</code></p>
</td></tr>
<tr><td><code>mboot</code></td>
<td>
<p>Table of bootstrapped values of i<code>m(k)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Francois Munoz </p>


<h3>References</h3>

<p>Francois Munoz, Pierre Couteron and B.R. Ramesh
(2008). &ldquo;Beta-diversity in spatially implicit neutral models:
a new way to assess species migration.&rdquo; <em>The American
Naturalist</em> 172(1): 116-127
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+optimal.params">optimal.params</a></code>,<code><a href="#topic+optimal.params.sloss">optimal.params.sloss</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ghats)
optimal.params.gst(ghats)
</code></pre>

<hr>
<h2 id='optimal.params.sloss'> Estimation of neutral community parameters using a two-stage maximum-likelihood procedure </h2><span id='topic+optimal.params.sloss'></span>

<h3>Description</h3>

<p>Function <code>optimal.params.sloss()</code> returns maximum likelihood
estimates of <code>theta</code> and <code>m(k)</code> using numerical
optimization.
</p>
<p>It differs from <code>untb</code>'s <code>optimal.params()</code> function as it
applies to a network of smaller community samples <code>k</code> instead of
to a single large community sample.
</p>
<p>Although there is a single, common <code>theta</code> for all communities,
immigration estimates are provided for each local community <code>k</code>,
sharing a same biogeographical background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal.params.sloss(D, nbres = 100, ci = FALSE, cint = c(0.025, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal.params.sloss_+3A_d">D</code></td>
<td>
<p> Species counts over a network of community samples (species by sample table) </p>
</td></tr>
<tr><td><code id="optimal.params.sloss_+3A_nbres">nbres</code></td>
<td>
<p> Number of resampling rounds for <code>theta</code> estimation</p>
</td></tr>
<tr><td><code id="optimal.params.sloss_+3A_ci">ci</code></td>
<td>
<p> Specifies whether bootstraps confidence intervals should be provided for estimates </p>
</td></tr>
<tr><td><code id="optimal.params.sloss_+3A_cint">cint</code></td>
<td>
<p> Bounds of confidence intervals, if ci = T </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>theta</code></td>
<td>
<p>Mean <code>theta</code> estimate</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>The vector of estimated immigration numbers <code>I(k)</code></p>
</td></tr>
</table>
<p>Output of the bootstrap procedure, if ci = T:
</p>
<table>
<tr><td><code>thetaci</code></td>
<td>
<p>Confidence interval for <code>theta</code></p>
</td></tr>
<tr><td><code>msampleci</code></td>
<td>
<p>Confidence intervals for <code>m(k)</code></p>
</td></tr>
<tr><td><code>thetasamp</code></td>
<td>
<p>theta estimates provided by the resampling procedure</p>
</td></tr>
<tr><td><code>Iboot</code></td>
<td>
<p>Bootstrapped values of <code>I(k)</code></p>
</td></tr>
<tr><td><code>mboot</code></td>
<td>
<p>Bootstrapped values of <code>m(k)</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p> The function returns unhelpful output when run with the
<code>caruso</code> dataset as in <code>optimal.params.sloss(caruso)</code>.  The
reason for this behaviour is unknown.</p>


<h3>Author(s)</h3>

<p> Francois Munoz </p>


<h3>References</h3>

<p>Francois Munoz, Pierre Couteron, B. R. Ramesh, and Rampal S. Etienne
2007. &ldquo;Estimating parameters of neutral communities: from one
single large to several small samples&rdquo;. <em>Ecology</em>
88(10):2482-2488 
</p>


<h3>See Also</h3>

 <p><a href="#topic+optimal.params">optimal.params</a>, <a href="#topic+optimal.params.gst">optimal.params.gst</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ghats)
optimal.params.sloss(ghats)
</code></pre>

<hr>
<h2 id='optimal.prob'>Returns an estimate of the fundamental biodiversity number</h2><span id='topic+optimal.prob'></span><span id='topic+optimal.theta'></span>

<h3>Description</h3>

<p>Returns a maximum likelihood estimate for the fundamental biodiversity
number <code class="reqn">\theta</code> (function <code>optimal.theta()</code>) or the
probability of mutation (function <code>optimal.prob()</code>) and optionally
return information about the likely error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal.prob(x,  interval=NULL, N=NULL, like=NULL, ...)
optimal.theta(x, interval=NULL, N=NULL, like=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal.prob_+3A_x">x</code></td>
<td>
<p>Ecosystem vector or species count table</p>
</td></tr>
<tr><td><code id="optimal.prob_+3A_interval">interval</code></td>
<td>
<p>Bracketing interval for probability of mutation to be
passed to the optimization routine (here <code>optimize()</code>).  
Default of <code>NULL</code> means to use a wide interval.  Note that this
argument is interpreted as an interval of <em><code class="reqn">\theta</code></em> for
both <code>optimal.prob()</code> and <code>optimal.theta()</code>.</p>
</td></tr>
<tr><td><code id="optimal.prob_+3A_n">N</code></td>
<td>
<p>Integer; the number of parametric resampled estimates to
give.  Default of <code>NULL</code> means to return just the maximum
likelihood estimate</p>
</td></tr>
<tr><td><code id="optimal.prob_+3A_like">like</code></td>
<td>
<p>Units of likelihood to calculate credible interval.
Edwards recommends using 2</p>
</td></tr>
<tr><td><code id="optimal.prob_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>optimize()</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The fundamental biodiversity parameter <code class="reqn">\theta</code> is
<code class="reqn">2\nu J</code>, where <code class="reqn">\nu</code> is the probability of
mutation (ie, as estimated by <code>optimal.prob()</code>), and <code class="reqn">J</code> is
the size of the ecosystem.
</p>
<p>For the general case of dispersal limitation, see functions
<code>etienne()</code> and <code>optimal.params()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+etienne">etienne</a></code>,<code><a href="#topic+optimal.params.sloss">optimal.params.sloss</a></code>,<code><a href="#topic+optimal.params.gst">optimal.params.gst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(butterflies)
optimal.prob(butterflies)
optimal.theta(butterflies)
</code></pre>

<hr>
<h2 id='phi'>Hubbell's phi</h2><span id='topic+phi'></span><span id='topic+unphi'></span>

<h3>Description</h3>

<p>Hubbell's phi: counts of species abundances 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(x,addnames=TRUE)
unphi(freq, string="spp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_+3A_x">x</code></td>
<td>
<p>Ecosystem vector; is coerced to class <code>count</code></p>
</td></tr>
<tr><td><code id="phi_+3A_addnames">addnames</code></td>
<td>
<p>Boolean with default
<code>TRUE</code> meaning to set the name of the <code class="reqn">i</code>th element
to the species with abundance <code class="reqn">i</code> if unique.  Set to
<code>FALSE</code> to suppress this, which is useful if the species names
are long</p>
</td></tr>
<tr><td><code id="phi_+3A_freq">freq</code></td>
<td>
<p>Frequency data (eg as returned by <code>phi()</code>)</p>
</td></tr>
<tr><td><code id="phi_+3A_string">string</code></td>
<td>
<p>Character; species name to prepend (using <code>NULL</code>
can be confusing)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>phi()</code> coerces its argument to a <code>count</code> object and
by default returns a named vector whose <code class="reqn">i</code>th element is the
number of species with <code class="reqn">i</code> individuals.  The name of the
<code class="reqn">i</code>th element is the species with abundance <code class="reqn">i</code> if unique
and empty otherwise.  Function <code>phi()</code> is used by
<code>theta.prob()</code>.
</p>
<p>Function <code>unphi()</code> does the reverse: given the output of
<code>phi()</code>, it returns a corresponding <code>count</code> object.  Note that
species names are lost.
</p>


<h3>Note</h3>

<p>The code for setting the names is a dog's breakfast</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>S. P. Hubbell 2001.  &ldquo;The Unified Neutral Theory of Biodiversity&rdquo;.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+preston">preston</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
jj &lt;- c(rep("oak",5) ,rep("ash",2),rep("elm",3),"pine","tea","yew")
a &lt;- as.count(jj)

phi(a)
unphi(phi(a))   #should match 'a' except for species names (which are lost)

data(butterflies)
phi(butterflies,add=FALSE)

summary(unphi(phi(butterflies)))  #should match 'summary(butterflies)'

</code></pre>

<hr>
<h2 id='plot.count'>Abundance curves</h2><span id='topic+plot.count'></span><span id='topic+plot.census'></span>

<h3>Description</h3>

<p>Plot the ranked abundance curve</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'count'
plot(x, uncertainty = FALSE, expectation = FALSE, theta = NULL, n = 10, ...)
## S3 method for class 'census'
plot(x, uncertainty = FALSE, expectation = FALSE, theta = NULL, n = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.count_+3A_x">x</code></td>
<td>
<p>Ecosystem object, coerced to class count</p>
</td></tr>
<tr><td><code id="plot.count_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Boolean,
with <code>TRUE</code> meaning to show bootstrapped estimates for the
species diversity curve, and default <code>FALSE</code> meaning to omit
this</p>
</td></tr>
<tr><td><code id="plot.count_+3A_expectation">expectation</code></td>
<td>
<p>Boolean,
with <code>TRUE</code> meaning to plot expected abundances, and default <code>FALSE</code>
meaning not to plot them.  <strong>Warning</strong> this option takes a
loooong time to run, even for moderate values of <code class="reqn">J</code></p>
</td></tr>
<tr><td><code id="plot.count_+3A_theta">theta</code></td>
<td>
<p>Fundamental biodiversity number used if argument
<code>uncertainty</code> or <code>expectation</code> are <code>TRUE</code>.  Default
value of <code>NULL</code> means to use the maximum likelihood estimate
returned by function <code>optimal.theta()</code></p>
</td></tr>    
<tr><td><code id="plot.count_+3A_n">n</code></td>
<td>
<p>Number of bootstrapped estimates to plot</p>
</td></tr>
<tr><td><code id="plot.count_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code>untb()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots a ranked abundance curve, optionally with parametrically resampled
datasets showing the uncertainties</p>


<h3>Note</h3>

<p>If using <code>expectation</code>, it's usually necessary to set <code>ylim</code>
and possibly <code>xlim</code> manually.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(copepod)
plot(copepod)

data(butterflies)
plot(butterflies,uncertainty=TRUE)

x &lt;- count(c(pigs=1, dogs=1, cats=2, frogs=3, bats=5, slugs=8))
plot(x,expectation=TRUE,ylim=c(0.5,10))

</code></pre>

<hr>
<h2 id='preston'>Preston diagram of an ecosystem</h2><span id='topic+preston'></span><span id='topic+Preston'></span>

<h3>Description</h3>

<p>Gives a standard Preston diagram for an ecosystem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preston(x,n=NULL,original=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preston_+3A_x">x</code></td>
<td>
<p>Ecosystem vector that is coerced to class <code>count</code>, or a
matrix whose rows are species counts</p>
</td></tr>
<tr><td><code id="preston_+3A_n">n</code></td>
<td>
<p>An integer specifying the number of species abundance classes
to use, with default <code>NULL</code> meaning to use
<code class="reqn">1+\log_2(J)</code>.  Must be greater than 1 if specified.
If <code>x</code> is a vector, <code>NULL</code> is not acceptable as the
program does not try to guess what is required</p>
</td></tr>
<tr><td><code id="preston_+3A_original">original</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to use the
nonoverlapping technique discussed below, and <code>TRUE</code>
meaning to use Preston's original formulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Preston diagram is a table showing the number of species having
abundances in specified abundance classes.  Consider the following
Preston diagram, created with <code>original = FALSE</code>:
</p>
<pre>
                  1  2  3-4  5-8  9-16  17-32  33-64  65-Inf
number of species 10 5    7    5     1      5      4       0
</pre>
<p>This shows that there are 10 species with abundance 1 (that is,
singletons); 5 species with abundance 2; 7 species with abundance 3-4; 5
species with abundance 5-8, and so on.  This method is used by Hubbell
(2001), and Chisholm and Burgman (2004).
</p>
<p>Setting argument <code>original</code> to <code>TRUE</code> means to follow Preston
(1948) and count any species with an abundance on the boundary between
two adjacent abundance classes as being split 50-50 between the classes.
Thus the fourth class would be
<code class="reqn">\phi_4/2+\phi_5+\phi_6+\phi_7+\phi_8/2</code>
where <code class="reqn">\phi_i</code> is the number of species with abundance
<code class="reqn">i</code> (given by <code>phi(x)</code>).
</p>


<h3>Value</h3>

<p>Function <code>preston()</code> returns an object of class &ldquo;<code>preston</code>&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>F. W. Preston 1948. &ldquo;The Commonness, and Rarity, of Species&rdquo;.
<em>Ecology</em> 29(3):254-283
</p>
</li>
<li>
<p>R. A. Chisholm and M. A. Burgman 2004. &ldquo;The unified neutral
theory of biodiversity and biogeography: comment&rdquo;.  <em>Ecology</em> 85(11):
3172-3174
</p>
</li>
<li>
<p>S. P. Hubbell 2001.  &ldquo;The Unified Neutral Theory of Biodiversity&rdquo;.
Princeton University Press
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+phi">phi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>preston(untb(start=rep(1,100), prob=0.01, gens=1000, keep=FALSE))

data(butterflies)
preston(butterflies)
preston(butterflies,original=TRUE)

data(copepod)
preston(copepod)
plot(preston(copepod))
</code></pre>

<hr>
<h2 id='print.preston'>Print and plot objects of class Preston</h2><span id='topic+print.preston'></span><span id='topic+plot.preston'></span>

<h3>Description</h3>

<p>Print and plot objects of class Preston
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'preston'
print(x, ...)
## S3 method for class 'preston'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.preston_+3A_x">x</code></td>
<td>
<p>Object of class &ldquo;preston&rdquo;</p>
</td></tr>
<tr><td><code id="print.preston_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print()</code> after class
reset</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>Intended to work with the output of function <code>preston()</code>.
</p>
<p>See the vignette for how to annotate a Preston plot.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+preston">preston</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(butterflies)
print(preston(butterflies))
</code></pre>

<hr>
<h2 id='print.summary.count'>Print method for summary objects</h2><span id='topic+print.summary.count'></span><span id='topic+print.summary.census'></span>

<h3>Description</h3>

<p>Print method for summary objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.count'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.count_+3A_x">x</code></td>
<td>
<p>Object of class &ldquo;summary.count&rdquo;</p>
</td></tr>
<tr><td><code id="print.summary.count_+3A_...">...</code></td>
<td>
<p>extra arguments, currently ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(butterflies)
summary(butterflies)
</code></pre>

<hr>
<h2 id='rand.neutral'>Random neutral ecosystem</h2><span id='topic+rand.neutral'></span>

<h3>Description</h3>

<p>Given the size of the metacommunity <code class="reqn">J</code>, and the fundamental
biodiversity number <code class="reqn">\theta</code>, generate an object of class
<code>count</code> using a stochastic mechanism consistent with the
neutral theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand.neutral(J, theta=NULL, prob.of.mutate=NULL, string = NULL, pad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand.neutral_+3A_j">J</code></td>
<td>
<p>Size of metacommunity</p>
</td></tr>
<tr><td><code id="rand.neutral_+3A_theta">theta</code></td>
<td>
<p>Fundamental biodiversity number <code class="reqn">\theta</code>.
User must supply exactly one of <code>theta</code> and
<code>prob.of.mutate</code>.</p>
</td></tr>
<tr><td><code id="rand.neutral_+3A_prob.of.mutate">prob.of.mutate</code></td>
<td>
<p>Probability of mutation <code class="reqn">\nu</code>:
<code class="reqn">\theta=2J\nu</code>.</p>
</td></tr>
<tr><td><code id="rand.neutral_+3A_string">string</code></td>
<td>
<p>String to add to species names.  By default (ie
<code>string</code> being <code>NULL</code>), species are named &ldquo;1&rdquo;,
&ldquo;2&rdquo;,<code class="reqn">\ldots</code>.   Argument <code>string</code> supplies a
prefix for these species names; a good one to use is
&ldquo;<code>spp.</code>&rdquo;.  This argument is useful because printing a
<code>count</code> object can be confusing if the species names are
all integers.</p>
</td></tr>
<tr><td><code id="rand.neutral_+3A_pad">pad</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return a
<code>count</code> object having only extant species, and <code>TRUE</code>
meaning to pad the count with extinct species to <code>J</code> species.
Use this when a vector of length <code>J</code> is required consistently
(see examples section).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the simulation method on page 289 of Hubbell (2001).
</p>


<h3>Note</h3>

<p>If <code>pad</code> is <code>TRUE</code>, and you set <code>string</code> to
&ldquo;<code>extinct</code>&rdquo;, things will break.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>S. P. Hubbell 2001.  &ldquo;The Unified Neutral Theory of Biodiversity&rdquo;.
Princeton University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+untb">untb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rand.neutral(1000, 9)
rand.neutral(1000, 9, string="spp.")

data(butterflies)
rand.neutral(no.of.ind(butterflies), optimal.theta(butterflies),string="spp.")


# what is the distribution of abundance of the second ranked species if
# J=10, theta=0.7?
plot(table(replicate(100,rand.neutral(10,theta=0.7,pad=TRUE)[2])))

</code></pre>

<hr>
<h2 id='sahfos'>Biodiversity dataset provided by SAHFOS</h2><span id='topic+sahfos'></span>

<h3>Description</h3>

<p>Species counts in the North Atlantic</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sahfos)</code></pre>


<h3>References</h3>

<p>Warner AJ and Hays GC 1994.  &ldquo;Sampling by the Continuous
Plankton Recorder Survey&rdquo;. <em>Progress in Oceanography</em>, 34:
237-256
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sahfos)
preston(sahfos)
</code></pre>

<hr>
<h2 id='saunders'>Dataset due to Saunders</h2><span id='topic+saunders'></span><span id='topic+saunders.tot'></span><span id='topic+saunders.exposed'></span><span id='topic+saunders.exposed.tot'></span><span id='topic+saunders.sheltered'></span><span id='topic+saunders.sheltered.tot'></span>

<h3>Description</h3>

<p>A dataframe showing species inventories for a kelp holdfast
(<code>saunders</code>) including a Boolean flag indicating whether the
holdfast was in a sheltered or exposed location.
</p>
<p>Also two data frames, one for the 20 exposed holdfasts
(<code>saunders.exposed</code>) and one for the 20 sheltered holdfasts
(<code>saunders.sheltered</code>).
</p>
<p>Also three <code>count</code> objects, giving counts for all organisms
(<code>saunders.tot</code>), all those from exposed locations
(<code>saunders.exposed.tot</code>), and all those from sheltered locations
only (<code>saunders.sheltered.tot</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(saunders)</code></pre>


<h3>Format</h3>

<p>Dataset <code>saunders</code> is a dataframe with 40 observations on 177
variables.  Each row corresponds to a holdfast.  The first column is
Boolean, indicating whether or not that holdfast was exposed
(<code>TRUE</code>) or sheltered (<code>FALSE</code>).  The other columns show
species abundances for each of 176 species.
</p>
<p>Summary datasets <code>saunders.sheltered.tot</code>,
<code>saunders.exposed.tot</code>, and <code>saunders.tot</code> are objects of
class <code>count</code> that are the species abundance for sheltered
holdfasts, exposed holdfasts, and the entire dataset.
</p>
<p>The user will probably be most interested in <code>saunders.sheltered</code>
and <code>saunders.exposed</code>, which are the <strong>transpose</strong> of the
appropriate rows of <code>saunders</code>.  Thus these dataframes have 176
rows, one per species and 20 rows, one per holdfast.
</p>


<h3>Details</h3>

<p>Kelp are large seaweeds classified in kingdom Chromista.  Kelp grows
in shallow oceans in kelp forests.
</p>
<p>The <dfn>holdfast</dfn> is a root-like structure that anchors the kelp to
the ocean floor.  Fauna inhabiting kelp holdfasts, being
&ldquo;incredibly diverse&rdquo; (Anderson et al 2005), are often used as
indicators of environmental change.
</p>
<p>The data was collected in New Zealand, from eight sites along the
Leigh coastline from north of Leigh Harbour down to the southern end
of Kawau Island (a stretch of roughly 20 km).  Four sites were
wave-exposed, four were sheltered (although two of the latter were
arguably quite tidally-dominated).  Each site had a spatial extent of
roughly one hectare.  They were collected from 5 - 10 November, 2003.
</p>
<p>The <code>saunders</code> dataset must be arranged as it is because if it
were transposed, the first row would be the (nonsensical) observation
<code>c(T,T,...,T,F,...,F)</code>.   
</p>


<h3>Note</h3>

<p>It is not entirely obvious how to derive the summary datasets from the
<code>saunders</code> dataframe.  Use function <code>extractor()</code> for this.
</p>


<h3>Source</h3>

<p>Data supplied by Justine Saunders
</p>


<h3>References</h3>


<ul>
<li><p> J. Saunders 2007.  &ldquo;Biodiversity of kelp holdfasts&rdquo;
(provisional title).  PhD thesis (in preparation); School of Geography
and Environmental Sciences, The University of Auckland
</p>
</li>
<li><p> M. J. Anderson and others 2005.  &ldquo;Consistency and
variation in kelp holdfast assemblages: Spatial patterns of
biodiversity for the major phyla at different taxonomic resolutions&rdquo;.
<em>Journal of Experimental Marine Biology and Ecology</em>. Volume 320, pages
35-56
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+extractor">extractor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("saunders")

jj &lt;- t(saunders)[-1,]
jj.exposed &lt;- saunders[,1]
"saunders.tot" &lt;- count(apply(jj,1,sum))
"saunders.exposed"   &lt;- jj[, jj.exposed]
"saunders.sheltered" &lt;- jj[,!jj.exposed]
"saunders.exposed.tot"   &lt;- count(apply(saunders.exposed,1,sum))
"saunders.sheltered.tot" &lt;- count(apply(saunders.sheltered,1,sum))


plot(saunders.sheltered.tot, uncertainty=TRUE, n=1)
preston(saunders.tot)
optimal.params.sloss(saunders.exposed)

</code></pre>

<hr>
<h2 id='simpson'>Simpson's diversity index</h2><span id='topic+simpson'></span>

<h3>Description</h3>

<p>Simpson's diversity index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpson(x, with.replacement=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpson_+3A_x">x</code></td>
<td>
<p>Ecosystem vector; coerced to class <code>count</code></p>
</td></tr>
<tr><td><code id="simpson_+3A_with.replacement">with.replacement</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
sample without replacement; see details section</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the Simpson index <code class="reqn">D</code>: the
probability that two randomly sampled individuals belong to
different species.
</p>
<p>There is some confusion as to the precise definition: some authors
specify that the two individuals are necessarily distinct (ie sampling
without replacement), and some do not.
</p>
<p>Simpson (1949) assumed sampling without replacement and gave
</p>
<p style="text-align: center;"><code class="reqn"> 1-\frac{\sum_{i=1}^Sn_i\left(n_i-1\right)}{J(J-1)} </code>
</p>

<p>in our notation.
</p>
<p>He and Hu (2005) assumed sampling with replacement:
</p>
<p style="text-align: center;"><code class="reqn"> 1-\frac{\sum_{i=1}^Sn_i^2}{J^2}. </code>
</p>

<p>The difference is largely academic but is most pronounced when many
species occur with low counts (ie close to 1).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> S. P. Hubbell 2001.
&ldquo;The Unified Neutral Theory of Biodiversity&rdquo;.
Princeton University Press.
</p>
</li>
<li><p> F. He and X.-S. Hu 2005.
&ldquo;Hubbell's Fundamental Biodiversity
Parameter and the Simpson Diversity Index&rdquo;.  <em>Ecology Letters</em>, volume 8,
pp386-390. doi: <code>10.1111/j.1461-0248.2005.00729.x</code>
</p>
</li>
<li><p> E. H. Simpson 1949. &ldquo;Measurement of diversity&rdquo;,
<em>Nature</em>, volume 163, p688
</p>
</li></ul>
  


<h3>See Also</h3>

<p><code><a href="#topic+preston">preston</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(butterflies)

D &lt;- simpson(butterflies)
theta &lt;- optimal.prob(butterflies)*2*no.of.ind(butterflies)

# compare theta with D/(1-D) (should be roughly equal; see He &amp; Hu 2005):
theta
D/(1-D)


# Second argument pedantic in practice.

# Mostly, the difference is small:
simpson(butterflies,FALSE) - simpson(butterflies,TRUE)

# Most extreme example:
x &lt;- count(c(1,1))
simpson(x,TRUE)
simpson(x,FALSE)


</code></pre>

<hr>
<h2 id='species.count'>Ecosystem diagnostics for output of untb()</h2><span id='topic+species.count'></span><span id='topic+species.table'></span>

<h3>Description</h3>

<p>Provides ecosystem diagnostics of species count datasets (species
counts and species tables), useful for the output of <code>untb()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species.count(x)
species.table(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species.count_+3A_x">x</code></td>
<td>
<p>An integer matrix whose rows are integers
representing the individuals' species</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions takes a matrix argument, which is interpreted as the
output of <code>untb(...,keep=TRUE)</code>.
</p>
<p>Function <code>species.count()</code> returns the total number of species
present in each row (ie at each timestep).
</p>
<p>Function <code>species.table()</code> returns a matrix <code class="reqn">M</code> where
<code>M[i,j]</code>   column of the matrix is the abundance of species <code class="reqn">j</code> 
at time <code>i</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+preston">preston</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- untb(start=rep(1,50), prob=0.01, gens=2000, keep=TRUE)

plot(species.count(a),type="b")
matplot(species.table(a),type="l",lty=1)

jj &lt;- a[2000,]
print(jj)
as.count(jj)

</code></pre>

<hr>
<h2 id='spitale'>Counts of diatom species in springs of the Adamello-Brenta Nature Park</h2><span id='topic+spitale'></span>

<h3>Description</h3>

<p>A dataset due to Spitale and Cantonati comprising abundances of
different species of diatoms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spitale)</code></pre>


<h3>Format</h3>

<p>A count object
</p>


<h3>Source</h3>

<p>Data kindly provided by Daniel Spitale
</p>


<h3>References</h3>

<p>D. Spitale and M. Cantonati 2011.  &ldquo;Understanding the natural
variability of diatom assemblages in springs of the Adamello-Brenta
Nature Park (south-eastern Alps) on a temporal scale&rdquo;.
<em>Fundamental Applied Limnology</em> volume 179/2, pp137&ndash;149
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spitale)
summary(spitale)
</code></pre>

<hr>
<h2 id='summary.count'>Summary methods for count and census objects</h2><span id='topic+summary.count'></span><span id='topic+summary.census'></span>

<h3>Description</h3>

<p>Summary methods for count and census objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'count'
summary(object, ...)
## S3 method for class 'census'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.count_+3A_object">object</code></td>
<td>
<p>Ecosystem object coerced to class count</p>
</td></tr>
<tr><td><code id="summary.count_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a summary of an ecosystem object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+phi">phi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ostracod)
summary(ostracod)
</code></pre>

<hr>
<h2 id='theta.prob'>Posterior probabilities for theta</h2><span id='topic+theta.prob'></span><span id='topic+theta.likelihood'></span>

<h3>Description</h3>

<p>Determines the posterior probability and likelihood for theta,
given a count object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.prob(theta, x=NULL, give.log=TRUE)
theta.likelihood(theta, x=NULL, S=NULL, J=NULL, give.log=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta.prob_+3A_theta">theta</code></td>
<td>
<p>biodiversity parameter</p>
</td></tr>
<tr><td><code id="theta.prob_+3A_x">x</code></td>
<td>
<p>object of class count or census</p>
</td></tr>
<tr><td><code id="theta.prob_+3A_give.log">give.log</code></td>
<td>
<p>Boolean, with <code>FALSE</code> meaning to return
the  value, and default <code>TRUE</code> meaning to return
the (natural) logarithm of the value</p>
</td></tr>
<tr><td><code id="theta.prob_+3A_s">S</code>, <code id="theta.prob_+3A_j">J</code></td>
<td>
<p>In function <code>theta.likelihood()</code>, the number of
individuals (<code>J</code>) and number of species (<code>S</code>) in
the ecosystem, if <code>x</code> is not
supplied.  These arguments are provided so that <code>x</code> need
not be specified if <code>S</code> and <code>J</code> are known.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula was originally given by Ewens (1972) and is shown on
page 122 of Hubbell (2001):
</p>
<p style="text-align: center;"><code class="reqn">\frac{J!\theta^S}{
      1^{\phi_1}2^{\phi_2}\ldots J^{\phi_J}
      \phi_1!\phi_2!\ldots \phi_J!
      \prod_{k=1}^J\left(\theta+k-1\right)}.</code>
</p>

<p>The likelihood is thus given by
</p>
<p style="text-align: center;"><code class="reqn">\frac{\theta^S}{\prod_{k=1}^J\left(\theta+k-1\right)}.</code>
</p>

<p>Etienne observes that the denominator is equivalent to a Pochhammer
symbol <code class="reqn">(\theta)_J</code>, so is thus readily evaluated as
<code class="reqn">\Gamma(\theta+J)/\Gamma(\theta)</code>
(Abramowitz and Stegun 1965, equation 6.1.22). 
</p>


<h3>Note</h3>

<p>If estimating <code>theta</code>, use <code>theta.likelihood()</code> rather than
<code>theta.probability()</code> because the former function generally
executes <strong>much</strong> faster: the latter calculates a factor that is
independent of <code>theta</code>.
</p>
<p>The likelihood function <code class="reqn">L(\theta)</code> is any function of
<code class="reqn">\theta</code> proportional, for fixed observation <code class="reqn">z</code>, to
the probability density <code class="reqn">f(z,\theta)</code>.  There is thus
a slight notational inaccuracy in speaking of &ldquo;the&rdquo; likelihood
function which is defined only up to a multiplicative constant.  Note
also that the &ldquo;support&rdquo; function is usually defined as a
likelihood function with maximum value <code class="reqn">1</code> (at the maximum
likelihood estimator for <code class="reqn">\theta</code>).  This is not easy to
determine analytically for <code class="reqn">J&gt;5</code>.
</p>
<p>Note that <code class="reqn">S</code> is a sufficient statistic for <code class="reqn">\theta</code>.
</p>
<p>Function <code>theta.prob()</code> does <strong>not</strong> give a PDF for
<code class="reqn">\theta</code> (so, for example, integrating over the real line
does not give unity).  The PDF is over partitions of <code class="reqn">J</code>; an
example is given below.
</p>
<p>Function <code>theta.prob()</code> requires a count object (as opposed to
<code>theta.likelihood()</code>, for which  <code class="reqn">J</code> and <code class="reqn">S</code> are
sufficient) because it needs to call <code>phi()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> S. P. Hubbell 2001.
&ldquo;The Unified Neutral Theory of Biodiversity&rdquo;,
Princeton University Press.
</p>
</li>
<li><p> W. J. Ewens 1972.  &ldquo;The sampling theory of selectively
neutral alleles&rdquo;, <em>Theoretical Population Biology</em>, <b>3</b>:87&ndash;112
</p>
</li>
<li><p> M. Abramowitz and I. A. Stegun 1965.
<em>Handbook of Mathematical Functions</em>, New York: Dover
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+phi">phi</a></code>, <code><a href="#topic+optimal.prob">optimal.prob</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
theta.prob(1,rand.neutral(15,theta=2))

gg &lt;- as.count(c(rep("a",10),rep("b",3),letters[5:9]))
theta.likelihood(theta=2,gg)

optimize(f=theta.likelihood,interval=c(0,100),maximum=TRUE,x=gg)


## An example showing that theta.prob() is indeed a PMF:

a &lt;- count(c(dogs=3,pigs=3,hogs=2,crabs=1,bugs=1,bats=1))
x &lt;- partitions::parts(no.of.ind(a))
f &lt;- function(x){theta.prob(theta=1.123,extant(count(x)),give.log=FALSE)}
sum(apply(x,2,f))  ## should be one exactly.
</code></pre>

<hr>
<h2 id='untb'>Ecological drift simulation under the Unified Neutral
Theory of Biodiversity</h2><span id='topic+untb'></span><span id='topic+select'></span><span id='topic+select.immigrate'></span><span id='topic+select.mutate'></span>

<h3>Description</h3>

<p>Simulates ecological drift under the UNTB.  Function <code>untb()</code>
carries out the simulation; function <code>select()</code>
carries out a single generational step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untb(start, prob=0, D=1, gens=150, keep=FALSE, meta=NULL)
select(a, D=length(a), prob=0, meta=NULL)
select.mutate(a, D=length(a), prob.of.mutate=0)
select.immigrate(a, D=length(a), prob.of.immigrate=0, meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untb_+3A_a">a</code>, <code id="untb_+3A_start">start</code></td>
<td>
<p>Starting ecosystem; coerced to class census.  Usually,
pass an object of class count; see examples.  To start
with a monoculture of size 10, use <code>start=rep(1,10)</code> and to
use <code>start=1:10</code>.</p>
</td></tr>
<tr><td><code id="untb_+3A_prob">prob</code>, <code id="untb_+3A_prob.of.immigrate">prob.of.immigrate</code>, <code id="untb_+3A_prob.of.mutate">prob.of.mutate</code></td>
<td>
<p>Probability of
&ldquo;new&rdquo; organism not being a descendent of an existing
individual</p>
</td></tr>
<tr><td><code id="untb_+3A_d">D</code></td>
<td>
<p>Number of organisms that die in each timestep</p>
</td></tr>
<tr><td><code id="untb_+3A_gens">gens</code></td>
<td>
<p>Number of generations to simulate</p>
</td></tr>
<tr><td><code id="untb_+3A_keep">keep</code></td>
<td>
<p>In function <code>untb()</code> Boolean with default
<code>FALSE</code> meaning to return the system at the end of the
simulation and <code>TRUE</code> meaning to return a matrix whose rows are
the ecosystem at successive times</p>
</td></tr>
<tr><td><code id="untb_+3A_meta">meta</code></td>
<td>
<p>In function <code>untb()</code>, the metacommunity; coerced to a
<code>count</code> object.  Default of <code>NULL</code> means to use a
&ldquo;greedy&rdquo; system in which every mutation gives rise to a new,
previously unencountered species.  This would correspond to an
infinitely large, infinitely diverse, Hubbellian ecosystem (which is
not too ridiculous an assumption for a small island near a large
diverse mainland).
</p>
<p>In function <code>select.immigrate()</code>, a simplified representation
of a metacommunity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>select.immigrate()</code> and <code>select.mutate()</code> are not
really intended for the end user; they use computationally efficient
(and opaque) integer arithmetic.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>S. P. Hubbell 2001.  &ldquo;The Unified Neutral Theory of Biodiversity&rdquo;.
Princeton University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(butterflies)
untb(start=butterflies, prob=0, gens=100)

a &lt;- untb(start=1:10,prob=0.005, gens=1000,keep=TRUE)
plot(species.count(a),type="b")
matplot(species.table(a),type="l",lty=1)

</code></pre>

<hr>
<h2 id='untb-package'>
Unified neutral theory of biodiversity
</h2><span id='topic+untb-package'></span>

<h3>Description</h3>

<p>Numerical simulations, and visualizations, of the unified
neutral theory of biodiversity
</p>


<h3>Details</h3>

<p>Package <code>untb</code> uses two classes of object to represent an
ecosystem: class <code>count</code> and class <code>census</code>.  In essence, a
<code>count</code> object is a table of species abundances and a <code>census</code>
object is a list of individuals.  See <code>?census</code> and <code>?count</code>
for more details.  Although objects of either class can be coerced to
the other, class <code>count</code> is the preferred form: it is a more
compact representation, especially for large ecosystems.
</p>
<p>The package simulates neutral ecological drift using function
<code>untb()</code>.  Function <code>display.untb()</code> displays a semi-animated
graphic of an ecosystem undergoing neutral drift.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>
<p>Maintainer: &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> S. P. Hubbell 2001.  &ldquo;The Unified Neutral Theory of
Biodiversity&rdquo;.   Princeton University Press.
</p>
</li>
<li><p> R. K. S. Hankin 2007.  <em>Introducing <b>untb</b>, an R
package for simulating ecological drift under the unified neutral
theory of biodiversity</em>.  Journal of Statistical Software, volume
22, issue 12
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- untb(start=rep(1,100),prob=0.005,gens=5000,keep=FALSE)
preston(a)
no.of.spp(a)

display.untb(start=rep(1,100),prob=0.1,gens=1000)

data(butterflies)
plot(butterflies,uncertainty=TRUE)

</code></pre>

<hr>
<h2 id='vallade'>Various functions from Vallade and Houchmandzadeh</h2><span id='topic+vallade'></span><span id='topic+Vallade'></span><span id='topic+vallade.eqn5'></span><span id='topic+vallade.eqn7'></span><span id='topic+vallade.eqn12'></span><span id='topic+vallade.eqn14'></span><span id='topic+vallade.eqn16'></span><span id='topic+vallade.eqn17'></span>

<h3>Description</h3>

<p>Various functions from Vallade and Houchmandzadeh (2003), dealing with
analytical solutions of a neutral model of biodiversity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vallade.eqn5(JM, theta, k)
vallade.eqn7(JM, theta)
vallade.eqn12(J, omega, m, n)
vallade.eqn14(J, theta, m, n)
vallade.eqn16(J, theta, mu)
vallade.eqn17(mu, theta, omega, give=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vallade_+3A_j">J</code>, <code id="vallade_+3A_jm">JM</code></td>
<td>
<p>Size of the community and metacommunity respectively</p>
</td></tr>
<tr><td><code id="vallade_+3A_theta">theta</code></td>
<td>
<p>Biodiversity number
<code class="reqn">\theta=(J_M-1)\nu/(1-\nu)</code> as discussed
in equation 6</p>
</td></tr>
<tr><td><code id="vallade_+3A_k">k</code>, <code id="vallade_+3A_n">n</code></td>
<td>
<p>Abundance</p>
</td></tr>
<tr><td><code id="vallade_+3A_omega">omega</code></td>
<td>
<p>Relative abundance <code class="reqn">\omega=k/J_M</code></p>
</td></tr>
<tr><td><code id="vallade_+3A_m">m</code></td>
<td>
<p>Immigration probability</p>
</td></tr>
<tr><td><code id="vallade_+3A_mu">mu</code></td>
<td>
<p>Scaled immigration probability
<code class="reqn">\mu=(J-1)m/(1-m)</code></p>
</td></tr>
<tr><td><code id="vallade_+3A_give">give</code></td>
<td>
<p>In function <code>vallade.eqn17()</code>, Boolean with default
<code>FALSE</code> meaning to return the numerical value of the integral
and <code>TRUE</code> meaning to return the entire output of
<code>integrate()</code> including the error estimates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notation follows Vallade and Houchmandzadeh (2003) exactly. 
</p>


<h3>Note</h3>

<p>Function <code>vallade.eqn16()</code> requires the <code>polynom</code> library,
which is not loaded by default.  It will not run for <code class="reqn">J&gt;50</code> due to
some stack overflow error.
</p>
<p>Function <code>vallade.eqn5()</code> is identical to function
<code>alonso.eqn6()</code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Vallade and B. Houchmandzadeh 2003. &ldquo;Analytical Solution of a
Neutral Model of Biodiversity&rdquo;, <em>Physical Review E</em>, volume 68.
doi: 10.1103/PhysRevE.68.061902
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A nice check:
JM &lt;- 100
k &lt;- 1:JM
sum(k*vallade.eqn5(JM,theta=5,k))  # should be JM=100 exactly.



# Now, a replication of Figure 3:
  omega &lt;- seq(from=0.01, to=0.99,len=100)
  f &lt;- function(omega,mu){
    vallade.eqn17(mu,theta=5, omega=omega)
  }
  plot(omega,
  omega*5,type="n",xlim=c(0,1),ylim=c(0,5),
        xlab=expression(omega),
        ylab=expression(omega*g[C](omega)),
        main="Figure 3 of Vallade and Houchmandzadeh")
  points(omega,omega*sapply(omega,f,mu=0.5),type="l")
  points(omega,omega*sapply(omega,f,mu=1),type="l")
  points(omega,omega*sapply(omega,f,mu=2),type="l")
  points(omega,omega*sapply(omega,f,mu=4),type="l")
  points(omega,omega*sapply(omega,f,mu=8),type="l")
  points(omega,omega*sapply(omega,f,mu=16),type="l")
  points(omega,omega*sapply(omega,f,mu=Inf),type="l")




# Now a discrete version of Figure 3 using equation 14:
J &lt;- 100
omega &lt;- (1:J)/J

f &lt;- function(n,mu){
   m &lt;- mu/(J-1+mu)
   vallade.eqn14(J=J, theta=5, m=m, n=n)
 }
plot(omega,omega*0.03,type="n",main="Discrete version of Figure 3 using
   eqn 14")
points(omega,omega*sapply(1:J,f,mu=16))
points(omega,omega*sapply(1:J,f,mu=8))
points(omega,omega*sapply(1:J,f,mu=4))
points(omega,omega*sapply(1:J,f,mu=2))
points(omega,omega*sapply(1:J,f,mu=1))
points(omega,omega*sapply(1:J,f,mu=0.5))

</code></pre>

<hr>
<h2 id='volkov'>Expected frequency of species</h2><span id='topic+volkov'></span>

<h3>Description</h3>

<p>Given a community size, biodiversity parameter <code class="reqn">\theta</code>,
and an immigration rate <code class="reqn">m</code>, returns the expected frequency of
species with <code class="reqn">n</code>  individuals, for <code class="reqn">0&lt;n\leq J</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volkov(J, params, bins = FALSE, give = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volkov_+3A_j">J</code></td>
<td>
<p>Size of community</p>
</td></tr>
<tr><td><code id="volkov_+3A_params">params</code></td>
<td>
<p>A two-element vector with first element interpreted as
theta, the Fundamental biodiversity parameter and the second, m,
interpreted as the probability of immigration.  This argument will
accept the output of <code>optimal.params()</code></p>
</td></tr>
<tr><td><code id="volkov_+3A_bins">bins</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return the
expected number of species with <code class="reqn">1,2,\ldots,J</code>
individuals, and <code>FALSE</code> meaning to return the binned total,
using a Preston-like binning system as used in <code>preston()</code></p>
</td></tr>
<tr><td><code id="volkov_+3A_give">give</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <em>all</em> the
output of <code>integrate()</code>, and default <code>FALSE</code> meaning to
return just the value of the integral</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class &ldquo;phi&rdquo;.
</p>


<h3>Note</h3>

<p>The method used is slightly inefficient: the terms to the left of the
integral sign [in Volkov's equation 7] are integrated and this is,
strictly, unnecessary as it is not a function of <code class="reqn">y</code>.  However,
taking advantage of this fact results in messy code.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>I. Volkov and others 2003. &ldquo;Neutral theory and relative species
abundance in ecology&rdquo;.  <em>Nature</em>, volume 424, number 28.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phi">phi</a></code>,<code><a href="#topic+preston">preston</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  volkov(J=21457,c(theta=47.226, m=0.1)) # Example in figure 1

## End(Not run) 

volkov(J=20,params=c(theta=1,m=0.4))

 data(butterflies)
 r &lt;- plot(preston(butterflies,n=9,orig=TRUE))

 ## Not run:   jj &lt;- optimal.params(butterflies)    # needs PARI/GP

 jj &lt;- c(9.99980936124759, 0.991791987473506)

 points(r,volkov(no.of.ind(butterflies), jj, bins=TRUE),type="b")
 
</code></pre>

<hr>
<h2 id='zsm'>Zero sum multinomial distribution as derived by McKane</h2><span id='topic+zsm'></span>

<h3>Description</h3>

<p>The Zero sum multinomial distribution of species abundances as derived
by McKane 2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsm(J, P, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zsm_+3A_j">J</code></td>
<td>
<p>Size of local community</p>
</td></tr>
<tr><td><code id="zsm_+3A_p">P</code></td>
<td>
<p>Abundance in metacommunity</p>
</td></tr>
<tr><td><code id="zsm_+3A_m">m</code></td>
<td>
<p>Probability of immigration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of size <code>J</code> showing the probability of the
stationary abundance being <code class="reqn">1,\ldots,J</code>.
</p>


<h3>Note</h3>

<p>The function uses <code>lgamma()</code> to avoid numerical overflow
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>A. J. McKane and others 2004. &ldquo;Analytic solution of
Hubbell's model of local community dynamics&rdquo;.  <em>Theoretical Population
Biology</em> 65:67-73</p>


<h3>Examples</h3>

<pre><code class='language-R'> sum(zsm(164,0.1,0.5))  # should be 1



# McKane et al 2004: figure 1.
layout(matrix(1:4,2,2))
par(mai=0.2+rep(0,4))
plot(1,type="n",log="y",ylim=c(1e-9,1),xlim=c(0,64),xlab="",ylab="Ps(N)",
     axes=FALSE,main=expression(J==64))
axis(1,pos=1e-9)
axis(2,pos=0,at=10^(-(0:9)))
segments(64,1e-9,64,1)
segments(60,1e-9,64,1e-9)
f &lt;- function(P){points(0:64,zsm(64,P=P,m=0.05),type="l")}
for(i in 1:9){f(i/10)}
f(0.99)
f(0.999)
f(0.01)
f(0.001)
text(07,3.2e-7,adj=0,expression(P==0.999))
text(49,3.2e-7,adj=0,expression(P==0.001))
text(45,0.1,expression(m==0.05))


plot(1,type="n",log="y",ylim=c(1e-5,1),xlim=c(0,64),xlab="",ylab="Ps(N)",
     axes=FALSE,main="")
axis(1,pos=1e-5)
axis(2,pos=0,at=10^-(0:5))
segments(60,1e-5,64,1e-5)
segments(64,1e-5,64,1)
par(xpd=FALSE)
g &lt;- function(m){points(0:64,pmax(zsm(64,P=0.1,m=m),1e-5),type="l")}
g(0.0001)
g(0.0005)
g(0.002)
g(0.01)
g(0.02)
g(0.05)
g(0.5)
g(0.999)
text(50,0.4,expression(P==0.1))

plot(1,type="n",log="y",ylim=c(1e-9,1),xlim=c(0,1e5),xlab="",ylab="Ps(N)",
     axes=FALSE,main=expression(J==10000))
axis(1,pos=1e-9)
axis(2,pos=0)
segments(1e5,1e-9,1e5,0.1)


h &lt;- function(P){points(0:1e5,pmax(zsm(1e5,P=P,m=0.05),1e-9),type="l")}
for(i in 1:9){h(i/10)}
h(0.01)
h(0.99)
text(75000,0.1,expression(m==0.5))

plot(1,type="n",log="y",ylim=c(1e-40,1),xlim=c(0,1e5),xlab="",ylab="Ps(N)",
     axes=FALSE,main="")
axis(1,pos=1e-40)
axis(2,pos=0,at=1/10^c(40,32,24,16,8,0))
segments(1e5,1e-40,1e5,1)

i &lt;- function(m){points(0:1e5,pmax(zsm(1e5,P=0.1,m=m),1e-40),type="l")}
i(0.0001)
i(0.0002)
i(0.0005)
i(0.001)
i(0.002)
i(0.005)
i(0.01)
i(0.02)
i(0.5)
text(60000,1e-4,expression(P==0.1))




</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
