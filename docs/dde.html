<!DOCTYPE html><html><head><title>Help for package dde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#difeq'><p>Solve difference equation</p></a></li>
<li><a href='#difeq_replicate'><p>Solve difference equations repeatedly</p></a></li>
<li><a href='#dopri'><p>Integrate ODE/DDE with dopri</p></a></li>
<li><a href='#dopri_interpolate'><p>Interpolate Dormand-Prince output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Solve Delay Differential Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Solves ordinary and delay differential equations, where
    the objective function is written in either R or C.  Suitable only
    for non-stiff equations, the solver uses a 'Dormand-Prince' method
    that allows interpolation of the solution at any point.  This
    approach is as described by Hairer, Norsett and Wanner (1993)
    &lt;ISBN:3540604529&gt;.  Support is also included for iterating
    difference equations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mrc-ide/dde">https://github.com/mrc-ide/dde</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mrc-ide/dde/issues">https://github.com/mrc-ide/dde/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>ring (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>deSolve, knitr, microbenchmark, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-13 08:16:09 UTC; rfitzjoh</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre],
  Wes Hinsley [aut],
  Imperial College of Science, Technology and Medicine [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-13 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='difeq'>Solve difference equation</h2><span id='topic+difeq'></span><span id='topic+difeq_continue'></span><span id='topic+yprev'></span>

<h3>Description</h3>

<p>Solve a difference (or recurrence) equation by iterating it a
number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difeq(y, steps, target, parms, ..., n_out = 0L, n_history = 0L,
  grow_history = FALSE, return_history = n_history &gt; 0, dllname = "",
  parms_are_real = TRUE, ynames = names(y), outnames = NULL,
  return_by_column = TRUE, return_initial = TRUE, return_step = TRUE,
  return_output_with_y = TRUE, restartable = FALSE,
  return_minimal = FALSE)

difeq_continue(obj, steps, y = NULL, ..., copy = FALSE, parms = NULL,
  return_history = NULL, return_by_column = NULL, return_initial = NULL,
  return_step = NULL, return_output_with_y = NULL, restartable = NULL)

yprev(step, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difeq_+3A_y">y</code></td>
<td>
<p>The initial state of the system.  Must be a numeric
vector (and will be passed through <code>as.numeric</code> by this
function).</p>
</td></tr>
<tr><td><code id="difeq_+3A_steps">steps</code></td>
<td>
<p>A vector of steps to return the system at.  The
<em>first</em> step is taken as step zero, and the solution will
be recorded at every other step in the vector.  So to step a
system from time zero to times 1, 2, 3, ..., n use 0:n.  Must be
integer values and will be passed through <code>as.integer</code>
(which may truncate or otherwise butcher non-integer values).</p>
</td></tr>
<tr><td><code id="difeq_+3A_target">target</code></td>
<td>
<p>The target function to advance.  This can either be
an R function taking arguments <code>n, i, t, y, parms</code> or be a
scalar character with the name of a compiled function with
arguments <code>size_t n, size_t step, double time, const double
*y, double *dydt, size_t n_out, double *output void *data</code>.</p>
</td></tr>
<tr><td><code id="difeq_+3A_parms">parms</code></td>
<td>
<p>Parameters to pass through to the difference function</p>
</td></tr>
<tr><td><code id="difeq_+3A_...">...</code></td>
<td>
<p>Dummy arguments - nothing is allowed here, but this
means that all further arguments <em>must</em> be specified by
name (not order) so I can easily reorder them later on.</p>
</td></tr>
<tr><td><code id="difeq_+3A_n_out">n_out</code></td>
<td>
<p>The number of output variables (in addition to the
difference equation variables).  If given, then an R function
must return an <em>attribute</em> <code>output</code> with the output
variables.</p>
</td></tr>
<tr><td><code id="difeq_+3A_n_history">n_history</code></td>
<td>
<p>The number of iterations of history to save
during the simulation.  By default, no history is saved.</p>
</td></tr>
<tr><td><code id="difeq_+3A_grow_history">grow_history</code></td>
<td>
<p>Logical indicating if history should be grown
during the simulation.  If <code>FALSE</code> (the default) then when
history is used it is overwritten as needed (so only the most
recent <code>n_history</code> elements are saved.  This may require
some tuning so that you have enough history to run your
simulation (i.e. to the longest delay) or an error will be
thrown when it underflows.  The required history length will
vary with your delay sizes and with the timestep for dopri.  If
<code>TRUE</code>, then history will grow as the buffer is exhausted.
The growth is geometric, so every time it reaches the end of the
buffer it will increase by a factor of about 1.6 (see the
<code>ring</code> documentation).  This may consume more memory than
necessary, but may be useful where you don't want to care about
picking the history length carefully.</p>
</td></tr>
<tr><td><code id="difeq_+3A_return_history">return_history</code></td>
<td>
<p>Logical indicating if history is to be
returned.  By default, history is returned if <code>n_history</code>
is nonzero.</p>
</td></tr>
<tr><td><code id="difeq_+3A_dllname">dllname</code></td>
<td>
<p>Name of the shared library (without extension) to
find the function <code>func</code> in the case where <code>func</code>
refers to compiled function.</p>
</td></tr>
<tr><td><code id="difeq_+3A_parms_are_real">parms_are_real</code></td>
<td>
<p>Logical, indicating if <code>parms</code> should
be treated as vector of doubles by <code>func</code> (when it is a
compiled function).  If <code>TRUE</code> (the default), then
<code>REAL(parms)</code>, which is <code>double*</code> is passed through.
If <code>FALSE</code> then if <code>params</code> is an externalptr type
(<code>EXTPTRSXP</code>) we pass through the result of
<code>R_ExternalPtrAddr</code>, otherwise we pass <code>params</code>
through unmodified as a <code>SEXP</code>.  In the last case, in your
target function you will need to include <code>&lt;Rinternals.h&gt;</code>,
cast to <code>SEXP</code> and then pull it apart using the R API (or
Rcpp).</p>
</td></tr>
<tr><td><code id="difeq_+3A_ynames">ynames</code></td>
<td>
<p>Logical, indicating if the output should be named
following the names of the input vector <code>y</code>.
Alternatively, if <code>ynames</code> is a character vector of the
same length as <code>y</code>, these will be used as the output names.</p>
</td></tr>
<tr><td><code id="difeq_+3A_outnames">outnames</code></td>
<td>
<p>An optional character vector, used when
<code>n_out</code> is greater than 0, to name the model output matrix.</p>
</td></tr>
<tr><td><code id="difeq_+3A_return_by_column">return_by_column</code></td>
<td>
<p>Logical, indicating if the output should be
returned organised by column (rather than row).  This incurs a
slight cost for transposing the matrices.  If you can work with
matrices that are transposed relative to <code>deSolve</code>, then
set this to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="difeq_+3A_return_initial">return_initial</code></td>
<td>
<p>Logical, indicating if the output should
include the initial conditions.  Specifying <code>FALSE</code> avoids
binding this onto the output.</p>
</td></tr>
<tr><td><code id="difeq_+3A_return_step">return_step</code></td>
<td>
<p>Logical, indicating if a row (or column if
<code>return_by_column</code> is <code>TRUE</code>) representing step is included.</p>
</td></tr>
<tr><td><code id="difeq_+3A_return_output_with_y">return_output_with_y</code></td>
<td>
<p>Logical, indicating if the output
should be bound together with the returned matrix <code>y</code> (as
it is with <code>deSolve</code>).  If <code>FALSE</code>, then output will
be returned as the attribute <code>output</code>.</p>
</td></tr>
<tr><td><code id="difeq_+3A_restartable">restartable</code></td>
<td>
<p>Logical, indicating if the problem should be
restartable.  If <code>TRUE</code>, then the return value of a
simulation can be passed to <code>difeq_restart</code> to continue the
simulation after arbitrary changes to the state or the
parameters.  Note that this is really only useful for delay
difference equations where you want to keep the history but make
changes to the parameters or to the state vector while keeping
the history of the problem so far.</p>
</td></tr>
<tr><td><code id="difeq_+3A_return_minimal">return_minimal</code></td>
<td>
<p>Shorthand option - if set to <code>TRUE</code>
then it sets all of <code>return_by_column</code>,
<code>return_initial</code>, <code>return_time</code>,
<code>return_output_with_y</code> to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="difeq_+3A_obj">obj</code></td>
<td>
<p>An object to continue from; this must be the results of
running a simulation with the option <code>restartable =
TRUE</code>.  Note that continuing a problem moves the pointer along
in time (unless <code>copy = TRUE</code>, and that the incoming time
(<code>times[[1]]</code>) must equal the previous time <em>exactly</em>.</p>
</td></tr>
<tr><td><code id="difeq_+3A_copy">copy</code></td>
<td>
<p>Logical, indicating if the pointer should be copied
before continuing.  If <code>TRUE</code>, this is non-destructive with
respect to the data in the original pointer so the problem can
be restarted multiple times.  By default this is <code>FALSE</code>
because there is a (potentially very small) cost to this
operation.</p>
</td></tr>
<tr><td><code id="difeq_+3A_step">step</code></td>
<td>
<p>The step to access (not that this is not an offset,
but the actual step; within your target function you'd write
things like <code>yprev(step - 1)</code> to get the previous step.</p>
</td></tr>
<tr><td><code id="difeq_+3A_i">i</code></td>
<td>
<p>index within the state vector <code>y</code> to return.  The
index here is R-style base-1 indexing, so pass <code>1</code> in to
access the first element.  This can be left <code>NULL</code> to
return all the elements or a vector longer than one.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Here is a really simple equation that just increases by 'p' each
# time (p is the parameter vector and could be any R structure).
rhs &lt;- function(i, y, p) y + p

y0 &lt;- 1
t &lt;- 0:10
p &lt;- 5
dde::difeq(y0, t, rhs, p)
</code></pre>

<hr>
<h2 id='difeq_replicate'>Solve difference equations repeatedly</h2><span id='topic+difeq_replicate'></span>

<h3>Description</h3>

<p>Solve a replicate set of difference (or recurrence) equation by
iterating it a number of times.  This is a wrapper around
<code><a href="#topic+difeq">difeq</a></code> that does not (yet) do anything clever to
avoid many allocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difeq_replicate(n, y, steps, target, parms, ..., n_out = 0L,
  n_history = 0L, grow_history = FALSE, return_history = n_history &gt; 0,
  dllname = "", parms_are_real = TRUE, ynames = NULL, outnames = NULL,
  return_by_column = TRUE, return_initial = TRUE, return_step = TRUE,
  return_output_with_y = TRUE, restartable = FALSE,
  return_minimal = FALSE, as_array = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difeq_replicate_+3A_n">n</code></td>
<td>
<p>Number of replicates.  It is an error to request zero
replicates.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_y">y</code></td>
<td>
<p>The initial state of the system.  Must be either a
numeric vector or a <code>list</code> of numeric vectors.  If the
latter, it must have length <code>n</code>.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_steps">steps</code></td>
<td>
<p>A vector of steps to return the system at.  The
<em>first</em> step is taken as step zero, and the solution will
be recorded at every other step in the vector.  So to step a
system from time zero to times 1, 2, 3, ..., n use 0:n.  Must be
integer values and will be passed through <code>as.integer</code>
(which may truncate or otherwise butcher non-integer values).</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_target">target</code></td>
<td>
<p>The target function to advance.  This can either be
an R function taking arguments <code>n, i, t, y, parms</code> or be a
scalar character with the name of a compiled function with
arguments <code>size_t n, size_t step, double time, const double
*y, double *dydt, size_t n_out, double *output void *data</code>.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_parms">parms</code></td>
<td>
<p>Parameters to pass through to the difference function</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_...">...</code></td>
<td>
<p>Dummy arguments - nothing is allowed here, but this
means that all further arguments <em>must</em> be specified by
name (not order) so I can easily reorder them later on.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_n_out">n_out</code></td>
<td>
<p>The number of output variables (in addition to the
difference equation variables).  If given, then an R function
must return an <em>attribute</em> <code>output</code> with the output
variables.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_n_history">n_history</code></td>
<td>
<p>The number of iterations of history to save
during the simulation.  By default, no history is saved.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_grow_history">grow_history</code></td>
<td>
<p>Logical indicating if history should be grown
during the simulation.  If <code>FALSE</code> (the default) then when
history is used it is overwritten as needed (so only the most
recent <code>n_history</code> elements are saved.  This may require
some tuning so that you have enough history to run your
simulation (i.e. to the longest delay) or an error will be
thrown when it underflows.  The required history length will
vary with your delay sizes and with the timestep for dopri.  If
<code>TRUE</code>, then history will grow as the buffer is exhausted.
The growth is geometric, so every time it reaches the end of the
buffer it will increase by a factor of about 1.6 (see the
<code>ring</code> documentation).  This may consume more memory than
necessary, but may be useful where you don't want to care about
picking the history length carefully.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_return_history">return_history</code></td>
<td>
<p>Logical indicating if history is to be
returned.  By default, history is returned if <code>n_history</code>
is nonzero.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_dllname">dllname</code></td>
<td>
<p>Name of the shared library (without extension) to
find the function <code>func</code> in the case where <code>func</code>
refers to compiled function.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_parms_are_real">parms_are_real</code></td>
<td>
<p>Logical, indicating if <code>parms</code> should
be treated as vector of doubles by <code>func</code> (when it is a
compiled function).  If <code>TRUE</code> (the default), then
<code>REAL(parms)</code>, which is <code>double*</code> is passed through.
If <code>FALSE</code> then if <code>params</code> is an externalptr type
(<code>EXTPTRSXP</code>) we pass through the result of
<code>R_ExternalPtrAddr</code>, otherwise we pass <code>params</code>
through unmodified as a <code>SEXP</code>.  In the last case, in your
target function you will need to include <code>&lt;Rinternals.h&gt;</code>,
cast to <code>SEXP</code> and then pull it apart using the R API (or
Rcpp).</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_ynames">ynames</code></td>
<td>
<p>Logical, indicating if the output should be named
following the names of the input vector <code>y</code>.
Alternatively, if <code>ynames</code> is a character vector of the
same length as <code>y</code>, these will be used as the output names.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_outnames">outnames</code></td>
<td>
<p>An optional character vector, used when
<code>n_out</code> is greater than 0, to name the model output matrix.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_return_by_column">return_by_column</code></td>
<td>
<p>Logical, indicating if the output should be
returned organised by column (rather than row).  This incurs a
slight cost for transposing the matrices.  If you can work with
matrices that are transposed relative to <code>deSolve</code>, then
set this to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_return_initial">return_initial</code></td>
<td>
<p>Logical, indicating if the output should
include the initial conditions.  Specifying <code>FALSE</code> avoids
binding this onto the output.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_return_step">return_step</code></td>
<td>
<p>Logical, indicating if a row (or column if
<code>return_by_column</code> is <code>TRUE</code>) representing step is included.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_return_output_with_y">return_output_with_y</code></td>
<td>
<p>Logical, indicating if the output
should be bound together with the returned matrix <code>y</code> (as
it is with <code>deSolve</code>).  If <code>FALSE</code>, then output will
be returned as the attribute <code>output</code>.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_restartable">restartable</code></td>
<td>
<p>Logical, indicating if the problem should be
restartable.  If <code>TRUE</code>, then the return value of a
simulation can be passed to <code>difeq_restart</code> to continue the
simulation after arbitrary changes to the state or the
parameters.  Note that this is really only useful for delay
difference equations where you want to keep the history but make
changes to the parameters or to the state vector while keeping
the history of the problem so far.</p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_return_minimal">return_minimal</code></td>
<td>
<p>Shorthand option - if set to <code>TRUE</code>
then it sets all of <code>return_by_column</code>,
<code>return_initial</code>, <code>return_time</code>,
<code>return_output_with_y</code> to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="difeq_replicate_+3A_as_array">as_array</code></td>
<td>
<p>(Defunct) Logical, indicating if the output should
be converted into an array.  If <code>TRUE</code> then <code>res[, ,
i]</code> will contain the <code>i</code>'th replicate, if <code>FALSE</code> then
<code>res[[i]]</code> does instead.  If both <code>as_array</code> and
<code>restartable</code> are <code>TRUE</code>, then the attributes
<code>ptr</code> and <code>restart_data</code> will be present as a
<code>list</code> of restarting information for <code>difeq_continue</code>,
though using these is not yet supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is not currently possible to replicate over a set of parameters
at once yet; the same parameter set will be used for all
replications.
</p>
<p>The details of how replication is done here are all considered
implementation details and are up for change in the future - in
particular if the models are run in turn or simultaneously (and
the effect that has on the random number stream).  Logic around
naming output may change in future too; note that varying names in
the <code>y</code> here will have some unexpected behaviours.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Here is a really simple equation that does a random walk with
# steps that are normally distributed:
rhs &lt;- function(i, y, p) y + runif(1)
y0 &lt;- 1
t &lt;- 0:10
p &lt;- 5
dde::difeq_replicate(10, y0, t, rhs, p)
</code></pre>

<hr>
<h2 id='dopri'>Integrate ODE/DDE with dopri</h2><span id='topic+dopri'></span><span id='topic+dopri5'></span><span id='topic+dopri853'></span><span id='topic+dopri_continue'></span><span id='topic+ylag'></span>

<h3>Description</h3>

<p>Integrate an ODE or DDE with dopri.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dopri(y, times, func, parms, ..., n_out = 0L, output = NULL,
  rtol = 1e-06, atol = 1e-06, step_size_min = 0, step_size_max = Inf,
  step_size_initial = 0, step_max_n = 100000L,
  step_size_min_allow = FALSE, tcrit = NULL, event_time = NULL,
  event_function = NULL, method = "dopri5", stiff_check = 0,
  verbose = FALSE, callback = NULL, n_history = 0,
  grow_history = FALSE, return_history = n_history &gt; 0, dllname = "",
  parms_are_real = TRUE, ynames = names(y), outnames = NULL,
  return_by_column = TRUE, return_initial = TRUE, return_time = TRUE,
  return_output_with_y = TRUE, return_statistics = FALSE,
  restartable = FALSE, return_minimal = FALSE)

dopri5(y, times, func, parms, ...)

dopri853(y, times, func, parms, ...)

dopri_continue(obj, times, y = NULL, ..., copy = FALSE, parms = NULL,
  tcrit = NULL, return_history = NULL, return_by_column = NULL,
  return_initial = NULL, return_statistics = NULL, return_time = NULL,
  return_output_with_y = NULL, restartable = NULL)

ylag(t, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dopri_+3A_y">y</code></td>
<td>
<p>Initial conditions for the integration</p>
</td></tr>
<tr><td><code id="dopri_+3A_times">times</code></td>
<td>
<p>Times where output is needed.  Unlike <code>deSolve</code>
we won't actually stop at these times, but instead interpolate
back to get the result.</p>
</td></tr>
<tr><td><code id="dopri_+3A_func">func</code></td>
<td>
<p>Function to integrate.  Can be an R function of
arguments <code>t, y, parms</code>, returning a numeric vector, or it
can be the name or address of a C function with arguments
<code>size_t n, double t, const double *y, double *dydt, void *data</code>.</p>
</td></tr>
<tr><td><code id="dopri_+3A_parms">parms</code></td>
<td>
<p>Parameters to pass through to the derivatives.</p>
</td></tr>
<tr><td><code id="dopri_+3A_...">...</code></td>
<td>
<p>Dummy arguments - nothing is allowed here, but this
means that all further arguments <em>must</em> be specified by
name (not order) so I can easily reorder them later on.</p>
</td></tr>
<tr><td><code id="dopri_+3A_n_out">n_out</code></td>
<td>
<p>Number of &quot;output&quot; variables (not differential
equation variables) to compute via the routine <code>output</code>.</p>
</td></tr>
<tr><td><code id="dopri_+3A_output">output</code></td>
<td>
<p>The output routine; either an R function taking
arguments <code>t, y, parms</code> or the name/address of a C function
taking arguments <code>size_t n, double t, const double *y,
size_t n_out, double *out, void *data</code>.</p>
</td></tr>
<tr><td><code id="dopri_+3A_rtol">rtol</code></td>
<td>
<p>The per-step relative tolerance.  The total accuracy
will be less than this.</p>
</td></tr>
<tr><td><code id="dopri_+3A_atol">atol</code></td>
<td>
<p>The per-step absolute tolerance.</p>
</td></tr>
<tr><td><code id="dopri_+3A_step_size_min">step_size_min</code></td>
<td>
<p>The minimum step size.  The actual minimum
used will be the largest of the absolute value of this
<code>step_size_min</code> or <code>.Machine$double.eps</code>.  If the
integration attempts to make a step smaller than this, it will
throw an error by default, stopping the integration (note that
this differs from the treatment of <code>hmin</code> in
<code>deSolve::lsoda</code>). See <code>allow_step_size_min</code> to change
this behaviour.</p>
</td></tr>
<tr><td><code id="dopri_+3A_step_size_max">step_size_max</code></td>
<td>
<p>The largest step size.  By default there is
no maximum step size (Inf) so the solver can take as large a
step as it wants to.  If you have short-lived fluctuations in
your rhs that the solver may skip over by accident, then specify
a smaller maximum step size here (or use <code>tcrit</code> below).</p>
</td></tr>
<tr><td><code id="dopri_+3A_step_size_initial">step_size_initial</code></td>
<td>
<p>The initial step size.  By default the
integrator will guess the step size automatically, but one can
be given here instead.</p>
</td></tr>
<tr><td><code id="dopri_+3A_step_max_n">step_max_n</code></td>
<td>
<p>The maximum number of steps allowed.  If the
solver takes more steps than this it will throw an error.  Note
the number of evaluations of <code>func</code> will be about 6 times
the number of steps (or 11 times if using <code>method =
"dopri853"</code>).</p>
</td></tr>
<tr><td><code id="dopri_+3A_step_size_min_allow">step_size_min_allow</code></td>
<td>
<p>Logical, indicating if when a step size
is driven down to <code>step_size_min</code> we should allow it to
proceed. This is the behaviour in of <code>hmin</code> in
<code>deSolve::lsoda</code>.</p>
</td></tr>
<tr><td><code id="dopri_+3A_tcrit">tcrit</code></td>
<td>
<p>An optional vector of critical times that the solver
must stop at (rather than interpolating over).  This can include
an end time that we can't go past, or points within the
integration that must be stopped at exactly (for example cases
where the derivatives change abruptly).  Note that this differs
from the interpretation of this parameter in deSolve; there
<code>tcrit</code> is a single time that integration may not go past
&ndash; with dde we never go past the final time, and this is just
for times that fall <em>within</em> the range of times in
<code>times</code>.</p>
</td></tr>
<tr><td><code id="dopri_+3A_event_time">event_time</code></td>
<td>
<p>Vector of times to fire events listed in
<code>event_function</code> at</p>
</td></tr>
<tr><td><code id="dopri_+3A_event_function">event_function</code></td>
<td>
<p>Function to fire at events.  For R models
(<code>func</code> is an R function and <code>dllname</code> is empty), this
must be either a single R function (same function for all
events) or a <code>list</code> of R functions.  For C models, this
must be a singe C function (same requirements as <code>func</code> or
<code>output</code> or a list/vector of these as appropriate).</p>
</td></tr>
<tr><td><code id="dopri_+3A_method">method</code></td>
<td>
<p>The integration method to use, as a string.  The
supported methods are <code>"dopri5"</code> (5th order method with 4th
order dense output) and <code>"dopri853"</code> (8th order method with
7th order output and embedded 5th and 3rd order schemes).
Alternatively, use the functions <code>dopri5</code> or
<code>dopri853</code> which simply sets this argument.</p>
</td></tr>
<tr><td><code id="dopri_+3A_stiff_check">stiff_check</code></td>
<td>
<p>How often to check that the problem has become
stiff.  If zero, then the problem is never checked, and if
positive then the problem is checked every <code>stiff_check</code>
accepted steps.  The actual check is based off the algorithm in
Hairer's implementation of the solvers and may be overly strict,
especially for delay equations with the 853 method (in my
limited experience with it).</p>
</td></tr>
<tr><td><code id="dopri_+3A_verbose">verbose</code></td>
<td>
<p>Be verbose, and print information about each step.
This may be useful for learning about models that misbehave.
Valid values are <code>TRUE</code> (enable debugging) or <code>FALSE</code>
(disable debugging) or use one of <code>dopri:::VERBOSE_QUIET</code>,
<code>dopri:::VERBOSE_STEP</code> or <code>VERBOSE:::VERBOSE_EVAL</code>.
If an R function is provided as the argument <code>callback</code>
then this function will also be called at each step or
evaluation (see below for details).</p>
</td></tr>
<tr><td><code id="dopri_+3A_callback">callback</code></td>
<td>
<p>Callback function that can be used to make verbose
output more useful.  This can be used to return more information
about the evaluation as it proceeds, generally as information
printed to the screen.  The function must accept arguments
<code>t</code>, <code>y</code> and <code>dydt</code>.  See Details for further
information.</p>
</td></tr>
<tr><td><code id="dopri_+3A_n_history">n_history</code></td>
<td>
<p>Number of history points to retain.  This needs
to be greater than zero for delay differential equations to
work.  Alternatively, this may be greater than zero to return
model outputs that can be inspected later.</p>
</td></tr>
<tr><td><code id="dopri_+3A_grow_history">grow_history</code></td>
<td>
<p>Logical indicating if history should be grown
during the simulation.  If <code>FALSE</code> (the default) then when
history is used it is overwritten as needed (so only the most
recent <code>n_history</code> elements are saved.  This may require
some tuning so that you have enough history to run your
simulation (i.e. to the longest delay) or an error will be
thrown when it underflows.  The required history length will
vary with your delay sizes and with the timestep for dopri.  If
<code>TRUE</code>, then history will grow as the buffer is exhausted.
The growth is geometric, so every time it reaches the end of the
buffer it will increase by a factor of about 1.6 (see the
<code>ring</code> documentation).  This may consume more memory than
necessary, but may be useful where you don't want to care about
picking the history length carefully.</p>
</td></tr>
<tr><td><code id="dopri_+3A_return_history">return_history</code></td>
<td>
<p>Logical indicating if history should be
returned alongside the output or discarded.  By default, history
is retained if <code>n_history</code> is greater than 0, but that
might change (and may not be desirable unless you plan on
actually using it).</p>
</td></tr>
<tr><td><code id="dopri_+3A_dllname">dllname</code></td>
<td>
<p>Name of the shared library (without extension) to
find the function <code>func</code> (and <code>output</code> if given) in
the case where <code>func</code> refers to compiled function.</p>
</td></tr>
<tr><td><code id="dopri_+3A_parms_are_real">parms_are_real</code></td>
<td>
<p>Logical, indicating if <code>parms</code> should
be treated as vector of doubles by <code>func</code> (when it is a
compiled function).  If <code>TRUE</code> (the default), then
<code>REAL(parms)</code>, which is <code>double*</code> is passed through.
If <code>FALSE</code> then if <code>params</code> is an externalptr type
(<code>EXTPTRSXP</code>) we pass through the result of
<code>R_ExternalPtrAddr</code>, otherwise we pass <code>params</code>
through unmodified as a <code>SEXP</code>.  In the last case, in your
target function you will need to include <code>&lt;Rinternals.h&gt;</code>,
cast to <code>SEXP</code> and then pull it apart using the R API (or
Rcpp).</p>
</td></tr>
<tr><td><code id="dopri_+3A_ynames">ynames</code></td>
<td>
<p>Logical, indicating if the output should be named
following the names of the input vector <code>y</code>.
Alternatively, if <code>ynames</code> is a character vector of the
same length as <code>y</code>, these will be used as the output names.</p>
</td></tr>
<tr><td><code id="dopri_+3A_outnames">outnames</code></td>
<td>
<p>An optional character vector, used when
<code>n_out</code> is greater than 0, to name the model output matrix.</p>
</td></tr>
<tr><td><code id="dopri_+3A_return_by_column">return_by_column</code></td>
<td>
<p>Logical, indicating if the output should be
returned organised by column (rather than row).  This incurs a
slight cost for transposing the matrices.  If you can work with
matrices that are transposed relative to <code>deSolve</code>, then
set this to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dopri_+3A_return_initial">return_initial</code></td>
<td>
<p>Logical, indicating if the output should
include the initial conditions.  Specifying <code>FALSE</code> avoids
binding this onto the output.</p>
</td></tr>
<tr><td><code id="dopri_+3A_return_time">return_time</code></td>
<td>
<p>Logical, indicating if a row (or column if
<code>return_by_column</code> is <code>TRUE</code>) representing time is included.
If <code>FALSE</code>, this is not added.</p>
</td></tr>
<tr><td><code id="dopri_+3A_return_output_with_y">return_output_with_y</code></td>
<td>
<p>Logical, indicating if the output
should be bound together with the returned matrix <code>y</code> (as
it is with <code>deSolve</code>).  If <code>FALSE</code>, then output will
be returned as the attribute <code>output</code>.</p>
</td></tr>
<tr><td><code id="dopri_+3A_return_statistics">return_statistics</code></td>
<td>
<p>Logical, indicating if statistics about
the run should be included.  If <code>TRUE</code>, then an integer
vector containing the number of target evaluations, steps,
accepted steps and rejected steps is returned (the vector is
named).</p>
</td></tr>
<tr><td><code id="dopri_+3A_restartable">restartable</code></td>
<td>
<p>Logical, indicating if the problem should be
restartable.  If <code>TRUE</code>, then the return value of an
integration can be passed to <code>dopri_restart</code> to continue
the integration after arbitrary changes to the state or the
parameters.  Note that when using delay models, the integrator
is fairly naive about how abrupt changes in the state space are
dealt with, and may perform very badly with <code>method =
"dopri853"</code> which assumes a fairly smooth problem.  Note that
this is really only useful for delay differential equations
where you want to keep the history but make changes to the
parameters or to the state vector while keeping the history of
the problem so far.</p>
</td></tr>
<tr><td><code id="dopri_+3A_return_minimal">return_minimal</code></td>
<td>
<p>Shorthand option - if set to <code>TRUE</code>
then it sets all of <code>return_by_column</code>,
<code>return_initial</code>, <code>return_time</code>,
<code>return_output_with_y</code> to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="dopri_+3A_obj">obj</code></td>
<td>
<p>An object to continue from; this must be the results of
running an integration with the option <code>restartable =
TRUE</code>.  Note that continuing a problem moves the pointer along
in time (unless <code>copy = TRUE</code>, and that the incoming time
(<code>times[[1]]</code>) must equal the previous time <em>exactly</em>.</p>
</td></tr>
<tr><td><code id="dopri_+3A_copy">copy</code></td>
<td>
<p>Logical, indicating if the pointer should be copied
before continuing.  If <code>TRUE</code>, this is non-destructive with
respect to the data in the original pointer so the problem can
be restarted multiple times.  By default this is <code>FALSE</code>
because there is a (potentially very small) cost to this
operation.</p>
</td></tr>
<tr><td><code id="dopri_+3A_t">t</code></td>
<td>
<p>The time to access (not that this is not an offset,
but the actual time; within your target function you'd write
things like <code>tlag(t - 1)</code> to get 1 time unit ago.</p>
</td></tr>
<tr><td><code id="dopri_+3A_i">i</code></td>
<td>
<p>index within the state vector <code>y</code> to return.  The
index here is R-style base-1 indexing, so pass <code>1</code> in to
access the first element.  This can be left <code>NULL</code> to
return all the elements or a vector longer than one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like <code>deSolve::lsoda</code>, this function has <em>many</em>
arguments.  This is far from ideal, and I would welcome any
approach for simplifying it a bit.
</p>
<p>The options <code>return_by_column</code>, <code>return_initial</code>,
<code>return_time</code>, <code>return_output_with_y</code> exist because
these options all carry out modifications of the data at the end
of solving the ODE and this can incur a small but measurable cost.
When solving an ODE repeatedly (e.g., in the context of an MCMC or
optimisation) it may be useful to do as little as possible.  For
simple problems this can save around 5-10% of the total
computational time (especially the transpose).  The shorthand
option <code>return_minimal</code> will set all to <code>FALSE</code> when
used.
</p>


<h3>Value</h3>

<p>At present the return value is transposed relative to
deSolve.  This might change in future.
</p>


<h3>Verbose output and callbacks</h3>

<p>Debugging a failed integration can be difficult, but <code>dopri</code>
provides a couple of tools to get more information about where a
failure might have occurred.  Most simply, one can pass
<code>verbose = TRUE</code> which will print information about the
time and the step size at each point just before the step is
stated.  Passing in <code>verbose = dde:::VERBOSE_EVAL</code> will
print information just before every evaluation of the target
function (there are several evaluations per step).
</p>
<p>However, this does not provide information about the state just
before failure.  To get that, one must provide a <code>callback</code>
function - this is an R function that will be called just before
a step or evaluation (based on the value of the <code>verbose</code>
argument) in place of the default print.  Define a callback
function with arguments <code>t</code>, <code>h</code> and <code>y</code> where
<code>t</code> is the time (beginning of a step or location of an
evaluation), <code>h</code> is the step size (or <code>NA</code> for an
evaluation) and <code>y</code> is the state at the point of the step
or evaluation.  Your callback function can do anything - you can
print to the screen (using <code>cat</code> or <code>message</code>), you
can store results using a closure and <code>&lt;&lt;-</code> or you could
conditionally use a <code>browser()</code> call to debug
interactively.  However, it is not possible for the callback to
affect the solution short of throwing an error and interrupting
it.  See the Examples for an example of use.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dopri_interpolate">dopri_interpolate</a></code> which can be used to
efficiently sample from output of <code>dopri</code>, and the package
vignette which shows in more detail how to solve delay
differential equations and to use compiled objective functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The lorenz attractor:
lorenz &lt;- function(t, y, p) {
  sigma &lt;- p[[1L]]
  R &lt;- p[[2L]]
  b &lt;- p[[3L]]
  c(sigma * (y[[2L]] - y[[1L]]),
    R * y[[1L]] - y[[2L]] - y[[1L]] * y[[3L]],
    -b * y[[3L]] + y[[1L]] * y[[2L]])
}

p &lt;- c(10, 28, 8 / 3)
y0 &lt;- c(10, 1, 1)

tt &lt;- seq(0, 100, length.out = 40000)
y &lt;- dde::dopri(y0, tt, lorenz, p, return_time = FALSE)
plot(y[, c(1, 3)], type = "l", lwd = 0.5, col = "#00000066")

# If we want to print progress as the integration progresses we can
# use the verbose argument:
y &lt;- dde::dopri(y0, c(0, 0.1), lorenz, p, verbose = TRUE)

# Or print the y values too using a callback:
callback &lt;- function(t, h, y) {
  message(sprintf("t: %f, h: %e, y: [%s]", t, h,
                  paste(format(y, 5), collapse = ", ")))
}
y &lt;- dde::dopri(y0, c(0, 0.1), lorenz, p, verbose = TRUE,
                callback = callback)
</code></pre>

<hr>
<h2 id='dopri_interpolate'>Interpolate Dormand-Prince output</h2><span id='topic+dopri_interpolate'></span>

<h3>Description</h3>

<p>Interpolate the Dormand-Prince output after an integration.  This
only interpolates the core integration variables and not any
additional output variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dopri_interpolate(h, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dopri_interpolate_+3A_h">h</code></td>
<td>
<p>The interpolation history.  This can be the output
running <code>dopri</code> with <code>return_history = TRUE</code>, or the
history attribute of this object (retrievable with
<code>attr(res, "history")</code>).</p>
</td></tr>
<tr><td><code id="dopri_interpolate_+3A_t">t</code></td>
<td>
<p>The times at which interpolated output is required.
These times must fall within the included history (i.e., the
times that the original simulation was run) or an error will be
thrown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This decouples the integration of the equations and the generation
of output; it is not necessary for use of the package, but may
come in useful where you need to do (for example) root finding on
the time course of a problem, or generate minimal output in some
cases and interrogate the solution more deeply in others.  See the
examples and the package vignette for a full worked example.
</p>


<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here is the Lorenz attractor implemented as an R function
lorenz &lt;- function(t, y, p) {
  sigma &lt;- p[[1L]]
  R &lt;- p[[2L]]
  b &lt;- p[[3L]]
  c(sigma * (y[[2L]] - y[[1L]]),
    R * y[[1L]] - y[[2L]] - y[[1L]] * y[[3L]],
    -b * y[[3L]] + y[[1L]] * y[[2L]])
}

# Standard parameters and a reasonable starting point:
p &lt;- c(10, 28, 8 / 3)
y0 &lt;- c(10, 1, 1)

# Run the integration for times [0, 50] and return minimal output,
# but *do* record and return history.
y &lt;- dopri(y0, c(0, 50), lorenz, p,
           n_history = 5000, return_history = TRUE,
           return_time = FALSE, return_initial = FALSE,
           return_by_column = FALSE)

# Very little output is returned (just 3 numbers being the final
# state of the system), but the "history" attribute is fairly
# large matrix of history information.  It is not printed though
# as its contents should not be relied on.  What does matter is
# the range of supported times printed (i.e., [0, 50]) and the
# number of entries (~2000).
y

# Generate an interpolated set of variables using this; first for
# 1000 steps over the full range:
tt &lt;- seq(0, 50, length.out = 1000)
yy &lt;- dopri_interpolate(y, tt)
plot(yy[, c(1, 3)], type = "l")

# Then for 50000
tt &lt;- seq(0, 50, length.out = 50000)
yy &lt;- dopri_interpolate(y, tt)
plot(yy[, c(1, 3)], type = "l")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
