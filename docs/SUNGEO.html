<!DOCTYPE html><html lang="en"><head><title>Help for package SUNGEO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SUNGEO}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SUNGEO-package'><p>SUNGEO: Sub-National Geospatial Data Archive: Geoprocessing Toolkit</p></a></li>
<li><a href='#available_data'><p>Data availability through SUNGEO API</p></a></li>
<li><a href='#cc_dict'><p>Country code dictionary</p></a></li>
<li><a href='#clea_deu2009'><p>Constituency level results for lower chamber legislative elections, Germany 2009.</p></a></li>
<li><a href='#clea_deu2009_df'><p>Constituency level results for lower chamber legislative elections, Germany 2009.</p></a></li>
<li><a href='#clea_deu2009_pt'><p>Constituency level results for lower chamber legislative elections, Germany 2009.</p></a></li>
<li><a href='#df2sf'><p>Convert data.frame object into simple features object</p></a></li>
<li><a href='#fix_geom'><p>Fix polygon geometries</p></a></li>
<li><a href='#geocode_osm'><p>Geocode addresses with OpenStreetMap</p></a></li>
<li><a href='#geocode_osm_batch'><p>Batch geocode addresses with OpenStreetMap</p></a></li>
<li><a href='#get_data'><p>Download data from SUNGEO server</p></a></li>
<li><a href='#get_info'><p>Information on available SUNGEO data files</p></a></li>
<li><a href='#gpw4_deu2010'><p>Population count raster for Germany, 2010.</p></a></li>
<li><a href='#hex_05_deu'><p>Hexagonal grid for Germany.</p></a></li>
<li><a href='#highways_deu1992'><p>Roads polylines for Germany, 1992</p></a></li>
<li><a href='#hot_spot'><p>Automatically calculate Local G hot spot intensity</p></a></li>
<li><a href='#line2poly'><p>Line-in-polygon analysis</p></a></li>
<li><a href='#make_ticker'><p>Make date ticker</p></a></li>
<li><a href='#merge_list'><p>Merge list of tables on common variable(s)</p></a></li>
<li><a href='#nesting'><p>Relative scale and nesting coefficients</p></a></li>
<li><a href='#point2poly_krige'><p>Point-to-polygon interpolation, ordinary and universal Kriging method</p></a></li>
<li><a href='#point2poly_simp'><p>Point-to-polygon interpolation, simple overlay method</p></a></li>
<li><a href='#point2poly_tess'><p>Point-to-polygon interpolation, tessellation method</p></a></li>
<li><a href='#poly2poly_ap'><p>Area and population weighted polygon-to-polygon interpolation</p></a></li>
<li><a href='#sf2raster'><p>Convert simple features object into regularly spaced raster</p></a></li>
<li><a href='#smart_round'><p>Smart numerical rounding function</p></a></li>
<li><a href='#SUNGEO'><p><code>SUNGEO</code></p></a></li>
<li><a href='#update_bbox'><p>Update bounding box of sf object</p></a></li>
<li><a href='#utm_select'><p>Automatically convert geographic (degree) to planar coordinates (meters)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sub-National Geospatial Data Archive: Geoprocessing Toolkit</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-14</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuri M. Zhukov, Jason Byers, Marty Davidson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yuri M. Zhukov &lt;zhukov@umich.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for integrating spatially-misaligned GIS datasets. Part of the Sub-National Geospatial Data Archive System.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.sungeo.org/">https://www.sungeo.org/</a>, <a href="https://github.com/zhukovyuri/SUNGEO">https://github.com/zhukovyuri/SUNGEO</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf,data.table,dplyr,RCurl,jsonlite,terra,raster,stringr,stats,methods,purrr,measurements,RANN,cartogram,packcircles,rmapshaper,spdep,Rcpp,httr,rlang,automap</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-14 21:55:48 UTC; zhukov</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-14 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SUNGEO-package'>SUNGEO: Sub-National Geospatial Data Archive: Geoprocessing Toolkit</h2><span id='topic+SUNGEO-package'></span>

<h3>Description</h3>

<p>Tools for integrating spatially-misaligned GIS datasets. Part of the Sub-National Geospatial Data Archive System.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.sungeo.org/">https://www.sungeo.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/zhukovyuri/SUNGEO">https://github.com/zhukovyuri/SUNGEO</a>
</p>
</li></ul>


<hr>
<h2 id='available_data'>Data availability through SUNGEO API</h2><span id='topic+available_data'></span>

<h3>Description</h3>

<p>Census of geospatial and processed data files available to download using <code>SUNGEO::get_data()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_data
</code></pre>


<h3>Format</h3>

<p>List of 42 data.table objects
Geoset:GADM :Classes ‘data.table’ and 'data.frame': 249 obs. of  4 variables
Geoset:GAUL :Classes ‘data.table’ and 'data.frame': 242 obs. of  4 variables
Geoset:geoBoundaries :Classes ‘data.table’ and 'data.frame': 197 obs. of  4 variables
Geoset:GRED :Classes ‘data.table’ and 'data.frame': 74 obs. of  4 variables
Geoset:HEXGRID :Classes ‘data.table’ and 'data.frame': 199 obs. of  4 variables
Geoset:MPIDR :Classes ‘data.table’ and 'data.frame': 52 obs. of  4 variables
Geoset:NHGIS :Classes ‘data.table’ and 'data.frame': 1 obs. of  4 variables
Geoset:PRIOGRID :Classes ‘data.table’ and 'data.frame': 199 obs. of  4 variables
Geoset:SHGIS :Classes ‘data.table’ and 'data.frame': 68 obs. of  4 variables
</p>

<dl>
<dt>country_iso3 </dt><dd><p>Codes for available countries (ISO 3166-1 alpha-3). Character string.</p>
</dd>
<dt>country_name </dt><dd><p>Names of available countries. Character string.</p>
</dd>
<dt>geoset_years </dt><dd><p>Years of available historical boundary files. Character string.</p>
</dd>
<dt>space_units </dt><dd><p>Available spatial units of analysis. Character string.</p>
</dd>
</dl>

<p>Elections:LowerHouse:CLEA :Classes ‘data.table’ and 'data.frame': 168 obs. of  6 variables
Demographics:Ethnicity:EPR :Classes ‘data.table’ and 'data.frame': 180 obs. of  6 variables
Demographics:Ethnicity:GREG :Classes ‘data.table’ and 'data.frame': 234 obs. of  6 variables
Demographics:Population:GHS :Classes ‘data.table’ and 'data.frame': 257 obs. of  6 variables
Events:PoliticalViolence:ABADarfur :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:ACLED :Classes ‘data.table’ and 'data.frame': 100 obs. of  6 variables
Events:PoliticalViolence:BeissingerProtest :Classes ‘data.table’ and 'data.frame': 15 obs. of  6 variables
Events:PoliticalViolence:BeissingerRiot :Classes ‘data.table’ and 'data.frame': 15 obs. of  6 variables
Events:PoliticalViolence:BeissingerUkraine :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:COCACW :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:ESOCAfghanistanWITS :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:ESOCIraqSIGACT :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:ESOCIraqWITS :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:ESOCMexicoDrugRelatedMurders :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:ESOCMexicoHomicide :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:ESOCPakistanBFRS :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:ESOCPakistanWITS :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:GED :Classes ‘data.table’ and 'data.frame': 121 obs. of  6 variables
Events:PoliticalViolence:Lankina :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:NIRI :Classes ‘data.table’ and 'data.frame': 12 obs. of  6 variables
Events:PoliticalViolence:NVMS :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:PITF :Classes ‘data.table’ and 'data.frame': 133 obs. of  6 variables
Events:PoliticalViolence:SCAD :Classes ‘data.table’ and 'data.frame': 60 obs. of  6 variables
Events:PoliticalViolence:yzCaucasus2000 :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:yzChechnya :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:yzLibya :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Events:PoliticalViolence:yzUkraine2014 :Classes ‘data.table’ and 'data.frame': 1 obs. of  6 variables
Infrastructure:Roads:gRoads :Classes ‘data.table’ and 'data.frame': 240 obs. of  6 variables
Infrastructure:NightLights:DMSP :Classes ‘data.table’ and 'data.frame': 257 obs. of  6 variables
PublicHealth:Covid19:JHUCSSEC19 :Classes ‘data.table’ and 'data.frame': 207 obs. of  6 variables
Terrain:Elevation:ETOPO1 :Classes ‘data.table’ and 'data.frame': 256 obs. of  6 variables
Terrain:LandCover:GLCC :Classes ‘data.table’ and 'data.frame': 257 obs. of  6 variables
Weather:AirTemperatureAndPrecipitation:NOAA :Classes ‘data.table’ and 'data.frame': 209 obs. of  6 variables
</p>

<dl>
<dt>country_iso3 </dt><dd><p>Codes for available countries (ISO 3166-1 alpha-3). Character string.</p>
</dd>
<dt>country_name </dt><dd><p>Names of available countries. Character string.</p>
</dd>
<dt>year_range </dt><dd><p>Range of available years for data topic. Character string.</p>
</dd>
<dt>time_units </dt><dd><p>Available time units. Character string.</p>
</dd>
<dt>space_units </dt><dd><p>Available spatial units. Character string.</p>
</dd>
<dt>geosets </dt><dd><p>Names of available geographic boundary data sources. Character string.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Sub-National Geospatial Data Archive System: Geoprocessing Toolkit (updated March 17, 2023).
</p>

<hr>
<h2 id='cc_dict'>Country code dictionary</h2><span id='topic+cc_dict'></span>

<h3>Description</h3>

<p>Reference table of country names and ISO-3166 codes, adapted from <code>countrycode</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_dict
</code></pre>


<h3>Format</h3>

<p>data.table object, with	8626 obs. of  3 variables:
</p>

<dl>
<dt>country_name </dt><dd><p>Country names. Character string.</p>
</dd>
<dt>country_name_alt </dt><dd><p>Alternative spellings of country names, ASCII characters only. Character string.</p>
</dd>
<dt>country_iso3 </dt><dd><p>Country codes (ISO 3166-1 alpha-3). Character string.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Vincent Arel-Bundock. Package countrycode: Convert Country Names and Country Code, version 1.40. CRAN (October 12, 2022).
</p>

<hr>
<h2 id='clea_deu2009'>Constituency level results for lower chamber legislative elections, Germany 2009.</h2><span id='topic+clea_deu2009'></span>

<h3>Description</h3>

<p>A simple feature collection containing the spatial geometries of electoral constituency
borders, and data on turnout levels, votes shares and other attributes of lower chamber
legislative elections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clea_deu2009
</code></pre>


<h3>Format</h3>

<p>Simple feature collection with 16 features and 10 fields.
geometry type:  MULTIPOLYGON.
dimension:      XY.
bbox:           xmin: 5.867281 ymin: 47.27096 xmax: 15.04388 ymax: 55.05902.
epsg (SRID):    4326.
proj4string:    +proj=longlat +datum=WGS84 +no_defs.
</p>

<dl>
<dt>cst </dt><dd><p>Constituency number. Numeric.</p>
</dd>
<dt>cst_n </dt><dd><p>Constituency name. Character.</p>
</dd>
<dt>ctr </dt><dd><p>Country number. Numeric.</p>
</dd>
<dt>ctr_n </dt><dd><p>Country name. Character.</p>
</dd>
<dt>yrmo </dt><dd><p>Year and month of election (YYYYMM). Character.</p>
</dd>
<dt>to1 </dt><dd><p>Turnout in first round. Numeric.</p>
</dd>
<dt>vv1 </dt><dd><p>Number of valid votes in first round. Numeric.</p>
</dd>
<dt>pvs1_margin </dt><dd><p>Popular vote share margin in first round. Numeric.</p>
</dd>
<dt>incumb_pty_n </dt><dd><p>Incumbent party name.</p>
</dd>
<dt>win1_pty_n </dt><dd><p>Party name of popular vote share winner in first round. Character.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Constituency-Level Elections Archive (CLEA) <a href="https://electiondataarchive.org/">https://electiondataarchive.org/</a>
</p>

<hr>
<h2 id='clea_deu2009_df'>Constituency level results for lower chamber legislative elections, Germany 2009.</h2><span id='topic+clea_deu2009_df'></span>

<h3>Description</h3>

<p>A data.frame object containing the geographic centroids of electoral
contituencies, and data on turnout levels, votes shares and other attributes of
lower chamber legislative elections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clea_deu2009_df
</code></pre>


<h3>Format</h3>

<p>data.frame with 16 observations and 12 variables.
</p>

<dl>
<dt>cst </dt><dd><p>Constituency number. Numeric.</p>
</dd>
<dt>cst_n </dt><dd><p>Constituency name. Character.</p>
</dd>
<dt>ctr </dt><dd><p>Country number. Numeric.</p>
</dd>
<dt>ctr_n </dt><dd><p>Country name. Character.</p>
</dd>
<dt>yrmo </dt><dd><p>Year and month of election (YYYYMM). Character.</p>
</dd>
<dt>to1 </dt><dd><p>Turnout in first round. Numeric.</p>
</dd>
<dt>vv1 </dt><dd><p>Number of valid votes in first round. Numeric.</p>
</dd>
<dt>pvs1_margin </dt><dd><p>Popular vote share margin in first round. Numeric.</p>
</dd>
<dt>incumb_pty_n </dt><dd><p>Incumbent party name.</p>
</dd>
<dt>win1_pty_n </dt><dd><p>Party name of popular vote share winner in first round. Character.</p>
</dd>
<dt>longitude </dt><dd><p>Longitude of constituency centroid. Numeric.</p>
</dd>
<dt>latitude </dt><dd><p>Latitude of constituency centroid. Numeric.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Constituency-Level Elections Archive (CLEA) <a href="https://electiondataarchive.org/">https://electiondataarchive.org/</a>
</p>

<hr>
<h2 id='clea_deu2009_pt'>Constituency level results for lower chamber legislative elections, Germany 2009.</h2><span id='topic+clea_deu2009_pt'></span>

<h3>Description</h3>

<p>A simple feature collection containing the geographic centroids of electoral
contituencies, and data on turnout levels, votes shares and other attributes of
lower chamber legislative elections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clea_deu2009_pt
</code></pre>


<h3>Format</h3>

<p>Simple feature collection with 16 features and 10 fields.
geometry type:  POINT.
dimension:      XY.
bbox:           xmin: 6.953882 ymin: 48.54535 xmax: 13.40315 ymax: 54.18635.
epsg (SRID):    4326.
proj4string:    +proj=longlat +datum=WGS84 +no_defs.
</p>

<dl>
<dt>cst </dt><dd><p>Constituency number. Numeric.</p>
</dd>
<dt>cst_n </dt><dd><p>Constituency name. Character.</p>
</dd>
<dt>ctr </dt><dd><p>Country number. Numeric.</p>
</dd>
<dt>ctr_n </dt><dd><p>Country name. Character.</p>
</dd>
<dt>yrmo </dt><dd><p>Year and month of election (YYYYMM). Character.</p>
</dd>
<dt>to1 </dt><dd><p>Turnout in first round. Numeric.</p>
</dd>
<dt>vv1 </dt><dd><p>Number of valid votes in first round. Numeric.</p>
</dd>
<dt>pvs1_margin </dt><dd><p>Popular vote share margin in first round. Numeric.</p>
</dd>
<dt>incumb_pty_n </dt><dd><p>Incumbent party name.</p>
</dd>
<dt>win1_pty_n </dt><dd><p>Party name of popular vote share winner in first round. Character.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Constituency-Level Elections Archive (CLEA) <a href="https://electiondataarchive.org/">https://electiondataarchive.org/</a>
</p>

<hr>
<h2 id='df2sf'>Convert data.frame object into simple features object</h2><span id='topic+df2sf'></span>

<h3>Description</h3>

<p>Function takes in x-, y-coordinates, and a data.frame of variables (optional) and returns an SFC object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2sf(
  x_coord,
  y_coord,
  input_data = NULL,
  file = NULL,
  n_max = Inf,
  start = 0,
  projection_input = "EPSG:4326",
  zero.policy = FALSE,
  show_removed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df2sf_+3A_x_coord">x_coord</code></td>
<td>
<p>Numeric vector with longitude or easting projected coordinates. When <code>input_data</code> or <code>file</code> is supplied, can be either column name or numeric vector of the same length as <code>nrow(input_data)</code>.</p>
</td></tr>
<tr><td><code id="df2sf_+3A_y_coord">y_coord</code></td>
<td>
<p>Numeric vector with latitude or northing projected coordinates. Must be equal to the vector length of <code>x_coord</code>. When <code>input_data</code> or <code>file</code> is supplied, can be either column name or numeric vector of the same length as <code>nrow(input_data)</code>.</p>
</td></tr>
<tr><td><code id="df2sf_+3A_input_data">input_data</code></td>
<td>
<p>Optional data frame object, containing <code>x_coord</code> and <code>y_coord</code>. <code>nrow(input_data)</code> must be equal to the vector length of <code>x_coord</code>. NOTE: Rows corresponding to non-usable coordinates are removed from the final output.</p>
</td></tr>
<tr><td><code id="df2sf_+3A_file">file</code></td>
<td>
<p>Optional path to csv file. Overrides <code>input_data</code>.</p>
</td></tr>
<tr><td><code id="df2sf_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of rows to read in <code>file</code>. Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="df2sf_+3A_start">start</code></td>
<td>
<p>Number of rows to skip in <code>file</code>. Default is 0 (start on first row).</p>
</td></tr>
<tr><td><code id="df2sf_+3A_projection_input">projection_input</code></td>
<td>
<p>Projection string associated with <code>x_coord</code> and <code>y_coord</code>. Default is <code>'+proj=longlat'</code>.</p>
</td></tr>
<tr><td><code id="df2sf_+3A_zero.policy">zero.policy</code></td>
<td>
<p>If <code>TRUE</code>, removes rows where corresponding coordinates equals (0,0). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="df2sf_+3A_show_removed">show_removed</code></td>
<td>
<p>If <code>TRUE</code>, returns a vector of indices corresponding to non-usable coordinates. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>show_removed==FALSE</code>, returns an <code>sf</code> object, with rows corresponding to non-usable coordinates removed. If <code>show_removed==TRUE</code>, returns a list, with an <code>sf</code> object (<code>Spatial_Coordinates</code>), and a vector of indices corresponding to non-usable coordinates removed (<code>Removed_Rows</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Coordinates supplied as vectors
## Not run: 
data(clea_deu2009_df)
out_1 &lt;- df2sf(x_coord=clea_deu2009_df$longitude,y_coord = clea_deu2009_df$latitude)
class(out_1)
plot(out_1$geometry)

## End(Not run)
# Coordinates supplied as column mames
## Not run: 
out_2 &lt;- df2sf(x_coord="longitude",y_coord ="latitude", input_data = clea_deu2009_df)
plot(out_2["geometry"])

## End(Not run)
# Load from external file
## Not run: 
tmp &lt;- tempfile()
write.csv(clea_deu2009_df,file=tmp)
out_3 &lt;- df2sf(x_coord="longitude",y_coord ="latitude", file=tmp)
plot(out_3["geometry"])

## End(Not run)
</code></pre>

<hr>
<h2 id='fix_geom'>Fix polygon geometries</h2><span id='topic+fix_geom'></span>

<h3>Description</h3>

<p>Function to check validity and fix broken geometries in simple features polygon objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_geom(x, n_it = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_geom_+3A_x">x</code></td>
<td>
<p>Polygon layer to be checked and fixed. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="fix_geom_+3A_n_it">n_it</code></td>
<td>
<p>Number of iterations. Default is 10. Numeric..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>sf</code> polygon object, with self-intersections and other geometry problems fixed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assignment of a single variable (sums)
## Not run: 
data(clea_deu2009)
out_1 &lt;- fix_geom(clea_deu2009)

## End(Not run)
</code></pre>

<hr>
<h2 id='geocode_osm'>Geocode addresses with OpenStreetMap</h2><span id='topic+geocode_osm'></span>

<h3>Description</h3>

<p>Function to find geographic coordinates of addresses and place names, using OpenStreetMap's Nominatum API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocode_osm(
  query,
  match_num = 1,
  return_all = FALSE,
  details = FALSE,
  user_agent = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geocode_osm_+3A_query">query</code></td>
<td>
<p>Address or place name to be geocoded. Character string.</p>
</td></tr>
<tr><td><code id="geocode_osm_+3A_match_num">match_num</code></td>
<td>
<p>If query matches multiple locations, which match to return? Default is 1 (highest-ranking match, by relevance). Numeric.</p>
</td></tr>
<tr><td><code id="geocode_osm_+3A_return_all">return_all</code></td>
<td>
<p>Should all matches be returned? Overrides <code>match_num</code> if <code>TRUE</code>. Default is <code>FALSE</code>. Logical.</p>
</td></tr>
<tr><td><code id="geocode_osm_+3A_details">details</code></td>
<td>
<p>Should detailed results be returned? Default is <code>FALSE</code>. Logical.</p>
</td></tr>
<tr><td><code id="geocode_osm_+3A_user_agent">user_agent</code></td>
<td>
<p>Valid User-Agent identifying the application for OSM-Nominatum. If none supplied, function will attempt to auto-detect. Character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that Nominatim Usage Policy stipulates an absolute maximum of 1 request per second (<a href="https://operations.osmfoundation.org/policies/nominatim/">https://operations.osmfoundation.org/policies/nominatim/</a>). For batch geocoding of multiple addresses, please use <code><a href="#topic+geocode_osm_batch">geocode_osm_batch</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object. If <code>details=FALSE</code>, contains fields
</p>

<ul>
<li><p> &quot;query&quot;. User-supplied address query(ies). Character string.
</p>
</li>
<li><p> &quot;osm_id&quot;. OpenStreetMap ID. Character string.
</p>
</li>
<li><p> &quot;address&quot;. OpenStreetMap address. Character string.
</p>
</li>
<li><p> &quot;longitude&quot;. Horizontal coordinate. Numeric.
</p>
</li>
<li><p> &quot;latitude&quot;. Vertical coordinate. Numeric.
</p>
</li></ul>

<p>If <code>details=TRUE</code>, contains additional fields
</p>

<ul>
<li><p> &quot;osm_type&quot;. OpenStreetMap ID. Character string.
</p>
</li>
<li><p> &quot;importance&quot;. Relevance of Nominatum match to query, from 0 (worst) to 1 (best). Numeric.
</p>
</li>
<li><p> &quot;bbox_ymin&quot;. Minimum vertical coordinate of bounding box. Numeric.
</p>
</li>
<li><p> &quot;bbox_ymax&quot;. Maximum vertical coordinate of bounding box. Numeric.
</p>
</li>
<li><p> &quot;bbox_xmin&quot;. Minimum horizontal coordinate of bounding box. Numeric.
</p>
</li>
<li><p> &quot;bbox_xmax&quot;. Maximum horizontal coordinate of bounding box. Numeric.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Geocode an address (top match only)
## Not run: 
geocode_osm("Michigan Stadium")

## End(Not run)
# Return detailed results for top match
## Not run: 
geocode_osm("Michigan Stadium", details=TRUE)

## End(Not run)
# Return detailed results for all matches
## Not run: 
geocode_osm("Michigan Stadium", details=TRUE, return_all = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='geocode_osm_batch'>Batch geocode addresses with OpenStreetMap</h2><span id='topic+geocode_osm_batch'></span>

<h3>Description</h3>

<p>Function to find geographic coordinates of multiple addresses and place names, using OpenStreetMap's Nominatum API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocode_osm_batch(
  query,
  delay = 1,
  return_all = FALSE,
  match_num = 1,
  details = FALSE,
  user_agent = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geocode_osm_batch_+3A_query">query</code></td>
<td>
<p>Addresses or place names to be geocoded. Character string.</p>
</td></tr>
<tr><td><code id="geocode_osm_batch_+3A_delay">delay</code></td>
<td>
<p>Delay between requests. Default is 1 second. Numeric.</p>
</td></tr>
<tr><td><code id="geocode_osm_batch_+3A_return_all">return_all</code></td>
<td>
<p>Should all matches be returned? Overrides <code>match_num</code> if <code>TRUE</code>. Default is <code>FALSE</code>. Logical.</p>
</td></tr>
<tr><td><code id="geocode_osm_batch_+3A_match_num">match_num</code></td>
<td>
<p>If query matches multiple locations, which match to return? Default is 1 (highest-ranking match, by relevance). Numeric.</p>
</td></tr>
<tr><td><code id="geocode_osm_batch_+3A_details">details</code></td>
<td>
<p>Should detailed results be returned? Default is <code>FALSE</code>. Logical.</p>
</td></tr>
<tr><td><code id="geocode_osm_batch_+3A_user_agent">user_agent</code></td>
<td>
<p>Valid User-Agent identifying the application for OSM-Nominatum. If none supplied, function will attempt to auto-detect. Character string.</p>
</td></tr>
<tr><td><code id="geocode_osm_batch_+3A_verbose">verbose</code></td>
<td>
<p>Print status messages and progress? Default is <code>FALSE</code>. Logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper function for <code><a href="#topic+geocode_osm">geocode_osm</a></code>. Because Nominatim Usage Policy stipulates an absolute maximum of 1 request per second, this function facilitates batch geocoding by adding a small delay between queries (<a href="https://operations.osmfoundation.org/policies/nominatim/">https://operations.osmfoundation.org/policies/nominatim/</a>).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object. If <code>details=FALSE</code>, contains fields
</p>

<ul>
<li><p> &quot;query&quot;. User-supplied address query(ies). Character string.
</p>
</li>
<li><p> &quot;osm_id&quot;. OpenStreetMap ID. Character string.
</p>
</li>
<li><p> &quot;address&quot;. OpenStreetMap address. Character string.
</p>
</li>
<li><p> &quot;longitude&quot;. Horizontal coordinate. Numeric.
</p>
</li>
<li><p> &quot;latitude&quot;. Vertical coordinate. Numeric.
</p>
</li></ul>

<p>If <code>details=TRUE</code>, contains additional fields
</p>

<ul>
<li><p> &quot;osm_type&quot;. OpenStreetMap ID. Character string.
</p>
</li>
<li><p> &quot;importance&quot;. Relevance of Nominatum match to query, from 0 (worst) to 1 (best). Numeric.
</p>
</li>
<li><p> &quot;bbox_ymin&quot;. Minimum vertical coordinate of bounding box. Numeric.
</p>
</li>
<li><p> &quot;bbox_ymax&quot;. Maximum vertical coordinate of bounding box. Numeric.
</p>
</li>
<li><p> &quot;bbox_xmin&quot;. Minimum horizontal coordinate of bounding box. Numeric.
</p>
</li>
<li><p> &quot;bbox_xmax&quot;. Maximum horizontal coordinate of bounding box. Numeric.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Geocode multiple addresses (top matches only)
## Not run: 
geocode_osm_batch(c("Ann Arbor","East Lansing","Columbus"))

## End(Not run)
# With progress reports
## Not run: 
geocode_osm_batch(c("Ann Arbor","East Lansing","Columbus"), verbose = TRUE)

## End(Not run)
# Return detailed results for all matches
## Not run: 
geocode_osm_batch(c("Ann Arbor","East Lansing","Columbus"),
                  details = TRUE, return_all = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_data'>Download data from SUNGEO server</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>Function to download data files through the SUNGEO API. Function produces a data.table object, corresponding to the user's choice of countries, topics, sources, and spatial and temporal units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(
  country_names = NULL,
  country_iso3 = NULL,
  geoset = "GADM",
  geoset_yr = 2018,
  space_unit = "adm1",
  time_unit = "year",
  topics = NULL,
  year_min = 1990,
  year_max = 2017,
  print_url = TRUE,
  print_time = TRUE,
  error_stop = FALSE,
  by_topic = TRUE,
  skip_missing = TRUE,
  cache_param = FALSE,
  short_message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data_+3A_country_names">country_names</code></td>
<td>
<p>Country name(s). Character string (single country) or vector of character strings (multiple countries).</p>
</td></tr>
<tr><td><code id="get_data_+3A_country_iso3">country_iso3</code></td>
<td>
<p>Country code (ISO 3166-1 alpha-3). Character string (single country) or vector of character strings (multiple countries).</p>
</td></tr>
<tr><td><code id="get_data_+3A_geoset">geoset</code></td>
<td>
<p>Name of geographic boundary set. Can be one of <code>"GADM"</code> (Database of Global Administrative Areas), <code>"GAUL"</code> (Global Administrative Unit Layers), <code>"geoBoundaries"</code>, <code>"GRED"</code> (GeoReferenced Electoral Districts Datasets), <code>"HEXGRID"</code> (SUNGEO Hexagonal Grid), <code>"MPIDR"</code> (Max Planck Institute for Demographic Research Population History GIS Collection), <code>"NHGIS"</code> (National Historical Geographic Information System), <code>"PRIOGRID"</code> (PRIO-GRID 2.0), <code>"SHGIS"</code> (SUNGEO Historical GIS). Default is <code>"GADM"</code>. Character string.</p>
</td></tr>
<tr><td><code id="get_data_+3A_geoset_yr">geoset_yr</code></td>
<td>
<p>Year of geographic boundaries. See <code>get_info()['geosets']</code> for availability. Default is <code>2018</code>. Integer.</p>
</td></tr>
<tr><td><code id="get_data_+3A_space_unit">space_unit</code></td>
<td>
<p>Geographic level of analysis. Can be one of <code>"adm0"</code> (country), <code>"adm1"</code> (province), <code>"adm2"</code> (district), <code>"cst"</code> (GRED electoral constituency), <code>"hex05"</code> (SUNGEO Hexagonal Grid cell), <code>"prio"</code> (PRIO-GRID cell). See <code>get_info()['geosets']</code> for availability by geoset, country and topic. Default is <code>"adm1"</code>. Character string.</p>
</td></tr>
<tr><td><code id="get_data_+3A_time_unit">time_unit</code></td>
<td>
<p>Temporal level of analysis. Can be one of <code>"year"</code>, <code>"month"</code>, <code>"week"</code>. See <code>get_info()['topics']</code> for availability by topic. Default is <code>"year"</code>. Character string.</p>
</td></tr>
<tr><td><code id="get_data_+3A_topics">topics</code></td>
<td>
<p>Data topics. See <code>get_info()['summary']</code> for full list. Character string (single topic) or vector of character strings (multiple topics).</p>
</td></tr>
<tr><td><code id="get_data_+3A_year_min">year_min</code></td>
<td>
<p>Time range of requested data: start year. See <code>get_info()['topics']</code> for availability by topic. Default is <code>1990</code>. Integer.</p>
</td></tr>
<tr><td><code id="get_data_+3A_year_max">year_max</code></td>
<td>
<p>Time range of requested data: end year. See <code>get_info()['topics']</code> for availability by topic. Default is <code>2017</code>. Integer.</p>
</td></tr>
<tr><td><code id="get_data_+3A_print_url">print_url</code></td>
<td>
<p>Print url string of requested data to console? Default is <code>TRUE</code>. Logical.</p>
</td></tr>
<tr><td><code id="get_data_+3A_print_time">print_time</code></td>
<td>
<p>Print processing time for API query to console? Default is <code>TRUE</code>. Logical.</p>
</td></tr>
<tr><td><code id="get_data_+3A_error_stop">error_stop</code></td>
<td>
<p>Error handling. If <code>TRUE</code>, function terminates request if an error is encountered. If <code>FALSE</code>, error is skipped and error message is recorded in a new <code>message</code> column. Default is <code>FALSE</code>. Logical.</p>
</td></tr>
<tr><td><code id="get_data_+3A_by_topic">by_topic</code></td>
<td>
<p>Break query down by topic and country? If <code>TRUE</code>, a separate request is sent to the API for each country and topic, and the results are combined on the client side. This ensures that data that are available for some, but not all countries are returned, rather than resulting in a failed request. If <code>FALSE</code>, a single request is sent to the API for all countries and topics, and the results are combined on the server side. Only data that are available for all countries are returned. Default is <code>TRUE</code>. Logical.</p>
</td></tr>
<tr><td><code id="get_data_+3A_skip_missing">skip_missing</code></td>
<td>
<p>Skip missing data topics? If <code>TRUE</code>, missing data topics are skipped, columns are populated with NAs, and corresponding error message is recorded in a new <code>message</code> column. If <code>FALSE</code>, returns NULL results for missing topics. Default is <code>TRUE</code>. Logical.</p>
</td></tr>
<tr><td><code id="get_data_+3A_cache_param">cache_param</code></td>
<td>
<p>Store cached query on server? This can speed up processing for repeated queries. Default is <code>FALSE</code>. Logical.</p>
</td></tr>
<tr><td><code id="get_data_+3A_short_message">short_message</code></td>
<td>
<p>Shorten error messages? If <code>TRUE</code>, a short, informative error message is recorded in the <code>message</code> column. If <code>FALSE</code>, full error message is recorded. Default is <code>TRUE</code>. Logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table object, with requested data from SUNGEO API.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_info">get_info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single country, single topic
## Not run: 
out_1 &lt;- get_data(country_name="Afghanistan",topics="Demographics:Population:GHS")
out_1

## End(Not run)

## Not run: 
out_2 &lt;- get_data(
	country_name=c("Afghanistan","Moldova"),
	topics=c("Demographics:Ethnicity:EPR","Demographics:Population:GHS"))
out_2

## End(Not run)

# Other boundary sets, spatial and time units
## Not run: 
out_3 &lt;- get_data(
	country_name="Albania",
	topics="Weather:AirTemperatureAndPrecipitation:NOAA",
	geoset="GAUL",geoset_yr=1990,space_unit="adm2",time_unit="month",
	year_min=1990,year_max=1991)
out_3

## End(Not run)
</code></pre>

<hr>
<h2 id='get_info'>Information on available SUNGEO data files</h2><span id='topic+get_info'></span>

<h3>Description</h3>

<p>This function reports the availability of data files on the SUNGEO server, searchable by country and topic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_info(country_names = NULL, country_iso3s = NULL, topics = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_info_+3A_country_names">country_names</code></td>
<td>
<p>Country name(s). Character string (single country) or vector of character strings (multiple countries).</p>
</td></tr>
<tr><td><code id="get_info_+3A_country_iso3s">country_iso3s</code></td>
<td>
<p>Country code (ISO 3166-1 alpha-3). Character string (single country) or vector of character strings (multiple countries).</p>
</td></tr>
<tr><td><code id="get_info_+3A_topics">topics</code></td>
<td>
<p>Data topics. See <code>get_info()</code> for full list. Character string (single topic) or vector of character strings (multiple topics).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list object, with three slots: 'summary', 'topics', and 'geoset'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_data">get_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get list of all available data
## Not run: 
out_1 &lt;- get_info()
out_1["summary"]
out_1["topics"]
out_1["geosets"]

## End(Not run)

# Get list of available data for a single country
## Not run: 
out_2 &lt;- get_info(country_names="Afghanistan")
out_2

## End(Not run)

# Get list of available data for a single topic
## Not run: 
out_3 &lt;- get_info(topics="Elections:LowerHouse:CLEA")
out_3

## End(Not run)

# Get list of available data for a multiple countries and topics
## Not run: 
out_4 &lt;- get_info(
                 country_names=c("Afghanistan","Zambia"),
                 topics=c("Elections:LowerHouse:CLEA","Events:PoliticalViolence:GED"))
out_4

## End(Not run)
</code></pre>

<hr>
<h2 id='gpw4_deu2010'>Population count raster for Germany, 2010.</h2><span id='topic+gpw4_deu2010'></span>

<h3>Description</h3>

<p>2.5 arc-minute resolution raster of estimates of human population (number of persons per pixel),
consistent with national censuses and population registers, for the year 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpw4_deu2010
</code></pre>


<h3>Format</h3>

<p>class       : SpatRaster
dimensions  : 186, 220, 1  (nrow, ncol, nlyr)
resolution  : 0.04166667, 0.04166667  (x, y)
extent      : 5.875, 15.04167, 47.29167, 55.04167  (xmin, xmax, ymin, ymax)
coord. ref. : lon/lat WGS 84 (EPSG:4326)
source(s)   : memory
name        : gpw_v4_population_count_rev11_2010_2pt5_min
min value   :                                        0.00
max value   :                                    92915.66
</p>


<h3>Source</h3>

<p>Gridded Population of the World (GPW) v4: Population Count, v4.11 &lt;doi:10.7927/H4JW8BX5&gt;.
</p>

<hr>
<h2 id='hex_05_deu'>Hexagonal grid for Germany.</h2><span id='topic+hex_05_deu'></span>

<h3>Description</h3>

<p>Regular hexagonal grid of 0.5 degree diameter cells, covering territory of Germany (2020 borders).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hex_05_deu
</code></pre>


<h3>Format</h3>

<p>Simple feature collection with 257 features and 3 fields.
geometry type:  POLYGON.
dimension:      XY.
bbox:           xmin: 5.375001 ymin: 46.76568 xmax: 15.375 ymax: 55.13726.
epsg (SRID):    4326.
proj4string:    +proj=longlat +datum=WGS84 +no_defs.
</p>

<dl>
<dt>HEX_ID </dt><dd><p>Unique cell identifier. Character.</p>
</dd>
<dt>HEX_X </dt><dd><p>Longitude of cell centroid. Numeric.</p>
</dd>
<dt>HEX_Y </dt><dd><p>Latitude of cell centroid. Numeric.</p>
</dd>
</dl>



<h3>Source</h3>

<p>SUNGEO
</p>

<hr>
<h2 id='highways_deu1992'>Roads polylines for Germany, 1992</h2><span id='topic+highways_deu1992'></span>

<h3>Description</h3>

<p>Roads thematic layer from Digital Chart of the World. Subset: divided multi-lane highways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highways_deu1992
</code></pre>


<h3>Format</h3>

<p>Simple feature collection with 1741 features and 5 fields.
geometry type:  MULTILINESTRING.
dimension:      XY.
bbox:           xmin: 5.750933 ymin: 47.58799 xmax: 14.75109 ymax: 54.80712
epsg (SRID):    4326.
proj4string:    +proj=longlat +datum=WGS84 +no_defs.
</p>

<dl>
<dt>MED_DESCRI </dt><dd><p>Is the road a divided multi-lane highway with a median? Character string.</p>
</dd>
<dt>RTT_DESCRI </dt><dd><p>Primary or secondary route? Character string.</p>
</dd>
<dt>F_CODE_DES </dt><dd><p>Feature code description (road or trail). Character string.</p>
</dd>
<dt>ISO </dt><dd><p>ISO 3166-1 alpha-3 country code. Character string.</p>
</dd>
<dt>ISOCOUNTRY </dt><dd><p>Country name. Character string.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Defense Mapping Agency (DMA), 1992. Digital Chart of the World. Defense Mapping Agency, Fairfax, Virginia. (Four CD-ROMs). Available through DIVA-GIS: <a href="http://www.diva-gis.org/gData">http://www.diva-gis.org/gData</a> (accessed August 12, 2021).
</p>

<hr>
<h2 id='hot_spot'>Automatically calculate Local G hot spot intensity</h2><span id='topic+hot_spot'></span>

<h3>Description</h3>

<p>Function automatically calculates the Local G hot spot intensity measure for spatial points, spatial polygons, and single raster layers. Uses RANN for efficient nearest neighbor calculation (spatial points and single raster layers only); users can specify the number of neighbors (k). Users can specify the neighborhood style (see spdep::nb2listw) with default being standardized weight matrix (W).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hot_spot(
  insert,
  variable = NULL,
  style = "W",
  k = 9,
  remove_missing = TRUE,
  NA_Value = 0,
  include_Moran = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hot_spot_+3A_insert">insert</code></td>
<td>
<p>Spatial point, spatial polygon, or single raster layer object. Acceptable formats include <code>sf</code>, <code>SpatialPolygonsDataFrame</code>, <code>SpatialPointsDataFrame</code>, and <code>RasterLayer</code>.</p>
</td></tr>
<tr><td><code id="hot_spot_+3A_variable">variable</code></td>
<td>
<p>Column name or numeric vector containing the variable from which the local G statistic will be calculated. Must possess a natural scale that orders small and large observations (i.e. number, percentage, ratio and not model residuals).</p>
</td></tr>
<tr><td><code id="hot_spot_+3A_style">style</code></td>
<td>
<p>Style can take values <code>'W'</code>, <code>'B'</code>, <code>'C'</code>, <code>'U'</code>, <code>'mimax'</code>, <code>'S'</code> (see  <code><a href="spdep.html#topic+nb2listw">nb2listw</a></code>). Character string.</p>
</td></tr>
<tr><td><code id="hot_spot_+3A_k">k</code></td>
<td>
<p>Number of neighbors. Default is 9. Numeric.</p>
</td></tr>
<tr><td><code id="hot_spot_+3A_remove_missing">remove_missing</code></td>
<td>
<p>Whether to calculate statistic without missing values. If <code>FALSE</code>, substitute value must be supplied to <code>NA_Value</code>.</p>
</td></tr>
<tr><td><code id="hot_spot_+3A_na_value">NA_Value</code></td>
<td>
<p>Substitute for missing values. Default value is 0. Numeric.</p>
</td></tr>
<tr><td><code id="hot_spot_+3A_include_moran">include_Moran</code></td>
<td>
<p>Calculate local Moran's I statistics. Default is <code>FALSE</code>. Logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>input</code> is <code>sf</code>, <code>SpatialPolygonsDataFrame</code> or <code>SpatialPointsDataFrame</code> object, returns <code>sf</code> object with same geometries and columns as <code>input</code>, appended with additional column containing Local G estimates (<code>LocalG</code>). If <code>input</code> is <code>RasterLayer</code> object, returns <code>RasterBrick</code> object containing original values (<code>Original</code>) and Local G estimates (<code>LocalG</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate Local G for sf point layer

## Not run: 
data(clea_deu2009_pt)
out_1 &lt;- hot_spot(insert=clea_deu2009_pt, variable = clea_deu2009_pt$to1)
class(out_1)
plot(out_1["LocalG"])

## End(Not run)

# Calculate Local G for sf polygon layer (variable as numeric vector)

## Not run: 
data(clea_deu2009)
out_2 &lt;- hot_spot(insert=clea_deu2009, variable = clea_deu2009$to1)
summary(out_2$LocalG)
plot(out_2["LocalG"])

## End(Not run)

# Calculate Local G for sf polygon layer (variable as column name)

## Not run: 
out_3 &lt;- hot_spot(insert=clea_deu2009, variable = "to1")
summary(out_3$LocalG)
plot(out_3["LocalG"])

## End(Not run)

# Calculate Local G for sf polygon SpatialPolygonsDataFrame (variable as column name)

## Not run: 
out_4 &lt;- hot_spot(insert=as(clea_deu2009,"Spatial"), variable = "to1")
summary(out_4$LocalG)
plot(out_4["LocalG"])

## End(Not run)

# Calculate Local G for RasterLayer
## Not run: 
data(gpw4_deu2010)
out_5 &lt;- hot_spot(insert=gpw4_deu2010)
class(out_5)
terra::plot(out_5$LocalG)

## End(Not run)
</code></pre>

<hr>
<h2 id='line2poly'>Line-in-polygon analysis</h2><span id='topic+line2poly'></span>

<h3>Description</h3>

<p>Function for basic geometry calculations on polyline features, within an overlapping destination polygon layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line2poly(
  linez,
  polyz,
  poly_id,
  measurez = c("length", "density", "distance"),
  outvar_name = "line",
  unitz = "km",
  reproject = TRUE,
  na_val = NA,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="line2poly_+3A_linez">linez</code></td>
<td>
<p>Source polyline layer. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="line2poly_+3A_polyz">polyz</code></td>
<td>
<p>Destination polygon layer. Must have identical CRS to <code>linez</code>. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="line2poly_+3A_poly_id">poly_id</code></td>
<td>
<p>Name of unique ID column for destination polygon layer. Character string.</p>
</td></tr>
<tr><td><code id="line2poly_+3A_measurez">measurez</code></td>
<td>
<p>Desired measurements. Could be any of &quot;length&quot; (sum of line lengths by polygon), &quot;density&quot; (sum of line lengths divided by area of polygon) and/or &quot;distance&quot; (distance from each polygon to nearest line feature). Default is to report all three. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="line2poly_+3A_outvar_name">outvar_name</code></td>
<td>
<p>Name (root) to be given to output variable. Default is <code>"line"</code>. Character string.</p>
</td></tr>
<tr><td><code id="line2poly_+3A_unitz">unitz</code></td>
<td>
<p>Units of measurement (linear). Defaul is <code>"km"</code>. Character string.</p>
</td></tr>
<tr><td><code id="line2poly_+3A_reproject">reproject</code></td>
<td>
<p>Temporarily reproject layers to planar projection for geometric operations? Defaul is <code>TRUE</code>. Logical.</p>
</td></tr>
<tr><td><code id="line2poly_+3A_na_val">na_val</code></td>
<td>
<p>Value to be assigned to missing values (line lengths and densities only). Defaul is <code>NA</code>. Logical or list.</p>
</td></tr>
<tr><td><code id="line2poly_+3A_verbose">verbose</code></td>
<td>
<p>Print status messages and progress? Default is <code>TRUE</code>. Logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> polygon object, with summary statisics of <code>linez</code> features aggregated to the geometries of <code>polyz</code>.
</p>
<p>If <code>measurez = "lengths"</code>, contains fields with suffixes
</p>

<ul>
<li><p> &quot;<code>_length</code>&quot;. Sum of line lengths within each polygon, in km or other units supplied in <code>unitz</code>.
</p>
</li></ul>

<p>If <code>measurez = "density"</code>, contains fields with suffixes
</p>

<ul>
<li><p> &quot;<code>_length</code>&quot;. Sum of line lengths within each polygon, in km or other units supplied in <code>unitz</code>.
</p>
</li>
<li><p> &quot;<code>_area</code>&quot;. Area of each polygon, in km^2 or the square of linear units supplied in <code>unitz</code>.
</p>
</li>
<li><p> &quot;<code>_density</code>&quot;. Sum of line lengths divided by area of each polygon, in km/km^2 or other units supplied in <code>unitz</code>.
</p>
</li></ul>

<p>If <code>measurez = "distance"</code>, contains fields with suffixes
</p>

<ul>
<li><p> &quot;<code>_distance</code>&quot;. Distance from each polygon to nearest line feature, in km or other units supplied in <code>unitz</code>.
</p>
</li></ul>

<p>If <code>measurez = c("length","density","distance")</code> (default), contains all of the above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Road lengths, densities and distance from polygon to nearest highway
## Not run: 
data(hex_05_deu)
data(highways_deu1992)
out_1 &lt;- line2poly(linez = highways_deu1992,
                   polyz = hex_05_deu,
                   poly_id = "HEX_ID")
plot(out_1["line_length"])
plot(out_1["line_density"])
plot(out_1["line_distance"])

## End(Not run)

# Replace missing road lengths and densities with 0's, rename variables
## Not run: 
out_2 &lt;- line2poly(linez = highways_deu1992,
                   polyz = hex_05_deu,
                   poly_id = "HEX_ID",
                   outvar_name = "road",
                   na_val = 0)
plot(out_2["road_length"])
plot(out_2["road_density"])
plot(out_2["road_distance"])

## End(Not run)
</code></pre>

<hr>
<h2 id='make_ticker'>Make date ticker</h2><span id='topic+make_ticker'></span>

<h3>Description</h3>

<p>Function to create a table of consecutive dates, in SUNGEO-compliant format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ticker(
  date_min = 19000101,
  date_max = as.integer(gsub("-", "", as.Date(Sys.Date())))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_ticker_+3A_date_min">date_min</code></td>
<td>
<p>Start date, in YYYYMMDD format. Default is <code>19000101</code>. Integer.</p>
</td></tr>
<tr><td><code id="make_ticker_+3A_date_max">date_max</code></td>
<td>
<p>End date, in YYYYMMDD format. Default is today. Integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.table</code> object, with seven columns:
</p>

<ul>
<li> <p><code>DATE</code>. Date in YYYYMMDD format. Integer.
</p>
</li>
<li> <p><code>DATE_ALT</code>. Date in <code>Date</code> (YYYY-MM-DD) format. Date.
</p>
</li>
<li> <p><code>TID</code>. Date ID, in consecutive integer format. Integer.
</p>
</li>
<li> <p><code>YRWK</code>. Week in YYYYWW format. Integer.
</p>
</li>
<li> <p><code>WID</code>. Weed ID, in consecutive integer format. Integer.
</p>
</li>
<li> <p><code>YRMO</code>. Month in YYYYMM format. Integer.
</p>
</li>
<li> <p><code>MID</code>. Month ID, in consecutive integer format. Integer.
</p>
</li>
<li> <p><code>YEAR</code>. Year in YYYY format. Integer.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># All dates from January 1, 1900 to today
## Not run: 
out_1 &lt;- make_ticker()
out_1

## End(Not run)

# All dates from January 1, 1200 to today
## Not run: 
out_2 &lt;- make_ticker(date_min=12000101)
out_2

## End(Not run)
 
# All dates from January 1, 1500 to December 31, 1899
## Not run: 
out_3 &lt;- make_ticker(date_min=15000101, date_max=18991231)
out_3

## End(Not run)
</code></pre>

<hr>
<h2 id='merge_list'>Merge list of tables on common variable(s)</h2><span id='topic+merge_list'></span>

<h3>Description</h3>

<p>Function that finds a set of common columns in a list of tables, and merges the tables on these columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_list(lst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_list_+3A_lst">lst</code></td>
<td>
<p>List of tables to be merged. List object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.table</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Merge list of three tables with different common variables
## Not run: 
A &lt;- data.table::data.table(month=month.name,year=rep(1991:1992,each=12),A=rnorm(24))
B &lt;- data.table::data.table(year=c(1991,1992),B=rbeta(2,1,1))
C &lt;- data.table::data.table(month=month.name,C=runif(12))

out_1 &lt;- merge_list(list(A,B,C))
out_1

## End(Not run)

</code></pre>

<hr>
<h2 id='nesting'>Relative scale and nesting coefficients</h2><span id='topic+nesting'></span>

<h3>Description</h3>

<p>Function to calculate relative scale and nesting metrics for changes of support from a source polygon layer to an overlapping (but spatially misaligned) destination polygon layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nesting(
  poly_from = NULL,
  poly_to = NULL,
  metrix = "all",
  tol_ = 0.001,
  by_unit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nesting_+3A_poly_from">poly_from</code></td>
<td>
<p>Source polygon layer. <code>sf</code> object (polygon or multipolygon).</p>
</td></tr>
<tr><td><code id="nesting_+3A_poly_to">poly_to</code></td>
<td>
<p>Destination polygon layer. Must have identical CRS to <code>poly_from</code>. <code>sf</code> object (polygon or multipolygon).</p>
</td></tr>
<tr><td><code id="nesting_+3A_metrix">metrix</code></td>
<td>
<p>Requested scaling and nesting metrics. See &quot;details&quot;. Default is &quot;all&quot;. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="nesting_+3A_tol_">tol_</code></td>
<td>
<p>Minimum area of polygon intersection, in square meters. Default is 0.001. Numeric.</p>
</td></tr>
<tr><td><code id="nesting_+3A_by_unit">by_unit</code></td>
<td>
<p>Include a by-unit decomposition of requested nesting metrics (if available)? Default is FALSE. Logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supported metrics (<code>metrix</code>) include:
</p>

<ul>
<li><p> Relative scale (&quot;rs&quot;). Measures whether a change-of-support (CoS) task is one of aggregation or disaggregation, by calculating the share of source units that are smaller than destination units. Its range is from 0 to 1, where values of 1 indicate pure aggregation (all source units are smaller than destination units) and values of 0 indicate no aggregation (all source units are at least as large as destination units). Values between 0 and 1 indicate a hybrid (i.e. some source units are smaller, others are larger than target units).
</p>
</li>
<li><p> Relative nesting (&quot;rn&quot;). Measures how closely source and destination boundaries align, by calculating the share of source units that cannot be split across multiple destination units. Its range is from 0 to 1, where values of 0 indicate no nesting (every source unit can be split across multiple destination units) and values of 1 indicate full nesting (no source unit can be split across multiple destination units).
</p>
</li>
<li><p> Relative scale, symmetric (&quot;rs_sym&quot;). Alternative measure of &quot;rs&quot;, which ranges from -1 to 1. It calculates a difference between two proportions: the share of source units that is smaller than destination units (i.e. &quot;rs&quot; from standpoint of source units), and the share that is larger (i.e. &quot;rs&quot; from standpoint of destination units). Values of -1 indicate pure disaggregation (all source units are larger than destination units), 1 indicates pure aggregation (all source units are smaller than destination units). Values of 0 indicate that all source units are the same size as target units.
</p>
</li>
<li><p> Relative nesting, symmetric (&quot;rn_sym&quot;). Alternative measure of &quot;rn&quot;, which ranges from -1 to 1. It calculates a difference between two components: the nesting of source units within destination units (i.e. &quot;rn&quot; from standpoint of source units), and the nesting of destination units within source units (i.e. &quot;rn&quot; from standpoint of destination units. Values of 1 indicate that source units are perfectly nested within destination units; -1 indicates that destination units are perfectly nested within source units.
</p>
</li>
<li><p> Relative scale, alternative (&quot;rs_alt&quot;). Alternative measure of &quot;rs&quot;, rescaled as a proportion of destination unit area. This measure can take any value on the real line, with positive values indicating aggregation and negative values indicating disaggregation.
</p>
</li>
<li><p> Relative nesting, alternative (&quot;rn_alt&quot;). Alternative measure of &quot;rn&quot;, which places more weight on areas of maximum overlap. The main difference between this measure and &quot;rn&quot; is its use of the maximum intersection area for each source polygon instead of averaging over the quadratic term. Two sets of polygons are considered nested if one set is completely contained within another, with as few splits as possible. If none or only a sliver of a source polygon area falls outside a single destination polygon, those polygons are &quot;more nested&quot; than a case where half of a source polygon falls in destination polygon A and half falls into another polygon B.
</p>
</li>
<li><p> Relative scale, conditional (&quot;rs_nn&quot;). Alternative measure of &quot;rs&quot;, calculated for the subset of source units that are not fully nested within destination units.
</p>
</li>
<li><p> Relative nesting, conditional (&quot;rn_nn&quot;). Alternative measure of &quot;rn&quot;, calculated for the subset of source units that are not fully nested within destination units.
</p>
</li>
<li><p> Proportion intact (&quot;p_intact&quot;). A nesting metric that requires no area calculations at all. This measure ranges from 0 to 1, where 1 indicates full nesting (i.e. every source unit is intact/no splits), and 0 indicates no nesting (i.e. no source unit is intact/all are split).
</p>
</li>
<li><p> Proportion fully nested (&quot;full_nest&quot;). A stricter version of &quot;p_intact&quot;. This measure ranges from 0 to 1, where 1 indicates full nesting (i.e. every source unit is intact/no splits AND falls completely inside the destination layer), and 0 indicates no nesting (i.e. no source unit is both intact and falls inside destination layer).
</p>
</li>
<li><p> Relative overlap (&quot;ro&quot;). Assesses extent of spatial overlap between source and destination polygons. This measure is scaled between -1 and 1. Values of 0 indicate perfect overlap (there is no part of source units that fall outside of destination units, and vice versa). Values between 0 and 1 indicate a &quot;source underlap&quot; (some parts of source polygons fall outside of destination polygons; more precisely, a larger part of source polygon area falls outside destination polygons than the other way around). Values between -1 and 0 indicate a &quot;destination underlap&quot; (some parts of destination polygons fall outside of source polygons; a larger part of destination polygon area falls outside source polygons than the other way around). Values of -1 and 1 indicate no overlap (all source units fall outside destination units, and vice versa). This is a theoretical limit only; the function returns an error if there is no overlap.
</p>
</li>
<li><p> Gibbs-Martin index of diversification (&quot;gmi&quot;). Inverse of &quot;rn&quot;, where values of 1 indicate that every source unit is evenly split across multiple destination units, and 0 indicates that no source unit is split across any destination units.
</p>
</li></ul>

<p>It is possible to pass multiple arguments to <code>metrix</code> (e.g. <code>metrix=c("rn","rs")</code>). The default (<code>metrix="all"</code>) returns all of the above metrics.
</p>
<p>The function automatically reprojects source and destination geometries to Lambert Equal Area prior to calculation, with map units in meters.
</p>
<p>Values of <code>tol_</code> can be adjusted to increase or decrease the sensitivity of these metrics to small border misalignments. The default value discards polygon intersections smaller than 0.001 square meters in area.
</p>


<h3>Value</h3>

<p>Named list, with numeric values for each requested metric in <code>metrix</code>. If <code>by_unit==TRUE</code>, last element of list is a data.table, with nesting metrics disaggregated by source unit, where the first column is a row index for the source polygon layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate all scale and nesting metrics for two sets of polygons
## Not run: 
data(clea_deu2009)
data(hex_05_deu)
nest_1 &lt;- nesting(
              poly_from = clea_deu2009,
              poly_to = hex_05_deu
              )
nest_1

## End(Not run)

# Calculate just Relative Nesting, in the opposite direction
## Not run: 
nest_2 &lt;- nesting(
              poly_from = hex_05_deu,
              poly_to = clea_deu2009,
              metrix = "rn"
              )
nest_2

## End(Not run)
</code></pre>

<hr>
<h2 id='point2poly_krige'>Point-to-polygon interpolation, ordinary and universal Kriging method</h2><span id='topic+point2poly_krige'></span>

<h3>Description</h3>

<p>Function for interpolating values from a source points layer to an overlapping destination polygon layer, using ordinary and universal kriging with automatic variogram fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point2poly_krige(
  pointz,
  polyz,
  rasterz = NULL,
  yvarz = NULL,
  xvarz = NULL,
  pycno_yvarz = NULL,
  funz = base::mean,
  use_grid = FALSE,
  nz_grid = 25,
  blockz = 0,
  pointz_x_coord = NULL,
  pointz_y_coord = NULL,
  polyz_x_coord = NULL,
  polyz_y_coord = NULL,
  messagez = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point2poly_krige_+3A_pointz">pointz</code></td>
<td>
<p>Source points layer. <code>sf</code>, <code>sp</code>, or data frame object.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_polyz">polyz</code></td>
<td>
<p>Destination polygon layer. Must have identical CRS to <code>pointz</code>. <code>sf</code>, <code>sp</code>, or data frame object.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_rasterz">rasterz</code></td>
<td>
<p>Source raster layer (or list of raster), with covariate(s) used for universal kriging. Must have identical CRS to <code>polyz</code>.  <code>RasterLayer</code> object or list of <code>RasterLayer</code> objects.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_yvarz">yvarz</code></td>
<td>
<p>Names of numeric variable(s) to be interpolated from source points layer to destination polygons. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_xvarz">xvarz</code></td>
<td>
<p>Names of numeric variable(s) for universal Kriging, in which yvarz is linearly dependent. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_pycno_yvarz">pycno_yvarz</code></td>
<td>
<p>Names of spatially extensive numeric variables for which the pycnophylactic (mass-preserving) property should be preserved. Must be a subset of <code>yvarz</code>. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_funz">funz</code></td>
<td>
<p>Aggregation function to be applied to values in <code>rasterz</code> and to interpolated values. Must take as an input a vector <code>x</code>. Default is mean.  Function.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_use_grid">use_grid</code></td>
<td>
<p>Use regular grid as destination layer for interpolation, before aggregating to polygons? Default is FALSE.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_nz_grid">nz_grid</code></td>
<td>
<p>Number of grid cells in x and y direction (columns, rows). Integer of length 1 or 2. Default is 25. Ignored if use_grid=FALSE.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_blockz">blockz</code></td>
<td>
<p>Size of blocks used for Block Kriging, in meters. Integer of length 1 or 2. Default is 0.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_pointz_x_coord">pointz_x_coord</code></td>
<td>
<p>Name of numeric variable corresponding to a measure of longitude (Easting) in a data frame object for <code>pointz</code>. Character string.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_pointz_y_coord">pointz_y_coord</code></td>
<td>
<p>Name of numeric variable corresponding to a measure of Latitude (Northing) in a data frame object for <code>pointz</code>. Character string.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_polyz_x_coord">polyz_x_coord</code></td>
<td>
<p>Name of numeric variable corresponding to a measure of longitude (Easting) in a data frame object for <code>polyz</code>. Character string.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_polyz_y_coord">polyz_y_coord</code></td>
<td>
<p>Name of numeric variable corresponding to a measure of Latitude (Northing) in a data frame object for <code>polyz</code>. Character string.</p>
</td></tr>
<tr><td><code id="point2poly_krige_+3A_messagez">messagez</code></td>
<td>
<p>Optional message to be printed during Kriging estimation. Character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs Ordinary and Universal Kriging, automatically selecting a variogram model with the smallest residual sum of squares from the sample variogram. See <a href="automap.html#topic+autofitVariogram">autofitVariogram</a>.
</p>
<p>Unlike other available point-to-polygon interpolation techniques, this function currently only accepts numeric variables in <code>varz</code> and does not support interpolation of character strings.
</p>


<h3>Value</h3>

<p><code>sf</code> polygon object, with variables from <code>pointz</code> interpolated to the geometries of <code>polyz</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ordinary Kriging with one variable
## Not run: 
data(clea_deu2009)
data(clea_deu2009_pt)
out_1 &lt;- point2poly_krige(pointz = clea_deu2009_pt,
                         polyz = clea_deu2009,
                         yvarz = "to1")
par(mfrow=c(1,2))
plot(clea_deu2009["to1"], key.pos = NULL, reset = FALSE)
plot(out_1["to1.pred"], key.pos = NULL, reset = FALSE)

## End(Not run)

# Ordinary Kriging with multiple variables
## Not run: 
out_2 &lt;- point2poly_krige(pointz = clea_deu2009_pt,
                         polyz = clea_deu2009,
                         yvarz = c("to1","pvs1_margin"))
par(mfrow=c(1,2))
plot(clea_deu2009["pvs1_margin"], key.pos = NULL, reset = FALSE)
plot(out_2["pvs1_margin.pred"], key.pos = NULL, reset = FALSE)

## End(Not run)

# Universal Kriging with one variable from a raster
## Not run: 
data(gpw4_deu2010)
data(clea_deu2009)
data(clea_deu2009_pt)
out_3 &lt;- point2poly_krige(pointz = clea_deu2009_pt,
                         polyz = clea_deu2009,
                         yvarz = "to1",
                         rasterz = gpw4_deu2010)
par(mfrow=c(1,2))
plot(clea_deu2009["to1"], key.pos = NULL, reset = FALSE)
plot(out_3["to1.pred"], key.pos = NULL, reset = FALSE)

## End(Not run)

# Block Kriging with block size of 100 km
## Not run: 
data(clea_deu2009)
data(clea_deu2009_pt)
out_4 &lt;- point2poly_krige(pointz = clea_deu2009_pt,
                         polyz = clea_deu2009,
                         yvarz = "to1",
                         blockz = 100000)
par(mfrow=c(1,2))
plot(clea_deu2009["to1"], key.pos = NULL, reset = FALSE)
plot(out_4["to1.pred"], key.pos = NULL, reset = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='point2poly_simp'>Point-to-polygon interpolation, simple overlay method</h2><span id='topic+point2poly_simp'></span>

<h3>Description</h3>

<p>Function for assigning values from a source point layer to a destination polygon layer, using simple point-in-polygon overlays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point2poly_simp(
  pointz,
  polyz,
  varz,
  char_varz = NULL,
  funz = list(function(x) {
     sum(x, na.rm = TRUE)
 }),
  na_val = NA,
  drop_na_cols = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point2poly_simp_+3A_pointz">pointz</code></td>
<td>
<p>Source points layer. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="point2poly_simp_+3A_polyz">polyz</code></td>
<td>
<p>Destination polygon layer. Must have identical CRS to <code>pointz</code>. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="point2poly_simp_+3A_varz">varz</code></td>
<td>
<p>Names of variable(s) to be assigned from source polygon layer to destination polygons. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_simp_+3A_char_varz">char_varz</code></td>
<td>
<p>Names of character string variable(s) in <code>varz</code>. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_simp_+3A_funz">funz</code></td>
<td>
<p>Aggregation function to be applied to variables specified in <code>varz</code>. Must take as an input a vector <code>x</code>. Function or list of functions.</p>
</td></tr>
<tr><td><code id="point2poly_simp_+3A_na_val">na_val</code></td>
<td>
<p>Value to be assigned to missing values. Defaul is <code>NA</code>. Logical or list.</p>
</td></tr>
<tr><td><code id="point2poly_simp_+3A_drop_na_cols">drop_na_cols</code></td>
<td>
<p>Drop columns with completely missing values. Defaul is <code>FALSE</code>. Logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assignment procedures are the same for numeric and character string variables. All variables supplied in <code>varz</code> are passed directly to the function specified in <code>funz</code>. If different sets of variables are to be aggregated with different functions, both <code>varz</code> and <code>funz</code> should be specified as lists (see examples below).
</p>


<h3>Value</h3>

<p>Returns a <code>sf</code> polygon object, with variables from <code>pointz</code> assigned to the geometries of <code>polyz</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assignment of a single variable (sums)
## Not run: 
data(hex_05_deu)
data(clea_deu2009_pt)
out_1 &lt;- point2poly_simp(pointz=clea_deu2009_pt,
                         polyz=hex_05_deu,
                         varz="vv1")
plot(out_1["vv1"])

## End(Not run)

# Replace NA's with 0's
## Not run: 
out_2 &lt;- point2poly_simp(pointz = clea_deu2009_pt,
                         polyz = hex_05_deu,
                         varz = "vv1",
                         na_val = 0)
plot(out_2["vv1"])

## End(Not run)

# Multiple variables, with different assignment functions
## Not run: 
out_3 &lt;- point2poly_simp(pointz = clea_deu2009_pt,
                         polyz = hex_05_deu,
                         varz = list(
                           c("to1","pvs1_margin"),
                           c("vv1"),
                           c("incumb_pty_n","win1_pty_n")),
                         funz = list(
                           function(x){mean(x,na.rm=TRUE)},
                           function(x){sum(x,na.rm=TRUE)},
                           function(x){paste0(unique(na.omit(x)),collapse=" | ") }),
                         na_val = list(NA_real_,0,NA_character_))

## End(Not run)
</code></pre>

<hr>
<h2 id='point2poly_tess'>Point-to-polygon interpolation, tessellation method</h2><span id='topic+point2poly_tess'></span>

<h3>Description</h3>

<p>Function for interpolating values from a source point layer to a destination polygon layer, using Voronoi tessellation and area/population weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point2poly_tess(
  pointz,
  polyz,
  poly_id,
  char_methodz = "aw",
  methodz = "aw",
  pop_raster = NULL,
  varz = NULL,
  pycno_varz = NULL,
  char_varz = NULL,
  char_assign = "biggest_overlap",
  funz = function(x, w) {
     stats::weighted.mean(x, w, na.rm = TRUE)
 },
  return_tess = FALSE,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point2poly_tess_+3A_pointz">pointz</code></td>
<td>
<p>Source points layer. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_polyz">polyz</code></td>
<td>
<p>Destination polygon layer. Must have identical CRS to <code>pointz</code>. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_poly_id">poly_id</code></td>
<td>
<p>Name of unique ID column for destination polygon layer. Character string.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_char_methodz">char_methodz</code></td>
<td>
<p>Interpolation method(s) for character strings. Could be either of &quot;aw&quot; (areal weighting, default) or &quot;pw&quot; (population weighting). See &quot;details&quot;. Character string.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_methodz">methodz</code></td>
<td>
<p>Interpolation method(s) for numeric covariates. Could be either of &quot;aw&quot; (areal weighting, default) and/or &quot;pw&quot; (population weighting). See &quot;details&quot;. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_pop_raster">pop_raster</code></td>
<td>
<p>Population raster to be used for population weighting, Must be supplied if <code>methodz="pw"</code>. Must have identical CRS to <code>poly_from</code>. <code>raster</code> or <code>SpatRaster</code> object.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_varz">varz</code></td>
<td>
<p>Names of numeric variable(s) to be interpolated from source polygon layer to destination polygons. Character string or list of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_pycno_varz">pycno_varz</code></td>
<td>
<p>Names of spatially extensive numeric variables for which the pycnophylactic (mass-preserving) property should be preserved. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_char_varz">char_varz</code></td>
<td>
<p>Names of character string variables to be interpolated from source polygon layer to destination polygons. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_char_assign">char_assign</code></td>
<td>
<p>Assignment rule to be used for variables specified in <code>char_varz</code>. Could be either &quot;biggest_overlap&quot; (default) or &quot;all_overlap&quot;. See &quot;details&quot;. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_funz">funz</code></td>
<td>
<p>Aggregation function to be applied to variables specified in <code>varz</code>. Must take as an input a numeric vector <code>x</code> and vector of weights <code>w</code>. Function or list of functions.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_return_tess">return_tess</code></td>
<td>
<p>Return Voronoi polygons, in addition to destinaton polygon layer? Default is <code>FALSE</code>. Logical.</p>
</td></tr>
<tr><td><code id="point2poly_tess_+3A_seed">seed</code></td>
<td>
<p>Seed for generation of random numbers. Default is 1. Numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function interpolates point data to polygons with a two-step process. In the first step (tessellation), each point is assigned a Voronoi cell, drawn such that (a) the distance from its borders to the focal point is less than or equal to the distance to any other point, and (b) no gaps between cells remain. The second step (interpolation) performs a polygon-in-polygon interpolation, using the Voronoi cells as source polygons.
</p>
<p>Currently supported integration methods in the second step (<code>methodz</code>) include:
</p>

<ul>
<li><p> Areal weighting (&quot;aw&quot;). Values from <code>poly_from</code> weighted in proportion to relative area of spatial overlap between source features and geometries of <code>poly_to</code>.
</p>
</li>
<li><p> Population weighting (&quot;pw&quot;). Values from <code>poly_from</code> weighted in proportion to relative population sizes in areas of spatial overlap between source features and geometries of <code>poly_to</code>. This routine uses a third layer (supplied in <code>pop_raster</code>) to calculate the weights.
</p>
</li></ul>

<p>When a list of variables are supplied and one methods argument specified, then the chosen method will be applied to all variables.
</p>
<p>When a list of of variables are supplied and multiple methods arguments specified, then weighting methods will be applied in a pairwise order. For example, specifying <code>varz = list(c("to1","pvs1_margin"), c("vv1"))</code> and <code>methodz = c('aw', 'pw')</code> will apply areal weighting to the the first set of variables (to1 and pvs1_margin) and population weighing to the second set (vv1).
</p>
<p>Interpolation procedures are handled somewhat differently for numeric and character string variables. For numeric variables supplied in <code>varz</code>, &quot;aw&quot; and/or &quot;pw&quot; weights are passed to the function specified in <code>funz</code>. If different sets of numeric variables are to be aggregated with different functions, both <code>varz</code> and <code>funz</code> should be specified as lists (see examples below).
</p>
<p>For character string (and any other) variables supplied in <code>char_varz</code>, &quot;aw&quot; and/or &quot;pw&quot; weights are passed to the assignment rule(s) specified in <code>char_assign</code>. Note that the <code>char_varz</code> argument may include numerical variables, but <code>varz</code> cannot include character string variables.
</p>
<p>Currently supported assignment rules for character strings (<code>char_assign</code>) include:
</p>

<ul>
<li><p> &quot;biggest_overlap&quot;. For each variable in <code>char_varz</code>, the features in <code>poly_to</code> are assigned a single value from overlapping <code>poly_from</code> features, corresponding to the intersection with largest area and/or population weight.
</p>
</li>
<li><p> &quot;all_overlap&quot;. For each variable in <code>char_varz</code>, the features in <code>poly_to</code> are assigned all values from overlapping <code>poly_from</code> features, ranked by area and/or population weights (largest-to-smallest) of intersections.
</p>
</li></ul>

<p>It is possible to pass multiple arguments to <code>char_assign</code> (e.g. <code>char_assign=c("biggest_overlap","all_overlap")</code>), in which case the function will calculate both, and append the resulting columns to the output.
</p>


<h3>Value</h3>

<p>If <code>return_tess=FALSE</code>, returns a <code>sf</code> polygon object, with variables from <code>pointz</code> interpolated to the geometries of <code>polyz</code>.
</p>
<p>If <code>return_tess=TRUE</code>, returns a list, containing
</p>

<ul>
<li><p> &quot;result&quot;. The destination polygon layer. <code>sf</code> object.
</p>
</li>
<li><p> &quot;tess&quot;. The (intermediate) Voronoi tessellation polygon layer. <code>sf</code> object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Interpolation of a single variable, with area weights
## Not run: 
data(hex_05_deu)
data(clea_deu2009_pt)
out_1 &lt;- point2poly_tess(pointz = clea_deu2009_pt,
                             polyz = hex_05_deu,
                             poly_id = "HEX_ID",
                             varz = "to1")
plot(out_1["to1_aw"])

## End(Not run)

# Extract and inspect tessellation polygons
## Not run: 
out_2 &lt;- point2poly_tess(pointz = clea_deu2009_pt,
                             polyz = hex_05_deu,
                             poly_id = "HEX_ID",
                             varz = "to1",
                             return_tess = TRUE)
plot(out_2$tess["to1"])
plot(out_2$result["to1_aw"])

## End(Not run)

# Interpolation of multiple variables, with area and population weights
## Not run: 
data(gpw4_deu2010)
out_3 &lt;- point2poly_tess(pointz = clea_deu2009_pt,
                         polyz = hex_05_deu,
                         poly_id = "HEX_ID",
                         methodz = c("aw","pw"),
                         varz = list(
                           c("to1","pvs1_margin"),
                           c("vv1")
                         ),
                         pycno_varz = "vv1",
                         funz = list(
                           function(x,w){stats::weighted.mean(x,w)},
                           function(x,w){sum(x*w)}
                           ),
                         char_varz = c("incumb_pty_n","win1_pty_n"),
                         pop_raster = gpw4_deu2010)
plot(out_3["vv1_pw"])

## End(Not run)
</code></pre>

<hr>
<h2 id='poly2poly_ap'>Area and population weighted polygon-to-polygon interpolation</h2><span id='topic+poly2poly_ap'></span>

<h3>Description</h3>

<p>Function for interpolating values from a source polygon layer to an overlapping (but spatially misaligned) destination polygon layer, using area and/or population weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly2poly_ap(
  poly_from,
  poly_to,
  poly_to_id,
  geo_vor = NULL,
  methodz = "aw",
  char_methodz = "aw",
  pop_raster = NULL,
  varz = NULL,
  pycno_varz = NULL,
  char_varz = NULL,
  char_assign = "biggest_overlap",
  funz = function(x, w) {
     stats::weighted.mean(x, w, na.rm = TRUE)
 },
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poly2poly_ap_+3A_poly_from">poly_from</code></td>
<td>
<p>Source polygon layer. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_poly_to">poly_to</code></td>
<td>
<p>Destination polygon layer. Must have identical CRS to <code>poly_from</code>. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_poly_to_id">poly_to_id</code></td>
<td>
<p>Name of unique ID column for destination polygon layer. Character string.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_geo_vor">geo_vor</code></td>
<td>
<p>Voronoi polygons object (used internally by <code>point2poly_tess</code>). <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_methodz">methodz</code></td>
<td>
<p>Area interpolation method(s). Could be either of &quot;aw&quot; (areal weighting, default) and/or &quot;pw&quot; (population weighting). See &quot;details&quot;. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_char_methodz">char_methodz</code></td>
<td>
<p>Interpolation method(s) for character strings. Could be either of &quot;aw&quot; (areal weighting, default) or &quot;pw&quot; (population weighting). See &quot;details&quot;. Character string.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_pop_raster">pop_raster</code></td>
<td>
<p>Population raster to be used for population weighting, Must be supplied if <code>methodz="pw"</code>. Must have identical CRS to <code>poly_from</code>. <code>raster</code> or <code>SpatRaster</code> object.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_varz">varz</code></td>
<td>
<p>Names of numeric variable(s) to be interpolated from source polygon layer to destination polygons. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_pycno_varz">pycno_varz</code></td>
<td>
<p>Names of spatially extensive numeric variables for which the pycnophylactic (mass-preserving) property should be preserved. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_char_varz">char_varz</code></td>
<td>
<p>Names of character string variables to be interpolated from source polygon layer to destination polygons. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_char_assign">char_assign</code></td>
<td>
<p>Assignment rule to be used for variables specified in <code>char_varz</code>. Could be either &quot;biggest_overlap&quot; (default) or &quot;all_overlap&quot;. See &quot;details&quot;. Character string or vector of character strings.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_funz">funz</code></td>
<td>
<p>Aggregation function to be applied to variables specified in <code>varz</code>. Must take as an input a numeric vector <code>x</code> and vector of weights <code>w</code>. Function or list of functions.</p>
</td></tr>
<tr><td><code id="poly2poly_ap_+3A_seed">seed</code></td>
<td>
<p>Seed for generation of random numbers. Default is 1. Numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supported integration methods (<code>methodz</code>) include:
</p>

<ul>
<li><p> Areal weighting (&quot;aw&quot;). Values from <code>poly_from</code> weighted in proportion to relative area of spatial overlap between source features and geometries of <code>poly_to</code>.
</p>
</li>
<li><p> Population weighting (&quot;pw&quot;). Values from <code>poly_from</code> weighted in proportion to relative population sizes in areas of spatial overlap between source features and geometries of <code>poly_to</code>. This routine uses a third layer (supplied in <code>pop_raster</code>) to calculate the weights.
</p>
</li></ul>

<p>It is possible to pass multiple arguments to <code>methodz</code> (e.g. <code>methodz=c("aw","pw")</code>), in which case the function will calculate both sets of weights, and append the resulting columns to the output.
</p>
<p>Interpolation procedures are handled somewhat differently for numeric and character string variables. For numeric variables supplied in <code>varz</code>, &quot;aw&quot; and/or &quot;pw&quot; weights are passed to the function specified in <code>funz</code>. If different sets of numeric variables are to be aggregated with different functions, both <code>varz</code> and <code>funz</code> should be specified as lists (see examples below).
</p>
<p>For character string (and any other) variables supplied in <code>char_varz</code>, &quot;aw&quot; and/or &quot;pw&quot; weights are passed to the assignment rule(s) specified in <code>char_assign</code>. Note that the <code>char_varz</code> argument may include numerical variables, but <code>varz</code> cannot include character string variables.
</p>
<p>Currently supported assignment rules for character strings (<code>char_assign</code>) include:
</p>

<ul>
<li><p> &quot;biggest_overlap&quot;. For each variable in <code>char_varz</code>, the features in <code>poly_to</code> are assigned a single value from overlapping <code>poly_from</code> features, corresponding to the intersection with largest area and/or population weight.
</p>
</li>
<li><p> &quot;all_overlap&quot;. For each variable in <code>char_varz</code>, the features in <code>poly_to</code> are assigned all values from overlapping <code>poly_from</code> features, ranked by area and/or population weights (largest-to-smallest) of intersections.
</p>
</li></ul>

<p>It is possible to pass multiple arguments to <code>char_assign</code> (e.g. <code>char_assign=c("biggest_overlap","all_overlap")</code>), in which case the function will calculate both, and append the resulting columns to the output.
</p>


<h3>Value</h3>

<p><code>sf</code> polygon object, with variables from <code>poly_from</code> interpolated to the geometries of <code>poly_to</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interpolation of a single variable, with area weights
## Not run: 
data(clea_deu2009)
data(hex_05_deu)
out_1 &lt;- poly2poly_ap(poly_from = clea_deu2009,
              poly_to = hex_05_deu,
              poly_to_id = "HEX_ID",
              varz = "to1"
             )

## End(Not run)

# Interpolation of multiple variables, with area weights
## Not run: 
out_2 &lt;- poly2poly_ap(
              poly_from = clea_deu2009,
              poly_to = hex_05_deu,
              poly_to_id = "HEX_ID",
              varz = list(
                c("to1","pvs1_margin"),
                c("vv1") ),
              pycno_varz = "vv1",
              funz = list(
                function(x,w){stats::weighted.mean(x,w)},
                function(x,w){sum(x*w)} ),
              char_varz = c("incumb_pty_n","win1_pty_n")
             )

## End(Not run)

# Interpolation of a single variable, with population weights
## Not run: 
data(gpw4_deu2010)
out_3 &lt;- poly2poly_ap(poly_from = clea_deu2009,
                         poly_to = hex_05_deu,
                         poly_to_id = "HEX_ID",
                         varz = "to1",
                         methodz = "pw",
                         pop_raster = gpw4_deu2010)

## End(Not run)

# Interpolation of a single variable, with area and population weights
## Not run: 
out_4 &lt;- poly2poly_ap(poly_from = clea_deu2009,
                         poly_to = hex_05_deu,
                         poly_to_id = "HEX_ID",
                         varz = "to1",
                         methodz = c("aw","pw"),
                         pop_raster = gpw4_deu2010)

## End(Not run)
</code></pre>

<hr>
<h2 id='sf2raster'>Convert simple features object into regularly spaced raster</h2><span id='topic+sf2raster'></span>

<h3>Description</h3>

<p>This function takes in an <code>sf</code> spatial object (polygon or point) and returns a regularly spaced RasterLayer. Reverse translation option allows users to create an <code>sf</code> polygon object from the regularly spaced RasterLayer. This function can also conver the <code>sf</code> object into a cartogram with a user-specified variable name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf2raster(
  polyz_from = NULL,
  pointz_from = NULL,
  input_variable = NULL,
  reverse = FALSE,
  poly_to = NULL,
  return_output = NULL,
  return_field = NULL,
  aggregate_function = list(function(x) mean(x, na.rm = TRUE)),
  reverse_function = list(function(x) mean(x, na.rm = TRUE)),
  grid_dim = c(1000, 1000),
  cartogram = FALSE,
  carto_var = NULL,
  message_out = TRUE,
  return_list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sf2raster_+3A_polyz_from">polyz_from</code></td>
<td>
<p>Source polygon layer. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_pointz_from">pointz_from</code></td>
<td>
<p>Source point layer. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_input_variable">input_variable</code></td>
<td>
<p>Name of input variable from source layer. Character string.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_reverse">reverse</code></td>
<td>
<p>Reverse translation from raster layer to <code>sf</code> polygon object (polygon features only). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_poly_to">poly_to</code></td>
<td>
<p>Destination polygon layer for reverse conversion. Must be specified if <code>reverse=TRUE</code>. <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_return_output">return_output</code></td>
<td>
<p>Return output for reverse conversion. Must be specified if <code>reverse=TRUE</code>.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_return_field">return_field</code></td>
<td>
<p>Return field for reverse conversion. Must be specified if <code>reverse=TRUE</code>.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_aggregate_function">aggregate_function</code></td>
<td>
<p>Aggregation function to be applied to variables specified in <code>input_variable</code>. Must take as an input a numeric vector <code>x</code>. Function or list of functions. Default is <code>mean</code>.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_reverse_function">reverse_function</code></td>
<td>
<p>Aggregation function for reverse conversion. Must be specified if <code>reverse=TRUE</code>. Function or list of functions. Default is <code>mean</code>.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_grid_dim">grid_dim</code></td>
<td>
<p>Dimensions of raster grid. Numerical vector of length 2 (number of rows, number of columns). Default is <code>c(1000,1000)</code>.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_cartogram">cartogram</code></td>
<td>
<p>Cartogram transformation. Logical. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_carto_var">carto_var</code></td>
<td>
<p>Input variable for cartogram transformation. Must be specified if <code>cartogram=TRUE</code>. Character string.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_message_out">message_out</code></td>
<td>
<p>Print informational messages. Logical. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sf2raster_+3A_return_list">return_list</code></td>
<td>
<p>Return full set of results, including input polygons, centroids and field raster. Default is <code>FALSE</code>. Logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_list=FALSE</code> (default) and <code>reverse=FALSE</code> (default), returns <code>RasterLayer</code> object, with cell values corresponding to <code>input_variable</code>.
</p>
<p>If <code>return_list=TRUE</code> and input layer is polygon, returns a list containing
</p>

<ul>
<li><p> &quot;return_output&quot;. Output raster, with values corresponding to <code>input_variable</code>. <code>RasterLayer</code> object.
</p>
</li>
<li><p> &quot;return_centroid&quot;. Raster of centroids, with values corresponding to <code>input_variable</code>. <code>RasterLayer</code> object.
</p>
</li>
<li><p> &quot;poly_to&quot;. Source polygons, with columns corresponding to <code>input_variable</code> and auto-generated numerical ID <code>Field</code>. <code>sf</code> object.
</p>
</li>
<li><p> &quot;return_field&quot;. Output raster, with values corresponding to auto-generated numerical ID <code>Field</code>. <code>RasterLayer</code> object.</p>
</li></ul>

<p>If <code>return_list=TRUE</code> and  input layer is points, returns a list containing
</p>

<ul>
<li><p> &quot;return_output&quot;. Output raster, with values corresponding to <code>input_variable</code>. <code>RasterLayer</code> object.
</p>
</li>
<li><p> &quot;return_point&quot;. Source points, with column corresponding to <code>input_variable</code>.
</p>
</li></ul>

<p>If <code>reverse=TRUE</code>, returns an <code>sf</code> polygon layer, with columns corresponding to <code>input_variable</code> and auto-generated numerical ID <code>Field</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rasterization of polygon layer.
## Not run: 
data(clea_deu2009)
out_1 &lt;- sf2raster(polyz_from = utm_select(clea_deu2009),
                   input_variable = "to1")
terra::plot(out_1)

## End(Not run)
# Rasterization of point layer
## Not run: 
data(clea_deu2009_pt)
out_2 &lt;- sf2raster(pointz_from = utm_select(clea_deu2009_pt),
                   input_variable = "to1",
                   grid_dim = c(25,25))
terra::plot(out_2)

## End(Not run)
# Cartogram (vote turnout scaled by number of valid votes)
## Not run: 
out_3 &lt;- sf2raster(polyz_from = utm_select(clea_deu2009),
                   input_variable = "to1",
                   cartogram = TRUE,
                   carto_var = "vv1")
terra::plot(out_3)

## End(Not run)
# Polygonization of cartogram raster
## Not run: 
out_4a &lt;- sf2raster(polyz_from = utm_select(clea_deu2009),
                    input_variable = "to1",
                    cartogram = TRUE,
                    carto_var = "vv1",
                    return_list = TRUE)
out_4 &lt;- sf2raster(reverse = TRUE,
                   poly_to = out_4a$poly_to,
                   return_output = out_4a$return_output,
                   return_field = out_4a$return_field)
terra::plot(out_4)

## End(Not run)
</code></pre>

<hr>
<h2 id='smart_round'>Smart numerical rounding function</h2><span id='topic+smart_round'></span>

<h3>Description</h3>

<p>Function to round numerical values with minimal information loss (e.g. to avoid &quot;0.000&quot; values in tables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_round(x, rnd = 0, return_char = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smart_round_+3A_x">x</code></td>
<td>
<p>Vector of values to be rounded. Numeric.</p>
</td></tr>
<tr><td><code id="smart_round_+3A_rnd">rnd</code></td>
<td>
<p>Requested number of decimal places. Default is 0. Non-negative integer.</p>
</td></tr>
<tr><td><code id="smart_round_+3A_return_char">return_char</code></td>
<td>
<p>Return rounded values as character string? Default is TRUE. Logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rounds the values in its first argument to the specified number of decimal places (default 0). If brute-force rounding produces zero values (e.g. &quot;0.00&quot;), the number of decimal places is expanded to include the first significant digit.
</p>


<h3>Value</h3>

<p>If <code>return_char=TRUE</code>, returns a character string of same length as <code>x</code>. If <code>return_char=FALSE</code>, returns a numerical vector of same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Round a vector of numbers, character string output (best for tables) 
## Not run: 
out_1 &lt;- smart_round(c(.0013,2.3,-1,pi),rnd=2)
out_1

## End(Not run)

# Round a vector of numbers, numerical output 
## Not run: 
out_2 &lt;- smart_round(c(.0013,2.3,-1,pi),rnd=2,return_char=FALSE)
out_2

## End(Not run)
</code></pre>

<hr>
<h2 id='SUNGEO'><code>SUNGEO</code></h2><span id='topic+SUNGEO'></span>

<h3>Description</h3>

<p>Sub-National Geospatial Data Archive System: Geoprocessing Toolkit
</p>


<h3>Details</h3>

<p>See the README on
[GitHub](https://github.com/zhukovyuri/SUNGEO#readme)
</p>

<hr>
<h2 id='update_bbox'>Update bounding box of sf object</h2><span id='topic+update_bbox'></span>

<h3>Description</h3>

<p>Function to update the coordinates of the bounding box of sf vector data objects (e.g. after cropping or subsetting).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_bbox(sfobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_bbox_+3A_sfobj">sfobj</code></td>
<td>
<p>Layer to be updated. <code>sf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sf</code> object, with corrected bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Update bbox for subset of sf object
## Not run: 
data(clea_deu2009)
out_1 &lt;- update_bbox(clea_deu2009[clea_deu2009$cst_n%in%c("Berlin"),])
out_1

# Bounding box of full dataset
data.table::as.data.table(clea_deu2009)[,sf::st_bbox(geometry)]

# Bounding box of subset (incorrect)
data.table::as.data.table(clea_deu2009)[cst_n%in%c("Berlin"),sf::st_bbox(geometry)]

# Corrected bounding box
data.table::as.data.table(out_1)[,sf::st_bbox(geometry)]

## End(Not run)
</code></pre>

<hr>
<h2 id='utm_select'>Automatically convert geographic (degree) to planar coordinates (meters)</h2><span id='topic+utm_select'></span>

<h3>Description</h3>

<p>Function to automatically convert simple feature, spatial and raster objects with geographic coordinates (longitude, latitude / WGS 1984, EPSG:4326) to planar UTM coordinates. If the study region spans multiple UTM zones, defaults to Albers Equal Area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utm_select(x, max_zones = 5, return_list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utm_select_+3A_x">x</code></td>
<td>
<p>Layer to be reprojected. <code>sf</code>, <code>sp</code>, <code>SpatRaster</code> or <code>RasterLayer</code> object.</p>
</td></tr>
<tr><td><code id="utm_select_+3A_max_zones">max_zones</code></td>
<td>
<p>Maximum number of UTM zones for single layer. Default is 5. Numeric.</p>
</td></tr>
<tr><td><code id="utm_select_+3A_return_list">return_list</code></td>
<td>
<p>Return list object instead of reprojected layer (see Details). Default is <code>FALSE</code>. Logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optimal map projection for the object <code>x</code> is defined by matching its horizontal extent with that of the 60 UTM zones. If object spans multiple UTM zones, uses either the median zone (if number of zones is equal to or less than <code>max_zones</code>) or Albers Equal Area projection with median longitude as projection center (if number of zones is greater than <code>max_zones</code>).
</p>


<h3>Value</h3>

<p>Re-projected layer. <code>sf</code> or <code>RasterLayer</code> object, depending on input.
</p>
<p>If <code>return_list=TRUE</code>, returns a list object containing
</p>

<ul>
<li><p> &quot;x_out&quot;. The re-projected layer. <code>sf</code> or <code>RasterLayer</code> object, depending on input.
</p>
</li>
<li><p> &quot;proj4_best&quot;.proj4string of the projection. Character string.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Find a planar projection for an unprojected (WSG 1984) hexagonal grid of Germany
## Not run: 
data(hex_05_deu)
out_1 &lt;- utm_select(hex_05_deu)

## End(Not run)
# Find a planar projection for a raster
## Not run: 
data(gpw4_deu2010)
out_2 &lt;- utm_select(gpw4_deu2010)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
