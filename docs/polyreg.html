<!DOCTYPE html><html><head><title>Help for package polyreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polyreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FSR'><p>FSR</p></a></li>
<li><a href='#getPoly'><p>Get polynomial terms</p></a></li>
<li><a href='#misc'><p>Miscellaneous</p></a></li>
<li><a href='#pef'>
<p>Silicon Valley programmers and engineers data</p></a></li>
<li><a href='#polyFit'><p>Polynomial Fit</p></a></li>
<li><a href='#predict.FSR'><p>predict.FSR</p></a></li>
<li><a href='#weatherTS'>
<p>Weather Time Series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Polynomial Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Norm Matloff &lt;matloff@cs.ucdavis.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Automate formation and evaluation of polynomial regression models. The motivation for this package is described in 'Polynomial Regression As an Alternative to Neural Nets' by Xi Cheng, Bohdan Khomtchouk, Norman Matloff, and Pete Mohanty (&lt;<a href="https://doi.org/10.48550/arXiv.1806.06850">doi:10.48550/arXiv.1806.06850</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown,knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/matloff/polyreg">https://github.com/matloff/polyreg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/matloff/polyreg/issues">https://github.com/matloff/polyreg/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>nnet,parallel, stats, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-30 22:15:11 UTC; normanmatloff</td>
</tr>
<tr>
<td>Author:</td>
<td>Norm Matloff <a href="https://orcid.org/0000-0001-9179-6785"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Xi Cheng [aut],
  Pete Mohanty <a href="https://orcid.org/0000-0001-8531-3345"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bohdan Khomtchouk [aut],
  Matthew Kotila [aut],
  Robin Yancey [aut],
  Robert Tucker [aut],
  Allan Zhao [aut],
  Tiffany Jiang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-31 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='FSR'>FSR</h2><span id='topic+FSR'></span><span id='topic+print.FSR'></span><span id='topic+summary.FSR'></span>

<h3>Description</h3>

<p>FSR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSR(Xy, max_poly_degree = 3, max_interaction_degree = 2,
  outcome = NULL, linear_estimation = FALSE,
  threshold_include = 0.01, threshold_estimate = 0.001,
  min_models = NULL, max_fails = 2, standardize = FALSE,
  pTraining = 0.8, file_name = NULL, store_fit = "none",
  max_block = 250, noisy = TRUE, seed = NULL)
## S3 method for class 'FSR'
summary(object, estimation_overview = TRUE,
  results_overview = TRUE, model_number = NULL, ...)
## S3 method for class 'FSR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FSR_+3A_xy">Xy</code></td>
<td>
<p>matrix or data.frame; outcome must be in final column. Categorical variables (&gt; 2 levels) should be passed as factors, not dummy variables or integers, to ensure the polynomial matrix is constructed properly.</p>
</td></tr>
<tr><td><code id="FSR_+3A_max_poly_degree">max_poly_degree</code></td>
<td>
<p>highest power to raise continuous features; default 3 (cubic).</p>
</td></tr>
<tr><td><code id="FSR_+3A_max_interaction_degree">max_interaction_degree</code></td>
<td>
<p>highest interaction order; default 2 (allow x_i*x_j). Also interacts each level of factors with continuous features.</p>
</td></tr>
<tr><td><code id="FSR_+3A_outcome">outcome</code></td>
<td>
<p>Treat y as either 'continuous', 'binary', 'multinomial', or NULL (auto-detect based on response).</p>
</td></tr>
<tr><td><code id="FSR_+3A_linear_estimation">linear_estimation</code></td>
<td>
<p>Logical: model outcome as linear and estimate with ordinary least squares? Recommended for speed on large datasets even if outcome is categorical. (For multinomial outcome, this means treated response as vector.) If FALSE, estimator chosen based on 'outcome' (i.e., OLS for continuous outcomes, glm() to estimate logistic regression models for 'binary' outcomes, and nnet::multinom() for 'multinomial').</p>
</td></tr>
<tr><td><code id="FSR_+3A_threshold_include">threshold_include</code></td>
<td>
<p>minimum improvement to include a recently added term in the model (change in fit originally on 0 to 1 scale). -1.001 means 'include all'. Default: 0.01. (Adjust R^2 for linear models, Pseudo R^2 for logistic regression, out-of-sample accuracy for multinomial models. In latter two cases, the same adjustment for number of predictors is applied as pseudo-R^2.)</p>
</td></tr>
<tr><td><code id="FSR_+3A_threshold_estimate">threshold_estimate</code></td>
<td>
<p>minimum improvement to keep estimating (pseudo R^2 so scale 0 to 1). -1.001 means 'estimate all'. Default: 0.001.</p>
</td></tr>
<tr><td><code id="FSR_+3A_min_models">min_models</code></td>
<td>
<p>minimum number of models to estimate. Defaults to the number of features (unless P &gt; N).</p>
</td></tr>
<tr><td><code id="FSR_+3A_max_fails">max_fails</code></td>
<td>
<p>maximum number of models to FSR() can fail on computationally before exiting. Default == 2.</p>
</td></tr>
<tr><td><code id="FSR_+3A_standardize">standardize</code></td>
<td>
<p>if TRUE (not default), standardizes continuous variables.</p>
</td></tr>
<tr><td><code id="FSR_+3A_ptraining">pTraining</code></td>
<td>
<p>portion of data for training</p>
</td></tr>
<tr><td><code id="FSR_+3A_file_name">file_name</code></td>
<td>
<p>If a file name (and path) is provided, saves output after each model is estimated as an .RData file. ex: file_name = &quot;results.RData&quot;. See also store_fit for options as to how much to store in the outputted object.</p>
</td></tr>
<tr><td><code id="FSR_+3A_store_fit">store_fit</code></td>
<td>
<p>If file_name is provided, FSR() will return coefficients, measures of fit, and call details. Save entire fit objects? Options include &quot;none&quot; (default, just save those other items), &quot;accepted_only&quot; (only models that meet the threshold), and &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="FSR_+3A_max_block">max_block</code></td>
<td>
<p>Most of the linear algebra is done recursively in blocks to ease memory managment. Default 250. Changing up or down may slow things...</p>
</td></tr>
<tr><td><code id="FSR_+3A_noisy">noisy</code></td>
<td>
<p>display measures of fit, progress, etc. Recommended.</p>
</td></tr>
<tr><td><code id="FSR_+3A_seed">seed</code></td>
<td>
<p>Automatically set but can also be passed as paramater.</p>
</td></tr>
<tr><td><code id="FSR_+3A_estimation_overview">estimation_overview</code></td>
<td>
<p>logical: describe how many models were planned, sample size, etc.?</p>
</td></tr>
<tr><td><code id="FSR_+3A_results_overview">results_overview</code></td>
<td>
<p>logical: give overview of best fit model, etc?</p>
</td></tr>
<tr><td><code id="FSR_+3A_model_number">model_number</code></td>
<td>
<p>If non-null, an integer indicating which model to display a summary of.</p>
</td></tr>
<tr><td><code id="FSR_+3A_object">object</code></td>
<td>
<p>an FSR object, can be used with predict().</p>
</td></tr>
<tr><td><code id="FSR_+3A_x">x</code></td>
<td>
<p>an FSR object, can be used with print().</p>
</td></tr>
<tr><td><code id="FSR_+3A_...">...</code></td>
<td>
<p>ignore.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with slope coefficients, model and estimation details, and measures of fit (object of class 'FSR').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- FSR(mtcars)
</code></pre>

<hr>
<h2 id='getPoly'>Get polynomial terms</h2><span id='topic+getPoly'></span><span id='topic+polyMatrix'></span>

<h3>Description</h3>

<p>Generate polynomial terms of predictor variables for a
data frame or data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPoly(xdata = NULL, deg = 1, maxInteractDeg = deg,
        Xy = NULL, standardize = FALSE,
        noisy = TRUE, intercept = FALSE, returnDF = TRUE, 
        modelFormula = NULL, retainedNames = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPoly_+3A_xdata">xdata</code></td>
<td>
<p> Data matrix or data frame without response variable. Categorical variables (&gt; 2 levels) should be passed as factors, not dummy variables or integers, to ensure the polynomial matrix is constructed properly.</p>
</td></tr>
<tr><td><code id="getPoly_+3A_deg">deg</code></td>
<td>
<p> The max degree of power terms. Default 1 so just returns model matrix by default.</p>
</td></tr>
<tr><td><code id="getPoly_+3A_maxinteractdeg">maxInteractDeg</code></td>
<td>
<p>The max degree of nondummy interaction terms. x1 * x2 is degree 2. x1^3 * x2^2 is degree 5. Implicitly constrained by deg. For example, if deg = 3 and maxInteractDegree = 2, x1^1 * x2^2 (i.e., degree 3) will be included but x1^2 * x2^2 (i.e., degree 4) will not.</p>
</td></tr>
<tr><td><code id="getPoly_+3A_xy">Xy</code></td>
<td>
<p> The dataframe with the response in the final column (provide xdata or Xy but not both).Categorical variables (&gt; 2 levels) should be passed as factors, not dummy variables or integers, to ensure the polynomial matrix is constructed properly.</p>
</td></tr>
<tr><td><code id="getPoly_+3A_standardize">standardize</code></td>
<td>
<p> Standardize all continuous variables? (Default: FALSE.)</p>
</td></tr>
<tr><td><code id="getPoly_+3A_noisy">noisy</code></td>
<td>
<p> Output progress updates? (Default: TRUE.)</p>
</td></tr>
<tr><td><code id="getPoly_+3A_intercept">intercept</code></td>
<td>
<p> Include intercept? (Default: FALSE.)</p>
</td></tr>
<tr><td><code id="getPoly_+3A_returndf">returnDF</code></td>
<td>
<p> Return a data.frame (as opposed to model.matrix)? (Default: TRUE.)</p>
</td></tr>
<tr><td><code id="getPoly_+3A_modelformula">modelFormula</code></td>
<td>
<p> Internal use. Formula used to generate the training model matrix. Note: anticipates that polynomial terms are generated using internal functions of library(polyreg). Also, providing modelFormula bypasses deg and maxInteractDeg.</p>
</td></tr>
<tr><td><code id="getPoly_+3A_retainednames">retainedNames</code></td>
<td>
<p> Internal use. colnames of polyMatrix object$xdata. Requires modelFormula be inputted as well.</p>
</td></tr>
<tr><td><code id="getPoly_+3A_...">...</code></td>
<td>
<p> Additional arguments to be passed to model.matrix() via polyreg:::model_matrix(). Note na.action = &quot;na.omit&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getPoly</code> function takes in a data frame or data matrix and
generates polynomial terms of predictor variables.
</p>
<p>Note the subtleties involving dummy variables.  The square, cubic and
so on terms are the same as the original variable, and the various
duplicates must be eliminated.
</p>
<p>Similarly, after dummy variable are created from a categorical
variable having more than two levels, the resulting columns will be
orthogonal to each other.  In almost
all cases, this argument should be set to TRUE at the training stage, and
then in predictions one should use the vector of names in the
component in the return value;
<code>predict.polyFit</code> does the latter automatically.
</p>
<p>Note:  If a column that is an R factor has levels with spaces in the
names, this will interfere with the parsing, and must be avoided.
</p>





<h3>Value</h3>

<p>The return value of <code>getPoly</code> is a <code>polyMatrix</code>
object.  This is an S3 class containing a model.matrix <code>
xdata</code> of the generated polynomial terms. The predictor
variables have column names V1, V2, etc. The object also contains
<code>modelFormula</code>, the formula used to construct the model matrix, and 
<code>XtestFormula</code>, the formula which should be used out-of-sample 
(when y_test is not available).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 125
rawdata &lt;- data.frame(x1 = rnorm(N), 
                      x2 = rnorm(N),
                      group = sample(letters[1:5], N, replace=TRUE),
                      z = sample(c("treatment", "control"), N, replace=TRUE),
                      result = sample(c("win", "lose", "tie"), N, replace=TRUE))
head(rawdata)

P &lt;- length(levels(rawdata$group)) - 1 + 
     length(levels(rawdata$z)) - 1 + 
     length(levels(rawdata$result)) - 1 + 
     sum(unlist(lapply(rawdata, is.numeric)))

# quadratic polynomial, includes interactions 
# since maxInteractDeg defaults to deg
X &lt;- getPoly(rawdata, 2)$xdata 
ncol(X) # 40

# cubic polynomial, no interactions
X &lt;- getPoly(rawdata, 3, 1)$xdata
ncol(X) # 13

# cubic polynomial, interactions
X &lt;- getPoly(rawdata, 3, 2)$xdata
ncol(X) # 58

# cubic polynomial, interactions
X &lt;- getPoly(rawdata, 3)$xdata
ncol(X) # 101

# making final column the response variable, y
# results in TRUE (fewer columns)
ncol(getPoly(Xy=rawdata, deg=2)$xdata) &lt; ncol(getPoly(rawdata, 2)$xdata)

# preparing polynomial matrices for crossvalidation
# getPoly() returns a polyMatrix() object containing XtestFormula
# which should be used to ensure factors are handled correctly out-of-sample
Xtrain &lt;- getPoly(rawdata[1:100,],2)
Xtest &lt;- getPoly(rawdata[101:125,], 2, modelFormula = Xtrain$XtestFormula)

</code></pre>

<hr>
<h2 id='misc'>Miscellaneous</h2><span id='topic+toFactors'></span>

<h3>Description</h3>

<p>Utilities</p>


<h3>Usage</h3>

<pre><code class='language-R'>   toFactors(df,cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misc_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="misc_+3A_cols">cols</code></td>
<td>
<p>A vector of column numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>toFactors</code> function converts each <code>df</code> column in 
<code>cols</code> to a factor, returns new version of <code>df</code>. 
Should be used on categorical variables stored as integer codes 
before calling the library's main functions, 
including <code>getPoly</code>, <code>FSR</code>, or <code>polyFit</code>.
</p>

<hr>
<h2 id='pef'>
Silicon Valley programmers and engineers data
</h2><span id='topic+pef'></span>

<h3>Description</h3>

<p>This data set is adapted from the 2000 Census (5% sample, person
records).  It is mainly restricted to programmers and engineers in the 
Silicon Valley area.  (Apparently due to errors, there are some from
other ZIP codes.)
</p>
<p>Has columns for age, education, occupation, gender, wage income and
weeks worked.  The education column has been collapsed to Master's
degree, PhD and other.
</p>
<p>The variable codes, e.g. occupational codes, are available from
<a href="https://usa.ipums.org/usa/volii/occ2000.shtml">https://usa.ipums.org/usa/volii/occ2000.shtml</a>.
(Short code lists are given in the record layout, but longer ones are in
the appendix Code Lists.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pef)
</code></pre>

<hr>
<h2 id='polyFit'>Polynomial Fit</h2><span id='topic+polyFit'></span><span id='topic+predict.polyFit'></span>

<h3>Description</h3>

<p>Fit polynomial regression using a linear or logistic model; predict
new data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyFit(xy, deg, maxInteractDeg=deg, use = "lm", glmMethod="one", 
     return_xy=FALSE, returnPoly=FALSE, noisy=TRUE)
## S3 method for class 'polyFit'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyFit_+3A_xy">xy</code></td>
<td>
<p>Data frame with response variable in the last
column.  Latter is numeric, except in the classification case: 
Categorical variables (&gt; 2 levels) must be passed as factors 
or character variables if <code>use</code> is 'glm'; an integer vector
must be used for the for the 'mvrlm' case, or for the 2-class case
(0s and 1s).</p>
</td></tr>
<tr><td><code id="polyFit_+3A_deg">deg</code></td>
<td>
<p>The max degree for polynomial terms.  A term such as uv,
for instance, is considered degree 2.</p>
</td></tr>
<tr><td><code id="polyFit_+3A_maxinteractdeg">maxInteractDeg</code></td>
<td>
<p>The max degree of interaction terms.</p>
</td></tr>
<tr><td><code id="polyFit_+3A_use">use</code></td>
<td>
<p>Set to 'lm' for linear regression, 'glm' for
logistic regression, or 'mvrlm' for multivariate-response <code>lm</code>.</p>
</td></tr>
<tr><td><code id="polyFit_+3A_glmmethod">glmMethod</code></td>
<td>
<p>Defaults to 'one,' meaning the One Versus All Method.
Use 'all' for All Versus All.</p>
</td></tr>
<tr><td><code id="polyFit_+3A_newdata">newdata</code></td>
<td>
<p>Data frame, one row for each &quot;X&quot; to be predicted.  Must
have the same column names as in <code>xy</code> (without &quot;Y&quot;).</p>
</td></tr>
<tr><td><code id="polyFit_+3A_object">object</code></td>
<td>
<p>An item of class 'polyFit' containing output. Can be 
used with predict().</p>
</td></tr>
<tr><td><code id="polyFit_+3A_return_xy">return_xy</code></td>
<td>
<p>Return data? Default: FALSE</p>
</td></tr>
<tr><td><code id="polyFit_+3A_returnpoly">returnPoly</code></td>
<td>
<p>return polyMatrix object? Defaults to FALSE since may be quite large.</p>
</td></tr>
<tr><td><code id="polyFit_+3A_noisy">noisy</code></td>
<td>
<p>Logical: display messages?</p>
</td></tr>
<tr><td><code id="polyFit_+3A_...">...</code></td>
<td>
<p>Additional arguments for getPoly().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>polyFit</code> function calls <code>getPoly</code> to generate
polynomial terms from predictor variables, then fits the generated
data to a linear or logistic regression model.  (Powers of dummy
variables will not be generated, other than degree 1, but interaction
terms will calculated.)
</p>
<p>When logistic regression for classification is indicated, with more
than two classes, All-vs-All or One-vs-All methods, coded
<code>'all'</code> and <code>'one'</code>, can be applied to deal with multiclass
problem.  
</p>
<p>Under the 'mvrlm' option in a classification problem, <code>lm</code> is
called with multivariate response, using <code>cbind</code> and dummy
variables for class membership as the response.  Since predictors are
used to form polynomials, this should be a reasonable model, and is
much faster than 'glm'.
</p>


<h3>Value</h3>

<p>The return value of <code>polyFit()</code> is an <code>polyFit</code> object.  The
orginal arguments are retained, along with the fitted models and so on.
</p>
<p>The prediction function <code>predict.polyFit</code> returns the predicted
value(s) for <code>newdata</code>. It also contains probability for each class as
an attribute named <code>prob</code>. In the classification case, these will be
the predicted class labels, 1,2,3,...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 125
xyTrain &lt;- data.frame(x1 = rnorm(N), 
                      x2 = rnorm(N),
                      group = sample(letters[1:5], N, replace=TRUE),
                      score = sample(100, N, replace = TRUE) # final column is y
                      )

pfOut &lt;- polyFit(xyTrain, 2)

# 4 new test points
xTest &lt;- data.frame(x1 = rnorm(4), 
                    x2 = rnorm(4),
                    group = sample(letters[1:5], 4, replace=TRUE))
  
predict(pfOut, xTest) # returns vector of 4 predictions

data(pef)
# predict wageinc
z &lt;- polyFit(pef[,c(setdiff(1:6,5),5)],2)
predict(z,pef[2000,c(setdiff(1:6,5),5)])  # 56934.39
# predict occ
z &lt;- polyFit(pef[,c(setdiff(1:6,3),3)],2,use='glm')
predict(z,pef[2000,c(setdiff(1:6,3),3)])  # '100', probs 0.43, 0.26,...

</code></pre>

<hr>
<h2 id='predict.FSR'>predict.FSR</h2><span id='topic+predict.FSR'></span>

<h3>Description</h3>

<p>predict.FSR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FSR'
predict(object, newdata, model_to_use = NULL,
  standardize = NULL, noisy = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.FSR_+3A_object">object</code></td>
<td>
<p>FSR output. Predictions will be made based on object$best_formula unless model_to_use is provided (as an integer).</p>
</td></tr>
<tr><td><code id="predict.FSR_+3A_newdata">newdata</code></td>
<td>
<p>New Xdata.</p>
</td></tr>
<tr><td><code id="predict.FSR_+3A_model_to_use">model_to_use</code></td>
<td>
<p>Integer optionally indicating a model to use if object$best_formula is not selected. Example: model_to_use = 3 will use object$models$formula[3].</p>
</td></tr>
<tr><td><code id="predict.FSR_+3A_standardize">standardize</code></td>
<td>
<p>Logical&ndash;standardize numeric variables? (If NULL, the default, bypasses and decides based on object$standardize.)</p>
</td></tr>
<tr><td><code id="predict.FSR_+3A_noisy">noisy</code></td>
<td>
<p>Display output?</p>
</td></tr>
<tr><td><code id="predict.FSR_+3A_...">...</code></td>
<td>
<p>ignore</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y_hat (predictions using chosen model estimates).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- FSR(mtcars[1:30,])
forecast &lt;- predict(out, mtcars[31:nrow(mtcars),])
</code></pre>

<hr>
<h2 id='weatherTS'>
Weather Time Series
</h2><span id='topic+weatherTS'></span>

<h3>Description</h3>

<p>Various measurements on weather variables collected by NASA.  Downloaded
via <code>nasapower</code>; see that package for documentation.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
