<!DOCTYPE html><html><head><title>Help for package pGPx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pGPx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pGPx-package'><p>pGPx: Pseudo-Realizations for Gaussian Process Excursions</p></a></li>
<li><a href='#compute_contourLength'><p>Compute contour lenghts</p></a></li>
<li><a href='#computeVolumes'><p>Compute Excursion Volume Distribution</p></a></li>
<li><a href='#dtt_fast'><p>Rcpp implementation of Felzenszwalb distance transfom</p></a></li>
<li><a href='#DTV'><p>Compute Distance Transform Variability</p></a></li>
<li><a href='#edm_crit'><p>Distance in measure criterion</p></a></li>
<li><a href='#edm_crit2'><p>Distance in measure criterion</p></a></li>
<li><a href='#expDistMeasure'><p>Compute expected distance in measure of approximate excursion set</p></a></li>
<li><a href='#grad_kweights'><p>Gradient of the weights for interpolating simulations</p></a></li>
<li><a href='#integrand_edm_crit'><p>Integrand of the distance in measure criterion</p></a></li>
<li><a href='#krig_weight_GPsimu'><p>Weights for interpolating simulations</p></a></li>
<li><a href='#max_distance_measure'><p>Minimize the distance in measure criterion</p></a></li>
<li><a href='#max_integrand_edm'><p>Maximize the integrand distance in measure criterion</p></a></li>
<li><a href='#optim_dist_measure'><p>Choose simulation points</p></a></li>
<li><a href='#simulate_and_interpolate'><p>Simulate and interpolate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pseudo-Realizations for Gaussian Process Excursions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Dario Azzimonti <a href="https://orcid.org/0000-0001-5080-3061"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Julien Bect [ctb],
  Pedro Felzenszwalb [ctb, cph] (Original dt code,
    https://cs.brown.edu/people/pfelzens/dt/index.html)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dario Azzimonti &lt;dario.azzimonti@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes pseudo-realizations from the posterior distribution of a Gaussian Process (GP) with the method described in Azzimonti et al. (2016) &lt;<a href="https://doi.org/10.1137%2F141000749">doi:10.1137/141000749</a>&gt;. The realizations are obtained from simulations of the field at few well chosen points that minimize the expected distance in measure between the true excursion set of the field and the approximate one. Also implements a R interface for (the main function of) Distance Transform of sampled Functions (<a href="https://cs.brown.edu/people/pfelzens/dt/index.html">https://cs.brown.edu/people/pfelzens/dt/index.html</a>).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.1137/141000749">https://doi.org/10.1137/141000749</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), DiceKriging, pbivnorm, KrigInv, rgenoud,
randtoolbox, pracma, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>anMC, DiceDesign</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-23 07:42:08 UTC; dario.azzimonti</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 15:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='pGPx-package'>pGPx: Pseudo-Realizations for Gaussian Process Excursions</h2><span id='topic+pGPx'></span><span id='topic+pGPx-package'></span>

<h3>Description</h3>

<p>Computes pseudo-realizations from the posterior distribution of a Gaussian Process (GP) with the method described in Azzimonti et al. (2016) <a href="https://doi.org/10.1137/141000749">doi:10.1137/141000749</a>. The realizations are obtained from simulations of the field at few well chosen points that minimize the expected distance in measure between the true excursion set of the field and the approximate one. Also implements a R interface for (the main function of) Distance Transform of sampled Functions (<a href="https://cs.brown.edu/people/pfelzens/dt/index.html">https://cs.brown.edu/people/pfelzens/dt/index.html</a>).
</p>


<h3>Details</h3>

<p>Generates posterior pseudo-realizations of Gaussian processes for excursion set estimation. The package provides posterior pseudo-realizations over large designs by simulating the field at few well chosen points and interpolating the result. The points are chosen minimizing the (posterior) expected distance in measure between the approximate excursion set and the full excursion set. The main functions in the package are: </p>

<dl>
<dt><strong>Approximation:</strong></dt><dd> 
<ul>
<li> <p><code><a href="#topic+optim_dist_measure">optim_dist_measure</a></code>: Given a <a href="DiceKriging.html#topic+km">km</a> objects computes the optimal simulation points <code class="reqn">e_1</code>, ... , <code class="reqn">e_m</code> according to algorithm <code>A</code> or <code>B</code>.
</p>
</li>
<li> <p><code><a href="#topic+krig_weight_GPsimu">krig_weight_GPsimu</a></code>: Given the simulations points and the interpolation points computes the kriging weights for the approximate process <code class="reqn">\tilde{Z}</code> at the interpolation points.
</p>
</li>
<li> <p><code><a href="#topic+grad_kweights">grad_kweights</a></code>: Given the simulations points and the interpolation points returns the gradient of kriging weights with respect to the interpolation points.
</p>
</li>
<li> <p><code><a href="#topic+expDistMeasure">expDistMeasure</a></code>: computes the expected distance in measure between the excursion set of the approximated process and the true excursion set.
</p>
</li></ul>
 </dd>
<dt><strong>Simulation:</strong></dt><dd> 
<ul>
<li> <p><code><a href="#topic+simulate_and_interpolate">simulate_and_interpolate</a></code>: Generates <code>nsims</code> approximate posterior field realizations at <code>interpolatepoints</code> given the optimized simulation points.
</p>
</li></ul>
  </dd>
<dt><strong>Applications:</strong></dt><dd> 
<ul>
<li> <p><em>Contour length</em>: the function <code><a href="#topic+compute_contourLength">compute_contourLength</a></code> computes the excursion set contour length for each GP realization.
</p>
</li>
<li> <p><em>Distance transform</em>: the function <code><a href="#topic+dtt_fast">dtt_fast</a></code> computes the distance transform of a binary image (Felzenszwalb and Huttenlocher, 2012) and the function <code><a href="#topic+DTV">DTV</a></code> computes the distance transfom variability.
</p>
</li>
<li> <p><em>Volumes</em>: the function <code><a href="#topic+computeVolumes">computeVolumes</a></code> computes the excursion volumes for each GP realization. It also applies a bias correction for approximate realizations.
</p>
</li></ul>
  </dd>
</dl>



<h3>Note</h3>

<p>This work was supported in part by the Swiss National Science Foundation, grant numbers 146354, 167199 and the Hasler Foundation, grant number 16065. The author wishes to thank David Ginsbourger, Clément Chevalier and Julien Bect for the fruitful discussions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dario Azzimonti <a href="mailto:dario.azzimonti@gmail.com">dario.azzimonti@gmail.com</a> (<a href="https://orcid.org/0000-0001-5080-3061">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Julien Bect <a href="mailto:julien.bect@centralesupelec.fr">julien.bect@centralesupelec.fr</a> [contributor]
</p>
</li>
<li><p> Pedro Felzenszwalb (Original dt code, https://cs.brown.edu/people/pfelzens/dt/index.html) [contributor, copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>Azzimonti, D., Bect, J., Chevalier, C., and Ginsbourger, D. (2016a). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Azzimonti, D. and Ginsbourger, D. (2017). Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation. Journal of Computational and Graphical Statistics.
</p>
<p>Bolin, D. and Lindgren, F. (2015). Excursion and contour uncertainty regions for latent Gaussian models. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 77(1):85&ndash;106.
</p>
<p>Chevalier, C. (2013). Fast uncertainty reduction strategies relying on Gaussian process models. PhD thesis, University of Bern.
</p>
<p>Chevalier, C., Bect, J., Ginsbourger, D., Vazquez, E., Picheny, V., and Richet, Y. (2014). Fast kriging-based stepwise uncertainty reduction with application to the identification of an excursion set. Technometrics, 56(4):455–465.
</p>
<p>Felzenszwalb, P. F. and Huttenlocher, D. P. (2012). Distance Transforms of Sampled Functions. Theory of Computing, 8(19):415-428.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://doi.org/10.1137/141000749">doi:10.1137/141000749</a>
</p>
</li></ul>


<hr>
<h2 id='compute_contourLength'>Compute contour lenghts</h2><span id='topic+compute_contourLength'></span>

<h3>Description</h3>

<p>Computes the contour lengths for the excursion sets in <code>gpRealizations</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_contourLength(gpRealizations, threshold, nRealizations, verb = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_contourLength_+3A_gprealizations">gpRealizations</code></td>
<td>
<p>a matrix of size <code>nRealizations</code>x<code>imageSize^2</code> containing the GP realizations stored as long vectors. For example the object returned by <code><a href="#topic+simulate_and_interpolate">simulate_and_interpolate</a></code>.</p>
</td></tr>
<tr><td><code id="compute_contourLength_+3A_threshold">threshold</code></td>
<td>
<p>threshold value</p>
</td></tr>
<tr><td><code id="compute_contourLength_+3A_nrealizations">nRealizations</code></td>
<td>
<p>number of simulations of the excursion set</p>
</td></tr>
<tr><td><code id="compute_contourLength_+3A_verb">verb</code></td>
<td>
<p>an integer to choose the level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>nRealizations</code> containing the countour lines lenghts.
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulate and interpolate for a 2d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
# Define the function
g=function(x){
  return(-DiceKriging::branin(x))
}
d=2
# Fit OK km model
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=50,
                                                                  dimension = 2,
                                                                  seed=42)$design)$design
colnames(design)&lt;-c("x1","x2")
observations&lt;-apply(X = design,MARGIN = 1,FUN = g)
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))
# Get simulation points
# Here they are not optimized, you can use optim_dist_measure to find optimized points
simu_points &lt;- DiceDesign::maximinSA_LHS(DiceDesign::lhsDesign(n=100,
                                                               dimension = d,
                                                               seed=1)$design)$design


# obtain nsims posterior realization at simu_points
nsims &lt;- 1
nn_data&lt;-expand.grid(seq(0,1,,50),seq(0,1,,50))
nn_data&lt;-data.frame(nn_data)
colnames(nn_data)&lt;-colnames(kmModel@X)
approx.simu &lt;- simulate_and_interpolate(object=kmModel, nsim = nsims, simupoints = simu_points,
                                        interpolatepoints = as.matrix(nn_data),
                                        nugget.sim = 0, type = "UK")
cLLs&lt;- compute_contourLength(gpRealizations = approx.simu,threshold = -10,
                             nRealizations = nsims,verb = 1)
</code></pre>

<hr>
<h2 id='computeVolumes'>Compute Excursion Volume Distribution</h2><span id='topic+computeVolumes'></span>

<h3>Description</h3>

<p>Compute the volume of excursion for each realization, includes a bias.correction for the mean.    If the input is the actual GP values, compute also the random sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeVolumes(
  rand.set,
  threshold,
  nsim,
  n.int.points,
  bias.corr = F,
  model = NULL,
  bias.corr.points = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeVolumes_+3A_rand.set">rand.set</code></td>
<td>
<p>a matrix of size <code>n.int.points</code>x<code>nsim</code> containing the excursion set realizations stored as long vectors. For example the excursion set obtained from the result of <code><a href="#topic+simulate_and_interpolate">simulate_and_interpolate</a></code>.</p>
</td></tr>
<tr><td><code id="computeVolumes_+3A_threshold">threshold</code></td>
<td>
<p>threshold value</p>
</td></tr>
<tr><td><code id="computeVolumes_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations of the excursion set</p>
</td></tr>
<tr><td><code id="computeVolumes_+3A_n.int.points">n.int.points</code></td>
<td>
<p>total length of the excursion set discretization. The size of the image is <code>sqrt(n.int.points)</code>.</p>
</td></tr>
<tr><td><code id="computeVolumes_+3A_bias.corr">bias.corr</code></td>
<td>
<p>a boolean, if <code>TRUE</code> it computes the bias correction for the volume distribution.</p>
</td></tr>
<tr><td><code id="computeVolumes_+3A_model">model</code></td>
<td>
<p>the <a href="DiceKriging.html#topic+km">km</a> model for computing the bias correction. If <code>NULL</code> the bias correction is not computed.</p>
</td></tr>
<tr><td><code id="computeVolumes_+3A_bias.corr.points">bias.corr.points</code></td>
<td>
<p>a matrix with <code class="reqn">d</code> columns with the input points where to compute the bias correction. If <code>NULL</code> it is initialized as the first <code>n.int.points</code> of the Sobol' sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size <code>nsim</code> containing the excursion volumes for each realization.
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulate and interpolate for a 2d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
# Define the function
g=function(x){
  return(-DiceKriging::branin(x))
}
d=2
# Fit OK km model
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=50,
                                                                  dimension = 2,
                                                                  seed=42)$design)$design
colnames(design)&lt;-c("x1","x2")
observations&lt;-apply(X = design,MARGIN = 1,FUN = g)
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))
# Get simulation points
# Here they are not optimized, you can use optim_dist_measure to find optimized points
simu_points &lt;- DiceDesign::maximinSA_LHS(DiceDesign::lhsDesign(n=100,
                                                               dimension = d,
                                                               seed=1)$design)$design
# obtain nsims posterior realization at simu_points
nsims &lt;- 30
nn_data&lt;-expand.grid(seq(0,1,,50),seq(0,1,,50))
nn_data&lt;-data.frame(nn_data)
colnames(nn_data)&lt;-colnames(kmModel@X)
approx.simu &lt;- simulate_and_interpolate(object=kmModel, nsim = nsims, simupoints = simu_points,
                                        interpolatepoints = as.matrix(nn_data),
                                        nugget.sim = 0, type = "UK")
exVol&lt;- computeVolumes(rand.set = approx.simu,threshold = -10,
                             nsim = nsims,n.int.points = 50^2,bias.corr=TRUE, model=kmModel)

hist(exVol, main="Excursion Volume")

</code></pre>

<hr>
<h2 id='dtt_fast'>Rcpp implementation of Felzenszwalb distance transfom</h2><span id='topic+dtt_fast'></span>

<h3>Description</h3>

<p>Rcpp wrapper for the distance transform algorithm described in Felzenszwalb and Huttenlocher (2012)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtt_fast(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtt_fast_+3A_x">x</code></td>
<td>
<p>matrix of booleans of size <code class="reqn">n x m</code> representing a (binary) image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of size <code class="reqn">n x m</code> containing the distance transform result. Note that this function does not perform any checks on <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pedro Felzenszwalb for the header files <code>dt.h</code> and <code>misc.h</code> that do the work, Dario Azzimonti and Julien Bect for the wrapper.
</p>


<h3>References</h3>

<p>Felzenszwalb, P. F. and Huttenlocher, D. P. (2012). Distance Transforms of Sampled Functions. Theory of Computing, 8(19):415-428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an image with a square
nc = 256
nr = 256
xx = matrix(FALSE,ncol=nc,nrow=nr)
xx[(nr/16):(nr/16*15-1),nc/16]&lt;-rep(TRUE,nr/16*14)
xx[(nr/16):(nr/16*15-1),nc/16*15]&lt;-rep(TRUE,nr/16*14)
xx[nr/16,(nc/16):(nc/16*15-1)]&lt;-rep(TRUE,nc/16*14)
xx[nr/16*15,(nc/16):(nc/16*15-1)]&lt;-rep(TRUE,nc/16*14)
# Compute Distance transform
zz&lt;- dtt_fast(xx)

# Plot the results
image(xx,col=grey.colors(20), main="Original image")
image(zz,col=grey.colors(20), main="Distance transform")

</code></pre>

<hr>
<h2 id='DTV'>Compute Distance Transform Variability</h2><span id='topic+DTV'></span>

<h3>Description</h3>

<p>Compute the expected L^2 distance between the average distance transform and the set realizations.    If the input is the actual values of the gaussian process, compute also the random sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTV(rand.set, threshold, nsim, n.int.points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DTV_+3A_rand.set">rand.set</code></td>
<td>
<p>a matrix of size <code>n.int.points</code>x<code>nsim</code> containing the excursion set realizations stored as long vectors. For example the excursion set obtained from the result of <code><a href="#topic+simulate_and_interpolate">simulate_and_interpolate</a></code>.</p>
</td></tr>
<tr><td><code id="DTV_+3A_threshold">threshold</code></td>
<td>
<p>threshold value</p>
</td></tr>
<tr><td><code id="DTV_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations of the excursion set</p>
</td></tr>
<tr><td><code id="DTV_+3A_n.int.points">n.int.points</code></td>
<td>
<p>total length of the excursion set discretization. The size of the image is <code>sqrt(n.int.points)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing</p>

<ul>
<li><p><code>variance:</code>Value of the distance transform variability. The integral of <code>dvar</code> over the spatial domain.
</p>
</li>
<li><p><code>dbar:</code>empirical distance average transform <code class="reqn"> 1/N \sum_{i=1}^N d(x,\Gamma_i)</code>, a matrix of size <code>n.int.points</code> x <code>n.int.points</code>
</p>
</li>
<li><p><code>dvar:</code>empirical variance of distance transform <code class="reqn"> 1/N \sum_{i=1}^N (d(x,\Gamma_i) - dbar)^2</code>, a matrix of size <code>n.int.points</code> x <code>n.int.points</code>
</p>
</li>
<li><p><code>alldt:</code>distance transforms for all realizations, a matrix of size <code>n.int.points</code> x <code>nsim</code>
</p>
</li>
<li><p><code>naTot:</code>Total number of infinite distance transform values. These are returned in realizations where there is no excursion.
</p>
</li></ul>



<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>
<p>Felzenszwalb, P. F. and Huttenlocher, D. P. (2012). Distance Transforms of Sampled Functions. Theory of Computing, 8(19):415-428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulate and interpolate for a 2d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
# Define the function
g=function(x){
  return(-DiceKriging::branin(x))
}
d=2
# Fit OK km model
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=50,
                                                                  dimension = 2,
                                                                  seed=42)$design)$design
colnames(design)&lt;-c("x1","x2")
observations&lt;-apply(X = design,MARGIN = 1,FUN = g)
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))
# Get simulation points
# Here they are not optimized, you can use optim_dist_measure to find optimized points
simu_points &lt;- DiceDesign::maximinSA_LHS(DiceDesign::lhsDesign(n=100,
                                                               dimension = d,
                                                               seed=1)$design)$design

# obtain nsims posterior realization at simu_points
nsims &lt;- 30
nn_data&lt;-expand.grid(seq(0,1,,50),seq(0,1,,50))
nn_data&lt;-data.frame(nn_data)
colnames(nn_data)&lt;-colnames(kmModel@X)
approx.simu &lt;- simulate_and_interpolate(object=kmModel, nsim = nsims, simupoints = simu_points,
                                        interpolatepoints = as.matrix(nn_data),
                                        nugget.sim = 0, type = "UK")
Dvar&lt;- DTV(rand.set = approx.simu,threshold = -10,
                             nsim = nsims,n.int.points = 50^2)

image(matrix(Dvar$dbar,ncol=50),col=grey.colors(20),main="average distance transform")
image(matrix(Dvar$dvar,ncol=50),col=grey.colors(20),main="variance of distance transform")
points(design,pch=17)

</code></pre>

<hr>
<h2 id='edm_crit'>Distance in measure criterion</h2><span id='topic+edm_crit'></span>

<h3>Description</h3>

<p>Computes the distance in measure criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edm_crit(
  x,
  integration.points,
  integration.weights = NULL,
  intpoints.oldmean,
  intpoints.oldsd,
  precalc.data,
  model,
  threshold,
  batchsize,
  alpha,
  current.crit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edm_crit_+3A_x">x</code></td>
<td>
<p>vector of dimension <code class="reqn">d</code> representing the <code class="reqn">ith</code> point where to compute the criterion</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p corresponding to the kriging mean at the integration points.</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p corresponding to the kriging standard deviation at the integration points.</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_precalc.data">precalc.data</code></td>
<td>
<p>list result of <a href="KrigInv.html#topic+precomputeUpdateData">precomputeUpdateData</a> with <code>model</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_model">model</code></td>
<td>
<p>km model</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_threshold">threshold</code></td>
<td>
<p>threshold selected for excursion set</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_batchsize">batchsize</code></td>
<td>
<p>number of simulation points</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_alpha">alpha</code></td>
<td>
<p>value of Vorob'ev threshold</p>
</td></tr>
<tr><td><code id="edm_crit_+3A_current.crit">current.crit</code></td>
<td>
<p>Current value of the criterion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the expected distance in measure criterion at <code class="reqn">x</code>
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>

<hr>
<h2 id='edm_crit2'>Distance in measure criterion</h2><span id='topic+edm_crit2'></span>

<h3>Description</h3>

<p>Computes the distance in measure criterion. To be used in optimization routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edm_crit2(
  x,
  other.points,
  integration.points,
  integration.weights = NULL,
  intpoints.oldmean,
  intpoints.oldsd,
  precalc.data,
  model,
  threshold,
  batchsize,
  alpha,
  current.crit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edm_crit2_+3A_x">x</code></td>
<td>
<p>vector of dimension <code class="reqn">d</code> representing the point where to compute the criterion</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_other.points">other.points</code></td>
<td>
<p>Vector giving the other batchsize-1 points at which one wants to evaluate the criterion</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p corresponding to the kriging mean at the integration points.</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p corresponding to the kriging standard deviation at the integration points.</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_precalc.data">precalc.data</code></td>
<td>
<p>list result of <a href="KrigInv.html#topic+precomputeUpdateData">precomputeUpdateData</a> with <code>model</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_model">model</code></td>
<td>
<p>km model</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_threshold">threshold</code></td>
<td>
<p>threshold selected for excursion set</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_batchsize">batchsize</code></td>
<td>
<p>number of simulation points</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_alpha">alpha</code></td>
<td>
<p>value of Vorob'ev threshold</p>
</td></tr>
<tr><td><code id="edm_crit2_+3A_current.crit">current.crit</code></td>
<td>
<p>Current value of the criterion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the expected distance in measure criterion at <code class="reqn">x</code>,<code>other.points</code>.
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>

<hr>
<h2 id='expDistMeasure'>Compute expected distance in measure of approximate excursion set</h2><span id='topic+expDistMeasure'></span>

<h3>Description</h3>

<p>Computes expected distance in measure between the excursion set of the approximated process and the true excursion set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expDistMeasure(
  simupoints,
  model,
  threshold,
  batchsize,
  integration.param = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expDistMeasure_+3A_simupoints">simupoints</code></td>
<td>
<p>a numeric array of size <code>batchsize*d</code> containing the simulation points.</p>
</td></tr>
<tr><td><code id="expDistMeasure_+3A_model">model</code></td>
<td>
<p>a km model</p>
</td></tr>
<tr><td><code id="expDistMeasure_+3A_threshold">threshold</code></td>
<td>
<p>threshold value</p>
</td></tr>
<tr><td><code id="expDistMeasure_+3A_batchsize">batchsize</code></td>
<td>
<p>number of simulations points</p>
</td></tr>
<tr><td><code id="expDistMeasure_+3A_integration.param">integration.param</code></td>
<td>
<p>a list containing parameters for the integration of the criterion A, see <a href="KrigInv.html#topic+max_sur_parallel">max_sur_parallel</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive value indicating the expected distance in measure.
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Compute optimal simulation points in a 2d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
# Define the function
g=function(x){
  return(-DiceKriging::branin(x))
}
d=2
# Fit OK km model
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=20,
                                                                  dimension = 2,
                                                                  seed=42)$design)$design
colnames(design)&lt;-c("x1","x2")
observations&lt;-apply(X = design,MARGIN = 1,FUN = g)
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))


threshold &lt;- -10

# Obtain simulation point sampling from maximin LHS design
batchsize &lt;- 50
set.seed(1)
mmLHS_simu_points &lt;-  DiceDesign::maximinSA_LHS(DiceDesign::lhsDesign(n=batchsize,
                                                                     dimension = d,
                                                                     seed=1)$design)$design


# Compute expected distance in measure for approximation obtain from random simulation points
EDM_mmLHS &lt;- rep(NA,batchsize)
integcontrol &lt;- list(distrib="sobol",n.points=1000)
integration.param &lt;- KrigInv::integration_design(integcontrol,d=d,
                                        lower=c(0,0),upper=c(1,1),
                                        model=kmModel,T=threshold)
integration.param$alpha &lt;- 0.5
for(i in seq(1,batchsize)){
EDM_mmLHS[i]&lt;-expDistMeasure( mmLHS_simu_points[1:i,],model = kmModel,
                             threshold = threshold,batchsize = i,
                             integration.param = integration.param  )
}

plot(EDM_mmLHS,type='l',main="Expected distance in measure",xlab="batchsize")


## Not run: 
# Get optimized simulation points with algorithm B
simu_points &lt;- optim_dist_measure(model=kmModel,threshold = threshold,
                                  lower = c(0,0),upper = c(1,1),
                                  batchsize = batchsize,algorithm = "B")
# plot the criterion value
plot(1:batchsize,simu_points$value,type='l',main="Criterion value")

# Compute expected distance in measure for approximation obtained from optimized simulation points
EDM_optB &lt;- rep(NA,batchsize)
for(i in seq(1,batchsize)){
  EDM_optB[i]&lt;-expDistMeasure( simu_points$par[1:i,],model = kmModel,threshold = threshold,
                                 batchsize = i,integration.param = integration.param  )
}
plot(EDM_mmLHS,type='l',main="Expected distance in measure",
     xlab="batchsize",ylab="EDM",
     ylim=range(EDM_mmLHS,EDM_optB))
lines(EDM_optB,col=2,lty=2)
legend("topright",c("Maximin LHS","B"),lty=c(1,2),col=c(1,2))

# Get optimized simulation points with algorithm A
simu_pointsA &lt;- optim_dist_measure(model=kmModel,threshold = threshold,
                                   lower = c(0,0),upper = c(1,1),
                                   batchsize = batchsize,algorithm = "A")
# plot the criterion value
plot(1:batchsize,simu_pointsA$value,type='l',main="Criterion value")

# Compute expected distance in measure for approximation obtained from optimized simulation points
EDM_optA &lt;- rep(NA,batchsize)
for(i in seq(1,batchsize)){
  EDM_optA[i]&lt;-expDistMeasure( simu_pointsA$par[1:i,],model = kmModel,threshold = threshold,
                                 batchsize = i,integration.param = integration.param  )
}
plot(EDM_mmLHS,type='l',main="Expected distance in measure",
     xlab="batchsize",ylab="EDM",
     ylim=range(EDM_mmLHS,EDM_optB,EDM_optA))
lines(EDM_optB,col=2,lty=2)
lines(EDM_optA,col=3,lty=3)
legend("topright",c("Maximin LHS","A","B"),lty=c(1,3,2),col=c(1,3,2))


## End(Not run)
</code></pre>

<hr>
<h2 id='grad_kweights'>Gradient of the weights for interpolating simulations</h2><span id='topic+grad_kweights'></span>

<h3>Description</h3>

<p>Returns a list with the gradients of the posterior mean and the gradient of the (ordinary) kriging weights for simulations points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_kweights(object, simu_points, krig_points, T.mat = NULL, F.mat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grad_kweights_+3A_object">object</code></td>
<td>
<p>km object</p>
</td></tr>
<tr><td><code id="grad_kweights_+3A_simu_points">simu_points</code></td>
<td>
<p>simulations points, locations where the field was simulated.</p>
</td></tr>
<tr><td><code id="grad_kweights_+3A_krig_points">krig_points</code></td>
<td>
<p>one point where the interpolation is computed.</p>
</td></tr>
<tr><td><code id="grad_kweights_+3A_t.mat">T.mat</code></td>
<td>
<p>a matrix (n+p)x(n+p) representing the Choleski factorization of the covariance matrix for the initial design and simulation points.</p>
</td></tr>
<tr><td><code id="grad_kweights_+3A_f.mat">F.mat</code></td>
<td>
<p>a matrix (n+p)x(fdim) representing the evaluation of the model matrix at the initial design and simulation points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the gradients of posterior mean and kriging weights for simulation points.
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######################################################################
### Compute the weights and gradient on a 2d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
# Define the function
g=function(x){
  return(-DiceKriging::branin(x))
}
d=2
# Fit OK km model
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=50,
                                                                  dimension = 2,
                                                                  seed=42)$design)$design
colnames(design)&lt;-c("x1","x2")
observations&lt;-apply(X = design,MARGIN = 1,FUN = g)
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))
# Get simulation points
# Here they are not optimized, you can use optim_dist_measure to find optimized points
set.seed(1)
simu_points &lt;- matrix(runif(100*d),ncol=d)
# obtain nsims posterior realization at simu_points
nsims &lt;- 1
set.seed(2)
some.simu &lt;- DiceKriging::simulate(object=kmModel,nsim=nsims,newdata=simu_points,nugget.sim=1e-6,
                         cond=TRUE,checkNames = FALSE)
nn_data&lt;-expand.grid(seq(0,1,,50),seq(0,1,,50))
nn_data&lt;-data.frame(nn_data)
colnames(nn_data)&lt;-colnames(kmModel@X)
obj&lt;-krig_weight_GPsimu(object = kmModel,simu_points = simu_points,krig_points = as.matrix(nn_data))


## Plot the approximate process realization and the gradient vector field
k_scale&lt;-5e-4
image(matrix(obj$krig.mean.init+crossprod(obj$Lambda.end,some.simu[1,]),ncol=50),
      col=grey.colors(20))
contour(matrix(obj$krig.mean.init+crossprod(obj$Lambda.end,some.simu[1,]),ncol=50),
        nlevels = 20,add=TRUE)

for(c_ii in c(1,seq(10,2500,by = 64))){
   pp&lt;-t(as.matrix(nn_data)[c_ii,])
   obj_deriv &lt;- grad_kweights(object = kmModel,simu_points = simu_points,krig_points = pp)
   S_der&lt;-obj_deriv$krig.mean.init + crossprod(obj_deriv$Lambda.end,some.simu[1,])
   points(x = pp[1],y = pp[2],pch=16)
   arrows(x0=pp[1],y0=pp[2],x1 = pp[1]+k_scale*S_der[1,1],y1=pp[2]+k_scale*S_der[2,1])
}

</code></pre>

<hr>
<h2 id='integrand_edm_crit'>Integrand of the distance in measure criterion</h2><span id='topic+integrand_edm_crit'></span>

<h3>Description</h3>

<p>Computes the integrand of the distance in measure criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrand_edm_crit(
  x,
  E,
  model,
  Thresh,
  batchsize,
  alpha,
  predE,
  predx = NULL,
  precalc.data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrand_edm_crit_+3A_x">x</code></td>
<td>
<p>vector of dimension <code class="reqn">d</code> representing the <code class="reqn">ith</code> point where to compute the criterion</p>
</td></tr>
<tr><td><code id="integrand_edm_crit_+3A_e">E</code></td>
<td>
<p>matrix of dimension <code class="reqn">d*(i-1)</code> containing the previously optimized simulation points</p>
</td></tr>
<tr><td><code id="integrand_edm_crit_+3A_model">model</code></td>
<td>
<p>km model</p>
</td></tr>
<tr><td><code id="integrand_edm_crit_+3A_thresh">Thresh</code></td>
<td>
<p>threshold selected for excursion set</p>
</td></tr>
<tr><td><code id="integrand_edm_crit_+3A_batchsize">batchsize</code></td>
<td>
<p>number of simulation points</p>
</td></tr>
<tr><td><code id="integrand_edm_crit_+3A_alpha">alpha</code></td>
<td>
<p>value of Vorob'ev threshold</p>
</td></tr>
<tr><td><code id="integrand_edm_crit_+3A_prede">predE</code></td>
<td>
<p>list containing the posterior mean and standard deviation at E</p>
</td></tr>
<tr><td><code id="integrand_edm_crit_+3A_predx">predx</code></td>
<td>
<p>list containing the posterior mean and standard deviation at x</p>
</td></tr>
<tr><td><code id="integrand_edm_crit_+3A_precalc.data">precalc.data</code></td>
<td>
<p>list result of <a href="KrigInv.html#topic+precomputeUpdateData">precomputeUpdateData</a> with <code>model</code> and <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the integrand at <code class="reqn">x</code>
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>

<hr>
<h2 id='krig_weight_GPsimu'>Weights for interpolating simulations</h2><span id='topic+krig_weight_GPsimu'></span>

<h3>Description</h3>

<p>Returns a list with the posterior mean and the kriging weights for simulations points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krig_weight_GPsimu(
  object,
  simu_points,
  krig_points,
  T.mat = NULL,
  F.mat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krig_weight_GPsimu_+3A_object">object</code></td>
<td>
<p>km object.</p>
</td></tr>
<tr><td><code id="krig_weight_GPsimu_+3A_simu_points">simu_points</code></td>
<td>
<p>simulations points, locations where the field was simulated.</p>
</td></tr>
<tr><td><code id="krig_weight_GPsimu_+3A_krig_points">krig_points</code></td>
<td>
<p>points where the interpolation is computed.</p>
</td></tr>
<tr><td><code id="krig_weight_GPsimu_+3A_t.mat">T.mat</code></td>
<td>
<p>a matrix (n+p)x(n+p) representing the Choleski factorization of the covariance matrix for the initial design and simulation points.</p>
</td></tr>
<tr><td><code id="krig_weight_GPsimu_+3A_f.mat">F.mat</code></td>
<td>
<p>a matrix (n+p)x(fdim) representing the evaluation of the model matrix at the initial design and simulation points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the posterior mean and the (ordinary) kriging weights for simulation points.
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######################################################################
### Compute the weights for approximating process on a 1d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
## Create kriging model from GP realization
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=20,
                                                                 dimension = 1,
                                                                 seed=42)$design)$design
colnames(design)&lt;-c("x1")
gp0 &lt;- DiceKriging::km (formula = ~1, design = design,
                        response = rep (x = 0, times = nrow (design)),
                        covtype = "matern3_2", coef.trend = 0,
                        coef.var = 1, coef.cov = 0.2)
set.seed(1)
observations &lt;- t (DiceKriging::simulate (object = gp0, newdata = design, cond = FALSE))

# Fit OK km model
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))

# Get simulation points
# Here they are not optimized, you can use optim_dist_measure to find optimized points
set.seed(2)
simu_points &lt;- matrix(runif(20),ncol=1)
# obtain nsims posterior realization at simu_points
nsims &lt;- 10
set.seed(3)
some.simu &lt;- DiceKriging::simulate(object=kmModel,nsim=nsims,newdata=simu_points,nugget.sim=1e-6,
                         cond=TRUE,checkNames = FALSE)
grid&lt;-seq(0,1,,100)
nn_data&lt;-data.frame(grid)
colnames(nn_data)&lt;-colnames(kmModel@X)
pred_nn&lt;-DiceKriging::predict.km(object = kmModel,newdata = nn_data,type = "UK")
obj &lt;- krig_weight_GPsimu(object=kmModel,simu_points=simu_points,krig_points=grid)


# Plot the posterior mean and some approximate process realizations
result &lt;- matrix(nrow=nsims,ncol=length(grid))

plot(nn_data$x1,pred_nn$mean,type='l')
for(i in 1:nsims){
   some.simu.i &lt;- matrix(some.simu[i,],ncol=1)
   result[i,] &lt;- obj$krig.mean.init + crossprod(obj$Lambda.end,some.simu.i)
   points(simu_points,some.simu.i)
   lines(grid,result[i,],col=3)
}

</code></pre>

<hr>
<h2 id='max_distance_measure'>Minimize the distance in measure criterion</h2><span id='topic+max_distance_measure'></span>

<h3>Description</h3>

<p>Optimizes the distance in measure criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_distance_measure(
  lower,
  upper,
  optimcontrol = NULL,
  batchsize,
  integration.param,
  T,
  model
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_distance_measure_+3A_lower">lower</code></td>
<td>
<p>a <code class="reqn">d</code> dimensional vector containing the lower bounds for the optimization</p>
</td></tr>
<tr><td><code id="max_distance_measure_+3A_upper">upper</code></td>
<td>
<p>a <code class="reqn">d</code> dimensional vector containing the upper bounds for the optimization</p>
</td></tr>
<tr><td><code id="max_distance_measure_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>the parameters for the optimization, see <a href="KrigInv.html#topic+max_sur_parallel">max_sur_parallel</a> for more details.</p>
</td></tr>
<tr><td><code id="max_distance_measure_+3A_batchsize">batchsize</code></td>
<td>
<p>number of simulations points to find</p>
</td></tr>
<tr><td><code id="max_distance_measure_+3A_integration.param">integration.param</code></td>
<td>
<p>the parameters for the integration of the criterion, see <a href="KrigInv.html#topic+max_sur_parallel">max_sur_parallel</a> for more details.</p>
</td></tr>
<tr><td><code id="max_distance_measure_+3A_t">T</code></td>
<td>
<p>threshold value</p>
</td></tr>
<tr><td><code id="max_distance_measure_+3A_model">model</code></td>
<td>
<p>a km model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing </p>

<ul>
<li> <p><code>par</code> a matrix <code>batchsize*d</code> containing the optimal points
</p>
</li>
<li> <p><code>value</code> if <code>optimcontrol$optim.option!=1</code> and <code>optimcontrol$method=="genoud"</code> (default options) a vector of length <code>batchsize</code> containing the optimum at each step
otherwise the value of the criterion at the optimum.
</p>
</li></ul>



<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>

<hr>
<h2 id='max_integrand_edm'>Maximize the integrand distance in measure criterion</h2><span id='topic+max_integrand_edm'></span>

<h3>Description</h3>

<p>Optimizes the integrand of the distance in measure criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_integrand_edm(
  lower,
  upper,
  batchsize,
  alpha = 0.5,
  Thresh,
  model,
  verb = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_integrand_edm_+3A_lower">lower</code></td>
<td>
<p>a <code class="reqn">d</code> dimensional vector containing the lower bounds for the optimization</p>
</td></tr>
<tr><td><code id="max_integrand_edm_+3A_upper">upper</code></td>
<td>
<p>a <code class="reqn">d</code> dimensional vector containing the upper bounds for the optimization</p>
</td></tr>
<tr><td><code id="max_integrand_edm_+3A_batchsize">batchsize</code></td>
<td>
<p>number of simulations points to find</p>
</td></tr>
<tr><td><code id="max_integrand_edm_+3A_alpha">alpha</code></td>
<td>
<p>value of Vorob'ev threshold</p>
</td></tr>
<tr><td><code id="max_integrand_edm_+3A_thresh">Thresh</code></td>
<td>
<p>threshold value</p>
</td></tr>
<tr><td><code id="max_integrand_edm_+3A_model">model</code></td>
<td>
<p>a km model</p>
</td></tr>
<tr><td><code id="max_integrand_edm_+3A_verb">verb</code></td>
<td>
<p>an integer to choose the level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing </p>

<ul>
<li> <p><code>par</code> a matrix <code>batchsize*d</code> containing the optimal points
</p>
</li>
<li> <p><code>value</code> a vector of length <code>batchsize</code> with the value of the criterion after each optimization
</p>
</li>
<li> <p><code>fcount</code> count of the number of criterion evaluations
</p>
</li></ul>



<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>

<hr>
<h2 id='optim_dist_measure'>Choose simulation points</h2><span id='topic+optim_dist_measure'></span>

<h3>Description</h3>

<p>Selects <code>batchsize</code> locations where to simulate the field by minimizing the distance in measure criterion or by maximizing the integrand of the distance in measure criterion. Currently it is only a wrapper for the functions <code>max_distance_measure</code> and <code>max_integrand_edm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_dist_measure(
  model,
  threshold,
  lower,
  upper,
  batchsize,
  algorithm = "B",
  alpha = 0.5,
  verb = 1,
  optimcontrol = NULL,
  integration.param = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim_dist_measure_+3A_model">model</code></td>
<td>
<p>a km model</p>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_threshold">threshold</code></td>
<td>
<p>threshold value</p>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_lower">lower</code></td>
<td>
<p>a <code class="reqn">d</code> dimensional vector containing the lower bounds for the optimization</p>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_upper">upper</code></td>
<td>
<p>a <code class="reqn">d</code> dimensional vector containing the upper bounds for the optimization</p>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_batchsize">batchsize</code></td>
<td>
<p>number of simulations points to find</p>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_algorithm">algorithm</code></td>
<td>
<p>type of algorithm used to obtain simulation points: </p>

<ul>
<li> <p><code>"A"</code> minimize the full integral criterion;
</p>
</li>
<li> <p><code>"B"</code> maximize the integrand of the criterion.
</p>
</li></ul>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_alpha">alpha</code></td>
<td>
<p>value of Vorob'ev threshold</p>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_verb">verb</code></td>
<td>
<p>an integer to choose the level of verbosity</p>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>a list containing optional parameters for the optimization, see <a href="KrigInv.html#topic+max_sur_parallel">max_sur_parallel</a> for more details.</p>
</td></tr>
<tr><td><code id="optim_dist_measure_+3A_integration.param">integration.param</code></td>
<td>
<p>a list containing parameters for the integration of the criterion A, see <a href="KrigInv.html#topic+max_sur_parallel">max_sur_parallel</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing </p>

<ul>
<li> <p><code>par</code> a matrix <code>batchsize*d</code> containing the optimal points
</p>
</li>
<li> <p><code>value</code> a vector of length <code>batchsize</code> with the values of the criterion at each step
</p>
</li></ul>



<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Compute optimal simulation points in a 2d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
# Define the function
g=function(x){
  return(-DiceKriging::branin(x))
}
d=2
# Fit OK km model
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=20,
                                                                  dimension = 2,
                                                                  seed=42)$design)$design
colnames(design)&lt;-c("x1","x2")
observations&lt;-apply(X = design,MARGIN = 1,FUN = g)
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))

# Run optim_dist_measure, algorithm B to obtain one simulation point
# NOTE: the approximating process resulting from 1 simulation point
# is very rough and it should not be used, see below for a more principled example.
simu_pointsB &lt;- optim_dist_measure(model=kmModel,threshold = -10,
                                  lower = c(0,0),upper = c(1,1),
                                  batchsize = 1,algorithm = "B")

## Not run: 
# Get 75 simulation points with algorithm A
batchsize &lt;- 50
simu_pointsA &lt;- optim_dist_measure(model=kmModel,threshold = -10,
                                  lower = c(0,0),upper = c(1,1),
                                  batchsize = batchsize,algorithm = "A")

# Get 75 simulation points with algorithm B
batchsize &lt;- 75
simu_pointsB &lt;- optim_dist_measure(model=kmModel,threshold = -10,
                                  lower = c(0,0),upper = c(1,1),
                                  batchsize = batchsize,algorithm = "B")
# plot the criterion value
critValA &lt;-c(simu_pointsA$value,rep(NA,25))
par(mar = c(5,5,2,5))
plot(1:batchsize,critValA,type='l',main="Criterion value",ylab="Algorithm A",xlab="batchsize")
par(new=T)
plot(1:batchsize,simu_pointsB$value, axes=F, xlab=NA, ylab=NA,col=2,lty=2,type='l')
axis(side = 4)
mtext(side = 4, line = 3, 'Algorithm B')
legend("topright",c("Algorithm A","Algorithm B"),lty=c(1,2),col=c(1,2))
par(mar= c(5, 4, 4, 2) + 0.1)

# obtain nsims posterior realization at simu_points
nsims &lt;- 1
nn_data&lt;-expand.grid(seq(0,1,,50),seq(0,1,,50))
nn_data&lt;-data.frame(nn_data)
colnames(nn_data)&lt;-colnames(kmModel@X)
approx.simu &lt;- simulate_and_interpolate(object=kmModel, nsim = 1, simupoints = simu_pointsA$par,
                                        interpolatepoints = as.matrix(nn_data),
                                        nugget.sim = 0, type = "UK")

## Plot the approximate process realization
image(matrix(approx.simu[1,],ncol=50),
      col=grey.colors(20))
contour(matrix(approx.simu[1,],ncol=50),
        nlevels = 20,add=TRUE)
points(simu_pointsA$par,pch=17)
points(simu_pointsB$par,pch=1,col=2)


## End(Not run)
</code></pre>

<hr>
<h2 id='simulate_and_interpolate'>Simulate and interpolate</h2><span id='topic+simulate_and_interpolate'></span>

<h3>Description</h3>

<p>Generates <code>nsims</code> approximate posterior field realizations
at <code>interpolatepoints</code>. The approximate realizations are computed by
simulating the field only at <code>simupoints</code> simulation points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_and_interpolate(
  object,
  nsim = 1,
  simupoints = NULL,
  interpolatepoints = NULL,
  nugget.sim = 0,
  type = "UK"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_and_interpolate_+3A_object">object</code></td>
<td>
<p>km object</p>
</td></tr>
<tr><td><code id="simulate_and_interpolate_+3A_nsim">nsim</code></td>
<td>
<p>numbero of simulations</p>
</td></tr>
<tr><td><code id="simulate_and_interpolate_+3A_simupoints">simupoints</code></td>
<td>
<p>simulations points, locations where the field was simulated</p>
</td></tr>
<tr><td><code id="simulate_and_interpolate_+3A_interpolatepoints">interpolatepoints</code></td>
<td>
<p>points where posterior simulations are approximated</p>
</td></tr>
<tr><td><code id="simulate_and_interpolate_+3A_nugget.sim">nugget.sim</code></td>
<td>
<p>nugget to be added to simulations for numerical stability</p>
</td></tr>
<tr><td><code id="simulate_and_interpolate_+3A_type">type</code></td>
<td>
<p>type of kriging model used for approximation (default Universal Kriging)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>nsim*interpolatepoints</code> containing the approximate realizations.
</p>


<h3>References</h3>

<p>Azzimonti D. F., Bect J., Chevalier C. and Ginsbourger D. (2016). Quantifying uncertainties on excursion sets under a Gaussian random field prior. SIAM/ASA Journal on Uncertainty Quantification, 4(1):850–874.
</p>
<p>Azzimonti, D. (2016). Contributions to Bayesian set estimation relying on random field priors. PhD thesis, University of Bern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulate and interpolate for a 2d example
if (!requireNamespace("DiceKriging", quietly = TRUE)) {
stop("DiceKriging needed for this example to work. Please install it.",
     call. = FALSE)
}
if (!requireNamespace("DiceDesign", quietly = TRUE)) {
stop("DiceDesign needed for this example to work. Please install it.",
     call. = FALSE)
}
# Define the function
g=function(x){
  return(-DiceKriging::branin(x))
}
d=2
# Fit OK km model
design&lt;-DiceDesign::maximinESE_LHS(design = DiceDesign::lhsDesign(n=50,
                                                                  dimension = 2,
                                                                  seed=42)$design)$design
colnames(design)&lt;-c("x1","x2")
observations&lt;-apply(X = design,MARGIN = 1,FUN = g)
kmModel&lt;-DiceKriging::km(formula = ~1,design = design,response = observations,
                         covtype = "matern3_2",control=list(trace=FALSE))
# Get simulation points
# Here they are not optimized, you can use optim_dist_measure to find optimized points
simu_points &lt;- DiceDesign::maximinSA_LHS(DiceDesign::lhsDesign(n=100,
                                                               dimension = d,
                                                               seed=1)$design)$design
# obtain nsims posterior realization at simu_points
nsims &lt;- 1
nn_data&lt;-expand.grid(seq(0,1,,50),seq(0,1,,50))
nn_data&lt;-data.frame(nn_data)
colnames(nn_data)&lt;-colnames(kmModel@X)
approx.simu &lt;- simulate_and_interpolate(object=kmModel, nsim = 1, simupoints = simu_points,
                                        interpolatepoints = as.matrix(nn_data),
                                        nugget.sim = 0, type = "UK")

## Plot the approximate process realization
image(matrix(approx.simu[1,],ncol=50),
      col=grey.colors(20))
contour(matrix(approx.simu[1,],ncol=50),
        nlevels = 20,add=TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
