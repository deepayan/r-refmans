<!DOCTYPE html><html lang="en"><head><title>Help for package BayesPostEst</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesPostEst}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesPostEst'><p>BayesPostEst Overview</p></a></li>
<li><a href='#BayesPostEst-deprecated'><p>Deprecated functions in package <span class="pkg">BayesPostEst</span>.</p></a></li>
<li><a href='#compute_roc'><p>Compute ROC and PR curve points</p></a></li>
<li><a href='#identify_link_function'><p>Try to identify link function</p></a></li>
<li><a href='#is_binary_model'><p>Try to identify if a stanfit model is a binary choice model</p></a></li>
<li><a href='#jags_interactive'><p>Fitted JAGS interactive linear model</p></a></li>
<li><a href='#jags_interactive_cat'><p>Fitted JAGS interactive linear model with categorical moderator</p></a></li>
<li><a href='#jags_logit'><p>Fitted JAGS logit model</p></a></li>
<li><a href='#jags_probit'><p>Fitted JAGS probit model</p></a></li>
<li><a href='#mcmcAveProb'><p>Predicted Probabilities using Bayesian MCMC estimates for the &quot;Average&quot; Case</p></a></li>
<li><a href='#mcmcCoefPlot'><p>Coefficient Plots for MCMC Output</p></a></li>
<li><a href='#mcmcFD'><p>First Differences of a Bayesian Logit or Probit model</p></a></li>
<li><a href='#mcmcMargEff'><p>Marginal Effects Plots for MCMC Output</p></a></li>
<li><a href='#mcmcObsProb'><p>Predicted Probabilities using Bayesian MCMC estimates for the Average of Observed Cases</p></a></li>
<li><a href='#mcmcReg'><p>LaTeX or HTML regression tables for MCMC Output</p></a></li>
<li><a href='#mcmcRocPrcGen'><p>ROC and Precision-Recall Curves using Bayesian MCMC estimates generalized</p></a></li>
<li><a href='#mcmcTab'><p>Summarize Bayesian MCMC Output</p>
</p>
<p>R function for summarizing MCMC output in a regression-style table.</p></a></li>
<li><a href='#new_mcmcRocPrc'><p>Constructor for mcmcRocPrc objects</p></a></li>
<li><a href='#plot.mcmcFD'><p>Plot Method for First Differences from MCMC output</p></a></li>
<li><a href='#print.mcmcRocPrc'><p>ROC and Precision-Recall Curves using Bayesian MCMC estimates</p></a></li>
<li><a href='#sim_data'><p>Simulated data for examples</p></a></li>
<li><a href='#sim_data_interactive'><p>Simulated data for examples</p></a></li>
<li><a href='#sim_data_interactive_cat'><p>Simulated data for examples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generate Postestimation Quantities for Bayesian MCMC Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-10</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of functions to generate and plot postestimation quantities after estimating Bayesian regression models using Markov chain Monte Carlo (MCMC). Functionality includes the estimation of the Precision-Recall curves (see Beger, 2016 &lt;<a href="https://doi.org/10.2139%2Fssrn.2765419">doi:10.2139/ssrn.2765419</a>&gt;), the implementation of the observed values method of calculating predicted probabilities by Hanmer and Kalkan (2013) &lt;<a href="https://doi.org/10.1111%2Fj.1540-5907.2012.00602.x">doi:10.1111/j.1540-5907.2012.00602.x</a>&gt;, the implementation of the average value method of calculating predicted probabilities (see King, Tomz, and Wittenberg, 2000 &lt;<a href="https://doi.org/10.2307%2F2669316">doi:10.2307/2669316</a>&gt;), and the generation and plotting of first differences to summarize typical effects across covariates (see Long 1997, ISBN:9780803973749; King, Tomz, and Wittenberg, 2000 &lt;<a href="https://doi.org/10.2307%2F2669316">doi:10.2307/2669316</a>&gt;). This package can be used with MCMC output generated by any Bayesian estimation tool including 'JAGS', 'BUGS', 'MCMCpack', and 'Stan'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ShanaScogin/BayesPostEst">https://github.com/ShanaScogin/BayesPostEst</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ShanaScogin/BayesPostEst/issues">https://github.com/ShanaScogin/BayesPostEst/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>carData, caTools, coda (&ge; 0.13), dplyr (&ge; 0.5.0), ggplot2,
ggridges, reshape2, rlang, stats, texreg, tidyr (&ge; 0.5.1),
HDInterval, ROCR, graphics, grDevices, R2jags, runjags,
rstanarm, rjags, MCMCpack, R2WinBUGS, brms</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>datasets, knitr, rmarkdown, rstan (&ge; 2.10.1), testthat, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS (http://mcmc-jags.sourceforge.io)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-10 20:56:50 UTC; shanascogin</td>
</tr>
<tr>
<td>Author:</td>
<td>Johannes Karreth <a href="https://orcid.org/0000-0003-4586-7153"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Shana Scogin <a href="https://orcid.org/0000-0002-7801-853X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rob Williams <a href="https://orcid.org/0000-0001-9259-3883"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Andreas Beger <a href="https://orcid.org/0000-0003-1883-3169"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Myunghee Lee [ctb],
  Neil Williams [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shana Scogin &lt;shanarscogin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-11 08:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesPostEst'>BayesPostEst Overview</h2><span id='topic+BayesPostEst'></span>

<h3>Description</h3>

<p>This package currently has nine main functions that can be used to generate 
and plot postestimation quantities after estimating Bayesian regression models using MCMC. 
The package combines functions written originally for Johannes Karreth's workshop on 
Bayesian modeling at the ICPSR Summer program. Currently BayesPostEst focuses mostly on 
generalized linear regression models for binary outcomes (logistic and probit regression). 
The vignette for this package has a walk-through of each function in action. 
Please refer to that to get an overview of all the functions, or visit the 
documentation for a specific function of your choice. Johannes Karreth's website
(http://www.jkarreth.net) also has resources for getting started with Bayesian 
analysis, fitting models, and presenting results.
</p>


<h3>Main Functions</h3>


<ul>
<li> <p><code>mcmcAveProb()</code>
</p>
</li>
<li> <p><code>mcmcObsProb()</code>
</p>
</li>
<li> <p><code>mcmcFD()</code>
</p>
</li>
<li> <p><code>mcmcMargEff()</code>
</p>
</li>
<li> <p><code>mcmcRocPrc()</code>
</p>
</li>
<li> <p><code>mcmcRocPrcGen()</code>
</p>
</li>
<li> <p><code>mcmcTab()</code>
</p>
</li>
<li> <p><code>mcmcReg()</code>
</p>
</li>
<li> <p><code>plot.mcmcFD()</code>
</p>
</li></ul>


<hr>
<h2 id='BayesPostEst-deprecated'>Deprecated functions in package <span class="pkg">BayesPostEst</span>.</h2><span id='topic+BayesPostEst-deprecated'></span><span id='topic+mcmcFDplot-deprecated'></span><span id='topic+mcmcFDplot'></span>

<h3>Description</h3>

<p>The functions listed below are deprecated and will be defunct in
the near future. When possible, alternative functions with similar
functionality are also mentioned. Help pages for deprecated functions are
available at <code>help("-deprecated")</code>.
</p>
<p>R function to plot first differences generated from MCMC output.
For more on this method, see the documentation for <code>mcmcFD()</code>, Long (1997, 
Sage Publications), and King, Tomz, and Wittenberg (2000, American Journal 
of Political Science 44(2): 347-361). For a description of this type of plot,
see Figure 1 in Karreth (2018, International Interactions 44(3): 463-90).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcFDplot(fdfull, ROPE = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesPostEst-deprecated_+3A_fdfull">fdfull</code></td>
<td>
<p>Output generated from <code>mcmcFD(..., full_sims = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="BayesPostEst-deprecated_+3A_rope">ROPE</code></td>
<td>
<p>defaults to NULL. If not NULL, a numeric vector of length two, 
defining the Region of Practical Equivalence around 0. See Kruschke (2013, Journal of 
Experimental Psychology 143(2): 573-603) for more on the ROPE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a density plot of the differences in probabilities. The plot is made with ggplot2 and can be
passed on as an object to customize. Annotated numbers show the percent of posterior draws with
the same sign as the median estimate (if <code>ROPE = NULL</code>) or on the same side of the 
ROPE as the median estimate (if <code>ROPE</code> is specified).
</p>


<h3><code>mcmcFDplot</code></h3>

<p>For <code>mcmcFDplot</code>, use <code><a href="#topic+plot.mcmcFD">plot.mcmcFD</a></code>.
</p>


<h3>References</h3>


<ul>
<li><p> Karreth, Johannes. 2018. “The Economic Leverage of International Organizations in Interstate Disputes.” 
International Interactions 44 (3): 463-90. https://doi.org/10.1080/03050629.2018.1389728.
</p>
</li>
<li><p> King, Gary, Michael Tomz, and Jason Wittenberg. 2000. “Making the Most of Statistical 
Analyses: Improving Interpretation and Presentation.” American Journal of Political Science 
44 (2): 347–61. http://www.jstor.org/stable/2669316.
</p>
</li>
<li><p> Kruschke, John K. 2013. “Bayesian Estimation Supersedes the T-Test.” Journal of 
Experimental Psychology: General 142 (2): 573–603. https://doi.org/10.1037/a0029146.
</p>
</li>
<li><p> Long, J. Scott. 1997. Regression Models for Categorical and Limited Dependent Variables. 
Thousand Oaks: Sage Publications.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+BayesPostEst-deprecated">BayesPostEst-deprecated</a></code>
</p>
<p><code><a href="#topic+mcmcFD">mcmcFD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
## simulating data
set.seed(1234)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr) 
df &lt;- data.frame(cbind(X1, X2, Y))

## formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits, 
                    parameters.to.save = params, n.chains = 2, n.iter = 2000, 
                    n.burnin = 1000, model.file = model)

## preparing data for mcmcFD()
xmat &lt;- model.matrix(Y ~ X1 + X2, data = df)
mcmc &lt;- coda::as.mcmc(fit)
mcmc_mat &lt;- as.matrix(mcmc)[, 1:ncol(xmat)]

## plotting with mcmcFDplot()
full &lt;- mcmcFD(modelmatrix = xmat,
               mcmcout = mcmc_mat,
               fullsims = TRUE)
# suppress deprecated warning for R check
suppressWarnings(mcmcFDplot(full))

}




</code></pre>

<hr>
<h2 id='compute_roc'>Compute ROC and PR curve points</h2><span id='topic+compute_roc'></span><span id='topic+compute_pr'></span>

<h3>Description</h3>

<p>Faster replacements for calculating ROC and PR curve data than with
<code><a href="ROCR.html#topic+prediction">ROCR::prediction()</a></code> and <code><a href="ROCR.html#topic+performance">ROCR::performance()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_roc(yvec, pvec)

compute_pr(yvec, pvec)
</code></pre>


<h3>Details</h3>

<p>Replacements to use instead of a combination of <code><a href="ROCR.html#topic+prediction">ROCR::prediction()</a></code>
and <code><a href="ROCR.html#topic+performance">ROCR::performance()</a></code> to calculate ROC and PR curves. These functions are
about 10 to 20 times faster when using <code><a href="#topic+mcmcRocPrc">mcmcRocPrc()</a></code> with <code>curves = TRUE</code>
and/or <code>fullsims = TRUE</code>.
</p>
<p>See this <a href="https://github.com/ShanaScogin/BayesPostEst/issues/25">issue on GH (ShanaScogin/BayesPostEst#25)</a> for more general details.
</p>
<p>And <a href="https://github.com/andybega/BayesPostEst/blob/f1da23b9db86461d4f9c671d9393265dd10578c5/tests/profile-mcmcRocPrc.md">here is a note</a> with specific performance benchmarks, compared to the
old approach relying on ROCR.
</p>

<hr>
<h2 id='identify_link_function'>Try to identify link function</h2><span id='topic+identify_link_function'></span>

<h3>Description</h3>

<p>Try to identify link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_link_function(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_link_function_+3A_obj">obj</code></td>
<td>
<p>stanfit object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either &quot;logit&quot; or &quot;probit&quot;; if neither can be identified the function
will return 'NA_character_'.
</p>

<hr>
<h2 id='is_binary_model'>Try to identify if a stanfit model is a binary choice model</h2><span id='topic+is_binary_model'></span>

<h3>Description</h3>

<p>Try to identify if a stanfit model is a binary choice model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_binary_model(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_binary_model_+3A_obj">obj</code></td>
<td>
<p>stanfit object</p>
</td></tr>
</table>

<hr>
<h2 id='jags_interactive'>Fitted JAGS interactive linear model</h2><span id='topic+jags_interactive'></span>

<h3>Description</h3>

<p>A fitted JAGS linear model with interaction term generated with
[R2jags::jags()]. See the example  code below for how it was created. Used
in examples and for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags_interactive
</code></pre>


<h3>Format</h3>

<p>A class &quot;rjags&quot; object created by [R2jags::jags()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
data("sim_data_interactive")

## formatting the data for jags
datjags &lt;- as.list(sim_data_interactive)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dnorm(mu[i], sigma)  ## Bernoulli distribution of y_i
    
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i] +
      b[4] * X1[i] * X2[i]
    
  }
  
  for(j in 1:4){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
  sigma ~ dexp(1)
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 4))
inits2 &lt;- list("b" = rep(0, 4))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
jags_interactive &lt;- R2jags::jags(data = datjags, inits = inits, 
                                 parameters.to.save = params, n.chains = 2,
                                 n.iter = 2000, n.burnin = 1000,
                                 model.file = model)
                                 
}

</code></pre>

<hr>
<h2 id='jags_interactive_cat'>Fitted JAGS interactive linear model with categorical moderator</h2><span id='topic+jags_interactive_cat'></span>

<h3>Description</h3>

<p>A fitted JAGS linear model with interaction term generated with
[R2jags::jags()]. See the example  code below for how it was created. Used
in examples and for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags_interactive_cat
</code></pre>


<h3>Format</h3>

<p>A class &quot;rjags&quot; object created by [R2jags::jags()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
data("sim_data_interactive_cat")

## formatting the data for jags
datjags &lt;- as.list(sim_data_interactive_cat)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dnorm(mu[i], sigma)  ## Bernoulli distribution of y_i
    
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X3[i] +
      b[4] * X1[i] * X3[i]
    
  }
  
  for(j in 1:4){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
  sigma ~ dexp(1)
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 4))
inits2 &lt;- list("b" = rep(0, 4))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
jags_interactive_cat &lt;- R2jags::jags(data = datjags, inits = inits,
                                     parameters.to.save = params, n.chains = 2,
                                     n.iter = 2000, n.burnin = 1000,
                                     model.file = model)
                                 
}

</code></pre>

<hr>
<h2 id='jags_logit'>Fitted JAGS logit model</h2><span id='topic+jags_logit'></span>

<h3>Description</h3>

<p>A fitted JAGS logit model generated with [R2jags::jags()]. See the example 
code below for how it was created. Used in examples and for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags_logit
</code></pre>


<h3>Format</h3>

<p>A class &quot;rjags&quot; object created by [R2jags::jags()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
data("sim_data")
  
## formatting the data for jags
datjags &lt;- as.list(sim_data)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {

  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
      logit(p[i]) &lt;- mu[i]    ## Logit link function
      mu[i] &lt;- b[1] +
        b[2] * X1[i] +
        b[3] * X2[i]
  }

  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }

}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
jags_logit &lt;- R2jags::jags(data = datjags, inits = inits,
                         parameters.to.save = params, n.chains = 2, 
                         n.iter = 2000, n.burnin = 1000, model.file = model)

}


</code></pre>

<hr>
<h2 id='jags_probit'>Fitted JAGS probit model</h2><span id='topic+jags_probit'></span>

<h3>Description</h3>

<p>A fitted JAGS probit model generated with [R2jags::jags()]. See the example 
code below for how it was created. Used in examples and for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jags_probit
</code></pre>


<h3>Format</h3>

<p>A class &quot;rjags&quot; object created by [R2jags::jags()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
data("sim_data")
  
## formatting the data for jags
datjags &lt;- as.list(sim_data)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {

  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
      probit(p[i]) &lt;- mu[i]    ## Update with probit link function
      mu[i] &lt;- b[1] +
        b[2] * X1[i] +
        b[3] * X2[i]
  }

  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }

}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
jags_probit &lt;- R2jags::jags(data = datjags, inits = inits,
                         parameters.to.save = params, n.chains = 2, 
                         n.iter = 2000, n.burnin = 1000, model.file = model)

}


</code></pre>

<hr>
<h2 id='mcmcAveProb'>Predicted Probabilities using Bayesian MCMC estimates for the &quot;Average&quot; Case</h2><span id='topic+mcmcAveProb'></span>

<h3>Description</h3>

<p>This function calculates predicted probabilities for &quot;average&quot; cases after 
a Bayesian logit or probit model. As &quot;average&quot; cases, this function calculates the median
value of each predictor. For an explanation of predicted probabilities for 
&quot;average&quot; cases, see e.g. King, Tomz &amp; Wittenberg (2000, American Journal of 
Political Science 44(2): 347-361).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcAveProb(
  modelmatrix,
  mcmcout,
  xcol,
  xrange,
  xinterest,
  link = "logit",
  ci = c(0.025, 0.975),
  fullsims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcAveProb_+3A_modelmatrix">modelmatrix</code></td>
<td>
<p>model matrix, including intercept (if the intercept is among the
parameters estimated in the model). Create with model.matrix(formula, data).
Note: the order of columns in the model matrix must correspond to the order of columns 
in the matrix of posterior draws in the <code>mcmcout</code> argument. See the <code>mcmcout</code>
argument for more.</p>
</td></tr>
<tr><td><code id="mcmcAveProb_+3A_mcmcout">mcmcout</code></td>
<td>
<p>posterior distributions of all logit coefficients, 
in matrix form. This can be created from rstan, MCMCpack, R2jags, etc. and transformed
into a matrix using the function as.mcmc() from the coda package for <code>jags</code> class
objects, as.matrix() from base R for <code>mcmc</code>, <code>mcmc.list</code>, <code>stanreg</code>, and 
<code>stanfit</code> class objects, and <code>object$sims.matrix</code> for <code>bugs</code> class objects.
Note: the order of columns in this matrix must correspond to the order of columns 
in the model matrix. One can do this by examining the posterior distribution matrix and sorting the 
variables in the order of this matrix when creating the model matrix. A useful function for sorting 
column names containing both characters and numbers as 
you create the matrix of posterior distributions is <code>mixedsort()</code> from the gtools package.</p>
</td></tr>
<tr><td><code id="mcmcAveProb_+3A_xcol">xcol</code></td>
<td>
<p>column number of the posterior draws (<code>mcmcout</code>) and model matrices 
that corresponds to the explanatory variable for which to calculate associated Pr(y = 1).
Note that the columns in these matrices must match.</p>
</td></tr>
<tr><td><code id="mcmcAveProb_+3A_xrange">xrange</code></td>
<td>
<p>name of the vector with the range of relevant values of the 
explanatory variable for which to calculate associated Pr(y = 1).</p>
</td></tr>
<tr><td><code id="mcmcAveProb_+3A_xinterest">xinterest</code></td>
<td>
<p>semi-optional argument. Name of the explanatory variable for which 
to calculate associated Pr(y = 1). If <code>xcol</code> is supplied, this is not needed. 
If both are supplied, the function defaults to <code>xcol</code> and this argument is ignored.</p>
</td></tr>
<tr><td><code id="mcmcAveProb_+3A_link">link</code></td>
<td>
<p>type of generalized linear model; a character vector set to <code>"logit"</code> 
(default) or <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="mcmcAveProb_+3A_ci">ci</code></td>
<td>
<p>the bounds of the credible interval. Default is <code>c(0.025, 0.975)</code> for the 95% 
credible interval.</p>
</td></tr>
<tr><td><code id="mcmcAveProb_+3A_fullsims">fullsims</code></td>
<td>
<p>logical indicator of whether full object (based on all MCMC draws 
rather than their average) will be returned. Default is <code>FALSE</code>. Note: The longer 
<code>xrange</code> is, the larger the full output will be if <code>TRUE</code> is selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates predicted probabilities for &quot;average&quot; cases after a Bayesian 
logit or probit model. For an explanation of predicted probabilities for &quot;average&quot; cases,
see e.g. King, Tomz &amp; Wittenberg (2000, American Journal of Political Science 44(2): 347-361)
</p>


<h3>Value</h3>

<p>if <code>fullsims = FALSE</code> (default), a tibble with 4 columns:
</p>

<ul>
<li><p> x: value of variable of interest, drawn from <code>xrange</code>
</p>
</li>
<li><p> median_pp: median predicted Pr(y = 1) when variable of interest is set to x, 
holding all other predictors to average (median) values
</p>
</li>
<li><p> lower_pp: lower bound of credible interval of predicted probability at given x
</p>
</li>
<li><p> upper_pp: upper bound of credible interval of predicted probability at given x
</p>
</li></ul>

<p>if <code>fullsims = TRUE</code>, a tibble with 3 columns:
</p>

<ul>
<li><p> Iteration: number of the posterior draw
</p>
</li>
<li><p> x: value of variable of interest, drawn from <code>xrange</code>
</p>
</li>
<li><p> pp: average predicted Pr(y = 1) when variable of interest is set to x, holding all other predictors to average (median) values
</p>
</li></ul>



<h3>References</h3>

<p>King, Gary, Michael Tomz, and Jason Wittenberg. 2000. “Making the Most 
of Statistical Analyses: Improving Interpretation and Presentation.” American Journal 
of Political Science 44 (2): 347–61. http://www.jstor.org/stable/2669316
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
  ## simulating data
  set.seed(123)
  b0 &lt;- 0.2 # true value for the intercept
  b1 &lt;- 0.5 # true value for first beta
  b2 &lt;- 0.7 # true value for second beta
  n &lt;- 500 # sample size
  X1 &lt;- runif(n, -1, 1)
  X2 &lt;- runif(n, -1, 1)
  Z &lt;- b0 + b1 * X1 + b2 * X2
  pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
  Y &lt;- rbinom(n, 1, pr) 
  df &lt;- data.frame(cbind(X1, X2, Y))
  
  ## formatting the data for jags
  datjags &lt;- as.list(df)
  datjags$N &lt;- length(datjags$Y)
  
  ## creating jags model
  model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
library(R2jags)
set.seed(123)
fit &lt;- jags(data = datjags, inits = inits, 
         parameters.to.save = params, n.chains = 2, n.iter = 2000, 
         n.burnin = 1000, model.file = model)

### average value approach
library(coda)
xmat &lt;- model.matrix(Y ~ X1 + X2, data = df)
mcmc &lt;- as.mcmc(fit)
mcmc_mat &lt;- as.matrix(mcmc)[, 1:ncol(xmat)]
X1_sim &lt;- seq(from = min(datjags$X1),
              to = max(datjags$X1), 
              length.out = 10)
ave_prob &lt;- mcmcAveProb(modelmatrix = xmat,
                        mcmcout = mcmc_mat,
                        xrange = X1_sim, 
                        xcol = 2)
}



</code></pre>

<hr>
<h2 id='mcmcCoefPlot'>Coefficient Plots for MCMC Output</h2><span id='topic+mcmcCoefPlot'></span>

<h3>Description</h3>

<p>Coefficient plots for MCMC output using <code>ggplot2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcCoefPlot(
  mod,
  pars = NULL,
  pointest = "mean",
  ci = 0.95,
  hpdi = FALSE,
  sort = FALSE,
  plot = TRUE,
  regex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcCoefPlot_+3A_mod">mod</code></td>
<td>
<p>Bayesian model object generated by R2jags, rjags, R2WinBUGS, R2OpenBUGS, 
MCMCpack, rstan, rstanarm, and brms.</p>
</td></tr>
<tr><td><code id="mcmcCoefPlot_+3A_pars">pars</code></td>
<td>
<p>a scalar or vector of the parameters you wish to include in the table.
By default, <code>mcmcCoefPlot</code> includes all parameters saved in a model object. If a
model has lots of samples and lots of saved parameters, not explicitly specifying
a limited number of parameters to include via <code>pars</code> may take a long time
or produce an unreadable plot. <code>pars</code> can either be a vector with the
specific parameters to be included in the table e.g. <code>pars = c("beta[1]",
"beta[2]", "beta[3]")</code>, or they can be partial names that will be matched using
regular expressions e.g. <code>pars = "beta"</code> if <code>regex = TRUE</code>. Both of
these will include <code>beta[1]</code>, <code>beta[2]</code>, and <code>beta[3]</code> in the
plot. If <code>pars</code> is left blank, <code>mcmcCoefPlot</code> will exclude auxiliary
parameters such as <code>deviance</code> from JAGS or <code>lp__</code> from Stan.</p>
</td></tr>
<tr><td><code id="mcmcCoefPlot_+3A_pointest">pointest</code></td>
<td>
<p>a character indicating whether to use the mean or median for
point estimates in the table.</p>
</td></tr>
<tr><td><code id="mcmcCoefPlot_+3A_ci">ci</code></td>
<td>
<p>a scalar indicating the confidence level of the uncertainty intervals.</p>
</td></tr>
<tr><td><code id="mcmcCoefPlot_+3A_hpdi">hpdi</code></td>
<td>
<p>a logical indicating whether to use highest posterior density intervals
or equal tailed credible intervals to capture uncertainty; default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mcmcCoefPlot_+3A_sort">sort</code></td>
<td>
<p>logical indicating whether to sort the point estimates to produce
a caterpillar or dot plot; default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mcmcCoefPlot_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether to return a <code>ggplot</code> object or the
underlying tidy DataFrame; default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mcmcCoefPlot_+3A_regex">regex</code></td>
<td>
<p>use regular expression matching with <code>pars</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object or a tidy DataFrame.
</p>


<h3>Author(s)</h3>

<p>Rob Williams, <a href="mailto:jayrobwilliams@gmail.com">jayrobwilliams@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
## simulating data
set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr)
df &lt;- data.frame(cbind(X1, X2, Y))

## formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] +
      b[2] * X1[i] +
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits,
                    parameters.to.save = params, n.chains = 2, n.iter = 2000,
                    n.burnin = 1000, model.file = model)

## generating coefficient plot with all non-auxiliary parameters
mcmcCoefPlot(fit)
}



</code></pre>

<hr>
<h2 id='mcmcFD'>First Differences of a Bayesian Logit or Probit model</h2><span id='topic+mcmcFD'></span>

<h3>Description</h3>

<p>R function to calculate first differences after a Bayesian logit or probit model.
First differences are a method to summarize effects across covariates. This quantity represents
the difference in predicted probabilities for each covariate for cases with low and high values 
of the respective covariate. For each of these differences, all other variables are held constant 
at their median. For more, see Long (1997, Sage Publications) and King, Tomz, and Wittenberg (2000, 
American Journal of Political Science 44(2): 347-361).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcFD(
  modelmatrix,
  mcmcout,
  link = "logit",
  ci = c(0.025, 0.975),
  percentiles = c(0.25, 0.75),
  fullsims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcFD_+3A_modelmatrix">modelmatrix</code></td>
<td>
<p>model matrix, including intercept (if the intercept is among the
parameters estimated in the model). Create with model.matrix(formula, data).
Note: the order of columns in the model matrix must correspond to the order of columns 
in the matrix of posterior draws in the <code>mcmcout</code> argument. See the <code>mcmcout</code>
argument for more.</p>
</td></tr>
<tr><td><code id="mcmcFD_+3A_mcmcout">mcmcout</code></td>
<td>
<p>posterior distributions of all logit coefficients, 
in matrix form. This can be created from rstan, MCMCpack, R2jags, etc. and transformed
into a matrix using the function as.mcmc() from the coda package for <code>jags</code> class
objects, as.matrix() from base R for <code>mcmc</code>, <code>mcmc.list</code>, <code>stanreg</code>, and 
<code>stanfit</code> class objects, and <code>object$sims.matrix</code> for <code>bugs</code> class objects.
Note: the order of columns in this matrix must correspond to the order of columns 
in the model matrix. One can do this by examining the posterior distribution matrix and sorting the 
variables in the order of this matrix when creating the model matrix. A useful function for sorting 
column names containing both characters and numbers as 
you create the matrix of posterior distributions is <code>mixedsort()</code> from the gtools package.</p>
</td></tr>
<tr><td><code id="mcmcFD_+3A_link">link</code></td>
<td>
<p>type of generalized linear model; a character vector set to <code>"logit"</code> (default) 
or <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="mcmcFD_+3A_ci">ci</code></td>
<td>
<p>the bounds of the credible interval. Default is <code>c(0.025, 0.975)</code> for the 95% 
credible interval.</p>
</td></tr>
<tr><td><code id="mcmcFD_+3A_percentiles">percentiles</code></td>
<td>
<p>values of each predictor for which the difference in Pr(y = 1) 
is to be calculated. Default is <code>c(0.25, 0.75)</code>, which will calculate the difference 
between Pr(y = 1) for the 25th percentile and 75th percentile of the predictor. For binary 
predictors, the function automatically calculates the difference between Pr(y = 1) 
for x = 0 and x = 1.</p>
</td></tr>
<tr><td><code id="mcmcFD_+3A_fullsims">fullsims</code></td>
<td>
<p>logical indicator of whether full object (based on all MCMC draws 
rather than their average) will be returned. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mcmcFD</code>. If <code>fullsims = FALSE</code> (default),
a data frame with five columns:
</p>

<ul>
<li><p> median_fd: median first difference
</p>
</li>
<li><p> lower_fd: lower bound of credible interval of the first difference
</p>
</li>
<li><p> upper_fd: upper bound of credible interval of the first difference
</p>
</li>
<li><p> VarName: name of the variable as found in <code>modelmatrix</code>
</p>
</li>
<li><p> VarID: identifier of the variable, based on the order of columns in
<code>modelmatrix</code> and  <code>mcmcout</code>. Can be adjusted for plotting
</p>
</li></ul>

<p>If <code>fullsims = TRUE</code>, a matrix with as many columns as predictors in the model. Each row 
is the first difference for that variable based on one set of posterior draws. Column names are taken 
from the column names of <code>modelmatrix</code>.
</p>


<h3>References</h3>


<ul>
<li><p> King, Gary, Michael Tomz, and Jason Wittenberg. 2000. “Making the Most of Statistical 
Analyses: Improving Interpretation and Presentation.” American Journal of Political Science 
44 (2): 347–61. http://www.jstor.org/stable/2669316
</p>
</li>
<li><p> Long, J. Scott. 1997. Regression Models for Categorical and Limited Dependent Variables. 
Thousand Oaks: Sage Publications
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
## simulating data
set.seed(1234)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr) 
df &lt;- data.frame(cbind(X1, X2, Y))

## formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits, 
                    parameters.to.save = params, n.chains = 2, n.iter = 2000, 
                    n.burnin = 1000, model.file = model)

## running function with logit
xmat &lt;- model.matrix(Y ~ X1 + X2, data = df)
mcmc &lt;- coda::as.mcmc(fit)
mcmc_mat &lt;- as.matrix(mcmc)[, 1:ncol(xmat)]
object &lt;- mcmcFD(modelmatrix = xmat,
                 mcmcout = mcmc_mat)
object
}



</code></pre>

<hr>
<h2 id='mcmcMargEff'>Marginal Effects Plots for MCMC Output</h2><span id='topic+mcmcMargEff'></span>

<h3>Description</h3>

<p>Marginal effects plots for MCMC output using <code>ggplot2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcMargEff(
  mod,
  main,
  int,
  moderator,
  pointest = "mean",
  seq = 100,
  ci = 0.95,
  hpdi = FALSE,
  plot = TRUE,
  xlab = "Moderator",
  ylab = "Marginal Effect"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcMargEff_+3A_mod">mod</code></td>
<td>
<p>Bayesian model object generated by R2jags, rjags, R2WinBUGS, R2OpenBUGS, 
MCMCpack, rstan, rstanarm, and brms.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_main">main</code></td>
<td>
<p>a character with the name of the parameter of interest in the
interaction term.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_int">int</code></td>
<td>
<p>a character with the name of the moderating parameter in the
interaction term.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_moderator">moderator</code></td>
<td>
<p>a vector of values that the moderating parameter takes on
in the data.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_pointest">pointest</code></td>
<td>
<p>a character indicating whether to use the mean or median for
point estimates in the plot.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_seq">seq</code></td>
<td>
<p>a numeric giving the number of moderator values used to generate
the marginal effects plot.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_ci">ci</code></td>
<td>
<p>a scalar indicating the confidence level of the uncertainty intervals.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_hpdi">hpdi</code></td>
<td>
<p>a logical indicating whether to use highest posterior density intervals
or equal tailed credible intervals to capture uncertainty.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_plot">plot</code></td>
<td>
<p>logical indicating whether to return a <code>ggplot</code> object or the
underlying tidy DataFrame. By default, <code>mcmcMargEff</code> returns a line and
ribbon plot for continuous variables, and a dot and line plot for factor
variables and discrete variables with fewer than 25 unique values.</p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_xlab">xlab</code></td>
<td>
<p>character giving x axis label if <code>plot = TRUE</code>, default <code>"Moderator"</code></p>
</td></tr>
<tr><td><code id="mcmcMargEff_+3A_ylab">ylab</code></td>
<td>
<p>character giving y axis label if <code>plot = TRUE</code>, default <code>"Marginal Effect"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object or a tidy DataFrame.
</p>


<h3>Author(s)</h3>

<p>Rob Williams, <a href="mailto:jayrobwilliams@gmail.com">jayrobwilliams@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
## simulating data
set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2

## linear model data
Y_linear &lt;- rnorm(n, Z, 1)
df &lt;- data.frame(cbind(X1, X2, Y = Y_linear))

## formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dnorm(mu[i], sigma)  ## Bernoulli distribution of y_i
    
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i] +
      b[4] * X1[i] * X2[i]
    
  }
  
  for(j in 1:4){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
  sigma ~ dexp(1)
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 4))
inits2 &lt;- list("b" = rep(0, 4))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits, 
                    parameters.to.save = params, n.chains = 2, n.iter = 2000, 
                    n.burnin = 1000, model.file = model)

mcmcMargEff(mod = fit,
            main = 'b[2]',
            int = 'b[4]',
            moderator = sim_data_interactive$X2,
            plot = TRUE)
}



</code></pre>

<hr>
<h2 id='mcmcObsProb'>Predicted Probabilities using Bayesian MCMC estimates for the Average of Observed Cases</h2><span id='topic+mcmcObsProb'></span>

<h3>Description</h3>

<p>Implements R function to calculate the predicted probabilities
for &quot;observed&quot; cases after a Bayesian logit or probit model, following
Hanmer &amp; Kalkan (2013) (2013, American Journal of Political Science 57(1): 263-277).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcObsProb(
  modelmatrix,
  mcmcout,
  xcol,
  xrange,
  xinterest,
  link = "logit",
  ci = c(0.025, 0.975),
  fullsims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcObsProb_+3A_modelmatrix">modelmatrix</code></td>
<td>
<p>model matrix, including intercept (if the intercept is among the
parameters estimated in the model). Create with model.matrix(formula, data).
Note: the order of columns in the model matrix must correspond to the order of columns 
in the matrix of posterior draws in the <code>mcmcout</code> argument. See the <code>mcmcout</code>
argument for more.</p>
</td></tr>
<tr><td><code id="mcmcObsProb_+3A_mcmcout">mcmcout</code></td>
<td>
<p>posterior distributions of all logit coefficients, 
in matrix form. This can be created from rstan, MCMCpack, R2jags, etc. and transformed
into a matrix using the function as.mcmc() from the coda package for <code>jags</code> class
objects, as.matrix() from base R for <code>mcmc</code>, <code>mcmc.list</code>, <code>stanreg</code>, and 
<code>stanfit</code> class objects, and <code>object$sims.matrix</code> for <code>bugs</code> class objects.
Note: the order of columns in this matrix must correspond to the order of columns 
in the model matrix. One can do this by examining the posterior distribution matrix and sorting the 
variables in the order of this matrix when creating the model matrix. A useful function for sorting 
column names containing both characters and numbers as 
you create the matrix of posterior distributions is <code>mixedsort()</code> from the gtools package.</p>
</td></tr>
<tr><td><code id="mcmcObsProb_+3A_xcol">xcol</code></td>
<td>
<p>column number of the posterior draws (<code>mcmcout</code>) and model matrices 
that corresponds to the explanatory variable for which to calculate associated Pr(y = 1).
Note that the columns in these matrices must match.</p>
</td></tr>
<tr><td><code id="mcmcObsProb_+3A_xrange">xrange</code></td>
<td>
<p>name of the vector with the range of relevant values of the 
explanatory variable for which to calculate associated Pr(y = 1).</p>
</td></tr>
<tr><td><code id="mcmcObsProb_+3A_xinterest">xinterest</code></td>
<td>
<p>semi-optional argument. Name of the explanatory variable for which 
to calculate associated Pr(y = 1). If <code>xcol</code> is supplied, this is not needed. 
If both are supplied, the function defaults to <code>xcol</code> and this argument is ignored.</p>
</td></tr>
<tr><td><code id="mcmcObsProb_+3A_link">link</code></td>
<td>
<p>type of generalized linear model; a character vector set to <code>"logit"</code> (default) 
or <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="mcmcObsProb_+3A_ci">ci</code></td>
<td>
<p>the bounds of the credible interval. Default is <code>c(0.025, 0.975)</code> for the 95% 
credible interval.</p>
</td></tr>
<tr><td><code id="mcmcObsProb_+3A_fullsims">fullsims</code></td>
<td>
<p>logical indicator of whether full object (based on all MCMC draws 
rather than their average) will be returned. Default is <code>FALSE</code>. Note: The longer 
<code>xrange</code> is, the larger the full output will be if <code>TRUE</code> is selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates predicted probabilities for 
&quot;observed&quot; cases after a Bayesian logit or probit model
following Hanmer and Kalkan (2013, American Journal of 
Political Science 57(1): 263-277)
</p>


<h3>Value</h3>

<p>if <code>fullsims = FALSE</code> (default), a tibble with 4 columns:
</p>

<ul>
<li><p> x: value of variable of interest, drawn from <code>xrange</code>
</p>
</li>
<li><p> median_pp: median predicted Pr(y = 1) when variable of interest is set to x
</p>
</li>
<li><p> lower_pp: lower bound of credible interval of predicted probability at given x
</p>
</li>
<li><p> upper_pp: upper bound of credible interval of predicted probability at given x
</p>
</li></ul>

<p>if <code>fullsims = TRUE</code>, a tibble with 3 columns:
</p>

<ul>
<li><p> Iteration: number of the posterior draw
</p>
</li>
<li><p> x: value of variable of interest, drawn from <code>xrange</code>
</p>
</li>
<li><p> pp: average predicted Pr(y = 1) of all observed cases when variable of interest is set to x
</p>
</li></ul>



<h3>References</h3>

<p>Hanmer, Michael J., &amp; Ozan Kalkan, K. (2013). Behind the curve: Clarifying 
the best approach to calculating predicted probabilities and marginal effects from 
limited dependent variable models. American Journal of Political Science, 57(1), 
263-277. https://doi.org/10.1111/j.1540-5907.2012.00602.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
  ## simulating data
  set.seed(12345)
  b0 &lt;- 0.2 # true value for the intercept
  b1 &lt;- 0.5 # true value for first beta
  b2 &lt;- 0.7 # true value for second beta
  n &lt;- 500 # sample size
  X1 &lt;- runif(n, -1, 1)
  X2 &lt;- runif(n, -1, 1)
  Z &lt;- b0 + b1 * X1 + b2 * X2
  pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
  Y &lt;- rbinom(n, 1, pr) 
  df &lt;- data.frame(cbind(X1, X2, Y))
  
  ## formatting the data for jags
  datjags &lt;- as.list(df)
  datjags$N &lt;- length(datjags$Y)
  
  ## creating jags model
  model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
library(R2jags)
set.seed(123)
fit &lt;- jags(data = datjags, inits = inits, 
          parameters.to.save = params, n.chains = 2, n.iter = 2000, 
          n.burnin = 1000, model.file = model)

### observed value approach
library(coda)
xmat &lt;- model.matrix(Y ~ X1 + X2, data = df)
mcmc &lt;- as.mcmc(fit)
mcmc_mat &lt;- as.matrix(mcmc)[, 1:ncol(xmat)]
X1_sim &lt;- seq(from = min(datjags$X1),
              to = max(datjags$X1), 
              length.out = 10)
obs_prob &lt;- mcmcObsProb(modelmatrix = xmat,
                        mcmcout = mcmc_mat,
                        xrange = X1_sim,
                        xcol = 2)
}



</code></pre>

<hr>
<h2 id='mcmcReg'>LaTeX or HTML regression tables for MCMC Output</h2><span id='topic+mcmcReg'></span>

<h3>Description</h3>

<p>This function creates LaTeX or HTML regression tables for MCMC Output using 
the <code><a href="texreg.html#topic+texreg">texreg</a></code> function from the <code><a href="texreg.html#topic+texreg-package">texreg</a></code> R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcReg(
  mod,
  pars = NULL,
  pointest = "mean",
  ci = 0.95,
  hpdi = FALSE,
  sd = FALSE,
  pr = FALSE,
  coefnames = NULL,
  gof = numeric(0),
  gofnames = character(0),
  format = "latex",
  file,
  regex = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcReg_+3A_mod">mod</code></td>
<td>
<p>Bayesian model object generated by R2jags, rjags, R2WinBUGS, R2OpenBUGS, 
MCMCpack, rstan, rstanarm, and brms, or a list of model objects of the same class.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_pars">pars</code></td>
<td>
<p>a scalar or vector of the parameters you wish to include in the table.
By default, <code>mcmcReg</code> includes all parameters saved in a model object. If a
model has lots of samples and lots of saved parameters, not explicitly specifying
a limited number of parameters to include via <code>pars</code> may take a long time.
<code>pars</code> can either be a vector with the specific parameters to be included
in the table e.g. <code>pars = c("beta[1]", "beta[2]", "beta[3]")</code>, or they can
be partial names that will be matched using regular expressions e.g.
<code>pars = "beta"</code> if <code>regex = TRUE</code>. Both of these will include
<code>beta[1]</code>, <code>beta[2]</code>, and <code>beta[3]</code> in the table. When
combining models with different parameters in one table, this argument also
accepts a list the length of the number of models.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_pointest">pointest</code></td>
<td>
<p>a character indicating whether to use the mean or median for
point estimates in the table.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_ci">ci</code></td>
<td>
<p>a scalar indicating the confidence level of the uncertainty intervals.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_hpdi">hpdi</code></td>
<td>
<p>a logical indicating whether to use highest posterior density
intervals instead of equal tailed credible intervals to capture uncertainty
(default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_sd">sd</code></td>
<td>
<p>a logical indicating whether to report the standard deviation of
posterior distributions instead of an uncertainty interval
(default <code>FALSE</code>). If <code>TRUE</code>, overrides <code>ci</code>, <code>hpdi</code>, and
<code>pr</code>.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_pr">pr</code></td>
<td>
<p>a logical indicating whether to report the probability that a
coefficient is in the same direction as the point estimate for that
coefficient (default <code>FALSE</code>). If <code>TRUE</code>, overrides <code>ci</code> and
<code>hpdi</code>.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_coefnames">coefnames</code></td>
<td>
<p>an optional vector or list of vectors containing parameter
names for each model. If there are multiple models, the list must have the same
number of elements as there are models, and the vector of names in each list
element must match the number of parameters. If not supplied, the function
will use the parameter names in the model object(s). Note that this replaces
the standard <code>custom.coef.names</code> argument in <code><a href="texreg.html#topic+texreg">texreg</a></code>
because there is no <code>extract</code> method for MCMC model objects, and many
MCMC model objects do not have unique parameter names.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_gof">gof</code></td>
<td>
<p>a named list of goodness of fit statistics, or a list of such lists.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_gofnames">gofnames</code></td>
<td>
<p>an optional vector or list of vectors containing
goodness of fit statistic names for each model. Like <code>coefnames</code> in this function
(which replaces the <code>custom.coef.names</code> argument in <code><a href="texreg.html#topic+texreg">texreg</a></code>),
<code>gofnames</code> replaces the standard <code>custom.gof.names</code> argument in
<code><a href="texreg.html#topic+texreg">texreg</a></code>. If 
there are multiple models, the list must have the same number of elements as
there are models, and the vector of names in each list element must match the
number of goodness of fit statistics.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_format">format</code></td>
<td>
<p>a character indicating <code>latex</code> or <code>html</code> output.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_file">file</code></td>
<td>
<p>optional file name to write table to file instead of printing to
console.</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_regex">regex</code></td>
<td>
<p>use regular expression matching with <code>pars</code>?</p>
</td></tr>
<tr><td><code id="mcmcReg_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="texreg.html#topic+texreg">texreg</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If using <code>custom.coef.map</code> with more than one model, you should rename
the parameters in the model objects to ensure that different parameters with the
same subscript are not conflated by <code>texreg</code> e.g. <code>beta[1]</code> could represent age
in one model and income in another, and <code>texreg</code> would combine the two if you
do not rename <code>beta[1]</code> to more informative names in the model objects.
</p>
<p>If <code>mod</code> is a <code>brmsfit</code> object or list of <code>brmsfit</code> objects, note that the
default <code>brms</code> names for coefficients are <code>b_Intercept</code> and <code>b</code>, so both of
these should be included in <code>par</code> if you wish to include the intercept in the
table.
</p>


<h3>Value</h3>

<p>A formatted regression table in LaTeX or HTML format.
</p>


<h3>Author(s)</h3>

<p>Rob Williams, <a href="mailto:jayrobwilliams@gmail.com">jayrobwilliams@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
## simulating data
set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr)
df &lt;- data.frame(cbind(X1, X2, Y))

## formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {

  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] +
      b[2] * X1[i] +
      b[3] * X2[i]
  }

  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }

}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits,
                    parameters.to.save = params,
                    n.chains = 2,
                    n.iter = 2000, n.burnin = 1000,
                    model.file = model)

## generating regression table with all parameters
mcmcReg(fit)

## generating regression table with only betas and custom coefficent names
mcmcReg(fit, pars = c('b'), coefnames = c('Variable 1',
                                          'Variable 2',
                                          'Variable 3'),
        regex = TRUE)
## generating regression tables with all betas and custom names
mcmcReg(fit, coefnames = c('Variable 1', 'Variable 2',
                           'Variable 3', 'deviance'))
}



</code></pre>

<hr>
<h2 id='mcmcRocPrcGen'>ROC and Precision-Recall Curves using Bayesian MCMC estimates generalized</h2><span id='topic+mcmcRocPrcGen'></span>

<h3>Description</h3>

<p>This function generates ROC and Precision-Recall curves 
after fitting a Bayesian logit or probit regression. For fast calculation for 
from an &quot;rjags&quot; object use <code><a href="#topic+mcmcRocPrc">mcmcRocPrc</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcRocPrcGen(
  modelmatrix,
  mcmcout,
  modelframe,
  curves = FALSE,
  link = "logit",
  fullsims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcRocPrcGen_+3A_modelmatrix">modelmatrix</code></td>
<td>
<p>model matrix, including intercept (if the intercept is among the
parameters estimated in the model). Create with model.matrix(formula, data).
Note: the order of columns in the model matrix must correspond to the order of columns 
in the matrix of posterior draws in the <code>mcmcout</code> argument. See the <code>mcmcout</code>
argument for more and Beger (2016) for background.</p>
</td></tr>
<tr><td><code id="mcmcRocPrcGen_+3A_mcmcout">mcmcout</code></td>
<td>
<p>posterior distributions of all logit coefficients, 
in matrix form. This can be created from rstan, MCMCpack, R2jags, etc. and transformed
into a matrix using the function as.mcmc() from the coda package for <code>jags</code> class
objects, as.matrix() from base R for <code>mcmc</code>, <code>mcmc.list</code>, <code>stanreg</code>, and 
<code>stanfit</code> class objects, and <code>object$sims.matrix</code> for <code>bugs</code> class objects.
Note: the order of columns in this matrix must correspond to the order of columns 
in the model matrix. One can do this by examining the posterior distribution matrix and sorting the 
variables in the order of this matrix when creating the model matrix. A useful function for sorting 
column names containing both characters and numbers as 
you create the matrix of posterior distributions is <code>mixedsort()</code> from the gtools package.</p>
</td></tr>
<tr><td><code id="mcmcRocPrcGen_+3A_modelframe">modelframe</code></td>
<td>
<p>model frame in matrix form. Can be created using 
as.matrix(model.frame(formula, data))</p>
</td></tr>
<tr><td><code id="mcmcRocPrcGen_+3A_curves">curves</code></td>
<td>
<p>logical indicator of whether or not to return values to plot the ROC or Precision-Recall 
curves. If set to <code>FALSE</code> (default), results are returned as a list without the extra
values.</p>
</td></tr>
<tr><td><code id="mcmcRocPrcGen_+3A_link">link</code></td>
<td>
<p>type of generalized linear model; a character vector set to <code>"logit"</code> (default) or <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="mcmcRocPrcGen_+3A_fullsims">fullsims</code></td>
<td>
<p>logical indicator of whether full object (based on all MCMC draws 
rather than their average) will be returned. Default is <code>FALSE</code>. Note:  If <code>TRUE</code>
is chosen, the function takes notably longer to execute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates ROC and precision-recall curves
after fitting a Bayesian logit or probit model.
</p>


<h3>Value</h3>

<p>This function returns a list with 4 elements:
</p>

<ul>
<li><p> area_under_roc: area under ROC curve (scalar)
</p>
</li>
<li><p> area_under_prc: area under precision-recall curve (scalar)
</p>
</li>
<li><p> prc_dat: data to plot precision-recall curve (data frame)
</p>
</li>
<li><p> roc_dat: data to plot ROC curve (data frame)
</p>
</li></ul>



<h3>References</h3>

<p>Beger, Andreas. 2016. “Precision-Recall Curves.” Available at SSRN: 
https://ssrn.com/Abstract=2765419. http://dx.doi.org/10.2139/ssrn.2765419.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
# simulating data

set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr) 
df &lt;- data.frame(cbind(X1, X2, Y))

# formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

# creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits, 
                    parameters.to.save = params, n.chains = 2, n.iter = 2000, 
                    n.burnin = 1000, model.file = model)

# processing the data
mm &lt;- model.matrix(Y ~ X1 + X2, data = df)
xframe &lt;- as.matrix(model.frame(Y ~ X1 + X2, data = df))
mcmc &lt;- coda::as.mcmc(fit)
mcmc_mat &lt;- as.matrix(mcmc)[, 1:ncol(xframe)]

# using mcmcRocPrcGen
fit_sum &lt;- mcmcRocPrcGen(modelmatrix = mm,
                      modelframe = xframe,
                      mcmcout = mcmc_mat,
                      curves = TRUE,
                      fullsims = FALSE)
}



</code></pre>

<hr>
<h2 id='mcmcTab'>Summarize Bayesian MCMC Output
R function for summarizing MCMC output in a regression-style table.</h2><span id='topic+mcmcTab'></span>

<h3>Description</h3>

<p>Summarize Bayesian MCMC Output
</p>
<p>R function for summarizing MCMC output in a regression-style table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcTab(
  sims,
  ci = c(0.025, 0.975),
  pars = NULL,
  Pr = FALSE,
  ROPE = NULL,
  regex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcTab_+3A_sims">sims</code></td>
<td>
<p>Bayesian model object generated by R2jags, rjags, R2WinBUGS, 
R2OpenBUGS, MCMCpack, rstan, and rstanarm.</p>
</td></tr>
<tr><td><code id="mcmcTab_+3A_ci">ci</code></td>
<td>
<p>desired level for credible intervals; defaults to c(0.025, 0.975).</p>
</td></tr>
<tr><td><code id="mcmcTab_+3A_pars">pars</code></td>
<td>
<p>character vector of parameters to be printed; defaults to <code>NULL</code> 
(all parameters are printed). If not <code>NULL</code>, the user can either specify the exact names of 
parameters to be printed (e.g. <code>c("alpha", "beta1", "beta2")</code>) or part of a name 
so that all parameters containing that name will be printed (e.g. <code>"beta"</code> will print <code>beta1</code>, <code>beta2</code>, etc.).</p>
</td></tr>
<tr><td><code id="mcmcTab_+3A_pr">Pr</code></td>
<td>
<p>print percent of posterior draws with same sign as median; defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mcmcTab_+3A_rope">ROPE</code></td>
<td>
<p>defaults to <code>NULL</code>. If not <code>NULL</code>, a vector of two values defining the region of 
practical equivalence (&quot;ROPE&quot;); returns % of posterior draws to the left/right of ROPE. For this quantity 
to be meaningful, all parameters must be on the same scale (e.g. standardized coefficients 
or first differences). See Kruschke (2013, Journal of Experimental 
Psychology 143(2): 573-603) for more on the ROPE.</p>
</td></tr>
<tr><td><code id="mcmcTab_+3A_regex">regex</code></td>
<td>
<p>use regular expression matching with <code>pars</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing MCMC summary statistics.
</p>


<h3>References</h3>

<p>Kruschke, John K. 2013. “Bayesian Estimation Supersedes the T-Test.” Journal of 
Experimental Psychology: General 142 (2): 573–603. https://doi.org/10.1037/a0029146.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
data("jags_logit")

## printing out table
object &lt;- mcmcTab(jags_logit, 
          ci = c(0.025, 0.975), 
          pars = NULL, 
          Pr = FALSE,
          ROPE = NULL)
object
}



</code></pre>

<hr>
<h2 id='new_mcmcRocPrc'>Constructor for mcmcRocPrc objects</h2><span id='topic+new_mcmcRocPrc'></span>

<h3>Description</h3>

<p>This function actually does the heavy lifting once we have a matrix of
predicted probabilities from a model, plus the vector of observed outcomes.
The reason to have it here in a single function is that we don't replicate
it in each function that accomodates a JAGS, BUGS, RStan, etc. object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_mcmcRocPrc(pred_prob, yvec, curves, fullsims)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_mcmcRocPrc_+3A_pred_prob">pred_prob</code></td>
<td>
<p>a <code style="white-space: pre;">&#8288;\[N, iter\]&#8288;</code> matrix of predicted probabilities</p>
</td></tr>
<tr><td><code id="new_mcmcRocPrc_+3A_yvec">yvec</code></td>
<td>
<p>a <code>numeric(N)</code> vector of observed outcomes</p>
</td></tr>
<tr><td><code id="new_mcmcRocPrc_+3A_curves">curves</code></td>
<td>
<p>include curve data in output?</p>
</td></tr>
<tr><td><code id="new_mcmcRocPrc_+3A_fullsims">fullsims</code></td>
<td>
<p>collapse posterior samples into single summary?</p>
</td></tr>
</table>

<hr>
<h2 id='plot.mcmcFD'>Plot Method for First Differences from MCMC output</h2><span id='topic+plot.mcmcFD'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for first differences generated from MCMC
output by <code><a href="#topic+mcmcFD">mcmcFD</a></code>. For more on this method, see Long
(1997, Sage Publications), and King, Tomz, and Wittenberg (2000, American
Journal of Political Science 44(2): 347-361). For a description of this type
of plot, see Figure 1 in Karreth (2018, International Interactions 44(3): 463-90).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcFD'
plot(x, ROPE = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mcmcFD_+3A_x">x</code></td>
<td>
<p>Output generated from <code>mcmcFD(..., full_sims = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="plot.mcmcFD_+3A_rope">ROPE</code></td>
<td>
<p>defaults to NULL. If not NULL, a numeric vector of length two, 
defining the Region of Practical Equivalence around 0. See Kruschke (2013, Journal of 
Experimental Psychology 143(2): 573-603) for more on the ROPE.</p>
</td></tr>
<tr><td><code id="plot.mcmcFD_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="ggplot2.html#topic+theme">theme</a></code> from <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a density plot of the differences in probabilities. The plot is made with ggplot2 and can be
passed on as an object to customize. Annotated numbers show the percent of posterior draws with
the same sign as the median estimate (if <code>ROPE = NULL</code>) or on the same side of the 
ROPE as the median estimate (if <code>ROPE</code> is specified).
</p>


<h3>References</h3>


<ul>
<li><p> Karreth, Johannes. 2018. “The Economic Leverage of International Organizations in Interstate Disputes.” 
International Interactions 44 (3): 463-90. https://doi.org/10.1080/03050629.2018.1389728.
</p>
</li>
<li><p> King, Gary, Michael Tomz, and Jason Wittenberg. 2000. “Making the Most of Statistical 
Analyses: Improving Interpretation and Presentation.” American Journal of Political Science 
44 (2): 347–61. http://www.jstor.org/stable/2669316.
</p>
</li>
<li><p> Kruschke, John K. 2013. “Bayesian Estimation Supersedes the T-Test.” Journal of 
Experimental Psychology: General 142 (2): 573–603. https://doi.org/10.1037/a0029146.
</p>
</li>
<li><p> Long, J. Scott. 1997. Regression Models for Categorical and Limited Dependent Variables. 
Thousand Oaks: Sage Publications.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mcmcFD">mcmcFD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (interactive()) {
## simulating data
set.seed(1234)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr) 
df &lt;- data.frame(cbind(X1, X2, Y))

## formatting the data for jags
datjags &lt;- as.list(df)
datjags$N &lt;- length(datjags$Y)

## creating jags model
model &lt;- function()  {
  
  for(i in 1:N){
    Y[i] ~ dbern(p[i])  ## Bernoulli distribution of y_i
    logit(p[i]) &lt;- mu[i]    ## Logit link function
    mu[i] &lt;- b[1] + 
      b[2] * X1[i] + 
      b[3] * X2[i]
  }
  
  for(j in 1:3){
    b[j] ~ dnorm(0, 0.001) ## Use a coefficient vector for simplicity
  }
  
}

params &lt;- c("b")
inits1 &lt;- list("b" = rep(0, 3))
inits2 &lt;- list("b" = rep(0, 3))
inits &lt;- list(inits1, inits2)

## fitting the model with R2jags
set.seed(123)
fit &lt;- R2jags::jags(data = datjags, inits = inits, 
                    parameters.to.save = params, n.chains = 2, n.iter = 2000, 
                    n.burnin = 1000, model.file = model)

## preparing data for mcmcFD()
xmat &lt;- model.matrix(Y ~ X1 + X2, data = df)
mcmc &lt;- coda::as.mcmc(fit)
mcmc_mat &lt;- as.matrix(mcmc)[, 1:ncol(xmat)]

## plotting with mcmcFDplot()
full &lt;- mcmcFD(modelmatrix = xmat,
               mcmcout = mcmc_mat,
               fullsims = TRUE)
plot(full)

}




</code></pre>

<hr>
<h2 id='print.mcmcRocPrc'>ROC and Precision-Recall Curves using Bayesian MCMC estimates</h2><span id='topic+print.mcmcRocPrc'></span><span id='topic+plot.mcmcRocPrc'></span><span id='topic+as.data.frame.mcmcRocPrc'></span><span id='topic+mcmcRocPrc'></span><span id='topic+mcmcRocPrc.default'></span><span id='topic+mcmcRocPrc.jags'></span><span id='topic+mcmcRocPrc.rjags'></span><span id='topic+mcmcRocPrc.runjags'></span><span id='topic+mcmcRocPrc.stanfit'></span><span id='topic+mcmcRocPrc.stanreg'></span><span id='topic+mcmcRocPrc.brmsfit'></span><span id='topic+mcmcRocPrc.bugs'></span><span id='topic+mcmcRocPrc.mcmc'></span>

<h3>Description</h3>

<p>Generate ROC and Precision-Recall curves after fitting a Bayesian logit or
probit regression using <code><a href="rstan.html#topic+stan">rstan::stan()</a></code>, <code><a href="rstanarm.html#topic+stan_glm">rstanarm::stan_glm()</a></code>,
<code><a href="R2jags.html#topic+jags">R2jags::jags()</a></code>, <code><a href="R2WinBUGS.html#topic+bugs">R2WinBUGS::bugs()</a></code>, <code><a href="MCMCpack.html#topic+MCMClogit">MCMCpack::MCMClogit()</a></code>, or other
functions that provide samples from a posterior density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcRocPrc'
print(x, ...)

## S3 method for class 'mcmcRocPrc'
plot(x, n = 40, alpha = 0.5, ...)

## S3 method for class 'mcmcRocPrc'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  what = c("auc", "roc", "prc"),
  ...
)

mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, ...)

## Default S3 method:
mcmcRocPrc(object, curves, fullsims, yvec, ...)

## S3 method for class 'jags'
mcmcRocPrc(
  object,
  curves = FALSE,
  fullsims = FALSE,
  yname,
  xnames,
  posterior_samples,
  ...
)

## S3 method for class 'rjags'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, yname, xnames, ...)

## S3 method for class 'runjags'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, yname, xnames, ...)

## S3 method for class 'stanfit'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, data, xnames, yname, ...)

## S3 method for class 'stanreg'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, ...)

## S3 method for class 'brmsfit'
mcmcRocPrc(object, curves = FALSE, fullsims = FALSE, ...)

## S3 method for class 'bugs'
mcmcRocPrc(
  object,
  curves = FALSE,
  fullsims = FALSE,
  data,
  xnames,
  yname,
  type = c("logit", "probit"),
  ...
)

## S3 method for class 'mcmc'
mcmcRocPrc(
  object,
  curves = FALSE,
  fullsims = FALSE,
  data,
  xnames,
  yname,
  type = c("logit", "probit"),
  force = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mcmcRocPrc_+3A_x">x</code></td>
<td>
<p>a <code>mcmcRocPrc()</code> object</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_...">...</code></td>
<td>
<p>Used by methods</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_n">n</code></td>
<td>
<p>plot method: if 'fullsims = TRUE', how many sample curves to draw?</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_alpha">alpha</code></td>
<td>
<p>plot method: alpha value for plotting sampled curves; between 0 and 1</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_row.names">row.names</code></td>
<td>
<p>see [base::as.data.frame()]</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_optional">optional</code></td>
<td>
<p>see [base::as.data.frame()]</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_what">what</code></td>
<td>
<p>which information to extract and convert to a data frame?</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_object">object</code></td>
<td>
<p>A fitted binary choice model, e.g. &quot;rjags&quot; object
(see <code><a href="R2jags.html#topic+jags">R2jags::jags()</a></code>), or a <code style="white-space: pre;">&#8288;[N, iter]&#8288;</code> matrix of predicted probabilites.</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_curves">curves</code></td>
<td>
<p>logical indicator of whether or not to return values to plot
the ROC or Precision-Recall curves. If set to <code>FALSE</code> (default),
results are returned as a list without the extra values.</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_fullsims">fullsims</code></td>
<td>
<p>logical indicator of whether full object (based on all MCMC
draws rather than their average) will be returned. Default is <code>FALSE</code>.
Note: If <code>TRUE</code> is chosen, the function takes notably longer to execute.</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_yvec">yvec</code></td>
<td>
<p>A <code>numeric(N)</code> vector of observed outcomes.</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_yname">yname</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The name of the dependent variable, should match the variable name in the
JAGS data object.</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_xnames">xnames</code></td>
<td>
<p>(<code><a href="base.html#topic+character">base::character()</a></code>)<br />
A character vector of the independent variable names, should match the
corresponding names in the JAGS data object.</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>a &quot;mcmc&quot; object with the posterior samples</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_data">data</code></td>
<td>
<p>the data that was used in the 'stan(data = ?, ...)' call</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_type">type</code></td>
<td>
<p>&quot;logit&quot; or &quot;probit&quot;</p>
</td></tr>
<tr><td><code id="print.mcmcRocPrc_+3A_force">force</code></td>
<td>
<p>for MCMCpack models, suppress warning if the model does not 
appear to be a binary choice model?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only the average AUC-ROC and PR are of interest, setting
<code>curves = FALSE</code> and <code>fullsims = FALSE</code> can greatly speed up calculation
time. The curve data (<code>curves = TRUE</code>) is needed for plotting. The plot
method will always plot both the ROC and PR curves, but the underlying
data can easily be extracted from the output for your own plotting;
see the documentation of the value returned below.
</p>
<p>The default method works with a matrix of predicted probabilities and the
vector of observed incomes as input. Other methods accommodate some of the
common Bayesian modeling packages like rstan (which returns class &quot;stanfit&quot;),
rstanarm (&quot;stanreg&quot;), R2jags (&quot;jags&quot;), R2WinBUGS (&quot;bugs&quot;), and
MCMCpack (&quot;mcmc&quot;). Even if a package-specific method is not implemented,
the default method can always be used as a fallback by manually calculating
the matrix of predicted probabilities for each posterior sample.
</p>
<p>Note that MCMCpack returns generic &quot;mcmc&quot; output that is annotated with
some additional information as attributes, including the original function
call. There is no inherent way to distinguish any other kind of &quot;mcmc&quot;
object from one generated by a proper MCMCpack modeling function, but as a
basic precaution, <code>mcmcRocPrc()</code> will check the saved call and return an
error if the function called was not <code>MCMClogit()</code> or <code>MCMCprobit()</code>.
This behavior can be suppressed by setting <code>force = TRUE</code>.
</p>


<h3>Value</h3>

<p>Returns a list with length 2 or 4, depending on the on the &quot;curves&quot;
and &quot;fullsims&quot; argument values:
</p>

<ul>
<li><p> &quot;area_under_roc&quot;: <code>numeric()</code>; either length 1 if <code>fullsims = FALSE</code>, or
one value for each posterior sample otherwise
</p>
</li>
<li><p> &quot;area_under_prc&quot;: <code>numeric()</code>; either length 1 if <code>fullsims = FALSE</code>, or
one value for each posterior sample otherwise
</p>
</li>
<li><p> &quot;prc_dat&quot;: only if <code>curves = TRUE</code>; a list with length 1 if
<code>fullsims = FALSE</code>, longer otherwise
</p>
</li>
<li><p> &quot;roc_dat&quot;: only if <code>curves = TRUE</code>; a list with length 1 if
<code>fullsims = FALSE</code>, longer otherwise
</p>
</li></ul>



<h3>References</h3>

<p>Beger, Andreas. 2016. “Precision-Recall Curves.” Available at
doi: <a href="https://doi.org/10.2139/ssrn.2765419">10.2139/ssrn.2765419</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
# load simulated data and fitted model (see ?sim_data and ?jags_logit)
data("jags_logit")

# using mcmcRocPrc
fit_sum &lt;- mcmcRocPrc(jags_logit,
                      yname = "Y",
                      xnames = c("X1", "X2"),
                      curves = TRUE,
                      fullsims = FALSE)
fit_sum                     
plot(fit_sum)

# Equivalently, we can calculate the matrix of predicted probabilities 
# ourselves; using the example from ?jags_logit:
library(R2jags)

data("sim_data")
yvec &lt;- sim_data$Y
xmat &lt;- sim_data[, c("X1", "X2")]

# add intercept to the X data
xmat &lt;- as.matrix(cbind(Intercept = 1L, xmat))

beta &lt;- as.matrix(as.mcmc(jags_logit))[, c("b[1]", "b[2]", "b[3]")]
pred_mat &lt;- plogis(xmat %*% t(beta)) 

# the matrix of predictions has rows matching the number of rows in the data;
# the column are the predictions for each of the 2,000 posterior samples
nrow(sim_data)
dim(pred_mat)

# now we can call mcmcRocPrc; the default method works with the matrix
# of predictions and vector of outcomes as input
mcmcRocPrc(object = pred_mat, curves = TRUE, fullsims = FALSE, yvec = yvec)
}


</code></pre>

<hr>
<h2 id='sim_data'>Simulated data for examples</h2><span id='topic+sim_data'></span>

<h3>Description</h3>

<p>Simulated data to fit example models against
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data
</code></pre>


<h3>Format</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulating data
set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z &lt;- b0 + b1 * X1 + b2 * X2
pr &lt;- 1 / (1 + exp(-Z)) # inv logit function
Y &lt;- rbinom(n, 1, pr) 
sim_data &lt;- data.frame(cbind(X1, X2, Y))
</code></pre>

<hr>
<h2 id='sim_data_interactive'>Simulated data for examples</h2><span id='topic+sim_data_interactive'></span>

<h3>Description</h3>

<p>Simulated data to fit example models against
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data_interactive
</code></pre>


<h3>Format</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
b3 &lt;- -0.3 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X2 &lt;- runif(n, -1, 1)
Z_interactive &lt;- b0 + b1 * X1 + b2 * X2 + b3 * (X1 * X2)
Y_interactive &lt;- rnorm(n, Z_interactive, 1)
sim_data_interactive &lt;- data.frame(cbind(X1, X2, Y = Y_interactive))
</code></pre>

<hr>
<h2 id='sim_data_interactive_cat'>Simulated data for examples</h2><span id='topic+sim_data_interactive_cat'></span>

<h3>Description</h3>

<p>Simulated data to fit example models against
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data_interactive_cat
</code></pre>


<h3>Format</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
b0 &lt;- 0.2 # true value for the intercept
b1 &lt;- 0.5 # true value for first beta
b2 &lt;- 0.7 # true value for second beta
b3 &lt;- -0.3 # true value for second beta
n &lt;- 500 # sample size
X1 &lt;- runif(n, -1, 1)
X3 &lt;- rbinom(n, 5, .23)
Z_interactive_cat &lt;- b0 + b1 * X1 + b2 * X3 + b3 * (X1 * X3)
Y_interactive_cat &lt;- rnorm(n, Z_interactive_cat, 1)
sim_data_interactive_cat &lt;- data.frame(cbind(X1, X3, Y = Y_interactive_cat))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
