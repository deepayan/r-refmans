<!DOCTYPE html><html><head><title>Help for package plot3D</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plot3D}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#plot3D-package'>
<p>Plotting multi-dimensional data.</p></a></li>
<li><a href='#2-D data set'><p>The earths hypsometry (land elevation) and the ocean's bathymetry</p></a></li>
<li><a href='#2D image and contour plots'>
<p>Extended image and contour plots for 2-D (and 3-D) data.</p></a></li>
<li><a href='#3-D arrows, segments, polygons, boxes, rectangles'>
<p>Plots arrows, segments, points, lines, polygons, rectangles and boxes in a 3D perspective plot or in 2D.</p></a></li>
<li><a href='#3-D contours'>
<p>Contours in 3-D plots.</p></a></li>
<li><a href='#3-D data set'>
<p>Yearly averaged oxygen saturation from the NODC World Ocean</p>
Atlas 2005.</a></li>
<li><a href='#3-D perspectives'>
<p>Perspective plots, 3-D ribbons and 3-D histograms.</p></a></li>
<li><a href='#3-D surfaces'>
<p>Functions for plotting 3 dimensional shapes</p></a></li>
<li><a href='#3-D volume visualisation'>
<p>Functions for plotting 3-D volumetric data.</p></a></li>
<li><a href='#Color key legend'>
<p>Plots a color legend</p></a></li>
<li><a href='#Colors'>
<p>Colors, shading, lighting.</p></a></li>
<li><a href='#Composite plots'>
<p>Handling and plotting plotting lists.</p></a></li>
<li><a href='#images in 3D frame'>
<p>Images in 3-D plots.</p></a></li>
<li><a href='#Mesh generation'>
<p>Rectangular grids.</p></a></li>
<li><a href='#Perspective box'>
<p>Creates an empty perspective box, ready for adding objects</p></a></li>
<li><a href='#plots with legend or colorkeys'>
<p>Plots with legend or colorkeys outside of the plotting region</p></a></li>
<li><a href='#Scatter plots'>
<p>Colored scatter plots and text in 2-D and 3-D</p></a></li>
<li><a href='#trans3D'>
<p>Transformation of 3D elements</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Plotting Multi-Dimensional Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15)</td>
</tr>
<tr>
<td>Imports:</td>
<td>misc3d, stats, graphics, grDevices, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for viewing 2-D and 3-D data, including perspective plots, slice plots, surface plots, scatter plots, etc. Includes data sets from oceanography.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 12:08:36 UTC; karlines</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='plot3D-package'>
Plotting multi-dimensional data.
</h2><span id='topic+plot3D-package'></span><span id='topic+plot3D'></span>

<h3>Description</h3>

<p>Functions for visualising 2-D and 3-D data.
</p>
<p>Many of the functions are extensions of R's <a href="graphics.html#topic+persp">persp</a> or <a href="Matrix.html#topic+image">image</a> function.
</p>
<p>Other packages that provide visualisation of 3-D data (and which might be better suited) are:
<code>rgl, scatterplot3D, misc3D</code>.
</p>


<h3>Note</h3>

<p>This package is dedicated to Carlo.
</p>


<h3>Note</h3>

<p>Some of the functions based on <code>persp</code> will not work properly for all
values of <code>phi</code> (which turns the plots upside-down). 
This is because an assumption is made as to how the perspective plots are viewed.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert
</p>


<h3>References</h3>

<p><a href="https://www.rforscience.com/oceanview.html">https://www.rforscience.com/oceanview.html</a>
</p>
<p><a href="https://www.rforscience.com/plot3d.html">https://www.rforscience.com/plot3d.html</a>
</p>


<h3>See Also</h3>

<p>Functions that are based on the <a href="graphics.html#topic+persp">persp</a> function:
</p>

<ul>
<li> <p><a href="#topic+persp3D">persp3D</a>: an extended version of persp.
</p>
</li>
<li> <p><a href="#topic+ribbon3D">ribbon3D</a>: a perspective plot as ribbons.
</p>
</li>
<li> <p><a href="#topic+hist3D">hist3D</a>: 3-D histograms.
</p>
</li>
<li> <p><a href="#topic+scatter3D">scatter3D</a>, <a href="#topic+points3D">points3D</a>, <a href="#topic+lines3D">lines3D</a>: colored points, lines, ... in 3-D. 
</p>
</li>
<li> <p><a href="#topic+slice3D">slice3D</a>, <a href="#topic+slicecont3D">slicecont3D</a>: slices from a full 3-D data set.
</p>
</li>
<li> <p><a href="#topic+isosurf3D">isosurf3D</a>: isosurfaces from a full 3-D data set as triangles.
</p>
</li>
<li> <p><a href="#topic+voxel3D">voxel3D</a>: isosurfaces from a full 3-D data set as points.
</p>
</li>
<li> <p><a href="#topic+surf3D">surf3D</a>, <a href="#topic+spheresurf3D">spheresurf3D</a>: 3-D shapes or surfaces.
</p>
</li>
<li> <p><a href="#topic+arrows3D">arrows3D</a>: arrows in 3-D.
</p>
</li>
<li> <p><a href="#topic+segments3D">segments3D</a>: line segments in 3-D.
</p>
</li>
<li> <p><a href="#topic+polygon3D">polygon3D</a>: 3-D polygons.
</p>
</li>
<li> <p><a href="#topic+box3D">box3D</a>, <a href="#topic+border3D">border3D</a>, <a href="#topic+rect3D">rect3D</a>: boxes and rectangles in 3-D.
</p>
</li>
<li> <p><a href="#topic+text3D">text3D</a>: labels in 3-D.
</p>
</li></ul>

<p>Functions defined on the <a href="Matrix.html#topic+image">image</a> function:
</p>

<ul>
<li> <p><a href="#topic+image2D">image2D</a>, for an image function to visualise 2-D or 3-D data.
</p>
</li>
<li> <p><a href="#topic+ImageOcean">ImageOcean</a>: an image of the ocean's bathymetry.
</p>
</li></ul>

<p>Other plotting functions:
</p>

<ul>
<li> <p><a href="#topic+contour2D">contour2D</a>, for a contour function to visualise 2-D data and that have a color key.
</p>
</li>
<li> <p><a href="#topic+scatter2D">scatter2D</a>: colored points, lines, ... in 2-D. 
</p>
</li>
<li> <p><a href="#topic+text2D">text2D</a>, <a href="#topic+arrows2D">arrows2D</a>, <a href="#topic+segments2D">segments2D</a>, <a href="#topic+rect2D">rect2D</a>, 
<a href="#topic+polygon2D">polygon2D</a> for other 2D functions that have a color key.
</p>
</li></ul>

<p>Colors and colorkey:
</p>

<ul>
<li> <p><a href="#topic+colkey">colkey</a>: adds a color legend.
</p>
</li>
<li> <p><a href="#topic+jet.col">jet.col</a>, <a href="#topic+ramp.col">ramp.col</a>, <a href="#topic+gg.col">gg.col</a>, <code>alpha.col</code>: suitable colors, shade and lighting.
</p>
</li></ul>

<p>Utility functions:
</p>

<ul>
<li> <p><a href="#topic+mesh">mesh</a>: to generate rectangular (x, y) or (x, y, z) meshes.
</p>
</li></ul>

<p>Data sets:
</p>

<ul>
<li> <p><a href="#topic+Oxsat">Oxsat</a>: 3-D data set with the ocean's oxygen saturation values. 
</p>
</li>
<li> <p><a href="#topic+Hypsometry">Hypsometry</a>: 2-D data set with the worlds elevation 
and ocean's bathymetry.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># run all examples
## Not run: 
 example(persp3D)  
 example(surf3D)  
 example(slice3D)
 example(scatter3D)
 example(segments3D)
 example(image2D)
 example(image3D)
 example(contour3D)
 example(colkey) 
 example(jet.col) 
 example(perspbox)
 example(mesh)
 example(trans3D)
 example(plot.plist)
 example(ImageOcean)
 example(Oxsat)

## End(Not run)
</code></pre>

<hr>
<h2 id='2-D+20data+20set'>The earths hypsometry (land elevation) and the ocean's bathymetry</h2><span id='topic+ImageOcean'></span><span id='topic+Hypsometry'></span>

<h3>Description</h3>

<p><code>Hypsometry</code> is a relatively crude data set of the earths land elevation
(positive) and ocean depth (negative), at 1 dg intervals.
</p>
<p><code>ImageOcean</code> plots the ocean's bathymetry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImageOcean (...)
Hypsometry
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="2-D+2B20data+2B20set_+3A_...">...</code></td>
<td>
<p> arguments passed to function <a href="#topic+image2D">image2D</a>. </p>
</td></tr>
</table>


<h3>Format</h3>

  
<p>A list with the bathymetry (depth) and hypsometry (altitude) of the
world.  It contains:
</p>

<dl>
<dt>x</dt><dd><p>the latitude,</p>
</dd>
<dt>y</dt><dd><p>the longitude,</p>
</dd>
<dt>z</dt><dd><p>the height (m).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Hypsometry is based on dataset <code>Bathymetry</code> from the R-package <code>marelac</code>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+image2D">image2D</a>, for the image function that visualises the bathymetry
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")
 mar &lt;- par("mar")

## =======================================================================
## Images of the hypsometry
## =======================================================================

 par(mfrow = c(2, 2))
 image2D(Hypsometry, asp = TRUE, xlab = expression(degree*E), 
   ylab =  expression(degree*N), contour = TRUE)

# remove ocean
 zz         &lt;- Hypsometry$z
 zz[zz &lt; 0] &lt;- NA
 image2D(zz, x = Hypsometry$x, y = Hypsometry$y, NAcol = "black")

## =======================================================================
## A short version for plotting the Ocean's bathymetry
## =======================================================================

 ImageOcean(asp = TRUE, contour = TRUE)
 ImageOcean(col = "white", 
   contour = list(levels = seq(-6000, 0, by = 2000)))

## =======================================================================
## A complex image of part of the ocean 
## =======================================================================

# elaborate version
 par(mfrow = c(1, 1), mar = c(2, 2, 2, 2))
 ii &lt;- which(Hypsometry$x &gt; -50 &amp; Hypsometry$x &lt; -20)
 jj &lt;- which(Hypsometry$y &gt;  10 &amp; Hypsometry$y &lt;  40)

# Draw empty persp box
 zlim &lt;- c(-10000, 0)
 pmat &lt;- perspbox(z = Hypsometry$z[ii, jj], 
                  xlab = "longitude", ylab = "latitude", zlab = "depth", 
                  expand = 0.5, d = 2, zlim = zlim, phi = 20, theta = 30,
                  colkey = list(side = 1))

# A function that makes a black panel with grey edge:
 panelfunc &lt;- function(x, y, z) {
    XY &lt;- trans3D(x, y, z, pmat = pmat)
    polygon(XY$x, XY$y, col = "black", border = "grey")
 }
 
# left panel
 panelfunc(x = c(0, 0, 0, 0), y = c(0, 0, 1, 1), 
           z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
 
# back panel
 panelfunc(x = c(0, 0, 1, 1), y = c(1, 1, 1, 1),
           z = c(zlim[1], zlim[2], zlim[2], zlim[1]))
 
# bottom panel
 panelfunc(x = c(0, 0, 1, 1), y = c(0, 1, 1, 0),
           z = c(zlim[1], zlim[1], zlim[1], zlim[1]))
 
# Actual bathymetry, 2 times increased resolution, with contours
 persp3D(z = Hypsometry$z[ii,jj], add = TRUE, resfac = 2,  
       contour = list(col = "grey", side = c("zmin", "z")), 
       zlim = zlim, clab = "depth, m", 
       colkey = list(side = 1, length = 0.5, dist = -0.1))

# shorter alternative for same plot, higher resolution
## Not run: 
 persp3D(z = Hypsometry$z[ii,jj], resfac = 4,  
       contour = list(col = "grey", side = c("zmin", "z")), 
       zlim = zlim, clab = "depth, m", bty = "bl2",
       xlab = "longitude", ylab = "latitude", zlab = "depth", 
       expand = 0.5, d = 2, phi = 20, theta = 30,
       colkey = list(side = 1, length = 0.5, dist = -0.1))

## End(Not run)

# reset plotting parameters
 par(mfrow = pm)
 par(mar = mar)
</code></pre>

<hr>
<h2 id='2D+20image+20and+20contour+20plots'>
Extended image and contour plots for 2-D (and 3-D) data.
</h2><span id='topic+image2D'></span><span id='topic+contour2D'></span><span id='topic+image2D.matrix'></span><span id='topic+image2D.array'></span><span id='topic+image2D.list'></span>

<h3>Description</h3>

<p><code>image2D</code> extends R's <a href="Matrix.html#topic+image">image</a> function. Input can be a matrix (2-D) or an array (3-D) or a list.
</p>
<p><code>contour2D</code> extends R's <a href="graphics.html#topic+contour">contour</a> function.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image2D (z, ...)
contour2D (z, x = seq(0, 1, length.out = nrow(z)),
         y = seq(0, 1, length.out = ncol(z)), ...,
         col = NULL, NAcol = NULL, 
         colkey = NULL, resfac = 1,
         clab = NULL, add = FALSE, plot = TRUE)

## S3 method for class 'matrix'
image2D(z, x = seq(0, 1, length.out = nrow(z)), 
               y = seq(0, 1, length.out = ncol(z)), colvar = z, ...,
               col = NULL, NAcol = "white", breaks = NULL,
               border = NA, facets = TRUE, contour = FALSE, 
               colkey = NULL, resfac = 1, clab = NULL, 
               lighting = FALSE, shade = NA, ltheta = -135, lphi = 0,
               theta = 0, rasterImage = FALSE,
               add = FALSE, plot = TRUE) 

## S3 method for class 'array'
image2D(z, margin = c(1, 2), subset, ask = NULL, ...) 
## S3 method for class 'list'
image2D(z, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_z">z</code></td>
<td>
<p>Matrix (2-D) or array (3-D) or a list with matrices or arrays,
with z-values. By default <code>colvar</code> is equal to <code>z</code>, hence 
<code>z</code> also defines the variable used to color the <a href="Matrix.html#topic+image">image</a>. 
Only when <code>shade</code> or <code>lighting</code> is toggled on does it make 
sense to use <code>z</code> different from <code>colvar</code>.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_x">x</code>, <code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_y">y</code></td>
<td>
<p>Vectors or matrix with x and y values. 
If a vector <code>x</code> should be of length equal to <code>nrow(z)</code> and 
<code>y</code> should be of length equal to <code>ncol(z)</code>. 
If a matrix (only for <code>image2D</code>), they should have
the same dimension as <code>z</code> or be of dimension = <code>dim(z)+1</code>.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_colvar">colvar</code></td>
<td>
<p>Only used when <code>shade</code> or <code>lighting</code> is toggled on.
The variable used to color the image. 
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_col">col</code></td>
<td>
<p>Color palette to be used for the <a href="Matrix.html#topic+image">image</a> function or for the contours.
See details.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_nacol">NAcol</code></td>
<td>
<p>Color to be used for <code>NA</code> values of <code>z</code>; for <code>image2D</code>, the default is &ldquo;white&rdquo;,
for <code>contour2D</code>, the default is to do nothing. 
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_contour">contour</code></td>
<td>
<p>If <code>TRUE</code>, then a <a href="graphics.html#topic+contour">contour</a> plot will be
added to the image plot, unless <code>x, y</code> are a matrix. 
Also allowed is to pass a <code>list</code> with arguments for the 
<a href="graphics.html#topic+contour">contour</a> function. 
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters 
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_resfac">resfac</code></td>
<td>
<p>Resolution factor, one value or a vector of two numbers, for 
the x and y- values respectively. A value &gt; 1 will increase the 
resolution. For instance, if <code>resfac</code> equals <code>3</code> then for each 
adjacent pair of x- and y-values, z will be interpolated to two intermediary points. 
This uses simple linear interpolation. If <code>resfac</code> is one number then
the resolution will be increased similarly in x and y-direction.  
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_lighting">lighting</code></td>
<td>
<p>If not <code>FALSE</code> the facets will be illuminated, and colors may
appear more bright. To switch on lighting, the argument <code>lighting</code> 
should be either set to <code>TRUE</code> (using default settings) or it can be a 
list with specifications of one of the following: 
<code>ambient, diffuse, specular, exponent, sr</code> and <code>alpha</code>. 
</p>
<p>Will overrule <code>shade</code> not equal to <code>NA</code>.
</p>
<p>See examples in <a href="#topic+jet.col">jet.col</a>.
</p>
</td></tr> 
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_shade">shade</code></td>
<td>
<p>the degree of shading of the surface facets. 
Values of shade close to one yield shading similar to a point light 
source model and values close to zero produce no shading. 
Values in the range 0.5 to 0.75 provide an approximation to daylight illumination.
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr> 
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_ltheta">ltheta</code>, <code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_lphi">lphi</code></td>
<td>
<p>if finite values are specified for <code>ltheta</code> and 
<code>lphi</code>, the surface is shaded as though it was being illuminated from 
the direction specified by azimuth <code>ltheta</code> and colatitude <code>lphi</code>.
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>   
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_theta">theta</code></td>
<td>
<p>The angle defining the azimuthal direction. 
Implemented for consistency with the other functions based on <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_border">border</code></td>
<td>
<p>The color of the lines drawn around the surface facets.
The default, <code>NA</code>, will disable the drawing of borders.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_facets">facets</code></td>
<td>
<p>If <code>TRUE</code>, then <code>col</code> denotes the color of the surface facets. 
If <code>FALSE</code>, then the surface facets are colored &ldquo;white&rdquo; and the <code>border</code>
will be colored as specified by <code>col</code>. If <code>NA</code> then the facets will be
transparent. 
It is usually faster to draw with <code>facets = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_rasterimage">rasterImage</code></td>
<td>
<p>If <code>TRUE</code>, the function <a href="graphics.html#topic+rasterImage">rasterImage</a> will be
used for plotting rather than <a href="Matrix.html#topic+image">image</a> or <a href="graphics.html#topic+polygon">polygon</a>. This requires
the <code>x</code> and <code>y</code> to be a vector with equally spaced elements.
Note that by default, <a href="graphics.html#topic+rasterImage">rasterImage</a> linearly interpolates the image,
so it will appear smoother.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the points will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr> 
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise (for 3D plots) the viewing transformation matrix is returned (as invisible).
</p>
</td></tr>   
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_margin">margin</code></td>
<td>
<p>A vector giving the subscripts which the <code>image</code> 
function will be applied over. 
The image function will loop over the index that is not in <code>margin</code>.
For instance, <code>c(1, 2)</code>, indicates to plot rows(x) and columns(y) and to 
loop over index <code>3</code>;  
<code>c(2, 1)</code> will do the same but the image will be transposed.
<code>margin</code> should be a vector with two numbers inbetween <code>1</code>, and <code>3</code>.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_ask">ask</code></td>
<td>
<p>A logical; if <code>TRUE</code>, the user is asked before each plot, 
if <code>NULL</code> the user is only asked if more than one page of plots is 
necessary and the current graphics device is set interactive, 
see <a href="graphics.html#topic+par">par</a>(ask) and <a href="grDevices.html#topic+dev.interactive">dev.interactive</a>.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_subset">subset</code></td>
<td>
<p>Either a logical expression indicating over which elements to loop,
or a vector or integers denoting the indices of the elements over which to loop.
Missing values are taken as <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="2D+2B20image+2B20and+2B20contour+2B20plots_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting methods <a href="Matrix.html#topic+image">image</a>,
<a href="graphics.html#topic+rasterImage">rasterImage</a>, <a href="graphics.html#topic+polygon">polygon</a> and  <a href="graphics.html#topic+contour">contour</a>. 
</p>
<p><code>alpha</code> can be given a value inbetween 0 and 1 to make colors transparent.
</p>
<p>The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>image2D</code> is an extension to the default <a href="Matrix.html#topic+image">image</a> plot that has
the possibility to add a color key and contourlines, and to increase the 
resolution in order to make smoother images. It also uses a different color
scheme, it can deal with decreasing x- and y- values and x and y can be
a matrix. In the latter case, the image will be drawn as a set of <a href="graphics.html#topic+polygon">polygon</a>s;
if <code>x</code> and <code>y</code> are a vector, either R-function <a href="Matrix.html#topic+image">image</a> or 
<a href="graphics.html#topic+rasterImage">rasterImage</a> will be used.
</p>
<p><code>image2D.array</code> and <code>image2D.list</code> are versions that
accept a 3 dimensional array respectively a list with z-matrices 
as their first argument to produce multiple plots.
</p>
<p>For argument <code>col</code> of the <code>image2D</code> function, 
both <code>NA</code> and <code>NULL</code> are allowed, 
in which case the color will be white, and no color key will be drawn.
</p>
<p>To set the ranges of the z-variable, both arguments <code>zlim</code> (as in <a href="Matrix.html#topic+image">image</a>)
and <code>clim</code> (as in the other <code>plot3D</code> functions) are accepted. 
</p>
<p>Upon returning from the <code>image2D</code> and <code>contour2D</code> functions, the figure coordinates are defined
by the main figure (excluding the color key). Thus, one can safely add other 
plotting elements.  
</p>


<h3>Value</h3>

<p>Returns nothing.
</p>


<h3>Note</h3>

<p>The first argument, <code>z</code> generally determines the color variable. 
For consistency with the other functions, another variable, <code>colvar</code>
is also defined and set by default equal to <code>z</code>. <code>colvar</code> will
only be used if <code>shade</code> or <code>lighting</code> are toggled on. In this case,
<code>z</code> will be used to define the shading (orientation of each facet), while 
<code>colvar</code> will define the color.
</p>
<p>When <code>x</code> and <code>y</code> is a vector, the function uses R-function <a href="Matrix.html#topic+image">image</a>.
This means that the x- and y- axis will extend the x- and y- values with half
a grid cell. 
</p>
<p>In contrast, when <code>x</code> and <code>y</code> are a matrix, 
the axis will not extend the x- or y- values.  See first example.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+jet.col">jet.col</a>,  <a href="#topic+ImageOcean">ImageOcean</a>, 
<a href="#topic+Oxsat">Oxsat</a>, <a href="#topic+persp3D">persp3D</a>, <a href="#topic+scatter2D">scatter2D</a> 
for other examples where <code>image2D</code> is used.
</p>
<p><a href="Matrix.html#topic+image">image</a> and <a href="graphics.html#topic+contour">contour</a> for the original R functions.
</p>
<p><code>plot.image</code> from the fields package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## =======================================================================
## Difference between x or y a vector/matrix and rasterImage
## =======================================================================

 par(mfrow = c(2, 2))
 x &lt;- y &lt;- 1:3
 z &lt;- matrix (nrow = 3, ncol = 3, data = 1:9)
 image2D(z, x, y, border = "black")
 image2D(z, x, y, rasterImage = TRUE, border = "black")
 image2D(z, x = matrix(nrow = 3, ncol = 3, data = rep(x, times = 3)), 
       y, border = "black")
 image2D(z, x, y, border = "black", theta = 45)

## =======================================================================
## shading, light, adding contours, points and lines
## =======================================================================

 par(mfrow = c(2, 2))
 nr &lt;- nrow(volcano)
 nc &lt;- ncol(volcano)

 image2D(volcano, x = 1:nr, y = 1:nc, lighting = TRUE, 
       main = "volcano", clab = "height, m")

 abline(v = seq(10, 80, by = 10))
 abline(h = seq(10, 60, by = 10))
 points(50, 30, pch = 3, cex = 5, lwd = 3, col = "white")

 image2D(z = volcano, x = 1:nr, y = 1:nc, lwd = 2, shade = 0.2,
       main = "volcano", clab = "height, m")

 image2D(volcano, x = 1:nr, y = 1:nc, contour = TRUE, shade = 0.5, lphi = 0,
       col = "lightblue", main = "volcano")

 breaks &lt;- seq(90, 200, by = 10)
 image2D(volcano, x = 1:nr, y = 1:nc, col = jet.col(length(breaks)-1),
       main = "volcano", clab = "height, m", breaks = breaks)

## =======================================================================
## Contour plots
## =======================================================================

 par(mfrow = c(2, 2))
 V &lt;- volcano - 150
 
# default, no color key
 contour2D(z = V, colkey = FALSE, lwd = 2)

# imposed levels
 contour2D(z = V, lwd = 2, levels = seq(-40, 40, by = 20))

# negative levels dashed
 contour2D(z = V, col = "black", lwd = 2, 
           levels = seq(0, 40, by = 20))
 contour2D(z = V, col = "black", lwd = 2, lty = 2, 
           levels = seq(-40, -20, by = 20), add = TRUE)

# no labels, imposed number of levels, colorkey
 contour2D(z = V, lwd = 2, nlevels = 20, drawlabels = FALSE, 
           colkey = list(at = seq(-40, 40, by = 20)))

## =======================================================================
## A large data set, input is an array
## =======================================================================

 par(mfrow = c(1, 1))
 image2D(z = Oxsat$val[, , 1], x = Oxsat$lon, y = Oxsat$lat,
       main = "surface oxygen saturation data 2005", NAcol = "black", 
       clab = c("","","%"))

# images at first 9 depths - use subset to select them
 image2D(z = Oxsat$val, subset = 1:9, 
       x = Oxsat$lon, y = Oxsat$lat,
       margin = c(1, 2), NAcol = "black", 
       xlab = "longitude", ylab = "latitude", 
       zlim = c(0, 115),
       main = paste("depth ", Oxsat$depth[1:9], " m"),
       mfrow = c(3, 3))

# images at latitude - depth section - increase resolution
 z &lt;- Oxsat$val[,  Oxsat$lat &gt; - 5 &amp; Oxsat$lat &lt; 5, ]
 image2D(z = z, x = Oxsat$lon, y = Oxsat$depth,
       margin = c(1, 3), NAcol = "black", 
       resfac = 3, ylim = c(5000, 0))
  
# show position of transects 
 image2D(z = Oxsat$val[ , ,1], 
       x = Oxsat$lon, y = Oxsat$lat,
       NAcol = "black")
 abline(h = Oxsat$lat[Oxsat$lat &gt; - 5 &amp; Oxsat$lat &lt; 5])      

## =======================================================================
## Image of a list of matrices
## =======================================================================

 listvolcano &lt;- list(volcano = volcano, logvolcano = log(volcano)) 
 image2D(listvolcano, x = 1:nr, y = 1:nc, contour = TRUE,
       main = c("volcano", "log(volcano)"), 
       clab = list("height, m", "log(m)"),
       zlim = list(c(80, 200), c(4.4, 5.5)))

## =======================================================================
## Image of a list of arrays
## =======================================================================

## Not run: 
# crude conversion from oxsat to oxygen 
 listoxygen &lt;- list(Oxsat$val, Oxsat$val/100 * 360)
  
 image2D(z = listoxygen, 
       x = Oxsat$lon, y = Oxsat$lat,
       margin = c(1, 2), NAcol = "black", 
       main = c("Oxygen saturation ", " Oxygen concentration"),
       mtext = paste("depth ", Oxsat$depth, " m")
       )

## End(Not run)

## =======================================================================
## 'x', 'y' and 'z' are matrices
## =======================================================================

 par(mfrow = c(2, 1))

# tilted x- and y-coordinates of 'volcano'
 volcx &lt;- matrix(nrow = 87, ncol = 61, data = rep(1:87, times=61))
 volcx &lt;- volcx + matrix(nrow = 87, ncol = 61, byrow = TRUE, 
        data = rep(seq(0., 15, length.out=61), times=87))

 volcy &lt;- matrix(ncol = 87, nrow = 61, data = rep(1:61, times=87))
 volcy &lt;- t(volcy + matrix(ncol = 87, nrow = 61, byrow = TRUE, 
        data = rep(seq(0., 25, length.out=87), times=61)))

 image2D(volcano, x = volcx, y = volcy)

# x and y can also be of dimension dim(z)+1:
## Not run: 
# tilted x- and y-coordinates of 'volcano'
 volcx &lt;- matrix(nrow = 88, ncol = 62, data = rep(1:88, times=62))
 volcx &lt;- volcx + matrix(nrow = 88, ncol = 62, byrow = TRUE, 
        data = rep(seq(0., 15, length.out=62), times=88))

 volcy &lt;- matrix(ncol = 88, nrow = 62, data = rep(1:62, times=88))
 volcy &lt;- t(volcy + matrix(ncol = 88, nrow = 62, byrow = TRUE, 
        data = rep(seq(0., 25, length.out=88), times=62)))

 image2D(volcano, x = volcx, y = volcy)

## End(Not run)

# use of panel function
 image2D(volcano, x = volcx, y = volcy, NAcol = "black", 
       panel.first = substitute(box(col = "lightgrey", lwd = 30)))
                                    
## =======================================================================
## Image with NAs and logs
## =======================================================================

 par(mfrow = c(2, 2))
# normal volcano
 image2D(volcano, clab = c("height", "m"))

# logarithmic z-axis
 image2D(volcano, log = "z", clab = c("height", "m"),
     main = "log='z'")

# Including NAs
 VOLC &lt;- volcano - 110
 VOLC [VOLC &lt;= 0] &lt;- NA
 image2D(VOLC, main = "including NAs and rescaled")

# both
 image2D(VOLC, NAcol = "black", log = "z", zlim = c(1, 100),
     main = "NAs and log = 'z'")

## =======================================================================
## Image with contour specification (alpha sets the transparency)
## =======================================================================

 par(mfrow = c(1, 1))
 image2D(volcano, shade = 0.2, rasterImage = TRUE,
   contour = list(col = "white", labcex = 0.8, lwd = 3, alpha = 0.5))
# same:
## Not run: 
 image2D(z = volcano, shade = 0.2, rasterImage = TRUE)
 contour2D(z = volcano, col = "white", labcex = 0.8, 
   lwd = 3, alpha = 0.5, add = TRUE)

## End(Not run)
# reset plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='3-D+20arrows+2C+20segments+2C+20polygons+2C+20boxes+2C+20rectangles'>
Plots arrows, segments, points, lines, polygons, rectangles and boxes in a 3D perspective plot or in 2D.
</h2><span id='topic+arrows3D'></span><span id='topic+segments3D'></span><span id='topic+box3D'></span><span id='topic+border3D'></span><span id='topic+rect3D'></span><span id='topic+polygon3D'></span><span id='topic+arrows2D'></span><span id='topic+segments2D'></span><span id='topic+rect2D'></span><span id='topic+polygon2D'></span>

<h3>Description</h3>

<p>Functions <code>arrows3D</code> and <code>segments3D</code> draw arrows and line segments 
between pairs of points.
</p>
<p>Functions <code>box3D</code> and <code>border3D</code> draw boxes between pairs of points. 
</p>
<p><code>polygon3D</code> draws polygons; <code>rect3D</code> draws rectangles.
</p>
<p>The 2D functions <code>arrows2D</code>, <code>segments2D</code>, <code>rect2D</code> and <code>polygon2D</code> are included
for their side effect of having a color key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrows3D (x0, y0, z0, x1 = x0, y1 = y0, z1 = z0, ...,  
         colvar = NULL, phi = 40, theta = 40,
         col = NULL, NAcol = "white", breaks = NULL,
         colkey = NULL, panel.first = NULL,
         clim = NULL, clab = NULL, bty = "b", type = "triangle", 
         add = FALSE, plot = TRUE)

segments3D (x0, y0, z0, x1 = x0, y1 = y0, z1 = z0, ..., 
         colvar = NULL, phi = 40, theta = 40,
         col = NULL, NAcol = "white", breaks = NULL,
         colkey = NULL, panel.first = NULL,
         clim = NULL, clab = NULL, bty = "b", 
         add = FALSE, plot = TRUE)

box3D (x0, y0, z0, x1, y1, z1, ..., 
         colvar = NULL, phi = 40, theta = 40,
         col = NULL, NAcol = "white", breaks = NULL,
         border = NA, facets = TRUE, colkey = NULL,
         panel.first = NULL, clim = NULL, clab = NULL, bty = "b",
         add = FALSE, plot = TRUE)

border3D(x0, y0, z0, x1, y1, z1, ..., 
         colvar = NULL, phi = 40, theta = 40,
         col = NULL, NAcol = "white", breaks = NULL,
         colkey = NULL, panel.first = NULL,
         clim = NULL, clab = NULL, bty = "b", 
         add = FALSE, plot = TRUE)  

rect3D (x0, y0, z0, x1 = NULL, y1 = NULL, z1 = NULL, ..., 
         colvar = NULL, phi = 40, theta = 40,
         col = NULL, NAcol = "white", breaks = NULL,
         border = NA, facets = TRUE, colkey = NULL,
         panel.first = NULL, clim = NULL, clab = NULL, bty = "b",
         add = FALSE, plot = TRUE)

polygon3D (x, y, z, ..., 
         colvar = NULL, phi = 40, theta = 40,
         col = NULL, NAcol = "white", breaks = NULL,
         border = NA, facets = TRUE, colkey = NULL,
         panel.first = NULL, clim = NULL, clab = NULL, bty = "b",
         add = FALSE, plot = TRUE)  
         
arrows2D (x0, y0, x1 = x0, y1 = y0, ..., colvar = NULL,
         col = NULL, NAcol = "white", breaks = NULL,
         colkey = NULL, clim = NULL, clab = NULL, 
         type = "triangle", add = FALSE, plot = TRUE)  

segments2D (x0, y0, x1 = x0, y1 = y0, ..., colvar = NULL,
         col = NULL, NAcol = "white", breaks = NULL,
         colkey = NULL, clim = NULL, clab = NULL, 
         add = FALSE, plot = TRUE) 

rect2D (x0, y0, x1 = x0, y1 = y0, ..., colvar = NULL,
         col = NULL, NAcol = "white", breaks = NULL,
         colkey = NULL, clim = NULL, clab = NULL, 
         add = FALSE, plot = TRUE) 
         
polygon2D (x, y, ..., colvar = NULL, 
         col = NULL, NAcol = "white", breaks = NULL,
         border = NA, facets = TRUE,
         colkey = NULL, clim = NULL, clab = NULL, 
         add = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_x0">x0</code>, <code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_y0">y0</code>, <code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_z0">z0</code></td>
<td>
<p>coordinates of points <em>from</em> which to draw.  
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_x1">x1</code>, <code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_y1">y1</code>, <code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_z1">z1</code></td>
<td>
<p>coordinates of points <em>to</em> which to draw. 
For <code>arrows3D</code> and <code>segments3D</code>, at least one must be supplied. 
For <code>rect3D</code> exactly one must be <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_x">x</code>, <code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_y">y</code>, <code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_z">z</code></td>
<td>
<p>coordinates of the vertices of the polygon. 
The polygon will be closed by joining the last point to the first point. 
The coordinates can contain missing values (<code>NA</code>). 
These <code>NA</code> values break the polygon into several complete polygons.
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. It need
not be present, but if specified, it should be a vector of 
dimension equal to the coordinates or to the number of polygons.
Values of <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>
will toggle off coloration according to <code>colvar</code>. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_theta">theta</code>, <code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_phi">phi</code></td>
<td>
<p>the angles defining the viewing direction. 
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. 
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_col">col</code></td>
<td>
<p>Color palette to be used for coloring the arrows or segments 
as specified by the <code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<a href="#topic+jet.col">jet.col</a>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be &quot;black&quot;. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_border">border</code></td>
<td>
<p>The color of the lines drawn around the surface facets.
The default, <code>NA</code>, will disable the drawing of borders.
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_facets">facets</code></td>
<td>
<p>If <code>TRUE</code>, then <code>col</code> denotes the color of the surface facets. 
If <code>FALSE</code>, then the surface facets are colored &ldquo;white&rdquo; and the <code>border</code> 
(if <code>NA</code>) will be colored as specified by <code>col</code>. 
If <code>NA</code> then the facets will be transparent. 
It is usually faster to draw with <code>facets = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_panel.first">panel.first</code></td>
<td>
<p>A <code>function</code> to be evaluated after the plot axes are 
set up but before any plotting takes place. 
This can be useful e.g. for drawing background grids or scatterplot smooths. 
The function should have as argument the transformation matrix, e.g. it should
be defined as <code>function(pmat)</code>. See example of <a href="#topic+persp3D">persp3D</a> and last example of <a href="#topic+voxel3D">voxel3D</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable, used
for the color key. Values of <code>colvar</code> that extend the range will be put to <code>NA</code>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_bty">bty</code></td>
<td>
<p>The type of the perspective box, the default draws only the back panels.
Only effective if the <a href="graphics.html#topic+persp">persp</a> 
argument (<code>box</code>) equals <code>TRUE</code> (this is the default). See <a href="#topic+perspbox">perspbox</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_type">type</code></td>
<td>
<p>The type of the arrow head, one of <code>"simple"</code> 
(which uses R-function <a href="graphics.html#topic+arrows">arrows</a>), <code>"curved"</code> or <code>"triangle"</code> and <code>"cone"</code>.
The latter two are the same in <code>plot3D</code> (but differ in package <code>plot3Drgl</code>).
</p>
</td></tr>
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the arrows, segments, ... will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise the viewing transformation matrix is returned (as invisible). 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20arrows+2B2C+2B20segments+2B2C+2B20polygons+2B2C+2B20boxes+2B2C+2B20rectangles_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting methods. 
</p>
<p>The following <a href="graphics.html#topic+persp">persp</a> arguments can be specified: 
<code>xlim, ylim, zlim, xlab, ylab, zlab, main, sub, r, d, 
    scale, expand, box, axes, nticks, ticktype</code>.
The arguments <code>xlim</code>, <code>ylim</code>, <code>zlim</code> only affect the axes for 3D plots.
All objects will be plotted, including those that fall out of these ranges.
To select objects only within the axis limits, use <a href="#topic+plotdev">plotdev</a>.
</p>
<p><code>shade</code> and <code>lighting</code> arguments will have no effect.
</p>
<p><code>alpha</code> can be given a value inbetween 0 and 1 to make colors transparent.
</p>
<p>In addition, the <a href="#topic+perspbox">perspbox</a> arguments
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> can 
also be given a value.
</p>
<p>For <code>arrows3D</code>, the following <a href="graphics.html#topic+arrows">arrows</a> arguments can be specified:
<code>length, code, angle</code>.
</p>
<p>For <code>polygon3D</code>, the following <a href="graphics.html#topic+polygon">polygon</a> arguments can be specified:
<code>border</code>.
</p>
<p>For all the functions, arguments <code>lty, lwd</code> can be specified.
</p>
<p>The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the viewing transformation matrix.
</p>
<p>See <a href="#topic+trans3D">trans3D</a>.
</p>


<h3>See Also</h3>

<p><a href="graphics.html#topic+arrows">arrows</a> for the 2-D arrows function on which <code>arrows3D</code> is based.
</p>
<p><a href="graphics.html#topic+segments">segments</a> for the 2-D arrows function on which <code>segments3D</code> is based.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
  pm &lt;- par("mfrow")

## ========================================================================
## arrows, points, segments, box
## ========================================================================

# Create a grid of x, y, and z values
 xx &lt;- yy &lt;- seq(-0.8, 0.8, by = 0.2)
 zz &lt;- seq(-0.8, 0.8, by = 0.8)

 M &lt;- mesh(xx, yy, zz)
 x0 &lt;- M$x; y0 &lt;- M$y; z0 &lt;- M$z
 x1 &lt;- x0 + 0.1

 Col &lt;- c("red", "blue", "green") 
 arrows3D(x0, y0, z0, x1 = x1, colvar = z0, lwd = 2, 
          d = 2, clab = "z-value", col = Col, length = 0.1,
          xlim = c(-0.8, 0.8), ylim = c(-0.8, 0.8),
          main = "arrows3D, points3D, segments3D, border3D")

# add starting point of arrows
 points3D(x0, y0, z0, add = TRUE, colvar = z0, 
           colkey = FALSE, pch = ".", cex = 3, col = Col)

# use segments to add section
 x0 &lt;- c(-0.8, 0.8,  0.8, -0.8)
 x1 &lt;- c( 0.8, 0.8, -0.8, -0.8)
         
 y0 &lt;- c(-0.8, -0.8, 0.8, -0.8)
 y1 &lt;- c(-0.8,  0.8, 0.8, 0.8)

 z0 &lt;- c(0., 0., 0., 0.)
 segments3D(x0, y0, z0, x1, y1, z1 = z0,
     add = TRUE, col = "black", lwd = 2)

# add a box 
 border3D(-0.8, -0.8, -0.8, 0.8, 0.8, 0.8,
       col = "orange", add = TRUE, lwd = 3)

## ========================================================================
## boxes, cubes
## ========================================================================

# borders are boxes without facets  
 border3D(x0 = seq(-0.8, -0.1, by = 0.1), 
       y0 = seq(-0.8, -0.1, by = 0.1),
       z0 = seq(-0.8, -0.1, by = 0.1),
       x1 = seq(0.8, 0.1, by = -0.1),
       y1 = seq(0.8, 0.1, by = -0.1),
       z1 = seq(0.8, 0.1, by = -0.1),
       col = gg.col(8), lty = 2, 
       lwd = c(1, 4), phi = 20, main = "border3D")

 box3D(x0 = -0.8, y0 = -0.8, z0 = -0.8, 
       x1 = 0.8, y1 = 0.8, z1 = 0.8, 
       border = "black", lwd = 2, 
       col = gg.col(1, alpha = 0.8), 
       main = "box3D")

 box3D(x0 = seq(-0.8, -0.1, by = 0.1), 
       y0 = seq(-0.8, -0.1, by = 0.1),
       z0 = seq(-0.8, -0.1, by = 0.1),
       x1 = seq(0.8, 0.1, by = -0.1),
       y1 = seq(0.8, 0.1, by = -0.1),
       z1 = seq(0.8, 0.1, by = -0.1),
       col = rainbow(n = 8, alpha = 0.1), 
       border = "black", lwd = 2, phi = 20)

# here the perspective does not always work 
# use alpha.col to set the transparency of a vector of colors
 box3D(x0 = runif(3), y0 = runif(3), z0 = runif(3),
       x1 = runif(3), y1 = runif(3), z1 = runif(3),
       col = c("red", "lightblue", "orange"), alpha = 0.5,
       border = "black", lwd = 2)

## ========================================================================
## rectangles
## ========================================================================
# at constant 'z'
 rect3D(x0 = seq(-0.8, -0.1, by = 0.1),
        y0 = seq(-0.8, -0.1, by = 0.1),
        z0 = seq(-0.8, -0.1, by = 0.1),
        x1 = seq(0.8, 0.1, by = -0.1),
        y1 = seq(0.8, 0.1, by = -0.1),
        col = gg.col(8), border = "black",
        bty = "g", lwd = 2, phi = 20, main = "rect3D")

# constant y and with transparent facets
 rect3D(x0 = 0, y0 = 0, z0 = 0, x1 = 1, z1 = 5,
        ylim = c(0, 1), facets = NA, border = "red",
        bty = "g", lwd = 2, phi = 20)

# add rect at constant z, with colored facet
 rect3D(x0 = 0, y0 = 0, z0 = 0, x1 = 1, y1 = 1,
        border = "red", add = TRUE)

## ========================================================================
## arrows added to a persp plot 
## ========================================================================

 x &lt;- y &lt;- seq(-10, 10, length = 30)
 z &lt;- outer(x, y, FUN = function(x,y) x^2 + y^2)

 persp3D(x, y, z, theta = 30, phi = 30, 
         col = "lightblue", ltheta = 120, shade = 0.75, 
         ticktype = "detailed", xlab = "X", 
         ylab = "Y", zlab = "x^2+y^2" )  

# Points where to put the arrows
 x &lt;- y &lt;- seq(-10, 10, len = 6)
 X0 &lt;- outer(x, y, FUN = function (x,y) x)
 Y0 &lt;- outer(x, y, FUN = function (x,y) y)
 Z0 &lt;- outer(x, y, FUN = function (x,y) x^2 + y^2)

 X1 &lt;- X0 + 1
 Y1 &lt;- Y0 + 1
 Z1 &lt;- Z0 + 10

 arrows3D(X0, Y0, Z0, X1, Y1, Z1, lwd = 2, 
         add = TRUE, type = "curved", col = "red")

 segments3D(X0, Y0, Z0, X0, Y0, rep(0, length(X0)), lwd = 2, 
         add = TRUE, col = "green")

## ========================================================================
## polygon3D 
## ========================================================================

 x &lt;- runif(10)
 y &lt;- runif(10)
 z &lt;- runif(10)
 
 polygon3D(x, y, z)

# several polygons, separated by NAs
 x &lt;- runif(39) 
 y &lt;- runif(39)
 z &lt;- runif(39)
 ii &lt;- seq(4, 36, by  = 4)
 x[ii] &lt;- y[ii] &lt;- z[ii] &lt;- NA 

# transparent colors (alpha)
 polygon3D(x, y, z, border = "black", lwd = 3,
   col = gg.col(length(ii) + 1, alpha = 0.8), 
   main = "polygon3D")

## ========================================================================
## 2D examples, with color key
## ========================================================================

arrows2D(x0 = runif(10), y0 = runif(10),
         x1 = runif(10), y1 = runif(10), colvar = 1:10, 
         code = 3, main = "arrows2D, segments2D")

segments2D(x0 = runif(10), y0 = runif(10),
         x1 = runif(10), y1 = runif(10), colvar = 1:10, 
         lwd = 2, add = TRUE, colkey = FALSE) 

# transparency
rect2D(x0 = runif(10), y0 = runif(10),
       x1 = runif(10), y1 = runif(10), colvar = 1:10, 
       alpha = 0.4, lwd = 2, main = "rect2D") 

## ========================================================================
## polygon2D 
## ========================================================================

 x &lt;- runif(10)
 y &lt;- runif(10)
 
 polygon2D(x, y)    # same as polygon

# several polygons, separated by NAs
 x &lt;- runif(59) 
 y &lt;- runif(59)

 ii &lt;- seq(5, 55, by  = 5)
 x[ii] &lt;- y[ii] &lt;- NA 

# transparent colors (alpha)
 polygon2D(x, y, border = "black", lwd = 3,
   colvar = 1:(length(ii) + 1), 
   col = gg.col(), alpha = 0.2,
   main = "polygon2D")

# restore plotting parameters
 par(mfrow = pm)

</code></pre>

<hr>
<h2 id='3-D+20contours'>
Contours in 3-D plots.
</h2><span id='topic+contour3D'></span>

<h3>Description</h3>

<p><code>contour3D</code> adds a <a href="graphics.html#topic+contour">contour</a> in a 3-D plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contour3D (x = NULL, y = NULL, z = NULL, 
       ..., colvar = NULL, phi = 40, theta = 40,
       col = NULL, colkey = NULL, 
       panel.first = NULL, clim = NULL, clab = NULL, bty = "b", 
       dDepth = 1e-1, addbox = TRUE, add = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="3-D+2B20contours_+3A_x">x</code>, <code id="3-D+2B20contours_+3A_y">y</code>, <code id="3-D+2B20contours_+3A_z">z</code></td>
<td>
<p>Matrix (2-D), vector, or one value containing the values 
where the image is to be plotted. 
At least one of them should be one number, as this will determine where the 
image is plotted, parallel to the (y-z) plane (x one number), 
to the (x-z) plane (y one number) or to the (z-y) plane (z one number).
</p>
<p>If two are vectors, the first vector should be of length equal to 
<code>nrow(colvar)</code> and the second should be of length equal to 
<code>ncol(colvar)</code>. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20contours_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. 
Values of <code>colvar</code> equal to <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>
will toggle off coloration according to <code>colvar</code>. This gives good results
only if <code>border</code> is given a color, or when <code>shade</code> is &gt;0 (see <a href="graphics.html#topic+persp">persp</a>).
</p>
</td></tr>
<tr><td><code id="3-D+2B20contours_+3A_col">col</code></td>
<td>
<p>Color palette to be used for the <code>colvar</code> variable.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<a href="#topic+jet.col">jet.col</a>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be &quot;black&quot;. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20contours_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters 
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr>  
<tr><td><code id="3-D+2B20contours_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey = TRUE</code>, the label to be written on top of the
color key. The label will be written at the same level as the main title.
to lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20contours_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable, used
for the color key. Values of <code>colvar</code> that extend the range will be put to <code>NA</code>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20contours_+3A_theta">theta</code>, <code id="3-D+2B20contours_+3A_phi">phi</code></td>
<td>
<p>The angles defining the viewing direction. 
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. 
see <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20contours_+3A_panel.first">panel.first</code></td>
<td>
<p>A <code>function</code> to be evaluated after the plot axes are 
set up but before any plotting takes place. 
This can be useful for drawing background grids or scatterplot smooths. 
The function should have as argument the transformation matrix, e.g. it should
be defined as <code>function(pmat)</code>. See example of <a href="#topic+persp3D">persp3D</a> and last example of <a href="#topic+voxel3D">voxel3D</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20contours_+3A_bty">bty</code></td>
<td>
<p>The type of the box, the default only drawing background panels.
Only effective if the <a href="graphics.html#topic+persp">persp</a> 
argument (<code>box</code>) equals <code>TRUE</code> (this is the default). See <a href="#topic+perspbox">perspbox</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20contours_+3A_ddepth">dDepth</code></td>
<td>
<p>When a contour is added on an image, the image polygons may
hide some contour segments. To avoid that, the viewing depth of the segments
can be artificially decreased with the factor <code>dDepth</code> times the 
<a href="graphics.html#topic+persp">persp</a> argument <code>expand</code> (usually = 1), to make them 
appear in front of the polygons. Too large values of <code>dDepth</code> 
may create visible artifacts.
</p>
</td></tr>   
<tr><td><code id="3-D+2B20contours_+3A_addbox">addbox</code></td>
<td>
<p>If <code>TRUE</code> will draw a box around the
plot.
</p>
</td></tr>   
<tr><td><code id="3-D+2B20contours_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the contours will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20contours_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise the viewing transformation matrix is returned (as invisible). 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20contours_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting methods. 
</p>
<p>The following <a href="graphics.html#topic+persp">persp</a> arguments can be specified: 
<code>xlim, ylim, zlim, xlab, ylab, zlab, main, sub, r, d, 
    scale, expand, box, axes, nticks, ticktype</code>.      
The arguments <code>xlim</code>, <code>ylim</code>, <code>zlim</code> only affect the axes.
All objects will be plotted, including those that fall out of these ranges.
To select objects only within the axis limits, use <a href="#topic+plotdev">plotdev</a>.
</p>
<p>In addition, the <a href="#topic+perspbox">perspbox</a> arguments
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> can 
also be given a value.
</p>
<p>The arguments <code>lty, lwd</code> can also be specified.
</p>
<p><code>shade</code> and <code>lighting</code> arguments will have no effect.
</p>
<p><code>alpha</code> can be given a value inbetween 0 and 1 to make colors transparent.
</p>
<p>The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the viewing transformation matrix.
See <a href="#topic+trans3D">trans3D</a>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><a href="graphics.html#topic+contour">contour</a> for R's 2-D contour function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## =======================================================================
## Contours
## =======================================================================
 par (mfrow = c(2, 2))

 r &lt;- 1:nrow(volcano)
 c &lt;- 1:ncol(volcano)
 contour3D(x = r, y = c, z = 100, colvar = volcano, zlim = c(0, 150),
   clab = c("height", "m"))

 contour3D(x = 100, y = r, z = c, colvar = volcano, clab = c("height", "m"))

 contour3D(z = volcano, colvar = volcano, lwd = 2, 
   nlevels = 20, clab = c("height", "m"), colkey = FALSE)

 contour3D(y = volcano, colvar = volcano, lwd = 2, 
   nlevels = 10, clab = c("height", "m"))

## =======================================================================
## Composite images and contours in 3D
## =======================================================================
 persp3D(z = volcano, zlim = c(90, 300), col = "white", 
         shade = 0.1, d = 2, plot = FALSE)
 contour3D(z = volcano, colvar = volcano, lwd = 2, add = TRUE, 
         nlevels = 20, clab = c("height", "m"), plot = FALSE,
         colkey = list(at = seq(90, 190, length.out = 5)))
 contour3D(z = 300, colvar = volcano, lwd = 2, col = "grey",
         add = TRUE, nlevels = 5)
          
## =======================================================================
## the viewing depth of contours (dDepth)
## =======================================================================

# too low
 persp3D(z = volcano, col = "white", shade = 0.1, plot = FALSE)
 contour3D(z = volcano, colvar = volcano, lwd = 2, 
         add = TRUE, dDepth = 0, col = "black")

# default
 persp3D(z = volcano, col = "white", shade = 0.1, plot = FALSE)
 contour3D(z = volcano, colvar = volcano, lwd = 2, 
         add = TRUE, dDepth = 0.1, col = "black")

# too high
 persp3D(z = volcano, col = "white", shade = 0.1, plot = FALSE)
 contour3D(z = volcano, colvar = volcano, lwd = 1, 
         add = TRUE, dDepth = 0.5, col = "black")

# reset plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='3-D+20data+20set'>
Yearly averaged oxygen saturation from the NODC World Ocean
Atlas 2005.
</h2><span id='topic+Oxsat'></span>

<h3>Description</h3>

<p>Percentage Oxygen Saturation from the NODC World Ocean Atlas 2005 (WOA05). 
</p>
<p>The values are gridded in 2dg * 2dg longitude - latitude sets, 
and there are 33 depth intervals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Oxsat)
</code></pre>


<h3>Format</h3>

<p>list with 
</p>

<ul>
<li> <p><code>lon</code>, the longitude (dg E), at 2 dg resolution, 180 values. 
</p>
</li>
<li> <p><code>lat</code>, the latitude (dg N), at 2 dg resolution, 90 values.
</p>
</li>
<li> <p><code>depth</code>, the water depth (m), 33 values.
</p>
</li>
<li> <p><code>val</code>, the saturation value (%).   
<code>val</code> is an array of dimension (180, 90, 33), (lon, lat, depth).
</p>
</li>
<li> <p><code>name</code>, the long name of the variable.
</p>
</li>
<li> <p><code>units</code>, the units of measurement.
</p>
</li></ul>



<h3>Details</h3>

<p>The &ldquo;objectively analyzed climatology&rdquo; has been used to extract these data.
</p>
<p>The original data were averaged over the 4 seasons, and converted to half 
the resolution for latitude and longitude.
The longitude was converted to the European view, i.e. the original data 
from (0, 360) was changed to (-180, 180).
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p><a href="https://www.nodc.noaa.gov/OC5/WOA05/woa05nc.html">https://www.nodc.noaa.gov/OC5/WOA05/woa05nc.html</a> 
</p>
<p>Originally made available by CSIRO:
</p>
<p>Mark A. Collier and Paul J. Durack, 2005. CSIRO netCDF version of the
NODC World Ocean Atlas 2005. CSIRO Marine and Atmospheric Research Paper 015.
December 2006
</p>


<h3>See Also</h3>

<p><a href="#topic+image2D">image2D</a> for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## ========================================================================
## plot all surface data
## ========================================================================

 par(mfrow = c(1, 1))
 image2D(z = Oxsat$val[ , , 1], x = Oxsat$lon, y = Oxsat$lat,
       main = "surface oxygen saturation (%) for 2005")

## ========================================================================
## plot a selection of latitude-depth profiles; input is an array
## ========================================================================

 lon &lt;- Oxsat$lon
 image2D (z = Oxsat$val, margin = c(2, 3), x = Oxsat$lat, 
        y = Oxsat$depth, subset = (lon &gt; 18 &amp; lon &lt; 23),
        ylim = c(5500, 0), NAcol = "black", zlim = c(0, 110),
        xlab = "latitude", ylab = "depth, m")

 ImageOcean()
 abline ( v = lon[lon &gt; 18 &amp; lon &lt; 23])

## ========================================================================
## plot with slices
## ========================================================================

 par(mfrow = c(1, 1))
 ii &lt;- which (Oxsat$lon &gt; -90 &amp; Oxsat$lon &lt; 90)
 jj &lt;- which (Oxsat$lat &gt; 0 &amp; Oxsat$lat &lt; 90)

 xs &lt;- Oxsat$lon[ii[length(ii)]]  # E boundary
 ys &lt;- Oxsat$lat[jj[1]]           # S boundary

 slice3D(colvar = Oxsat$val[ii,jj,], x = Oxsat$lon[ii],  
        y = Oxsat$lat[jj], z = -Oxsat$depth,
        NAcol = "black", xs = xs, ys = ys, zs = 0, 
        theta = 35, phi = 50, colkey = list(length = 0.5),
        expand = 0.5, ticktype = "detailed",
        clab = "%", main = "Oxygen saturation", 
        xlab = "longitude", ylab = "latitude", zlab = "depth")

# restore plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='3-D+20perspectives'>
Perspective plots, 3-D ribbons and 3-D histograms.
</h2><span id='topic+persp3D'></span><span id='topic+ribbon3D'></span><span id='topic+hist3D'></span>

<h3>Description</h3>

<p><code>persp3D</code> extends R's <a href="graphics.html#topic+persp">persp</a> function. 
</p>
<p><code>ribbon3D</code> is similar to <code>persp3D</code> but has ribbon-like colored surfaces.
</p>
<p><code>hist3D</code> generates 3-D histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>persp3D (x = seq(0, 1, length.out = nrow(z)), 
       y = seq(0, 1, length.out = ncol(z)), z, ..., 
       colvar = z, phi = 40, theta = 40,
       col = NULL,  NAcol = "white", breaks = NULL,
       border = NA, facets = TRUE, colkey = NULL, resfac = 1,
       image = FALSE, contour = FALSE, panel.first = NULL,
       clim = NULL, clab = NULL, bty = "b", 
       lighting = FALSE, shade = NA, ltheta = -135, lphi = 0,
       inttype = 1, curtain = FALSE, add = FALSE, plot = TRUE)

ribbon3D (x = seq(0, 1, length.out = nrow(z)), 
      y = seq(0, 1, length.out = ncol(z)), z, ..., 
      colvar = z, phi = 40, theta = 40, 
      col = NULL,  NAcol = "white", breaks = NULL,
      border = NA, facets = TRUE, colkey = NULL, resfac = 1,
      image = FALSE, contour = FALSE, panel.first = NULL,
      clim = NULL, clab = NULL, bty = "b",
      lighting = FALSE, shade = NA, ltheta = -135, lphi = 0,
      space = 0.4, along = "x", 
      curtain = FALSE, add = FALSE, plot = TRUE)

hist3D (x = seq(0, 1, length.out = nrow(z)),
      y = seq(0, 1, length.out = ncol(z)), z, ..., 
      colvar = z, phi = 40, theta = 40, 
      col = NULL, NAcol = "white", breaks = NULL,
      border = NA, facets = TRUE, colkey = NULL,
      image = FALSE, contour = FALSE,
      panel.first = NULL, clim = NULL, clab = NULL, bty = "b", 
      lighting = FALSE, shade = NA, ltheta = -135, lphi = 0,
      space = 0, opaque.top = FALSE, zmin = NULL,
      add = FALSE, plot = TRUE)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="3-D+2B20perspectives_+3A_z">z</code></td>
<td>
<p>Matrix (2-D) containing the values to be plotted as a <a href="graphics.html#topic+persp">persp</a> plot. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_x">x</code>, <code id="3-D+2B20perspectives_+3A_y">y</code></td>
<td>
<p>Vectors or matrices with x and y values. 
If a vector, <code>x</code> should be of length equal to <code>nrow(z)</code> and 
<code>y</code> should be equal to <code>ncol(z)</code>. If a matrix (only for <code>persp3D</code>), 
<code>x</code> and <code>y</code> should have the same dimension as <code>z</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. If present, it should have the 
same dimension as <code>z</code>. Values of <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>
will toggle off coloration according to <code>colvar</code>. This gives good results
only if <code>border</code> is given a color, or when <code>shade</code> is &gt; 0 or 
<code>lighting</code> is <code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_col">col</code></td>
<td>
<p>Color palette to be used for the <code>colvar</code> variable.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<a href="#topic+jet.col">jet.col</a>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be <code>grey</code>. 
</p>
<p>Finally, to mimic the behavior of <a href="graphics.html#topic+persp">persp</a>, set <code>colvar</code> = <code>NULL</code>
and make <code>col</code> a matrix of colors with (nrow(z)-1) rows and 
(ncol(z)-1) columns.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_nacol">NAcol</code></td>
<td>
<p>Color to be used for <code>NA</code> values of <code>colvar</code>; default is &ldquo;white&rdquo;. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey = TRUE</code>, the label to be written on top of the
color key. The label will be written at the same level as the main title.
to lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable, used
for the color key. Values of <code>colvar</code> that extend the range will be put to <code>NA</code>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_resfac">resfac</code></td>
<td>
<p>Resolution factor, one value or a vector of two numbers, for 
the x and y- values respectively. A value &gt; 1 will increase the 
resolution. For instance, if <code>resfac</code> equals <code>3</code> then for each 
adjacent pair of x- and y-values, z will be interpolated to two intermediary points. 
This uses simple linear interpolation. If <code>resfac</code> is one number then
the resolution will be increased similarly in x and y-direction.  
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_theta">theta</code>, <code id="3-D+2B20perspectives_+3A_phi">phi</code></td>
<td>
<p>The angles defining the viewing direction. 
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. 
see <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_border">border</code></td>
<td>
<p>The color of the lines drawn around the surface facets.
The default, <code>NA</code>, will disable the drawing of borders.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_facets">facets</code></td>
<td>
<p>If <code>TRUE</code>, then <code>col</code> denotes the color of the surface facets. 
If <code>FALSE</code>, then the surface facets are colored &ldquo;white&rdquo; and the <code>border</code> 
(if <code>NA</code>) will be colored as specified by <code>col</code>. 
If <code>NA</code> then the facets will be transparent. 
It is usually faster to draw with <code>facets = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_image">image</code></td>
<td>
<p>If <code>TRUE</code>, an image will be plotted at the bottom. 
Also allowed is to pass a <code>list</code> with arguments for the <a href="#topic+image2D">image2D</a> function.
An optional parameter to this <code>list</code> is the <code>side</code> where the image 
should be plotted. Allowed values for <code>side</code> are a z-value, 
or <code>side = "zmin", "zmax"</code>, for positioning at 
bottom or top respectively.  The default is to put the image at the bottom.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_contour">contour</code></td>
<td>
<p>If <code>TRUE</code>, a <a href="graphics.html#topic+contour">contour</a> will be plotted at the bottom. 
Also allowed is to pass a <code>list</code> with arguments for the <a href="graphics.html#topic+contour">contour</a> function.
An optional parameter to this <code>list</code> is the <code>side</code> where the image 
should be plotted. Allowed values for <code>side</code> are a z-value, 
or <code>side = "zmin", "zmax"</code>, for positioning at 
bottom or top respectively.  The default is to put the image at the bottom.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_panel.first">panel.first</code></td>
<td>
<p>A <code>function</code> to be evaluated after the plot axes are 
set up (and if applicable, images or contours drawn) but before any plotting takes place. 
This can be useful for drawing background grids or scatterplot smooths. 
The function should have as argument the transformation matrix (pmat), e.g. it should
be defined as <code>function(pmat)</code>. See example.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_along">along</code></td>
<td>
<p>The direction along which the ribbons are drawn, one of &quot;x&quot;, &quot;y&quot; or &quot;xy&quot;,
for ribbons parallel to the x- y- or both axes. In the latter case, the 
figure looks like a net.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_curtain">curtain</code></td>
<td>
<p>If <code>TRUE</code>, the ribbon or persp edges will be draped till the bottom. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_space">space</code></td>
<td>
<p>The amount of space (as a fraction of the average bar/ribbon width) 
left between bars/ribbons. A value inbetween [0, 0.9] (<code>hist3D</code>) 
or [0.1, 0.9] (<code>ribbon3D</code>). Either one number, or a two-valued vector, 
for the x- and y- direction.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_bty">bty</code></td>
<td>
<p>The type of the box, the default only drawing background panels.
Only effective if the <a href="graphics.html#topic+persp">persp</a> 
argument (<code>box</code>) equals <code>TRUE</code> (this is the default). See <a href="#topic+perspbox">perspbox</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_lighting">lighting</code></td>
<td>
<p>If not <code>FALSE</code> the facets will be illuminated, and colors may
appear more bright. To switch on lighting, the argument <code>lighting</code> 
should be either set to <code>TRUE</code> (using default settings) or it can be a 
list with specifications of one of the following: 
<code>ambient, diffuse, specular, exponent, sr</code> and <code>alpha</code>. 
</p>
<p>Will overrule <code>shade</code> not equal to <code>NA</code>.
</p>
<p>See examples in <a href="#topic+jet.col">jet.col</a>.
</p>
</td></tr>  
<tr><td><code id="3-D+2B20perspectives_+3A_shade">shade</code></td>
<td>
<p>the degree of shading of the surface facets. 
Values of shade close to one yield shading similar to a point light 
source model and values close to zero produce no shading. 
Values in the range 0.5 to 0.75 provide an approximation to daylight illumination.
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_ltheta">ltheta</code>, <code id="3-D+2B20perspectives_+3A_lphi">lphi</code></td>
<td>
<p>if finite values are specified for <code>ltheta</code> and 
<code>lphi</code>, the surface is shaded as though it was being illuminated from 
the direction specified by azimuth <code>ltheta</code> and colatitude <code>lphi</code>.
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20perspectives_+3A_inttype">inttype</code></td>
<td>
<p>The interpolation type to create the polygons, either 
averaging the <code>colvar</code> (<code>inttype = 1, 3</code> or extending 
the <code>x, y, z</code> values (<code>inttype = 2</code>) - see details.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_opaque.top">opaque.top</code></td>
<td>
<p>Only used when <code>alpha</code> is set (transparency):
if <code>TRUE</code> then the top of the bars is opaque.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_zmin">zmin</code></td>
<td>
<p>The base of the histogram ; if <code>NULL</code> then it extends to 
the minimum of the z-axis. Note: this was added from version 1.1.1 on;
before that it was assumed that the base of the histogram was at z=0. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the surfaces will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise the viewing transformation matrix is returned (as invisible). 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20perspectives_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting methods. 
The following <a href="graphics.html#topic+persp">persp</a> arguments can be specified: 
<code>xlim, ylim, zlim, xlab, ylab, zlab, main, sub, r, d, 
    scale, expand, box, axes, nticks, ticktype</code>. 
The arguments <code>xlim</code>, <code>ylim</code>, <code>zlim</code> only affect the axes.
All objects will be plotted, including those that fall out of these ranges.
To select objects only within the axis limits, use <a href="#topic+plotdev">plotdev</a>.
</p>
<p>In addition, the <a href="#topic+perspbox">perspbox</a> arguments
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> can 
also be given a value.
</p>
<p><code>alpha</code> can be given a value inbetween 0 and 1 to make colors transparent.
</p>
<p>For all functions, the arguments <code>lty, lwd</code> can be specified; this is only
effective is <code>border</code> is not <code>NA</code>.
</p>
<p>The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>persp3D</code> is an extension to the default <a href="graphics.html#topic+persp">persp</a> plot that has
the possibility to add a color key, to increase the 
resolution in order to make smoother images, 
to toggle on or off facet coloration, ... 
</p>
<p>The perspective plots are drawn as filled polygons. Each polygon is defined by 
4 corners and a color, defined in its centre. 
When facets are colored, there are three interpolation schemes as set by <code>inttype</code>. 
</p>
<p>The default (<code>inttype = 1</code>) is similar to R's function <code>persp</code>, 
and assumes that the <code>z</code>-values define the points on the corners of 
each polygon. In case a <code>colvar</code> is defined, its values are to be recalculated 
to the middle of each polygon, i.e. the color values need to be of size 
(nx-1)(ny-1), and averages are taken from the original data 
(nx and ny are number of x and y points). 
This will make the colors (and/or shading) smoother.
When <code>inttype = 1</code> then <code>NA</code> values in <code>colvar</code> will be used as 
such during the averaging. This will tend to make the <code>NA</code> region larger.
</p>
<p>An alternative is to set <code>inttype = 3</code>, which is similar to <code>inttype = 1</code>
except for the <code>NA</code> values, which will be removed during the averaging.
This will tend to make the <code>NA</code> region smaller.
</p>
<p>By setting <code>inttype = 2</code>, a second interpolation scheme 
is selected. This is mainly of use in case a <code>colvar</code> is defined, and it 
is not desirable that the colors are smoothened. 
In this scheme, it is assumed that the <code>z</code> values and <code>colvar</code> 
values are both defined in the centre of the polygons.
To color the facets the x, y, z grid is extended (to a (nx+1)(ny+1) grid), 
while <code>colvar</code> is used as such. 
This will make the z-values (topography) smoother than the original data.
This type of interpolation may be preferable for color variables that have <code>NA</code> values,
as taking averages tends to increase the <code>NA</code> region.
</p>


<h3>Value</h3>

<p>Returns, as invisible, the viewing transformation matrix.
</p>
<p>See <a href="#topic+trans3D">trans3D</a>.
</p>


<h3>Note</h3>

<p>To make a <code>contour</code> to appear on top of an image, 
i.e. when <code>side = "z"</code>, the viewing depth
of the contour segments is artificially decreased. In some cases this 
may produce slight artifacts. The viewing depth can be adjusted with argument <code>dDepth</code>,
e.g. <code>persp3D(z = volcano, contour = list(side = "z", dDepth = 0.))</code>
</p>
<p>Parts of this help page come from the help pages of the R-core function 
<a href="graphics.html#topic+persp">persp</a>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>The <a href="graphics.html#topic+persp">persp</a> function on which this implementation is based:
</p>
<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) 
The New S Language. Wadsworth &amp; Brooks/Cole. 
</p>


<h3>See Also</h3>

<p><a href="graphics.html#topic+persp">persp</a> for the function on which this is based.
</p>
<p><a href="#topic+Hypsometry">Hypsometry</a> for an example where axis-panels are colored.
</p>
<p><a href="#topic+scatter3D">scatter3D</a> for a combination of a persp surface and data points.  
</p>
<p><a href="#topic+text3D">text3D</a> for annotating axes (hist3D).
</p>
<p><a href="#topic+plotdev">plotdev</a> for zooming, rescaling, rotating a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## =======================================================================
## Ribbon, persp, color keys, facets
## =======================================================================

 par(mfrow = c(2, 2))
# simple, no scaling, use breaks to set colors
 persp3D(z = volcano, main = "volcano", clab = c("height", "m"), 
   breaks = seq(80,200, by = 10))
  
# keep ratios between x- and y (scale = FALSE) 
# change ratio between x- and z (expand)
 persp3D(z = volcano, x = 1: nrow(volcano), y = 1:ncol(volcano),
       expand = 0.3, main = "volcano", facets = FALSE, scale = FALSE,
       clab = "height, m", colkey = list(side = 1, length = 0.5))

# ribbon, in x--direction
 V &lt;- volcano[, seq(1, ncol(volcano), by = 3)]  # lower resolution
 ribbon3D(z = V, colkey = list(width = 0.5, length = 0.5, 
          cex.axis = 0.8, side = 2), clab = "m")

# ribbon, in y-direction
 Vy &lt;- volcano[seq(1, nrow(volcano), by = 3), ]
 ribbon3D(z = Vy, expand = 0.3, space = 0.3, along = "y", 
          colkey = list(width = 0.5, length = 0.5, cex.axis = 0.8))
  
## =======================================================================
## Several ways to visualise 3-D data
## =======================================================================

 x &lt;- seq(-pi, pi, by = 0.2)
 y &lt;- seq(-pi, pi, by = 0.3)
 grid &lt;- mesh(x, y)

 z    &lt;- with(grid, cos(x) * sin(y))

 par(mfrow = c(2,2))

 persp3D(z = z, x = x, y = y)

 persp3D(z = z, x = x, y = y, facets = FALSE, curtain = TRUE)

# ribbons in two directions and larger spaces
 ribbon3D(z = z, x = x, y = y, along = "xy", space = 0.3)

 hist3D(z = z, x = x, y = y, border = "black")  
  
## =======================================================================
## Contours and images added
## =======================================================================

 par(mfrow = c(2, 2))
 x &lt;- seq(1, nrow(volcano), by = 3)
 y &lt;- seq(1, ncol(volcano), by = 3) 

 Volcano &lt;- volcano [x, y]
 ribbon3D(z = Volcano, contour = TRUE, zlim= c(-100, 200), 
          image = TRUE)

 persp3D(z = Volcano, contour = TRUE, zlim= c(-200, 200), image = FALSE)

 persp3D(z = Volcano, x = x, y = y, scale = FALSE, 
       contour = list(nlevels = 20, col = "red"), 
       zlim = c(-200, 200), expand = 0.2,
       image = list(col = grey (seq(0, 1, length.out = 100))))

 persp3D(z = Volcano, contour = list(side = c("zmin", "z", "350")), 
       zlim = c(-100, 400), phi = 20, image = list(side = 350))

## =======================================================================
## Use of inttype
## =======================================================================

 par(mfrow = c(2, 2))
 persp3D(z = Volcano, shade = 0.5, colkey = FALSE)
 persp3D(z = Volcano, inttype = 2, shade = 0.5, colkey = FALSE)

 x &lt;- y &lt;- seq(0, 2*pi, length.out = 10)
 z &lt;- with (mesh(x, y), cos(x) *sin(y)) + runif(100)
 cv &lt;- matrix(nrow = 10, ncol = 10, 0.5*runif(100))
 persp3D(x, y, z, colvar = cv)              # takes averages of z
 persp3D(x, y, z, colvar = cv, inttype = 2) # takes averages of colvar

## =======================================================================
## Use of inttype with NAs
## =======================================================================

 par(mfrow = c(2, 2))
 VV &lt;- V2 &lt;- volcano[10:15, 10:15]
 V2[3:4, 3:4] &lt;- NA
 V2[4, 5] &lt;- NA

 image2D(V2, border = "black")  # shows true NA region

# averages of V2, including NAs, NA region larger
 persp3D(z = VV, colvar = V2, inttype = 1, theta = 0, 
       phi = 20, border = "black", main = "inttype = 1")

# extension of VV; NAs unaffected
 persp3D(z = VV, colvar = V2, inttype = 2, theta = 0, 
       phi = 20, border = "black", main = "inttype = 2")

# average of V2, ignoring NA; NA region smaller
 persp3D(z = VV, colvar = V2, inttype = 3, theta = 0, 
       phi = 20, border = "black", main = "inttype = 3")

## =======================================================================
## Use of panel.first
## =======================================================================

 par(mfrow = c(1, 1))

# A function that is called after the axes were drawn
 panelfirst &lt;- function(trans) {
    zticks &lt;- seq(100, 180, by = 20)
    len &lt;- length(zticks)
    XY0 &lt;- trans3D(x = rep(1, len), y = rep(1, len), z = zticks,
                   pmat = trans)
    XY1 &lt;- trans3D(x = rep(1, len), y = rep(61, len), z = zticks,
                   pmat = trans)
    segments(XY0$x, XY0$y, XY1$x, XY1$y, lty = 2) 
    
    rm &lt;- rowMeans(volcano)             
    XY &lt;- trans3D(x = 1:87, y = rep(ncol(volcano), 87), 
                  z = rm, pmat = trans)
    lines(XY, col = "blue", lwd = 2)
 }
 persp3D(z = volcano, x = 1:87, y = 1: 61, scale = FALSE, theta = 10,
       expand = 0.2, panel.first = panelfirst, colkey = FALSE)
                                                       
## =======================================================================
## with / without colvar / facets 
## =======================================================================

 par(mfrow = c(2, 2))
 persp3D(z = volcano, shade = 0.3, col = gg.col(100))

# shiny colors - set lphi for more brightness
 persp3D(z = volcano, lighting = TRUE, lphi = 90)

 persp3D(z = volcano, col = "lightblue", colvar = NULL, 
   shade = 0.3, bty = "b2")

# this also works:
#  persp3D(z = volcano, col = "grey", shade = 0.3)

# tilted x- and y-coordinates of 'volcano'
 volcx &lt;- matrix(nrow = 87, ncol = 61, data = rep(1:87, times=61))
 volcx &lt;- volcx + matrix(nrow = 87, ncol = 61, byrow = TRUE, 
        data = rep(seq(0., 15, length.out=61), times=87))

 volcy &lt;- matrix(ncol = 87, nrow = 61, data = rep(1:61, times=87))
 volcy &lt;- t(volcy + matrix(ncol = 87, nrow = 61, byrow = TRUE, 
        data = rep(seq(0., 15, length.out=87), times=61)))

 persp3D(volcano, x = volcx, y = volcy, phi = 80)
    
## =======================================================================
## Several persps on one plot
## =======================================================================

 par(mfrow = c(1, 1))
 clim &lt;- range(volcano)
 persp3D(z = volcano, zlim = c(100, 600), clim = clim, 
   box = FALSE, plot = FALSE)
  
 persp3D(z = volcano + 200, clim = clim, colvar = volcano, 
       add = TRUE, colkey = FALSE, plot = FALSE)

 persp3D(z = volcano + 400, clim = clim, colvar = volcano, 
       add = TRUE, colkey = FALSE)    # plot = TRUE by default

## =======================================================================
## hist3D
## =======================================================================

 par(mfrow = c(2, 2))
 VV   &lt;- volcano[seq(1, 87, 15), seq(1, 61, 15)]
 hist3D(z = VV, scale = FALSE, expand = 0.01, border = "black")

# transparent colors
 hist3D(z = VV, scale = FALSE, expand = 0.01, 
   alpha = 0.5, opaque.top = TRUE, border = "black")

 hist3D(z = VV, scale = FALSE, expand = 0.01, facets = FALSE, lwd = 2)

 hist3D(z = VV, scale = FALSE, expand = 0.01, facets = NA)

## =======================================================================
## hist3D and ribbon3D with greyish background, rotated, rescaled,...
## =======================================================================

 par(mfrow = c(2, 2))
 hist3D(z = VV, scale = FALSE, expand = 0.01, bty = "g", phi = 20,
        col = "#0072B2", border = "black", shade = 0.2, ltheta = 90,
        space = 0.3, ticktype = "detailed", d = 2)

# extending the ranges
 plotdev(xlim = c(-0.2, 1.2), ylim = c(-0.2, 1.2), theta = 45)

 ribbon3D(z = VV, scale = FALSE, expand = 0.01, bty = "g", phi = 20,
        col = "lightblue", border = "black", shade = 0.2, ltheta = 90,
        space = 0.3, ticktype = "detailed", d = 2, curtain = TRUE)

 ribbon3D(z = VV, scale = FALSE, expand = 0.01, bty = "g", phi = 20, zlim = c(95,183),
        col = "lightblue", lighting = TRUE, ltheta = 50, along = "y",
        space = 0.7, ticktype = "detailed", d = 2, curtain = TRUE)

## =======================================================================
## hist3D for a 1-D data set
## =======================================================================

 par(mfrow = c(2, 1))
 x &lt;- rchisq(1000, df = 4)
 hs &lt;- hist(x, breaks = 15)
 
 hist3D(x = hs$mids, y = 1, z = matrix(ncol = 1, data = hs$density), 
  bty = "g", ylim = c(0., 2.0), scale = FALSE, expand = 20, 
  border = "black", col = "white", shade = 0.3, space = 0.1, 
  theta = 20, phi = 20, main = "3-D perspective")

          
# reset plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='3-D+20surfaces'>
Functions for plotting 3 dimensional shapes
</h2><span id='topic+surf3D'></span><span id='topic+spheresurf3D'></span>

<h3>Description</h3>

<p><code>surf3D</code> plots a surface in 3-D with a color variable.
</p>
<p><code>spheresurf3D</code> plots a colored image on a sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf3D (x, y, z, ..., colvar = z, phi = 40, theta = 40,
        col = NULL, NAcol = "white", breaks = NULL,
        border = NA, facets = TRUE, colkey = NULL,
        panel.first = NULL, clim = NULL, clab = NULL, bty = "n",
        lighting = FALSE, shade = NA, ltheta = -135, lphi = 0,
        inttype = 1, add = FALSE, plot = TRUE)

spheresurf3D (colvar = matrix(nrow = 50, ncol = 50, data = 1:50, byrow = TRUE), 
        ..., phi = 0, theta = 0,
        col = NULL, NAcol = "white", breaks = NULL,
        border = NA, facets = TRUE, contour = FALSE,
        colkey = NULL, resfac = 1,
        panel.first = NULL, clim = NULL, clab = NULL, bty = "n", 
        lighting = FALSE, shade = NA, ltheta = -135, lphi = 0,
        inttype = 1, full = FALSE, add = FALSE, plot = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="3-D+2B20surfaces_+3A_x">x</code>, <code id="3-D+2B20surfaces_+3A_y">y</code>, <code id="3-D+2B20surfaces_+3A_z">z</code></td>
<td>
<p>Matrices with x, y and z-values that define the surfaces to
be colored. They should be of the same dimension
as <code>colvar</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. If a matrix, it should be of the same 
dimension as <code>x, y, z</code>.
Values of <code>NULL</code>, <code>NA</code>, or <code>FALSE</code>
will toggle off coloration according to <code>colvar</code>. This gives good results
only if <code>border</code> is given a color or a shade is used.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_theta">theta</code>, <code id="3-D+2B20surfaces_+3A_phi">phi</code></td>
<td>
<p>the angles defining the viewing direction. 
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. see <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_col">col</code></td>
<td>
<p>Color palette to be used for coloring the <code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<a href="#topic+jet.col">jet.col</a>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be &quot;grey&quot;. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_border">border</code></td>
<td>
<p>The color of the lines drawn around the surface facets.
The default, <code>NA</code>, will disable the drawing of borders.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_facets">facets</code></td>
<td>
<p>If <code>TRUE</code>, then <code>col</code> denotes the color of the surface facets. 
If <code>FALSE</code>, then the surface facets are colored &ldquo;white&rdquo; and the <code>border</code> 
(if <code>NA</code>) will be colored as specified by <code>col</code>. 
If <code>NA</code> then the facets will be transparent. 
It is usually faster to draw with <code>facets = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_contour">contour</code></td>
<td>
<p>If <code>TRUE</code>, then a <a href="graphics.html#topic+contour">contour</a> plot will be 
added to the image plot, unless <code>x, y</code> are a matrix. 
Also allowed is to pass a <code>list</code> with arguments for the 
<a href="graphics.html#topic+contour">contour</a> function. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters 
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_resfac">resfac</code></td>
<td>
<p>Resolution factor, one value or a vector of two numbers, for 
the x and y- values respectively. A value &gt; 1 will increase the 
resolution. For instance, if <code>resfac</code> equals <code>3</code> then for each 
adjacent pair of x- and y-values, z will be interpolated to two intermediary points. 
This uses simple linear interpolation. If <code>resfac</code> is one number then
the resolution will be increased similarly in x and y-direction.  
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_panel.first">panel.first</code></td>
<td>
<p>A <code>function</code> to be evaluated after the plot axes are 
set up but before any plotting takes place. 
This can be useful for drawing background grids or scatterplot smooths. 
The function should have as argument the transformation matrix, e.g. it should
be defined as <code>function(pmat)</code>. See example of <a href="#topic+persp3D">persp3D</a> and last example of <a href="#topic+voxel3D">voxel3D</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable, used
for the color key.  Values of <code>colvar</code> that extend the range will be put to <code>NA</code>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_bty">bty</code></td>
<td>
<p>The type of the box, the default is to draw no box.
Set <code>bty = "f"</code> or <code>bty = "b"</code> if you want a full box or the backpanel.
See <a href="#topic+perspbox">perspbox</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_lighting">lighting</code></td>
<td>
<p>If not <code>FALSE</code> the facets will be illuminated, and colors may
appear more bright. To switch on lighting, the argument <code>lighting</code> 
should be either set to <code>TRUE</code> (using default settings) or it can be a 
list with specifications of one of the following: 
<code>ambient, diffuse, specular, exponent, sr</code> and <code>alpha</code>. 
</p>
<p>Will overrule <code>shade</code> not equal to <code>NA</code>.
</p>
<p>See examples in <a href="#topic+jet.col">jet.col</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_shade">shade</code></td>
<td>
<p>the degree of shading of the surface facets. 
Values of shade close to one yield shading similar to a point light 
source model and values close to zero produce no shading. 
Values in the range 0.5 to 0.75 provide an approximation to daylight illumination.
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_ltheta">ltheta</code>, <code id="3-D+2B20surfaces_+3A_lphi">lphi</code></td>
<td>
<p>if finite values are specified for <code>ltheta</code> and 
<code>lphi</code>, the surface is shaded as though it was being illuminated from 
the direction specified by azimuth <code>ltheta</code> and colatitude <code>lphi</code>.
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20surfaces_+3A_inttype">inttype</code></td>
<td>
<p>The interpolation type to create the polygons, either 
taking the mean of the <code>colvar</code> variable (<code>inttype = 1, 3</code> or 
extending the <code>x, y, z</code> values (<code>inttype = 2</code>). 
Values <code>1, 3</code> differ in how they treat <code>NA</code>s in the <code>colvar</code> variable. 
For <code>inttype = 3</code>, <code>NA</code>s are removed before taking averages; 
this will tend to make the <code>NA</code> region smaller. 
<code>NA</code>s are included when <code>inttype = 1</code>. This will tend to make the <code>NA</code> region larger.
See details and an example in <a href="#topic+persp3D">persp3D</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_full">full</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the full sphere will be drawn, including the 
invisible part. If <code>FALSE</code> only the visible half will be drawn (faster). 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the surfaces will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise the viewing transformation matrix is returned (as invisible). 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20surfaces_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plotting methods. 
The following <a href="graphics.html#topic+persp">persp</a> arguments can be specified: 
<code>xlim, ylim, zlim, xlab, ylab, zlab, main, sub, r, d, 
    scale, expand, box, axes, nticks, ticktype</code>.      
The arguments <code>xlim</code>, <code>ylim</code>, <code>zlim</code> only affect the axes.
All objects will be plotted, including those that fall out of these ranges.
To select objects only within the axis limits, use <a href="#topic+plotdev">plotdev</a>.
</p>
<p>In addition, the <a href="#topic+perspbox">perspbox</a> arguments
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> can 
also be given a value.
The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>spheresurf3D</code> is a projection on a sphere with radius 1.
This means that the x- y- and z- axes range from [-1, 1].
</p>


<h3>Value</h3>

<p>Returns the viewing transformation matrix,
See <a href="#topic+trans3D">trans3D</a>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="graphics.html#topic+persp">persp</a> for the function on which this implementation is based.
</p>
<p><a href="#topic+jet.col">jet.col</a>, <a href="#topic+plotdev">plotdev</a> for other examples of <code>surf3D</code>.
</p>
<p><a href="#topic+plotdev">plotdev</a> for zooming, rescaling, rotating a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm   &lt;- par("mfrow")
 pmar &lt;- par("mar")

 par(mar = c(1, 1, 1, 1))

## =======================================================================
## A three-dimensional shape 
## (ala http://docs.enthought.com/mayavi/mayavi/mlab.html)
## =======================================================================

 par(mfrow = c(2, 2))
# create grid matrices
 X       &lt;- seq(0, pi, length.out = 50)
 Y       &lt;- seq(0, 2*pi, length.out = 50)
 M       &lt;- mesh(X, Y)
 phi     &lt;- M$x
 theta   &lt;- M$y

# x, y and z grids
 r &lt;- sin(4*phi)^3 + cos(2*phi)^3 + sin(6*theta)^2 + cos(6*theta)^4
 x &lt;- r * sin(phi) * cos(theta)
 y &lt;- r * cos(phi)
 z &lt;- r * sin(phi) * sin(theta)

# full colored image
 surf3D(x, y, z, colvar = y, colkey = FALSE, shade = 0.5,
        box = FALSE, theta = 60)

# same, but just facets
 surf3D(x, y, z, colvar = y, colkey = FALSE, box = FALSE, 
        theta = 60, facets = FALSE)

# with colors and border, AND increasing the size
# (by reducing the x- y and z- ranges
 surf3D(x, y, z, colvar = y, colkey = FALSE, box = FALSE, 
        theta = 60, border = "black", xlim = range(x)*0.8, 
        ylim = range(y)*0.8, zlim = range(z)*0.8)

# Now with one color and shading
 surf3D(x, y, z, box = FALSE,
        theta = 60, col = "lightblue", shade = 0.9)

## Not run:  # rotation
  for (angle in seq(0, 360, by = 10))
    plotdev(theta = angle)


## End(Not run)

## =======================================================================
## Several other shapes 
## http://xahlee.info/surface/gallery.html
## =======================================================================

 par(mfrow = c(2, 2)) 
 # Shape 1
 M  &lt;- mesh(seq(0,  6*pi, length.out = 50), 
            seq(pi/3, pi, length.out = 50))
 u  &lt;- M$x ; v &lt;- M$y

 x &lt;- u/2 * sin(v) * cos(u)
 y &lt;- u/2 * sin(v) * sin(u)
 z &lt;- u/2 * cos(v)

 surf3D(x, y, z, colvar = z, colkey = FALSE, box = FALSE, phi = 50)

# Shape 2: add border
 M  &lt;- mesh(seq(0, 2*pi, length.out = 50), 
            seq(0, 2*pi, length.out = 50))
 u  &lt;- M$x ; v  &lt;- M$y

 x  &lt;- sin(u)
 y  &lt;- sin(v)
 z  &lt;- sin(u + v)

 surf3D(x, y, z, colvar = z, border = "black", 
        colkey = FALSE)

# shape 3: uses same mesh, other perspective (d &gt;1)
 x &lt;- (3 + cos(v/2)*sin(u) - sin(v/2)*sin(2*u))*cos(v)
 y &lt;- (3 + cos(v/2)*sin(u) - sin(v/2)*sin(2*u))*sin(v)
 z &lt;- sin(v/2)*sin(u) + cos(v/2)*sin(2*u)

 surf3D(x, y, z, colvar = z, colkey = FALSE, d = 2, facets = FALSE)

# shape 4: more complex colvar
 M  &lt;- mesh(seq(-13.2, 13.2, length.out = 50), 
            seq(-37.4, 37.4, length.out = 50))
 u  &lt;- M$x   ; v &lt;- M$y

 b &lt;- 0.4; r &lt;- 1 - b^2; w &lt;- sqrt(r)
 D &lt;- b*((w*cosh(b*u))^2 + (b*sin(w*v))^2)
 x &lt;- -u + (2*r*cosh(b*u)*sinh(b*u)) / D
 y &lt;- (2*w*cosh(b*u)*(-(w*cos(v)*cos(w*v)) - sin(v)*sin(w*v))) / D
 z &lt;- (2*w*cosh(b*u)*(-(w*sin(v)*cos(w*v)) + cos(v)*sin(w*v))) / D

 surf3D(x, y, z, colvar = sqrt(x + 8.3), colkey = FALSE, 
        theta = 10, border = "black", box = FALSE)
 box()

## =======================================================================
## A sphere, with box type with grid lines
## =======================================================================

 par(mar = c(2, 2, 2, 2))
 par(mfrow = c(1, 1))
 M  &lt;- mesh(seq(0, 2*pi, length.out = 50), 
            seq(0,   pi, length.out = 50))
 u  &lt;- M$x ; v  &lt;- M$y

 x &lt;- cos(u)*sin(v)
 y &lt;- sin(u)*sin(v)
 z &lt;- cos(v)

 colvar &lt;- sin(u*6) * sin(v*6)

 surf3D(y, x, z, colvar = colvar, phi = 0, bty = "b2", 
        lighting = TRUE, ltheta = 40)

## =======================================================================
## Function spheresurf3D
## =======================================================================

 par(mfrow = c(2, 2))
 spheresurf3D()
 
# true ranges are [-1, 1]; set limits to [-0.8, 0.8] to make larger plots
 lim &lt;- c(-0.8, 0.8)
 spheresurf3D(colkey = FALSE, xlim = lim, ylim = lim, zlim = lim)

 spheresurf3D(bty = "b", ticktype = "detailed", phi = 50)
 spheresurf3D(colvar = matrix(nrow = 30, ncol = 30, data = runif(900)))
 
## =======================================================================
## Images on a sphere
## =======================================================================

 par(mfrow = c(1, 1), mar = c(1, 1, 1, 3))

 AA &lt;- Hypsometry$z; AA[AA&lt;=0] &lt;- NA
 
 lim &lt;- c(-0.8, 0.8)

# log transformation of color variable
 spheresurf3D(AA, NAcol = "black", theta = 90, phi = 30, box = FALSE,
   xlim = lim, ylim = lim, zlim = lim, log = "c")

# restore plotting parameters
 par(mfrow = pm)
 par(mar = pmar)
</code></pre>

<hr>
<h2 id='3-D+20volume+20visualisation'>
Functions for plotting 3-D volumetric data.
</h2><span id='topic+slice3D'></span><span id='topic+slicecont3D'></span><span id='topic+isosurf3D'></span><span id='topic+triangle3D'></span><span id='topic+voxel3D'></span><span id='topic+createisosurf'></span><span id='topic+createvoxel'></span>

<h3>Description</h3>

<p><code>slice3D</code> plots a 3-D dataset with a color variable as slices or on surfaces.
</p>
<p><code>slicecont3D</code> plots a 3-D dataset with a color variable as contours on slices.
</p>
<p><code>isosurf3D</code> plots isosurfaces from a 3-D dataset.
</p>
<p><code>voxel3D</code> plots isosurfaces as scatterpoints.
</p>
<p><code>createisosurf</code> create the isosurfaces (triangulations)
from volumetric data. Its output can be plotted with <code>triangle3D</code>.
</p>
<p><code>createvoxel</code> creates voxels (x, y, z) points from volumetric data. 
Its output can be plotted with <a href="#topic+scatter3D">scatter3D</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice3D (x, y, z, colvar, ..., phi = 40, theta = 40,
         xs = min(x), ys = max(y), zs = min(z),
         col = NULL, NAcol = "white", breaks = NULL,
         border = NA, facets = TRUE, colkey = NULL, 
         panel.first = NULL, clim = NULL, 
         clab = NULL, bty = "b", 
         lighting = FALSE, shade = NA, ltheta = -135, lphi = 0,  
         add = FALSE, plot = TRUE) 

slicecont3D (x, y, z, colvar, ..., phi = 40, theta = 40,
         xs = NULL, ys = NULL, zs = NULL, level = NULL,
         col = NULL, NAcol = "white", breaks = NULL,
         border = NA, facets = TRUE, 
         colkey = NULL, panel.first = NULL,
         clim = NULL, clab = NULL, bty = "b", 
         dDepth = 0, add = FALSE, plot = TRUE) 

isosurf3D (x, y, z, colvar, ..., phi = 40, theta = 40, 
         level = mean(colvar, na.rm = TRUE), isofunc = createisosurf,
         col = NULL, border = NA, facets = TRUE, 
         colkey = NULL, panel.first = NULL, 
         clab = NULL, bty = "b", 
         lighting = FALSE, shade = 0.5, ltheta = -135, lphi = 0, 
         add = FALSE, plot = TRUE) 

voxel3D (x, y, z, colvar, ..., phi = 40, theta = 40, 
         level = mean(colvar, na.rm = TRUE), eps = 0.01, operator = "=", 
         col = NULL, NAcol = "white", breaks = NULL, colkey = FALSE,
         panel.first = NULL, bty = "b", add = FALSE, plot = TRUE)

triangle3D (tri, colvar = NULL, ..., phi = 40, theta = 40,
           col = NULL, NAcol = "white", breaks = NULL,
           border = NA, facets = TRUE,
           colkey = NULL, panel.first = NULL,
           lighting = FALSE, shade = 0.5, ltheta = -135, lphi = 0, 
           clim = NULL, clab = NULL,
           bty = "b", add = FALSE, plot = TRUE)  

createisosurf (x, y, z, colvar, level = mean(colvar, na.rm = TRUE))

createvoxel (x, y, z, colvar, level = mean(colvar, na.rm = TRUE), eps = 0.01,
             operator = "=")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_x">x</code>, <code id="3-D+2B20volume+2B20visualisation_+3A_y">y</code>, <code id="3-D+2B20volume+2B20visualisation_+3A_z">z</code></td>
<td>
<p>Vectors with x, y and z-values. 
They should be of length equal to the first, second and 
third dimension of <code>colvar</code> respectively.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. 
It should be an array of dimension equal to 
<code>c(length(x), length(y), length(z))</code>.
For <code>triangle3D</code>, <code>colvar</code> should be of length = nrow(<code>tri</code>) / 3.
It must be present.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_tri">tri</code></td>
<td>
<p>A three-columned matrix (x, y, z) with triangle coordinates. 
A triangle is defined by three consecutive rows.
</p>
</td></tr>  
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_isofunc">isofunc</code></td>
<td>
<p>A function defined as <code>function(x, y, z, colvar, level)</code>,
and that returns the three-columned matrix with triangle coordinates.
The default, <code>createisosurf</code> uses function <a href="misc3d.html#topic+computeContour3d">computeContour3d</a> 
from package <code>misc3d</code>. 
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_theta">theta</code>, <code id="3-D+2B20volume+2B20visualisation_+3A_phi">phi</code></td>
<td>
<p>the angles defining the viewing direction. 
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. see <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_col">col</code></td>
<td>
<p>Colors to be used for coloring the <code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> 
then a red-yellow-blue colorscheme (<a href="#topic+jet.col">jet.col</a>) will be used.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_border">border</code></td>
<td>
<p>The color of the lines drawn around the surface facets.
The default, <code>NA</code>, will disable the drawing of borders.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_facets">facets</code></td>
<td>
<p>If <code>TRUE</code>, then <code>col</code> denotes the color of the surface facets. 
If <code>FALSE</code>, then the surface facets are colored &ldquo;white&rdquo; and the <code>border</code> 
(if <code>NA</code>) will be colored as specified by <code>col</code>. 
If <code>NA</code> then the facets will be transparent. 
It is usually faster to draw with <code>facets = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters 
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_panel.first">panel.first</code></td>
<td>
<p>A <code>function</code> to be evaluated after the plot axes are 
set up but before any plotting takes place. 
This can be useful for drawing background grids or scatterplot smooths. 
The function should have as argument the transformation matrix, e.g. it should
be defined as <code>function(pmat)</code>. See last example and example of <a href="#topic+persp3D">persp3D</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable, used
for the color key. Values of <code>colvar</code> that extend the range will be put to <code>NA</code>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_xs">xs</code>, <code id="3-D+2B20volume+2B20visualisation_+3A_ys">ys</code>, <code id="3-D+2B20volume+2B20visualisation_+3A_zs">zs</code></td>
<td>
<p>Vectors or matrices.
Vectors specify the positions in x, y or z where the slices (planes) are to be drawn.
The values of <code>colvar</code> will be projected on these slices.
Matrices specify a surface on which the <code>colvar</code> will be projected.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_level">level</code></td>
<td>
<p>The level(s) at which the <code>contour</code> will be generated or the
isosurfaces generated. 
</p>
<p>There can be more than one level, but for <code>slicecont3D</code> too many 
will give a crowded view, and one is often best.
For <code>isosurf3D</code>, the use of multiple values may need transparent colors to visualise.
For <code>voxel3D</code>, <code>level</code> should either be one number (if <code>operator</code>
equals <code>'=', '&lt;', '&gt;'</code>) or two numbers (for <code>operator = '&lt;&gt;'</code>).
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_lighting">lighting</code></td>
<td>
<p>If not <code>FALSE</code> the facets will be illuminated, and colors may
appear more bright. To switch on lighting, the argument <code>lighting</code> 
should be either set to <code>TRUE</code> (using default settings) or it can be a 
list with specifications of one of the following: 
<code>ambient, diffuse, specular, exponent, sr</code> and <code>alpha</code>. 
</p>
<p>Will overrule <code>shade</code> not equal to <code>NA</code>.
</p>
<p>See examples in <a href="#topic+jet.col">jet.col</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_shade">shade</code></td>
<td>
<p>the degree of shading of the surface facets. 
Values of shade close to one yield shading similar to a point light 
source model and values close to zero produce no shading. 
Values in the range 0.5 to 0.75 provide an approximation to daylight illumination.
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_ltheta">ltheta</code>, <code id="3-D+2B20volume+2B20visualisation_+3A_lphi">lphi</code></td>
<td>
<p>if finite values are specified for <code>ltheta</code> and 
<code>lphi</code>, the surface is shaded as though it was being illuminated from 
the direction specified by azimuth <code>ltheta</code> and colatitude <code>lphi</code>.
See <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>  
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_bty">bty</code></td>
<td>
<p>The type of the box, the default only draws background panels.
Only effective if the <a href="graphics.html#topic+persp">persp</a> 
argument (<code>box</code>) equals <code>TRUE</code> (this is the default). See <a href="#topic+perspbox">perspbox</a>.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_eps">eps</code></td>
<td>
<p>The voxel precision, only used when <code>operator = "="</code>.
A point is selected if it closer than <code>eps*diff(range(colvar))</code> 
to the required level.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_operator">operator</code></td>
<td>
<p>One of '=', '&lt;', '&gt;', '&lt;&gt;' for selection of points &lsquo;equal&rsquo; (within
precision), larger or smaller than the required level or to be within an 
interval.
</p>
</td></tr>
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_ddepth">dDepth</code></td>
<td>
<p>When a contour is added on an image, the image polygons may
hide some contour segments. To avoid that, the viewing depth of the segments
can be artificially decreased with the factor <code>dDepth</code> times the 
<a href="graphics.html#topic+persp">persp</a> argument <code>expand</code> (usually = 1), to make them 
appear in front of the polygons. 
Too large values of <code>dDepth</code> may create visible artifacts.
See <a href="#topic+contour3D">contour3D</a>.
</p>
</td></tr>   
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the slices, voxels or surfaces will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise the viewing transformation matrix is returned (as invisible). 
</p>
</td></tr> 
<tr><td><code id="3-D+2B20volume+2B20visualisation_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting methods. 
</p>
<p>The following <a href="graphics.html#topic+persp">persp</a> arguments can be specified: 
<code>xlim, ylim, zlim, xlab, ylab, zlab, main, sub, r, d, 
    scale, expand, box, axes, nticks, ticktype</code>.      
The arguments <code>xlim</code>, <code>ylim</code>, <code>zlim</code> only affect the axes.
All objects will be plotted, including those that fall out of these ranges.
To select objects only within the axis limits, use <a href="#topic+plotdev">plotdev</a>.
</p>
<p>In addition, the <a href="#topic+perspbox">perspbox</a> arguments
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> can 
also be given a value.
</p>
<p><code>alpha</code> can be given a value inbetween 0 and 1 to make colors transparent.
</p>
<p>For all functions, the arguments <code>lty, lwd</code> can be specified.
</p>
<p>The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plotting functions return the viewing transformation matrix,
See <a href="#topic+trans3D">trans3D</a>.
</p>
<p>Function <code>createisosurf</code> returns a three-columned matrix (x, y, z) with 
triangle coordinates. One triangle is defined by three consecutive rows.
It can be plotted with <code>triangle3D</code>.
</p>
<p>Function <code>createvoxel</code> returns a list with the elements <code>x, y, z</code> 
defining the points that are at a distance of less than 
<code>eps*diff(range(colvar))</code> from the required <code>level</code>.
Its output can be plotted with <a href="#topic+scatter3D">scatter3D</a>.
</p>


<h3>Note</h3>

<p>The <code>isosurf3D</code> function uses function  <code>computeContour3d</code>, 
from package <code>misc3d</code>, which is based on the marching cubes algorithm.
Please cite the package <code>misc3d</code> (Feng &amp; Tierney, 2008) when using <code>isosurf3D</code>.
</p>
<p>For <code>voxel3D</code>, coloring is always according to the z-variable. A more flexible
coloration can be achieved by using <code>createvoxel</code>, followed by <a href="#topic+scatter3D">scatter3D</a>.
See examples.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>Lorensen, W.E. and Cline, H.E.,
Marching Cubes: a high resolution 3D surface reconstruction algorithm,
Computer Graphics, Vol. 21, No. 4, pp 163-169 (Proc. of SIGGRAPH), 1987.
</p>
<p>Dai Feng, Luke Tierney, Computing and Displaying Isosurfaces in R, 
Journal of Statistical Software 28(1), 2008.
URL <a href="https://www.jstatsoft.org/v28/i01/">https://www.jstatsoft.org/v28/i01/</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+Oxsat">Oxsat</a> for another example of <code>slice3D</code>.
</p>
<p><a href="#topic+plotdev">plotdev</a> for zooming, rescaling, rotating a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")
 pmar &lt;- par("mar")

## =======================================================================
## Simple slice3D examples
## =======================================================================

 par(mfrow = c(2, 2))
 x &lt;- y &lt;- z &lt;- seq(-1, 1, by = 0.1)
 grid   &lt;- mesh(x, y, z)
 colvar &lt;- with(grid, x*exp(-x^2 - y^2 - z^2))

# default is just the panels
 slice3D  (x, y, z, colvar = colvar, theta = 60)

# contour slices
 slicecont3D (x, y, z, ys = seq(-1, 1, by = 0.5), colvar = colvar, 
           theta = 60, border = "black")
          
 slice3D  (x, y, z, xs = c(-1, -0.5, 0.5), ys = c(-1, 0, 1), 
           zs = c(-1, 0), colvar = colvar, 
           theta = 60, phi = 40)

## =======================================================================
## coloring on a surface
## =======================================================================

 XY &lt;- mesh(x, y)
 ZZ &lt;- XY$x*XY$y
 slice3D  (x, y, z, xs = XY$x, ys = XY$y, zs = ZZ, colvar = colvar, 
           lighting =  TRUE, lphi = 90, ltheta = 0)

## =======================================================================
## Specifying transparent colors
## =======================================================================

 par(mfrow = c(1, 1))
 x &lt;- y &lt;- z &lt;- seq(-4, 4, by = 0.2)
 M &lt;- mesh(x, y, z)

 R &lt;- with (M, sqrt(x^2 + y^2 + z^2))
 p &lt;- sin(2*R) /(R+1e-3)

## Not run: 
# This is very slow - alpha = 0.5 makes it transparent

 slice3D(x, y, z, colvar = p, col = jet.col(alpha = 0.5), 
         xs = 0, ys = c(-4, 0, 4), zs = NULL, d = 2) 

## End(Not run)

 slice3D(x, y, z, colvar = p, d = 2, theta = 60, border = "black",
         xs = c(-4, 0), ys = c(-4, 0, 4), zs = c(-4, 0))

## =======================================================================
## A section along a transect
## =======================================================================

 data(Oxsat)
 Ox &lt;- Oxsat$val[,  Oxsat$lat &gt; - 5 &amp; Oxsat$lat &lt; 5, ]
 slice3D(x = Oxsat$lon, z = -Oxsat$depth, y = 1:5, colvar = Ox, 
         ys = 1:5, zs = NULL, NAcol = "black", 
         expand = 0.4, theta = 45, phi = 45)

## =======================================================================
## isosurf3D example - rather slow
## =======================================================================

 par(mfrow = c(2, 2), mar  = c(2, 2, 2, 2))
 x &lt;- y &lt;- z &lt;- seq(-2, 2, length.out = 15)
 xyz &lt;- mesh(x, y, z)
 F &lt;- with(xyz, log(x^2 + y^2 + z^2 + 
                10*(x^2 + y^2) * (y^2 + z^2) ^2))

# use shading for level = 1 - show triangulation with border
 isosurf3D(x, y, z, F, level = 1, shade = 0.9, 
           col = "yellow", border = "orange")

# lighting for level - 2
 isosurf3D(x, y, z, F, level = 2, lighting = TRUE,
           lphi = 0, ltheta = 0, col = "blue", shade = NA)  
 
# three levels, transparency added
 isosurf3D(x, y, z, F, level = seq(0, 4, by = 2), 
   col = c("red", "blue", "yellow"), 
   clab = "F", alpha = 0.2, theta = 0, lighting = TRUE)  

# transparency can also be added afterwards with plotdev()
## Not run: 
 isosurf3D(x, y, z, F, level = seq(0, 4, by = 2), 
   col = c("red", "blue", "yellow"), 
   shade = NA, plot = FALSE, clab = "F")  
 plotdev(lighting = TRUE, alpha = 0.2, theta = 0)

## End(Not run)
# use of creatisosurf
 iso &lt;- createisosurf(x, y, z, F, level = 2)
 head(iso)
 triangle3D(iso, col = "green", shade = 0.3)

## Not run: 
 # higher resolution
  x &lt;- y &lt;- z &lt;- seq(-2, 2, length.out = 50)
  xyz &lt;- mesh(x, y, z)
  F &lt;- with(xyz, log(x^2 + y^2 + z^2 + 
                10*(x^2 + y^2) * (y^2 + z^2) ^2))

# three levels
  isosurf3D(x, y, z, F, level = seq(0, 4, by = 2), 
    col = c("red", "blue", "yellow"), 
    shade = NA, plot = FALSE, clab = "F")  
  plotdev(lighting = TRUE, alpha = 0.2, theta = 0)

## End(Not run)

## =======================================================================
## voxel3D example
## =======================================================================

 par(mfrow = c(2, 2), mar  = c(2, 2, 2, 2))

# fast but needs high resolution grid
 x &lt;- y &lt;- z &lt;- seq(-2, 2, length.out = 70)
 xyz &lt;- mesh(x, y, z)
 F &lt;- with(xyz, log(x^2 + y^2 + z^2 + 
                10*(x^2 + y^2) * (y^2 + z^2) ^2))

 voxel3D(x, y, z, F, level = 4, pch = ".", cex = 5)

## =======================================================================
## rotation 
## =======================================================================

 plotdev(theta = 45, phi = 0)
 plotdev(theta = 90, phi = 10)

# same using createvoxel -  more flexible for coloring
 vox &lt;- createvoxel(x, y, z, F, level = 4)
 scatter3D(vox$x, vox$y, vox$z, colvar = vox$y, 
   bty = "g", colkey = FALSE)


## =======================================================================
## voxel3D to show hypox sites
## =======================================================================

 par(mfrow = c(1, 1), mar = c(2, 2, 2, 2))
 Hypox &lt;- createvoxel(Oxsat$lon, Oxsat$lat, Oxsat$depth[1:19], 
                      Oxsat$val[,,1:19], level = 40, operator = "&lt;")

 panel &lt;- function(pmat) {  # an image at the bottom
   Nx &lt;- length(Oxsat$lon)
   Ny &lt;- length(Oxsat$lat)
   M &lt;- mesh(Oxsat$lon, Oxsat$lat) 
   xy &lt;- trans3D(pmat = pmat, x = as.vector(M$x), y = as.vector(M$y), 
        z = rep(-1000, length.out = Nx*Ny)) 
   x &lt;- matrix(nrow = Nx, ncol = Ny, data = xy$x)
   y &lt;- matrix(nrow = Nx, ncol = Ny, data = xy$y)
   Bat &lt;- Oxsat$val[,,1]; Bat[!is.na(Bat)] &lt;- 1
   image2D(x = x, y = y, z = Bat, NAcol = "black", col = "grey",
         add = TRUE, colkey = FALSE)
 }
   
 scatter3D(Hypox$x, Hypox$y, -Hypox$z, colvar = Hypox$cv, 
           panel.first = panel, pch = ".", bty = "b", 
           theta = 30, phi = 20, ticktype = "detailed",
           zlim = c(-1000,0), xlim = range(Oxsat$lon), 
           ylim = range(Oxsat$lat) )
           
# restore plotting parameters
 par(mfrow = pm)
 par(mar = pmar)
</code></pre>

<hr>
<h2 id='Color+20key+20legend'>
Plots a color legend
</h2><span id='topic+colkey'></span>

<h3>Description</h3>

<p><code>colkey</code> plots a color legend, either to an existing plot or starting
a new plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colkey (col = NULL, clim, clab = NULL, clog = FALSE, add = FALSE, 
        cex.clab = NULL, col.clab = NULL, side.clab = NULL, 
        line.clab = NULL, adj.clab = NULL, font.clab = NULL,
        side = 4, length = 1, width = 1, dist = 0, shift = 0,
        addlines = FALSE, breaks = NULL, at = NULL, labels = TRUE, tick = TRUE,
        line = NA, pos = NA, outer = FALSE, font = NA, lty = 1, lwd = 1, 
        lwd.ticks = 1, col.axis = NULL, col.ticks = NULL, col.box = NULL,
        hadj = NA, padj = NA, cex.axis = par("cex.axis"),
        mgp = NULL, tck = NULL, tcl = NULL, las = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Color+2B20key+2B20legend_+3A_col">col</code></td>
<td>
<p>Colors to be used for the color key.
If <code>col</code> is <code>NULL</code>, 
then a red-yellow-blue colorscheme (<code>jet.col</code>) will be used.
</p>
</td></tr>
<tr><td><code id="Color+2B20key+2B20legend_+3A_clim">clim</code></td>
<td>
<p>The range of the color values, used in the color key. 
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_clab">clab</code></td>
<td>
<p>The label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, either <code>clab</code> can be made a vector, with the first values empty 
strings. Alternatively, it can be lowered by argument <code>line.clab</code>.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_clog">clog</code></td>
<td>
<p>If <code>TRUE</code>, then values of the color key will be log transformed.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, the color key will be added to the current plot and
positioned in the margin. If <code>FALSE</code> a new plot will be started and the color
key will be positioned in the centre.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_cex.clab">cex.clab</code></td>
<td>
<p>The size of the label 
written on top of the color key; default = same as axis labels. 
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_col.clab">col.clab</code></td>
<td>
<p>The color of the label 
written on top of the color key; default = same as main title. 
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_side.clab">side.clab</code></td>
<td>
<p>The side of the label 
written on top of the color key; default = same as main title, i.e. side = 3. 
Values of 1, 2, 4 will put the colorkey label at bottom, left and right of the key respectively.     
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_line.clab">line.clab</code></td>
<td>
<p>The numer of lines in the margin where the colorkey title is to be drawn.
If unspecified, it is at line.clab =1.75.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_adj.clab">adj.clab</code></td>
<td>
<p>The adjustment of the colorkey title, 
a number inbetween 0 (left) to 1 (right). The default is to put it central. 
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_font.clab">font.clab</code></td>
<td>
<p>The font of the colorkey title, 
a number inbetween 0 (left) to 1 (right). The default is to put it central. 
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_side">side</code></td>
<td>
<p>Where to put the color key. 1 = bottom, 2 = left, 3 = top, 4 = right.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_length">length</code></td>
<td>
<p>Relative length of the color key; 1 = same length as the axis.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_width">width</code></td>
<td>
<p>Relative width of the color key.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_dist">dist</code></td>
<td>
<p>Distance of the color key to the margin. 
Positive values are further into the margin, negative values cause the color key
to be positioned closer to or within the main plot. Reasonable range is [-0.5, 0.05].
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_shift">shift</code></td>
<td>
<p>Shift relative to the centre. 
Positive values are upward when side = 2 or 4, and to the right for side = 1 or 3.
It does not make sense to use this argument if <code>length = 1</code>. 
Reasonable range is [-0.2, 0.2].
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_addlines">addlines</code></td>
<td>
<p>If <code>TRUE</code>, will draw lines inbetween the colors.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="Color+2B20key+2B20legend_+3A_at">at</code>, <code id="Color+2B20key+2B20legend_+3A_labels">labels</code>, <code id="Color+2B20key+2B20legend_+3A_tick">tick</code>, <code id="Color+2B20key+2B20legend_+3A_line">line</code>, <code id="Color+2B20key+2B20legend_+3A_pos">pos</code>, <code id="Color+2B20key+2B20legend_+3A_outer">outer</code>, <code id="Color+2B20key+2B20legend_+3A_font">font</code>, <code id="Color+2B20key+2B20legend_+3A_lty">lty</code>, <code id="Color+2B20key+2B20legend_+3A_lwd">lwd</code></td>
<td>
<p>Additional parameters
as from the <a href="graphics.html#topic+axis">axis</a> command.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_lwd.ticks">lwd.ticks</code>, <code id="Color+2B20key+2B20legend_+3A_hadj">hadj</code>, <code id="Color+2B20key+2B20legend_+3A_padj">padj</code>, <code id="Color+2B20key+2B20legend_+3A_cex.axis">cex.axis</code>, <code id="Color+2B20key+2B20legend_+3A_mgp">mgp</code>, <code id="Color+2B20key+2B20legend_+3A_tck">tck</code>, <code id="Color+2B20key+2B20legend_+3A_tcl">tcl</code>, <code id="Color+2B20key+2B20legend_+3A_las">las</code></td>
<td>
<p>Additional parameters 
as from the <a href="graphics.html#topic+axis">axis</a> command.
</p>
</td></tr> 
<tr><td><code id="Color+2B20key+2B20legend_+3A_col.box">col.box</code>, <code id="Color+2B20key+2B20legend_+3A_col.axis">col.axis</code>, <code id="Color+2B20key+2B20legend_+3A_col.ticks">col.ticks</code></td>
<td>
<p>Additional parameters 
to set the color of the color legend framing <code>box</code>, 
the axis label and the axis ticks.
</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par(mfrow = c(2, 2))
 pmar &lt;- par(mar = c(5.1, 4.1, 4.1, 2.1))

## =======================================================================
##  colorkey as argument of a plot3D function
## =======================================================================
# default, colkey = NULL: adds colkey because multiple colors
 image2D(z = volcano)  

# default, colkey = NULL: no colkey because only one color
 image2D(z = volcano, col = "grey", shade = 0.2, contour = TRUE)  

# colkey = FALSE: no color key, no extra space foreseen
 image2D(z = volcano, colkey = FALSE)
 
# colkey = list(plot = FALSE): no color key, extra space foreseen
 image2D(z = volcano, colkey = list(plot = FALSE, side = 3))
 colkey (side = 3, add = TRUE, clim = range(volcano))
 
 
## =======================================================================
##  colorkey in new plot
## =======================================================================
 
 colkey(side = 1, clim = c(0, 1), add = FALSE, clab = "z", 
   col.clab = "red", adj.clab = 0)
 colkey(side = 2, clim = c(0, 1), clab = "z", length = 0.5, width = 0.5)
 colkey(side = 3, clim = c(0, 1), lwd = 3, clab = c("a","b","c","d"), 
   line.clab = 5)
 colkey(side = 4, clim = c(1e-6, 1), clog = TRUE, 
   clab = "a very long title in bold and close to the key", 
   line.clab = 1, side.clab = 2, font.clab = 2)

## =======================================================================
##  colorkey added to existing plot
## =======================================================================

 par(mfrow = c(1, 1))

 image2D(volcano, xlab = "", clab = "m", 
       colkey = list(side = 1, length = 0.5, width = 0.5, 
         line.clab = 1))
 colkey(side = 3, clim = range(volcano), add = TRUE)

# 'dist' to put colkey within the image 
# 'shift' to position colkey to the right or upward
 par(mfrow = c(1, 1))
 image2D(volcano, colkey = FALSE)

 colkey(clim = range(volcano), dist = -0.15, shift = 0.2,
        side = 3, add = TRUE, clab = "key 1", col.clab = "white",
        length = 0.5, width = 0.5, col.axis = "white", 
        col.ticks = "white", cex.axis = 0.8)

 colkey(clim = range(volcano), dist = -0.1, shift = -0.2,
        side = 4, add = TRUE, clab = "key 2", col.clab = "white",
        length = 0.3, width = 0.5, col.axis = "white", 
        col.ticks = "white", col.box = "red", cex.axis = 0.8)

 colkey(clim = range(volcano), dist = -0.3, 
        side = 1, add = TRUE, clab = "key 3", col.clab = "white",
        length = 0.3, width = 0.5, col.axis = "white", 
        col.ticks = "white", at  = c(100, 140, 180), 
        labels = c("a", "b", "c"), font = 2)

 colkey(clim = range(volcano), dist = -0.3, shift = -0.2,
        side = 2, add = TRUE, clab = "key 4", col.clab = "white",
        length = 0.3, width = 0.5, col.axis = "white", 
        col.ticks = "white", col.box = "red", cex.axis = 0.8,
        las = 3)

## =======================================================================
##  colorkey in other plots
## =======================================================================

 par(mfrow = c(1, 1))
 par(mar = par("mar") + c(0, 0, -2, 0))
 image2D(volcano, clab = "height, m", 
       colkey = list(dist = -0.15, shift = 0.2,
       side = 3, length = 0.5, width = 0.5, line.clab = 2.5,
       cex.clab = 2, col.clab = "white", col.axis = "white", 
       col.ticks = "white", cex.axis = 0.8))

## =======================================================================
## Several color keys in composite plot
## =======================================================================

 persp3D(z = volcano, zlim = c(-60, 200), phi = 20, bty = "b",   
    colkey = list(length = 0.2, width = 0.4, shift = 0.15,
      cex.axis = 0.8, cex.clab = 0.85), lighting = TRUE, lphi = 90,
    clab = c("height","m"), plot = FALSE)

# create gradient in x-direction
 Vx &lt;- volcano[-1, ] - volcano[-nrow(volcano), ]

# add as image with own color key, at bottom 
 image3D(z = -60, colvar = Vx/10, add = TRUE, 
    colkey = list(length = 0.2, width = 0.4, shift = -0.15,
      cex.axis = 0.8, cex.clab = 0.85),
   clab = c("gradient","m/m"), plot = TRUE)

## =======================================================================
## categorical colors; use addlines = TRUE to separate colors
## =======================================================================

 with(iris, scatter3D(x = Sepal.Length, y = Sepal.Width, 
   z = Petal.Length, colvar = as.integer(Species), 
   col = c("orange", "green", "lightblue"), pch = 16, cex = 2,  
   clim = c(1, 3), ticktype = "detailed", phi = 20,
   xlab = "Sepal Length", ylab = "Sepal Width", 
   zlab = "Petal Length",  main = "iris",
   colkey = list(at = c(1.33, 2, 2.66), side = 1, 
   addlines = TRUE, length = 0.5, width = 0.5,
   labels = c("setosa", "versicolor", "virginica") )))

# reset plotting parameters
 par(mfrow = pm)
 par(mar = pmar)
</code></pre>

<hr>
<h2 id='Colors'>
Colors, shading, lighting.
</h2><span id='topic+jet.col'></span><span id='topic+jet2.col'></span><span id='topic+gg.col'></span><span id='topic+gg2.col'></span><span id='topic+ramp.col'></span><span id='topic+alpha.col'></span>

<h3>Description</h3>

<p><code>jet.col</code> generates the matlab-type colors.
</p>
<p><code>jet2.col</code> is similar but lacks the deep blue colors
</p>
<p><code>gg.col</code> and <code>gg2.col</code> generate gg-plot-like colors.
</p>
<p><code>ramp.col</code> creates color schemes by interpolation. 
</p>
<p><code>alpha.col</code> creates transparent colors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jet.col (n = 100, alpha = 1)

jet2.col (n = 100, alpha = 1)

gg.col (n = 100, alpha = 1)

gg2.col (n = 100, alpha = 1)

ramp.col (col = c("grey", "black"), n = 100, alpha = 1)

alpha.col (col = "grey", alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Colors_+3A_n">n</code></td>
<td>
<p>Number of colors to generate.
</p>
</td></tr>
<tr><td><code id="Colors_+3A_alpha">alpha</code></td>
<td>
<p>Value in the range [0, 1] for alpha 
transparency channel (0 means transparent and 1 means opaque).
Transparency defined in the color palette is overruled when 
<code>lighting</code> or <code>shading</code> is switched on. 
To combine transparency with lighting or shading, pass argument <code>alpha</code> 
to the plotting functions directly.
</p>
</td></tr>
<tr><td><code id="Colors_+3A_col">col</code></td>
<td>
<p>Colors to interpolate, change.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the color functions described here, colors 
can also be adapted by shading and lighting, or made transparent. 
Shading will be overruled if lighting is not <code>FALSE</code>.
</p>
<p>To make colors transparent, use argument <code>alpha</code>, with a value inbetween 0 and 1.
</p>
<p>To switch on shading, the argument <code>shade</code> should be given a value inbetween 0 and 1.
</p>
<p>To switch on lighting, the argument <code>lighting</code> should be either set to <code>TRUE</code>
(in which case default settings will be used) or should be a list with specifications of 
one of the following: <code>ambient, diffuse, specular, exponent, sr</code> and <code>alpha</code>.
</p>
<p>The defaults are:
<code>ambient = 0.3, diffuse = 0.6, specular = 1., exponent = 20, sr = 0, alpha = 1</code>
</p>
<p>Lighting is defined as the sum of ambient, diffuse and specular light.
If <code>N</code> is the normal vector on the facets (3-values, x-, y-, z direction) 
and <code>I</code> is the light vector, then 
<code>col = (ambient + Id + sr * Is) * col + (1 - sr) * Is</code>, where
<code>Is = specular * abs(Light) ^ exponent</code>, <code>Id = diffuse * Light</code> and 
<code>Light = sum(N*I)</code>.
</p>
<p>The lighting algorithm is very simple, i.e. it is flat shading, no interpolation.
</p>
<p>Toggling on lighting or shading also requires the input of the angles of the 
light source, as <code>ltheta</code> and <code>lphi</code>, whose defaults are: 
<code>ltheta = -135, lphi = 0</code>. This usually works well for shading, but may
not be optimal for lighting.
</p>


<h3>Value</h3>

<p>A list with colors.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>The gg-plot type of colors <code>gg.plot</code> is a color-blind friendly palette from 
<code>http://wiki.stdout.org/rcookbook/Graphs</code>.
</p>


<h3>See Also</h3>

<p><a href="grDevices.html#topic+colorRamp">colorRamp</a> and <a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a> for comparable (and more elaborate) 
R-functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")
 pmar &lt;- par("mar")

## =======================================================================
## Transparency and various color schemes
## =======================================================================

 par(mfrow = c(3, 3))
 for (alph in c(0.25, 0.75))
   image2D(volcano, alpha = alph, 
         main = paste("jet.col, alpha = ", alph))  
 image2D(volcano, main = "jet.col")
 image2D(volcano, col = jet2.col(100), main = "jet2.col")
 image2D(volcano, col = gg.col(100), main = "gg.col")
 image2D(volcano, col = gg2.col(100), main = "gg2.col")
 image2D(volcano, col = rainbow(100), main = "rainbow")
 image2D(volcano, col = terrain.colors(100), main = "terrain.colors")
 image2D(volcano, col = ramp.col(c("blue", "yellow", "green", "red")),
       main = "ramp.col")  

## =======================================================================
## Shading, lighting -  one color
## =======================================================================

# create grid matrices
 X      &lt;- seq(0, pi, length.out = 50)
 Y      &lt;- seq(0, 2*pi, length.out = 50)
 M      &lt;- mesh(X, Y)
 phi    &lt;- M$x
 theta  &lt;- M$y

# x, y and z grids
 x &lt;- sin(phi) * cos(theta)
 y &lt;- cos(phi)
 z &lt;- sin(phi) * sin(theta)

# these are the defaults
 p &lt;- list(ambient = 0.3, diffuse = 0.6, specular = 1.,
           exponent = 20, sr = 0, alpha = 1)

 par(mfrow = c(3, 3), mar = c(0, 0, 0, 0))
 Col &lt;- "red"

 surf3D(x, y, z, box = FALSE, col = Col, shade = 0.9)
 surf3D(x, y, z, box = FALSE, col = Col, lighting = TRUE)  
 surf3D(x, y, z, box = FALSE, col = Col, lighting = list(ambient = 0))
 surf3D(x, y, z, box = FALSE, col = Col, lighting = list(diffuse = 0))
 surf3D(x, y, z, box = FALSE, col = Col, lighting = list(diffuse = 1))
 surf3D(x, y, z, box = FALSE, col = Col, lighting = list(specular = 0))
 surf3D(x, y, z, box = FALSE, col = Col, lighting = list(exponent = 5))
 surf3D(x, y, z, box = FALSE, col = Col, lighting = list(exponent = 50))
 surf3D(x, y, z, box = FALSE, col = Col, lighting = list(sr = 1)) 

## =======================================================================
## Shading, lighting with default colors
## =======================================================================

 x &lt;- seq(-pi, pi, len = 100)
 y &lt;- seq(-pi, pi, len = 100)
 grid &lt;- mesh(x, y)

 z    &lt;- with(grid, cos(x) * sin(y))
 cv   &lt;- with(grid, -cos(y) * sin(x))

# lphi = 180, ltheta = -130  - good for shade
# lphi = 90, ltheta = 0  - good for lighting

 par(mfrow = c(2, 2))
 persp3D(z = z, x = x, y = y, colvar = cv, zlim = c(-3, 3), colkey = FALSE)
 persp3D(z = z, x = x, y = y, colvar = cv, zlim = c(-3, 3), 
       lighting = TRUE, colkey = FALSE)
 persp3D(z = z, x = x, y = y, colvar = cv, zlim = c(-3, 3), 
       shade = 0.25, colkey = FALSE)
 persp3D(z = z, x = x, y = y, colvar = cv, zlim = c(-3, 3), 
       lighting = TRUE, lphi = 90, ltheta = 0, colkey = FALSE)

## =======================================================================
## transparency of a vector of colors
## =======================================================================

 par(mfrow = c(1, 1))
 x &lt;- runif(19)
 y &lt;- runif(19)
 z &lt;- runif(19)
# split into 5 sections (polygons) 
 ii &lt;- seq(4, 19, by = 4)
 x[ii] &lt;- y[ii] &lt;- z[ii] &lt;- NA
  
 polygon3D(x, y, z, border = "black", lwd = 2, 
   col = alpha.col(c("red", "lightblue", "yellow", "green", "black"), 
                  alpha = 0.4))

# the same, now passing alpha as an argument to polygon3D:
## Not run: 
 polygon3D(x, y, z, border = "black", lwd = 2, 
   col = c("red", "lightblue", "yellow", "green", "black"), 
                  alpha = 0.4)

## End(Not run)
# reset plotting parameters
 par(mfrow = pm)
 par(mar = pmar)
</code></pre>

<hr>
<h2 id='Composite+20plots'>
Handling and plotting plotting lists.
</h2><span id='topic+plot.plist'></span><span id='topic+plotdev'></span><span id='topic+setplist'></span><span id='topic+getplist'></span><span id='topic+selectplist'></span>

<h3>Description</h3>

<p>S3 method <code>plot.plist</code> and function <code>plotdev</code> plot the plotting list 
to the current device. 
Changes can be made to the perspective view, to the lighting and shading, 
or to make colors transparent. 
</p>
<p><code>getplist</code> and <code>setplist</code> retrieve and store information in the plotting list.
</p>
<p><code>selectplist</code> selects parts from the plotting list, based on a user-defined function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getplist()
setplist(plist)
plotdev(...)
## S3 method for class 'plist'
 plot(x, ...) 
selectplist(plist, SS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Composite+2B20plots_+3A_x">x</code>, <code id="Composite+2B20plots_+3A_plist">plist</code></td>
<td>
<p>The plotting <code>list</code> as generated (invisibly) 
by any of the 3D plotting functions.
</p>
</td></tr>
<tr><td><code id="Composite+2B20plots_+3A_ss">SS</code></td>
<td>
<p>Function which tests points for inclusion in the plotting list.
It should take as argument three vectors (x, y, z) and return a vector of 
equal length that is either <code>TRUE</code> or <code>FALSE</code>, denoting whether
the point should be selected or not.
</p>
</td></tr>
<tr><td><code id="Composite+2B20plots_+3A_...">...</code></td>
<td>
<p>Additional arguments to change the view or coloration. 
Supported arguments to change the view are :
<code>theta, phi, xlim, ylim, zlim, d, r, scale, expand</code>. See <a href="#topic+perspbox">perspbox</a>,
<a href="graphics.html#topic+persp">persp</a>.
</p>
<p>Supported arguments to change the lighting, or coloration are :
<code>ltheta, lphi, shade, lighting</code>. See <a href="#topic+jet.col">jet.col</a>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All 3-D functions from package <code>plot3D</code> produce or update a plotting list
that is local to the package. One can access this plotting list via <code>getplist</code>
and <code>setplist</code>. The list is used to plot when, in a 3-D function, the argument
<code>plot</code> is <code>TRUE</code> or via function <code>plotdev</code>.
</p>
<p>When new 3-D objects are added to a plot, using the <code>add</code> argument of the 
plotting functions, then everything except the axes, is redrawn on top of 
what was already there. This means that several object will be drawn multiple times,
and this may clutter the output. This may not be visible on your screen, but
it may become apparent when exported. Use <code>plotdev</code> to create clean figures, where 
every object is drawn only  once. 
</p>
<p>The plotting <code>list</code> can contain the following items:
</p>

<ul>
<li> <p><code>mat</code>, the viewing transformation matrix,
a 4 x 4 matrix suitable for projecting 3D coordinates 
(x, y, z) into the 2D plane using homogeneous 4D coordinates (x,y,z,v). 
</p>
<p>It can be used to superimpose additional graphical elements on the 3D plot, 
by any function that is defined on <a href="graphics.html#topic+persp">persp</a>.
</p>
<p>It can also be used to add <code>lines</code>, <code>arrows</code> or 
<code>points</code>, using the function <a href="#topic+trans3D">trans3D</a>. 
</p>
</li>
<li> <p><code>plt</code>, with original <code>plt</code> parameters and the <code>plt</code> 
parameters used for the main frame.
</p>
</li>
<li> <p><code>persp</code>, with settings for the perspective box.
</p>
</li>
<li> <p><code>xlim, ylim, zlim</code>, with ranges.
</p>
</li>
<li> <p><code>scalefac</code>, the scaling factors in x, y and z direction,
used e.g. for shading.
</p>
</li>
<li> <p><code>dot</code> other plotting parameters passed to <code>persp</code>.
</p>
</li>
<li> <p><code>colkey</code>, <code>numkey</code>, with settings for the color key(s).
</p>
</li>
<li> <p><code>poly, segm, pt, CIpt, labels, arr</code> the information for drawing 
polygons, segments, points, points with confidence intervals, labels and arrows,
that are part of the plot.  
</p>
</li></ul>

<p>For the item <code>poly</code> the elements are:
</p>

<ul>
<li> <p><code>x, y, z</code> : A matrix with typically 4 or 5 rows, the first rows defining the x-, y- or z- 
values of each polygon, the last row contains <code>NA</code> (and which therefore terminates a polygon).
</p>
</li>
<li> <p><code>col</code>: a vector with the colors for the facets of each polygon.
</p>
</li>
<li> <p><code>lwd, lty, border</code>: a vector with the line widths, line type and colors for the border of each polygon.
(note in R-function <a href="graphics.html#topic+polygon">polygon</a>, passing a vector of line widths is not implemented;
therefore, only the first value of <code>lwd</code> will be used for all polygons).
</p>
<p>When <code>plot.plist</code> is called, the projection depth is calculated and used to sort the
facets and function <code>polygon</code> used to draw them.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns the updated plotting list.
</p>


<h3>Note</h3>

<p>Once a 3D plot has been generated, a new device can be opened and 
<code>plotdev</code> used to plot also on this device.
</p>
<p><code>plotdev</code> and <code>plot(getplist())</code> are the same.
</p>
<p>In an extension package, <code>plot3Drgl</code>, a similar function, <code>plotrgl</code>,
plots the graphs to the device opened with <code>rgl</code>. This allows interactive
zooming, rotating, etc...
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters                            
 pm   &lt;- par("mfrow")
 pmar &lt;- par("mar")

## ========================================================================
## The volcano
## ========================================================================

 par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))

# The volcano at lower resolution
 x &lt;- seq(1, nrow(volcano), by = 2)
 y &lt;- seq(1, ncol(volcano), by = 2)
 V &lt;- volcano[x,y]

 persp3D(z = V)

# rotate
 plotdev(theta = 0)

# light and transparence
 plotdev(lighting  = TRUE, lphi = 90, alpha = 0.6)  

# zoom
 plotdev(xlim = c(0.2, 0.6), ylim = c(0.2, 0.6), phi = 60) 
 
## ========================================================================
## Two spheres 
## ========================================================================

 par(mfrow = c(1, 1), mar = c(0, 0, 0, 0))

# create a sphere
 M  &lt;- mesh(seq(0, 2*pi, length.out = 30),
            seq(0,   pi, length.out = 30))
 u  &lt;- M$x ; v  &lt;- M$y

 x &lt;- cos(u)*sin(v)
 y &lt;- sin(u)*sin(v)
 z &lt;- cos(v)

 surf3D(x = 2*x, y = 2*y, z = 2*z, 
        colvar = NULL, lighting = TRUE, #plot = FALSE,
        facets = NA, col = "blue", lwd = 5)
 
 surf3D(x, y, z, colvar = NULL, lighting = TRUE, 
        col = "red", add = TRUE)

 names(getplist())

# plot with different view:
 plotdev(phi = 0)  
## Not run:   # will plot same 3-D graph to pdf
 pdf(file = "save.pdf")
 plotdev()
 dev.off()

## End(Not run)
             
## ========================================================================
## Two spheres and two planes 
## ========================================================================

 par(mar = c(2, 2, 2, 2))

# equation of a sphere
 M  &lt;- mesh(seq(0, 2*pi, length.out = 100),                                     -
            seq(0,   pi, length.out = 100))
 u  &lt;- M$x ; v  &lt;- M$y

 x &lt;- cos(u)*sin(v)
 y &lt;- sin(u)*sin(v)
 z &lt;- cos(v)

 surf3D(x, y, z, colvar = z, 
        theta = 45, phi = 20, bty = "b",
        xlim = c(-1.5, 1.5), ylim = c(-1, 2), 
        zlim = c(-1.5, 1.5), plot = FALSE)

# add a second sphere, shifted 1 unit to the right on y-axis; 
# no facets drawn for this sphere 
 surf3D (x, y+1, z, colvar = z, add = TRUE, 
         facets = FALSE, plot = FALSE)

# define a plane at z = 0
 Nx &lt;- 100
 Ny &lt;- 100
  
 x &lt;- seq(-1.5, 1.5, length.out = Nx)
 y &lt;- seq(-1, 2, length.out = Ny)

 image3D (x = x, y = y, z = 0, add = TRUE, colvar = NULL, 
          col = "blue", facets = TRUE, plot = FALSE)

# another, small plane at y = 0 - here x and y have to be matrices!
 x &lt;- seq(-1., 1., length.out = 50)
 z &lt;- seq(-1., 1., length.out = 50)
 
 image3D (x = x, y = 0, z = z, colvar = NULL, 
         add = TRUE, col = NA, border = "blue", 
         facets = TRUE, plot = TRUE)       

## Not run:   # rotate 
 for (angle in seq(0, 360, by = 10)) 
   plotdev(theta = angle)

## End(Not run)

## ========================================================================
## Zooming, rescaling, lighting,...
## ========================================================================

 par(mfrow = c(2, 2)) 

# The volcano
 x &lt;- seq(1, nrow(volcano), by = 2)
 y &lt;- seq(1, ncol(volcano), by = 2)
 V &lt;- volcano[x,y]
# plot the volcano
 persp3D (x, y, z = V, colvar = V, theta = 10, phi = 20, 
          box = FALSE, scale = FALSE, expand = 0.3, 
          clim = range(V), plot = FALSE)

# add a plane (image) at z = 170; jetcolored, transparant: only border
 image3D(x, y, z = 170, add = TRUE, clim = range(V), 
         colvar = V, facets = NA, plot = FALSE, colkey = FALSE)

# add a contour (image) at z = 170; jetcolored, 
 contour3D(x, y, z = 170, add = TRUE, clim = range(V),
           colvar = V, plot = FALSE, colkey = FALSE)

# plot it  - 
 plot(getplist())   #  same as plotdev()

# plot but with different expansion
 plotdev(expand = 1)

# other perspective, and shading
 plotdev(d = 2, r = 10, shade = 0.3)
    
# zoom and rotate
 plotdev(xlim = c(10, 30), ylim = c(20, 30), phi = 50)

## ========================================================================
## Using setplist
## ========================================================================

 polygon3D(runif(3), runif(3), runif(3))
# retrieve plotting list
 plist &lt;- getplist()
 names(plist)
 plist$poly
# change copy of plotting list
 plist$poly$col &lt;- "red"
# update internal plotting list
 setplist(plist)
# plot updated list
 plotdev()
 

## ========================================================================
## Using selectplist
## ========================================================================

 polygon3D(runif(10), runif(10), runif(10), col = "red", 
   alpha = 0.2, plot = FALSE, ticktype = "detailed", 
   xlim = c(0,1), ylim = c(0, 1), zlim = c(0, 1))
 polygon3D(runif(10)*0.5, runif(10), runif(10), col = "yellow", 
   alpha = 0.2, plot = FALSE, add = TRUE)
 polygon3D(runif(10)*0.5+0.5, runif(10), runif(10), col = "green", 
   alpha = 0.2, plot = FALSE, add = TRUE)
 points3D(runif(10), runif(10), runif(10), col = "blue", 
   add = TRUE, plot = FALSE)
 segments3D(x0 = runif(10), y0 = runif(10), z0 = runif(10), 
   x1 = runif(10), y1 = runif(10), z1 = runif(10), 
   colvar = 1:10, add = TRUE, lwd = 3)

# retrieve plotting list
 plist &lt;- getplist()

# selection function 
 SS &lt;- function (x, y, z)  {
   sel &lt;- rep(TRUE, length.out = length(x))
   sel[x &lt; 0.5] &lt;- FALSE
   return(sel)
 } 
# The whole polygon will be removed or kept.  
 plot(x = selectplist(plist, SS), 
   xlim = c(0, 1), ylim = c(0, 1), zlim = c(0, 1))

# restore plotting parameters
 par(mfrow = pm)
 par(mar = pmar)
</code></pre>

<hr>
<h2 id='images+20in+203D+20frame'>
Images in 3-D plots.
</h2><span id='topic+image3D'></span>

<h3>Description</h3>

<p><code>image3D</code> adds an image in a 3-D plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image3D (x = NULL, y = NULL, z = NULL, ..., colvar = NULL, 
      phi = 40, theta = 40, col = NULL,
      NAcol = "white", breaks = NULL, border = NA, facets = TRUE,
      colkey = NULL, resfac = 1, panel.first = NULL,
      clim = NULL, clab = NULL, bty = "b",
      inttype = 1, add = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_x">x</code>, <code id="images+2B20in+2B203D+2B20frame_+3A_y">y</code>, <code id="images+2B20in+2B203D+2B20frame_+3A_z">z</code></td>
<td>
<p>Matrix (2-D), vector, or one value containing the values 
where the image is to be plotted. 
At least one of them should be one number, as this will determine where the 
image is plotted, parallel to the (y-z) plane (x one number), 
to the (x-z) plane (y one number) or to the (z-y) plane (z one number).
</p>
<p>If two are vectors, the first vector should be of length equal to 
<code>nrow(colvar)</code> and the second should be of length equal to 
<code>ncol(colvar)</code>. 
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. 
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_col">col</code></td>
<td>
<p>Color palette to be used for the <code>colvar</code> variable.
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_nacol">NAcol</code></td>
<td>
<p>Color to be used for <code>NA</code> values of <code>colvar</code>; default is &ldquo;white&rdquo;. 
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey = TRUE</code>, the label to be written on top of the
color key. The label will be written at the same level as the main title.
to lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable, used
for the color key. Values of <code>colvar</code> that extend the range will be put to <code>NA</code>.
</p>
</td></tr> 
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_resfac">resfac</code></td>
<td>
<p>Resolution factor, one value or a vector of two numbers, for 
the x and y- values respectively. A value &gt; 1 will increase the 
resolution. For instance, if <code>resfac</code> equals <code>3</code> then for each 
adjacent pair of x- and y-values, z will be interpolated to two intermediary points. 
This uses simple linear interpolation. If <code>resfac</code> is one number then
the resolution will be increased similarly in x and y-direction.  
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_theta">theta</code>, <code id="images+2B20in+2B203D+2B20frame_+3A_phi">phi</code></td>
<td>
<p>The angles defining the viewing direction. 
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. 
see <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_border">border</code></td>
<td>
<p>The color of the lines drawn around the surface facets.
The default, <code>NA</code>, will disable the drawing of borders.
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_facets">facets</code></td>
<td>
<p>If <code>TRUE</code>, then <code>col</code> denotes the color of the surface facets. 
If <code>FALSE</code>, then the surface facets are colored &ldquo;white&rdquo; and the <code>border</code> 
(if <code>NA</code>) will be colored as specified by <code>col</code>. 
If <code>NA</code> then the facets will be transparent. 
It is usually faster to draw with <code>facets = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_panel.first">panel.first</code></td>
<td>
<p>A <code>function</code> to be evaluated after the plot axes are 
set up (and if applicable, images or contours drawn) but before any plotting takes place. 
This can be useful for drawing background grids or scatterplot smooths. 
The function should have as argument the transformation matrix, e.g. it should
be defined as <code>function(pmat)</code>. See example of <a href="#topic+persp3D">persp3D</a> and last example of <a href="#topic+voxel3D">voxel3D</a>.
</p>
</td></tr> 
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_bty">bty</code></td>
<td>
<p>The type of the box, the default only drawing background panels.
Only effective if the <a href="graphics.html#topic+persp">persp</a> 
argument (<code>box</code>) equals <code>TRUE</code> (this is the default). See <a href="#topic+perspbox">perspbox</a>.
</p>
</td></tr>
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_inttype">inttype</code></td>
<td>
<p>The interpolation type to create the polygons, either 
taking the mean of the <code>colvar</code> variable (<code>inttype = 1, 3</code> or 
extending the <code>x, y, z</code> values (<code>inttype = 2</code>). 
Values <code>1, 3</code> differ in how they treat <code>NA</code>s in the <code>colvar</code> variable. 
For <code>inttype = 3</code>, <code>NA</code>s are removed before taking averages; 
this will tend to make the <code>NA</code> region smaller. 
<code>NA</code>s are included when <code>inttype = 1</code>. This will tend to make the <code>NA</code> region larger.
see details and an example in <a href="#topic+persp3D">persp3D</a>.
</p>
</td></tr> 
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the image will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr> 
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise the viewing transformation matrix is returned (as invisible). 
</p>
</td></tr> 
<tr><td><code id="images+2B20in+2B203D+2B20frame_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting methods. 
</p>
<p>The following <a href="graphics.html#topic+persp">persp</a> arguments can be specified: 
<code>xlim, ylim, zlim, xlab, ylab, zlab, main, sub, r, d, 
    scale, expand, box, axes, nticks, ticktype</code>.      
The arguments <code>xlim</code>, <code>ylim</code>, <code>zlim</code> only affect the axes.
All objects will be plotted, including those that fall out of these ranges.
To select objects only within the axis limits, use <a href="#topic+plotdev">plotdev</a>.
</p>
<p>In addition, the <a href="#topic+perspbox">perspbox</a> arguments
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> can 
also be given a value.
</p>
<p><code>shade</code> and <code>lighting</code> arguments will have no effect.
</p>
<p><code>alpha</code> can be given a value inbetween 0 and 1 to make colors transparent.
</p>
<p>Also the arguments <code>lty, lwd</code> can be specified (when <code>border</code> is not <code>NA</code>).
</p>
<p>The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>image3D</code> calls the <a href="#topic+surf3D">surf3D</a> function. The x, y, and z values are 
expanded as a matrix. 
</p>


<h3>Value</h3>

<p>Returns the viewing transformation matrix.
See <a href="#topic+trans3D">trans3D</a>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><a href="#topic+surf3D">surf3D</a> for the function on which <code>image3D</code> is based.
</p>
<p><a href="#topic+image2D">image2D</a> for <code>plot3D</code>s 2-D image function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

## =======================================================================
## images in x, y, z plane
## =======================================================================

 par(mfrow = c(2, 2))

# images in x, y, z plane
# We use colkey = list(plot = FALSE) to create room for a color key
 image3D(y = seq(0, 1, 0.1), z = seq(0, 1, 0.1), x = 0.5, 
   col = "blue", xlim = c(0,1), colkey = list(plot = FALSE))
 image3D(x = seq(0, 1, 0.1), z = seq(0, 1, 0.1), y = 0.5, 
   add = TRUE, col = "red", alpha = 0.2)   # alpha makes it transparent
 image3D(x = seq(0, 1, 0.1), y = seq(0, 1, 0.1), z = 0.5, 
   add = TRUE, col = "green")
 colkey(col = c("green", "red", "blue"), clim = c(0.5, 3.5), 
   at = 1:3, labels = c("z", "y", "x"), add = TRUE)
#
 image3D(z = 100, colvar = volcano, zlim = c(0, 150),
   clab = c("height", "m"))
  
#
 image3D( x = 0.5, colvar = volcano, xlim = c(0, 1), 
   ylim = c(0, 1), zlim = c(0, 1))

 image3D( y = 0.5, colvar = volcano, add = TRUE)

#
 image3D( z = 1, colvar = volcano, 
   x = seq(0, 1, length.out = nrow(volcano)),
   y = seq(0, 1, length.out = ncol(volcano)), 
   xlim = c(0, 2), ylim = c(0, 2), zlim = c(0, 2))
 image3D(y = 2, colvar = volcano, add = TRUE, 
    shade = 0.2,
    x = seq(0, 1, length.out = nrow(volcano)),
    z = seq(1, 2, length.out = ncol(volcano)))
 image3D(x = 2, colvar = NULL, col = "orange", add = TRUE, 
    y = seq(0, 1, length.out = nrow(volcano)),
    z = seq(1, 2, length.out = ncol(volcano)))

# reset plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='Mesh+20generation'>
Rectangular grids. 
</h2><span id='topic+mesh'></span>

<h3>Description</h3>

<p><code>mesh</code> creates a rectangular full 2-D or 3-D grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh (x, y, z = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mesh+2B20generation_+3A_x">x</code>, <code id="Mesh+2B20generation_+3A_y">y</code>, <code id="Mesh+2B20generation_+3A_z">z</code></td>
<td>
<p>Vectors with x, y and z-values. 
They can be of arbitrary length.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>mesh</code> returns a <code>list</code> with the expanded x- y- and z 
arrays (in case <code>z</code> is not <code>NULL</code>) or matrices (in case <code>z = NULL</code>).
The dimensions of these list elements are the same and equal to 
<code>c(length(x), length(y), length(z))</code>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+persp3D">persp3D</a>, <a href="#topic+arrows3D">arrows3D</a>, <a href="#topic+slice3D">slice3D</a>, <a href="#topic+surf3D">surf3D</a>
for other examples that use <code>mesh</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ========================================================================
## 2-D mesh
## ========================================================================

 x &lt;- c(-1 , 0, 1)
 y &lt;- 1 : 4

# 2-D mesh
 (M &lt;- mesh(x, y))

# calculate with this mesh
 V &lt;- with (M, x/2 * sin(y))

# same as:
 V2 &lt;- outer(x, y, FUN = function(x, y) x/2*sin(y))

## ========================================================================
## 3-D mesh
## ========================================================================

 x &lt;- y &lt;- z &lt;- c(-1 , 0, 1)

# 3-D mesh
 (M &lt;- mesh(x, y, z))

# calculate with 3-D mesh
 V &lt;- with (M, x/2 * sin(y) *sqrt(z+2))
  
# plot result
 scatter3D(M$x, M$y, M$z, V, pch = "+", cex = 3, colkey = FALSE)
</code></pre>

<hr>
<h2 id='Perspective+20box'>
Creates an empty perspective box, ready for adding objects
</h2><span id='topic+perspbox'></span>

<h3>Description</h3>

<p><code>perspbox</code> draws a box and labels, and makes space for a colorkey (if any).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perspbox (x = seq(0, 1, length.out = nrow(z)), 
          y = seq(0, 1, length.out = ncol(z)), z, 
          bty = c("b", "b2", "f", "g", "bl", "bl2", "u", "n"),  ..., 
          col.axis = "black", col.panel = NULL, lwd.panel = 1,                     
          col.grid = NULL, lwd.grid = 1, 
          phi = 40, theta = 40, col = NULL,
          colkey = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Perspective+2B20box_+3A_x">x</code>, <code id="Perspective+2B20box_+3A_y">y</code></td>
<td>
<p>Vectors with x and y values. It is sufficient to pass the 
ranges of the x- and y-values, as they will not be drawn. 
If <code>z</code> is a matrix, it is required that <code>length(x) = nrow(z)</code> and 
<code>length(y) = ncol(z)</code>.
</p>
</td></tr>
<tr><td><code id="Perspective+2B20box_+3A_z">z</code></td>
<td>
<p>Matrix or vector with z-values. If <code>z</code> is a matrix, 
it is sufficient to pass a diagonal matrix with the range of the z-values, 
as they will not be drawn. 
</p>
</td></tr>
<tr><td><code id="Perspective+2B20box_+3A_bty">bty</code></td>
<td>
<p>The type of the box; only effective if the <a href="graphics.html#topic+persp">persp</a> 
argument <code>box</code> equals <code>TRUE</code> (the default).
Unless <code>bty</code> is equal to <code>"u"</code> then the arguments 
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> will be ignored.
<code>"f"</code> is the full box, the default as from <a href="graphics.html#topic+persp">persp</a>, 
<code>"b"</code> has only the back panels visible, when <code>"b2"</code>
has back panels and grid lines, <code>"g"</code> has grey background with white 
gridlines, <code>"bl"</code> has a black background, 
<code>"bl2"</code> has a black background with grey lines.
<code>"u"</code> means that the user will specify the arguments 
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> manually.
<code>"n"</code> means that no box will be drawn. This is the same as setting
<code>box = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="Perspective+2B20box_+3A_col.axis">col.axis</code>, <code id="Perspective+2B20box_+3A_col.panel">col.panel</code>, <code id="Perspective+2B20box_+3A_col.grid">col.grid</code></td>
<td>
<p>The color of the axis line, of the 
axis panel or of the grid lines. Only used if <code>bty = "u"</code>.
</p>
</td></tr>
<tr><td><code id="Perspective+2B20box_+3A_lwd.panel">lwd.panel</code>, <code id="Perspective+2B20box_+3A_lwd.grid">lwd.grid</code></td>
<td>
<p>The width of the panel border or of the 
grid lines. Only used if <code>bty = "u"</code>.
</p>
</td></tr>
<tr><td><code id="Perspective+2B20box_+3A_theta">theta</code>, <code id="Perspective+2B20box_+3A_phi">phi</code></td>
<td>
<p>The angles defining the viewing direction. 
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. 
see <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="Perspective+2B20box_+3A_col">col</code></td>
<td>
<p>Colors to be used for coloring the <code>colvar</code> variable. 
Here only used for assessing if a color key should be drawn.
</p>
</td></tr>
<tr><td><code id="Perspective+2B20box_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters 
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="Perspective+2B20box_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise the viewing transformation matrix is returned (as invisible). 
</p>
</td></tr> 
<tr><td><code id="Perspective+2B20box_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="graphics.html#topic+persp">persp</a>. 
</p>
<p>The following <a href="graphics.html#topic+persp">persp</a> arguments can be specified: 
<code>xlim, ylim, zlim, xlab, ylab, zlab, main, sub, r, d, 
    scale, expand, box, axes, nticks, ticktype</code>.      
</p>
<p>Arguments <code>scale</code> and <code>expand</code> affect the size of the axes.
</p>
<p>The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>xlim</code>, <code>ylim</code>, <code>zlim</code> only affect the axes.
All objects will be plotted, including those that fall out of these ranges.
To select objects only within the axis limits, use <a href="#topic+plotdev">plotdev</a>.
</p>
<p>The predefined box types <code>bty</code> are defined as follows:
</p>
<p>&ldquo;f&rdquo;: all panels are shown and transparent, also the <a href="graphics.html#topic+persp">persp</a> default.
</p>
<p>&ldquo;b&rdquo;: only backward panels shown.
</p>
<p>&ldquo;b2&rdquo;: as &ldquo;b&rdquo; with <code>col.grid = "grey"</code>.
</p>
<p>&ldquo;g&rdquo;: only backward panels shown; <code>col.panel = grey(0.95)</code>, 
<code>col.axis = "grey"</code>,
<code>lwd.grid = 2</code> and <code>col.grid = "white"</code>.
</p>
<p>&ldquo;bl&rdquo;: only backward panels shown; <code>col.panel = "black"</code>, 
<code>col.axis = "grey"</code>,
<code>lwd.grid = 2</code> and <code>col.grid = "white"</code>.
</p>
<p>&ldquo;n&rdquo;: no box is drawn.
</p>


<h3>Value</h3>

<p>Function <code>perspbox</code> returns the viewing transformation matrix.
See <a href="#topic+trans3D">trans3D</a>.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+persp3D">persp3D</a>, <a href="#topic+scatter2D">scatter2D</a>, <a href="#topic+surf3D">surf3D</a> for examples where box types 
different than the default are used.
</p>
<p><a href="#topic+Hypsometry">Hypsometry</a> for an example where colored axis-panels are added to a 
figure started with <code>perspbox</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters                            
 pm   &lt;- par("mfrow")
 pmar &lt;- par("mar")

## ========================================================================
## The 4 predefined box types
## ========================================================================

 par(mfrow = c(2, 2), mar = c(1, 1, 1, 1))
 
# box type with only backward panels
 perspbox(z = volcano, bty = "b", ticktype = "detailed", d = 2, 
          main  = "bty = 'b'")
# box as in 'persp'
 perspbox(z = volcano, bty = "f", ticktype = "detailed", 
          d = 2, main  = "bty = 'f'")

# back panels with gridlines, detailed axes
 perspbox(z = volcano, bty = "b2", ticktype = "detailed", 
          d = 2, main  = "bty = 'b2'")

# ggplot-type, simple axes 
 perspbox(z = volcano, bty = "g", 
          d = 2, main  = "bty = 'g'")

## ========================================================================
## A user-defined box
## ========================================================================

 par(mfrow = c(1, 1))

 perspbox(z = diag(2), bty = "u", ticktype = "detailed", 
          col.panel = "gold", col.axis = "white",  
          scale = FALSE, expand = 0.4, 
          col.grid = "grey", main = "user-defined")

# restore plotting parameters
 par(mfrow = pm)
 par(mar = pmar)
</code></pre>

<hr>
<h2 id='plots+20with+20legend+20or+20colorkeys'>
Plots with legend or colorkeys outside of the plotting region
</h2><span id='topic+legendplot'></span><span id='topic+legendmatplot'></span><span id='topic+legendhist'></span><span id='topic+legendpairs'></span><span id='topic+legend.plt'></span><span id='topic+legend.oma'></span><span id='topic+colorkeyplot'></span><span id='topic+colorkeymatplot'></span><span id='topic+colorkeyhist'></span><span id='topic+colorkeypairs'></span><span id='topic+colorkey.plt'></span><span id='topic+colorkey.oma'></span><span id='topic+createKey'></span>

<h3>Description</h3>

<p><code>legendplot</code>, <code>legendmatplot</code>, <code>legendhist</code> and <code>legendpairs</code> create 
plots with a legend adjacent to it, using R's default plotting functions plot, matplot, hist and pairs. 
</p>
<p><code>colorkeyplot</code>, <code>colorkeymatplot</code>, <code>colorkeyhist</code> and <code>colorkeypairs</code> 
create a plot with a colorkey adjacent to it. 
</p>
<p><code>createKey</code> creates suitable colors for the color variables.
</p>
<p><code>legend.plt</code> and <code>colorkey.plt</code> are general functions that might 
also work with other plotting methods, and that add a legend or color key by changing the <code>plt</code> parameter.
</p>
<p><code>legend.oma</code> and <code>colorkey.oma</code> are general functions that might 
also work with other plotting methods, and that add a legend or color key by changing the <code>oma</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendplot    (..., legend = list(), legend.side = 4, legend.cex = 1, legend.pars = NULL)  
legendmatplot (..., legend = list(), legend.side = 4, legend.cex = 1, legend.pars = NULL)  
legendhist    (..., legend = list(), legend.side = 4, legend.cex = 1, legend.pars = NULL)  
legendpairs   (..., legend = list(), legend.side = 4, legend.cex = 1, legend.pars = NULL)  

legend.plt (method = "plot", ..., legend = list(), legend.side = 4, legend.cex = 1, 
            legend.pars = NULL)  
legend.oma (method = "pairs", ..., legend = list(), legend.side = 4, legend.cex = 1, 
            legend.pars = NULL)  

colorkeyplot    (..., colorkey = list(), colorkey.side = 4)
colorkeymatplot (..., colorkey = list(), colorkey.side = 4)
colorkeyhist    (..., colorkey = list(), colorkey.side = 4)
colorkeypairs   (..., colorkey = list(), colorkey.side = 4)

colorkey.plt (method = "plot",..., colorkey = list(), colorkey.side = 4)
colorkey.oma (method = "pairs",..., colorkey = list(), colorkey.side = 4)

createKey (x, clim = NULL, col = NULL, NAcol = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_method">method</code></td>
<td>
<p>A plotting method to which to add the legend or colorkey,
such as <a href="graphics.html#topic+plot">plot</a>, <code>matplot</code>, <code>boxplot</code>, ... Note that not all
of R's plotting functions can be used.
</p>
</td></tr>
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_...">...</code></td>
<td>
<p>Any argument passed to <a href="graphics.html#topic+plot">plot</a>, <a href="graphics.html#topic+matplot">matplot</a>, 
<a href="graphics.html#topic+hist">hist</a> or any other <code>method</code>.
</p>
</td></tr>
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_colorkey.side">colorkey.side</code>, <code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_legend.side">legend.side</code></td>
<td>
<p>On which side of the plot 
(1=bottom, 2=left, 3=top, 4=right) to put the legend or color key.
</p>
</td></tr> 
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_legend.cex">legend.cex</code></td>
<td>
<p>The expansion factor of the space around the legend.
</p>
</td></tr> 
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_legend.pars">legend.pars</code></td>
<td>
<p>A list that determines the size of the legend 
and of the main plotting region, as returned by any of the legend plotting 
functions. 
It should contain two vectors, one that sets the size of the plotting region
called <code>plt.main</code> and one that sets the size of the legend,
called <code>plt.legend</code>. The format of these vectors is as the <a href="graphics.html#topic+par">par</a>ameter <code>"plt"</code>.
See last example. 
</p>
</td></tr> 
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_colorkey">colorkey</code></td>
<td>
<p>A list with arguments passed to function <a href="#topic+colkey">colkey</a>.
</p>
</td></tr> 
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_legend">legend</code></td>
<td>
<p>A list with arguments passed to function <a href="graphics.html#topic+legend">legend</a>. 
</p>
</td></tr> 
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_x">x</code></td>
<td>
<p>The variable for which the color key has to be created.
</p>
</td></tr> 
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_col">col</code></td>
<td>
<p>Colors to be used for the color key.
If <code>col</code> is <code>NULL</code>, 
then a red-yellow-blue colorscheme (<code>jet.col</code>) will be used.
</p>
</td></tr>
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_clim">clim</code></td>
<td>
<p>The range of the color values, used in the color key. 
</p>
</td></tr> 
<tr><td><code id="plots+2B20with+2B20legend+2B20or+2B20colorkeys_+3A_nacol">NAcol</code></td>
<td>
<p>Color to be used for <code>NA</code> values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The legend plotting functions return as <code>invisible</code>, a <code>list</code> that contains the plotting parameters for the regions of the legend and of the main plotting region, elements called <code>plt.legend</code> and <code>plt.main</code>. For the <code>pairs</code> method, the list returned contains the size of the outer margin  instead, i.e. the <code>oma</code> parameter. 
</p>


<h3>Note</h3>

<p>The method that changes the oma parameter (based on legend.oma) is not optimal, as plot.new is called several times. This means you will need to &quot;hit return to see next plot&quot; several times before you see the actual figure.  
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# save plotting parameters
pm &lt;- par(mfrow = c(2, 2))
pmar &lt;- par(mar = c(5.1, 4.1, 4.1, 2.1))


# ============================================================================
#  Colorkey and legend added to simple plot
# ============================================================================

par(mfrow = c(2,1))
x &lt;- seq(0, 2*pi, length.out = 30)
y &lt;- sin(x)

# Note: this forgets the names of the x and y-variables.
colorkeyplot(x = x, y = y, col = createKey(y), pch = 18,
              main = "colorkeyplot with 'plot'", 
              colorkey = list(clim = range(y)))
abline (v = 4)
abline (h = 0.4)

legendplot(x = x, y = y, col = c("red", "blue")[(y &gt; 0)+1], 
          main = "legendplot with 'plot'", pch = 18, 
          xlab = "x", ylab = "y", 
          legend = list(col = c("red","blue"), pch = 18, 
                          legend = c("&gt;0", "&lt;0")))
abline (v = pi)
abline (h = 0)

par(mfrow = c(1,1))
legendplot(x = x, y = y, col = c("red", "blue")[(y &gt; 0)+1], 
          main = "legendplot with 'plot'", pch = 18,
          legend.side = 1, las = 1,
          legend = list(col = c("red","blue"), pch = 18, 
                      horiz = TRUE, legend = c("&gt;0", "&lt;0")))
abline (v = pi)
abline (h = 0)

# We do not label the y-axis, so the legend can be a 
# closer to the axis (legend.cex)
par(mfrow = c(1,1), mar = c(4,2,4,2))
legendplot(x = x, y = y, col = c("red", "blue")[(y &gt; 0)+1], 
            main = "legendplot with 'plot'", pch = 18,
            legend.side = 2, legend.cex = 0.5, ylab = "",
            legend = list(col = c("red","blue"), pch = 18, 
                          horiz = FALSE, legend = c("&gt;0", "&lt;0")))

# Here we have a title with two lines, so the legend is put further away
# Also the legend is put near the bottom here.
legendplot(x = x, y = y, col = c("red", "blue")[(y &gt; 0)+1], 
            main = "legendplot with 'plot'", pch = 18,
            legend.side = 2, legend.cex = 2, ylab = c("axis","on two lines"),
            legend = list(col = c("red","blue"), pch = 18, x = "bottomleft",
                          horiz = FALSE, legend = c("&gt;0", "&lt;0")))

# This works as ordinary legend function (except for the labeling of the axes)
par(mfrow = c(1,1), mar = c(4,4,2,2))
legendplot(x = x, y = y, col = c("red", "blue")[(y &gt; 0)+1], 
            main = "legendplot with 'plot'", pch = 18,
            legend.side = 0,
            legend = list(col = c("red","blue"), pch = 18, x = "right",
                          horiz = TRUE, legend = c("&gt;0", "&lt;0")))

## =============================================================================
## ... added to a more complex plot
## =============================================================================

legend.plt(method = "points2D", x = x, y = y, colvar = y, 
           pch = c(18, 20)[(y &gt; 0)+1], cex = 2, 
           colkey = list(side = 1, dist = -0.25, length = 0.4, shift = -0.15), 
           main = "legendplot with 'points2D'",
           legend = list(pch = c(18, 20), pt.cex = 2,
                         horiz = FALSE, legend = c("&gt;0", "&lt;0")))

# to use the image function with a color key - easier to do with image2D...
colorkey.plt(method = "image", x = 1:nrow(volcano), y = 1:ncol(volcano), 
             z = volcano, col = jet.col(100), 
             main = "colorkeyplot with 'image'",
             colorkey = list(col = jet.col(100), clim = range(volcano), clab = "m"))

## =============================================================================
## with matplot
## =============================================================================

# this is not a very instructive figure!  

lon &lt;- Hypsometry$x           # Longitude
iy  &lt;- seq(10, 180, by = 10)  # Index to latitudes where we want to see data
lat &lt;- Hypsometry$y[iy]       # corresponding latitudes

Col &lt;- createKey(iy)
colorkeymatplot(main = "matplot with color key",
                 xlab = "longitude", ylab = "heigh, m",
                 x = lon, y = Hypsometry$z[,iy], col = Col, type = "l", 
                 colorkey = list(clim = range(lat), clab = "latitude"))  

n &lt;- 100
colorkey.plt(method = "pie", x = rep(1, n), labels = "", 
             col = rainbow(n), border = NA,
             main = "colorkeyplot with 'pie'", 
             colorkey = list(col = rainbow(n), clim = c(1,n)))

## =============================================================================
## A complex figure, consisting of overlays (based on example(boxplot))
## =============================================================================

plotit &lt;- function(){
  boxplot(len ~ dose, data = ToothGrowth,
          boxwex = 0.25, at = 1:3 - 0.2,
          subset = supp == "VC", col = "yellow",
          main = "Guinea Pigs' Tooth Growth",
          xlab = "Vitamin C dose mg", ylab = "tooth length",
          xlim = c(0.5, 3.5), ylim = c(0, 35), yaxs = "i")
  
  boxplot(len ~ dose, data = ToothGrowth, add = TRUE,
          boxwex = 0.25, at = 1:3 + 0.2,
          subset = supp == "OJ", col = "orange")
}
legend.plt(method = "plotit", 
           legend = list(legend = c("Ascorbic acid", "Orange juice"),
                         fill = c("yellow", "orange")))

# All in one - putting legend on other side..
pm &lt;- par(mar = c(4,3,4,2))
legend.plt(formula = len ~ dose:supp, data = ToothGrowth,
           boxwex = 0.5, col = c("orange", "yellow"),
           main = "Guinea Pigs' Tooth Growth",
           xlab = "Vitamin C dose mg", ylab = "tooth length",
           sep = ":", lex.order = TRUE, ylim = c(0, 35), yaxs = "i", 
           method = "boxplot", legend.side = 2, 
           legend = list(legend = c("Ascorbic acid", "Orange juice"),
                         fill = c("yellow", "orange")))
par(mar = pm)

## =============================================================================
## Nesting..
## =============================================================================

Fun1 &lt;- function()
  legend.plt(x = 0, method = "plot", type = "n", xlab = "", ylab = "", axes = FALSE,
             frame.plot = TRUE, 
             legend = list(legend = 
            c("this can", "also be used", "to write text", "next to a plot")))

X &lt;- legend.plt(method = "Fun1", legend.side = 1, 
              legend = list(legend = 
                     c("but also to put text", "below a plot"), 
                     horiz = TRUE, x = "left", box.col = "grey"))

print(X)
P &lt;- par(plt = X$plt.legend, new = TRUE)  
plot.new()
legend("right", legend = "second legend")
par (plt = X$plt.main, new = TRUE)
plot.new()
legend("left", legend = "another legend")

## =============================================================================
## Pairs
## =============================================================================

legendpairs(iris, legend = list(legend = levels(iris$Species), cex = 0.5, col = 1:3, pch = 1), 
    legend.side = 4, col = (1:3)[iris$Species])

legendpairs( iris[1:4], main = "Anderson's Iris Data -- 3 species",
            pch = 21, bg = c("red", "green3", "blue")[unclass(iris$Species)],
            legend.side = 1,
            legend = list(levels(iris$Species), pt.bg = c("red", "green3", "blue"), 
                         pch = 21, title = "Species", horiz = TRUE))

# reset plotting parameters
par(mfrow = pm)
par(mar = pmar)

## Pairs with a color key

colorkeypairs(swiss[,c(1,4,5)], pch = 18, cex = 2, 
    col = createKey(swiss[,2]),
    colorkey=list(clim = range(swiss[,2]), clab = "Agriculture"))

## =============================================================================
## Aligning plots
## =============================================================================

par(mfrow = c(2,1))
AA &lt;- legendplot(1:10, runif(10), xlab = "x", ylab = "y", pch= 18, 
      cex = 2, col = 1:10, 
      legend = list(col = 1:10, legend = 11111:11120, pch = 18, pt.cex = 2))

  legendplot(1:10, runif(10), xlab = "x", ylab = "y", pch= 18, 
      cex = 2, col = 1:10, legend.pars = AA,   # use par settings of previous plot
      legend = list(plot=FALSE))


</code></pre>

<hr>
<h2 id='Scatter+20plots'>
Colored scatter plots and text in 2-D and 3-D
</h2><span id='topic+scatter3D'></span><span id='topic+text3D'></span><span id='topic+points3D'></span><span id='topic+lines3D'></span><span id='topic+scatter2D'></span><span id='topic+points2D'></span><span id='topic+lines2D'></span><span id='topic+text2D'></span>

<h3>Description</h3>

<p><code>scatter2D and scatter3D</code> plot a (2- or 3 dimensional) dataset with a color variable as points or lines.
</p>
<p><code>text3D</code> plot a 3-D dataset with a color variable as text labels.
</p>
<p><code>points3D</code> is shorthand for <code><a href="#topic+scatter3D">scatter3D</a>(..., type = "p")</code>
</p>
<p><code>lines3D</code> is shorthand for <code><a href="#topic+scatter3D">scatter3D</a>(..., type = "l")</code>
</p>
<p><code>points2D</code> is shorthand for <code>scatter2D(..., type = "p")</code>
</p>
<p><code>lines2D</code> is shorthand for <code>scatter2D(..., type = "l")</code>
</p>
<p>The 2D functions are included for their side effect of having a color key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter3D (x, y, z, ..., colvar = z, phi = 40, theta = 40,
           col = NULL, NAcol = "white", breaks = NULL,
           colkey = NULL, panel.first = NULL, 
           clim = NULL, clab = NULL, 
           bty = "b", CI = NULL, surf = NULL, 
           add = FALSE, plot = TRUE)
          
text3D (x, y, z, labels, ..., colvar = NULL, phi = 40, theta = 40,
        col = NULL, NAcol = "white",  breaks = NULL,
        colkey = NULL, panel.first = NULL, 
        clim = NULL, clab = NULL, 
        bty = "b", add = FALSE, plot = TRUE)

points3D (x, y, z, ...)

lines3D (x, y, z, ...)

scatter2D (x, y, ..., colvar = NULL,
         col = NULL, NAcol = "white", breaks = NULL,
         colkey = NULL, clim = NULL, clab = NULL, 
         CI = NULL, add = FALSE, plot = TRUE)

lines2D(x, y, ...)

points2D(x, y, ...)

text2D (x, y, labels, ..., colvar = NULL, 
         col = NULL, NAcol = "white", breaks = NULL, colkey = NULL,
         clim = NULL, clab = NULL, add = FALSE, plot = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Scatter+2B20plots_+3A_x">x</code>, <code id="Scatter+2B20plots_+3A_y">y</code>, <code id="Scatter+2B20plots_+3A_z">z</code></td>
<td>
<p>Vectors with x, y and z-values of the points to be plotted. 
They should be of equal length, and the same length as <code>colvar</code> (if present).
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_colvar">colvar</code></td>
<td>
<p>The variable used for coloring. For <code>scatter3D</code>, it need
not be present, but if specified, it should be a vector of equal length as 
(<code>x, y, z</code>).
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_theta">theta</code>, <code id="Scatter+2B20plots_+3A_phi">phi</code></td>
<td>
<p>the angles defining the viewing direction. 
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude. see <a href="graphics.html#topic+persp">persp</a>.
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_col">col</code></td>
<td>
<p>Color palette to be used for coloring the <code>colvar</code> variable. 
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is specified, 
then a red-yellow-blue colorscheme (<a href="#topic+jet.col">jet.col</a>) will be used.
If <code>col</code> is <code>NULL</code> and <code>colvar</code> is not specified, then 
<code>col</code> will be &quot;black&quot;.    
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_nacol">NAcol</code></td>
<td>
<p>Colors to be used for <code>colvar</code> values that are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_breaks">breaks</code></td>
<td>
<p>a set of finite numeric breakpoints for the colors;
must have one more breakpoint than color and be in increasing order.
Unsorted vectors will be sorted, with a warning.
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_colkey">colkey</code></td>
<td>
<p>A logical, <code>NULL</code> (default), or a <code>list</code> with parameters
for the color key (legend). List parameters should be one of 
<code>side, plot, length, width, dist, shift, addlines, col.clab, cex.clab,
      side.clab, line.clab, adj.clab, font.clab</code>
and the axis parameters <code>at, labels, tick, line, pos, outer, font, lty, lwd,
    lwd.ticks, col.box, col.axis, col.ticks, hadj, padj, cex.axis, mgp, tck, tcl, las</code>.
The defaults for the parameters are <code>side = 4, plot = TRUE, length = 1, width = 1, 
      dist = 0, shift = 0, addlines = FALSE, col.clab = NULL, cex.clab = par("cex.lab"), 
      side.clab = NULL, line.clab = NULL, adj.clab = NULL, font.clab = NULL</code>)
See <a href="#topic+colkey">colkey</a>.
</p>
<p>The default is to draw the color key on side = 4, i.e. in the right margin.
If <code>colkey</code> = <code>NULL</code> then a color key will be added only if <code>col</code> is a vector.
Setting <code>colkey = list(plot = FALSE)</code> will create room for the color key 
without drawing it.
if <code>colkey = FALSE</code>, no color key legend will be added.
</p>
</td></tr> 
<tr><td><code id="Scatter+2B20plots_+3A_ci">CI</code></td>
<td>
<p>A <code>list</code> with parameters and values for the confidence 
intervals or <code>NULL</code>.
If a list it should contain at least the item <code>x</code>, <code>y</code> or <code>z</code> 
(latter for <code>scatter3D</code>). These should be 2-columned matrices, defining the left/right intervals. 
Other parameters should be one of (with defaults):
<code>alen = 0.01, lty = par("lty"), lwd = par("lwd"), col = NULL</code>,
to set the length of the arrow head, the line type and width, and the color.
If <code>col</code> is <code>NULL</code>, then the colors as specified by <code>colvar</code> are used.
See examples.
</p>
</td></tr> 
<tr><td><code id="Scatter+2B20plots_+3A_panel.first">panel.first</code></td>
<td>
<p>A <code>function</code> to be evaluated after the plot axes are 
set up but before any plotting takes place. 
This can be useful for drawing background grids or scatterplot smooths. 
The function should have as argument the transformation matrix, e.g. it should
be defined as <code>function(pmat)</code>. See example of <a href="#topic+persp3D">persp3D</a> and last example of <a href="#topic+voxel3D">voxel3D</a>.
</p>
</td></tr> 
<tr><td><code id="Scatter+2B20plots_+3A_clab">clab</code></td>
<td>
<p>Only if <code>colkey</code> is not <code>NULL</code> or <code>FALSE</code>, 
the label to be written on top of the color key. 
The label will be written at the same level as the main title.
To lower it, <code>clab</code> can be made a vector, with the first values empty 
strings. 
</p>
</td></tr> 
<tr><td><code id="Scatter+2B20plots_+3A_clim">clim</code></td>
<td>
<p>Only if <code>colvar</code> is specified, the range of the color variable, used
for the color key. Values of <code>colvar</code> that extend the range will be put to <code>NA</code>.
</p>
</td></tr> 
<tr><td><code id="Scatter+2B20plots_+3A_bty">bty</code></td>
<td>
<p>The type of the box, the default draws only the back panels.
Only effective if the <a href="graphics.html#topic+persp">persp</a> 
argument (<code>box</code>) equals <code>TRUE</code> (this is the default). See <a href="#topic+perspbox">perspbox</a>.
Note: the <code>bty = "g", "b2", "bl"</code> can also be specified 
for <code>scatter2D</code> (if <code>add = FALSE</code>).
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_labels">labels</code></td>
<td>
<p>The text to be written. A vector of length equal to length of
x, y, z.
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_surf">surf</code></td>
<td>
<p>If not <code>NULL</code>, a list specifying a (fitted) surface to be added on 
the scatterplot. 
The list should include at least <code>x</code>, <code>y</code>, <code>z</code>, defining the surface, 
and optional: <code>colvar, col, NAcol, border, facets, 
    lwd, resfac, clim, ltheta, lphi, shade, lighting, fit</code>. Note that the default is 
that <code>colvar</code> is not specified which will set <code>colvar = z</code>.
The argument <code>fit</code> should give the fitted z-values, in the same order as the 
z-values of the scatter points, for instance produced by <code>predict</code>. 
When present, this will produce droplines from points to the fitted surface.
</p>
</td></tr>
<tr><td><code id="Scatter+2B20plots_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the points will be added to the current plot.
If <code>FALSE</code> a new plot is started. 
</p>
</td></tr> 
<tr><td><code id="Scatter+2B20plots_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a plot is created, 
otherwise (for 3D plots) the viewing transformation matrix is returned (as invisible). 
</p>
</td></tr> 
<tr><td><code id="Scatter+2B20plots_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the plotting methods. 
</p>
<p>The following <a href="graphics.html#topic+persp">persp</a> arguments can be specified: 
<code>xlim, ylim, zlim, xlab, ylab, zlab, main, sub, r, d, 
    scale, expand, box, axes, nticks, ticktype</code>.      
The arguments <code>xlim</code>, <code>ylim</code>, <code>zlim</code> only affect the axes for 3D plots.
All objects will be plotted, including those that fall out of these ranges.
To select objects only within the axis limits, use <a href="#topic+plotdev">plotdev</a>.
</p>
<p>In addition, the <a href="#topic+perspbox">perspbox</a> arguments
<code>col.axis, col.panel, lwd.panel, col.grid, lwd.grid</code> can 
also be given a value.
</p>
<p><code>shade</code> and <code>lighting</code> arguments will have no effect.
</p>
<p><code>alpha</code> can be given a value inbetween 0 and 1 to make colors transparent.
</p>
<p>For all functions, the arguments <code>lty, lwd</code> can be specified; <code>type</code>
can be specified for all except <code>text3D</code>.
</p>
<p>In case <code>type = "p"</code> or <code>"b"</code>, then <code>pch, cex, bg</code> can also be specified.
</p>
<p>The arguments after ... must be matched exactly.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>scatter3D</code> returns the viewing transformation matrix.
See <a href="#topic+trans3D">trans3D</a>.
</p>


<h3>Note</h3>

<p>For <code>scatter2D</code> and <code>scatter3D</code> the plottypes that are supported 
are: <code>type = "p"</code>,  <code>type = "l"</code>, <code>type = "h"</code>,
<code>type = "o"</code>. For <code>type = "b"</code>,  <code>type = "o"</code> is used instead.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="graphics.html#topic+persp">persp</a> for the function on which this implementation is based.
</p>
<p><a href="#topic+mesh">mesh</a>, <a href="#topic+trans3D">trans3D</a>, <code>slice3D</code>, for other examples of 
<code>scatter2D</code> or <code>scatter3D</code>.
</p>
<p><a href="#topic+plotdev">plotdev</a> for zooming, rescaling, rotating a plot.
</p>
<p>package <code>scatterplot3D</code> for an implementation of scatterplots that is 
not based on <code>persp</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># save plotting parameters
 pm &lt;- par("mfrow")

 
## =======================================================================
## A sphere 
## =======================================================================

 par(mfrow = c(1, 1))
 M  &lt;- mesh(seq(0, 2*pi, length.out = 100), 
            seq(0,   pi, length.out = 100))
 u  &lt;- M$x ; v  &lt;- M$y

 x &lt;- cos(u)*sin(v)
 y &lt;- sin(u)*sin(v)
 z &lt;- cos(v)

# full  panels of box are drawn (bty = "f")
 scatter3D(x, y, z, pch = ".", col = "red", 
           bty = "f", cex = 2, colkey = FALSE)

## =======================================================================
## Different types
## =======================================================================

 par (mfrow = c(2, 2))
 z &lt;- seq(0, 10, 0.2)
 x &lt;- cos(z)
 y &lt;- sin(z)*z

# greyish background for the boxtype (bty = "g") 
 scatter3D(x, y, z, phi = 0, bty = "g",
           pch = 20, cex = 2, ticktype = "detailed")
# add another point
 scatter3D(x = 0, y = 0, z = 0, add = TRUE, colkey = FALSE, 
           pch = 18, cex = 3, col = "black")

# add text
 text3D(x = cos(1:10), y = (sin(1:10)*(1:10) - 1), 
        z = 1:10, colkey = FALSE, add = TRUE, 
        labels = LETTERS[1:10], col = c("black", "red"))

# line plot
 scatter3D(x, y, z, phi = 0, bty = "g", type = "l", 
           ticktype = "detailed", lwd = 4)

# points and lines
 scatter3D(x, y, z, phi = 0, bty = "g", type = "b", 
           ticktype = "detailed", pch = 20, 
           cex = c(0.5, 1, 1.5))

# vertical lines
 scatter3D(x, y, z, phi = 0, bty = "g",  type = "h", 
           ticktype = "detailed")

## =======================================================================
## With confidence interval
## =======================================================================

 x &lt;- runif(20)
 y &lt;- runif(20)
 z &lt;- runif(20)

 par(mfrow = c(1, 1))
 CI &lt;- list(z = matrix(nrow = length(x), ncol = 2,
                       data = rep(0.05, times = 2*length(x))))

# greyish background for the boxtype (bty = "g")
 scatter3D(x, y, z, phi = 0, bty = "g", CI = CI,
   col = gg.col(100), pch = 18, cex = 2, ticktype = "detailed",
   xlim = c(0, 1), ylim = c(0, 1), zlim = c(0, 1))

# add new set of points
 x &lt;- runif(20)
 y &lt;- runif(20)
 z &lt;- runif(20)

 CI2 &lt;- list(x = matrix(nrow = length(x), ncol = 2,
                       data = rep(0.05, 2*length(x))),
             z = matrix(nrow = length(x), ncol = 2,
                       data = rep(0.05, 2*length(x))))

 scatter3D(x, y, z, CI = CI2, add = TRUE, col = "red", pch = 16)

## =======================================================================
## With a surface
## =======================================================================

 par(mfrow = c(1, 1))
 
# surface = volcano
 M &lt;- mesh(1:nrow(volcano), 1:ncol(volcano))

# 100 points above volcano 
 N  &lt;- 100
 xs &lt;- runif(N) * 87
 ys &lt;- runif(N) * 61
 zs &lt;- runif(N)*50 + 154
  
# scatter + surface
 scatter3D(xs, ys, zs, ticktype = "detailed", pch = 16, 
   bty = "f", xlim = c(1, 87), ylim = c(1,61), zlim = c(94, 215), 
   surf = list(x = M$x, y = M$y, z = volcano,  
               NAcol = "grey", shade = 0.1))
 
## =======================================================================
## A surface and CI
## =======================================================================

 par(mfrow = c(1, 1))
 M &lt;- mesh(seq(0, 2*pi, length = 30), (1:30)/100)
 z &lt;- with (M, sin(x) + y)
 
# points 'sampled'
 N &lt;- 30
 xs &lt;- runif(N) * 2*pi
 ys &lt;- runif(N) * 0.3

 zs &lt;- sin(xs) + ys + rnorm(N)*0.3
 
 CI &lt;- list(z = matrix(nrow = length(xs), 
                       data = rep(0.3, 2*length(xs))),
            lwd = 3)
  
# facets = NA makes a transparent surface; borders are black
 scatter3D(xs, ys, zs, ticktype = "detailed", pch = 16, 
   xlim = c(0, 2*pi), ylim = c(0, 0.3), zlim = c(-1.5, 1.5), 
   CI = CI, theta = 20, phi = 30, cex = 2,
   surf = list(x = M$x, y = M$y, z = z, border = "black", facets = NA)
   )

## =======================================================================
## droplines till the fitted surface
## =======================================================================

 with (mtcars, {

  # linear regression
   fit &lt;- lm(mpg ~ wt + disp)

  # predict values on regular xy grid
   wt.pred &lt;- seq(1.5, 5.5, length.out = 30)
   disp.pred &lt;- seq(71, 472, length.out = 30)
   xy &lt;- expand.grid(wt = wt.pred, 
                     disp = disp.pred)

   mpg.pred &lt;- matrix (nrow = 30, ncol = 30, 
      data = predict(fit, newdata = data.frame(xy), 
      interval = "prediction")[,1])

# fitted points for droplines to surface
   fitpoints &lt;- predict(fit) 

   scatter3D(z = mpg, x = wt, y = disp, pch = 18, cex = 2, 
      theta = 20, phi = 20, ticktype = "detailed",
      xlab = "wt", ylab = "disp", zlab = "mpg",  
      surf = list(x = wt.pred, y = disp.pred, z = mpg.pred,  
                  facets = NA, fit = fitpoints),
      main = "mtcars")
  
 })

## =======================================================================
## Two ways to make a scatter 3D of quakes data set
## =======================================================================

 par(mfrow = c(1, 1)) 
# first way, use vertical spikes (type = "h")
 with(quakes, scatter3D(x = long, y = lat, z = -depth, colvar = mag, 
      pch = 16, cex = 1.5, xlab = "longitude", ylab = "latitude", 
      zlab = "depth, km", clab = c("Richter","Magnitude"),
      main = "Earthquakes off Fiji", ticktype = "detailed", 
      type = "h", theta = 10, d = 2, 
      colkey = list(length = 0.5, width = 0.5, cex.clab = 0.75))
      )

# second way: add dots on bottom and left panel
# before the scatters are drawn, 
# add small dots on basal plane and on the depth plane
 panelfirst &lt;- function(pmat) {
    zmin &lt;- min(-quakes$depth)
    XY &lt;- trans3D(quakes$long, quakes$lat, 
                  z = rep(zmin, nrow(quakes)), pmat = pmat)
    scatter2D(XY$x, XY$y, colvar = quakes$mag, pch = ".", 
            cex = 2, add = TRUE, colkey = FALSE)
 
    xmin &lt;- min(quakes$long)
    XY &lt;- trans3D(x = rep(xmin, nrow(quakes)), y = quakes$lat, 
                  z = -quakes$depth, pmat = pmat)
    scatter2D(XY$x, XY$y, colvar = quakes$mag, pch = ".", 
            cex = 2, add = TRUE, colkey = FALSE)
 }

 with(quakes, scatter3D(x = long, y = lat, z = -depth, colvar = mag, 
      pch = 16, cex = 1.5, xlab = "longitude", ylab = "latitude", 
      zlab = "depth, km", clab = c("Richter","Magnitude"),
      main = "Earthquakes off Fiji", ticktype = "detailed", 
      panel.first = panelfirst, theta = 10, d = 2, 
      colkey = list(length = 0.5, width = 0.5, cex.clab = 0.75))
      )

## =======================================================================
## text3D and scatter3D
## =======================================================================

 with(USArrests, text3D(Murder, Assault, Rape, 
    colvar = UrbanPop, col = gg.col(100), theta = 60, phi = 20,
    xlab = "Murder", ylab = "Assault", zlab = "Rape", 
    main = "USA arrests", 
    labels = rownames(USArrests), cex = 0.6, 
    bty = "g", ticktype = "detailed", d = 2,
    clab = c("Urban","Pop"), adj = 0.5, font = 2))

 with(USArrests, scatter3D(Murder, Assault, Rape - 1, 
    colvar = UrbanPop, col = gg.col(100), 
    type = "h", pch = ".", add = TRUE))

## =======================================================================
## zoom near origin
## =======================================================================

# display axis ranges
 getplist()[c("xlim","ylim","zlim")] 

# choose suitable ranges
 plotdev(xlim = c(0, 10), ylim = c(40, 150), 
         zlim = c(7, 25))

## =======================================================================
## text3D to label x- and y axis
## =======================================================================

 par(mfrow = c(1, 1))
 hist3D (x = 1:5, y = 1:4, z = VADeaths,
        bty = "g", phi = 20,  theta = -60,
        xlab = "", ylab = "", zlab = "", main = "VADeaths",
        col = "#0072B2", border = "black", shade = 0.8,
        ticktype = "detailed", space = 0.15, d = 2, cex.axis = 1e-9)

 text3D(x = 1:5, y = rep(0.5, 5), z = rep(3, 5),
       labels = rownames(VADeaths),
       add = TRUE, adj = 0)
 text3D(x = rep(1, 4),   y = 1:4, z = rep(0, 4),
       labels  = colnames(VADeaths),
       add = TRUE, adj = 1)

## =======================================================================
## Scatter2D; bty can also be set = to one of the perspbox alernatives
## =======================================================================

 par(mfrow = c(2, 2))
 x &lt;- seq(0, 2*pi, length.out = 30)

 scatter2D(x, sin(x), colvar = cos(x), pch = 16, 
         ylab = "sin", clab = "cos", cex = 1.5)
# other box types:
 scatter2D(x, sin(x), colvar = cos(x), type = "l", lwd = 4, bty = "g")
 scatter2D(x, sin(x), colvar = cos(x), type = "b", lwd = 2, bty = "b2")
# transparent colors and spikes
 scatter2D(x, sin(x), colvar = cos(x), type = "h", lwd = 4, alpha = 0.5)
  
## =======================================================================
## mesh examples and scatter2D
## =======================================================================

 par(mfrow = c(1, 2))
 x &lt;- seq(-1, 1, by = 0.1)
 y &lt;- seq(-2, 2, by = 0.2)

 grid &lt;- mesh(x, y)
 z    &lt;- with(grid, cos(x) * sin(y))
 image2D(z, x = x, y = y)
 points(grid)
 scatter2D(grid$x, grid$y, colvar = z, pch = 20, cex = 2)

## =======================================================================
## scatter plot with confidence intervals
## =======================================================================

 par(mfrow = c(2, 2))
 x  &lt;- sort(rnorm(10)) 
 y  &lt;- runif(10)
 cv &lt;- sqrt(x^2 + y^2)

 CI &lt;- list(lwd = 2)
 CI$x &lt;- matrix (nrow = length(x), ncol = 2, data = rep(0.25, 2*length(x)))
 scatter2D(x, y, colvar = cv, pch = 16, cex = 2, CI = CI)
 scatter2D(x, y, colvar = cv, pch = 16, cex = 2, CI = CI, type = "b")

 CI$y &lt;- matrix (nrow = length(x), ncol = 2, data = rep(0.05, 2*length(x)))
 CI$col &lt;- "black"
 scatter2D(x, y, colvar = cv, pch = 16, cex = 2, CI = CI)

 CI$y[c(2,4,8,10), ] &lt;- NA  # Some points have no CI
 CI$x[c(2,4,8,10), ] &lt;- NA  # Some points have no CI
 CI$alen &lt;- 0.02            # increase arrow head
 scatter2D(x, y, colvar = cv, pch = 16, cex = 2, CI = CI)

## =======================================================================
## Scatter on an image
## =======================================================================
 
 par(mfrow = c(1, 1))
# image of oxygen saturation
 oxlim &lt;- range(Oxsat$val[,,1], na.rm  = TRUE) 
 image2D(z = Oxsat$val[,,1], x = Oxsat$lon, y = Oxsat$lat,
       contour = TRUE, 
       xlab = "longitude", ylab = "latitude", 
       main = "Oxygen saturation", clim = oxlim, clab = "%")

# (imaginary) measurements at 5 sites
 lon   &lt;- c( 11.2,   6.0, 0.9,  -4, -8.8)
 lat   &lt;- c(-19.7,-14.45,-9.1,-3.8, -1.5)
 O2sat &lt;- c(   90,    95,  92,  85,  100)
               
# add to image; use same zrange; avoid adding  a color key
 scatter2D(colvar = O2sat, x = lon, y = lat, clim = oxlim, pch = 16,
         add = TRUE, cex = 2, colkey = FALSE)

## =======================================================================
## Scatter on a contourplot
## =======================================================================

 par(mfrow = c(1, 1))

# room for colorkey by setting colkey = list(plot = FALSE)

# contour plot of the ocean's bathymetry
 Depth &lt;- Hypsometry$z
 Depth[Depth &gt; 0] &lt;- NA
 contour2D(z = Depth, x = Hypsometry$x, y = Hypsometry$y, 
       xlab = "longitude", ylab = "latitude", 
       col = "black", NAcol = "grey", levels = seq(-6000, 0, by = 2000),
       main = "Oxygen saturation along ship track", 
       colkey = list(plot = FALSE))

# add data to image; with  a color key
 scatter2D(colvar = O2sat, x = lon, y = lat, pch = 16,
         add = TRUE, cex = 2, clab = "%")

## =======================================================================
## scatter2D for time-series plots
## =======================================================================

# Plotting sunspot 'anomalies'
sunspot &lt;- data.frame(year = time(sunspot.month), 
  anom = sunspot.month - mean(sunspot.month))

# long-term moving average of anomaly
ff &lt;- 100
sunspot$ma &lt;- filter(sunspot$anom, rep(1/ff, ff), sides = 2)

with (sunspot, lines2D(year, anom, 
  colvar = anom &gt; 0, 
  col = c("pink", "lightblue"),
  main = "sunspot anomaly", type = "h", 
  colkey = FALSE, las = 1, xlab = "year", ylab = ""))
lines2D(sunspot$year, sunspot$ma, add = TRUE)  

# The same
#with (sunspot, plot(year, anom, 
#  col = c("pink", "lightblue")[(anom &gt; 0) + 1],
#  main = "sunspot", type = "h", las = 1))

# but this does not work due to NAs...  
# lines(sunspot$year, sunspot$ma)  

## =======================================================================
## text2D
## =======================================================================

 with(USArrests, text2D(x = Murder, y = Assault + 5, colvar = Rape, 
     xlab = "Murder", ylab = "Assault", clab = "Rape", 
     main = "USA arrests", labels = rownames(USArrests), cex = 0.6, 
     adj = 0.5, font = 2))

 with(USArrests, scatter2D(x = Murder, y = Assault, colvar = Rape, 
     pch = 16, add = TRUE, colkey = FALSE))

# reset plotting parameters
 par(mfrow = pm)
</code></pre>

<hr>
<h2 id='trans3D'>
Transformation of 3D elements
</h2><span id='topic+trans3D'></span>

<h3>Description</h3>

<p><code>trans3D</code> is the <code>plot3D</code> equivalent of <a href="grDevices.html#topic+trans3d">trans3d</a>, that projects
3-D elements to 2 dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans3D (x, y, z, pmat) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans3D_+3A_x">x</code>, <code id="trans3D_+3A_y">y</code>, <code id="trans3D_+3A_z">z</code></td>
<td>
<p>Vectors, matrices, arrays, with x, y and z-values. 
</p>
</td></tr>
<tr><td><code id="trans3D_+3A_pmat">pmat</code></td>
<td>
<p>A 4 x 4 viewing transformation matrix, suitable for projecting 
the 3D coordinates (x,y,z) into the 2D plane using homogeneous 
4D coordinates (x,y,z,t); such matrices are returned by any of the 3-D
plotting functions from package <code>plot3D</code> and by <a href="graphics.html#topic+persp">persp</a>().
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components:
</p>
<table>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>the projected 2-D coordinates of the 3-D input <code>x, y, z</code></p>
</td></tr>
</table>
<p>In contrast to <a href="grDevices.html#topic+trans3d">trans3d</a>, <code>trans3D</code> the returned values x and y 
will be of the same class and dimensions as the input x and y.
If inputted <code>x, y, z</code> are matrices or arrays, so will the projected
coordinates be.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+scatter3D">scatter3D</a>, <a href="#topic+slice3D">slice3D</a>, <a href="#topic+surf3D">surf3D</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ========================================================================
## 3-D mesh
## ========================================================================

 x &lt;- y &lt;- z &lt;- c(-1 , 0, 1)

# plot a 3-D mesh
 (M &lt;- mesh(x, y, z))

# plot result
 pmat &lt;- scatter3D(M$x, M$y, M$z, pch = "+", cex = 3, colkey = FALSE)

# add line
 XY &lt;- trans3D(x = c(-1, 1), y = c(-1, 1), z = c(-1, 1), pmat = pmat) 
 lines(XY, lwd = 2, col = "blue")

## ========================================================================
## Example 2
## ========================================================================

 pmat &lt;- perspbox (z = diag(2))
 XY &lt;- trans3D(x = runif(30), y = runif(30), z = runif(30), pmat = pmat) 
 polygon(XY, col = "darkblue")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
