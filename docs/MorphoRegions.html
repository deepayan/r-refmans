<!DOCTYPE html><html lang="en"><head><title>Help for package MorphoRegions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MorphoRegions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MorphoRegions-package'><p>MorphoRegions: Analysis of Regionalization Patterns in Serially Homologous Structures</p></a></li>
<li><a href='#alligator'><p>Measurements from the vertebral column of an alligator</p></a></li>
<li><a href='#calcBPvar'><p>Calculate variability of breakpoints</p></a></li>
<li><a href='#calcmodel'><p>Calculate results of a single segmented regression model</p></a></li>
<li><a href='#calcregions'><p>Fit segmented regression models for all combinations of breakpoints</p></a></li>
<li><a href='#dolphin'><p>Measurements from the vertebral column of a dolphin</p></a></li>
<li><a href='#modelperf'><p>Assess model performance</p></a></li>
<li><a href='#modelselect'><p>Select the best models</p></a></li>
<li><a href='#modelsupport'><p>Evaluate model support</p></a></li>
<li><a href='#musm'><p>Measurements from the vertebral column of a mouse</p></a></li>
<li><a href='#PCOload'><p>Calculate PCO loadings</p></a></li>
<li><a href='#PCOselect'><p>Select PCO scores</p></a></li>
<li><a href='#plot.regions_pco'><p>Plot PCO axes</p></a></li>
<li><a href='#plotsegreg'><p>Plot a segmented regression model</p></a></li>
<li><a href='#plotvertmap'><p>Plot a vertebra map</p></a></li>
<li><a href='#porpoise'><p>Measurements from the vertebral column of three porpoises</p></a></li>
<li><a href='#process_measurements'><p>Process vertebra measurements</p></a></li>
<li><a href='#simregions'><p>Simulate regions data</p></a></li>
<li><a href='#subsample'><p>Subsample a dataset</p></a></li>
<li><a href='#svdPCO'><p>Calculate PCO (principal co-ordinates analysis) based on SVD</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Regionalization Patterns in Serially Homologous
Structures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the optimal number of regions (or subdivisions) and 
    their position in serial structures without a priori assumptions and to visualize 
    the results. After reducing data dimensionality with the built-in function for
    data ordination, regions are fitted as segmented linear regressions
    along the serial structure. Every region boundary
    position and increasing number of regions are iteratively fitted and
    the best model (number of regions and boundary positions) is selected
    with an information criterion. This package expands on the previous
    'regions' package (Jones et al., Science 2018) with improved
    computation and more fitting and plotting options.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, parallel, utils, grDevices, RColorBrewer (&ge; 1.1-3),
cluster (&ge; 2.1.4), scales (&ge; 1.3.0), ggplot2 (&ge; 3.5.1), chk
(&ge; 0.9.0), pbapply (&ge; 1.7-2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>viridisLite, patchwork (&ge; 1.1.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://aagillet.github.io/MorphoRegions/">https://aagillet.github.io/MorphoRegions/</a>,
<a href="https://github.com/aagillet/MorphoRegions">https://github.com/aagillet/MorphoRegions</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aagillet/MorphoRegions/issues">https://github.com/aagillet/MorphoRegions/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-16 09:17:48 UTC; Amandine Gillet</td>
</tr>
<tr>
<td>Author:</td>
<td>Amandine Gillet <a href="https://orcid.org/0000-0001-9763-6061"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Katrina Jones <a href="https://orcid.org/0000-0003-1088-0497"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Noah Greifer <a href="https://orcid.org/0000-0003-3067-7154"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Stephanie Pierce <a href="https://orcid.org/0000-0003-0717-1841"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Amandine Gillet &lt;gillet.aman@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-21 12:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='MorphoRegions-package'>MorphoRegions: Analysis of Regionalization Patterns in Serially Homologous Structures</h2><span id='topic+MorphoRegions'></span><span id='topic+MorphoRegions-package'></span>

<h3>Description</h3>

<p>Computes the optimal number of regions (or subdivisions) and their position in serial structures without a priori assumptions and to visualize the results. After reducing data dimensionality with the built-in function for data ordination, regions are fitted as segmented linear regressions along the serial structure. Every region boundary position and increasing number of regions are iteratively fitted and the best model (number of regions and boundary positions) is selected with an information criterion. This package expands on the previous 'regions' package (Jones et al., Science 2018) with improved computation and more fitting and plotting options.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Noah Greifer <a href="mailto:ngreifer@iq.harvard.edu">ngreifer@iq.harvard.edu</a> (<a href="https://orcid.org/0000-0003-3067-7154">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Amandine Gillet <a href="mailto:gillet.aman@gmail.com">gillet.aman@gmail.com</a> (<a href="https://orcid.org/0000-0001-9763-6061">ORCID</a>)
</p>
</li>
<li><p> Katrina Jones <a href="mailto:katrina.jones@manchester.ac.uk">katrina.jones@manchester.ac.uk</a> (<a href="https://orcid.org/0000-0003-1088-0497">ORCID</a>)
</p>
</li>
<li><p> Stephanie Pierce <a href="mailto:spierce@oeb.harvard.edu">spierce@oeb.harvard.edu</a> (<a href="https://orcid.org/0000-0003-0717-1841">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://aagillet.github.io/MorphoRegions/">https://aagillet.github.io/MorphoRegions/</a>
</p>
</li>
<li> <p><a href="https://github.com/aagillet/MorphoRegions">https://github.com/aagillet/MorphoRegions</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/aagillet/MorphoRegions/issues">https://github.com/aagillet/MorphoRegions/issues</a>
</p>
</li></ul>


<hr>
<h2 id='alligator'>Measurements from the vertebral column of an alligator</h2><span id='topic+alligator'></span>

<h3>Description</h3>

<p>Linear and angular measurements from Alligator mississipiensis MCZ 81457
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alligator
</code></pre>


<h3>Format</h3>

<p>A matrix with 22 vertebrae and 19 measurements. Column 1, vertebra, is the positional
information.
</p>

<hr>
<h2 id='calcBPvar'>Calculate variability of breakpoints</h2><span id='topic+calcBPvar'></span>

<h3>Description</h3>

<p><code>calcBPvar()</code> computes an estimate of the variability of the breakpoints for a given number of regions. This involves computing the weighted mean and standard deviation of each breakpoint using Akaike weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBPvar(regions_results, noregions, pct = 0.05, criterion = "aic")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcBPvar_+3A_regions_results">regions_results</code></td>
<td>
<p>a <code>regions_results</code> object; the output of a call to <code><a href="#topic+calcregions">calcregions()</a></code> or <code><a href="#topic+addregions">addregions()</a></code>.</p>
</td></tr>
<tr><td><code id="calcBPvar_+3A_noregions">noregions</code></td>
<td>
<p>the number of regions for which the weighted mean and standard deviation are to be computed.</p>
</td></tr>
<tr><td><code id="calcBPvar_+3A_pct">pct</code></td>
<td>
<p>the proportion of best model to keep from the original total number of possible models</p>
</td></tr>
<tr><td><code id="calcBPvar_+3A_criterion">criterion</code></td>
<td>
<p>string; the criterion used to compute the weights. Allowable options include <code>"aic"</code> and <code>"bic"</code>. Abbreviations allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>regions_BPvar</code> object, which has two components:
</p>

<ul>
<li> <p><code>WeightedBP</code> is a matrix containing the weighted mean and standard deviation of each breakpoint
</p>
</li>
<li> <p><code>BestModels</code> is a data frame containing the models used to compute the weighted breakpoint statistics and the weights each one is given.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+calcregions">calcregions()</a></code> for fitting segmented regression models to all combinations of breakpoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Fit segmented regression models for 1 to 7 regions
# using PCOs 1 to 4 and a continuous model with a
# exhaustive search
regionresults &lt;- calcregions(alligator_PCO,
                             scores = 1:4,
                             noregions = 7,
                             minvert = 3,
                             cont = TRUE,
                             exhaus = TRUE,
                             verbose = FALSE)

# Compute Akaike-weighted location and SD of optimal
# breakpoints using top 10% of models with 4 regions
calcBPvar(regionresults, noregions = 4,
          pct = .1, criterion = "aic")
</code></pre>

<hr>
<h2 id='calcmodel'>Calculate results of a single segmented regression model</h2><span id='topic+calcmodel'></span>

<h3>Description</h3>

<p><code>calcmodel()</code> fits a multivariate segmented regression model using the supplied PCOs and breakpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcmodel(x, scores, bps, cont = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcmodel_+3A_x">x</code></td>
<td>
<p>a <code>regions_pco</code> object; the output of a call to <code>svdPCO()</code>.</p>
</td></tr>
<tr><td><code id="calcmodel_+3A_scores">scores</code></td>
<td>
<p><code>numeric</code>; the indices of the PCO scores to use as the outcomes in fitting the model (e.g., <code>1:4</code> to use the first four scores).</p>
</td></tr>
<tr><td><code id="calcmodel_+3A_bps">bps</code></td>
<td>
<p><code>numeric</code>; the indices of the breakpoints to use in fitting the model. To request a model with no breakpoints, set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="calcmodel_+3A_cont">cont</code></td>
<td>
<p><code>logical</code>; whether to fit a model that is continuous (<code>TRUE</code>) or discontinuous (<code>FALSE</code>) at the breakpoints. Default is <code>TRUE</code>. Ignored when <code>bps</code> is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>regions_results_single</code> object, which contains the results of the model (breakpoints and RSS of each PCO and overall) and model support statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcregions">calcregions()</a></code> and <code><a href="#topic+addregions">addregions()</a></code> for computing all possible models instead of just a single one; <code><a href="#topic+plotsegreg">plotsegreg()</a></code>, for which the <code>plot</code> method is an alias, for plotting the fitted regression lines; <code><a href="#topic+modelsupport">modelsupport()</a></code> for interpreting the model support statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Calculate a single segmented regression model
# using first 2 PCOs and a discontinuous model
regionsmodel &lt;- calcmodel(alligator_PCO,
                          scores = 1:3,
                          bps = c(8, 16, 21),
                          cont = FALSE)

regionsmodel

#Evaluate performance (R2) on that model
modelperf(regionsmodel)

#Plot model results:
plotsegreg(regionsmodel, scores = 1:3)
</code></pre>

<hr>
<h2 id='calcregions'>Fit segmented regression models for all combinations of breakpoints</h2><span id='topic+calcregions'></span><span id='topic+addregions'></span><span id='topic+summary.regions_results'></span><span id='topic+ncombos'></span>

<h3>Description</h3>

<p><code>calcregions()</code> enumerates all possible combinations of breakpoints to fit multivariate segmented regression models. <code>addregions()</code> adds models with additional numbers of regions to the resulting output object. <code>ncombos()</code> computes an upper bound on the number of breakpoint combinations that will be tested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcregions(
  pco,
  scores,
  noregions,
  minvert = 3,
  cont = TRUE,
  exhaus = TRUE,
  includebp = NULL,
  omitbp = NULL,
  ncombos_file_trigger = 1e+07,
  temp_file_dir = tempdir(TRUE),
  cl = NULL,
  verbose = TRUE
)

addregions(
  regions_results,
  noregions,
  exhaus = TRUE,
  ncombos_file_trigger = 1e+07,
  temp_file_dir = tempdir(TRUE),
  cl = NULL,
  verbose = TRUE
)

## S3 method for class 'regions_results'
summary(object, ...)

ncombos(pco, noregions, minvert = 3, includebp = NULL, omitbp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcregions_+3A_pco">pco</code></td>
<td>
<p>a <code>regions_pco</code> object; the output of a call to <code><a href="#topic+svdPCO">svdPCO()</a></code>.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_scores">scores</code></td>
<td>
<p><code>numeric</code>; the indices of the PCO scores to use as the outcomes in fitting the models (e.g., <code>1:4</code> to use the first four scores). Can also be the output of a call to <code><a href="#topic+PCOselect">PCOselect()</a></code>.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_noregions">noregions</code></td>
<td>
<p><code>numeric</code>; for <code>calcregions()</code>, the maximum number of regions for which models are fit (e.g, 4 to request models with 1 to 4 regions); for <code>addregions()</code>, a vector containing the numbers of regions to add (e.g., 5:6 to request models with 5 and 6 regions); for <code>ncombos()</code>, a vector containing the numbers of regions to check.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_minvert">minvert</code></td>
<td>
<p><code>numeric</code>; the minimum number of vertebrae allowed in each region. Default is 3.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_cont">cont</code></td>
<td>
<p><code>logical</code>; whether to fit models that are continuous (<code>TRUE</code>) or discontinuous (<code>FALSE</code>) at the breakpoints. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_exhaus">exhaus</code></td>
<td>
<p><code>logical</code>; whether to fit all possible models (<code>TRUE</code>) or use heuristics to reduce the number of models fit (<code>FALSE</code>). Default is <code>TRUE</code>. See Details. Setting to <code>FALSE</code> can reduce the size of the resulting object.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_includebp">includebp</code></td>
<td>
<p>an optional vector of vertebrae that must be included in any tested set of breakpoints, e.g., if it is known that two regions are divided at that vertebra. <code>includebp</code> does not have to obey the <code>minvert</code> rules, but a warning will be thrown if it doesn't.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_omitbp">omitbp</code></td>
<td>
<p>an optional vector of vertebrae to be omitted from the list of possible breakpoints, e.g., if it is known that two adjacent vertebrae belong to the same region.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_ncombos_file_trigger">ncombos_file_trigger</code></td>
<td>
<p><code>numeric</code>; when the number of eligible combinations of breakpoints exceeds this number, the problem will be split into smaller problems, with the results of each stored in its own temporary file in the directory supplied to <code>temp_file_dir</code> before being re-read into memory. The primary purpose of this is to preserve memory when <code>exhaus = FALSE</code> by delegating storage of the results to disk instead of RAM.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_temp_file_dir">temp_file_dir</code></td>
<td>
<p>string; the directory where the temporary files will be saved (and then deleted) when the number of breakpoint combinations exceeds <code>ncombos_file_trigger</code>. Default is the directory produced by <code><a href="base.html#topic+tempdir">tempdir()</a></code>, but it is much safer to provide your own directory, which must already exist on your machine. See Details.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_cl">cl</code></td>
<td>
<p>a cluster object created by <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>, an integer to indicate number of child-processes (integer values are ignored on Windows) for parallel evaluations, or <code>"future"</code> to use a future backend. <code>NULL</code> (the default) refers to sequential evaluation (no parallelization). See <code><a href="pbapply.html#topic+pbapply">pbapply::pbapply()</a></code> for details.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code>; whether to print information about the fitting process, including a progress bar. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_regions_results">regions_results</code>, <code id="calcregions_+3A_object">object</code></td>
<td>
<p>a <code>regions_results</code> object; the output of a call to <code>calcregions()</code> or <code>addregions()</code>.</p>
</td></tr>
<tr><td><code id="calcregions_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calcregions()</code> enumerates all possible combinations of breakpoints that satisfy the constraint imposed by <code>minvert</code> (i.e., that breakpoints need to be at least <code>minvert</code> vertebrae apart) and fits the segmented regression models implied by each combination. These are multivariate regression models with the PCO scores specified by <code>scores</code> as the outcomes. When <code>cont = TRUE</code>, these regression models are continuous; i.e., the regression lines for each region connect at the breakpoints. Otherwise, the models are discontinuous so that each region has its own intercept and slope. The models are fit using <code><a href="stats.html#topic+.lm.fit">.lm.fit()</a></code>, which efficiently implements ordinary least squares regression.
</p>
<p>When <code>exhaus = FALSE</code>, heuristics are used to reduce the number of models to fit, which can be useful for keeping the size of the resulting object down by avoiding fitting models corresponding to breakpoint combinations that yield a poor fit to the data. Only breakpoint combinations that correspond to the breakpoints of the best fitting model with a smaller number of regions +/- 3 vertebrae are used, and only models that have an RSS smaller than half a standard deviation more the smallest RSS are kept.
</p>
<p><code>addregions()</code> should be used on an existing <code>regions_results</code> object to add models with more regions. Internally, it works just the same as <code>calcregions()</code>.
</p>
<p><code>ncomobs()</code> computes an upper bound on the number of possible breakpoint combinations. When <code>exhaus = FALSE</code> or <code>includebp</code> is specified, the actual number of combinations will be smaller than that produced by <code>ncombos()</code>.
</p>
<p>When the number of possible combinations of breakpoints for a given number of regions (as computed by <code>ncombos()</code>) is larger than <code>ncombos_file_trigger</code>, the problem will be split into smaller problems, with the results of each stored in temporary files that are deleted when the function completes. These temporary files will be stored in the directory supplied to <code>temp_file_dir</code>. By default, this is the temporary directory produced by <code><a href="base.html#topic+tempdir">tempdir()</a></code>. However, this directory can be deleted by R at any time without warning, which will cause the function to crash, so it is a good idea to supply your own directory that will be preserved. You can use <code>ncombos()</code> to check to see if the number of breakpoint combinations exceeds <code>ncombos_file_trigger</code>.
</p>


<h3>Value</h3>

<p>A <code>regions_results</code> object with the following components:
</p>

<ul>
<li> <p><code>results</code> - the results of the fitting process for each combination of breakpoints
</p>
</li>
<li> <p><code>stats</code> - statistics summarizing the fitting process. Use <code>summary()</code> to view this information in a clean format.
</p>
</li></ul>

<p><code>ncombos()</code> returns a numeric vector with the number of breakpoint combinations for each number of regions (which are stored as the names).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcmodel">calcmodel()</a></code> to fit a segmented regression model for a single set of breakpoints; <code><a href="#topic+modelselect">modelselect()</a></code> to select the best model for each number of regions based on RSS; <code><a href="#topic+modelsupport">modelsupport()</a></code> to compute statistics the describe the support of the best models; <code><a href="#topic+calcBPvar">calcBPvar()</a></code> to compute the variability in the optimal breakpoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Fit segmented regression models for 1 to 5 regions
# using PCOs 1 to 4 and a continuous model with a
# non-exhaustive search
regionresults &lt;- calcregions(alligator_PCO,
                             scores = 1:4,
                             noregions = 5,
                             minvert = 3,
                             cont = TRUE,
                             exhaus = FALSE,
                             verbose = FALSE)

regionresults

# View model fitting summary
summary(regionresults)

# Add additional regions to existing results,
# exhaustive search this time
regionresults &lt;- addregions(regionresults,
                            noregions = 6:7,
                            exhaus = TRUE,
                            verbose = FALSE)

regionresults

summary(regionresults)

# Fit segmented regression models for 1 to 5 regions
# using PCOs 1 to 4 and a discontinuous model with a
# exhaustive search, excluding breakpoints at vertebrae
# 10 and 15
regionresults &lt;- calcregions(alligator_PCO,
                             scores = 1:4,
                             noregions = 5,
                             minvert = 3,
                             cont = FALSE,
                             omitbp = c(10, 15),
                             verbose = FALSE)

regionresults

summary(regionresults)

# Compute the number of breakpoint combinations for given
# specification using `ncombos()`; if any number exceeds
# the value supplied to `ncombos_file_trigger`, results
# will temporary be stored in files before being read in and
# deleted.
ncombos(alligator_PCO,
        noregions = 1:8,
        minvert = 3)
</code></pre>

<hr>
<h2 id='dolphin'>Measurements from the vertebral column of a dolphin</h2><span id='topic+dolphin'></span>

<h3>Description</h3>

<p>Linear and angular measurements from Platanista gangetica SMNS 45653
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dolphin
</code></pre>


<h3>Format</h3>

<p>A matrix with 40 vertebrae and 16 measurements. Column 1, vertebra, is the positional
information.
</p>

<hr>
<h2 id='modelperf'>Assess model performance</h2><span id='topic+modelperf'></span><span id='topic+modelperf.regions_pco'></span><span id='topic+modelperf.regions_sim'></span><span id='topic+modelperf.regions_results_single'></span>

<h3>Description</h3>

<p><code>modelperf()</code> computes model performance statistics in the form of <code class="reqn">R^2</code> measures for a given combination of breakpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelperf(x, ...)

## S3 method for class 'regions_pco'
modelperf(
  x,
  scores,
  modelsupport = NULL,
  criterion = "aic",
  model = 1,
  bps = NULL,
  cont = TRUE,
  ...
)

## S3 method for class 'regions_sim'
modelperf(
  x,
  scores = NULL,
  modelsupport = NULL,
  criterion = "aic",
  model = 1,
  bps = NULL,
  cont = TRUE,
  ...
)

## S3 method for class 'regions_results_single'
modelperf(x, scores = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelperf_+3A_x">x</code></td>
<td>
<p>a <code>regions_pco</code> object, the output of a call to <code><a href="#topic+svdPCO">svdPCO()</a></code>, or a <code>regions_results_single</code> object, the output of a call to <code><a href="#topic+calcmodel">calcmodel()</a></code>.</p>
</td></tr>
<tr><td><code id="modelperf_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="modelperf_+3A_scores">scores</code></td>
<td>
<p><code>numeric</code>; the indices of the PCO scores for which fit statistics are to be computed.</p>
</td></tr>
<tr><td><code id="modelperf_+3A_modelsupport">modelsupport</code></td>
<td>
<p>a <code>regions_modelsupport</code> object, the output of a call to <code><a href="#topic+modelsupport">modelsupport()</a></code>. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
<tr><td><code id="modelperf_+3A_criterion">criterion</code></td>
<td>
<p>string; the criterion to use to select the best model for which breakpoints are to be displayed when <code>modelsupport</code> is specified. Ignored otherwise. Allowable options include <code>"aic"</code> to use the AICc and <code>"bic"</code> to use the BIC. Abbreviations allowed. Default is <code>"aic"</code>. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
<tr><td><code id="modelperf_+3A_model">model</code></td>
<td>
<p><code>numeric</code>; for which model among the best as determined by <code>criterion</code> should fit statistics be computed. 1 is the best model, 2 the second best, etc. Default is 1. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
<tr><td><code id="modelperf_+3A_bps">bps</code></td>
<td>
<p><code>numeric</code>; a vector of breakpoints for which model fit should be computed. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
<tr><td><code id="modelperf_+3A_cont">cont</code></td>
<td>
<p><code>logical</code>; whether to fit a model that is continuous (<code>TRUE</code>) or discontinuous (<code>FALSE</code>) at the breakpoints supplied to <code>bps</code>. Default is <code>TRUE</code>. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modelperf()</code> operates on a single model identified by breakpoints and whether the model is continuous or not. When <code>x</code> is a <code>regions_pco</code> object, the model is selected either as the best model in the supplied <code>modelsupport</code> object (where &quot;best&quot; is determined by the arguments to <code>criterion</code> and <code>model</code>) or as specified by the user using the arguments to <code>bps</code> and <code>cont</code>. When <code>x</code> is a <code>regions_results_single</code> object, the breakpoints and model form are determined based on the supplied object.
</p>


<h3>Value</h3>

<p>A <code>regions_perf</code> object containing the breakpoints of the specified model, the univariate <code class="reqn">R^2</code> and adjusted <code class="reqn">R^2</code> statistics for each PCO score, and the multivariate <code class="reqn">R^2</code> and adjusted <code class="reqn">R^2</code> statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelsupport">modelsupport()</a></code> for assessing model support using information criteria; <code><a href="#topic+calcmodel">calcmodel()</a></code> for fitting a single segmented regression model; <code><a href="#topic+plotsegreg">plotsegreg()</a></code> for plotting the results of a single segmented regression model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Evaluate model performance (R2) given supplied
# breakpoints for a continuous model
modelperf(alligator_PCO, scores = 1:3,
          bps = c(7, 15, 20), cont = TRUE)

plotsegreg(alligator_PCO, scores = 1:3,
           bps = c(7, 15, 20), cont = TRUE)
## See also `?calcmodel` for use with a single model

# Fit segmented regression models for 1 to 7 regions
# using PCOs 1 to 4 and a continuous model with a
# non-exhaustive search
regionresults &lt;- calcregions(alligator_PCO,
                             scores = 1:4,
                             noregions = 7,
                             minvert = 3,
                             cont = TRUE,
                             exhaus = FALSE,
                             verbose = FALSE)

regionresults

# For each number of regions, identify best
# model based on minimizing RSS
bestresults &lt;- modelselect(regionresults)

# Evaluate support for each model and rank
supp &lt;- modelsupport(bestresults)

# Evaluate model performance (R2) for best model
# as chosen by BIC
modelperf(alligator_PCO, scores = 1:4,
          modelsupport = supp,
          criterion = "bic", model = 1)

# Plot that model for the first PCO score
plotsegreg(alligator_PCO, scores = 1:4,
           modelsupport = supp,
           criterion = "bic", model = 1)

## See `?simregions` for use with simulated data
</code></pre>

<hr>
<h2 id='modelselect'>Select the best models</h2><span id='topic+modelselect'></span>

<h3>Description</h3>

<p><code>modelselect()</code> narrows down the search for the best model by identifying the best model for each number of regions as determined by its residual sums of squares (RSS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelselect(results, scores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelselect_+3A_results">results</code></td>
<td>
<p>a <code>regions_results</code> object; the output of a call to <code>calcregions()</code> or <code>addregions()</code>.</p>
</td></tr>
<tr><td><code id="modelselect_+3A_scores">scores</code></td>
<td>
<p><code>numeric</code>; a vector corresponding to the indices of the PCOs the <code class="reqn">R^2</code> of which will be used to determine the best model for each number of regions. If <code>NULL</code>, the default, all PCOs used included in the fitting will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>regions_modelselect</code> object, which contains information about the best models for each number of regions extracted from <code>results</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelsupport">modelsupport()</a></code> for computing statistics that describe the support of each model using information criteria; <code><a href="#topic+modelperf">modelperf()</a></code> for computing fit statistics for selected models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Fit segmented regression models for 1 to 7 regions
# using PCOs 1 to 4 and a continuous model with a
# non-exhaustive search
regionresults &lt;- calcregions(alligator_PCO,
                             scores = 1:4,
                             noregions = 7,
                             minvert = 3,
                             cont = TRUE,
                             exhaus = FALSE,
                             verbose = FALSE)

regionresults

# For each number of regions, identify best
# model based on minimizing RSS
bestresults &lt;- modelselect(regionresults)
bestresults

# Evaluate support for each model and rank models
supp &lt;- modelsupport(bestresults)
supp

# 5 regions best based on AICc; 6 regions based on BIC
</code></pre>

<hr>
<h2 id='modelsupport'>Evaluate model support</h2><span id='topic+modelsupport'></span>

<h3>Description</h3>

<p><code>modelsupport()</code> computes measures of the relative support of each of the best models identified by <code><a href="#topic+modelselect">modelselect()</a></code> to facilitate selecting the optimal number and position of regions. These measures are in the form of information criteria (AICc and BIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelsupport(models)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelsupport_+3A_models">models</code></td>
<td>
<p>a <code>regions_modelselect</code> object; the output of a call to <code><a href="#topic+modelselect">modelselect()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>regions_modelsupport</code> object, which contains the best model for each number of regions as determined by the AICc and BIC. The computed statistics are <code>AICc</code>/<code>BIC</code>&ndash;the value of the information criterion (IC) for each model, <code>deltaAIC</code>/<code>deltaBIC</code>&ndash;the difference between the IC for the corresponding model and that of the model with the lowest IC value, <code>model_lik</code>&ndash;the likelihood ratio of the model against the model with the lowest IC value, and <code>Ak_weight</code>/<code>BIC_weight</code>&ndash;the Akaike weights for each model used to compute the region score. The region score is a weighted average of the numbers of regions, weighted by the Akaike weights to represent the variability around the optimal number of regions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelselect">modelselect()</a></code>, <code><a href="#topic+calcregions">calcregions()</a></code>, <code><a href="#topic+calcBPvar">calcBPvar()</a></code>, <code><a href="#topic+modelperf">modelperf()</a></code>, <code><a href="#topic+plotsegreg">plotsegreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Fit segmented regression models for 1 to 7 regions
# using PCOs 1 to 4 and a continuous model with a
# non-exhaustive search
regionresults &lt;- calcregions(alligator_PCO,
                             scores = 1:4,
                             noregions = 7,
                             minvert = 3,
                             cont = TRUE,
                             exhaus = FALSE,
                             verbose = FALSE)

regionresults

# For each number of regions, identify best
# model based on minimizing RSS
bestresults &lt;- modelselect(regionresults)
bestresults

# Evaluate support for each model and rank models
supp &lt;- modelsupport(bestresults)
supp

# 5 regions best based on AICc; 6 regions based on BIC
</code></pre>

<hr>
<h2 id='musm'>Measurements from the vertebral column of a mouse</h2><span id='topic+musm'></span>

<h3>Description</h3>

<p>Linear and angular measurements from Mus musculus MCZ 59560
</p>


<h3>Usage</h3>

<pre><code class='language-R'>musm
</code></pre>


<h3>Format</h3>

<p>A matrix with 23 vertebrae and 19 measurements. Column 1, vertebra, is the positional
information.
</p>

<hr>
<h2 id='PCOload'>Calculate PCO loadings</h2><span id='topic+PCOload'></span><span id='topic+plot.regions_pco_load'></span>

<h3>Description</h3>

<p><code>PCOload()</code> computes the loadings for each principal coordinates (PCOs) analysis score, which are the correlations between the features used to compute the PCOs and the PCOs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCOload(x, scores)

## S3 method for class 'regions_pco_load'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCOload_+3A_x">x</code></td>
<td>
<p>for <code>PCOload()</code>, a <code>regions_pco</code> object; the output of a call to <code><a href="#topic+svdPCO">svdPCO()</a></code>. For <code>plot()</code>, a <code>regions_pco_load</code> object.</p>
</td></tr>
<tr><td><code id="PCOload_+3A_scores">scores</code></td>
<td>
<p>a numeric vector containing the indices of the desired scores.</p>
</td></tr>
<tr><td><code id="PCOload_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the loadings for a constructed variable, <code>vert.size</code>, are also computed and displayed. This is computed as the mean of the features for each vertebra.
</p>


<h3>Value</h3>

<p><code>PCOload()</code> returns a <code>regions_pco_load</code> object, which is a matrix with a column for each PCO score requested and a row for each variable in the original dataset; values indicate the correlation between each variable and each PCO score. <code>plot()</code> returns a <code>ggplot</code> object, which can be manipulated using <em>ggplot2</em> syntax, that displays the loadings visually.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svdPCO">svdPCO()</a></code> for computing the PCOs; <code><a href="#topic+plot.regions_pco">plot.regions_pco()</a></code> for visualizing the correlations between PCO scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Compute PCO loadings
loadings &lt;- PCOload(alligator_PCO, scores = 1:4)
loadings

# Plot loadings
plot(loadings)
</code></pre>

<hr>
<h2 id='PCOselect'>Select PCO scores</h2><span id='topic+PCOselect'></span><span id='topic+plot.regions_pco_select'></span><span id='topic+summary.regions_pco_select'></span>

<h3>Description</h3>

<p><code>PCOselect()</code> provides several methods to select the number of principal coordinates (PCOs) analysis scores to be used in subsequent analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCOselect(
  pco,
  method = "manual",
  scores = NULL,
  cutoff = 0.05,
  nreps = 500,
  results = NULL,
  criterion = "aic",
  verbose = TRUE
)

## S3 method for class 'regions_pco_select'
plot(x, ...)

## S3 method for class 'regions_pco_select'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCOselect_+3A_pco">pco</code></td>
<td>
<p>a <code>regions_pco</code> object; the output of a call to <code><a href="#topic+svdPCO">svdPCO()</a></code>.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_method">method</code></td>
<td>
<p>string; the method used to select the number of PCOs. Allowable options include <code>"manual"</code>, <code>"boot"</code>, <code>"variance"</code>, and <code>"max"</code>. Default is <code>"manual"</code>. Abbreviations allowed. See Details.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_scores">scores</code></td>
<td>
<p>when <code>method = "manual"</code>, the number of PCO scores to use.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_cutoff">cutoff</code></td>
<td>
<p>when <code>method = "variance"</code>, the cutoff for the variance explained by each PCO score.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_nreps">nreps</code></td>
<td>
<p>when <code>method = "boot"</code>, the number of bootstrap replications to use.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_results">results</code></td>
<td>
<p>when <code>method = "max"</code>, a <code>regions_results</code> object, the output of a call to <code><a href="#topic+calcregions">calcregions()</a></code>.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_criterion">criterion</code></td>
<td>
<p>when <code>method = "max"</code>, which criterion should be used to select the number of scores. Allowable options include <code>"aic"</code> and <code>"bic"</code>. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_verbose">verbose</code></td>
<td>
<p>when <code>method = "boot"</code>, whether to display a progress bar. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_x">x</code></td>
<td>
<p>for <code>plot.regions_pco_select()</code>, a <code>regions_pco_select</code> object, the output of a call to <code>PCOselect()</code> with <code>method = "boot"</code> or <code>"max"</code>.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="PCOselect_+3A_object">object</code></td>
<td>
<p>a <code>regions_pco_select</code> object, the output of a call to <code>PCOselect()</code> with <code>method = "max"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each method provides an alternate way to select the number of scores. These are described below.
</p>


<h4><code>method = "manual"</code>:</h4>

<p>This simply returns the number supplied to <code>scores</code> after running some checks to ensure it is valid.
</p>



<h4><code>method = "boot"</code></h4>

<p>Bootstrapping works by comparing the eigenvalue distributions of PCOs to those with randomized data in order to extract PCO axes with significant signal, which are defined as those with eigenvalues greater than those from randomized data. The returned PCO cutoff is the largest PCO axis whose eigenvalues fall below the mean eigenvalue for that axis from the randomized data. Data are randomly sampled by row. Bootstrapping is sensitive to unequal variances of columns, so <code>scale = TRUE</code> should be set in the call to <code><a href="#topic+svdPCO">svdPCO()</a></code>, which is the default; the data are scaled in the same way prior to bootstrapping. The <code>plot()</code> method displays the eigenvalues of the true PCOs and boxplots summarizing the distribution of the bootstrapped eigenvalues for each PCO.
</p>



<h4><code>method = "variance"</code></h4>

<p>This method works by computing the ratio of each eigenvalue to the sum of the eigenvalues (i.e., to compute the proportion of variance explained by each PCO score) and select the number of scores with ratios greater than the cutoff value supplied to <code>cutoff</code>.
</p>



<h4><code>method = "max"</code></h4>

<p>This method works by selecting the smallest number of PCOs that gives a region score within .001 of the maximum possible region score for the segmented models fit in the object supplied to <code>results</code>. Which criterion is maximized (AIC or BIC) is determined by the value supplied to <code>criterion</code>. The <code>summary()</code> method displays the region score (estimated number of regions) for each PCO (<code>RSind</code>) and for PCOs cumulatively (<code>RScum</code>) selected using the AICc or BIC as well as the cumulative proportion of variance explained by the PCOs. The <code>plot()</code> method displays this information graphically, with the left y-axis displaying the region score for the PCOs individually (pale blue triangles) and cumulatively (orange circles) using each of the two criteria, and the right y-axis displaying the cumulative percentage of variance explained by the PCOs.
</p>



<h3>Value</h3>

<p>For <code>PCOselect()</code>, a <code>regions_pco_select</code> object, which is a numeric vector containing the indices of the chosen PCOs, with attributes containing information about the PCO scores chosen by the specified method. When <code>method = "boot"</code>, the bootstrap results are stored in the <code>"boot"</code> attribute. When <code>method = "max"</code>, the <code>regions_results</code> object passed to <code>regions</code> and other information about the quality of fit for each number of PCOs are stored in the <code>"pcomax"</code> attribute.
</p>
<p>The <code>plot()</code> methods each return a <code>ggplot</code> object that can manipulated using <span class="pkg">ggplot2</span> syntax. The <code>summary()</code> method returns a data.frame of results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Select which PCOs to use
## Manually (first 4 PCOs)
(PCOs &lt;- PCOselect(alligator_PCO, "manual", scores = 4))

## Using variance cutoff: PCOs that explain 5% or more
## of total PCO variance
(PCOs &lt;- PCOselect(alligator_PCO, "variance", cutoff = .05))

## Using bootstrapping with 50 reps (more reps should
## be used in practice; default is fine)
(PCOs &lt;- PCOselect(alligator_PCO, "boot", nreps = 50))

plot(PCOs) #plot true eigenvalues against bootstrapped

## Using PCOs that optimize region score:
regionresults &lt;- calcregions(alligator_PCO, scores = 1:21, noregions = 7,
                             minvert = 3, cont = TRUE, exhaus = TRUE,
                             verbose = FALSE)

(PCOs &lt;- PCOselect(alligator_PCO, "max",
                   results = regionresults,
                   criterion = "bic"))

plot(PCOs)

summary(PCOs)
</code></pre>

<hr>
<h2 id='plot.regions_pco'>Plot PCO axes</h2><span id='topic+plot.regions_pco'></span>

<h3>Description</h3>

<p><code>plot()</code> visualizes the relationship between a PCO axis and the vertebra or between pairs of PCO axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regions_pco'
plot(x, pco_y = 1, pco_x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.regions_pco_+3A_x">x</code></td>
<td>
<p>a <code>regions_pco</code> object; the output of a call to <code><a href="#topic+svdPCO">svdPCO()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.regions_pco_+3A_pco_y">pco_y</code>, <code id="plot.regions_pco_+3A_pco_x">pco_x</code></td>
<td>
<p>number; PCO score indices for the y- and x-axes, respectively. <code>pco_x</code> can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.regions_pco_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code> when <code>pco_x</code> is not <code>NULL</code>. If <code>scores</code> is supplied as an argument, it will replace <code>pco_y</code> if unspecified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>pco_x</code> is <code>NULL</code> (the default), <code>plot()</code> will display a scatterplot of the PCO axis identified by <code>pco_y</code> and vertebra position using <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>. This plot is similar to that generated by <code><a href="#topic+plotsegreg">plotsegreg()</a></code>. Otherwise, <code>plot()</code> uses <code><a href="ggplot2.html#topic+geom_text">ggplot2::geom_text()</a></code> to identify vertebrae positions in the space corresponding to the requested PCOs.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svdPCO">svdPCO()</a></code> for generating the PCO scores. <code><a href="#topic+plot.regions_sim">plot.regions_sim()</a></code> for plotting PCO scores against vertebra position for simulated PCOs. <code><a href="#topic+plotsegreg">plotsegreg()</a></code> for plotting PCO scores against vertebra position after selecting breakpoints for a segmented regression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data,
                        metric = "gower")

alligator_PCO

# Plot PCOs against vertebra index
plot(alligator_PCO, pco_y = 1:2)

# Plot PCOs against each other
plot(alligator_PCO, pco_y = 1, pco_x = 2)
</code></pre>

<hr>
<h2 id='plotsegreg'>Plot a segmented regression model</h2><span id='topic+plotsegreg'></span><span id='topic+plotsegreg.regions_pco'></span><span id='topic+plotsegreg.regions_sim'></span><span id='topic+plotsegreg.regions_results_single'></span>

<h3>Description</h3>

<p><code>plotsegreg()</code> plots the fitted lines resulting from a segmented regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsegreg(x, scores, ...)

## S3 method for class 'regions_pco'
plotsegreg(
  x,
  scores,
  modelsupport = NULL,
  criterion = "aic",
  model = 1,
  bps = NULL,
  cont = TRUE,
  ...
)

## S3 method for class 'regions_sim'
plotsegreg(
  x,
  scores,
  modelsupport = NULL,
  criterion = "aic",
  model = 1,
  bps = NULL,
  cont = TRUE,
  ...
)

## S3 method for class 'regions_results_single'
plotsegreg(x, scores, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotsegreg_+3A_x">x</code></td>
<td>
<p>a <code>regions_pco</code> object, the output of a call to <code><a href="#topic+svdPCO">svdPCO()</a></code>, or a <code>regions_results_single</code> object, the output of a call to <code><a href="#topic+calcmodel">calcmodel()</a></code>.</p>
</td></tr>
<tr><td><code id="plotsegreg_+3A_scores">scores</code></td>
<td>
<p><code>numeric</code>; the indices of the PCO scores for which the fitted lines should be plotted.</p>
</td></tr>
<tr><td><code id="plotsegreg_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="plotsegreg_+3A_modelsupport">modelsupport</code></td>
<td>
<p>a <code>regions_modelsupport</code> object, the output of a call to <code><a href="#topic+modelsupport">modelsupport()</a></code>. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
<tr><td><code id="plotsegreg_+3A_criterion">criterion</code></td>
<td>
<p>string; the criterion to use to select the best model for which breakpoints are to be displayed when <code>modelsupport</code> is specified. Ignored otherwise. Allowable options include <code>"aic"</code> to use the AICc and <code>"bic"</code> to use the BIC. Abbreviations allowed. Default is <code>"aic"</code>. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
<tr><td><code id="plotsegreg_+3A_model">model</code></td>
<td>
<p><code>numeric</code>; for which model among the best as determined by <code>criterion</code> should fitted lines be plotted. 1 is the best model, 2 the second best, etc. Default is 1. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
<tr><td><code id="plotsegreg_+3A_bps">bps</code></td>
<td>
<p><code>numeric</code>; a vector of breakpoints for which model fitted lines should be plotted. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
<tr><td><code id="plotsegreg_+3A_cont">cont</code></td>
<td>
<p><code>logical</code>; whether to fit a model that is continuous (<code>TRUE</code>) or discontinuous (<code>FALSE</code>) at the breakpoints supplied to <code>bps</code>. Default is <code>TRUE</code>. When <code>x</code> is a <code>regions_pco</code> object, either <code>modelsupport</code>, <code>criterion</code>, and <code>model</code> must be supplied or <code>bps</code> and <code>cont</code> must be supplied. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotsegreg()</code> operates on a single model identified by breakpoints and whether the model is continuous or not. When <code>x</code> is a <code>regions_pco</code> object, the model is selected either as the best model in the supplied <code>modelsupport</code> object (where &quot;best&quot; is determined by the arguments to <code>criterion</code> and <code>model</code>) or as specified by the user using the arguments to <code>bps</code> and <code>cont</code>. When <code>x</code> is a <code>regions_results_single</code> object, the breakpoints and model form are determined based on the supplied object.
</p>
<p><code>plot()</code> is an alias for <code>plotsegreg()</code> for <code>regions_results_single</code> objects.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object that can be manipulated using <em>ggplot2</em> syntax.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelsupport">modelsupport()</a></code> for assessing model support using information criteria; <code><a href="#topic+calcmodel">calcmodel()</a></code> for fitting a single segmented regression model; <code><a href="#topic+modelperf">modelperf()</a></code> for computing fit statistics for a single segmented regression model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Evaluate model performance (R2) given supplied
# breakpoints for a continuous model
modelperf(alligator_PCO, scores = 1:3,
          bps = c(7, 15, 20), cont = TRUE)

plotsegreg(alligator_PCO, scores = 1:3,
           bps = c(7, 15, 20), cont = TRUE)
## See also `?calcmodel` for use with a single model

# Fit segmented regression models for 1 to 7 regions
# using PCOs 1 to 4 and a continuous model with a
# non-exhaustive search
regionresults &lt;- calcregions(alligator_PCO,
                             scores = 1:4,
                             noregions = 7,
                             minvert = 3,
                             cont = TRUE,
                             exhaus = FALSE,
                             verbose = FALSE)

regionresults

# For each number of regions, identify best
# model based on minimizing RSS
bestresults &lt;- modelselect(regionresults)

# Evaluate support for each model and rank
supp &lt;- modelsupport(bestresults)

# Evaluate model performance (R2) for best model
# as chosen by BIC
modelperf(alligator_PCO, scores = 1:4,
          modelsupport = supp,
          criterion = "bic", model = 1)

# Plot that model for the first PCO score
plotsegreg(alligator_PCO, scores = 1:4,
           modelsupport = supp,
           criterion = "bic", model = 1)

## See `?simregions` for use with simulated data
</code></pre>

<hr>
<h2 id='plotvertmap'>Plot a vertebra map</h2><span id='topic+plotvertmap'></span>

<h3>Description</h3>

<p><code>plotvertmap()</code> plots a map of the supplied vertebrae, optionally adding colors, marks, and text to identify existing and estimated features of the vertebrae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotvertmap(
  x,
  type = "count",
  bps = NULL,
  modelsupport = NULL,
  criterion = "aic",
  model = 1,
  bpvar = NULL,
  bp.sd = NULL,
  sd.col = "black",
  dropNA = FALSE,
  text = FALSE,
  name = NULL,
  centraL = NULL,
  reg.lim = NULL,
  lim.col = "black",
  block.cols = NULL,
  block.lim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotvertmap_+3A_x">x</code></td>
<td>
<p>a <code>regions_data</code>, <code>regions_pco</code>, or <code>regions_sim</code> object; the output of a call to <code><a href="#topic+process_measurements">process_measurements()</a></code>, <code><a href="#topic+svdPCO">svdPCO()</a></code>, or <code><a href="#topic+simregions">simregions()</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_type">type</code></td>
<td>
<p>string; the labeling of the x-axis of the plot. Either <code>"count"</code> to identify the vertebra index (or absolute position when <code>centraL</code> is supplied) or <code>"percent"</code> to identify the percent vertebra count (or percent total length when <code>centraL</code> is supplied). Abbreviations allowed. Default is <code>"count"</code>.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_bps">bps</code></td>
<td>
<p>an optional vector containing the region breakpoints. One of <code>bps</code>, <code>modelsupport</code>, or <code>bpvar</code> should be specified to display regions breakpoints. See Details.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_modelsupport">modelsupport</code></td>
<td>
<p>an optional <code>regions_modelsupport</code> object; the output of a call to <code><a href="#topic+modelsupport">modelsupport()</a></code>. One of <code>bps</code>, <code>modelsupport</code>, or <code>bpvar</code> should be specified to display regions breakpoints. See Details.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_criterion">criterion</code></td>
<td>
<p>string; the criterion to use to select the best model for which breakpoints are to be displayed when <code>modelsupport</code> is specified. Ignored otherwise. Allowable options include <code>"aic"</code> to use the AICc and <code>"bic"</code> to use the BIC. Abbreviations allowed. Default is <code>"aic"</code>.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_model">model</code></td>
<td>
<p><code>numeric</code>; from which model among the best as determined by <code>criterion</code> should breakpoints be selected when <code>modelsupport</code> is supplied. Ignored otherwise. 1 is the best model, 2 the second best, etc. Default is 1.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_bpvar">bpvar</code></td>
<td>
<p>an optional <code>regions_BPvar</code> object; the output of a call to <code><a href="#topic+calcBPvar">calcBPvar()</a></code>. One of <code>bps</code>, <code>modelsupport</code>, or <code>bpvar</code> should be specified to display regions breakpoints. See Details.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_bp.sd">bp.sd</code></td>
<td>
<p>an optional vector of the standard deviations of the breakpoints (e.g., as calculated by <code><a href="#topic+calcBPvar">calcBPvar()</a></code>). When <code>bpvar</code> is supplied, the weighted standard deviations are used.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_sd.col">sd.col</code></td>
<td>
<p>when <code>bp.sd</code> is specified, the color of the mark on plot indicating the standard deviations. Default is black.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_dropna">dropNA</code></td>
<td>
<p><code>logical</code>; when some vertebrae are missing, e.g., due to subsampling or starting the analysis at a vertebra beyond the first, whether to remove the missing vertebrae from the plot (<code>TRUE</code>) or retain them and label them as missing (i.e., lacking a region) (<code>FALSE</code>). Default is <code>FALSE</code> to retain them.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_text">text</code></td>
<td>
<p><code>logical</code>; whether to print the vertebra index on each vertebra. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_name">name</code></td>
<td>
<p>an optional string containing a label used on the left side of the plot.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_central">centraL</code></td>
<td>
<p>an optional numeric vector containing centrum length for each vertebra, which is used to change the size of the plotted vertebrae, or a string containing the name of the variable in the original dataset containing centrum length. Should be of length equal to the number of included vertebrae (i.e., the length of the original dataset). Any vertebrae with centrum length of 0 will be omitted.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_reg.lim">reg.lim</code></td>
<td>
<p>a vector of breakpoints indicating other region limits, e.g., anatomic regions.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_lim.col">lim.col</code></td>
<td>
<p>when <code>reg.lim</code> is specified, the color of the lines separating the regions. Default is black.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_block.cols">block.cols</code></td>
<td>
<p>when breakpoints are specified (i.e., using <code>bps</code>, <code>modelsupport</code>, or <code>bpvar</code>) and <code>block.lim</code> is not specified, a vector of color names or hex codes, one for each region. If not specified, <code><a href="RColorBrewer.html#topic+ColorBrewer">RColorBrewer::brewer.pal()</a></code> with <code>name = "paired"</code> will be used to generate colors. When <code>block.lim</code> is specified, a named list of vectors of color names or hex codes. See Details.</p>
</td></tr>
<tr><td><code id="plotvertmap_+3A_block.lim">block.lim</code></td>
<td>
<p>a vector of breakpoints indicating the limits of traditional regions, which will be colored using <code>block.cols</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotvertmap()</code> uses <code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_rect()</a></code> to create the plot. The plots are best viewed with a short height and a long width.
</p>


<h4>Specifying breakpoints:</h4>

<p>There are three ways to specify regions in <code>plotvertmap()</code>. First is to supply the vector of breakpoints directly to <code>bps</code>. Second is to supply a <code>regions_modelsupport</code> object to <code>modelsupport</code>. When supplied, the <code>criterion</code> and <code>model</code> arguments can be used to select which of the sets of breakpoints in the object is to be used. <code>model</code> selects which breakpoint model is to be used (1 for first best, 2 for second best, etc.), and <code>criterion</code> determines which criterion (AICc or BIC) is used to rank the models. Third is to supply <code> regions_BPvar</code> object to <code>bpvar</code>. The weighted average breakpoints will be used after rounding (e.g., a weighted average breakpoint of 3.3 will place vertebrae 1, 2, and 3 in a region, and a weighted average breakpoint of 3.9 will place vertebrae 1, 2, 3, and 4 in a region).
</p>



<h4>Using <code>block.cols</code>:</h4>

<p>When <code>block.lim</code> is specified, <code>block.cols</code> must be specified as a list of vectors of colors, with an entry for each &quot;block&quot;. Blocks are predefined regions separate from those specified using the above arguments, e.g., traditional regions. For each region, the most common block is found and assigned to that region. A color of that block as supplied in <code>block.cols</code> is used to color that region. So, each block needs as many colors as there are regions assigned to it. For example, if regions 1 and 2 are both assigned to block 1 (i.e., because block 1 is the most common block in those regions), the entry in <code>block.cols</code> for that block must have (at least) 2 colors. If an incorrect number of colors per block is supplied, an error will be thrown identifying which blocks are lacking colors. See Examples.
</p>



<h3>Value</h3>

<p>A <code>ggplot</code> object that can be manipulated using <code>ggplot2</code> syntax.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Plot vertebral map with specified breakpoints
plotvertmap(alligator_PCO,
            type = "percent",
            name = "Alligator",
            bps = c(8, 15, 19),
            text = TRUE)

# Fit segmented regression models for 1 to 7 regions
# using PCOs 1 to 4 and a continuous model with a
# exhaustive search
regionresults &lt;- calcregions(alligator_PCO,
                             scores = 1:4,
                             noregions = 7,
                             minvert = 3,
                             cont = TRUE,
                             exhaus = TRUE,
                             verbose = FALSE)

# For each number of regions, identify best
# model based on minimizing RSS
bestresults &lt;- modelselect(regionresults)

# Evaluate support for each model and rank models
supp &lt;- modelsupport(bestresults)

# Plot vertebral map with breakpoints corresponding to
# best segmented regression model as determined by
# AICc
plotvertmap(alligator_PCO,
            type = "percent",
            name = "Alligator",
            modelsupport = supp,
            model = 1,
            criterion = "aic",
            text = TRUE)

# Plot vertebral map with breakpoints corresponding to
# best segmented regression model as determined by
# AICc, using centrum length to size vertebrae
plotvertmap(alligator_PCO,
            name = "Alligator",
            modelsupport = supp,
            model = 1,
            criterion = "aic",
            centraL = "CL",
            text = TRUE)

# Compute Akaike-weighted location and SD of optimal
# breakpoints using top 10% of models with 4 regions
bpvar &lt;- calcBPvar(regionresults, noregions = 5,
                   pct = .1, criterion = "aic")

#Using weighted BPs and SDs from calcBPvar()
plotvertmap(alligator_PCO, name = "Dolphin",
            bpvar = bpvar,
            text = TRUE)
</code></pre>

<hr>
<h2 id='porpoise'>Measurements from the vertebral column of three porpoises</h2><span id='topic+porpoise'></span><span id='topic+porpoise1'></span><span id='topic+porpoise2'></span><span id='topic+porpoise3'></span>

<h3>Description</h3>

<p>Linear and angular measurements from Phocoena phocoena NRM 815072 (<code>porpoise1</code>), NRM 835011 (<code>porpoise2</code>), and NRM 855083 (<code>porpoise3</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("porpoise")
</code></pre>


<h3>Format</h3>

<p>Each is a data frame with 58, 56, and 59 vertebrae (respectively) and 16 measurements. Column 1, Vertebra, contains the positional information.
</p>


<h3>References</h3>

<p>Gillet, A., Frederich, B., Pierce, S. E., &amp; Parmentier, E. (2022). Iterative habitat transitions are associated with morphological convergence of the backbone in delphinoids. Journal of Mammalian Evolution, 29(4), 931-946.
</p>

<hr>
<h2 id='process_measurements'>Process vertebra measurements</h2><span id='topic+process_measurements'></span>

<h3>Description</h3>

<p><code>process_measurements()</code> initializes the analysis workflow by processing a dataset of vertebra measurements into an object usable by <span class="pkg">MorphoRegions</span>. Such processing includes identifying the vertebra indices and the measurements and filling in missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_measurements(data, pos = 1L, measurements, fillNA = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_measurements_+3A_data">data</code></td>
<td>
<p>a data.frame containing a column of vertebra indices and measurements for each vertebra, or a list thereof for multiple specimens.</p>
</td></tr>
<tr><td><code id="process_measurements_+3A_pos">pos</code></td>
<td>
<p>the name or index of the variable in <code>data</code> containing the vertebra indices. Default is to use the first column.</p>
</td></tr>
<tr><td><code id="process_measurements_+3A_measurements">measurements</code></td>
<td>
<p>the names or indices of the variables in <code>data</code> containing the relevant vertebra measurements. If unspecified, will use all variables other than that specified in <code>pos</code>.</p>
</td></tr>
<tr><td><code id="process_measurements_+3A_fillna">fillNA</code></td>
<td>
<p><code>logical</code>; whether to fill in missing values using a simple linear imputation. Default is <code>TRUE</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any rows with missing values for all measurements will be removed. When missing values in non-removed rows are present and <code>fillNA</code> is set to <code>TRUE</code>, <code>process_measurements()</code> fills them in if the sequence of missing values is no greater than 2 in length. For numeric variables, it uses a linear interpolation, and for categorical variables, it fills in the missing values with the surrounding non-missing values if they are identical and leaves them missing otherwise. Otherwise, missing values are left as they are.
</p>
<p>When a list of data frames is supplied to <code>data</code>, only the variables named in <code>measurements</code> that are common across datasets will be stored as measurement variables.
</p>


<h3>Value</h3>

<p>A <code>regions_data</code> object, which is a list of data.frames (one for each specimen) with attributes containing metadata.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svdPCO">svdPCO()</a></code> for computing principal coordinate axes from processed vertebra data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Process dataset; vertebra index in "Vertebra" column
data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Process multiple datasets; vertebra index in first column
data("porpoise")

porpoise_data &lt;- process_measurements(list(porpoise1,
                                           porpoise2,
                                           porpoise3),
                                      pos = 1)
</code></pre>

<hr>
<h2 id='simregions'>Simulate regions data</h2><span id='topic+simregions'></span><span id='topic+plot.regions_sim'></span>

<h3>Description</h3>

<p><code>simregions()</code> simulates vertebrae and PCOs that satisfy certain constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simregions(
  nvert,
  nregions,
  nvar = 1,
  r2 = 0.95,
  minvert = 3,
  cont = TRUE,
  sl.dif = 0
)

## S3 method for class 'regions_sim'
plot(x, scores = 1, lines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simregions_+3A_nvert">nvert</code></td>
<td>
<p><code>numeric</code>; the number of vertebrae for which to simulate data.</p>
</td></tr>
<tr><td><code id="simregions_+3A_nregions">nregions</code></td>
<td>
<p><code>numeric</code>; the desired number of regions in the simulated data.</p>
</td></tr>
<tr><td><code id="simregions_+3A_nvar">nvar</code></td>
<td>
<p><code>numeric</code>; the number of PCO axes to simulate. Default is 1.</p>
</td></tr>
<tr><td><code id="simregions_+3A_r2">r2</code></td>
<td>
<p><code>numeric</code>; a vector containing the <code class="reqn">R^2</code> of the true segmented regression model for each simulated PCO. If a single value is supplied, all PCOs will receive that value. Otherwise, one value should be supplied for each simulated PCO.</p>
</td></tr>
<tr><td><code id="simregions_+3A_minvert">minvert</code></td>
<td>
<p><code>numeric</code>; the minimum number of vertebrae allowed in each region. Default is 3.</p>
</td></tr>
<tr><td><code id="simregions_+3A_cont">cont</code></td>
<td>
<p><code>logical</code>; whether to use models that are continuous (<code>TRUE</code>) or discontinuous (<code>FALSE</code>) at the breakpoints to generate the data. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simregions_+3A_sl.dif">sl.dif</code></td>
<td>
<p><code>numeric</code>; the minimum required difference in slopes between adjacent regions, expressed as a proportion of the maximal difference between allowable slopes. Must be between 0 and 1. See Details.</p>
</td></tr>
<tr><td><code id="simregions_+3A_x">x</code></td>
<td>
<p>a <code>regions_sim</code> object.</p>
</td></tr>
<tr><td><code id="simregions_+3A_scores">scores</code></td>
<td>
<p><code>numeric</code>; for which simulated PCO scores the simulated values should be plotted.</p>
</td></tr>
<tr><td><code id="simregions_+3A_lines">lines</code></td>
<td>
<p><code>logical</code>; whether to display the simulated regression lines on the plot. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="simregions_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>simregions()</code> generates PCO scores for each requested vertebra such that certain conditions are met. The slopes for each region are drawn from a uniform distribution with limits of -.5 and .5. If a set of slopes contains two adjacent slopes that have a difference less than <code>sl.dif</code>, it is rejected and a new one is drawn. The scaling of the PCOs is determined by the slopes and the requested <code class="reqn">R^2</code>. The PCOs will not necessarily be in order from most variable to least variable as they are in a traditional PCO analysis.
</p>
<p>Intercepts (the intercept of the first region when <code>cont = TRUE</code> and the intercept of all regions when <code>cont = FALSE</code>) are drawn from a uniform distribution with limits of <code class="reqn">-n/4</code> and <code class="reqn">n/4</code>, where <code class="reqn">n</code> is the number of breakpoints, one less than <code>nregions</code>. Intercepts other than the first when <code>cont = TRUE</code> are determined by the slopes.
</p>
<p>The <code>cont</code>, <code>r2</code>, and <code>sl.dif</code> arguments control how easy it is for fitted segmented regression models to capture the true structure. When <code>cont = TRUE</code>, it can be harder to determine exactly where regions begin and end, especially if <code>sl.dif</code> is 0. When <code>r2</code> is high, there is little variation around the true line, so the fitted lines will be more precise and region boundaries clearer. When <code>sl.dif</code> is high, slopes of adjacent regions are different from each other, so it is easier to detect region boundaries. Setting <code>sl.dif</code> to between .5 and 1 ensures that the slopes in adjacent regions have different signs.
</p>


<h3>Value</h3>

<p><code>simregions()</code> returns a <code>regions_sim</code> object, which contains the vertebra indices in the <code>Xvar</code> entry, the PCO scores in the <code>Yvar</code> entry, the simulated breakpoints in the <code>BPs</code> entry, the simulated model coefficients in the <code>coefs</code> entry, and the simulated error standard deviation in the <code>ersd</code> entry. The attribute <code>"design"</code> contains the design matrix, which when multiplied by the coefficients and added to a random normal variate with standard deviation equal to the error standard deviation yields the observed PCO scores.
</p>
<p><code>plot()</code> returns a <code>ggplot</code> object that can be manipulated using <code>ggplot2</code> syntax. The plot is similar to that produced by <code><a href="#topic+plot.regions_pco">plot.regions_pco()</a></code> and to that produced by <code><a href="#topic+plotsegreg">plotsegreg()</a></code> except that the displayed lines (if requested) are the true rather than fitted regression lines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcregions">calcregions()</a></code> for fitting segmented regression models to the simulated data; <code><a href="#topic+calcmodel">calcmodel()</a></code> for fitting a single segmented regression model to the simulated data; <code><a href="#topic+plotsegreg">plotsegreg()</a></code> for plotting estimated regression lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate 40 vertebra, 4 regions (3 breakpoints), 3 PCOs,
# true model R2 of .9, continuous
set.seed(11)
sim &lt;- simregions(nvert = 30, nregions = 4, nvar = 3, r2 = .95,
                  minvert = 3, cont = TRUE)

sim

# Plot the true data-generating lines and breakpoints
plot(sim, scores = 1:3)

# Run segmented regression models on simulated data,
# up to 6 regions
simresults &lt;- calcregions(sim, scores = 1:3, noregions = 6,
                          minvert = 3, cont = TRUE,
                          verbose = FALSE)

summary(simresults)

# Select best model for each number of regions
(simmodels &lt;- modelselect(simresults))

# Evaluate support for each model and rank models
(simsupp &lt;- modelsupport(simmodels))
# AICc supports 3-4 regions

# Evaluate model performance of best model
modelperf(sim, modelsupport = simsupp,
          criterion = "aic", model = 1)
# Second best model (3 regions) does quite well, too
modelperf(sim, modelsupport = simsupp,
          criterion = "aic", model = 2)

#Plot best model fit
plotsegreg(sim, scores = 1:3,
           modelsupport = simsupp,
           criterion = "aic", model = 1)

# Calculate variability of estimate breakpoints for
# 3-region model; high uncertainty for breakpoints
# 1 and 2. Note weighted value for breakpoint 2
# differs from that of best model
bpvar &lt;- calcBPvar(simresults, noregions = 4,
                   pct = .05, criterion = "aic")
bpvar

# Plot estimated vertebral map with variability
plotvertmap(sim, modelsupport = simsupp, model = 1,
            criterion = "aic", text = TRUE)

# True map; pretty close
plotvertmap(sim, bps = c(3, 7, 24),
            text = TRUE)
</code></pre>

<hr>
<h2 id='subsample'>Subsample a dataset</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p><code>subsample()</code> creates a smaller version of the original dataset by sampling its rows. Because PCOs should be computed on the full dataset and most other functions take in <code>regions_pco</code> objects, <code>subsample()</code> requires a <code>regions_pco</code> object as its input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(pco, sample = NULL, type = "seq")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample_+3A_pco">pco</code></td>
<td>
<p>a <code>regions_pco</code> object; the output of a call to <code><a href="#topic+svdPCO">svdPCO()</a></code>.</p>
</td></tr>
<tr><td><code id="subsample_+3A_sample">sample</code></td>
<td>
<p><code>numeric</code>; either the number or proportion of vertebrae to remain the sampled dataset. If <code>NULL</code>, the original dataset is returned.</p>
</td></tr>
<tr><td><code id="subsample_+3A_type">type</code></td>
<td>
<p>string; the type of subsampling to do, either <code>"seq"</code> for sampling in sequence or <code>"random"</code> for random sampling. Default is <code>"seq"</code>. Abbreviations allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>regions_pco</code> object, a subset of the original supplied to <code>pco</code>. The original dataset is stored as an attribute, which itself contains the subsampling indices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svdPCO">svdPCO()</a></code>, <code><a href="#topic+process_measurements">process_measurements()</a></code>, <code><a href="#topic+plotvertmap">plotvertmap()</a></code> to visualize the vertebral map after subsampling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data)

# Plot vertebrae before subsampling
plotvertmap(alligator_PCO, dropNA = FALSE,
            text = TRUE)

# Subsample data after estimating PCOs; subsample down
# to 15 vertebrae
alligator_PCO_sample &lt;- subsample(alligator_PCO,
                                  sample = 15)

# Plot vertebrae after subsampling; gray vertebrae
# have been dropped
plotvertmap(alligator_PCO_sample, dropNA = FALSE,
            text = TRUE)
</code></pre>

<hr>
<h2 id='svdPCO'>Calculate PCO (principal co-ordinates analysis) based on SVD</h2><span id='topic+svdPCO'></span>

<h3>Description</h3>

<p>Calculates distance matrix from raw data, then conducts a PCO ordination using a
single value decomposition (SVD). This differs from other PCO functions which use <code><a href="stats.html#topic+cmdscale">stats::cmdscale()</a></code> and rely on a
spectral decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdPCO(x, metric = "gower", scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svdPCO_+3A_x">x</code></td>
<td>
<p>a <code>regions_data</code> object; the output of a call to <code><a href="#topic+process_measurements">process_measurements()</a></code>.</p>
</td></tr>
<tr><td><code id="svdPCO_+3A_metric">metric</code></td>
<td>
<p>string; the distance matrix calculation metric. Allowable options include those support by <code><a href="cluster.html#topic+daisy">cluster::daisy()</a></code>, which are <code>"euclidean"</code>, <code>"manhattan"</code>, or <code>"gower"</code>. Default is <code>"gower"</code>. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="svdPCO_+3A_scale">scale</code></td>
<td>
<p><code>logical</code>; whether to scale the variables prior to including them in the PCO estimation. Default is <code>TRUE</code>, which is especially advisable when using the bootstrap to select the number of PCOs to use in downstream analyses. Passed to the <code>stand</code> argument of <code>cluster::daisy()</code>. Ignored if <code>metric = "gower"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>regions_pco</code> object, which contains eigenvectors in the <code>scores</code> component and eigenvalues in the <code>eigen.val</code> component. The original dataset is stored in the <code>data</code> attribute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.regions_pco">plot.regions_pco()</a></code> for plotting PCO axes
</p>
<p><code><a href="cluster.html#topic+daisy">cluster::daisy()</a></code>, which is used to compute the distance matrix used in the calculation; <code><a href="stats.html#topic+cmdscale">stats::cmdscale()</a></code> for a spectral decomposition-based implementation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("alligator")

alligator_data &lt;- process_measurements(alligator,
                                       pos = "Vertebra")

# Compute PCOs
alligator_PCO &lt;- svdPCO(alligator_data,
                        metric = "gower")

alligator_PCO

# Plot PCOs against vertebra index
plot(alligator_PCO, pco_y = 1:2)

# Plot PCOs against each other
plot(alligator_PCO, pco_y = 1, pco_x = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
