<!DOCTYPE html><html><head><title>Help for package EfficientMaxEigenpair</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EfficientMaxEigenpair}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EfficientMaxEigenpair'><p>EfficientMaxEigenpair: A package for computating the maximal eigenpair for a matrix.</p></a></li>
<li><a href='#eff.ini.maxeig.general'><p>General matrix maximal eigenpair</p></a></li>
<li><a href='#eff.ini.maxeig.shift.inv.tri'><p>Tridiagonal matrix maximal eigenpair</p></a></li>
<li><a href='#eff.ini.maxeig.tri'><p>Tridiagonal matrix maximal eigenpair</p></a></li>
<li><a href='#eff.ini.seceig.general'><p>General conservative matrix maximal eigenpair</p></a></li>
<li><a href='#eff.ini.seceig.tri'><p>Tridiagonal matrix next to the maximal eigenpair</p></a></li>
<li><a href='#find_deltak'><p>Compute <code class="reqn">\delta_k</code></p></a></li>
<li><a href='#ray.quot.general'><p>Rayleigh quotient iteration</p></a></li>
<li><a href='#ray.quot.seceig.general'><p>Rayleigh quotient iteration</p></a></li>
<li><a href='#ray.quot.seceig.tri'><p>Rayleigh quotient iteration for Tridiagonal matrix</p></a></li>
<li><a href='#ray.quot.tri'><p>Rayleigh quotient iteration for Tridiagonal matrix</p></a></li>
<li><a href='#shift.inv.tri'><p>Shifted inverse iteration algorithm for Tridiagonal matrix</p></a></li>
<li><a href='#tri.sol'><p>Solve the linear equation (-Q-zI)w=v.</p></a></li>
<li><a href='#tridiag'><p>Tridiagonal matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Initials for Computing the Maximal Eigenpair</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-10-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Mu-Fa Chen &lt;mfchen@bnu.edu.cn&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiao-Jun Mao &lt;maoxj.ki@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation for using efficient initials to compute the
    maximal eigenpair in R. It provides three algorithms to find the efficient
    initials under two cases: the tridiagonal matrix case and the general matrix
    case. Besides, it also provides two algorithms for the next to the maximal eigenpair under
    these two cases.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/mxjki/EfficientMaxEigenpair">http://github.com/mxjki/EfficientMaxEigenpair</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/mxjki/EfficientMaxEigenpair/issues">http://github.com/mxjki/EfficientMaxEigenpair/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.2), stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-10-23 11:42:20 UTC; xiaojunmao</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-10-23 12:00:48 UTC</td>
</tr>
</table>
<hr>
<h2 id='EfficientMaxEigenpair'>EfficientMaxEigenpair: A package for computating the maximal eigenpair for a matrix.</h2><span id='topic+EfficientMaxEigenpair'></span><span id='topic+EfficientMaxEigenpair-package'></span>

<h3>Description</h3>

<p>The EfficientMaxEigenpair package provides some auxillary functions and
five categories of important functions:
<code><a href="#topic+tridiag">tridiag</a></code>, <code><a href="#topic+tri.sol">tri.sol</a></code>, <code><a href="#topic+find_deltak">find_deltak</a></code>,
<code><a href="#topic+ray.quot.tri">ray.quot.tri</a></code>, <code><a href="#topic+shift.inv.tri">shift.inv.tri</a></code>,
<code><a href="#topic+ray.quot.seceig.tri">ray.quot.seceig.tri</a></code>, <code><a href="#topic+ray.quot.general">ray.quot.general</a></code>, <code><a href="#topic+ray.quot.seceig.general">ray.quot.seceig.general</a></code>,
<code><a href="#topic+eff.ini.maxeig.tri">eff.ini.maxeig.tri</a></code>, <code><a href="#topic+eff.ini.maxeig.shift.inv.tri">eff.ini.maxeig.shift.inv.tri</a></code>,
<code><a href="#topic+eff.ini.maxeig.general">eff.ini.maxeig.general</a></code>, <code><a href="#topic+eff.ini.seceig.tri">eff.ini.seceig.tri</a></code> 
and <code><a href="#topic+eff.ini.seceig.general">eff.ini.seceig.general</a></code>.
</p>


<h3>EfficientMaxEigenpair functions</h3>

<p><code><a href="#topic+tridiag">tridiag</a></code>: generate tridiagonal matrix Q based on three input vectors.
</p>
<p><code><a href="#topic+tri.sol">tri.sol</a></code>: construct the solution of linear equation (-Q-zI)w=v.
</p>
<p><code><a href="#topic+find_deltak">find_deltak</a></code>: compute <code class="reqn">\delta_k</code> for given vector <code class="reqn">v</code> and matrix <code class="reqn">Q</code>.
</p>
<p><code><a href="#topic+ray.quot.tri">ray.quot.tri</a></code>: rayleigh quotient iteration algorithm to computing the maximal eigenpair of
tridiagonal matrix <code class="reqn">Q</code>.
</p>
<p><code><a href="#topic+shift.inv.tri">shift.inv.tri</a></code>: shifted inverse iteration algorithm to computing the maximal eigenpair of
tridiagonal matrix <code class="reqn">Q</code>.
</p>
<p><code><a href="#topic+ray.quot.seceig.tri">ray.quot.seceig.tri</a></code>: rayleigh quotient iteration algorithm to computing the next to 
maximal eigenpair of tridiagonal matrix <code class="reqn">Q</code>.
</p>
<p><code><a href="#topic+ray.quot.general">ray.quot.general</a></code>: rayleigh quotient iteration algorithm to computing the maximal eigenpair of
general matrix <code class="reqn">A</code>.
</p>
<p><code><a href="#topic+ray.quot.seceig.general">ray.quot.seceig.general</a></code>: rayleigh quotient iteration algorithm to computing the  next to maximal eigenpair of
general matrix <code class="reqn">A</code>.
</p>
<p><code><a href="#topic+eff.ini.maxeig.tri">eff.ini.maxeig.tri</a></code>: calculate the maximal eigenpair for the tridiagonal matrix by
rayleigh quotient iteration algorithm.
</p>
<p><code><a href="#topic+eff.ini.maxeig.shift.inv.tri">eff.ini.maxeig.shift.inv.tri</a></code>: calculate the maximal eigenpair for the tridiagonal matrix by
shifted inverse iteration algorithm.
</p>
<p><code><a href="#topic+eff.ini.maxeig.general">eff.ini.maxeig.general</a></code>: calculate the maximal eigenpair for the general matrix.
</p>
<p><code><a href="#topic+eff.ini.seceig.tri">eff.ini.seceig.tri</a></code>: calculate the next to maximal eigenpair for the tridiagonal matrix whose sums of each row should be 0.
</p>
<p><code><a href="#topic+eff.ini.seceig.general">eff.ini.seceig.general</a></code>: calculate the next to maximal eigenpair for the general conservative matrix.
</p>

<hr>
<h2 id='eff.ini.maxeig.general'>General matrix maximal eigenpair</h2><span id='topic+eff.ini.maxeig.general'></span>

<h3>Description</h3>

<p>Calculate the maximal eigenpair for the general matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff.ini.maxeig.general(A, v0_tilde = NULL, z0 = NULL, z0numeric, xi = 1,
  digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff.ini.maxeig.general_+3A_a">A</code></td>
<td>
<p>The input general matrix.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.general_+3A_v0_tilde">v0_tilde</code></td>
<td>
<p>The unnormalized initial vector <code class="reqn">\tilde{v0}</code>.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.general_+3A_z0">z0</code></td>
<td>
<p>The type of initial <code class="reqn">z_0</code> used to calculate the approximation of <code class="reqn">\rho(Q)</code>.
There are three types: 'fixed', 'Auto' and 'numeric' corresponding to three choices
of <code class="reqn">z_0</code> in paper.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.general_+3A_z0numeric">z0numeric</code></td>
<td>
<p>The numerical value assigned to initial <code class="reqn">z_0</code> as an approximation of
<code class="reqn">\rho(Q)</code> when z_0='numeric'.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.general_+3A_xi">xi</code></td>
<td>
<p>The coefficient used to form the convex combination of <code class="reqn">\delta_1^{-1}</code> and
<code class="reqn">(v_0,-Q*v_0)_\mu</code>, it should between 0 and 1.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.general_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eff.ini.maxeig.tri">eff.ini.maxeig.tri</a></code> for the tridiagonal matrix maximal 
eigenpair by rayleigh quotient iteration algorithm.
<code><a href="#topic+eff.ini.maxeig.shift.inv.tri">eff.ini.maxeig.shift.inv.tri</a></code> for the tridiagonal matrix 
maximal eigenpair by shifted inverse iteration algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(1, 1, 3, 2, 2, 2, 3, 1, 1), 3, 3)
eff.ini.maxeig.general(A, v0_tilde = rep(1, dim(A)[1]), z0 = 'fixed')

A = matrix(c(1, 1, 3, 2, 2, 2, 3, 1, 1), 3, 3)
eff.ini.maxeig.general(A, v0_tilde = rep(1, dim(A)[1]), z0 = 'Auto')

##Symmetrizing A converge to second largest eigenvalue
A = matrix(c(1, 3, 9, 5, 2, 14, 10, 6, 0, 11, 11, 7, 0, 0, 1, 8), 4, 4)
S = (t(A) + A)/2
N = dim(S)[1]
a = diag(S[-1, -N])
b = diag(S[-N, -1])
c = rep(NA, N)
c[1] = -diag(S)[1] - b[1]
c[2:(N - 1)] = -diag(S)[2:(N - 1)] - b[2:(N - 1)] - a[1:(N - 2)]
c[N] = -diag(S)[N] - a[N - 1]

z0ini = eff.ini.maxeig.tri(a, b, c, xi = 7/8)$z[1]
eff.ini.maxeig.general(A, v0_tilde = rep(1, dim(A)[1]), z0 = 'numeric',
z0numeric = 28 - z0ini)
</code></pre>

<hr>
<h2 id='eff.ini.maxeig.shift.inv.tri'>Tridiagonal matrix maximal eigenpair</h2><span id='topic+eff.ini.maxeig.shift.inv.tri'></span>

<h3>Description</h3>

<p>Calculate the maximal eigenpair for the tridiagonal matrix by 
shifted inverse iteration algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff.ini.maxeig.shift.inv.tri(a, b, c, xi = 1, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff.ini.maxeig.shift.inv.tri_+3A_a">a</code></td>
<td>
<p>The lower diagonal vector.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.shift.inv.tri_+3A_b">b</code></td>
<td>
<p>The upper diagonal vector.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.shift.inv.tri_+3A_c">c</code></td>
<td>
<p>The shifted main diagonal vector. The corresponding unshift diagonal vector
is -c(b[1] + c[1], a[1:N - 1] + b[2:N] + c[2:N], a[N] + c[N + 1]) where N+1
is the dimension of matrix.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.shift.inv.tri_+3A_xi">xi</code></td>
<td>
<p>The coefficient used to form the convex combination of <code class="reqn">\delta_1^{-1}</code> and
<code class="reqn">(v_0,-Q*v_0)_\mu</code>, it should between 0 and 1.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.shift.inv.tri_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eff.ini.maxeig.tri">eff.ini.maxeig.tri</a></code> for the tridiagonal matrix maximal 
eigenpair by rayleigh quotient iteration algorithm.
<code><a href="#topic+eff.ini.maxeig.general">eff.ini.maxeig.general</a></code> for the general matrix maximal eigenpair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2
c = rep(0, length(a) + 1)
c[length(a) + 1] = 8^2
eff.ini.maxeig.shift.inv.tri(a, b, c, xi = 1)
</code></pre>

<hr>
<h2 id='eff.ini.maxeig.tri'>Tridiagonal matrix maximal eigenpair</h2><span id='topic+eff.ini.maxeig.tri'></span>

<h3>Description</h3>

<p>Calculate the maximal eigenpair for the tridiagonal matrix by
rayleigh quotient iteration algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff.ini.maxeig.tri(a, b, c, xi = 1, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff.ini.maxeig.tri_+3A_a">a</code></td>
<td>
<p>The lower diagonal vector.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.tri_+3A_b">b</code></td>
<td>
<p>The upper diagonal vector.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.tri_+3A_c">c</code></td>
<td>
<p>The shifted main diagonal vector. The corresponding unshift diagonal vector
is -c(b[1] + c[1], a[1:N - 1] + b[2:N] + c[2:N], a[N] + c[N + 1]) where N+1
is the dimension of matrix.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.tri_+3A_xi">xi</code></td>
<td>
<p>The coefficient used to form the convex combination of <code class="reqn">\delta_1^{-1}</code> and
<code class="reqn">(v_0,-Q*v_0)_\mu</code>, it should between 0 and 1.</p>
</td></tr>
<tr><td><code id="eff.ini.maxeig.tri_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eff.ini.maxeig.shift.inv.tri">eff.ini.maxeig.shift.inv.tri</a></code> for the tridiagonal matrix 
maximal eigenpair by shifted inverse iteration algorithm.
<code><a href="#topic+eff.ini.maxeig.general">eff.ini.maxeig.general</a></code> for the general matrix maximal eigenpair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2
c = rep(0, length(a) + 1)
c[length(a) + 1] = 8^2
eff.ini.maxeig.tri(a, b, c, xi = 1)
</code></pre>

<hr>
<h2 id='eff.ini.seceig.general'>General conservative matrix maximal eigenpair</h2><span id='topic+eff.ini.seceig.general'></span>

<h3>Description</h3>

<p>Calculate the next to maximal eigenpair for the general conservative matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff.ini.seceig.general(Q, z0 = NULL, c1 = 1000, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff.ini.seceig.general_+3A_q">Q</code></td>
<td>
<p>The input general matrix.</p>
</td></tr>
<tr><td><code id="eff.ini.seceig.general_+3A_z0">z0</code></td>
<td>
<p>The type of initial <code class="reqn">z_0</code> used to calculate the approximation of <code class="reqn">\rho(Q)</code>.
There are two types: 'fixed' and 'Auto' corresponding to two choices
of <code class="reqn">z_0</code> in paper.</p>
</td></tr>
<tr><td><code id="eff.ini.seceig.general_+3A_c1">c1</code></td>
<td>
<p>A large constant.</p>
</td></tr>
<tr><td><code id="eff.ini.seceig.general_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The conservativity of matrix <code class="reqn">Q=(q_{ij})</code> means that the sums of each row of
matrix <code class="reqn">Q</code> are all 0.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eff.ini.seceig.tri">eff.ini.seceig.tri</a></code> for the tridiagonal matrix next to the maximal eigenpair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q = matrix(c(-30, 1/5, 11/28, 55/3291, 30, -17, 275/42, 330/1097,
0, 84/5, -20, 588/1097, 0, 0, 1097/84, -2809/3291), 4, 4)
eff.ini.seceig.general(Q, z0 = 'Auto', digit.thresh = 5)
eff.ini.seceig.general(Q, z0 = 'fixed', digit.thresh = 5)
</code></pre>

<hr>
<h2 id='eff.ini.seceig.tri'>Tridiagonal matrix next to the maximal eigenpair</h2><span id='topic+eff.ini.seceig.tri'></span>

<h3>Description</h3>

<p>Calculate the next to maximal eigenpair for the tridiagonal matrix
whose sums of each row should be 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eff.ini.seceig.tri(a, b, xi = 1, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eff.ini.seceig.tri_+3A_a">a</code></td>
<td>
<p>The lower diagonal vector.</p>
</td></tr>
<tr><td><code id="eff.ini.seceig.tri_+3A_b">b</code></td>
<td>
<p>The upper diagonal vector.</p>
</td></tr>
<tr><td><code id="eff.ini.seceig.tri_+3A_xi">xi</code></td>
<td>
<p>The coefficient used in the improved initials to form
the convex combination of <code class="reqn">\delta_1^{-1}</code> and <code class="reqn">(v_0,-Q*v_0)_\mu</code>,
it should between 0 and 1.</p>
</td></tr>
<tr><td><code id="eff.ini.seceig.tri_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The sums of each row of the input tridiagonal matrix should be 0.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eff.ini.seceig.general">eff.ini.seceig.general</a></code> for the general conservative matrix next to the maximal eigenpair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2

eff.ini.seceig.tri(a, b, xi = 0)
eff.ini.seceig.tri(a, b, xi = 1)
eff.ini.seceig.tri(a, b, xi = 2/5)
</code></pre>

<hr>
<h2 id='find_deltak'>Compute <code class="reqn">\delta_k</code></h2><span id='topic+find_deltak'></span>

<h3>Description</h3>

<p>Compute <code class="reqn">\delta_k</code> for given vector <code class="reqn">v</code> and matrix <code class="reqn">Q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_deltak(Q, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_deltak_+3A_q">Q</code></td>
<td>
<p>The given tridiagonal matrix.</p>
</td></tr>
<tr><td><code id="find_deltak_+3A_v">v</code></td>
<td>
<p>The column vector on the right hand of equation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code class="reqn">\delta_k</code> for given vector <code class="reqn">v</code> and matrix <code class="reqn">Q</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2
c = rep(0, length(a) + 1)
c[length(a) + 1] = 8^2
N = length(a)
Q = tridiag(b, a, -c(b[1] + c[1], a[1:N - 1] + b[2:N] + c[2:N], a[N] + c[N + 1]))
find_deltak(Q, v=rep(1,dim(Q)[1]))
</code></pre>

<hr>
<h2 id='ray.quot.general'>Rayleigh quotient iteration</h2><span id='topic+ray.quot.general'></span>

<h3>Description</h3>

<p>Rayleigh quotient iteration algorithm to computing the maximal eigenpair of
general matrix <code class="reqn">A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray.quot.general(A, mu, v0_tilde, zstart, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ray.quot.general_+3A_a">A</code></td>
<td>
<p>The input matrix to find the maximal eigenpair.</p>
</td></tr>
<tr><td><code id="ray.quot.general_+3A_mu">mu</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="ray.quot.general_+3A_v0_tilde">v0_tilde</code></td>
<td>
<p>The unnormalized initial vector <code class="reqn">\tilde{v0}</code>.</p>
</td></tr>
<tr><td><code id="ray.quot.general_+3A_zstart">zstart</code></td>
<td>
<p>The initial <code class="reqn">z_0</code> as an approximation of <code class="reqn">\rho(Q)</code>.</p>
</td></tr>
<tr><td><code id="ray.quot.general_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(1, 1, 3, 2, 2, 2, 3, 1, 1), 3, 3)
ray.quot.general(A, mu=rep(1,dim(A)[1]), v0_tilde=rep(1,dim(A)[1]), zstart=6,
 digit.thresh = 6)
</code></pre>

<hr>
<h2 id='ray.quot.seceig.general'>Rayleigh quotient iteration</h2><span id='topic+ray.quot.seceig.general'></span>

<h3>Description</h3>

<p>Rayleigh quotient iteration algorithm to computing the maximal eigenpair of
matrix Q.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray.quot.seceig.general(Q, mu, v0_tilde, zstart, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ray.quot.seceig.general_+3A_q">Q</code></td>
<td>
<p>The input matrix to find the maximal eigenpair.</p>
</td></tr>
<tr><td><code id="ray.quot.seceig.general_+3A_mu">mu</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="ray.quot.seceig.general_+3A_v0_tilde">v0_tilde</code></td>
<td>
<p>The unnormalized initial vector <code class="reqn">\tilde{v0}</code>.</p>
</td></tr>
<tr><td><code id="ray.quot.seceig.general_+3A_zstart">zstart</code></td>
<td>
<p>The initial <code class="reqn">z_0</code> as an approximation of <code class="reqn">\rho(Q)</code>.</p>
</td></tr>
<tr><td><code id="ray.quot.seceig.general_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating sequence of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Q = matrix(c(1, 1, 3, 2, 2, 2, 3, 1, 1), 3, 3)
ray.quot.seceig.general(Q, mu=rep(1,dim(Q)[1]), v0_tilde=rep(1,dim(Q)[1]), zstart=6,
 digit.thresh = 6)
</code></pre>

<hr>
<h2 id='ray.quot.seceig.tri'>Rayleigh quotient iteration for Tridiagonal matrix</h2><span id='topic+ray.quot.seceig.tri'></span>

<h3>Description</h3>

<p>Rayleigh quotient iteration algorithm to computing the next to 
maximal eigenpair of tridiagonal matrix Q.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray.quot.seceig.tri(Q, mu, v0_tilde, zstart, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ray.quot.seceig.tri_+3A_q">Q</code></td>
<td>
<p>The input matrix to find the maximal eigenpair.</p>
</td></tr>
<tr><td><code id="ray.quot.seceig.tri_+3A_mu">mu</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="ray.quot.seceig.tri_+3A_v0_tilde">v0_tilde</code></td>
<td>
<p>The unnormalized initial vector <code class="reqn">\tilde{v0}</code>.</p>
</td></tr>
<tr><td><code id="ray.quot.seceig.tri_+3A_zstart">zstart</code></td>
<td>
<p>The initial <code class="reqn">z_0</code> as an approximation of <code class="reqn">\rho(Q)</code>.</p>
</td></tr>
<tr><td><code id="ray.quot.seceig.tri_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2
c = rep(0, length(a) + 1)
c[length(a) + 1] = 8^2
N = length(a)
Q = tridiag(b, a, -c(b[1] + c[1], a[1:N - 1] + b[2:N] + c[2:N], a[N] + c[N + 1]))
ray.quot.seceig.tri(Q, mu=rep(1,dim(Q)[1]), v0_tilde=rep(1,dim(Q)[1]), zstart=6,
 digit.thresh = 6)
</code></pre>

<hr>
<h2 id='ray.quot.tri'>Rayleigh quotient iteration for Tridiagonal matrix</h2><span id='topic+ray.quot.tri'></span>

<h3>Description</h3>

<p>Rayleigh quotient iteration algorithm to computing the maximal eigenpair of
tridiagonal matrix Q.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ray.quot.tri(Q, mu, v0_tilde, zstart, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ray.quot.tri_+3A_q">Q</code></td>
<td>
<p>The input matrix to find the maximal eigenpair.</p>
</td></tr>
<tr><td><code id="ray.quot.tri_+3A_mu">mu</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="ray.quot.tri_+3A_v0_tilde">v0_tilde</code></td>
<td>
<p>The unnormalized initial vector <code class="reqn">\tilde{v0}</code>.</p>
</td></tr>
<tr><td><code id="ray.quot.tri_+3A_zstart">zstart</code></td>
<td>
<p>The initial <code class="reqn">z_0</code> as an approximation of <code class="reqn">\rho(Q)</code>.</p>
</td></tr>
<tr><td><code id="ray.quot.tri_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2
c = rep(0, length(a) + 1)
c[length(a) + 1] = 8^2
N = length(a)
Q = tridiag(b, a, -c(b[1] + c[1], a[1:N - 1] + b[2:N] + c[2:N], a[N] + c[N + 1]))
ray.quot.tri(Q, mu=rep(1,dim(Q)[1]), v0_tilde=rep(1,dim(Q)[1]), zstart=6,
 digit.thresh = 6)
</code></pre>

<hr>
<h2 id='shift.inv.tri'>Shifted inverse iteration algorithm for Tridiagonal matrix</h2><span id='topic+shift.inv.tri'></span>

<h3>Description</h3>

<p>Shifted inverse iteration algorithm algorithm to computing the maximal eigenpair of
tridiagonal matrix <code class="reqn">Q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.inv.tri(Q, mu, v0_tilde, zstart, digit.thresh = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.inv.tri_+3A_q">Q</code></td>
<td>
<p>The input matrix to find the maximal eigenpair.</p>
</td></tr>
<tr><td><code id="shift.inv.tri_+3A_mu">mu</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="shift.inv.tri_+3A_v0_tilde">v0_tilde</code></td>
<td>
<p>The unnormalized initial vector <code class="reqn">\tilde{v0}</code>.</p>
</td></tr>
<tr><td><code id="shift.inv.tri_+3A_zstart">zstart</code></td>
<td>
<p>The initial <code class="reqn">z_0</code> as an approximation of <code class="reqn">\rho(Q)</code>.</p>
</td></tr>
<tr><td><code id="shift.inv.tri_+3A_digit.thresh">digit.thresh</code></td>
<td>
<p>The precise level of output results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of eigenpair object are returned, with components <code class="reqn">z</code>, <code class="reqn">v</code> and <code class="reqn">iter</code>.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The approximating sequence of the maximal eigenvalue.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The approximating eigenfunction of the corresponding eigenvector.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2
c = rep(0, length(a) + 1)
c[length(a) + 1] = 8^2
N = length(a)
Q = tridiag(b, a, -c(b[1] + c[1], a[1:N - 1] + b[2:N] + c[2:N], a[N] + c[N + 1]))
shift.inv.tri(Q, mu=rep(1,dim(Q)[1]), v0_tilde=rep(1,dim(Q)[1]), zstart=6,
 digit.thresh = 6)
</code></pre>

<hr>
<h2 id='tri.sol'>Solve the linear equation (-Q-zI)w=v.</h2><span id='topic+tri.sol'></span>

<h3>Description</h3>

<p>Construct the solution of linear equation (-Q-zI)w=v.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.sol(Q, z, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.sol_+3A_q">Q</code></td>
<td>
<p>The given tridiagonal matrix.</p>
</td></tr>
<tr><td><code id="tri.sol_+3A_z">z</code></td>
<td>
<p>The Rayleigh shift.</p>
</td></tr>
<tr><td><code id="tri.sol_+3A_v">v</code></td>
<td>
<p>The column vector on the right hand of  equation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A solution sequence <code class="reqn">w</code> to the equation (-Q-zI)w=v.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2
c = rep(0, length(a) + 1)
c[length(a) + 1] = 8^2
N = length(a)
zstart = 6
Q = tridiag(b, a, -c(b[1] + c[1], a[1:N - 1] + b[2:N] + c[2:N], a[N] + c[N + 1]))
tri.sol(Q, z=zstart, v=rep(1,dim(Q)[1]))
</code></pre>

<hr>
<h2 id='tridiag'>Tridiagonal matrix</h2><span id='topic+tridiag'></span>

<h3>Description</h3>

<p>Generate tridiagonal matrix Q based on three input vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tridiag(upper, lower, main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tridiag_+3A_upper">upper</code></td>
<td>
<p>The upper diagonal vector.</p>
</td></tr>
<tr><td><code id="tridiag_+3A_lower">lower</code></td>
<td>
<p>The lower diagonal vector.</p>
</td></tr>
<tr><td><code id="tridiag_+3A_main">main</code></td>
<td>
<p>The main diagonal vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tridiagonal matrix is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = c(1:7)^2
b = c(1:7)^2
c = -c(1:8)^2
tridiag(b, a, c)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
