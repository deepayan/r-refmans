<!DOCTYPE html><html><head><title>Help for package gpindex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gpindex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gpindex-package'><p>gpindex: Generalized Price and Quantity Indexes</p></a></li>
<li><a href='#back_period'><p>Offset a vector prices or quantities</p></a></li>
<li><a href='#balanced'><p>Balanced operator</p></a></li>
<li><a href='#contributions'><p>Percent-change contributions</p></a></li>
<li><a href='#extended_mean'><p>Extended mean</p></a></li>
<li><a href='#factor_weights'><p>Factor weights</p></a></li>
<li><a href='#geks'><p>GEKS index</p></a></li>
<li><a href='#generalized_mean'><p>Generalized mean</p></a></li>
<li><a href='#grouped'><p>Grouped operator</p></a></li>
<li><a href='#index_weights'><p>Index weights</p></a></li>
<li><a href='#lehmer_mean'><p>Lehmer mean</p></a></li>
<li><a href='#nested_mean'><p>Nested generalized mean</p></a></li>
<li><a href='#outliers'><p>Outlier detection for price relatives</p></a></li>
<li><a href='#price_data'><p>Sample price/quantity data</p></a></li>
<li><a href='#price_indexes'><p>Price indexes</p></a></li>
<li><a href='#quantity_index'><p>Quantity index operator</p></a></li>
<li><a href='#scale_weights'><p>Scale weights</p></a></li>
<li><a href='#transmute_weights'><p>Transmute weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalized Price and Quantity Indexes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to build and work with bilateral generalized-mean
    price indexes (and by extension quantity indexes), and indexes composed of
    generalized-mean indexes (e.g., superlative quadratic-mean indexes, GEKS).
    Covers the core mathematical machinery for making bilateral price indexes,
    computing price relatives, detecting outliers, and decomposing indexes,
    with wrapper for all common (and many uncommon) index-number
    formulas. Implements and extends many of the methods in
    Balk (2008, ISBN:978-1-107-40496-0),
    von der Lippe (2001, ISBN:3-8246-0638-0), and the
    CPI manual (2020, ISBN:978-1-51354-298-0).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://marberts.github.io/gpindex/">https://marberts.github.io/gpindex/</a>,
<a href="https://github.com/marberts/gpindex">https://github.com/marberts/gpindex</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/marberts/gpindex/issues">https://github.com/marberts/gpindex/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'helpers.R' 'means.R' 'weights.R' 'contributions.R'
'price_indexes.R' 'geks.R' 'operators.R' 'offset_prices.R'
'outliers.R' 'price_data.R' 'gpindex-package.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-15 01:12:16 UTC; steve</td>
</tr>
<tr>
<td>Author:</td>
<td>Steve Martin <a href="https://orcid.org/0000-0003-2544-9480"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steve Martin &lt;stevemartin041@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-15 05:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gpindex-package'>gpindex: Generalized Price and Quantity Indexes</h2><span id='topic+gpindex-package'></span><span id='topic+_PACKAGE'></span><span id='topic+gpindex'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Tools to build and work with bilateral generalized-mean price indexes (and by extension quantity indexes), and indexes composed of generalized-mean indexes (e.g., superlative quadratic-mean indexes, GEKS). Covers the core mathematical machinery for making bilateral price indexes, computing price relatives, detecting outliers, and decomposing indexes, with wrapper for all common (and many uncommon) index-number formulas. Implements and extends many of the methods in Balk (2008, ISBN:978-1-107-40496-0), von der Lippe (2001, ISBN:3-8246-0638-0), and the CPI manual (2020, ISBN:978-1-51354-298-0).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Steve Martin <a href="mailto:stevemartin041@gmail.com">stevemartin041@gmail.com</a> (<a href="https://orcid.org/0000-0003-2544-9480">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://marberts.github.io/gpindex/">https://marberts.github.io/gpindex/</a>
</p>
</li>
<li> <p><a href="https://github.com/marberts/gpindex">https://github.com/marberts/gpindex</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/marberts/gpindex/issues">https://github.com/marberts/gpindex/issues</a>
</p>
</li></ul>


<hr>
<h2 id='back_period'>Offset a vector prices or quantities</h2><span id='topic+back_period'></span><span id='topic+base_period'></span>

<h3>Description</h3>

<p>For each product, compute either the position of the previous period (back
period), or the position of the first period (base period). Useful when price
information is stored in a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>back_period(period, product = gl(1, length(period)), match_first = TRUE)

base_period(period, product = gl(1, length(period)), match_first = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="back_period_+3A_period">period</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the time period for each transaction. The ordering of time periods
follows the levels of <code>period</code> to agree with
<code><a href="base.html#topic+cut.Date">cut()</a></code>.</p>
</td></tr>
<tr><td><code id="back_period_+3A_product">product</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the product identifier for each transaction. The default is to assume
that all transactions are for the same product.</p>
</td></tr>
<tr><td><code id="back_period_+3A_match_first">match_first</code></td>
<td>
<p>Should products in the first period match with
themselves (the default)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a numeric vector of indices for the back/base periods.
With <code>back_period()</code>, for all periods after the first, the resulting vector
gives the location of the corresponding product in the previous period.
With <code>base_period()</code>, the resulting vector gives the location of the
corresponding product in the first period. The locations are unchanged for
the first time period if <code>match_first = TRUE</code>, <code>NA</code> otherwise.
</p>


<h3>Note</h3>

<p>By definition, there must be at most one transaction for each product
in each time period to determine a back/base period. If multiple transactions
correspond to a period-product pair, then the back/base period at a point in
time is always the first position for that product in the previous period.
</p>


<h3>See Also</h3>

<p><a href="#topic+outliers">outliers</a> for common methods to detect outliers for price relatives.
</p>
<p><code>rs_pairs</code> in the <span class="pkg">rsmatrix</span> package for making sales pairs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  price = 1:6,
  product = factor(c("a", "b")),
  period = factor(c(1, 1, 2, 2, 3, 3))
)

with(df, back_period(period, product))

# Make period-over-period price relatives

with(df, price / price[back_period(period, product)])

# Make fixed-base price relatives

with(df, price / price[base_period(period, product)])

# Change the base period with relevel()

with(df, price / price[base_period(relevel(period, "2"), product)])

# Warning is given if the same product has multiple prices
# at any point in time

with(df, back_period(period))

</code></pre>

<hr>
<h2 id='balanced'>Balanced operator</h2><span id='topic+balanced'></span>

<h3>Description</h3>

<p>Makes a function balance the removal of <code>NA</code>s across multiple input vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanced(f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanced_+3A_f">f</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="balanced_+3A_...">...</code></td>
<td>
<p>Deprecated. Additional arguments to <code>f</code> that should <em>not</em> be
balanced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function like <code>f</code> with a new argument <code>na.rm</code>. If <code>na.rm = TRUE</code> then
<code><a href="stats.html#topic+complete.cases">complete.cases()</a></code> is used to remove missing values across all inputs
prior to calling <code>f</code>.
</p>


<h3>See Also</h3>

<p>Other operators: 
<code><a href="#topic+grouped">grouped</a>()</code>,
<code><a href="#topic+quantity_index">quantity_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- price6[[3]]
p0 &lt;- price6[[2]]
q1 &lt;- quantity6[[3]]
q0 &lt;- quantity6[[2]]

# Balance missing values for a Fisher index

fisher &lt;- balanced(fisher_index)
fisher(p1, p0, q1, replace(q0, 3, NA), na.rm = TRUE)
fisher_index(p1[-3], p0[-3], q1[-3], q0[-3])

# Operators can be combined, but some care may be needed

x &lt;- 1:6
w &lt;- c(1:5, NA)

f &lt;- factor(rep(letters[1:2], each = 3))

grouped(\(x, w) balanced(fisher_mean)(x, w, na.rm = TRUE))(x, w, group = f)
balanced(grouped(fisher_mean))(x, w, group = f, na.rm = TRUE)

</code></pre>

<hr>
<h2 id='contributions'>Percent-change contributions</h2><span id='topic+contributions'></span><span id='topic+arithmetic_contributions'></span><span id='topic+geometric_contributions'></span><span id='topic+harmonic_contributions'></span><span id='topic+nested_contributions'></span><span id='topic+nested_contributions2'></span><span id='topic+fisher_contributions'></span><span id='topic+fisher_contributions2'></span>

<h3>Description</h3>

<p>Calculate additive percent-change contributions for generalized-mean price
indexes, and indexes that nest two levels of generalized means consisting of
an outer generalized mean and two inner generalized means (e.g., the Fisher
index).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contributions(r)

arithmetic_contributions(x, w = NULL)

geometric_contributions(x, w = NULL)

harmonic_contributions(x, w = NULL)

nested_contributions(r1, r2, t = c(1, 1))

nested_contributions2(r1, r2, t = c(1, 1))

fisher_contributions(x, w1 = NULL, w2 = NULL)

fisher_contributions2(x, w1 = NULL, w2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contributions_+3A_r">r</code></td>
<td>
<p>A finite number giving the order of the generalized mean.</p>
</td></tr>
<tr><td><code id="contributions_+3A_x">x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td></tr>
<tr><td><code id="contributions_+3A_w">w</code>, <code id="contributions_+3A_w1">w1</code>, <code id="contributions_+3A_w2">w2</code></td>
<td>
<p>A strictly positive numeric vector of weights, the same length
as <code>x</code>. The default is to equally weight each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="contributions_+3A_r1">r1</code></td>
<td>
<p>A finite number giving the order of the outer generalized mean.</p>
</td></tr>
<tr><td><code id="contributions_+3A_r2">r2</code></td>
<td>
<p>A pair of finite numbers giving the order of the inner generalized
means.</p>
</td></tr>
<tr><td><code id="contributions_+3A_t">t</code></td>
<td>
<p>A pair of strictly positive weights for the inner generalized
means. The default is equal weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>contributions()</code> is a simple wrapper for
<code><a href="#topic+transmute_weights">transmute_weights(r, 1)()</a></code> to calculate
(additive) percent-change contributions for a price index based on a
generalized mean of order <code>r</code>. It returns a function to compute a
vector <code>v(x, w)</code> such that
</p>
<pre>generalized_mean(r)(x, w) - 1 == sum(v(x, w))</pre>
<p>This generalizes the approach for calculating percent-change contributions
in section 4.2 of Balk (2008) using the method by Martin (2021). The
<code>arithmetic_contributions()</code>, <code>geometric_contributions()</code> and
<code>harmonic_contributions()</code> functions cover the most important cases
(i.e., <code>r = 1</code>, <code>r = 0</code>, and <code>r = -1</code>).
</p>
<p>The <code>nested_contributions()</code> and <code>nested_contributions2()</code>
functions are the analog of <code>contributions()</code> for an index based on a
nested generalized mean with two levels, like a Fisher index. They return a
function that calculates the contribution of each element of <code>x</code> when a
generalized mean of order <code>r1</code> aggregates two generalized-mean indexes
of <code>x</code> with orders <code>r2</code>, and weights <code>w1</code> and <code>w2</code>.
</p>
<p>Unlike the case of a generalized-mean index, there are several ways to make
contributions for an index based on nested generalized means.
<code>nested_contributions()</code> uses a generalization of the algorithm in
section 6 of Reinsdorf et al. (2002) by Martin (2021).
<code>nested_contributions2()</code> generalizes the van IJzeren decomposition for
the Fisher index (Balk, 2008, section 4.2.2) by constructing a weighted
average of the contributions for both of the inner means with the approach
by Martin (2021). In most cases the results are broadly similar.
</p>
<p>The <code>fisher_contributions()</code> and <code>fisher_contributions2()</code>
functions correspond to <code>nested_contributions(0, c(1, -1))()</code> and
<code>nested_contributions2(0, c(1, -1))()</code>, and are appropriate for
calculating percent-change contributions for a Fisher index.
</p>


<h3>Value</h3>

<p><code>contributions()</code> returns a function:
</p>
<pre>function(x, w = NULL){...}</pre>
<p>This computes the additive contribution for each element of <code>x</code> in an
index based on the generalized mean of order <code>r</code> with weights <code>w</code>.
</p>
<p><code>nested_contributions()</code> and <code>nested_contributions2()</code> return a
function:
</p>
<pre>function(x, w1 = NULL, w2 = NULL){...}</pre>
<p>This computes the additive contribution for each element of <code>x</code> when a
generalized mean of order <code>r1</code> aggregates a generalized-mean index of
order <code>r2[1]</code> with weights <code>w1</code> and a generalized-mean index of
order <code>r2[2]</code> with weights <code>w2</code>.
</p>
<p><code>arithmetic_contributions()</code>, <code>geometric_contributions()</code>, and
<code>harmonic_contributions()</code> each return a numeric vector, the same
length as <code>x</code>, giving the contribution of each element of <code>x</code> in
an arithmetic, geometric, or harmonic index.
</p>
<p><code>fisher_contributions()</code> and <code>fisher_contributions2()</code> each return
a numeric vector, the same length as <code>x</code>, giving the contribution of
each element of <code>x</code> when a geometric mean aggregates an arithmetic mean
of <code>x</code> with weights <code>w1</code> and a harmonic mean of <code>x</code> with
weights <code>w2</code>.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>Hallerbach, W. G. (2005). An alternative decomposition of the Fisher index.
<em>Economics Letters</em>, 86(2):147&ndash;152
</p>
<p>Martin, S. (2021). A note on general decompositions for price indexes.
<em>Prices Analytical Series</em>, Statistics Canada catalogue no. 62F0014M.
Statistics Canada, Ottawa.
</p>
<p>Reinsdorf, M. B., Diewert, W. E., and Ehemann, C. (2002). Additive
decompositions for Fisher, Törnqvist and geometric mean indexes.
<em>Journal of Economic and Social Measurement</em>, 28(1-2):51&ndash;61.
</p>
<p>Webster, M. and Tarnow-Mordi, R. C. (2019). Decomposing multilateral price
indexes into the contributions of individual commodities.
<em>Journal of Official Statistics</em>, 35(2):461&ndash;486.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transmute_weights">transmute_weights()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 2:3

#---- Contributions for a geometric index ----

geometric_mean(x) - 1 # percent change in the Jevons index

geometric_contributions(x)

all.equal(geometric_mean(x) - 1, sum(geometric_contributions(x)))

# This works by first transmuting the weights in the geometric mean
# into weights for an arithmetic mean, then finding the contributions
# to the percent change

scale_weights(transmute_weights(0, 1)(x)) * (x - 1)

# Not the only way to calculate contributions

transmute2 &lt;- function(x) {
  m &lt;- geometric_mean(x)
  (m - 1) / log(m) * log(x) / (x - 1) / length(x)
}

transmute2(x) * (x - 1) # not proportional to the method above
all.equal(sum(transmute2(x) * (x - 1)), geometric_mean(x) - 1)

# But these "transmuted" weights don't recover the geometric mean!
# Not a particularly good way to calculate contributions

isTRUE(all.equal(
  arithmetic_mean(x, transmute2(x)),
  geometric_mean(x)
))

# There are infinitely many ways to calculate contributions, but the
# weights from transmute_weights(0, 1)() are the *unique* weights that
# recover the geometric mean

perturb &lt;- function(w, e) {
  w + c(e, -e) / (x - 1)
}

perturb(transmute2(x), 0.1) * (x - 1)
all.equal(
  sum(perturb(transmute2(x), 0.1) * (x - 1)),
  geometric_mean(x) - 1
)
isTRUE(all.equal(
  arithmetic_mean(x, perturb(transmute2(x), 0.1)),
  geometric_mean(x)
))

#---- Contributions for a Fisher index ----

p1 &lt;- price6[[2]]
p0 &lt;- price6[[1]]
q1 &lt;- quantity6[[2]]
q0 &lt;- quantity6[[1]]

# Percent-change contributions for the Fisher index in section 6 of
# Reinsdorf et al. (2002)

(con &lt;- fisher_contributions(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Paasche")(p1, q1)
))

all.equal(sum(con), fisher_index(p1, p0, q1, q0) - 1)

# Not the only way

(con2 &lt;- fisher_contributions2(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Paasche")(p1, q1)
))

all.equal(sum(con2), fisher_index(p1, p0, q1, q0) - 1)

# The same as the van IJzeren decomposition in section 4.2.2 of
# Balk (2008)

Qf &lt;- quantity_index(fisher_index)(q1, q0, p1, p0)
Ql &lt;- quantity_index(laspeyres_index)(q1, q0, p0)
wl &lt;- scale_weights(index_weights("Laspeyres")(p0, q0))
wp &lt;- scale_weights(index_weights("HybridPaasche")(p0, q1))

(Qf / (Qf + Ql) * wl + Ql / (Qf + Ql) * wp) * (p1 / p0 - 1)

# Similar to the method in section 2 of Reinsdorf et al. (2002),
# although those contributions aren't based on weights that sum to 1

Pf &lt;- fisher_index(p1, p0, q1, q0)
Pl &lt;- laspeyres_index(p1, p0, q0)

(1 / (1 + Pf) * wl + Pl / (1 + Pf) * wp) * (p1 / p0 - 1)

# Also similar to the decomposition by Hallerbach (2005), noting that
# the Euler weights are close to unity

Pp &lt;- paasche_index(p1, p0, q1)

(0.5 * sqrt(Pp / Pl) * wl + 0.5 * sqrt(Pl / Pp) * wp) * (p1 / p0 - 1)

#---- Contributions for other types of indexes ----

# A function to get contributions for any superlative quadratic mean of
# order 'r' index

superlative_contributions &lt;- function(r) {
  nested_contributions(0, c(r / 2, -r / 2))
}

# Works for other types of indexes, like the harmonic
# Laspeyres Paasche index

hlp_contributions &lt;- nested_contributions(-1, c(1, -1))
hlp_contributions(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Paasche")(p1, q1)
)

# Or the AG mean index (tau = 0.25)

agmean_contributions &lt;- nested_contributions(1, c(0, 1), c(0.25, 0.75))
agmean_contributions(
  p1 / p0,
  index_weights("Laspeyres")(p0, q0),
  index_weights("Laspeyres")(p0, q0)
)

# Or the Balk-Walsh index

bw_contributions &lt;- nested_contributions(0, c(0.5, -0.5))
bw_contributions(p1 / p0)

</code></pre>

<hr>
<h2 id='extended_mean'>Extended mean</h2><span id='topic+extended_mean'></span><span id='topic+generalized_logmean'></span><span id='topic+logmean'></span>

<h3>Description</h3>

<p>Calculate a generalized logarithmic mean / extended mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extended_mean(r, s)

generalized_logmean(r)

logmean(a, b, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extended_mean_+3A_r">r</code>, <code id="extended_mean_+3A_s">s</code></td>
<td>
<p>A finite number giving the order of the generalized logarithmic
mean / extended mean.</p>
</td></tr>
<tr><td><code id="extended_mean_+3A_a">a</code>, <code id="extended_mean_+3A_b">b</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td></tr>
<tr><td><code id="extended_mean_+3A_tol">tol</code></td>
<td>
<p>The tolerance used to determine if <code>a == b</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>extended_mean()</code> returns a function to compute the
component-wise extended mean of <code>a</code> and <code>b</code> of orders <code>r</code> and
<code>s</code>. See Bullen (2003, p. 393) for a definition. This is also called
the difference mean, Stolarsky mean, or extended mean-value mean.
</p>
<p>The function <code>generalized_logmean()</code> returns a function to compute the
component-wise generalized logarithmic mean of <code>a</code> and <code>b</code> of
order <code>r</code>. See Bullen (2003, p. 385) for a definition, or
<a href="https://en.wikipedia.org/wiki/Stolarsky_mean">https://en.wikipedia.org/wiki/Stolarsky_mean</a>. The generalized
logarithmic mean is a special case of the extended mean, corresponding to
<code>extended_mean(r, 1)()</code>, but is more commonly used for price indexes.
</p>
<p>The function <code>logmean()</code> returns the ordinary component-wise
logarithmic mean of <code>a</code> and <code>b</code>, and corresponds to
<code>generalized_logmean(1)()</code>.
</p>
<p>Both <code>a</code> and <code>b</code> should be strictly positive. This is not
enforced, but the results may not make sense when the generalized
logarithmic mean / extended mean is not defined. The usual recycling rules
apply when <code>a</code> and <code>b</code> are not the same length.
</p>
<p>By definition, the generalized logarithmic mean / extended mean of <code>a</code>
and <code>b</code> is <code>a</code> when <code>a == b</code>. The <code>tol</code> argument is used
to test equality by checking if <code>abs(a - b) &lt;= tol</code>. The default value
is the same as <code><a href="Matrix.html#topic+all.equal">all.equal()</a></code>. Setting <code>tol = 0</code>
tests for exact equality, but can give misleading results when <code>a</code> and
<code>b</code> are computed values. In some cases it's useful to multiply
<code>tol</code> by a scale factor, such as <code>max(abs(a), abs(b))</code>. This often
doesn't matter when making price indexes, however, as <code>a</code> and <code>b</code>
are usually around 1.
</p>


<h3>Value</h3>

<p><code>generalized_logmean()</code> and <code>extended_mean()</code> return a
function:
</p>
<pre>function(a, b, tol = .Machine$double.eps^0.5){...}</pre>
<p>This computes the component-wise generalized logarithmic mean of order
<code>r</code>, or the extended mean of orders <code>r</code> and <code>s</code>, of <code>a</code> and <code>b</code>.
</p>
<p><code>logmean()</code> returns a numeric vector, the same length as
<code>max(length(a), length(b))</code>, giving the component-wise logarithmic mean
of <code>a</code> and <code>b</code>.
</p>


<h3>Note</h3>

<p><code>generalized_logmean()</code> can be defined on the extended real line,
so that <code>r = -Inf / Inf</code> returns <code><a href="base.html#topic+pmin">pmin()</a></code>/<code><a href="base.html#topic+pmax">pmax()</a></code>, to agree with the
definition in, e.g., Bullen (2003). This is not implemented, and <code>r</code>
must be finite as in the original formulation by Stolarsky (1975).
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>Bullen, P. S. (2003). <em>Handbook of Means and Their Inequalities</em>.
Springer Science+Business Media.
</p>
<p>Stolarsky, K. B. (1975). Generalizations of the Logarithmic Mean.
<em>Mathematics Magazine</em>, 48(2): 87-92.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transmute_weights">transmute_weights()</a></code> uses the extended mean to turn a generalized
mean of order <code class="reqn">r</code> into a generalized mean of order <code class="reqn">s</code>.
</p>
<p>Other means: 
<code><a href="#topic+generalized_mean">generalized_mean</a>()</code>,
<code><a href="#topic+lehmer_mean">lehmer_mean</a>()</code>,
<code><a href="#topic+nested_mean">nested_mean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 8:5
y &lt;- 1:4

#---- Comparing logarithmic means and generalized means ----

# The arithmetic and geometric means are special cases of the
# generalized logarithmic mean

all.equal(generalized_logmean(2)(x, y), (x + y) / 2)
all.equal(generalized_logmean(-1)(x, y), sqrt(x * y))

# The logarithmic mean lies between the arithmetic and geometric means
# because the generalized logarithmic mean is increasing in r

all(logmean(x, y) &lt; (x + y) / 2) &amp;
  all(logmean(x, y) &gt; sqrt(x * y))

# The harmonic mean cannot be expressed as a logarithmic mean, but can
# be expressed as an extended mean

all.equal(extended_mean(-2, -1)(x, y), 2 / (1 / x + 1 / y))

# The quadratic mean is also a type of extended mean

all.equal(extended_mean(2, 4)(x, y), sqrt(x^2 / 2 + y^2 / 2))

# As are heronian and centroidal means

all.equal(
  extended_mean(0.5, 1.5)(x, y),
  (x + sqrt(x * y) + y) / 3
)
all.equal(
  extended_mean(2, 3)(x, y),
  2 / 3 * (x^2 + x * y + y^2) / (x + y)
)

#---- Approximating the logarithmic mean ----

# The logarithmic mean can be approximated as a convex combination of
# the arithmetic and geometric means that gives more weight to the
# geometric mean

approx1 &lt;- 1 / 3 * (x + y) / 2 + 2 / 3 * sqrt(x * y)
approx2 &lt;- ((x + y) / 2)^(1 / 3) * (sqrt(x * y))^(2 / 3)

approx1 - logmean(x, y) # always a positive approximation error
approx2 - logmean(x, y) # a negative approximation error

# A better approximation

correction &lt;- (log(x / y) / pi)^4 / 32
approx1 / (1 + correction) - logmean(x, y)

#---- Some identities ----

# A useful identity for turning an additive change into a proportionate
# change

all.equal(logmean(x, y) * log(x / y), x - y)

# Works for other orders, too

r &lt;- 2

all.equal(
  generalized_logmean(r)(x, y)^(r - 1) * (r * (x - y)),
  (x^r - y^r)
)

# Some other identities

all.equal(
  generalized_logmean(-2)(1, 2),
  (harmonic_mean(1:2) * geometric_mean(1:2)^2)^(1 / 3)
)

all.equal(
  generalized_logmean(0.5)(1, 2),
  (arithmetic_mean(1:2) + geometric_mean(1:2)) / 2
)

all.equal(
  logmean(1, 2),
  geometric_mean(1:2)^2 * logmean(1, 1 / 2)
)

#---- Integral representations of the logarithmic mean ----

logmean(2, 3)

integrate(function(t) 2^(1 - t) * 3^t, 0, 1)$value
1 / integrate(function(t) 1 / (2 * (1 - t) + 3 * t), 0, 1)$value

</code></pre>

<hr>
<h2 id='factor_weights'>Factor weights</h2><span id='topic+factor_weights'></span><span id='topic+update_weights'></span>

<h3>Description</h3>

<p>Factor weights to turn the generalized mean of a product into the product
of generalized means. Useful for price-updating the weights in a
generalized-mean index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_weights(r)

update_weights(x, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor_weights_+3A_r">r</code></td>
<td>
<p>A finite number giving the order of the generalized mean.</p>
</td></tr>
<tr><td><code id="factor_weights_+3A_x">x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td></tr>
<tr><td><code id="factor_weights_+3A_w">w</code></td>
<td>
<p>A strictly positive numeric vector of weights, the same length as
<code>x</code>. The default is to equally weight each element of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>factor_weights(r)</code> returns a function to compute weights
<code>u(x, w)</code> such that
</p>
<pre>generalized_mean(r)(x * y, w) ==
  generalized_mean(r)(x, w) * generalized_mean(r)(y, u(x, w))</pre>
<p>This generalizes the result in section C.5 of Chapter 9 of the PPI Manual
for chaining the Young index, and gives a way to chain generalized-mean
price indexes over time.
</p>
<p>Factoring weights with <code>r = 1</code> sometimes gets called price-updating
weights; <code>update_weights()</code> simply calls <code>factor_weights(1)()</code>.
</p>
<p>Factoring weights return a value that is the same length as <code>x</code>,
so any missing values in <code>x</code> or the weights will return <code>NA</code>.
Unless all values are <code>NA</code>, however, the result for will still satisfy
the above identity when <code>na.rm = TRUE</code>.
</p>


<h3>Value</h3>

<p><code>factor_weights()</code> return a function:
</p>
<pre>function(x, w = NULL){...}</pre>
<p><code>update_weights()</code> returns a numeric vector the same length as <code>x</code>.
</p>


<h3>References</h3>

<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2004).
<em>Producer Price Index Manual: Theory and Practice</em>.
International Monetary Fund.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generalized_mean">generalized_mean()</a></code> for the generalized mean.
</p>
<p><code><a href="#topic+grouped">grouped()</a></code> to make these functions operate on grouped data.
</p>
<p>Other weights: 
<code><a href="#topic+scale_weights">scale_weights</a>()</code>,
<code><a href="#topic+transmute_weights">transmute_weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
y &lt;- 4:6
w &lt;- 3:1
# Factor the harmonic mean by chaining the calculation

harmonic_mean(x * y, w)
harmonic_mean(x, w) * harmonic_mean(y, factor_weights(-1)(x, w))

# The common case of an arithmetic mean

arithmetic_mean(x * y, w)
arithmetic_mean(x, w) * arithmetic_mean(y, update_weights(x, w))

# In cases where x and y have the same order, Chebyshev's
# inequality implies that the chained calculation is too small

arithmetic_mean(x * y, w) &gt;
  arithmetic_mean(x, w) * arithmetic_mean(y, w)

</code></pre>

<hr>
<h2 id='geks'>GEKS index</h2><span id='topic+geks'></span><span id='topic+tornqvist_geks'></span><span id='topic+fisher_geks'></span><span id='topic+walsh_geks'></span>

<h3>Description</h3>

<p>Calculate an inter-temporal GEKS price index over a rolling window, as
described in chapter 7 of Balk (2008), by Ivancic et al. (2011), and in
chapter 10 of the CPI manual (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geks(f)

tornqvist_geks(
  p,
  q,
  period,
  product,
  window = nlevels(period),
  n = window - 1L,
  na.rm = FALSE
)

fisher_geks(
  p,
  q,
  period,
  product,
  window = nlevels(period),
  n = window - 1L,
  na.rm = FALSE
)

walsh_geks(
  p,
  q,
  period,
  product,
  window = nlevels(period),
  n = window - 1L,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geks_+3A_f">f</code></td>
<td>
<p>A <a href="#topic+price_indexes">price index function</a> that uses information on both
base and current-period prices and quantities, and satisfies the
time-reversal test. Usually a Törnqvist, Fisher, or Walsh index.</p>
</td></tr>
<tr><td><code id="geks_+3A_p">p</code></td>
<td>
<p>A numeric vector of prices, the same length as <code>q</code>.</p>
</td></tr>
<tr><td><code id="geks_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantities, the same length as <code>p</code>.</p>
</td></tr>
<tr><td><code id="geks_+3A_period">period</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the corresponding time period for each element in <code>p</code> and
<code>q</code>. The ordering of time periods follows the levels of <code>period</code>
to agree with <code><a href="base.html#topic+cut.Date">cut()</a></code>.</p>
</td></tr>
<tr><td><code id="geks_+3A_product">product</code></td>
<td>
<p>A factor, or something that can be coerced into one, that
gives the corresponding product identifier for each element in <code>p</code> and
<code>q</code>.</p>
</td></tr>
<tr><td><code id="geks_+3A_window">window</code></td>
<td>
<p>A positive integer giving the length of the rolling window.
The default is a window that encompasses all periods in <code>period</code>.
Non-integers are truncated towards zero.</p>
</td></tr>
<tr><td><code id="geks_+3A_n">n</code></td>
<td>
<p>A positive integer giving the length of the index series for each
window, starting from the end of the window. For example, if there are 13
periods in <code>window</code>, setting <code>n = 1</code> gives the index for period 13. The
default gives an index for each period in <code>window</code>. Non-integers are
truncated towards zero.</p>
</td></tr>
<tr><td><code id="geks_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code>f</code> to control if missing values are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>geks()</code> returns a function:
</p>
<pre>function(p, q, period, product, window = nlevels(period), n =
         window - 1, na.rm = FALSE){...}</pre>
<p>This calculates a period-over-period GEKS index with the desired
index-number formula, returning a list for each window with a named-numeric
vector of index values.
</p>
<p><code>tornqvist_geks()</code>, <code>fisher_geks()</code>, and <code>walsh_geks()</code> each return a list
with a named numeric vector giving the value of the respective
period-over-period GEKS index for each window.
</p>


<h3>Note</h3>

<p>Like <code><a href="#topic+back_period">back_period()</a></code>, if multiple prices
correspond to a period-product pair, then the back price at a point in time
is always the first price for that product in the previous period. Unlike a
bilateral index, however, duplicated period-product pairs can have more
subtle implications for a multilateral index.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2020).
<em>Consumer Price Index Manual: Theory and Practice</em>.
International Monetary Fund.
</p>
<p>Ivancic, L., Diewert, W. E., and Fox, K. J. (2011). Scanner data, time
aggregation and the construction of price indexes.
<em>Journal of Econometrics</em>, 161(1): 24&ndash;35.
</p>


<h3>See Also</h3>

<p><code>GEKSIndex()</code> in the <span class="pkg">indexNumR</span> package for an implementation of the
GEKS index with more options.
</p>
<p>Other price-indexes: 
<code><a href="#topic+index_weights">index_weights</a>()</code>,
<code><a href="#topic+price_indexes">price_indexes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>price &lt;- 1:6
quantity &lt;- 6:1
period &lt;- rep(1:3, 2)
product &lt;- rep(letters[1:2], each = 3)

tornqvist_geks(price, quantity, period, product)

tornqvist_geks(price, quantity, period, product, window = 2)

# Missing data

quantity[2] &lt;- NA

# Use all non-missing data

fisher_geks(price, quantity, period, product, na.rm = TRUE)

# Remove records with any missing data

fg &lt;- geks(balanced(fisher_index))
fg(price, quantity, period, product, na.rm = TRUE)

# Make a Jevons GEKS index
jevons_geks &lt;- geks(\(p1, p0, ..., na.rm) jevons_index(p1, p0, na.rm))
jevons_geks(price, quantity, period, product)

</code></pre>

<hr>
<h2 id='generalized_mean'>Generalized mean</h2><span id='topic+generalized_mean'></span><span id='topic+arithmetic_mean'></span><span id='topic+geometric_mean'></span><span id='topic+harmonic_mean'></span>

<h3>Description</h3>

<p>Calculate a weighted generalized mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generalized_mean(r)

arithmetic_mean(x, w = NULL, na.rm = FALSE)

geometric_mean(x, w = NULL, na.rm = FALSE)

harmonic_mean(x, w = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalized_mean_+3A_r">r</code></td>
<td>
<p>A finite number giving the order of the generalized mean.</p>
</td></tr>
<tr><td><code id="generalized_mean_+3A_x">x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td></tr>
<tr><td><code id="generalized_mean_+3A_w">w</code></td>
<td>
<p>A strictly positive numeric vector of weights, the same length as
<code>x</code>. The default is to equally weight each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="generalized_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values in <code>x</code> and <code>w</code> be removed? By
default missing values in <code>x</code> or <code>w</code> return a missing value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>generalized_mean()</code> returns a function to compute the
generalized mean of <code>x</code> with weights <code>w</code> and exponent <code>r</code>
(i.e., <code class="reqn">\prod_{i = 1}^{n} x_{i}^{w_{i}}</code> when <code class="reqn">r = 0</code> and
<code class="reqn">\left(\sum_{i = 1}^{n} w_{i} x_{i}^{r}\right)^{1 / r}</code>
otherwise). This is also called the power mean, Hölder mean, or <code class="reqn">l_p</code>
mean. See Bullen (2003, p. 175) for a definition, or
<a href="https://en.wikipedia.org/wiki/Generalized_mean">https://en.wikipedia.org/wiki/Generalized_mean</a>. The generalized mean
is the solution to the optimal prediction problem: choose <code class="reqn">m</code> to
minimize <code class="reqn">\sum_{i = 1}^{n} w_{i} \left[\log(x_{i}) - \log(m)
\right]^2</code> when <code class="reqn">r = 0</code>, <code class="reqn">\sum_{i =
1}^{n} w_{i} \left[x_{i}^r - m^r \right]^2</code> otherwise.
</p>
<p>The functions <code>arithmetic_mean()</code>, <code>geometric_mean()</code>, and
<code>harmonic_mean()</code> compute the arithmetic, geometric, and harmonic (or
subcontrary) means, also known as the Pythagorean means. These are the most
useful means for making price indexes, and correspond to setting
<code>r = 1</code>, <code>r = 0</code>, and <code>r = -1</code> in <code>generalized_mean()</code>.
</p>
<p>Both <code>x</code> and <code>w</code> should be strictly positive (and finite),
especially for the purpose of making a price index. This is not enforced,
but the results may not make sense if the generalized mean is not defined.
There are two exceptions to this.
</p>

<ol>
<li><p> The convention in Hardy et al. (1952, p. 13) is used in cases where <code>x</code>
has zeros: the generalized mean is 0 whenever <code>w</code> is strictly positive and
<code>r</code> &lt; 0. (The analogous convention holds whenever at least one element of <code>x</code>
is <code>Inf</code>: the generalized mean is <code>Inf</code> whenever <code>w</code> is strictly positive
and <code>r</code> &gt; 0.)
</p>
</li>
<li><p> Some authors let <code>w</code> be non-negative and sum to 1 (e.g., Sydsaeter
et al., 2005, p. 47). If <code>w</code> has zeros, then the corresponding element
of <code>x</code> has no impact on the mean whenever <code>x</code> is strictly
positive. Unlike <code><a href="stats.html#topic+weighted.mean">weighted.mean()</a></code>, however,
zeros in <code>w</code> are not strong zeros, so infinite values in <code>x</code> will
propagate even if the corresponding elements of <code>w</code> are zero.
</p>
</li></ol>

<p>The weights are scaled to sum to 1 to satisfy the definition of a
generalized mean. There are certain price indexes where the weights should
not be scaled (e.g., the Vartia-I index); use <code><a href="base.html#topic+sum">sum()</a></code> for
these cases.
</p>
<p>The underlying calculation returned by <code>generalized_mean()</code> is mostly
identical to <code><a href="stats.html#topic+weighted.mean">weighted.mean()</a></code>, with one
important exception: missing values in the weights are not treated
differently than missing values in <code>x</code>. Setting <code>na.rm = TRUE</code>
drops missing values in both <code>x</code> and <code>w</code>, not just <code>x</code>. This
ensures that certain useful identities are satisfied with missing values in
<code>x</code>. In most cases <code>arithmetic_mean()</code> is a drop-in replacement
for <code><a href="stats.html#topic+weighted.mean">weighted.mean()</a></code>.
</p>


<h3>Value</h3>

<p><code>generalized_mean()</code> returns a function:
</p>
<pre>function(x, w = NULL, na.rm = FALSE){...}</pre>
<p>This computes the generalized mean of order <code>r</code> of <code>x</code> with
weights <code>w</code>.
</p>
<p><code>arithmetic_mean()</code>, <code>geometric_mean()</code>, and
<code>harmonic_mean()</code> each return a numeric value for the generalized means
of order 1, 0, and -1.
</p>


<h3>Note</h3>

<p><code>generalized_mean()</code> can be defined on the extended real line, so
that <code>r = -Inf / Inf</code> returns <code><a href="base.html#topic+min">min()</a></code>/<code><a href="base.html#topic+max">max()</a></code>, to agree with the
definition in, e.g., Bullen (2003). This is not implemented, and <code>r</code>
must be finite.
</p>
<p>There are a number of existing functions for calculating <em>unweighted</em>
geometric and harmonic means, namely the <code>geometric.mean()</code> and
<code>harmonic.mean()</code> functions in the <span class="pkg">psych</span> package, the
<code>geomean()</code> function in the <span class="pkg">FSA</span> package, the <code>GMean()</code> and
<code>HMean()</code> functions in the <span class="pkg">DescTools</span> package, and the
<code>geoMean()</code> function in the <span class="pkg">EnvStats</span> package. Similarly, the
<code>ci_generalized_mean()</code> function in the <span class="pkg">Compind</span> package
calculates an <em>unweighted</em> generalized mean.
</p>


<h3>References</h3>

<p>Bullen, P. S. (2003). <em>Handbook of Means and Their Inequalities</em>.
Springer Science+Business Media.
</p>
<p>Fisher, I. (1922). <em>The Making of Index Numbers</em>. Houghton Mifflin
Company.
</p>
<p>Hardy, G., Littlewood, J. E., and Polya, G. (1952). <em>Inequalities</em> (2nd
edition). Cambridge University Press.
</p>
<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2020).
<em>Consumer Price Index Manual: Theory and Practice</em>.
International Monetary Fund.
</p>
<p>Lord, N. (2002). Does Smaller Spread Always Mean Larger Product?
<em>The Mathematical Gazette</em>, 86(506): 273-274.
</p>
<p>Sydsaeter, K., Strom, A., and Berck, P. (2005).
<em>Economists' Mathematical Manual</em> (4th edition). Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transmute_weights">transmute_weights()</a></code> transforms the weights to turn a generalized
mean of order <code class="reqn">r</code> into a generalized mean of order <code class="reqn">s</code>.
</p>
<p><code><a href="#topic+factor_weights">factor_weights()</a></code> calculates the weights to factor a mean of
products into a product of means.
</p>
<p><a href="#topic+price_indexes">price_indexes</a> and <code><a href="#topic+quantity_index">quantity_index()</a></code> for simple
wrappers that use <code>generalized_mean()</code> to calculate common indexes.
</p>
<p><code><a href="#topic+back_period">back_period()</a></code>/<code><a href="#topic+base_period">base_period()</a></code> for a simple utility
function to turn prices in a table into price relatives.
</p>
<p>Other means: 
<code><a href="#topic+extended_mean">extended_mean</a>()</code>,
<code><a href="#topic+lehmer_mean">lehmer_mean</a>()</code>,
<code><a href="#topic+nested_mean">nested_mean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
w &lt;- c(0.25, 0.25, 0.5)

#---- Common generalized means ----

# Arithmetic mean

arithmetic_mean(x, w) # same as weighted.mean(x, w)

# Geometric mean

geometric_mean(x, w) # same as prod(x^w)

# Harmonic mean

harmonic_mean(x, w) # same as 1 / weighted.mean(1 / x, w)

# Quadratic mean / root mean square

generalized_mean(2)(x, w)

# Cubic mean
# Notice that this is larger than the other means so far because
# the generalized mean is increasing in r

generalized_mean(3)(x, w)

#---- Comparing the Pythagorean means ----

# The dispersion between the arithmetic, geometric, and harmonic
# mean usually increases as the variance of 'x' increases

x &lt;- c(1, 3, 5)
y &lt;- c(2, 3, 4)

var(x) &gt; var(y)

arithmetic_mean(x) - geometric_mean(x)
arithmetic_mean(y) - geometric_mean(y)

geometric_mean(x) - harmonic_mean(x)
geometric_mean(y) - harmonic_mean(y)

# But the dispersion between these means is only bounded by the
# variance (Bullen, 2003, p. 156)

arithmetic_mean(x) - geometric_mean(x) &gt;= 2 / 3 * var(x) / (2 * max(x))
arithmetic_mean(x) - geometric_mean(x) &lt;= 2 / 3 * var(x) / (2 * min(x))

# Example by Lord (2002) where the dispersion decreases as the variance
# increases, counter to the claims by Fisher (1922, p. 108) and the
# CPI manual (par. 1.14)

x &lt;- (5 + c(sqrt(5), -sqrt(5), -3)) / 4
y &lt;- (16 + c(7 * sqrt(2), -7 * sqrt(2), 0)) / 16

var(x) &gt; var(y)

arithmetic_mean(x) - geometric_mean(x)
arithmetic_mean(y) - geometric_mean(y)

geometric_mean(x) - harmonic_mean(x)
geometric_mean(y) - harmonic_mean(y)

# The "bias" in the arithmetic and harmonic indexes is also smaller in
# this case, counter to the claim by Fisher (1922, p. 108)

arithmetic_mean(x) * arithmetic_mean(1 / x) - 1
arithmetic_mean(y) * arithmetic_mean(1 / y) - 1

harmonic_mean(x) * harmonic_mean(1 / x) - 1
harmonic_mean(y) * harmonic_mean(1 / y) - 1

#---- Missing values ----

w[2] &lt;- NA

arithmetic_mean(x, w, na.rm = TRUE) # drop the second observation
weighted.mean(x, w, na.rm = TRUE) # still returns NA

</code></pre>

<hr>
<h2 id='grouped'>Grouped operator</h2><span id='topic+grouped'></span>

<h3>Description</h3>

<p>Make a function applicable to grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grouped(f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grouped_+3A_f">f</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="grouped_+3A_...">...</code></td>
<td>
<p>Deprecated. Additional arguments to <code>f</code> that should <em>not</em> be
treated as grouped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function like <code>f</code> with a new argument <code>group</code>. This accepts a factor to
split all other arguments in <code>f</code> into groups before applying <code>f</code> to each
group and combining the results. It is similar to <code><a href="stats.html#topic+ave">ave()</a></code>, but more general.
</p>


<h3>See Also</h3>

<p>Other operators: 
<code><a href="#topic+balanced">balanced</a>()</code>,
<code><a href="#topic+quantity_index">quantity_index</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- price6[[3]]
p0 &lt;- price6[[2]]
q1 &lt;- quantity6[[3]]
q0 &lt;- quantity6[[2]]

# Calculate Tornqvist weights for two groups

f &lt;- factor(rep(letters[1:2], each = 3))
tornqvist_weights &lt;- grouped(index_weights("Tornqvist"))
tornqvist_weights(p1, p0, q1, q0, group = f)

# Calculate a mean like ave(), but with weights

x &lt;- 1:6
w &lt;- c(1:5, NA)
grouped_mean &lt;- grouped(\(x, w) geometric_mean(x, w, na.rm = TRUE))
grouped_mean(x, w, group = f)

# Redistribute weights

w1 &lt;- c(2, 4)
w2 &lt;- 1:6

harmonic_mean(mapply(harmonic_mean, split(x, f), split(w2, f)), w1)

wr &lt;- grouped(scale_weights)(w2, group = f) * w1[f]
harmonic_mean(x, wr)

</code></pre>

<hr>
<h2 id='index_weights'>Index weights</h2><span id='topic+index_weights'></span>

<h3>Description</h3>

<p>Calculate weights for a variety of different price indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_weights(
  type = c("Carli", "Jevons", "Coggeshall", "Dutot", "Laspeyres", "HybridLaspeyres",
    "LloydMoulton", "Palgrave", "Paasche", "HybridPaasche", "Drobisch", "Unnamed",
    "Tornqvist", "Walsh1", "Walsh2", "MarshallEdgeworth", "GearyKhamis", "Vartia1",
    "MontgomeryVartia", "Vartia2", "SatoVartia", "Theil", "Rao", "Lowe", "Young")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_weights_+3A_type">type</code></td>
<td>
<p>The name of the index. See details for the possible types of
indexes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>index_weights()</code> function returns a function to calculate weights
for a variety of price indexes. Weights for the following types of indexes
can be calculated.
</p>

<ul>
<li><p> Carli / Jevons / Coggeshall
</p>
</li>
<li><p> Dutot
</p>
</li>
<li><p> Laspeyres / Lloyd-Moulton
</p>
</li>
<li><p> Hybrid Laspeyres (for use in a harmonic mean)
</p>
</li>
<li><p> Paasche / Palgrave
</p>
</li>
<li><p> Hybrid Paasche (for use in an arithmetic mean)
</p>
</li>
<li><p> Törnqvist / Unnamed
</p>
</li>
<li><p> Drobisch
</p>
</li>
<li><p> Walsh-I (for an arithmetic Walsh index)
</p>
</li>
<li><p> Walsh-II (for a geometric Walsh index)
</p>
</li>
<li><p> Marshall-Edgeworth
</p>
</li>
<li><p> Geary-Khamis
</p>
</li>
<li><p> Montgomery-Vartia / Vartia-I
</p>
</li>
<li><p> Sato-Vartia / Vartia-II
</p>
</li>
<li><p> Theil
</p>
</li>
<li><p> Rao
</p>
</li>
<li><p> Lowe
</p>
</li>
<li><p> Young
</p>
</li></ul>

<p>The weights need not sum to 1, as this normalization isn't always
appropriate (i.e., for the Vartia-I weights).
</p>


<h3>Value</h3>

<p>A function of current and base period prices/quantities that calculates
the relevant weights.
</p>


<h3>Note</h3>

<p>Naming for the indexes and weights generally follows the CPI manual (2020),
Balk (2008), and Selvanathan and Rao (1994). In several cases two or more
names correspond to the same weights (e.g., Paasche and Palgrave, or
Sato-Vartia and Vartia-II). The calculations are given in the examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_weights">update_weights()</a></code> for price-updating weights.
</p>
<p><code><a href="#topic+quantity_index">quantity_index()</a></code> to remap the arguments in these functions for a
quantity index.
</p>
<p>Other price-indexes: 
<code><a href="#topic+geks">geks</a>()</code>,
<code><a href="#topic+price_indexes">price_indexes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0 &lt;- price6[[2]]
p1 &lt;- price6[[3]]
q0 &lt;- quantity6[[2]]
q1 &lt;- quantity6[[3]]
pb &lt;- price6[[1]]
qb &lt;- quantity6[[1]]

#---- Making the weights for different indexes ----

# Explicit calculation for each of the different weights
# Carli/Jevons/Coggeshall

all.equal(index_weights("Carli")(p1), rep(1, length(p0)))

# Dutot

all.equal(index_weights("Dutot")(p0), p0)

# Laspeyres / Lloyd-Moulton

all.equal(index_weights("Laspeyres")(p0, q0), p0 * q0)

# Hybrid Laspeyres

all.equal(index_weights("HybridLaspeyres")(p1, q0), p1 * q0)

# Paasche / Palgrave

all.equal(index_weights("Paasche")(p1, q1), p1 * q1)

# Hybrid Paasche

all.equal(index_weights("HybridPaasche")(p0, q1), p0 * q1)

# Tornqvist / Unnamed

all.equal(
  index_weights("Tornqvist")(p1, p0, q1, q0),
  0.5 * p0 * q0 / sum(p0 * q0) + 0.5 * p1 * q1 / sum(p1 * q1)
)

# Drobisch

all.equal(
  index_weights("Drobisch")(p1, p0, q1, q0),
  0.5 * p0 * q0 / sum(p0 * q0) + 0.5 * p0 * q1 / sum(p0 * q1)
)

# Walsh-I

all.equal(
  index_weights("Walsh1")(p0, q1, q0),
  p0 * sqrt(q0 * q1)
)

# Marshall-Edgeworth

all.equal(
  index_weights("MarshallEdgeworth")(p0, q1, q0),
  p0 * (q0 + q1)
)

# Geary-Khamis

all.equal(
  index_weights("GearyKhamis")(p0, q1, q0),
  p0 / (1 / q0 + 1 / q1)
)

# Montgomery-Vartia / Vartia-I

all.equal(
  index_weights("MontgomeryVartia")(p1, p0, q1, q0),
  logmean(p0 * q0, p1 * q1) / logmean(sum(p0 * q0), sum(p1 * q1))
)

# Sato-Vartia / Vartia-II

all.equal(
  index_weights("SatoVartia")(p1, p0, q1, q0),
  logmean(p0 * q0 / sum(p0 * q0), p1 * q1 / sum(p1 * q1))
)

# Walsh-II

all.equal(
  index_weights("Walsh2")(p1, p0, q1, q0),
  sqrt(p0 * q0 * p1 * q1)
)

# Theil

all.equal(index_weights("Theil")(p1, p0, q1, q0), {
  w0 &lt;- scale_weights(p0 * q0)
  w1 &lt;- scale_weights(p1 * q1)
  (w0 * w1 * (w0 + w1) / 2)^(1 / 3)
})

# Rao

all.equal(index_weights("Rao")(p1, p0, q1, q0), {
  w0 &lt;- scale_weights(p0 * q0)
  w1 &lt;- scale_weights(p1 * q1)
  w0 * w1 / (w0 + w1)
})

# Lowe

all.equal(index_weights("Lowe")(p0, qb), p0 * qb)

# Young

all.equal(index_weights("Young")(pb, qb), pb * qb)

</code></pre>

<hr>
<h2 id='lehmer_mean'>Lehmer mean</h2><span id='topic+lehmer_mean'></span><span id='topic+contraharmonic_mean'></span>

<h3>Description</h3>

<p>Calculate a weighted Lehmer mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lehmer_mean(r)

contraharmonic_mean(x, w = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lehmer_mean_+3A_r">r</code></td>
<td>
<p>A finite number giving the order of the Lehmer mean.</p>
</td></tr>
<tr><td><code id="lehmer_mean_+3A_x">x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td></tr>
<tr><td><code id="lehmer_mean_+3A_w">w</code></td>
<td>
<p>A strictly positive numeric vector of weights, the same length as
<code>x</code>. The default is to equally weight each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="lehmer_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values in <code>x</code> and <code>w</code> be removed? By
default missing values in <code>x</code> or <code>w</code> return a missing value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>lehmer_mean()</code> returns a function to compute the Lehmer
mean of order <code>r</code> of <code>x</code> with weights <code>w</code>, which is
calculated as the arithmetic mean of <code>x</code> with weights <code class="reqn">wx^{r-1}</code>.
This is also called the counter-harmonic mean or generalized anti-harmonic
mean. See Bullen (2003, p. 245) for a definition, or
<a href="https://en.wikipedia.org/wiki/Lehmer_mean">https://en.wikipedia.org/wiki/Lehmer_mean</a>.
</p>
<p>The Lehmer mean of order 2 is sometimes called the contraharmonic (or
anti-harmonic) mean. The function <code>contraharmonic_mean()</code> simply calls
<code>lehmer_mean(2)()</code>. Like the generalized mean, the contraharmonic mean
is the solution to an optimal prediction problem: choose <code class="reqn">m</code> to minimize
<code class="reqn">\sum_{i = 1}^{n} w_{i} \left(\frac{x_{i}}{m} - 1 \right)^2</code>. The Lehmer mean of order -1 has a similar interpretation,
replacing <code class="reqn">\frac{x_{i}}{m}</code> with <code class="reqn">\frac{m}{x_{i}}</code>,
and together these bound the harmonic and arithmetic means.
</p>
<p>The Lehmer mean is an alternative to the generalized mean that generalizes
the Pythagorean means. The function <code>lehmer_mean(1)()</code> is identical to
<code>arithmetic_mean()</code>, <code>lehmer_mean(0)()</code> is identical to
<code>harmonic_mean()</code>, and <code>lehmer_mean(0.5)()</code> is identical to
<code>geometric_mean()</code> with two values and no weights. See von der Lippe
(2015) for more details on the use of these means for making price indexes.
</p>


<h3>Value</h3>

<p><code>lehmer_mean()</code> returns a function:
</p>
<pre>function(x, w = NULL, na.rm = FALSE){...}</pre>
<p>This computes the Lehmer mean of order <code>r</code> of <code>x</code> with weights
<code>w</code>.
</p>
<p><code>contraharmonic_mean()</code> returns a numeric value for the Lehmer mean of
order 2.
</p>


<h3>Note</h3>

<p><code>lehmer_mean()</code> can be defined on the extended real line, so that
<code>r = -Inf / Inf</code> returns <code><a href="base.html#topic+min">min()</a></code>/<code><a href="base.html#topic+max">max()</a></code>, to agree with the
definition in, e.g., Bullen (2003). This is not implemented, and <code>r</code>
must be finite.
</p>


<h3>References</h3>

<p>Bullen, P. S. (2003). <em>Handbook of Means and Their Inequalities</em>.
Springer Science+Business Media.
</p>
<p>Lehmer, D. H. (1971). On the Compounding of Certain Means.
<em>Journal of Mathematical Analysis and Applications</em>, 36(1): 183-200.
</p>
<p>von der Lippe, P. (2015). Generalized Statistical Means and New Price Index
Formulas, Notes on some unexplored index formulas, their interpretations and
generalizations. Munich Personal RePEc Archive paper no. 64952.
</p>


<h3>See Also</h3>

<p>Other means: 
<code><a href="#topic+extended_mean">extended_mean</a>()</code>,
<code><a href="#topic+generalized_mean">generalized_mean</a>()</code>,
<code><a href="#topic+nested_mean">nested_mean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 2:3
w &lt;- c(0.25, 0.75)

#---- The Pythagorean means are special cases of the Lehmer mean ----

all.equal(lehmer_mean(1)(x, w), arithmetic_mean(x, w))
all.equal(lehmer_mean(0)(x, w), harmonic_mean(x, w))
all.equal(lehmer_mean(0.5)(x), geometric_mean(x))

#---- Comparing Lehmer means and generalized means ----

# When r &lt; 1, the generalized mean is larger than the corresponding
# Lehmer mean

lehmer_mean(-1)(x, w) &lt; generalized_mean(-1)(x, w)

# The reverse is true when r &gt; 1

lehmer_mean(3)(x, w) &gt; generalized_mean(3)(x, w)

# This implies the contraharmonic mean is larger than the quadratic
# mean, and therefore the Pythagorean means

contraharmonic_mean(x, w) &gt; arithmetic_mean(x, w)
contraharmonic_mean(x, w) &gt; geometric_mean(x, w)
contraharmonic_mean(x, w) &gt; harmonic_mean(x, w)

# ... and the logarithmic mean

contraharmonic_mean(2:3) &gt; logmean(2, 3)

# The difference between the arithmetic mean and contraharmonic mean
# is proportional to the variance of x

weighted_var &lt;- function(x, w) {
  arithmetic_mean(x^2, w) - arithmetic_mean(x, w)^2
}

arithmetic_mean(x, w) + weighted_var(x, w) / arithmetic_mean(x, w)
contraharmonic_mean(x, w)

#---- Changing the order of the mean ----

# It is easy to modify the weights to turn a Lehmer mean of order r
# into a Lehmer mean of order s because the Lehmer mean can be
# expressed as an arithmetic mean

r &lt;- 2
s &lt;- -3
lehmer_mean(r)(x, w)
lehmer_mean(s)(x, w * x^(r - 1) / x^(s - 1))

# The weights can also be modified to turn a Lehmer mean of order r
# into a generalized mean of order s

lehmer_mean(r)(x, w)
generalized_mean(s)(x, transmute_weights(1, s)(x, w * x^(r - 1)))

# ... and vice versa

lehmer_mean(r)(x, transmute_weights(s, 1)(x, w) / x^(r - 1))
generalized_mean(s)(x, w)

#---- Percent-change contributions ----

# Percent-change contributions for a price index based on the Lehmer
# mean are easy to calculate

scale_weights(w * x^(r - 1)) * (x - 1)

</code></pre>

<hr>
<h2 id='nested_mean'>Nested generalized mean</h2><span id='topic+nested_mean'></span><span id='topic+fisher_mean'></span>

<h3>Description</h3>

<p>Calculate the (outer) generalized mean of two (inner) generalized means
(i.e., crossing generalized means).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_mean(r1, r2, t = c(1, 1))

fisher_mean(x, w1 = NULL, w2 = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nested_mean_+3A_r1">r1</code></td>
<td>
<p>A finite number giving the order of the outer generalized mean.</p>
</td></tr>
<tr><td><code id="nested_mean_+3A_r2">r2</code></td>
<td>
<p>A pair of finite numbers giving the order of the inner generalized
means.</p>
</td></tr>
<tr><td><code id="nested_mean_+3A_t">t</code></td>
<td>
<p>A pair of strictly positive weights for the inner generalized
means. The default is equal weights.</p>
</td></tr>
<tr><td><code id="nested_mean_+3A_x">x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td></tr>
<tr><td><code id="nested_mean_+3A_w1">w1</code>, <code id="nested_mean_+3A_w2">w2</code></td>
<td>
<p>A strictly positive numeric vector of weights, the same length
as <code>x</code>. The default is to equally weight each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="nested_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values in <code>x</code>, <code>w1</code>, and <code>w2</code> be
removed? By default missing values in <code>x</code>, <code>w1</code>, or <code>w2</code>
return a missing value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nested_mean()</code> returns a function:
</p>
<pre>function(x, w1 = NULL, w2 = NULL, na.rm = FALSE){...}</pre>
<p>This computes the generalized mean of order <code>r1</code> of the generalized
mean of order <code>r2[1]</code> of <code>x</code> with weights <code>w1</code> and the
generalized mean of order <code>r2[2]</code> of <code>x</code> with weights <code>w2</code>.
</p>
<p><code>fisher_mean()</code> returns a numeric value for the geometric mean of the
arithmetic and harmonic means (i.e., <code>r1 = 0</code> and <code>r2 = c(1, -1)</code>).
</p>


<h3>Note</h3>

<p>There is some ambiguity about how to remove missing values in
<code>w1</code> or <code>w2</code> when <code>na.rm = TRUE</code>. The approach here is to
remove missing values when calculating each of the inner means individually,
rather than removing all missing values prior to any calculations. This
means that a different number of data points could be used to calculate the
inner means. Use the <code><a href="#topic+balanced">balanced()</a></code> operator to balance
missing values across <code>w1</code> and w2 prior to any calculations.
</p>


<h3>References</h3>

<p>Diewert, W. E. (1976). Exact and superlative index numbers.
<em>Journal of Econometrics</em>, 4(2): 114&ndash;145.
</p>
<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2004).
<em>Producer Price Index Manual: Theory and Practice</em>. International Monetary
Fund.
</p>
<p>Lent, J. and Dorfman, A. H. (2009). Using a weighted average of base period
price indexes to approximate a superlative index.
<em>Journal of Official Statistics</em>, 25(1):139&ndash;149.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested_contributions">nested_contributions()</a></code> for percent-change contributions for
indexes based on nested generalized means, like the Fisher index.
</p>
<p>Other means: 
<code><a href="#topic+extended_mean">extended_mean</a>()</code>,
<code><a href="#topic+generalized_mean">generalized_mean</a>()</code>,
<code><a href="#topic+lehmer_mean">lehmer_mean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
w1 &lt;- 4:6
w2 &lt;- 7:9

#---- Making superlative indexes ----

# A function to make the superlative quadratic mean price index by
# Diewert (1976) as a product of generalized means

quadratic_mean_index &lt;- function(x, w0, w1, r) {
  x &lt;- sqrt(x)
  generalized_mean(r)(x, w0) * generalized_mean(-r)(x, w1)
}

quadratic_mean_index(x, w1, w2, 2)

# Same as the nested generalized mean (with the order halved)

quadratic_mean_index2 &lt;- function(r) nested_mean(0, c(r / 2, -r / 2))

quadratic_mean_index2(2)(x, w1, w2)

# The arithmetic AG mean index by Lent and Dorfman (2009)

agmean_index &lt;- function(tau) nested_mean(1, c(0, 1), c(tau, 1 - tau))

agmean_index(0.25)(x, w1, w1)

#---- Walsh index ----

# The (arithmetic) Walsh index is the implicit price index when using a
# superlative quadratic mean quantity index of order 1

p1 &lt;- price6[[2]]
p0 &lt;- price6[[1]]
q1 &lt;- quantity6[[2]]
q0 &lt;- quantity6[[1]]

walsh &lt;- quadratic_mean_index2(1)

sum(p1 * q1) / sum(p0 * q0) / walsh(q1 / q0, p0 * q0, p1 * q1)

sum(p1 * sqrt(q1 * q0)) / sum(p0 * sqrt(q1 * q0))

# Counter to the PPI manual (par. 1.105), it is not a superlative
# quadratic mean price index of order 1

walsh(p1 / p0, p0 * q0, p1 * q1)

#---- Missing values ----

x[1] &lt;- NA
w1[2] &lt;- NA

fisher_mean(x, w1, w2, na.rm = TRUE)

# Same as using obs 2 and 3 in an arithmetic mean, and obs 3 in a
# harmonic mean

geometric_mean(c(
  arithmetic_mean(x, w1, na.rm = TRUE),
  harmonic_mean(x, w2, na.rm = TRUE)
))

# Use balanced() to use only obs 3 in both inner means

balanced(fisher_mean)(x, w1, w2, na.rm = TRUE)

</code></pre>

<hr>
<h2 id='outliers'>Outlier detection for price relatives</h2><span id='topic+outliers'></span><span id='topic+quartile_method'></span><span id='topic+resistant_fences'></span><span id='topic+robust_z'></span><span id='topic+fixed_cutoff'></span><span id='topic+tukey_algorithm'></span><span id='topic+hb_transform'></span>

<h3>Description</h3>

<p>Standard cutoff-based methods for detecting outliers with price relatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartile_method(x, cu = 2.5, cl = cu, a = 0, type = 7)

resistant_fences(x, cu = 2.5, cl = cu, a = 0, type = 7)

robust_z(x, cu = 2.5, cl = cu)

fixed_cutoff(x, cu = 2.5, cl = 1/cu)

tukey_algorithm(x, cu = 2.5, cl = cu, type = 7)

hb_transform(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outliers_+3A_x">x</code></td>
<td>
<p>A strictly positive numeric vector of price relatives. These can be
made with, e.g., <code><a href="#topic+back_period">back_period()</a></code>.</p>
</td></tr>
<tr><td><code id="outliers_+3A_cu">cu</code>, <code id="outliers_+3A_cl">cl</code></td>
<td>
<p>A numeric vector, or something that can be coerced into one,
giving the upper and lower cutoffs for each element of <code>x</code>. Recycled to the
same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="outliers_+3A_a">a</code></td>
<td>
<p>A numeric vector, or something that can be coerced into one,
between 0 and 1 giving the scale factor for the median to establish the
minimum dispersion between quartiles for each element of <code>x</code>. The default
does not set a minimum dispersion. Recycled to the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="outliers_+3A_type">type</code></td>
<td>
<p>See <code><a href="stats.html#topic+quantile">quantile()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of these functions constructs an interval of the form <code class="reqn">[b_l(x) -
c_l \times l(x), b_u(x) + c_u \times u(x)]</code> and assigns a value in <code>x</code> as <code>TRUE</code> if that value does not
belong to the interval, <code>FALSE</code> otherwise. The methods differ in how
they construct the values <code class="reqn">b_l(x)</code>, <code class="reqn">b_u(x)</code>,
<code class="reqn">l(x)</code>, and <code class="reqn">u(x)</code>. Any missing values in <code>x</code> are ignored when
calculating the cutoffs, but will return <code>NA</code>.
</p>
<p>The fixed cutoff method is the simplest, and just uses the interval
<code class="reqn">[c_l, c_u]</code>.
</p>
<p>The quartile method and Tukey algorithm are described in paragraphs 5.113 to
5.135 of the CPI manual (2020), as well as by Rais (2008) and Hutton (2008).
The resistant fences method is an alternative to the quartile method, and is
described by Rais (2008) and Hutton (2008). Quantile-based methods often
identify price relatives as outliers because the distribution is
concentrated around 1; setting <code>a &gt; 0</code> puts a floor on the minimum
dispersion between quantiles as a fraction of the median. See the references
for more details.
</p>
<p>The robust Z-score is the usual method to identify relatives in the
(asymmetric) tails of the distribution, simply replacing the mean with the
median, and the standard deviation with the median absolute deviation.
</p>
<p>These methods often assume that price relatives are symmetrically
distributed (if not Gaussian). As the distribution of price relatives often
has a long right tail, the natural logarithm can be used to transform price
relative before identifying outliers (sometimes under the assumption that
price relatives are distributed log-normal). The Hidiroglou-Berthelot
transformation is another approach, described in the CPI manual (par.
5.124).
</p>


<h3>Value</h3>

<p>A logical vector, the same length as <code>x</code>, that is <code>TRUE</code> if the
corresponding element of <code>x</code> is identified as an outlier,
<code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Hutton, H. (2008). Dynamic outlier detection in price index surveys.
<em>Proceedings of the Survey Methods Section: Statistical Society of Canada Annual Meeting</em>.
</p>
<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2020).
<em>Consumer Price Index Manual: Theory and Practice</em>.
International Monetary Fund.
</p>
<p>Rais, S. (2008). Outlier detection for the Consumer Price Index.
<em>Proceedings of the Survey Methods Section: Statistical Society of Canada Annual Meeting</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grouped">grouped()</a></code> to make each of these functions operate on grouped data.
</p>
<p><code><a href="#topic+back_period">back_period()</a></code>/<code><a href="#topic+base_period">base_period()</a></code> for a simple utility function to turn prices
in a table into price relatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

x &lt;- rlnorm(10)

fixed_cutoff(x)
robust_z(x)
quartile_method(x)
resistant_fences(x) # always identifies fewer outliers than above
tukey_algorithm(x)

log(x)
hb_transform(x)

# Works the same for grouped data

f &lt;- c("a", "b", "a", "a", "b", "b", "b", "a", "a", "b")
grouped(quartile_method)(x, group = f)

</code></pre>

<hr>
<h2 id='price_data'>Sample price/quantity data</h2><span id='topic+price_data'></span><span id='topic+price6'></span><span id='topic+quantity6'></span>

<h3>Description</h3>

<p>Prices and quantities for six products over five periods.
</p>


<h3>Format</h3>

<p>Each data frame has 6 rows and 5 columns, with each row corresponding
to a product and each column corresponding to a time period.
</p>


<h3>Note</h3>

<p>Adapted from tables 3.1 and 3.2 in Balk (2008), which were adapted
from tables 19.1 and 19.2 in the PPI manual.
</p>


<h3>Source</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2004). <em>Producer Price
Index Manual: Theory and Practice</em>. International Monetary Fund.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Recreate tables 3.4, 3.6, and 3.12 from Balk (2008)

index_formulas &lt;- function(p1, p0, q1, q0) {
  c(
    harmonic_laspeyres = harmonic_index("Laspeyres")(p1, p0, q0),
    geometric_laspeyres = geometric_index("Laspeyres")(p1, p0, q0),
    laspeyres = arithmetic_index("Laspeyres")(p1, p0, q0),
    paasche = harmonic_index("Paasche")(p1, p0, q1),
    geometric_paasche = geometric_index("Paasche")(p1, p0, q1),
    palgrave = arithmetic_index("Palgrave")(p1, p0, q1),
    fisher = fisher_index(p1, p0, q1, q0),
    tornqvist = geometric_index("Tornqvist")(p1, p0, q1, q0),
    marshall_edgeworth = arithmetic_index("MarshallEdgeworth")(p1, p0, q1, q0),
    walsh1 = arithmetic_index("Walsh1")(p1, p0, q1, q0),
    vartia2 = geometric_index("Vartia2")(p1, p0, q1, q0),
    vartia1 = geometric_index("Vartia1")(p1, p0, q1, q0),
    stuvel = stuvel_index(2, 2)(p1, p0, q1, q0)
  )
}

round(t(mapply(index_formulas, price6, price6[1], quantity6, quantity6[1])), 4)

</code></pre>

<hr>
<h2 id='price_indexes'>Price indexes</h2><span id='topic+price_indexes'></span><span id='topic+arithmetic_index'></span><span id='topic+geometric_index'></span><span id='topic+harmonic_index'></span><span id='topic+laspeyres_index'></span><span id='topic+paasche_index'></span><span id='topic+jevons_index'></span><span id='topic+lowe_index'></span><span id='topic+young_index'></span><span id='topic+fisher_index'></span><span id='topic+hlp_index'></span><span id='topic+lm_index'></span><span id='topic+cswd_index'></span><span id='topic+cswdb_index'></span><span id='topic+bw_index'></span><span id='topic+stuvel_index'></span><span id='topic+arithmetic_agmean_index'></span><span id='topic+geometric_agmean_index'></span><span id='topic+lehr_index'></span>

<h3>Description</h3>

<p>Calculate a variety of price indexes using information on prices and
quantities at two points in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arithmetic_index(type)

geometric_index(type)

harmonic_index(type)

laspeyres_index(p1, p0, q0, na.rm = FALSE)

paasche_index(p1, p0, q1, na.rm = FALSE)

jevons_index(p1, p0, na.rm = FALSE)

lowe_index(p1, p0, qb, na.rm = FALSE)

young_index(p1, p0, pb, qb, na.rm = FALSE)

fisher_index(p1, p0, q1, q0, na.rm = FALSE)

hlp_index(p1, p0, q1, q0, na.rm = FALSE)

lm_index(elasticity)

cswd_index(p1, p0, na.rm = FALSE)

cswdb_index(p1, p0, q1, q0, na.rm = FALSE)

bw_index(p1, p0, na.rm = FALSE)

stuvel_index(a, b)

arithmetic_agmean_index(elasticity)

geometric_agmean_index(elasticity)

lehr_index(p1, p0, q1, q0, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price_indexes_+3A_type">type</code></td>
<td>
<p>The name of the index. See details for the possible types of
indexes.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_p1">p1</code></td>
<td>
<p>Current-period prices.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_p0">p0</code></td>
<td>
<p>Base-period prices.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_q0">q0</code></td>
<td>
<p>Base-period quantities.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be removed? By default missing values for
prices or quantities return a missing value.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_q1">q1</code></td>
<td>
<p>Current-period quantities.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_qb">qb</code></td>
<td>
<p>Period-b quantities for the Lowe/Young index.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_pb">pb</code></td>
<td>
<p>Period-b prices for the Lowe/Young index.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_elasticity">elasticity</code></td>
<td>
<p>The elasticity of substitution for the Lloyd-Moulton and
AG mean indexes.</p>
</td></tr>
<tr><td><code id="price_indexes_+3A_a">a</code>, <code id="price_indexes_+3A_b">b</code></td>
<td>
<p>Parameters for the generalized Stuvel index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>arithmetic_index()</code>, <code>geometric_index()</code>, and
<code>harmonic_index()</code> functions return a function to calculate a given
type of arithmetic, geometric (logarithmic), and harmonic index. Together,
these functions produce functions to calculate the following indexes.
</p>

<ul>
<li> <p><strong>Arithmetic indexes</strong>
</p>
</li>
<li><p> Carli
</p>
</li>
<li><p> Dutot
</p>
</li>
<li><p> Laspeyres
</p>
</li>
<li><p> Palgrave
</p>
</li>
<li><p> Unnamed index (arithmetic mean of Laspeyres and Palgrave)
</p>
</li>
<li><p> Drobisch (arithmetic mean of Laspeyres and Paasche)
</p>
</li>
<li><p> Walsh-I (arithmetic Walsh)
</p>
</li>
<li><p> Marshall-Edgeworth
</p>
</li>
<li><p> Geary-Khamis
</p>
</li>
<li><p> Lowe
</p>
</li>
<li><p> Young
</p>
</li>
<li> <p><strong>Geometric indexes</strong>
</p>
</li>
<li><p> Jevons
</p>
</li>
<li><p> Geometric Laspeyres
</p>
</li>
<li><p> Geometric Paasche
</p>
</li>
<li><p> Geometric Young
</p>
</li>
<li><p> Törnqvist (or Törnqvist-Theil)
</p>
</li>
<li><p> Montgomery-Vartia / Vartia-I
</p>
</li>
<li><p> Sato-Vartia / Vartia-II
</p>
</li>
<li><p> Walsh-II (geometric Walsh)
</p>
</li>
<li><p> Theil
</p>
</li>
<li><p> Rao
</p>
</li>
<li> <p><strong>Harmonic indexes</strong>
</p>
</li>
<li><p> Coggeshall (equally weighted harmonic index)
</p>
</li>
<li><p> Paasche
</p>
</li>
<li><p> Harmonic Laspeyres
</p>
</li>
<li><p> Harmonic Young
</p>
</li></ul>

<p>Along with the <code>lm_index()</code> function to calculate the Lloyd-Moulton
index, these are just convenient wrappers for
<code><a href="#topic+generalized_mean">generalized_mean()</a></code> and <code><a href="#topic+index_weights">index_weights()</a></code>.
</p>
<p>The Laspeyres, Paasche, Jevons, Lowe, and Young indexes are among the most
common price indexes, and so they get their own functions. The
<code>laspeyres_index()</code>, <code>lowe_index()</code>, and <code>young_index()</code>
functions correspond to setting the appropriate <code>type</code> in
<code>arithmetic_index()</code>; <code>paasche_index()</code> and <code>jevons_index()</code>
instead come from the <code>harmonic_index()</code> and <code>geometric_index()</code>
functions.
</p>
<p>In addition to these indexes, there are also functions for calculating a
variety of indexes not based on generalized means. The Fisher index is the
geometric mean of the arithmetic Laspeyres and Paasche indexes; the Harmonic
Laspeyres Paasche index is the harmonic analog of the Fisher index (8054 on
Fisher's list). The Carruthers-Sellwood-Ward-Dalen and
Carruthers-Sellwood-Ward-Dalen-Balk indexes are sample analogs of the Fisher
index; the Balk-Walsh index is the sample analog of the Walsh index. The AG
mean index is the arithmetic or geometric mean of the geometric and
arithmetic Laspeyres indexes, weighted by the elasticity of substitution.
The <code>stuvel_index()</code> function returns a function to calculate a Stuvel
index of the given parameters. The Lehr index is an alternative to the
Geary-Khamis index, and is the implicit price index for Fisher's index 4153.
</p>


<h3>Value</h3>

<p><code>arithmetic_index()</code>, <code>geometric_index()</code>, <code>harmonic_index()</code>, and
<code>stuvel_index()</code> each return a function to compute the relevant price
indexes; <code>lm_index()</code>, <code>arithmetic_agmean_index()</code>, and
<code>geometric_agmean_index()</code> each return a function to calculate the
relevant index for a given elasticity of substitution. The others return a
numeric value giving the change in price between the base period and current
period.
</p>


<h3>Note</h3>

<p>There are different ways to deal with missing values in a price index,
and care should be taken when relying on these functions to remove missing
values. Setting <code>na.rm = TRUE</code> removes price relatives with missing
information, either because of a missing price or a missing weight, while
using all available non-missing information to make the weights.
</p>
<p>Certain properties of an index-number formula may not work as expected when
removing missing values if there is ambiguity about how to remove missing
values from the weights (as in, e.g., a Törnqvist or Sato-Vartia index). The
<code><a href="#topic+balanced">balanced()</a></code> operator may be helpful, as it balances the removal of missing
values across prices and quantities prior to making the weights.
</p>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>Fisher, I. (1922). <em>The Making of Index Numbers</em>. Houghton Mifflin
Company.
</p>
<p>ILO, IMF, OECD, Eurostat, UN, and World Bank. (2020).
<em>Consumer Price Index Manual: Theory and Practice</em>.
International Monetary Fund.
</p>
<p>von der Lippe, P. (2001).
<em>Chain Indices: A Study in Price Index Theory</em>, Spectrum of Federal
Statistics vol. 16. Federal Statistical Office, Wiesbaden.
</p>
<p>von der Lippe, P. (2015). Generalized Statistical Means and New Price Index
Formulas, Notes on some unexplored index formulas, their interpretations and
generalizations. Munich Personal RePEc Archive paper no. 64952.
</p>
<p>Selvanathan, E. A. and Rao, D. S. P. (1994).
<em>Index Numbers: A Stochastic Approach</em>. MacMillan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generalized_mean">generalized_mean()</a></code> for the generalized mean that powers
most of these functions.
</p>
<p><code><a href="#topic+contributions">contributions()</a></code> for calculating percent-change contributions.
</p>
<p><code><a href="#topic+quantity_index">quantity_index()</a></code> to remap the arguments in these functions for a
quantity index.
</p>
<p><code><a href="#topic+price6">price6()</a></code> for an example of how to use these functions with more
than two time periods.
</p>
<p>The <span class="pkg">piar</span> package has more functionality working with price indexes for
multiple groups of products over many time periods.
</p>
<p>Other price-indexes: 
<code><a href="#topic+geks">geks</a>()</code>,
<code><a href="#topic+index_weights">index_weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p0 &lt;- price6[[2]]
p1 &lt;- price6[[3]]
q0 &lt;- quantity6[[2]]
q1 &lt;- quantity6[[3]]
pb &lt;- price6[[1]]
qb &lt;- quantity6[[1]]

#---- Calculating price indexes ----

# Most indexes can be calculated by combining the appropriate weights
# with the correct type of mean

geometric_index("Laspeyres")(p1, p0, q0)
geometric_mean(p1 / p0, index_weights("Laspeyres")(p0, q0))

# Arithmetic Laspeyres index

laspeyres_index(p1, p0, q0)
arithmetic_mean(p1 / p0, index_weights("Laspeyres")(p0, q0))

# Harmonic calculation for the arithmetic Laspeyres

harmonic_mean(p1 / p0, index_weights("HybridLaspeyres")(p1, q0))

# Same as transmuting the weights

all.equal(
  scale_weights(index_weights("HybridLaspeyres")(p1, q0)),
  scale_weights(
    transmute_weights(1, -1)(p1 / p0, index_weights("Laspeyres")(p0, q0))
  )
)

# This strategy can be used to make more exotic indexes, like the
# quadratic-mean index (von der Lippe, 2001, p. 71)

generalized_mean(2)(p1 / p0, index_weights("Laspeyres")(p0, q0))

# Or the exponential mean index (p. 64)

log(arithmetic_mean(exp(p1 / p0), index_weights("Laspeyres")(p0, q0)))

# Or the arithmetic hybrid index (von der Lippe, 2015, p. 5)

arithmetic_mean(p1 / p0, index_weights("HybridLaspeyres")(p1, q0))
contraharmonic_mean(p1 / p0, index_weights("Laspeyres")(p0, q0))

# Unlike its arithmetic counterpart, the geometric Laspeyres can
# increase when base-period prices increase if some of these prices
# are small

gl &lt;- geometric_index("Laspeyres")
p0_small &lt;- replace(p0, 1, p0[1] / 5)
p0_dx &lt;- replace(p0_small, 1, p0_small[1] + 0.01)
gl(p1, p0_small, q0) &lt; gl(p1, p0_dx, q0)

#---- Price updating the weights in a price index ----

# Chain an index by price updating the weights

p2 &lt;- price6[[4]]
laspeyres_index(p2, p0, q0)

I1 &lt;- laspeyres_index(p1, p0, q0)
w_pu &lt;- update_weights(p1 / p0, index_weights("Laspeyres")(p0, q0))
I2 &lt;- arithmetic_mean(p2 / p1, w_pu)
I1 * I2

# Works for other types of indexes, too

harmonic_index("Laspeyres")(p2, p0, q0)

I1 &lt;- harmonic_index("Laspeyres")(p1, p0, q0)
w_pu &lt;- factor_weights(-1)(p1 / p0, index_weights("Laspeyres")(p0, q0))
I2 &lt;- harmonic_mean(p2 / p1, w_pu)
I1 * I2

#---- Percent-change contributions ----

# Percent-change contributions for the Tornqvist index

w &lt;- index_weights("Tornqvist")(p1, p0, q1, q0)
(con &lt;- geometric_contributions(p1 / p0, w))

all.equal(sum(con), geometric_index("Tornqvist")(p1, p0, q1, q0) - 1)

#---- Missing values ----

# NAs get special treatment

p_na &lt;- replace(p0, 6, NA)

# Drops the last price relative

laspeyres_index(p1, p_na, q0, na.rm = TRUE)

# Only drops the last period-0 price

sum(p1 * q0, na.rm = TRUE) / sum(p_na * q0, na.rm = TRUE)

#---- von Bortkiewicz decomposition ----

paasche_index(p1, p0, q1) / laspeyres_index(p1, p0, q0) - 1

wl &lt;- scale_weights(index_weights("Laspeyres")(p0, q0))
pl &lt;- laspeyres_index(p1, p0, q0)
ql &lt;- quantity_index(laspeyres_index)(q1, q0, p0)

sum(wl * (p1 / p0 / pl - 1) * (q1 / q0 / ql - 1))

# Similar decomposition for geometric Laspeyres/Paasche

wp &lt;- scale_weights(index_weights("Paasche")(p1, q1))
gl &lt;- geometric_index("Laspeyres")(p1, p0, q0)
gp &lt;- geometric_index("Paasche")(p1, p0, q1)

log(gp / gl)

sum(scale_weights(wl) * (wp / wl - 1) * log(p1 / p0 / gl))

#---- Consistency in aggregation ----

p0a &lt;- p0[1:3]
p0b &lt;- p0[4:6]
p1a &lt;- p1[1:3]
p1b &lt;- p1[4:6]
q0a &lt;- q0[1:3]
q0b &lt;- q0[4:6]
q1a &lt;- q1[1:3]
q1b &lt;- q1[4:6]

# Indexes based on the generalized mean with value share weights are
# consistent in aggregation

lm_index(0.75)(p1, p0, q0)

w &lt;- index_weights("LloydMoulton")(p0, q0)
Ia &lt;- generalized_mean(0.25)(p1a / p0a, w[1:3])
Ib &lt;- generalized_mean(0.25)(p1b / p0b, w[4:6])
generalized_mean(0.25)(c(Ia, Ib), c(sum(w[1:3]), sum(w[4:6])))

# Agrees with group-wise indexes

all.equal(lm_index(0.75)(p1a, p0a, q0a), Ia)
all.equal(lm_index(0.75)(p1b, p0b, q0b), Ib)

# Care is needed with more complex weights, e.g., Drobisch, as this
# doesn't fit Balk's (2008) definition (p. 113) of a generalized-mean
# index (it's the arithmetic mean of a Laspeyres and Paasche index)

arithmetic_index("Drobisch")(p1, p0, q1, q0)

w &lt;- index_weights("Drobisch")(p1, p0, q1, q0)
Ia &lt;- arithmetic_mean(p1a / p0a, w[1:3])
Ib &lt;- arithmetic_mean(p1b / p0b, w[4:6])
arithmetic_mean(c(Ia, Ib), c(sum(w[1:3]), sum(w[4:6])))

# Does not agree with group-wise indexes

all.equal(arithmetic_index("Drobisch")(p1a, p0a, q1a, q0a), Ia)
all.equal(arithmetic_index("Drobisch")(p1b, p0b, q1b, q0b), Ib)

</code></pre>

<hr>
<h2 id='quantity_index'>Quantity index operator</h2><span id='topic+quantity_index'></span>

<h3>Description</h3>

<p>Remaps price arguments into quantity argument (and vice versa) to turn a
price index into a quantity index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantity_index(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantity_index_+3A_f">f</code></td>
<td>
<p>A <a href="#topic+price_indexes">price-index function</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function like <code>f</code>, except that the role of prices/quantities is reversed.
</p>


<h3>See Also</h3>

<p>Other operators: 
<code><a href="#topic+balanced">balanced</a>()</code>,
<code><a href="#topic+grouped">grouped</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- price6[[3]]
p0 &lt;- price6[[2]]
q1 &lt;- quantity6[[3]]
q0 &lt;- quantity6[[2]]

# Remap argument names to be quantities rather than prices

quantity_index(laspeyres_index)(q1 = q1, q0 = q0, p0 = p0)

laspeyres_index(p1 = q1, p0 = q0, q0 = p0)

# Works with the index_weights() functions, too

quantity_index(index_weights("Laspeyres"))(q0 = q0, p0 = p0)

</code></pre>

<hr>
<h2 id='scale_weights'>Scale weights</h2><span id='topic+scale_weights'></span>

<h3>Description</h3>

<p>Scale a vector of weights so that they sum to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_weights(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_weights_+3A_x">x</code></td>
<td>
<p>A strictly positive numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector that sums to 1. If there are <code>NA</code>s in <code>x</code> then the result
sums 1 to if these values are removed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grouped">grouped()</a></code> to make this function applicable to grouped data.
</p>
<p>Other weights: 
<code><a href="#topic+factor_weights">factor_weights</a>()</code>,
<code><a href="#topic+transmute_weights">transmute_weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_weights(1:5)

</code></pre>

<hr>
<h2 id='transmute_weights'>Transmute weights</h2><span id='topic+transmute_weights'></span><span id='topic+nested_transmute'></span><span id='topic+nested_transmute2'></span>

<h3>Description</h3>

<p>Transmute weights to turn a generalized mean of order <code class="reqn">r</code> into a
generalized mean of order <code class="reqn">s</code>. Useful for calculating additive and
multiplicative decompositions for a generalized-mean index, and those made
of nested generalized means (e.g., Fisher index).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmute_weights(r, s)

nested_transmute(r1, r2, s, t = c(1, 1))

nested_transmute2(r1, r2, s, t = c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmute_weights_+3A_r">r</code>, <code id="transmute_weights_+3A_s">s</code></td>
<td>
<p>A finite number giving the order of the generalized mean. See
details.</p>
</td></tr>
<tr><td><code id="transmute_weights_+3A_r1">r1</code></td>
<td>
<p>A finite number giving the order of the outer generalized mean.</p>
</td></tr>
<tr><td><code id="transmute_weights_+3A_r2">r2</code></td>
<td>
<p>A pair of finite numbers giving the order of the inner generalized
means.</p>
</td></tr>
<tr><td><code id="transmute_weights_+3A_t">t</code></td>
<td>
<p>A pair of strictly positive weights for the inner generalized
means. The default is equal weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>transmute_weights(r, s)</code> returns a function to compute a
vector of weights <code>v(x, w)</code> such that
</p>
<pre>generalized_mean(r)(x, w) == generalized_mean(s)(x, v(x, w))</pre>
<p><code>nested_transmute(r1, r2, t, s)</code> and <code>nested_transmute2(r1, r2, t, s)</code> do
the same for nested generalized means, so that
</p>
<pre>nested_mean(r1, r2, t)(x, w1, w2) ==
  generalized_mean(s)(x, v(x, w1, w2))</pre>
<p>This generalizes the result for turning a geometric mean into an arithmetic
mean (and vice versa) in section 4.2 of Balk (2008), and a Fisher mean into
an arithmetic mean in section 6 of Reinsdorf et al. (2002), although these
are usually the most important cases. See Martin (2021) for details.
<code>nested_transmute2()</code> takes a slightly different approach than
<code>nested_transmute()</code>, generalizing the van IJzeren arithmetic
decomposition for the Fisher index (Balk, 2008, section 4.2.2) using the
approach by Martin (2021), although in most cases the results are broadly
similar.
</p>
<p>Transmuting weights returns a value that is the same length as <code>x</code>,
so any missing values in <code>x</code> or the weights will return <code>NA</code>.
Unless all values are <code>NA</code>, however, the result for will still satisfy
the above identities when <code>na.rm = TRUE</code>.
</p>


<h3>Value</h3>

<p><code>transmute_weights()</code> returns a function:
</p>
<pre>function(x, w = NULL){...}</pre>
<p><code>nested_transmute()</code> and <code>nested_transmute2()</code> similarly return a
function:
</p>
<pre>function(x, w1 = NULL, w2 = NULL){...}</pre>


<h3>References</h3>

<p>Balk, B. M. (2008). <em>Price and Quantity Index Numbers</em>.
Cambridge University Press.
</p>
<p>Martin, S. (2021). A note on general decompositions for price indexes.
<em>Prices Analytical Series</em>, Statistics Canada catalogue no. 62F0014M.
Statistics Canada, Ottawa.
</p>
<p>Reinsdorf, M. B., Diewert, W. E., and Ehemann, C. (2002). Additive
decompositions for Fisher, Törnqvist and geometric mean indexes.
<em>Journal of Economic and Social Measurement</em>, 28(1-2):51&ndash;61.
</p>
<p>Sydsaeter, K., Strom, A., and Berck, P. (2005). <em>Economists'
Mathematical Manual</em> (4th edition). Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generalized_mean">generalized_mean()</a></code> for the generalized mean and <code><a href="#topic+nested_mean">nested_mean()</a></code> for the
nested mean.
</p>
<p><code><a href="#topic+extended_mean">extended_mean()</a></code> for the extended mean that underlies
<code>transmute_weights()</code>.
</p>
<p><code><a href="#topic+contributions">contributions()</a></code> for calculating additive percent-change
contributions.
</p>
<p><code><a href="#topic+grouped">grouped()</a></code> to make these functions operate on grouped data.
</p>
<p>Other weights: 
<code><a href="#topic+factor_weights">factor_weights</a>()</code>,
<code><a href="#topic+scale_weights">scale_weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
y &lt;- 4:6
w &lt;- 3:1

#---- Transforming generalized means ----

# Calculate the geometric mean as an arithmetic mean and
# harmonic mean by transmuting the weights

geometric_mean(x)
arithmetic_mean(x, transmute_weights(0, 1)(x))
harmonic_mean(x, transmute_weights(0, -1)(x))

# Transmuting the weights for a harmonic mean into those
# for an arithmetic mean is the same as using weights w / x

all.equal(
  scale_weights(transmute_weights(-1, 1)(x, w)),
  scale_weights(w / x)
)

# Works for nested means, too

w1 &lt;- 3:1
w2 &lt;- 1:3

fisher_mean(x, w1, w2)

arithmetic_mean(x, nested_transmute(0, c(1, -1), 1)(x, w1, w2))
arithmetic_mean(x, nested_transmute2(0, c(1, -1), 1)(x, w1, w2))

# Note that nested_transmute() has an invariance property
# not shared by nested_transmute2()

all.equal(
  nested_transmute(0, c(1, -1), 1)(x, w1, w2),
  transmute_weights(2, 1)(
    x, nested_transmute(0, c(1, -1), 2)(x, w1, w2)
  )
)

all.equal(
  nested_transmute2(0, c(1, -1), 1)(x, w1, w2),
  transmute_weights(2, 1)(
    x, nested_transmute2(0, c(1, -1), 2)(x, w1, w2)
  )
)

#---- Percent-change contributions ----

# Transmuted weights can be used to calculate percent-change
# contributions for, e.g., a geometric price index

scale_weights(transmute_weights(0, 1)(x)) * (x - 1)
geometric_contributions(x) # the more convenient way

#---- Basket representation of a price index ----

# Any generalized-mean index can be represented as a basket-style
# index by transmuting the weights, which is how some authors
# define a price index (e.g., Sydsaeter et al., 2005, p. 174)

p1 &lt;- 2:6
p0 &lt;- 1:5

qs &lt;- transmute_weights(-1, 1)(p1 / p0) / p0
all.equal(harmonic_mean(p1 / p0), sum(p1 * qs) / sum(p0 * qs))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
