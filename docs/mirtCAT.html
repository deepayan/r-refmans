<!DOCTYPE html><html><head><title>Help for package mirtCAT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mirtCAT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#computeCriteria'><p>Compute the values given the criteria and internal objects</p></a></li>
<li><a href='#createSessionName'><p>Create a unique GUI session name from a string of characters</p></a></li>
<li><a href='#createShinyGUI'><p>Function returning an object used by shiny</p></a></li>
<li><a href='#extract.mirtCAT'><p>Extract elements from the internal person, test, and design objects</p></a></li>
<li><a href='#findNextItem'><p>Find next CAT item</p></a></li>
<li><a href='#generate_pattern'><p>Generate a CAT patterns</p></a></li>
<li><a href='#generate.mirt_object'><p>Generate a mirt object from population parameters</p></a></li>
<li><a href='#get_mirtCAT_env'><p>Get the internal working environment state during mirtCAT session</p></a></li>
<li><a href='#getPerson'><p>Retrieve person object after running createShinyGUI</p></a></li>
<li><a href='#mirtCAT'><p>Generate an adaptive or non-adaptive test HTML interface</p></a></li>
<li><a href='#mirtCAT_preamble'><p>Preamble function called by mirtCAT</p></a></li>
<li><a href='#mirtCAT-package'><p>Computerized Adaptive Testing with Multidimensional Item Response Theory</p></a></li>
<li><a href='#updateDesign'><p>Update design elements</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.13</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computerized Adaptive Testing with Multidimensional Item
Response Theory</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools to generate HTML interfaces for adaptive
    and non-adaptive tests using the shiny
    package (Chalmers (2016) &lt;<a href="https://doi.org/10.18637%2Fjss.v071.i05">doi:10.18637/jss.v071.i05</a>&gt;). 
    Suitable for applying unidimensional and multidimensional
    computerized adaptive tests (CAT) using item response theory methodology and for
    creating simple questionnaires forms to collect response data directly in R.
    Additionally, optimal test designs (e.g., "shadow testing") are supported
    for tests that contain a large number of item selection constraints.
    Finally, package contains tools useful for performing Monte Carlo simulations 
    for studying test item banks.</td>
</tr>
<tr>
<td>Depends:</td>
<td>mirt (&ge; 1.37), shiny (&ge; 1.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, stats, Rcpp, methods, markdown, pbapply, lpSolve</td>
</tr>
<tr>
<td>Suggests:</td>
<td>shinythemes, parallel, knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Phil Chalmers &lt;rphilip.chalmers@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/philchalmers/mirtCAT">https://github.com/philchalmers/mirtCAT</a>,
<a href="https://github.com/philchalmers/mirtCAT/wiki">https://github.com/philchalmers/mirtCAT/wiki</a>,
<a href="https://groups.google.com/forum/#!forum/mirt-package">https://groups.google.com/forum/#!forum/mirt-package</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/philchalmers/mirtCAT/issues?state=open">https://github.com/philchalmers/mirtCAT/issues?state=open</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-17 14:44:55 UTC; phil</td>
</tr>
<tr>
<td>Author:</td>
<td>Phil Chalmers <a href="https://orcid.org/0000-0001-5332-2810"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Magnus Nordmo <a href="https://orcid.org/0000-0002-1977-1038"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-17 16:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='computeCriteria'>Compute the values given the criteria and internal objects</h2><span id='topic+computeCriteria'></span>

<h3>Description</h3>

<p>A function that returns a named vector of evaluated criteria for each respective item in the 
test bank. The names are associated with the item number in the bank. 
Note that criteria values are returned such that the maximum value always 
represents the most optimal item (e.g., maximum information). In cases where the minimum value is 
typically selected (e.g., minimum variance) all values are multiplied by -1 to turn it into a maximization
problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeCriteria(
  x,
  criteria,
  person = NULL,
  test = NULL,
  design = NULL,
  subset = NULL,
  info_mats = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeCriteria_+3A_x">x</code></td>
<td>
<p>an object of class 'mirtCAT_design' returned from the <code><a href="#topic+mirtCAT">mirtCAT</a></code> function
when passing <code>design_elements = TRUE</code></p>
</td></tr>
<tr><td><code id="computeCriteria_+3A_criteria">criteria</code></td>
<td>
<p>item selection criteria (see <code><a href="#topic+mirtCAT">mirtCAT</a></code>'s <code>criteria</code> input)</p>
</td></tr>
<tr><td><code id="computeCriteria_+3A_person">person</code></td>
<td>
<p>(required when <code>x</code> is missing) internal person object. To be 
used when <code>customNextItem</code> function has been defined</p>
</td></tr>
<tr><td><code id="computeCriteria_+3A_test">test</code></td>
<td>
<p>(required when <code>x</code> is missing) internal test object. To be 
used when <code>customNextItem</code> function has been defined</p>
</td></tr>
<tr><td><code id="computeCriteria_+3A_design">design</code></td>
<td>
<p>(required when <code>x</code> is missing) internal design object. To be 
used when <code>customNextItem</code> function has been defined</p>
</td></tr>
<tr><td><code id="computeCriteria_+3A_subset">subset</code></td>
<td>
<p>an integer vector indicating which items should be included in the optimal search;
the default <code>NULL</code> includes all possible items. To allow only the first 10 items to be 
selected from this can be modified to <code>subset = 1:10</code>. This is useful when administering 
a multi-unidimensional CAT session where unidimensional blocks should be clustered together 
for smoother presentation. Useful when using the <code>customNextItem</code> function in 
<code><a href="#topic+mirtCAT">mirtCAT</a></code></p>
</td></tr>
<tr><td><code id="computeCriteria_+3A_info_mats">info_mats</code></td>
<td>
<p>logical; if more than one trait is present in the test, should the respective information
matricies be returned instead of the scalar summary statistics (e.g., D-rule). When TRUE will 
return a list of matricies associated with each respective item</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of criteria values for each respective item
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirtCAT">mirtCAT</a></code>, <code><a href="#topic+updateDesign">updateDesign</a></code>, <code><a href="#topic+extract.mirtCAT">extract.mirtCAT</a></code>,
<code><a href="#topic+findNextItem">findNextItem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# test defined in mirtCAT help file, first example
CATdesign &lt;- mirtCAT(df, mod, design_elements = TRUE)

computeCriteria(CATdesign, criteria = 'MI')
computeCriteria(CATdesign, criteria = 'MEI')


## End(Not run)
</code></pre>

<hr>
<h2 id='createSessionName'>Create a unique GUI session name from a string of characters</h2><span id='topic+createSessionName'></span>

<h3>Description</h3>

<p>This is used in <code><a href="#topic+mirtCAT">mirtCAT</a></code> to create a random session name so that
<code>shiny</code> knows which environment to select objects from when multiple CAT
sessions have been initialized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSessionName(n = 30, datetime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSessionName_+3A_n">n</code></td>
<td>
<p>number of upper/lower characters to sample</p>
</td></tr>
<tr><td><code id="createSessionName_+3A_datetime">datetime</code></td>
<td>
<p>logical; include the current date/time the function was called
in the string as well? This further helps with the uniqueness of the generated
string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the internal environmental components for mirtCAT
</p>

<hr>
<h2 id='createShinyGUI'>Function returning an object used by shiny</h2><span id='topic+createShinyGUI'></span>

<h3>Description</h3>

<p>This function returns the GUI setup results by calling <code><a href="shiny.html#topic+shinyApp">shinyApp</a></code>. 
Primarily, this is only useful when hosting the application publicly, such as 
through <a href="https://www.shinyapps.io/">https://www.shinyapps.io/</a>. The function <code><a href="#topic+mirtCAT_preamble">mirtCAT_preamble</a></code> must be 
run <em>before</em> this function is called. The object is executed by calling <code><a href="shiny.html#topic+runApp">runApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createShinyGUI(ui = NULL, host_server = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createShinyGUI_+3A_ui">ui</code></td>
<td>
<p>a shiny UI function used to define the interface. If <code>NULL</code>, the default one will be used. 
See <code>mirtCAT:::default_UI</code> for the internal code</p>
</td></tr>
<tr><td><code id="createShinyGUI_+3A_host_server">host_server</code></td>
<td>
<p>logical; is <code>createShinyGUI()</code> being used on a remote server or executed locally?
When <code>TRUE</code> any calls to <code><a href="shiny.html#topic+stopApp">stopApp</a></code> are suppressed to allow for multiple sessions to
be executed. Note that <code>FALSE</code> gives the same behaviour as the GUI in <code><a href="#topic+mirtCAT">mirtCAT</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirtCAT">mirtCAT</a></code>, <code><a href="#topic+mirtCAT_preamble">mirtCAT_preamble</a></code>, <code><a href="#topic+getPerson">getPerson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

mirtCAT_preamble(df=df)
runApp(createShinyGUI(host_server = FALSE), port = 8000) # run locally

person &lt;- getPerson()
summary(person)

runApp(createShinyGUI(), port = 8000) # for remote server hosting


## End(Not run) 
</code></pre>

<hr>
<h2 id='extract.mirtCAT'>Extract elements from the internal person, test, and design objects</h2><span id='topic+extract.mirtCAT'></span>

<h3>Description</h3>

<p>This function extracts elements, as well as builds a few convenient elements, 
from the three internal <code>person</code>, <code>design</code>, or <code>test</code>
objects that are accessible through a <code>customNextItem</code> function 
definition (see <code><a href="#topic+mirtCAT">mirtCAT</a></code> for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.mirtCAT(x, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.mirtCAT_+3A_x">x</code></td>
<td>
<p>either the <code>person</code>, <code>design</code>, or <code>test</code> object defined through a 
<code>customNextItem</code> definition</p>
</td></tr>
<tr><td><code id="extract.mirtCAT_+3A_what">what</code></td>
<td>
<p>a character vector extracting the desired element (see the Details section)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on which object is supplied, the following elements can be extracted.
</p>


<h3>The 'person' argument</h3>


<dl>
<dt><code>ID</code></dt><dd><p>a scalar value indicating the ID of the participant 
(generally only needed in Monte Carlo simulations)</p>
</dd>
<dt><code>responses</code></dt><dd><p>an integer vector indicating how items that have been responded to. 
Each element pertains to the associated item location (e.g., <code>responses[100]</code> is associated with the 
100th item), and is <code>NA</code> if the item has not been responded to</p>
</dd>
<dt><code>raw_responses</code></dt><dd><p>of the same form as <code>responses</code>, pertaining to the observed responses
in a character vector</p>
</dd>
<dt><code>items_in_bank</code></dt><dd><p>an integer vector indicating items which have not been administered yet and 
are also valid candidates for administration</p>
</dd>
<dt><code>items_answered</code></dt><dd><p>an integer vector indicating the order in which items have been responded to</p>
</dd>
<dt><code>thetas</code></dt><dd><p>the current ability/latent trait estimates given the previously administered items</p>
</dd>
<dt><code>thetas_SE</code></dt><dd><p>the current ability/latent trait standard error estimates given the 
previously administered items</p>
</dd>
<dt><code>thetas_history</code></dt><dd><p>history of the  ability/latent trait estimates</p>
</dd>
<dt><code>thetas_SE_history</code></dt><dd><p>history of the latent trait standard error estimates</p>
</dd>
<dt><code>item_time</code></dt><dd><p>of the same form as <code>items_answered</code>, pertaining to the amount of time it took the 
participant to response to the item</p>
</dd>
<dt><code>demographics</code></dt><dd><p>a data.frame containing the (optional) prior survey information from the GUI interface</p>
</dd>
<dt><code>clientData</code></dt><dd><p>a list of useful information from shiny's <code>session$clientData</code></p>
</dd>
</dl>



<h3>The 'design' argument</h3>


<dl>
<dt><code>items_not_scored</code></dt><dd><p>an integer vector indicating items which should be included but not 
scored in the test (these are experimental items)</p>
</dd>
<dt><code>min_items</code></dt><dd><p>minimum number of items to administer</p>
</dd>
<dt><code>max_items</code></dt><dd><p>maximum number of items to administer</p>
</dd>
<dt><code>max_time</code></dt><dd><p>maximum amount of time alloted to the GUI</p>
</dd>
<dt><code>met_SEM</code></dt><dd><p>logical vector indicating whether the SEM criteria has been met</p>
</dd>
<dt><code>met_delta_thetas</code></dt><dd><p>logical vector indicating whether the delta_thetas criteria has been met</p>
</dd>
<dt><code>met_classify</code></dt><dd><p>logical vector indicating whether the classify criteria has been met</p>
</dd>
<dt><code>exposure</code></dt><dd><p>exposure control elements of the same form as <code>responses</code></p>
</dd>
<dt><code>content</code></dt><dd><p>content constraint information</p>
</dd>
<dt><code>content_prop</code></dt><dd><p>content proportions</p>
</dd>
<dt><code>test_properties</code></dt><dd><p>user-defined <code>data.frame</code> of test-based properties</p>
</dd>
<dt><code>person_properties</code></dt><dd><p>user-defined <code>data.frame</code> of person-based properties</p>
</dd>
</dl>



<h3>The 'test' argument</h3>


<dl>
<dt><code>mo</code></dt><dd><p>extract the defined model from the <code>mirt</code> package. Afterward, users can use the 
<code><a href="mirt.html#topic+extract.mirt">extract.mirt</a></code> function to pull out a large number of internal elements for easy use</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="mirt.html#topic+mirt">mirt</a></code>, <code><a href="#topic+mirtCAT">mirtCAT</a></code>, <code><a href="mirt.html#topic+extract.mirt">extract.mirt</a></code>, 
<code><a href="#topic+findNextItem">findNextItem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
 #example test
set.seed(1234)
nitems &lt;- 25
itemnames &lt;- paste0('Item.', 1:nitems)
a &lt;- matrix(rlnorm(nitems, .2, .3))
d &lt;- matrix(rnorm(nitems))
dat &lt;- simdata(a, d, 500, itemtype = 'dich')
colnames(dat) &lt;- itemnames
mod &lt;- mirt(dat, 1, verbose = FALSE, TOL = .01)

# simple math items
questions &lt;- answers &lt;- character(nitems)
choices &lt;- matrix(NA, nitems, 5)
spacing &lt;- floor(d - min(d)) + 1 #easier items have more variation in the options

for(i in 1:nitems){
  n1 &lt;- sample(1:50, 1)
  n2 &lt;- sample(51:100, 1)
  ans &lt;- n1 + n2
  questions[i] &lt;- paste0(n1, ' + ', n2, ' = ?')
  answers[i] &lt;- as.character(ans)
  ch &lt;- ans + sample(c(-5:-1, 1:5) * spacing[i,], 5)
  ch[sample(1:5, 1)] &lt;- ans
  choices[i, ] &lt;- as.character(ch)
}

df &lt;- data.frame(Question=questions, Option=choices, 
  Type = 'radio', stringsAsFactors = FALSE)
df$Answer &lt;- answers

pat &lt;- generate_pattern(mod, Theta = 0, df)

#------------------------------------------------
# administer items in sequence
customNextItem &lt;- function(person, design, test){
   # browser()
   items_left_2_choose_from &lt;- extract.mirtCAT(person, 'items_in_bank')
   min(items_left_2_choose_from)
}

res &lt;- mirtCAT(df, local_pattern=pat, 
  design = list(customNextItem=customNextItem))
summary(res)

#------------------------------------------------
# administer items in order, but stop after 10 items
customNextItem &lt;- function(person, design, test){
   items_left_2_choose_from &lt;- extract.mirtCAT(person, 'items_in_bank')
   items_answered &lt;- extract.mirtCAT(person, 'items_answered')
   total &lt;- sum(!is.na(items_answered))
   ret &lt;- if(total &lt; 10) min(items_left_2_choose_from)
     else return(NA)
   ret
}

res &lt;- mirtCAT(df, local_pattern=pat, 
  design = list(customNextItem=customNextItem))
summary(res)

#------------------------------------------------
# using findNextItem() and stopping after 10 items

customNextItem &lt;- function(person, design, test){
   items_answered &lt;- extract.mirtCAT(person, 'items_answered')
   total &lt;- sum(!is.na(items_answered))
   ret &lt;- NA
   if(total &lt; 10) 
     ret &lt;- findNextItem(person=person, test=test, design=design, criteria = 'MI')
   ret
}

res &lt;- mirtCAT(df, mod, local_pattern=pat, start_item = 'MI',
  design = list(customNextItem=customNextItem))
summary(res)

# equivalent to the following
res2 &lt;- mirtCAT(df, mod, local_pattern=pat, start_item = 'MI', 
  criteria = 'MI', design = list(max_items = 10))
summary(res2)


## End(Not run)
</code></pre>

<hr>
<h2 id='findNextItem'>Find next CAT item</h2><span id='topic+findNextItem'></span>

<h3>Description</h3>

<p>A function that returns the next item in the computerized adaptive, optimal assembly, or shadow test.
For direction manipulation of the internal objects this function should be used in conjunction
with the <code><a href="#topic+updateDesign">updateDesign</a></code> and <code>customNextItem</code>.
Finally, the raw input forms can be used when a <code>customNextItem</code> function has been
defined in <code><a href="#topic+mirtCAT">mirtCAT</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findNextItem(
  x,
  person = NULL,
  test = NULL,
  design = NULL,
  criteria = NULL,
  objective = NULL,
  subset = NULL,
  all_index = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNextItem_+3A_x">x</code></td>
<td>
<p>an object of class 'mirtCAT_design' returned from the <code><a href="#topic+mirtCAT">mirtCAT</a></code> function
when passing <code>design_elements = TRUE</code></p>
</td></tr>
<tr><td><code id="findNextItem_+3A_person">person</code></td>
<td>
<p>(required when <code>x</code> is missing) internal person object. To be
used when <code>customNextItem</code> function has been defined</p>
</td></tr>
<tr><td><code id="findNextItem_+3A_test">test</code></td>
<td>
<p>(required when <code>x</code> is missing) internal test object. To be
used when <code>customNextItem</code> function has been defined</p>
</td></tr>
<tr><td><code id="findNextItem_+3A_design">design</code></td>
<td>
<p>(required when <code>x</code> is missing) internal design object. To be
used when <code>customNextItem</code> function has been defined</p>
</td></tr>
<tr><td><code id="findNextItem_+3A_criteria">criteria</code></td>
<td>
<p>item selection criteria (see <code><a href="#topic+mirtCAT">mirtCAT</a></code>'s <code>criteria</code> input).
If not specified the value from <code>extract.mirtCAT(design, 'criteria')</code> will be used</p>
</td></tr>
<tr><td><code id="findNextItem_+3A_objective">objective</code></td>
<td>
<p>a vector of values used as the optimization criteria to be passed to
<code>lp(objective.in)</code>. This is typically the vector of criteria values returned from
<code><a href="#topic+computeCriteria">computeCriteria</a></code>, however supplying other
criteria are possible (e.g., to minimize the number of items administered simply pass a vector
of -1's)</p>
</td></tr>
<tr><td><code id="findNextItem_+3A_subset">subset</code></td>
<td>
<p>an integer vector indicating which items should be included in the optimal search;
the default <code>NULL</code> includes all possible items. To allow only the first 10 items to be
selected from this can be modified to <code>subset = 1:10</code>. This is useful when administering
a multi-unidimensional CAT session where unidimensional blocks should be clustered together
for smoother presentation. Useful when using the <code>customNextItem</code> function in
<code><a href="#topic+mirtCAT">mirtCAT</a></code></p>
</td></tr>
<tr><td><code id="findNextItem_+3A_all_index">all_index</code></td>
<td>
<p>logical; return all items instead of just the most optimal?
When <code>TRUE</code> a vector of items is returned instead of the most optimal,
where the items are sorted according to how
well they fit the criteria (e.g., the first element is the most optimal, followed by the second
most optimal, and so on). Note that this does not work for some selection criteria (e.g.,
'seq' or 'random')</p>
</td></tr>
<tr><td><code id="findNextItem_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="lpSolve.html#topic+lp">lp</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a numeric <code>objective</code> is supplied the next item in the computerized adaptive test is found via
an integer solver through searching for a maximum. The raw input forms can be used
when a <code>customNextItem</code> function has been defined in <code><a href="#topic+mirtCAT">mirtCAT</a></code>, and requires
the definition of a <code>constr_fun</code> (see the associated element in <code><a href="#topic+mirtCAT">mirtCAT</a></code> for details,
as well as the examples below). Can be used to for 'Optimal Test Assembly',
as well as 'Shadow Testing' designs (van der Linden, 2005),
by using the <code><a href="lpSolve.html#topic+lp">lp</a></code> function. When <code>objective</code> is not supplied the result follows the
typical maximum criteria of more standard adaptive tests.
</p>


<h3>Value</h3>

<p>typically returns an integer value indicating the index of the next item to be selected or a
value of <code>NA</code> to indicate that the test should be terminated. However, see the arguments for
further returned object descriptions
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>
<p>van der Linden, W. J. (2005). Linear models for optimal test design. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirtCAT">mirtCAT</a></code>, <code><a href="#topic+updateDesign">updateDesign</a></code>, <code><a href="#topic+extract.mirtCAT">extract.mirtCAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# test defined in mirtCAT help file, first example 
# equivalent to criteria = 'MI'
customNextItem &lt;- function(design, person, test){
   item &lt;- findNextItem(person=person, design=design, test=test,
                        criteria = 'MI')
   item
 }
 
set.seed(1)
nitems &lt;- 100
itemnames &lt;- paste0('Item.', 1:nitems)
a &lt;- matrix(rlnorm(nitems, .2, .3))
d &lt;- matrix(rnorm(nitems))
dat &lt;- simdata(a, d, 500, itemtype = 'dich')
colnames(dat) &lt;- itemnames
mod &lt;- mirt(dat, 1, verbose = FALSE)

# simple math items
questions &lt;- answers &lt;- character(nitems)
choices &lt;- matrix(NA, nitems, 5)
spacing &lt;- floor(d - min(d)) + 1 #easier items have more variation in the options

for(i in 1:nitems){
 n1 &lt;- sample(1:50, 1)
 n2 &lt;- sample(51:100, 1)
 ans &lt;- n1 + n2
 questions[i] &lt;- paste0(n1, ' + ', n2, ' = ?')
 answers[i] &lt;- as.character(ans)
 ch &lt;- ans + sample(c(-5:-1, 1:5) * spacing[i,], 5)
 ch[sample(1:5, 1)] &lt;- ans
 choices[i, ] &lt;- as.character(ch)
}

df &lt;- data.frame(Question=questions, Option=choices, 
              Type = 'radio', stringsAsFactors = FALSE)
   
response &lt;- generate_pattern(mod, 1)
result &lt;- mirtCAT(mo=mod, local_pattern = response, 
                  design = list(customNextItem=customNextItem))
                
-----------------------------------------------------------
# direct manipulation of internal objects
CATdesign &lt;- mirtCAT(df=df, mo=mod, criteria = 'MI', design_elements = TRUE)

# returns number 1 in this case, since that's the starting item
findNextItem(CATdesign)

# determine next item if item 1 and item 10 were answered correctly
CATdesign &lt;- updateDesign(CATdesign, new_item = 1, new_response = 1)
extract.mirtCAT(CATdesign$person, 'thetas') # updated thetas
CATdesign &lt;- updateDesign(CATdesign, new_item = 10, new_response = 1)
extract.mirtCAT(CATdesign$person, 'thetas') # updated thetas again
findNextItem(CATdesign)
findNextItem(CATdesign, all_index = TRUE) # all items rank in terms of most optimal

#-------------------------------------------------------------
## Integer programming example (e.g., shadow testing)

# find maximum information subject to constraints
#  sum(xi) &lt;= 5               ### 5 or fewer items
#  x1 + x2 &lt;= 1               ### items 1 and 2 can't be together
#  x4 == 0                    ### item 4 not included
#  x5 + x6 == 1               ### item 5 or 6 must be included, but not both

# constraint function
constr_fun &lt;- function(design, person, test){

  # left hand side constrains
  #    - 1 row per constraint, and ncol must equal number of items
  mo &lt;- extract.mirtCAT(test, 'mo')
  nitems &lt;- extract.mirt(mo, 'nitems')
  lhs &lt;- matrix(0, 4, nitems)
  lhs[1,] &lt;- 1
  lhs[2,c(1,2)] &lt;- 1
  lhs[3, 4] &lt;- 1
  lhs[4, c(5,6)] &lt;- 1

  # relationship direction
  dirs &lt;- c("&lt;=", "&lt;=", '==', '==')

  #right hand side
  rhs &lt;- c(5, 1, 0, 1)

  #all together
  constraints &lt;- data.frame(lhs, dirs, rhs)
  constraints
}

CATdesign &lt;- mirtCAT(df=df, mo=mod, design_elements = TRUE,
                     design = list(constr_fun=constr_fun))

# MI criteria value associated with each respective item
objective &lt;- computeCriteria(CATdesign, criteria = 'MI')

# most optimal item, given constraints
findNextItem(CATdesign, objective=objective)

# all the items which solve the problem
findNextItem(CATdesign, objective=objective, all_index = TRUE)

## within a customNextItem() definition the above code would look like
# customNextItem &lt;- function(design, person, test){
#   objective &lt;- computeCriteria(person=person, design=design, test=test,
#                                criteria = 'MI')
#   item &lt;- findNextItem(person=person, design=design, test=test,
#                        objective=objective)
#   item
# }


## End(Not run)
</code></pre>

<hr>
<h2 id='generate_pattern'>Generate a CAT patterns</h2><span id='topic+generate_pattern'></span>

<h3>Description</h3>

<p>Generate a CAT pattern given various inputs. Returns a character vector or numeric matrix 
(depending on whether a <code>df</code> input was supplied) with columns equal to the test size and
rows equal to the number of rows in <code>Theta</code>. For simulation studies, supplying a 
<code>Theta</code> input with more than 1 row will generate a matrix of responses for
running independent CAT session when passed to <code>mirtCAT(..., local_pattern)</code>. When
the returned object is an integer vector then the <code>Theta</code> values will be stored 
as an attribute <code>'Theta'</code> to be automatically used in Monte Carlo simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_pattern(mo, Theta, df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_pattern_+3A_mo">mo</code></td>
<td>
<p>single group object defined by the <code>mirt</code> package</p>
</td></tr>
<tr><td><code id="generate_pattern_+3A_theta">Theta</code></td>
<td>
<p>a numeric vector indicating the latent theta values for a single person</p>
</td></tr>
<tr><td><code id="generate_pattern_+3A_df">df</code></td>
<td>
<p>(optional) data.frame object containing questions, options, and scoring
keys. See <code><a href="#topic+mirtCAT">mirtCAT</a></code> for details</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirtCAT">mirtCAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# return real response vector given choices and (optional) answers 
pat &lt;- generate_pattern(mod, Theta = 0, df=df)
# mirtCAT(df, mo=mod, local_pattern = pat)

# generate single pattern observed in dataset used to define mod
pat2 &lt;- generate_pattern(mod, Theta = 0)
# mirtCAT(mo=mod, local_pattern = pat2)

# generate multiple patterns to be analyzed independently 
pat3 &lt;- generate_pattern(mod, Theta = matrix(c(0, 2, -2), 3))
# mirtCAT(mo=mod, local_pattern = pat3)


## End(Not run)
</code></pre>

<hr>
<h2 id='generate.mirt_object'>Generate a mirt object from population parameters</h2><span id='topic+generate.mirt_object'></span>

<h3>Description</h3>

<p>This function generates a <code>mirt</code> object from known population parameters, which is  
then passed to <code><a href="#topic+mirtCAT">mirtCAT</a></code> for running CAT applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.mirt_object(
  parameters,
  itemtype,
  latent_means = NULL,
  latent_covariance = NULL,
  key = NULL,
  min_category = rep(0L, length(itemtype))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.mirt_object_+3A_parameters">parameters</code></td>
<td>
<p>a matrix or data.frame of parameters corresponding to the model definitions
listed in <code><a href="mirt.html#topic+mirt">mirt</a></code>. Each row represents a unique item, while the 
column names correspond to the respective parameter names. If a parameter is not relevant
for a particular item/row then use <code>NA</code>'s as placeholders</p>
</td></tr>
<tr><td><code id="generate.mirt_object_+3A_itemtype">itemtype</code></td>
<td>
<p>a character vector indicating the type of item with which the parameters 
refer. See the <code>itemtype</code> argument in <code><a href="mirt.html#topic+mirt">mirt</a></code>. Note that this input 
is only used to determine the relevant item class for the rows in <code>parameters</code>, 
therefore many inputs are interchangeable (e.g., '2PL' generates the same internal model object as '3PL').
If only a single value is provided then all items types will be assumed identical</p>
</td></tr>
<tr><td><code id="generate.mirt_object_+3A_latent_means">latent_means</code></td>
<td>
<p>(optional) a numeric vector used to define the population latent mean
structure. By default the mean structure is centered at a 0 vector</p>
</td></tr>
<tr><td><code id="generate.mirt_object_+3A_latent_covariance">latent_covariance</code></td>
<td>
<p>(optional) a matrix used to define the population 
variance-covariance structure between the latent traits. By default the relationship is 
assumed to be orthogonal standard normal (i.e., an identity matrix)</p>
</td></tr>
<tr><td><code id="generate.mirt_object_+3A_key">key</code></td>
<td>
<p>scoring key required for nested-logit models. See <code><a href="mirt.html#topic+mirt">mirt</a></code> for details</p>
</td></tr>
<tr><td><code id="generate.mirt_object_+3A_min_category">min_category</code></td>
<td>
<p>the value representing the lowest category index. By default this is 0,
therefore the response suitable for the first category is 0, second is 1, and so on up to 
<code>K - 1</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="mirt.html#topic+mirt">mirt</a></code>, <code><a href="#topic+mirtCAT">mirtCAT</a></code>, <code><a href="#topic+generate_pattern">generate_pattern</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

### build a unidimensional test with all 3PL items

nitems &lt;- 50
a1 &lt;- rlnorm(nitems, .2,.2)
d &lt;- rnorm(nitems)
g &lt;- rbeta(nitems, 20, 80)

pars &lt;- data.frame(a1=a1, d=d, g=g)
head(pars)

obj &lt;- generate.mirt_object(pars, '3PL')
coef(obj, simplify = TRUE)
plot(obj, type = 'trace')

### build a two-dimensional test  
## all graded items with 5 response categories

nitems &lt;- 30
as &lt;- matrix(rlnorm(nitems*2, .2, .2), nitems)
diffs &lt;- t(apply(matrix(runif(nitems*4, .3, 1), nitems), 1, cumsum)) 
diffs &lt;- -(diffs - rowMeans(diffs)) 
ds &lt;- diffs + rnorm(nitems)
pars2 &lt;- data.frame(as, ds)
colnames(pars2) &lt;- c('a1', 'a2', paste0('d', 1:4))
head(pars2)

obj &lt;- generate.mirt_object(pars2, 'graded')
coef(obj, simplify = TRUE)

### unidimensional mixed-item test

library(plyr)
pars3 &lt;- rbind.fill(pars, pars2) #notice the NA's where parameters do not exist
obj &lt;- generate.mirt_object(pars3, itemtype = c(rep('2PL', 50), rep('graded', 30)))
coef(obj)
itemplot(obj, 51)
itemplot(obj, 1, drop.zeros=TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='get_mirtCAT_env'>Get the internal working environment state during mirtCAT session</h2><span id='topic+get_mirtCAT_env'></span>

<h3>Description</h3>

<p>This function is used to access the internal state of the mirtCAT GUI session. 
It is only useful when designing a customized GUI using the <code>shinyGUI$ui</code>
input to <code><a href="#topic+mirtCAT">mirtCAT</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mirtCAT_env(sessionName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mirtCAT_env_+3A_sessionname">sessionName</code></td>
<td>
<p>the name of the session defined in <code><a href="#topic+mirtCAT">mirtCAT</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the internal environmental components for mirtCAT
</p>

<hr>
<h2 id='getPerson'>Retrieve person object after running createShinyGUI</h2><span id='topic+getPerson'></span>

<h3>Description</h3>

<p>This function returns a suitable person object identical to the result returned by <code><a href="#topic+mirtCAT">mirtCAT</a></code>,
and is only required when the GUI is launched by the <code><a href="#topic+createShinyGUI">createShinyGUI</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPerson()
</code></pre>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirtCAT">mirtCAT</a></code>, <code><a href="#topic+mirtCAT_preamble">mirtCAT_preamble</a></code>, <code><a href="#topic+createShinyGUI">createShinyGUI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

mirtCAT_preamble(df=df)
runApp(createShinyGUI(), port = 8000)

person &lt;- getPerson()
summary(person)

## End(Not run) 
</code></pre>

<hr>
<h2 id='mirtCAT'>Generate an adaptive or non-adaptive test HTML interface</h2><span id='topic+mirtCAT'></span><span id='topic+print.mirtCAT'></span><span id='topic+summary.mirtCAT'></span><span id='topic+plot.mirtCAT'></span>

<h3>Description</h3>

<p>Provides tools to generate an HTML interface for creating adaptive and 
non-adaptive educational and psychological tests using the <code>shiny</code> package. 
Suitable for applying unidimensional and multidimensional computerized adaptive tests 
using item response theory methodology. Test scoring is performed using the <code>mirt</code> package.
However, if no scoring is required (i.e., a standard survey) then defining a <code>mirt</code> 
object may be omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirtCAT(
  df = NULL,
  mo = NULL,
  method = "MAP",
  criteria = "seq",
  start_item = 1,
  local_pattern = NULL,
  AnswerFuns = list(),
  design_elements = FALSE,
  cl = NULL,
  progress = FALSE,
  primeCluster = TRUE,
  customTypes = list(),
  design = list(),
  shinyGUI = list(),
  preCAT = list(),
  ...
)

## S3 method for class 'mirtCAT'
print(x, ...)

## S3 method for class 'mirtCAT'
summary(object, sort = TRUE, ...)

## S3 method for class 'mirtCAT'
plot(
  x,
  pick_theta = NULL,
  true_thetas = TRUE,
  SE = 1,
  main = NULL,
  par.strip.text = list(cex = 0.7),
  par.settings = list(strip.background = list(col = "#9ECAE1"), strip.border = list(col =
    "black")),
  scales = list(x = list(rot = 90)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirtCAT_+3A_df">df</code></td>
<td>
<p>a <code>data.frame</code> containing the <code>character</code> vector inputs required to generate 
GUI questions through shiny. If <code>factor</code>s are supplied instead of <code>character</code> vectors 
then the inputs will be coerced using the <code>as.character()</code> function (set 
<code>stringsAsFactors = FALSE</code> when defining a <code>data.frame</code> to avoid this). 
Each row in the object corresponds to a unique
item. The object supports the follow column name combinations as inputs to specify the 
type of response format, questions, options, answers, and stems:
</p>

<dl>
<dt><code>Type</code></dt><dd><p>Indicates the type of response input 
to use from the shiny package. The supported types are: <code>'radio'</code> for radio buttons 
(<code><a href="shiny.html#topic+radioButtons">radioButtons</a></code>), <code>'select'</code> for a pull-down box for selecting 
inputs (<code><a href="shiny.html#topic+selectInput">selectInput</a></code>), <code>'rankselect'</code> for a set of pull-down boxes rank-ordering
inputs (<code><a href="shiny.html#topic+selectInput">selectInput</a></code>) associated with each option supplied, 
<code>'text'</code> and <code>'textArea'</code> for requiring 
typed user input (<code><a href="shiny.html#topic+textInput">textInput</a></code> and <code><a href="shiny.html#topic+textAreaInput">textAreaInput</a></code>), 
<code>'checkbox'</code> for allowing multiple 
responses to be checked off (<code><a href="shiny.html#topic+checkboxGroupInput">checkboxGroupInput</a></code>),
<code>'slider'</code> for generating slider inputs (<code><a href="shiny.html#topic+sliderInput">sliderInput</a></code>), or
<code>'none'</code> for presenting only an item stem with no selection options. Note that slider
inputs require additional arguments to be passed; see <code>...</code> instructions below).
</p>
<p>Additionally, if the above types are not sufficient for the desired output then users 
can create their own response formats and inputs via the <code>customTypes</code> list input 
(see below). E.g., if a function with the name <code>'MyTableQuestion'</code> is supplied 
to <code>customTypes</code> then supplying this type to the <code>df</code> will use this function for
the respective item. Note that this is more advanced and requires a working knowledge of shiny's 
design, inputs, and specifications. This is generally for advanced users
to use on an as-per-needed basis.</p>
</dd> 
<dt><code>Question</code></dt><dd><p>A character vector containing all the questions or stems to be generated.
By default these character vectors are passed to <code><a href="shiny.html#topic+HTML">HTML</a></code>, and therefore allow for 
HTML tags to be included directly. For example, the following example defines two stems, 
where the second uses an emphasis tag to provide italics.
</p>
<p><code>Question = c('This is the first item stem.', 'This is the &lt;em&gt;second&lt;/em&gt; item stem.'))</code>
</p>
<p>Alternatively, if tag constructor function are preferred these need only be wrapped within
a final call to <code><a href="base.html#topic+as.character">as.character</a></code> to coerce the shiny.tag expressions into suitable
character vectors of HTML code. For example, the above could be expressed as 
</p>
<p><code>Question = c('This is the first item stem.', 
         as.character(div('This is the', em('second'), 'item stem.')))</code>
</p>
<p>Moreover, because this input must be a character vector, the use of <code><a href="base.html#topic+sapply">sapply</a></code> in 
concert with <code><a href="base.html#topic+as.character">as.character</a></code> can apply this conversion to all elements (often
redundantly). Here's an example of this format:
</p>
<pre>
                    Question = sapply(list('This is the first item stem.',
                        div('This is the', em('second'), 'item stem.'),
                        div('This is the', strong('third'), br(), br(), 'item stem.'),
                        div('Fourth with some code:', code('obj &lt;- 42'))),
                    as.character)
       </pre>
</dd>
<dt><code>Option.#</code></dt><dd><p>Names pertaining to the possible response
options for each item, where the # corresponds to the specific category. For
instance, a test with 4 unique response options for each item would contain
the columns (<code>Option.1</code>, <code>Option.2</code>, <code>Option.3</code>, <code>Option.4</code>).
If, however, some items have fewer categories than others then <code>NA</code>'s can be used for response
options that do not apply.</p>
</dd>
<dt><code>Answer</code> or <code>Answer.#</code></dt><dd><p>(Optional) A character vector (or multiple character
vectors) indicating the scoring key for items that have correct answer(s). If there
is no correct answer for a question then a value of <code>NA</code> must be declared.</p>
</dd>
<dt><code>Stem</code></dt><dd><p>(Optional) a character vector of absolute or relative paths 
pointing external markdown (.md) or HTML (.html) files to be used as item stems. 
<code>NA</code>s are used if the item has no corresponding file.</p>
</dd> 
<dt><code>Timer</code></dt><dd><p>(Optional) a numeric vector indicating a time limit (in seconds) 
for each respective item. If a response is not provided before this limit then the question
will automatically advance to the next selected item. The values <code>NA</code> and <code>Inf</code>
indicate no time limit for the respective items. Note that this option can only be used 
when <code>shinyGUI = list(forced_choice = FALSE)</code></p>
</dd>
<dt><code>Mastery</code></dt><dd><p>(Optional) a logical vector indicating whether the item must be mastered
prior to continuing. Naturally, this requires that one or more <code>Answers</code> are provided,
or suitable functions for scoring are supplied</p>
</dd>
<dt><code>HTMLOptions</code></dt><dd><p>(Optional) a logical vector indicating whether the respective
<code>Option.#</code> terms should be wrapped within an <code><a href="shiny.html#topic+HTML">HTML</a></code> function and rendered
for suitable shiny inputs (e.g., radio buttons). This is a short-hand wrapper to the more
flexible <code>choiceNames</code> approach, which can be used to wrap option inputs with alternative 
functions.</p>
</dd>
<dt><code>...</code></dt><dd><p>In cases where <code>'slider'</code> inputs are used instead only 
the <code>Question</code> input is required along with (at minimum) a 
<code>min</code>, <code>max</code>, and <code>step</code> column. In rows where the <code>Type == 'slider'</code> the 
column names will correspond to the input arguments to <code><a href="shiny.html#topic+sliderInput">sliderInput</a></code>. 
Other input column options such as <code>step</code>, <code>round</code>, <code>pre</code>, <code>post</code>, 
<code>ticks</code>, <code>inline</code>, <code>placeholder</code>, <code>width</code>, and <code>size</code> 
are also supported for the respective input types.</p>
</dd> 
</dl>
</td></tr>
<tr><td><code id="mirtCAT_+3A_mo">mo</code></td>
<td>
<p>single group object defined by the <code>mirt::mirt()</code> function. This is required
if the test is to be scored adaptively or non-adaptively, but not required for general 
questionnaires. The object can be constructed by using the 
<code><a href="#topic+generate.mirt_object">generate.mirt_object</a></code> function if population parameters are known or by
including a calibrated model estimated from the <code><a href="mirt.html#topic+mirt">mirt</a></code> function with real data.</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_method">method</code></td>
<td>
<p>argument passed to <code>mirt::fscores()</code> for computing new scores in the CAT 
stage, with the addition of a <code>'fixed'</code> input to keep the latent trait estimates
fixed at the previous values. When <code>method = 'ML'</code>, if there is no variability 
in the given response pattern during the CAT (i.e., the participant is responding completely
correctly or completely incorrectly) then the method will temporarily be set to MAP until 
sufficient response variability is present. Default is 'MAP'</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_criteria">criteria</code></td>
<td>
<p>adaptive criteria used, default is to administer each item sequentially 
using <code>criteria = 'seq'</code>. 
</p>
<p>Possible inputs for unidimensional adaptive tests include: <code>'MI'</code> for the maximum
information, <code>'MEPV'</code> for minimum expected posterior variance, 
<code>'MLWI'</code> for maximum likelihood weighted information, 
<code>'MPWI'</code> for maximum posterior weighted information, <code>'MEI'</code> for 
maximum expected information, and <code>'IKLP'</code> as well as <code>'IKL'</code> for the 
integration based Kullback-Leibler criteria with and without the prior density weight,
respectively, and their root-n items administered weighted counter-parts, <code>'IKLn'</code> and 
<code>'IKLPn'</code>.
</p>
<p>Possible inputs for multidimensional adaptive tests include: <code>'Drule'</code> 
for the maximum determinant of the information matrix, <code>'Trule'</code> for the 
maximum (potentially weighted) trace of the information matrix, 
<code>'Arule'</code> for the minimum (potentially weighted) trace of the asymptotic covariance matrix,
<code>'Erule'</code> for the  minimum value of the information matrix, and <code>'Wrule'</code> for 
the weighted information criteria. For each of these rules, the posterior weight for 
the latent trait scores can also be included with the <code>'DPrule'</code>, <code>'TPrule'</code>,
<code>'APrule'</code>, <code>'EPrule'</code>, and <code>'WPrule'</code>, respectively. 
</p>
<p>Applicable to both unidimensional and multidimensional tests are the
<code>'KL'</code> and <code>'KLn'</code> for point-wise Kullback-Leibler divergence and 
point-wise Kullback-Leibler with a decreasing delta value (<code>delta*sqrt(n)</code>, 
where <code>n</code> is the number of items previous answered), respectively. 
The <code>delta</code> criteria is defined in the <code>design</code> object
</p>
<p>Non-adaptive methods applicable even when no <code>mo</code> object is passed 
are: <code>'random'</code> to randomly select items, and <code>'seq'</code> for selecting 
items sequentially.</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_start_item">start_item</code></td>
<td>
<p>two possible inputs to determine the starting item are available. 
Passing a number will indicate the specific item to be used as the start item;
default is 1, which selects the first item in the defined test/survey. 
If a character string is passed then the item will be selected from one of 
the item selections criteria available (see the <code>criteria</code> argument). For off-line 
runs where a <code>local_pattern</code> input is used then a vector of numbers/characters
may be supplied and will be associated with each row response vector</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_local_pattern">local_pattern</code></td>
<td>
<p>a character/numeric matrix of response patterns 
used to run the CAT application without generating the GUI interface. 
This option requires complete response pattern(s) to be supplied. <code>local_pattern</code> 
is required to be numeric if no <code>questions</code> are supplied, and the responses must be 
within a valid range of the defined <code>mo</code> object.
Otherwise, it must contain character values of plausible responses which corresponds to the
answer key and/or options supplied in <code>df</code>. If the object contains an attribute <code>'Theta'</code> 
then these values will be stored within the respective returned objects. 
See <code><a href="#topic+generate_pattern">generate_pattern</a></code> to generate response patterns for Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_answerfuns">AnswerFuns</code></td>
<td>
<p>a list with the length equal to the number of items in the item bank consisting 
of user-defined functions. These functions are used to determine whether a given
response obtained from the GUI is 'correct' or 'incorrect' by returning a logical scalar value, 
while <code>NA</code>'s must be used to indicate <code>AnswerFuns</code> should not be used for a given item. Note 
that <code>AnswerFuns</code> is given priority over the answers provided by <code>df</code>, therefore any answers
provided by <code>df</code> will be entirely ignored.
</p>
<p>For example, the following provides a customized response function for the first item.
</p>
<pre>
   AnswerFuns &lt;- as.list(rep(NA, nrow(df)))
   AnswerFuns[[1]] &lt;- function(input) input == '10' || to.lower(input) == 'ten'
</pre></td></tr>
<tr><td><code id="mirtCAT_+3A_design_elements">design_elements</code></td>
<td>
<p>logical; return an object containing the test, person, and design 
elements? Primarily this is to be used with the <code><a href="#topic+findNextItem">findNextItem</a></code> function</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_cl">cl</code></td>
<td>
<p>an object definition to be passed to the parallel package 
(see <code>?parallel::parLapply</code> for details). If defined, and if 
<code>nrow(local_pattern) &gt; 1</code>, then each row will be run in parallel to help 
decrease estimation times in simulation work</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_progress">progress</code></td>
<td>
<p>logical; print a progress bar to the console 
with the <code>pbapply</code> package for given response patterns? Useful for 
gauging how long Monte Carlo simulations will take to finish</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_primecluster">primeCluster</code></td>
<td>
<p>logical; when a <code>cl</code> object is supplied, should the cluster be primed 
first before running the simulations in parallel? Setting to <code>TRUE</code> will ensure that 
using the cluster will be optimal every time a new <code>cl</code> is defined. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_customtypes">customTypes</code></td>
<td>
<p>an optional list input containing functions for Designing Original Graphical Stimuli (DOGS).
DOGS elements in the input list must contain a unique name, and the item with which it is associated must be
declared in the a <code>df$Type</code> input. The functions defined must be of the form
</p>
<pre>myDOGS &lt;- function(inputId, df_row) ...</pre>
<p>and must return, at the very minimum, an associated <code>shiny</code> input object that makes use of the
<code>inputId</code> argument (e.g., <code><a href="shiny.html#topic+radioButtons">radioButtons</a></code>). Any valid shiny object can be returned,
including lists of shiny objects. As well, the <code>df_row</code> argument contains
any extra information the users wishes to obtain from the associated row in the <code>df</code> object. 
</p>
<p>The following is a simple example of DOGS for a true-false question and how it is passed:   
</p>
<pre>
good_dogs &lt;- function(inputId, df_row){
   return(list(h2('This statement is false'),
               radioButtons(inputId = inputId, label='', 
                            choices = c('True', 'False'), selected = '') 
        ))
   }
   
df &lt;- data.frame(Question = '', ..., Type = 'Doug') 
results &lt;- mirtCAT(df=df, customTypes = list(Doug = good_dogs))
</pre></td></tr>
<tr><td><code id="mirtCAT_+3A_design">design</code></td>
<td>
<p>a list of design based control parameters for adaptive and non-adaptive tests. 
These can be
</p>

<dl>
<dt><code>min_SEM</code></dt><dd><p>Default is <code>rep(0.3, nfact)</code>; minimum standard error or measurement
to be reached for the latent traits (thetas) before the test is stopped. If the test is
multidimensional, either a single value or a vector of values may be supplied to provide
SEM criteria values for each dimension</p>
</dd>
<dt><code>delta_thetas</code></dt><dd><p>Default is <code>rep(0, nfact)</code>; stopping criteria based on the change in latent
trait values (e.g., a change from <code>theta = 1.5</code> to <code>theta = 1.54</code> would 
stop the CAT if <code>delta_thetas = 0.05</code>). The default disables this stopping criteria</p>
</dd>
<dt><code>thetas.start</code></dt><dd><p>a numeric vector of starting values for the theta parameters 
(default is <code>rep(0, nfact)</code>) or an <code>matrix</code> with N rows and nfact columns, where N
is equal to <code>nrow(local_pattern)</code></p>
</dd>
<dt><code>min_items</code></dt><dd><p>minimum number of items that must be answered 
before the test is stopped. Default is <code>1</code></p>
</dd>
<dt><code>max_items</code></dt><dd><p>maximum number of items that 
can be answered. Default is the length of the item bank</p>
</dd>
<dt><code>max_time</code></dt><dd><p>maximum time allowed for the generated GUI, measured
in seconds. For instance, if the test should stop after 10 minutes then the number 
600 should be passed (10 * 60). Default is <code>Inf</code>, therefore no time limit</p>
</dd>
<dt><code>quadpts</code></dt><dd><p>Number of quadrature points used per dimension 
for integration (if required). Default is identical to scheme in <code><a href="mirt.html#topic+fscores">fscores</a></code></p>
</dd>
<dt><code>theta_range</code></dt><dd><p>upper and lower range for the theta 
integration grid. Used in conjunction with <code>quadpts</code> to generate an equally spaced 
quadrature grid. Default is <code>c(-6,6)</code></p>
</dd>
<dt><code>allow_constrain_breaks</code></dt><dd><p>logical; should the test be allowed to terminate in 
the middle of administering the items in an (un)ordered testlet set specified in 
<code>constraints</code>? Default is <code>FALSE</code></p>
</dd> 
<dt><code>weights</code></dt><dd><p>weights used when <code>criteria == 'Wrule'</code>, but also 
will be applied for weighted trace functions in the T- and A-rules. The default 
weights the latent dimensions equally. Default is <code>rep(1, nfact)</code>, 
where <code>nfact</code> is the number of test dimensions</p>
</dd>
<dt><code>KL_delta</code></dt><dd><p>interval range used when <code>criteria = 'KL'</code>
or <code>criteria = 'KLn'</code>. Default is <code>0.1</code></p>
</dd>
<dt><code>content</code></dt><dd><p>an optional character vector indicating the type of content measured
by an item. Must be supplied in conjunction with <code>content_prop</code></p>
</dd>
<dt><code>content_prop</code></dt><dd><p>an optional named numeric vector indicating the 
distribution of item content proportions. A <code>content</code> vector must also be supplied
to indicate the item content membership. For instance, if <code>content</code> contains three
possible item content domains 'Addition', 'Subtraction', and 'Multiplication', and the 
test should contain approximately half multiplication and a quarter of both 
addition and subtraction, then a suitable input would be 
</p>
<p><code>content_prop = c('Addition'=0.25, 'Subtraction'=0.25, 'Multiplication'=.5)</code>
</p>
<p>Note that <code>content_prop</code> must sum to 1 in order to represent valid population 
proportions.
</p>
</dd>
<dt><code>classify</code></dt><dd><p>a numeric vector indicating cut-off value(s) for classification
above or below some prior threshold. Default does not use the classification scheme</p>
</dd>
<dt><code>classify_CI</code></dt><dd><p>a numeric vector indicating the confident intervals used to 
classify individuals being above or below values in <code>classify</code>. Values must 
be between 0 and 1 (e.g., 0.95 gives 95% confidence interval)</p>
</dd>
<dt><code>sprt_lower</code></dt><dd><p>a numeric vector indicating lower cut-off value(s) for classification
above or below some prior threshold using the sequential probability ratio test.
Default does not use the classification scheme</p>
</dd>
<dt><code>sprt_upper</code></dt><dd><p>a numeric vector indicating upper cut-off value(s) for classification
above or below some prior threshold using the sequential probability ratio test.
Default does not use the classification scheme</p>
</dd>
<dt><code>sprt_alpha</code></dt><dd><p>a numeric vector indicating the lower-bound error rate 
to use for SPRT. Default is .05</p>
</dd>
<dt><code>sprt_beta</code></dt><dd><p>a numeric vector indicating the upper-bound error rate 
to use for SPRT. Default is .05</p>
</dd>
<dt><code>exposure</code></dt><dd><p>a numeric vector specifying the amount of exposure control to apply for
each successive item (length must equal the number of items). Note that this includes the 
first item as well when a selection criteria is specified, therefore if a specific first 
item should be used then the first element to <code>exposure</code> should be 1.  
The default uses no exposure control. 
</p>
<p>If the item exposure 
is greater than 1 then the <code>n</code> most optimal
criteria will be randomly sampled from. For instance, if 
<code>exposure[5] == 3</code>, and <code>criteria = 'MI'</code>, then when the fifth item is to be 
selected from the remaining pool of items the top 3 candidate items demonstrating 
the largest information criteria will be sampled from. Naturally, the first and last 
elements of <code>exposure</code> are ignored since exposure control will be meaningless.
</p>
<p>If all elements in <code>exposure</code> are between 0 and 1 then the Sympson-Hetter exposure 
control method will be implemented. In this method, an item is administered only if it 
passes a probability simulation experiment; otherwise, it is removed from the item pool.
Values closer to 1 are more likely to appear in the test, while value closer to 0 are more
likely to be randomly discarded.</p>
</dd>
<dt><code>constraints</code></dt><dd><p>A named list declaring various item selection constraints for which
particular item, where each list element is a vector of item numbers. Unless otherwise stated,
multiple elements can be declared (e.g., <code>list(ordered = c(1:5), ordered = c(7:9))</code> is
perfectly acceptable). These include:
</p>

<dl>
<dt><code>not_scored</code></dt><dd><p>declaring items that can be selected but will not be used in the 
scoring of the CAT. This is primarily useful when including experimental items for
future CATs. Only one vector of <code>not_scored</code> elements can be supplied</p>
</dd>
<dt><code>excluded</code></dt><dd><p>items which should not actually appear in the session 
(useful when re-testing participants who have already seen some of the items). 
Only one vector of <code>excluded</code> elements can be supplied</p>
</dd>
<dt><code>independent</code></dt><dd><p>declaring which items should never appear in the same CAT session.
Use this if, for example, item 1 and item 10 have very similar questions 
types and therefore should not appear within the same session</p>
</dd>
<dt><code>ordered</code></dt><dd><p>if one item is selected during the CAT, administer this 
particular group of items in order according to the specified sequence</p>
</dd>
<dt><code>unordered</code></dt><dd><p>same as ordered, except the items in the group will be selected at 
random until the group is complete</p>
</dd>
</dl>

</dd>
<dt><code>customUpdateThetas</code></dt><dd><p>a more advanced function of the form 
<code>customUpdateThetas &lt;- function(design, person, test)</code>      
to update the ability/latent trait estimates throughout the CAT (or more generally, scoring) session.
The <code>design</code>, <code>person</code>, and <code>test</code> are the same as in 
<code>customNextItem</code>. 
The latent trait terms are updated directly in the <code>person</code> object, which is a 
<code><a href="methods.html#topic+ReferenceClasses">ReferenceClasses</a></code> type, and therefore direct assignment to the object will modify the internal
elements. Hence, to avoid manual modification users can pass the latent trait estimates and their 
respective standard errors to the associated <code>person$Update_thetas(theta, theta_SE)</code> function.
Note that the <code>fscores()</code> function can be useful here
to capitalize on the estimation algorithms implemented in <code>mirt</code>.
</p>
<p>For example, a minimal working function would look like the following (note the use of <code>rbind()</code> to
append the history terms in the <code>person</code> object):
</p>
<pre>
       myfun &lt;- function(design, person, test){
           mo &lt;- extract.mirtCAT(test, 'mo')
           responses &lt;- extract.mirtCAT(person, 'responses')
           tmp &lt;- fscores(mo, response.pattern = responses)
           person$Update_thetas(tmp[,'F1'],
                                tmp[,'SE_F1', drop=FALSE])
           invisible()
        }
    </pre>
</dd>
<dt><code>customNextItem</code></dt><dd><p>a more advanced function of the form 
<code>customNextItem &lt;- function(design, person, test)</code> to use a customized item selection
method. This requires more complex programming and understanding of <code>mirtCAT</code>s internal elements,
and it's recommended to initially use a <code><a href="base.html#topic+browser">browser</a></code> to understand the state 
of the input arguments. When defined, all but the <code>not_scored</code> input 
to the optional <code>constraints</code> list will be ignored.
</p>
<p>Use this if you wish to program your item selection techniques explicitly, though this 
can be combined the internal <code><a href="#topic+findNextItem">findNextItem</a></code> function with analogous inputs. 
Function must return a single integer value 
indicating the next item to administer or an <code>NA</code> value to indicate that the test
should be terminated. See <code><a href="#topic+extract.mirtCAT">extract.mirtCAT</a></code> for details on how to extract and manipulate
various internal elements from the required functional arguments
</p>
</dd>
<dt><code>constr_fun</code></dt><dd><p>(WARNING: supplying this function will disable a number of the heuristic 
item selection constraints in the <code>constraints</code> list as a consequence; namely, all list options
except for <code>"not_scored"</code>).
</p>
<p>This argument contains an optional user-defined function of the form <code>function(design, person, test)</code> 
that returns a <code>data.frame</code> containing the left hand side, relationship, and right hand side
of the constraints for <code><a href="lpSolve.html#topic+lp">lp</a></code>. 
Each row corresponds to a constraint, while the number of columns should be 
equal to the number of items plus 2. Note that the column names of the 
returned <code>data.frame</code> object do not matter. 
</p>
<p>For example, say that for a given test the user wants to add 
the constraint that exactly 10 items 
should be administered to all participants, and that items 1 and 2 should not 
be included in the same test. The input would then be defined as 
</p>
<pre>const_fun &lt;- function(design, person, test){
       nitems &lt;- extract.mirt(test@mo, 'nitems')
       lhs &lt;- matrix(0, 2, nitems)
       lhs[1, ] &lt;- 1
       lhs[2, c(1,2)] &lt;- 1
       data.frame(item=lhs, relation=c("==", "&lt;="), value=c(10, 1))
     }</pre>
<p>The definition above corresponds to the constraints <code>1 * x1 + 1 * x2 + ... + 1 * xn = 10</code> 
and <code>1 * x1 + 1 * x2 + 0 * x3 + ... + 0 * xn &lt;= 1</code> , where 
the <code>x</code> terms represent binary indicators for each respective item which the optimizer 
is searching through. Given some objective vector supplied to <code><a href="#topic+findNextItem">findNextItem</a></code>,
the most optimal 10 items will be selected which satisfy these two constraints, meaning that
1) exactly 10 items will be administered, and 2) if either item 1 or 2 were
selected these two items would never appear in the same test form (though neither is forced to
appear in any given test). 
See <code><a href="#topic+findNextItem">findNextItem</a></code> for further details and examples
</p>
</dd>
<dt><code>test_properties</code></dt><dd><p>a user-defined <code>data.frame</code> object to be used
with a supplied <code>customNextItem</code> function. This should be used to define particular
properties inherent to the test items (e.g., whether they are experimental, have a particular
weighting scheme, should only be used for one particular group of individuals, and so on). 
The number of rows must be equal to the number of items in the item bank, and each row 
corresponds to the respective item. This input appears within the internal <code>design</code> object
in a <code>test_properties</code> slot.
</p>
</dd>
<dt><code>person_properties</code></dt><dd><p>a user-defined <code>data.frame</code> object to be used
with a supplied <code>customNextItem</code> function. This should be used to define particular
properties inherent to the individuals participants (e.g., known grouping variable, age, 
whether they've taken the test before (and which items they took), and so on). 
In off-line simulations, the number of rows must be equal to the number of participants. 
This input appears within the internal <code>design</code> object in a <code>person_properties</code> slot; 
for Monte Carlo simulations, rows should be manually indexed using the <code>person$ID</code> slot.
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mirtCAT_+3A_shinygui">shinyGUI</code></td>
<td>
<p>a list of GUI based parameters to be over-written. These can be
</p>

<dl>
<dt><code>title</code></dt><dd><p>A character string for the test title. Default is 
<code>'mirtCAT'</code></p>
</dd>
<dt><code>authors</code></dt><dd><p>A character string for the author names. Default is 
<code>'Author of survey'</code>. If the input is an empty string (<code>''</code>) then the author 
information will be omitted in the GUI</p>
</dd>
<dt><code>instructions</code></dt><dd><p>A two part character vector indicating how to use the GUI. 
Default is: 
</p>
<pre>c("To progress through the interface, click on the action button below.",
       "Next")</pre>
<p>The second part of the character vector provides the name for the action button.
</p>
</dd>
<dt><code>itemtimer</code></dt><dd><p>A character string to display the item-timer clock. Default is 
<code>'Item timer: '</code></p>
</dd>
<dt><code>incorrect</code></dt><dd><p>A character string to display in case of a failed response. Default is 
<code>'The answer provided was incorrect. Please select an alternative.'</code></p>
</dd>
<dt><code>failpass</code></dt><dd><p>A character string to display in case of a failed password input. Default is 
<code>'Incorrect Login Name/Password. Please try again (you have %s attempts remaining).'</code></p>
</dd>
<dt><code>timemsg</code></dt><dd><p>A three part character vector indicating words for hour, minute, second &amp; and. Default is 
<code>c('hour ','minutes ','seconds ', 'and ')</code></p>
</dd>
<dt><code>firstpage</code></dt><dd><p>The first page of the shiny GUI. Default prints the title
and information message. 
</p>
<pre> 
         list(h1('Welcome to the mirtCAT interface'),
              sprintf('The following interface was created using the mirtCAT package v
              To cite the package use citation(\'mirtCAT\') in R.', 
                 packageVersion("mirtCAT")))
         </pre>
<p>If an empty list is passed, this page will be skipped.
</p>
</dd>
<dt><code>begin_message</code></dt><dd><p>Text to display on the page prior to beginning the CAT. Default is 
<code>"Click the action button to begin."</code> for scored tests whereby a <code>mo</code> object has been include,
while the default is <code>""</code> for non-scored tests (which disables the page).</p>
</dd>
<dt><code>demographics</code></dt><dd><p>A person information page used in the GUI for collecting 
demographic information, generated using tools from the shiny package. For example,
the following code asks the participants about their Gender: 
</p>
<pre> 
         list(selectInput(inputId = 'gender',
                  label = 'Please select your gender.',
                  choices = c('', 'Male', 'Female', 'Other'),
                  selected = ''))
        </pre>
<p>By default, the demographics page is not included. 
</p>
</dd>
<dt><code>demographics_inputIDs</code></dt><dd><p>a character vector required if a custom demographics
input is used. Default is <code>demographics_inputIDs = 'gender'</code>, corresponding to
the <code>demographics</code> default</p>
</dd>
<dt><code>stem_default_format</code></dt><dd><p><code>shiny</code> function used for the stems of the items. Default uses the 
<code><a href="shiny.html#topic+HTML">HTML</a></code> wrapper, allowing for HTML tags to be included directly in the character vector 
definitions. To change this to something different, like <code><a href="shiny.html#topic+h5">h5</a></code> for example, 
pass <code>stem_default_format = shiny::h5</code> to the <code>shinyGUI</code> list</p>
</dd>
<dt><code>temp_file</code></dt><dd><p>a character vector indicating where a temporary .rds file 
containing the response information should be saved while the GUI is running. 
The object will be saved after each item is successfully completed. This is used to 
save response information to the hard drive in case there are power outages or 
unexpected computer restarts.      
</p>
<p>If <code>NULL</code>, no temp file will be created. Upon completion of the test, the 
temp file will be deleted. If a file already exists, however, then this will be used to 
resume the GUI at the last location where the session was interrupted</p>
</dd>
<dt><code>lastpage</code></dt><dd><p>A function printing the last message, indicating that the test has been completed 
(i.e., criteria has been met). The function requires exactly one argument (called <code>person</code>), where 
the input argument is the person object that has been updated throughout the test. The default function is 
</p>
<pre>function(person){ 
                    return(list(h5("You have successfully completed the interface. 
                                   It is now safe to leave the application.")))
                     } </pre>
</dd>    
<dt><code>css</code></dt><dd><p>a character string defining CSS elements to modify the GUI presentation 
elements. The input string is passed to the argument <code>tags$style(HTML(shinyGUI$css))</code>
prior to constructing the user interface</p>
</dd>
<dt><code>theme</code></dt><dd><p>a character definition for the <code>shinytheme</code> package to globally change 
the GUI theme</p>
</dd>
<dt><code>forced_choice</code></dt><dd><p>logical; require a response to each item? Default is <code>TRUE</code>.
This should only be set to <code>FALSE</code> for surveys (not CATs)</p>
</dd>
<dt><code>choiceNames</code></dt><dd><p>a list containing the <code>choiceNames</code> input for each respective item when
the input is 'radio' or 'checkbox' (see <code><a href="shiny.html#topic+radioButtons">radioButtons</a></code>). 
This is used to modify the output of the controllers using 
suitable HTML code. If a row in <code>df</code> should not have a customized names then supplying 
the value <code>NULL</code> in the associated list element will use the standard inputs instead. 
Alternatively, if specified the names of the elements to this list can be used to match the 
rownames of the <code>df</code> object to avoid the use of <code>NULL</code> placeholders</p>
</dd>
<dt><code>choiceValues</code></dt><dd><p>associated values to be used along with <code>choiceNames</code> (see above)</p>
</dd>
<dt><code>time_before_answer</code></dt><dd><p>a numeric value representing the number of seconds that must have elapsed
when <code>forced_choice = FALSE</code> before a response can be provided or skipped. This is used 
to control accidental skips over items when responses are not forced. Default is 1, indicating
one full second</p>
</dd>
<dt><code>password</code></dt><dd><p>a <code>data.frame</code> object indicating the user name (optional) and password
required prior to beginning the CAT. Possible options are
</p>

<dl>
<dt>No User Information</dt><dd><p>a single row <code>data.frame</code>. Each column supplied in this case will be associated
with a suitable password for all individuals. Naturally, if only 1 column is defined then
there is only 1 global password for all users</p>
</dd>
<dt>User Information Pairing</dt><dd><p>a multi-row <code>data.frame</code> where the first column 
represents the user name and all other columns as the same as the first option. 
E.g., if two users ('name1' and 'name2') 
are given the same password '1234' then 
<code>password = data.frame(User = c('user1', 'user2'), Password = rep('1234', 2))</code></p>
</dd>      
</dl>

</dd>
<dt><code>response_msg</code></dt><dd><p>string to print when valid responses are required but the users does not provide
a valid input. Default is <code>"Please provide a suitable response"</code></p>
</dd>    
<dt><code>ui</code></dt><dd><p>a shiny UI function used to define the interface. If <code>NULL</code>, the 
default one will be used. See <code>mirtCAT:::default_UI</code> for the internal code definition</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mirtCAT_+3A_precat">preCAT</code></td>
<td>
<p>a list object which can be used to specify a pre-CAT block in which 
different test properties may be applied prior to beginning the CAT session. If the
list is empty, no preCAT block will be used. All of the following elements are required 
to use the <code>preCAT</code> input:
</p>

<dl>
<dt><code>min_items</code></dt><dd><p>minimum number of items to administer before the CAT session begins.
Default is 0</p>
</dd>
<dt><code>max_items</code></dt><dd><p>max number of items to administer before the CAT session begins.
An input greater than 0 is required to run the preCAT stage</p>
</dd>
<dt><code>criteria</code></dt><dd><p>selection criteria (see above). Default is 'random'</p>
</dd>
<dt><code>method</code></dt><dd><p>estimation criteria (see above). It is generally recommended to 
select a method which can deal with all-or-none response patterns, such as 'EAP',
'MAP', or 'WLE'. Default is 'MAP'</p>
</dd>
<dt><code>response_variance</code></dt><dd><p>logical; terminate the preCAT stage when there is variability in the 
response pattern (i.e., when maximum-likelihood estimation contains a potential optimum)?
Default is FALSE</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mirtCAT_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="mirt.html#topic+mirt">mirt</a></code>, <code><a href="mirt.html#topic+fscores">fscores</a></code>, 
<code><a href="shiny.html#topic+runApp">runApp</a></code>, or <code>lattice</code></p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_x">x</code></td>
<td>
<p>object of class <code>'mirtCAT'</code></p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_object">object</code></td>
<td>
<p>object of class <code>'mirtCAT'</code></p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_sort">sort</code></td>
<td>
<p>logical; sort the response patterns based on the order they 
were administered? If FALSE, the raw response patterns containing NAs will be returned
for items that were not administered</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_pick_theta">pick_theta</code></td>
<td>
<p>a number indicating which theta to plot (only applicable for multidimensional 
tests). The default is to facet each theta on one plot, but to plot only the first factor pass
<code>pick_theta = 1</code></p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_true_thetas">true_thetas</code></td>
<td>
<p>logical; include a horizontal line indicating where the population-level 
theta values are? Only applicable to Monte Carlo simulations because this value would not 
be known otherwise</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_se">SE</code></td>
<td>
<p>size of the standard errors to plot. The default is 1, and therefore plots the
standard error. To obtain the 95% interval use <code>SE = 1.96</code> (from the z-distribution)</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_main">main</code></td>
<td>
<p>title of the plot. Will default to <code>'CAT Standard Errors'</code> or 
<code>'CAT ##% Confidence Intervals'</code> depending on the SE input</p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_par.strip.text">par.strip.text</code></td>
<td>
<p>plotting argument passed to <code><a href="lattice.html#topic+lattice">lattice</a></code></p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_par.settings">par.settings</code></td>
<td>
<p>plotting argument passed to <code><a href="lattice.html#topic+lattice">lattice</a></code></p>
</td></tr>
<tr><td><code id="mirtCAT_+3A_scales">scales</code></td>
<td>
<p>plotting argument passed to <code><a href="lattice.html#topic+lattice">lattice</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All tests will stop once the <code>'min_SEM'</code> criteria has been reached or classification
above or below the specified cutoffs can be made. If all questions should
be answered, users should specify an extremely small <code>'min_SEM'</code> or, equivalently, 
a large <code>'min_items'</code> criteria to the <code>design</code> list input.
</p>


<h3>Value</h3>

<p>Returns a list object of class <code>'Person'</code> containing the following elements:
</p>

<dl>
<dt><code>raw_responses</code></dt><dd><p>A character vector indicating the raws responses to the respective
items, where NA indicates the item was not answered</p>
</dd>
<dt><code>scored_responses</code></dt><dd><p>An integer vector of scored responses if the <code>item_answers</code> input
was used for each respective item</p>
</dd>
<dt><code>items_answered</code></dt><dd><p>An integer vector indicating the order in which the items were 
answered</p>
</dd>
<dt><code>thetas</code></dt><dd><p>A numeric vector indicating the final theta estimates</p>
</dd>
<dt><code>SE_thetas</code></dt><dd><p>A numeric vector indicating the standard errors of the 
final theta estimates</p>
</dd>
<dt><code>thetas_history</code></dt><dd><p>A matrix indicating the progression of updating the theta values
during the test</p>
</dd>
<dt><code>thetas_SE_history</code></dt><dd><p>A matrix indicating the standard errors for theta after each
successive item was answered</p>
</dd>
<dt><code>item_time</code></dt><dd><p>A numeric vector indicating how long the respondent took to answer
each question (in seconds)</p>
</dd>
<dt><code>demographics</code></dt><dd><p>A data.frame object containing the information collected on the 
first page of the shiny GUI. This is used to store the demographic information for each
participant</p>
</dd> 
<dt><code>classification</code></dt><dd><p>A character vector indicating whether the traits could be 
classified as 'above' or 'below' the desired cutoffs</p>
</dd>
</dl>



<h3>HTML help files, exercises, and examples</h3>

<p>To access examples, vignettes, and exercise files that have been generated with <code>knitr</code> please
visit <a href="https://github.com/philchalmers/mirtCAT/wiki">https://github.com/philchalmers/mirtCAT/wiki</a>.
</p>


<h3>Modifying the <code>design</code> object directly through <code>customNextItem()</code> (advanced)</h3>

<p>In addition to providing a completely defined item-selection map via the <code>customNextItem()</code> function, 
users may also wish to control some of the more fine-grained elements of the <code>design</code> object to adjust 
the general control parameters of the CAT (e.g., modifying the maximum number of items to administer, stopping
the CAT if something peculiar has been detected in the response patterns, etc). Note that 
this feature is rarely required for most applications, though more advanced users may wish to 
modify these various low-level elements of the <code>design</code> object directly to change the flow of the CAT
to suit their specific needs. 
</p>
<p>While the <code>person</code> object is defined as a <code>Reference Class</code> (see <code><a href="methods.html#topic+setRefClass">setRefClass</a></code>) 
the design object is generally considered a fixed S4 class, meaning that, unlike the <code>person</code> object, 
it's elements are not mutable. Therefore, in order to make changes directly to the 
<code>design</code> object the users should follow these steps:
</p>

<ol>
<li><p> Within the defined <code>customNextItem</code> function, the <code>design</code> object slots are first modified (e.g.,
<code>design@max_items &lt;- 20L</code>).
</p>
</li>
<li><p> Along with the desired next item scalar value from <code>customNextItem()</code>, the scalar object should also 
contain an attribute with the name <code>'design'</code> which holds the newly defined <code>design</code> object
(e.g., <code>attr(ret, 'design') &lt;- design; return(ret)</code>).
</p>
</li></ol>

<p>Following the above process the work-flow in <code><a href="#topic+mirtCAT">mirtCAT</a></code> will use the new <code>design</code> object in place of the
old one, even in Monte Carlo simulations.
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>
<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>
<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>
<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_pattern">generate_pattern</a></code>, <code><a href="#topic+generate.mirt_object">generate.mirt_object</a></code>, 
<code><a href="#topic+extract.mirtCAT">extract.mirtCAT</a></code>, <code><a href="#topic+findNextItem">findNextItem</a></code>, <code><a href="#topic+computeCriteria">computeCriteria</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

### unidimensional scored example with generated items

# create mo from estimated parameters
set.seed(1234)
nitems &lt;- 50
itemnames &lt;- paste0('Item.', 1:nitems)
a &lt;- matrix(rlnorm(nitems, .2, .3))
d &lt;- matrix(rnorm(nitems))
dat &lt;- simdata(a, d, 1000, itemtype = 'dich')
mod &lt;- mirt(dat, 1)
coef(mod, simplify=TRUE)

# alternatively, define mo from population values (not run)
pars &lt;- data.frame(a1=a, d=d)
mod2 &lt;- generate.mirt_object(pars, itemtype='2PL')
coef(mod2, simplify=TRUE)

# simple math items
questions &lt;- answers &lt;- character(nitems)
choices &lt;- matrix(NA, nitems, 5)
spacing &lt;- floor(d - min(d)) + 1 #easier items have more variation in the options

for(i in 1:nitems){
    n1 &lt;- sample(1:50, 1)
    n2 &lt;- sample(51:100, 1)
    ans &lt;- n1 + n2
    questions[i] &lt;- paste0(n1, ' + ', n2, ' = ?')
    answers[i] &lt;- as.character(ans)
    ch &lt;- ans + sample(c(-5:-1, 1:5) * spacing[i,], 5)
    ch[sample(1:5, 1)] &lt;- ans
    choices[i, ] &lt;- as.character(ch)
}

df &lt;- data.frame(Question=questions, Option=choices, 
                              Type = 'radio', stringsAsFactors = FALSE)
head(df)

(res &lt;- mirtCAT(df)) #collect response only (no scoring or estimating thetas)
summary(res)

# include scoring by providing Answer key
df$Answer &lt;- answers
(res_seq &lt;- mirtCAT(df, mod)) #sequential scoring 
(res_random &lt;- mirtCAT(df, mod, criteria = 'random')) #random
(res_MI &lt;- mirtCAT(df, mod, criteria = 'MI', start_item = 'MI')) #adaptive, MI starting item

summary(res_seq)
summary(res_random)
summary(res_MI)

#-----------------------------------------
# HTML tags for better customization, coerced to characters for compatibility

# help(tags, package='shiny')
options &lt;- matrix(c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"),
                  nrow = 3, ncol = 5, byrow = TRUE)
shinyStems &lt;- list(HTML('Building CATs with mirtCAT is difficult.'),
               div(HTML('mirtCAT requires a'), br(), HTML('substantial amount of coding.')),
               div(strong('I would use'), HTML('mirtCAT in my research.')))
questions &lt;- sapply(shinyStems, as.character)
df &lt;- data.frame(Question=questions,
                 Option = options, 
                 Type = "radio",
                 stringsAsFactors=FALSE)

res &lt;- mirtCAT(df)
res

#-----------------------------------------

# run locally, random response pattern given Theta
set.seed(1)
pat &lt;- generate_pattern(mod, Theta = 0, df=df)
head(pat)

# seq scoring with character pattern for the entire test (adjust min_items)
res &lt;- mirtCAT(df, mod, local_pattern=pat, design = list(min_items = 50)) 
summary(res)

# same as above, but using special input vector that doesn't require df input
set.seed(1)
pat2 &lt;- generate_pattern(mod, Theta = 0)
head(pat2)
print(mirtCAT(mo=mod, local_pattern=pat2))

# run CAT, and save results to object called person (start at 10th item)
person &lt;- mirtCAT(df, mod, item_answers = answers, criteria = 'MI', 
                  start_item = 10, local_pattern = pat)
print(person)
summary(person)

# plot the session
plot(person) #standard errors
plot(person, SE=1.96) #95 percent confidence intervals

#-----------------------------------------

### save response object to temp directory in case session ends early
wdf &lt;- paste0(getwd(), '/temp_file.rds')
res &lt;- mirtCAT(df, mod, shinyGUI = list(temp_file = wdf))

# resume test this way if test was stopped early (and temp files were saved)
res &lt;- mirtCAT(df, mod, shinyGUI = list(temp_file = wdf))
print(res)


## End(Not run)
</code></pre>

<hr>
<h2 id='mirtCAT_preamble'>Preamble function called by mirtCAT</h2><span id='topic+mirtCAT_preamble'></span>

<h3>Description</h3>

<p>This is largely an internal function called by <code><a href="#topic+mirtCAT">mirtCAT</a></code>, however it is made 
public for better use with external web-hosting interfaces (like shinyapps.io).
For more information see <a href="https://shiny.rstudio.com/articles/persistent-data-storage.html">https://shiny.rstudio.com/articles/persistent-data-storage.html</a> for 
further information about saving output remotely when using <code>shiny</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mirtCAT_preamble(..., final_fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mirtCAT_preamble_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+mirtCAT">mirtCAT</a></code></p>
</td></tr>
<tr><td><code id="mirtCAT_preamble_+3A_final_fun">final_fun</code></td>
<td>
<p>a function called just before the shiny GUI has been terminated, primarily for
saving results externally with packages such as <code>rDrop2</code>, <code>RAmazonS3</code>, 
<code>googlesheets</code>, <code>RMySQL</code>, personal servers, and 
so on when applications are hosted on the web. The function
must be of the form <code>final_fun &lt;- function(person){...}</code>, where <code>person</code> is the 
standard output returned from <code><a href="#topic+mirtCAT">mirtCAT</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirtCAT">mirtCAT</a></code>, <code><a href="#topic+createShinyGUI">createShinyGUI</a></code>, <code><a href="#topic+getPerson">getPerson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

mirtCAT_preamble(df = df)


## End(Not run)
</code></pre>

<hr>
<h2 id='mirtCAT-package'>Computerized Adaptive Testing with Multidimensional Item Response Theory</h2><span id='topic+mirtCAT-package'></span>

<h3>Description</h3>

<p>Computerized Adaptive Testing with Multidimensional Item Response Theory
</p>


<h3>Details</h3>

<p>Provides tools to generate an HTML interface for creating adaptive and 
non-adaptive educational and psychological tests using the shiny package. Suitable for 
applying unidimensional and multidimensional computerized adaptive tests using item 
response theory methodology and for creating simple questionnaires forms to collect
response data directly in R. 
</p>
<p>Users interested in the most recent version of this package can visit
<a href="https://github.com/philchalmers/mirtCAT">https://github.com/philchalmers/mirtCAT</a> and follow the instructions
for installing the package from source (additional details about installing from 
Github can be found at <a href="https://github.com/philchalmers/mirt">https://github.com/philchalmers/mirt</a>). 
Questions regarding the package can be sent to the mirt-package Google Group, located at
<a href="https://groups.google.com/forum/#!forum/mirt-package">https://groups.google.com/forum/#!forum/mirt-package</a>.
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>

<hr>
<h2 id='updateDesign'>Update design elements</h2><span id='topic+updateDesign'></span>

<h3>Description</h3>

<p>A function that will update the object returned from <code><a href="#topic+findNextItem">findNextItem</a></code>. This can 
be used to run the CAT session manually in a set-by-step manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateDesign(x, new_item, new_response, updateTheta = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateDesign_+3A_x">x</code></td>
<td>
<p>an object of class 'mirtCAT_design' returned from the <code><a href="#topic+mirtCAT">mirtCAT</a></code> function
when passing <code>design_elements = TRUE</code></p>
</td></tr>
<tr><td><code id="updateDesign_+3A_new_item">new_item</code></td>
<td>
<p>a numeric vector indicating which items to select</p>
</td></tr>
<tr><td><code id="updateDesign_+3A_new_response">new_response</code></td>
<td>
<p>a numeric vector indicating the responses the the selected items</p>
</td></tr>
<tr><td><code id="updateDesign_+3A_updatetheta">updateTheta</code></td>
<td>
<p>logical; update the internal ability terms after the new item response has been
added to the internal objects?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class 'mirtCAT_design' with updated elements.
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers <a href="mailto:rphilip.chalmers@gmail.com">rphilip.chalmers@gmail.com</a>
</p>


<h3>References</h3>

<p>Chalmers, R., P. (2012). mirt: A Multidimensional Item Response Theory
Package for the R Environment. <em>Journal of Statistical Software, 48</em>(6), 1-29.
<a href="https://doi.org/10.18637/jss.v048.i06">doi:10.18637/jss.v048.i06</a>
</p>
<p>Chalmers, R. P. (2016). Generating Adaptive and Non-Adaptive Test Interfaces for 
Multidimensional Item Response Theory Applications. <em>Journal of Statistical Software, 71</em>(5), 
1-39. <a href="https://doi.org/10.18637/jss.v071.i05">doi:10.18637/jss.v071.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mirtCAT">mirtCAT</a></code>, <code><a href="#topic+findNextItem">findNextItem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

set.seed(1)
nitems &lt;- 100
itemnames &lt;- paste0('Item.', 1:nitems)
a &lt;- matrix(rlnorm(nitems, .2, .3))
d &lt;- matrix(rnorm(nitems))
dat &lt;- simdata(a, d, 500, itemtype = 'dich')
colnames(dat) &lt;- itemnames
mod &lt;- mirt(dat, 1, verbose = FALSE)

# test defined in mirtCAT help file, first example
CATdesign &lt;- mirtCAT(mo = mod, criteria = 'MI', design_elements = TRUE,
  start_item = 2)

# returns 2 in this case, since that was the starting item
findNextItem(CATdesign) 

# first iteration, no answered items
CATdesign$person$items_answered

# update when next item is item 2 and answered correctly
CATdesign &lt;- updateDesign(CATdesign, new_item = 2, new_response = 1)
CATdesign$person$items_answered  # item 2 answered first
CATdesign$person$responses       # in item 2 element response was = 1 
CATdesign$person$thetas # current estimate
findNextItem(CATdesign) 

# determine next item if item 70 were also answered correctly next
CATdesign &lt;- updateDesign(CATdesign, new_item = 70, new_response = 1)
CATdesign$person$items_answered  
CATdesign$person$responses       
findNextItem(CATdesign) 

# continue on, now with item 95 added next (answered incorrectly)
CATdesign &lt;- updateDesign(CATdesign, new_item = 95, new_response = 0)
CATdesign$person$thetas
CATdesign$person$thetas_history
CATdesign$person$thetas_SE_history
findNextItem(CATdesign)


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
