<!DOCTYPE html><html><head><title>Help for package SGL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SGL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cvSGL'><p>Fit and Cross-Validate a GLM with a Combination of Lasso and Group Lasso Regularization</p></a></li>
<li><a href='#plot.cv.SGL'><p>plots the cross-validated error curve produced by cv.SGL</p></a></li>
<li><a href='#predictSGL'><p>Outputs Predicted Responses from an SGL Model for New Observations</p></a></li>
<li><a href='#print.SGL'><p>prints a summary of the SGL solution path</p></a></li>
<li><a href='#SGL'><p>Fit a GLM with a Combination of Lasso and Group Lasso Regularization</p></a></li>
<li><a href='#SGL-package'><p>Fit a GLM (or Cox Model) with a Combination of Lasso and Group Lasso Regularization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit a GLM (or Cox Model) with a Combination of Lasso and Group
Lasso Regularization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-9-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Noah Simon, Jerome Friedman, Trevor Hastie, and Rob Tibshirani</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Noah Simon &lt;nrsimon@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit a regularized generalized linear model via penalized
        maximum likelihood.  The model is fit for a path of values of
        the penalty parameter. Fits linear, logistic and Cox models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-27 17:27:56 UTC; noahsimon</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-27 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cvSGL'>Fit and Cross-Validate a GLM with a Combination of Lasso and Group Lasso Regularization</h2><span id='topic+cvSGL'></span>

<h3>Description</h3>

<p>Fits and cross-validates a regularized generalized linear model via penalized maximum likelihood.  The model is fit for a path of values of the penalty parameter, and a parameter value is chosen by cross-validation. Fits linear, logistic and Cox models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvSGL(data, index = rep(1, ncol(data$x)), type = "linear", maxit = 1000, thresh = 0.001,
min.frac = 0.05, nlam = 20, gamma = 0.8, nfold = 10, standardize = TRUE,
verbose = FALSE, step = 1, reset = 10, alpha = 0.95, lambdas = NULL,
foldid = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvSGL_+3A_data">data</code></td>
<td>
<p>For <code>type="linear"</code> should be a list with $x$ an input matrix of dimension n-obs by p-vars, and $y$ a length $n$ response vector. For <code>type="logit"</code> should be a list with $x$, an input matrix, as before, and $y$ a length $n$ binary response vector. For <code>type="cox"</code> should be a list with x as before, <code>time</code>, an n-vector corresponding to failure/censor times, and <code>status</code>, an n-vector indicating failure (1) or censoring (0). 
</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_index">index</code></td>
<td>
<p>A p-vector indicating group membership of each covariate</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_type">type</code></td>
<td>
<p>model type: one of (&quot;linear&quot;,&quot;logit&quot;, &quot;cox&quot;)</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations to convergence</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for change in beta</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_min.frac">min.frac</code></td>
<td>
<p>The minimum value of the penalty parameter, as a fraction of the maximum value</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_nlam">nlam</code></td>
<td>
<p>Number of lambda to use in the regularization path</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_gamma">gamma</code></td>
<td>
<p>Fitting parameter used for tuning backtracking (between 0 and 1)</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_nfold">nfold</code></td>
<td>
<p>Number of folds of the cross-validation loop</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for variable standardization (scaling) prior to fitting the model.</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag for whether or not step number will be output</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_step">step</code></td>
<td>
<p>Fitting parameter used for inital backtracking step size (between 0 and 1)</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_reset">reset</code></td>
<td>
<p>Fitting parameter used for taking advantage of local strong convexity in nesterov momentum (number of iterations before momentum term is reset)</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_alpha">alpha</code></td>
<td>

<p>The mixing parameter. <code>alpha</code> = 1 is the lasso penalty.</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_lambdas">lambdas</code></td>
<td>
<p>A user inputted sequence of lambda values for fitting. We recommend leaving this NULL and letting SGL self-select values</p>
</td></tr>
<tr><td><code id="cvSGL_+3A_foldid">foldid</code></td>
<td>
<p>An optional user-pecified vector indicating the cross-validation fold in which each observation should be included. Values in this vector should range from 1 to nfold. If left unspecified, SGL will randomly assign observations to folds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code>SGL</code> <code>nfold</code>+1 times; the initial run is to find the <code>lambda</code> sequence, subsequent runs are used to compute the cross-validated error rate and its standard deviation.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"cv.SGL"</code>
</p>
<table>
<tr><td><code>lldiff</code></td>
<td>

<p>An <code>nlam</code> vector of cross validated negative log likelihoods (squared error loss in the <code>linear</code> case, along the regularization path)
</p>
</td></tr>
<tr><td><code>llSD</code></td>
<td>

<p>An <code>nlame</code> vector of approximate standard deviations of <code>lldiff</code>
</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>The actual list of <code>lambda</code> values used in the regularization path.
</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Response type (linear/logic/cox)</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>A model fit object created by a call to <code>SGL</code> on the entire dataset
</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>A vector indicating the cross-validation folds that each observation is assigned to</p>
</td></tr>
<tr><td><code>prevals</code></td>
<td>
<p>A matrix of prevalidated predictions for each observation, for each lambda-value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Noah Simon, Jerry Friedman, Trevor Hastie, and Rob Tibshirani<br />
Maintainer: Noah Simon <a href="mailto:nrsimon@uw.edu">nrsimon@uw.edu</a>
</p>


<h3>References</h3>

<p>Simon, N., Friedman, J., Hastie, T., and Tibshirani, R. (2011)
<em>A Sparse-Group Lasso</em>, <br />
<a href="http://faculty.washington.edu/nrsimon/SGLpaper.pdf">http://faculty.washington.edu/nrsimon/SGLpaper.pdf</a>
</p>


<h3>See Also</h3>

<p><code>SGL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n = 50; p = 100; size.groups = 10
index &lt;- ceiling(1:p / size.groups)
X = matrix(rnorm(n * p), ncol = p, nrow = n)
beta = (-2:2)
y = X[,1:5] %*% beta + 0.1*rnorm(n)
data = list(x = X, y = y)
cvFit = cvSGL(data, index, type = "linear")
</code></pre>

<hr>
<h2 id='plot.cv.SGL'>plots the cross-validated error curve produced by cv.SGL</h2><span id='topic+plot.cv.SGL'></span>

<h3>Description</h3>

<p>Plots the cross-validated error curve, and confidence bounds for each <code>lambda</code> in our regularization path.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.SGL'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.SGL_+3A_x">x</code></td>
<td>
<p>fitted <code>"cv.SGL"</code> object</p>
</td></tr>
<tr><td><code id="plot.cv.SGL_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A cross validated deviance plot is produced. More regularized models are to the right (less regularized to the left)</p>


<h3>Author(s)</h3>

<p>Noah Simon, Jerome Friedman, Trevor Hastie, and Rob Tibshirani<br />
Maintainer: Noah Simon &lt;nrsimon@uw.edu&gt;
</p>


<h3>References</h3>

<p>Simon, N., Friedman, J., Hastie T., and Tibshirani, R. (2011)
<em>A Sparse-Group Lasso</em>, <br />
<a href="http://faculty.washington.edu/nrsimon/SGLpaper.pdf">http://faculty.washington.edu/nrsimon/SGLpaper.pdf</a>
</p>


<h3>See Also</h3>

<p><code>SGL</code> and <code>cv.SGL</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 50; p = 100; size.groups = 10
index &lt;- ceiling(1:p / size.groups)
X = matrix(rnorm(n * p), ncol = p, nrow = n)
beta = (-2:2)
y = X[,1:5] %*% beta + 0.1*rnorm(n)
data = list(x = X, y = y)
cvFit = cvSGL(data, index, type = "linear")
plot(cvFit)
</code></pre>

<hr>
<h2 id='predictSGL'>Outputs Predicted Responses from an SGL Model for New Observations</h2><span id='topic+predictSGL'></span>

<h3>Description</h3>

<p>Outputs predicted response values for new user input observations at a specified <code>lambda</code> value</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictSGL(x, newX, lam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictSGL_+3A_x">x</code></td>
<td>
<p>fitted <code>"SGL"</code> object</p>
</td></tr>
<tr><td><code id="predictSGL_+3A_newx">newX</code></td>
<td>
<p>covariate matrix for new observations whose responses we wish to predict</p>
</td></tr>
<tr><td><code id="predictSGL_+3A_lam">lam</code></td>
<td>
<p>the index of the lambda value for the model with which we desire to predict</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predicted outcomes are given</p>


<h3>Author(s)</h3>

<p>Noah Simon, Jerome Friedman, Trevor Hastie, and Rob Tibshirani<br />
Maintainer: Noah Simon &lt;nrsimon@uw.edu&gt;
</p>


<h3>References</h3>

<p>Simon, N., Friedman, J., Hastie T., and Tibshirani, R. (2011)
<em>A Sparse-Group Lasso</em>, <br />
<a href="http://faculty.washington.edu/nrsimon/SGLpaper.pdf">http://faculty.washington.edu/nrsimon/SGLpaper.pdf</a>
</p>


<h3>See Also</h3>

<p><code>SGL</code> and <code>cvSGL</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 50; p = 100; size.groups = 10
index &lt;- ceiling(1:p / size.groups)
X = matrix(rnorm(n * p), ncol = p, nrow = n)
beta = (-2:2)
y = X[,1:5] %*% beta + 0.1*rnorm(n)
data = list(x = X, y = y)
Fit = SGL(data, index, type = "linear")
X.new = matrix(rnorm(n * p), ncol = p, nrow = n)
predictSGL(Fit, X.new, 5)
</code></pre>

<hr>
<h2 id='print.SGL'>prints a summary of the SGL solution path</h2><span id='topic+print.SGL'></span>

<h3>Description</h3>

<p>Prints a short summary of the SGL solution path.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SGL'
print(x, digits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SGL_+3A_x">x</code></td>
<td>
<p>fitted <code>"SGL"</code> object</p>
</td></tr>
<tr><td><code id="print.SGL_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout</p>
</td></tr>
<tr><td><code id="print.SGL_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time of regression run, followed by a 2-column matrix with rows <code> lambdas</code> and <code> num.nonzero</code>. <code> lambdas</code> gives the lambda-value of each fit. <code> num.nonzero</code> gives the the number of non-zero coefficients.</p>


<h3>Author(s)</h3>

<p>Noah Simon, Jerome Friedman, Trevor Hastie, and Rob Tibshirani<br />
Maintainer: Noah Simon &lt;nrsimon@uw.edu&gt;
</p>


<h3>References</h3>

<p>Simon, N., Friedman, J., Hastie T., and Tibshirani, R. (2011)
<em>A Sparse-Group Lasso</em>, <br />
<a href="http://faculty.washington.edu/nrsimon/SGLpaper.pdf">http://faculty.washington.edu/nrsimon/SGLpaper.pdf</a>
</p>


<h3>See Also</h3>

<p><code>SGL</code> and <code>cv.SGL</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 50; p = 100; size.groups = 10
index &lt;- ceiling(1:p / size.groups)
X = matrix(rnorm(n * p), ncol = p, nrow = n)
beta = (-2:2)
y = X[,1:5] %*% beta + 0.1*rnorm(n)
data = list(x = X, y = y)
fit = SGL(data, index, type = "linear")
print(fit)
</code></pre>

<hr>
<h2 id='SGL'>Fit a GLM with a Combination of Lasso and Group Lasso Regularization</h2><span id='topic+SGL'></span>

<h3>Description</h3>

<p>Fit a regularized generalized linear model via penalized maximum likelihood.  The model is fit for a path of values of the penalty parameter. Fits linear, logistic and Cox models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SGL(data, index, type = "linear", maxit = 1000, thresh = 0.001,
min.frac = 0.1, nlam = 20, gamma = 0.8, standardize = TRUE,
verbose = FALSE, step = 1, reset = 10, alpha = 0.95, lambdas = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SGL_+3A_data">data</code></td>
<td>
<p>For <code>type="linear"</code> should be a list with $x$ an input matrix of dimension n-obs by p-vars, and $y$ a length $n$ response vector. For <code>type="logit"</code> should be a list with $x$, an input matrix, as before, and $y$ a length $n$ binary response vector. For <code>type="cox"</code> should be a list with x as before, <code>time</code>, an n-vector corresponding to failure/censor times, and <code>status</code>, an n-vector indicating failure (1) or censoring (0). 
</p>
</td></tr>
<tr><td><code id="SGL_+3A_index">index</code></td>
<td>
<p>A p-vector indicating group membership of each covariate</p>
</td></tr>
<tr><td><code id="SGL_+3A_type">type</code></td>
<td>
<p>model type: one of (&quot;linear&quot;,&quot;logit&quot;, &quot;cox&quot;)</p>
</td></tr>
<tr><td><code id="SGL_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations to convergence</p>
</td></tr>
<tr><td><code id="SGL_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for change in beta</p>
</td></tr>
<tr><td><code id="SGL_+3A_min.frac">min.frac</code></td>
<td>
<p>The minimum value of the penalty parameter, as a fraction of the maximum value</p>
</td></tr>
<tr><td><code id="SGL_+3A_nlam">nlam</code></td>
<td>
<p>Number of lambda to use in the regularization path</p>
</td></tr>
<tr><td><code id="SGL_+3A_gamma">gamma</code></td>
<td>
<p>Fitting parameter used for tuning backtracking (between 0 and 1)</p>
</td></tr>
<tr><td><code id="SGL_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for variable standardization prior to fitting the model.</p>
</td></tr>
<tr><td><code id="SGL_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag for whether or not step number will be output</p>
</td></tr>
<tr><td><code id="SGL_+3A_step">step</code></td>
<td>
<p>Fitting parameter used for inital backtracking step size (between 0 and 1)</p>
</td></tr>
<tr><td><code id="SGL_+3A_reset">reset</code></td>
<td>
<p>Fitting parameter used for taking advantage of local strong convexity in nesterov momentum (number of iterations before momentum term is reset)</p>
</td></tr>
<tr><td><code id="SGL_+3A_alpha">alpha</code></td>
<td>
<p>The mixing parameter. <code>alpha</code> = 1 is the lasso penalty. <code>alpha</code> = 0 is the group lasso penalty.</p>
</td></tr>
<tr><td><code id="SGL_+3A_lambdas">lambdas</code></td>
<td>
<p>A user specified sequence of lambda values for fitting. We recommend leaving this NULL and letting SGL self-select values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of models along the regularization path is fit by accelerated generalized gradient descent.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"SGL"</code>
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>A p by <code>nlam</code> matrix, giving the penalized MLEs for the nlam different models, where the index corresponds to the penalty parameter <code>lambda</code></p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>The actual sequence of <code>lambda</code> values used (penalty parameter)</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Response type (linear/logic/cox)</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>For some model types, an intercept is fit</p>
</td></tr>
<tr><td><code>X.transform</code></td>
<td>
<p>A list used in <code>predict</code> which gives the empirical mean and variance of the x matrix used to build the model</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>A user specified sequence of lambda values for fitting. We recommend leaving this NULL and letting SGL self-select values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Noah Simon, Jerry Friedman, Trevor Hastie, and Rob Tibshirani<br />
Maintainer: Noah Simon <a href="mailto:nrsimon@uw.edu">nrsimon@uw.edu</a>
</p>


<h3>References</h3>

<p>Simon, N., Friedman, J., Hastie, T., and Tibshirani, R. (2011)
<em>A Sparse-Group Lasso</em>, <br />
<a href="http://faculty.washington.edu/nrsimon/SGLpaper.pdf">http://faculty.washington.edu/nrsimon/SGLpaper.pdf</a>
</p>


<h3>See Also</h3>

<p><code>cv.SGL</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 50; p = 100; size.groups = 10
index &lt;- ceiling(1:p / size.groups)
X = matrix(rnorm(n * p), ncol = p, nrow = n)
beta = (-2:2)
y = X[,1:5] %*% beta + 0.1*rnorm(n)
data = list(x = X, y = y)
fit = SGL(data, index, type = "linear")
</code></pre>

<hr>
<h2 id='SGL-package'>Fit a GLM (or Cox Model) with a Combination of Lasso and Group Lasso Regularization
</h2><span id='topic+SGL-package'></span>

<h3>Description</h3>

<p>Fit a regularized generalized linear model via penalized maximum likelihood.  The model is fit for a path of values of the penalty parameter. Fits linear, logistic and Cox models.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SGL</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2012-3-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Only 4 functions:
<code>SGL</code>
<code>cvSGL</code>
<code>predictSGL</code>
<code>plot.cvSGL</code>
</p>


<h3>Author(s)</h3>

<p>Noah Simon, Jerome Friedman, Trevor Hastie, and Rob Tibshirani
</p>
<p>Maintainer: Noah Simon &lt;nrsimon@uw.edu&gt;
</p>


<h3>References</h3>

<p>Simon, N., Friedman, J., Hastie T., and Tibshirani, R. (2011)
<em>A Sparse-Group Lasso</em>, <br />
<a href="http://faculty.washington.edu/nrsimon/SGLpaper.pdf">http://faculty.washington.edu/nrsimon/SGLpaper.pdf</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
