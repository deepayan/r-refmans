<!DOCTYPE html><html lang="en"><head><title>Help for package cTMed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cTMed}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cTMed-package'><p>cTMed: Continuous Time Mediation</p></a></li>
<li><a href='#BootBeta'><p>Bootstrap Sampling Distribution</p>
for the Elements of the Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#BootBetaStd'><p>Bootstrap Sampling Distribution</p>
for the Elements of the Standardized Matrix
of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#BootIndirectCentral'><p>Bootstrap Sampling Distribution</p>
for the Indirect Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#BootMed'><p>Bootstrap Sampling Distribution</p>
of Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#BootMedStd'><p>Bootstrap Sampling Distribution</p>
of Standardized Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#BootTotalCentral'><p>Bootstrap Sampling Distribution</p>
for the Total Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#confint.ctmedboot'><p>Bootstrap Method Confidence Intervals</p></a></li>
<li><a href='#confint.ctmeddelta'><p>Delta Method Confidence Intervals</p></a></li>
<li><a href='#confint.ctmedmc'><p>Monte Carlo Method Confidence Intervals</p></a></li>
<li><a href='#DeltaBeta'><p>Delta Method Sampling Variance-Covariance Matrix</p>
for the Elements of the Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#DeltaBetaStd'><p>Delta Method Sampling Variance-Covariance Matrix</p>
for the Elements of the Standardized Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#DeltaIndirectCentral'><p>Delta Method Sampling Variance-Covariance Matrix</p>
for the Indirect Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#DeltaMed'><p>Delta Method Sampling Variance-Covariance Matrix</p>
for the Total, Direct, and Indirect Effects of X on Y
Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#DeltaMedStd'><p>Delta Method Sampling Variance-Covariance Matrix</p>
for the Standardized Total, Direct, and Indirect Effects of X on Y
Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#DeltaTotalCentral'><p>Delta Method Sampling Variance-Covariance Matrix</p>
for the Total Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#Direct'><p>Direct Effect of X on Y</p>
Over a Specific Time Interval</a></li>
<li><a href='#DirectStd'><p>Standardized Direct Effect of X on Y</p>
Over a Specific Time Interval</a></li>
<li><a href='#Indirect'><p>Indirect Effect of X on Y Through M</p>
Over a Specific Time Interval</a></li>
<li><a href='#IndirectCentral'><p>Indirect Effect Centrality</p></a></li>
<li><a href='#IndirectStd'><p>Standardized Indirect Effect of X on Y Through M</p>
Over a Specific Time Interval</a></li>
<li><a href='#MCBeta'><p>Monte Carlo Sampling Distribution</p>
for the Elements of the Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#MCBetaStd'><p>Monte Carlo Sampling Distribution</p>
for the Elements of the Standardized Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#MCIndirectCentral'><p>Monte Carlo Sampling Distribution</p>
of Indirect Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#MCMed'><p>Monte Carlo Sampling Distribution</p>
of Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#MCMedStd'><p>Monte Carlo Sampling Distribution</p>
of Standardized Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#MCPhi'><p>Generate Random Drift Matrices</p>
Using the Monte Carlo Method</a></li>
<li><a href='#MCPhiSigma'><p>Generate Random Drift Matrices</p>
and Process Noise Covariance Matrices
Using the Monte Carlo Method</a></li>
<li><a href='#MCTotalCentral'><p>Monte Carlo Sampling Distribution</p>
of Total Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#Med'><p>Total, Direct, and Indirect Effects of X on Y</p>
Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#MedStd'><p>Standardized Total, Direct, and Indirect Effects of X on Y</p>
Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#plot.ctmedboot'><p>Plot Method for an Object of Class <code>ctmedboot</code></p></a></li>
<li><a href='#plot.ctmeddelta'><p>Plot Method for an Object of Class <code>ctmeddelta</code></p></a></li>
<li><a href='#plot.ctmedmc'><p>Plot Method for an Object of Class <code>ctmedmc</code></p></a></li>
<li><a href='#plot.ctmedmed'><p>Plot Method for an Object of Class <code>ctmedmed</code></p></a></li>
<li><a href='#plot.ctmedtraj'><p>Plot Method for an Object of Class <code>ctmedtraj</code></p></a></li>
<li><a href='#PosteriorBeta'><p>Posterior Sampling Distribution</p>
for the Elements of the Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#PosteriorIndirectCentral'><p>Posterior Distribution</p>
of the Indirect Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#PosteriorMed'><p>Posterior Distribution</p>
of Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#PosteriorTotalCentral'><p>Posterior Distribution</p>
of the Total Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</a></li>
<li><a href='#print.ctmedboot'><p>Print Method for Object of Class <code>ctmedboot</code></p></a></li>
<li><a href='#print.ctmeddelta'><p>Print Method for Object of Class <code>ctmeddelta</code></p></a></li>
<li><a href='#print.ctmedeffect'><p>Print Method for Object of Class <code>ctmedeffect</code></p></a></li>
<li><a href='#print.ctmedmc'><p>Print Method for Object of Class <code>ctmedmc</code></p></a></li>
<li><a href='#print.ctmedmcphi'><p>Print Method for Object of Class <code>ctmedmcphi</code></p></a></li>
<li><a href='#print.ctmedmed'><p>Print Method for Object of Class <code>ctmedmed</code></p></a></li>
<li><a href='#print.ctmedtraj'><p>Print Method for Object of Class <code>ctmedtraj</code></p></a></li>
<li><a href='#summary.ctmedboot'><p>Summary Method for an Object of Class <code>ctmedboot</code></p></a></li>
<li><a href='#summary.ctmeddelta'><p>Summary Method for an Object of Class <code>ctmeddelta</code></p></a></li>
<li><a href='#summary.ctmedmc'><p>Summary Method for an Object of Class <code>ctmedmc</code></p></a></li>
<li><a href='#summary.ctmedmed'><p>Summary Method for an Object of Class <code>ctmedmed</code></p></a></li>
<li><a href='#summary.ctmedposteriorphi'><p>Summary Method for Object of Class <code>ctmedposteriorphi</code></p></a></li>
<li><a href='#summary.ctmedtraj'><p>Summary Method for an Object of Class <code>ctmedtraj</code></p></a></li>
<li><a href='#Total'><p>Total Effect Matrix</p>
Over a Specific Time Interval</a></li>
<li><a href='#TotalCentral'><p>Total Effect Centrality</p></a></li>
<li><a href='#TotalStd'><p>Standardized Total Effect Matrix</p>
Over a Specific Time Interval</a></li>
<li><a href='#Trajectory'><p>Simulate Trajectories of Variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Continuous Time Mediation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates standard errors and confidence intervals for effects in continuous-time mediation models. This package extends the work of
    Deboeck and Preacher (2015) &lt;<a href="https://doi.org/10.1080%2F10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>&gt; and 
    Ryan and Hamaker (2021) &lt;<a href="https://doi.org/10.1007%2Fs11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>&gt;
    by providing methods to generate standard errors and confidence intervals for the total, direct, and indirect effects in these models.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jeksterslab/cTMed">https://github.com/jeksterslab/cTMed</a>,
<a href="https://jeksterslab.github.io/cTMed/">https://jeksterslab.github.io/cTMed/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jeksterslab/cTMed/issues">https://github.com/jeksterslab/cTMed/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, numDeriv, parallel, simStateSpace</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, expm, bootStateSpace</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-21 07:20:56 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Ivan Jacob Agaloos Pesigan
    <a href="https://orcid.org/0000-0003-4818-8420"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ivan Jacob Agaloos Pesigan &lt;r.jeksterslab@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-21 17:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='cTMed-package'>cTMed: Continuous Time Mediation</h2><span id='topic+cTMed'></span><span id='topic+cTMed-package'></span>

<h3>Description</h3>

<p>Calculates standard errors and confidence intervals for effects in continuous-time mediation models. This package extends the work of Deboeck and Preacher (2015) <a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a> and Ryan and Hamaker (2021) <a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a> by providing methods to generate standard errors and confidence intervals for the total, direct, and indirect effects in these models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ivan Jacob Agaloos Pesigan <a href="mailto:r.jeksterslab@gmail.com">r.jeksterslab@gmail.com</a> (<a href="https://orcid.org/0000-0003-4818-8420">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jeksterslab/cTMed">https://github.com/jeksterslab/cTMed</a>
</p>
</li>
<li> <p><a href="https://jeksterslab.github.io/cTMed/">https://jeksterslab.github.io/cTMed/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jeksterslab/cTMed/issues">https://github.com/jeksterslab/cTMed/issues</a>
</p>
</li></ul>


<hr>
<h2 id='BootBeta'>Bootstrap Sampling Distribution
for the Elements of the Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+BootBeta'></span>

<h3>Description</h3>

<p>This function generates a bootstrap method
sampling distribution
for the elements of the matrix of lagged coefficients
<code class="reqn">\boldsymbol{\beta}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootBeta(phi, phi_hat, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootBeta_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a bootstrap estimate
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).</p>
</td></tr>
<tr><td><code id="BootBeta_+3A_phi_hat">phi_hat</code></td>
<td>
<p>Numeric matrix.
The estimated drift matrix (<code class="reqn">\hat{\boldsymbol{\Phi}}</code>)
from the original data set.
<code>phi_hat</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="BootBeta_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="BootBeta_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="BootBeta_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedboot</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;BootBeta&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list with length of <code>length(delta_t)</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>Estimated elements of the matrix of lagged coefficients.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of bootstrap
elements of the matrix of lagged coefficients.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 10L, # use at least 1000 in actual research
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = NULL, # consider using multiple cores
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
phi &lt;- extract(object = boot, what = "phi")

# Specific time interval ----------------------------------------------------
BootBeta(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
boot &lt;- BootBeta(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1:5
)
plot(boot)
plot(boot, type = "bc") # bias-corrected

# Methods -------------------------------------------------------------------
# BootBeta has a number of methods including
# print, summary, confint, and plot
print(boot)
summary(boot)
confint(boot, level = 0.95)
print(boot, type = "bc") # bias-corrected
summary(boot, type = "bc")
confint(boot, level = 0.95, type = "bc")


</code></pre>

<hr>
<h2 id='BootBetaStd'>Bootstrap Sampling Distribution
for the Elements of the Standardized Matrix
of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+BootBetaStd'></span>

<h3>Description</h3>

<p>This function generates a bootstrap method
sampling distribution
for the elements of the standardized matrix
of lagged coefficients
<code class="reqn">\boldsymbol{\beta}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootBetaStd(phi, sigma, phi_hat, sigma_hat, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootBetaStd_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a bootstrap estimate
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).</p>
</td></tr>
<tr><td><code id="BootBetaStd_+3A_sigma">sigma</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a bootstrap estimate
of the process noise covariance matrix
(<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="BootBetaStd_+3A_phi_hat">phi_hat</code></td>
<td>
<p>Numeric matrix.
The estimated drift matrix (<code class="reqn">\hat{\boldsymbol{\Phi}}</code>)
from the original data set.
<code>phi_hat</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="BootBetaStd_+3A_sigma_hat">sigma_hat</code></td>
<td>
<p>Numeric matrix.
The estimated process noise covariance matrix
(<code class="reqn">\hat{\boldsymbol{\Sigma}}</code>)
from the original data set.</p>
</td></tr>
<tr><td><code id="BootBetaStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="BootBetaStd_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="BootBetaStd_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalStd">TotalStd()</a></code>.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedboot</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;BootBetaStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list with length of <code>length(delta_t)</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>Estimated elements of the standardized matrix
of lagged coefficients.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of bootstrap
elements of the standardized matrix of lagged coefficients.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 10L, # use at least 1000 in actual research
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = NULL, # consider using multiple cores
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
sigma_hat &lt;- sigma
phi &lt;- extract(object = boot, what = "phi")
sigma &lt;- extract(object = boot, what = "sigma")

# Specific time interval ----------------------------------------------------
BootBetaStd(
  phi = phi,
  sigma = sigma,
  phi_hat = phi_hat,
  sigma_hat = sigma_hat,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
boot &lt;- BootBetaStd(
  phi = phi,
  sigma = sigma,
  phi_hat = phi_hat,
  sigma_hat = sigma_hat,
  delta_t = 1:5
)
plot(boot)
plot(boot, type = "bc") # bias-corrected

# Methods -------------------------------------------------------------------
# BootBetaStd has a number of methods including
# print, summary, confint, and plot
print(boot)
summary(boot)
confint(boot, level = 0.95)
print(boot, type = "bc") # bias-corrected
summary(boot, type = "bc")
confint(boot, level = 0.95, type = "bc")


</code></pre>

<hr>
<h2 id='BootIndirectCentral'>Bootstrap Sampling Distribution
for the Indirect Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+BootIndirectCentral'></span>

<h3>Description</h3>

<p>This function generates a bootstrap method
sampling distribution
for the indirect effect centrality
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootIndirectCentral(phi, phi_hat, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootIndirectCentral_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a bootstrap estimate
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).</p>
</td></tr>
<tr><td><code id="BootIndirectCentral_+3A_phi_hat">phi_hat</code></td>
<td>
<p>Numeric matrix.
The estimated drift matrix (<code class="reqn">\hat{\boldsymbol{\Phi}}</code>)
from the original data set.
<code>phi_hat</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="BootIndirectCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="BootIndirectCentral_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="BootIndirectCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+IndirectCentral">IndirectCentral()</a></code> more details.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedboot</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;BootIndirectCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list with length of <code>length(delta_t)</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of indirect effect centrality.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of bootstrap
indirect effect centrality.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 10L, # use at least 1000 in actual research
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = NULL, # consider using multiple cores
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
phi &lt;- extract(object = boot, what = "phi")

# Specific time interval ----------------------------------------------------
BootIndirectCentral(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
boot &lt;- BootIndirectCentral(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1:5
)
plot(boot)
plot(boot, type = "bc") # bias-corrected

# Methods -------------------------------------------------------------------
# BootIndirectCentral has a number of methods including
# print, summary, confint, and plot
print(boot)
summary(boot)
confint(boot, level = 0.95)
print(boot, type = "bc") # bias-corrected
summary(boot, type = "bc")
confint(boot, level = 0.95, type = "bc")


</code></pre>

<hr>
<h2 id='BootMed'>Bootstrap Sampling Distribution
of Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+BootMed'></span>

<h3>Description</h3>

<p>This function generates a bootstrap method
sampling distribution
of the total, direct and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootMed(phi, phi_hat, delta_t, from, to, med, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootMed_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a bootstrap estimate
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).</p>
</td></tr>
<tr><td><code id="BootMed_+3A_phi_hat">phi_hat</code></td>
<td>
<p>Numeric matrix.
The estimated drift matrix (<code class="reqn">\hat{\boldsymbol{\Phi}}</code>)
from the original data set.
<code>phi_hat</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="BootMed_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="BootMed_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="BootMed_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="BootMed_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="BootMed_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="BootMed_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>,
<code><a href="#topic+Direct">Direct()</a></code>, and
<code><a href="#topic+Indirect">Indirect()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedboot</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;BootMed&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list with length of <code>length(delta_t)</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of total, direct, and indirect effects.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of bootstrap
total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 10L, # use at least 1000 in actual research
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = NULL, # consider using multiple cores
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
phi &lt;- extract(object = boot, what = "phi")

# Specific time interval ----------------------------------------------------
BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)

# Range of time intervals ---------------------------------------------------
boot &lt;- BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
plot(boot)
plot(boot, type = "bc") # bias-corrected

# Methods -------------------------------------------------------------------
# BootMed has a number of methods including
# print, summary, confint, and plot
print(boot)
summary(boot)
confint(boot, level = 0.95)
print(boot, type = "bc") # bias-corrected
summary(boot, type = "bc")
confint(boot, level = 0.95, type = "bc")


</code></pre>

<hr>
<h2 id='BootMedStd'>Bootstrap Sampling Distribution
of Standardized Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+BootMedStd'></span>

<h3>Description</h3>

<p>This function generates a bootstrap method
sampling distribution
of the standardized total, direct and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootMedStd(
  phi,
  sigma,
  phi_hat,
  sigma_hat,
  delta_t,
  from,
  to,
  med,
  ncores = NULL,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootMedStd_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a bootstrap estimate
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_sigma">sigma</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a bootstrap estimate
of the process noise covariance matrix
(<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_phi_hat">phi_hat</code></td>
<td>
<p>Numeric matrix.
The estimated drift matrix (<code class="reqn">\hat{\boldsymbol{\Phi}}</code>)
from the original data set.
<code>phi_hat</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_sigma_hat">sigma_hat</code></td>
<td>
<p>Numeric matrix.
The estimated process noise covariance matrix
(<code class="reqn">\hat{\boldsymbol{\Sigma}}</code>)
from the original data set.</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="BootMedStd_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalStd">TotalStd()</a></code>,
<code><a href="#topic+DirectStd">DirectStd()</a></code>, and
<code><a href="#topic+IndirectStd">IndirectStd()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedboot</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;BootMedStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list with length of <code>length(delta_t)</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of standardized total, direct, and indirect effects.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of bootstrap
standardized total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 10L, # use at least 1000 in actual research
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = NULL, # consider using multiple cores
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
sigma_hat &lt;- sigma
phi &lt;- extract(object = boot, what = "phi")
sigma &lt;- extract(object = boot, what = "sigma")

# Specific time interval ----------------------------------------------------
BootMedStd(
  phi = phi,
  sigma = sigma,
  phi_hat = phi_hat,
  sigma_hat = sigma_hat,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)

# Range of time intervals ---------------------------------------------------
boot &lt;- BootMedStd(
  phi = phi,
  sigma = sigma,
  phi_hat = phi_hat,
  sigma_hat = sigma_hat,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
plot(boot)
plot(boot, type = "bc") # bias-corrected

# Methods -------------------------------------------------------------------
# BootMedStd has a number of methods including
# print, summary, confint, and plot
print(boot)
summary(boot)
confint(boot, level = 0.95)
print(boot, type = "bc") # bias-corrected
summary(boot, type = "bc")
confint(boot, level = 0.95, type = "bc")


</code></pre>

<hr>
<h2 id='BootTotalCentral'>Bootstrap Sampling Distribution
for the Total Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+BootTotalCentral'></span>

<h3>Description</h3>

<p>This function generates a bootstrap method
sampling distribution
for the total effect centrality
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootTotalCentral(phi, phi_hat, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BootTotalCentral_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a bootstrap estimate
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).</p>
</td></tr>
<tr><td><code id="BootTotalCentral_+3A_phi_hat">phi_hat</code></td>
<td>
<p>Numeric matrix.
The estimated drift matrix (<code class="reqn">\hat{\boldsymbol{\Phi}}</code>)
from the original data set.
<code>phi_hat</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="BootTotalCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="BootTotalCentral_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="BootTotalCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalCentral">TotalCentral()</a></code> more details.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedboot</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;BootTotalCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list with length of <code>length(delta_t)</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of total effect centrality.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of bootstrap
total effect centrality.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 10L, # use at least 1000 in actual research
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = NULL, # consider using multiple cores
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
phi &lt;- extract(object = boot, what = "phi")

# Specific time interval ----------------------------------------------------
BootTotalCentral(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
boot &lt;- BootTotalCentral(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1:5
)
plot(boot)
plot(boot, type = "bc") # bias-corrected

# Methods -------------------------------------------------------------------
# BootTotalCentral has a number of methods including
# print, summary, confint, and plot
print(boot)
summary(boot)
confint(boot, level = 0.95)
print(boot, type = "bc") # bias-corrected
summary(boot, type = "bc")
confint(boot, level = 0.95, type = "bc")


</code></pre>

<hr>
<h2 id='confint.ctmedboot'>Bootstrap Method Confidence Intervals</h2><span id='topic+confint.ctmedboot'></span>

<h3>Description</h3>

<p>Bootstrap Method Confidence Intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedboot'
confint(object, parm = NULL, level = 0.95, type = "pc", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.ctmedboot_+3A_object">object</code></td>
<td>
<p>Object of class <code>ctmedboot</code>.</p>
</td></tr>
<tr><td><code id="confint.ctmedboot_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters
are to be given confidence intervals,
either a vector of numbers or a vector of names.
If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.ctmedboot_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.ctmedboot_+3A_type">type</code></td>
<td>
<p>Charater string.
Confidence interval type, that is,
<code>type = "pc"</code> for percentile;
<code>type = "bc"</code> for bias corrected.</p>
</td></tr>
<tr><td><code id="confint.ctmedboot_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 1000L,
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = parallel::detectCores() - 1,
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
phi &lt;- extract(object = boot, what = "phi")

# Specific time interval ----------------------------------------------------
boot &lt;- BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)
confint(boot)
confint(boot, type = "bc") # bias-corrected

# Range of time intervals ---------------------------------------------------
boot &lt;- BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
confint(boot)
confint(boot, type = "bc") # bias-corrected

## End(Not run)

</code></pre>

<hr>
<h2 id='confint.ctmeddelta'>Delta Method Confidence Intervals</h2><span id='topic+confint.ctmeddelta'></span>

<h3>Description</h3>

<p>Delta Method Confidence Intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmeddelta'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.ctmeddelta_+3A_object">object</code></td>
<td>
<p>Object of class <code>ctmeddelta</code>.</p>
</td></tr>
<tr><td><code id="confint.ctmeddelta_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters
are to be given confidence intervals,
either a vector of numbers or a vector of names.
If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.ctmeddelta_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.ctmeddelta_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
delta &lt;- DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)
confint(delta, level = 0.95)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
confint(delta, level = 0.95)

</code></pre>

<hr>
<h2 id='confint.ctmedmc'>Monte Carlo Method Confidence Intervals</h2><span id='topic+confint.ctmedmc'></span>

<h3>Description</h3>

<p>Monte Carlo Method Confidence Intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedmc'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.ctmedmc_+3A_object">object</code></td>
<td>
<p>Object of class <code>ctmedmc</code>.</p>
</td></tr>
<tr><td><code id="confint.ctmedmc_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters
are to be given confidence intervals,
either a vector of numbers or a vector of names.
If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.ctmedmc_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.ctmedmc_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
mc &lt;- MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
confint(mc, level = 0.95)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
confint(mc, level = 0.95)

</code></pre>

<hr>
<h2 id='DeltaBeta'>Delta Method Sampling Variance-Covariance Matrix
for the Elements of the Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+DeltaBeta'></span>

<h3>Description</h3>

<p>This function computes the delta method
sampling variance-covariance matrix
for the elements of the matrix of lagged coefficients
<code class="reqn">\boldsymbol{\beta}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaBeta(phi, vcov_phi_vec, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeltaBeta_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="DeltaBeta_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="DeltaBeta_+3A_delta_t">delta_t</code></td>
<td>
<p>Vector of positive numbers.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="DeltaBeta_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when the length of <code>delta_t</code> is long.</p>
</td></tr>
<tr><td><code id="DeltaBeta_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>.
</p>


<h4>Delta Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
By the multivariate central limit theory,
the function <code class="reqn">\mathbf{g}</code>
using <code class="reqn">\hat{\boldsymbol{\theta}}</code> as input
can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
  	\sqrt{n}
  	\left(
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	-
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	\right)
  	\xrightarrow[]{
  		\mathrm{D}
  	}
  	\mathcal{N}
  	\left(
  	0,
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>where <code class="reqn">\mathbf{J}</code> is the matrix of first-order derivatives
of the function <code class="reqn">\mathbf{g}</code>
with respect to the elements of <code class="reqn">\boldsymbol{\theta}</code>
and
<code class="reqn">\boldsymbol{\Gamma}</code>
is the asymptotic variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>.
</p>
<p>From the former,
we can derive the distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	n^{-1}
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>The uncertainty associated with the estimator
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is, therefore, given by
<code class="reqn">n^{-1} \mathbf{J} \boldsymbol{\Gamma} \mathbf{J}^{\prime}</code> .
When <code class="reqn">\boldsymbol{\Gamma}</code> is unknown,
by substitution,
we can use
the estimated sampling variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>,
that is,
<code class="reqn">\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)</code>
for <code class="reqn">n^{-1} \boldsymbol{\Gamma}</code>.
Therefore,
the sampling variance-covariance matrix of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	\mathbf{J}
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\mathbf{J}^{\prime}
  	\right) .
  </code>
</p>




<h3>Value</h3>

<p>Returns an object
of class <code>ctmeddelta</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;DeltaBeta&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>delta_t</dt><dd><p>Time interval.</p>
</dd>
<dt>jacobian</dt><dd><p>Jacobian matrix.</p>
</dd>
<dt>est</dt><dd><p>Estimated elements of the matrix of lagged coefficients.</p>
</dd>
<dt>vcov</dt><dd><p>Sampling variance-covariance matrix of
estimated elements of the matrix of lagged coefficients.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
DeltaBeta(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaBeta(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5
)
plot(delta)

# Methods -------------------------------------------------------------------
# DeltaBeta has a number of methods including
# print, summary, confint, and plot
print(delta)
summary(delta)
confint(delta, level = 0.95)
plot(delta)

</code></pre>

<hr>
<h2 id='DeltaBetaStd'>Delta Method Sampling Variance-Covariance Matrix
for the Elements of the Standardized Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+DeltaBetaStd'></span>

<h3>Description</h3>

<p>This function computes the delta method
sampling variance-covariance matrix
for the elements of the standardized matrix of lagged coefficients
<code class="reqn">\boldsymbol{\beta}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaBetaStd(phi, sigma, vcov_theta, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeltaBetaStd_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="DeltaBetaStd_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="DeltaBetaStd_+3A_vcov_theta">vcov_theta</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code></p>
</td></tr>
<tr><td><code id="DeltaBetaStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="DeltaBetaStd_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="DeltaBetaStd_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalStd">TotalStd()</a></code>.
</p>


<h4>Delta Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code>,
that is,
the unique elements of the <code class="reqn">\boldsymbol{\Sigma}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \hat{\boldsymbol{\Sigma}} \right)</code>.
By the multivariate central limit theory,
the function <code class="reqn">\mathbf{g}</code>
using <code class="reqn">\hat{\boldsymbol{\theta}}</code> as input
can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
  	\sqrt{n}
  	\left(
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	-
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	\right)
  	\xrightarrow[]{
  		\mathrm{D}
  	}
  	\mathcal{N}
  	\left(
  	0,
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>where <code class="reqn">\mathbf{J}</code> is the matrix of first-order derivatives
of the function <code class="reqn">\mathbf{g}</code>
with respect to the elements of <code class="reqn">\boldsymbol{\theta}</code>
and
<code class="reqn">\boldsymbol{\Gamma}</code>
is the asymptotic variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>.
</p>
<p>From the former,
we can derive the distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	n^{-1}
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>The uncertainty associated with the estimator
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is, therefore, given by
<code class="reqn">n^{-1} \mathbf{J} \boldsymbol{\Gamma} \mathbf{J}^{\prime}</code> .
When <code class="reqn">\boldsymbol{\Gamma}</code> is unknown,
by substitution,
we can use
the estimated sampling variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>,
that is,
<code class="reqn">\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)</code>
for <code class="reqn">n^{-1} \boldsymbol{\Gamma}</code>.
Therefore,
the sampling variance-covariance matrix of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	\mathbf{J}
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\mathbf{J}^{\prime}
  	\right) .
  </code>
</p>




<h3>Value</h3>

<p>Returns an object
of class <code>ctmeddelta</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;DeltaBetaStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>delta_t</dt><dd><p>Time interval.</p>
</dd>
<dt>jacobian</dt><dd><p>Jacobian matrix.</p>
</dd>
<dt>est</dt><dd><p>Estimated elements of the standardized matrix
of lagged coefficients.</p>
</dd>
<dt>vcov</dt><dd><p>Sampling variance-covariance matrix of
estimated elements of the standardized matrix
of lagged coefficients.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)
vcov_theta &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151, -0.00600, -0.00033,
    0.00110, 0.00324, 0.00020, -0.00061, -0.00115,
    0.00011, 0.00015, 0.00001, -0.00002, -0.00001,
    0.00040, 0.00374, 0.00016, -0.00022, -0.00273,
    -0.00016, 0.00009, 0.00150, 0.00012, -0.00010,
    -0.00026, 0.00002, 0.00012, 0.00004, -0.00001,
    -0.00151, 0.00016, 0.00389, 0.00103, -0.00007,
    -0.00283, -0.00050, 0.00000, 0.00156, 0.00021,
    -0.00005, -0.00031, 0.00001, 0.00007, 0.00006,
    -0.00600, -0.00022, 0.00103, 0.00644, 0.00031,
    -0.00119, -0.00374, -0.00021, 0.00070, 0.00064,
    -0.00015, -0.00005, 0.00000, 0.00003, -0.00001,
    -0.00033, -0.00273, -0.00007, 0.00031, 0.00287,
    0.00013, -0.00014, -0.00170, -0.00012, 0.00006,
    0.00014, -0.00001, -0.00015, 0.00000, 0.00001,
    0.00110, -0.00016, -0.00283, -0.00119, 0.00013,
    0.00297, 0.00063, -0.00004, -0.00177, -0.00013,
    0.00005, 0.00017, -0.00002, -0.00008, 0.00001,
    0.00324, 0.00009, -0.00050, -0.00374, -0.00014,
    0.00063, 0.00495, 0.00024, -0.00093, -0.00020,
    0.00006, -0.00010, 0.00000, -0.00001, 0.00004,
    0.00020, 0.00150, 0.00000, -0.00021, -0.00170,
    -0.00004, 0.00024, 0.00214, 0.00012, -0.00002,
    -0.00004, 0.00000, 0.00006, -0.00005, -0.00001,
    -0.00061, 0.00012, 0.00156, 0.00070, -0.00012,
    -0.00177, -0.00093, 0.00012, 0.00223, 0.00004,
    -0.00002, -0.00003, 0.00001, 0.00003, -0.00013,
    -0.00115, -0.00010, 0.00021, 0.00064, 0.00006,
    -0.00013, -0.00020, -0.00002, 0.00004, 0.00057,
    0.00001, -0.00009, 0.00000, 0.00000, 0.00001,
    0.00011, -0.00026, -0.00005, -0.00015, 0.00014,
    0.00005, 0.00006, -0.00004, -0.00002, 0.00001,
    0.00012, 0.00001, 0.00000, -0.00002, 0.00000,
    0.00015, 0.00002, -0.00031, -0.00005, -0.00001,
    0.00017, -0.00010, 0.00000, -0.00003, -0.00009,
    0.00001, 0.00014, 0.00000, 0.00000, -0.00005,
    0.00001, 0.00012, 0.00001, 0.00000, -0.00015,
    -0.00002, 0.00000, 0.00006, 0.00001, 0.00000,
    0.00000, 0.00000, 0.00010, 0.00001, 0.00000,
    -0.00002, 0.00004, 0.00007, 0.00003, 0.00000,
    -0.00008, -0.00001, -0.00005, 0.00003, 0.00000,
    -0.00002, 0.00000, 0.00001, 0.00005, 0.00001,
    -0.00001, -0.00001, 0.00006, -0.00001, 0.00001,
    0.00001, 0.00004, -0.00001, -0.00013, 0.00001,
    0.00000, -0.00005, 0.00000, 0.00001, 0.00012
  ),
  nrow = 15
)

# Specific time interval ----------------------------------------------------
DeltaBetaStd(
  phi = phi,
  sigma = sigma,
  vcov_theta = vcov_theta,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaBetaStd(
  phi = phi,
  sigma = sigma,
  vcov_theta = vcov_theta,
  delta_t = 1:5
)
plot(delta)

# Methods -------------------------------------------------------------------
# DeltaBetaStd has a number of methods including
# print, summary, confint, and plot
print(delta)
summary(delta)
confint(delta, level = 0.95)
plot(delta)

</code></pre>

<hr>
<h2 id='DeltaIndirectCentral'>Delta Method Sampling Variance-Covariance Matrix
for the Indirect Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+DeltaIndirectCentral'></span>

<h3>Description</h3>

<p>This function computes the delta method
sampling variance-covariance matrix
for the indirect effect centrality
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaIndirectCentral(phi, vcov_phi_vec, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeltaIndirectCentral_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="DeltaIndirectCentral_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="DeltaIndirectCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Vector of positive numbers.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="DeltaIndirectCentral_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when the length of <code>delta_t</code> is long.</p>
</td></tr>
<tr><td><code id="DeltaIndirectCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+IndirectCentral">IndirectCentral()</a></code> more details.
</p>


<h4>Delta Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
By the multivariate central limit theory,
the function <code class="reqn">\mathbf{g}</code>
using <code class="reqn">\hat{\boldsymbol{\theta}}</code> as input
can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
  	\sqrt{n}
  	\left(
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	-
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	\right)
  	\xrightarrow[]{
  		\mathrm{D}
  	}
  	\mathcal{N}
  	\left(
  	0,
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>where <code class="reqn">\mathbf{J}</code> is the matrix of first-order derivatives
of the function <code class="reqn">\mathbf{g}</code>
with respect to the elements of <code class="reqn">\boldsymbol{\theta}</code>
and
<code class="reqn">\boldsymbol{\Gamma}</code>
is the asymptotic variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>.
</p>
<p>From the former,
we can derive the distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	n^{-1}
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>The uncertainty associated with the estimator
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is, therefore, given by
<code class="reqn">n^{-1} \mathbf{J} \boldsymbol{\Gamma} \mathbf{J}^{\prime}</code> .
When <code class="reqn">\boldsymbol{\Gamma}</code> is unknown,
by substitution,
we can use
the estimated sampling variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>,
that is,
<code class="reqn">\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)</code>
for <code class="reqn">n^{-1} \boldsymbol{\Gamma}</code>.
Therefore,
the sampling variance-covariance matrix of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	\mathbf{J}
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\mathbf{J}^{\prime}
  	\right) .
  </code>
</p>




<h3>Value</h3>

<p>Returns an object
of class <code>ctmeddelta</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;DeltaIndirectCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>delta_t</dt><dd><p>Time interval.</p>
</dd>
<dt>jacobian</dt><dd><p>Jacobian matrix.</p>
</dd>
<dt>est</dt><dd><p>Estimated indirect effect centrality.</p>
</dd>
<dt>vcov</dt><dd><p>Sampling variance-covariance matrix of
estimated indirect effect centrality.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.002704274, -0.001475275, 0.000949122,
    -0.001619422, 0.000885122, -0.000569404,
    0.00085493, -0.000465824, 0.000297815,
    -0.001475275, 0.004428442, -0.002642303,
    0.000980573, -0.00271817, 0.001618805,
    -0.000586921, 0.001478421, -0.000871547,
    0.000949122, -0.002642303, 0.006402668,
    -0.000697798, 0.001813471, -0.004043138,
    0.000463086, -0.001120949, 0.002271711,
    -0.001619422, 0.000980573, -0.000697798,
    0.002079286, -0.001152501, 0.000753,
    -0.001528701, 0.000820587, -0.000517524,
    0.000885122, -0.00271817, 0.001813471,
    -0.001152501, 0.00342605, -0.002075005,
    0.000899165, -0.002532849, 0.001475579,
    -0.000569404, 0.001618805, -0.004043138,
    0.000753, -0.002075005, 0.004984032,
    -0.000622255, 0.001634917, -0.003705661,
    0.00085493, -0.000586921, 0.000463086,
    -0.001528701, 0.000899165, -0.000622255,
    0.002060076, -0.001096684, 0.000686386,
    -0.000465824, 0.001478421, -0.001120949,
    0.000820587, -0.002532849, 0.001634917,
    -0.001096684, 0.003328692, -0.001926088,
    0.000297815, -0.000871547, 0.002271711,
    -0.000517524, 0.001475579, -0.003705661,
    0.000686386, -0.001926088, 0.004726235
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
DeltaIndirectCentral(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaIndirectCentral(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5
)
plot(delta)

# Methods -------------------------------------------------------------------
# DeltaIndirectCentral has a number of methods including
# print, summary, confint, and plot
print(delta)
summary(delta)
confint(delta, level = 0.95)
plot(delta)

</code></pre>

<hr>
<h2 id='DeltaMed'>Delta Method Sampling Variance-Covariance Matrix
for the Total, Direct, and Indirect Effects of X on Y
Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+DeltaMed'></span>

<h3>Description</h3>

<p>This function computes the delta method
sampling variance-covariance matrix
for the total, direct, and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaMed(phi, vcov_phi_vec, delta_t, from, to, med, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeltaMed_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="DeltaMed_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="DeltaMed_+3A_delta_t">delta_t</code></td>
<td>
<p>Vector of positive numbers.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="DeltaMed_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="DeltaMed_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="DeltaMed_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="DeltaMed_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when the length of <code>delta_t</code> is long.</p>
</td></tr>
<tr><td><code id="DeltaMed_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>,
<code><a href="#topic+Direct">Direct()</a></code>, and
<code><a href="#topic+Indirect">Indirect()</a></code> for more details.
</p>


<h4>Delta Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
By the multivariate central limit theory,
the function <code class="reqn">\mathbf{g}</code>
using <code class="reqn">\hat{\boldsymbol{\theta}}</code> as input
can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
  	\sqrt{n}
  	\left(
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	-
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	\right)
  	\xrightarrow[]{
  		\mathrm{D}
  	}
  	\mathcal{N}
  	\left(
  	0,
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>where <code class="reqn">\mathbf{J}</code> is the matrix of first-order derivatives
of the function <code class="reqn">\mathbf{g}</code>
with respect to the elements of <code class="reqn">\boldsymbol{\theta}</code>
and
<code class="reqn">\boldsymbol{\Gamma}</code>
is the asymptotic variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>.
</p>
<p>From the former,
we can derive the distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	n^{-1}
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>The uncertainty associated with the estimator
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is, therefore, given by
<code class="reqn">n^{-1} \mathbf{J} \boldsymbol{\Gamma} \mathbf{J}^{\prime}</code> .
When <code class="reqn">\boldsymbol{\Gamma}</code> is unknown,
by substitution,
we can use
the estimated sampling variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>,
that is,
<code class="reqn">\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)</code>
for <code class="reqn">n^{-1} \boldsymbol{\Gamma}</code>.
Therefore,
the sampling variance-covariance matrix of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	\mathbf{J}
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\mathbf{J}^{\prime}
  	\right) .
  </code>
</p>




<h3>Value</h3>

<p>Returns an object
of class <code>ctmeddelta</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;DeltaMed&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>delta_t</dt><dd><p>Time interval.</p>
</dd>
<dt>jacobian</dt><dd><p>Jacobian matrix.</p>
</dd>
<dt>est</dt><dd><p>Estimated total, direct, and indirect effects.</p>
</dd>
<dt>vcov</dt><dd><p>Sampling variance-covariance matrix of the
estimated total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
plot(delta)

# Methods -------------------------------------------------------------------
# DeltaMed has a number of methods including
# print, summary, confint, and plot
print(delta)
summary(delta)
confint(delta, level = 0.95)
plot(delta)

</code></pre>

<hr>
<h2 id='DeltaMedStd'>Delta Method Sampling Variance-Covariance Matrix
for the Standardized Total, Direct, and Indirect Effects of X on Y
Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+DeltaMedStd'></span>

<h3>Description</h3>

<p>This function computes the delta method
sampling variance-covariance matrix
for the standardized total, direct, and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaMedStd(
  phi,
  sigma,
  vcov_theta,
  delta_t,
  from,
  to,
  med,
  ncores = NULL,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeltaMedStd_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="DeltaMedStd_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="DeltaMedStd_+3A_vcov_theta">vcov_theta</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code></p>
</td></tr>
<tr><td><code id="DeltaMedStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="DeltaMedStd_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="DeltaMedStd_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="DeltaMedStd_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="DeltaMedStd_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="DeltaMedStd_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalStd">TotalStd()</a></code>,
<code><a href="#topic+DirectStd">DirectStd()</a></code>, and
<code><a href="#topic+IndirectStd">IndirectStd()</a></code> for more details.
</p>


<h4>Delta Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code>,
that is,
the unique elements of the <code class="reqn">\boldsymbol{\Sigma}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \hat{\boldsymbol{\Sigma}} \right)</code>.
By the multivariate central limit theory,
the function <code class="reqn">\mathbf{g}</code>
using <code class="reqn">\hat{\boldsymbol{\theta}}</code> as input
can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
  	\sqrt{n}
  	\left(
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	-
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	\right)
  	\xrightarrow[]{
  		\mathrm{D}
  	}
  	\mathcal{N}
  	\left(
  	0,
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>where <code class="reqn">\mathbf{J}</code> is the matrix of first-order derivatives
of the function <code class="reqn">\mathbf{g}</code>
with respect to the elements of <code class="reqn">\boldsymbol{\theta}</code>
and
<code class="reqn">\boldsymbol{\Gamma}</code>
is the asymptotic variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>.
</p>
<p>From the former,
we can derive the distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	n^{-1}
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>The uncertainty associated with the estimator
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is, therefore, given by
<code class="reqn">n^{-1} \mathbf{J} \boldsymbol{\Gamma} \mathbf{J}^{\prime}</code> .
When <code class="reqn">\boldsymbol{\Gamma}</code> is unknown,
by substitution,
we can use
the estimated sampling variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>,
that is,
<code class="reqn">\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)</code>
for <code class="reqn">n^{-1} \boldsymbol{\Gamma}</code>.
Therefore,
the sampling variance-covariance matrix of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	\mathbf{J}
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\mathbf{J}^{\prime}
  	\right) .
  </code>
</p>




<h3>Value</h3>

<p>Returns an object
of class <code>ctmeddelta</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;DeltaMedStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>delta_t</dt><dd><p>Time interval.</p>
</dd>
<dt>jacobian</dt><dd><p>Jacobian matrix.</p>
</dd>
<dt>est</dt><dd><p>Estimated standardized total, direct, and indirect effects.</p>
</dd>
<dt>vcov</dt><dd><p>Sampling variance-covariance matrix of the
estimated standardized total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)
vcov_theta &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151, -0.00600, -0.00033,
    0.00110, 0.00324, 0.00020, -0.00061, -0.00115,
    0.00011, 0.00015, 0.00001, -0.00002, -0.00001,
    0.00040, 0.00374, 0.00016, -0.00022, -0.00273,
    -0.00016, 0.00009, 0.00150, 0.00012, -0.00010,
    -0.00026, 0.00002, 0.00012, 0.00004, -0.00001,
    -0.00151, 0.00016, 0.00389, 0.00103, -0.00007,
    -0.00283, -0.00050, 0.00000, 0.00156, 0.00021,
    -0.00005, -0.00031, 0.00001, 0.00007, 0.00006,
    -0.00600, -0.00022, 0.00103, 0.00644, 0.00031,
    -0.00119, -0.00374, -0.00021, 0.00070, 0.00064,
    -0.00015, -0.00005, 0.00000, 0.00003, -0.00001,
    -0.00033, -0.00273, -0.00007, 0.00031, 0.00287,
    0.00013, -0.00014, -0.00170, -0.00012, 0.00006,
    0.00014, -0.00001, -0.00015, 0.00000, 0.00001,
    0.00110, -0.00016, -0.00283, -0.00119, 0.00013,
    0.00297, 0.00063, -0.00004, -0.00177, -0.00013,
    0.00005, 0.00017, -0.00002, -0.00008, 0.00001,
    0.00324, 0.00009, -0.00050, -0.00374, -0.00014,
    0.00063, 0.00495, 0.00024, -0.00093, -0.00020,
    0.00006, -0.00010, 0.00000, -0.00001, 0.00004,
    0.00020, 0.00150, 0.00000, -0.00021, -0.00170,
    -0.00004, 0.00024, 0.00214, 0.00012, -0.00002,
    -0.00004, 0.00000, 0.00006, -0.00005, -0.00001,
    -0.00061, 0.00012, 0.00156, 0.00070, -0.00012,
    -0.00177, -0.00093, 0.00012, 0.00223, 0.00004,
    -0.00002, -0.00003, 0.00001, 0.00003, -0.00013,
    -0.00115, -0.00010, 0.00021, 0.00064, 0.00006,
    -0.00013, -0.00020, -0.00002, 0.00004, 0.00057,
    0.00001, -0.00009, 0.00000, 0.00000, 0.00001,
    0.00011, -0.00026, -0.00005, -0.00015, 0.00014,
    0.00005, 0.00006, -0.00004, -0.00002, 0.00001,
    0.00012, 0.00001, 0.00000, -0.00002, 0.00000,
    0.00015, 0.00002, -0.00031, -0.00005, -0.00001,
    0.00017, -0.00010, 0.00000, -0.00003, -0.00009,
    0.00001, 0.00014, 0.00000, 0.00000, -0.00005,
    0.00001, 0.00012, 0.00001, 0.00000, -0.00015,
    -0.00002, 0.00000, 0.00006, 0.00001, 0.00000,
    0.00000, 0.00000, 0.00010, 0.00001, 0.00000,
    -0.00002, 0.00004, 0.00007, 0.00003, 0.00000,
    -0.00008, -0.00001, -0.00005, 0.00003, 0.00000,
    -0.00002, 0.00000, 0.00001, 0.00005, 0.00001,
    -0.00001, -0.00001, 0.00006, -0.00001, 0.00001,
    0.00001, 0.00004, -0.00001, -0.00013, 0.00001,
    0.00000, -0.00005, 0.00000, 0.00001, 0.00012
  ),
  nrow = 15
)

# Specific time interval ----------------------------------------------------
DeltaMedStd(
  phi = phi,
  sigma = sigma,
  vcov_theta = vcov_theta,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaMedStd(
  phi = phi,
  sigma = sigma,
  vcov_theta = vcov_theta,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
plot(delta)

# Methods -------------------------------------------------------------------
# DeltaMedStd has a number of methods including
# print, summary, confint, and plot
print(delta)
summary(delta)
confint(delta, level = 0.95)
plot(delta)

</code></pre>

<hr>
<h2 id='DeltaTotalCentral'>Delta Method Sampling Variance-Covariance Matrix
for the Total Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+DeltaTotalCentral'></span>

<h3>Description</h3>

<p>This function computes the delta method
sampling variance-covariance matrix
for the total effect centrality
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaTotalCentral(phi, vcov_phi_vec, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeltaTotalCentral_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="DeltaTotalCentral_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="DeltaTotalCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Vector of positive numbers.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="DeltaTotalCentral_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when the length of <code>delta_t</code> is long.</p>
</td></tr>
<tr><td><code id="DeltaTotalCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalCentral">TotalCentral()</a></code> more details.
</p>


<h4>Delta Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
By the multivariate central limit theory,
the function <code class="reqn">\mathbf{g}</code>
using <code class="reqn">\hat{\boldsymbol{\theta}}</code> as input
can be expressed as:
</p>
<p style="text-align: center;"><code class="reqn">
  	\sqrt{n}
  	\left(
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	-
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	\right)
  	\xrightarrow[]{
  		\mathrm{D}
  	}
  	\mathcal{N}
  	\left(
  	0,
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>where <code class="reqn">\mathbf{J}</code> is the matrix of first-order derivatives
of the function <code class="reqn">\mathbf{g}</code>
with respect to the elements of <code class="reqn">\boldsymbol{\theta}</code>
and
<code class="reqn">\boldsymbol{\Gamma}</code>
is the asymptotic variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>.
</p>
<p>From the former,
we can derive the distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	n^{-1}
  	\mathbf{J}
  	\boldsymbol{\Gamma}
  	\mathbf{J}^{\prime}
  	\right)
  </code>
</p>

<p>The uncertainty associated with the estimator
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is, therefore, given by
<code class="reqn">n^{-1} \mathbf{J} \boldsymbol{\Gamma} \mathbf{J}^{\prime}</code> .
When <code class="reqn">\boldsymbol{\Gamma}</code> is unknown,
by substitution,
we can use
the estimated sampling variance-covariance matrix of
<code class="reqn">\hat{\boldsymbol{\theta}}</code>,
that is,
<code class="reqn">\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)</code>
for <code class="reqn">n^{-1} \boldsymbol{\Gamma}</code>.
Therefore,
the sampling variance-covariance matrix of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
  	\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)
  	\approx
  	\mathcal{N}
  	\left(
  	\mathbf{g} \left( \boldsymbol{\theta} \right)
  	,
  	\mathbf{J}
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\mathbf{J}^{\prime}
  	\right) .
  </code>
</p>




<h3>Value</h3>

<p>Returns an object
of class <code>ctmeddelta</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;DeltaTotalCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>delta_t</dt><dd><p>Time interval.</p>
</dd>
<dt>jacobian</dt><dd><p>Jacobian matrix.</p>
</dd>
<dt>est</dt><dd><p>Estimated total effect centrality.</p>
</dd>
<dt>vcov</dt><dd><p>Sampling variance-covariance matrix of
estimated total effect centrality.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
DeltaTotalCentral(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaTotalCentral(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5
)
plot(delta)

# Methods -------------------------------------------------------------------
# DeltaTotalCentral has a number of methods including
# print, summary, confint, and plot
print(delta)
summary(delta)
confint(delta, level = 0.95)
plot(delta)

</code></pre>

<hr>
<h2 id='Direct'>Direct Effect of X on Y
Over a Specific Time Interval</h2><span id='topic+Direct'></span>

<h3>Description</h3>

<p>This function computes the direct effect
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Direct(phi, delta_t, from, to, med)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Direct_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="Direct_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="Direct_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="Direct_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="Direct_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The direct effect
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
relative to some mediator variables <code class="reqn">\mathbf{m}</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{Direct}_{{\Delta t}_{i, j}}
    =
    \exp
    \left(
      \Delta t
      \mathbf{D}
      \boldsymbol{\Phi}
      \mathbf{D}
    \right)_{i, j}
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\Phi}</code> denotes the drift matrix,
<code class="reqn">\mathbf{D}</code> a diagonal matrix
where the diagonal elements corresponding
to mediator variables <code class="reqn">\mathbf{m}</code>
are set to zero and the rest to one,
<code class="reqn">i</code> the row index of <code class="reqn">Y</code> in <code class="reqn">\boldsymbol{\Phi}</code>,
<code class="reqn">j</code> the column index of <code class="reqn">X</code> in <code class="reqn">\boldsymbol{\Phi}</code>, and
<code class="reqn">\Delta t</code> the time interval.
</p>


<h4>Linear Stochastic Differential Equation Model</h4>

<p>The measurement model is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathbf{y}_{i, t}
    =
    \boldsymbol{\nu}
    +
    \boldsymbol{\Lambda}
    \boldsymbol{\eta}_{i, t}
    +
    \boldsymbol{\varepsilon}_{i, t},
    \quad
    \mathrm{with}
    \quad
    \boldsymbol{\varepsilon}_{i, t}
    \sim
    \mathcal{N}
    \left(
    \mathbf{0},
    \boldsymbol{\Theta}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\mathbf{y}_{i, t}</code>,
<code class="reqn">\boldsymbol{\eta}_{i, t}</code>,
and
<code class="reqn">\boldsymbol{\varepsilon}_{i, t}</code>
are random variables
and
<code class="reqn">\boldsymbol{\nu}</code>,
<code class="reqn">\boldsymbol{\Lambda}</code>,
and
<code class="reqn">\boldsymbol{\Theta}</code>
are model parameters.
<code class="reqn">\mathbf{y}_{i, t}</code>
represents a vector of observed random variables,
<code class="reqn">\boldsymbol{\eta}_{i, t}</code>
a vector of latent random variables,
and
<code class="reqn">\boldsymbol{\varepsilon}_{i, t}</code>
a vector of random measurement errors,
at time <code class="reqn">t</code> and individual <code class="reqn">i</code>.
<code class="reqn">\boldsymbol{\nu}</code>
denotes a vector of intercepts,
<code class="reqn">\boldsymbol{\Lambda}</code>
a matrix of factor loadings,
and
<code class="reqn">\boldsymbol{\Theta}</code>
the covariance matrix of
<code class="reqn">\boldsymbol{\varepsilon}</code>.
</p>
<p>An alternative representation of the measurement error
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \boldsymbol{\varepsilon}_{i, t}
    =
    \boldsymbol{\Theta}^{\frac{1}{2}}
    \mathbf{z}_{i, t},
    \quad
    \mathrm{with}
    \quad
    \mathbf{z}_{i, t}
    \sim
    \mathcal{N}
    \left(
    \mathbf{0},
    \mathbf{I}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\mathbf{z}_{i, t}</code> is a vector of
independent standard normal random variables and
<code class="reqn">
    \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)
    \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)^{\prime}
    =
    \boldsymbol{\Theta} .
  </code>
</p>
<p>The dynamic structure is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{d} \boldsymbol{\eta}_{i, t}
    =
    \left(
    \boldsymbol{\iota}
    +
    \boldsymbol{\Phi}
    \boldsymbol{\eta}_{i, t}
    \right)
    \mathrm{d}t
    +
    \boldsymbol{\Sigma}^{\frac{1}{2}}
    \mathrm{d}
    \mathbf{W}_{i, t}
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\iota}</code>
is a term which is unobserved and constant over time,
<code class="reqn">\boldsymbol{\Phi}</code>
is the drift matrix
which represents the rate of change of the solution
in the absence of any random fluctuations,
<code class="reqn">\boldsymbol{\Sigma}</code>
is the matrix of volatility
or randomness in the process, and
<code class="reqn">\mathrm{d}\boldsymbol{W}</code>
is a Wiener process or Brownian motion,
which represents random fluctuations.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedeffect</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;Direct&quot;).</p>
</dd>
<dt>output</dt><dd><p>The direct effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
delta_t &lt;- 1
Direct(
  phi = phi,
  delta_t = delta_t,
  from = "x",
  to = "y",
  med = "m"
)
phi &lt;- matrix(
  data = c(
    -6, 5.5, 0, 0,
    1.25, -2.5, 5.9, -7.3,
    0, 0, -6, 2.5,
    5, 0, 0, -6
  ),
  nrow = 4
)
colnames(phi) &lt;- rownames(phi) &lt;- paste0("y", 1:4)
Direct(
  phi = phi,
  delta_t = delta_t,
  from = "y2",
  to = "y4",
  med = c("y1", "y3")
)

</code></pre>

<hr>
<h2 id='DirectStd'>Standardized Direct Effect of X on Y
Over a Specific Time Interval</h2><span id='topic+DirectStd'></span>

<h3>Description</h3>

<p>This function computes the standardized direct effect
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DirectStd(phi, sigma, delta_t, from, to, med)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DirectStd_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="DirectStd_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="DirectStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="DirectStd_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="DirectStd_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="DirectStd_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized direct effect
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
relative to some mediator variables <code class="reqn">\mathbf{m}</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{Direct}^{\ast}_{{\Delta t}_{i, j}}
    =
    \mathrm{Direct}_{{\Delta t}_{i, j}}
    \left(
    \frac{\sigma_{{x}_{j}}}{\sigma_{{y}_{i}}}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\Phi}</code> denotes the drift matrix,
<code class="reqn">\sigma_{{x}_{j}}</code> and <code class="reqn">\sigma_{{y}_{i}}</code>
are the steady-state model-implied standard deviations
of the state independent and dependent variables, respectively, and
<code class="reqn">\Delta t</code> the time interval.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedeffect</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;DirectStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>The standardized direct effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)
delta_t &lt;- 1
DirectStd(
  phi = phi,
  sigma = sigma,
  delta_t = delta_t,
  from = "x",
  to = "y",
  med = "m"
)

</code></pre>

<hr>
<h2 id='Indirect'>Indirect Effect of X on Y Through M
Over a Specific Time Interval</h2><span id='topic+Indirect'></span>

<h3>Description</h3>

<p>This function computes the indirect effect
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Indirect(phi, delta_t, from, to, med)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Indirect_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="Indirect_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="Indirect_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="Indirect_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="Indirect_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The indirect effect
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
relative to some mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{Indirect}_{{\Delta t}_{i, j}}
    =
    \exp
    \left(
      \Delta t
      \boldsymbol{\Phi}
    \right)_{i, j} -
    \exp
    \left(
      \Delta t
      \mathbf{D}_{\mathbf{m}}
      \boldsymbol{\Phi}
      \mathbf{D}_{\mathbf{m}}
    \right)_{i, j}
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\Phi}</code> denotes the drift matrix,
<code class="reqn">\mathbf{D}_{\mathbf{m}}</code> a matrix
where the off diagonal elements are zeros
and the diagonal elements are zero
for the index/indices of mediator variables <code class="reqn">\mathbf{m}</code>
and one otherwise,
<code class="reqn">i</code> the row index of <code class="reqn">Y</code> in <code class="reqn">\boldsymbol{\Phi}</code>,
<code class="reqn">j</code> the column index of <code class="reqn">X</code> in <code class="reqn">\boldsymbol{\Phi}</code>, and
<code class="reqn">\Delta t</code> the time interval.
</p>


<h4>Linear Stochastic Differential Equation Model</h4>

<p>The measurement model is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathbf{y}_{i, t}
    =
    \boldsymbol{\nu}
    +
    \boldsymbol{\Lambda}
    \boldsymbol{\eta}_{i, t}
    +
    \boldsymbol{\varepsilon}_{i, t},
    \quad
    \mathrm{with}
    \quad
    \boldsymbol{\varepsilon}_{i, t}
    \sim
    \mathcal{N}
    \left(
    \mathbf{0},
    \boldsymbol{\Theta}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\mathbf{y}_{i, t}</code>,
<code class="reqn">\boldsymbol{\eta}_{i, t}</code>,
and
<code class="reqn">\boldsymbol{\varepsilon}_{i, t}</code>
are random variables
and
<code class="reqn">\boldsymbol{\nu}</code>,
<code class="reqn">\boldsymbol{\Lambda}</code>,
and
<code class="reqn">\boldsymbol{\Theta}</code>
are model parameters.
<code class="reqn">\mathbf{y}_{i, t}</code>
represents a vector of observed random variables,
<code class="reqn">\boldsymbol{\eta}_{i, t}</code>
a vector of latent random variables,
and
<code class="reqn">\boldsymbol{\varepsilon}_{i, t}</code>
a vector of random measurement errors,
at time <code class="reqn">t</code> and individual <code class="reqn">i</code>.
<code class="reqn">\boldsymbol{\nu}</code>
denotes a vector of intercepts,
<code class="reqn">\boldsymbol{\Lambda}</code>
a matrix of factor loadings,
and
<code class="reqn">\boldsymbol{\Theta}</code>
the covariance matrix of
<code class="reqn">\boldsymbol{\varepsilon}</code>.
</p>
<p>An alternative representation of the measurement error
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \boldsymbol{\varepsilon}_{i, t}
    =
    \boldsymbol{\Theta}^{\frac{1}{2}}
    \mathbf{z}_{i, t},
    \quad
    \mathrm{with}
    \quad
    \mathbf{z}_{i, t}
    \sim
    \mathcal{N}
    \left(
    \mathbf{0},
    \mathbf{I}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\mathbf{z}_{i, t}</code> is a vector of
independent standard normal random variables and
<code class="reqn">
    \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)
    \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)^{\prime}
    =
    \boldsymbol{\Theta} .
  </code>
</p>
<p>The dynamic structure is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{d} \boldsymbol{\eta}_{i, t}
    =
    \left(
    \boldsymbol{\iota}
    +
    \boldsymbol{\Phi}
    \boldsymbol{\eta}_{i, t}
    \right)
    \mathrm{d}t
    +
    \boldsymbol{\Sigma}^{\frac{1}{2}}
    \mathrm{d}
    \mathbf{W}_{i, t}
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\iota}</code>
is a term which is unobserved and constant over time,
<code class="reqn">\boldsymbol{\Phi}</code>
is the drift matrix
which represents the rate of change of the solution
in the absence of any random fluctuations,
<code class="reqn">\boldsymbol{\Sigma}</code>
is the matrix of volatility
or randomness in the process, and
<code class="reqn">\mathrm{d}\boldsymbol{W}</code>
is a Wiener process or Brownian motion,
which represents random fluctuations.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedeffect</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;Indirect&quot;).</p>
</dd>
<dt>output</dt><dd><p>The indirect effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
delta_t &lt;- 1
Indirect(
  phi = phi,
  delta_t = delta_t,
  from = "x",
  to = "y",
  med = "m"
)
phi &lt;- matrix(
  data = c(
    -6, 5.5, 0, 0,
    1.25, -2.5, 5.9, -7.3,
    0, 0, -6, 2.5,
    5, 0, 0, -6
  ),
  nrow = 4
)
colnames(phi) &lt;- rownames(phi) &lt;- paste0("y", 1:4)
Indirect(
  phi = phi,
  delta_t = delta_t,
  from = "y2",
  to = "y4",
  med = c("y1", "y3")
)

</code></pre>

<hr>
<h2 id='IndirectCentral'>Indirect Effect Centrality</h2><span id='topic+IndirectCentral'></span>

<h3>Description</h3>

<p>Indirect Effect Centrality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndirectCentral(phi, delta_t, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IndirectCentral_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="IndirectCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Vector of positive numbers.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="IndirectCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indirect effect centrality
is the sum of all possible indirect effects
between different pairs of variables
in which a specific variable serves as the only mediator.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmed</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;IndirectCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A matrix of indirect effect centrality.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

# Specific time interval ----------------------------------------------------
IndirectCentral(
  phi = phi,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
indirect_central &lt;- IndirectCentral(
  phi = phi,
  delta_t = 1:30
)
plot(indirect_central)

# Methods -------------------------------------------------------------------
# IndirectCentral has a number of methods including
# print, summary, and plot
indirect_central &lt;- IndirectCentral(
  phi = phi,
  delta_t = 1:5
)
print(indirect_central)
summary(indirect_central)
plot(indirect_central)

</code></pre>

<hr>
<h2 id='IndirectStd'>Standardized Indirect Effect of X on Y Through M
Over a Specific Time Interval</h2><span id='topic+IndirectStd'></span>

<h3>Description</h3>

<p>This function computes the standardized indirect effect
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndirectStd(phi, sigma, delta_t, from, to, med)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IndirectStd_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="IndirectStd_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="IndirectStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="IndirectStd_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="IndirectStd_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="IndirectStd_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized indirect effect
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
relative to some mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{Indirect}^{\ast}_{{\Delta t}_{i, j}}
    =
    \mathrm{Total}^{\ast}_{{\Delta t}_{i, j}} -
    \mathrm{Direct}^{\ast}_{{\Delta t}_{i, j}}
  </code>
</p>

<p>where
<code class="reqn">\mathrm{Total}^{\ast}_{\Delta t}</code> and
<code class="reqn">\mathrm{Direct}^{\ast}_{\Delta t}</code>
are standardized total and direct effects
for time interval <code class="reqn">\Delta t</code>.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedeffect</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;IndirectStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>The standardized indirect effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)
delta_t &lt;- 1
IndirectStd(
  phi = phi,
  sigma = sigma,
  delta_t = delta_t,
  from = "x",
  to = "y",
  med = "m"
)

</code></pre>

<hr>
<h2 id='MCBeta'>Monte Carlo Sampling Distribution
for the Elements of the Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+MCBeta'></span>

<h3>Description</h3>

<p>This function generates a Monte Carlo method
sampling distribution
for the elements of the matrix of lagged coefficients
<code class="reqn">\boldsymbol{\beta}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCBeta(
  phi,
  vcov_phi_vec,
  delta_t,
  R,
  test_phi = TRUE,
  ncores = NULL,
  seed = NULL,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCBeta_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MCBeta_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="MCBeta_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="MCBeta_+3A_r">R</code></td>
<td>
<p>Positive integer.
Number of replications.</p>
</td></tr>
<tr><td><code id="MCBeta_+3A_test_phi">test_phi</code></td>
<td>
<p>Logical.
If <code>test_phi = TRUE</code>,
the function tests the stability
of the generated drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
If the test returns <code>FALSE</code>,
the function generates a new drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and runs the test recursively
until the test returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCBeta_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="MCBeta_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="MCBeta_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>.
</p>


<h4>Monte Carlo Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
Based on the asymptotic properties of maximum likelihood estimators,
we can assume that estimators are normally distributed
around the population parameters.
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}
  	\sim
  	\mathcal{N}
  	\left(
  	\boldsymbol{\theta},
  	\mathbb{V} \left( \hat{\boldsymbol{\theta}} \right)
  	\right)
  </code>
</p>

<p>Using this distributional assumption,
a sampling distribution of <code class="reqn">\hat{\boldsymbol{\theta}}</code>
which we refer to as <code class="reqn">\hat{\boldsymbol{\theta}}^{\ast}</code>
can be generated by replacing the population parameters
with sample estimates,
that is,
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}^{\ast}
  	\sim
  	\mathcal{N}
  	\left(
  	\hat{\boldsymbol{\theta}},
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\right) .
  </code>
</p>

<p>Let
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
be a parameter that is a function of the estimated parameters.
A sampling distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> ,
which we refer to as
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}}^{\ast} \right)</code> ,
can be generated by using the simulated estimates
to calculate
<code class="reqn">\mathbf{g}</code>.
The standard deviations of the simulated estimates
are the standard errors.
Percentiles corresponding to
<code class="reqn">100 \left( 1 - \alpha \right) \%</code>
are the confidence intervals.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MCBeta&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>Estimated elements of the matrix of lagged coefficients.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of Monte Carlo
elements of the matrix of lagged coefficients.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
MCBeta(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  R = 100L # use a large value for R in actual research
)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCBeta(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  R = 100L # use a large value for R in actual research
)
plot(mc)

# Methods -------------------------------------------------------------------
# MCBeta has a number of methods including
# print, summary, confint, and plot
print(mc)
summary(mc)
confint(mc, level = 0.95)
plot(mc)

</code></pre>

<hr>
<h2 id='MCBetaStd'>Monte Carlo Sampling Distribution
for the Elements of the Standardized Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+MCBetaStd'></span>

<h3>Description</h3>

<p>This function generates a Monte Carlo method
sampling distribution
for the elements of the standardized matrix of lagged coefficients
<code class="reqn">\boldsymbol{\beta}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCBetaStd(
  phi,
  sigma,
  vcov_theta,
  delta_t,
  R,
  test_phi = TRUE,
  ncores = NULL,
  seed = NULL,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCBetaStd_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MCBetaStd_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="MCBetaStd_+3A_vcov_theta">vcov_theta</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code></p>
</td></tr>
<tr><td><code id="MCBetaStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="MCBetaStd_+3A_r">R</code></td>
<td>
<p>Positive integer.
Number of replications.</p>
</td></tr>
<tr><td><code id="MCBetaStd_+3A_test_phi">test_phi</code></td>
<td>
<p>Logical.
If <code>test_phi = TRUE</code>,
the function tests the stability
of the generated drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
If the test returns <code>FALSE</code>,
the function generates a new drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and runs the test recursively
until the test returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCBetaStd_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="MCBetaStd_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="MCBetaStd_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalStd">TotalStd()</a></code>.
</p>


<h4>Monte Carlo Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code>,
that is,
the unique elements of the <code class="reqn">\boldsymbol{\Sigma}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \hat{\boldsymbol{\Sigma}} \right)</code>.
Based on the asymptotic properties of maximum likelihood estimators,
we can assume that estimators are normally distributed
around the population parameters.
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}
  	\sim
  	\mathcal{N}
  	\left(
  	\boldsymbol{\theta},
  	\mathbb{V} \left( \hat{\boldsymbol{\theta}} \right)
  	\right)
  </code>
</p>

<p>Using this distributional assumption,
a sampling distribution of <code class="reqn">\hat{\boldsymbol{\theta}}</code>
which we refer to as <code class="reqn">\hat{\boldsymbol{\theta}}^{\ast}</code>
can be generated by replacing the population parameters
with sample estimates,
that is,
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}^{\ast}
  	\sim
  	\mathcal{N}
  	\left(
  	\hat{\boldsymbol{\theta}},
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\right) .
  </code>
</p>

<p>Let
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
be a parameter that is a function of the estimated parameters.
A sampling distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> ,
which we refer to as
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}}^{\ast} \right)</code> ,
can be generated by using the simulated estimates
to calculate
<code class="reqn">\mathbf{g}</code>.
The standard deviations of the simulated estimates
are the standard errors.
Percentiles corresponding to
<code class="reqn">100 \left( 1 - \alpha \right) \%</code>
are the confidence intervals.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MCBetaStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>Estimated elements of the standardized matrix
of lagged coefficients.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of Monte Carlo
elements of the standardized matrix of lagged coefficients.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)
vcov_theta &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151, -0.00600, -0.00033,
    0.00110, 0.00324, 0.00020, -0.00061, -0.00115,
    0.00011, 0.00015, 0.00001, -0.00002, -0.00001,
    0.00040, 0.00374, 0.00016, -0.00022, -0.00273,
    -0.00016, 0.00009, 0.00150, 0.00012, -0.00010,
    -0.00026, 0.00002, 0.00012, 0.00004, -0.00001,
    -0.00151, 0.00016, 0.00389, 0.00103, -0.00007,
    -0.00283, -0.00050, 0.00000, 0.00156, 0.00021,
    -0.00005, -0.00031, 0.00001, 0.00007, 0.00006,
    -0.00600, -0.00022, 0.00103, 0.00644, 0.00031,
    -0.00119, -0.00374, -0.00021, 0.00070, 0.00064,
    -0.00015, -0.00005, 0.00000, 0.00003, -0.00001,
    -0.00033, -0.00273, -0.00007, 0.00031, 0.00287,
    0.00013, -0.00014, -0.00170, -0.00012, 0.00006,
    0.00014, -0.00001, -0.00015, 0.00000, 0.00001,
    0.00110, -0.00016, -0.00283, -0.00119, 0.00013,
    0.00297, 0.00063, -0.00004, -0.00177, -0.00013,
    0.00005, 0.00017, -0.00002, -0.00008, 0.00001,
    0.00324, 0.00009, -0.00050, -0.00374, -0.00014,
    0.00063, 0.00495, 0.00024, -0.00093, -0.00020,
    0.00006, -0.00010, 0.00000, -0.00001, 0.00004,
    0.00020, 0.00150, 0.00000, -0.00021, -0.00170,
    -0.00004, 0.00024, 0.00214, 0.00012, -0.00002,
    -0.00004, 0.00000, 0.00006, -0.00005, -0.00001,
    -0.00061, 0.00012, 0.00156, 0.00070, -0.00012,
    -0.00177, -0.00093, 0.00012, 0.00223, 0.00004,
    -0.00002, -0.00003, 0.00001, 0.00003, -0.00013,
    -0.00115, -0.00010, 0.00021, 0.00064, 0.00006,
    -0.00013, -0.00020, -0.00002, 0.00004, 0.00057,
    0.00001, -0.00009, 0.00000, 0.00000, 0.00001,
    0.00011, -0.00026, -0.00005, -0.00015, 0.00014,
    0.00005, 0.00006, -0.00004, -0.00002, 0.00001,
    0.00012, 0.00001, 0.00000, -0.00002, 0.00000,
    0.00015, 0.00002, -0.00031, -0.00005, -0.00001,
    0.00017, -0.00010, 0.00000, -0.00003, -0.00009,
    0.00001, 0.00014, 0.00000, 0.00000, -0.00005,
    0.00001, 0.00012, 0.00001, 0.00000, -0.00015,
    -0.00002, 0.00000, 0.00006, 0.00001, 0.00000,
    0.00000, 0.00000, 0.00010, 0.00001, 0.00000,
    -0.00002, 0.00004, 0.00007, 0.00003, 0.00000,
    -0.00008, -0.00001, -0.00005, 0.00003, 0.00000,
    -0.00002, 0.00000, 0.00001, 0.00005, 0.00001,
    -0.00001, -0.00001, 0.00006, -0.00001, 0.00001,
    0.00001, 0.00004, -0.00001, -0.00013, 0.00001,
    0.00000, -0.00005, 0.00000, 0.00001, 0.00012
  ),
  nrow = 15
)

# Specific time interval ----------------------------------------------------
MCBetaStd(
  phi = phi,
  sigma = sigma,
  vcov_theta = vcov_theta,
  delta_t = 1,
  R = 100L # use a large value for R in actual research
)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCBetaStd(
  phi = phi,
  sigma = sigma,
  vcov_theta = vcov_theta,
  delta_t = 1:5,
  R = 100L # use a large value for R in actual research
)
plot(mc)

# Methods -------------------------------------------------------------------
# MCBetaStd has a number of methods including
# print, summary, confint, and plot
print(mc)
summary(mc)
confint(mc, level = 0.95)
plot(mc)

</code></pre>

<hr>
<h2 id='MCIndirectCentral'>Monte Carlo Sampling Distribution
of Indirect Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+MCIndirectCentral'></span>

<h3>Description</h3>

<p>This function generates a Monte Carlo method
sampling distribution
of the indirect effect centrality
at a particular time interval <code class="reqn">\Delta t</code>
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCIndirectCentral(
  phi,
  vcov_phi_vec,
  delta_t,
  R,
  test_phi = TRUE,
  ncores = NULL,
  seed = NULL,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCIndirectCentral_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MCIndirectCentral_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="MCIndirectCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="MCIndirectCentral_+3A_r">R</code></td>
<td>
<p>Positive integer.
Number of replications.</p>
</td></tr>
<tr><td><code id="MCIndirectCentral_+3A_test_phi">test_phi</code></td>
<td>
<p>Logical.
If <code>test_phi = TRUE</code>,
the function tests the stability
of the generated drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
If the test returns <code>FALSE</code>,
the function generates a new drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and runs the test recursively
until the test returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCIndirectCentral_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="MCIndirectCentral_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="MCIndirectCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+IndirectCentral">IndirectCentral()</a></code> for more details.
</p>


<h4>Monte Carlo Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
Based on the asymptotic properties of maximum likelihood estimators,
we can assume that estimators are normally distributed
around the population parameters.
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}
  	\sim
  	\mathcal{N}
  	\left(
  	\boldsymbol{\theta},
  	\mathbb{V} \left( \hat{\boldsymbol{\theta}} \right)
  	\right)
  </code>
</p>

<p>Using this distributional assumption,
a sampling distribution of <code class="reqn">\hat{\boldsymbol{\theta}}</code>
which we refer to as <code class="reqn">\hat{\boldsymbol{\theta}}^{\ast}</code>
can be generated by replacing the population parameters
with sample estimates,
that is,
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}^{\ast}
  	\sim
  	\mathcal{N}
  	\left(
  	\hat{\boldsymbol{\theta}},
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\right) .
  </code>
</p>

<p>Let
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
be a parameter that is a function of the estimated parameters.
A sampling distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> ,
which we refer to as
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}}^{\ast} \right)</code> ,
can be generated by using the simulated estimates
to calculate
<code class="reqn">\mathbf{g}</code>.
The standard deviations of the simulated estimates
are the standard errors.
Percentiles corresponding to
<code class="reqn">100 \left( 1 - \alpha \right) \%</code>
are the confidence intervals.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MCIndirectCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of indirect effect centrality.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of Monte Carlo
indirect effect centrality.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
MCIndirectCentral(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  R = 100L # use a large value for R in actual research
)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCIndirectCentral(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  R = 100L # use a large value for R in actual research
)
plot(mc)

# Methods -------------------------------------------------------------------
# MCIndirectCentral has a number of methods including
# print, summary, confint, and plot
print(mc)
summary(mc)
confint(mc, level = 0.95)
plot(mc)

</code></pre>

<hr>
<h2 id='MCMed'>Monte Carlo Sampling Distribution
of Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+MCMed'></span>

<h3>Description</h3>

<p>This function generates a Monte Carlo method
sampling distribution
of the total, direct and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMed(
  phi,
  vcov_phi_vec,
  delta_t,
  from,
  to,
  med,
  R,
  test_phi = TRUE,
  ncores = NULL,
  seed = NULL,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMed_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="MCMed_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_r">R</code></td>
<td>
<p>Positive integer.
Number of replications.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_test_phi">test_phi</code></td>
<td>
<p>Logical.
If <code>test_phi = TRUE</code>,
the function tests the stability
of the generated drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
If the test returns <code>FALSE</code>,
the function generates a new drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and runs the test recursively
until the test returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="MCMed_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>,
<code><a href="#topic+Direct">Direct()</a></code>, and
<code><a href="#topic+Indirect">Indirect()</a></code> for more details.
</p>


<h4>Monte Carlo Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
Based on the asymptotic properties of maximum likelihood estimators,
we can assume that estimators are normally distributed
around the population parameters.
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}
  	\sim
  	\mathcal{N}
  	\left(
  	\boldsymbol{\theta},
  	\mathbb{V} \left( \hat{\boldsymbol{\theta}} \right)
  	\right)
  </code>
</p>

<p>Using this distributional assumption,
a sampling distribution of <code class="reqn">\hat{\boldsymbol{\theta}}</code>
which we refer to as <code class="reqn">\hat{\boldsymbol{\theta}}^{\ast}</code>
can be generated by replacing the population parameters
with sample estimates,
that is,
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}^{\ast}
  	\sim
  	\mathcal{N}
  	\left(
  	\hat{\boldsymbol{\theta}},
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\right) .
  </code>
</p>

<p>Let
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
be a parameter that is a function of the estimated parameters.
A sampling distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> ,
which we refer to as
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}}^{\ast} \right)</code> ,
can be generated by using the simulated estimates
to calculate
<code class="reqn">\mathbf{g}</code>.
The standard deviations of the simulated estimates
are the standard errors.
Percentiles corresponding to
<code class="reqn">100 \left( 1 - \alpha \right) \%</code>
are the confidence intervals.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MCMed&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list with length of <code>length(delta_t)</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of total, direct, and indirect effects.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of Monte Carlo
total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
plot(mc)

# Methods -------------------------------------------------------------------
# MCMed has a number of methods including
# print, summary, confint, and plot
print(mc)
summary(mc)
confint(mc, level = 0.95)

</code></pre>

<hr>
<h2 id='MCMedStd'>Monte Carlo Sampling Distribution
of Standardized Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+MCMedStd'></span>

<h3>Description</h3>

<p>This function generates a Monte Carlo method
sampling distribution
of the standardized total, direct and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMedStd(
  phi,
  sigma,
  vcov_theta,
  delta_t,
  from,
  to,
  med,
  R,
  test_phi = TRUE,
  ncores = NULL,
  seed = NULL,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMedStd_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_vcov_theta">vcov_theta</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code></p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_r">R</code></td>
<td>
<p>Positive integer.
Number of replications.</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_test_phi">test_phi</code></td>
<td>
<p>Logical.
If <code>test_phi = TRUE</code>,
the function tests the stability
of the generated drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
If the test returns <code>FALSE</code>,
the function generates a new drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and runs the test recursively
until the test returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="MCMedStd_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalStd">TotalStd()</a></code>,
<code><a href="#topic+DirectStd">DirectStd()</a></code>, and
<code><a href="#topic+IndirectStd">IndirectStd()</a></code> for more details.
</p>


<h4>Monte Carlo Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code>,
that is,
the unique elements of the <code class="reqn">\boldsymbol{\Sigma}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \hat{\boldsymbol{\Sigma}} \right)</code>.
Based on the asymptotic properties of maximum likelihood estimators,
we can assume that estimators are normally distributed
around the population parameters.
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}
  	\sim
  	\mathcal{N}
  	\left(
  	\boldsymbol{\theta},
  	\mathbb{V} \left( \hat{\boldsymbol{\theta}} \right)
  	\right)
  </code>
</p>

<p>Using this distributional assumption,
a sampling distribution of <code class="reqn">\hat{\boldsymbol{\theta}}</code>
which we refer to as <code class="reqn">\hat{\boldsymbol{\theta}}^{\ast}</code>
can be generated by replacing the population parameters
with sample estimates,
that is,
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}^{\ast}
  	\sim
  	\mathcal{N}
  	\left(
  	\hat{\boldsymbol{\theta}},
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\right) .
  </code>
</p>

<p>Let
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
be a parameter that is a function of the estimated parameters.
A sampling distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> ,
which we refer to as
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}}^{\ast} \right)</code> ,
can be generated by using the simulated estimates
to calculate
<code class="reqn">\mathbf{g}</code>.
The standard deviations of the simulated estimates
are the standard errors.
Percentiles corresponding to
<code class="reqn">100 \left( 1 - \alpha \right) \%</code>
are the confidence intervals.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MCMedStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list with length of <code>length(delta_t)</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of standardized total, direct, and indirect effects.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of Monte Carlo
standardized total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)
vcov_theta &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151, -0.00600, -0.00033,
    0.00110, 0.00324, 0.00020, -0.00061, -0.00115,
    0.00011, 0.00015, 0.00001, -0.00002, -0.00001,
    0.00040, 0.00374, 0.00016, -0.00022, -0.00273,
    -0.00016, 0.00009, 0.00150, 0.00012, -0.00010,
    -0.00026, 0.00002, 0.00012, 0.00004, -0.00001,
    -0.00151, 0.00016, 0.00389, 0.00103, -0.00007,
    -0.00283, -0.00050, 0.00000, 0.00156, 0.00021,
    -0.00005, -0.00031, 0.00001, 0.00007, 0.00006,
    -0.00600, -0.00022, 0.00103, 0.00644, 0.00031,
    -0.00119, -0.00374, -0.00021, 0.00070, 0.00064,
    -0.00015, -0.00005, 0.00000, 0.00003, -0.00001,
    -0.00033, -0.00273, -0.00007, 0.00031, 0.00287,
    0.00013, -0.00014, -0.00170, -0.00012, 0.00006,
    0.00014, -0.00001, -0.00015, 0.00000, 0.00001,
    0.00110, -0.00016, -0.00283, -0.00119, 0.00013,
    0.00297, 0.00063, -0.00004, -0.00177, -0.00013,
    0.00005, 0.00017, -0.00002, -0.00008, 0.00001,
    0.00324, 0.00009, -0.00050, -0.00374, -0.00014,
    0.00063, 0.00495, 0.00024, -0.00093, -0.00020,
    0.00006, -0.00010, 0.00000, -0.00001, 0.00004,
    0.00020, 0.00150, 0.00000, -0.00021, -0.00170,
    -0.00004, 0.00024, 0.00214, 0.00012, -0.00002,
    -0.00004, 0.00000, 0.00006, -0.00005, -0.00001,
    -0.00061, 0.00012, 0.00156, 0.00070, -0.00012,
    -0.00177, -0.00093, 0.00012, 0.00223, 0.00004,
    -0.00002, -0.00003, 0.00001, 0.00003, -0.00013,
    -0.00115, -0.00010, 0.00021, 0.00064, 0.00006,
    -0.00013, -0.00020, -0.00002, 0.00004, 0.00057,
    0.00001, -0.00009, 0.00000, 0.00000, 0.00001,
    0.00011, -0.00026, -0.00005, -0.00015, 0.00014,
    0.00005, 0.00006, -0.00004, -0.00002, 0.00001,
    0.00012, 0.00001, 0.00000, -0.00002, 0.00000,
    0.00015, 0.00002, -0.00031, -0.00005, -0.00001,
    0.00017, -0.00010, 0.00000, -0.00003, -0.00009,
    0.00001, 0.00014, 0.00000, 0.00000, -0.00005,
    0.00001, 0.00012, 0.00001, 0.00000, -0.00015,
    -0.00002, 0.00000, 0.00006, 0.00001, 0.00000,
    0.00000, 0.00000, 0.00010, 0.00001, 0.00000,
    -0.00002, 0.00004, 0.00007, 0.00003, 0.00000,
    -0.00008, -0.00001, -0.00005, 0.00003, 0.00000,
    -0.00002, 0.00000, 0.00001, 0.00005, 0.00001,
    -0.00001, -0.00001, 0.00006, -0.00001, 0.00001,
    0.00001, 0.00004, -0.00001, -0.00013, 0.00001,
    0.00000, -0.00005, 0.00000, 0.00001, 0.00012
  ),
  nrow = 15
)

# Specific time interval ----------------------------------------------------
MCMedStd(
  phi = phi,
  sigma = sigma,
  vcov_theta = vcov_theta,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCMedStd(
  phi = phi,
  sigma = sigma,
  vcov_theta = vcov_theta,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
plot(mc)

# Methods -------------------------------------------------------------------
# MCMedStd has a number of methods including
# print, summary, confint, and plot
print(mc)
summary(mc)
confint(mc, level = 0.95)

</code></pre>

<hr>
<h2 id='MCPhi'>Generate Random Drift Matrices
Using the Monte Carlo Method</h2><span id='topic+MCPhi'></span>

<h3>Description</h3>

<p>This function generates random
drift matrices <code class="reqn">\boldsymbol{\Phi}</code>
using the Monte Carlo method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCPhi(phi, vcov_phi_vec, R, test_phi = TRUE, ncores = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCPhi_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MCPhi_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="MCPhi_+3A_r">R</code></td>
<td>
<p>Positive integer.
Number of replications.</p>
</td></tr>
<tr><td><code id="MCPhi_+3A_test_phi">test_phi</code></td>
<td>
<p>Logical.
If <code>test_phi = TRUE</code>,
the function tests the stability
of the generated drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
If the test returns <code>FALSE</code>,
the function generates a new drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and runs the test recursively
until the test returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCPhi_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="MCPhi_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Monte Carlo Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
Based on the asymptotic properties of maximum likelihood estimators,
we can assume that estimators are normally distributed
around the population parameters.
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}
  	\sim
  	\mathcal{N}
  	\left(
  	\boldsymbol{\theta},
  	\mathbb{V} \left( \hat{\boldsymbol{\theta}} \right)
  	\right)
  </code>
</p>

<p>Using this distributional assumption,
a sampling distribution of <code class="reqn">\hat{\boldsymbol{\theta}}</code>
which we refer to as <code class="reqn">\hat{\boldsymbol{\theta}}^{\ast}</code>
can be generated by replacing the population parameters
with sample estimates,
that is,
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}^{\ast}
  	\sim
  	\mathcal{N}
  	\left(
  	\hat{\boldsymbol{\theta}},
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\right) .
  </code>
</p>




<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MCPhi&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list simulated drift matrices.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
MCPhi(
  phi = phi,
  vcov_phi_vec = 0.1 * diag(9),
  R = 100L # use a large value for R in actual research
)
phi &lt;- matrix(
  data = c(
    -6, 5.5, 0, 0,
    1.25, -2.5, 5.9, -7.3,
    0, 0, -6, 2.5,
    5, 0, 0, -6
  ),
  nrow = 4
)
colnames(phi) &lt;- rownames(phi) &lt;- paste0("y", 1:4)
MCPhi(
  phi = phi,
  vcov_phi_vec = 0.1 * diag(16),
  R = 100L, # use a large value for R in actual research
  test_phi = FALSE
)

</code></pre>

<hr>
<h2 id='MCPhiSigma'>Generate Random Drift Matrices
and Process Noise Covariance Matrices
Using the Monte Carlo Method</h2><span id='topic+MCPhiSigma'></span>

<h3>Description</h3>

<p>This function generates random
drift matrices <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariabces matrices <code class="reqn">\boldsymbol{\Sigma}</code>
using the Monte Carlo method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCPhiSigma(
  phi,
  sigma,
  vcov_theta,
  R,
  test_phi = TRUE,
  ncores = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCPhiSigma_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MCPhiSigma_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="MCPhiSigma_+3A_vcov_theta">vcov_theta</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code></p>
</td></tr>
<tr><td><code id="MCPhiSigma_+3A_r">R</code></td>
<td>
<p>Positive integer.
Number of replications.</p>
</td></tr>
<tr><td><code id="MCPhiSigma_+3A_test_phi">test_phi</code></td>
<td>
<p>Logical.
If <code>test_phi = TRUE</code>,
the function tests the stability
of the generated drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
If the test returns <code>FALSE</code>,
the function generates a new drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and runs the test recursively
until the test returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCPhiSigma_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="MCPhiSigma_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Monte Carlo Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise and
<code class="reqn">\mathrm{vech} \left( \boldsymbol{\Sigma} \right)</code>,
that is,
the unique elements of the <code class="reqn">\boldsymbol{\Sigma}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
a vector that combines
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code> and
<code class="reqn">\mathrm{vech} \left( \hat{\boldsymbol{\Sigma}} \right)</code>.
Based on the asymptotic properties of maximum likelihood estimators,
we can assume that estimators are normally distributed
around the population parameters.
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}
  	\sim
  	\mathcal{N}
  	\left(
  	\boldsymbol{\theta},
  	\mathbb{V} \left( \hat{\boldsymbol{\theta}} \right)
  	\right)
  </code>
</p>

<p>Using this distributional assumption,
a sampling distribution of <code class="reqn">\hat{\boldsymbol{\theta}}</code>
which we refer to as <code class="reqn">\hat{\boldsymbol{\theta}}^{\ast}</code>
can be generated by replacing the population parameters
with sample estimates,
that is,
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}^{\ast}
  	\sim
  	\mathcal{N}
  	\left(
  	\hat{\boldsymbol{\theta}},
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\right) .
  </code>
</p>




<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MCPhiSigma&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list simulated drift matrices.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)
MCPhiSigma(
  phi = phi,
  sigma = sigma,
  vcov_theta = 0.1 * diag(15),
  R = 100L # use a large value for R in actual research
)

</code></pre>

<hr>
<h2 id='MCTotalCentral'>Monte Carlo Sampling Distribution
of Total Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+MCTotalCentral'></span>

<h3>Description</h3>

<p>This function generates a Monte Carlo method
sampling distribution
of the total effect centrality
at a particular time interval <code class="reqn">\Delta t</code>
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCTotalCentral(
  phi,
  vcov_phi_vec,
  delta_t,
  R,
  test_phi = TRUE,
  ncores = NULL,
  seed = NULL,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCTotalCentral_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MCTotalCentral_+3A_vcov_phi_vec">vcov_phi_vec</code></td>
<td>
<p>Numeric matrix.
The sampling variance-covariance matrix of
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>.</p>
</td></tr>
<tr><td><code id="MCTotalCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="MCTotalCentral_+3A_r">R</code></td>
<td>
<p>Positive integer.
Number of replications.</p>
</td></tr>
<tr><td><code id="MCTotalCentral_+3A_test_phi">test_phi</code></td>
<td>
<p>Logical.
If <code>test_phi = TRUE</code>,
the function tests the stability
of the generated drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
If the test returns <code>FALSE</code>,
the function generates a new drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and runs the test recursively
until the test returns <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="MCTotalCentral_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="MCTotalCentral_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
<tr><td><code id="MCTotalCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalCentral">TotalCentral()</a></code> for more details.
</p>


<h4>Monte Carlo Method</h4>

<p>Let <code class="reqn">\boldsymbol{\theta}</code> be
<code class="reqn">\mathrm{vec} \left( \boldsymbol{\Phi} \right)</code>,
that is,
the elements of the <code class="reqn">\boldsymbol{\Phi}</code> matrix
in vector form sorted column-wise.
Let <code class="reqn">\hat{\boldsymbol{\theta}}</code> be
<code class="reqn">\mathrm{vec} \left( \hat{\boldsymbol{\Phi}} \right)</code>.
Based on the asymptotic properties of maximum likelihood estimators,
we can assume that estimators are normally distributed
around the population parameters.
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}
  	\sim
  	\mathcal{N}
  	\left(
  	\boldsymbol{\theta},
  	\mathbb{V} \left( \hat{\boldsymbol{\theta}} \right)
  	\right)
  </code>
</p>

<p>Using this distributional assumption,
a sampling distribution of <code class="reqn">\hat{\boldsymbol{\theta}}</code>
which we refer to as <code class="reqn">\hat{\boldsymbol{\theta}}^{\ast}</code>
can be generated by replacing the population parameters
with sample estimates,
that is,
</p>
<p style="text-align: center;"><code class="reqn">
  	\hat{\boldsymbol{\theta}}^{\ast}
  	\sim
  	\mathcal{N}
  	\left(
  	\hat{\boldsymbol{\theta}},
  	\hat{\mathbb{V}} \left( \hat{\boldsymbol{\theta}} \right)
  	\right) .
  </code>
</p>

<p>Let
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code>
be a parameter that is a function of the estimated parameters.
A sampling distribution of
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}} \right)</code> ,
which we refer to as
<code class="reqn">\mathbf{g} \left( \hat{\boldsymbol{\theta}}^{\ast} \right)</code> ,
can be generated by using the simulated estimates
to calculate
<code class="reqn">\mathbf{g}</code>.
The standard deviations of the simulated estimates
are the standard errors.
Percentiles corresponding to
<code class="reqn">100 \left( 1 - \alpha \right) \%</code>
are the confidence intervals.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MCTotalCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of total effect centrality.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of Monte Carlo
total effect centrality.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
MCTotalCentral(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  R = 100L # use a large value for R in actual research
)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCTotalCentral(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  R = 100L # use a large value for R in actual research
)
plot(mc)

# Methods -------------------------------------------------------------------
# MCTotalCentral has a number of methods including
# print, summary, confint, and plot
print(mc)
summary(mc)
confint(mc, level = 0.95)
plot(mc)

</code></pre>

<hr>
<h2 id='Med'>Total, Direct, and Indirect Effects of X on Y
Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+Med'></span>

<h3>Description</h3>

<p>This function computes the total, direct, and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Med(phi, delta_t, from, to, med, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Med_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="Med_+3A_delta_t">delta_t</code></td>
<td>
<p>Vector of positive numbers.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="Med_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="Med_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="Med_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="Med_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>,
<code><a href="#topic+Direct">Direct()</a></code>, and
<code><a href="#topic+Indirect">Indirect()</a></code> for more details.
</p>


<h4>Linear Stochastic Differential Equation Model</h4>

<p>The measurement model is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathbf{y}_{i, t}
    =
    \boldsymbol{\nu}
    +
    \boldsymbol{\Lambda}
    \boldsymbol{\eta}_{i, t}
    +
    \boldsymbol{\varepsilon}_{i, t},
    \quad
    \mathrm{with}
    \quad
    \boldsymbol{\varepsilon}_{i, t}
    \sim
    \mathcal{N}
    \left(
    \mathbf{0},
    \boldsymbol{\Theta}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\mathbf{y}_{i, t}</code>,
<code class="reqn">\boldsymbol{\eta}_{i, t}</code>,
and
<code class="reqn">\boldsymbol{\varepsilon}_{i, t}</code>
are random variables
and
<code class="reqn">\boldsymbol{\nu}</code>,
<code class="reqn">\boldsymbol{\Lambda}</code>,
and
<code class="reqn">\boldsymbol{\Theta}</code>
are model parameters.
<code class="reqn">\mathbf{y}_{i, t}</code>
represents a vector of observed random variables,
<code class="reqn">\boldsymbol{\eta}_{i, t}</code>
a vector of latent random variables,
and
<code class="reqn">\boldsymbol{\varepsilon}_{i, t}</code>
a vector of random measurement errors,
at time <code class="reqn">t</code> and individual <code class="reqn">i</code>.
<code class="reqn">\boldsymbol{\nu}</code>
denotes a vector of intercepts,
<code class="reqn">\boldsymbol{\Lambda}</code>
a matrix of factor loadings,
and
<code class="reqn">\boldsymbol{\Theta}</code>
the covariance matrix of
<code class="reqn">\boldsymbol{\varepsilon}</code>.
</p>
<p>An alternative representation of the measurement error
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \boldsymbol{\varepsilon}_{i, t}
    =
    \boldsymbol{\Theta}^{\frac{1}{2}}
    \mathbf{z}_{i, t},
    \quad
    \mathrm{with}
    \quad
    \mathbf{z}_{i, t}
    \sim
    \mathcal{N}
    \left(
    \mathbf{0},
    \mathbf{I}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\mathbf{z}_{i, t}</code> is a vector of
independent standard normal random variables and
<code class="reqn">
    \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)
    \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)^{\prime}
    =
    \boldsymbol{\Theta} .
  </code>
</p>
<p>The dynamic structure is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{d} \boldsymbol{\eta}_{i, t}
    =
    \left(
    \boldsymbol{\iota}
    +
    \boldsymbol{\Phi}
    \boldsymbol{\eta}_{i, t}
    \right)
    \mathrm{d}t
    +
    \boldsymbol{\Sigma}^{\frac{1}{2}}
    \mathrm{d}
    \mathbf{W}_{i, t}
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\iota}</code>
is a term which is unobserved and constant over time,
<code class="reqn">\boldsymbol{\Phi}</code>
is the drift matrix
which represents the rate of change of the solution
in the absence of any random fluctuations,
<code class="reqn">\boldsymbol{\Sigma}</code>
is the matrix of volatility
or randomness in the process, and
<code class="reqn">\mathrm{d}\boldsymbol{W}</code>
is a Wiener process or Brownian motion,
which represents random fluctuations.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmed</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;Med&quot;).</p>
</dd>
<dt>output</dt><dd><p>A matrix of total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

# Specific time interval ----------------------------------------------------
Med(
  phi = phi,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)

# Range of time intervals ---------------------------------------------------
med &lt;- Med(
  phi = phi,
  delta_t = 1:30,
  from = "x",
  to = "y",
  med = "m"
)
plot(med)

# Methods -------------------------------------------------------------------
# Med has a number of methods including
# print, summary, and plot
med &lt;- Med(
  phi = phi,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
print(med)
summary(med)
plot(med)

</code></pre>

<hr>
<h2 id='MedStd'>Standardized Total, Direct, and Indirect Effects of X on Y
Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+MedStd'></span>

<h3>Description</h3>

<p>This function computes the standardized total, direct, and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MedStd(phi, sigma, delta_t, from, to, med, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MedStd_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="MedStd_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="MedStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="MedStd_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MedStd_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MedStd_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="MedStd_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalStd">TotalStd()</a></code>,
<code><a href="#topic+DirectStd">DirectStd()</a></code>, and
<code><a href="#topic+IndirectStd">IndirectStd()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmed</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;MedStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>A standardized matrix of
total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)

# Specific time interval ----------------------------------------------------
MedStd(
  phi = phi,
  sigma = sigma,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)

# Range of time intervals ---------------------------------------------------
med &lt;- MedStd(
  phi = phi,
  sigma = sigma,
  delta_t = 1:30,
  from = "x",
  to = "y",
  med = "m"
)
plot(med)

# Methods -------------------------------------------------------------------
# MedStd has a number of methods including
# print, summary, and plot
med &lt;- MedStd(
  phi = phi,
  sigma = sigma,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
print(med)
summary(med)
plot(med)

</code></pre>

<hr>
<h2 id='plot.ctmedboot'>Plot Method for an Object of Class <code>ctmedboot</code></h2><span id='topic+plot.ctmedboot'></span>

<h3>Description</h3>

<p>Plot Method for an Object of Class <code>ctmedboot</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedboot'
plot(x, alpha = 0.05, col = NULL, type = "pc", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ctmedboot_+3A_x">x</code></td>
<td>
<p>Object of class <code>ctmedboot</code>.</p>
</td></tr>
<tr><td><code id="plot.ctmedboot_+3A_alpha">alpha</code></td>
<td>
<p>Numeric.
Significance level</p>
</td></tr>
<tr><td><code id="plot.ctmedboot_+3A_col">col</code></td>
<td>
<p>Character vector.
Optional argument.
Character vector of colors.</p>
</td></tr>
<tr><td><code id="plot.ctmedboot_+3A_type">type</code></td>
<td>
<p>Charater string.
Confidence interval type, that is,
<code>type = "pc"</code> for percentile;
<code>type = "bc"</code> for bias corrected.</p>
</td></tr>
<tr><td><code id="plot.ctmedboot_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays plots of point estimates and confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 1000L,
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = parallel::detectCores() - 1,
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
phi &lt;- extract(object = boot, what = "phi")

# Range of time intervals ---------------------------------------------------
boot &lt;- BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
confint(boot)
confint(boot, type = "bc") # bias-corrected

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.ctmeddelta'>Plot Method for an Object of Class <code>ctmeddelta</code></h2><span id='topic+plot.ctmeddelta'></span>

<h3>Description</h3>

<p>Plot Method for an Object of Class <code>ctmeddelta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmeddelta'
plot(x, alpha = 0.05, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ctmeddelta_+3A_x">x</code></td>
<td>
<p>Object of class <code>ctmeddelta</code>.</p>
</td></tr>
<tr><td><code id="plot.ctmeddelta_+3A_alpha">alpha</code></td>
<td>
<p>Numeric.
Significance level</p>
</td></tr>
<tr><td><code id="plot.ctmeddelta_+3A_col">col</code></td>
<td>
<p>Character vector.
Optional argument.
Character vector of colors.</p>
</td></tr>
<tr><td><code id="plot.ctmeddelta_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays plots of point estimates and confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
plot(delta)

</code></pre>

<hr>
<h2 id='plot.ctmedmc'>Plot Method for an Object of Class <code>ctmedmc</code></h2><span id='topic+plot.ctmedmc'></span>

<h3>Description</h3>

<p>Plot Method for an Object of Class <code>ctmedmc</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedmc'
plot(x, alpha = 0.05, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ctmedmc_+3A_x">x</code></td>
<td>
<p>Object of class <code>ctmedmc</code>.</p>
</td></tr>
<tr><td><code id="plot.ctmedmc_+3A_alpha">alpha</code></td>
<td>
<p>Numeric.
Significance level</p>
</td></tr>
<tr><td><code id="plot.ctmedmc_+3A_col">col</code></td>
<td>
<p>Character vector.
Optional argument.
Character vector of colors.</p>
</td></tr>
<tr><td><code id="plot.ctmedmc_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays plots of point estimates and confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
plot(mc)

</code></pre>

<hr>
<h2 id='plot.ctmedmed'>Plot Method for an Object of Class <code>ctmedmed</code></h2><span id='topic+plot.ctmedmed'></span>

<h3>Description</h3>

<p>Plot Method for an Object of Class <code>ctmedmed</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedmed'
plot(x, col = NULL, legend_pos = "topright", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ctmedmed_+3A_x">x</code></td>
<td>
<p>Object of class <code>ctmedmed</code>.</p>
</td></tr>
<tr><td><code id="plot.ctmedmed_+3A_col">col</code></td>
<td>
<p>Character vector.
Optional argument.
Character vector of colors.</p>
</td></tr>
<tr><td><code id="plot.ctmedmed_+3A_legend_pos">legend_pos</code></td>
<td>
<p>Character vector.
Optional argument.
Legend position.</p>
</td></tr>
<tr><td><code id="plot.ctmedmed_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays plots of point estimates and confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

# Range of time intervals ---------------------------------------------------
med &lt;- Med(
  phi = phi,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
plot(med)

</code></pre>

<hr>
<h2 id='plot.ctmedtraj'>Plot Method for an Object of Class <code>ctmedtraj</code></h2><span id='topic+plot.ctmedtraj'></span>

<h3>Description</h3>

<p>Plot Method for an Object of Class <code>ctmedtraj</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedtraj'
plot(x, legend_pos = "topright", total = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ctmedtraj_+3A_x">x</code></td>
<td>
<p>Object of class <code>ctmedtraj</code>.</p>
</td></tr>
<tr><td><code id="plot.ctmedtraj_+3A_legend_pos">legend_pos</code></td>
<td>
<p>Character vector.
Optional argument.
Legend position.</p>
</td></tr>
<tr><td><code id="plot.ctmedtraj_+3A_total">total</code></td>
<td>
<p>Logical.
If <code>total = TRUE</code>, include the total effect trajectory.
If <code>total = FALSE</code>, exclude the total effect trajectory.</p>
</td></tr>
<tr><td><code id="plot.ctmedtraj_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays trajectory plots of the effects.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

traj &lt;- Trajectory(
  mu0 = c(3, 3, -3),
  time = 150,
  phi = phi,
  med = "m"
)

plot(traj)

</code></pre>

<hr>
<h2 id='PosteriorBeta'>Posterior Sampling Distribution
for the Elements of the Matrix of Lagged Coefficients
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+PosteriorBeta'></span>

<h3>Description</h3>

<p>This function generates a posterior
sampling distribution
for the elements of the matrix of lagged coefficients
<code class="reqn">\boldsymbol{\beta}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PosteriorBeta(phi, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PosteriorBeta_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="PosteriorBeta_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="PosteriorBeta_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="PosteriorBeta_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;PosteriorBeta&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>A vector of total, direct, and indirect effects.</p>
</dd>
<dt>thetahatstar</dt><dd><p>A matrix of Monte Carlo
total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

phi &lt;- MCPhi(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  R = 1000L
)$output

# Specific time interval ----------------------------------------------------
PosteriorBeta(
  phi = phi,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
posterior &lt;- PosteriorBeta(
  phi = phi,
  delta_t = 1:5
)
plot(posterior)

# Methods -------------------------------------------------------------------
# PosteriorBeta has a number of methods including
# print, summary, confint, and plot
print(posterior)
summary(posterior)
confint(posterior, level = 0.95)
plot(posterior)

</code></pre>

<hr>
<h2 id='PosteriorIndirectCentral'>Posterior Distribution
of the Indirect Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+PosteriorIndirectCentral'></span>

<h3>Description</h3>

<p>This function generates a posterior
distribution
of the indirect effect centrality
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the posterior distribution
of the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PosteriorIndirectCentral(phi, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PosteriorIndirectCentral_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a sample
from the posterior distribution
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
Each matrix should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="PosteriorIndirectCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="PosteriorIndirectCentral_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="PosteriorIndirectCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalCentral">TotalCentral()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;PosteriorIndirectCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>Mean of the posterior distribution
of the total, direct, and indirect effects.</p>
</dd>
<dt>thetahatstar</dt><dd><p>Posterior distribution of the
total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

phi &lt;- MCPhi(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  R = 1000L
)$output

# Specific time interval ----------------------------------------------------
PosteriorIndirectCentral(
  phi = phi,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
posterior &lt;- PosteriorIndirectCentral(
  phi = phi,
  delta_t = 1:5
)

# Methods -------------------------------------------------------------------
# PosteriorIndirectCentral has a number of methods including
# print, summary, confint, and plot
print(posterior)
summary(posterior)
confint(posterior, level = 0.95)
plot(posterior)

</code></pre>

<hr>
<h2 id='PosteriorMed'>Posterior Distribution
of Total, Direct, and Indirect Effects
of X on Y Through M
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+PosteriorMed'></span>

<h3>Description</h3>

<p>This function generates a posterior
distribution
of the total, direct and indirect effects
of the independent variable <code class="reqn">X</code>
on the dependent variable <code class="reqn">Y</code>
through mediator variables <code class="reqn">\mathbf{m}</code>
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the posterior distribution
of the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PosteriorMed(phi, delta_t, from, to, med, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PosteriorMed_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a sample
from the posterior distribution
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
Each matrix should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="PosteriorMed_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="PosteriorMed_+3A_from">from</code></td>
<td>
<p>Character string.
Name of the independent variable <code class="reqn">X</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="PosteriorMed_+3A_to">to</code></td>
<td>
<p>Character string.
Name of the dependent variable <code class="reqn">Y</code> in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="PosteriorMed_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
<tr><td><code id="PosteriorMed_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="PosteriorMed_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Total">Total()</a></code>,
<code><a href="#topic+Direct">Direct()</a></code>, and
<code><a href="#topic+Indirect">Indirect()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;PosteriorMed&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>Mean of the posterior distribution
of the total, direct, and indirect effects.</p>
</dd>
<dt>thetahatstar</dt><dd><p>Posterior distribution of the
total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

phi &lt;- MCPhi(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  R = 1000L
)$output

# Specific time interval ----------------------------------------------------
PosteriorMed(
  phi = phi,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)

# Range of time intervals ---------------------------------------------------
posterior &lt;- PosteriorMed(
  phi = phi,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)

# Methods -------------------------------------------------------------------
# PosteriorMed has a number of methods including
# print, summary, confint, and plot
print(posterior)
summary(posterior)
confint(posterior, level = 0.95)
plot(posterior)

</code></pre>

<hr>
<h2 id='PosteriorTotalCentral'>Posterior Distribution
of the Total Effect Centrality
Over a Specific Time Interval
or a Range of Time Intervals</h2><span id='topic+PosteriorTotalCentral'></span>

<h3>Description</h3>

<p>This function generates a posterior
distribution
of the total effect centrality
over a specific time interval <code class="reqn">\Delta t</code>
or a range of time intervals
using the posterior distribution
of the first-order stochastic differential equation model
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PosteriorTotalCentral(phi, delta_t, ncores = NULL, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PosteriorTotalCentral_+3A_phi">phi</code></td>
<td>
<p>List of numeric matrices.
Each element of the list is a sample
from the posterior distribution
of the drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
Each matrix should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="PosteriorTotalCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="PosteriorTotalCentral_+3A_ncores">ncores</code></td>
<td>
<p>Positive integer.
Number of cores to use.
If <code>ncores = NULL</code>,
use a single core.
Consider using multiple cores
when number of replications <code>R</code>
is a large value.</p>
</td></tr>
<tr><td><code id="PosteriorTotalCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+TotalCentral">TotalCentral()</a></code> for more details.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmc</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;PosteriorTotalCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A list the length of which is equal to
the length of <code>delta_t</code>.</p>
</dd>
</dl>

<p>Each element in the <code>output</code> list has the following elements:
</p>

<dl>
<dt>est</dt><dd><p>Mean of the posterior distribution
of the total, direct, and indirect effects.</p>
</dd>
<dt>thetahatstar</dt><dd><p>Posterior distribution of the
total, direct, and indirect effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

phi &lt;- MCPhi(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  R = 1000L
)$output

# Specific time interval ----------------------------------------------------
PosteriorTotalCentral(
  phi = phi,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
posterior &lt;- PosteriorTotalCentral(
  phi = phi,
  delta_t = 1:5
)

# Methods -------------------------------------------------------------------
# PosteriorTotalCentral has a number of methods including
# print, summary, confint, and plot
print(posterior)
summary(posterior)
confint(posterior, level = 0.95)
plot(posterior)

</code></pre>

<hr>
<h2 id='print.ctmedboot'>Print Method for Object of Class <code>ctmedboot</code></h2><span id='topic+print.ctmedboot'></span>

<h3>Description</h3>

<p>Print Method for Object of Class <code>ctmedboot</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedboot'
print(x, alpha = 0.05, digits = 4, type = "pc", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ctmedboot_+3A_x">x</code></td>
<td>
<p>an object of class <code>ctmedboot</code>.</p>
</td></tr>
<tr><td><code id="print.ctmedboot_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector.
Significance level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="print.ctmedboot_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to display.</p>
</td></tr>
<tr><td><code id="print.ctmedboot_+3A_type">type</code></td>
<td>
<p>Charater string.
Confidence interval type, that is,
<code>type = "pc"</code> for percentile;
<code>type = "bc"</code> for bias corrected.</p>
</td></tr>
<tr><td><code id="print.ctmedboot_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a list of matrices of
time intervals,
estimates,
standard errors,
number of bootstrap replications,
and
confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 1000L,
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = parallel::detectCores() - 1,
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
phi &lt;- extract(object = boot, what = "phi")

# Specific time interval ----------------------------------------------------
boot &lt;- BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)
print(boot)
print(boot, type = "bc") # bias-corrected

# Range of time intervals ---------------------------------------------------
boot &lt;- BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
print(boot)
print(boot, type = "bc") # bias-corrected

## End(Not run)

</code></pre>

<hr>
<h2 id='print.ctmeddelta'>Print Method for Object of Class <code>ctmeddelta</code></h2><span id='topic+print.ctmeddelta'></span>

<h3>Description</h3>

<p>Print Method for Object of Class <code>ctmeddelta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmeddelta'
print(x, alpha = 0.05, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ctmeddelta_+3A_x">x</code></td>
<td>
<p>an object of class <code>ctmeddelta</code>.</p>
</td></tr>
<tr><td><code id="print.ctmeddelta_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector.
Significance level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="print.ctmeddelta_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to display.</p>
</td></tr>
<tr><td><code id="print.ctmeddelta_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a list of matrices of
time intervals,
estimates,
standard errors,
test statistics,
p-values,
and
confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
delta &lt;- DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)
print(delta)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
print(delta)

</code></pre>

<hr>
<h2 id='print.ctmedeffect'>Print Method for Object of Class <code>ctmedeffect</code></h2><span id='topic+print.ctmedeffect'></span>

<h3>Description</h3>

<p>Print Method for Object of Class <code>ctmedeffect</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedeffect'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ctmedeffect_+3A_x">x</code></td>
<td>
<p>an object of class <code>ctmedeffect</code>.</p>
</td></tr>
<tr><td><code id="print.ctmedeffect_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to display.</p>
</td></tr>
<tr><td><code id="print.ctmedeffect_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the effects.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
delta_t &lt;- 1

# Time Interval of One -----------------------------------------------------

## Total Effect ------------------------------------------------------------
total_dt &lt;- Total(
  phi = phi,
  delta_t = delta_t
)
print(total_dt)

## Direct Effect -----------------------------------------------------------
direct_dt &lt;- Direct(
  phi = phi,
  delta_t = delta_t,
  from = "x",
  to = "y",
  med = "m"
)
print(direct_dt)

## Indirect Effect ---------------------------------------------------------
indirect_dt &lt;- Indirect(
  phi = phi,
  delta_t = delta_t,
  from = "x",
  to = "y",
  med = "m"
)
print(indirect_dt)

</code></pre>

<hr>
<h2 id='print.ctmedmc'>Print Method for Object of Class <code>ctmedmc</code></h2><span id='topic+print.ctmedmc'></span>

<h3>Description</h3>

<p>Print Method for Object of Class <code>ctmedmc</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedmc'
print(x, alpha = 0.05, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ctmedmc_+3A_x">x</code></td>
<td>
<p>an object of class <code>ctmedmc</code>.</p>
</td></tr>
<tr><td><code id="print.ctmedmc_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector.
Significance level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="print.ctmedmc_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to display.</p>
</td></tr>
<tr><td><code id="print.ctmedmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a list of matrices of
time intervals,
estimates,
standard errors,
number of Monte Carlo replications,
and
confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
mc &lt;- MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
print(mc)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
print(mc)

</code></pre>

<hr>
<h2 id='print.ctmedmcphi'>Print Method for Object of Class <code>ctmedmcphi</code></h2><span id='topic+print.ctmedmcphi'></span>

<h3>Description</h3>

<p>Print Method for Object of Class <code>ctmedmcphi</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedmcphi'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ctmedmcphi_+3A_x">x</code></td>
<td>
<p>an object of class <code>ctmedmcphi</code>.</p>
</td></tr>
<tr><td><code id="print.ctmedmcphi_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to display.</p>
</td></tr>
<tr><td><code id="print.ctmedmcphi_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a list of drift matrices.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
mc &lt;- MCPhi(
  phi = phi,
  vcov_phi_vec = 0.1 * diag(9),
  R = 100L # use a large value for R in actual research
)
print(mc)

</code></pre>

<hr>
<h2 id='print.ctmedmed'>Print Method for Object of Class <code>ctmedmed</code></h2><span id='topic+print.ctmedmed'></span>

<h3>Description</h3>

<p>Print Method for Object of Class <code>ctmedmed</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedmed'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ctmedmed_+3A_x">x</code></td>
<td>
<p>an object of class <code>ctmedmed</code>.</p>
</td></tr>
<tr><td><code id="print.ctmedmed_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to display.</p>
</td></tr>
<tr><td><code id="print.ctmedmed_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a matrix of effects.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

# Specific time interval ----------------------------------------------------
med &lt;- Med(
  phi = phi,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)
print(med)

# Range of time intervals ---------------------------------------------------
med &lt;- Med(
  phi = phi,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
print(med)

</code></pre>

<hr>
<h2 id='print.ctmedtraj'>Print Method for Object of Class <code>ctmedtraj</code></h2><span id='topic+print.ctmedtraj'></span>

<h3>Description</h3>

<p>Print Method for Object of Class <code>ctmedtraj</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedtraj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ctmedtraj_+3A_x">x</code></td>
<td>
<p>an object of class <code>ctmedtraj</code>.</p>
</td></tr>
<tr><td><code id="print.ctmedtraj_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a data frame of simulated data.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

traj &lt;- Trajectory(
  mu0 = c(3, 3, -3),
  time = 150,
  phi = phi,
  med = "m"
)

print(traj)

</code></pre>

<hr>
<h2 id='summary.ctmedboot'>Summary Method for an Object of Class <code>ctmedboot</code></h2><span id='topic+summary.ctmedboot'></span>

<h3>Description</h3>

<p>Summary Method for an Object of Class <code>ctmedboot</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedboot'
summary(object, alpha = 0.05, type = "pc", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ctmedboot_+3A_object">object</code></td>
<td>
<p>Object of class <code>ctmedboot</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmedboot_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector.
Significance level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmedboot_+3A_type">type</code></td>
<td>
<p>Charater string.
Confidence interval type, that is,
<code>type = "pc"</code> for percentile;
<code>type = "bc"</code> for bias corrected.</p>
</td></tr>
<tr><td><code id="summary.ctmedboot_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of
effects,
time intervals,
estimates,
standard errors,
number of bootstrap replications,
and
confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(bootStateSpace)
# prepare parameters
## number of individuals
n &lt;- 50
## time points
time &lt;- 100
delta_t &lt;- 0.10
## dynamic structure
p &lt;- 3
mu0 &lt;- rep(x = 0, times = p)
sigma0 &lt;- matrix(
  data = c(
    1.0,
    0.2,
    0.2,
    0.2,
    1.0,
    0.2,
    0.2,
    0.2,
    1.0
  ),
  nrow = p
)
sigma0_l &lt;- t(chol(sigma0))
mu &lt;- rep(x = 0, times = p)
phi &lt;- matrix(
  data = c(
    -0.357,
    0.771,
    -0.450,
    0.0,
    -0.511,
    0.729,
    0,
    0,
    -0.693
  ),
  nrow = p
)
sigma &lt;- matrix(
  data = c(
    0.24455556,
    0.02201587,
    -0.05004762,
    0.02201587,
    0.07067800,
    0.01539456,
    -0.05004762,
    0.01539456,
    0.07553061
  ),
  nrow = p
)
sigma_l &lt;- t(chol(sigma))
## measurement model
k &lt;- 3
nu &lt;- rep(x = 0, times = k)
lambda &lt;- diag(k)
theta &lt;- 0.2 * diag(k)
theta_l &lt;- t(chol(theta))

boot &lt;- PBSSMOUFixed(
  R = 1000L,
  path = getwd(),
  prefix = "ou",
  n = n,
  time = time,
  delta_t = delta_t,
  mu0 = mu0,
  sigma0_l = sigma0_l,
  mu = mu,
  phi = phi,
  sigma_l = sigma_l,
  nu = nu,
  lambda = lambda,
  theta_l = theta_l,
  ncores = parallel::detectCores() - 1,
  seed = 42
)
phi_hat &lt;- phi
colnames(phi_hat) &lt;- rownames(phi_hat) &lt;- c("x", "m", "y")
phi &lt;- extract(object = boot, what = "phi")

# Specific time interval ----------------------------------------------------
boot &lt;- BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)
summary(boot)
summary(boot, type = "bc") # bias-corrected

# Range of time intervals ---------------------------------------------------
boot &lt;- BootMed(
  phi = phi,
  phi_hat = phi_hat,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
summary(boot)
summary(boot, type = "bc") # bias-corrected

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.ctmeddelta'>Summary Method for an Object of Class <code>ctmeddelta</code></h2><span id='topic+summary.ctmeddelta'></span>

<h3>Description</h3>

<p>Summary Method for an Object of Class <code>ctmeddelta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmeddelta'
summary(object, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ctmeddelta_+3A_object">object</code></td>
<td>
<p>Object of class <code>ctmeddelta</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmeddelta_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector.
Significance level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmeddelta_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of
effects,
time intervals,
estimates,
standard errors,
test statistics,
p-values,
and
confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
delta &lt;- DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)
summary(delta)

# Range of time intervals ---------------------------------------------------
delta &lt;- DeltaMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
summary(delta)

</code></pre>

<hr>
<h2 id='summary.ctmedmc'>Summary Method for an Object of Class <code>ctmedmc</code></h2><span id='topic+summary.ctmedmc'></span>

<h3>Description</h3>

<p>Summary Method for an Object of Class <code>ctmedmc</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedmc'
summary(object, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ctmedmc_+3A_object">object</code></td>
<td>
<p>Object of class <code>ctmedmc</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmedmc_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector.
Significance level <code class="reqn">\alpha</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmedmc_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of
effects,
time intervals,
estimates,
standard errors,
number of Monte Carlo replications,
and
confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
vcov_phi_vec &lt;- matrix(
  data = c(
    0.00843, 0.00040, -0.00151,
    -0.00600, -0.00033, 0.00110,
    0.00324, 0.00020, -0.00061,
    0.00040, 0.00374, 0.00016,
    -0.00022, -0.00273, -0.00016,
    0.00009, 0.00150, 0.00012,
    -0.00151, 0.00016, 0.00389,
    0.00103, -0.00007, -0.00283,
    -0.00050, 0.00000, 0.00156,
    -0.00600, -0.00022, 0.00103,
    0.00644, 0.00031, -0.00119,
    -0.00374, -0.00021, 0.00070,
    -0.00033, -0.00273, -0.00007,
    0.00031, 0.00287, 0.00013,
    -0.00014, -0.00170, -0.00012,
    0.00110, -0.00016, -0.00283,
    -0.00119, 0.00013, 0.00297,
    0.00063, -0.00004, -0.00177,
    0.00324, 0.00009, -0.00050,
    -0.00374, -0.00014, 0.00063,
    0.00495, 0.00024, -0.00093,
    0.00020, 0.00150, 0.00000,
    -0.00021, -0.00170, -0.00004,
    0.00024, 0.00214, 0.00012,
    -0.00061, 0.00012, 0.00156,
    0.00070, -0.00012, -0.00177,
    -0.00093, 0.00012, 0.00223
  ),
  nrow = 9
)

# Specific time interval ----------------------------------------------------
mc &lt;- MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
summary(mc)

# Range of time intervals ---------------------------------------------------
mc &lt;- MCMed(
  phi = phi,
  vcov_phi_vec = vcov_phi_vec,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m",
  R = 100L # use a large value for R in actual research
)
summary(mc)

</code></pre>

<hr>
<h2 id='summary.ctmedmed'>Summary Method for an Object of Class <code>ctmedmed</code></h2><span id='topic+summary.ctmedmed'></span>

<h3>Description</h3>

<p>Summary Method for an Object of Class <code>ctmedmed</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedmed'
summary(object, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ctmedmed_+3A_object">object</code></td>
<td>
<p>an object of class <code>ctmedmed</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmedmed_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to display.</p>
</td></tr>
<tr><td><code id="summary.ctmedmed_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of effects.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

# Specific time interval ----------------------------------------------------
med &lt;- Med(
  phi = phi,
  delta_t = 1,
  from = "x",
  to = "y",
  med = "m"
)
summary(med)

# Range of time intervals ---------------------------------------------------
med &lt;- Med(
  phi = phi,
  delta_t = 1:5,
  from = "x",
  to = "y",
  med = "m"
)
summary(med)

</code></pre>

<hr>
<h2 id='summary.ctmedposteriorphi'>Summary Method for Object of Class <code>ctmedposteriorphi</code></h2><span id='topic+summary.ctmedposteriorphi'></span>

<h3>Description</h3>

<p>Summary Method for Object of Class <code>ctmedposteriorphi</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedposteriorphi'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ctmedposteriorphi_+3A_object">object</code></td>
<td>
<p>an object of class <code>ctmedposteriorphi</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmedposteriorphi_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the posterior means
(in matrix form) and covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>

<hr>
<h2 id='summary.ctmedtraj'>Summary Method for an Object of Class <code>ctmedtraj</code></h2><span id='topic+summary.ctmedtraj'></span>

<h3>Description</h3>

<p>Summary Method for an Object of Class <code>ctmedtraj</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctmedtraj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ctmedtraj_+3A_object">object</code></td>
<td>
<p>an object of class <code>ctmedtraj</code>.</p>
</td></tr>
<tr><td><code id="summary.ctmedtraj_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of simulated data.
</p>


<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

traj &lt;- Trajectory(
  mu0 = c(3, 3, -3),
  time = 150,
  phi = phi,
  med = "m"
)

summary(traj)

</code></pre>

<hr>
<h2 id='Total'>Total Effect Matrix
Over a Specific Time Interval</h2><span id='topic+Total'></span>

<h3>Description</h3>

<p>This function computes the total effects matrix
over a specific time interval <code class="reqn">\Delta t</code>
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Total(phi, delta_t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Total_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="Total_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total effect matrix
over a specific time interval <code class="reqn">\Delta t</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{Total}_{\Delta t}
    =
    \exp
    \left(
      \Delta t
      \boldsymbol{\Phi}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\Phi}</code> denotes the drift matrix, and
<code class="reqn">\Delta t</code> the time interval.
</p>


<h4>Linear Stochastic Differential Equation Model</h4>

<p>The measurement model is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathbf{y}_{i, t}
    =
    \boldsymbol{\nu}
    +
    \boldsymbol{\Lambda}
    \boldsymbol{\eta}_{i, t}
    +
    \boldsymbol{\varepsilon}_{i, t},
    \quad
    \mathrm{with}
    \quad
    \boldsymbol{\varepsilon}_{i, t}
    \sim
    \mathcal{N}
    \left(
    \mathbf{0},
    \boldsymbol{\Theta}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\mathbf{y}_{i, t}</code>,
<code class="reqn">\boldsymbol{\eta}_{i, t}</code>,
and
<code class="reqn">\boldsymbol{\varepsilon}_{i, t}</code>
are random variables
and
<code class="reqn">\boldsymbol{\nu}</code>,
<code class="reqn">\boldsymbol{\Lambda}</code>,
and
<code class="reqn">\boldsymbol{\Theta}</code>
are model parameters.
<code class="reqn">\mathbf{y}_{i, t}</code>
represents a vector of observed random variables,
<code class="reqn">\boldsymbol{\eta}_{i, t}</code>
a vector of latent random variables,
and
<code class="reqn">\boldsymbol{\varepsilon}_{i, t}</code>
a vector of random measurement errors,
at time <code class="reqn">t</code> and individual <code class="reqn">i</code>.
<code class="reqn">\boldsymbol{\nu}</code>
denotes a vector of intercepts,
<code class="reqn">\boldsymbol{\Lambda}</code>
a matrix of factor loadings,
and
<code class="reqn">\boldsymbol{\Theta}</code>
the covariance matrix of
<code class="reqn">\boldsymbol{\varepsilon}</code>.
</p>
<p>An alternative representation of the measurement error
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \boldsymbol{\varepsilon}_{i, t}
    =
    \boldsymbol{\Theta}^{\frac{1}{2}}
    \mathbf{z}_{i, t},
    \quad
    \mathrm{with}
    \quad
    \mathbf{z}_{i, t}
    \sim
    \mathcal{N}
    \left(
    \mathbf{0},
    \mathbf{I}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\mathbf{z}_{i, t}</code> is a vector of
independent standard normal random variables and
<code class="reqn">
    \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)
    \left( \boldsymbol{\Theta}^{\frac{1}{2}} \right)^{\prime}
    =
    \boldsymbol{\Theta} .
  </code>
</p>
<p>The dynamic structure is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{d} \boldsymbol{\eta}_{i, t}
    =
    \left(
    \boldsymbol{\iota}
    +
    \boldsymbol{\Phi}
    \boldsymbol{\eta}_{i, t}
    \right)
    \mathrm{d}t
    +
    \boldsymbol{\Sigma}^{\frac{1}{2}}
    \mathrm{d}
    \mathbf{W}_{i, t}
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\iota}</code>
is a term which is unobserved and constant over time,
<code class="reqn">\boldsymbol{\Phi}</code>
is the drift matrix
which represents the rate of change of the solution
in the absence of any random fluctuations,
<code class="reqn">\boldsymbol{\Sigma}</code>
is the matrix of volatility
or randomness in the process, and
<code class="reqn">\mathrm{d}\boldsymbol{W}</code>
is a Wiener process or Brownian motion,
which represents random fluctuations.
</p>



<h3>Value</h3>

<p>Returns an object
of class <code>ctmedeffect</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;Total&quot;).</p>
</dd>
<dt>output</dt><dd><p>The matrix of total effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
delta_t &lt;- 1
Total(
  phi = phi,
  delta_t = delta_t
)
phi &lt;- matrix(
  data = c(
    -6, 5.5, 0, 0,
    1.25, -2.5, 5.9, -7.3,
    0, 0, -6, 2.5,
    5, 0, 0, -6
  ),
  nrow = 4
)
colnames(phi) &lt;- rownames(phi) &lt;- paste0("y", 1:4)
Total(
  phi = phi,
  delta_t = delta_t
)

</code></pre>

<hr>
<h2 id='TotalCentral'>Total Effect Centrality</h2><span id='topic+TotalCentral'></span>

<h3>Description</h3>

<p>Total Effect Centrality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TotalCentral(phi, delta_t, tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TotalCentral_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="TotalCentral_+3A_delta_t">delta_t</code></td>
<td>
<p>Vector of positive numbers.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
<tr><td><code id="TotalCentral_+3A_tol">tol</code></td>
<td>
<p>Numeric.
Smallest possible time interval to allow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total effect centrality of a variable
is the sum of the total effects of a variable on all other variables
at a particular time interval.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedmed</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;TotalCentral&quot;).</p>
</dd>
<dt>output</dt><dd><p>A matrix of total effect centrality.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

# Specific time interval ----------------------------------------------------
TotalCentral(
  phi = phi,
  delta_t = 1
)

# Range of time intervals ---------------------------------------------------
total_central &lt;- TotalCentral(
  phi = phi,
  delta_t = 1:30
)
plot(total_central)

# Methods -------------------------------------------------------------------
# TotalCentral has a number of methods including
# print, summary, and plot
total_central &lt;- TotalCentral(
  phi = phi,
  delta_t = 1:5
)
print(total_central)
summary(total_central)
plot(total_central)

</code></pre>

<hr>
<h2 id='TotalStd'>Standardized Total Effect Matrix
Over a Specific Time Interval</h2><span id='topic+TotalStd'></span>

<h3>Description</h3>

<p>This function computes the standardized total effects matrix
over a specific time interval <code class="reqn">\Delta t</code>
using the first-order stochastic differential equation model's
drift matrix <code class="reqn">\boldsymbol{\Phi}</code>
and process noise covariance matrix <code class="reqn">\boldsymbol{\Sigma}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TotalStd(phi, sigma, delta_t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TotalStd_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="TotalStd_+3A_sigma">sigma</code></td>
<td>
<p>Numeric matrix.
The process noise covariance matrix (<code class="reqn">\boldsymbol{\Sigma}</code>).</p>
</td></tr>
<tr><td><code id="TotalStd_+3A_delta_t">delta_t</code></td>
<td>
<p>Numeric.
Time interval
(<code class="reqn">\Delta t</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized total effect matrix
over a specific time interval <code class="reqn">\Delta t</code>
is given by
</p>
<p style="text-align: center;"><code class="reqn">
    \mathrm{Total}^{\ast}_{{\Delta t}_{i, j}}
    =
    \mathrm{Total}_{{\Delta t}_{i, j}}
    \left(
    \frac{\sigma_{{x}_{j}}}{\sigma_{{y}_{i}}}
    \right)
  </code>
</p>

<p>where
<code class="reqn">\boldsymbol{\Phi}</code> denotes the drift matrix,
<code class="reqn">\sigma_{{x}_{j}}</code> and <code class="reqn">\sigma_{{y}_{i}}</code>
are the steady-state model-implied standard deviations
of the state independent and dependent variables, respectively, and
<code class="reqn">\Delta t</code> the time interval.
</p>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedeffect</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;TotalStd&quot;).</p>
</dd>
<dt>output</dt><dd><p>The standardized matrix of total effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ivan Jacob Agaloos Pesigan
</p>


<h3>References</h3>

<p>Bollen, K. A. (1987).
Total, direct, and indirect effects in structural equation models.
Sociological Methodology, 17, 37.
<a href="https://doi.org/10.2307/271028">doi:10.2307/271028</a>
</p>
<p>Deboeck, P. R., &amp; Preacher, K. J. (2015).
No need to be discrete:
A method for continuous time mediation analysis.
Structural Equation Modeling: A Multidisciplinary Journal, 23 (1), 61–75.
<a href="https://doi.org/10.1080/10705511.2014.973960">doi:10.1080/10705511.2014.973960</a>
</p>
<p>Ryan, O., &amp; Hamaker, E. L. (2021).
Time to intervene:
A continuous-time approach to network analysis and centrality.
Psychometrika, 87 (1), 214–252.
<a href="https://doi.org/10.1007/s11336-021-09767-0">doi:10.1007/s11336-021-09767-0</a>
</p>


<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+Trajectory">Trajectory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")
sigma &lt;- matrix(
  data = c(
    0.24455556, 0.02201587, -0.05004762,
    0.02201587, 0.07067800, 0.01539456,
    -0.05004762, 0.01539456, 0.07553061
  ),
  nrow = 3
)
delta_t &lt;- 1
TotalStd(
  phi = phi,
  sigma = sigma,
  delta_t = delta_t
)

</code></pre>

<hr>
<h2 id='Trajectory'>Simulate Trajectories of Variables</h2><span id='topic+Trajectory'></span>

<h3>Description</h3>

<p>This function simulates trajectories of variables
without measurement error or process noise.
<code>Total</code> corresponds to the total effect
and <code>Direct</code> corresponds to the portion of the total effect
where the indirect effect is removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trajectory(mu0, time, phi, med)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Trajectory_+3A_mu0">mu0</code></td>
<td>
<p>Numeric vector.
Initial values of the variables.</p>
</td></tr>
<tr><td><code id="Trajectory_+3A_time">time</code></td>
<td>
<p>Positive integer.
Number of time points.</p>
</td></tr>
<tr><td><code id="Trajectory_+3A_phi">phi</code></td>
<td>
<p>Numeric matrix.
The drift matrix (<code class="reqn">\boldsymbol{\Phi}</code>).
<code>phi</code> should have row and column names
pertaining to the variables in the system.</p>
</td></tr>
<tr><td><code id="Trajectory_+3A_med">med</code></td>
<td>
<p>Character vector.
Name/s of the mediator variable/s in <code>phi</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object
of class <code>ctmedtraj</code> which is a list with the following elements:
</p>

<dl>
<dt>call</dt><dd><p>Function call.</p>
</dd>
<dt>args</dt><dd><p>Function arguments.</p>
</dd>
<dt>fun</dt><dd><p>Function used (&quot;Trajectory&quot;).</p>
</dd>
<dt>output</dt><dd><p>A data frame of simulated data.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other Continuous Time Mediation Functions: 
<code><a href="#topic+BootBeta">BootBeta</a>()</code>,
<code><a href="#topic+BootBetaStd">BootBetaStd</a>()</code>,
<code><a href="#topic+BootIndirectCentral">BootIndirectCentral</a>()</code>,
<code><a href="#topic+BootMed">BootMed</a>()</code>,
<code><a href="#topic+BootMedStd">BootMedStd</a>()</code>,
<code><a href="#topic+BootTotalCentral">BootTotalCentral</a>()</code>,
<code><a href="#topic+DeltaBeta">DeltaBeta</a>()</code>,
<code><a href="#topic+DeltaBetaStd">DeltaBetaStd</a>()</code>,
<code><a href="#topic+DeltaIndirectCentral">DeltaIndirectCentral</a>()</code>,
<code><a href="#topic+DeltaMed">DeltaMed</a>()</code>,
<code><a href="#topic+DeltaMedStd">DeltaMedStd</a>()</code>,
<code><a href="#topic+DeltaTotalCentral">DeltaTotalCentral</a>()</code>,
<code><a href="#topic+Direct">Direct</a>()</code>,
<code><a href="#topic+DirectStd">DirectStd</a>()</code>,
<code><a href="#topic+Indirect">Indirect</a>()</code>,
<code><a href="#topic+IndirectCentral">IndirectCentral</a>()</code>,
<code><a href="#topic+IndirectStd">IndirectStd</a>()</code>,
<code><a href="#topic+MCBeta">MCBeta</a>()</code>,
<code><a href="#topic+MCBetaStd">MCBetaStd</a>()</code>,
<code><a href="#topic+MCIndirectCentral">MCIndirectCentral</a>()</code>,
<code><a href="#topic+MCMed">MCMed</a>()</code>,
<code><a href="#topic+MCMedStd">MCMedStd</a>()</code>,
<code><a href="#topic+MCPhi">MCPhi</a>()</code>,
<code><a href="#topic+MCPhiSigma">MCPhiSigma</a>()</code>,
<code><a href="#topic+MCTotalCentral">MCTotalCentral</a>()</code>,
<code><a href="#topic+Med">Med</a>()</code>,
<code><a href="#topic+MedStd">MedStd</a>()</code>,
<code><a href="#topic+PosteriorBeta">PosteriorBeta</a>()</code>,
<code><a href="#topic+PosteriorIndirectCentral">PosteriorIndirectCentral</a>()</code>,
<code><a href="#topic+PosteriorMed">PosteriorMed</a>()</code>,
<code><a href="#topic+PosteriorTotalCentral">PosteriorTotalCentral</a>()</code>,
<code><a href="#topic+Total">Total</a>()</code>,
<code><a href="#topic+TotalCentral">TotalCentral</a>()</code>,
<code><a href="#topic+TotalStd">TotalStd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phi &lt;- matrix(
  data = c(
    -0.357, 0.771, -0.450,
    0.0, -0.511, 0.729,
    0, 0, -0.693
  ),
  nrow = 3
)
colnames(phi) &lt;- rownames(phi) &lt;- c("x", "m", "y")

traj &lt;- Trajectory(
  mu0 = c(3, 3, -3),
  time = 150,
  phi = phi,
  med = "m"
)
plot(traj)

# Methods -------------------------------------------------------------------
# Trajectory has a number of methods including
# print, summary, and plot

traj &lt;- Trajectory(
  mu0 = c(3, 3, -3),
  time = 25,
  phi = phi,
  med = "m"
)
print(traj)
summary(traj)
plot(traj)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
