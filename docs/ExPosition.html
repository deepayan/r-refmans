<!DOCTYPE html><html><head><title>Help for package ExPosition</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ExPosition}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acknowledgements'>
<p>acknowledgements</p></a></li>
<li><a href='#authors'><p>(A truncated form of) Punctuation used by six authors (data).</p></a></li>
<li><a href='#bada.wine'><p>Twelve wines from 3 regions in France with 18 attributes.</p></a></li>
<li><a href='#beer.tasting.notes'><p>Some of authors' personal beer tasting notes.</p></a></li>
<li><a href='#beers2007'><p>Ten assessors sort eight beers into groups.</p></a></li>
<li><a href='#calculateConstraints'>
<p>calculateConstraints</p></a></li>
<li><a href='#caNorm'>
<p>Correspondence analysis preprocessing</p></a></li>
<li><a href='#caSupplementalElementsPreProcessing'>
<p>Correspondence Analysis preprocessing.</p></a></li>
<li><a href='#chi2Dist'>
<p>Chi-square Distance computation</p></a></li>
<li><a href='#coffee.data'><p>Small data set on flavor perception and preferences for coffee.</p></a></li>
<li><a href='#computeMW'>
<p>computeMW</p></a></li>
<li><a href='#coreCA'>
<p>coreCA</p></a></li>
<li><a href='#coreMDS'>
<p>coreMDS</p></a></li>
<li><a href='#corePCA'>
<p>corePCA</p></a></li>
<li><a href='#createDefaultDesign'>
<p>createDefaultDesign</p></a></li>
<li><a href='#designCheck'>
<p>designCheck</p></a></li>
<li><a href='#dica.ad'><p>Alzheimer's Patient-Spouse Dyads.</p></a></li>
<li><a href='#dica.wine'><p>Twelve wines from 3 regions in France with 16 attributes.</p></a></li>
<li><a href='#ep.iris'><p>Fisher's iris Set (for ExPosition)</p></a></li>
<li><a href='#epCA'>
<p>epCA: Correspondence Analysis (CA) via ExPosition.</p></a></li>
<li><a href='#epGPCA'>
<p>epGPCA: Generalized Principal Components Analysis (GPCA) via ExPosition.</p></a></li>
<li><a href='#epGraphs'>
<p>epGraphs: ExPosition plotting function</p></a></li>
<li><a href='#epMCA'>
<p>epMCA: Multiple Correspondence Analysis (MCA) via ExPosition.</p></a></li>
<li><a href='#epMDS'>
<p>epMDS: Multidimensional Scaling (MDS) via ExPosition.</p></a></li>
<li><a href='#epPCA'>
<p>epPCA: Principal Component Analysis (PCA) via ExPosition.</p></a></li>
<li><a href='#expo.scale'>
<p>Scaling functions for ExPosition.</p></a></li>
<li><a href='#ExPosition-package'>
<p>ExPosition: <em>Ex</em>ploratory Analysis with the Singular Value Decom<em>Position</em></p></a></li>
<li><a href='#faces2005'><p>Faces analyzed using Four Algorithms</p></a></li>
<li><a href='#french.social'><p>How twelve French families spend their income on groceries.</p></a></li>
<li><a href='#genPDQ'>
<p>genPDQ: the GSVD</p></a></li>
<li><a href='#great.beer.tasting.1'><p>A collection of beer tasting notes from untrained assessors.</p></a></li>
<li><a href='#great.beer.tasting.2'><p>A collection of beer tasting notes from untrained assessors.</p></a></li>
<li><a href='#hellingerNorm'>
<p>Hellinger version of CA preprocessing</p></a></li>
<li><a href='#hellingerSupplementaryColsPreProcessing'>
<p>Preprocessing for supplementary columns in Hellinger analyses.</p></a></li>
<li><a href='#hellingerSupplementaryRowsPreProcessing'>
<p>Preprocessing for supplementary rows in Hellinger analyses.</p></a></li>
<li><a href='#jlsr.2010.ad'><p>Data from 17 Alzheimer's Patient-Spouse dyads.</p></a></li>
<li><a href='#jocn.2005.fmri'><p>Data of categories of images as view in an <em>f</em>MRI experiment.</p></a></li>
<li><a href='#makeDistancesAndWeights'>
<p>Makes distances and weights for MDS analyses (see <code>epMDS</code>).</p></a></li>
<li><a href='#makeNominalData'>
<p>makeNominalData</p></a></li>
<li><a href='#makeRowProfiles'>
<p>Preprocessing for CA-based analyses</p></a></li>
<li><a href='#mca.eigen.fix'>
<p>mca.eigen.fix</p></a></li>
<li><a href='#mca.wine'><p>Six wines described by several assessors with qualitative attributes.</p></a></li>
<li><a href='#mdsSupplementalElementsPreProcessing'>
<p>MDS preprocessing</p></a></li>
<li><a href='#mdsTransform'>
<p>Transform data for MDS analysis.</p></a></li>
<li><a href='#nominalCheck'>
<p>Checks if data are disjunctive.</p></a></li>
<li><a href='#pause'>
<p>pause</p></a></li>
<li><a href='#pca.wine'><p>Six wines described by several assessors with rank attributes.</p></a></li>
<li><a href='#pcaSupplementaryColsPreProcessing'>
<p>Preprocessing for supplementary columns in PCA.</p></a></li>
<li><a href='#pcaSupplementaryRowsPreProcessing'>
<p>Preprocessing for supplemental rows in PCA.</p></a></li>
<li><a href='#pickSVD'>
<p>Pick which generalized SVD (or related) decomposition to use.</p></a></li>
<li><a href='#print.epCA'><p>Print Correspondence Analysis (CA) results</p></a></li>
<li><a href='#print.epGPCA'><p>Print Generalized Principal Components Analysis (GPCA) results</p></a></li>
<li><a href='#print.epGraphs'><p>Print epGraphs results</p></a></li>
<li><a href='#print.epMCA'><p>Print Multiple Correspondence Analysis (MCA) results</p></a></li>
<li><a href='#print.epMDS'><p>Print Multidimensional Scaling (MDS) results</p></a></li>
<li><a href='#print.epPCA'><p>Print Principal Components Analysis (PCA) results</p></a></li>
<li><a href='#print.epSVD'><p>Print results from the singular value decomposition (SVD) in ExPosition</p></a></li>
<li><a href='#print.expoOutput'><p>Print results from ExPosition</p></a></li>
<li><a href='#rowNorms'>
<p>Normalize the rows of a matrix.</p></a></li>
<li><a href='#rvCoeff'>
<p>Perform Rv coefficient computation.</p></a></li>
<li><a href='#snps.druguse'><p>Small data set for Partial Least Squares-Correspondence Analysis</p></a></li>
<li><a href='#supplementalProjection'>
<p>Supplemental projections.</p></a></li>
<li><a href='#supplementaryCols'>
<p>Supplementary columns</p></a></li>
<li><a href='#supplementaryRows'>
<p>Supplementary rows</p></a></li>
<li><a href='#wines2007'><p>Six wines described by 3 assessors.</p></a></li>
<li><a href='#wines2012'><p>Wines Data from 12 assessors described by 15 flavor profiles.</p></a></li>
<li><a href='#words'><p>Twenty words described by 2 features.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exploratory Analysis with the Singular Value Decomposition</td>
</tr>
<tr>
<td>Version:</td>
<td>2.8.23</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-12-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Derek Beaton, Cherise R. Chin Fatt, Herve Abdi</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Derek Beaton &lt;exposition.software@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A variety of descriptive multivariate analyses with the singular value decomposition,
    such as principal components analysis, correspondence analysis, and multidimensional scaling.
    See An ExPosition of the Singular Value Decomposition in R (Beaton et al 2014) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2013.11.006">doi:10.1016/j.csda.2013.11.006</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>prettyGraphs (&ge; 2.1.4)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-27 16:16:04 UTC; Derek</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/derekbeaton/ExPosition-Family_OLD">https://github.com/derekbeaton/ExPosition-Family_OLD</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-07 17:00:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='acknowledgements'>
acknowledgements
</h2><span id='topic+acknowledgements'></span>

<h3>Description</h3>

<p><code>acknowledgements</code> returns a list of people who have contributed to ExPosition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acknowledgements()
</code></pre>


<h3>Value</h3>

<p>A list of people who have contributed something beyond code to the ExPosition family of packages.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='authors'>(A truncated form of) Punctuation used by six authors (data).</h2><span id='topic+authors'></span>

<h3>Description</h3>

<p>How six authors use 3 different types of puncatuation throughout their writing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(authors)</code></pre>


<h3>Format</h3>

<p>authors$ca$data: Six authors (rows) and the frequency of three puncutuations (columns). For use with <code><a href="#topic+epCA">epCA</a></code>.<br />
authors$mca$data: A Burt table reformatting of the $ca$data. For use with <code><a href="#topic+epMCA">epMCA</a></code>.
</p>


<h3>References</h3>

<p>Brunet, E. (1989). Faut-il ponderer les donnees linguistiques. <em>CUMFID</em>, 16, 39-50. <br />
Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.<br />
Abdi, H., and Williams, L.J. (2010). Correspondence analysis. In N.J. Salkind, D.M., Dougherty, &amp; B. Frey (Eds.): <em>Encyclopedia of Research Design</em>. Thousand Oaks (CA): Sage. pp. 267-278.
</p>

<hr>
<h2 id='bada.wine'>Twelve wines from 3 regions in France with 18 attributes.</h2><span id='topic+bada.wine'></span>

<h3>Description</h3>

<p>This data should be used for discriminant analyses or analyses where the <em>group</em> information is important.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bada.wine)</code></pre>


<h3>Format</h3>

<p>bada.wine$data: Data matrix with twelve wines (rows) from 3 regions with 18 attributes (columns).<br />
bada.wine$design: Design matrix with twelve wines (rows) with 3 regions (columns) to indicate group relationship of the data matrix.
</p>


<h3>References</h3>

<p>Abdi, H. and Williams, L.J. (2010). Barycentric discriminant analysis (BADIA). In N.J. Salkind, D.M., Dougherty, &amp; B. Frey (Eds.): <em>Encyclopedia of Research Design</em>. Thousand Oaks (CA): Sage. pp. 64-75.
</p>

<hr>
<h2 id='beer.tasting.notes'>Some of authors' personal beer tasting notes.</h2><span id='topic+beer.tasting.notes'></span>

<h3>Description</h3>

<p>Tasting notes, preferences, breweries and styles of 38 different craft beers from various breweries, across various styles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(beer.tasting.notes)</code></pre>


<h3>Format</h3>

<p>beer.tasting.notes$data: Data matrix. Tasting notes (ratings) of 38 different beers (rows) described by 16 different flavor profiles (columns).<br />
beer.tasting.notes$brewery.design: Design matrix. Source brewery of 38 different beers (rows) across 26 breweries (columns). <br />
beer.tasting.notes$style.design: Design matrix. Style of 38 different beers (rows) across 20 styles (columns) (styles as listed from Beer Advocate website). <br />
beer.tasting.notes$sup.data: Supplementary data matrix. ABV and overall preference ratings of 38 beers described by two features (ABV &amp; overall) in original value and rounded value.
</p>


<h3>Source</h3>

<p>Jenny Rieck and Derek Beaton laboriously &ldquo;collected&rdquo; these data for &ldquo;experimental purposes&rdquo;.
</p>


<h3>References</h3>

<p>http://www.beeradvocate.com
</p>

<hr>
<h2 id='beers2007'>Ten assessors sort eight beers into groups.</h2><span id='topic+beers2007'></span>

<h3>Description</h3>

<p>Ten assessors perform a free-sorting task to sort eight beers into groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(beers2007)</code></pre>


<h3>Format</h3>

<p>beer2007$data: A data matrix with 8 rows (beers) described by 10 assessors (columns).
</p>


<h3>References</h3>

<p>Abdi, H., Valentin, D., Chollet, S., &amp; Chrea, C. (2007). Analyzing assessors and products in sorting tasks: DISTATIS, theory and applications. <em>Food Quality and Preference</em>, 627-640.
</p>

<hr>
<h2 id='calculateConstraints'>
calculateConstraints
</h2><span id='topic+calculateConstraints'></span>

<h3>Description</h3>

<p>Calculates constraints for plotting data..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateConstraints(results,x_axis=1,y_axis=2,constraints=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateConstraints_+3A_results">results</code></td>
<td>
<p>results from ExPosition (i.e., $ExPosition.Data)</p>
</td></tr>
<tr><td><code id="calculateConstraints_+3A_x_axis">x_axis</code></td>
<td>
<p>which component should be on the x axis?</p>
</td></tr>
<tr><td><code id="calculateConstraints_+3A_y_axis">y_axis</code></td>
<td>
<p>which component should be on the y axis?</p>
</td></tr>
<tr><td><code id="calculateConstraints_+3A_constraints">constraints</code></td>
<td>
<p>if available, axis constraints for the plots (determines end points of the plots).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following items:<br />
</p>
<table>
<tr><td><code>$constraints</code></td>
<td>
<p>axis constraints for the plots (determines end points of the plots).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='caNorm'>
Correspondence analysis preprocessing
</h2><span id='topic+caNorm'></span>

<h3>Description</h3>

<p>Performs all steps required for CA processing (row profile approach).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caNorm(X, X_dimensions, colTotal, rowTotal, grandTotal, weights = NULL, masses = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caNorm_+3A_x">X</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="caNorm_+3A_x_dimensions">X_dimensions</code></td>
<td>
<p>The dimensions of X in a vector of length 2 (rows, columns). See <code><a href="base.html#topic+dim">dim</a></code></p>
</td></tr>
<tr><td><code id="caNorm_+3A_coltotal">colTotal</code></td>
<td>
<p>Vector of column sums.</p>
</td></tr>
<tr><td><code id="caNorm_+3A_rowtotal">rowTotal</code></td>
<td>
<p>Vector of row sums.</p>
</td></tr>
<tr><td><code id="caNorm_+3A_grandtotal">grandTotal</code></td>
<td>
<p>Grand total of X</p>
</td></tr>
<tr><td><code id="caNorm_+3A_weights">weights</code></td>
<td>
<p>Optional weights to include for the columns.</p>
</td></tr>
<tr><td><code id="caNorm_+3A_masses">masses</code></td>
<td>
<p>Optional masses to include for the rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>rowCenter</code></td>
<td>
<p>The barycenter of X.</p>
</td></tr>
<tr><td><code>masses</code></td>
<td>
<p>Masses to be used for the GSVD.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Weights to be used for the GSVD.</p>
</td></tr>
<tr><td><code>rowProfiles</code></td>
<td>
<p>The row profiles of X.</p>
</td></tr>
<tr><td><code>deviations</code></td>
<td>
<p>Deviations of row profiles from <code>rowCenter</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='caSupplementalElementsPreProcessing'>
Correspondence Analysis preprocessing. 
</h2><span id='topic+caSupplementalElementsPreProcessing'></span>

<h3>Description</h3>

<p>CA preprocessing for data. Can be performed on rows or columns of your data. This is a row-profile normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caSupplementalElementsPreProcessing(SUP.DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caSupplementalElementsPreProcessing_+3A_sup.data">SUP.DATA</code></td>
<td>
<p>Data that will be supplemental. Row profile normalization is used. For supplemental rows use <code>t(SUP.DATA)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix that is preprocessed for supplemental projections.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mdsSupplementalElementsPreProcessing">mdsSupplementalElementsPreProcessing</a></code>, <code><a href="#topic+pcaSupplementaryColsPreProcessing">pcaSupplementaryColsPreProcessing</a></code>, <code><a href="#topic+pcaSupplementaryRowsPreProcessing">pcaSupplementaryRowsPreProcessing</a></code>, <code><a href="#topic+hellingerSupplementaryColsPreProcessing">hellingerSupplementaryColsPreProcessing</a></code>, <code><a href="#topic+hellingerSupplementaryRowsPreProcessing">hellingerSupplementaryRowsPreProcessing</a></code>, <code><a href="#topic+supplementaryCols">supplementaryCols</a></code>, <code><a href="#topic+supplementaryRows">supplementaryRows</a></code>, <code><a href="#topic+supplementalProjection">supplementalProjection</a></code>, <code><a href="#topic+rowNorms">rowNorms</a></code>
</p>

<hr>
<h2 id='chi2Dist'>
Chi-square Distance computation
</h2><span id='topic+chi2Dist'></span>

<h3>Description</h3>

<p>Performs a chi-square distance. Primarily used for <code><a href="#topic+epMDS">epMDS</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2Dist(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi2Dist_+3A_x">X</code></td>
<td>
<p>Compute chi-square distances between row items.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>Distance matrix for <code><a href="#topic+epMDS">epMDS</a></code> analysis.</p>
</td></tr>
<tr><td><code>MW</code></td>
<td>
<p>a list of masses and weights. Weights not used in MDS.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hervé Abdi
</p>

<hr>
<h2 id='coffee.data'>Small data set on flavor perception and preferences for coffee.</h2><span id='topic+coffee.data'></span>

<h3>Description</h3>

<p>One coffee from Oak Cliff roasters (Dallas, TX) was used in this experiment. Honduran source with a medium roast. The coffee was brewed in two ways and served in two ways (i.e., a 2x2 design). Two batches each of coffee were brewed at 180 degrees (Hot) Farenheit or at room temperature (Cold). One of each was served cold or heated back up to 180 degrees (Hot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coffee.data)</code></pre>


<h3>Format</h3>

<p>coffee.data$preferences: Ten participants indicated if they liked a particular serving or not.<br />
coffee.data$ratings: Ten participants indicated on a scale of 0-2 the presence of particular flavors. In an array format.
</p>


<h3>Details</h3>

<p>Flavor profiles measured: Salty, Spice Cabinet, Sweet, Bittery, and Nutty.
</p>

<hr>
<h2 id='computeMW'>
computeMW
</h2><span id='topic+computeMW'></span>

<h3>Description</h3>

<p>Computes masses and weights for <code><a href="#topic+epGPCA">epGPCA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMW(DATA, masses = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeMW_+3A_data">DATA</code></td>
<td>
<p>original data; will be used to compute masses and weights if none are provided.</p>
</td></tr>
<tr><td><code id="computeMW_+3A_masses">masses</code></td>
<td>
<p>a vector or (diagonal) matrix of masses for the row items. If NULL (default), masses are computed as 1/# of rows</p>
</td></tr>
<tr><td><code id="computeMW_+3A_weights">weights</code></td>
<td>
<p>a vector or (diagonal) matrix of weights for the column items. If NULL (default), weights are computed as 1/# of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following items:<br />
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>a diagonal matrix of masses (if too large, a vector is returned).</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>a diagonal matrix of weights (if too large, a vector is returned).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epGPCA">epGPCA</a></code>
</p>

<hr>
<h2 id='coreCA'>
coreCA
</h2><span id='topic+coreCA'></span>

<h3>Description</h3>

<p>coreCA performs the core of correspondence analysis (CA), multiple correspondence analysis (MCA) and related techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coreCA(DATA, masses = NULL, weights = NULL, hellinger = FALSE, symmetric = TRUE, 
decomp.approach = 'svd', k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coreCA_+3A_data">DATA</code></td>
<td>
<p>original data to decompose and analyze via the singular value decomposition.</p>
</td></tr>
<tr><td><code id="coreCA_+3A_masses">masses</code></td>
<td>
<p>a vector or diagonal matrix with masses for the rows (observations). If NULL, one is created or the plain SVD is used.</p>
</td></tr>
<tr><td><code id="coreCA_+3A_weights">weights</code></td>
<td>
<p>a vector or diagonal matrix with weights for the columns (measures). If NULL, one is created or the plain SVD is used.</p>
</td></tr>
<tr><td><code id="coreCA_+3A_hellinger">hellinger</code></td>
<td>
<p>a boolean. If FALSE (default), Chi-square distance will be used. If TRUE, Hellinger distance will be used.</p>
</td></tr>
<tr><td><code id="coreCA_+3A_symmetric">symmetric</code></td>
<td>
<p>a boolean. If TRUE (default) symmetric factor scores for rows and columns are computed. If FALSE, the simplex (column-based) will be returned.</p>
</td></tr>
<tr><td><code id="coreCA_+3A_decomp.approach">decomp.approach</code></td>
<td>
<p>string. A switch for different decompositions (typically for speed). See <code><a href="#topic+pickSVD">pickSVD</a></code>.</p>
</td></tr>  
<tr><td><code id="coreCA_+3A_k">k</code></td>
<td>
<p>number of components to return (this is not a rotation, just an <em>a priori</em> selection of how much data should be returned).</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This function should not be used directly. Please use <code><a href="#topic+epCA">epCA</a></code> or <code><a href="#topic+epMCA">epMCA</a></code> unless you plan on writing extensions to ExPosition. Any extensions wherein CA is the primary analysis should use <code>coreCA</code>.
</p>


<h3>Value</h3>

<p>Returns a large list of items which are also returned in <code><a href="#topic+epCA">epCA</a></code> and <code><a href="#topic+epMCA">epMCA</a></code> (the help files for those functions will refer to this as well).<br />
All items with a letter followed by an <em>i</em> are for the <em>I</em> rows of a DATA matrix. All items with a letter followed by an <em>j</em> are for the <em>J</em> rows of a DATA matrix.<br /><br />
</p>
<table>
<tr><td><code>fi</code></td>
<td>
<p>factor scores for the row items.</p>
</td></tr>
<tr><td><code>di</code></td>
<td>
<p>square distances of the row items.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>contributions (to the variance) of the row items.</p>
</td></tr>
<tr><td><code>ri</code></td>
<td>
<p>cosines of the row items.</p>
</td></tr>
<tr><td><code>fj</code></td>
<td>
<p>factor scores for the column items.</p>
</td></tr>
<tr><td><code>dj</code></td>
<td>
<p>square distances of the column items.</p>
</td></tr>
<tr><td><code>cj</code></td>
<td>
<p>contributions (to the variance) of the column items.</p>
</td></tr>
<tr><td><code>rj</code></td>
<td>
<p>cosines of the column items.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>the percent of explained variance per component (tau).</p>
</td></tr>
<tr><td><code>eigs</code></td>
<td>
<p>the eigenvalues from the decomposition.</p>
</td></tr>
<tr><td><code>pdq</code></td>
<td>
<p>the set of left singular vectors (pdq$p) for the rows, singular values (pdq$Dv and pdq$Dd), and the set of right singular vectors (pdq$q) for the columns.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>a column-vector or diagonal matrix of masses (for the rows)</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>a column-vector or diagonal matrix of weights (for the columns)</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>a centering vector (for the columns).</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the final matrix that was decomposed (includes scaling, centering, masses, etc...).</p>
</td></tr>
<tr><td><code>hellinger</code></td>
<td>
<p>a boolean. TRUE if Hellinger distance was used.</p>
</td></tr>
<tr><td><code>symmetric</code></td>
<td>
<p>a boolean. FALSE if asymmetric factor scores should be computed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Hervé Abdi.
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.<br />
Abdi, H., and Williams, L.J. (2010). Correspondence analysis. In N.J. Salkind, D.M., Dougherty, &amp; B. Frey (Eds.): <em>Encyclopedia of Research Design</em>. Thousand Oaks (CA): Sage. pp. 267-278.<br />
Abdi, H. (2007). Singular Value Decomposition (SVD) and Generalized Singular Value Decomposition (GSVD). In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>.Thousand Oaks (CA): Sage. pp. 907-912.
Greenacre, M. J. (2007). Correspondence Analysis in Practice. <em>Chapman and Hall</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epCA">epCA</a></code>, <code><a href="#topic+epMCA">epMCA</a></code>
</p>

<hr>
<h2 id='coreMDS'>
coreMDS
</h2><span id='topic+coreMDS'></span>

<h3>Description</h3>

<p>coreMDS performs metric multidimensional scaling (MDS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coreMDS(DATA, masses = NULL, decomp.approach = 'svd', k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coreMDS_+3A_data">DATA</code></td>
<td>
<p>original data to decompose and analyze via the singular value decomposition.</p>
</td></tr>
<tr><td><code id="coreMDS_+3A_masses">masses</code></td>
<td>
<p>a vector or diagonal matrix with masses for the rows (observations). If NULL, one is created.</p>
</td></tr>
<tr><td><code id="coreMDS_+3A_decomp.approach">decomp.approach</code></td>
<td>
<p>string. A switch for different decompositions (typically for speed). See <code><a href="#topic+pickSVD">pickSVD</a></code>.</p>
</td></tr>
<tr><td><code id="coreMDS_+3A_k">k</code></td>
<td>
<p>number of components to return (this is not a rotation, just an <em>a priori</em> selection of how much data should be returned).</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code><a href="#topic+epMDS">epMDS</a></code> should not be used directly unless you plan on writing extensions to ExPosition. See <code><a href="#topic+epMDS">epMDS</a></code>
</p>


<h3>Value</h3>

<p>Returns a large list of items which are also returned in <code><a href="#topic+epMDS">epMDS</a></code>.<br />
All items with a letter followed by an <em>i</em> are for the <em>I</em> rows of a DATA matrix. All items with a letter followed by an <em>j</em> are for the <em>J</em> rows of a DATA matrix.<br /><br />
</p>
<table>
<tr><td><code>fi</code></td>
<td>
<p>factor scores for the row items.</p>
</td></tr>
<tr><td><code>di</code></td>
<td>
<p>square distances of the row items.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>contributions (to the variance) of the row items.</p>
</td></tr>
<tr><td><code>ri</code></td>
<td>
<p>cosines of the row items.</p>
</td></tr>
<tr><td><code>masses</code></td>
<td>
<p>a column-vector or diagonal matrix of masses (for the rows)</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>the percent of explained variance per component (tau).</p>
</td></tr>
<tr><td><code>eigs</code></td>
<td>
<p>the eigenvalues from the decomposition.</p>
</td></tr>
<tr><td><code>pdq</code></td>
<td>
<p>the set of left singular vectors (pdq$p) for the rows, singular values (pdq$Dv and pdq$Dd), and the set of right singular vectors (pdq$q) for the columns.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the final matrix that was decomposed (includes scaling, centering, masses, etc...).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Hervé Abdi.
</p>


<h3>References</h3>

<p>Abdi, H. (2007). Metric multidimensional scaling. In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics.</em> Thousand Oaks (CA): Sage. pp. 598-605. <br />
O'Toole, A. J., Jiang, F., Abdi, H., and Haxby, J. V. (2005). Partially distributed representations of objects and faces in ventral temporal cortex. <em>Journal of Cognitive Neuroscience</em>, <em>17</em>(4), 580-590.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epMDS">epMDS</a></code>
</p>

<hr>
<h2 id='corePCA'>
corePCA
</h2><span id='topic+corePCA'></span>

<h3>Description</h3>

<p>corePCA performs the core of principal components analysis (PCA), generalized PCA (GPCA), multidimensionsal scaling (MDS), and related techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corePCA(DATA, M = NULL, W = NULL, decomp.approach = 'svd', k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corePCA_+3A_data">DATA</code></td>
<td>
<p>original data to decompose and analyze via the singular value decomposition.</p>
</td></tr>
<tr><td><code id="corePCA_+3A_m">M</code></td>
<td>
<p>a vector or diagonal matrix with masses for the rows (observations). If NULL, one is created or the plain SVD is used.</p>
</td></tr>
<tr><td><code id="corePCA_+3A_w">W</code></td>
<td>
<p>a vector or diagonal matrix with weights for the columns (measures). If NULL, one is created or the plain SVD is used.</p>
</td></tr>
<tr><td><code id="corePCA_+3A_decomp.approach">decomp.approach</code></td>
<td>
<p>string. A switch for different decompositions (typically for speed). See <code><a href="#topic+pickSVD">pickSVD</a></code>.</p>
</td></tr>  
<tr><td><code id="corePCA_+3A_k">k</code></td>
<td>
<p>number of components to return (this is not a rotation, just an <em>a priori</em> selection of how much data should be returned).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be used directly. Please use <code><a href="#topic+epPCA">epPCA</a></code> or <code><a href="#topic+epGPCA">epGPCA</a></code> unless you plan on writing extensions to ExPosition.
</p>


<h3>Value</h3>

<p>Returns a large list of items which are also returned in <code><a href="#topic+epPCA">epPCA</a></code> and <code><a href="#topic+epGPCA">epGPCA</a></code> (the help files for those functions will refer to this as well).<br />
All items with a letter followed by an <em>i</em> are for the <em>I</em> rows of a DATA matrix. All items with a letter followed by an <em>j</em> are for the <em>J</em> rows of a DATA matrix.<br /><br />
</p>
<table>
<tr><td><code>fi</code></td>
<td>
<p>factor scores for the row items.</p>
</td></tr>
<tr><td><code>di</code></td>
<td>
<p>square distances of the row items.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>contributions (to the variance) of the row items.</p>
</td></tr>
<tr><td><code>ri</code></td>
<td>
<p>cosines of the row items.</p>
</td></tr>
<tr><td><code>fj</code></td>
<td>
<p>factor scores for the column items.</p>
</td></tr>
<tr><td><code>dj</code></td>
<td>
<p>square distances of the column items.</p>
</td></tr>
<tr><td><code>cj</code></td>
<td>
<p>contributions (to the variance) of the column items.</p>
</td></tr>
<tr><td><code>rj</code></td>
<td>
<p>cosines of the column items.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>the percent of explained variance per component (tau).</p>
</td></tr>
<tr><td><code>eigs</code></td>
<td>
<p>the eigenvalues from the decomposition.</p>
</td></tr>
<tr><td><code>pdq</code></td>
<td>
<p>the set of left singular vectors (pdq$p) for the rows, singular values (pdq$Dv and pdq$Dd), and the set of right singular vectors (pdq$q) for the columns.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the final matrix that was decomposed (includes scaling, centering, masses, etc...).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Hervé Abdi.
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.<br />
Abdi, H. (2007). Singular Value Decomposition (SVD) and Generalized Singular Value Decomposition (GSVD). In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>.Thousand Oaks (CA): Sage. pp. 907-912.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epPCA">epPCA</a></code>, <code><a href="#topic+epGPCA">epGPCA</a></code>
</p>

<hr>
<h2 id='createDefaultDesign'>
createDefaultDesign
</h2><span id='topic+createDefaultDesign'></span>

<h3>Description</h3>

<p>Creates a default design matrix, wherein all observations (i.e., row items) are in the same group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDefaultDesign(DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createDefaultDesign_+3A_data">DATA</code></td>
<td>
<p>original data that requires a design matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>DESIGN</code></td>
<td>
<p>a column-vector matrix to indicate that all observations are in the same group.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='designCheck'>
designCheck
</h2><span id='topic+designCheck'></span>

<h3>Description</h3>

<p>Checks and/or creates a dummy-coded design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designCheck(DATA, DESIGN = NULL, make_design_nominal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designCheck_+3A_data">DATA</code></td>
<td>
<p>original data that should be matched to a design matrix</p>
</td></tr>
<tr><td><code id="designCheck_+3A_design">DESIGN</code></td>
<td>
<p>a column vector with levels for observations or a dummy-coded matrix</p>
</td></tr>
<tr><td><code id="designCheck_+3A_make_design_nominal">make_design_nominal</code></td>
<td>
<p>a boolean. Will make DESIGN nominal if TRUE (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a properly formatted, dummy-coded (or disjunctive coding) design matrix.
</p>


<h3>Value</h3>

<table>
<tr><td><code>DESIGN</code></td>
<td>
<p>dummy-coded design matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data &lt;- iris[,c(1:4)]
	design &lt;- as.matrix(iris[,c('Species')])
	iris.design &lt;- designCheck(data,DESIGN=design,make_design_nominal=TRUE)
</code></pre>

<hr>
<h2 id='dica.ad'>Alzheimer's Patient-Spouse Dyads.</h2><span id='topic+dica.ad'></span>

<h3>Description</h3>

<p>Conversational data from Alzheimer's Patient-Spouse Dyads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dica.ad)</code></pre>


<h3>Format</h3>

<p>dica.ad$data: Seventeen dyads described by 58 variables.<br />
dica.ad$design: Seventeen dyads that belong to three groups.
</p>


<h3>References</h3>

<p>Williams, L.J., Abdi, H., French, R., &amp; Orange, J.B. (2010). A tutorial on Multi-Block Discriminant Correspondence Analysis (MUDICA): A new method for analyzing discourse data from clinical populations. <em>Journal of Speech Language and Hearing Research</em>,<b> 53</b>, 1372-1393.
</p>

<hr>
<h2 id='dica.wine'>Twelve wines from 3 regions in France with 16 attributes.</h2><span id='topic+dica.wine'></span>

<h3>Description</h3>

<p>This data should be used for discriminant analyses or analyses where the <em>group</em> information is important.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dica.wine)</code></pre>


<h3>Format</h3>

<p>dica.wine$data: Data matrix with twelve wines (rows) from 3 regions with 16 attributes (columns) <em>in disjunctive (0/1) coding</em>.<br />
dica.wine$design: Design matrix with twelve wines (rows) with 3 regions (columns) to indicate group relationship of the data matrix.
</p>


<h3>References</h3>

<p>Abdi, H. (2007). Discriminant correspondence analysis. In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>. Thousand Oaks (CA): Sage. pp. 270-275.
</p>

<hr>
<h2 id='ep.iris'>Fisher's iris Set (for ExPosition)</h2><span id='topic+ep.iris'></span>

<h3>Description</h3>

<p>The world famous Fisher's iris set: 150 flowers from 3 species with 4 attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ep.iris)</code></pre>


<h3>Format</h3>

<p>ep.iris$data: Data matrix with 150 flowers (rows) from 3 species with 4 attributes (columns) describing sepal and petal features.<br />
ep.iris$design: Design matrix with 150 flowers (rows) with 3 species (columns) indicating which flower belongs to which species.
</p>


<h3>Source</h3>

<p>http://en.wikipedia.org/wiki/Iris_flower_data_set
</p>

<hr>
<h2 id='epCA'>
epCA: Correspondence Analysis (CA) via ExPosition.
</h2><span id='topic+epCA'></span>

<h3>Description</h3>

<p>Correspondence Analysis (CA) via ExPosition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epCA(DATA, DESIGN = NULL, make_design_nominal = TRUE, masses = NULL, weights = NULL,
	hellinger = FALSE, symmetric = TRUE, graphs = TRUE, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epCA_+3A_data">DATA</code></td>
<td>
<p>original data to perform a CA on.</p>
</td></tr>
<tr><td><code id="epCA_+3A_design">DESIGN</code></td>
<td>
<p>a design matrix to indicate if rows belong to groups.</p>
</td></tr>
<tr><td><code id="epCA_+3A_make_design_nominal">make_design_nominal</code></td>
<td>
<p>a boolean. If TRUE (default), DESIGN is a vector that indicates groups (and will be dummy-coded). If FALSE, DESIGN is a dummy-coded matrix.</p>
</td></tr>
<tr><td><code id="epCA_+3A_masses">masses</code></td>
<td>
<p>a diagonal matrix or column-vector of masses for the row items.</p>
</td></tr>
<tr><td><code id="epCA_+3A_weights">weights</code></td>
<td>
<p>a diagonal matrix or column-vector of weights for the column it</p>
</td></tr>
<tr><td><code id="epCA_+3A_hellinger">hellinger</code></td>
<td>
<p>a boolean. If FALSE (default), Chi-square distance will be used. If TRUE, Hellinger distance will be used.</p>
</td></tr>
<tr><td><code id="epCA_+3A_symmetric">symmetric</code></td>
<td>
<p>a boolean. If TRUE (default) symmetric factor scores for rows and columns are computed. If FALSE, the simplex (column-based) will be returned.</p>
</td></tr>
<tr><td><code id="epCA_+3A_graphs">graphs</code></td>
<td>
<p>a boolean. If TRUE (default), graphs and plots are provided (via <code><a href="#topic+epGraphs">epGraphs</a></code>)</p>
</td></tr>
<tr><td><code id="epCA_+3A_k">k</code></td>
<td>
<p>number of components to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>epCA</code> performs correspondence analysis. Essentially, a PCA for qualitative data (frequencies, proportions). If you decide to use Hellinger distance, it is best to set <code>symmetric</code> to FALSE.
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+coreCA">coreCA</a></code> for details on what is returned.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.<br />
Abdi, H., and Williams, L.J. (2010). Correspondence analysis. In N.J. Salkind, D.M., Dougherty, &amp; B. Frey (Eds.): <em>Encyclopedia of Research Design</em>. Thousand Oaks (CA): Sage. pp. 267-278.<br />
Abdi, H. (2007). Singular Value Decomposition (SVD) and Generalized Singular Value Decomposition (GSVD). In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>.Thousand Oaks (CA): Sage. pp. 907-912.<br />
Greenacre, M. J. (2007). Correspondence Analysis in Practice. <em>Chapman and Hall</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coreCA">coreCA</a></code>, <code><a href="#topic+epMCA">epMCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(authors)
	ca.authors.res &lt;- epCA(authors$ca$data)
</code></pre>

<hr>
<h2 id='epGPCA'>
epGPCA: Generalized Principal Components Analysis (GPCA) via ExPosition.
</h2><span id='topic+epGPCA'></span>

<h3>Description</h3>

<p>Generalized Principal Components Analysis (GPCA) via ExPosition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epGPCA(DATA, scale = TRUE, center = TRUE, DESIGN = NULL, make_design_nominal = TRUE, 
	masses = NULL, weights = NULL, graphs = TRUE, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epGPCA_+3A_data">DATA</code></td>
<td>
<p>original data to perform a PCA on.</p>
</td></tr>
<tr><td><code id="epGPCA_+3A_scale">scale</code></td>
<td>
<p>a boolean, vector, or string. See <code><a href="#topic+expo.scale">expo.scale</a></code> for details.</p>
</td></tr>
<tr><td><code id="epGPCA_+3A_center">center</code></td>
<td>
<p>a boolean, vector, or string. See <code><a href="#topic+expo.scale">expo.scale</a></code> for details.</p>
</td></tr>
<tr><td><code id="epGPCA_+3A_design">DESIGN</code></td>
<td>
<p>a design matrix to indicate if rows belong to groups.</p>
</td></tr>
<tr><td><code id="epGPCA_+3A_make_design_nominal">make_design_nominal</code></td>
<td>
<p>a boolean. If TRUE (default), DESIGN is a vector that indicates groups (and will be dummy-coded). If FALSE, DESIGN is a dummy-coded matrix.</p>
</td></tr>
<tr><td><code id="epGPCA_+3A_masses">masses</code></td>
<td>
<p>a diagonal matrix or column-vector of masses for the row items.</p>
</td></tr>
<tr><td><code id="epGPCA_+3A_weights">weights</code></td>
<td>
<p>a diagonal matrix or column-vector of weights for the column items.</p>
</td></tr>
<tr><td><code id="epGPCA_+3A_graphs">graphs</code></td>
<td>
<p>a boolean. If TRUE (default), graphs and plots are provided (via <code><a href="#topic+epGraphs">epGraphs</a></code>)</p>
</td></tr>
<tr><td><code id="epGPCA_+3A_k">k</code></td>
<td>
<p>number of components to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>epGPCA</code> performs generalized principal components analysis. Essentially, a PCA with masses and weights for rows and columns, respectively. 
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+corePCA">corePCA</a></code> for details on what is returned. In addition to the values in <code><a href="#topic+corePCA">corePCA</a></code>:<br />
</p>
<table>
<tr><td><code>M</code></td>
<td>
<p>a matrix (or vector, depending on size) of masses for the row items.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>a matrix (or vector, depending on size) of weights for the column items.</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.<br />
Abdi, H. (2007). Singular Value Decomposition (SVD) and Generalized Singular Value Decomposition (GSVD). In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>.Thousand Oaks (CA): Sage. pp. 907-912.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corePCA">corePCA</a></code>, <code><a href="#topic+epPCA">epPCA</a></code>, <code><a href="#topic+epMDS">epMDS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#this is for ExPosition's iris data
	data(ep.iris)
	gpca.iris.res &lt;- epGPCA(ep.iris$data,DESIGN=ep.iris$design,make_design_nominal=FALSE)
</code></pre>

<hr>
<h2 id='epGraphs'>
epGraphs: ExPosition plotting function
</h2><span id='topic+epGraphs'></span>

<h3>Description</h3>

<p>ExPosition plotting function which is an interface to <code><a href="prettyGraphs.html#topic+prettyGraphs">prettyGraphs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epGraphs(res, x_axis = 1, y_axis = 2, epPlotInfo = NULL, DESIGN=NULL, 
	fi.col = NULL, fi.pch = NULL, fj.col = NULL, fj.pch = NULL, col.offset = NULL, 
	constraints = NULL, xlab = NULL, ylab = NULL, main = NULL, 
	contributionPlots = TRUE, correlationPlotter = TRUE,
	graphs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epGraphs_+3A_res">res</code></td>
<td>
<p>results from ExPosition</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_x_axis">x_axis</code></td>
<td>
<p>which component should be on the x axis?</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_y_axis">y_axis</code></td>
<td>
<p>which component should be on the y axis?</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_epplotinfo">epPlotInfo</code></td>
<td>
<p>A list (<code>$Plotting.Data</code>) from <code>epGraphs</code> or <code>ExPosition</code>.</p>
</td></tr>    
<tr><td><code id="epGraphs_+3A_design">DESIGN</code></td>
<td>
<p>A design matrix to apply colors (by pallete selection) to row items</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_fi.col">fi.col</code></td>
<td>
<p>A matrix of colors for the row items. If NULL, colors will be selected.</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_fi.pch">fi.pch</code></td>
<td>
<p>A matrix of pch values for the row items. If NULL, pch values are all 21.</p>
</td></tr>  
<tr><td><code id="epGraphs_+3A_fj.col">fj.col</code></td>
<td>
<p>A matrix of colors for the column items. If NULL, colors will be selected.</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_fj.pch">fj.pch</code></td>
<td>
<p>A matrix of pch values for the column items. If NULL, pch values are all 21.</p>
</td></tr>    
<tr><td><code id="epGraphs_+3A_col.offset">col.offset</code></td>
<td>
<p>A numeric offset value. Is passed to <code><a href="prettyGraphs.html#topic+createColorVectorsByDesign">createColorVectorsByDesign</a></code>.</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_constraints">constraints</code></td>
<td>
<p>Plot constraints as returned from <code><a href="prettyGraphs.html#topic+prettyPlot">prettyPlot</a></code>. If NULL, constraints are selected.</p>
</td></tr>      
<tr><td><code id="epGraphs_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_main">main</code></td>
<td>
<p>main label for the graph window</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_contributionplots">contributionPlots</code></td>
<td>
<p>a boolean. If TRUE (default), contribution bar plots will be created.</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_correlationplotter">correlationPlotter</code></td>
<td>
<p>a boolean. If TRUE (default), a correlation circle plot will be created. Applies to PCA family of methods (CA is excluded for now).</p>
</td></tr>
<tr><td><code id="epGraphs_+3A_graphs">graphs</code></td>
<td>
<p>a boolean. If TRUE, graphs are created. If FALSE, only data associated to plotting (e.g., constraints, colors) are returned.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>epGraphs is an interface between <code><a href="#topic+ExPosition">ExPosition</a></code> and <code><a href="prettyGraphs.html#topic+prettyGraphs">prettyGraphs</a></code>. 
</p>


<h3>Value</h3>

<p>The following items are bundled inside of $Plotting.Data:<br />
</p>
<table>
<tr><td><code>$fi.col</code></td>
<td>
<p>the colors that are associated to the row items ($fi).</p>
</td></tr>
<tr><td><code>$fi.pch</code></td>
<td>
<p>the pch values associated to the row items ($fi).</p>
</td></tr>
<tr><td><code>$fj.col</code></td>
<td>
<p>the colors that are associated to the column items ($fj).</p>
</td></tr>
<tr><td><code>$fj.pch</code></td>
<td>
<p>the pch values associated to the column items ($fj).</p>
</td></tr>
<tr><td><code>$constraints</code></td>
<td>
<p>axis constraints for the plots (determines end points of the plots).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>See Also</h3>

<p><code><a href="prettyGraphs.html#topic+prettyGraphs">prettyGraphs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#this is for ExPosition's iris data
	data(ep.iris)
	pca.iris.res &lt;- epPCA(ep.iris$data)
	#this will put plotting data into a new variable.
	epGraphs.2.and.3 &lt;- epGraphs(pca.iris.res,x_axis=2,y_axis=3)
</code></pre>

<hr>
<h2 id='epMCA'>
epMCA: Multiple Correspondence Analysis (MCA) via ExPosition.
</h2><span id='topic+epMCA'></span>

<h3>Description</h3>

<p>Multiple Correspondence Analysis (MCA) via ExPosition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epMCA(DATA, make_data_nominal = TRUE, DESIGN = NULL, make_design_nominal = TRUE, 
	masses = NULL, weights = NULL, hellinger = FALSE, 
	symmetric = TRUE, correction = c("b"), graphs = TRUE, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epMCA_+3A_data">DATA</code></td>
<td>
<p>original data to perform a MCA on. This data can be in original formatting (qualitative levels) or in dummy-coded variables.</p>
</td></tr>
<tr><td><code id="epMCA_+3A_make_data_nominal">make_data_nominal</code></td>
<td>
<p>a boolean. If TRUE (default), DATA is recoded as a dummy-coded matrix. If FALSE, DATA is a dummy-coded matrix.</p>
</td></tr>
<tr><td><code id="epMCA_+3A_design">DESIGN</code></td>
<td>
<p>a design matrix to indicate if rows belong to groups.</p>
</td></tr>
<tr><td><code id="epMCA_+3A_make_design_nominal">make_design_nominal</code></td>
<td>
<p>a boolean. If TRUE (default), DESIGN is a vector that indicates groups (and will be dummy-coded). If FALSE, DESIGN is a dummy-coded matrix.</p>
</td></tr>
<tr><td><code id="epMCA_+3A_masses">masses</code></td>
<td>
<p>a diagonal matrix or column-vector of masses for the row items.</p>
</td></tr>
<tr><td><code id="epMCA_+3A_weights">weights</code></td>
<td>
<p>a diagonal matrix or column-vector of weights for the column it</p>
</td></tr>
<tr><td><code id="epMCA_+3A_hellinger">hellinger</code></td>
<td>
<p>a boolean. If FALSE (default), Chi-square distance will be used. If TRUE, Hellinger distance will be used.</p>
</td></tr>
<tr><td><code id="epMCA_+3A_symmetric">symmetric</code></td>
<td>
<p>a boolean. If TRUE symmetric factor scores for rows.</p>
</td></tr>
<tr><td><code id="epMCA_+3A_correction">correction</code></td>
<td>
<p>which corrections should be applied? &quot;b&quot; = Benzécri correction, &quot;bg&quot; = Greenacre adjustment to Benzécri correction.</p>
</td></tr>
<tr><td><code id="epMCA_+3A_graphs">graphs</code></td>
<td>
<p>a boolean. If TRUE (default), graphs and plots are provided (via <code><a href="#topic+epGraphs">epGraphs</a></code>)</p>
</td></tr>
<tr><td><code id="epMCA_+3A_k">k</code></td>
<td>
<p>number of components to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>epMCA</code> performs multiple correspondence analysis. Essentially, a CA for categorical data. <br />
It should be noted that when <code>hellinger</code> is selected as TRUE, no correction will be performed. Additionally, if you decide to use Hellinger, it is best to set <code>symmetric</code> to FALSE.
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+coreCA">coreCA</a></code> for details on what is returned. In addition to the values returned:<br />
</p>
<table>
<tr><td><code>$pdq</code></td>
<td>
<p>this is the corrected SVD data, if a correction was selected. If no correction was selected, it is uncorrected.</p>
</td></tr>
<tr><td><code>$pdq.uncor</code></td>
<td>
<p>uncorrected SVD data.</p>
</td></tr>		
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.<br />
Abdi, H., and Williams, L.J. (2010). Correspondence analysis. In N.J. Salkind, D.M., Dougherty, &amp; B. Frey (Eds.): <em>Encyclopedia of Research Design</em>. Thousand Oaks (CA): Sage. pp. 267-278.<br />
Abdi, H. (2007). Singular Value Decomposition (SVD) and Generalized Singular Value Decomposition (GSVD). In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>.Thousand Oaks (CA): Sage. pp. 907-912.<br />
Benzécri, J. P. (1979). Sur le calcul des taux d'inertie dans l'analyse d'un questionnaire. <em>Cahiers de l'Analyse des Données</em>, <b>4</b>, 377-378.<br />
Greenacre, M. J. (2007). Correspondence Analysis in Practice. <em>Chapman and Hall</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coreCA">coreCA</a></code>, <code><a href="#topic+epCA">epCA</a></code>, <code><a href="#topic+mca.eigen.fix">mca.eigen.fix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(mca.wine)
	mca.wine.res &lt;- epMCA(mca.wine$data)
</code></pre>

<hr>
<h2 id='epMDS'>
epMDS: Multidimensional Scaling (MDS) via ExPosition. 
</h2><span id='topic+epMDS'></span>

<h3>Description</h3>

<p>Multidimensional Scaling (MDS) via ExPosition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epMDS(DATA, DATA_is_dist = TRUE, method="euclidean", DESIGN = NULL, 
	make_design_nominal = TRUE, masses = NULL, graphs = TRUE, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epMDS_+3A_data">DATA</code></td>
<td>
<p>original data to perform a MDS on.</p>
</td></tr>
<tr><td><code id="epMDS_+3A_data_is_dist">DATA_is_dist</code></td>
<td>
<p>a boolean. If TRUE (default) the DATA matrix should be a symmetric distance matrix. If FALSE, a Euclidean distance of row items will be computed and used.</p>
</td></tr>
<tr><td><code id="epMDS_+3A_method">method</code></td>
<td>
<p>which distance metric should be used. <code>method</code> matches <code><a href="stats.html#topic+dist">dist</a></code>; Two additional distances are avaialble: &quot;correlation&quot; and &quot;chi2&quot;. For &quot;chi2&quot; see <code><a href="#topic+chi2Dist">chi2Dist</a></code>. Default is &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="epMDS_+3A_design">DESIGN</code></td>
<td>
<p>a design matrix to indicate if rows belong to groups.</p>
</td></tr>
<tr><td><code id="epMDS_+3A_make_design_nominal">make_design_nominal</code></td>
<td>
<p>a boolean. If TRUE (default), DESIGN is a vector that indicates groups (and will be dummy-coded). If FALSE, DESIGN is a dummy-coded matrix.</p>
</td></tr>
<tr><td><code id="epMDS_+3A_masses">masses</code></td>
<td>
<p>a diagonal matrix (or vector) that contains the masses (for the row items).</p>
</td></tr>
<tr><td><code id="epMDS_+3A_graphs">graphs</code></td>
<td>
<p>a boolean. If TRUE (default), graphs and plots are provided (via <code><a href="#topic+epGraphs">epGraphs</a></code>)</p>
</td></tr>
<tr><td><code id="epMDS_+3A_k">k</code></td>
<td>
<p>number of components to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>epMDS</code> performs metric multi-dimensional scaling. Essentially, a PCA for a symmetric distance matrix. 
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+coreMDS">coreMDS</a></code> for details on what is returned. epMDS only returns values related to row items (e.g., fi, ci); no column data is returned.
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>the distance matrix that was decomposed. In most cases, it is returned as a squared distance.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>With respect to input of <code>DATA</code>, <code>epMDS</code> differs slightly from other versions of multi-dimensional scaling. <br />
If you provide a rectangular matrix (e.g., observations x measures), <code>epMDS</code> will compute a distance matrix and square it. <br />
If you provide a distance (dissimilarity) matrix, <code>epMDS</code> does not square it.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>References</h3>

<p>Abdi, H. (2007). Metric multidimensional scaling. In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics.</em> Thousand Oaks (CA): Sage. pp. 598-605. <br />
O'Toole, A. J., Jiang, F., Abdi, H., and Haxby, J. V. (2005). Partially distributed representations of objects and faces in ventral temporal cortex. <em>Journal of Cognitive Neuroscience</em>, <em>17</em>(4), 580-590. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corePCA">corePCA</a></code>, <code><a href="#topic+epPCA">epPCA</a></code>, <code><a href="#topic+epGPCA">epGPCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	data(jocn.2005.fmri)
	#by default, components 1 and 2 will be plotted.
	mds.res.images &lt;- epMDS(jocn.2005.fmri$images$data)

	##iris example
	data(ep.iris)
	iris.rectangular &lt;- epMDS(ep.iris$data,DATA_is_dist=FALSE)
	iris.euc.dist &lt;- dist(ep.iris$data,upper=TRUE,diag=TRUE)
	iris.sq.euc.dist &lt;- as.matrix(iris.euc.dist^2)
	iris.sq &lt;- epMDS(iris.sq.euc.dist)
</code></pre>

<hr>
<h2 id='epPCA'>
epPCA: Principal Component Analysis (PCA) via ExPosition.
</h2><span id='topic+epPCA'></span>

<h3>Description</h3>

<p>Principal Component Analysis (PCA) via ExPosition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epPCA(DATA, scale = TRUE, center = TRUE, DESIGN = NULL, make_design_nominal = TRUE, 
	graphs = TRUE, k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epPCA_+3A_data">DATA</code></td>
<td>
<p>original data to perform a PCA on.</p>
</td></tr>
<tr><td><code id="epPCA_+3A_scale">scale</code></td>
<td>
<p>a boolean, vector, or string. See <code><a href="#topic+expo.scale">expo.scale</a></code> for details.</p>
</td></tr>
<tr><td><code id="epPCA_+3A_center">center</code></td>
<td>
<p>a boolean, vector, or string. See <code><a href="#topic+expo.scale">expo.scale</a></code> for details.</p>
</td></tr>
<tr><td><code id="epPCA_+3A_design">DESIGN</code></td>
<td>
<p>a design matrix to indicate if rows belong to groups.</p>
</td></tr>
<tr><td><code id="epPCA_+3A_make_design_nominal">make_design_nominal</code></td>
<td>
<p>a boolean. If TRUE (default), DESIGN is a vector that indicates groups (and will be dummy-coded). If FALSE, DESIGN is a dummy-coded matrix.</p>
</td></tr>
<tr><td><code id="epPCA_+3A_graphs">graphs</code></td>
<td>
<p>a boolean. If TRUE (default), graphs and plots are provided (via <code><a href="#topic+epGraphs">epGraphs</a></code>)</p>
</td></tr>
<tr><td><code id="epPCA_+3A_k">k</code></td>
<td>
<p>number of components to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>epPCA</code> performs principal components analysis on a data matrix. 
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+corePCA">corePCA</a></code> for details on what is returned.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.<br />
Abdi, H. (2007). Singular Value Decomposition (SVD) and Generalized Singular Value Decomposition (GSVD). In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>.Thousand Oaks (CA): Sage. pp. 907-912.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corePCA">corePCA</a></code>, <code><a href="#topic+epMDS">epMDS</a></code>, <code><a href="#topic+epGPCA">epGPCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(words)
	pca.words.res &lt;- epPCA(words$data)
</code></pre>

<hr>
<h2 id='expo.scale'>
Scaling functions for ExPosition.
</h2><span id='topic+expo.scale'></span>

<h3>Description</h3>

<p><code>expo.scale</code> is a more elaborate, and complete, version of <code><a href="base.html#topic+scale">scale</a></code>. Several text options are available, but more importantly, the center and scale factors are <em>always</em> returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expo.scale(DATA, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expo.scale_+3A_data">DATA</code></td>
<td>
<p>Data to center, scale, or both.</p>
</td></tr>
<tr><td><code id="expo.scale_+3A_center">center</code></td>
<td>
<p>boolean, or (numeric) vector. If boolean or vector, it works just as <code><a href="base.html#topic+scale">scale</a></code>.</p>
</td></tr>
<tr><td><code id="expo.scale_+3A_scale">scale</code></td>
<td>
<p>boolean, text, or (numeric) vector. If boolean or vector, it works just as <code><a href="base.html#topic+scale">scale</a></code>. The following text options are available: 'z': z-score normalization, 'sd': standard deviation normalization, 'rms': root mean square normalization, 'ss1': sum of squares (of columns) equals 1 normalization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data matrix that is scaled with the following <code>attributes</code> (see <code><a href="base.html#topic+scale">scale</a></code>):<br />
</p>
<table>
<tr><td><code>$`scaled:center`</code></td>
<td>
<p>The center of the data. If no center is provided, all 0s will be returned.</p>
</td></tr>
<tr><td><code>$`scaled:scale`</code></td>
<td>
<p>The scale factor of the data. If no scale is provided, all 1s will be returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='ExPosition-package'>
ExPosition: <em>Ex</em>ploratory Analysis with the Singular Value Decom<em>Position</em>
</h2><span id='topic+ExPosition-package'></span><span id='topic+ExPosition'></span>

<h3>Description</h3>

<p>Exposition is defined as <em>a comprehensive explanation of an idea</em>. With ExPosition for R, a comprehensive explanation of your data will be provided with minimal effort.<br /><br />
The core of ExPosition is the singular value decomposition (SVD; see: <code><a href="base.html#topic+svd">svd</a></code>). The point of ExPosition is simple: to provide the user with an overview of their data that only the SVD can provide. ExPosition includes several techniques that depend on the SVD (see below for examples and functions).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ExPosition</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.8.23</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-12-27</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;=2.15.0), prettyGraphs (&gt;= 2.1.4)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/derekbeaton/ExPosition-Family_OLD</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Questions, comments, compliments, and complaints go to Derek Beaton <a href="mailto:exposition.software@gmail.com">exposition.software@gmail.com</a>.<br /><br />
</p>
<p>The following people are authors or contributors to ExPosition code, data, or examples:<br />
Derek Beaton, Hervé Abdi, Cherise Chin-Fatt, Joseph Dunlop, Jenny Rieck, Rachel Williams,  Anjali Krishnan, and Francesca M. Filbey.
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.<br />
Abdi, H. and Williams, L.J. (2010). Correspondence analysis. In N.J. Salkind, D.M., Dougherty, &amp; B. Frey (Eds.): <em>Encyclopedia of Research Design</em>. Thousand Oaks (CA): Sage. pp. 267-278.<br />
Abdi, H. (2007). Singular Value Decomposition (SVD) and Generalized Singular Value Decomposition (GSVD). In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>.Thousand Oaks (CA): Sage. pp. 907-912.<br />
Abdi, H. (2007). Metric multidimensional scaling. In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics.</em> Thousand Oaks (CA): Sage. pp. 598-605.<br />
Greenacre, M. J. (2007). Correspondence Analysis in Practice. <em>Chapman and Hall</em>.<br />
Benzécri, J. P. (1979). Sur le calcul des taux d'inertie dans l'analyse d'un questionnaire. <em>Cahiers de l'Analyse des Données</em>, <b>4</b>, 377-378.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epPCA">epPCA</a></code>, <code><a href="#topic+epGPCA">epGPCA</a></code>, <code><a href="#topic+epMDS">epMDS</a></code>, <code><a href="#topic+epCA">epCA</a></code>, <code><a href="#topic+epMCA">epMCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#For more examples, see each individual function (as noted above).
</code></pre>

<hr>
<h2 id='faces2005'>Faces analyzed using Four Algorithms</h2><span id='topic+faces2005'></span>

<h3>Description</h3>

<p>Four algorithms compared using a distance matrix between six faces. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(faces2005)</code></pre>


<h3>Format</h3>

<p>faces2005$data: A data structure representing a distance matrix (6X6) for four algorithms.
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D. (2007). DISTATIS: the analysis of multiple distance matrices. <em>Encyclopedia of Measurement and Statistics</em>. 284-290.
</p>

<hr>
<h2 id='french.social'>How twelve French families spend their income on groceries.</h2><span id='topic+french.social'></span>

<h3>Description</h3>

<p>This data should be used with <code><a href="#topic+epPCA">epPCA</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(french.social)</code></pre>


<h3>Format</h3>

<p>french.social$data: Data matrix with twelve families (rows) with 7 attributes (columns) describing what they spend their income on.
</p>


<h3>References</h3>

<p>Lebart, L., and Fénelon, J.P. (1975) <em>Statistique et informatique appliquées</em>. Paris: Dunod<br />
Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.
</p>

<hr>
<h2 id='genPDQ'>
genPDQ: the GSVD
</h2><span id='topic+genPDQ'></span>

<h3>Description</h3>

<p>genPDQ performs the SVD and GSVD for all methods in <code><a href="#topic+ExPosition">ExPosition</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPDQ(datain, M = NULL, W = NULL, is.mds = FALSE, decomp.approach = "svd", k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genPDQ_+3A_datain">datain</code></td>
<td>
<p>fully preprocessed data to be decomposed.</p>
</td></tr>
<tr><td><code id="genPDQ_+3A_m">M</code></td>
<td>
<p>vector or diagonal matrix of masses (for the rows)</p>
</td></tr>
<tr><td><code id="genPDQ_+3A_w">W</code></td>
<td>
<p>vector or diagonal matrix of weights (for the columns)</p>
</td></tr>
<tr><td><code id="genPDQ_+3A_is.mds">is.mds</code></td>
<td>
<p>a boolean. If the method is of MDS (e.g., <code><a href="#topic+epMDS">epMDS</a></code>), use TRUE. All other methods: FALSE</p>
</td></tr>
<tr><td><code id="genPDQ_+3A_decomp.approach">decomp.approach</code></td>
<td>
<p>a string. Allows for the user to choose which decomposition method to perform. Current options are SVD or Eigen.</p>
</td></tr>
<tr><td><code id="genPDQ_+3A_k">k</code></td>
<td>
<p>number of components to return (this is not a rotation, just an <em>a priori</em> selection of how much data should be returned).</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function should only be used to create new methods based on the SVD or GSVD. 
</p>


<h3>Value</h3>

<p>Data of class <code>epSVD</code> which is a list of matrices and vectors:<br />
</p>
<table>
<tr><td><code>P</code></td>
<td>
<p>The left singular vectors (rows).</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>The right singular vectors (columns).</p>
</td></tr>
<tr><td><code>Dv</code></td>
<td>
<p>Vector of the singular values.</p>
</td></tr>
<tr><td><code>Dd</code></td>
<td>
<p>Diagonal matrix of the singular values.</p>
</td></tr>
<tr><td><code>ng</code></td>
<td>
<p>Number of singular values/vectors</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Rank of the decomposed matrix. If it is 1, 0s are padded to the above items for plotting purposes.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Explained variance per component</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pickSVD">pickSVD</a></code>
</p>

<hr>
<h2 id='great.beer.tasting.1'>A collection of beer tasting notes from untrained assessors.</h2><span id='topic+great.beer.tasting.1'></span>

<h3>Description</h3>

<p>A collection of beer tasting notes of 9 beers, across 16 descriptors, from 4 untrained assessors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(great.beer.tasting.1)</code></pre>


<h3>Format</h3>

<p>great.beer.tasting.1$data: Data matrix (cube). Tasting notes (ratings) of 9 different beers (rows) described by 16 different flavor profiles (columns) by 4 untrained assessors. Thes data contain NAs and must be imputed or adjusted before an analysis is performed.<br />
great.beer.tasting.1$brewery.design: Design matrix. Source brewery of 9 different beers (rows) across 5 breweries (columns). <br />
great.beer.tasting.1$flavor: Design matrix. Intended prominent flavor of 9 different beers (rows) across 3 flavor profiles (columns).
</p>


<h3>Source</h3>

<p>Rachel Williams, Jenny Rieck and Derek Beaton recoded, collected data and/or &ldquo;ran the experiment&rdquo;.
</p>

<hr>
<h2 id='great.beer.tasting.2'>A collection of beer tasting notes from untrained assessors.</h2><span id='topic+great.beer.tasting.2'></span>

<h3>Description</h3>

<p>A collection of beer tasting notes of 13 beers, across 15 descriptors, from 9 untrained assessors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(great.beer.tasting.2)</code></pre>


<h3>Format</h3>

<p>great.beer.tasting.2$data: Data matrix (cube). Tasting notes (ratings) of 13 different beers (rows) described by 15 different flavor profiles (columns) by 9 untrained assessors. All original values were on an interval scale of 0-5. Any decimal values are imputed from alternate data sources or additional assessors.<br />
great.beer.tasting.2$brewery.design: Design matrix. Source brewery of 13 different beers (rows) across 13 breweries (columns). <br />
great.beer.tasting.2$style.design: Design matrix. Style of 13 different beers (rows) across 8 styles (columns). Some complex styles were truncated.
</p>


<h3>Source</h3>

<p>Rachel Williams, Jenny Rieck and Derek Beaton recoded, collected data and/or &ldquo;ran the experiment&rdquo;.
</p>

<hr>
<h2 id='hellingerNorm'>
Hellinger version of CA preprocessing
</h2><span id='topic+hellingerNorm'></span>

<h3>Description</h3>

<p>Performs all steps required for Hellinger form of CA processing (row profile approach).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hellingerNorm(X, X_dimensions, colTotal, rowTotal, grandTotal, 
	weights = NULL, masses = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hellingerNorm_+3A_x">X</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="hellingerNorm_+3A_x_dimensions">X_dimensions</code></td>
<td>
<p>The dimensions of X in a vector of length 2 (rows, columns). See <code><a href="base.html#topic+dim">dim</a></code></p>
</td></tr>
<tr><td><code id="hellingerNorm_+3A_coltotal">colTotal</code></td>
<td>
<p>Vector of column sums.</p>
</td></tr>
<tr><td><code id="hellingerNorm_+3A_rowtotal">rowTotal</code></td>
<td>
<p>Vector of row sums.</p>
</td></tr>
<tr><td><code id="hellingerNorm_+3A_grandtotal">grandTotal</code></td>
<td>
<p>Grand total of X</p>
</td></tr>
<tr><td><code id="hellingerNorm_+3A_weights">weights</code></td>
<td>
<p>Optional weights to include for the columns.</p>
</td></tr>
<tr><td><code id="hellingerNorm_+3A_masses">masses</code></td>
<td>
<p>Optional masses to include for the rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>rowCenter</code></td>
<td>
<p>The barycenter of X.</p>
</td></tr>
<tr><td><code>masses</code></td>
<td>
<p>Masses to be used for the GSVD.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Weights to be used for the GSVD.</p>
</td></tr>
<tr><td><code>rowProfiles</code></td>
<td>
<p>The row profiles of X.</p>
</td></tr>
<tr><td><code>deviations</code></td>
<td>
<p>Deviations of row profiles from <code>rowCenter</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Hervé Abdi
</p>

<hr>
<h2 id='hellingerSupplementaryColsPreProcessing'>
Preprocessing for supplementary columns in Hellinger analyses.
</h2><span id='topic+hellingerSupplementaryColsPreProcessing'></span>

<h3>Description</h3>

<p>Preprocessing for supplementary columns in Hellinger analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hellingerSupplementaryColsPreProcessing(SUP.DATA, W = NULL, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hellingerSupplementaryColsPreProcessing_+3A_sup.data">SUP.DATA</code></td>
<td>
<p>A supplemental matrix that has the same number of rows as an active data set.</p>
</td></tr>
<tr><td><code id="hellingerSupplementaryColsPreProcessing_+3A_w">W</code></td>
<td>
<p>A vector or matrix of Weights. If none are provided, a default is computed.</p>
</td></tr>
<tr><td><code id="hellingerSupplementaryColsPreProcessing_+3A_m">M</code></td>
<td>
<p>A vector or matrix of Masses. If none are provided, a default is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that has been preprocessed to project supplementary rows for Hellinger methods.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='hellingerSupplementaryRowsPreProcessing'>
Preprocessing for supplementary rows in Hellinger analyses.
</h2><span id='topic+hellingerSupplementaryRowsPreProcessing'></span>

<h3>Description</h3>

<p>Preprocessing for supplementary rows in Hellinger analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hellingerSupplementaryRowsPreProcessing(SUP.DATA, center = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hellingerSupplementaryRowsPreProcessing_+3A_sup.data">SUP.DATA</code></td>
<td>
<p>A supplemental matrix that has the same number of rows as an active data set.</p>
</td></tr>
<tr><td><code id="hellingerSupplementaryRowsPreProcessing_+3A_center">center</code></td>
<td>
<p>The center from the active data. NULL will center <code>SUP.DATA</code> to itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that has been preprocessed to project supplementary columns for Hellinger methods.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='jlsr.2010.ad'>Data from 17 Alzheimer's Patient-Spouse dyads.</h2><span id='topic+jlsr.2010.ad'></span>

<h3>Description</h3>

<p>Seventeen Alzheimer's Patient-Spouse Dyads had conversations recorded and 58 attributes were recoded for this data. Each attribute is a frequency of occurence of the item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jlsr.2010.ad)</code></pre>


<h3>Format</h3>

<p>jlsr.2010.ad$ca$data: Seventeen patient-spouse dyads (rows) described by 58 conversation items. For use with <code><a href="#topic+epCA">epCA</a></code> and discriminant analyses.<br />
jlsr.2010.ad$mca$design: A design matrix that indicates which group the dyad belongs to: control (CTRL), early stage Alzheimer's (EDAT) or middle stage Alzheimer's (MDAT).
</p>


<h3>References</h3>

<p>Williams, L.J., Abdi, H., French, R., and Orange, J.B. (2010). A tutorial on Multi-Block Discriminant Correspondence Analysis (MUDICA): A new method for analyzing discourse data from clinical populations. <em>Journal of Speech Language and Hearing Research</em>, 53, 1372-1393.
</p>

<hr>
<h2 id='jocn.2005.fmri'>Data of categories of images as view in an <em>f</em>MRI experiment.</h2><span id='topic+jocn.2005.fmri'></span>

<h3>Description</h3>

<p>Contains 2 data sets: distance matrix of <em>f</em>MRI scans of participants viewing categories of items and distance matrix of the actual pixels from the images in each category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jocn.2005.fmri)</code></pre>


<h3>Format</h3>

<p>jocn.2005.fmri$images$data: A distance matrix of 6 categories of images based on a pixel analysis. <br />
jocn.2005.fmri$scans$data: A distance matrix of 6 categories of images based on <em>f</em>MRI scans.
</p>


<h3>References</h3>

<p>O'Toole, A. J., Jiang, F., Abdi, H., and Haxby, J. V. (2005). Partially distributed representations of objects and faces in ventral temporal cortex. <em>Journal of Cognitive Neuroscience</em>, <em>17</em>(4), 580-590. <br />
Haxby, J. V., Gobbini, M. I., Furey, M. L., Ishai, A., Schouten, J. L., and Pietrini, P. (2001). Distributed and overlapping representation of faces and objects in ventral temporal cortex. <em>Science</em>, 293, 2425-2430.<br />
</p>


<h3>See Also</h3>

<p>http://openfmri.org/dataset/ds000105
</p>

<hr>
<h2 id='makeDistancesAndWeights'>
Makes distances and weights for MDS analyses (see <code><a href="#topic+epMDS">epMDS</a></code>).
</h2><span id='topic+makeDistancesAndWeights'></span>

<h3>Description</h3>

<p>Makes distances and weights for MDS analyses (see <code><a href="#topic+epMDS">epMDS</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDistancesAndWeights(DATA, method = "euclidean", masses = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDistancesAndWeights_+3A_data">DATA</code></td>
<td>
<p>A data matrix to compute distances between row items.</p>
</td></tr>
<tr><td><code id="makeDistancesAndWeights_+3A_method">method</code></td>
<td>
<p>which distance metric should be used. <code>method</code> matches <code><a href="stats.html#topic+dist">dist</a></code>; Two additional distances are avaialble: &quot;correlation&quot; and &quot;chi2&quot;. For &quot;chi2&quot; see <code><a href="#topic+chi2Dist">chi2Dist</a></code>. Default is &quot;euclidean&quot;.</p>
</td></tr>
<tr><td><code id="makeDistancesAndWeights_+3A_masses">masses</code></td>
<td>
<p>a diagonal matrix (or vector) that contains the masses (for the row items).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>Distance matrix for analysis</p>
</td></tr>
<tr><td><code>MW</code></td>
<td>
<p>a list item with masses and weights. Weights are not used in <code><a href="#topic+epMDS">epMDS</a></code>.</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>See Also</h3>

<p><code>link{computeMW}</code>,	<code>link{epMDS}</code>,	<code>link{coreMDS}</code>
</p>

<hr>
<h2 id='makeNominalData'>
makeNominalData
</h2><span id='topic+makeNominalData'></span>

<h3>Description</h3>

<p>Transforms each column into measure-response columns with disjunctive (0/1) coding. If NA is found somewhere in matrix, barycentric recoding is peformed for the missing value(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNominalData(datain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeNominalData_+3A_datain">datain</code></td>
<td>
<p>a data matrix where the <em>columns</em> will be recoded.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>dataout</code></td>
<td>
<p>a transformed version of <em>datain</em>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epMCA">epMCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(mca.wine)
	nominal.wine &lt;- makeNominalData(mca.wine$data)
</code></pre>

<hr>
<h2 id='makeRowProfiles'>
Preprocessing for CA-based analyses
</h2><span id='topic+makeRowProfiles'></span>

<h3>Description</h3>

<p>This function performs all preprocessing steps required for Correspondence Analysis-based preprocessing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRowProfiles(X, weights = NULL, masses = NULL, hellinger = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeRowProfiles_+3A_x">X</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="makeRowProfiles_+3A_weights">weights</code></td>
<td>
<p>optional. Weights to include in preprocessing.</p>
</td></tr>
<tr><td><code id="makeRowProfiles_+3A_masses">masses</code></td>
<td>
<p>optional. Masses to include in preprocessing.</p>
</td></tr>
<tr><td><code id="makeRowProfiles_+3A_hellinger">hellinger</code></td>
<td>
<p>a boolean. If TRUE, Hellinger preprocessing is used. Else, CA row profile is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns from <code>link{hellingerNorm}</code> or <code><a href="#topic+caNorm">caNorm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='mca.eigen.fix'>
mca.eigen.fix
</h2><span id='topic+mca.eigen.fix'></span>

<h3>Description</h3>

<p>A function for correcting the eigenvalues and output from multiple correspondence analysis (MCA, <code><a href="#topic+epMCA">epMCA</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mca.eigen.fix(DATA, mca.results, make_data_nominal = TRUE, numVariables = NULL, 
correction = c("b"), symmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mca.eigen.fix_+3A_data">DATA</code></td>
<td>
<p>original data (i.e., not transformed into disjunctive coding)</p>
</td></tr>
<tr><td><code id="mca.eigen.fix_+3A_mca.results">mca.results</code></td>
<td>
<p>output from <code><a href="#topic+epMCA">epMCA</a></code></p>
</td></tr>
<tr><td><code id="mca.eigen.fix_+3A_make_data_nominal">make_data_nominal</code></td>
<td>
<p>a boolean. Should <em>DATA</em> be transformed into disjunctive coding? Default is TRUE.</p>
</td></tr>
<tr><td><code id="mca.eigen.fix_+3A_numvariables">numVariables</code></td>
<td>
<p>the number of actual measures/variables in the data (typically the number of columns in <em>DATA</em>)</p>
</td></tr>
<tr><td><code id="mca.eigen.fix_+3A_correction">correction</code></td>
<td>
<p>which corrections should be applied? &quot;b&quot; = Benzécri correction, &quot;bg&quot; = Greenacre adjustment to Benzécri correction.</p>
</td></tr>
<tr><td><code id="mca.eigen.fix_+3A_symmetric">symmetric</code></td>
<td>
<p>a boolean. If the results from MCA are symmetric or asymmetric factor scores. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mca.results</code></td>
<td>
<p>a modified version of mca.results. Factor scores (e.g., $fi, $fj), and $pdq are updated based on corrections chosen.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>References</h3>

<p>Benzécri, J. P. (1979). Sur le calcul des taux d'inertie dans l'analyse d'un questionnaire. <em>Cahiers de l'Analyse des Données</em>, <b>4</b>, 377-378.<br />
Greenacre, M. J. (2007). Correspondence Analysis in Practice. <em>Chapman and Hall</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epMCA">epMCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(mca.wine)
	#No corrections used in MCA
	mca.wine.res.uncor &lt;- epMCA(mca.wine$data,correction=NULL)
	data &lt;- mca.wine$data
	expo.output &lt;- mca.wine.res.uncor$ExPosition.Data
	#mca.eigen.fix with just Benzécri correction		
	mca.wine.res.b &lt;- mca.eigen.fix(data, expo.output,correction=c('b'))
	#mca.eigen.fix with Benzécri + Greenacre adjustment	
	mca.wine.res.bg &lt;- mca.eigen.fix(data,expo.output,correction=c('b','g'))
</code></pre>

<hr>
<h2 id='mca.wine'>Six wines described by several assessors with qualitative attributes.</h2><span id='topic+mca.wine'></span>

<h3>Description</h3>

<p>Six wines described by several assessors with qualitative attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mca.wine)</code></pre>


<h3>Format</h3>

<p>mca.wine$data: A (categorical) data matrix with 6 wines (rows) from several assessors described by 10 attributes (columns). For use with <code><a href="#topic+epMCA">epMCA</a></code>.
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D. (2007). Multiple correspondence analysis. In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>. Thousand Oaks (CA): Sage. pp. 651-657.
</p>

<hr>
<h2 id='mdsSupplementalElementsPreProcessing'>
MDS preprocessing
</h2><span id='topic+mdsSupplementalElementsPreProcessing'></span>

<h3>Description</h3>

<p>Preprocessing of supplemental data for MDS analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdsSupplementalElementsPreProcessing(SUP.DATA = NULL, D = NULL, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdsSupplementalElementsPreProcessing_+3A_sup.data">SUP.DATA</code></td>
<td>
<p>A supplementary data matrix.</p>
</td></tr>
<tr><td><code id="mdsSupplementalElementsPreProcessing_+3A_d">D</code></td>
<td>
<p>The original (active) distance matrix that <code>SUP.DATA</code> is supplementary to.</p>
</td></tr>
<tr><td><code id="mdsSupplementalElementsPreProcessing_+3A_m">M</code></td>
<td>
<p>masses from the original (active) analysis for <code>D</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that is preprocessed for supplementary projection in MDS.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='mdsTransform'>
Transform data for MDS analysis.
</h2><span id='topic+mdsTransform'></span>

<h3>Description</h3>

<p>Transform data for MDS analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdsTransform(D, masses)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdsTransform_+3A_d">D</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code id="mdsTransform_+3A_masses">masses</code></td>
<td>
<p>A vector or matrix of masses (see <code>computeMW</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>S</code></td>
<td>
<p>a preprocessed matrix that can be decomposed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='nominalCheck'>
Checks if data are disjunctive.
</h2><span id='topic+nominalCheck'></span>

<h3>Description</h3>

<p>Checks if data is in disjunctive (sometimes called complete binary) format. To be used with MCA (e.g., <code><a href="#topic+epMCA">epMCA</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nominalCheck(DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nominalCheck_+3A_data">DATA</code></td>
<td>
<p>A data matrix to check. This should be 0/1 disjunctive coded. <code>nominalCheck</code> just checks to make sure it is complete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>DATA</code> are nominal, <code>DATA</code> is returned. If not, <code><a href="base.html#topic+stop">stop</a></code> is called and execution halts.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='pause'>
pause
</h2><span id='topic+pause'></span>

<h3>Description</h3>

<p>A replication of MatLab pause function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pause(x = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pause_+3A_x">x</code></td>
<td>
<p>optional. If x&gt;0 a call is made to <code><a href="base.html#topic+Sys.sleep">Sys.sleep</a></code>. Else, execution pauses until a key is entered.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton (but the pase of which is provided by Phillipe Brosjean from the R mailing list.)
</p>


<h3>References</h3>

<p>Copied from:<br />
https://stat.ethz.ch/pipermail/r-help/2001-November/
</p>

<hr>
<h2 id='pca.wine'>Six wines described by several assessors with rank attributes.</h2><span id='topic+pca.wine'></span>

<h3>Description</h3>

<p>Six wines described by several assessors with rank attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pca.wine)</code></pre>


<h3>Format</h3>

<p>pca.wine$data: A data matrix with 6 wines (rows) from several assessors described by 11 attributes (columns). For use with <code><a href="#topic+epPCA">epPCA</a></code>.
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.
</p>


<h3>See Also</h3>

<p><a href="#topic+mca.wine">mca.wine</a>
</p>

<hr>
<h2 id='pcaSupplementaryColsPreProcessing'>
Preprocessing for supplementary columns in PCA.
</h2><span id='topic+pcaSupplementaryColsPreProcessing'></span>

<h3>Description</h3>

<p>Preprocessing for supplementary columns in PCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaSupplementaryColsPreProcessing(SUP.DATA = NULL, center = TRUE, scale = TRUE, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcaSupplementaryColsPreProcessing_+3A_sup.data">SUP.DATA</code></td>
<td>
<p>A supplemental matrix that has the same number of rows as an active data set.</p>
</td></tr>
<tr><td><code id="pcaSupplementaryColsPreProcessing_+3A_center">center</code></td>
<td>
<p>The center from the active data. NULL will center <code>SUP.DATA</code> to itself.</p>
</td></tr>
<tr><td><code id="pcaSupplementaryColsPreProcessing_+3A_scale">scale</code></td>
<td>
<p>The scale factor from the active data. NULL will scale (z-score) <code>SUP.DATA</code> to itself.</p>
</td></tr>
<tr><td><code id="pcaSupplementaryColsPreProcessing_+3A_m">M</code></td>
<td>
<p>Masses from the active data. Used in <code><a href="#topic+epGPCA">epGPCA</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that has been preprocessed to project supplementary columns for PCA methods.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='pcaSupplementaryRowsPreProcessing'>
Preprocessing for supplemental rows in PCA.
</h2><span id='topic+pcaSupplementaryRowsPreProcessing'></span>

<h3>Description</h3>

<p>Preprocessing for supplemental rows in PCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaSupplementaryRowsPreProcessing(SUP.DATA = NULL, center = TRUE, scale = TRUE, W = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcaSupplementaryRowsPreProcessing_+3A_sup.data">SUP.DATA</code></td>
<td>
<p>A supplemental matrix that has the same number of columns as an active data set.</p>
</td></tr>
<tr><td><code id="pcaSupplementaryRowsPreProcessing_+3A_center">center</code></td>
<td>
<p>The center from the active data. NULL will center <code>SUP.DATA</code> to itself.</p>
</td></tr>
<tr><td><code id="pcaSupplementaryRowsPreProcessing_+3A_scale">scale</code></td>
<td>
<p>The scale factor from the active data. NULL will scale (z-score) <code>SUP.DATA</code> to itself.</p>
</td></tr>
<tr><td><code id="pcaSupplementaryRowsPreProcessing_+3A_w">W</code></td>
<td>
<p>Weights from the active data. Used in <code><a href="#topic+epGPCA">epGPCA</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix that has been preprocessed to project supplementary rows for PCA methods.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='pickSVD'>
Pick which generalized SVD (or related) decomposition to use.
</h2><span id='topic+pickSVD'></span>

<h3>Description</h3>

<p>This function is an interface for the user to a general SVD or related decomposition. It provides direct access to <code><a href="base.html#topic+svd">svd</a></code> and <code><a href="base.html#topic+eigen">eigen</a></code>. Future decompositions will be available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickSVD(datain, is.mds = FALSE, decomp.approach = "svd", k = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickSVD_+3A_datain">datain</code></td>
<td>
<p>a data matrix to decompose.</p>
</td></tr>
<tr><td><code id="pickSVD_+3A_is.mds">is.mds</code></td>
<td>
<p>a boolean. TRUE for a MDS decomposition.</p>
</td></tr>
<tr><td><code id="pickSVD_+3A_decomp.approach">decomp.approach</code></td>
<td>
<p>a string. 'svd' for singular value decomposition, 'eigen' for an eigendecomposition. All approaches provide identical output. Some approaches are (in some cases) faster than others.</p>
</td></tr>
<tr><td><code id="pickSVD_+3A_k">k</code></td>
<td>
<p>numeric. The number of components to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>Left singular vectors (rows)</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Right singular vectors (columns)</p>
</td></tr>	
<tr><td><code>d</code></td>
<td>
<p>Singular values</p>
</td></tr>	
<tr><td><code>tau</code></td>
<td>
<p>Explained variance per component</p>
</td></tr>	
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='print.epCA'>Print Correspondence Analysis (CA) results</h2><span id='topic+print.epCA'></span>

<h3>Description</h3>

<p>Print Correspondence Analysis (CA) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epCA'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epCA_+3A_x">x</code></td>
<td>
<p>an list that contains items to make into the epCA class.</p>
</td></tr>
<tr><td><code id="print.epCA_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Cherise Chin-Fatt</p>

<hr>
<h2 id='print.epGPCA'>Print Generalized Principal Components Analysis (GPCA) results</h2><span id='topic+print.epGPCA'></span>

<h3>Description</h3>

<p>Print Generalized Principal Components Analysis (GPCA) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epGPCA'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epGPCA_+3A_x">x</code></td>
<td>
<p>an list that contains items to make into the epGPCA class.</p>
</td></tr>
<tr><td><code id="print.epGPCA_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Cherise Chin-Fatt</p>

<hr>
<h2 id='print.epGraphs'>Print epGraphs results</h2><span id='topic+print.epGraphs'></span>

<h3>Description</h3>

<p>Print epGraphs results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epGraphs'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epGraphs_+3A_x">x</code></td>
<td>
<p>an list that contains items to make into the epGraphs class.</p>
</td></tr>
<tr><td><code id="print.epGraphs_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Cherise Chin-Fatt</p>


<h3>See Also</h3>

<p><code><a href="#topic+epGraphs">epGraphs</a></code>
</p>

<hr>
<h2 id='print.epMCA'>Print Multiple Correspondence Analysis (MCA) results</h2><span id='topic+print.epMCA'></span>

<h3>Description</h3>

<p>Print Multiple Correspondence Analysis (MCA) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epMCA'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epMCA_+3A_x">x</code></td>
<td>
<p>an list that contains items to make into the epMCA class.</p>
</td></tr>
<tr><td><code id="print.epMCA_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Cherise Chin-Fatt</p>

<hr>
<h2 id='print.epMDS'>Print Multidimensional Scaling (MDS) results</h2><span id='topic+print.epMDS'></span>

<h3>Description</h3>

<p>Print Multidimensional Scaling (MDS) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epMDS'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epMDS_+3A_x">x</code></td>
<td>
<p>an list that contains items to make into the epMDS class.</p>
</td></tr>
<tr><td><code id="print.epMDS_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Cherise Chin-Fatt</p>

<hr>
<h2 id='print.epPCA'>Print Principal Components Analysis (PCA) results</h2><span id='topic+print.epPCA'></span>

<h3>Description</h3>

<p>Print Principal Components Analysis (PCA) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epPCA'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epPCA_+3A_x">x</code></td>
<td>
<p>an list that contains items to make into the epPCA class.</p>
</td></tr>
<tr><td><code id="print.epPCA_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Cherise Chin-Fatt</p>

<hr>
<h2 id='print.epSVD'>Print results from the singular value decomposition (SVD) in ExPosition</h2><span id='topic+print.epSVD'></span>

<h3>Description</h3>

<p>Print results from the singular value decomposition (SVD) in ExPosition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epSVD'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epSVD_+3A_x">x</code></td>
<td>
<p>an list that contains items to make into the epSVD class.</p>
</td></tr>
<tr><td><code id="print.epSVD_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Cherise Chin-Fatt</p>

<hr>
<h2 id='print.expoOutput'>Print results from ExPosition</h2><span id='topic+print.expoOutput'></span>

<h3>Description</h3>

<p>Print results from the ExPosition. Includes results from a given method and epGraphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'expoOutput'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.expoOutput_+3A_x">x</code></td>
<td>
<p>an list that contains items to make into the expoOutput class.</p>
</td></tr>
<tr><td><code id="print.expoOutput_+3A_...">...</code></td>
<td>
<p>inherited/passed arguments for S3 print method(s).</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Derek Beaton and Cherise Chin-Fatt</p>


<h3>See Also</h3>

<p><code><a href="#topic+epPCA">epPCA</a></code>, <code><a href="#topic+epGraphs">epGraphs</a></code>
</p>

<hr>
<h2 id='rowNorms'>
Normalize the rows of a matrix.
</h2><span id='topic+rowNorms'></span>

<h3>Description</h3>

<p>This function will normalize the rows of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowNorms(X, type = NULL, center = FALSE, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowNorms_+3A_x">X</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="rowNorms_+3A_type">type</code></td>
<td>
<p>a string. Type of normalization to perform. Options are <code>hellinger</code>, <code>ca</code>, <code>z</code>, <code>other</code></p>
</td></tr>
<tr><td><code id="rowNorms_+3A_center">center</code></td>
<td>
<p>optional. A vector to center the columns of X.</p>
</td></tr>
<tr><td><code id="rowNorms_+3A_scale">scale</code></td>
<td>
<p>optional. A vector to scale the values of X.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rowNorms works like <code>link{expo.scale}</code>, but for rows. Hellinger row norm via <code>hellinger</code>, Correspondence analysis analysis row norm (row profiles) via <code>ca</code>, Z-score row norm via <code>z</code>. <code>other</code> passes <code>center</code> and <code>scale</code> to <code><a href="#topic+expo.scale">expo.scale</a></code> and allows for optional centering and scaling parameters.
</p>


<h3>Value</h3>

<p>Returns a row normalized version of X.
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='rvCoeff'>
Perform Rv coefficient computation.
</h2><span id='topic+rvCoeff'></span>

<h3>Description</h3>

<p>Perform Rv coefficient computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvCoeff(Smat, Tmat, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvCoeff_+3A_smat">Smat</code></td>
<td>
<p>A square covariance matrix</p>
</td></tr>
<tr><td><code id="rvCoeff_+3A_tmat">Tmat</code></td>
<td>
<p>A square covariance matrix</p>
</td></tr>
<tr><td><code id="rvCoeff_+3A_type">type</code></td>
<td>
<p>DEPRECATED. Any value here will be ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value that is the Rv coefficient. 
</p>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>References</h3>

<p>Robert, P., &amp; Escoufier, Y. (1976). A Unifying Tool for Linear Multivariate Statistical Methods: The RV-Coefficient. <em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em>, <em>25</em>(3), 257&ndash;265.</p>

<hr>
<h2 id='snps.druguse'>Small data set for Partial Least Squares-Correspondence Analysis</h2><span id='topic+snps.druguse'></span>

<h3>Description</h3>

<p>The data come from a larger study on marijuauna dependent individuals (see Filbey et al., 2009) and are illustrated in Beaton et al., 2013. <br />
The data contain 2 genetic markers and 3 additional drug use questions from 50 marijuauna dependent individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(snps.druguse)</code></pre>


<h3>Format</h3>

<p>snps.druguse$DATA1: Fifty marijuana dependent participants indicated which, if any, other drugs they have ever used.<br />
snps.druguse$DATA2: Fifty marijuana dependent participants were genotyped for the COMT and FAAH genes.
</p>


<h3>Details</h3>

<p>In snps.druguse$DATA1:<br />
e - Stands for ecstacy use. Responses are yes or no.
cc - Stands for crack/cocaine use. Responses are yes or no.
cm - Stands for crystal meth use. Responses are yes or no.
<br />	In snps.druguse$DATA2:<br />
COMT - Stands for the COMT gene. Alleles are AA, AG, or GG. Some values are NA.
FAAH - Stands for FAAH gene. Alleles are AA, CA, CC. Some values are NA.
</p>


<h3>References</h3>

<p>Filbey, F. M., Schacht, J. P., Myers, U. S., Chavez, R. S., &amp; Hutchison, K. E. (2009). Marijuana craving in the brain. Proceedings of the National Academy of Sciences, 106(31), 13016 &ndash; 13021. 
</p>
<p>Beaton D., Filbey F. M., Abdi H. (2013, in press). Integrating Partial Least Squares Correlation and Correspondence Analysis for Nominal Data. In Abdi H, Chin W, Esposito-Vinzi V, Russolillo G, Trinchera L. <em>Proceedings in Mathematics and Statistics (Vol. 56): New Perspectives in Partial Least Squares and Related Methods</em>. New York, NY: Springer-Verlag. 
</p>

<hr>
<h2 id='supplementalProjection'>
Supplemental projections.
</h2><span id='topic+supplementalProjection'></span>

<h3>Description</h3>

<p>Performs a supplementary projection across ExPosition (and related) techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supplementalProjection(sup.transform = NULL, f.scores = NULL, Dv = NULL, 
scale.factor = NULL, symmetric = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supplementalProjection_+3A_sup.transform">sup.transform</code></td>
<td>
<p>Data already transformed for supplementary projection. That is, the output from: <code><a href="#topic+caSupplementalElementsPreProcessing">caSupplementalElementsPreProcessing</a></code>, <code><a href="#topic+mdsSupplementalElementsPreProcessing">mdsSupplementalElementsPreProcessing</a></code>, <code><a href="#topic+pcaSupplementaryColsPreProcessing">pcaSupplementaryColsPreProcessing</a></code>, or <code><a href="#topic+pcaSupplementaryRowsPreProcessing">pcaSupplementaryRowsPreProcessing</a></code>.</p>
</td></tr>
<tr><td><code id="supplementalProjection_+3A_f.scores">f.scores</code></td>
<td>
<p>Active factor scores, e.g., res$ExPosition.Data$fi</p>
</td></tr>
<tr><td><code id="supplementalProjection_+3A_dv">Dv</code></td>
<td>
<p>Active singular values, e.g., res$ExPosition.Data$pdq$Dv</p>
</td></tr>
<tr><td><code id="supplementalProjection_+3A_scale.factor">scale.factor</code></td>
<td>
<p>allows for a scaling factor of supplementary projections. Primarily used for MCA supplemental projections to a correction (e.g., Benzecri).</p>
</td></tr>  
<tr><td><code id="supplementalProjection_+3A_symmetric">symmetric</code></td>
<td>
<p>a boolean. Default is TRUE. If FALSE, factor scores are computed with asymmetric properties (for rows only).</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>A list with: <br />
</p>
<table>
<tr><td><code>f.out</code></td>
<td>
<p>Supplementary factor scores.</p>
</td></tr>
<tr><td><code>d.out</code></td>
<td>
<p>Supplementary square distances.</p>
</td></tr>
<tr><td><code>r.out</code></td>
<td>
<p>Supplementary cosines.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>


<h3>See Also</h3>

<p>It is preferred for users to compute supplemental projections via <code><a href="#topic+supplementaryRows">supplementaryRows</a></code> and <code><a href="#topic+supplementaryCols">supplementaryCols</a></code>. These handle some of the nuances and subtleties due to the different methods.
</p>

<hr>
<h2 id='supplementaryCols'>
Supplementary columns
</h2><span id='topic+supplementaryCols'></span>

<h3>Description</h3>

<p>Computes factor scores for supplementary measures (columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supplementaryCols(SUP.DATA, res, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supplementaryCols_+3A_sup.data">SUP.DATA</code></td>
<td>
<p>a data matrix of supplementary measures (must have the same observations [rows] as active data)</p>
</td></tr>
<tr><td><code id="supplementaryCols_+3A_res">res</code></td>
<td>
<p>ExPosition or TExPosition results</p>
</td></tr>
<tr><td><code id="supplementaryCols_+3A_center">center</code></td>
<td>
<p>a boolean, string, or numeric. See <code><a href="#topic+expo.scale">expo.scale</a></code></p>
</td></tr>
<tr><td><code id="supplementaryCols_+3A_scale">scale</code></td>
<td>
<p>a boolean, string, or numeric. See <code><a href="#topic+expo.scale">expo.scale</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function recognizes the class types of: <code><a href="#topic+epPCA">epPCA</a></code>, <code><a href="#topic+epGPCA">epGPCA</a></code>, <code><a href="#topic+epMDS">epMDS</a></code>, <code><a href="#topic+epCA">epCA</a></code>, <code><a href="#topic+epMCA">epMCA</a></code>, and <code>TExPosition</code> methods. Further, the function recognizes if Hellinger (as opposed to row profiles; in CA, MCA and DICA) were used. 
</p>


<h3>Value</h3>

<p>A list of values containing:<br />
</p>
<table>
<tr><td><code>fjj</code></td>
<td>
<p>factor scores computed for supplemental columns</p>
</td></tr>
<tr><td><code>djj</code></td>
<td>
<p>squared distances for supplemental columns</p>
</td></tr>
<tr><td><code>rjj</code></td>
<td>
<p>cosines for supplemental columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='supplementaryRows'>
Supplementary rows
</h2><span id='topic+supplementaryRows'></span>

<h3>Description</h3>

<p>Computes factor scores for supplementary observations (rows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supplementaryRows(SUP.DATA, res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supplementaryRows_+3A_sup.data">SUP.DATA</code></td>
<td>
<p>a data matrix of supplementary observations (must have the same measures [columns] as active data)</p>
</td></tr>
<tr><td><code id="supplementaryRows_+3A_res">res</code></td>
<td>
<p>ExPosition or TExPosition results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function recognizes the class types of: <code><a href="#topic+epPCA">epPCA</a></code>, <code><a href="#topic+epGPCA">epGPCA</a></code>, <code><a href="#topic+epMDS">epMDS</a></code>, <code><a href="#topic+epCA">epCA</a></code>, <code><a href="#topic+epMCA">epMCA</a></code> and <code>TExPosition</code> methods. Further, the function recognizes if Hellinger (as opposed to row profiles; in CA, MCA and DICA) were used. 
</p>


<h3>Value</h3>

<p>A list of values containing:<br />
</p>
<table>
<tr><td><code>fii</code></td>
<td>
<p>factor scores computed for supplemental observations</p>
</td></tr>
<tr><td><code>dii</code></td>
<td>
<p>squared distances for supplemental observations</p>
</td></tr>
<tr><td><code>rii</code></td>
<td>
<p>cosines for supplemental observations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Derek Beaton
</p>

<hr>
<h2 id='wines2007'>Six wines described by 3 assessors.</h2><span id='topic+wines2007'></span>

<h3>Description</h3>

<p>How six wines are described by 3 assessors across various flavor profiles, totaling 10 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wines2007)</code></pre>


<h3>Format</h3>

<p>wines2007$data: A data set with 3 experts (studies) describing 6 wines (rows) using several variables using a scale from 1 to 7 with a total of 10 measures (columns).<br />
wines2007$table: A data matrix which identifies the 3 experts (studies). <br />
</p>


<h3>References</h3>

<p>Abdi, H., &amp; Valentin, D. (2007). STATIS. In N.J. Salkind (Ed.): <em>Encyclopedia of Measurement and Statistics</em>. Thousand Oaks (CA): Sage. pp. 955-962.
</p>

<hr>
<h2 id='wines2012'>Wines Data from 12 assessors described by 15 flavor profiles.</h2><span id='topic+wines2012'></span>

<h3>Description</h3>

<p>10 experts who describe 12 wines using four variables (cat-pee, passion fruit, green pepper, and mineral) considered as standard, and up to two additional variables if the experts chose. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wines2012)</code></pre>


<h3>Format</h3>

<p>wines2012$data: A data set with 10 experts (studies) describing 12 wines (rows) using four to six variables using a scale from 1 to 9 with a total of 53 measures (columns).<br />
wines2012$table: A data matrix which identifies the 10 experts (studies). <br />
wines2012$supplementary: A data matrix with 12 wines (rows) describing 4 Chemical Properties (columns).<br />
</p>


<h3>References</h3>

<p>Abdi, H., Williams, L.J., Valentin, D., &amp; Bennani-Dosse, M. (2012). STATIS and DISTATIS: Optimum multi-table principal component analysis and three way metric multidimensional scaling. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 4, 124-167.
</p>

<hr>
<h2 id='words'>Twenty words described by 2 features.</h2><span id='topic+words'></span>

<h3>Description</h3>

<p>Twenty words &ldquo;randomly&rdquo; selected from a dictionary and described by two features: length of word and number of definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(words)</code></pre>


<h3>Format</h3>

<p>words$data: A data matrix with 20 words (rows) described by 2 attributes (columns). For use with <code><a href="#topic+epPCA">epPCA</a></code>.
</p>


<h3>References</h3>

<p>Abdi, H., and Williams, L.J. (2010). Principal component analysis. <em>Wiley Interdisciplinary Reviews: Computational Statistics</em>, 2, 433-459.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
