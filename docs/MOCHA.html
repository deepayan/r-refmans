<!DOCTYPE html><html><head><title>Help for package MOCHA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MOCHA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.counts_plot_default_theme'><p>Default ggplot theme for counts plot</p></a></li>
<li><a href='#.gene_plot_theme'><p>Common theme for gene plots</p></a></li>
<li><a href='#addAccessibilityShift'><p><code>addAccessibilityShift</code></p></a></li>
<li><a href='#addMotifSet'><p><code>addMotifSet</code></p></a></li>
<li><a href='#annotateTiles'><p><code>annotateTiles</code></p></a></li>
<li><a href='#bulkDimReduction'><p><code>bulkDimReduction</code></p></a></li>
<li><a href='#bulkUMAP'><p><code>bulkUMAP</code></p></a></li>
<li><a href='#callOpenTiles'><p><code>callOpenTiles</code> Perform peak-calling on a set of fragments or an</p>
ArchR Project.</a></li>
<li><a href='#combineSampleTileMatrix'><p><code>combineSampleTileMatrix</code></p></a></li>
<li><a href='#differentialsToGRanges'><p><code>differentialsToGRanges</code> Converts a data.frame matrix to a GRanges,</p>
preserving additional columns as GRanges metadata</a></li>
<li><a href='#exampleBlackList'><p>exampleBlackList</p></a></li>
<li><a href='#exampleCellColData'><p>exampleCellColData</p></a></li>
<li><a href='#exampleFragments'><p>exampleFragments</p></a></li>
<li><a href='#exportCoverage'><p><code>exportCoverage</code></p></a></li>
<li><a href='#exportDifferentials'><p><code>exportDifferentials</code></p></a></li>
<li><a href='#exportMotifs'><p><code>exportMotifs</code></p></a></li>
<li><a href='#exportOpenTiles'><p><code>exportOpenTiles</code></p></a></li>
<li><a href='#exportSmoothedInsertions'><p><code>exportSmoothedInsertions</code></p></a></li>
<li><a href='#extractErrorFromConsensusTiles'><p><code>extractErrorFromConsensusTiles</code></p></a></li>
<li><a href='#extractRegion'><p><code>extractRegion</code></p></a></li>
<li><a href='#filterCoAccessibleLinks'><p><code>filterCoAccessibleLinks</code></p></a></li>
<li><a href='#finalModelObject'><p>finalModelObject</p></a></li>
<li><a href='#getAltTSS'><p>Annotate Peaks falling in Transcription Start Sites</p>
(TSS) and identify alternatively regulated TSSs for each gene.</a></li>
<li><a href='#getAnnotationDbFromInstalledPkgname'><p><code>getAnnotationDbFromInstalledPkgname</code> Loads and attaches an installed TxDb or</p>
OrgDb-class Annotation database package.</a></li>
<li><a href='#getCellPopMatrix'><p><code>getCellPopMatrix</code></p></a></li>
<li><a href='#getCellTypes'><p><code>getCellTypes</code> Extract cell type names from a Tile Results or Sample Tile object.</p></a></li>
<li><a href='#getCellTypeTiles'><p><code>getCellTypeTiles</code> Extract the GRanges for a particular cell type</p></a></li>
<li><a href='#getCoAccessibleLinks'><p><code>getCoAccessibleLinks</code></p></a></li>
<li><a href='#getCoverage'><p>Get sample-specific coverage files for each sample-cell population.</p></a></li>
<li><a href='#getDifferentialAccessibleTiles'><p><code>getDifferentialAccessibleTiles</code></p></a></li>
<li><a href='#getIntensityThreshold'><p><code>getIntensityThreshold</code></p></a></li>
<li><a href='#getModelValues'><p>getModelValues from runZIGLMM output.</p></a></li>
<li><a href='#getPopFrags'><p>Extract fragments by populations from an ArchR Project</p></a></li>
<li><a href='#getPromoterGenes'><p><code>getPromoterGenes</code></p></a></li>
<li><a href='#getSampleCellTypeMetadata'><p><code>getSampleCellTypeMetadata</code> Extract Sample-celltype specific metadata</p></a></li>
<li><a href='#getSampleTileMatrix'><p><code>getSampleTileMatrix</code></p></a></li>
<li><a href='#getSequencingBias'><p><code>getSequencingBias</code></p></a></li>
<li><a href='#GRangesToString'><p><code>GRangesToString</code> Converts a GRanges object to a string in the format 'chr1:100-200'</p></a></li>
<li><a href='#mergeTileResults'><p><code>mergeTileResults</code></p></a></li>
<li><a href='#MotifEnrichment'><p><code>MotifEnrichment</code></p></a></li>
<li><a href='#MotifSetEnrichmentAnalysis'><p><code>MotifSetEnrichmentAnalysis</code></p></a></li>
<li><a href='#packMOCHA'><p><code>packMOCHA</code></p></a></li>
<li><a href='#pilotLMEM'><p>Execute a pilot run of single linear model on a subset of data</p></a></li>
<li><a href='#pilotZIGLMM'><p>Execute a pilot run of model on a subset of data</p></a></li>
<li><a href='#plotConsensus'><p><code>plotConsensus</code></p></a></li>
<li><a href='#plotIntensityDistribution'><p><code>plotIntensityDistribution</code></p></a></li>
<li><a href='#plotRegion'><p><code>plotRegion</code></p></a></li>
<li><a href='#renameCellTypes'><p><code>renameCellTypes</code></p></a></li>
<li><a href='#runLMEM'><p>Run Linear Mixed-Effects Modeling for continuous, non-zero inflated</p>
data</a></li>
<li><a href='#runZIGLMM'><p>Run Zero-inflated Generalized Linear Mixed Modeling on pseudobulked</p>
scATAC data</a></li>
<li><a href='#simplifiedConsensusTiles'><p><code>simplifiedConsensusTiles</code></p></a></li>
<li><a href='#singlePopulationConsensusTiles'><p><code>singlePopulationConsensusTiles</code></p></a></li>
<li><a href='#singlePopulationSampleTileMatrix'><p><code>singlePopulationSampleTileMatrix</code></p></a></li>
<li><a href='#StringsToGRanges'><p><code>StringsToGRanges</code></p></a></li>
<li><a href='#subsetMOCHAObject'><p><code>subsetMOCHAObject</code></p></a></li>
<li><a href='#testCoAccessibility'><p><code>testCoAccessibility</code></p></a></li>
<li><a href='#testCoAccessibilityChromVar'><p><code>testCoAccessibilityChromVar</code></p></a></li>
<li><a href='#testCoAccessibilityRandom'><p><code>testCoAccessibilityRandom</code></p></a></li>
<li><a href='#unpackMOCHA'><p><code>unpackMOCHA</code></p></a></li>
<li><a href='#varZIGLMM'><p>Zero-inflated Variance Decomposition for pseudobulked scATAC data</p></a></li>
<li><a href='#youden_threshold'><p>youden_threshold</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling for Single-Cell Open Chromatin Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Imran McGrath &lt;aifi.compbio.support@alleninstitute.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A statistical framework and analysis tool for open chromatin 
  analysis designed specifically for single cell ATAC-seq (Assay for 
  Transposase-Accessible Chromatin) data, after cell type/cluster 
  identification. These novel modules remove unwanted technical variation, 
  identify open chromatin, robustly models repeated measures in single cell 
  data, implement advanced statistical frameworks to model zero-inflation for 
  differential and co-accessibility analyses, and integrate with existing 
  databases and modules for downstream analyses to reveal biological insights. 
  MOCHA provides a statistical foundation for complex downstream analysis to 
  help advance the potential of single cell ATAC-seq for applied studies. 
  Methods for zero-inflated statistics are as described in: 
  Ghazanfar, S., Lin, Y., Su, X. et al. (2020) &lt;<a href="https://doi.org/10.1038%2Fs41592-020-0885-x">doi:10.1038/s41592-020-0885-x</a>&gt;.
  Pimentel, Ronald Silva, "Kendall's Tau and Spearman's Rho for Zero-Inflated 
  Data" (2009) <a href="https://scholarworks.wmich.edu/dissertations/721/">https://scholarworks.wmich.edu/dissertations/721/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, plyranges (&ge; 1.14.0), dplyr, GenomicRanges,
RaggedExperiment, MultiAssayExperiment, SummarizedExperiment,
stringr, ggbio, wCorr, magrittr, rlang, AnnotationDbi,
BiocGenerics, GenomeInfoDb, GenomicFeatures, IRanges,
S4Vectors, assertthat, ensembldb, ggplot2, ggrepel,
matrixStats, methods, qvalue, scales, tidyr, ggridges, pbapply,
BSgenome, tidyselect, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ArchR, RMariaDB, motifmatchr, BiocManager,
TxDb.Hsapiens.UCSC.hg38.refGene,
TxDb.Hsapiens.UCSC.hg19.knownGene, org.Hs.eg.db,
BSgenome.Hsapiens.UCSC.hg19, withr, knitr, rmarkdown, chromVAR,
testthat (&ge; 3.0.0), uwot, irlba, glmmTMB, Matrix, waldo,
purrr, lmerTest, Biobase, lme4, zip, rtracklayer, cowplot,
mixtools, zoo</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://imran-aifi.github.io/drat">https://imran-aifi.github.io/drat</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 08:05:32 UTC; imran.mcgrath</td>
</tr>
<tr>
<td>Author:</td>
<td>Samir Rachid Zaim [aut, ctb],
  Mark-Phillip Pebworth [aut, ctb],
  Imran McGrath [aut, cre],
  Lauren Okada [aut, ctb],
  Xiaojun Li [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-25 12:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='.counts_plot_default_theme'>Default ggplot theme for counts plot</h2><span id='topic+.counts_plot_default_theme'></span>

<h3>Description</h3>

<p>Default ggplot theme for counts plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.counts_plot_default_theme
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 10.
</p>

<hr>
<h2 id='.gene_plot_theme'>Common theme for gene plots</h2><span id='topic+.gene_plot_theme'></span>

<h3>Description</h3>

<p>Common theme for gene plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.gene_plot_theme
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>

<hr>
<h2 id='addAccessibilityShift'><code>addAccessibilityShift</code></h2><span id='topic+addAccessibilityShift'></span>

<h3>Description</h3>

<p><code>addAccessibilityShift</code> will add a new condition to the SummarizedExperiment output of extractRegion,
which will contain the difference in accessibility between two conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAccessibilityShift(CountSE, foreground, background, assayName = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addAccessibilityShift_+3A_countse">CountSE</code></td>
<td>
<p>The SummarizedExperiment object output from extractRegion</p>
</td></tr>
<tr><td><code id="addAccessibilityShift_+3A_foreground">foreground</code></td>
<td>
<p>Group that will be used as the foreground for the subtraction of accessibility</p>
</td></tr>
<tr><td><code id="addAccessibilityShift_+3A_background">background</code></td>
<td>
<p>Group that will be used as the background for the subtraction of accessibility</p>
</td></tr>
<tr><td><code id="addAccessibilityShift_+3A_assayname">assayName</code></td>
<td>
<p>The name given to the new assay that is difference in accessibility between foreground and background.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countSE a SummarizedExperiment containing coverage for the given input cell populations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# CountSE is a SummarizedExperiment generated by extractRegion()
countSE &lt;- MOCHA::addAccessibilityShift(
  CountSE = CountSE,
  foreground = "Condition1",
  background = "Condition2",
  assayName = "AccessibilityChanges"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='addMotifSet'><code>addMotifSet</code></h2><span id='topic+addMotifSet'></span>

<h3>Description</h3>

<p><code>addMotifSet</code> Identify motifs within your peakset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMotifSet(
  SampleTileObj,
  motifPWMs,
  w = 7,
  returnSTM = TRUE,
  motifSetName = "Motifs"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMotifSet_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>A SummarizedExperiment, specifically the output of
getSampleTileMatrix</p>
</td></tr>
<tr><td><code id="addMotifSet_+3A_motifpwms">motifPWMs</code></td>
<td>
<p>A pwms object for the motif database. Either PFMatrix,
PFMatrixList, PWMatrix, or PWMatrixList</p>
</td></tr>
<tr><td><code id="addMotifSet_+3A_w">w</code></td>
<td>
<p>Parameter for motifmatchr controlling size in basepairs of window for filtration.
Default is 7.</p>
</td></tr>
<tr><td><code id="addMotifSet_+3A_returnstm">returnSTM</code></td>
<td>
<p>If TRUE, return the modified SampleTileObj with motif set
added to metadata (default). If FALSE, return the motifs from motifmatchr as a GRanges.</p>
</td></tr>
<tr><td><code id="addMotifSet_+3A_motifsetname">motifSetName</code></td>
<td>
<p>Name to give motifList in the SampleTileObj's metadata
if &lsquo;returnSTM=TRUE'. Default is &rsquo;Motifs'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified SampleTileObj with motifs added to the metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load a curated motif set from library(chromVARmotifs)
# included with ArchR installation
data(human_pwms_v2)
SE_with_motifs &lt;- addMotifSet(
  SampleTileObj,
  motifPWMs = human_pwms_v2,
  returnSTM = TRUE, motifSetName = "Motifs", w = 7
)

## End(Not run)

</code></pre>

<hr>
<h2 id='annotateTiles'><code>annotateTiles</code></h2><span id='topic+annotateTiles'></span>

<h3>Description</h3>

<p><code>annotateTiles</code> annotates a set of sample-tile matrices
given with gene annotations. Details on TxDb and Org annotation packages
and available annotations can be found at Bioconductor:
https://bioconductor.org/packages/3.15/data/annotation/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotateTiles(Obj, TxDb = NULL, Org = NULL, promoterRegion = c(2000, 100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotateTiles_+3A_obj">Obj</code></td>
<td>
<p>A RangedSummarizedExperiment generated from getSampleTileMatrix,
containing TxDb and Org in the metadata. This may also be a GRanges object.</p>
</td></tr>
<tr><td><code id="annotateTiles_+3A_txdb">TxDb</code></td>
<td>
<p>The annotation package for TxDb object for your genome.
Optional, only required if Obj is a GRanges.</p>
</td></tr>
<tr><td><code id="annotateTiles_+3A_org">Org</code></td>
<td>
<p>The genome-wide annotation for your organism.
Optional, only required if Obj is a GRanges.</p>
</td></tr>
<tr><td><code id="annotateTiles_+3A_promoterregion">promoterRegion</code></td>
<td>
<p>Optional list containing the window size in basepairs
defining the promoter region. The format is (upstream, downstream).
Default is (2000, 100).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Obj, the input data structure with added gene annotations (whether GRanges or SampleTileObj)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(TxDb.Hsapiens.UCSC.hg38.refGene)
library(org.Hs.eg.db)
SampleTileMatricesAnnotated &lt;- MOCHA::annotateTiles(
  SampleTileMatrices,
  TxDb = TxDb.Hsapiens.UCSC.hg38.refGene,
  Org = org.Hs.eg.db
)

## End(Not run)

</code></pre>

<hr>
<h2 id='bulkDimReduction'><code>bulkDimReduction</code></h2><span id='topic+bulkDimReduction'></span>

<h3>Description</h3>

<p><code>bulkDimReduction</code> runs dimensionality reduction (either PCA or LSI). We adapt Signac's
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulkDimReduction(
  SampleTileObj,
  cellType = "All",
  componentNumber = 30,
  method = "LSI",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulkDimReduction_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The SummarizedExperiment object output from getSampleTileMatrix</p>
</td></tr>
<tr><td><code id="bulkDimReduction_+3A_celltype">cellType</code></td>
<td>
<p>vector of strings. Cell subsets for which to call
peaks. This list of group names must be identical to names that appear in
the SampleTileObj.  Optional, if cellPopulations='ALL', then peak
calling is done on all cell populations. Default is 'ALL'.</p>
</td></tr>
<tr><td><code id="bulkDimReduction_+3A_componentnumber">componentNumber</code></td>
<td>
<p>integer. Number of components to include in LSI, or PCA This must be strictly less than</p>
</td></tr>
<tr><td><code id="bulkDimReduction_+3A_method">method</code></td>
<td>
<p>a string. Represents the method to use. Includes LSI or PCA, but we do not recommend PCA for scATAC pseudobulk.</p>
</td></tr>
<tr><td><code id="bulkDimReduction_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SEObj a SummarizedExperiment containing PC components from dimensionality reduction and metadata from the SampleTileObj
</p>


<h3>References</h3>

<p>LSI method adapted from Andrew Hill: http://andrewjohnhill.com/blog/2019/05/06/dimensionality-reduction-for-scatac-data/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
LSIObj &lt;- MOCHA::bulkDimReduction(SampleTileObj, cellType = "CD16_Mono")

## End(Not run)
</code></pre>

<hr>
<h2 id='bulkUMAP'><code>bulkUMAP</code></h2><span id='topic+bulkUMAP'></span>

<h3>Description</h3>

<p><code>bulkUMAP</code> generates UMAP from pseudobulk LSIObj object, and merges in metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulkUMAP(
  SEObj,
  assay = "LSI",
  components = c(1:30),
  nNeighbors = 15,
  returnModel = FALSE,
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulkUMAP_+3A_seobj">SEObj</code></td>
<td>
<p>The SummarizedExperiment object output from bulkDimReduction, or an STM, subsetted down to just one cell type.</p>
</td></tr>
<tr><td><code id="bulkUMAP_+3A_assay">assay</code></td>
<td>
<p>A string, describing the name of the assay within SEObj to run UMAP ('PCA', 'LSI', or 'counts').</p>
</td></tr>
<tr><td><code id="bulkUMAP_+3A_components">components</code></td>
<td>
<p>A vector of integers. Number of components to include in LSI (1:30 typically).</p>
</td></tr>
<tr><td><code id="bulkUMAP_+3A_nneighbors">nNeighbors</code></td>
<td>
<p>See  <a href="uwot.html#topic+umap">umap</a>. The size of local neighborhood (in terms of number of
neighboring sample points) used for manifold approximation. Default is 15.</p>
</td></tr>
<tr><td><code id="bulkUMAP_+3A_returnmodel">returnModel</code></td>
<td>
<p>A boolean. Default is FALSE. If set to true, it will return a list, where the first is the UMAP coordinates with metadata for plotting, and the second is the full UMAP model so further projection can occur.</p>
</td></tr>
<tr><td><code id="bulkUMAP_+3A_seed">seed</code></td>
<td>
<p>an integer. Represents the random seed to pass to the UMAP. Default seed is 1.</p>
</td></tr>
<tr><td><code id="bulkUMAP_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <a href="uwot.html#topic+umap">umap</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fullUMAP data.frame of UMAP values with metadata attached.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
UMAPvalues &lt;- MOCHA::bulkUMAP(LSIObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='callOpenTiles'><code>callOpenTiles</code> Perform peak-calling on a set of fragments or an
ArchR Project.</h2><span id='topic+callOpenTiles'></span><span id='topic+callOpenTiles+2CGRangesList-method'></span><span id='topic+callOpenTiles+2Clist-method'></span><span id='topic+.callOpenTiles_ArchR'></span><span id='topic+callOpenTiles+2CArchRProject-method'></span>

<h3>Description</h3>

<p><code>callOpenTiles</code> is the main peak-calling function in MOCHA
that serves as a wrapper function to call peaks provided a set of fragment
files and an ArchR Project for meta-data purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callOpenTiles(
  ATACFragments,
  cellColData,
  blackList,
  genome,
  cellPopLabel,
  cellPopulations = "ALL",
  studySignal = NULL,
  generalizeStudySignal = FALSE,
  cellCol = "RG",
  TxDb,
  OrgDb,
  outDir,
  numCores = 30,
  verbose = FALSE,
  force = FALSE
)

## S4 method for signature 'GRangesList'
callOpenTiles(
  ATACFragments,
  cellColData,
  blackList,
  genome,
  cellPopLabel,
  cellPopulations = "ALL",
  studySignal = NULL,
  generalizeStudySignal = FALSE,
  cellCol = "RG",
  TxDb,
  OrgDb,
  outDir,
  numCores = 30,
  verbose = FALSE,
  force = FALSE
)

## S4 method for signature 'list'
callOpenTiles(
  ATACFragments,
  cellColData,
  blackList,
  genome,
  cellPopLabel,
  cellPopulations = "ALL",
  studySignal = NULL,
  generalizeStudySignal = FALSE,
  cellCol = "RG",
  TxDb,
  OrgDb,
  outDir,
  numCores = 30,
  verbose = FALSE,
  force = FALSE
)

.callOpenTiles_ArchR(
  ATACFragments,
  cellPopLabel,
  cellPopulations = "ALL",
  studySignal = NULL,
  generalizeStudySignal = FALSE,
  TxDb,
  OrgDb,
  outDir = NULL,
  numCores = 30,
  verbose = FALSE,
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callOpenTiles_+3A_atacfragments">ATACFragments</code></td>
<td>
<p>an ArchR Project, or a GRangesList of fragments. Each
GRanges in the GRanges list must have unique cell IDs in the column given
by 'cellCol'.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_cellcoldata">cellColData</code></td>
<td>
<p>A DataFrame containing cell-level metadata. This must
contain both a column 'Sample' with unique sample IDs and the column
specified by 'cellPopLabel'.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_blacklist">blackList</code></td>
<td>
<p>A GRanges of blacklisted regions</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_genome">genome</code></td>
<td>
<p>A BSgenome object, or the full name of an installed BSgenome
data package, or a short string specifying the name of an NCBI assembly
(e.g. &quot;GRCh38&quot;, &quot;TAIR10.1&quot;, etc...) or UCSC genome (e.g. &quot;hg38&quot;, &quot;bosTau9&quot;,
&quot;galGal6&quot;, &quot;ce11&quot;, etc...). The supplied short string must refer
unambiguously to an installed BSgenome data package. See
<a href="BSgenome.html#topic+getBSgenome">getBSgenome</a>.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_cellpoplabel">cellPopLabel</code></td>
<td>
<p>string indicating which column in the ArchRProject
metadata contains the cell population label.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_cellpopulations">cellPopulations</code></td>
<td>
<p>vector of strings. Cell subsets for which to call
peaks. This list of group names must be identical to names that appear in
the ArchRProject metadata.  Optional, if cellPopulations='ALL', then peak
calling is done on all cell populations in the ArchR project metadata.
Default is 'ALL'.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_studysignal">studySignal</code></td>
<td>
<p>The median signal (number of fragments) in your study. If
not set, this will be calculated using the input ArchR project but relies
on the assumption that the ArchR project encompasses your whole study (i.e.
is not a subset).</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_generalizestudysignal">generalizeStudySignal</code></td>
<td>
<p>If 'studySignal' is not provided, calculate the
signal as the mean of the mean &amp; median number of fragments for of
individual samples within each cell population. This may improve MOCHA's
ability to generalize to datasets with XXXXXX #TODO. Default is FALSE, use
the median number of fragments.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_cellcol">cellCol</code></td>
<td>
<p>The column in cellColData specifying unique cell ids or
barcodes. Default is &quot;RG&quot;, the unique cell identifier used by ArchR.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_txdb">TxDb</code></td>
<td>
<p>The exact package name of a TxDb-class transcript annotation
package for your organism (e.g. &quot;TxDb.Hsapiens.UCSC.hg38.refGene&quot;). This
must be installed. See
<a href="https://bioconductor.org/packages/release/data/annotation/">
Bioconductor AnnotationData Packages</a>.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_orgdb">OrgDb</code></td>
<td>
<p>The exact package name of a OrgDb-class genome wide annotation
package for your organism (e.g. &quot;org.Hs.eg.db&quot;). This must be installed.
See <a href="https://bioconductor.org/packages/release/data/annotation/">
Bioconductor AnnotationData Packages</a></p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_outdir">outDir</code></td>
<td>
<p>is a string describing the output directory for coverage files.
Must be a complete directory string. With ArchR input, set outDir to NULL
to create a directory within the input ArchR project directory named MOCHA
for saving files.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_numcores">numCores</code></td>
<td>
<p>integer. Number of cores to parallelize peak-calling across
multiple cell populations.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="callOpenTiles_+3A_force">force</code></td>
<td>
<p>Optional, whether to force creation of coverage files if they
already exist. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tileResults A MultiAssayExperiment object containing ranged data for
each tile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Starting from an ArchR Project:
tileResults &lt;- MOCHA::callOpenTiles(
  ArchRProj = myArchRProj,
  cellPopLabel = "celltype_labeling",
  cellPopulations = "CD4",
  TxDb = "TxDb.Hsapiens.UCSC.hg38.refGene",
  OrgDb = "org.Hs.eg.db",
  numCores = 1
)

## End(Not run)

# Starting from GRangesList
if (
  requireNamespace("BSgenome.Hsapiens.UCSC.hg19") &amp;&amp;
    requireNamespace("TxDb.Hsapiens.UCSC.hg38.refGene") &amp;&amp;
    requireNamespace("org.Hs.eg.db")
) {
  tiles &lt;- MOCHA::callOpenTiles(
    ATACFragments = MOCHA::exampleFragments,
    cellColData = MOCHA::exampleCellColData,
    blackList = MOCHA::exampleBlackList,
    genome = "BSgenome.Hsapiens.UCSC.hg19",
    TxDb = "TxDb.Hsapiens.UCSC.hg38.refGene",
    OrgDb = "org.Hs.eg.db",
    outDir = tempdir(),
    cellPopLabel = "Clusters",
    cellPopulations = c("C2", "C5"),
    numCores = 1
  )
}


</code></pre>

<hr>
<h2 id='combineSampleTileMatrix'><code>combineSampleTileMatrix</code></h2><span id='topic+combineSampleTileMatrix'></span>

<h3>Description</h3>

<p><code>combineSampleTileMatrix</code> combines all celltypes in a
SampleTileMatrix object into a SummarizedExperiment with one single matrix
across all cell types and samples,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineSampleTileMatrix(SampleTileObj, NAtoZero = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineSampleTileMatrix_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The SummarizedExperiment object output from
getSampleTileMatrix containing your sample-tile matrices</p>
</td></tr>
<tr><td><code id="combineSampleTileMatrix_+3A_natozero">NAtoZero</code></td>
<td>
<p>Set NA values in the sample-tile matrix to zero</p>
</td></tr>
<tr><td><code id="combineSampleTileMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TileCorr A data.table correlation matrix
</p>

<hr>
<h2 id='differentialsToGRanges'><code>differentialsToGRanges</code> Converts a data.frame matrix to a GRanges,
preserving additional columns as GRanges metadata</h2><span id='topic+differentialsToGRanges'></span>

<h3>Description</h3>

<p><code>differentialsToGRanges</code> Converts a data.frame matrix to a GRanges,
preserving additional columns as GRanges metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differentialsToGRanges(differentials, tileColumn = "Tile")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="differentialsToGRanges_+3A_differentials">differentials</code></td>
<td>
<p>a matrix/data.frame with a column tileColumn containing
region strings in the format &quot;chr:start-end&quot;</p>
</td></tr>
<tr><td><code id="differentialsToGRanges_+3A_tilecolumn">tileColumn</code></td>
<td>
<p>name of column containing region strings. Default is &quot;Tile&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a GRanges containing all original information
</p>

<hr>
<h2 id='exampleBlackList'>exampleBlackList</h2><span id='topic+exampleBlackList'></span>

<h3>Description</h3>

<p>Example input of a blackList extracted from the PBMC_Small dataset
consisting of 2k cells and spanning chr1 and 2 (~2-300MB).
The data is publicly available with the ArchR package at
&lt;https://www.archrproject.com/reference/getTestProject.html&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleBlackList
</code></pre>


<h3>Format</h3>

<p>A GRanges object with 210 ranges and 2 metadata columns
</p>

<hr>
<h2 id='exampleCellColData'>exampleCellColData</h2><span id='topic+exampleCellColData'></span>

<h3>Description</h3>

<p>Example input of cellColData extracted from the PBMC_Small dataset
consisting of 2k cells and spanning chr1 and 2 (~2-300MB).
The data is publicly available with the ArchR package at
&lt;https://www.archrproject.com/reference/getTestProject.html&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleCellColData
</code></pre>


<h3>Format</h3>

<p>A DataFrame with 2217 rows and 3 columns
</p>

<hr>
<h2 id='exampleFragments'>exampleFragments</h2><span id='topic+exampleFragments'></span>

<h3>Description</h3>

<p>Example input of ATAC fragments extracted from the PBMC_Small dataset
consisting of 2k cells and spanning chr1 and 2 (~2-300MB).
This subset consists of two cell populations: Clusters C2 and C5.
The data is publicly available with the ArchR package at
&lt;https://www.archrproject.com/reference/getTestProject.html&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleFragments
</code></pre>


<h3>Format</h3>

<p>A list of 2 GRanges objects
</p>

<hr>
<h2 id='exportCoverage'><code>exportCoverage</code></h2><span id='topic+exportCoverage'></span>

<h3>Description</h3>

<p><code>exportCoverage</code> will export normalized coverage files to
BigWig files, either as sample-specific or sample-averaged files, for
visualization in genome browsers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportCoverage(
  SampleTileObject,
  dir = getwd(),
  type = TRUE,
  cellPopulations = "ALL",
  groupColumn = NULL,
  subGroups = NULL,
  sampleSpecific = FALSE,
  saveFile = TRUE,
  numCores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportCoverage_+3A_sampletileobject">SampleTileObject</code></td>
<td>
<p>The SummarizedExperiment object output from
getSampleTileMatrix</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_dir">dir</code></td>
<td>
<p>string. Directory to save files to.</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_type">type</code></td>
<td>
<p>Boolean. Default is TRUE, and exports Coverage. If set to FALSE,
exports Insertions.</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_cellpopulations">cellPopulations</code></td>
<td>
<p>vector of strings. Cell subsets for which to call
peaks. This list of group names must be identical to names that appear in
the SampleTileObject.  Optional, if cellPopulations='ALL', then peak calling
is done on all cell populations. Default is 'ALL'.</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_groupcolumn">groupColumn</code></td>
<td>
<p>Optional, the column containing sample group labels for
returning coverage within sample groups. Default is NULL, all samples will
be used.</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_subgroups">subGroups</code></td>
<td>
<p>a list of subgroup(s) within the groupColumn from the
metadata. Optional, default is NULL, all labels within groupColumn will be
used.</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_samplespecific">sampleSpecific</code></td>
<td>
<p>If TRUE, a BigWig will export for each sample-cell type
combination.</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_savefile">saveFile</code></td>
<td>
<p>Boolean. If TRUE, it will save to a BigWig. If FALSE, it will
return the GRangesList without writing a BigWig.</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_numcores">numCores</code></td>
<td>
<p>integer. Number of cores to parallelize peak-calling across
multiple cell populations</p>
</td></tr>
<tr><td><code id="exportCoverage_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countSE a SummarizedExperiment containing coverage for the given
input cell populations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MOCHA::exportCoverage(
  SampleTileObject = SampleTileMatrices,
  cellPopulations = "ALL",
  numCores = 30,
  sampleSpecific = FALSE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='exportDifferentials'><code>exportDifferentials</code></h2><span id='topic+exportDifferentials'></span>

<h3>Description</h3>

<p><code>exportDifferentials</code> exports the differential peaks
output GRangesList output from <code>getDifferentialAccessibleTiles</code> to
bigBed format for visualization in genome browsers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportDifferentials(
  SampleTileObject,
  DifferentialsGRList,
  outDir,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportDifferentials_+3A_sampletileobject">SampleTileObject</code></td>
<td>
<p>The SummarizedExperiment object output from
<code>getSampleTileMatrix</code></p>
</td></tr>
<tr><td><code id="exportDifferentials_+3A_differentialsgrlist">DifferentialsGRList</code></td>
<td>
<p>GRangesList output from
<code>getDifferentialAccessibleTiles</code></p>
</td></tr>
<tr><td><code id="exportDifferentials_+3A_outdir">outDir</code></td>
<td>
<p>Desired output directory where bigBed files will be saved</p>
</td></tr>
<tr><td><code id="exportDifferentials_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outList A List of output filepaths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MOCHA::exportDifferentials(
  SampleTileObject = SampleTileMatrices,
  DifferentialsGRList,
  outDir = tempdir(),
  verbose = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='exportMotifs'><code>exportMotifs</code></h2><span id='topic+exportMotifs'></span>

<h3>Description</h3>

<p><code>exportMotifs</code> exports a motif set GRanges from running
<code>addMotifSet(returnSTM=FALSE)</code> to bigBed file files for visualization
in genome browsers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportMotifs(
  SampleTileObject,
  motifsGRanges,
  motifSetName = "motifs",
  filterByOpenTiles = FALSE,
  outDir,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportMotifs_+3A_sampletileobject">SampleTileObject</code></td>
<td>
<p>The SummarizedExperiment object output from
<code>getSampleTileMatrix</code></p>
</td></tr>
<tr><td><code id="exportMotifs_+3A_motifsgranges">motifsGRanges</code></td>
<td>
<p>A GRanges containing motif annotations, typically from
<code>addMotifSet(returnSTM=FALSE)</code></p>
</td></tr>
<tr><td><code id="exportMotifs_+3A_motifsetname">motifSetName</code></td>
<td>
<p>Optional, a name indicating the motif set. Used to name
files in the specified <code>outdir</code>. Default is &quot;motifs&quot;.</p>
</td></tr>
<tr><td><code id="exportMotifs_+3A_filterbyopentiles">filterByOpenTiles</code></td>
<td>
<p>Boolean. If TRUE, a bigBed file will be exported
for each cell population with motifs filtered to those occurring
only in open tiles.</p>
</td></tr>
<tr><td><code id="exportMotifs_+3A_outdir">outDir</code></td>
<td>
<p>Desired output directory where bigBed files will be saved</p>
</td></tr>
<tr><td><code id="exportMotifs_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outList A List of output filepaths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MOCHA::exportMotifs(
  SampleTileObject = SampleTileMatrices,
  motifsGRanges,
  motifSetName = "CISBP",
  filterByOpenTiles = FALSE,
  outDir = tempdir(),
  verbose = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='exportOpenTiles'><code>exportOpenTiles</code></h2><span id='topic+exportOpenTiles'></span>

<h3>Description</h3>

<p><code>exportOpenTiles</code> exports the open tiles of a given cell
population to bigBed file for visualization in genome browsers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportOpenTiles(SampleTileObject, cellPopulation, outDir, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportOpenTiles_+3A_sampletileobject">SampleTileObject</code></td>
<td>
<p>The SummarizedExperiment object output from
<code>getSampleTileMatrix</code></p>
</td></tr>
<tr><td><code id="exportOpenTiles_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>The name of the cell population to export</p>
</td></tr>
<tr><td><code id="exportOpenTiles_+3A_outdir">outDir</code></td>
<td>
<p>Desired output directory where bigBed files will be saved</p>
</td></tr>
<tr><td><code id="exportOpenTiles_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outList A List of output filepaths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
MOCHA::exportOpenTiles(
  SampleTileObject = SampleTileObject,
  cellPopulation,
  outDir = tempdir(),
  verbose = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='exportSmoothedInsertions'><code>exportSmoothedInsertions</code></h2><span id='topic+exportSmoothedInsertions'></span>

<h3>Description</h3>

<p><code>exportSmoothedInsertions</code> Takes a SampleTileMatrix with
linked insertion files and applies a smoothing filter (a rolling sum then
rolling median) to the insertions, finally exporting the smoothed insertion
files to bigwig format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportSmoothedInsertions(
  SampleTileObj,
  cellPopulation,
  outDir = NULL,
  sumWidth = 10,
  medianWidth = 11,
  force = FALSE,
  slow = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportSmoothedInsertions_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>A MultiAssayExperiment or RangedSummarizedExperiment
from MOCHA</p>
</td></tr>
<tr><td><code id="exportSmoothedInsertions_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>A string denoting the cell population of interest</p>
</td></tr>
<tr><td><code id="exportSmoothedInsertions_+3A_outdir">outDir</code></td>
<td>
<p>Directory to write output bigwig files. Default is NULL, where
the directory in 'SampleTileObj@metadata$Directory' will be used.</p>
</td></tr>
<tr><td><code id="exportSmoothedInsertions_+3A_sumwidth">sumWidth</code></td>
<td>
<p>Window size for rolling sum in basepairs. Default is 10.</p>
</td></tr>
<tr><td><code id="exportSmoothedInsertions_+3A_medianwidth">medianWidth</code></td>
<td>
<p>Window size for rolling median in basepairs. Must be odd.
Default is 11.</p>
</td></tr>
<tr><td><code id="exportSmoothedInsertions_+3A_force">force</code></td>
<td>
<p>Set TRUE to overwrite existing files. Default is FALSE.</p>
</td></tr>
<tr><td><code id="exportSmoothedInsertions_+3A_slow">slow</code></td>
<td>
<p>Set TRUE to bypass optimisations and compute smoothing filter
directly on the whole genome. May run slower and consume more RAM. Default
is FALSE.</p>
</td></tr>
<tr><td><code id="exportSmoothedInsertions_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outPaths List of paths of exported insertion files
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Depends on and manipulates files on filesystem
outPath &lt;- MOCHA::exportSmoothedInsertions(
  SampleTileObj,
  cellPopulation = "CD4 Naive", sumWidth = 10, medianWidth = 11, verbose = FALSE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='extractErrorFromConsensusTiles'><code>extractErrorFromConsensusTiles</code></h2><span id='topic+extractErrorFromConsensusTiles'></span>

<h3>Description</h3>

<p><code>extractErrorFromConsensusTiles</code> is an R helper function, part of
the single-cell peak calling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractErrorFromConsensusTiles(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractErrorFromConsensusTiles_+3A_x">x</code></td>
<td>
<p>a specific output from consensus tiles.</p>
</td></tr>
</table>

<hr>
<h2 id='extractRegion'><code>extractRegion</code></h2><span id='topic+extractRegion'></span>

<h3>Description</h3>

<p><code>extractRegion</code> will extract the coverage files created by
callOpenTiles and return a specific region's coverage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractRegion(
  SampleTileObj,
  type = TRUE,
  region,
  cellPopulations = "ALL",
  groupColumn = NULL,
  subGroups = NULL,
  sampleSpecific = FALSE,
  approxLimit = 1e+05,
  binSize = 250,
  sliding = NULL,
  numCores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractRegion_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The SummarizedExperiment object output from
getSampleTileMatrix</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_type">type</code></td>
<td>
<p>Boolean. Default is true, and exports Coverage. If set to FALSE,
exports Insertions.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_region">region</code></td>
<td>
<p>a GRanges object or vector or strings containing the regions of
interest. Strings must be in the format &quot;chr:start-end&quot;, e.g.
&quot;chr4:1300-2222&quot;.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_cellpopulations">cellPopulations</code></td>
<td>
<p>vector of strings. Cell subsets for which to call
peaks. This list of group names must be identical to names that appear in
the SampleTileObj.  Optional, if cellPopulations='ALL', then peak calling
is done on all cell populations. Default is 'ALL'.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_groupcolumn">groupColumn</code></td>
<td>
<p>Optional, the column containing sample group labels for
returning coverage within sample groups. Default is NULL, all samples will
be used.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_subgroups">subGroups</code></td>
<td>
<p>a list of subgroup(s) within the groupColumn from the
metadata. Optional, default is NULL, all labels within groupColumn will be
used.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_samplespecific">sampleSpecific</code></td>
<td>
<p>If TRUE, get a sample-specific count dataframe out.
Default is FALSE, average across samples and get a dataframe out.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_approxlimit">approxLimit</code></td>
<td>
<p>Optional limit to region size, where if region is larger
than approxLimit basepairs, binning will be used. Default is 100000.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_binsize">binSize</code></td>
<td>
<p>Optional numeric, size of bins in basepairs when binning is
used. Default is 250.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_sliding">sliding</code></td>
<td>
<p>Optional numeric. Default is NULL. This number is the size of
the sliding window for generating average intensities.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_numcores">numCores</code></td>
<td>
<p>integer. Number of cores to parallelize peak-calling across
multiple cell populations</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>countSE a SummarizedExperiment containing coverage for the given
input cell populations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
countSE &lt;- MOCHA::extractRegion(
  SampleTileObj = SampleTileMatrices,
  cellPopulations = "ALL",
  region = "chr1:18137866-38139912",
  numCores = 30,
  sampleSpecific = FALSE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='filterCoAccessibleLinks'><code>filterCoAccessibleLinks</code></h2><span id='topic+filterCoAccessibleLinks'></span>

<h3>Description</h3>

<p><code>filterCoAccessibleLinks</code> will filter the output from
getCoAccessibleLinks by a threshold, retaining links with a
absolute correlation greater than the threshold.
This function also adds the chr, start, and end site of each link to
the output table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterCoAccessibleLinks(TileCorr, threshold = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterCoAccessibleLinks_+3A_tilecorr">TileCorr</code></td>
<td>
<p>The correlation table output from getCoAccessibleLinks</p>
</td></tr>
<tr><td><code id="filterCoAccessibleLinks_+3A_threshold">threshold</code></td>
<td>
<p>Keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FilteredTileCorr The filtered correlation table with chr,
start, and end site of each link
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# links is the output of MOCHA::getCoAccessibleLinks
MOCHA::filterCoAccessibleLinks(links, threshold = 0.5)

## End(Not run)

</code></pre>

<hr>
<h2 id='finalModelObject'>finalModelObject</h2><span id='topic+finalModelObject'></span>

<h3>Description</h3>

<p>Trained MOCHA models - LOESS and linear regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalModelObject
</code></pre>


<h3>Format</h3>

<p>A list of lists containing 2 items: &quot;Loess&quot; and &quot;Linear&quot; each with &quot;Total&quot; &quot;Max&quot; and &quot;Intercept&quot;
</p>

<dl>
<dt>Loess</dt><dd><p>LOESS model</p>
</dd>
<dt>Linear</dt><dd><p>Linear model</p>
</dd>
</dl>


<hr>
<h2 id='getAltTSS'>Annotate Peaks falling in Transcription Start Sites
(TSS) and identify alternatively regulated TSSs for each gene.</h2><span id='topic+getAltTSS'></span>

<h3>Description</h3>

<p><code>getAltTSS</code> Pulls out all peaks that fall in TSS,
annotates them with the name of gene, and identifies genes that have
evidence for alternatively regulated TSSs, including both type i (only some
of the open TSSs for a gene are significantly more (or less) accessible),
and type ii (multiple TSSs are significant different, with some being more
accessible and others less). Alternatively, this function  will return all
open TSSs with differential measurements if the returnAllTSS flag is set to
TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAltTSS(
  completeDAPs,
  returnAllTSS = FALSE,
  nuancedTSS = TRUE,
  nuancedTSSGap = 150,
  threshold = 0.2,
  TxDb,
  OrgDb
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAltTSS_+3A_completedaps">completeDAPs</code></td>
<td>
<p>GRanges object that contains the differential
measurements across all peaks (unfiltered DAPs). Will also work with
data.frame or data.table version of a GRanges object. If you want
alternatively regulated TSSs, the object must include a column names 'FDR',
and 'Log2FC_C', which is standard for MOCHA differentials.</p>
</td></tr>
<tr><td><code id="getAltTSS_+3A_returnalltss">returnAllTSS</code></td>
<td>
<p>Flag to return all TSSs with DAPs measurements,
without filtering for alternative TSS usage. If multiple TSSs fall within
the same tile, then that tile will be repeated for each TSS.</p>
</td></tr>
<tr><td><code id="getAltTSS_+3A_nuancedtss">nuancedTSS</code></td>
<td>
<p>True/False flag to determine if alternative TSS genes
should be filtered out if all their differential TSS usage falls within too
small of a range. Default is TRUE</p>
</td></tr>
<tr><td><code id="getAltTSS_+3A_nuancedtssgap">nuancedTSSGap</code></td>
<td>
<p>Minimum distance betweeen TSSs needed for them to
considered distinctly regulated TSSs. If two TSSs are too close, it is
unclear and highly unlikely that ATAC data can distinguish between them.
Default is 150 bp.</p>
</td></tr>
<tr><td><code id="getAltTSS_+3A_threshold">threshold</code></td>
<td>
<p>FDR Threshold for determining significant vs non-significant
changes in accessibility. Following MOCHA's standards, default is 0.2.</p>
</td></tr>
<tr><td><code id="getAltTSS_+3A_txdb">TxDb</code></td>
<td>
<p>The TxDb-class transcript annotation
package for your organism (e.g. &quot;TxDb.Hsapiens.UCSC.hg38.refGene&quot;). This
must be installed. See
<a href="https://bioconductor.org/packages/release/data/annotation/">
Bioconductor AnnotationData Packages</a>.</p>
</td></tr>
<tr><td><code id="getAltTSS_+3A_orgdb">OrgDb</code></td>
<td>
<p>The OrgDb-class genome wide annotation
package for your organism (e.g. &quot;org.Hs.eg.db&quot;). This must be installed.
See <a href="https://bioconductor.org/packages/release/data/annotation/">
Bioconductor AnnotationData Packages</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>tpeaks A GRanges containing annotated peaks falling in TSS
</p>

<hr>
<h2 id='getAnnotationDbFromInstalledPkgname'><code>getAnnotationDbFromInstalledPkgname</code> Loads and attaches an installed TxDb or
OrgDb-class Annotation database package.</h2><span id='topic+getAnnotationDbFromInstalledPkgname'></span>

<h3>Description</h3>

<p>See <a href="BSgenome.html#topic+getBSgenome">getBSgenome</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAnnotationDbFromInstalledPkgname(dbName, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAnnotationDbFromInstalledPkgname_+3A_dbname">dbName</code></td>
<td>
<p>Exact name of installed annotation data package.</p>
</td></tr>
<tr><td><code id="getAnnotationDbFromInstalledPkgname_+3A_type">type</code></td>
<td>
<p>Expected class of the annotation data package, must be
either &quot;OrgDb&quot; or &quot;TxDb&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the loaded Annotation database object.#' @noRd
</p>

<hr>
<h2 id='getCellPopMatrix'><code>getCellPopMatrix</code></h2><span id='topic+getCellPopMatrix'></span>

<h3>Description</h3>

<p><code>getCellPopMatrix</code> pulls out the SampleTileMatrix of tiles
called in one given cell population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCellPopMatrix(
  SampleTileObj,
  cellPopulation,
  dropSamples = TRUE,
  NAtoZero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCellPopMatrix_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The output from getSampleTileMatrix, a
SummarizedExperiment of pseudobulk intensities across all tiles &amp; cell
types.</p>
</td></tr>
<tr><td><code id="getCellPopMatrix_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>The cell population you want to pull out.</p>
</td></tr>
<tr><td><code id="getCellPopMatrix_+3A_dropsamples">dropSamples</code></td>
<td>
<p>Boolean flag to determine whether to drop samples that
were too small for peak calling.</p>
</td></tr>
<tr><td><code id="getCellPopMatrix_+3A_natozero">NAtoZero</code></td>
<td>
<p>Boolean flag to determine whether to replace NAs with zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sampleTileMatrix a matrix of samples by called tiles for a given cell
population.
</p>

<hr>
<h2 id='getCellTypes'><code>getCellTypes</code> Extract cell type names from a Tile Results or Sample Tile object.</h2><span id='topic+getCellTypes'></span>

<h3>Description</h3>

<p><code>getCellTypes</code> Returns a vector of cell names from a Tile Results or Sample Tile object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCellTypes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCellTypes_+3A_object">object</code></td>
<td>
<p>tileResults object from callOpenTiles or SummarizedExperiment from getSampleTileMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of cell type names.
</p>

<hr>
<h2 id='getCellTypeTiles'><code>getCellTypeTiles</code> Extract the GRanges for a particular cell type</h2><span id='topic+getCellTypeTiles'></span>

<h3>Description</h3>

<p><code>getCellTypeTiles</code> Returns a GRanges object of all tiles called for a certain cell type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCellTypeTiles(object, cellType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCellTypeTiles_+3A_object">object</code></td>
<td>
<p>A SampleTileObject.</p>
</td></tr>
<tr><td><code id="getCellTypeTiles_+3A_celltype">cellType</code></td>
<td>
<p>A string describing one cell type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of cell type names.
</p>

<hr>
<h2 id='getCoAccessibleLinks'><code>getCoAccessibleLinks</code></h2><span id='topic+getCoAccessibleLinks'></span>

<h3>Description</h3>

<p><code>getCoAccessibleLinks</code> takes an input set of regions (tiles) and finds co-accessible neighboring regions within a window. Co-accessibility is defined as the correlation between two region intensity (openness) across samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoAccessibleLinks(
  SampleTileObj,
  cellPopulation = "All",
  regions,
  chrChunks = 1,
  windowSize = 1 * 10^6,
  numCores = 1,
  ZI = TRUE,
  approximateTile = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoAccessibleLinks_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The SummarizedExperiment object output from getSampleTileMatrix containing your sample-tile matrices</p>
</td></tr>
<tr><td><code id="getCoAccessibleLinks_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>A string denoting the cell population of interest, which must be present in SampleTileObj</p>
</td></tr>
<tr><td><code id="getCoAccessibleLinks_+3A_regions">regions</code></td>
<td>
<p>a GRanges object or vector or strings containing the regions on which to compute co-accessible links. Strings must be in the format &quot;chr:start-end&quot;, e.g. &quot;chr4:1300-2222&quot;.
Can be the output from getDifferentialAccessibleTiles.</p>
</td></tr>
<tr><td><code id="getCoAccessibleLinks_+3A_chrchunks">chrChunks</code></td>
<td>
<p>This functions subsets by groups of chromosome, and then parallelizes within each group of chromosomes when running correlations. This method keeps memory
low. To speed things up on high performing platforms, you can chunk out more than one chromosome at a time. Default is chrChunks = 1, so only one chromosome at a time.</p>
</td></tr>
<tr><td><code id="getCoAccessibleLinks_+3A_windowsize">windowSize</code></td>
<td>
<p>the size of the window, in basepairs, around each input region to search for co-accessible links</p>
</td></tr>
<tr><td><code id="getCoAccessibleLinks_+3A_numcores">numCores</code></td>
<td>
<p>Optional, the number of cores to use with multiprocessing. Default is 1.</p>
</td></tr>
<tr><td><code id="getCoAccessibleLinks_+3A_zi">ZI</code></td>
<td>
<p>boolean flag that enables zero-inflated (ZI) Spearman correlations to be used. Default is TRUE. If FALSE, skip zero-inflation and calculate the normal Spearman.</p>
</td></tr>
<tr><td><code id="getCoAccessibleLinks_+3A_approximatetile">approximateTile</code></td>
<td>
<p>If set to TRUE, it will use all tiles that overlap with the regions given, instead of finding an exact match to the regions variable. Default is FALSE.</p>
</td></tr>
<tr><td><code id="getCoAccessibleLinks_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The technical details of the zero-inflated correlation can be
found here:
</p>
<p>Pimentel, Ronald Silva, &quot;Kendall's Tau and Spearman's Rho
for Zero-Inflated Data&quot; (2009). Dissertations.
</p>
<p>while the implementation (scHOT R package), can be found here:
http://www.bioconductor.org/packages/release/bioc/html/scHOT.html
</p>


<h3>Value</h3>

<p>TileCorr A data.table correlation matrix
</p>

<hr>
<h2 id='getCoverage'>Get sample-specific coverage files for each sample-cell population.</h2><span id='topic+getCoverage'></span>

<h3>Description</h3>

<p>getCoverage takes the output of MOCHA::getPopFrags and returns
a GRanges of singe-basepair resolution coverage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCoverage(
  popFrags,
  normFactor,
  TxDb,
  cl,
  filterEmpty = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoverage_+3A_popfrags">popFrags</code></td>
<td>
<p>GRangesList of fragments for all sample/cell populations</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_normfactor">normFactor</code></td>
<td>
<p>Normalization factor. Can be either be one, in which case all coverage files will be normalized by the same value, or the same length as the GRangesList</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_txdb">TxDb</code></td>
<td>
<p>The TxDb-class transcript annotation
package for your organism (e.g. &quot;TxDb.Hsapiens.UCSC.hg38.refGene&quot;). This
must be installed. See
<a href="https://bioconductor.org/packages/release/data/annotation/">
Bioconductor AnnotationData Packages</a>.</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_cl">cl</code></td>
<td>
<p>cl argument to <code><a href="pbapply.html#topic+pblapply">pblapply</a></code></p>
</td></tr>
<tr><td><code id="getCoverage_+3A_filterempty">filterEmpty</code></td>
<td>
<p>True/False flag on whether or not to carry forward regions without coverage.</p>
</td></tr>
<tr><td><code id="getCoverage_+3A_verbose">verbose</code></td>
<td>
<p>Boolean variable to determine verbosity of output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>popCounts A GRangesList of coverage for each sample and cell population
</p>

<hr>
<h2 id='getDifferentialAccessibleTiles'><code>getDifferentialAccessibleTiles</code></h2><span id='topic+getDifferentialAccessibleTiles'></span>

<h3>Description</h3>

<p><code>getDifferentialAccessibleTiles</code> allows you to
determine whether regions of chromatin are differentially accessible
between groups by conducting a test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDifferentialAccessibleTiles(
  SampleTileObj,
  cellPopulation,
  groupColumn,
  foreground,
  background,
  signalThreshold = 12,
  minZeroDiff = 0.5,
  fdrToDisplay = 0.2,
  outputGRanges = TRUE,
  numCores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The SummarizedExperiment object output from
getSampleTileMatrix</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>A string denoting the cell population of interest</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_groupcolumn">groupColumn</code></td>
<td>
<p>The column containing sample group labels</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_foreground">foreground</code></td>
<td>
<p>The foreground group of samples for differential comparison</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_background">background</code></td>
<td>
<p>The background group of samples for differential comparison</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_signalthreshold">signalThreshold</code></td>
<td>
<p>Minimum median intensity required to keep tiles for
differential testing to increase statistical power in small sample cohorts.
Default is 12.</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_minzerodiff">minZeroDiff</code></td>
<td>
<p>Minimum difference in average dropout rates across groups
require to keep tiles for differential testing. Default is 0.5 (50%).</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_fdrtodisplay">fdrToDisplay</code></td>
<td>
<p>False-discovery rate used only for standard
output messaging. Default is 0.2.</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_outputgranges">outputGRanges</code></td>
<td>
<p>Outputs a GRanges if TRUE and a data.frame if
FALSE. Default is TRUE.</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_numcores">numCores</code></td>
<td>
<p>The number of cores to use with multiprocessing.
Default is 1.</p>
</td></tr>
<tr><td><code id="getDifferentialAccessibleTiles_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>full_results The differential accessibility results as a GRanges or
matrix data.frame depending on the flag 'outputGRanges'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cellPopulation &lt;- "MAIT"
foreground &lt;- "Positive"
background &lt;- "Negative"
# Standard output will display the number of tiles found below a false-discovery rate threshold.
# This parameter does not filter results and only affects the aforementioned message.
fdrToDisplay &lt;- 0.2
# Choose to output a GRanges or data.frame.
# Default is TRUE
outputGRanges &lt;- TRUE
# SampleTileMatrices is the output of MOCHA::getSampleTileMatrix
differentials &lt;- MOCHA::getDifferentialAccessibleTiles(
  SampleTileObj = SampleTileMatrices,
  cellPopulation = cellPopulation,
  groupColumn = groupColumn,
  foreground = foreground,
  background = background,
  fdrToDisplay = fdrToDisplay,
  outputGRanges = outputGRanges,
  numCores = numCores
)

## End(Not run)
</code></pre>

<hr>
<h2 id='getIntensityThreshold'><code>getIntensityThreshold</code></h2><span id='topic+getIntensityThreshold'></span>

<h3>Description</h3>

<p><code>getIntensityThreshold</code> takes the output of peak calling with
callOpenTiles and creates sample-tile matrices containing the signal
intensity at each tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIntensityThreshold(
  TSAM,
  cellPopulations = "all",
  type = "mean",
  returnPlots = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIntensityThreshold_+3A_tsam">TSAM</code></td>
<td>
<p>a SummarizedExperiment object generated by MOCHA</p>
</td></tr>
<tr><td><code id="getIntensityThreshold_+3A_cellpopulations">cellPopulations</code></td>
<td>
<p>vector of strings. Cell subsets found in the TSAM, or the word 'All' if all should be used.</p>
</td></tr>
<tr><td><code id="getIntensityThreshold_+3A_type">type</code></td>
<td>
<p>string. Describes the type of metric to be used. Options include median or mean.</p>
</td></tr>
<tr><td><code id="getIntensityThreshold_+3A_returnplots">returnPlots</code></td>
<td>
<p>Boolean. Default is TRUE and returns a plot of</p>
</td></tr>
<tr><td><code id="getIntensityThreshold_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot object
</p>

<hr>
<h2 id='getModelValues'>getModelValues from runZIGLMM output.</h2><span id='topic+getModelValues'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
This function is deprecated - improved modeling functions can be found in 
the package &quot;ChAI&quot; at https://github.com/aifimmunology/ChAI
<code>getModelValues</code> Pull out a data.frame of model values (slope, significance, and std.error) for a given factor from the SummarizedExperiment output of runZIGLMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModelValues(object, specificVariable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getModelValues_+3A_object">object</code></td>
<td>
<p>A SummarizedExperiment object generated from runZIGLMM.</p>
</td></tr>
<tr><td><code id="getModelValues_+3A_specificvariable">specificVariable</code></td>
<td>
<p>A string, describing the factor of influence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of slopes, significance, and standard error for one factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
age_df &lt;- getModelValues(runZIGLMM_output, "Age")

## End(Not run)

</code></pre>

<hr>
<h2 id='getPopFrags'>Extract fragments by populations from an ArchR Project</h2><span id='topic+getPopFrags'></span>

<h3>Description</h3>

<p><code>getPopFrags</code> returns a list of sample-specific fragments per cell population as a GRangesList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPopFrags(
  ArchRProj,
  cellPopLabel,
  cellSubsets = "ALL",
  poolSamples = FALSE,
  numCores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPopFrags_+3A_archrproj">ArchRProj</code></td>
<td>
<p>The ArchR Project.</p>
</td></tr>
<tr><td><code id="getPopFrags_+3A_cellpoplabel">cellPopLabel</code></td>
<td>
<p>The name of the metadata column of the ArchR Project that contains the populations
of cells you want to extract fragments from.</p>
</td></tr>
<tr><td><code id="getPopFrags_+3A_cellsubsets">cellSubsets</code></td>
<td>
<p>Default is 'ALL'. If you want to export only some populations,
then give it a list of group names. This needs to be unique - no duplicated
names. This list of group names must be identical to names that appear in
the given cellPopLabel metadata column of the ArchR Project.</p>
</td></tr>
<tr><td><code id="getPopFrags_+3A_poolsamples">poolSamples</code></td>
<td>
<p>Set TRUE to pool sample-specific fragments by cell population. By default this is FALSE and sample-specific fragments are returned.</p>
</td></tr>
<tr><td><code id="getPopFrags_+3A_numcores">numCores</code></td>
<td>
<p>Number of cores to use.</p>
</td></tr>
<tr><td><code id="getPopFrags_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of GRanges containing fragments. Each GRanges corresponds to a
population defined by cellSubsets and sample.
</p>

<hr>
<h2 id='getPromoterGenes'><code>getPromoterGenes</code></h2><span id='topic+getPromoterGenes'></span>

<h3>Description</h3>

<p><code>getPromoterGenes</code> Takes a rowRanges from annotateTiles and extracts a unique list of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPromoterGenes(GRangesObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPromoterGenes_+3A_grangesobj">GRangesObj</code></td>
<td>
<p>a GRanges object with a metadata column for tileType and Gene.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of strings with gene names.
</p>

<hr>
<h2 id='getSampleCellTypeMetadata'><code>getSampleCellTypeMetadata</code> Extract Sample-celltype specific metadata</h2><span id='topic+getSampleCellTypeMetadata'></span>

<h3>Description</h3>

<p><code>getSampleCellTypeMetadata</code> Extract Sample-celltype specific metadata like fragment number, cell counts, and
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleCellTypeMetadata(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSampleCellTypeMetadata_+3A_object">object</code></td>
<td>
<p>tileResults object from callOpenTiles or SummarizedExperiment from getSampleTileMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SummarizedExperiment where each assay is a different type of metadata.
</p>

<hr>
<h2 id='getSampleTileMatrix'><code>getSampleTileMatrix</code></h2><span id='topic+getSampleTileMatrix'></span>

<h3>Description</h3>

<p><code>getSampleTileMatrix</code> takes the output of peak calling with
callOpenTiles and creates sample-tile matrices containing the signal
intensity at each tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleTileMatrix(
  tileResults,
  cellPopulations = "ALL",
  groupColumn = NULL,
  threshold = 0.2,
  numCores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSampleTileMatrix_+3A_tileresults">tileResults</code></td>
<td>
<p>a MultiAssayExperiment returned by callOpenTiles
containing containing peak calling results.</p>
</td></tr>
<tr><td><code id="getSampleTileMatrix_+3A_cellpopulations">cellPopulations</code></td>
<td>
<p>vector of strings. Cell subsets in TileResults for
which to generate sample-tile matrices. This list of group names must be
identical to names that appear in the ArchRProject metadata.  If
cellPopulations='ALL', then peak calling is done on all cell populations in
the ArchR project metadata. Default is 'ALL'.</p>
</td></tr>
<tr><td><code id="getSampleTileMatrix_+3A_groupcolumn">groupColumn</code></td>
<td>
<p>Optional, the column containing sample group labels for
determining consensus tiles within sample groups. Default is NULL, all
samples will be used for determining consensus tiles.</p>
</td></tr>
<tr><td><code id="getSampleTileMatrix_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for consensus tiles, the minimum % of samples
(within a sample group, if groupColumn is set) that a peak must be called
in to be retained. If set to 0, retain the union of all samples' peaks
(this is equivalent to a threshold of 1/numSamples). It is recommended to
tune this parameter to omit potentially spurious peaks.</p>
</td></tr>
<tr><td><code id="getSampleTileMatrix_+3A_numcores">numCores</code></td>
<td>
<p>Optional, the number of cores to use with multiprocessing.
Default is 1.</p>
</td></tr>
<tr><td><code id="getSampleTileMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SampleTileMatrices a MultiAssayExperiment containing a sample-tile
intensity matrix for each cell population
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Starting from GRangesList
if (
  require(BSgenome.Hsapiens.UCSC.hg19) &amp;&amp;
    require(TxDb.Hsapiens.UCSC.hg38.refGene) &amp;&amp;
    require(org.Hs.eg.db)
) {
  tiles &lt;- MOCHA::callOpenTiles(
    ATACFragments = MOCHA::exampleFragments,
    cellColData = MOCHA::exampleCellColData,
    blackList = MOCHA::exampleBlackList,
    genome = "BSgenome.Hsapiens.UCSC.hg19",
    TxDb = "TxDb.Hsapiens.UCSC.hg38.refGene",
    Org = "org.Hs.eg.db",
    outDir = tempdir(),
    cellPopLabel = "Clusters",
    cellPopulations = c("C2", "C5"),
    numCores = 1
  )

  SampleTileMatrices &lt;- MOCHA::getSampleTileMatrix(
    tiles,
    cellPopulations = c("C2", "C5"),
    threshold = 0 # Take union of all samples' open tiles
  )
}


</code></pre>

<hr>
<h2 id='getSequencingBias'><code>getSequencingBias</code></h2><span id='topic+getSequencingBias'></span>

<h3>Description</h3>

<p><code>getSequencingBias</code> takes the output of peak calling with
callOpenTiles and creates sample-tile matrices containing the signal
intensity at each tile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSequencingBias(
  SampleTileObj,
  cellPopulations = "all",
  cellPopulation,
  groupColumn,
  foreground,
  background,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSequencingBias_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>a SummarizedExperiment object generated by MOCHA</p>
</td></tr>
<tr><td><code id="getSequencingBias_+3A_cellpopulations">cellPopulations</code></td>
<td>
<p>vector of strings. Cell subsets found in the TSAM, or the word 'All' if all should be used.</p>
</td></tr>
<tr><td><code id="getSequencingBias_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>A string denoting the cell population of interest</p>
</td></tr>
<tr><td><code id="getSequencingBias_+3A_groupcolumn">groupColumn</code></td>
<td>
<p>The column containing sample group labels</p>
</td></tr>
<tr><td><code id="getSequencingBias_+3A_foreground">foreground</code></td>
<td>
<p>The foreground group of samples for differential comparison</p>
</td></tr>
<tr><td><code id="getSequencingBias_+3A_background">background</code></td>
<td>
<p>The background group of samples for differential comparison</p>
</td></tr>
<tr><td><code id="getSequencingBias_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot object
</p>

<hr>
<h2 id='GRangesToString'><code>GRangesToString</code> Converts a GRanges object to a string in the format 'chr1:100-200'</h2><span id='topic+GRangesToString'></span>

<h3>Description</h3>

<p><code>GRangesToString</code> Turns a GRanges Object into
a list of strings in the format chr1:100-200
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRangesToString(GR_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRangesToString_+3A_gr_obj">GR_obj</code></td>
<td>
<p>the GRanges object to convert to a string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string or list of strings in the format 'chr1:100-200' representing
ranges in the input GRanges
</p>

<hr>
<h2 id='mergeTileResults'><code>mergeTileResults</code></h2><span id='topic+mergeTileResults'></span>

<h3>Description</h3>

<p><code>mergeTileResults</code> merges a list of tileResults that
each contain unique samples into a single object encompassing all samples.
Only cell populations shared among all input tileResults will be retained.
This function can merge MultiAssayExperiment objects from callOpenTiles
that are created with the same TxDb, OrgDb, and Genome assembly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeTileResults(tileResultsList, numCores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTileResults_+3A_tileresultslist">tileResultsList</code></td>
<td>
<p>List of MultiAssayExperiments objects returned by
callOpenTiles containing containing peak calling results.</p>
</td></tr>
<tr><td><code id="mergeTileResults_+3A_numcores">numCores</code></td>
<td>
<p>Optional, the number of cores to use with multiprocessing.
Default is 1.</p>
</td></tr>
<tr><td><code id="mergeTileResults_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tileResults a single MultiAssayExperiment containing a sample-tile
intensity matrix for each sample and common cell population in the input
tileResultsList.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Depends on local MOCHA tileResults
MOCHA::mergeTileResults(
  list(tileResultsCelltypesABC, tileResultsCelltypesBCD)
)

## End(Not run)

</code></pre>

<hr>
<h2 id='MotifEnrichment'><code>MotifEnrichment</code></h2><span id='topic+MotifEnrichment'></span>

<h3>Description</h3>

<p>Test for enrichment of motifs within Group1 against a background
Group2 using a hypergeometric t-test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MotifEnrichment(Group1, Group2, motifPosList, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MotifEnrichment_+3A_group1">Group1</code></td>
<td>
<p>A GRanges object, such as a set of significant differential
tiles.</p>
</td></tr>
<tr><td><code id="MotifEnrichment_+3A_group2">Group2</code></td>
<td>
<p>A GRanges object containing background regions, non-overlapping
with Group1</p>
</td></tr>
<tr><td><code id="MotifEnrichment_+3A_motifposlist">motifPosList</code></td>
<td>
<p>A GRangesList of motifs and positions for each motif.
Must be named for each motif.</p>
</td></tr>
<tr><td><code id="MotifEnrichment_+3A_type">type</code></td>
<td>
<p>Optional, name of a metadata column in Group1 and Group2 to test
for enrichment the number of unique entries in column given by 'type'.
Default is NULL, which tests the number of Ranges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing enrichment for each group
</p>

<hr>
<h2 id='MotifSetEnrichmentAnalysis'><code>MotifSetEnrichmentAnalysis</code></h2><span id='topic+MotifSetEnrichmentAnalysis'></span>

<h3>Description</h3>

<p>This analogous to Gene Set
Enrichment Analysis. Instead of testing for enrichment of a geneset with a
given gene set in a pathway, we are testing the enrichment of a given TF
motif set against a motif set downstream of a multiple ligands. If there is
enrichment, it's a sign that that ligand could drive that set of motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MotifSetEnrichmentAnalysis(
  ligandTFMatrix,
  motifEnrichmentDF,
  motifColumn,
  ligands,
  statColumn,
  statThreshold,
  annotationName = "CellType",
  annotation = "none",
  numCores = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_ligandtfmatrix">ligandTFMatrix</code></td>
<td>
<p>NicheNet Ligand-TF matrix</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_motifenrichmentdf">motifEnrichmentDF</code></td>
<td>
<p>Dataframe (unfiltered) from ArchR's peakAnnoEnrich
step. Expected to have a column with motif names, and a column with the
-log10 adjusted p-values.</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_motifcolumn">motifColumn</code></td>
<td>
<p>Column name within the motifEnrichmentDF that has motif
names.</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_ligands">ligands</code></td>
<td>
<p>Vector of ligands to test</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_statcolumn">statColumn</code></td>
<td>
<p>Column name in motifEnrichmentDF containing the statistic
to test</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_statthreshold">statThreshold</code></td>
<td>
<p>Significance threshold used to select significant motif
set</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_annotationname">annotationName</code></td>
<td>
<p>Optional column name for the annotation. Default is
&quot;CellType&quot;.</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_annotation">annotation</code></td>
<td>
<p>Optional annotation value added to all rows of the output
motif dataframe. Can be character vector or numeric. Default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_numcores">numCores</code></td>
<td>
<p>The number of cores to use with multiprocessing. Default is
1.</p>
</td></tr>
<tr><td><code id="MotifSetEnrichmentAnalysis_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>specDF A dataframe containing enrichment analysis results
</p>

<hr>
<h2 id='packMOCHA'><code>packMOCHA</code></h2><span id='topic+packMOCHA'></span>

<h3>Description</h3>

<p><code>packMOCHA</code> combines a MOCHA object (Sample-Tile
Matrix or tileResults) with its saved coverage tracks into a single zip
archive. This allows MOCHA objects and the necessary coverage files for
plotting to be shared to other file systems. See also:
<a href="#topic+unpackMOCHA">unpackMOCHA</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packMOCHA(MOCHAObj, zipfile, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="packMOCHA_+3A_mochaobj">MOCHAObj</code></td>
<td>
<p>A MultiAssayExperiment or RangedSummarizedExperiment, from
MOCHA</p>
</td></tr>
<tr><td><code id="packMOCHA_+3A_zipfile">zipfile</code></td>
<td>
<p>Filename and path of the zip archive.</p>
</td></tr>
<tr><td><code id="packMOCHA_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zipfile Path to zip archive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Depends on and manipulates files on filesystem
myOutputDir &lt;- "/home/documents/MOCHA_out"
zipPath &lt;- MOCHA::packMOCHA(
  tileResults, zipfile = file.path(myOutputDir, "testzip.zip")
)

## End(Not run)

</code></pre>

<hr>
<h2 id='pilotLMEM'>Execute a pilot run of single linear model on a subset of data</h2><span id='topic+pilotLMEM'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
This function is deprecated - improved modeling functions can be found in 
the package &quot;ChAI&quot; at https://github.com/aifimmunology/ChAI
<code>pilotLMEM</code> Runs linear mixed-effects modeling for
continuous, non-zero inflated data using <code><a href="lmerTest.html#topic+lmer">lmer</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pilotLMEM(
  ExperimentObj,
  assayName,
  modelFormula,
  pilotIndices = 1:10,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pilotLMEM_+3A_experimentobj">ExperimentObj</code></td>
<td>
<p>A SummarizedExperiment-type object generated from
chromVAR, makePseudobulkRNA, or other. Objects from getSampleTileMatrix can work,
but we recommend runZIGLMM for those objects, not runLMEM&gt;</p>
</td></tr>
<tr><td><code id="pilotLMEM_+3A_assayname">assayName</code></td>
<td>
<p>a character string, matching the name of an assay within the SummarizedExperiment.
The assay named will be used for modeling.</p>
</td></tr>
<tr><td><code id="pilotLMEM_+3A_modelformula">modelFormula</code></td>
<td>
<p>The formula to use with lmerTest::lmer, in the
format (exp ~ factors). All factors must be found in column names
of the ExperimentObj metadata.</p>
</td></tr>
<tr><td><code id="pilotLMEM_+3A_pilotindices">pilotIndices</code></td>
<td>
<p>A vector of integers defining the subset of
the ExperimentObj matrix. Default is 1:10.</p>
</td></tr>
<tr><td><code id="pilotLMEM_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modelList a list of outputs from lmerTest::lmer
</p>

<hr>
<h2 id='pilotZIGLMM'>Execute a pilot run of model on a subset of data</h2><span id='topic+pilotZIGLMM'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
This function is deprecated - improved modeling functions can be found in 
the package &quot;ChAI&quot; at https://github.com/aifimmunology/ChAI
<code>pilotLMEM</code> Runs linear mixed-effects modeling for zero
inflated data using <code><a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a></code>. TryCatch will catch
errors, and return the error and dataframe for troubleshooting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pilotZIGLMM(
  TSAM_Object,
  cellPopulation = NULL,
  continuousFormula = NULL,
  ziformula = NULL,
  zi_threshold = 0,
  verbose = FALSE,
  pilotIndices = 1:10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pilotZIGLMM_+3A_tsam_object">TSAM_Object</code></td>
<td>
<p>A SummarizedExperiment object generated from
getSampleTileMatrix, chromVAR, or other.</p>
</td></tr>
<tr><td><code id="pilotZIGLMM_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>A single cell population on which to run this pilot
model</p>
</td></tr>
<tr><td><code id="pilotZIGLMM_+3A_continuousformula">continuousFormula</code></td>
<td>
<p>The formula, see <code><a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a></code>.
Combined fixed and random effects formula, following lme4 syntax.</p>
</td></tr>
<tr><td><code id="pilotZIGLMM_+3A_ziformula">ziformula</code></td>
<td>
<p>The zero-inflated formula, see
<code><a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a></code>. a one-sided (i.e., no response variable)
formula for zero-inflation combining fixed and random effects: the default
~0 specifies no zero-inflation. Specifying ~. sets the zero-inflation
formula identical to the right-hand side of formula (i.e., the conditional
effects formula); terms can also be added or subtracted. When using ~. as
the zero-inflation formula in models where the conditional effects formula
contains an offset term, the offset term will automatically be dropped. The
zero-inflation model uses a logit link.</p>
</td></tr>
<tr><td><code id="pilotZIGLMM_+3A_zi_threshold">zi_threshold</code></td>
<td>
<p>Zero-inflated threshold (range = 0-1), representing the
fraction of samples with zeros. When the percentage of zeros in the tile is
between 0 and zi_threshold, samples with zeroes are dropped and only the
continous formula is used. Use this parameter at your own risk. Default is
0.</p>
</td></tr>
<tr><td><code id="pilotZIGLMM_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="pilotZIGLMM_+3A_pilotindices">pilotIndices</code></td>
<td>
<p>A vector of integers defining the subset of the
ExperimentObj matrix. Default is 1:10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modelList a list of outputs from glmmTMB::glmmTMB
</p>

<hr>
<h2 id='plotConsensus'><code>plotConsensus</code></h2><span id='topic+plotConsensus'></span>

<h3>Description</h3>

<p><code>plotConsensus</code> Extracts the peak reproducibility and generates a
heuristic plots that can be used to determine the reproducibility threshold
used within getSampleTileMatrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConsensus(
  tileObject,
  cellPopulations = "All",
  groupColumn = NULL,
  returnPlotList = FALSE,
  returnDFs = FALSE,
  numCores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotConsensus_+3A_tileobject">tileObject</code></td>
<td>
<p>A MultiAssayExperiment object from callOpenTiles,</p>
</td></tr>
<tr><td><code id="plotConsensus_+3A_cellpopulations">cellPopulations</code></td>
<td>
<p>the cell populations you want to visualize.</p>
</td></tr>
<tr><td><code id="plotConsensus_+3A_groupcolumn">groupColumn</code></td>
<td>
<p>Optional parameter, same as in getSampleTileMatrix, which defines whether you
want to plot reproducibility within each</p>
</td></tr>
<tr><td><code id="plotConsensus_+3A_returnplotlist">returnPlotList</code></td>
<td>
<p>Instead of one plot with all celltypes/conditions, it returns a list of plots for each cell types</p>
</td></tr>
<tr><td><code id="plotConsensus_+3A_returndfs">returnDFs</code></td>
<td>
<p>Instead of a plot, returns a data.frame of the reproducibility across samples.
If set to false, then it plots the data.frame instead of returning it.</p>
</td></tr>
<tr><td><code id="plotConsensus_+3A_numcores">numCores</code></td>
<td>
<p>Number of cores to multithread over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SampleTileObj the input data structure with added gene annotations.
</p>

<hr>
<h2 id='plotIntensityDistribution'><code>plotIntensityDistribution</code></h2><span id='topic+plotIntensityDistribution'></span>

<h3>Description</h3>

<p><code>plotIntensityDistribution</code>  Plots the distribution of sample-tile intensities for a give cell type
</p>
<p><code>plotIntensityDistribution</code>  Plots the distribution of sample-tile intensities for a give cell type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotIntensityDistribution(
  TSAM_object,
  cellPopulation,
  returnDF = FALSE,
  density = TRUE
)

plotIntensityDistribution(
  TSAM_object,
  cellPopulation,
  returnDF = FALSE,
  density = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotIntensityDistribution_+3A_tsam_object">TSAM_object</code></td>
<td>
<p>SummarizedExperiment from getSampleTileMatrix</p>
</td></tr>
<tr><td><code id="plotIntensityDistribution_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>Cell type names (assay name) within the TSAM_object</p>
</td></tr>
<tr><td><code id="plotIntensityDistribution_+3A_returndf">returnDF</code></td>
<td>
<p>If TRUE, return the data frame without plotting. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotIntensityDistribution_+3A_density">density</code></td>
<td>
<p>Boolean to determine whether to plot density or histogram. Default is TRUE (plots density).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or ggplot histogram.
</p>
<p>data.frame or ggplot histogram.
</p>

<hr>
<h2 id='plotRegion'><code>plotRegion</code></h2><span id='topic+plotRegion'></span>

<h3>Description</h3>

<p><code>plotRegion</code> Plots the region that you've summarized across
all cell groupings (groups=initial getPopFrags() split) with optional motif
overlay, chromosome position ideogram, and additional GRanges tracks. If
plotting motif overlay, ensure that motif annotations have been added to
your counts SummarizedExperiment. A basic plot can be rendered with just a
counts SummarizedExperiment, but additional formatting arguments allow for
further customization. Note that to show specific genes with the option
'whichGenes' the <span class="pkg">RMariaDB</span> package must be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRegion(
  countSE,
  plotType = "area",
  base_size = 12,
  counts_color = NULL,
  range_label_size = 2,
  legend.position = NULL,
  legendRatio = 0.25,
  facet_label_side = "top",
  counts_color_var = "Groups",
  counts_group_colors = NULL,
  counts_theme_ls = NULL,
  motifSetName = NULL,
  motif_y_space_factor = 4,
  motif_stagger_labels_y = FALSE,
  motif_weights = NULL,
  motif_weight_name = "Motif Weight",
  motif_weight_colors = c(darkblue = -10, gray = 0, darkred = 10),
  motif_lab_size = 1,
  motif_lab_alpha = 0.25,
  motif_line_alpha = 0.25,
  motif_line_size = 0.75,
  showGene = TRUE,
  whichGenes = NULL,
  monotoneGenes = FALSE,
  db_id_col = "REFSEQ",
  collapseGenes = FALSE,
  gene_theme_ls = NULL,
  additionalGRangesTrack = NULL,
  linkdf = NULL,
  showIdeogram = TRUE,
  ideogram_genome = "hg19",
  relativeHeights = c(Chr = 0.9, `Normalized Counts` = 7, Links = 1.5, Genes = 2,
    AdditionalGRanges = 4.5),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRegion_+3A_countse">countSE</code></td>
<td>
<p>A SummarizedExperiment from MOCHA::getCoverage</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_plottype">plotType</code></td>
<td>
<p>Options include 'overlaid','area', 'line', or 'RidgePlot'.
default is 'area', which will plot a separate track for each group with the
area filled in under the curve. Setting plotType to 'overlaid' will overlay
count plot histograms across samples, instead of faceting out separately.
Setting plotType to 'RidgePlot' will generate a RidgePlot across all
groups.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_base_size">base_size</code></td>
<td>
<p>Numeric, default 12. Global plot base text size parameter</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_counts_color">counts_color</code></td>
<td>
<p>Optional color palette. A named vector of color values
where names are unique values in the 'color_var' column</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_range_label_size">range_label_size</code></td>
<td>
<p>Numeric value, default 4. Text size for the y-axis
range label</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_legend.position">legend.position</code></td>
<td>
<p>Any acceptable 'legend.position' argument to theme().
Default NULL will place legend for overlaid plots at (0.8,0.8), or to the
&quot;right&quot; for faceted plots.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_legendratio">legendRatio</code></td>
<td>
<p>Ratio of width or height of the main plot to the legend. Useful if the legend is to large. If only used when legend.position is set to top, bottom, left, or right.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_facet_label_side">facet_label_side</code></td>
<td>
<p>Direction character value, default &quot;top&quot;. Can also be
&quot;right&quot;, &quot;left&quot;, or &quot;bottom&quot;. Position of facet label.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_counts_color_var">counts_color_var</code></td>
<td>
<p>Character value, default &quot;Groups&quot;. Column name from
countdf to use to color counts plots. Only used if counts_group_colors
provided</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_counts_group_colors">counts_group_colors</code></td>
<td>
<p>Optional named color vector. Values as colors,
names are levels of 'counts_color_var'. If provided, will color the plots
specifically using 'scale_color_manual()'</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_counts_theme_ls">counts_theme_ls</code></td>
<td>
<p>A list of named theme arguments passed to theme(). For
example, 'list(axis.ticks = element_blank())'. Default NULL will use
'.counts_plot_default_theme'.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motifsetname">motifSetName</code></td>
<td>
<p>The name of the motif set in ArchRProj to use for
annotation. Example: 'JasparMotifs'</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_y_space_factor">motif_y_space_factor</code></td>
<td>
<p>A factor for vertical spacing between motif
labels. Default 4. Increase to make labels farther apart, decrease to make
labels closer.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_stagger_labels_y">motif_stagger_labels_y</code></td>
<td>
<p>= FALSE Logical value, default FALSE. If TRUE,
will  stagger motif labels in adjacent columns in the vertical direction</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_weights">motif_weights</code></td>
<td>
<p>Optional numeric vector, default NULL. If provided will
be used to color motif labels by the weighted values</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_weight_name">motif_weight_name</code></td>
<td>
<p>Character value, default &quot;Motif Weight&quot;. Used to
label the legend for motif colors</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_weight_colors">motif_weight_colors</code></td>
<td>
<p>Named numeric vector. Names should be color values
and breaks should be the corresponding values of motif_weights. Values
outside the highest and lowest value will appear as max or min defined
color value.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_lab_size">motif_lab_size</code></td>
<td>
<p>Numeric value, default 1. Size of motif labels.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_lab_alpha">motif_lab_alpha</code></td>
<td>
<p>Numeric value, default 0.25. Alpha for motif labels.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_line_alpha">motif_line_alpha</code></td>
<td>
<p>Numeric value, default 0.25. Alpha for motif lines.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_motif_line_size">motif_line_size</code></td>
<td>
<p>Numeric value, default 1. Size of motif lines.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_showgene">showGene</code></td>
<td>
<p>Logical value, default TRUE. Whether or not the gene track
should be plotted.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_whichgenes">whichGenes</code></td>
<td>
<p>Name of gene for plotting this specific gene in region.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_monotonegenes">monotoneGenes</code></td>
<td>
<p>Boolean. Determines whether to color-code genes by gene name, or to set them all to dark gray.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_db_id_col">db_id_col</code></td>
<td>
<p>Character value. Column in 'OrgDb' containing the output id
for 'whichGenes' plotting. Default &quot;REFSEQ&quot;.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_collapsegenes">collapseGenes</code></td>
<td>
<p>Options include 'collapseAll', 'longestTx', or 'None'
Default 'None' will plot the expanded view of the reference genes,
'collapseAll' if you want collapse the gene tracks into one, and
'longestTx' will only plot the longest transcript of each gene.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_gene_theme_ls">gene_theme_ls</code></td>
<td>
<p>Named list of parameters passed to 'theme()' for the
gene plot. Default NULL will use '.gene_plot_theme'</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_additionalgrangestrack">additionalGRangesTrack</code></td>
<td>
<p>A GRanges object containing additional track
plot data</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_linkdf">linkdf</code></td>
<td>
<p>A dataframe with co-accessible links to display as an
additional track</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_showideogram">showIdeogram</code></td>
<td>
<p>Logical value, default TRUE. If TRUE plots the chromosome
ideogram at the top of the multi-track plot</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_ideogram_genome">ideogram_genome</code></td>
<td>
<p>Character value, a genome name for the ideogram plot.
Default 'hg19'.</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_relativeheights">relativeHeights</code></td>
<td>
<p>Named numeric vector of relative heights for each of
the 4 track plots to enable clean visualization when there are many tracks.
Unused tracks will be ignored. Default value = c('Chr' = 0.9, 'Normalized
Counts' = 7, 'Genes'= 2, 'AdditionalGRanges' = 4.5)</p>
</td></tr>
<tr><td><code id="plotRegion_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input ggplot object with motif labels overlaid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# my_count_SE is a counts data frame generated by extractRegion()

# Simple counts + ideogram + all genes:
plotRegion(countSE = my_count_SE)

# Motif overlay for a project my_proj containing "JasparMotifs" annotations:
plotRegion(
  countSE = my_count_SE, motifSetName = "JasparMotifs",
  motif_lab_alpha = 1, motif_line_alpha = 1
)

# Motif overlay w/ weights:
plotRegion(
  countSE = my_count_SE, motifSetName = "JasparMotifs", motif_lab_alpha = 1,
  motif_line_alpha = 1, motif_weights = my_enrichment_weights
)

## End(Not run)

</code></pre>

<hr>
<h2 id='renameCellTypes'><code>renameCellTypes</code></h2><span id='topic+renameCellTypes'></span>

<h3>Description</h3>

<p><code>renameCellTypes</code> Allows you to modify the cell type names for a MOCHA SampleTileObject, from
the assay names, GRanges column names, and summarizedData (within the metadata), all at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameCellTypes(MOCHAObject, oldNames, newNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renameCellTypes_+3A_mochaobject">MOCHAObject</code></td>
<td>
<p>A  RangedSummarizedExperiment,</p>
</td></tr>
<tr><td><code id="renameCellTypes_+3A_oldnames">oldNames</code></td>
<td>
<p>A list of cell type names that you want to change.</p>
</td></tr>
<tr><td><code id="renameCellTypes_+3A_newnames">newNames</code></td>
<td>
<p>A list of new cell type names to replace the old names with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A MOCHA SampleTile object with new cell types.
</p>

<hr>
<h2 id='runLMEM'>Run Linear Mixed-Effects Modeling for continuous, non-zero inflated
data</h2><span id='topic+runLMEM'></span>

<h3>Description</h3>

<p><code>runLMEM</code> Runs linear mixed-effects modeling for
continuous, non-zero inflated data using <code><a href="lmerTest.html#topic+lmer">lmer</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runLMEM(
  ExperimentObj,
  assayName,
  modelFormula,
  initialSampling = 5,
  verbose = FALSE,
  numCores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runLMEM_+3A_experimentobj">ExperimentObj</code></td>
<td>
<p>A SummarizedExperiment object generated from
getSampleTileMatrix, chromVAR, or other. It is expected to contain only one
assay, or only the first assay will be used for the model. Data should not
be zero-inflated.</p>
</td></tr>
<tr><td><code id="runLMEM_+3A_assayname">assayName</code></td>
<td>
<p>The name of the assay to model within the
SummarizedExperiment.</p>
</td></tr>
<tr><td><code id="runLMEM_+3A_modelformula">modelFormula</code></td>
<td>
<p>The formula to use with lmerTest::lmer, in the format
(exp ~ factors). All factors must be found in column names of the
ExperimentObj metadata. modelFormula must start with 'exp' as the response.
See <a href="lmerTest.html#topic+lmer">lmer</a>.</p>
</td></tr>
<tr><td><code id="runLMEM_+3A_initialsampling">initialSampling</code></td>
<td>
<p>Size of data to use for pilot</p>
</td></tr>
<tr><td><code id="runLMEM_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="runLMEM_+3A_numcores">numCores</code></td>
<td>
<p>integer. Number of cores to parallelize across.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results a SummarizedExperiment containing LMEM results. Assays are
metrics related to the model coefficients, including the Estimate,
Std_Error, df, t_value, p_value. Within each assay, each row corresponds to
each row of the SummarizedExperiment and columns correspond to each fixed
effect variable within the model. Any row metadata from the
ExperimentObject (see rowData(ExperimentObj)) is preserved in the output.
The Residual matrix and the variance of the random effects are saved in the
metadata slot of the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
modelList &lt;- runLMEM(ExperimentObj,
  assayName = names(ExperimentObj)[[1]]
  modelFormula = NULL,
  initialSampling = 5,
  verbose = FALSE,
  numCores = 1
)

## End(Not run)

</code></pre>

<hr>
<h2 id='runZIGLMM'>Run Zero-inflated Generalized Linear Mixed Modeling on pseudobulked
scATAC data</h2><span id='topic+runZIGLMM'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
This function is deprecated - improved modeling functions can be found in 
the package &quot;ChAI&quot; at https://github.com/aifimmunology/ChAI
<code>runZIGLMM</code> Runs linear mixed-effects modeling for
zero-inflated data using <code><a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runZIGLMM(
  TSAM_Object,
  cellPopulation = "all",
  continuousFormula = NULL,
  ziformula = NULL,
  zi_threshold = 0,
  initialSampling = 5,
  verbose = FALSE,
  numCores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runZIGLMM_+3A_tsam_object">TSAM_Object</code></td>
<td>
<p>A SummarizedExperiment object generated from
getSampleTileMatrix.</p>
</td></tr>
<tr><td><code id="runZIGLMM_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>Name of a cell type(s), or 'all'. The function will
combine the cell types mentioned into one matrix before running the model.</p>
</td></tr>
<tr><td><code id="runZIGLMM_+3A_continuousformula">continuousFormula</code></td>
<td>
<p>The formula for the continuous data that should be
used within glmmTMB. It should be in the format (exp ~ factors). All
factors must be found in column names of the TSAM_Object metadata, except
for CellType, FragNumber and CellCount, which will be extracted from the
TSAM_Object. modelFormula must start with 'exp' as the response. See
<a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a>.</p>
</td></tr>
<tr><td><code id="runZIGLMM_+3A_ziformula">ziformula</code></td>
<td>
<p>The formula for the zero-inflated data that should be used
within glmmTMB. It should be in the format ( ~ factors). All factors must
be found in column names of the TSAM_Object colData metadata, except for
CellType, FragNumber and CellCount, which will be extracted from the
TSAM_Object.</p>
</td></tr>
<tr><td><code id="runZIGLMM_+3A_zi_threshold">zi_threshold</code></td>
<td>
<p>Zero-inflated threshold ( range = 0-1), representing the
fraction of samples with zeros. When the percentage of zeros in the tile is
between 0 and zi_threshold, samples with zeroes are dropped and only the
continous formula is used. Use this parameter at your own risk. Default is
0.</p>
</td></tr>
<tr><td><code id="runZIGLMM_+3A_initialsampling">initialSampling</code></td>
<td>
<p>Size of data to use for pilot</p>
</td></tr>
<tr><td><code id="runZIGLMM_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="runZIGLMM_+3A_numcores">numCores</code></td>
<td>
<p>integer. Number of cores to parallelize across.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results a SummarizedExperiment containing LMEM results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
modelList &lt;- runZIGLMM(STM[c(1:1000), ],
  cellPopulation = "CD16 Mono",
  continuousFormula = exp ~ Age + Sex + days_since_symptoms + (1 | PTID),
  ziformula = ~ FragNumber + Age,
  verbose = TRUE,
  numCores = 35
)

## End(Not run)

</code></pre>

<hr>
<h2 id='simplifiedConsensusTiles'><code>simplifiedConsensusTiles</code></h2><span id='topic+simplifiedConsensusTiles'></span>

<h3>Description</h3>

<p><code>simplifiedConsensusTiles</code> is an R helper function, part of
the single-cell peak
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifiedConsensusTiles(ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplifiedConsensusTiles_+3A_ref">ref</code></td>
<td>
<p>ref a list of data on one specific cell type, sampleData, threshold, groupColumn, and verbose flag.</p>
</td></tr>
</table>

<hr>
<h2 id='singlePopulationConsensusTiles'><code>singlePopulationConsensusTiles</code></h2><span id='topic+singlePopulationConsensusTiles'></span>

<h3>Description</h3>

<p><code>singlePopulationConsensusTiles</code> is an R helper function, part of
the single-cell peak
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singlePopulationConsensusTiles(
  peaksExperiment,
  sampleData,
  threshold,
  groupColumn = NULL,
  verbose = TRUE
)
</code></pre>

<hr>
<h2 id='singlePopulationSampleTileMatrix'><code>singlePopulationSampleTileMatrix</code></h2><span id='topic+singlePopulationSampleTileMatrix'></span>

<h3>Description</h3>

<p><code>singlePopulationSampleTileMatrix</code> is a function that can transform
a set of tile intensities into peak X sample matrix for a custom set of tiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singlePopulationSampleTileMatrix(
  peaksExperiment,
  consensusTiles,
  NAtoZero = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singlePopulationSampleTileMatrix_+3A_peaksexperiment">peaksExperiment</code></td>
<td>
<p>peakset RaggedExperiment, one celltype from the output of callOpenTiles</p>
</td></tr>
<tr><td><code id="singlePopulationSampleTileMatrix_+3A_consensustiles">consensusTiles</code></td>
<td>
<p>a vector containing the tileIDs to subset the
sample-tile matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The technical details of the algorithm are found in XX.
</p>


<h3>Value</h3>

<p>sampleTileIntensityMat a sample X peak matrix containing observed
measurements for each sample at each peak.
</p>


<h3>References</h3>

<p>XX
</p>

<hr>
<h2 id='StringsToGRanges'><code>StringsToGRanges</code></h2><span id='topic+StringsToGRanges'></span>

<h3>Description</h3>

<p><code>StringsToGRanges</code> Turns a list of strings in the format chr1:100-200
into a GRanges object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StringsToGRanges(regionString)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StringsToGRanges_+3A_regionstring">regionString</code></td>
<td>
<p>A string or list of strings each in the format chr1:100-200</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a GRanges object with ranges representing the input string(s)
</p>

<hr>
<h2 id='subsetMOCHAObject'><code>subsetMOCHAObject</code></h2><span id='topic+subsetMOCHAObject'></span>

<h3>Description</h3>

<p><code>subsetMOCHAObject</code> subsets a tileResults-type object (from
callOpenTiles), or a SummarizedExperiment-type object (from
getSampleTileMatrix), either by cell type or sample metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetMOCHAObject(
  Object,
  subsetBy,
  groupList,
  removeNA = TRUE,
  subsetPeaks = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetMOCHAObject_+3A_object">Object</code></td>
<td>
<p>A MultiAssayExperiment or RangedSummarizedExperiment,</p>
</td></tr>
<tr><td><code id="subsetMOCHAObject_+3A_subsetby">subsetBy</code></td>
<td>
<p>The variable to subset by. Can either be 'celltype', or a
column from the sample metadata (see 'colData(Object)').</p>
</td></tr>
<tr><td><code id="subsetMOCHAObject_+3A_grouplist">groupList</code></td>
<td>
<p>the list of cell type names or sample-associated data that
should be used to subset the Object</p>
</td></tr>
<tr><td><code id="subsetMOCHAObject_+3A_removena">removeNA</code></td>
<td>
<p>If TRUE, removes groups in groupList that are NA. If FALSE,
keep groups that are NA.</p>
</td></tr>
<tr><td><code id="subsetMOCHAObject_+3A_subsetpeaks">subsetPeaks</code></td>
<td>
<p>If &lsquo;subsetBy' = &rsquo;celltype', subset the tile
set to tiles only called in those cell types. Default is TRUE.</p>
</td></tr>
<tr><td><code id="subsetMOCHAObject_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object the input Object, filtered down to either the cell type or
samples desired.
</p>

<hr>
<h2 id='testCoAccessibility'><code>testCoAccessibility</code></h2><span id='topic+testCoAccessibility'></span>

<h3>Description</h3>

<p><code>testCoAccessibility</code> takes an input set of tile
pairs and tests whether they are significantly different compared to
random, non-overlapping background set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testCoAccessibility(
  SampleTileObj,
  tile1,
  tile2,
  numCores = 1,
  ZI = TRUE,
  backNumber = 1000,
  calcPValue = TRUE,
  returnBackGround = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testCoAccessibility_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The SummarizedExperiment object output from
getSampleTileMatrix containing your sample-tile matrices</p>
</td></tr>
<tr><td><code id="testCoAccessibility_+3A_tile1">tile1</code></td>
<td>
<p>vector of indices or tile names (chrX:100-2000) for tile pairs
to test (first tile in each pair)</p>
</td></tr>
<tr><td><code id="testCoAccessibility_+3A_tile2">tile2</code></td>
<td>
<p>vector of indices or tile names (chrX:100-2000) for tile pairs
to test (second tile in each pair)</p>
</td></tr>
<tr><td><code id="testCoAccessibility_+3A_numcores">numCores</code></td>
<td>
<p>Optional, the number of cores to use with multiprocessing.
Default is 1.</p>
</td></tr>
<tr><td><code id="testCoAccessibility_+3A_zi">ZI</code></td>
<td>
<p>boolean flag that enables zero-inflated (ZI) Spearman correlations
to be used. Default is TRUE. If FALSE, skip zero-inflation and calculate
the normal Spearman.</p>
</td></tr>
<tr><td><code id="testCoAccessibility_+3A_backnumber">backNumber</code></td>
<td>
<p>number of background pairs. Default is 1000.</p>
</td></tr>
<tr><td><code id="testCoAccessibility_+3A_calcpvalue">calcPValue</code></td>
<td>
<p>Boolean, if TRUE calculate p-values. Default is TRUE.</p>
</td></tr>
<tr><td><code id="testCoAccessibility_+3A_returnbackground">returnBackGround</code></td>
<td>
<p>Boolean, if TRUE return the background correlations
as well as foreground. Default is FALSE.</p>
</td></tr>
<tr><td><code id="testCoAccessibility_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>foreGround A data.frame with Tile1, Tile2, Correlation, and p-value
for that correlation compared to the background
</p>

<hr>
<h2 id='testCoAccessibilityChromVar'><code>testCoAccessibilityChromVar</code></h2><span id='topic+testCoAccessibilityChromVar'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
This function is deprecated due as we no longer recommend using a chromVAR 
background set.
<code>testCoAccessibilityChromVar</code> takes an input set of tile
pairs and tests whether they are significantly different compared to a
background set found via ChromVAR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testCoAccessibilityChromVar(
  SampleTileObj,
  tile1,
  tile2,
  numCores = 1,
  ZI = TRUE,
  backNumber = 1000,
  returnBackGround = FALSE,
  highMem = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testCoAccessibilityChromVar_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The SummarizedExperiment object output from
getSampleTileMatrix containing your sample-tile matrices</p>
</td></tr>
<tr><td><code id="testCoAccessibilityChromVar_+3A_tile1">tile1</code></td>
<td>
<p>vector of indices or tile names (chrX:100-2000) for tile pairs
to test (first tile in each pair)</p>
</td></tr>
<tr><td><code id="testCoAccessibilityChromVar_+3A_tile2">tile2</code></td>
<td>
<p>vector of indices or tile names (chrX:100-2000) for tile pairs
to test (second tile in each pair)</p>
</td></tr>
<tr><td><code id="testCoAccessibilityChromVar_+3A_numcores">numCores</code></td>
<td>
<p>Optional, the number of cores to use with multiprocessing.
Default is 1.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityChromVar_+3A_zi">ZI</code></td>
<td>
<p>boolean flag that enables zero-inflated (ZI) Spearman correlations
to be used. Default is TRUE. If FALSE, skip zero-inflation and calculate
the normal Spearman.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityChromVar_+3A_backnumber">backNumber</code></td>
<td>
<p>number of ChromVAR-matched background pairs. Default is
1000.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityChromVar_+3A_returnbackground">returnBackGround</code></td>
<td>
<p>Boolean, if TRUE return the background correlations
as well as foreground. Default is FALSE.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityChromVar_+3A_highmem">highMem</code></td>
<td>
<p>Boolean to control memory usage. Default is FALSE. Only set
highMem to TRUE if you have plenty of memory and want to run this function
faster.s</p>
</td></tr>
<tr><td><code id="testCoAccessibilityChromVar_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>foreGround A data.frame with Tile1, Tile2, Correlation, and p-value
for that correlation compared to the background
</p>

<hr>
<h2 id='testCoAccessibilityRandom'><code>testCoAccessibilityRandom</code></h2><span id='topic+testCoAccessibilityRandom'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
Renamed to 'testCoAccessibility' to remove unnecessary specificity around
the background set, and for a shorter function name.
</p>
<p><code>testCoAccessibilityRandom</code> takes an input set of tile
pairs and tests whether they are significantly different compared to
random, non-overlapping background set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testCoAccessibilityRandom(
  SampleTileObj,
  tile1,
  tile2,
  numCores = 1,
  ZI = TRUE,
  backNumber = 1000,
  calcPValue = TRUE,
  returnBackGround = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testCoAccessibilityRandom_+3A_sampletileobj">SampleTileObj</code></td>
<td>
<p>The SummarizedExperiment object output from
getSampleTileMatrix containing your sample-tile matrices</p>
</td></tr>
<tr><td><code id="testCoAccessibilityRandom_+3A_tile1">tile1</code></td>
<td>
<p>vector of indices or tile names (chrX:100-2000) for tile pairs
to test (first tile in each pair)</p>
</td></tr>
<tr><td><code id="testCoAccessibilityRandom_+3A_tile2">tile2</code></td>
<td>
<p>vector of indices or tile names (chrX:100-2000) for tile pairs
to test (second tile in each pair)</p>
</td></tr>
<tr><td><code id="testCoAccessibilityRandom_+3A_numcores">numCores</code></td>
<td>
<p>Optional, the number of cores to use with multiprocessing.
Default is 1.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityRandom_+3A_zi">ZI</code></td>
<td>
<p>boolean flag that enables zero-inflated (ZI) Spearman correlations
to be used. Default is TRUE. If FALSE, skip zero-inflation and calculate
the normal Spearman.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityRandom_+3A_backnumber">backNumber</code></td>
<td>
<p>number of background pairs. Default is 1000.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityRandom_+3A_calcpvalue">calcPValue</code></td>
<td>
<p>Boolean, if TRUE calculate p-values. Default is TRUE.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityRandom_+3A_returnbackground">returnBackGround</code></td>
<td>
<p>Boolean, if TRUE return the background correlations
as well as foreground. Default is FALSE.</p>
</td></tr>
<tr><td><code id="testCoAccessibilityRandom_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>foreGround A data.frame with Tile1, Tile2, Correlation, and p-value
for that correlation compared to the background
</p>

<hr>
<h2 id='unpackMOCHA'><code>unpackMOCHA</code></h2><span id='topic+unpackMOCHA'></span>

<h3>Description</h3>

<p><code>unpackMOCHA</code> will unpack a zip archive created by
<a href="#topic+unpackMOCHA">unpackMOCHA</a>, setting the stored MOCHA object's stored
directory path to the new location. See also: <a href="#topic+packMOCHA">packMOCHA</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpackMOCHA(zipfile, exdir, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpackMOCHA_+3A_zipfile">zipfile</code></td>
<td>
<p>Filepath to the packed MOCHA object.</p>
</td></tr>
<tr><td><code id="unpackMOCHA_+3A_exdir">exdir</code></td>
<td>
<p>The path to the external directory where you want to unpack the MOCHA object.</p>
</td></tr>
<tr><td><code id="unpackMOCHA_+3A_verbose">verbose</code></td>
<td>
<p>Display additional messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MOCHAObj the MOCHA object (tileResults or Sample-Tile Matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Depends on files existing on your system
MOCHA::unpackMOCHA(zipfile = "./mochaobj.zip", exdir = "./newMOCHAdir")

## End(Not run)
</code></pre>

<hr>
<h2 id='varZIGLMM'>Zero-inflated Variance Decomposition for pseudobulked scATAC data</h2><span id='topic+varZIGLMM'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
This function is deprecated - improved modeling functions can be found in 
the package &quot;ChAI&quot; at https://github.com/aifimmunology/ChAI
<code>varZIGLMM</code> Identified variance decomposition on a given
cell type across both zero-inflated and continuous space using a
zero-inflated general linear mixed model <code><a href="glmmTMB.html#topic+glmmTMB">glmmTMB</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varZIGLMM(
  TSAM_Object,
  cellPopulation = NULL,
  continuousRandom = NULL,
  ziRandom = NULL,
  zi_threshold = 0.1,
  verbose = FALSE,
  numCores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varZIGLMM_+3A_tsam_object">TSAM_Object</code></td>
<td>
<p>A SummarizedExperiment object generated from
getSampleTileMatrix.</p>
</td></tr>
<tr><td><code id="varZIGLMM_+3A_cellpopulation">cellPopulation</code></td>
<td>
<p>Name of a cell type(s), or 'all'. The function will
combine the cell types mentioned into one matrix before running the model.</p>
</td></tr>
<tr><td><code id="varZIGLMM_+3A_continuousrandom">continuousRandom</code></td>
<td>
<p>Random effects to test in the continuous portion. All
factors must be found in column names of the TSAM_Object metadata, except
for FragNumber and CellCount, which will be extracted from the
TSAM_Object's metadata.</p>
</td></tr>
<tr><td><code id="varZIGLMM_+3A_zirandom">ziRandom</code></td>
<td>
<p>Random effects to test in the zero-inflated portion. All
factors must be found in column names of the TSAM_Object colData metadata,
except for FragNumber and CellCount, which will be extracted from the
TSAM_Object's metadata.</p>
</td></tr>
<tr><td><code id="varZIGLMM_+3A_zi_threshold">zi_threshold</code></td>
<td>
<p>Zero-inflated threshold ( range = 0-1), representing the
fraction of samples with zeros. When the percentage of zeros in the tile is
between 0 and zi_threshold, samples with zeroes are dropped and only the
continous formula is used. Use this parameter at your own risk. Default is
0.</p>
</td></tr>
<tr><td><code id="varZIGLMM_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to display additional messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="varZIGLMM_+3A_numcores">numCores</code></td>
<td>
<p>integer. Number of cores to parallelize across.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results a SummarizedExperiment containing results from ZIGLMM (Fixed
effect estiamtes, P-values, and Std Error)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
modelList &lt;- runZIGLMM(STM[c(1:1000), ],
  cellPopulation = "CD16 Mono",
  continuousRandom = c("Age", "Sex", "Days"),
  ziRandom = c("FragNumber", "Days"),
  verbose = TRUE,
  numCores = 35
)

## End(Not run)

</code></pre>

<hr>
<h2 id='youden_threshold'>youden_threshold</h2><span id='topic+youden_threshold'></span>

<h3>Description</h3>

<p>Trained regression model for predicting a cutoff threshold
for peak calling.
Call:
loess(formula = OptimalCutpoint ~ Ncells, data = thresh_df)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>youden_threshold
</code></pre>


<h3>Format</h3>

<p>A list of 18 regression variables
</p>


<h3>Details</h3>

<p>Number of Observations: 27
Equivalent Number of Parameters: 5.98
Residual Standard Error: 0.02121
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
