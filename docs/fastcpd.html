<!DOCTYPE html><html lang="en"><head><title>Help for package fastcpd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastcpd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bitcoin'><p>Bitcoin Market Price (USD)</p></a></li>
<li><a href='#fastcpd'><p>Find change points efficiently</p></a></li>
<li><a href='#fastcpd_ar'><p>Find change points efficiently in AR(<code class="reqn">p</code>) models</p></a></li>
<li><a href='#fastcpd_arima'><p>Find change points efficiently in</p>
ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) models</a></li>
<li><a href='#fastcpd_arma'><p>Find change points efficiently in ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>) models</p></a></li>
<li><a href='#fastcpd_binomial'><p>Find change points efficiently in logistic regression models</p></a></li>
<li><a href='#fastcpd_family'><p>Wrapper functions for fastcpd</p></a></li>
<li><a href='#fastcpd_garch'><p>Find change points efficiently in GARCH(<code class="reqn">p</code>, <code class="reqn">q</code>) models</p></a></li>
<li><a href='#fastcpd_lasso'><p>Find change points efficiently in penalized linear regression models</p></a></li>
<li><a href='#fastcpd_lm'><p>Find change points efficiently in linear regression models</p></a></li>
<li><a href='#fastcpd_mean'><p>Find change points efficiently in mean change models</p></a></li>
<li><a href='#fastcpd_meanvariance'><p>Find change points efficiently in mean variance change models</p></a></li>
<li><a href='#fastcpd_poisson'><p>Find change points efficiently in Poisson regression models</p></a></li>
<li><a href='#fastcpd_ts'><p>Find change points efficiently in time series data</p></a></li>
<li><a href='#fastcpd_var'><p>Find change points efficiently in VAR(<code class="reqn">p</code>) models</p></a></li>
<li><a href='#fastcpd_variance'><p>Find change points efficiently in variance change models</p></a></li>
<li><a href='#fastcpd-class'><p>An S4 class to store the output created with <code>fastcpd()</code></p></a></li>
<li><a href='#occupancy'><p>Occupancy Detection Data Set</p></a></li>
<li><a href='#plot.fastcpd'><p>Plot the data and the change points for a fastcpd object</p></a></li>
<li><a href='#print.fastcpd'><p>Print the call and the change points for a fastcpd object</p></a></li>
<li><a href='#show.fastcpd'><p>Show the available methods for a fastcpd object</p></a></li>
<li><a href='#summary.fastcpd'><p>Show the summary of a fastcpd object</p></a></li>
<li><a href='#transcriptome'><p>Transcription Profiling of 57 Human Bladder Carcinoma Samples</p></a></li>
<li><a href='#uk_seatbelts'><p>UK Seatbelts Data</p></a></li>
<li><a href='#variance_arma'><p>Variance estimation for ARMA model with change points</p></a></li>
<li><a href='#variance_lm'><p>Variance estimation for linear models with change points</p></a></li>
<li><a href='#variance_mean'><p>Variance estimation for mean change models</p></a></li>
<li><a href='#variance_median'><p>Variance estimation for median change models</p></a></li>
<li><a href='#well_log'><p>Well-log Dataset from Numerical Bayesian Methods Applied to</p>
Signal Processing</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Change Point Detection via Sequential Gradient Descent</td>
</tr>
<tr>
<td>Version:</td>
<td>0.16.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements fast change point detection algorithm based on the
    paper "Sequential Gradient Descent and Quasi-Newton's Method for
    Change-Point Analysis" by Xianyang Zhang, Trisha Dawn
    <a href="https://proceedings.mlr.press/v206/zhang23b.html">https://proceedings.mlr.press/v206/zhang23b.html</a>. The algorithm is
    based on dynamic programming with pruning and sequential gradient
    descent. It is able to detect change points a magnitude faster than
    the vanilla Pruned Exact Linear Time(PELT). The package includes
    examples of linear regression, logistic regression, Poisson
    regression, penalized linear regression data, and whole lot more
    examples with custom cost function in case the user wants to use their
    own cost function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fastcpd.xingchi.li">https://fastcpd.xingchi.li</a>, <a href="https://github.com/doccstat/fastcpd">https://github.com/doccstat/fastcpd</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/doccstat/fastcpd/issues">https://github.com/doccstat/fastcpd/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, Matrix, methods, Rcpp (&ge; 0.11.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, gridExtra, knitr, matrixStats, mvtnorm, rmarkdown,
testthat (&ge; 3.0.0), xml2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>progress, Rcpp, RcppArmadillo, RcppEigen, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>examples-fastcpd_arima,
examples-fastcpd_ts</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 17:42:42 UTC; doccstat</td>
</tr>
<tr>
<td>Author:</td>
<td>Xingchi Li <a href="https://orcid.org/0009-0006-2493-0853"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Xianyang Zhang [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xingchi Li &lt;anthony.li.stat.tamu.edu@lixingchi.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-13 23:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='bitcoin'>Bitcoin Market Price (USD)</h2><span id='topic+bitcoin'></span>

<h3>Description</h3>

<p>The average USD market price across major bitcoin exchanges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitcoin
</code></pre>


<h3>Format</h3>

<p>A data frame with 1354 rows and 2 variables:
</p>

<dl>
<dt>date</dt><dd><p>POSIXct,POSIXt (TZ: &quot;UTC&quot;) from 2019-01-02 to 2023-10-28</p>
</dd>
<dt>price</dt><dd><p>The average USD market price across major bitcoin exchanges</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://www.blockchain.com/explorer/charts/market-price&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("ggplot2", quietly = TRUE)) {
  p &lt;- ggplot2::ggplot(bitcoin, ggplot2::aes(x = date, y = price)) +
    ggplot2::geom_line()
  print(p)

  result &lt;- suppressWarnings(fastcpd.garch(
    diff(log(bitcoin$price[600:900])), c(1, 1),
    beta = "BIC", cost_adjustment = "BIC"
  ))
  summary(result)
  bitcoin$date[result@cp_set + 600]
  plot(result)

  cp_dates &lt;- bitcoin[600 + result@cp_set + 1, "date"]
  ggplot2::ggplot(
    data = data.frame(
      x = bitcoin$date[600:900], y = bitcoin$price[600:900]
    ),
    ggplot2::aes(x = x, y = y)
  ) +
    ggplot2::geom_line(color = "steelblue") +
    ggplot2::geom_vline(
      xintercept = cp_dates,
      color = "red",
      linetype = "dotted",
      linewidth = 0.5,
      alpha = 0.7
    ) +
    ggplot2::labs(
      x = "Year",
      y = "Bitcoin price in USD"
    ) +
    ggplot2::annotate(
      "text",
      x = cp_dates,
      y = 2000,
      label = as.character(cp_dates),
      color = "steelblue"
    ) +
    ggplot2::theme_bw()
}

</code></pre>

<hr>
<h2 id='fastcpd'>Find change points efficiently</h2><span id='topic+fastcpd'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code> takes in formulas, data, families and extra
parameters and returns a <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd(
  formula = y ~ . - 1,
  data,
  beta = "MBIC",
  cost_adjustment = "MBIC",
  family = NULL,
  cost = NULL,
  cost_gradient = NULL,
  cost_hessian = NULL,
  line_search = c(1),
  lower = rep(-Inf, p),
  upper = rep(Inf, p),
  pruning_coef = 0,
  segment_count = 10,
  trim = 0.02,
  momentum_coef = 0,
  multiple_epochs = function(x) 0,
  epsilon = 1e-10,
  order = c(0, 0, 0),
  p = ncol(data) - 1,
  variance_estimation = NULL,
  cp_only = FALSE,
  vanilla_percentage = 0,
  warm_start = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_+3A_formula">formula</code></td>
<td>
<p>A formula object specifying the model to be fitted. The
(optional) response variable should be on the LHS of the formula, while the
covariates should be on the RHS. The naming of variables used in the formula
should be consistent with the column names in the data frame provided in
<code>data</code>. The intercept term should be removed from the formula.
The response variable is not needed for mean/variance change models and time
series models. By default, an intercept column will be added to the data,
similar to the <code><a href="stats.html#topic+lm">lm()</a></code> function.
Thus, it is suggested that users should remove the intercept term by
appending <code>- 1</code> to the formula. Note that the <a href="#topic+fastcpd.family">fastcpd.family</a> functions
do not require a formula input.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_data">data</code></td>
<td>
<p>A data frame of dimension <code class="reqn">T \times d</code> containing the
data to be segmented (where each row denotes a data point
<code class="reqn">z_t \in \mathbb{R}^d</code> for <code class="reqn">t = 1, \ldots, T</code>) is
required in the main function, while a matrix or a vector input is also
accepted in the <a href="#topic+fastcpd.family">fastcpd.family</a> functions.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_beta">beta</code></td>
<td>
<p>Penalty criterion for the number of change points. This parameter
takes a string value of <code>"BIC"</code>, <code>"MBIC"</code>, <code>"MDL"</code> or a
numeric value.
If a numeric value is provided, the value will be used as the penalty.
By default, the mBIC criterion is used, where
<code class="reqn">\beta = (p + 2) \log(T) / 2</code>.
This parameter usage should be paired with <code>cost_adjustment</code> described
below. Discussions about the penalty criterion can be found in the
references.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_cost_adjustment">cost_adjustment</code></td>
<td>
<p>Cost adjustment criterion.
It can be <code>"BIC"</code>, <code>"MBIC"</code>, <code>"MDL"</code> or <code>NULL</code>.
By default, the cost adjustment criterion is set to be <code>"MBIC"</code>.
The <code>"MBIC"</code> and <code>"MDL"</code> criteria modify the cost function by
adding a negative adjustment term to the cost function.
<code>"BIC"</code> or <code>NULL</code> does not modify the cost function.
Details can in found in the references.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_family">family</code></td>
<td>
<p>Family class of the change point model. It can be
<code>"mean"</code> for mean change,
<code>"variance"</code> for variance change,
<code>"meanvariance"</code> for mean and/or variance change,
<code>"lm"</code> for linear regression,
<code>"binomial"</code> for logistic regression,
<code>"poisson"</code> for Poisson regression,
<code>"lasso"</code> for penalized linear regression,
<code>"ar"</code> for AR(<code class="reqn">p</code>) models,
<code>"arma"</code> for ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>) models,
<code>"arima"</code> for ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) models,
<code>"garch"</code> for GARCH(<code class="reqn">p</code>, <code class="reqn">q</code>) models,
<code>"var"</code> for VAR(<code class="reqn">p</code>) models and
<code>"custom"</code> for user-specified custom models.
Omitting this parameter is the same as specifying the parameter to be
<code>"custom"</code> or <code>NULL</code>, in which case, users must specify the
custom cost function.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_cost">cost</code></td>
<td>
<p>Cost function to be used. <code>cost</code>, <code>cost_gradient</code>, and
<code>cost_hessian</code> should not be specified at the same time with
<code>family</code> as built-in families have cost functions implemented in C++
to provide better performance. If not specified, the default is the negative
log-likelihood for the corresponding family. Custom cost functions can be
provided in the following two formats:
</p>

<ul>
<li> <p><code>cost = function(data) {...}</code>
</p>
</li>
<li> <p><code>cost = function(data, theta) {...}</code>
</p>
</li></ul>

<p>Users can specify a loss function using the second format that will be used
to calculate the cost value. In both formats, the input data is a subset of
the original data frame in the form of a matrix
(a matrix with a single column in the case of a univariate data set).
In the first format, the specified cost function directly calculates the cost
value. <code><a href="#topic+fastcpd">fastcpd()</a></code> performs the vanilla PELT algorithm, and
<code>cost_gradient</code> and <code>cost_hessian</code> should not be provided since no
parameter updating is necessary for vanilla PELT.
In the second format, the loss function
<code class="reqn">\sum_{i = s}^t l(z_i, \theta)</code> is
provided, which has to be optimized over the parameter <code class="reqn">\theta</code> to
obtain the cost value. A detailed discussion about the custom cost function
usage can be found in the references.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_cost_gradient">cost_gradient</code></td>
<td>
<p>Gradient of the custom cost function. Example usage:
</p>
<div class="sourceCode r"><pre>cost_gradient = function(data, theta) {
  ...
  return(gradient)
}
</pre></div>
<p>The gradient function takes two inputs, the first being a matrix representing
a segment of the data, similar to the format used in the <code>cost</code>
function, and the second being the parameter that needs to be optimized.
The gradient function returns the value of the gradient of the loss function,
i.e.,
<code class="reqn">\sum_{i = s}^t \nabla l(z_i, \theta)</code>.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_cost_hessian">cost_hessian</code></td>
<td>
<p>Hessian of the custom loss function. The Hessian function
takes two inputs, the first being a matrix representing a segment of the
data, similar to the format used in the <code>cost</code> function, and the second
being the parameter that needs to be optimized. The gradient function returns
the Hessian of the loss function, i.e.,
<code class="reqn">\sum_{i = s}^t \nabla^2 l(z_i, \theta)</code>.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_line_search">line_search</code></td>
<td>
<p>If a vector of numeric values is provided, a line search
will be performed to find the optimal step size for each update. Detailed
usage of <code>line_search</code> can be found in the references.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_lower">lower</code></td>
<td>
<p>Lower bound for the parameters. Used to specify the domain of
the parameters after each gradient descent step. If not specified, the lower
bound is set to be <code>-Inf</code> for all parameters. <code>lower</code> is especially
useful when the estimated parameters take only positive values, such as the
noise variance.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_upper">upper</code></td>
<td>
<p>Upper bound for the parameters. Used to specify the domain of
the parameters after each gradient descent step. If not specified, the upper
bound is set to be <code>Inf</code> for all parameters.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_pruning_coef">pruning_coef</code></td>
<td>
<p>Pruning coefficient $c_0$ used in the pruning step of the
PELT algorithm with the default value 0. If <code>cost_adjustment</code> is
specified as <code>"MBIC"</code>, an adjustment term <code class="reqn">p\log(2)</code>
will be added to the pruning coefficient. If <code>cost_adjustment</code> is
specified as <code>"MDL"</code>, an adjustment term <code class="reqn">p\log_2(2)</code>
will be added to the pruning coefficient. Detailed discussion about the
pruning coefficient can be found in the references.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_segment_count">segment_count</code></td>
<td>
<p>An initial guess of the number of segments. If not
specified, the initial guess of the number of segments is 10. The initial
guess affects the initial estimates of the parameters in SeGD.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_trim">trim</code></td>
<td>
<p>Trimming for the boundary change points so that a change point
close to the boundary will not be counted as a change point. This
parameter also specifies the minimum distance between two change points.
If several change points have mutual distances smaller than
<code>trim * nrow(data)</code>, those change points will be merged into one
single change point. The value of this parameter should be between
0 and 1.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_momentum_coef">momentum_coef</code></td>
<td>
<p>Momentum coefficient to be applied to each update. This
parameter is used when the loss function is bad-shaped so that
maintaining a momentum from previous update is desired. Default value is
0, meaning the algorithm doesn't maintain a momentum by default.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_multiple_epochs">multiple_epochs</code></td>
<td>
<p>A function can be specified such that an adaptive
number of multiple epochs can be utilized to improve the algorithm's
performance. <code>multiple_epochs</code> is a function of the length of the data
segment. The function returns an integer indicating how many epochs should be
performed apart from the default update. By default, the function returns
zero, meaning no multiple epochs will be used to update the parameters.
Example usage:
</p>
<div class="sourceCode r"><pre>multiple_epochs = function(segment_length) {
  if (segment_length &lt; 100) 1
  else 0
}
</pre></div>
<p>This function will let SeGD perform parameter updates with an additional
epoch for each segment with a length less than 100 and no additional epoch
for segments with lengths greater or equal to 100.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_epsilon">epsilon</code></td>
<td>
<p>Epsilon to avoid numerical issues. Only used for the Hessian
computation in Logistic Regression and Poisson Regression.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_order">order</code></td>
<td>
<p>Order of the AR(<code class="reqn">p</code>), VAR(<code class="reqn">p</code>) or
ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) model.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_p">p</code></td>
<td>
<p>Number of covariates in the model. If not specified, the number of
covariates will be inferred from the data, i.e.,
<code>p = ncol(data) - 1</code>. This parameter is superseded by <code>order</code> in the
case of time series models: &quot;ar&quot;, &quot;var&quot;, &quot;arima&quot;.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_variance_estimation">variance_estimation</code></td>
<td>
<p>An estimate of the variance / covariance matrix
for the data. If not specified, the variance / covariance matrix will be
estimated using the data.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_cp_only">cp_only</code></td>
<td>
<p>If <code>TRUE</code>, only the change points are returned.
Otherwise, the cost function values together with the estimated
parameters for each segment are also returned. By default the value is
set to be <code>FALSE</code> so that <code>plot</code> can be used to visualize the
results for a built-in model. <code>cp_only</code> has some performance impact
on the algorithm, since the cost values and estimated parameters for each
segment need to be calculated and stored. If the users are only
interested in the change points, setting <code>cp_only</code> to be <code>TRUE</code>
will help with the computational cost.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_vanilla_percentage">vanilla_percentage</code></td>
<td>
<p>The parameter <code class="reqn">v</code> is between zero and one.
For each segment, when its length is no more than <code class="reqn">vT</code>, the cost value
will be computed by performing an exact minimization of the loss function
over the parameter. When its length is greater than <code class="reqn">vT</code>, the cost value
is approximated through SeGD. Therefore, this parameter induces an algorithm
that can be interpreted as an interpolation between dynamic programming with
SeGD (<code class="reqn">v = 0</code>) and the vanilla PELT (<code class="reqn">v = 1</code>).
The readers are referred to the references for more details.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_warm_start">warm_start</code></td>
<td>
<p>If <code>TRUE</code>, the algorithm will use the estimated
parameters from the previous segment as the initial value for the
current segment. This parameter is only used for the <code>"glm"</code> families.</p>
</td></tr>
<tr><td><code id="fastcpd_+3A_...">...</code></td>
<td>
<p>Other parameters for specific models.
</p>

<ul>
<li> <p><code>include.mean</code> is used to determine if a mean/intercept term
should be included in the ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) or
GARCH(<code class="reqn">p</code>, <code class="reqn">q</code>) models.
</p>
</li>
<li> <p><code>r.progress</code> is used to control the progress bar. By default the
progress bar will be shown. To disable it, set <code>r.progress = FALSE</code>.
</p>
</li>
<li> <p><code>p.response</code> is used to specify the number of response variables.
This parameter is especially useful for linear models with multivariate
responses.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>Gallery</h3>

<p><a href="https://github.com/doccstat/fastcpd/tree/main/tests/testthat/examples">https://github.com/doccstat/fastcpd/tree/main/tests/testthat/examples</a>
</p>


<h3>References</h3>

<p>Xingchi Li, Xianyang Zhang (2024). &ldquo;fastcpd: Fast Change Point Detection
in R.&rdquo; <em>arXiv:2404.05933</em>, <a href="https://arxiv.org/abs/2404.05933">https://arxiv.org/abs/2404.05933</a>.
</p>
<p>Xianyang Zhang, Trisha Dawn (2023). &ldquo;Sequential Gradient Descent and
Quasi-Newton's Method for Change-Point Analysis.&rdquo; In Ruiz, Francisco,
Dy, Jennifer, van de Meent, Jan-Willem (eds.), <em>Proceedings of The 26th
International Conference on Artificial Intelligence and Statistics</em>,
volume 206 series Proceedings of Machine Learning Research, 1129-1143.
</p>


<h3>See Also</h3>

<p><a href="#topic+fastcpd.family">fastcpd.family</a> for the family-specific function;
<code><a href="#topic+plot.fastcpd">plot.fastcpd()</a></code> for plotting the results,
<code><a href="#topic+summary.fastcpd">summary.fastcpd()</a></code> for summarizing the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 200
  p &lt;- 4
  d &lt;- 2
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta_1 &lt;- matrix(runif(8, -3, -1), nrow = p)
  theta_2 &lt;- matrix(runif(8, -1, 3), nrow = p)
  y &lt;- rbind(
    x[1:125, ] %*% theta_1 + mvtnorm::rmvnorm(125, rep(0, d), 3 * diag(d)),
    x[126:n, ] %*% theta_2 + mvtnorm::rmvnorm(75, rep(0, d), 3 * diag(d))
  )
  result_mlm &lt;- fastcpd(
    cbind(y.1, y.2) ~ . - 1, cbind.data.frame(y = y, x = x), family = "lm"
  )
  summary(result_mlm)
}
if (
  requireNamespace("mvtnorm", quietly = TRUE) &amp;&amp;
    requireNamespace("stats", quietly = TRUE)
) {
  set.seed(1)
  n &lt;- 400 + 300 + 500
  p &lt;- 5
  x &lt;- mvtnorm::rmvnorm(n, mean = rep(0, p), sigma = diag(p))
  theta &lt;- rbind(
    mvtnorm::rmvnorm(1, mean = rep(0, p - 3), sigma = diag(p - 3)),
    mvtnorm::rmvnorm(1, mean = rep(5, p - 3), sigma = diag(p - 3)),
    mvtnorm::rmvnorm(1, mean = rep(9, p - 3), sigma = diag(p - 3))
  )
  theta &lt;- cbind(theta, matrix(0, 3, 3))
  theta &lt;- theta[rep(seq_len(3), c(400, 300, 500)), ]
  y_true &lt;- rowSums(x * theta)
  factor &lt;- c(
    2 * stats::rbinom(400, size = 1, prob = 0.95) - 1,
    2 * stats::rbinom(300, size = 1, prob = 0.95) - 1,
    2 * stats::rbinom(500, size = 1, prob = 0.95) - 1
  )
  y &lt;- factor * y_true + stats::rnorm(n)
  data &lt;- cbind.data.frame(y, x)
  huber_threshold &lt;- 1
  huber_loss &lt;- function(data, theta) {
    residual &lt;- data[, 1] - data[, -1, drop = FALSE] %*% theta
    indicator &lt;- abs(residual) &lt;= huber_threshold
    sum(
      residual^2 / 2 * indicator +
        huber_threshold * (
          abs(residual) - huber_threshold / 2
        ) * (1 - indicator)
    )
  }
  huber_loss_gradient &lt;- function(data, theta) {
    residual &lt;- c(data[nrow(data), 1] - data[nrow(data), -1] %*% theta)
    if (abs(residual) &lt;= huber_threshold) {
      -residual * data[nrow(data), -1]
    } else {
      -huber_threshold * sign(residual) * data[nrow(data), -1]
    }
  }
  huber_loss_hessian &lt;- function(data, theta) {
    residual &lt;- c(data[nrow(data), 1] - data[nrow(data), -1] %*% theta)
    if (abs(residual) &lt;= huber_threshold) {
      outer(data[nrow(data), -1], data[nrow(data), -1])
    } else {
      0.01 * diag(length(theta))
    }
  }
  huber_regression_result &lt;- fastcpd(
    formula = y ~ . - 1,
    data = data,
    beta = (p + 1) * log(n) / 2,
    cost = huber_loss,
    cost_gradient = huber_loss_gradient,
    cost_hessian = huber_loss_hessian
  )
  summary(huber_regression_result)
}

set.seed(1)
p &lt;- 1
x &lt;- matrix(rnorm(375 * p, 0, 1), ncol = p)
theta &lt;- rbind(rnorm(p, 0, 1), rnorm(p, 2, 1))
y &lt;- c(
  rbinom(200, 1, 1 / (1 + exp(-x[1:200, ] %*% theta[1, , drop = FALSE]))),
  rbinom(175, 1, 1 / (1 + exp(-x[201:375, ] %*% theta[2, , drop = FALSE])))
)
data &lt;- data.frame(y = y, x = x)
result_builtin &lt;- suppressWarnings(fastcpd.binomial(data))
logistic_loss &lt;- function(data, theta) {
  x &lt;- data[, -1, drop = FALSE]
  y &lt;- data[, 1]
  u &lt;- x %*% theta
  nll &lt;- -y * u + log(1 + exp(u))
  nll[u &gt; 10] &lt;- -y[u &gt; 10] * u[u &gt; 10] + u[u &gt; 10]
  sum(nll)
}
logistic_loss_gradient &lt;- function(data, theta) {
  x &lt;- data[nrow(data), -1, drop = FALSE]
  y &lt;- data[nrow(data), 1]
  c(-(y - 1 / (1 + exp(-x %*% theta)))) * x
}
logistic_loss_hessian &lt;- function(data, theta) {
  x &lt;- data[nrow(data), -1]
  prob &lt;- 1 / (1 + exp(-x %*% theta))
  (x %o% x) * c((1 - prob) * prob)
}
result_custom &lt;- fastcpd(
  formula = y ~ . - 1,
  data = data,
  epsilon = 1e-5,
  cost = logistic_loss,
  cost_gradient = logistic_loss_gradient,
  cost_hessian = logistic_loss_hessian
)
result_builtin@cp_set
result_custom@cp_set


if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 480
  p_true &lt;- 6
  p &lt;- 50
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta_0 &lt;- rbind(
    runif(p_true, -5, -2),
    runif(p_true, -3, 3),
    runif(p_true, 2, 5),
    runif(p_true, -5, 5)
  )
  theta_0 &lt;- cbind(theta_0, matrix(0, ncol = p - p_true, nrow = 4))
  y &lt;- c(
    x[1:80, ] %*% theta_0[1, ] + rnorm(80, 0, 1),
    x[81:200, ] %*% theta_0[2, ] + rnorm(120, 0, 1),
    x[201:320, ] %*% theta_0[3, ] + rnorm(120, 0, 1),
    x[321:n, ] %*% theta_0[4, ] + rnorm(160, 0, 1)
  )
  small_lasso_data &lt;- cbind.data.frame(y, x)
  result_no_vp &lt;- fastcpd.lasso(
    small_lasso_data,
    beta = "BIC",
    cost_adjustment = NULL,
    pruning_coef = 0
  )
  summary(result_no_vp)
  result_20_vp &lt;- fastcpd.lasso(
    small_lasso_data,
    beta = "BIC",
    cost_adjustment = NULL,
    vanilla_percentage = 0.2,
    pruning_coef = 0
  )
  summary(result_20_vp)
}

</code></pre>

<hr>
<h2 id='fastcpd_ar'>Find change points efficiently in AR(<code class="reqn">p</code>) models</h2><span id='topic+fastcpd_ar'></span><span id='topic+fastcpd.ar'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_ar">fastcpd_ar()</a></code> and <code><a href="#topic+fastcpd.ar">fastcpd.ar()</a></code> are
wrapper functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in
AR(<code class="reqn">p</code>) models. The function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code> except that
the data is by default a one-column matrix or univariate vector
and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_ar(data, order = 0, ...)

fastcpd.ar(data, order = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_ar_+3A_data">data</code></td>
<td>
<p>A numeric vector, a matrix, a data frame or a time series object.</p>
</td></tr>
<tr><td><code id="fastcpd_ar_+3A_order">order</code></td>
<td>
<p>A positive integer specifying the order of the AR model.</p>
</td></tr>
<tr><td><code id="fastcpd_ar_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>. One special argument can be passed here is
<code>include.mean</code>, which is a logical value indicating whether the
mean should be included in the model. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 1000
x &lt;- rep(0, n + 3)
for (i in 1:600) {
  x[i + 3] &lt;- 0.6 * x[i + 2] - 0.2 * x[i + 1] + 0.1 * x[i] + rnorm(1, 0, 3)
}
for (i in 601:1000) {
  x[i + 3] &lt;- 0.3 * x[i + 2] + 0.4 * x[i + 1] + 0.2 * x[i] + rnorm(1, 0, 3)
}
result &lt;- fastcpd.ar(x[3 + seq_len(n)], 3)
summary(result)
plot(result)
set.seed(1)
n &lt;- 1000
x &lt;- rep(0, n + 3)
for (i in 1:600) {
  x[i + 3] &lt;- 0.6 * x[i + 2] - 0.2 * x[i + 1] + 0.1 * x[i] + rnorm(1, 0, 3)
}
for (i in 601:1000) {
  x[i + 3] &lt;- 0.3 * x[i + 2] + 0.4 * x[i + 1] + 0.2 * x[i] + rnorm(1, 0, 3)
}
result &lt;-
  fastcpd.ar(x[3 + seq_len(n)], 3, beta = "MDL", cost_adjustment = "MDL")
summary(result)
plot(result)
</code></pre>

<hr>
<h2 id='fastcpd_arima'>Find change points efficiently in
ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) models</h2><span id='topic+fastcpd_arima'></span><span id='topic+fastcpd.arima'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_arima">fastcpd_arima()</a></code> and <code><a href="#topic+fastcpd.arima">fastcpd.arima()</a></code> are
wrapper functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in
ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) models.
The function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code>
except that the data is by default a one-column matrix or univariate vector
and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_arima(data, order = 0, ...)

fastcpd.arima(data, order = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_arima_+3A_data">data</code></td>
<td>
<p>A numeric vector, a matrix, a data frame or a time series object.</p>
</td></tr>
<tr><td><code id="fastcpd_arima_+3A_order">order</code></td>
<td>
<p>A vector of length three specifying the order of the ARIMA
model.</p>
</td></tr>
<tr><td><code id="fastcpd_arima_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>. One special argument can be passed here is
<code>include.mean</code>, which is a logical value indicating whether the
mean should be included in the model. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 801
w &lt;- rnorm(n + 1, 0, 3)
dx &lt;- rep(0, n + 1)
x &lt;- rep(0, n + 1)
for (i in 1:400) {
  dx[i + 1] &lt;- 0.9 * dx[i] + w[i + 1] - 0.1 * w[i]
  x[i + 1] &lt;- x[i] + dx[i + 1]
}
for (i in 401:n) {
  dx[i + 1] &lt;- -0.6 * dx[i] + w[i + 1] + 0.3 * w[i]
  x[i + 1] &lt;- x[i] + dx[i + 1]
}
result &lt;- fastcpd.arima(
  diff(x[1 + seq_len(n)]),
  c(1, 0, 1),
  segment_count = 3,
  include.mean = FALSE
)
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='fastcpd_arma'>Find change points efficiently in ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>) models</h2><span id='topic+fastcpd_arma'></span><span id='topic+fastcpd.arma'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_arma">fastcpd_arma()</a></code> and <code><a href="#topic+fastcpd.arma">fastcpd.arma()</a></code> are
wrapper functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in
ARMA(<code class="reqn">p</code>, <code class="reqn">q</code>) models. The function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code>
except that the data is by default a one-column matrix or univariate vector
and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_arma(data, order = c(0, 0), ...)

fastcpd.arma(data, order = c(0, 0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_arma_+3A_data">data</code></td>
<td>
<p>A numeric vector, a matrix, a data frame or a time series object.</p>
</td></tr>
<tr><td><code id="fastcpd_arma_+3A_order">order</code></td>
<td>
<p>A vector of length two specifying the order of the ARMA
model.</p>
</td></tr>
<tr><td><code id="fastcpd_arma_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 200
w &lt;- rnorm(n + 3, 0, 3)
x &lt;- rep(0, n + 3)
for (i in 1:150) {
  x[i + 3] &lt;- 0.1 * x[i + 2] - 0.3 * x[i + 1] + 0.1 * x[i] +
    0.1 * w[i + 2] + 0.5 * w[i + 1] + w[i + 3]
}
for (i in 151:n) {
  x[i + 3] &lt;- 0.3 * x[i + 2] + 0.1 * x[i + 1] - 0.3 * x[i] -
    0.6 * w[i + 2] - 0.1 * w[i + 1] + w[i + 3]
}
result &lt;- suppressWarnings(
  fastcpd.arma(
    data = x[3 + seq_len(n)],
    order = c(3, 2),
    segment_count = 3,
    lower = c(rep(-1, 3 + 2), 1e-10),
    upper = c(rep(1, 3 + 2), Inf),
    line_search = c(1, 0.1, 1e-2),
    beta = "BIC",
    cost_adjustment = "BIC",
    trim = 0.025
  )
)
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='fastcpd_binomial'>Find change points efficiently in logistic regression models</h2><span id='topic+fastcpd_binomial'></span><span id='topic+fastcpd.binomial'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_binomial">fastcpd_binomial()</a></code> and <code><a href="#topic+fastcpd.binomial">fastcpd.binomial()</a></code> are
wrapper functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in
logistic regression models. The function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code>
except that the data is by default a matrix or data frame with the response
variable as the first column and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_binomial(data, ...)

fastcpd.binomial(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_binomial_+3A_data">data</code></td>
<td>
<p>A matrix or a data frame with the response variable as the first
column.</p>
</td></tr>
<tr><td><code id="fastcpd_binomial_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 500
  p &lt;- 4
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta &lt;- rbind(rnorm(p, 0, 1), rnorm(p, 2, 1))
  y &lt;- c(
    rbinom(300, 1, 1 / (1 + exp(-x[1:300, ] %*% theta[1, ]))),
    rbinom(200, 1, 1 / (1 + exp(-x[301:n, ] %*% theta[2, ])))
  )
  result &lt;- suppressWarnings(fastcpd.binomial(cbind(y, x)))
  summary(result)
  plot(result)
}
</code></pre>

<hr>
<h2 id='fastcpd_family'>Wrapper functions for fastcpd</h2><span id='topic+fastcpd_family'></span><span id='topic+fastcpd.family'></span>

<h3>Description</h3>

<p>Wrapper functions for fastcpd to find change points in various
models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd.mean">fastcpd.mean()</a></code>, <code><a href="#topic+fastcpd.variance">fastcpd.variance()</a></code>, <code><a href="#topic+fastcpd.mv">fastcpd.mv()</a></code>,
<code><a href="#topic+fastcpd.meanvariance">fastcpd.meanvariance()</a></code> for basic statistics change models;
<code><a href="#topic+fastcpd.lm">fastcpd.lm()</a></code>, <code><a href="#topic+fastcpd.binomial">fastcpd.binomial()</a></code>, <code><a href="#topic+fastcpd.poisson">fastcpd.poisson()</a></code>,
<code><a href="#topic+fastcpd.lasso">fastcpd.lasso()</a></code> for regression coefficients change models;
<code><a href="#topic+fastcpd.ar">fastcpd.ar()</a></code>, <code><a href="#topic+fastcpd.var">fastcpd.var()</a></code>, <code><a href="#topic+fastcpd.arima">fastcpd.arima()</a></code>, <code><a href="#topic+fastcpd.arma">fastcpd.arma()</a></code>,
<code><a href="#topic+fastcpd.garch">fastcpd.garch()</a></code> for change in time series models.
</p>

<hr>
<h2 id='fastcpd_garch'>Find change points efficiently in GARCH(<code class="reqn">p</code>, <code class="reqn">q</code>) models</h2><span id='topic+fastcpd_garch'></span><span id='topic+fastcpd.garch'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_garch">fastcpd_garch()</a></code> and <code><a href="#topic+fastcpd.garch">fastcpd.garch()</a></code> are
wrapper functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in
GARCH(<code class="reqn">p</code>, <code class="reqn">q</code>) models. The function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code>
except that the data is by default a one-column matrix or univariate vector
and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_garch(data, order = c(0, 0), ...)

fastcpd.garch(data, order = c(0, 0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_garch_+3A_data">data</code></td>
<td>
<p>A numeric vector, a matrix, a data frame or a time series object.</p>
</td></tr>
<tr><td><code id="fastcpd_garch_+3A_order">order</code></td>
<td>
<p>A positive integer vector of length two specifying the order of
the GARCH model.</p>
</td></tr>
<tr><td><code id="fastcpd_garch_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 1501
sigma_2 &lt;- rep(1, n + 1)
x &lt;- rep(0, n + 1)
for (i in seq_len(750)) {
  sigma_2[i + 1] &lt;- 20 + 0.8 * x[i]^2 + 0.1 * sigma_2[i]
  x[i + 1] &lt;- rnorm(1, 0, sqrt(sigma_2[i + 1]))
}
for (i in 751:n) {
  sigma_2[i + 1] &lt;- 1 + 0.1 * x[i]^2 + 0.5 * sigma_2[i]
  x[i + 1] &lt;- rnorm(1, 0, sqrt(sigma_2[i + 1]))
}
result &lt;- suppressWarnings(
  fastcpd.garch(x[-1], c(1, 1), include.mean = FALSE)
)
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='fastcpd_lasso'>Find change points efficiently in penalized linear regression models</h2><span id='topic+fastcpd_lasso'></span><span id='topic+fastcpd.lasso'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_lasso">fastcpd_lasso()</a></code> and <code><a href="#topic+fastcpd.lasso">fastcpd.lasso()</a></code> are wrapper
functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in penalized
linear regression models. The function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code>
except that the data is by default a matrix or data frame with the response
variable as the first column and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_lasso(data, ...)

fastcpd.lasso(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_lasso_+3A_data">data</code></td>
<td>
<p>A matrix or a data frame with the response variable as the first
column.</p>
</td></tr>
<tr><td><code id="fastcpd_lasso_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (
  requireNamespace("ggplot2", quietly = TRUE) &amp;&amp;
    requireNamespace("mvtnorm", quietly = TRUE)
) {
  set.seed(1)
  n &lt;- 480
  p_true &lt;- 5
  p &lt;- 50
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta_0 &lt;- rbind(
    runif(p_true, -5, -2),
    runif(p_true, -3, 3),
    runif(p_true, 2, 5),
    runif(p_true, -5, 5)
  )
  theta_0 &lt;- cbind(theta_0, matrix(0, ncol = p - p_true, nrow = 4))
  y &lt;- c(
    x[1:80, ] %*% theta_0[1, ] + rnorm(80, 0, 1),
    x[81:200, ] %*% theta_0[2, ] + rnorm(120, 0, 1),
    x[201:320, ] %*% theta_0[3, ] + rnorm(120, 0, 1),
    x[321:n, ] %*% theta_0[4, ] + rnorm(160, 0, 1)
  )
  result &lt;- fastcpd.lasso(
    cbind(y, x),
    multiple_epochs = function(segment_length) if (segment_length &lt; 30) 1 else 0
  )
  summary(result)
  plot(result)

  # Combine estimated thetas with true parameters
  thetas &lt;- result@thetas
  thetas &lt;- cbind.data.frame(thetas, t(theta_0))
  names(thetas) &lt;- c(
    "segment 1", "segment 2", "segment 3", "segment 4",
    "segment 1 truth", "segment 2 truth", "segment 3 truth", "segment 4 truth"
  )
  thetas$coordinate &lt;- c(seq_len(p_true), rep("rest", p - p_true))

  # Melt the data frame using base R (i.e., convert from wide to long format)
  data_cols &lt;- setdiff(names(thetas), "coordinate")
  molten &lt;- data.frame(
    coordinate = rep(thetas$coordinate, times = length(data_cols)),
    variable = rep(data_cols, each = nrow(thetas)),
    value = as.vector(as.matrix(thetas[, data_cols]))
  )

  # Remove the "segment " and " truth" parts to extract the segment number
  molten$segment &lt;- gsub("segment ", "", molten$variable)
  molten$segment &lt;- gsub(" truth", "", molten$segment)

  # Compute height: the numeric value of the segment plus an offset for truth values
  molten$height &lt;- as.numeric(gsub("segment.*", "", molten$segment)) +
    0.2 * as.numeric(grepl("truth", molten$variable))

  # Create a parameter indicator based on whether the variable corresponds to truth or estimation
  molten$parameter &lt;- ifelse(grepl("truth", molten$variable), "truth", "estimated")

  p &lt;- ggplot2::ggplot() +
    ggplot2::geom_point(
      data = molten,
      ggplot2::aes(
        x = value, y = height, shape = coordinate, color = parameter
      ),
      size = 4
    ) +
    ggplot2::ylim(0.8, 4.4) +
    ggplot2::ylab("segment") +
    ggplot2::theme_bw()
  print(p)
}

</code></pre>

<hr>
<h2 id='fastcpd_lm'>Find change points efficiently in linear regression models</h2><span id='topic+fastcpd_lm'></span><span id='topic+fastcpd.lm'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_lm">fastcpd_lm()</a></code> and <code><a href="#topic+fastcpd.lm">fastcpd.lm()</a></code> are wrapper
functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in linear
regression models. The function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code> except that
the data is by default a matrix or data frame with the response variable
as the first column and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_lm(data, ...)

fastcpd.lm(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_lm_+3A_data">data</code></td>
<td>
<p>A matrix or a data frame with the response variable as the first
column.</p>
</td></tr>
<tr><td><code id="fastcpd_lm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 300
  p &lt;- 4
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta_0 &lt;- rbind(c(1, 3.2, -1, 0), c(-1, -0.5, 2.5, -2), c(0.8, 0, 1, 2))
  y &lt;- c(
    x[1:100, ] %*% theta_0[1, ] + rnorm(100, 0, 3),
    x[101:200, ] %*% theta_0[2, ] + rnorm(100, 0, 3),
    x[201:n, ] %*% theta_0[3, ] + rnorm(100, 0, 3)
  )
  result_lm &lt;- fastcpd.lm(cbind(y, x))
  summary(result_lm)
  plot(result_lm)
}

if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 600
  p &lt;- 4
  d &lt;- 2
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta_1 &lt;- matrix(runif(8, -3, -1), nrow = p)
  theta_2 &lt;- matrix(runif(8, -1, 3), nrow = p)
  y &lt;- rbind(
    x[1:350, ] %*% theta_1 + mvtnorm::rmvnorm(350, rep(0, d), 3 * diag(d)),
    x[351:n, ] %*% theta_2 + mvtnorm::rmvnorm(250, rep(0, d), 3 * diag(d))
  )
  result_mlm &lt;- fastcpd.lm(cbind.data.frame(y = y, x = x), p.response = 2)
  summary(result_mlm)
}

</code></pre>

<hr>
<h2 id='fastcpd_mean'>Find change points efficiently in mean change models</h2><span id='topic+fastcpd_mean'></span><span id='topic+fastcpd.mean'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_mean">fastcpd_mean()</a></code> and <code><a href="#topic+fastcpd.mean">fastcpd.mean()</a></code> are wrapper
functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find the mean change. The function is
similar to <code><a href="#topic+fastcpd">fastcpd()</a></code> except that the data is by default a matrix or
data frame or a vector with each row / element as an observation and thus a
formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_mean(data, ...)

fastcpd.mean(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_mean_+3A_data">data</code></td>
<td>
<p>A matrix, a data frame or a vector.</p>
</td></tr>
<tr><td><code id="fastcpd_mean_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  p &lt;- 3
  data &lt;- rbind(
    mvtnorm::rmvnorm(3e+5, mean = rep(0, p), sigma = diag(100, p)),
    mvtnorm::rmvnorm(4e+5, mean = rep(50, p), sigma = diag(100, p)),
    mvtnorm::rmvnorm(3e+5, mean = rep(2, p), sigma = diag(100, p))
  )
  result_time &lt;- system.time(
    result &lt;- fastcpd.mean(data, r.progress = FALSE, cp_only = TRUE)
  )
  print(result_time)
  summary(result)
}
</code></pre>

<hr>
<h2 id='fastcpd_meanvariance'>Find change points efficiently in mean variance change models</h2><span id='topic+fastcpd_meanvariance'></span><span id='topic+fastcpd.meanvariance'></span><span id='topic+fastcpd_mv'></span><span id='topic+fastcpd.mv'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_meanvariance">fastcpd_meanvariance()</a></code>, <code><a href="#topic+fastcpd.meanvariance">fastcpd.meanvariance()</a></code>,
<code><a href="#topic+fastcpd_mv">fastcpd_mv()</a></code>, <code><a href="#topic+fastcpd.mv">fastcpd.mv()</a></code> are wrapper
functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find the meanvariance change. The
function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code> except that the data is by
default a matrix or data frame or a vector with each row / element as an
observation and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_meanvariance(data, ...)

fastcpd.meanvariance(data, ...)

fastcpd_mv(data, ...)

fastcpd.mv(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_meanvariance_+3A_data">data</code></td>
<td>
<p>A matrix, a data frame or a vector.</p>
</td></tr>
<tr><td><code id="fastcpd_meanvariance_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
p &lt;- 3
data &lt;- if (requireNamespace("mvtnorm", quietly = TRUE)) {
  rbind(
    mvtnorm::rmvnorm(2e+5, mean = rep(0, p), sigma = diag(1, p)),
    mvtnorm::rmvnorm(1e+5, mean = rep(50, p), sigma = diag(1, p)),
    mvtnorm::rmvnorm(2e+5, mean = rep(0, p), sigma = diag(100, p)),
    mvtnorm::rmvnorm(2e+5, mean = rep(0, p), sigma = diag(1, p)),
    mvtnorm::rmvnorm(1e+5, mean = rep(50, p), sigma = diag(1, p)),
    mvtnorm::rmvnorm(2e+5, mean = rep(50, p), sigma = diag(100, p))
  )
} else {
  rbind(
    matrix(rnorm(p * 2e+5, mean = 0, sd = 1), ncol = p),
    matrix(rnorm(p * 1e+5, mean = 50, sd = 1), ncol = p),
    matrix(rnorm(p * 2e+5, mean = 0, sd = 10), ncol = p),
    matrix(rnorm(p * 2e+5, mean = 0, sd = 1), ncol = p),
    matrix(rnorm(p * 1e+5, mean = 50, sd = 1), ncol = p),
    matrix(rnorm(p * 2e+5, mean = 50, sd = 10), ncol = p)
  )
}
(result_time &lt;- system.time(result &lt;- fastcpd.mv(data)))
summary(result)
result@thetas[seq_len(p), ]
lapply(result@thetas[seq_len(p^2) + p, ], function(thetas) matrix(thetas, p))
</code></pre>

<hr>
<h2 id='fastcpd_poisson'>Find change points efficiently in Poisson regression models</h2><span id='topic+fastcpd_poisson'></span><span id='topic+fastcpd.poisson'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_poisson">fastcpd_poisson()</a></code> and <code><a href="#topic+fastcpd.poisson">fastcpd.poisson()</a></code> are
wrapper functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in
Poisson regression models. The function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code>
except that the data is by default a matrix or data frame with the response
variable as the first column and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_poisson(data, ...)

fastcpd.poisson(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_poisson_+3A_data">data</code></td>
<td>
<p>A matrix or a data frame with the response variable as the first
column.</p>
</td></tr>
<tr><td><code id="fastcpd_poisson_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 1100
  p &lt;- 3
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  delta &lt;- rnorm(p)
  theta_0 &lt;- c(1, 0.3, -1)
  y &lt;- c(
    rpois(500, exp(x[1:500, ] %*% theta_0)),
    rpois(300, exp(x[501:800, ] %*% (theta_0 + delta))),
    rpois(200, exp(x[801:1000, ] %*% theta_0)),
    rpois(100, exp(x[1001:1100, ] %*% (theta_0 - delta)))
  )
  result &lt;- fastcpd.poisson(cbind(y, x))
  summary(result)
  plot(result)
}

</code></pre>

<hr>
<h2 id='fastcpd_ts'>Find change points efficiently in time series data</h2><span id='topic+fastcpd_ts'></span><span id='topic+fastcpd.ts'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_ts">fastcpd_ts()</a></code> and <code><a href="#topic+fastcpd.ts">fastcpd.ts()</a></code> are wrapper functions for
<code><a href="#topic+fastcpd">fastcpd()</a></code> to find change points in time series data. The function is
similar to <code><a href="#topic+fastcpd">fastcpd()</a></code> except that the data is a time series and the
family is one of <code>"ar"</code>, <code>"var"</code>, <code>"arma"</code>, <code>"arima"</code> or
<code>"garch"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_ts(data, family = NULL, order = c(0, 0, 0), ...)

fastcpd.ts(data, family = NULL, order = c(0, 0, 0), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_ts_+3A_data">data</code></td>
<td>
<p>A numeric vector, a matrix, a data frame or a time series object.</p>
</td></tr>
<tr><td><code id="fastcpd_ts_+3A_family">family</code></td>
<td>
<p>A character string specifying the family of the time series.
The value should be one of <code>"ar"</code>, <code>"var"</code>, <code>"arima"</code> or
<code>"garch"</code>.</p>
</td></tr>
<tr><td><code id="fastcpd_ts_+3A_order">order</code></td>
<td>
<p>A positive integer or a vector of length less than four
specifying the order of the time series. Possible combinations with
<code>family</code> are:
</p>

<ul>
<li> <p><code>"ar"</code>, NUMERIC(1): AR(<code class="reqn">p</code>) model using linear regression.
</p>
</li>
<li> <p><code>"var"</code>, NUMERIC(1): VAR(<code class="reqn">p</code>) model using linear regression.
</p>
</li>
<li> <p><code>"arima"</code>, NUMERIC(3): ARIMA(<code class="reqn">p</code>, <code class="reqn">d</code>, <code class="reqn">q</code>) model
using <code><a href="stats.html#topic+arima">stats::arima()</a></code>.
</p>
</li>
<li> <p><code>"garch"</code>, NUMERIC(2): GARCH(<code class="reqn">p</code>, <code class="reqn">q</code>) model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fastcpd_ts_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>. One special argument can be passed here is
<code>include.mean</code>, which is a logical value indicating whether the
mean should be included in the model. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set seed for reproducibility
set.seed(1)

# 1. Define Parameters
n &lt;- 500           # Total length of the time series
cp1 &lt;- 200         # First change point at time 200
cp2 &lt;- 350         # Second change point at time 350

# Define MA(2) coefficients for each segment ensuring invertibility
# MA coefficients affect invertibility; to ensure invertibility, the roots of
# the MA polynomial should lie outside the unit circle.

# Segment 1: Time 1 to cp1
theta1_1 &lt;- 0.5
theta2_1 &lt;- -0.3

# Segment 2: Time (cp1+1) to cp2
theta1_2 &lt;- -0.4
theta2_2 &lt;- 0.25

# Segment 3: Time (cp2+1) to n
theta1_3 &lt;- 0.6
theta2_3 &lt;- -0.35

# Function to check invertibility for MA(2)
is_invertible_ma2 &lt;- function(theta1, theta2) {
  # The MA(2) polynomial is: 1 + theta1*z + theta2*z^2 = 0
  # Compute the roots of the polynomial
  roots &lt;- polyroot(c(1, theta1, theta2))
  # Invertible if all roots lie outside the unit circle
  all(Mod(roots) &gt; 1)
}

# Verify invertibility for each segment
stopifnot(is_invertible_ma2(theta1_1, theta2_1))
stopifnot(is_invertible_ma2(theta1_2, theta2_2))
stopifnot(is_invertible_ma2(theta1_3, theta2_3))

# 2. Simulate White Noise
e &lt;- rnorm(n + 2, mean = 0, sd = 1)  # Extra terms to handle lag

# 3. Initialize the Time Series
y &lt;- numeric(n + 2)  # Extra terms for initial lags (y[1], y[2] are zero)

# 4. Apply MA(2) Model with Change Points
for (t in 3:(n + 2)) {  # Start from 3 to have enough lags for MA(2)
  # Determine current segment
  current_time &lt;- t - 2  # Adjust for the extra lags
  if (current_time &lt;= cp1) {
    theta &lt;- c(theta1_1, theta2_1)
  } else if (current_time &lt;= cp2) {
    theta &lt;- c(theta1_2, theta2_2)
  } else {
    theta &lt;- c(theta1_3, theta2_3)
  }

  # Compute MA(2) value
  y[t] &lt;- e[t] + theta[1] * e[t - 1] + theta[2] * e[t - 2]
}

# Remove the initial extra terms
y &lt;- y[3:(n + 2)]
time &lt;- 1:n

# Function to get roots data for plotting
get_roots_data &lt;- function(theta1, theta2, segment) {
  roots &lt;- polyroot(c(1, theta1, theta2))
  data.frame(
    Re = Re(roots),
    Im = Im(roots),
    Distance = Mod(roots),
    Segment = segment
  )
}

roots_segment1 &lt;- get_roots_data(theta1_1, theta2_1, "Segment 1")
roots_segment2 &lt;- get_roots_data(theta1_2, theta2_2, "Segment 2")
roots_segment3 &lt;- get_roots_data(theta1_3, theta2_3, "Segment 3")

(roots_data &lt;- rbind(roots_segment1, roots_segment2, roots_segment3))

result &lt;- fastcpd.ts(
  y,
  "arma",
  c(0, 2),
  lower = c(-2, -2, 1e-10),
  upper = c(2, 2, Inf),
  line_search = c(1, 0.1, 1e-2),
  trim = 0.04
)
summary(result)
plot(result)

</code></pre>

<hr>
<h2 id='fastcpd_var'>Find change points efficiently in VAR(<code class="reqn">p</code>) models</h2><span id='topic+fastcpd_var'></span><span id='topic+fastcpd.var'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_var">fastcpd_var()</a></code> and <code><a href="#topic+fastcpd.var">fastcpd.var()</a></code> are
wrapper functions of <code><a href="#topic+fastcpd_ts">fastcpd_ts()</a></code> to find change points in
VAR(<code class="reqn">p</code>) models. The function is similar to <code><a href="#topic+fastcpd_ts">fastcpd_ts()</a></code>
except that the data is by default a matrix with row as an observation
and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_var(data, order = 0, ...)

fastcpd.var(data, order = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_var_+3A_data">data</code></td>
<td>
<p>A matrix, a data frame or a time series object.</p>
</td></tr>
<tr><td><code id="fastcpd_var_+3A_order">order</code></td>
<td>
<p>A positive integer specifying the order of the VAR model.</p>
</td></tr>
<tr><td><code id="fastcpd_var_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 300
p &lt;- 2
theta_1 &lt;- matrix(c(-0.3, 0.6, -0.5, 0.4, 0.2, 0.2, 0.2, -0.2), nrow = p)
theta_2 &lt;- matrix(c(0.3, -0.4, 0.1, -0.5, -0.5, -0.2, -0.5, 0.2), nrow = p)
x &lt;- matrix(0, n + 2, p)
for (i in 1:200) {
  x[i + 2, ] &lt;- theta_1 %*% c(x[i + 1, ], x[i, ]) + rnorm(p, 0, 1)
}
for (i in 201:n) {
  x[i + 2, ] &lt;- theta_2 %*% c(x[i + 1, ], x[i, ]) + rnorm(p, 0, 1)
}
result &lt;- fastcpd.var(x, 2)
summary(result)
</code></pre>

<hr>
<h2 id='fastcpd_variance'>Find change points efficiently in variance change models</h2><span id='topic+fastcpd_variance'></span><span id='topic+fastcpd.variance'></span>

<h3>Description</h3>

<p><code><a href="#topic+fastcpd_variance">fastcpd_variance()</a></code> and <code><a href="#topic+fastcpd.variance">fastcpd.variance()</a></code> are wrapper
functions of <code><a href="#topic+fastcpd">fastcpd()</a></code> to find the variance change. The
function is similar to <code><a href="#topic+fastcpd">fastcpd()</a></code> except that the data is by
default a matrix or data frame or a vector with each row / element as an
observation and thus a formula is not required here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcpd_variance(data, ...)

fastcpd.variance(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fastcpd_variance_+3A_data">data</code></td>
<td>
<p>A matrix, a data frame or a vector.</p>
</td></tr>
<tr><td><code id="fastcpd_variance_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+fastcpd">fastcpd()</a></code>, for example,
<code>segment_count</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fastcpd">fastcpd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  p &lt;- 3
  data &lt;- rbind(
    mvtnorm::rmvnorm(
      3e+5, rep(0, p), crossprod(matrix(runif(p^2) * 2 - 1, p))
    ),
    mvtnorm::rmvnorm(
      4e+5, rep(0, p), crossprod(matrix(runif(p^2) * 2 - 1, p))
    ),
    mvtnorm::rmvnorm(
      3e+5, rep(0, p), crossprod(matrix(runif(p^2) * 2 - 1, p))
    )
  )
  result_time &lt;- system.time(
    result &lt;- fastcpd.variance(data, r.progress = FALSE, cp_only = TRUE)
  )
  print(result_time)
  summary(result)
}
</code></pre>

<hr>
<h2 id='fastcpd-class'>An S4 class to store the output created with <code><a href="#topic+fastcpd">fastcpd()</a></code></h2><span id='topic+fastcpd-class'></span>

<h3>Description</h3>

<p>This S4 class stores the output from <code><a href="#topic+fastcpd">fastcpd()</a></code> and
<a href="#topic+fastcpd.family">fastcpd.family</a>. A fastcpd object consist
of several slots including the call to <code><a href="#topic+fastcpd">fastcpd()</a></code>, the data used, the
family of the model, the change points, the cost values, the residuals, the
estimated parameters and a boolean indicating whether the model was fitted
with only change points or with change points and parameters, which you can
select using <code>@</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>The call of the function.</p>
</dd>
<dt><code>data</code></dt><dd><p>The data passed to the function.</p>
</dd>
<dt><code>order</code></dt><dd><p>The order of the time series model.</p>
</dd>
<dt><code>family</code></dt><dd><p>The family of the model.</p>
</dd>
<dt><code>cp_set</code></dt><dd><p>The set of change points.</p>
</dd>
<dt><code>cost_values</code></dt><dd><p>The cost function values for each segment.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>The residuals of the model with change points.
Used only for built-in families.</p>
</dd>
<dt><code>thetas</code></dt><dd><p>The estimated parameters for each segment. Used only for
built-in families.</p>
</dd>
<dt><code>cp_only</code></dt><dd><p>A boolean indicating whether <code><a href="#topic+fastcpd">fastcpd()</a></code> was run to return
only the change points or the change points with the estimated parameters
and cost values for each segment.</p>
</dd>
</dl>

<hr>
<h2 id='occupancy'>Occupancy Detection Data Set</h2><span id='topic+occupancy'></span>

<h3>Description</h3>

<p>Data set for binary classification of room occupancy from
temperature, humidity, light and CO2 measurements. Ground-truth occupancy
was obtained from time stamped pictures that were taken every minute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occupancy
</code></pre>


<h3>Format</h3>

<p>A data frame with 9752 rows and 7 variables:
</p>

<dl>
<dt>date</dt><dd><p>Character in the format &quot;YYYY-MM-DD hh:mm:ss&quot; from
2015-02-11 14:48:00 to 2015-02-18 09:19:00</p>
</dd>
<dt>Temperature</dt><dd><p>Temperature in Celsius</p>
</dd>
<dt>Humidity</dt><dd><p>Humidity</p>
</dd>
<dt>Light</dt><dd><p>Light</p>
</dd>
<dt>CO2</dt><dd><p>CO2</p>
</dd>
<dt>HumidityRatio</dt><dd><p>Humidity Ratio</p>
</dd>
<dt>Occupancy</dt><dd><p>Binary variable with values 0 (unoccupied) and 1</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://github.com/LuisM78/Occupancy-detection-data&gt;
</p>

<hr>
<h2 id='plot.fastcpd'>Plot the data and the change points for a <a href="#topic+fastcpd-class">fastcpd</a> object</h2><span id='topic+plot.fastcpd'></span><span id='topic+plot+2Cfastcpd+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot the data and the change points for a <a href="#topic+fastcpd-class">fastcpd</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fastcpd'
plot(
  x,
  color_max_count = Inf,
  data_point_alpha = 0.8,
  data_point_linewidth = 0.5,
  data_point_size = 1,
  legend_position = "none",
  panel_background = ggplot2::element_blank(),
  panel_border = ggplot2::element_rect(fill = NA, colour = "grey20"),
  panel_grid_major = ggplot2::element_line(colour = "grey98"),
  panel_grid_minor = ggplot2::element_line(colour = "grey98"),
  segment_separator_alpha = 0.8,
  segment_separator_color = "grey",
  segment_separator_linetype = "dashed",
  strip_background = ggplot2::element_rect(fill = "grey85", colour = "grey20"),
  xlab = NULL,
  ylab = NULL,
  ...
)

## S4 method for signature 'fastcpd,missing'
plot(
  x,
  color_max_count = Inf,
  data_point_alpha = 0.8,
  data_point_linewidth = 0.5,
  data_point_size = 1,
  legend_position = "none",
  panel_background = ggplot2::element_blank(),
  panel_border = ggplot2::element_rect(fill = NA, colour = "grey20"),
  panel_grid_major = ggplot2::element_line(colour = "grey98"),
  panel_grid_minor = ggplot2::element_line(colour = "grey98"),
  segment_separator_alpha = 0.8,
  segment_separator_color = "grey",
  segment_separator_linetype = "dashed",
  strip_background = ggplot2::element_rect(fill = "grey85", colour = "grey20"),
  xlab = NULL,
  ylab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fastcpd_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_color_max_count">color_max_count</code></td>
<td>
<p>Maximum number of colors to use for the plotting
of segments.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_data_point_alpha">data_point_alpha</code></td>
<td>
<p>Alpha of the data points.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_data_point_linewidth">data_point_linewidth</code></td>
<td>
<p>Linewidth of the data points.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_data_point_size">data_point_size</code></td>
<td>
<p>Size of the data points.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_legend_position">legend_position</code></td>
<td>
<p>Position of the legend.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_panel_background">panel_background</code></td>
<td>
<p>Background of the panel.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_panel_border">panel_border</code></td>
<td>
<p>Border of the panel.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_panel_grid_major">panel_grid_major</code></td>
<td>
<p>Major grid lines of the panel.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_panel_grid_minor">panel_grid_minor</code></td>
<td>
<p>Minor grid lines of the panel.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_segment_separator_alpha">segment_separator_alpha</code></td>
<td>
<p>Alpha of the segment separator lines.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_segment_separator_color">segment_separator_color</code></td>
<td>
<p>Color of the segment separator lines.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_segment_separator_linetype">segment_separator_linetype</code></td>
<td>
<p>Linetype of the segment separator lines.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_strip_background">strip_background</code></td>
<td>
<p>Background of the strip.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.fastcpd_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  p &lt;- 1
  x &lt;- mvtnorm::rmvnorm(300, rep(0, p), diag(p))
  theta_0 &lt;- matrix(c(1, -1, 0.5))
  y &lt;- c(
    x[1:100, ] * theta_0[1, ] + rnorm(100, 0, 1),
    x[101:200, ] * theta_0[2, ] + rnorm(100, 0, 1),
    x[201:300, ] * theta_0[3, ] + rnorm(100, 0, 1)
  )
  result &lt;- fastcpd.lm(cbind(y, x))
  summary(result)
  plot(result)
}
</code></pre>

<hr>
<h2 id='print.fastcpd'>Print the call and the change points for a <a href="#topic+fastcpd-class">fastcpd</a> object</h2><span id='topic+print.fastcpd'></span><span id='topic+print+2Cfastcpd-method'></span>

<h3>Description</h3>

<p>Print the call and the change points for a <a href="#topic+fastcpd-class">fastcpd</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fastcpd'
print(x, ...)

## S4 method for signature 'fastcpd'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fastcpd_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.</p>
</td></tr>
<tr><td><code id="print.fastcpd_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a (temporarily) invisible copy of the <a href="#topic+fastcpd-class">fastcpd</a> object.
Called primarily for printing the change points in the model.
</p>

<hr>
<h2 id='show.fastcpd'>Show the available methods for a <a href="#topic+fastcpd-class">fastcpd</a> object</h2><span id='topic+show.fastcpd'></span><span id='topic+show+2Cfastcpd-method'></span>

<h3>Description</h3>

<p>Show the available methods for a <a href="#topic+fastcpd-class">fastcpd</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fastcpd'
show(object)

## S4 method for signature 'fastcpd'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show.fastcpd_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for showing a list of available methods
for a <a href="#topic+fastcpd-class">fastcpd</a> object.
</p>

<hr>
<h2 id='summary.fastcpd'>Show the summary of a <a href="#topic+fastcpd-class">fastcpd</a> object</h2><span id='topic+summary.fastcpd'></span><span id='topic+summary+2Cfastcpd-method'></span>

<h3>Description</h3>

<p>Show the summary of a <a href="#topic+fastcpd-class">fastcpd</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fastcpd'
summary(object, ...)

## S4 method for signature 'fastcpd'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fastcpd_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+fastcpd-class">fastcpd</a> object.</p>
</td></tr>
<tr><td><code id="summary.fastcpd_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a (temporarily) invisible copy of the <a href="#topic+fastcpd-class">fastcpd</a> object.
Called primarily for printing the summary of the model including the
call, the change points, the cost values and the estimated parameters.
</p>

<hr>
<h2 id='transcriptome'>Transcription Profiling of 57 Human Bladder Carcinoma Samples</h2><span id='topic+transcriptome'></span>

<h3>Description</h3>

<p>Transcriptome analysis of 57 bladder carcinomas on
Affymetrix HG-U95A and HG-U95Av2 microarrays
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcriptome
</code></pre>


<h3>Format</h3>

<p>A data frame with 2215 rows and 43 variables:
</p>

<dl>
<dt>3</dt><dd><p>Individual 3</p>
</dd>
<dt>4</dt><dd><p>Individual 4</p>
</dd>
<dt>5</dt><dd><p>Individual 5</p>
</dd>
<dt>6</dt><dd><p>Individual 6</p>
</dd>
<dt>7</dt><dd><p>Individual 7</p>
</dd>
<dt>8</dt><dd><p>Individual 8</p>
</dd>
<dt>9</dt><dd><p>Individual 9</p>
</dd>
<dt>10</dt><dd><p>Individual 10</p>
</dd>
<dt>14</dt><dd><p>Individual 14</p>
</dd>
<dt>15</dt><dd><p>Individual 15</p>
</dd>
<dt>16</dt><dd><p>Individual 16</p>
</dd>
<dt>17</dt><dd><p>Individual 17</p>
</dd>
<dt>18</dt><dd><p>Individual 18</p>
</dd>
<dt>19</dt><dd><p>Individual 19</p>
</dd>
<dt>21</dt><dd><p>Individual 21</p>
</dd>
<dt>22</dt><dd><p>Individual 22</p>
</dd>
<dt>24</dt><dd><p>Individual 24</p>
</dd>
<dt>26</dt><dd><p>Individual 26</p>
</dd>
<dt>28</dt><dd><p>Individual 28</p>
</dd>
<dt>30</dt><dd><p>Individual 30</p>
</dd>
<dt>31</dt><dd><p>Individual 31</p>
</dd>
<dt>33</dt><dd><p>Individual 33</p>
</dd>
<dt>34</dt><dd><p>Individual 34</p>
</dd>
<dt>35</dt><dd><p>Individual 35</p>
</dd>
<dt>36</dt><dd><p>Individual 36</p>
</dd>
<dt>37</dt><dd><p>Individual 37</p>
</dd>
<dt>38</dt><dd><p>Individual 38</p>
</dd>
<dt>39</dt><dd><p>Individual 39</p>
</dd>
<dt>40</dt><dd><p>Individual 40</p>
</dd>
<dt>41</dt><dd><p>Individual 41</p>
</dd>
<dt>42</dt><dd><p>Individual 42</p>
</dd>
<dt>43</dt><dd><p>Individual 43</p>
</dd>
<dt>44</dt><dd><p>Individual 44</p>
</dd>
<dt>45</dt><dd><p>Individual 45</p>
</dd>
<dt>46</dt><dd><p>Individual 46</p>
</dd>
<dt>47</dt><dd><p>Individual 47</p>
</dd>
<dt>48</dt><dd><p>Individual 48</p>
</dd>
<dt>49</dt><dd><p>Individual 49</p>
</dd>
<dt>50</dt><dd><p>Individual 50</p>
</dd>
<dt>51</dt><dd><p>Individual 51</p>
</dd>
<dt>53</dt><dd><p>Individual 53</p>
</dd>
<dt>54</dt><dd><p>Individual 54</p>
</dd>
<dt>57</dt><dd><p>Individual 57</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://www.ebi.ac.uk/biostudies/arrayexpress/studies/E-TABM-147&gt;
</p>
<p>&lt;https://github.com/cran/ecp/tree/master/data&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("ggplot2", quietly = TRUE)) {
  result &lt;- fastcpd.mean(transcriptome$"10", trim = 0.005)
  summary(result)
  plot(result)

  result_all &lt;- fastcpd.mean(
    transcriptome,
    beta = (ncol(transcriptome) + 1) * log(nrow(transcriptome)) / 2 * 5,
    trim = 0
  )

  plots &lt;- lapply(
    seq_len(ncol(transcriptome)), function(i) {
      ggplot2::ggplot(
        data = data.frame(
          x = seq_along(transcriptome[, i]), y = transcriptome[, i]
        ),
        ggplot2::aes(x = x, y = y)
      ) +
        ggplot2::geom_line(color = "steelblue") +
        ggplot2::geom_vline(
          xintercept = result_all@cp_set,
          color = "red",
          linetype = "dotted",
          linewidth = 0.5,
          alpha = 0.7
        ) +
        ggplot2::theme_void()
    }
  )

  if (requireNamespace("gridExtra", quietly = TRUE)) {
    gridExtra::grid.arrange(grobs = plots, ncol = 1, nrow = ncol(transcriptome))
  }
}

</code></pre>

<hr>
<h2 id='uk_seatbelts'>UK Seatbelts Data</h2><span id='topic+uk_seatbelts'></span>

<h3>Description</h3>

<p>Road Casualties in Great Britain 1969–84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uk_seatbelts
</code></pre>


<h3>Format</h3>

<p><code>uk_seatbelts</code> is a multiple time series, with columns
</p>

<dl>
<dt>DriversKilled</dt><dd><p>car drivers killed.</p>
</dd>
<dt>front</dt><dd><p>front-seat passengers killed or seriously injured.</p>
</dd>
<dt>rear</dt><dd><p>rear-seat passengers killed or seriously injured.</p>
</dd>
<dt>kms</dt><dd><p>distance driven.</p>
</dd>
<dt>PetrolPrice</dt><dd><p>petrol price.</p>
</dd>
<dt>VanKilled</dt><dd><p>number of van (‘light goods vehicle’) drivers.</p>
</dd>
<dt>law</dt><dd><p>0/1: was the law in effect that month?</p>
</dd>
</dl>



<h3>Source</h3>

<p>R package <span class="pkg">datasets</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("ggplot2", quietly = TRUE)) {
  result_ar &lt;- fastcpd.ar(diff(uk_seatbelts[, "drivers"], 12), 1, beta = "BIC")
  summary(result_ar)
  plot(result_ar)

  result_lm &lt;- suppressMessages(fastcpd.lm(
    diff(uk_seatbelts[, c("drivers", "kms", "PetrolPrice", "law")], lag = 12)
  ))

  # Compute change point dates:
  cp_dates &lt;- as.POSIXlt(as.Date("1969-01-01", format = "%Y-%m-%d"))
  cp_dates$mon &lt;- cp_dates$mon + (1 + result_lm@cp_set + 12)
  cp_dates &lt;- as.Date(cp_dates)

  # Convert the time series to Date objects:
  # For a monthly ts object, extract year and month manually.
  time_vals &lt;- time(uk_seatbelts)
  years &lt;- floor(time_vals)
  months &lt;- round((time_vals - years) * 12 + 1)
  dates &lt;- as.Date(paste(years, months, "01", sep = "-"), format = "%Y-%m-%d")

  # Prepare the data frame for plotting
  # 'color' is defined similarly to the original code.
  uk_seatbelts_df &lt;- data.frame(
    dates = dates,
    drivers = as.numeric(uk_seatbelts[, "drivers"]),
    color = as.factor((dates &lt; cp_dates[1]) + (dates &lt; cp_dates[2]))
  )

  p &lt;- ggplot2::ggplot(
    data = uk_seatbelts_df,
    ggplot2::aes(x = dates, y = drivers, color = color)
  ) +
    ggplot2::geom_line() +
    ggplot2::geom_vline(
      xintercept = cp_dates,
      linetype = "dashed",
      color = "red"
    ) +
    ggplot2::scale_x_date(date_labels = "%b %Y", date_breaks = "1 year") +
    ggplot2::annotate(
      "text",
      x = cp_dates,
      y = 1025,
      label = format(cp_dates, "%b %Y"),
      color = "blue"
    ) +
    ggplot2::theme_bw() +
    ggplot2::theme(legend.position = "none")
  print(p)
}
</code></pre>

<hr>
<h2 id='variance_arma'>Variance estimation for ARMA model with change points</h2><span id='topic+variance_arma'></span><span id='topic+variance.arma'></span>

<h3>Description</h3>

<p>Estimate the variance for each block and then take the average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance_arma(data, p, q, max_order = p * q)

variance.arma(data, p, q, max_order = p * q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variance_arma_+3A_data">data</code></td>
<td>
<p>A one-column matrix or a vector.</p>
</td></tr>
<tr><td><code id="variance_arma_+3A_p">p</code></td>
<td>
<p>The order of the autoregressive part.</p>
</td></tr>
<tr><td><code id="variance_arma_+3A_q">q</code></td>
<td>
<p>The order of the moving average part.</p>
</td></tr>
<tr><td><code id="variance_arma_+3A_max_order">max_order</code></td>
<td>
<p>The maximum order of the AR model to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 300
w &lt;- rnorm(n + 3, 0, 10)
x &lt;- rep(0, n + 3)
for (i in 1:200) {
  x[i + 3] &lt;- 0.1 * x[i + 2] - 0.3 * x[i + 1] + 0.1 * x[i] +
    0.1 * w[i + 2] + 0.5 * w[i + 1] + w[i + 3]
}
for (i in 201:n) {
  x[i + 3] &lt;- 0.3 * x[i + 2] + 0.1 * x[i + 1] - 0.3 * x[i] -
    0.6 * w[i + 2] - 0.1 * w[i + 1] + w[i + 3]
}
(result &lt;- variance.arma(x[-seq_len(3)], p = 3, q = 2))
</code></pre>

<hr>
<h2 id='variance_lm'>Variance estimation for linear models with change points</h2><span id='topic+variance_lm'></span><span id='topic+variance.lm'></span>

<h3>Description</h3>

<p>Estimate the variance for each block and then take the average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance_lm(data, d = 1, block_size = ncol(data) - d + 1, outlier_iqr = Inf)

variance.lm(data, d = 1, block_size = ncol(data) - d + 1, outlier_iqr = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variance_lm_+3A_data">data</code></td>
<td>
<p>A matrix or a data frame with the response variable as the first
column.</p>
</td></tr>
<tr><td><code id="variance_lm_+3A_d">d</code></td>
<td>
<p>The dimension of the response variable.</p>
</td></tr>
<tr><td><code id="variance_lm_+3A_block_size">block_size</code></td>
<td>
<p>The size of the blocks to use for variance estimation.</p>
</td></tr>
<tr><td><code id="variance_lm_+3A_outlier_iqr">outlier_iqr</code></td>
<td>
<p>The number of interquartile ranges to use as a threshold
for outlier detection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  n &lt;- 300
  p &lt;- 4
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta &lt;- rbind(c(1, 3.2, -1, 0), c(-1, -0.5, 2.5, -2), c(0.8, 0, 1, 2))
  y &lt;- c(
    x[1:100, ] %*% theta[1, ] + rnorm(100, 0, 3),
    x[101:200, ] %*% theta[2, ] + rnorm(100, 0, 3),
    x[201:n, ] %*% theta[3, ] + rnorm(100, 0, 3)
  )
  (sigma2 &lt;- variance.lm(cbind(y, x)))

  set.seed(1)
  n &lt;- 300
  p &lt;- 4
  d &lt;- 2
  x &lt;- mvtnorm::rmvnorm(n, rep(0, p), diag(p))
  theta &lt;- cbind(c(1, 3.2, -1, 0), c(-1, -0.5, 2.5, -2), c(0.8, 0, 1, 2))
  theta &lt;- cbind(theta, theta)
  y &lt;- rbind(
    x[1:100, ] %*% theta[, 1:2] +
      mvtnorm::rmvnorm(100, rep(0, d), diag(3, d)),
    x[101:200, ] %*% theta[, 3:4] +
      mvtnorm::rmvnorm(100, rep(0, d), diag(3, d)),
    x[201:n, ] %*% theta[, 5:6] +
      mvtnorm::rmvnorm(100, rep(0, d), diag(3, d))
  )
  (sigma &lt;- variance.lm(cbind(y, x), d = d))
}
</code></pre>

<hr>
<h2 id='variance_mean'>Variance estimation for mean change models</h2><span id='topic+variance_mean'></span><span id='topic+variance.mean'></span>

<h3>Description</h3>

<p>Implement Rice estimator for variance in mean change models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance_mean(data)

variance.mean(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variance_mean_+3A_data">data</code></td>
<td>
<p>A matrix or a data frame with data points as each row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the variance-covariance matrix or a numeric
value representing the variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mvtnorm", quietly = TRUE)) {
  set.seed(1)
  p &lt;- 3
  data &lt;- rbind(
    mvtnorm::rmvnorm(300, mean = rep(0, p), sigma = diag(100, p)),
    mvtnorm::rmvnorm(400, mean = rep(50, p), sigma = diag(100, p)),
    mvtnorm::rmvnorm(300, mean = rep(2, p), sigma = diag(100, p))
  )
  (sigma &lt;- variance.mean(data))
}
</code></pre>

<hr>
<h2 id='variance_median'>Variance estimation for median change models</h2><span id='topic+variance_median'></span><span id='topic+variance.median'></span>

<h3>Description</h3>

<p>Implement Rice estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance_median(data)

variance.median(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variance_median_+3A_data">data</code></td>
<td>
<p>A vector of data points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(sigma2 &lt;- variance.median(well_log))
</code></pre>

<hr>
<h2 id='well_log'>Well-log Dataset from Numerical Bayesian Methods Applied to
Signal Processing</h2><span id='topic+well_log'></span>

<h3>Description</h3>

<p>This is the well-known well-log dataset used in many changepoint
papers obtained from Alan Turing Institute GitHub repository and licensed
under the MIT license.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>well_log
</code></pre>


<h3>Format</h3>

<p>A Time-Series of length 4050.
</p>


<h3>Source</h3>

<p>&lt;https://github.com/alan-turing-institute/TCPD&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- fastcpd.mean(well_log, trim = 0.001)
summary(result)
plot(result)

if (requireNamespace("matrixStats", quietly = TRUE)) {
  sigma2 &lt;- variance.median(well_log)
  median_loss &lt;- function(data) {
    sum(abs(data - matrixStats::colMedians(data))) / sqrt(sigma2) / 2
  }
  result &lt;- fastcpd(
    formula = ~ x - 1,
    data = cbind.data.frame(x = well_log),
    cost = median_loss,
    trim = 0.002
  )
  summary(result)

  segment_starts &lt;- c(1, result@cp_set)
  segment_ends &lt;- c(result@cp_set - 1, length(well_log))
  residual &lt;- NULL
  for (segment_index in seq_along(segment_starts)) {
    segment &lt;-
      well_log[segment_starts[segment_index]:segment_ends[segment_index]]
    residual &lt;- c(residual, segment - median(segment))
  }

  result@residuals &lt;- matrix(residual)
  result@data &lt;- data.frame(x = c(well_log))
  plot(result)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
