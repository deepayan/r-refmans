<!DOCTYPE html><html><head><title>Help for package SCORPIUS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SCORPIUS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SCORPIUS-package'><p>SCORPIUS: Trajectory inference from single-cell RNA sequencing data.</p></a></li>
<li><a href='#draw_trajectory_heatmap'><p>Draw time-series heatmap</p></a></li>
<li><a href='#draw_trajectory_plot'><p>Visualise SCORPIUS</p></a></li>
<li><a href='#extract_modules'><p>Extract modules of features</p></a></li>
<li><a href='#gene_importances'><p>Calculate the importance of a feature</p></a></li>
<li><a href='#generate_dataset'><p>Generate a synthetic dataset</p></a></li>
<li><a href='#ginhoux'><p>scRNA-seq data of dendritic cell progenitors.</p></a></li>
<li><a href='#infer_initial_trajectory'><p>Infer an initial trajectory through space</p></a></li>
<li><a href='#infer_trajectory'><p>Infer linear trajectory through space</p></a></li>
<li><a href='#reduce_dimensionality'><p>Dimensionality reduction</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reverse_trajectory'><p>Reverse a trajectory</p></a></li>
<li><a href='#ti_scorpius'><p>Infer a trajectory using SCORPIUS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inferring Developmental Chronologies from Single-Cell RNA
Sequencing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.9</td>
</tr>
<tr>
<td>Description:</td>
<td>An accurate and easy tool for performing linear trajectory inference on
  single cells using single-cell RNA sequencing data. In addition, 'SCORPIUS'
  provides functions for discovering the most important genes with respect to
  the reconstructed trajectory, as well as nice visualisation tools.
  Cannoodt et al. (2016) &lt;<a href="https://doi.org/10.1101%2F079509">doi:10.1101/079509</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rcannood/SCORPIUS">https://github.com/rcannood/SCORPIUS</a>,
<a href="http://rcannood.github.io/SCORPIUS/">http://rcannood.github.io/SCORPIUS/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rcannood/SCORPIUS/issues">https://github.com/rcannood/SCORPIUS/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, dynutils (&ge; 1.0.3), dynwrap, grDevices, ggplot2 (&ge;
2.0), lmds, MASS, Matrix, mclust, methods, pbapply, pheatmap,
princurve (&ge; 2.1.4), purrr, ranger, RANN, RColorBrewer,
reshape2, stats, tidyr, TSP</td>
</tr>
<tr>
<td>Suggests:</td>
<td>anndata, covr, knitr, reticulate, rmarkdown, Seurat,
SingleCellExperiment, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-21 19:26:06 UTC; rcannood</td>
</tr>
<tr>
<td>Author:</td>
<td>Robrecht Cannoodt <a href="https://orcid.org/0000-0003-3641-729X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (rcannood),
  Wouter Saelens <a href="https://orcid.org/0000-0002-7114-6248"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (zouter)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robrecht Cannoodt &lt;rcannood@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-07 17:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='SCORPIUS-package'>SCORPIUS: Trajectory inference from single-cell RNA sequencing data.</h2><span id='topic+SCORPIUS-package'></span><span id='topic+SCORPIUS'></span>

<h3>Description</h3>

<p>SCORPIUS orders single cells with regard to an implicit timeline,
such as cellular development or progression over time.
</p>


<h3>Dimensionality Reduction functions</h3>

<p><code><a href="#topic+reduce_dimensionality">reduce_dimensionality</a></code>
</p>


<h3>Trajectory Inference functions</h3>

<p><code><a href="#topic+infer_trajectory">infer_trajectory</a></code>, <code><a href="#topic+infer_initial_trajectory">infer_initial_trajectory</a></code>, <code><a href="#topic+reverse_trajectory">reverse_trajectory</a></code>, <code><a href="#topic+gene_importances">gene_importances</a></code>, <code><a href="#topic+extract_modules">extract_modules</a></code>
</p>


<h3>Visualisation functions</h3>

<p><code><a href="#topic+draw_trajectory_plot">draw_trajectory_plot</a></code>, <code><a href="#topic+draw_trajectory_heatmap">draw_trajectory_heatmap</a></code>
</p>


<h3>Datasets</h3>

<p><code><a href="#topic+generate_dataset">generate_dataset</a></code>, <code><a href="#topic+ginhoux">ginhoux</a></code>
</p>


<h3>References</h3>

<p>Cannoodt R. et al., SCORPIUS improves trajectory inference and identifies novel modules in dendritic cell development,
bioRxiv (Oct., 2016). <a href="https://doi.org/10.1101/079509">doi:10.1101/079509</a>
(<a href="https://www.biorxiv.org/content/biorxiv/early/2016/10/07/079509.full.pdf">PDF</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load dataset from Schlitzer et al., 2015
data("ginhoux")

## Reduce dimensionality and infer trajectory with SCORPIUS
space &lt;- reduce_dimensionality(ginhoux$expression, "spearman")
traj &lt;- infer_trajectory(space)

## Visualise
draw_trajectory_plot(
  space,
  path = traj$path,
  progression_group = ginhoux$sample_info$group_name
)
</code></pre>

<hr>
<h2 id='draw_trajectory_heatmap'>Draw time-series heatmap</h2><span id='topic+draw_trajectory_heatmap'></span>

<h3>Description</h3>

<p><code>draw_trajectory_heatmap</code> draws a heatmap in which the samples
are ranked according their position in an inferred trajectory. In addition, the progression groups and
feature modules can be passed along to further enhance the visualisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_trajectory_heatmap(
  x,
  time,
  progression_group = NULL,
  modules = NULL,
  show_labels_row = FALSE,
  show_labels_col = FALSE,
  scale_features = TRUE,
  progression_group_palette = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_trajectory_heatmap_+3A_x">x</code></td>
<td>
<p>A numeric matrix or a data frame with one row per sample and one column per feature.</p>
</td></tr>
<tr><td><code id="draw_trajectory_heatmap_+3A_time">time</code></td>
<td>
<p>A numeric vector containing the inferred time points of each sample along a trajectory.</p>
</td></tr>
<tr><td><code id="draw_trajectory_heatmap_+3A_progression_group">progression_group</code></td>
<td>
<p><code>NULL</code> or a vector (or factor) containing the groupings of the samples (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="draw_trajectory_heatmap_+3A_modules">modules</code></td>
<td>
<p><code>NULL</code> or a data frame as returned by <code><a href="#topic+extract_modules">extract_modules</a></code>.</p>
</td></tr>
<tr><td><code id="draw_trajectory_heatmap_+3A_show_labels_row">show_labels_row</code></td>
<td>
<p><code>TRUE</code> if the labels of the rows are to be plotted (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="draw_trajectory_heatmap_+3A_show_labels_col">show_labels_col</code></td>
<td>
<p><code>TRUE</code> if the labels of the cols are to be plotted (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="draw_trajectory_heatmap_+3A_scale_features">scale_features</code></td>
<td>
<p><code>TRUE</code> if the values of each feature is to be scaled (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="draw_trajectory_heatmap_+3A_progression_group_palette">progression_group_palette</code></td>
<td>
<p>A named vector palette for the progression group.</p>
</td></tr>
<tr><td><code id="draw_trajectory_heatmap_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="pheatmap.html#topic+pheatmap">pheatmap</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the <code><a href="pheatmap.html#topic+pheatmap">pheatmap</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a dataset
dataset &lt;- generate_dataset(num_genes=500, num_samples=300, num_groups=4)
expression &lt;- dataset$expression
space &lt;- reduce_dimensionality(expression, ndim=2)
groups &lt;- dataset$sample_info$group_name
traj &lt;- infer_trajectory(space)
time &lt;- traj$time

gimp &lt;- gene_importances(expression, traj$time, num_permutations = 0, ntree = 10000)
gene_sel &lt;- gimp[1:50,]
expr_sel &lt;- expression[,gene_sel$gene]

## Draw a time series heatmap
draw_trajectory_heatmap(expr_sel, time)

## Also show the progression groupings
draw_trajectory_heatmap(expr_sel, time, progression_group=groups)

## Use a different palette
draw_trajectory_heatmap(
  expr_sel, time, progression_group=groups,
  progression_group_palette = setNames(RColorBrewer::brewer.pal(4, "Set2"), paste0("Group ", 1:4))
)

## Group the genes into modules and visualise the modules in a heatmap
modules &lt;- extract_modules(scale_quantile(expr_sel))
draw_trajectory_heatmap(expr_sel, time, progression_group=groups, modules=modules)

</code></pre>

<hr>
<h2 id='draw_trajectory_plot'>Visualise SCORPIUS</h2><span id='topic+draw_trajectory_plot'></span>

<h3>Description</h3>

<p><code>draw_trajectory_plot</code> is used to plot samples after performing dimensionality reduction.
Additional arguments can be provided to colour the samples, plot the trajectory inferred by SCORPIUS,
and draw a contour around the samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_trajectory_plot(
  space,
  progression_group = NULL,
  path = NULL,
  contour = FALSE,
  progression_group_palette = NULL,
  point_size = 2,
  point_alpha = 1,
  path_size = 0.5,
  path_alpha = 1,
  contour_alpha = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_trajectory_plot_+3A_space">space</code></td>
<td>
<p>A numeric matrix or a data frame containing the coordinates of samples.</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_progression_group">progression_group</code></td>
<td>
<p><code>NULL</code> or a vector (or factor) containing the groupings of the samples (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_path">path</code></td>
<td>
<p>A numeric matrix or a data frame containing the coordinates of the inferred path.</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_contour">contour</code></td>
<td>
<p><code>TRUE</code> if contours are to be drawn around the samples.</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_progression_group_palette">progression_group_palette</code></td>
<td>
<p>A named vector palette for the progression group.</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_point_size">point_size</code></td>
<td>
<p>The size of the points.</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_point_alpha">point_alpha</code></td>
<td>
<p>The alpha of the points.</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_path_size">path_size</code></td>
<td>
<p>The size of the path (if any).</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_path_alpha">path_alpha</code></td>
<td>
<p>The alpha of the path (if any).</p>
</td></tr>
<tr><td><code id="draw_trajectory_plot_+3A_contour_alpha">contour_alpha</code></td>
<td>
<p>The alpha of the contour (if any).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a synthetic dataset
dataset &lt;- generate_dataset(num_genes = 500, num_samples = 300, num_groups = 4)
space &lt;- reduce_dimensionality(dataset$expression, ndim = 2)
groups &lt;- dataset$sample_info$group_name

## Simply plot the samples
draw_trajectory_plot(space)

## Colour each sample according to its group
draw_trajectory_plot(space, progression_group = groups)

## Add contours to the plot
draw_trajectory_plot(space, progression_group = groups, contour = TRUE)

## Plot contours without colours
draw_trajectory_plot(space, contour = TRUE)

## Infer a trajectory and plot it
traj &lt;- infer_trajectory(space)
draw_trajectory_plot(space, progression_group = groups, path = traj$path)
draw_trajectory_plot(space, progression_group = groups, path = traj$path, contour = TRUE)

## Visualise gene expression
draw_trajectory_plot(space, progression_group = dataset$expression[,1])
</code></pre>

<hr>
<h2 id='extract_modules'>Extract modules of features</h2><span id='topic+extract_modules'></span>

<h3>Description</h3>

<p><code>extract_modules</code> uses adaptive branch pruning to extract modules of features,
which is typically done on the smoothed expression returned by <code><a href="#topic+gene_importances">gene_importances</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_modules(
  x,
  time = NULL,
  suppress_warnings = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_modules_+3A_x">x</code></td>
<td>
<p>A numeric matrix or a data frame with <em>M</em> rows (one per sample) and <em>P</em> columns (one per feature).</p>
</td></tr>
<tr><td><code id="extract_modules_+3A_time">time</code></td>
<td>
<p>(Optional) Order the modules according to a pseudotime</p>
</td></tr>
<tr><td><code id="extract_modules_+3A_suppress_warnings">suppress_warnings</code></td>
<td>
<p>Whether or not to suppress warnings when P &gt; 1000</p>
</td></tr>
<tr><td><code id="extract_modules_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not Mclust will print output or not</p>
</td></tr>
<tr><td><code id="extract_modules_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="mclust.html#topic+Mclust">Mclust</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing meta-data for the features in <code>x</code>, namely the order in which to visualise the features in and which module they belong to.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gene_importances">gene_importances</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a dataset and visualise
dataset &lt;- generate_dataset(num_genes=300, num_samples=200, num_groups=4)
expression &lt;- dataset$expression
group_name &lt;- dataset$sample_info$group_name
space &lt;- reduce_dimensionality(expression, ndim=2)
traj &lt;- infer_trajectory(space)
time &lt;- traj$time
draw_trajectory_plot(space, path=traj$path, group_name)

## Select most important genes (set ntree to at least 10000!)
gimp &lt;- gene_importances(expression, traj$time, num_permutations = 0, ntree = 1000)
gene_sel &lt;- gimp[1:50,]
expr_sel &lt;- expression[,gene_sel$gene]

## Group the genes into modules and visualise the modules in a heatmap
modules &lt;- extract_modules(scale_quantile(expr_sel))
draw_trajectory_heatmap(expr_sel, time, group_name, modules)
</code></pre>

<hr>
<h2 id='gene_importances'>Calculate the importance of a feature</h2><span id='topic+gene_importances'></span>

<h3>Description</h3>

<p>Calculates the feature importance of each column in <code>x</code> in trying to predict the time ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene_importances(
  x,
  time,
  num_permutations = 0,
  ntree = 10000,
  ntree_perm = ntree/10,
  mtry = ncol(x) * 0.01,
  num_threads = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gene_importances_+3A_x">x</code></td>
<td>
<p>A numeric matrix or a data frame with <em>M</em> rows (one per sample) and <em>P</em> columns (one per feature).</p>
</td></tr>
<tr><td><code id="gene_importances_+3A_time">time</code></td>
<td>
<p>A numeric vector containing the inferred time points of each sample along a trajectory as returned by <code><a href="#topic+infer_trajectory">infer_trajectory</a></code>.</p>
</td></tr>
<tr><td><code id="gene_importances_+3A_num_permutations">num_permutations</code></td>
<td>
<p>The number of permutations to test against for calculating the p-values (default: 0).</p>
</td></tr>
<tr><td><code id="gene_importances_+3A_ntree">ntree</code></td>
<td>
<p>The number of trees to grow (default: 10000).</p>
</td></tr>
<tr><td><code id="gene_importances_+3A_ntree_perm">ntree_perm</code></td>
<td>
<p>The number of trees to grow for each of the permutations (default: ntree / 10).</p>
</td></tr>
<tr><td><code id="gene_importances_+3A_mtry">mtry</code></td>
<td>
<p>The number of variables randomly samples at each split (default: 1% of features).</p>
</td></tr>
<tr><td><code id="gene_importances_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads. Default is 1.</p>
</td></tr>
<tr><td><code id="gene_importances_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to <code><a href="ranger.html#topic+ranger">ranger</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the importance of each feature for the given time line
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- generate_dataset(num_genes=500, num_samples=300, num_groups=4)
expression &lt;- dataset$expression
group_name &lt;- dataset$sample_info$group_name
space &lt;- reduce_dimensionality(expression, ndim=2)
traj &lt;- infer_trajectory(space)
# set ntree to at least 1000!
gene_importances(expression, traj$time, num_permutations = 0, ntree = 1000)
</code></pre>

<hr>
<h2 id='generate_dataset'>Generate a synthetic dataset</h2><span id='topic+generate_dataset'></span>

<h3>Description</h3>

<p><code>generate_dataset</code> generates an synthetic dataset which can be used for visualisation purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_dataset(
  num_samples = 400,
  num_genes = 500,
  num_groups = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_dataset_+3A_num_samples">num_samples</code></td>
<td>
<p>The number of samples the dataset will contain.</p>
</td></tr>
<tr><td><code id="generate_dataset_+3A_num_genes">num_genes</code></td>
<td>
<p>The number of genes the dataset will contain.</p>
</td></tr>
<tr><td><code id="generate_dataset_+3A_num_groups">num_groups</code></td>
<td>
<p>The number of groups the samples will be split up in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the expression data and the meta data of the samples.
</p>


<h3>See Also</h3>

<p><a href="#topic+SCORPIUS">SCORPIUS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a dataset
dataset &lt;- generate_dataset(num_genes = 200, num_samples = 400, num_groups = 4)

## Reduce dimensionality and infer trajectory with SCORPIUS
space &lt;- reduce_dimensionality(dataset$expression, ndim = 2)
traj &lt;- infer_trajectory(space)

## Visualise
draw_trajectory_plot(space, path=traj$path, progression_group=dataset$sample_info$group_name)
</code></pre>

<hr>
<h2 id='ginhoux'>scRNA-seq data of dendritic cell progenitors.</h2><span id='topic+ginhoux'></span>

<h3>Description</h3>

<p>This dataset contains the expression values of the
top 2000 most variable genes for 248 dendritic cell progenitors.
Each cell is in one of three maturation stages: MDP, CDP or PreDC.
The levels of the factor in <code>sample.info</code> are ordered according to the maturation process.
</p>
<p>The number of genes had to be reduced specifically for reducing the package size of SCORPIUS.
Use the following code to download the original data:
</p>
<pre>
download.file("https://github.com/rcannood/SCORPIUS/raw/master/data-raw/ginhoux_orig.rds", destfile = "local.rds")
ginhoux &lt;- readRDS("local.rds")
# do something with ginhoux
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>ginhoux
</code></pre>


<h3>Format</h3>

<p>A list containing two data frames, <code>expression</code> (248x2000) and <code>sample_info</code> (248x1).
</p>


<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60783">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60783</a>
</p>


<h3>References</h3>

<p>Schlitzer A, Sivakamasundari V, Chen J, Sumatoh HR et al.
Identification of cDC1- and cDC2-committed DC progenitors reveals early lineage priming at
the common DC progenitor stage in the bone marrow. Nat Immunol 2015 Jul;16(7):718-28. PMID: 26054720
</p>


<h3>See Also</h3>

<p><a href="#topic+SCORPIUS">SCORPIUS</a>
</p>

<hr>
<h2 id='infer_initial_trajectory'>Infer an initial trajectory through space</h2><span id='topic+infer_initial_trajectory'></span>

<h3>Description</h3>

<p><code>infer_initial_trajectory</code> infers an initial trajectory for
<code><a href="#topic+infer_trajectory">infer_trajectory</a></code> by clustering the points and calculating
the shortest path through cluster centers. The shortest path takes into account
the euclidean distance between cluster centers, and the density between those two
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_initial_trajectory(space, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_initial_trajectory_+3A_space">space</code></td>
<td>
<p>A numeric matrix or a data frame containing the coordinates of samples.</p>
</td></tr>
<tr><td><code id="infer_initial_trajectory_+3A_k">k</code></td>
<td>
<p>The number of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the initial trajectory obtained by this method
</p>

<hr>
<h2 id='infer_trajectory'>Infer linear trajectory through space</h2><span id='topic+infer_trajectory'></span>

<h3>Description</h3>

<p><code>infer_trajectory</code> infers a trajectory through samples in a given space in a four-step process:
</p>

<ol>
<li><p> Perform <em>k</em>-means clustering
</p>
</li>
<li><p> Calculate distance matrix between cluster centers using a custom distance function
</p>
</li>
<li><p> Find the shortest path connecting all cluster centers using the custom distance matrix
</p>
</li>
<li><p> Iteratively fit a curve to the given data using principal curves
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>infer_trajectory(
  space,
  k = 4,
  thresh = 0.001,
  maxit = 10,
  stretch = 0,
  smoother = "smooth_spline",
  approx_points = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_trajectory_+3A_space">space</code></td>
<td>
<p>A numeric matrix or a data frame containing the coordinates of samples.</p>
</td></tr>
<tr><td><code id="infer_trajectory_+3A_k">k</code></td>
<td>
<p>The number of clusters to cluster the data into.</p>
</td></tr>
<tr><td><code id="infer_trajectory_+3A_thresh">thresh</code></td>
<td>
<p>convergence threshold on shortest distances to the curve.</p>
</td></tr>
<tr><td><code id="infer_trajectory_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="infer_trajectory_+3A_stretch">stretch</code></td>
<td>
<p>A stretch factor for the endpoints of the curve,
allowing the curve to grow to avoid bunching at the end.
Must be a numeric value between 0 and 2.</p>
</td></tr>
<tr><td><code id="infer_trajectory_+3A_smoother">smoother</code></td>
<td>
<p>choice of smoother. The default is
<code>"smooth_spline"</code>, and other choices are <code>"lowess"</code> and
<code>"periodic_lowess"</code>. The latter allows one to fit closed curves.
Beware, you may want to use <code>iter = 0</code> with <code>lowess()</code>.</p>
</td></tr>
<tr><td><code id="infer_trajectory_+3A_approx_points">approx_points</code></td>
<td>
<p>Approximate curve after smoothing to reduce computational time.
If <code>FALSE</code>, no approximation of the curve occurs. Otherwise,
<code>approx_points</code> must be equal to the number of points the curve
gets approximated to; preferably about 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing several objects:
</p>

<ul>
<li> <p><code>path</code>: the trajectory obtained by principal curves.
</p>
</li>
<li> <p><code>time</code>: the time point of each sample along the inferred trajectory.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+reduce_dimensionality">reduce_dimensionality</a></code>, <code><a href="#topic+draw_trajectory_plot">draw_trajectory_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an example dataset and visualise it
dataset &lt;- generate_dataset(num_genes = 200, num_samples = 400, num_groups = 4)
space &lt;- reduce_dimensionality(dataset$expression, ndim = 2)
draw_trajectory_plot(space, progression_group = dataset$sample_info$group_name)

## Infer a trajectory through this space
traj &lt;- infer_trajectory(space)

## Visualise the trajectory
draw_trajectory_plot(space, path=traj$path, progression_group = dataset$sample_info$group_name)
</code></pre>

<hr>
<h2 id='reduce_dimensionality'>Dimensionality reduction</h2><span id='topic+reduce_dimensionality'></span>

<h3>Description</h3>

<p><code>reduce_dimensionality</code> performs an eigenanalysis of the given dissimilarity matrix
and returns coordinates of the samples represented in an <code>ndim</code>-dimensional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_dimensionality(
  x,
  dist = c("spearman", "pearson", "euclidean", "cosine", "manhattan"),
  ndim = 3,
  num_landmarks = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_dimensionality_+3A_x">x</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
<tr><td><code id="reduce_dimensionality_+3A_dist">dist</code></td>
<td>
<p>the distance metric to be used; can be any of the metrics listed in <code><a href="dynutils.html#topic+calculate_distance">dynutils::calculate_distance()</a></code>.</p>
</td></tr>
<tr><td><code id="reduce_dimensionality_+3A_ndim">ndim</code></td>
<td>
<p>the maximum dimension of the space which the data are to be represented in; must be in 1, 2, ..., n-1.</p>
</td></tr>
<tr><td><code id="reduce_dimensionality_+3A_num_landmarks">num_landmarks</code></td>
<td>
<p>the number of landmarks to be selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the coordinates of each sample, represented in an <code>ndim</code>-dimensional space.
</p>


<h3>See Also</h3>

<p><a href="#topic+SCORPIUS">SCORPIUS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an example dataset
dataset &lt;- generate_dataset(num_genes = 200, num_samples = 400, num_groups = 4)

## Reduce the dimensionality of this dataset
space &lt;- reduce_dimensionality(dataset$expression, ndim = 2)

## Visualise the dataset
draw_trajectory_plot(space, progression_group = dataset$sample_info$group_name)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+scale_quantile'></span><span id='topic+scale_minmax'></span><span id='topic+scale_uniform'></span><span id='topic+apply_quantile_scale'></span><span id='topic+apply_minmax_scale'></span><span id='topic+apply_uniform_scale'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dynutils</dt><dd><p><code><a href="dynutils.html#topic+apply_minmax_scale">apply_minmax_scale</a></code>, <code><a href="dynutils.html#topic+apply_quantile_scale">apply_quantile_scale</a></code>, <code><a href="dynutils.html#topic+apply_uniform_scale">apply_uniform_scale</a></code>, <code><a href="dynutils.html#topic+scale_minmax">scale_minmax</a></code>, <code><a href="dynutils.html#topic+scale_quantile">scale_quantile</a></code>, <code><a href="dynutils.html#topic+scale_uniform">scale_uniform</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reverse_trajectory'>Reverse a trajectory</h2><span id='topic+reverse_trajectory'></span>

<h3>Description</h3>

<p>Since the direction of the trajectory is not specified, the ordering of a trajectory may be inverted using <code>reverse_trajectory</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_trajectory(trajectory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_trajectory_+3A_trajectory">trajectory</code></td>
<td>
<p>A trajectory as returned by <code><a href="#topic+infer_trajectory">infer_trajectory</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same trajectory, but in the other direction.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infer_trajectory">infer_trajectory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate an example dataset and infer a trajectory through it
dataset &lt;- generate_dataset(num_genes = 200, num_samples = 400, num_groups = 4)
group_name &lt;- dataset$sample_info$group_name
space &lt;- reduce_dimensionality(dataset$expression, ndim = 2)
traj &lt;- infer_trajectory(space)

## Visualise the trajectory
draw_trajectory_plot(space, group_name, path = traj$path)

## Reverse the trajectory
reverse_traj &lt;- reverse_trajectory(traj)
draw_trajectory_plot(space, group_name, path = reverse_traj$path)

plot(traj$time, reverse_traj$time, type = "l")
</code></pre>

<hr>
<h2 id='ti_scorpius'>Infer a trajectory using SCORPIUS</h2><span id='topic+ti_scorpius'></span>

<h3>Description</h3>

<p>Pass this object to <code><a href="dynwrap.html#topic+infer_trajectories">dynwrap::infer_trajectory()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ti_scorpius(
  distance_method = "spearman",
  ndim = 3L,
  k = 4L,
  thresh = 0.001,
  maxit = 10L,
  stretch = 0,
  smoother = "smooth_spline"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ti_scorpius_+3A_distance_method">distance_method</code></td>
<td>
<p>A character string indicating which correlationcoefficient (or covariance) is to be computed. One of &quot;pearson&quot;, &quot;spearman&quot; (default), or &quot;cosine&quot;. Domain: spearman, pearson, cosine. Default: spearman. Format: character.</p>
</td></tr>
<tr><td><code id="ti_scorpius_+3A_ndim">ndim</code></td>
<td>
<p>The number of dimensions in the new space. Domain: U(2, 20). Default: 3. Format: integer.</p>
</td></tr>
<tr><td><code id="ti_scorpius_+3A_k">k</code></td>
<td>
<p>The number of clusters to cluster the data into to construct the initial trajectory. Domain: U(1, 20). Default: 4. Format: integer.</p>
</td></tr>
<tr><td><code id="ti_scorpius_+3A_thresh">thresh</code></td>
<td>
<p><code>principal_curve</code> parameter; convergence threshhold on shortest distances to the curve. Domain: e^U(-11.51, 11.51). Default: 0.001. Format: numeric.</p>
</td></tr>
<tr><td><code id="ti_scorpius_+3A_maxit">maxit</code></td>
<td>
<p><code>principal_curve</code> parameter; maximum number of iterations. Domain: U(0, 50). Default: 10. Format: integer.</p>
</td></tr>
<tr><td><code id="ti_scorpius_+3A_stretch">stretch</code></td>
<td>
<p><code>principal_curve</code> parameter; a factor by which the curve can be extrapolated when points are projected. Domain: U(0, 5). Default: 0. Format: numeric.</p>
</td></tr>
<tr><td><code id="ti_scorpius_+3A_smoother">smoother</code></td>
<td>
<p><code>principal_curve</code> parameter; choice of smoother. Domain: smooth_spline, lowess, periodic_lowess. Default: smooth_spline. Format: character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dynwrap TI method.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
