<!DOCTYPE html><html><head><title>Help for package Necklaces</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Necklaces}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Necklaces-package'>
<p>Necklaces and Bracelets</p></a></li>
<li><a href='#Bracelets'><p>Bracelets</p></a></li>
<li><a href='#cBracelets'><p>Elements in a bracelet</p></a></li>
<li><a href='#cNecklaces'><p>Elements in a necklace</p></a></li>
<li><a href='#fBracelets'><p>Bracelets of a fixed configuration</p></a></li>
<li><a href='#fNecklaces'><p>Necklaces of a fixed configuration</p></a></li>
<li><a href='#lSort'><p>Sort a list of vectors</p></a></li>
<li><a href='#LyndonW'><p>Lyndon words</p></a></li>
<li><a href='#Necklaces'><p>Necklaces</p></a></li>
<li><a href='#sBruijn'><p>The de Bruijn sequence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Necklaces and Bracelets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Elvira Di Nardo [aut, cph],
  Giuseppe Guarino [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giuseppe Guarino &lt;giuseppe.guarino@rete.basilicata.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to generate Necklaces, Bracelets, Lyndon words and de Bruijn sequences. The generation relies on integer partitions and uses the 'KStatistics' package. Methods used in the package refers to E. Di Nardo and G. Guarino (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2208.06855">doi:10.48550/arXiv.2208.06855</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>kStatistics</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-18 09:35:52 UTC; giuseppe.guarino</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 12:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='Necklaces-package'>
Necklaces and Bracelets
</h2><span id='topic+Necklaces-package'></span><span id='topic+Necklaces-package'></span>

<h3>Description</h3>

<p>Tools to generate Necklaces, Bracelets, Lyndon words and de Bruijn sequences. The generation relies on integer partitions and uses the 'KStatistics' package. Methods used in the package refers to E. Di Nardo and G. Guarino (2022) &lt;arXiv:2208.06855&gt;. 
</p>


<h3>Details</h3>

<p>Using multi-index compositions, necklaces and bracelets are generated 
as well as Lyndon words and de Bruijn sequences. For multi-index compositions, this package refers to the <code>kStatistics</code> package. 
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>
<p>Elvira Di Nardo [aut, cph],
        Giuseppe Guarino [aut, cre, cph]
</p>
<p>Maintainer: Giuseppe Guarino &lt;giuseppe.guarino@rete.basilicata.it&gt;
</p>


<h3>References</h3>

<p>Di Nardo, E. (2014) On a symbolic representation of non-central Wishart random matrices with applications. Jour. Mult. Anal. Vol.125, 121&ndash;135. (<a href="https://arxiv.org/abs/1312.4395">https://arxiv.org/abs/1312.4395</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022) kStatistics: Unbiased Estimates of Joint Cumulant Products from the Multivariate Faa Di Bruno's Formula. The R journal - In press. (<a href="https://arxiv.org/abs/2206.15348">https://arxiv.org/abs/2206.15348</a>)  
</p>
<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sort the following list [2,2,3],[3,2,3],[1,2,3] 
#
lSort(list(c(2,2,3),c(3,2,3),c(1,2,3)))

# Generate the elements of the necklace in equivalence relation with 
# the input vector c(1,0,2,1) 
cNecklaces(c(1,0,2,1)) 

# The previous result in a compact form
cNecklaces(c(1,0,2,1),TRUE)

# Generate the elements of the bracelet in equivalence relation with 
# the input vector (1,0,2,1) 
cBracelets(c(1,0,2,1)) 

# The previous result in a compact form
cBracelets(c(1,0,2,1),TRUE)  

# Generate all the necklaces of the configuration (2,1,1) 
# corresponding to the vector (1,1,2,3)
fNecklaces(c(2,1,1))  

# The previous result in a compact form
fNecklaces(c(2,1,1),TRUE)

# The first value of the alphabet is set equal to zero 
fNecklaces(c(2,1,1),TRUE,0)

# Generate all the bracelets of the configuration (2,1,1) 
# corresponding to the vector (1,1,2,3)
fBracelets(c(2,1,1))  

# The previous result in a compact form
fBracelets(c(2,1,1),TRUE)

# The first value of the alphabet is set equal to zero
fBracelets(c(2,1,1),TRUE,0)

# Generate the list of all the representatives of all the necklaces 
# of length 4 over the alphabet {1,2}. 
Necklaces(4,2)  

# Generate the list of  all the representatives of all the necklaces 
# of length 5 over the alphabet {1,2,3}. 
Necklaces(5,3)  

# Generate the list of  all the representatives of all the necklaces 
# of length 5 over the alphabet {0,1,2}. 
Necklaces(5,3,0) 

# Generate the list of all the representatives of all the bracelets 
# of length 4 over the alphabet {1,2}. 
Bracelets(4,2)  

# Generate the list of  all the representatives of all the bracelets 
# of length 5 over the alphabet {1,2,3}. 
Bracelets(5,3)  

# Generate the list of  all the representatives of all the bracelets 
# of length 5 over the alphabet {0,1,2}. 
Bracelets(5,3,0)  

# Generate all the Lyndon words of length 5 over the alphabet 
# {1,2} 
LyndonW(5) 
# or equivalently 
LyndonW(5,2) 

# The previous result in a compact form 
LyndonW(5,2,TRUE)

# Generate all the Lyndon words of length 5 over the alphabet 
# {0,1}
LyndonW(5,2,TRUE,0)

# Generate the de Bruijn sequence of length 4 on the binary alphabet
# {0,1}
sBruijn(4) 
# or equivalently 
sBruijn(4,2) 

# Generate the de Bruijn sequence of length 2 over the alphabet {0,1,2} 
sBruijn(2,3)

# Generate the de Bruijn sequence of length 2 over the alphabet {1,2,3}
sBruijn(2,3,1)

# Generate the de Bruijn sequence of length 2 over the alphabet {1,2,3} 
# with a block separator. 
sBruijn(2,3,1,TRUE)

</code></pre>

<hr>
<h2 id='Bracelets'>Bracelets</h2><span id='topic+Bracelets'></span>

<h3>Description</h3>

<p>The function generates all the representatives of all the bracelets of length <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bracelets(n=1, m=1, fn=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bracelets_+3A_n">n</code></td>
<td>
<p>positive integer: the length of the representatives</p>
</td></tr>
<tr><td><code id="Bracelets_+3A_m">m</code></td>
<td>
<p>positive integer: the number of consecutive non-negative integers in the alphabet</p>
</td></tr>
<tr><td><code id="Bracelets_+3A_fn">fn</code></td>
<td>
<p>integer: the first value of the alphabet, the default is 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the list of all representatives of all bracelets having a fixed length <code>n</code> on the same alphabet, by default <code>{1,2,...,m}</code>.
The main block function is the <code><a href="#topic+fBracelets">fBracelets</a></code> function of the  <code>Necklaces</code> package, which is called repeatedly. The input parameters of the <code><a href="#topic+fBracelets">fBracelets</a></code> function are generated by using the <code>mKT</code> function of the <code>kStatistics</code> package. Indeed, given a multi-index <code>v</code>, that is a vector of non-negative integers, and a positive integer <code>n</code>, the <code>mKT</code> function  returns all the lists <code>(v1,...,vn)</code> of non-negative integer vectors, having the same length of the multi-index <code>v</code> and such that <code>v=v1+...+vn</code>. Here, the <code>mKT</code> function is used with the input vector 
having length <code>1</code> as well as the output vectors <code>v1,...,vn</code>, corresponding to the partitions of an integer with a fixed number of parts. As example,  the <code>mKT</code> function with input <code>(3,3)</code> generates the following result:
</p>

<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 1 )( 1 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 )( 1 )( 2 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 0 )( 2 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 2 )( 0 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 )( 2 )( 1 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 2 )( 0 )( 1 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 2 )( 1 )( 0 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 )( 3 )( 0 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 3 )( 0 )( 0 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 )( 0 )( 3 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Each vector is a possible configuration and 
then passed to the <code><a href="#topic+fBracelets">fBracelets</a></code> function to recover the corresponding bracelet. For example <br />
</p>

<ul>
<li><p> the configuration <code>[( 1 )( 1 )( 1 )]</code> denotes the vector 
<code>(1,2,3)</code>; calling <code>fBracelets(c(1,1,1))</code>, the representative
<code>[1 2 3]</code> is generated; <br />
</p>
</li>
<li><p> the configuration <code>[( 0 )( 1 )( 2 )]</code> denotes the vector   <code>(2,3,3)</code>; calling <code>fBracelets(c(0,1,2))</code>, the representative <code>[2 3 3]</code> is generated; <br /> 
</p>
</li>
<li><p> the configuration  <code>[( 1 )( 0 )( 2 )]</code> denotes the vector   <code>(1,3,3)</code>; calling <code>fBracelets(c(1,0,2))</code>, the representative <code>[1 3 3]</code> is generated;
</p>
</li></ul>

<p>and so on. As last step, the union of all the outputs gives the expected result:<br />
</p>

<table>
<tr>
 <td style="text-align: center;">
<code>[ 1 1 1 ], [ 1 1 2 ], [ 1 1 3 ], [ 1 2 2 ], [ 1 2 3 ],
      [ 1 3 3 ], [ 2 2 2 ], [ 2 2 3 ], [ 2 3 3 ], [ 3 3 3 ]</code></td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>that are  all the representatives of bracelets of length <code>3</code> on the alphabet <code>{1,2,3}</code>. 
</p>
<p>Note: Comparing this example with the one given in the description of the <code><a href="#topic+fNecklaces">fNecklaces</a></code> function, <code>[1 3 2]</code> is missed since it is in the class of the bracelet 
<code>[1 2 3] = {(1 2 3),(1 3 2),(2 1 3),(2 3 1),(3 1 2),(3 2 1)}</code> obtained running <code>cBracelets(c(1,2,3))</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list containing all the representatives of all the bracelets of length <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers.</p>
</td></tr></table>


<h3>Note</h3>

<p>The function calls the <code><a href="#topic+fBracelets">fBracelets</a></code> function in the <code>Necklaces</code> package and the <code>mKT</code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo, E., and Guarino., G.  (2022) kStatistics: Unbiased Estimates of Joint Cumulant Products from the Multivariate Faa Di Bruno's Formula. The R journal - In press.  (<a href="https://arxiv.org/abs/2206.15348">https://arxiv.org/abs/2206.15348</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fBracelets">fBracelets</a></code>,
<code><a href="#topic+LyndonW">LyndonW</a></code>,
<code><a href="#topic+sBruijn">sBruijn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the list of all the representatives of all the bracelets 
# of length 4 over the alphabet {1,2}. 
Bracelets(4,2)  

# Generate the list of  all the representatives of all the bracelets 
# of length 5 over the alphabet {1,2,3}. 
Bracelets(5,3)  

# Generate the list of  all the representatives of all the bracelets 
# of length 5 over the alphabet {0,1,2}. 
Bracelets(5,3,0) 

</code></pre>

<hr>
<h2 id='cBracelets'>Elements in a bracelet</h2><span id='topic+cBracelets'></span>

<h3>Description</h3>

<p>The function generates the elements of a bracelet in equivalence relation with the vector given in input.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cBracelets(v=c(), bOut=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cBracelets_+3A_v">v</code></td>
<td>
<p>vector: input vector</p>
</td></tr>
<tr><td><code id="cBracelets_+3A_bout">bOut</code></td>
<td>
<p>boolean: if <code>TRUE</code>, the function produces a compact result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the elements of a bracelet which are in equivalence relation with the vector given in input. The first parameter is the input vector. If the second parameter (<code>bOut</code>) is set equal to <code>TRUE</code>,
the function produces a compact result.
</p>
<p>Example: <code>cBracelets(c(1,0,2,1))</code> produces the following result:
</p>

<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 0 1 1 2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 0 2 1 1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 1 0 2 1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 1 1 0 2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 1 1 2 0</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 1 2 0 1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 2 0 1 1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 2 1 1 0</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>cBracelets(c(1,0,2,1),TRUE)</code> produces the following result:
</p>

<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 0 1 1 2 ]  ( 1 )</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 0 2 1 1 ]  ( 2 )</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 1 0 2 1 ]  ( 3 )</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 1 1 0 2 ]  ( 4 )</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 1 1 2 0 ]  ( 5 )</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 1 2 0 1 ]  ( 6 )</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 2 0 1 1 ]  ( 7 )</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 2 1 1 0 ]  ( 8 )</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that <code>0 1 1 2</code> is the representative of the class, that is the minimum in lexicographical order. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list containing all the elements of the bracelet in equivalence  relation with the vector given in input</p>
</td></tr></table>


<h3>Note</h3>

<p>The function is called from the <code><a href="#topic+fBracelets">fBracelets</a></code> function in the <code>Necklaces</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo, E., and Guarino., G.  (2022) kStatistics: Unbiased Estimates of Joint Cumulant Products from the Multivariate Faa Di Bruno's Formula. The R journal - In press.  (<a href="https://arxiv.org/abs/2206.15348">https://arxiv.org/abs/2206.15348</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fBracelets">fBracelets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the elements of the bracelet in equivalence relation with 
# the input vector (1,0,2,1) 
cBracelets(c(1,0,2,1)) 

# The previous result in a compact form
cBracelets(c(1,0,2,1),TRUE) 

</code></pre>

<hr>
<h2 id='cNecklaces'>Elements in a necklace</h2><span id='topic+cNecklaces'></span>

<h3>Description</h3>

<p>The function generates the elements of a necklace in equivalence relation with the vector given in input.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cNecklaces(v=c(), bOut=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cNecklaces_+3A_v">v</code></td>
<td>
<p>vector: input vector</p>
</td></tr>
<tr><td><code id="cNecklaces_+3A_bout">bOut</code></td>
<td>
<p>boolean: if <code>TRUE</code>, the function produces a compact result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the elements of a necklace which are in equivalence relation with the vector given in input. The first parameter is the input vector. If the second parameter (<code>bOut</code>) is set equal to <code>TRUE</code>, the function produces a compact result.
</p>
<p>Example: <code>cNecklaces(c(1,0,2,1))</code> produces the following result:
</p>

<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 0 2 1 1</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 1 0 2 1</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 1 1 0 2</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[1] 2 1 1 0</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>cNecklaces(c(1,0,2,1),TRUE)</code> produces the following result:
</p>

<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 0 2 1 1 ]  ( 1 )</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 1 0 2 1 ]  ( 2 )</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 1 1 0 2 ]  ( 3 )</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[ 2 1 1 0 ]  ( 4 )</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that <code>0 2 1 1</code> is the representative of the class, that is the minimum in lexicographical order. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list containing all the elements of the necklace in equivalence  relation with the vector given in input</p>
</td></tr></table>


<h3>Note</h3>

<p>The function is called from the <code><a href="#topic+fNecklaces">fNecklaces</a>, <a href="#topic+sBruijn">sBruijn</a>, <a href="#topic+cBracelets">cBracelets</a></code> functions in the <code>Necklaces</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo, E., and Guarino., G.  (2022) kStatistics: Unbiased Estimates of Joint Cumulant Products from the Multivariate Faa Di Bruno's Formula. The R journal - In press.  (<a href="https://arxiv.org/abs/2206.15348">https://arxiv.org/abs/2206.15348</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fNecklaces">fNecklaces</a></code>,
<code><a href="#topic+sBruijn">sBruijn</a></code>,
<code><a href="#topic+cBracelets">cBracelets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the elements of the necklace in equivalence relation with 
# the input vector c(1,0,2,1) 
cNecklaces(c(1,0,2,1)) 

# The previous result in a compact form
cNecklaces(c(1,0,2,1),TRUE) 

</code></pre>

<hr>
<h2 id='fBracelets'>Bracelets of a fixed configuration
</h2><span id='topic+fBracelets'></span>

<h3>Description</h3>

<p>The function generates all the representatives of the bracelets corresponding to a fixed configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fBracelets(pv=c(), bOut=FALSE, fn=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fBracelets_+3A_pv">pv</code></td>
<td>
<p>vector: the fixed configuration</p>
</td></tr>
<tr><td><code id="fBracelets_+3A_bout">bOut</code></td>
<td>
<p>boolean: if <code>TRUE</code>, the function produces a compact result</p>
</td></tr>
<tr><td><code id="fBracelets_+3A_fn">fn</code></td>
<td>
<p>integer: the first value of the alphabet, the default is 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates all the representatives of the bracelets corresponding 
to a fixed configuration. If the second parameter (<code>bOut</code>) is set equal to <code>TRUE</code>, the function produces a compact result. The third parameter 
(<code>fn</code>) initializes the first value of the alphabet, which by default is equal to 1. For example, to generate all the representatives of the bracelets 
corresponding to the fixed configuration <code>(2,1,1)</code>, run <code>fBracelets(c(2,1,1))</code>. In such a case the alphabet is <code>{1,2,3}</code>. Using the <code><a href="kStatistics.html#topic+nPerm">nPerm</a></code> function of the <code>kStatistics</code> package, the function first generates all the permutations of the vector <code>(1,1,2,3)</code> corresponding to the configuration <code>(2,1,1)</code>, that is 
</p>

<table>
<tr>
 <td style="text-align: left;"><code>(I)</code> </td><td style="text-align: left;"> <code>(3,2,1,1), (2,3,1,1), (3,1,1,2), ..., (1,1,2,3)</code> (12 in total)</td>
</tr>

</table>

<p>Then the <code><a href="#topic+cBracelets">cBracelets</a></code> function of the <code>Necklaces</code> package is called with input equal to each vector in <code>(I)</code>. For each obtained list, only the representative survives. At the end all the representatives of the  bracelets are printed, that are <code>[1 1 2 3], [1 2 1 3]</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list containing all the representatives of the bracelets corresponding to a fixed configuration.</p>
</td></tr></table>


<h3>Note</h3>

<p>The function calls the <code><a href="#topic+cBracelets">cBracelets</a></code> function in the <code>Necklaces</code> package and the <code><a href="kStatistics.html#topic+nPerm">nPerm</a></code> function in the <code>kStatistics</code> package.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo, E. (2014) On a symbolic representation of non-central Wishart random matrices with applications. Jour. Mult. Anal. Vol.125, 121&ndash;135. (<a href="https://arxiv.org/abs/1312.4395">https://arxiv.org/abs/1312.4395</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022) kStatistics: Unbiased Estimates of Joint Cumulant Products from the Multivariate Faa Di Bruno's Formula. The R journal - In press.  (<a href="https://arxiv.org/abs/2206.15348">https://arxiv.org/abs/2206.15348</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cBracelets">cBracelets</a></code>,
<code><a href="#topic+LyndonW">LyndonW</a></code>,
<code><a href="#topic+sBruijn">sBruijn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate all the bracelets of the configuration (2,1,1) 
# corresponding to the vector (1,1,2,3)
fBracelets(c(2,1,1))  

# The previous result in a compact form
fBracelets(c(2,1,1),TRUE)

# The first value of the alphabet is set equal to zero
fBracelets(c(2,1,1),TRUE,0)


</code></pre>

<hr>
<h2 id='fNecklaces'>Necklaces of a fixed configuration</h2><span id='topic+fNecklaces'></span>

<h3>Description</h3>

<p>The function generates all the representatives of the necklaces corresponding to a fixed configuration.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fNecklaces(pv=c(), bOut=FALSE, fn=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fNecklaces_+3A_pv">pv</code></td>
<td>
<p>vector: the fixed configuration</p>
</td></tr>
<tr><td><code id="fNecklaces_+3A_bout">bOut</code></td>
<td>
<p>boolean: if <code>TRUE</code>, the function produces a compact result</p>
</td></tr>
<tr><td><code id="fNecklaces_+3A_fn">fn</code></td>
<td>
<p>integer: the first value of the alphabet, the default is 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates all the representatives of the necklaces corresponding 
to a fixed configuration. If the second parameter (<code>bOut</code>) is set equal to <code>TRUE</code>, the function produces a compact result. The third parameter 
(<code>fn</code>) initializes the first value of the alphabet, which by default is equal to 1. For example, to generate all the representatives of necklaces 
corresponding to the fixed configuration <code>(2,1,1)</code>, run <code>fNecklaces(c(2,1,1))</code>. In such a case the alphabet is <code>{1,2,3}</code>. Using the <code><a href="kStatistics.html#topic+nPerm">nPerm</a></code> function of the <code>kStatistics</code> package, the function first generates all the permutations of the vector <code>(1,1,2,3)</code> corresponding to the configuration <code>(2,1,1)</code>: 
</p>

<table>
<tr>
 <td style="text-align: left;"><code>(I)</code> </td><td style="text-align: left;"> <code>(3,2,1,1), (2,3,1,1), (3,1,1,2), ..., (1,1,2,3)</code> (12 in total)</td>
</tr>

</table>

<p>Then the <code><a href="#topic+cNecklaces">cNecklaces</a></code> function of the <code>Necklaces</code> package is called with input equal to each vector in <code>(I)</code>. For each obtained list, only the representative survives. At the end all the representatives of the  necklaces are printed, that are <code>[1 1 2 3], [1 1 3 2], [1 2 1 3].</code>
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list containing all the representatives of the necklaces corresponding to a fixed configuration.</p>
</td></tr></table>


<h3>Note</h3>

<p>The function calls the <code><a href="#topic+cNecklaces">cNecklaces</a></code> function in the <code>Necklaces</code> package and the <code><a href="kStatistics.html#topic+nPerm">nPerm</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo, E. (2014) On a symbolic representation of non-central Wishart random matrices with applications. Jour. Mult. Anal. Vol.125, 121&ndash;135. (<a href="https://arxiv.org/abs/1312.4395">https://arxiv.org/abs/1312.4395</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022) kStatistics: Unbiased Estimates of Joint Cumulant Products from the Multivariate Faa Di Bruno's Formula. The R journal - In press.  (<a href="https://arxiv.org/abs/2206.15348">https://arxiv.org/abs/2206.15348</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cBracelets">cBracelets</a></code>,
<code><a href="#topic+LyndonW">LyndonW</a></code>,
<code><a href="#topic+sBruijn">sBruijn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate all the necklaces of the configuration (2,1,1) 
# corresponding to the vector (1,1,2,3)
fNecklaces(c(2,1,1))  

# The previous result in a compact form
fNecklaces(c(2,1,1),TRUE)

# The first value of the alphabet is set equal to zero 
fNecklaces(c(2,1,1),TRUE,0)


</code></pre>

<hr>
<h2 id='lSort'>Sort a list of vectors
</h2><span id='topic+lSort'></span>

<h3>Description</h3>

<p>The function takes in input a list of vectors and returns the same list ordered in a lexicographical way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lSort(pL = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lSort_+3A_pl">pL</code></td>
<td>
<p>list of vectors to be ordered</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes as input a list of vectors and returns the same list ordered in a lexicographical way.
For example if the input list is <code>(2,2,3),(3,2,3),(1,2,3)</code>, then the output of the function <code><a href="#topic+lSort">lSort</a></code> produces the following result:
<code>(1,2,3),(2,2,3),(3,2,3).</code> 
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the input list ordered in lexicographical way</p>
</td></tr></table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+cNecklaces">cNecklaces</a></code>, <code><a href="#topic+cBracelets">cBracelets</a></code>, <code><a href="#topic+fNecklaces">fNecklaces</a></code>, <code><a href="#topic+Necklaces">Necklaces</a></code>, <code><a href="#topic+Bracelets">Bracelets</a></code>,  <code><a href="#topic+LyndonW">LyndonW</a></code>, <code><a href="#topic+sBruijn">sBruijn</a></code> functions in the <code>Necklaces</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cNecklaces">cNecklaces</a></code>,
<code><a href="#topic+cBracelets">cBracelets</a></code>,
<code><a href="#topic+fNecklaces">fNecklaces</a></code>,
<code><a href="#topic+Necklaces">Necklaces</a></code>,
<code><a href="#topic+Bracelets">Bracelets</a></code>,
<code><a href="#topic+LyndonW">LyndonW</a></code>,
<code><a href="#topic+sBruijn">sBruijn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sort the following list (2,2,3),(3,2,3),(1,2,3) 
#
lSort(list(c(2,2,3),c(3,2,3),c(1,2,3)))
</code></pre>

<hr>
<h2 id='LyndonW'>Lyndon words</h2><span id='topic+LyndonW'></span>

<h3>Description</h3>

<p>The function generates Lyndon words from necklaces of length <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LyndonW(n=1, m=2, bOut=FALSE, fn=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LyndonW_+3A_n">n</code></td>
<td>
<p>positive integer: the length of the representatives</p>
</td></tr>
<tr><td><code id="LyndonW_+3A_m">m</code></td>
<td>
<p>positive integer: the number of consecutive non-negative integers in the alphabet</p>
</td></tr>
<tr><td><code id="LyndonW_+3A_bout">bOut</code></td>
<td>
<p>boolean: if <code>TRUE</code>, the function produces a compact result</p>
</td></tr>
<tr><td><code id="LyndonW_+3A_fn">fn</code></td>
<td>
<p>integer: the first value of the alphabet, the default is 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates Lyndon words from necklaces of length <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers. The last parameter 
(<code>fn</code>) initializes the first value of the alphabet, which by default is equal to 1. If the parameter (<code>bOut</code>) is set equal to <code>TRUE</code>, the function produces a compact result. As example, running <code>LyndonW(5,2, TRUE,0)</code>, the function  generates Lyndon words in compact form, from the binary necklaces of length <code>5</code>, that are <code>[0 0 0 0 1], [0 0 0 1 1], [0 0 1 0 1], 
[0 0 1 1 1], [0 1 0 1 1], [0 1 1 1 1]</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list containing all the Lyndon words  of length <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers.</p>
</td></tr></table>


<h3>Note</h3>

<p>The function calls the <code><a href="#topic+cNecklaces">cNecklaces</a> and <a href="#topic+lSort">lSort</a></code> functions in the <code>Necklaces</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo, E. (2014) On a symbolic representation of non-central Wishart random matrices with applications. Jour. Mult. Anal. Vol.125, 121&ndash;135. (<a href="https://arxiv.org/abs/1312.4395">https://arxiv.org/abs/1312.4395</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cNecklaces">cNecklaces</a></code>,
<code><a href="#topic+sBruijn">sBruijn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate all the Lyndon words of length 5 over the alphabet 
# {1,2} 
LyndonW(5) 
# or equivalently 
LyndonW(5,2) 

# The previous result in a compact form 
LyndonW(5,2,TRUE)

# Generate all the Lyndon words of length 5 over the alphabet 
# {0,1}
LyndonW(5,2,TRUE,0)

</code></pre>

<hr>
<h2 id='Necklaces'>Necklaces</h2><span id='topic+Necklaces'></span>

<h3>Description</h3>

<p>The function generates all the representatives of all the necklaces of length <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Necklaces(n=1, m=1, fn=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Necklaces_+3A_n">n</code></td>
<td>
<p>positive integer: the length of the representatives</p>
</td></tr>
<tr><td><code id="Necklaces_+3A_m">m</code></td>
<td>
<p>positive integer: the number of consecutive non-negative integers in the alphabet</p>
</td></tr>
<tr><td><code id="Necklaces_+3A_fn">fn</code></td>
<td>
<p>integer: the first value of the alphabet, the default is 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the list of all representatives of all necklaces having a fixed length <code>n</code> on the same alphabet, by default <code>{1,2,...,m}</code>.
The main block function is the <code><a href="#topic+fNecklaces">fNecklaces</a></code> function of the  <code>Necklaces</code> package, which is called repeatedly. The input parameters of the <code><a href="#topic+fNecklaces">fNecklaces</a></code> function are generated by using the <code>mKT</code> function of the <code>kStatistics</code> package. Indeed, given a multi-index <code>v</code>, that is a vector of non-negative integers, and a positive integer <code>n</code>, the <code>mKT</code> function  returns all the lists <code>(v1,...,vn)</code> of non-negative integer vectors, having the same length of the multi-index <code>v</code> and such that <code>v=v1+...+vn</code>. Here, the <code>mKT</code> function is used with the input vector 
having length <code>1</code> as well as the output vectors <code>v1,...,vn</code>, corresponding to the partitions of an integer with a fixed number of parts. As example,  the <code>mKT</code> function with input <code>(3,3)</code> generates the following result:
</p>

<table>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 1 )( 1 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 )( 1 )( 2 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 0 )( 2 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 2 )( 0 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 )( 2 )( 1 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 2 )( 0 )( 1 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 2 )( 1 )( 0 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 )( 3 )( 0 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 3 )( 0 )( 0 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 )( 0 )( 3 )]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Each vector is a possible configuration and 
then passed  to the <code><a href="#topic+fNecklaces">fNecklaces</a></code> function to recover the corresponding necklace. For example <br />
</p>

<ul>
<li><p> the configuration <code>[( 1 )( 1 )( 1 )]</code> denotes the vector 
<code>[1,2,3]</code>; calling <code>fNecklaces(c(1,1,1))</code>, the representatives 
<code>[1,2,3]</code> and <code>[1,3,2]</code> are generated; <br />
</p>
</li>
<li><p> the configuration <code>[( 0 )( 1 )( 2 )]</code> denotes the vector   <code>[2,3,3]</code>; calling <code>fNecklaces(c(0,1,2))</code>, the reprsentative <code>[2,3,3]</code> is generated <br /> 
</p>
</li>
<li><p> the configuration  <code>[( 1 )( 0 )( 2 )]</code> denotes the vector   <code>[1,3,3]</code>; calling <code>fNecklaces(c(1,0,2))</code>, the representative <code>[1,3,3]</code> is generated;
</p>
</li></ul>

<p>and so on. As last step, the union of all the outputs gives the expected result:<br />
</p>

<table>
<tr>
 <td style="text-align: center;">
<code>[ 1 1 1 ], [ 1 1 2 ], [ 1 1 3 ], [ 1 2 2 ], [ 1 2 3 ], [ 1 3 2 ], 
      [ 1 3 3 ], [ 2 2 2 ], [ 2 2 3 ], [ 2 3 3 ], [ 3 3 3 ]</code></td>
</tr>

</table>

<p>that are  all the representatives of necklaces of length <code>3</code> on the alphabet <code>{1,2,3}</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list containing all the representatives of all the necklaces of length <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers.</p>
</td></tr> </table>


<h3>Note</h3>

<p>The function calls the <code><a href="#topic+fNecklaces">fNecklaces</a></code> function in the <code>Necklaces</code> package and the <code>mKT</code> functions in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo, E., and Guarino., G.  (2022) kStatistics: Unbiased Estimates of Joint Cumulant Products from the Multivariate Faa Di Bruno's Formula. The R journal - In press.  (<a href="https://arxiv.org/abs/2206.15348">https://arxiv.org/abs/2206.15348</a>)
</p>
<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fNecklaces">fNecklaces</a></code>,
<code><a href="#topic+LyndonW">LyndonW</a></code>,
<code><a href="#topic+sBruijn">sBruijn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the list of all the representatives of all the necklaces 
# of length 4 over the alphabet {1,2}. 
Necklaces(4,2)  


# Generate the list of  all the representatives of all the necklaces 
# of length 5 over the alphabet {1,2,3}. 
Necklaces(5,3)  


# Generate the list of  all the representatives of all the necklaces 
# of length 5 over the alphabet {0,1,2}. 
Necklaces(5,3,0) 


</code></pre>

<hr>
<h2 id='sBruijn'>The de Bruijn sequence</h2><span id='topic+sBruijn'></span>

<h3>Description</h3>

<p>The function generates the (minimum) de Bruijn sequence of length <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sBruijn(n=1,m=2, fn=0, bSep=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sBruijn_+3A_n">n</code></td>
<td>
<p>positive integer: the length of the representatives</p>
</td></tr>
<tr><td><code id="sBruijn_+3A_m">m</code></td>
<td>
<p>positive integer: the number of consecutive non-negative integers in the alphabet</p>
</td></tr>
<tr><td><code id="sBruijn_+3A_fn">fn</code></td>
<td>
<p>integer: the first value of the alphabet, the default is 0</p>
</td></tr>
<tr><td><code id="sBruijn_+3A_bsep">bSep</code></td>
<td>
<p>boolean: if <code>TRUE</code>, a separator is inserted between the output blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the (minimum) de Bruijn sequence of order <code>n</code> over an alphabet of <code>m</code> consecutive non-negative integers. The parameter 
(<code>fn</code>) assigns the first value of the alphabet, which by default is equal to 0. If (<code>bSep</code>) is set equal to <code>TRUE</code>, a 
separator is inserted between the output blocks.  
</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the de Bruijn sequence</p>
</td></tr></table>


<h3>Note</h3>

<p>The function calls the <code><a href="#topic+Necklaces">Necklaces</a> function and the <a href="#topic+cNecklaces">cNecklaces</a></code> function in the <code>Necklaces</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo, E., and Guarino., G.  (2022)  Necklaces and bracelets in R - (<a href="https://arxiv.org/abs/2208.06855">https://arxiv.org/abs/2208.06855</a>)
</p>
<p>Flajolet, P., and Sedgewick, R. (2009) Analytic combinatorics. Cambridge University press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Necklaces">Necklaces</a></code>,
<code><a href="#topic+cNecklaces">cNecklaces</a></code>,
<code><a href="#topic+LyndonW">LyndonW</a></code>,
<code><a href="#topic+sBruijn">sBruijn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the de Bruijn sequence of length 4 on the binary alphabet
# {0,1}
sBruijn(4) 
# or equivalently 
sBruijn(4,2) 

# Generate the de Bruijn sequence of length 2 over the alphabet {0,1,2} 
sBruijn(2,3)

# Generate the de Bruijn sequence of length 2 over the alphabet {1,2,3}
sBruijn(2,3,1)

# Generate the de Bruijn sequence of length 2 over the alphabet {1,2,3} 
# with a block separator. 
sBruijn(2,3,1,TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
