<!DOCTYPE html><html><head><title>Help for package bvls</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bvls}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bvls-package'><p>The Stark-Parker algorithm for bounded-variable least squares</p></a></li>
<li><a href='#bvls'><p>The Stark-Parker implementation of bounded-variable least squares</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Stark-Parker algorithm for bounded-variable least squares</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Katharine M. Mullen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Katharine M. Mullen &lt;katharine.mullen@stat.ucla.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An R interface to the Stark-Parker implementation of an
        algorithm for bounded-variable least squares</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2013-12-17 20:21:41 UTC; kmm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2013-12-18 08:53:26</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
</table>
<hr>
<h2 id='bvls-package'>The Stark-Parker algorithm for bounded-variable least squares</h2><span id='topic+bvls-package'></span>

<h3>Description</h3>

<p>An R interface to the Stark-Parker implementation of an
algorithm for bounded-variable
least squares that solves  <code class="reqn">\min{\parallel A x - b \parallel_2}</code>
with the constraint <code class="reqn">l \le x \le u</code>, where
<code class="reqn">l,x,u \in R^n, b \in R^m</code>  and <code class="reqn">A</code> is an
<code class="reqn">m \times n</code> matrix.
</p>


<h3>References</h3>

<p>Stark PB, Parker RL (1995). Bounded-variable least-squares:
an algorithm and applications, Computational Statistics, 10, 129-141.
</p>


<h3>See Also</h3>

 <p><a href="#topic+bvls">bvls</a>, the method <code>"L-BFGS-B"</code> for <a href="stats.html#topic+optim">optim</a>,
<a href="quadprog.html#topic+solve.QP">solve.QP</a>, <a href="nnls.html#topic+nnls">nnls</a>
</p>

<hr>
<h2 id='bvls'>The Stark-Parker implementation of bounded-variable least squares</h2><span id='topic+bvls'></span>

<h3>Description</h3>

<p>An R interface to the Stark-Parker implementation of bounded-variable
least squares that solves the least squares problem
<code class="reqn">\min{\parallel A x - b \parallel_2}</code> 
with the constraint <code class="reqn">l \le x \le u</code>, where
<code class="reqn">l,x,u \in R^n, b \in R^m</code>  and <code class="reqn">A</code> is an
<code class="reqn">m \times n</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvls(A, b, bl, bu, key=0, istate=rep(0,ncol(A)+1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvls_+3A_a">A</code></td>
<td>
<p>numeric matrix with <code>m</code> rows and <code>n</code> columns</p>
</td></tr>
<tr><td><code id="bvls_+3A_b">b</code></td>
<td>
<p>numeric vector of length <code>m</code> </p>
</td></tr>
<tr><td><code id="bvls_+3A_bl">bl</code></td>
<td>
<p>numeric vector of length <code>n</code> specifying the lower bound
on each element of <code>x</code></p>
</td></tr>
<tr><td><code id="bvls_+3A_bu">bu</code></td>
<td>
<p>numeric vector of length <code>n</code> specifying the upper bound
on each element of <code>x</code></p>
</td></tr>
<tr><td><code id="bvls_+3A_key">key</code></td>
<td>
<p>If <code>key &gt; 0</code> the routine initializes using the
user's guess about
which components of  <code>x</code>  are active, i.e. are strictly within their
bounds, which are at their lower bounds, and which are at their 
upper bounds.  This information is supplied through the array  
<code>istate</code>.</p>
</td></tr> 
<tr><td><code id="bvls_+3A_istate">istate</code></td>
<td>
<p>vector of length <code>ncol(A)+1</code>.  If <code>key &gt; 0</code>,
<code>istate</code> is as follows: the last
contains the total number of
components at their bounds (the bound variables).  The absolute
values of the first <code>nbound &lt;- tail(istate,1)</code> entries of
<code>istate</code> are the indices of these bound components of
<code>x</code>.  The sign of <code>istate[1:nbound]</code> indicates whether
<code>x(abs(istate[1:nbound]))</code> is at its upper or lower bound.
<code>istate[1:nbound]</code> is positive if the component is at its upper
bound, negative if the component is at its lower bound.
<code>istate[(nbound+1):ncol(A)]</code> contain the indices of the
components of <code>x</code> that are active (i.e. are expected to lie
strictly within their bounds).  When <code>key &gt; 0</code>, the routine
initially sets the active components to the averages of their upper
and lower bounds.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bvls</code> returns an object of class <code>"bvls"</code>.
</p>
<p>The generic assessor functions <code>coefficients</code>,
<code>fitted.values</code>, <code>deviance</code> and <code>residuals</code> extract
various useful features of the value returned by <code>bvls</code>.
</p>
<p>An object of class <code>"bvls"</code> is a list containing the
following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the parameter estimates.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the residual sum-of-squares.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>This is an R interface to the Fortran77 code accompanying the article
referenced below by Stark PB, Parker RL (1995), and distributed via
the <b>statlib</b> on-line software repository at Carnegie Mellon
University (URL <a href="http://lib.stat.cmu.edu/general/bvls">http://lib.stat.cmu.edu/general/bvls</a>).  The code
was modified slightly to allow compatibility with the gfortran
compiler.  The authors have agreed to distribution under GPL version
2 or newer.
</p>


<h3>References</h3>

<p>Stark PB, Parker RL (1995). Bounded-variable least-squares:
an algorithm and applications, Computational Statistics, 10, 129-141.
</p>


<h3>See Also</h3>

<p>the method <code>"L-BFGS-B"</code> for <a href="stats.html#topic+optim">optim</a>,
<a href="quadprog.html#topic+solve.QP">solve.QP</a>, <a href="nnls.html#topic+nnls">nnls</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate a matrix A
## with 3 columns, each containing an exponential decay 
t &lt;- seq(0, 2, by = .04)
k &lt;- c(.5, .6, 1)
A &lt;- matrix(nrow = 51, ncol = 3)
Acolfunc &lt;- function(k, t) exp(-k*t)
for(i in 1:3) A[,i] &lt;- Acolfunc(k[i],t)

## simulate a matrix X
X &lt;- matrix(nrow = 50, ncol = 3) 
wavenum &lt;- seq(18000,28000, length=nrow(X))
location &lt;- c(25000, 22000) 
delta &lt;- c(1000,1000)
Xcolfunc &lt;- function(wavenum, location, delta)
  exp( - log(2) * (2 * (wavenum - location)/delta)^2)
for(i in 1:2) X[,i] &lt;- Xcolfunc(wavenum, location[i], delta[i])

X[1:40,3] &lt;- Xcolfunc(wavenum, 23000, 1000)[11:nrow(X)]
X[41:nrow(X),3]&lt;- - Xcolfunc(wavenum, 23000, 1000)[21:30]

## set seed for reproducibility
set.seed(3300)

## simulated data is the product of A and X with some
## spherical Gaussian noise added 
matdat &lt;- A %*% t(X) + .005 * rnorm(nrow(A) * nrow(X))

## estimate the rows of X using BVLS criteria 
bvls_sol &lt;- function(matdat, A) {
  X &lt;- matrix(0, nrow = ncol(matdat), ncol = ncol(A) )
  bu &lt;- c(Inf,Inf,.75)
  bl &lt;- c(0,0,-.75)
  for(i in 1:ncol(matdat)) 
     X[i,] &lt;- coef(bvls(A,matdat[,i], bl, bu))
  X
}
X_bvls &lt;- bvls_sol(matdat,A) 

matplot(X,type="p",pch=20)
matplot(X_bvls,type="l",pch=20,add=TRUE)
legend(10, -.5,
c("bound &lt;= zero", "bound &lt;= zero", "bound &lt;= -.75 &lt;= .75"),
col = c(1,2,3), lty=c(1,2,3),
text.col = "blue")

## Not run:  
## can solve the same problem with L-BFGS-B algorithm
## but need starting values for x 
bfgs_sol &lt;- function(matdat, A) {
  startval &lt;- rep(0, ncol(A))
  fn1 &lt;- function(par1, b, A) sum( ( b - A %*% par1)^2)
  X &lt;- matrix(0, nrow = ncol(matdat), ncol = 3)
  bu &lt;- c(1000,1000,.75)
  bl &lt;- c(0,0,-.75)
  for(i in 1:ncol(matdat))  
    X[i,] &lt;-  optim(startval, fn = fn1, b=matdat[,i], A=A,
                  upper = bu, lower = bl,
                  method="L-BFGS-B")$par
    X
}
X_bfgs &lt;- bfgs_sol(matdat,A) 

## the RMS deviation under BVLS is less than under L-BFGS-B 
sqrt(sum((X - X_bvls)^2)) &lt; sqrt(sum((X - X_bfgs)^2))

## and L-BFGS-B is much slower 
system.time(bvls_sol(matdat,A))
system.time(bfgs_sol(matdat,A))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
