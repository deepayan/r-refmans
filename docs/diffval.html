<!DOCTYPE html><html><head><title>Help for package diffval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {diffval}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bigdata_tdv'><p>The Total Differential Value of a big phytosociological data set</p></a></li>
<li><a href='#diffval-package'><p>diffval: Vegetation Patterns</p></a></li>
<li><a href='#explore_tabulation'><p>Interactively explore a tabulation of a phytosociological matrix</p></a></li>
<li><a href='#identical_partition'><p>Do the vectors represent the same k-partition?</p></a></li>
<li><a href='#optim_tdv_gurobi_k_2'><p>Total Differential Value optimization using Gurobi</p></a></li>
<li><a href='#optim_tdv_hill_climb'><p>Total Differential Value optimization using Hill-climbing algorithms</p></a></li>
<li><a href='#optim_tdv_simul_anne'><p>Total Differential Value optimization using a Simulated Annealing (and GRASP)</p>
algorithm(s)</a></li>
<li><a href='#partition_tdv_grasp'><p>Obtain a partition using a GRASP algorithm</p></a></li>
<li><a href='#partition_tdv_grdtp'><p>Obtain a partition using a Greedy-type algorithm</p></a></li>
<li><a href='#tabulation'><p>Rearrange a phytosociological table, showing differential taxa on top</p></a></li>
<li><a href='#taxus_bin'><p><em>Taxus baccata</em> forests</p></a></li>
<li><a href='#tdv'><p>The Total Differential Value of a phytosociological table</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Vegetation Patterns</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Find, visualize and explore patterns of differential taxa in
    vegetation data (namely in a phytosociological table), using the
    Differential Value (DiffVal). Patterns are searched through
    mathematical optimization algorithms. Ultimately, Total Differential
    Value (TDV) optimization aims at obtaining classifications of
    vegetation data based on differential taxa, as in the traditional
    geobotanical approach.  The Gurobi optimizer, as well as the R package
    'gurobi', can be installed from
    <a href="https://www.gurobi.com/products/gurobi-optimizer/">https://www.gurobi.com/products/gurobi-optimizer/</a>.  The useful
    vignette Gurobi Installation Guide, from package 'prioritizr', can be
    found here:
    <a href="https://prioritizr.net/articles/gurobi_installation_guide.html">https://prioritizr.net/articles/gurobi_installation_guide.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/point-veg/diffval">https://gitlab.com/point-veg/diffval</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/point-veg/diffval/-/issues">https://gitlab.com/point-veg/diffval/-/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, parallel, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gurobi, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-09 13:59:50 UTC; tmh</td>
</tr>
<tr>
<td>Author:</td>
<td>Tiago Monteiro-Henriques
    <a href="https://orcid.org/0000-0002-4206-0699"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jorge Orestes Cerdeira
    <a href="https://orcid.org/0000-0002-3814-7660"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Fundação para a Ciência e a Tecnologia, Portugal [fnd]
    (&lt;https://www.fct.pt/&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tiago Monteiro-Henriques &lt;tmh.dev@icloud.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-09 15:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bigdata_tdv'>The Total Differential Value of a big phytosociological data set</h2><span id='topic+bigdata_tdv'></span>

<h3>Description</h3>

<p>Given a big phytosociological data set represented as a list, and a partition
of the relevés in that list, this function calculates the respective Total
Differential Value (TDV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bigdata_tdv(
  phyto_list,
  p,
  n_rel,
  output_type = "normal",
  parallel = FALSE,
  mc_cores = getOption("mc.cores", 2L)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigdata_tdv_+3A_phyto_list">phyto_list</code></td>
<td>
<p>A list. This is a very light representation of what could
be a usual phytosociological table, registering only taxa presences. Each
component should uniquely represent a taxon and should contain a vector (of
numeric values) with the relevé(s) id(s) where that taxon was observed.
Relevé's ids are expected to be represented by consecutive integers,
starting with 1. The components of the list might be named (e.g. using the
taxon name) or empty (decreasing further memory burden). However, for
<code>output_type == "normal"</code> taxa names are useful for output interpretation.</p>
</td></tr>
<tr><td><code id="bigdata_tdv_+3A_p">p</code></td>
<td>
<p>A vector of integer numbers with the partition of the relevés (i.e.,
a k-partition, consisting in a vector with values from 1 to k, with length
equal to the number of relevés in <code>phyto_list</code>, ascribing each relevé to
one of the k groups).</p>
</td></tr>
<tr><td><code id="bigdata_tdv_+3A_n_rel">n_rel</code></td>
<td>
<p>The number of relevés in the <code>phyto_list</code>, obtained e.g.
with <code>length(unique(unlist(phyto_list)))</code>.</p>
</td></tr>
<tr><td><code id="bigdata_tdv_+3A_output_type">output_type</code></td>
<td>
<p>A character determining the amount of information returned
by the function and also the amount of pre-validations. Possible values are
&quot;normal&quot; (the default) and &quot;fast&quot;.</p>
</td></tr>
<tr><td><code id="bigdata_tdv_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Should function <code><a href="parallel.html#topic+mclapply">parallel::mclapply()</a></code>) be used to
improve computation time by forking? Not available on Windows. Refer to
that function manual for more information. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bigdata_tdv_+3A_mc_cores">mc_cores</code></td>
<td>
<p>The number of cores to be passed to <code><a href="parallel.html#topic+mclapply">parallel::mclapply()</a></code> if
<code>parallel = TRUE</code>. See <code><a href="parallel.html#topic+mclapply">parallel::mclapply()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a list (<code>phyto_list</code>) representing a
phytosociological data set, as well as a k-partition of its relevés (<code>p</code>),
returning the corresponding TDV (see <code><a href="#topic+tdv">tdv()</a></code> for an explanation
on TDV).
Partition <code>p</code> gives the group to which each relevé is ascribed, by
increasing order of relevé id.
Big phytosociological tables can occupy a significant amount of computer
memory, which mostly relate to the fact that the absences (usually more
frequent than presences) are also recorded in memory. The use of a list,
focusing only on presences, reduces significantly the amount of needed
memory to store all the information that a phytosociological table contains
and also the computation time of TDV, allowing computations for big data
sets.
</p>


<h3>Value</h3>

<p>If <code>output_type = "normal"</code> (the default) pre-validations are done
(which can take some time) and a list is returned, with the following
components (see <code><a href="#topic+tdv">tdv()</a></code> for the mathematical notation):
</p>

<dl>
<dt>ifp</dt><dd><p>A matrix with the <code class="reqn">\frac{a}{b}</code> values for each taxon
in each group, for short called the 'inner frequency of presences'.</p>
</dd>
<dt>ofda</dt><dd><p>A matrix with the <code class="reqn">\frac{c}{d}</code> values for each
taxon in each group, for short called the 'outer frequency of
differentiating absences'.</p>
</dd>
<dt>e</dt><dd><p>A vector with the <code class="reqn">e</code> values for each taxon, i.e., the
number of groups containing that taxon.</p>
</dd>
<dt>diffval</dt><dd><p>A matrix with the <code class="reqn">DiffVal</code> for each taxon.</p>
</dd>
<dt>tdv</dt><dd><p>A numeric with the TDV of matrix <code style="white-space: pre;">&#8288;m_bin,&#8288;</code> given the partition
<code>p</code>.</p>
</dd>
</dl>

<p>If <code>output_type = "fast"</code>, only TDV is returned and no pre-validations are
done.
</p>


<h3>Author(s)</h3>

<p>Tiago Monteiro-Henriques. E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Creating a group partition, as the one presented in the original article of
# the data set
groups &lt;- rep(c(1, 2, 3), c(3, 11, 19))

# Removing taxa occurring in only one relevé, in order to reproduce exactly
# the example in the original article of the data set
taxus_bin_wmt &lt;- taxus_bin[rowSums(taxus_bin) &gt; 1, ]

# Calculating TDV using tdv()
tdv(taxus_bin_wmt, groups)$tdv

# Converting from the phytosociologic matrix format to the list format
taxus_phyto_list &lt;- apply(taxus_bin_wmt, 1, function(x) which(as.logical(x)))

# Getting the number of relevés in the list
n_rel &lt;- length(unique(unlist(taxus_phyto_list)))

# Calculating TDV using bigdata_tdv(), even if this is not a big matrix
bigdata_tdv(
  phyto_list = taxus_phyto_list,
  p = groups,
  n_rel = n_rel,
  output_type = "normal"
)$tdv

</code></pre>

<hr>
<h2 id='diffval-package'>diffval: Vegetation Patterns</h2><span id='topic+diffval'></span><span id='topic+diffval-package'></span>

<h3>Description</h3>

<p>Find, visualize and explore patterns of differential taxa in vegetation data (namely in a phytosociological table), using the Differential Value (DiffVal). Patterns are searched through mathematical optimization algorithms. Ultimately, Total Differential Value (TDV) optimization aims at obtaining classifications of vegetation data based on differential taxa, as in the traditional geobotanical approach. The Gurobi optimizer, as well as the R package 'gurobi', can be installed from <a href="https://www.gurobi.com/products/gurobi-optimizer/">https://www.gurobi.com/products/gurobi-optimizer/</a>. The useful vignette Gurobi Installation Guide, from package 'prioritizr', can be found here: <a href="https://prioritizr.net/articles/gurobi_installation_guide.html">https://prioritizr.net/articles/gurobi_installation_guide.html</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tiago Monteiro-Henriques <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a> (<a href="https://orcid.org/0000-0002-4206-0699">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jorge Orestes Cerdeira (<a href="https://orcid.org/0000-0002-3814-7660">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Fundação para a Ciência e a Tecnologia, Portugal (&lt;https://www.fct.pt/&gt;) [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://gitlab.com/point-veg/diffval">https://gitlab.com/point-veg/diffval</a>
</p>
</li>
<li><p> Report bugs at <a href="https://gitlab.com/point-veg/diffval/-/issues">https://gitlab.com/point-veg/diffval/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='explore_tabulation'>Interactively explore a tabulation of a phytosociological matrix</h2><span id='topic+explore_tabulation'></span>

<h3>Description</h3>

<p>This function plots an interactive image of a tabulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore_tabulation(tab, palette = "Vik")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explore_tabulation_+3A_tab">tab</code></td>
<td>
<p>A list as returned by the <code><a href="#topic+tabulation">tabulation()</a></code> function.</p>
</td></tr>
<tr><td><code id="explore_tabulation_+3A_palette">palette</code></td>
<td>
<p>A character with the name of the colour palette (one of
<code><a href="grDevices.html#topic+palettes">grDevices::hcl.pals()</a></code> to be passed to <code><a href="grDevices.html#topic+palettes">grDevices::hcl.colors()</a></code>. Defaults
to &quot;Vik&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function explore.tabulation accepts an object returned by the
<code><a href="#topic+tabulation">tabulation()</a></code> function, plotting a condensed image of the
respective tabulated matrix, permitting the user to click on the coloured
blocks and receive the respective list of taxa names on the console.
</p>


<h3>Value</h3>

<p>Returns invisibly, although it prints taxa names on the console upon
the user click on the figure.
</p>


<h3>Author(s)</h3>

<p>Tiago Monteiro-Henriques. E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)
# Creating a group partition, as presented in the original article of
# the data set
groups &lt;- rep(c(1, 2, 3), c(3, 11, 19))

# Removing taxa occurring in only one relevé in order to
# reproduce exactly the example in the original article of the data set
taxus_bin_wmt &lt;- taxus_bin[rowSums(taxus_bin) &gt; 1, ]

# Sorts the phytosociological table, putting exclusive taxa at the top and
# plots an image of it
tabul &lt;- tabulation(
  m_bin = taxus_bin_wmt,
  p = groups,
  taxa_names = rownames(taxus_bin_wmt),
  plot_im = "normal",
  palette = "Zissou 1"
)

# This creates an interactive plot (where you can click)
if (interactive()) {
  explore_tabulation(tabul, palette = "Zissou 1")
}

</code></pre>

<hr>
<h2 id='identical_partition'>Do the vectors represent the same k-partition?</h2><span id='topic+identical_partition'></span>

<h3>Description</h3>

<p>Checks if two vectors represent the same k-partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identical_partition(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identical_partition_+3A_p1">p1</code></td>
<td>
<p>A vector of integers representing a k-partition (taking values
from 1 to k), of the same length of <code>p2</code>.</p>
</td></tr>
<tr><td><code id="identical_partition_+3A_p2">p2</code></td>
<td>
<p>A vector of integers representing a k-partition (taking values
from 1 to k), of the same length of <code>p1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters <code>p1</code>and <code>p2</code>are vectors indicating group membership.
In this package context, these vectors have as many elements as the columns
of a phytosociological table, indicating the group membership of each
relevé to one of k groups (i.e., a k-partition).
This function checks if the two given vectors <code>p1</code>and <code>p2</code> correspond, in
practice, to the same k-partition, i.e., if the relevé groups are actually
the same, but the group numbers are somehow swapped.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if <code>p1</code>and <code>p2</code> represent the same k-partitions; <code>FALSE</code>
otherwise.
</p>


<h3>Author(s)</h3>

<p>Tiago Monteiro-Henriques and Jorge Orestes Cerdeira.
E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating three 2-partitions
par1 &lt;- c(1, 1, 2, 2, 2)
par2 &lt;- c(2, 2, 1, 1, 1)
par3 &lt;- c(1, 1, 1, 2, 2)

# Is it the same partition?
identical_partition(par1, par2) # TRUE
identical_partition(par1, par3) # FALSE
identical_partition(par2, par3) # FALSE

</code></pre>

<hr>
<h2 id='optim_tdv_gurobi_k_2'>Total Differential Value optimization using Gurobi</h2><span id='topic+optim_tdv_gurobi_k_2'></span>

<h3>Description</h3>

<p>Given a phytosociological matrix, this function finds a partition in two
groups of the matrix columns, which maximizes the Total Differential Value
(TDV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_tdv_gurobi_k_2(m_bin, formulation = "t-dependent", time_limit = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim_tdv_gurobi_k_2_+3A_m_bin">m_bin</code></td>
<td>
<p>A matrix. A phytosociological table of 0s (absences) and 1s
(presences), where rows correspond to taxa and columns correspond to
relevés.</p>
</td></tr>
<tr><td><code id="optim_tdv_gurobi_k_2_+3A_formulation">formulation</code></td>
<td>
<p>A character selecting which formulation to use. Possible
values are &quot;t-dependent&quot; (the default) or &quot;t-independent&quot;. See Details.</p>
</td></tr>
<tr><td><code id="optim_tdv_gurobi_k_2_+3A_time_limit">time_limit</code></td>
<td>
<p>A numeric (&quot;double&quot;) with the time limit (in seconds) to
be passed as a parameter to Gurobi, Defaults to 5 seconds, but see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a phytosociological table <code>m_bin</code> (rows corresponding to taxa
and columns corresponding to relevés) this function finds a 2-partition (a
partition in two groups) that maximizes TDV, using the Gurobi optimizer.
</p>
<p><a href="https://www.gurobi.com/">Gurobi</a> is a commercial software for which a free
academic license can be obtained if you are affiliated with a recognized
educational institution. Package 'prioritizr' contains a comprehensive
vignette (<a href="https://prioritizr.net/articles/gurobi_installation_guide.html">Gurobi Installation Guide</a>),
which can guide you trough the process of obtaining a license, installing
the <a href="https://www.gurobi.com/products/gurobi-optimizer/">Gurobi optimizer</a>,
activating the license and eventually installing the R package 'gurobi'.
</p>
<p><code><a href="#topic+optim_tdv_gurobi_k_2">optim_tdv_gurobi_k_2()</a></code> returns, when the optimization is successful, a
2-partition which is a global maximum of TDV for any 2-partitions of the
columns on <code>m_bin</code>.
</p>
<p>See <code><a href="#topic+tdv">tdv()</a></code> for an explanation on the Total Differential Value of a
phytosociological table.
</p>
<p>The function implements two different mixed-integer linear programming
formulations of the problem. The formulations differ as one is independent
of the size of the obtained groups (t-independent), while the other
formulation fixes the size of the obtained groups (t-dependent). The
t-dependent formulation is implemented to run Gurobi as many times as
necessary to cover all possible group sizes; this approach can result in
faster total computation time.
</p>
<p>For medium-sized matrices the computation time might become already
prohibitive, thus the use of a time limit (<code>time_limit</code>) is advisable.
</p>


<h3>Value</h3>

<p>For <code>formulation = "t-dependent"</code>, a list with the following
components:
</p>

<dl>
<dt>status.runs</dt><dd><p>A character vector with Gurobi output status for all
the runs.</p>
</dd>
<dt>objval</dt><dd><p>A numeric with the maximum TDV found by Gurobi.</p>
</dd>
<dt>par</dt><dd><p>A vector with the 2-partition corresponding to the the
maximum TDV found by Gurobi.</p>
</dd>
</dl>

<p>For <code>formulation = "t-independent"</code>, a list with the following components:
</p>

<dl>
<dt>status</dt><dd><p>A character with Gurobi output status.</p>
</dd>
<dt>objval</dt><dd><p>A numeric with the maximum TDV found by Gurobi.</p>
</dd>
<dt>par</dt><dd><p>A vector with the 2-partition corresponding to the the
maximum TDV found by Gurobi.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jorge Orestes Cerdeira and Tiago Monteiro-Henriques.
E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Obtaining the 2-partition that maximizes TDV using the Gurobi solver, by
# mixed-integer linear programming
## Not run: 
# Requires the suggested package 'gurobi'
optim_tdv_gurobi_k_2(taxus_bin)

## End(Not run)

</code></pre>

<hr>
<h2 id='optim_tdv_hill_climb'>Total Differential Value optimization using Hill-climbing algorithms</h2><span id='topic+optim_tdv_hill_climb'></span>

<h3>Description</h3>

<p>This function searches for partitions of the columns of a given matrix,
optimizing the Total Differential Value (TDV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_tdv_hill_climb(
  m_bin,
  k,
  p_initial = "random",
  n_runs = 1,
  n_sol = 1,
  maxit = 10,
  min_g_size = 1,
  stoch_first = FALSE,
  stoch_neigh_size = 1,
  stoch_maxit = 100,
  full_output = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim_tdv_hill_climb_+3A_m_bin">m_bin</code></td>
<td>
<p>A matrix. A phytosociological table of 0s (absences) and 1s
(presences), where rows correspond to taxa and columns correspond to
relevés.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_k">k</code></td>
<td>
<p>A numeric giving the number of desired groups.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_p_initial">p_initial</code></td>
<td>
<p>A vector or a character. A vector of integer numbers
with the initial partition of the relevés (i.e., a vector with values from
1 to <code>k</code>, with length equal to the number of columns of <code>m_bin</code>, ascribing
each relevé to one of the <code>k</code> groups). By default, <code>p_initial = "random"</code>,
generates a random initial partition.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_n_runs">n_runs</code></td>
<td>
<p>A numeric giving the number of runs to perform.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_n_sol">n_sol</code></td>
<td>
<p>A numeric giving the number of best solutions to keep
in the final output. Defaults to 1.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_maxit">maxit</code></td>
<td>
<p>A numeric giving the number of iterations of the Hill-climbing
optimization.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_min_g_size">min_g_size</code></td>
<td>
<p>A numeric. The minimum number of relevés that a group can
contain (must be 1 or higher).</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_stoch_first">stoch_first</code></td>
<td>
<p>A logical. <code>FALSE</code> (the default), performs only
Hill-climbing on the 1-neighbours; <code>TRUE</code> first, performs a Stochastic
Hill-climbing on n-neighbours (n is defined by the parameter
<code>stoch_neigh_size</code>), and only after runs the Hill-climbing search on the
1-neighbours; see description above.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_stoch_neigh_size">stoch_neigh_size</code></td>
<td>
<p>A numeric giving the size (n) of the
n-neighbours for the Stochastic Hill-climbing; only used if
<code>stoch_first = TRUE</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_stoch_maxit">stoch_maxit</code></td>
<td>
<p>A numeric giving the number of iterations of the
Stochastic Hill-climbing optimization; only used if <code>stoch_first = TRUE</code>.
Defaults to 100.</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_full_output">full_output</code></td>
<td>
<p>A logical. If <code>FALSE</code> (the default) the best <code>n_sol</code>
partitions and respective indices are returned. If <code>TRUE</code> (only available
for <code>n_sol = 1</code>) the output will also contain information on the
optimization steps (see below).</p>
</td></tr>
<tr><td><code id="optim_tdv_hill_climb_+3A_verbose">verbose</code></td>
<td>
<p>A logical. If <code>FALSE</code> nothing is printed during the runs.
If <code>TRUE</code>, after each run, the run number is printed as well as and
indication if the found partition is a 1-neighbour local maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a phytosociological table (<code>m_bin</code>, rows corresponding to
taxa and columns corresponding to relevés) this function searches for
a <code>k</code>-partition (<code>k</code> defined by the user) optimizing TDV, i.e., searches,
using a Hill-climbing algorithm, for patterns of differential taxa by
rearranging the relevés into <code>k</code> groups.
</p>
<p>Optimization can start from a random partition (<code>p_ini = "random"</code>), or
from a given partition (<code>p_ini</code>, defined by the user or produced by any
clustering method, or even a manual classification of the relevés).
</p>
<p>Each iteration searches for a TDV improvement screening all 1-neighbours,
until the given number of maximum iterations (<code>maxit</code>) is reached. A
1-neighbour of a given partition is another partition obtained by changing
1 relevé (of the original partition) to a different group. A n-neighbour
is obtained, equivalently, ascribing n relevés to different groups.
</p>
<p>Optionally, a faster search (Stochastic Hill-climbing) can be performed in
a first step (<code>stoch_first = TRUE</code>), consisting on searching for TDV
improvements, by randomly selecting, in each iteration, one n-neighbour (n
defined by the user in the parameter <code>stoch_neigh_size</code>), accepting that
n-neighbour partition as a better solution if it improves TDV. This is
repeated until a given number of maximum iterations (<code>stoch_maxit</code>) is
reached. Stochastic Hill-climbing might be helpful for big tables (where
the screening of all 1-neighbours might be too time consuming).
</p>
<p>Several runs of this function (i.e., multiple starts) should be
tried out, as several local maxima are usually present and the
Hill-climbing algorithm converges easily to local maxima.
</p>
<p>Trimming your table by a 'constancy' range or using the result of other
cluster methodologies as input, might help finding interesting partitions.
Specially after trimming the table by a 'constancy' range, getting a random
initial partition with TDV greater than zero might be unlikely; on such
cases using a initial partition from <code><a href="#topic+partition_tdv_grasp">partition_tdv_grasp()</a></code> or
<code><a href="#topic+partition_tdv_grdtp">partition_tdv_grdtp()</a></code> (or even the result of other clustering
strategies) as an input partition might be useful.
</p>


<h3>Value</h3>

<p>If <code>full_output = FALSE</code>, a list with (at most) <code>n_sol</code> best
solutions (equivalent solutions are removed). Each best solution is also
a list with the following components:
</p>

<dl>
<dt>local_maximum</dt><dd><p>A logical indicating if <code>par</code> is a 1-neighbour
local maximum.</p>
</dd>
<dt>par</dt><dd><p>A vector with the partition of highest TDV obtained by the
Hill-climbing algorithm(s).</p>
</dd>
<dt>tdv</dt><dd><p>A numeric with the TDV of <code>par</code>.</p>
</dd>
</dl>

<p>If <code>full_output = TRUE</code>, a list with just one component (one run only),
containing also a list with the following components:
</p>

<dl>
<dt>res.stoch</dt><dd><p>A matrix with the iteration number (of the Stochastic
Hill-climbing phase), the maximum TDV found until that iteration, and the
TDV of the randomly selected n-neighbour in that iteration.</p>
</dd>
<dt>par.stoch</dt><dd><p>A vector with the best partition found in the Stochastic
Hill-climbing phase.</p>
</dd>
<dt>tdv.stoch</dt><dd><p>A numeric showing the maximum TDV found in the
Stochastic Hill-climbing phase (if selected).</p>
</dd>
<dt>res</dt><dd><p>A matrix with the iteration number (of the Hill-climbing), the
maximum TDV found until that iteration, and the highest TDV among all
1-neighbours.</p>
</dd>
<dt>local_maximum</dt><dd><p>A logical indicating if <code>par</code> is a 1-neighbour local
maximum.</p>
</dd>
<dt>par</dt><dd><p>A vector with the partition of highest TDV obtained by the
Hill-climbing algorithm(s).</p>
</dd>
<dt>tdv</dt><dd><p>A numeric with the TDV of <code>par</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Tiago Monteiro-Henriques. E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Removing taxa occurring in only one relevé in order to
# reproduce the example in the original article of the data set
taxus_bin_wmt &lt;- taxus_bin[rowSums(taxus_bin) &gt; 1, ]

# Obtaining a partition that maximizes TDV using the Stochastic Hill-climbing
# and the Hill-climbing algorithms

result &lt;- optim_tdv_hill_climb(
  m_bin = taxus_bin_wmt,
  k = 3,
  n_runs = 7,
  n_sol = 2,
  min_g_size = 3,
  stoch_first = TRUE,
  stoch_maxit = 500,
  verbose = TRUE
)

# Inspect the result. The highest TDV found in the runs.
result[[1]]$tdv
# If result[[1]]$tdv is 0.1958471 you are probably reproducing the three
# groups (Estrela, Gerês and Galicia) from the original article. If not
# try again the optim_tdv_hill_climb function (maybe increasing n_runs).

# Plot the sorted (or tabulated) phytosociological table
tabul1 &lt;- tabulation(
  m_bin = taxus_bin_wmt,
  p = result[[1]]$par,
  taxa_names = rownames(taxus_bin_wmt),
  plot_im = "normal"
)

# Plot the sorted (or tabulated) phytosociological table, also including
# taxa occurring just once in the matrix
tabul2 &lt;- tabulation(
  m_bin = taxus_bin,
  p = result[[1]]$par,
  taxa_names = rownames(taxus_bin),
  plot_im = "normal"
)

</code></pre>

<hr>
<h2 id='optim_tdv_simul_anne'>Total Differential Value optimization using a Simulated Annealing (and GRASP)
algorithm(s)</h2><span id='topic+optim_tdv_simul_anne'></span>

<h3>Description</h3>

<p>This function searches for <code>k</code>-partitions of the columns of a given matrix
(i.e., a partition of the columns in <code>k</code> groups), optimizing the Total
Differential Value (TDV) using a stochastic global optimization method
called Simulated Annealing (SANN) algorithm. Optionally, a Greedy
Randomized Adaptive Search Procedure (GRASP) can be used to find a initial
partition (seed) to be passed to the SANN algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_tdv_simul_anne(
  m_bin,
  k,
  p_initial = NULL,
  n_runs = 10,
  n_sol = 1,
  t_inic = 0.3,
  t_final = 1e-06,
  alpha = 0.05,
  n_iter = 1000,
  use_grasp = TRUE,
  thr = 0.95,
  full_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim_tdv_simul_anne_+3A_m_bin">m_bin</code></td>
<td>
<p>A matrix. A phytosociological table of 0s (absences) and
1s (presences), where rows correspond to taxa and columns correspond to
relevés.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_k">k</code></td>
<td>
<p>A numeric giving the number of desired groups.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_p_initial">p_initial</code></td>
<td>
<p>A vector of integer numbers with the partition of the
relevés (i.e., a <code>k</code>-partition, consisting in a vector with values from 1
to <code>k</code>, with length equal to the number of columns of <code>m_bin</code>, ascribing
each relevé to one of the <code>k</code> groups), to be used as initial partition in
the Simulated Annealing. For a random partition use <code>p_initial = "random"</code>.
This argument is ignored if <code>use_grasp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_n_runs">n_runs</code></td>
<td>
<p>A numeric giving the number of runs. Defaults to 10.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_n_sol">n_sol</code></td>
<td>
<p>A numeric giving the number of best solutions to keep in the
final output (only used if <code>full_output</code> is <code>FALSE</code>; if <code>full_output</code> is
<code>TRUE</code> all runs will produce an output). Defaults to 1.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_t_inic">t_inic</code></td>
<td>
<p>A numeric giving the initial temperature. Must be greater
than 0 and maximum admitted value is 1. Defaults to 0.3.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_t_final">t_final</code></td>
<td>
<p>A numeric giving the final temperature. Must be bounded
between 0 and 1. Usually very low values are needed to ensure convergence.
Defaults to 0.000001.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_alpha">alpha</code></td>
<td>
<p>A numeric giving the fraction of temperature drop to be used
in the temperature reduction scheme (see Details). Must be bounded between
0 and 1. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_n_iter">n_iter</code></td>
<td>
<p>A numeric giving the number of iterations. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_use_grasp">use_grasp</code></td>
<td>
<p>A logical. Defaults to <code>TRUE</code>. IF <code>TRUE</code>, a GRASP is used
to obtain the initial partitions for the Simulated Annealing. If <code>FALSE</code>
the user should provide an initial partition or use or use
<code>p_initial = "random"</code> for a random one.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_thr">thr</code></td>
<td>
<p>A numeric giving a threshold value (from 0 to 1 ) with the
probability used to compute the sample quantile, in order to get the best
<code>m_bin</code> columns from which to select one to be include in the GRASP
solution (in each step of the procedure). Only needed if <code>use_grasp</code> is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="optim_tdv_simul_anne_+3A_full_output">full_output</code></td>
<td>
<p>A logical. Defaults to <code>FALSE</code>. If <code>TRUE</code> extra
information is presented in the output. See Value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a phytosociological table (<code>m_bin</code>, with rows corresponding to
taxa and columns corresponding to relevés) this function searches for a
<code>k</code>-partition (<code>k</code>, defined by the user) optimizing the TDV, i.e.,
searches, using a SANN algorithm (optionally working upon GRASP solutions),
for a global maximum of TDV (by rearranging the relevés into <code>k</code> groups).
</p>
<p>This function uses two main algorithms:
</p>

<ol>
<li><p> An optional GRASP, which is used to obtain initial solutions
(partitions of <code>m_bin</code>) using function <code><a href="#topic+partition_tdv_grasp">partition_tdv_grasp()</a></code>.
Such initial solutions are then submitted to the SANN algorithm.
</p>
</li>
<li><p> The (main) SANN algorithm, which is used to search for a global
maximum of TDV. The initial partition for each run of SANN can be a
partition obtained from GRASP (if <code>use_grasp = TRUE</code>) or, (if
<code>use_grasp = FALSE</code>), a partition given by the user (using <code>p_initial</code>) or
a random partition (using <code>p_initial = "random"</code>).
</p>
</li></ol>

<p>The SANN algorithm decreases the temperature multiplying the current
temperature by <code>1 - alpha</code> according to a predefined schedule, which is
automatically calculated from the given values for <code>t_inic</code>, <code>t_final</code>,
<code>alpha</code> and <code>n_iter</code>.
Specifically, the cooling schedule is obtained calculating the number of
times that the temperature has to be decreased in order to approximate
<code>t_final</code> starting from <code>t_inic</code>. The number of times that the temperature
decreases, say <code>nt</code>, is calculated by the expression:
</p>
<p><code style="white-space: pre;">&#8288;floor(n_iter/((n_iter * log(1 - alpha)) / (log((1 - alpha) * t_final / &#8288;</code>
<code style="white-space: pre;">&#8288;t_inic))))&#8288;</code>.
</p>
<p>Finally, these decreasing stages are scattered through the desired
iterations (<code>n_iter</code>) homogeneously, by calculating the indices of the
iterations that will experience a decrease in temperature using
<code>floor(n_iter / nt * (1:nt))</code>.
</p>
<p>SANN is often seen as an exploratory technique where the temperature
settings are challenging and dependent on the problem. This function tries
to restrict temperature values taking into account that TDV is always
between 0 and 1. Even though, obtaining values of temperature that allow
convergence can be challenging. <code>full_output = TRUE</code> allows the user to
inspect the behaviour of <code>current.tdv</code> and check if convergence fails.
Generally, convergence failure can be spotted when final SANN TDV values
are similar to the initial <code>current.tdv</code>, specially when coming from random
partitions. In such cases, as a rule of thumb, it is advisable to decrease
<code>t_final</code>.
</p>


<h3>Value</h3>

<p>If <code>full_output = FALSE</code> (the default), a list with the following
components (the GRASP component is only returned if <code>use_grasp = TRUE</code>):
</p>

<dl>
<dt>GRASP</dt><dd><p>A list with at most <code>n_sol</code> components, each one
containing also a list with two components:
</p>

<dl>
<dt>par</dt><dd><p>A vector with the partition of highest TDV obtained by
GRASP;</p>
</dd>
<dt>tdv</dt><dd><p>A numeric with the TDV of <code>par</code>.</p>
</dd>
</dl>

</dd>
<dt>SANN</dt><dd><p>A list with at most <code>n_sol</code> components, each one containing
also a list with two components:
</p>

<dl>
<dt>par</dt><dd><p>A vector with the partition of highest TDV obtained by the
(GRASP +) SANN algorithm(s);</p>
</dd>
<dt>tdv</dt><dd><p>A numeric with the TDV of <code>par</code>.</p>
</dd>
</dl>

</dd>
</dl>

<p>If <code>full_output = TRUE</code>, a list with the following components (the GRASP
component is only returned if <code>use_grasp = TRUE</code>):
</p>

<dl>
<dt>GRASP</dt><dd><p>A list with <code>n_runs</code> components, each one containing also a
list with two components:
</p>

<dl>
<dt>par</dt><dd><p>A vector with the partition of highest TDV obtained by
GRASP.</p>
</dd>
<dt>tdv</dt><dd><p>A numeric with the TDV of <code>par</code>.</p>
</dd>
</dl>

</dd>
<dt>SANN</dt><dd><p>A list with <code>n_runs</code> components, each one containing also a
list with six components:
</p>

<dl>
<dt>current.tdv</dt><dd><p>A vector of length <code>n_iter</code> with the current TDV of
each SANN iteration.</p>
</dd>
<dt>alternative.tdv</dt><dd><p>A vector of length <code>n_iter</code> with the alternative
TDV used in each SANN iteration.</p>
</dd>
<dt>probability</dt><dd><p>A vector of length <code>n_iter</code> with the probability
used in each SANN iteration.</p>
</dd>
<dt>temperature</dt><dd><p>A vector of length <code>n_iter</code> with the temperature of
each SANN iteration.</p>
</dd>
<dt>par</dt><dd><p>A vector with the partition of highest TDV obtained by the
(GRASP +) SANN algorithm(s).</p>
</dd>
<dt>tdv</dt><dd><p>A numeric with the TDV of <code>par</code>.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Jorge Orestes Cerdeira and Tiago Monteiro-Henriques.
E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Removing taxa occurring in only one relevé in order to
# reproduce the example in the original article of the data set
taxus_bin_wmt &lt;- taxus_bin[rowSums(taxus_bin) &gt; 1, ]

# Obtaining a partition that maximizes TDV using the Simulated Annealing
# algorithm
result &lt;- optim_tdv_simul_anne(
  m_bin = taxus_bin_wmt,
  k = 3,
  p_initial = "random",
  n_runs = 5,
  n_sol = 5,
  use_grasp = FALSE,
  full_output = TRUE
)

# Inspect the result
# The TDV of each run
sapply(result[["SANN"]], function(x) x$tdv)
# The best partition that was found (i.e., with highest TDV)
result[["SANN"]][[1]]$par

# A TDV of 0.1958471 indicates you are probably reproducing the three
# groups (Estrela, Gerês and Galicia) from the original article. A solution
# with TDV = 0.2005789 might also occur, but note that one group has only two
# elements. For now, a minimum group size is not implemented in function
# optim_tdv_simul_anne() as it is in the function optim_tdv_hill_climb().

# Inspect how the optimization progressed (should increase towards the right)
plot(
  result[["SANN"]][[1]]$current.tdv,
  type = "l",
  xlab = "Iteration number",
  ylab = "TDV of the currently accepted solution"
)
for (run in 2:length(result[["SANN"]])) {
  lines(result[["SANN"]][[run]]$current.tdv)
}

# Plot the sorted (or tabulated) phytosociological table, using the best
# partition that was found
tabul &lt;- tabulation(
  m_bin = taxus_bin_wmt,
  p = result[["SANN"]][[1]]$par,
  taxa_names = rownames(taxus_bin_wmt),
  plot_im = "normal"
)

</code></pre>

<hr>
<h2 id='partition_tdv_grasp'>Obtain a partition using a GRASP algorithm</h2><span id='topic+partition_tdv_grasp'></span>

<h3>Description</h3>

<p>This function obtains a partition of the columns of a given phytosociological
matrix, aiming at high values of the Total Differential Value (TDV) using a
GRASP algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_tdv_grasp(m_bin, k, thr = 0.95, verify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_tdv_grasp_+3A_m_bin">m_bin</code></td>
<td>
<p>A matrix. A phytosociological table of 0s (absences) and 1s
(presences), where rows correspond to taxa and columns correspond to
relevés.</p>
</td></tr>
<tr><td><code id="partition_tdv_grasp_+3A_k">k</code></td>
<td>
<p>A numeric giving the number of desired groups.</p>
</td></tr>
<tr><td><code id="partition_tdv_grasp_+3A_thr">thr</code></td>
<td>
<p>A numeric giving a threshold value (from 0 to 1 ) with the
probability used to compute the sample quantile, in order to get the best
<code>m_bin</code> columns from which to select one to be include in the GRASP
solution (in each step of the procedure).</p>
</td></tr>
<tr><td><code id="partition_tdv_grasp_+3A_verify">verify</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default) the function verifies if
basic features of <code>m_bin</code> data structure are met. Otherwise if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a Greedy Randomized Adaptive Search Procedure
(GRASP) to obtain a partition of <code>m_bin</code>.
Given a phytosociological table (<code>m_bin</code>, with rows corresponding to taxa
and columns corresponding to relevés) this function searches for a
<code>k</code>-partition (<code>k</code>, defined by the user) aiming at high values of the TDV.
See <code><a href="#topic+tdv">tdv()</a></code> for an explanation on the TDV of a phytosociological table.
</p>
<p>With <code>thr = 1</code>, the algorithm corresponds to the Greedy algorithm.
</p>


<h3>Value</h3>

<p>A numeric vector, which length is the same as the number of columns
of <code>m_bin</code>, with numbers from 1 to <code>k</code>, representing the group to which the
respective column was ascribed.
</p>


<h3>Author(s)</h3>

<p>Jorge Orestes Cerdeira and Tiago Monteiro-Henriques.
E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Obtaining a partition based on the GRASP algorithm
partition_tdv_grasp(taxus_bin, 3)

</code></pre>

<hr>
<h2 id='partition_tdv_grdtp'>Obtain a partition using a Greedy-type algorithm</h2><span id='topic+partition_tdv_grdtp'></span>

<h3>Description</h3>

<p>This function obtains a partition of the columns of a given phytosociological
matrix, aiming at high values of the Total Differential Value (TDV),
implementing a Greedy-type algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_tdv_grdtp(m_bin, k, verify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_tdv_grdtp_+3A_m_bin">m_bin</code></td>
<td>
<p>A matrix. A phytosociological table of 0s (absences) and 1s
(presences), where rows correspond to taxa and columns correspond to
relevés.</p>
</td></tr>
<tr><td><code id="partition_tdv_grdtp_+3A_k">k</code></td>
<td>
<p>A numeric giving the number of desired groups.</p>
</td></tr>
<tr><td><code id="partition_tdv_grdtp_+3A_verify">verify</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default) the function verifies if
basic features of <code>m_bin</code> data structure are met. Otherwise if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the phytosociological table <code>m_bin</code> (rows corresponding to
taxa and columns corresponding to relevés), this function uses a
Greedy-type algorithm (a simplified version of the Greedy algorithm) to
obtain a <code>k</code>-partition (<code>k</code>, defined by the user) of the columns of
<code>m_bin</code>, aiming at high values of TDV.
The algorithm operates in the following way: Firstly, <code>k</code> columns are
selected randomly to work as seeds for each one of the desired <code>k</code> groups.
Secondly, one of the remaining columns is selected randomly and added to
the partition group which maximizes the upcoming TDV. This second step is
repeated until all columns are placed in a group of the <code>k</code>-partition.
</p>
<p>This function is expected to perform faster than <code><a href="#topic+partition_tdv_grasp">partition_tdv_grasp()</a></code>,
yet returning worse partitions in terms of TDV. For the (true) Greedy
algorithm see <code><a href="#topic+partition_tdv_grasp">partition_tdv_grasp()</a></code>.
See <code><a href="#topic+tdv">tdv()</a></code> for an explanation on the TDV of a phytosociological table.
</p>


<h3>Value</h3>

<p>A numeric vector, which length is the same as the number of columns
of <code>m_bin</code>, with numbers from 1 to <code>k</code>, representing the group to which the
respective column was ascribed.
</p>


<h3>Author(s)</h3>

<p>Jorge Orestes Cerdeira and Tiago Monteiro-Henriques.
E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Obtaining a partiton based on a Greedy-type algorithm
partition_tdv_grdtp(taxus_bin, 3)

</code></pre>

<hr>
<h2 id='tabulation'>Rearrange a phytosociological table, showing differential taxa on top</h2><span id='topic+tabulation'></span>

<h3>Description</h3>

<p>This function reorders a phytosociological table rows using, firstly, the
increasing number of groups in which a taxon occurs, and secondly, the
decreasing sum of the inner frequency of presences of each taxon
(see <code><a href="#topic+tdv">tdv()</a></code>). The columns are also reordered, simply using the increasing
number of the respective group membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabulation(
  m_bin,
  p,
  taxa_names,
  plot_im = NULL,
  palette = "Vik",
  greyout = TRUE,
  greyout_colour = "grey"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabulation_+3A_m_bin">m_bin</code></td>
<td>
<p>A matrix. A phytosociological table of 0s (absences) and 1s
(presences), where rows correspond to taxa and columns correspond to
relevés.</p>
</td></tr>
<tr><td><code id="tabulation_+3A_p">p</code></td>
<td>
<p>A vector of integer numbers with the partition of the relevés (i.e.,
a k-partition, consisting in a vector with values from 1 to k, with length
equal to the number of columns of <code>m_bin</code>, ascribing each relevé to one of
the k groups).</p>
</td></tr>
<tr><td><code id="tabulation_+3A_taxa_names">taxa_names</code></td>
<td>
<p>A character vector (with length equal to the number of rows
of <code>m_bin</code>) with the taxa names.</p>
</td></tr>
<tr><td><code id="tabulation_+3A_plot_im">plot_im</code></td>
<td>
<p>By default, <code>NULL</code>, returns without plotting. If
<code>plot_im = "normal"</code>, plots an image of the tabulated matrix. If
<code>plot_im = "condensed"</code>, plots an image of the tabulated matrix but
presenting sets of differential taxa as solid coloured blocks.</p>
</td></tr>
<tr><td><code id="tabulation_+3A_palette">palette</code></td>
<td>
<p>A character with the name of the colour palette (one of
<code><a href="grDevices.html#topic+palettes">grDevices::hcl.pals()</a></code> to be passed to <code><a href="grDevices.html#topic+palettes">grDevices::hcl.colors()</a></code>. Defaults
to &quot;Vik&quot;.</p>
</td></tr>
<tr><td><code id="tabulation_+3A_greyout">greyout</code></td>
<td>
<p>A logical. If <code>TRUE</code> (the default), non-differential taxa are
greyed out (using the colour defined by <code>greyout_colour</code>). If <code>FALSE</code>,
non-differential taxa is depicted with the respective group colours.</p>
</td></tr>
<tr><td><code id="tabulation_+3A_greyout_colour">greyout_colour</code></td>
<td>
<p>A character with the name of the colour to use for
non-differential taxa. Defaults to &quot;grey&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts a phytosociological table (<code>m_bin</code>), a
k-partition of its columns (<code>p</code>) and the names of the taxa (corresponding
to the rows of <code>m_bin</code>), returning a rearranged/reordered matrix (and
plotting optionally).
</p>


<h3>Value</h3>

<p>If <code>plot_im = NULL</code>, a list with the following components:
</p>

<dl>
<dt>taxa.names</dt><dd><p>The given <code>taxa_names</code></p>
</dd>
<dt>taxa.ord</dt><dd><p>A vector with the order of the rows/taxa.</p>
</dd>
<dt>tabulated</dt><dd><p>The rearranged/reordered <code>m_bin</code> matrix.</p>
</dd>
<dt>condensed</dt><dd><p>The matrix used to create the &quot;condensed&quot; image.</p>
</dd>
</dl>

<p>If <code>plot_im = "normal"</code>, it returns the above list and, additionally, plots
an image of the tabulated matrix.
If <code>plot_im = "condensed"</code>, it returns the above list and, additionally,
plots an image of the tabulated matrix, but presenting the sets of
differential taxa as solid coloured blocks of equal width.
</p>


<h3>Author(s)</h3>

<p>Tiago Monteiro-Henriques. E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Creating a group partition, as presented in the original article of the
# data set
groups &lt;- rep(c(1, 2, 3), c(3, 11, 19))

# Removing taxa occurring in only one relevé in order to
# reproduce exactly the example in the original article of the data set
taxus_bin_wmt &lt;- taxus_bin[rowSums(taxus_bin) &gt; 1, ]

# Sorting the phytosociological table, putting exclusive taxa in the top and
# plotting an image of it
tabul &lt;- tabulation(
  m_bin = taxus_bin_wmt,
  p = groups,
  taxa_names = rownames(taxus_bin_wmt),
  plot_im = "normal",
  palette = "Zissou 1"
)

# Inspect the first rows and columns of the reordered phytosociological table
head(tabul$tabulated, n = c(5, 5))

</code></pre>

<hr>
<h2 id='taxus_bin'><em>Taxus baccata</em> forests</h2><span id='topic+taxus_bin'></span>

<h3>Description</h3>

<p>A binary phytosociological table containing relevés of <em>Taxus baccata</em>
forests, from the northwest of the Iberian Peninsula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxus_bin
</code></pre>


<h3>Format</h3>

<p>A matrix with 209 rows and 33 columns. Each column corresponds to a
phytosociological relevé and each row corresponds to a taxon. Values in the
matrix denote presences (1) and absences (0).
</p>


<h3>Source</h3>

<p>Portela-Pereira E., Monteiro-Henriques T., Casas C., Forner N.,
Garcia-Cabral I., Fonseca J.P. &amp; Neto C. 2021. <em>Teixedos no noroeste da</em>
<em>Península Ibérica</em>. Finisterra 56(117): 127-150.
<a href="https://doi.org/10.18055/FINIS18102">doi:10.18055/FINIS18102</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Inspect the first rows and columns of taxus_bin
head(taxus_bin, n = c(5, 5))

</code></pre>

<hr>
<h2 id='tdv'>The Total Differential Value of a phytosociological table</h2><span id='topic+tdv'></span>

<h3>Description</h3>

<p>Given a phytosociological table and a partition of its columns, this function
calculates the respective Total Differential Value (TDV).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdv(m_bin, p, output_type = "normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdv_+3A_m_bin">m_bin</code></td>
<td>
<p>A matrix. A phytosociological table of 0s (absences) and 1s
(presences), where rows correspond to taxa and columns correspond to
relevés.</p>
</td></tr>
<tr><td><code id="tdv_+3A_p">p</code></td>
<td>
<p>A vector of integer numbers with the partition of the relevés (i.e.,
a k-partition, consisting in a vector with values from 1 to k, with length
equal to the number of columns of <code>m_bin</code>, ascribing each relevé to one of
the k groups).</p>
</td></tr>
<tr><td><code id="tdv_+3A_output_type">output_type</code></td>
<td>
<p>A character determining the amount of information returned
by the function and also the amount of pre-validations. Possible values are
&quot;normal&quot; (the default), &quot;fast&quot; and &quot;full&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts a phytosociological table (<code>m_bin</code>) and a
k-partition of its columns (<code>p</code>), returning the corresponding TDV.
TDV was proposed by Monteiro-Henriques and Bellu (2014).
Monteiro-Henriques (2016) proposed TDV1, modifying TDV slightly with the
objective of ensuring a value from 0 to 1. Yet, TDV is always within that
range. In practice, both TDV and TDV1 have 0 as possible minimum value
and 1 as possible maximum value, but TDV1 reduces further the contribution
of differential taxa present in more than one group. TDV is then
implemented here, for parsimony.
</p>
<p>TDV is calculated using the <code class="reqn">DiffVal</code> index for each (and all) of the
taxa present in a tabulated phytosociological table <code class="reqn">M</code> (also called
sorted table). <code class="reqn">DiffVal</code> index aims at characterizing how well a taxon
works as a differential taxon in a such tabulated phytosociological table
(for more information on differential taxa see Mueller-Dombois &amp; Ellenberg,
1974).
</p>
<p>An archetypal differential taxon of a certain group <code class="reqn">g</code> of the
partition <code class="reqn">p</code> (a partition on the columns of <code class="reqn">M</code>) is the one
present in all relevés of group <code class="reqn">g</code>, and absent from all the other
groups of that partition. Therefore, <code class="reqn">DiffVal</code> has two components, an
inner one (<code class="reqn">\frac{a}{b}</code>), which measures the presence of the
taxon inside each of the groups, and an outer one (<code class="reqn">\frac{c}{d}</code>),
which measures the relevant absences of the taxon outside of each of the
groups. Specifically, given a partition <code class="reqn">p</code> with <code class="reqn">k</code> groups,
<code class="reqn">DiffVal</code> is calculated for each taxon <code class="reqn">s</code> as:
</p>
<p style="text-align: center;"><code class="reqn">DiffVal_{s,p} = \frac{1}{e}\sum_{g=1}^k{\frac{a}{b}\frac{c}{d}}</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">a</code>, is the total number of presences of taxon <code class="reqn">s</code> within group
<code class="reqn">g</code>.
</p>
</li>
<li> <p><code class="reqn">b</code>, is the total number of relevés of group <code class="reqn">g</code>.
</p>
</li>
<li> <p><code class="reqn">c</code>, is the total number of differentiating absences of taxon
<code class="reqn">s</code>, i.e., absences coming from the groups other than <code class="reqn">g</code> from
which the taxon <code class="reqn">s</code> is completely absent.
</p>
</li>
<li> <p><code class="reqn">d</code>, is the total number of relevés of all groups but <code class="reqn">g</code> (i.e.,
the total number of relevés in the table - <code class="reqn">b</code>).
</p>
</li>
<li> <p><code class="reqn">e</code>, is the total number of groups in which the taxon <code class="reqn">s</code> occurs
at least once.
</p>
</li></ul>

<p>Therefore, for each taxon <code class="reqn">s</code> and for each group <code class="reqn">g</code>, the
<code class="reqn">DiffVal</code> index evaluates:
</p>

<ul>
<li> <p><code class="reqn">\frac{a}{b}</code>, i.e., the frequency of the presences of taxon
<code class="reqn">s</code>, relative to the size of group <code class="reqn">g</code>; commonly called 'relative
frequency.' <code class="reqn">\frac{a}{b}</code> is only 1 if and only if taxon <code class="reqn">s</code>
occurs in all the relevés of group <code class="reqn">g</code>.
</p>
</li>
<li> <p><code class="reqn">\frac{c}{d}</code>, i.e., the frequency of the differentiating
absences of taxon <code class="reqn">s</code> outside group <code class="reqn">g</code>, relative to the sum of
sizes of all groups but <code class="reqn">g</code>. <em>Nota bene</em>: absences in <code class="reqn">c</code> are
counted outside the group <code class="reqn">g</code> but only in the groups from which taxon
<code class="reqn">s</code> is completely absent (these are the relevant absences, which
produce differentiation among groups); in practice <code class="reqn">c</code> corresponds to
the sum of the sizes of all groups other than <code class="reqn">g</code> that are empty.
<code class="reqn">\frac{c}{d}</code> is 1 if and only if the taxon <code class="reqn">s</code> is absent
from all groups but <code class="reqn">g</code>.
</p>
</li></ul>

<p>Finally, <code class="reqn">\frac{1}{e}</code> ensures that <code class="reqn">DiffVal</code> is a value
from 0 to 1.
</p>
<p>The Total Differential Value (TDV or <code class="reqn">TotDiffVal</code>) of a
phytosociological table <code class="reqn">M</code> tabulated/sorted by the partition <code class="reqn">p</code>
is:
</p>
<p style="text-align: center;"><code class="reqn">TDV_{M,p} = \frac{1}{n}\sum_{i=1}^n{Diffval_{i,p}}</code>
</p>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">n</code>, is the number of taxa in table <code class="reqn">M</code>.
</p>
</li></ul>

<p>The division by the number of taxa present in <code class="reqn">M</code> ensures that TDV
remains in the [0,1] interval (as <code class="reqn">DiffVal</code> is also in the same
interval).
</p>


<h3>Value</h3>

<p>If <code>output_type = "normal"</code> (the default) pre-validations are done
and a list is returned, with the following components:
</p>

<dl>
<dt>ifp</dt><dd><p>A matrix with the <code class="reqn">\frac{a}{b}</code> values for each taxon
in each group, for short called the 'inner frequency of presences'.</p>
</dd>
<dt>ofda</dt><dd><p>A matrix with the <code class="reqn">\frac{c}{d}</code> values for each
taxon in each group, for short called the 'outer frequency of
differentiating absences'.</p>
</dd>
<dt>e</dt><dd><p>A vector with the <code class="reqn">e</code> values for each taxon, i.e., the
number of groups containing that taxon.</p>
</dd>
<dt>diffval</dt><dd><p>A matrix with the <code class="reqn">DiffVal</code> for each taxon.</p>
</dd>
<dt>tdv</dt><dd><p>A numeric with the TDV of matrix <code style="white-space: pre;">&#8288;m_bin,&#8288;</code> given the partition
<code>p</code>.</p>
</dd>
</dl>

<p>If <code>output_type = "full"</code>, some extra components are added to the output:
<code>afg</code>, <code>empty.size</code>, <code>gct</code> (= <code class="reqn">e</code>) and <code>i.mul</code>. These are intermediate
matrices used in the computation of TDV.
</p>
<p>If <code>output_type = "fast"</code>, only TDV is returned and no pre-validations are
done.
</p>


<h3>Author(s)</h3>

<p>Tiago Monteiro-Henriques. E-mail: <a href="mailto:tmh.dev@icloud.com">tmh.dev@icloud.com</a>.
</p>


<h3>References</h3>

<p>Monteiro-Henriques T. &amp; Bellu A. 2014. <em>An optimization approach to the</em>
<em>production of differentiated tables based on new differentiability</em>
<em>measures</em>. 23rd EVS European Vegetation Survey. Presented orally. Ljubljana,
Slovenia.
</p>
<p>Monteiro-Henriques T. 2016. <em>A bunch of R functions to assist</em>
<em>phytosociological tabulation</em>. 25th Meeting of European Vegetation Survey.
Presented in poster. Rome. Italy.
</p>
<p>Mueller-Dombois D. &amp; Ellenberg H. 1974. <em>Aims and Methods of Vegetation</em>
<em>Ecology</em>. New York: John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Getting the Taxus baccata forests data set
data(taxus_bin)

# Creating a group partition, as the one presented in the original article of
# the data set
groups &lt;- rep(c(1, 2, 3), c(3, 11, 19))

# Removing taxa occurring in only one relevé, in order to reproduce exactly
# the example in the original article of the data set
taxus_bin_wmt &lt;- taxus_bin[rowSums(taxus_bin) &gt; 1, ]

# Calculating TDV
result &lt;- tdv(taxus_bin_wmt, groups)

# This is the TDV
result$tdv
# This is TDV1, reproducing exactly the value from the original article
sum(result$diffval / result$e) / nrow(taxus_bin_wmt)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
