<!DOCTYPE html><html><head><title>Help for package robustrank</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robustrank}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#choose.test'>
<p>Make Recommendations on the Most Powerful Test to Use</p></a></li>
<li><a href='#dat.mtct.rob'>
<p>Example Dataset</p></a></li>
<li><a href='#mod.wmw.test'>
<p>Modified Wilcoxon-Mann-Whitney Test</p></a></li>
<li><a href='#multinom.test'>
<p>Multinom Test</p></a></li>
<li><a href='#mw.mw.2.perm'>
<p>A Test that Combines WMW for Paired Data and WMW for Unpaired Data</p></a></li>
<li><a href='#pair.wmw.test'>
<p>WMW test for paired data</p></a></li>
<li><a href='#pm.wilcox.test'>
<p>Wilcoxon test for Partially Matched Two Sample Data</p></a></li>
<li><a href='#robustrank'><p>robustrank</p></a></li>
<li><a href='#sim.partially.matched'>
<p>Simulate Paired, Independent, or Partially Matched Two-Sample Data</p></a></li>
<li><a href='#wmw.paired.replicates.test'>
<p>WMW Paired Replicates Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Version:</td>
<td>2024.1-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Rank-Based Tests</td>
</tr>
<tr>
<td>Author:</td>
<td>Youyi Fong &lt;youyifong@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Youyi Fong &lt;youyifong@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), kyotil</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, VGAM, copula, mvtnorm, pracma</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements two-sample tests for paired data with missing values (Fong, Huang, Lemos and McElrath 2018, Biostatics, &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxx039">doi:10.1093/biostatistics/kxx039</a>&gt;) and modified Wilcoxon-Mann-Whitney two sample location test, also known as the Fligner-Policello test. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-28 05:17:55 UTC; Youyi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-28 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='choose.test'>
Make Recommendations on the Most Powerful Test to Use
</h2><span id='topic+choose.test'></span>

<h3>Description</h3>

<p>Performs simulations to compare the power of different tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose.test(Xpaired, Ypaired, Xextra = NULL, Yextra = NULL, mc.rep = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choose.test_+3A_xpaired">Xpaired</code></td>
<td>

<p>Xpaired
</p>
</td></tr>
<tr><td><code id="choose.test_+3A_ypaired">Ypaired</code></td>
<td>

<p>Ypaired
</p>
</td></tr>
<tr><td><code id="choose.test_+3A_xextra">Xextra</code></td>
<td>

<p>Xextra
</p>
</td></tr>
<tr><td><code id="choose.test_+3A_yextra">Yextra</code></td>
<td>

<p>Yextra
</p>
</td></tr>
<tr><td><code id="choose.test_+3A_mc.rep">mc.rep</code></td>
<td>

<p>mc.rep
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# There are unpaired observations from both samples
dat=sim.partially.matched(m=20,n.x=40,n.y=5,distr="normal",
    params=c(loc.2=.8,rho=.1,scale.2=1),seed=1)
choose.test(dat$X, dat$Y, dat$Xprime, dat$Yprime)

## There are unpaired observations from only one sample
#dat=sim.partially.matched(m=20,n.x=0,n.y=10,distr="normal",
#    params=c(loc.2=.5,rho=.8,scale.2=1),seed=1)
#choose.test(dat$X, dat$Y, dat$Xprime, dat$Yprime)


</code></pre>

<hr>
<h2 id='dat.mtct.rob'>
Example Dataset
</h2><span id='topic+dat.mtct.rob'></span>

<h3>Description</h3>

<p>from MTCT correlates study, C-section only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dat.mtct.rob")</code></pre>


<h3>Format</h3>

<p>A data frame with 55 observations on the following 2 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>V3_BioV3B_500</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Fong and Huang (2016) Modified Wilcoxon-Mann-Whitney Test and Power against Strong Null.
</p>

<hr>
<h2 id='mod.wmw.test'>
Modified Wilcoxon-Mann-Whitney Test
</h2><span id='topic+mod.wmw.test'></span>

<h3>Description</h3>

<p>Also known as the Fligner-Policello test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod.wmw.test(X, Y, alternative = c("two.sided", "less", "greater"),
         correct = TRUE, perm = NULL, mc.rep = 10000, method =
         c("combine", "comb2", "fp", "wmw", "fplarge", "nsm3"),
         verbose = FALSE, mode = c("test", "var"), useC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod.wmw.test_+3A_x">X</code></td>
<td>

<p>Samples from population 1.
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_y">Y</code></td>
<td>

<p>Samples from population 2.
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_alternative">alternative</code></td>
<td>

<p>Directon of the alternative hypothesis.
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_correct">correct</code></td>
<td>

<p>Whether to do continutiy correction.
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_perm">perm</code></td>
<td>

<p>Boolean, whether to do permutation to get p-value or use normal approximation. See details.
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_mc.rep">mc.rep</code></td>
<td>

<p>Default number of replicates when doing permutation. See details.
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_method">method</code></td>
<td>

<p>For development.
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_verbose">verbose</code></td>
<td>

<p>For development. Print some debug info.
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_mode">mode</code></td>
<td>

<p>For development. 
</p>
</td></tr>
<tr><td><code id="mod.wmw.test_+3A_usec">useC</code></td>
<td>

<p>For development. Run C or R implementation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When perm is null, we will compute permutation-based p values if either sample size is less than 20 and compute normal approximation-based p values otherwise.
When doing permuation, if the possible number of combinations is less than mc.rep, every possible configuration is done.
</p>


<h3>Value</h3>

<p>A p value for now.
</p>


<h3>References</h3>

<p>manuscript in preperation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 4.1, Hollander, Wolfe and Chicken (2014) Nonparameteric Statistics
X &lt;- c(0.80, 0.83, 1.89, 1.04, 1.45, 1.38, 1.91, 1.64, 0.73, 1.46)
Y &lt;- c(1.15, 0.88, 0.90, 0.74, 1.21)
mod.wmw.test(X, Y, method="wmw", alternative="greater")
mod.wmw.test(X, Y, method="combine", alternative="greater", verbose=1)

# Section 4.1 Problem 1, Hollander et al. 
X=c(1651,1112,102.4,100,67.6,65.9,64.7,39.6,31.0)
Y=c(48.1,48.0,45.5,41.7,35.4,34.3,32.4,29.1,27.3,18.9,6.6,5.2,4.7)
mod.wmw.test(X, Y, method="wmw")
mod.wmw.test(X, Y, method="combine", verbose=1)

# Section 4.1 Problem 5, Hollander et al. 
X=c(12 ,44 ,34 ,14 ,9  ,19 ,156,23 ,13 ,11 ,47 ,26 ,14 ,33 ,15 ,62 ,5  ,8  ,0  ,154,146)
Y=c(37,39,30,7,13,139, 45,25,16,146,94,16,23,1,290,169,62,145,36, 20, 13)
mod.wmw.test(X, Y, method="wmw", alternative="less")
mod.wmw.test(X, Y, method="combine", alternative="less", verbose=1)

# Section 4.1 Problem 15, Hollander et al. 
X=c(0.19,0.14,0.02,0.44,0.37)
Y=c(0.89,0.76,0.63,0.69,0.58,0.79,0.02,0.79)
mod.wmw.test(X, Y, method="wmw")
mod.wmw.test(X, Y, method="combine", verbose=1)

# Table 4.7, Hollander et al. 
X=c(297,340,325,227,277,337,250,290)
Y=c(293,291,289,430,510,353,318)
mod.wmw.test(X, Y, method="wmw", alternative="less")
mod.wmw.test(X, Y, method="combine", alternative="less", verbose=1)


</code></pre>

<hr>
<h2 id='multinom.test'>
Multinom Test
</h2><span id='topic+multinom.test'></span>

<h3>Description</h3>

<p>Perform multinom test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom.test(X, Y, alternative = c("two.sided", "less", "greater"),
         correct = FALSE, perm = NULL, mc.rep = 10000, method =
         c("exact.2", "large.0", "large", "exact", "exact.0",
         "exact.1", "exact.3"), verbose = FALSE, mode =
         c("test", "var"), useC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinom.test_+3A_x">X</code></td>
<td>

<p>X
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_y">Y</code></td>
<td>

<p>Y
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_alternative">alternative</code></td>
<td>

<p>alternative
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_correct">correct</code></td>
<td>

<p>correct
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_perm">perm</code></td>
<td>

<p>perm
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_mc.rep">mc.rep</code></td>
<td>

<p>mc.rep
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_method">method</code></td>
<td>

<p>method
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_verbose">verbose</code></td>
<td>

<p>verbose
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_mode">mode</code></td>
<td>

<p>mode
</p>
</td></tr>
<tr><td><code id="multinom.test_+3A_usec">useC</code></td>
<td>

<p>useC
</p>
</td></tr>
</table>

<hr>
<h2 id='mw.mw.2.perm'>
A Test that Combines WMW for Paired Data and WMW for Unpaired Data
</h2><span id='topic+mw.mw.2.perm'></span>

<h3>Description</h3>

<p>Use permutation-based reference distribution to obtain p values for a test that combines WMW for paired data and WMW for unpaired data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mw.mw.2.perm(X, Y, Xprime, Yprime, .corr, mc.rep = 10000, 
    alternative = c("two.sided", "less", "greater"), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mw.mw.2.perm_+3A_x">X</code></td>
<td>

<p>X
</p>
</td></tr>
<tr><td><code id="mw.mw.2.perm_+3A_y">Y</code></td>
<td>

<p>Y
</p>
</td></tr>
<tr><td><code id="mw.mw.2.perm_+3A_xprime">Xprime</code></td>
<td>

<p>Xprime
</p>
</td></tr>
<tr><td><code id="mw.mw.2.perm_+3A_yprime">Yprime</code></td>
<td>

<p>Yprime
</p>
</td></tr>
<tr><td><code id="mw.mw.2.perm_+3A_.corr">.corr</code></td>
<td>

<p>.corr
</p>
</td></tr>
<tr><td><code id="mw.mw.2.perm_+3A_mc.rep">mc.rep</code></td>
<td>

<p>mc.rep
</p>
</td></tr>
<tr><td><code id="mw.mw.2.perm_+3A_alternative">alternative</code></td>
<td>

<p>alternative
</p>
</td></tr>
<tr><td><code id="mw.mw.2.perm_+3A_verbose">verbose</code></td>
<td>

<p>verbose
</p>
</td></tr>
</table>

<hr>
<h2 id='pair.wmw.test'>
WMW test for paired data
</h2><span id='topic+pair.wmw.test'></span>

<h3>Description</h3>

<p>Performs a WMW-type test of the strong null for paired data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.wmw.test(X, Y, alternative = c("two.sided", "less", "greater"),
 correct = TRUE, perm = NULL, mc.rep = 10000, method =
 c("exact.2", "large.0", "large", "exact", "exact.0",
 "exact.1", "exact.3"), verbose = FALSE, mode =
 c("test", "var"), p.method = NULL, useC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.wmw.test_+3A_x">X</code></td>
<td>

<p>Sample 1.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_y">Y</code></td>
<td>

<p>Sample 2. 
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_alternative">alternative</code></td>
<td>

<p>Alternative hypothesis.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_correct">correct</code></td>
<td>

<p>Whether to apply continuity correction.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_perm">perm</code></td>
<td>

<p>Whether to use permutation distribution or normal approximation to find p-value. See details.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_mc.rep">mc.rep</code></td>
<td>

<p>Number of Monte Carlo replicates for permutation test.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_method">method</code></td>
<td>

<p>Choices of test statistics.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_verbose">verbose</code></td>
<td>

<p>Print debug message when positive.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_mode">mode</code></td>
<td>

<p>For development used.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_usec">useC</code></td>
<td>

<p>For development used.
</p>
</td></tr>
<tr><td><code id="pair.wmw.test_+3A_p.method">p.method</code></td>
<td>

<p>Method for obtaining p values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When perm is NULL, if (min(m,n)&gt;=20) normal approximatino is used to find p value, otherwise permutation test is used.
When permutation test is used, if the number of possible permutations is less than mc.rep, a test statistic is computed for all permutations; otherwise, Monte Carlo is done.
</p>


<h3>Value</h3>

<p>P value for now.
</p>


<h3>References</h3>

<p>Under prep.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat=sim.partially.matched(m=15,n.x=0,n.y=20,distr="mixnormal",params=c(p.1=0.3,p.2=0.3),seed=1)
X=dat$X; Y=dat$Y
pair.wmw.test(X, Y, perm=TRUE,  method="large.0", verbose=1)
pair.wmw.test(X, Y, perm=FALSE, method="large.0", verbose=1)

</code></pre>

<hr>
<h2 id='pm.wilcox.test'>
Wilcoxon test for Partially Matched Two Sample Data
</h2><span id='topic+pm.wilcox.test'></span>

<h3>Description</h3>

<p>Performs rank-based two sample test for partially matched two sample data by combining information from matched and unmatched data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pm.wilcox.test(Xpaired, Ypaired, Xextra = NULL, Yextra = NULL,
 alternative = c("two.sided", "less", "greater"),
 method = c("SR-MW", "MW-MW", "all"), mode = c("test",
 "var", "power.study"), useC = FALSE, correct = NULL,
 verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pm.wilcox.test_+3A_xpaired">Xpaired</code></td>
<td>

<p>Xpaired
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_ypaired">Ypaired</code></td>
<td>

<p>Ypaired
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_xextra">Xextra</code></td>
<td>

<p>Xextra
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_yextra">Yextra</code></td>
<td>

<p>Yextra
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_alternative">alternative</code></td>
<td>

<p>alternative
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_method">method</code></td>
<td>

<p>String. SR-MW is recommended, all is for development only.
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_mode">mode</code></td>
<td>

<p>String. Do not change it to var, for developpment only.
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_usec">useC</code></td>
<td>

<p>Boolean. Do not set it to TRUE, for development only.
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_verbose">verbose</code></td>
<td>

<p>verbose
</p>
</td></tr>
<tr><td><code id="pm.wilcox.test_+3A_correct">correct</code></td>
<td>

<p>Continuity correction.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If Xpaired and Ypaired have NAs, the corresponding unpaired data in Ypaired and Xpaired will be combined with Yextra and Xextra.
</p>


<h3>Value</h3>

<p>An htest object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
z=rnorm(20, sd=0.5) # induces correlation between X and Y
X=rnorm(20)+z
Y=rnorm(20,mean=0.8)+z
X[1:10]=NA
boxplot(X,Y,names=c("X","Y"))

pm.wilcox.test(X,Y)
# for comparison
wilcox.test(X,Y,paired=TRUE)
wilcox.test(X,Y,paired=FALSE)# often a conservative test due to the correlation

# no paired data
Y1=Y
Y1[11:20]=NA
pm.wilcox.test(X,Y1)
# should match the following
wilcox.test(X,Y1,paired=FALSE)

# only 1 pair of matched data
Y1=Y
Y1[12:20]=NA
pm.wilcox.test(X,Y1)


</code></pre>

<hr>
<h2 id='robustrank'>robustrank</h2><span id='topic+robustrank'></span>

<h3>Description</h3>

<p>Please see the Index link below for a list of available functions.
</p>

<hr>
<h2 id='sim.partially.matched'>
Simulate Paired, Independent, or Partially Matched Two-Sample Data
</h2><span id='topic+r2sample'></span><span id='topic+sim.paired.with.replicates'></span><span id='topic+sim.partially.matched'></span>

<h3>Description</h3>

<p>sim.partially.matched generates partially matched two-sample data.  for Monte Carlo studies. 
r2sample is a wrapper for sim.partially.matched and generates indepenent two-sample data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.partially.matched(m, n.x, n.y, 
distr = c("normal","logistic","student","mixnormal","gamma","lognormal","beta",
    "uniform","hybrid1","hybrid2","doublexp"), params, seed)

r2sample(m, n, 
distr = c("normal", "logistic", "student", "mixnormal"), params, seed)

sim.paired.with.replicates(m, meanRatio, sdRatio, within.sd, type, hyp, distr, seed)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.partially.matched_+3A_m">m</code></td>
<td>

<p>Number of pairs.
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_n">n</code></td>
<td>

<p>Number of Ys.
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_n.x">n.x</code></td>
<td>

<p>Number of extra Xs.
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_n.y">n.y</code></td>
<td>

<p>Number of extra Ys.
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_distr">distr</code></td>
<td>

<p>Distributions.
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_params">params</code></td>
<td>

<p>Named vector. See details.
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_seed">seed</code></td>
<td>

<p>Seed for random number generator.
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_meanratio">meanRatio</code></td>
<td>

<p>meanRatio
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_sdratio">sdRatio</code></td>
<td>

<p>sdRatio
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_within.sd">within.sd</code></td>
<td>

<p>within.sd
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_type">type</code></td>
<td>

<p>type
</p>
</td></tr>
<tr><td><code id="sim.partially.matched_+3A_hyp">hyp</code></td>
<td>

<p>hyp
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the distribution is in <code>c("normal","student","logistic")</code>, <code>params</code> should have three fields: loc.2, rho and scale.2; loc.1 is set to 0 and scale.1 is set to 1.
</p>
<p>If the distribution is mixnormal, <code>params</code> should have three fields: p.1, p.2 and sd.n. 
</p>
<p>If the distribution is gamma, <code>params</code> should have fix fields: loc.2, shape.1, shape.2, rate.1, rate.2 and rho.
</p>
<p>For details on bivariate logistic distribution, see <code>rbilogistic</code>
</p>


<h3>Value</h3>

<p>sim.partially.matched return a list with the following components:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>m sample 1 that pair with Y</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>m sample 2 that pair with X</p>
</td></tr>
<tr><td><code>Xprime</code></td>
<td>
<p>n.x sample 1</p>
</td></tr>
<tr><td><code>Yprime</code></td>
<td>
<p>n.y sample 2</p>
</td></tr>
</table>
<p>r2sample returns a list with the following components:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>m sample 1 that are independent of Y</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>n sample 2 that are independent of X</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dat=sim.partially.matched(m=10,n.x=5,n.y=4,distr="normal",
    params=c("loc.2"=0,"rho"=0,"scale.2"=1),seed=1)
X=dat$X; Y=dat$Y; Yprime=dat$Yprime    

#dat=sim.partially.matched(m=10,n.x=5,n.y=4,distr="logistic",
#    params=c("loc.2"=0,"rho"=0,"scale.2"=1),seed=1)
#X=dat$X; Y=dat$Y; Yprime=dat$Yprime    


</code></pre>

<hr>
<h2 id='wmw.paired.replicates.test'>
WMW Paired Replicates Test
</h2><span id='topic+wmw.paired.replicates.test'></span>

<h3>Description</h3>

<p>Perform WMW paired replicates test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wmw.paired.replicates.test(X, Y, alternative = c("two.sided", "less", "greater"),
 correct = FALSE, perm = NULL, mc.rep = 10000, method =
 c("exact.2", "large.0", "large", "exact", "exact.0",
 "exact.1", "exact.3"), verbose = FALSE, mode =
 c("test", "var"), useC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmw.paired.replicates.test_+3A_x">X</code></td>
<td>

<p>X
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_y">Y</code></td>
<td>

<p>Y
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_alternative">alternative</code></td>
<td>

<p>alternative
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_correct">correct</code></td>
<td>

<p>correct
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_perm">perm</code></td>
<td>

<p>perm
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_mc.rep">mc.rep</code></td>
<td>

<p>mc.rep
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_method">method</code></td>
<td>

<p>method
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_verbose">verbose</code></td>
<td>

<p>verbose
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_mode">mode</code></td>
<td>

<p>mode
</p>
</td></tr>
<tr><td><code id="wmw.paired.replicates.test_+3A_usec">useC</code></td>
<td>

<p>useC
</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
