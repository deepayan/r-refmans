<!DOCTYPE html><html lang="en"><head><title>Help for package geex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geex-package'><p>geex: M-estimation API</p></a></li>
<li><a href='#approx_control-class'><p>approx_control S4 class</p></a></li>
<li><a href='#basic_control-class'><p>basic_control S4 class</p></a></li>
<li><a href='#coef+2Cgeex-method'><p>Gets the parameter estimates from a geex object</p></a></li>
<li><a href='#compute_pairwise_sum_of_list'><p>Compute the sum of  a list of matrices to sum</p></a></li>
<li><a href='#compute_sigma'><p>Compute empirical sandwich covariate estimator</p></a></li>
<li><a href='#compute_sum_of_list'><p>Compute the sum of  a list of matrices to sum</p></a></li>
<li><a href='#correct_by'><p>Correct sandwich components</p></a></li>
<li><a href='#correct_control-class'><p>correct_control S4 class</p></a></li>
<li><a href='#correction'><p>Creates a correct_control object</p></a></li>
<li><a href='#create_basis'><p>Creates an m_estimation_basis object</p></a></li>
<li><a href='#create_GFUN'><p>Creates a function that sums over psi functions</p></a></li>
<li><a href='#create_psiFUN_list'><p>Creates list of psi functions</p></a></li>
<li><a href='#deriv_control-class'><p>deriv_control S4 class</p></a></li>
<li><a href='#diagnose_roots'><p>Diagnose roots of estimating equations</p></a></li>
<li><a href='#estimate_GFUN_roots'><p>Estimate roots for a set of estimating equations</p></a></li>
<li><a href='#estimate_sandwich_matrices'><p>Estimate component matrices of the empirical sandwich covariance estimator</p></a></li>
<li><a href='#estimating_function-class'><p>estimating_function S4 class</p></a></li>
<li><a href='#fay_bias_correction'><p>Correct sandwich variance estimator byFay's bias correction</p></a></li>
<li><a href='#fay_df_correction'><p>Correct sandwich variance inference by Fay's degrees of freedom correction</p></a></li>
<li><a href='#geex_control-class'><p>geex_control S4 class</p></a></li>
<li><a href='#geex_summary-class'><p>geex summary object</p></a></li>
<li><a href='#geex-class'><p>geex S4 class</p></a></li>
<li><a href='#geexex'><p>Dataset used to illustrate Stefanski and Boos examples.</p></a></li>
<li><a href='#get_corrections'><p>Gets the corrections from a geex object</p></a></li>
<li><a href='#grab'><p>Grab something from an object</p></a></li>
<li><a href='#grab_bread'><p>Grabs the .A (bread matrix) slot</p></a></li>
<li><a href='#grab_bread_list'><p>Gets the .A_i (list of bread matrices) slot</p></a></li>
<li><a href='#grab_design_levels'><p>Grab a list of the levels of factor variables in a model.</p></a></li>
<li><a href='#grab_design_matrix'><p>Grab a matrix of fixed effects from a model object</p></a></li>
<li><a href='#grab_ee_list'><p>Gets the .ee_i (observed estimating function) slot</p></a></li>
<li><a href='#grab_estFUN'><p>Grab estimating functions from a model object</p></a></li>
<li><a href='#grab_fixed_formula'><p>Grab the RHS formula from a model object</p></a></li>
<li><a href='#grab_GFUN'><p>Gets the .psi_list slot in a m_estimation_basis</p></a></li>
<li><a href='#grab_meat'><p>Gets the .B (meat matrix) slot</p></a></li>
<li><a href='#grab_meat_list'><p>Gets the .B_i (list of bread matrices) slot</p></a></li>
<li><a href='#grab_psiFUN'><p>Grab estimating functions from a model object</p></a></li>
<li><a href='#grab_psiFUN_list'><p>Gets the .psi_list slot in a m_estimation_basis</p></a></li>
<li><a href='#grab_response'><p>Grab a vector of responses from a model object</p></a></li>
<li><a href='#grab_response_formula'><p>Grab the LHS formula from a model object</p></a></li>
<li><a href='#m_estimate'><p>Estimate parameters and their covariance from a set of estimating equations</p></a></li>
<li><a href='#m_estimation_basis-class'><p>m_estimation_basis S4 class</p></a></li>
<li><a href='#nobs+2Cgeex-method'><p>Extract the number observations</p></a></li>
<li><a href='#root_control-class'><p>root_control S4 class</p></a></li>
<li><a href='#roots'><p>Gets the parameter estimates matrix from a geex object</p></a></li>
<li><a href='#sandwich_components-class'><p>sandwich_components S4 class</p></a></li>
<li><a href='#setup_approx_control'><p>Setup an approx_control object</p></a></li>
<li><a href='#setup_control'><p>Setup a basic_control object</p></a></li>
<li><a href='#setup_deriv_control'><p>Setup a deriv_control object</p></a></li>
<li><a href='#setup_root_control'><p>Setup a root_control object</p></a></li>
<li><a href='#show'><p>Show (print) the S4 geex classes</p></a></li>
<li><a href='#summary+2Cgeex-method'><p>Object Summaries</p></a></li>
<li><a href='#vcov+2Cgeex-method'><p>Gets the variance-covariance matrix from a geex object</p></a></li>
<li><a href='#weights+2Cgeex-method'><p>Extract Model weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An API for M-Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Bradley Saul [aut, cre],
  Brian Barkley [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bradley Saul &lt;bradleysaul@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a general, flexible framework for estimating parameters
    and empirical sandwich variance estimator from a set of unbiased estimating
    equations (i.e., M-estimation in the vein of Stefanski &amp; Boos (2002)
    &lt;<a href="https://doi.org/10.1198%2F000313002753631330">doi:10.1198/000313002753631330</a>&gt;). All examples from Stefanski &amp; Boos (2002)
    are published in the corresponding Journal of Statistical Software paper
    "The Calculus of M-Estimation in R with geex" by Saul &amp; Hudgens (2020)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v092.i02">doi:10.18637/jss.v092.i02</a>&gt;. Also provides an API to compute finite-sample 
    variance corrections.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.2-6), rootSolve (&ge; 1.6.6), numDeriv (&ge;
2014.2-1), lme4 (&ge; 1.1-12), methods (&ge; 3.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, dplyr, moments, sandwich, inferference,
xtable, AER, ICSNP, MASS, gee, saws, rmarkdown, geepack, covr,
mvtnorm</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bsaul/geex">https://github.com/bsaul/geex</a>, <a href="https://bsaul.github.io/geex/">https://bsaul.github.io/geex/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bsaul/geex/issues">https://github.com/bsaul/geex/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-24 16:01:38 UTC; bradley.saul</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-08 10:40:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='geex-package'>geex: M-estimation API</h2><span id='topic+geex'></span><span id='topic+geex-package'></span>

<h3>Description</h3>

<p>geex provides an extensible API for estimating parameters and their covariance
from a set of estimating functions (M-estimation). M-estimation theory has a
long history [see reference in the M-estimation bibliography:
<a href="https://bsaul.github.io/geex/articles/articles/mestimation_bib.html">https://bsaul.github.io/geex/articles/articles/mestimation_bib.html</a>.
For an excellent introduction, see the primer by L.A. Stefanski and D.D. Boos,
&quot;The Calculus of M-estimation&quot; (The American Statistician (2002), 56(1), 29-38)
(<a href="http://www.jstor.org/stable/3087324">http://www.jstor.org/stable/3087324</a>).
</p>


<h3>Details</h3>

<p>M-estimation encompasses a broad swath of statistical estimators and ideas including:
</p>

<ul>
<li><p> the empirical &quot;sandwich&quot; variance estimator
</p>
</li>
<li><p> generalized estimating equations (GEE)
</p>
</li>
<li><p> many maximum likelihood estimators
</p>
</li>
<li><p> robust regression
</p>
</li>
<li><p> and many more</p>
</li></ul>

<p>geex can implement all of these using a user-defined estimating function.
</p>
<p>To learn more about geex, see the package vignettes: <code>browseVignettes(package = 'geex')</code>.
</p>


<h3>Goals</h3>

<p>If you can specify a set of unbiased estimating equations, geex does the rest.
The goals of geex are simply:
</p>

<ul>
<li><p> To minimize the translational distance between a set of estimating
functions and R code;
</p>
</li>
<li><p> To return numerically accurate point and covariance estimates from
a set of unbiased estimating functions.
</p>
</li></ul>

<p>geex does not, by itself, necessarily aim to be fast nor precise. Such goals
are left to the user to implement or confirm.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Bradley Saul <a href="mailto:bradleysaul@gmail.com">bradleysaul@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Brian Barkley [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Saul, Bradley C., and Michael G. Hudgens. (2020).
&quot;The Calculus of M-estimation in R with geex.&quot; Journal of Statistical Software 92(2), 1-15.
doi: <a href="https://doi.org/10.18637/jss.v092.i02">10.18637/jss.v092.i02</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bsaul/geex">https://github.com/bsaul/geex</a>
</p>
</li>
<li> <p><a href="https://bsaul.github.io/geex/">https://bsaul.github.io/geex/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bsaul/geex/issues">https://github.com/bsaul/geex/issues</a>
</p>
</li></ul>


<hr>
<h2 id='approx_control-class'>approx_control S4 class</h2><span id='topic+approx_control-class'></span>

<h3>Description</h3>

<p>EXPERIMENTAL. See example 7 in <code>vignette("01_additional_examples", package = "geex")</code>
for usage.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.FUN</code></dt><dd><p>a function which approximates an <code>estFUN</code>.</p>
</dd>
<dt><code>.options</code></dt><dd><p>a list of options passed to <code>.FUN</code>.</p>
</dd>
</dl>

<hr>
<h2 id='basic_control-class'>basic_control S4 class</h2><span id='topic+basic_control-class'></span>

<h3>Description</h3>

<p>A general class for defining a <code>function</code>, and the options passed to the
function
</p>


<h3>Slots</h3>


<dl>
<dt><code>.FUN</code></dt><dd><p>a function</p>
</dd>
<dt><code>.options</code></dt><dd><p>a list of options passed to <code>.FUN</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+root_control-class">root_control-class</a></code>, <code><a href="#topic+deriv_control-class">deriv_control-class</a></code>
<code><a href="#topic+approx_control-class">approx_control-class</a></code>
</p>

<hr>
<h2 id='coef+2Cgeex-method'>Gets the parameter estimates from a geex object</h2><span id='topic+coef+2Cgeex-method'></span><span id='topic+coef+2Cgeex+2Cgeex-method'></span><span id='topic+coef+2Cgeex_summary-method'></span>

<h3>Description</h3>

<p>Gets the parameter estimates from a geex object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'geex'
coef(object)

## S4 method for signature 'geex_summary'
coef(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef+2B2Cgeex-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+geex-class">geex</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ex_eeFUN &lt;- function(data){
 function(theta){
   with(data,
    c(Y1 - theta[1],
     (Y1 - theta[1])^2 - theta[2] ))
}}

results &lt;- m_estimate(
 estFUN = ex_eeFUN,
 data  = geexex,
 root_control = setup_root_control(start = c(1,1)))

coef(results)
</code></pre>

<hr>
<h2 id='compute_pairwise_sum_of_list'>Compute the sum of  a list of matrices to sum</h2><span id='topic+compute_pairwise_sum_of_list'></span>

<h3>Description</h3>

<p>Compute the sum of  a list of matrices to sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_pairwise_sum_of_list(.l, .w = NULL, .wFUN = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_pairwise_sum_of_list_+3A_.l">.l</code></td>
<td>
<p>a list of matrices</p>
</td></tr>
<tr><td><code id="compute_pairwise_sum_of_list_+3A_.w">.w</code></td>
<td>
<p>a numeric vector of weights</p>
</td></tr>
<tr><td><code id="compute_pairwise_sum_of_list_+3A_.wfun">.wFUN</code></td>
<td>
<p>a function of <code>i</code>, <code>j</code>, and (optionally) additional
arguments</p>
</td></tr>
<tr><td><code id="compute_pairwise_sum_of_list_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>.wFUN</code>
</p>
<p>Either <code>.w</code> or <code>.wFUN</code> must be specified but not both.</p>
</td></tr>
</table>

<hr>
<h2 id='compute_sigma'>Compute empirical sandwich covariate estimator</h2><span id='topic+compute_sigma'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">\Sigma = A^{-1} B (A^{-1})^T </code> with
provided <code class="reqn">A</code> and <code class="reqn">B</code> matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_sigma(A, B, solver = solve)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_sigma_+3A_a">A</code></td>
<td>
<p>a matrix, generally the <code>.A</code> slot in a
<code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object created in
<code><a href="#topic+estimate_sandwich_matrices">estimate_sandwich_matrices</a></code></p>
</td></tr>
<tr><td><code id="compute_sigma_+3A_b">B</code></td>
<td>
<p>a matrix, generally the <code>.B</code> slot in a
<code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object created in
<code><a href="#topic+estimate_sandwich_matrices">estimate_sandwich_matrices</a></code></p>
</td></tr>
<tr><td><code id="compute_sigma_+3A_solver">solver</code></td>
<td>
<p>the function used to compute the inverse of <code>A</code>, Defaults
to <code><a href="base.html#topic+solve">solve</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>matrix</code> <code>Ainv %*% B %*% t(Ainv)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag(2, nrow = 2, ncol = 2)
B &lt;- matrix(4, nrow = 2, ncol = 2)
compute_sigma(A = A, B = B)
</code></pre>

<hr>
<h2 id='compute_sum_of_list'>Compute the sum of  a list of matrices to sum</h2><span id='topic+compute_sum_of_list'></span>

<h3>Description</h3>

<p>Compute the sum of  a list of matrices to sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_sum_of_list(.l, .w = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_sum_of_list_+3A_.l">.l</code></td>
<td>
<p>a list of matrices</p>
</td></tr>
<tr><td><code id="compute_sum_of_list_+3A_.w">.w</code></td>
<td>
<p>a numeric vector of weights</p>
</td></tr>
</table>

<hr>
<h2 id='correct_by'>Correct sandwich components</h2><span id='topic+correct_by'></span>

<h3>Description</h3>

<p>Modifies the matrices in a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object
using the function and options in a <code><a href="#topic+correct_control-class">correct_control</a></code> object.
The function <code><a href="#topic+correction">correction</a></code> is a utility for creating
<code><a href="#topic+correct_control-class">correct_control</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_by(.components, .correct_control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_by_+3A_.components">.components</code></td>
<td>
<p>an object of class <code><a href="#topic+sandwich_components-class">sandwich_components</a></code></p>
</td></tr>
<tr><td><code id="correct_by_+3A_.correct_control">.correct_control</code></td>
<td>
<p>an object of class <code><a href="#topic+correct_control-class">correct_control</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the finite sample corrections vignette for further examples.
</p>


<h3>Value</h3>

<p>the result of <code>.FUN</code> in <code>.correct_control</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fay_bias_correction">fay_bias_correction</a></code> and <code><a href="#topic+fay_df_correction">fay_df_correction</a></code>
for corrections provided by <code>geex</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
   function(theta){
    c(data$Y1 - theta[1],
     (data$Y1 - theta[1])^2 - theta[2])
   }
 }
mybasis &lt;- create_basis(
   estFUN = myee,
   data   = geexex)
mats &lt;- estimate_sandwich_matrices(mybasis, .theta = c(5.04, 10.04))
correct_by(mats,
   .correct_control =  correction(fay_bias_correction, b = .75))
</code></pre>

<hr>
<h2 id='correct_control-class'>correct_control S4 class</h2><span id='topic+correct_control-class'></span>

<h3>Description</h3>

<p>correct_control S4 class
</p>


<h3>Slots</h3>


<dl>
<dt><code>.FUN</code></dt><dd><p>a function which &quot;corrects&quot; a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code>
object. Usually a small-sample correction</p>
</dd>
<dt><code>.options</code></dt><dd><p>a list of options passed to <code>.FUN</code>.</p>
</dd>
</dl>

<hr>
<h2 id='correction'>Creates a correct_control object</h2><span id='topic+correction'></span>

<h3>Description</h3>

<p>Creates a correct_control object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correction(FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correction_+3A_fun">FUN</code></td>
<td>
<p>a correction to perform. <code>components</code> must be the
first argument</p>
</td></tr>
<tr><td><code id="correction_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+correct_control-class">correct_control</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>correction(FUN = fay_bias_correction, b = 0.75)
</code></pre>

<hr>
<h2 id='create_basis'>Creates an m_estimation_basis object</h2><span id='topic+create_basis'></span>

<h3>Description</h3>

<p>Creates an m_estimation_basis object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_basis(estFUN, data, units, outer_args, inner_args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_basis_+3A_estfun">estFUN</code></td>
<td>
<p>a function that takes in group-level data and returns a function
that takes parameters as its first argument</p>
</td></tr>
<tr><td><code id="create_basis_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="create_basis_+3A_units">units</code></td>
<td>
<p>an optional character string identifying the grouping variable in <code>data</code></p>
</td></tr>
<tr><td><code id="create_basis_+3A_outer_args">outer_args</code></td>
<td>
<p>a list of arguments passed to the outer (data) function of <code>estFUN</code>. (optional)</p>
</td></tr>
<tr><td><code id="create_basis_+3A_inner_args">inner_args</code></td>
<td>
<p>a list of arguments passed to the inner (theta) function of <code>estFUN</code>. (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>data</code> or <code>split_data</code> must be provided
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
   function(theta){
    c(data$Y1 - theta[1],
     (data$Y1 - theta[1])^2 - theta[2])
   }
 }
mybasis &lt;- create_basis(
   estFUN = myee,
   data   = geexex)
</code></pre>

<hr>
<h2 id='create_GFUN'>Creates a function that sums over psi functions</h2><span id='topic+create_GFUN'></span><span id='topic+create_GFUN+2Cm_estimation_basis-method'></span><span id='topic+create_GFUN+2Cm_estimation_basis+2Cm_estimation_basis-method'></span>

<h3>Description</h3>

<p>From a list of <code class="reqn">\psi(O_i, \theta)</code> for i = 1, ..., m,
creates <code class="reqn">G_m = \sum_i \psi(O_i, \theta)</code>,
called <code>GFUN</code>. Here, <code class="reqn">\psi(O_i, \theta)</code> is the
*inner* part of an <code>estFUN</code>, in that the data is fixed and <code class="reqn">G_m</code>
is a function of <code class="reqn">\theta)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_GFUN(object, ...)

## S4 method for signature 'm_estimation_basis'
create_GFUN(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_GFUN_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code></p>
</td></tr>
<tr><td><code id="create_GFUN_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
   function(theta){
    c(data$Y1 - theta[1],
     (data$Y1 - theta[1])^2 - theta[2])
   }
 }
mybasis &lt;- create_basis(
   estFUN = myee,
   data   = geexex)
f &lt;- grab_GFUN(create_GFUN(mybasis))

# Evaluate GFUN at mean and variance: should be close to zero
n &lt;- nrow(geexex)
f(c(mean(geexex$Y1), var(geexex$Y1) * (n - 1)/n))


</code></pre>

<hr>
<h2 id='create_psiFUN_list'>Creates list of psi functions</h2><span id='topic+create_psiFUN_list'></span><span id='topic+create_psiFUN_list+2Cm_estimation_basis-method'></span><span id='topic+create_psiFUN_list+2Cm_estimation_basis+2Cm_estimation_basis-method'></span>

<h3>Description</h3>

<p>Creates the estimating function (<code class="reqn">\psi(O_i, \theta)</code>)
for each unit. That is, this function evaluates the outer function in
<code>estFUN</code> for each independent unit and a returns the inner function in
<code>estFUN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_psiFUN_list(object, ...)

## S4 method for signature 'm_estimation_basis'
create_psiFUN_list(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_psiFUN_list_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code></p>
</td></tr>
<tr><td><code id="create_psiFUN_list_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>object</code> with the <code>.psiFUN_list</code> slot populated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
   function(theta){
    c(data$Y1 - theta[1],
     (data$Y1 - theta[1])^2 - theta[2])
   }
 }
mybasis &lt;- create_basis(
   estFUN = myee,
   data   = geexex)
psi_list &lt;- grab_psiFUN_list(create_psiFUN_list(mybasis))

# A list of functions
head(psi_list)
</code></pre>

<hr>
<h2 id='deriv_control-class'>deriv_control S4 class</h2><span id='topic+deriv_control-class'></span>

<h3>Description</h3>

<p>deriv_control S4 class
</p>


<h3>Slots</h3>


<dl>
<dt><code>.FUN</code></dt><dd><p>a function which computes a numerical derivation. This functions
first argument must the function on which the derivative is being compute.
Defaults to <code><a href="numDeriv.html#topic+jacobian">jacobian</a></code>.</p>
</dd>
<dt><code>.options</code></dt><dd><p>a list of options passed to <code>.FUN</code>. Defaults to
<code>list(method = 'Richardson')</code></p>
</dd>
</dl>

<hr>
<h2 id='diagnose_roots'>Diagnose roots of estimating equations</h2><span id='topic+diagnose_roots'></span>

<h3>Description</h3>

<p>Computes the value of </p>
<p style="text-align: center;"><code class="reqn">G_m = sum_i psi(O_i, \hat{\theta})</code>
</p>
<p>, i.e., the estimating
equations at <code>theta</code>. Used to verify that <code class="reqn">G_m = 0</code> (or close to 0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose_roots(GFUN, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnose_roots_+3A_gfun">GFUN</code></td>
<td>
<p>a function of theta</p>
</td></tr>
<tr><td><code id="diagnose_roots_+3A_theta">theta</code></td>
<td>
<p>parameter estimates to use in evaluating the estimating equations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
   function(theta){
    c(data$Y1 - theta[1],
     (data$Y1 - theta[1])^2 - theta[2])
   }
 }

mest &lt;- m_estimate(
   estFUN = myee,
   data   = geexex,
   root_control = setup_root_control(start = c(1, 1)))

f &lt;- grab_GFUN(mest@basis)
# Should be close to zero
diagnose_roots(GFUN = f, theta = roots(mest))
</code></pre>

<hr>
<h2 id='estimate_GFUN_roots'>Estimate roots for a set of estimating equations</h2><span id='topic+estimate_GFUN_roots'></span>

<h3>Description</h3>

<p>Using the <code>rootFUN</code> specified by the user (defaults to <code><a href="rootSolve.html#topic+multiroot">multiroot</a></code>),
this function estimates the roots of the equations:
</p>
<p style="text-align: center;"><code class="reqn">G_m = sum_i psi(O_i, \hat{\theta}) = 0</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>estimate_GFUN_roots(.basis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_GFUN_roots_+3A_.basis">.basis</code></td>
<td>
<p>an object of class <code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is primilary an internal function used within <code><a href="#topic+m_estimate">m_estimate</a></code>,
but it is exported for use in debugging and development.
</p>
<p>For an example of how to use a different <code>rootFUN</code>,
see the root solver vignette, <code>vignette('geex_root_solvers', package = 'geex')</code>.
</p>


<h3>Value</h3>

<p>the output of the <code>rootFUN</code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
myee &lt;- function(data){
  function(theta){
    c(data$Y1 - theta[1],
     (data$Y1 - theta[1])^2 - theta[2])
   }
 }

# Start with a basic basis
mybasis &lt;- create_basis(
  estFUN = myee,
  data   = geexex)

# Add a control for the root solver
mycontrol &lt;- new('geex_control', .root = setup_root_control(start = c(1, 1)))
mybasis@.control &lt;- mycontrol

# Now estimate roots of GFUN
roots &lt;- estimate_GFUN_roots(mybasis)
roots

</code></pre>

<hr>
<h2 id='estimate_sandwich_matrices'>Estimate component matrices of the empirical sandwich covariance estimator</h2><span id='topic+estimate_sandwich_matrices'></span>

<h3>Description</h3>

<p>For a given set of estimating equations computes the 'meat' (<code class="reqn">B_m</code>
in Stefanski and Boos notation) and 'bread' (<code class="reqn">A_m</code> in Stefanski and
Boos notation) matrices necessary to compute the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_sandwich_matrices(.basis, .theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_sandwich_matrices_+3A_.basis">.basis</code></td>
<td>
<p>basis an object of class <code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code></p>
</td></tr>
<tr><td><code id="estimate_sandwich_matrices_+3A_.theta">.theta</code></td>
<td>
<p>vector of parameter estimates (i.e. estimated roots)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a set of estimating equations (<code class="reqn">\sum_i \psi(O_i, \theta) = 0</code>),
this function computes:
</p>
<p style="text-align: center;"><code class="reqn">A_i =  \partial \psi(O_i, \theta)/\partial \theta</code>
</p>

<p style="text-align: center;"><code class="reqn">A =  \sum_i A_i</code>
</p>

<p style="text-align: center;"><code class="reqn">B_i =  \psi(O_i, \theta)\psi(O_i, \theta)^T</code>
</p>

<p style="text-align: center;"><code class="reqn">B =  \sum_i B_i</code>
</p>

<p>where all of the above are evaluated at <code class="reqn">\hat{\theta}</code>. The partial derivatives in <code class="reqn">A_i</code>
numerically approximated by the function defined in <code><a href="#topic+deriv_control-class">deriv_control</a></code>.
</p>
<p>Note that <code class="reqn">A =  \sum_i A_i</code> and not <code class="reqn">\sum_i A_i/m</code>, and the same for <code class="reqn">B</code>.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object
</p>


<h3>References</h3>

<p>Stefanski, L. A., &amp; Boos, D. D. (2002). The calculus of m-estimation. The American Statistician, 56(1), 29-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
myee &lt;- function(data){
  function(theta){
    c(data$Y1 - theta[1],
     (data$Y1 - theta[1])^2 - theta[2])
   }
 }

# Start with a basic basis
mybasis &lt;- create_basis(
  estFUN = myee,
  data   = geexex)

# Now estimate sandwich matrices
estimate_sandwich_matrices(
 mybasis, c(mean(geexex$Y1), var(geexex$Y1)))
</code></pre>

<hr>
<h2 id='estimating_function-class'>estimating_function S4 class</h2><span id='topic+estimating_function-class'></span>

<h3>Description</h3>

<p>estimating_function S4 class
</p>


<h3>Slots</h3>


<dl>
<dt><code>.estFUN</code></dt><dd><p>the estimating function.</p>
</dd>
<dt><code>.outer_args</code></dt><dd><p>a named <code>list</code> of arguments passed to the outer
function of <code>.estFUN</code>. Should *not* include the <code>data</code> argument.</p>
</dd>
<dt><code>.inner_args</code></dt><dd><p>a named <code>list</code> of arguments passed to the inner
function of <code>.estFUN</code>. Should *not* include the <code>theta</code> argument.</p>
</dd>
</dl>

<hr>
<h2 id='fay_bias_correction'>Correct sandwich variance estimator byFay's bias correction</h2><span id='topic+fay_bias_correction'></span>

<h3>Description</h3>

<p>Computes the bias corrected sandwich covariance matrix described in Fay and
Graubard (2001). See <code>vignette("05_finite_sample_corrections", package = "geex")</code>
for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fay_bias_correction(components, b = 0.75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fay_bias_correction_+3A_components">components</code></td>
<td>
<p>an object of class <code><a href="#topic+sandwich_components-class">sandwich_components</a></code></p>
</td></tr>
<tr><td><code id="fay_bias_correction_+3A_b">b</code></td>
<td>
<p>a numeric value &lt; 1. Defaults to 0.75 as in Fay.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a corrected covariance matrix
</p>


<h3>References</h3>

<p>Fay, M. P., &amp; Graubard, B. I. (2001). Small-Sample adjustments for
Wald-type tests using sandwich estimators. Biometrics, 57(4), 1198-1206
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example demonstrates usage of the corrections, not a meaningful application
myee &lt;- function(data){
 function(theta){
   c(data$Y1 - theta[1],
   (data$Y1 - theta[1])^2 - theta[2])
  }
}

results &lt;- m_estimate(
   estFUN = myee,
   data = geexex,
   root_control = setup_root_control(start = c(1,1)),
   corrections  = list(
     bias_correction_.1 = correction(fay_bias_correction, b = .1),
     bias_correction_.3 = correction(fay_bias_correction, b = .3))
   )

get_corrections(results)
</code></pre>

<hr>
<h2 id='fay_df_correction'>Correct sandwich variance inference by Fay's degrees of freedom correction</h2><span id='topic+fay_df_correction'></span>

<h3>Description</h3>

<p>Computes the degrees of freedom correction described in Fay and
Graubard (2001). See <code>vignette("05_finite_sample_corrections", package = "geex")</code>
for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fay_df_correction(components, b = 0.75, L, version)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fay_df_correction_+3A_components">components</code></td>
<td>
<p>an object of class <code><a href="#topic+sandwich_components-class">sandwich_components</a></code></p>
</td></tr>
<tr><td><code id="fay_df_correction_+3A_b">b</code></td>
<td>
<p>a numeric value &lt; 1. Defaults to 0.75 as in Fay.</p>
</td></tr>
<tr><td><code id="fay_df_correction_+3A_l">L</code></td>
<td>
<p>a k x p matrix where p is the dimension of theta</p>
</td></tr>
<tr><td><code id="fay_df_correction_+3A_version">version</code></td>
<td>
<p>either 1 or 2, corresponding to hat(d) or tilde(d), respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar corresponding to the estimated degrees of freedom
</p>


<h3>References</h3>

<p>Fay, M. P., &amp; Graubard, B. I. (2001). Small-Sample adjustments for
Wald-type tests using sandwich estimators. Biometrics, 57(4), 1198-1206
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This example demonstrates usage of the corrections, not a meaningful application
myee &lt;- function(data){
 function(theta){
   c(data$Y1 - theta[1],
   (data$Y1 - theta[1])^2 - theta[2])
  }
}

results &lt;- m_estimate(
   estFUN = myee,
   data = geexex,
   root_control = setup_root_control(start = c(1,1)),
   corrections  = list(
     df_correction1 = correction(fay_df_correction,
                        b = .75, L = c(0, 1), version = 1 ),
     df_correction2 = correction(fay_df_correction,
                        b = .75, L = c(0, 1), version = 2 ))
   )

get_corrections(results)
</code></pre>

<hr>
<h2 id='geex_control-class'>geex_control S4 class</h2><span id='topic+geex_control-class'></span>

<h3>Description</h3>

<p>An object which control all the <code><a href="#topic+basic_control-class">basic_control</a></code> objects
necessary to perform M-estimation
</p>


<h3>Slots</h3>


<dl>
<dt><code>.approx</code></dt><dd><p>an <code><a href="#topic+approx_control-class">approx_control</a></code> object</p>
</dd>
<dt><code>.root</code></dt><dd><p>a <code><a href="#topic+root_control-class">root_control</a></code> object</p>
</dd>
<dt><code>.deriv</code></dt><dd><p>a <code><a href="#topic+deriv_control-class">deriv_control</a></code> object</p>
</dd>
</dl>

<hr>
<h2 id='geex_summary-class'>geex summary object</h2><span id='topic+geex_summary-class'></span>

<h3>Description</h3>

<p>geex summary object
</p>


<h3>Slots</h3>


<dl>
<dt><code>estFUN</code></dt><dd><p>a <code>estimating-function</code></p>
</dd>
<dt><code>outer_args</code></dt><dd><p>the <code>list</code> arguments passed to the <code>m_estimate</code> call</p>
</dd>
<dt><code>inner_args</code></dt><dd><p>the <code>list</code> arguments passed to the <code>m_estimate</code> call</p>
</dd>
<dt><code>data</code></dt><dd><p>the <code>data.frame</code> passed to the <code>m_estimate</code> call</p>
</dd>
<dt><code>weights</code></dt><dd><p>the <code>weights</code> passed to the <code>m_estimate</code> call</p>
</dd>
<dt><code>nobs</code></dt><dd><p>the number of observational units used to compute the M-estimator</p>
</dd>
<dt><code>units</code></dt><dd><p>the name of the variable identifying the observational units</p>
</dd>
<dt><code>corrections</code></dt><dd><p>a <code>list</code> of correction performed on <code>sandwich_components</code></p>
</dd>
<dt><code>estimates</code></dt><dd><p>a <code>numeric</code> vector of parameter estimates</p>
</dd>
<dt><code>vcov</code></dt><dd><p>the empirical sandwich variance <code>matrix</code></p>
</dd>
</dl>

<hr>
<h2 id='geex-class'>geex S4 class</h2><span id='topic+geex-class'></span>

<h3>Description</h3>

<p>geex S4 class
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>the <code>m_estimate</code> call</p>
</dd>
<dt><code>basis</code></dt><dd><p>a <code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code> object</p>
</dd>
<dt><code>rootFUN_results</code></dt><dd><p>the results of call to the root finding algorithm function</p>
</dd>
<dt><code>sandwich_components</code></dt><dd><p>a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object</p>
</dd>
<dt><code>GFUN</code></dt><dd><p>the <code>function</code> of which the roots are computed.</p>
</dd>
<dt><code>corrections</code></dt><dd><p>a <code>list</code> of correction performed on <code>sandwich_components</code></p>
</dd>
<dt><code>estimates</code></dt><dd><p>a <code>numeric</code> vector of parameter estimates</p>
</dd>
<dt><code>vcov</code></dt><dd><p>the empirical sandwich variance <code>matrix</code></p>
</dd>
</dl>

<hr>
<h2 id='geexex'>Dataset used to illustrate Stefanski and Boos examples.</h2><span id='topic+geexex'></span>

<h3>Description</h3>

<p>The data used to illustrate examples 1-9 of Stefanski and Boos (2002).
</p>


<h3>Format</h3>

<p>a dataset with 9 variables and 100 observations
</p>

<ul>
<li><p>Y1 rnorm(mean = 5, sd = 4)
</p>
</li>
<li><p>Y2 rnorm(mean = 2, sd = 1)
</p>
</li>
<li><p>X1 rgamma(shape =5)
</p>
</li>
<li><p>Y3 2 + 3*X1 + 1*rnorm(0, 1)
</p>
</li>
<li><p>W1 X1 + 0.25 * rnorm(0, 1)
</p>
</li>
<li><p>Z1 2 + 1.5*X1 + 1*rnorm(0, 1)
</p>
</li>
<li><p>X2 0 for first 50 observation, 1 for rest
</p>
</li>
<li><p>Y4 0.1 + 0.1*X1 + 0.5*X2 + rnorm(0, 1)
</p>
</li>
<li><p>Y5 rbinom(prob = plogis(0.1 + 0.1*X1 + 0.5*X2))
</p>
</li></ul>



<h3>References</h3>

<p>Stefanski, L. A., &amp; Boos, D. D. (2002). The calculus of m-estimation. The American Statistician, 56(1), 29-38.
</p>

<hr>
<h2 id='get_corrections'>Gets the corrections from a geex object</h2><span id='topic+get_corrections'></span><span id='topic+get_corrections+2Cgeex-method'></span><span id='topic+get_corrections+2Cm_estimation_basis+2Cm_estimation_basis-method'></span><span id='topic+get_corrections+2Cgeex_summary-method'></span>

<h3>Description</h3>

<p>Gets the corrections from a geex object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_corrections(object, ...)

## S4 method for signature 'geex'
get_corrections(object)

## S4 method for signature 'geex_summary'
get_corrections(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_corrections_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+geex-class">geex</a></code> object</p>
</td></tr>
<tr><td><code id="get_corrections_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
 function(theta){
   c(data$Y1 - theta[1],
   (data$Y1 - theta[1])^2 - theta[2])
  }
}

results &lt;- m_estimate(
   estFUN = myee,
   data = geexex,
   root_control = setup_root_control(start = c(1,1)),
   corrections  = list(
     bias_correction_.1 = correction(fay_bias_correction, b = .1),
     bias_correction_.3 = correction(fay_bias_correction, b = .3))
   )

get_corrections(results)
</code></pre>

<hr>
<h2 id='grab'>Grab something from an object</h2><span id='topic+grab'></span>

<h3>Description</h3>

<p>Grab something from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab(from, what, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_+3A_from">from</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="grab_+3A_what">what</code></td>
<td>
<p>what to grab one of 'response', 'design_matrix', 'response_formula',
'fixed_formula', 'eeFUN'</p>
</td></tr>
<tr><td><code id="grab_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>grab_**</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value returns depends on the argument <code>what</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grab_response">grab_response</a></code>, <code><a href="#topic+grab_design_matrix">grab_design_matrix</a></code>,
<code><a href="#topic+grab_response_formula">grab_response_formula</a></code>, <code><a href="#topic+grab_fixed_formula">grab_fixed_formula</a></code>,
<code><a href="#topic+grab_design_levels">grab_design_levels</a></code>
</p>

<hr>
<h2 id='grab_bread'>Grabs the .A (bread matrix) slot</h2><span id='topic+grab_bread'></span><span id='topic+grab_bread+2Csandwich_components-method'></span><span id='topic+grab_bread+2Csandwich_components+2Csandwich_components-method'></span>

<h3>Description</h3>

<p>Grabs the .A (bread matrix) slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_bread(object)

## S4 method for signature 'sandwich_components'
grab_bread(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_bread_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
 function(theta){
   c(data$Y1 - theta[1],
   (data$Y1 - theta[1])^2 - theta[2])
  }
}

results &lt;- m_estimate(
   estFUN = myee,
   data = geexex,
   root_control = setup_root_control(start = c(1,1)))

grab_bread(results@sandwich_components)
</code></pre>

<hr>
<h2 id='grab_bread_list'>Gets the .A_i (list of bread matrices) slot</h2><span id='topic+grab_bread_list'></span><span id='topic+grab_bread_list+2Csandwich_components-method'></span><span id='topic+grab_bread_list+2Csandwich_components+2Csandwich_components-method'></span>

<h3>Description</h3>

<p>Gets the .A_i (list of bread matrices) slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_bread_list(object)

## S4 method for signature 'sandwich_components'
grab_bread_list(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_bread_list_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
 function(theta){
   c(data$Y1 - theta[1],
   (data$Y1 - theta[1])^2 - theta[2])
  }
}

results &lt;- m_estimate(
   estFUN = myee,
   data = geexex,
   root_control = setup_root_control(start = c(1,1)))

head(grab_bread_list(results@sandwich_components))
</code></pre>

<hr>
<h2 id='grab_design_levels'>Grab a list of the levels of factor variables in a model.</h2><span id='topic+grab_design_levels'></span>

<h3>Description</h3>

<p>Useful when splitting data later, used with <code><a href="#topic+grab_design_matrix">grab_design_matrix</a></code>
or especially when calling <code><a href="#topic+grab_psiFUN">grab_psiFUN</a></code> from within an eeFun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_design_levels(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_design_levels_+3A_model">model</code></td>
<td>
<p>a model object such as <code>lm</code>, <code>glm</code>, <code>merMod</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of character vectors that provides the fentire set of
levels that each factor predictor in <code>model</code> will take on. This is
hopefully identical to what the <code>xlev</code> argument to
<code>link[stats]{model.frame}</code> desires. When <code>model</code> has no factors
as predictors, then an empty list is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  geex::grab_design_matrix(
    data = data,
    rhs_formula = geex::grab_fixed_formula(model),
    xlev = geex::grab_design_levels(model)
  )
  ## Below is helpful within an eeFun.
  geex::grab_psiFUN(
    data = data,## Especially when this is a subset of the data
    rhs_formula = geex::grab_fixed_formula(model),
    xlev = geex::grab_design_levels(model)
  )

## End(Not run)
</code></pre>

<hr>
<h2 id='grab_design_matrix'>Grab a matrix of fixed effects from a model object</h2><span id='topic+grab_design_matrix'></span>

<h3>Description</h3>

<p>Grab a matrix of fixed effects from a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_design_matrix(data, rhs_formula, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_design_matrix_+3A_data">data</code></td>
<td>
<p>the data from which to extract the matrix</p>
</td></tr>
<tr><td><code id="grab_design_matrix_+3A_rhs_formula">rhs_formula</code></td>
<td>
<p>the right hand side of a model formula</p>
</td></tr>
<tr><td><code id="grab_design_matrix_+3A_...">...</code></td>
<td>
<p>Can be used to pass <code>xlev</code> to <code><a href="stats.html#topic+model.frame">model.frame</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a "desigm" matrix for the first ten rows of iris data
fit &lt;- lm(Sepal.Width ~ Petal.Width, data = iris)
grab_design_matrix(
  data = iris[1:10, ],
  grab_fixed_formula(fit))
</code></pre>

<hr>
<h2 id='grab_ee_list'>Gets the .ee_i (observed estimating function) slot</h2><span id='topic+grab_ee_list'></span>

<h3>Description</h3>

<p>Gets the .ee_i (observed estimating function) slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_ee_list(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_ee_list_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
 function(theta){
   c(data$Y1 - theta[1],
   (data$Y1 - theta[1])^2 - theta[2])
  }
}

results &lt;- m_estimate(
   estFUN = myee,
   data = geexex,
   root_control = setup_root_control(start = c(1,1)))

grab_ee_list(results@sandwich_components)
</code></pre>

<hr>
<h2 id='grab_estFUN'>Grab estimating functions from a model object</h2><span id='topic+grab_estFUN'></span><span id='topic+grab_estFUN+2Cestimating_function-method'></span><span id='topic+grab_estFUN+2Cestimating_function+2Cestimating_function-method'></span>

<h3>Description</h3>

<p>Grab estimating functions from a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_estFUN(object)

## S4 method for signature 'estimating_function'
grab_estFUN(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_estFUN_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+estimating_function-class">estimating_function</a></code> object</p>
</td></tr>
</table>

<hr>
<h2 id='grab_fixed_formula'>Grab the RHS formula from a model object</h2><span id='topic+grab_fixed_formula'></span>

<h3>Description</h3>

<p>Grab the RHS formula from a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_fixed_formula(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_fixed_formula_+3A_model">model</code></td>
<td>
<p>a model object such as <code>lm</code>, <code>glm</code>, <code>merMod</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the right-hand side of a model's <code><a href="stats.html#topic+formula">formula</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Width ~ Petal.Width, data = iris)
grab_fixed_formula(fit)
</code></pre>

<hr>
<h2 id='grab_GFUN'>Gets the .psi_list slot in a m_estimation_basis</h2><span id='topic+grab_GFUN'></span><span id='topic+grab_GFUN+2Cm_estimation_basis-method'></span><span id='topic+grab_GFUN+2Cm_estimation_basis+2Cm_estimation_basis-method'></span><span id='topic+grab_GFUN+2Cgeex-method'></span><span id='topic+grab_GFUN+2Cgeex+2Cgeex-method'></span>

<h3>Description</h3>

<p>Gets the .psi_list slot in a m_estimation_basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_GFUN(object)

## S4 method for signature 'm_estimation_basis'
grab_GFUN(object)

## S4 method for signature 'geex'
grab_GFUN(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_GFUN_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code> object</p>
</td></tr>
</table>

<hr>
<h2 id='grab_meat'>Gets the .B (meat matrix) slot</h2><span id='topic+grab_meat'></span><span id='topic+grab_meat+2Csandwich_components-method'></span><span id='topic+grab_meat+2Csandwich_components+2Csandwich_components-method'></span>

<h3>Description</h3>

<p>Gets the .B (meat matrix) slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_meat(object)

## S4 method for signature 'sandwich_components'
grab_meat(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_meat_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
 function(theta){
   c(data$Y1 - theta[1],
   (data$Y1 - theta[1])^2 - theta[2])
  }
}

results &lt;- m_estimate(
   estFUN = myee,
   data = geexex,
   root_control = setup_root_control(start = c(1,1)))

grab_meat_list(results@sandwich_components)
</code></pre>

<hr>
<h2 id='grab_meat_list'>Gets the .B_i (list of bread matrices) slot</h2><span id='topic+grab_meat_list'></span><span id='topic+grab_meat_list+2Csandwich_components-method'></span><span id='topic+grab_meat_list+2Csandwich_components+2Csandwich_components-method'></span><span id='topic+grab_ee_list+2Csandwich_components-method'></span>

<h3>Description</h3>

<p>Gets the .B_i (list of bread matrices) slot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_meat_list(object)

## S4 method for signature 'sandwich_components'
grab_meat_list(object)

## S4 method for signature 'sandwich_components'
grab_ee_list(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_meat_list_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+sandwich_components-class">sandwich_components</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myee &lt;- function(data){
 function(theta){
   c(data$Y1 - theta[1],
   (data$Y1 - theta[1])^2 - theta[2])
  }
}

results &lt;- m_estimate(
   estFUN = myee,
   data = geexex,
   root_control = setup_root_control(start = c(1,1)))

head(grab_meat_list(results@sandwich_components))
</code></pre>

<hr>
<h2 id='grab_psiFUN'>Grab estimating functions from a model object</h2><span id='topic+grab_psiFUN'></span><span id='topic+grab_psiFUN.glm'></span><span id='topic+grab_psiFUN.geeglm'></span><span id='topic+grab_psiFUN.merMod'></span>

<h3>Description</h3>

<p>Grab estimating functions from a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_psiFUN(object, ...)

## S3 method for class 'glm'
grab_psiFUN(object, data, ...)

## S3 method for class 'geeglm'
grab_psiFUN(object, data, ...)

## S3 method for class 'merMod'
grab_psiFUN(object, data, numderiv_opts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_psiFUN_+3A_object">object</code></td>
<td>
<p>the object from which to extrace <code>psiFUN</code></p>
</td></tr>
<tr><td><code id="grab_psiFUN_+3A_...">...</code></td>
<td>
<p>additonal arguments passed to other methods</p>
</td></tr>
<tr><td><code id="grab_psiFUN_+3A_data">data</code></td>
<td>
<p>the data to use for the estimating function</p>
</td></tr>
<tr><td><code id="grab_psiFUN_+3A_numderiv_opts">numderiv_opts</code></td>
<td>
<p>a list of arguments passed to <code>numDeriv::grad</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function corresponding to the estimating equations of a model
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>grab_psiFUN(glm)</code>: Create estimating equation function from a <code>glm</code> object
</p>
</li>
<li> <p><code>grab_psiFUN(geeglm)</code>: Create estimating equation function from a <code>geeglm</code> object
</p>
</li>
<li> <p><code>grab_psiFUN(merMod)</code>: Create estimating equation function from a <code>merMod</code> object
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(geepack)
library(lme4)
data('ohio')

glmfit  &lt;- glm(resp ~ age, data = ohio,
               family = binomial(link = "logit"))
geefit  &lt;- geeglm(resp ~ age, data = ohio, id = id,
                  family = binomial(link = "logit"))
glmmfit &lt;- glmer(resp ~ age + (1|id), data = ohio,
                 family = binomial(link = "logit"))
example_ee &lt;- function(data, model){
 f &lt;- grab_psiFUN(model, data)
 function(theta){
  f(theta)
 }
}

m_estimate(
  estFUN = example_ee,
  data = ohio,
  compute_roots = FALSE,
  units = 'id',
  roots = coef(glmfit),
  outer_args = list(model = glmfit))
m_estimate(
  estFUN = example_ee,
  data = ohio,
  compute_roots = FALSE,
  units = 'id',
  roots = coef(geefit),
  outer_args = list(model = geefit))
m_estimate(
  estFUN = example_ee,
  data = ohio,
  compute_roots = FALSE,
  units = 'id',
  roots = unlist(getME(glmmfit, c('beta', 'theta'))),
  outer_args = list(model = glmmfit))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='grab_psiFUN_list'>Gets the .psi_list slot in a m_estimation_basis</h2><span id='topic+grab_psiFUN_list'></span><span id='topic+grab_psiFUN_list+2Cm_estimation_basis-method'></span><span id='topic+grab_psiFUN_list+2Cm_estimation_basis+2Cm_estimation_basis-method'></span><span id='topic+grab_psiFUN_list+2Cgeex-method'></span><span id='topic+grab_psiFUN_list+2Cgeex+2Cgeex-method'></span>

<h3>Description</h3>

<p>Gets the .psi_list slot in a m_estimation_basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_psiFUN_list(object)

## S4 method for signature 'm_estimation_basis'
grab_psiFUN_list(object)

## S4 method for signature 'geex'
grab_psiFUN_list(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_psiFUN_list_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code> object</p>
</td></tr>
</table>

<hr>
<h2 id='grab_response'>Grab a vector of responses from a model object</h2><span id='topic+grab_response'></span>

<h3>Description</h3>

<p>Grab a vector of responses from a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_response(data, formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_response_+3A_data">data</code></td>
<td>
<p>data.frame from which to extract the vector of responses</p>
</td></tr>
<tr><td><code id="grab_response_+3A_formula">formula</code></td>
<td>
<p>model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="stats.html#topic+model.response">model.response</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grab vector of responses for the first ten rows of iris data
fit &lt;- lm(Sepal.Width ~ Petal.Width, data = iris)
grab_response(
  data = iris[1:10, ],
  formula(fit))
</code></pre>

<hr>
<h2 id='grab_response_formula'>Grab the LHS formula from a model object</h2><span id='topic+grab_response_formula'></span>

<h3>Description</h3>

<p>Grab the LHS formula from a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_response_formula(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_response_formula_+3A_model">model</code></td>
<td>
<p>a model object such as <code>lm</code>, <code>glm</code>, <code>merMod</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the left-hand side of a model's <code><a href="stats.html#topic+formula">formula</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- lm(Sepal.Width ~ Petal.Width, data = iris)
grab_response_formula(fit)
</code></pre>

<hr>
<h2 id='m_estimate'>Estimate parameters and their covariance from a set of estimating equations</h2><span id='topic+m_estimate'></span>

<h3>Description</h3>

<p>M-estimation theory provides a framework for asympotic properties of estimators
that are solutions to estimating equations. Many R packages implement specific
applications of estimating equations. <span class="pkg">geex</span> aims to be provide a more general
framework that any modelling method can use to compute point and variance estimates
for parameters that are solutions to estimating equations of the form:
</p>
<p style="text-align: center;"><code class="reqn">\sum_i \psi(O_i, \hat{\theta}) = 0</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>m_estimate(
  estFUN,
  data,
  units = character(0),
  weights = numeric(0),
  outer_args = list(),
  inner_args = list(),
  roots = NULL,
  compute_roots = TRUE,
  compute_vcov = TRUE,
  Asolver = solve,
  corrections,
  deriv_control,
  root_control,
  approx_control
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="m_estimate_+3A_estfun">estFUN</code></td>
<td>
<p>a function that takes in group-level data and returns a function
that takes parameters as its first argument</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_units">units</code></td>
<td>
<p>an optional character string identifying the grouping variable in <code>data</code></p>
</td></tr>
<tr><td><code id="m_estimate_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights. See details.</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_outer_args">outer_args</code></td>
<td>
<p>a list of arguments passed to the outer (data) function of <code>estFUN</code>. (optional)</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_inner_args">inner_args</code></td>
<td>
<p>a list of arguments passed to the inner (theta) function of <code>estFUN</code>. (optional)</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_roots">roots</code></td>
<td>
<p>a vector of parameter estimates must be provided if <code>compute_roots = FALSE</code></p>
</td></tr>
<tr><td><code id="m_estimate_+3A_compute_roots">compute_roots</code></td>
<td>
<p>whether or not to find the roots of the estimating equations.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_compute_vcov">compute_vcov</code></td>
<td>
<p>whether or not to compute the variance-covariance matrix.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_asolver">Asolver</code></td>
<td>
<p>a function passed to <code>compute_sigma</code> used to compute the
inverse of the &quot;bread&quot; matrix. Defaults to <code><a href="base.html#topic+solve">solve</a></code>.</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_corrections">corrections</code></td>
<td>
<p>an optional list of small sample corrections where each
list element is a <code><a href="#topic+correct_control-class">correct_control</a></code> object which contains
two elements: <code>correctFUN</code> and <code>correctFUN_options</code>. The function
<code><a href="#topic+correction">correction</a></code> constructs <code><a href="#topic+correct_control-class">correct_control</a></code> objects.
See details for more information.</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_deriv_control">deriv_control</code></td>
<td>
<p>a <code><a href="#topic+deriv_control-class">deriv_control</a></code> object</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_root_control">root_control</code></td>
<td>
<p>a <code><a href="#topic+root_control-class">root_control</a></code> object</p>
</td></tr>
<tr><td><code id="m_estimate_+3A_approx_control">approx_control</code></td>
<td>
<p>a <code><a href="#topic+approx_control-class">approx_control</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea of <span class="pkg">geex</span> is for the analyst to provide at least
two items:
</p>

<ul>
<li><p> data
</p>
</li>
<li> <p><code>estFUN</code>: (the <code class="reqn">\psi</code> function), a function that takes unit-level
data and returns a function in terms of parameters (<code class="reqn">\theta</code>)
</p>
</li></ul>

<p>With the <code>estFUN</code>, <span class="pkg">geex</span> computes the roots of the estimating equations
and/or the empirical sandwich variance estimator.
</p>
<p>The root finding algorithm defaults to <code><a href="rootSolve.html#topic+multiroot">multiroot</a></code> to
estimate roots though the solver algorithm can be specified in the <code>rootFUN</code>
argument. Starting values for <code><a href="rootSolve.html#topic+multiroot">multiroot</a></code> are passed via the
<code>root_control</code> argument. See <code>vignette("v03_root_solvers", package = "geex")</code>
for information on customizing the root solver function.
</p>
<p>To compute only the covariance matrix, set <code>compute_roots = FALSE</code> and pass
estimates of <code class="reqn">\theta</code> via the <code>roots</code> argument.
</p>
<p>M-estimation is often used for clustered data, and a variable by which to split
the data.frame  into independent units is specified by the <code>units</code> argument.
This argument defaults to <code>NULL</code>, in which case the number of units equals
the number of rows in the data.frame.
</p>
<p>For information on the finite-sample corrections, refer to the finite sample
correction API vignette: <code>vignette("v05_finite_sample_corrections", package = "geex")</code>
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+geex-class">geex</a></code> object
</p>


<h3>Writing an estFUN</h3>



<h4>Description</h4>

<p>An <code>estFUN</code> is a function representing <code class="reqn">\psi</code>. <span class="pkg">geex</span> works
by breaking <code class="reqn">\psi</code> into two parts:
</p>

<ul>
<li><p> the &quot;outer&quot; part of the <code>estFUN</code> which manipulates <code>data</code> and
<code>outer_args</code> and returns an
</p>
</li>
<li><p> &quot;inner&quot; function of <code>theta</code> and <code>inner_args</code>. Internally, this
&quot;inner&quot; function is called <code>psiFUN</code>.
</p>
</li></ul>

<p>In pseudo-code this looks like:
</p>
<pre>
function(data, &lt;&lt;outer_args&gt;&gt;){
  O &lt;- manipulate(data, &lt;&lt;outer_args&gt;&gt;)
  function(theta, &lt;&lt;inner_args&gt;&gt;){
    map(O, to = theta, and = &lt;&lt;inner_args&gt;&gt;)
  }
}</pre>
<p>See the examples below or the package vignettes to see an <code>estFUN</code>
in action.
</p>
<p>Importantly, the <code>data</code> used in an <code>estFUN</code> is *unit* level data,
which may be single rows in a data.frame or block of rows for clustered data.
</p>



<h4>Additional arguments</h4>

<p>Additional arguments may be passed to both the inner and outer function of the
<code>estFUN</code>. Elements in an <code>outer_args</code> list are passed to the outer
function; any elements of the <code>inner_args</code> list are passed to the inner
function. For an example, see the finite sample correction vignette [<code>
vignette("v05_finite_sample_corrections", package = "geex")</code>].
</p>



<h3>Setting up root_control</h3>

<p>To estimate roots of the estimating functions, <span class="pkg">geex</span> uses the <span class="pkg">rootSolve</span>
<code><a href="rootSolve.html#topic+multiroot">multiroot</a></code> function by default, which requires starting
values. The <code>root_control</code> argument expects a <code><a href="#topic+root_control-class">root_control</a></code>
object, which the utility function <code><a href="#topic+setup_root_control">setup_root_control</a></code> aids in
creating. For example, <code>setup_root_control(start = 4)</code> creates a
<code><a href="#topic+root_control-class">root_control</a></code> setting the starting value to 4. In general,
the dimension of <code>start</code> must the same as <code>theta</code> in the inner
<code>estFUN</code>.
</p>


<h3>Using weights</h3>

<p>In some situations, use of weights can massively speed computations. Refer
to <code>vignette("v04_weights", package = "geex")</code> for an example.
</p>


<h3>References</h3>

<p>Stefanski, L. A., &amp; Boos, D. D. (2002). The calculus of M-estimation.
The American Statistician, 56(1), 29-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate the mean and variance of Y1 in the geexex dataset
ex_eeFUN &lt;- function(data){
 function(theta){
   with(data,
    c(Y1 - theta[1],
     (Y1 - theta[1])^2 - theta[2] ))
}}

m_estimate(
 estFUN = ex_eeFUN,
 data  = geexex,
 root_control = setup_root_control(start = c(1,1)))

# compare to the mean() and variance() functions
mean(geexex$Y1)
n &lt;- nrow(geexex)
var(geexex$Y1) * (n - 1)/n

# A simple linear model for regressing X1 and X2 on Y4
lm_eefun &lt;- function(data){
 X &lt;- cbind(1, data$X1, data$X2)
 Y &lt;- data$Y4
 function(theta){
    t(X) %*% (Y - X %*% theta)
   }
 }

m_estimate(
 estFUN = lm_eefun,
 data  = geexex,
 root_control = setup_root_control(start = c(0, 0, 0)))

# Compare to lm() results
summary(lm(Y4 ~ X1 + X2, data = geexex))
</code></pre>

<hr>
<h2 id='m_estimation_basis-class'>m_estimation_basis S4 class</h2><span id='topic+m_estimation_basis-class'></span>

<h3>Description</h3>

<p>m_estimation_basis S4 class
</p>


<h3>Slots</h3>


<dl>
<dt><code>.data</code></dt><dd><p>the analysis data.frame</p>
</dd>
<dt><code>.units</code></dt><dd><p>an (optional) character string identifying the variable in
<code>.data</code> which splits the data into indepedent units</p>
</dd>
<dt><code>.weights</code></dt><dd><p>a numeric vector of weights used in weighting the estimating
functions</p>
</dd>
<dt><code>.psiFUN_list</code></dt><dd><p>a list of <code>psiFUN</code>s created by <code><a href="#topic+create_psiFUN_list">create_psiFUN_list</a></code></p>
</dd>
<dt><code>.GFUN</code></dt><dd><p>a function created by <code><a href="#topic+create_GFUN">create_GFUN</a></code></p>
</dd>
<dt><code>.control</code></dt><dd><p>a <code><a href="#topic+geex_control-class">geex_control</a></code> object</p>
</dd>
</dl>

<hr>
<h2 id='nobs+2Cgeex-method'>Extract the number observations</h2><span id='topic+nobs+2Cgeex-method'></span><span id='topic+nobs+2Cgeex+2Cgeex-method'></span><span id='topic+nobs+2Cgeex_summary-method'></span><span id='topic+nobs+2Cgeex_summary+2Cgeex_summary-method'></span>

<h3>Description</h3>

<p>Extract the number observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'geex'
nobs(object)

## S4 method for signature 'geex_summary'
nobs(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs+2B2Cgeex-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+geex-class">geex</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(geepack)
data('ohio')

glmfit  &lt;- glm(resp ~ age, data = ohio,
              family = binomial(link = "logit"))
example_ee &lt;- function(data, model){
  f &lt;- grab_psiFUN(model, data)
  function(theta){
    f(theta)
  }
}
z  &lt;- m_estimate(
  estFUN = example_ee,
  data = ohio,
  compute_roots = FALSE,
  units = 'id',
  roots = coef(glmfit),
  outer_args = list(model = glmfit))

nobs(z)
</code></pre>

<hr>
<h2 id='root_control-class'>root_control S4 class</h2><span id='topic+root_control-class'></span>

<h3>Description</h3>

<p>root_control S4 class
</p>


<h3>Slots</h3>


<dl>
<dt><code>.FUN</code></dt><dd><p>a root finding function whose first argument must be named <code>f</code>.</p>
</dd>
<dt><code>.options</code></dt><dd><p>a list of options passed to <code>.FUN</code>.</p>
</dd>
<dt><code>.object_name</code></dt><dd><p>a character string identifying the object containing the
roots in the output of <code>.FUN</code>.</p>
</dd>
</dl>

<hr>
<h2 id='roots'>Gets the parameter estimates matrix from a geex object</h2><span id='topic+roots'></span><span id='topic+roots+2Cgeex-method'></span><span id='topic+roots+2Cgeex+2Cgeex-method'></span><span id='topic+roots+2Cgeex_summary-method'></span>

<h3>Description</h3>

<p>Gets the parameter estimates matrix from a geex object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roots(object, ...)

## S4 method for signature 'geex'
roots(object)

## S4 method for signature 'geex_summary'
roots(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roots_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+geex-class">geex</a></code> object</p>
</td></tr>
<tr><td><code id="roots_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ex_eeFUN &lt;- function(data){
 function(theta){
   with(data,
    c(Y1 - theta[1],
     (Y1 - theta[1])^2 - theta[2] ))
}}

results &lt;- m_estimate(
 estFUN = ex_eeFUN,
 data  = geexex,
 root_control = setup_root_control(start = c(1,1)))

roots(results)
</code></pre>

<hr>
<h2 id='sandwich_components-class'>sandwich_components S4 class</h2><span id='topic+sandwich_components-class'></span>

<h3>Description</h3>

<p>sandwich_components S4 class
</p>


<h3>Slots</h3>


<dl>
<dt><code>.A</code></dt><dd><p>the &quot;bread&quot; matrix</p>
</dd>
<dt><code>.A_i</code></dt><dd><p>a list of &quot;bread&quot; matrices per unit</p>
</dd>
<dt><code>.B</code></dt><dd><p>the &quot;meat&quot; matrix</p>
</dd>
<dt><code>.B_i</code></dt><dd><p>a list of &quot;meat&quot; matrices per unit</p>
</dd>
<dt><code>.ee_i</code></dt><dd><p>a list of observed estimating function values per unit</p>
</dd>
</dl>

<hr>
<h2 id='setup_approx_control'>Setup an approx_control object</h2><span id='topic+setup_approx_control'></span>

<h3>Description</h3>

<p>Setup an approx_control object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_approx_control(FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_approx_control_+3A_fun">FUN</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="setup_approx_control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+approx_control-class">approx_control</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For usage, see example 7 in
vignette("01_additional_examples", package = "geex")
</code></pre>

<hr>
<h2 id='setup_control'>Setup a basic_control object</h2><span id='topic+setup_control'></span>

<h3>Description</h3>

<p>Setup a basic_control object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_control(type, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_control_+3A_type">type</code></td>
<td>
<p>one of <code>c("deriv", "approx", "root")</code></p>
</td></tr>
<tr><td><code id="setup_control_+3A_fun">FUN</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="setup_control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+basic_control-class">basic_control</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setup_root_control">setup_root_control</a></code>, <code><a href="#topic+setup_deriv_control">setup_deriv_control</a></code>,
<code><a href="#topic+setup_approx_control">setup_approx_control</a></code>
</p>

<hr>
<h2 id='setup_deriv_control'>Setup a deriv_control object</h2><span id='topic+setup_deriv_control'></span>

<h3>Description</h3>

<p>Setup a deriv_control object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_deriv_control(FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_deriv_control_+3A_fun">FUN</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="setup_deriv_control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+deriv_control-class">deriv_control</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setup_deriv_control() # default
setup_deriv_control(method = "simple") # will speed up computations
</code></pre>

<hr>
<h2 id='setup_root_control'>Setup a root_control object</h2><span id='topic+setup_root_control'></span>

<h3>Description</h3>

<p>Setup a root_control object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_root_control(FUN, roots_name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setup_root_control_+3A_fun">FUN</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="setup_root_control_+3A_roots_name">roots_name</code></td>
<td>
<p>a character string identifying the object containing the</p>
</td></tr>
<tr><td><code id="setup_root_control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+root_control-class">root_control</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup the default
setup_root_control(start = c(3, 5, 6))

# Also setup the default
setup_root_control(FUN = rootSolve::multiroot,
                   start = c(3, 5, 6))

# Or use uniroot()
setup_root_control(FUN = stats::uniroot,
                   interval = c(0, 1))
</code></pre>

<hr>
<h2 id='show'>Show (print) the S4 geex classes</h2><span id='topic+show'></span><span id='topic+show+2Csandwich_components-method'></span><span id='topic+show+2Csandwich_components+2Csandwich_components-method'></span><span id='topic+show+2Cm_estimation_basis-method'></span><span id='topic+show+2Cm_estimation_basis+2Cm_estimation_basis-method'></span><span id='topic+show+2Cgeex-method'></span><span id='topic+show+2Cgeex+2Cgeex-method'></span><span id='topic+show+2Cgeex_summary-method'></span><span id='topic+show+2Cgeex_summary+2Cgeex_summary-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+m_estimation_basis-class">m_estimation_basis</a></code>, or <code><a href="#topic+geex-class">geex</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show(object)

## S4 method for signature 'sandwich_components'
show(object)

## S4 method for signature 'm_estimation_basis'
show(object)

## S4 method for signature 'geex'
show(object)

## S4 method for signature 'geex_summary'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>the object to print</p>
</td></tr>
</table>

<hr>
<h2 id='summary+2Cgeex-method'>Object Summaries</h2><span id='topic+summary+2Cgeex-method'></span>

<h3>Description</h3>

<p>Object Summaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'geex'
summary(object, keep_data = TRUE, keep_args = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary+2B2Cgeex-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+geex-class">geex</a></code> object</p>
</td></tr>
<tr><td><code id="summary+2B2Cgeex-method_+3A_keep_data">keep_data</code></td>
<td>
<p>keep the original data or not</p>
</td></tr>
<tr><td><code id="summary+2B2Cgeex-method_+3A_keep_args">keep_args</code></td>
<td>
<p>keep the <code>outer_args</code> and <code>inner_args</code> passed to <code>estFUN</code> or not</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(geepack)
data('ohio')
glmfit  &lt;- glm(resp ~ age, data = ohio,
              family = binomial(link = "logit"))
example_ee &lt;- function(data, model){
  f &lt;- grab_psiFUN(model, data)
  function(theta){
    f(theta)
  }
}
z  &lt;- m_estimate(
estFUN = example_ee,
data = ohio,
compute_roots = FALSE,
units = 'id',
roots = coef(glmfit),
outer_args = list(model = glmfit))

object.size(z)
object.size(summary(z))
object.size(summary(z, keep_data = FALSE))
object.size(summary(z, keep_data = FALSE, keep_args = FALSE))
</code></pre>

<hr>
<h2 id='vcov+2Cgeex-method'>Gets the variance-covariance matrix from a geex object</h2><span id='topic+vcov+2Cgeex-method'></span><span id='topic+vcov+2Cgeex+2Cgeex-method'></span><span id='topic+vcov+2Cgeex_summary-method'></span><span id='topic+vcov+2Cgeex_summary+2Cgeex_summary-method'></span>

<h3>Description</h3>

<p>Gets the variance-covariance matrix from a geex object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'geex'
vcov(object)

## S4 method for signature 'geex_summary'
vcov(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov+2B2Cgeex-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+geex-class">geex</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ex_eeFUN &lt;- function(data){
 function(theta){
   with(data,
    c(Y1 - theta[1],
     (Y1 - theta[1])^2 - theta[2] ))
}}

results &lt;- m_estimate(
 estFUN = ex_eeFUN,
 data  = geexex,
 root_control = setup_root_control(start = c(1,1)))

vcov(results)
</code></pre>

<hr>
<h2 id='weights+2Cgeex-method'>Extract Model weights</h2><span id='topic+weights+2Cgeex-method'></span><span id='topic+weights+2Cgeex+2Cgeex-method'></span><span id='topic+weights+2Cgeex_summary-method'></span><span id='topic+weights+2Cgeex_summary+2Cgeex_summary-method'></span>

<h3>Description</h3>

<p>Extract Model weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'geex'
weights(object)

## S4 method for signature 'geex_summary'
weights(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights+2B2Cgeex-method_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+geex-class">geex</a></code> object</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
