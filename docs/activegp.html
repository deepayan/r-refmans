<!DOCTYPE html><html lang="en"><head><title>Help for package activegp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {activegp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#activegp'><p>Package activegp</p></a></li>
<li><a href='#as.matrix.const_C'><p>Extract Matrix</p></a></li>
<li><a href='#C_GP'><p>Active Subspace Matrix closed form expression for a GP.</p></a></li>
<li><a href='#C_GP_ci'><p>CI on Eigenvalues via Monte Carlo/GP</p></a></li>
<li><a href='#C_GP_cpp'><p>Equivalent of <code>C_GP</code> using RcppArmadillo</p></a></li>
<li><a href='#C_Q'><p>Active subspace for second order linear model</p></a></li>
<li><a href='#C_tr'><p>Expected variance of trace of C</p></a></li>
<li><a href='#C_var'><p>Element-wise Cn+1 variance</p></a></li>
<li><a href='#C_var2'><p>Alternative Variance of Update</p></a></li>
<li><a href='#d1'><p>Get Integerodifferential Quantities</p></a></li>
<li><a href='#domain_to_R'><p>Rectangular Domain -&gt; Unbounded Domain</p></a></li>
<li><a href='#domain_to_unit'><p>Change a function's inputs to live in [-1, 1]</p></a></li>
<li><a href='#get_betagamma'><p>Quantities for Acquisition Functions</p></a></li>
<li><a href='#grad_est_subspace'><p>Estimate the Active Subspace of a Cheap Function using Gradients</p></a></li>
<li><a href='#grad_W_kappa_ij2'><p>Covariance of kernel computations</p></a></li>
<li><a href='#grad_W_kappa_ij2_w2'><p>Covariance of kernel computations</p></a></li>
<li><a href='#logLikHessian'><p>Hessian of the log-likelihood with respect to lengthscales hyperparameters</p>
Works for homGP and hetGP models from the hetGP package for now.</a></li>
<li><a href='#Lt_GP'><p>Active Subspace Prewarping</p></a></li>
<li><a href='#n11_2_01'><p>f:[-1, 1] -&gt; R Becomes f:[0,1] -&gt; R</p></a></li>
<li><a href='#plot.const_C'><p>Plot const_C objectc</p></a></li>
<li><a href='#print.const_C'><p>Print const_C objects</p></a></li>
<li><a href='#quick_C'><p>Covariance of kernel computations</p></a></li>
<li><a href='#subspace_dist'><p>Get the distance between subspaces defined as the ranges of A and B</p></a></li>
<li><a href='#update_C2'><p>Update Constantine's C, using update formula</p></a></li>
<li><a href='#update.const_C'><p>C update with new observations</p></a></li>
<li><a href='#W_kappa_ij'><p>Covariance of kernel computations</p></a></li>
<li><a href='#W_kappa_ij_up'><p>Covariance of kernel computations</p></a></li>
<li><a href='#W_kappa_ij2'><p>Covariance of kernel computations</p></a></li>
<li><a href='#W_kappa_lk'><p>Covariance of kernel computations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Process Based Design and Analysis for the Active
Subspace Method</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathan Wycoff, Mickael Binois</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathan Wycoff &lt;nathan.wycoff@georgetown.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The active subspace method is a sensitivity analysis technique that finds important linear combinations of input variables for a simulator. This package provides functions allowing estimation of the active subspace without gradient information using Gaussian processes as well as sequential experimental design tools to minimize the amount of data required to do so. Implements Wycoff et al. (JCGS, 2021) &lt;<a href="https://doi.org/10.48550%2FarXiv.1907.11572">doi:10.48550/arXiv.1907.11572</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.18), hetGP (&ge; 1.1.1), lhs, numDeriv, methods,
MASS, RcppProgress</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-25 19:46:37 UTC; nate</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-25 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='activegp'>Package activegp</h2><span id='topic+activegp'></span>

<h3>Description</h3>

<p>Active subspace estimation with Gaussian processes
</p>


<h3>Details</h3>

<p>The primary function for analysis of the active subspace given some set of function evaluations is C_GP. 
</p>
<p>C_var, C_var2, and C_tr give three possible acquisition functions for sequential design. Either C_var or C_var2 is recommended, see Wycoff et al for details and the example below for usage.
</p>


<h3>Author(s)</h3>

<p>Nathan Wycoff, Mickael Binois
</p>


<h3>References</h3>

<p>N. Wycoff, M. Binois, S. Wild (2019+), Sequential Learning of Active Subspaces, preprint.<br />
P. Constantine (2015) Active Subspaces: Emerging Ideas for Dimension Reduction in Parameter Studies, SIAM Spotlights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
################################################################################
### Sequential learning of active subspaces
################################################################################
    library(hetGP); library(lhs)
    set.seed(42)

    nvar &lt;- 2
    n &lt;- 20
    nits &lt;- 20

    # theta gives the subspace direction
    f &lt;- function(x, theta, nugget = 1e-6){
      if(is.null(dim(x))) x &lt;- matrix(x, 1)
      xact &lt;- cos(theta) * x[,1] - sin(theta) * x[,2]
      return(hetGP::f1d(xact) + rnorm(n = nrow(x), sd = rep(nugget, nrow(x))))
      return(100*erf((xact + 0.5)*5) + hetGP::f1d(xact) + 
        rnorm(n = nrow(x), sd = rep(nugget, nrow(x))))
    }

    theta_dir &lt;- pi/6
    act_dir &lt;- c(cos(theta_dir), -sin(theta_dir))

    # Create design of experiments and initial GP model
    design &lt;- X &lt;- matrix(signif(maximinLHS(n, nvar), 2), ncol = nvar)
    response &lt;- Y &lt;- apply(design, 1, f, theta = theta_dir)
    model &lt;- mleHomGP(design, response, lower = rep(1e-4, nvar),
                      upper = rep(0.5,nvar), known = list(g = 1e-6, beta0 = 0))

    C_hat &lt;- C_GP(model)

    ngrid &lt;- 51
    xgrid &lt;- seq(0, 1,, ngrid)
    Xgrid &lt;- as.matrix(expand.grid(xgrid, xgrid))
    filled.contour(matrix(f(Xgrid, theta = theta_dir), ngrid))
    ssd &lt;- rep(NA, nits)

    # Main loop
    for(nit in 1:nits) {
      cat(nit)
      cat(" ")
      
      af &lt;- function(x, C) C_var(C, x, grad = FALSE)
      af_gr &lt;- function(x, C) C_var(C, x, grad = TRUE)
      Ctr_grid &lt;- apply(Xgrid, 1, af, C = C_hat) # CVAR
      
      # Best candidate point
      opt_cand &lt;- matrix(Xgrid[which.max(Ctr_grid),], 1)
      
      # Refine with gradient based optimization
      opt &lt;-  optim(opt_cand, af, af_gr, method = 'L-BFGS-B', lower = rep(0, nvar), C = C_hat,
                    upper = rep(1, nvar), hessian = TRUE, 
                    control = list(fnscale=-1, trace = 0, maxit = 10))
      
      # Criterion surface with best initial point and corresponding local optimum
      filled.contour(matrix(Ctr_grid, ngrid), color.palette = terrain.colors,
                     plot.axes = {axis(1); axis(2); points(X, pch = 20);
                                  points(opt_cand, pch = 20, col = 'blue');
                                  points(opt$par, pch = 20, col = 'red')})
      
      X &lt;- rbind(X, opt$par)
      Ynew &lt;- f(opt$par, theta = theta_dir)
      Y &lt;- c(Y, Ynew)
      model &lt;- update(model, Xnew = opt$par, Znew = Ynew)
      
      ## periodically restart model fit
      if(nit %% 5 == 0){
        mod2 &lt;- mleHomGP(X = list(X0 = model$X0, Z0 = model$Z0, mult = model$mult), Z = model$Z,
                         known = model$used_args$known, lower = model$used_args$lower,
                         upper = model$used_args$upper)
        if(mod2$ll &gt; model$ll) model &lt;- mod2
      }
      C_hat &lt;- C_GP(model)
      # Compute subspace distance
      ssd[nit] &lt;- subspace_dist(C_hat, matrix(act_dir, nrow = nvar), r = 1)
    }
    plot(ssd, type = 'b')

</code></pre>

<hr>
<h2 id='as.matrix.const_C'>Extract Matrix</h2><span id='topic+as.matrix.const_C'></span>

<h3>Description</h3>

<p>Given a const_C object, extracts the actual matrix itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'const_C'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.const_C_+3A_x">x</code></td>
<td>
<p>A const_C object with field 'mat'.</p>
</td></tr>
<tr><td><code id="as.matrix.const_C_+3A_...">...</code></td>
<td>
<p>Additional parameters. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mat entry of C, a matrix.
</p>

<hr>
<h2 id='C_GP'>Active Subspace Matrix closed form expression for a GP.</h2><span id='topic+C_GP'></span>

<h3>Description</h3>

<p>Computes the integral over the input domain of the outer product of the gradients of a Gaussian process. 
The corresponding matrix is the C matrix central in active subspace methodology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_GP(
  modelX,
  y,
  measure = "lebesgue",
  xm = NULL,
  xv = NULL,
  S = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_GP_+3A_modelx">modelX</code></td>
<td>
<p>This may be either 1) a <code>homGP</code> or <code>hetGP</code> GP model, see <code><a href="hetGP.html#topic+hetGP-package">hetGP-package</a></code> containing, e.g.,
a vector of <code>theta</code>s, type of covariance <code>ct</code>, an inverse covariance matrix <code>Ki</code>,
a design matrix <code>X0</code>, and response vector <code>Z0</code>. 2) A matrix of design locations, in which case a vector of responses must be given as the y argument, and this function will fit a default model for you.</p>
</td></tr>
<tr><td><code id="C_GP_+3A_y">y</code></td>
<td>
<p>A vector of responses corresponding to the design matrix; may be ommited if a GP fit is provided in the modelX argument.</p>
</td></tr>
<tr><td><code id="C_GP_+3A_measure">measure</code></td>
<td>
<p>One of c(&quot;lebesgue&quot;, &quot;gaussian&quot;, &quot;trunc_gaussian&quot;, &quot;sample&quot;, &quot;discrete&quot;), indiciating the probability distribution with respect to which the input points are drawn in the definition of the active subspace. &quot;lebesgue&quot; uses the Lebesgue or Uniform measure over the unit hypercube [0,1]^d. &quot;gaussian&quot; uses a Gaussian or Normal distribution, in which case xm and xv should be specified. &quot;trunc_gaussian&quot; gives a truncated Gaussian or Normal distribution over the unit hypercube [0,1]^d, in which case xm and xv should be specified. &quot;sample&quot; gives the Sample or Empirical measure (dirac deltas located at each design point), which is equivalent to calculating the average expected gradient outer product at the design points. &quot;discrete&quot; gives a measure which puts equal weight at points in the input space specified via the S parameter, which should be a matrix with one row for each atom of the measure.</p>
</td></tr>
<tr><td><code id="C_GP_+3A_xm">xm</code></td>
<td>
<p>If measure is &quot;gaussian&quot; or &quot;trunc_gaussian&quot;, gives the mean vector.</p>
</td></tr>
<tr><td><code id="C_GP_+3A_xv">xv</code></td>
<td>
<p>If measure is &quot;gaussian&quot; or &quot;trunc_gaussian&quot;, gives the marginal variance vector. The covariance matrix is assumed to be diagonal.</p>
</td></tr>
<tr><td><code id="C_GP_+3A_s">S</code></td>
<td>
<p>If measure is &quot;discrete&quot;, gives the locations of the measure's atoms. S is a matrix, each row of which gives an atom.</p>
</td></tr>
<tr><td><code id="C_GP_+3A_verbose">verbose</code></td>
<td>
<p>Should we print progress?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>const_C</code> object with elements
</p>

<ul>
<li> <p><code>model</code>: GP model provided or estimated;
</p>
</li>
<li> <p><code>mat</code>: C matrix estimated;
</p>
</li>
<li> <p><code>Wij</code>: list of W matrices, of size number of variables;
</p>
</li>
<li> <p><code>ct</code>: covariance type (1 for &quot;Gaussian&quot;, 2 for &quot;Matern3_2&quot;, 3 for &quot;Matern5_2&quot;).
</p>
</li></ul>



<h3>References</h3>

<p>N. Wycoff, M. Binois, S. Wild (2019+), Sequential Learning of Active Subspaces, preprint.<br />
</p>
<p>P. Constantine (2015), Active Subspaces, Philadelphia, PA: SIAM.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.const_C">print.const_C</a></code>, <code><a href="#topic+plot.const_C">plot.const_C</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
### Active subspace of a Gaussian process
################################################################################
 
library(hetGP); library(lhs)
set.seed(42)

nvar &lt;- 2
n &lt;- 100

# theta gives the subspace direction
f &lt;- function(x, theta, nugget = 1e-3){
  if(is.null(dim(x))) x &lt;- matrix(x, 1)
  xact &lt;- cos(theta) * x[,1] - sin(theta) * x[,2]
  return(hetGP::f1d(xact) + rnorm(n = nrow(x), sd = rep(nugget, nrow(x))))
}

theta_dir &lt;- pi/6
act_dir &lt;- c(cos(theta_dir), -sin(theta_dir))

# Create design of experiments and initial GP model
design &lt;- X &lt;- matrix(signif(maximinLHS(n, nvar), 2), ncol = nvar)
response &lt;- Y &lt;- apply(design, 1, f, theta = theta_dir)
model &lt;- mleHomGP(design, response, known = list(beta0 = 0))

C_hat &lt;- C_GP(model)

# Subspace distance to true subspace:
print(subspace_dist(C_hat, matrix(act_dir, nrow = nvar), r = 1))
plot(design %*% eigen(C_hat$mat)$vectors[,1], response, 
  main = "Projection along estimated active direction")
plot(design %*% eigen(C_hat$mat)$vectors[,2], response, 
  main = "Projection along estimated inactive direction")
  
# For other plots:
# par(mfrow = c(1, 3)) # uncomment to have all plots together
plot(C_hat)
# par(mfrow = c(1, 1)) # restore graphical window

 
</code></pre>

<hr>
<h2 id='C_GP_ci'>CI on Eigenvalues via Monte Carlo/GP</h2><span id='topic+C_GP_ci'></span>

<h3>Description</h3>

<p>CI on Eigenvalues via Monte Carlo/GP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_GP_ci(model, B = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_GP_ci_+3A_model">model</code></td>
<td>
<p>A homGP model</p>
</td></tr>
<tr><td><code id="C_GP_ci_+3A_b">B</code></td>
<td>
<p>Monte Carlo iterates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements ci giving 95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
## Example of uncertainty quantification on C estimate
################################################################################
library(hetGP); library(lhs)
set.seed(42)

nvar &lt;- 2
n &lt;- 20
nits &lt;- 20

# theta gives the subspace direction
f &lt;- function(x, theta, nugget = 1e-6){
  if(is.null(dim(x))) x &lt;- matrix(x, 1)
  xact &lt;- cos(theta) * x[,1] - sin(theta) * x[,2]
  return(hetGP::f1d(xact) + rnorm(n = nrow(x), sd = rep(nugget, nrow(x))))
}

theta_dir &lt;- pi/6
act_dir &lt;- c(cos(theta_dir), -sin(theta_dir))

# Create design of experiments and initial GP model
design &lt;- X &lt;- matrix(signif(maximinLHS(n, nvar), 2), ncol = nvar)
response &lt;- Y &lt;- apply(design, 1, f, theta = theta_dir)
model &lt;- mleHomGP(design, response, known = list(beta0 =  0))

res &lt;- C_GP_ci(model)

plot(c(1, 2), log(c(mean(res$eigen_draws[,1]), mean(res$eigen_draws[,2]))),
  ylim = range(log(res$eigen_draws)), ylab = "Eigenvalue", xlab = "Index")
  segments(1, log(res$ci[1,1]), 1, log(res$ci[2,1]))
  segments(2, log(res$ci[1,2]), 2, log(res$ci[2,2]))

</code></pre>

<hr>
<h2 id='C_GP_cpp'>Equivalent of <code><a href="#topic+C_GP">C_GP</a></code> using RcppArmadillo</h2><span id='topic+C_GP_cpp'></span>

<h3>Description</h3>

<p>Equivalent of <code><a href="#topic+C_GP">C_GP</a></code> using RcppArmadillo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_GP_cpp(design, response, theta, Ki, ct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_GP_cpp_+3A_design">design</code></td>
<td>
<p>A matrix of design points, one in each row</p>
</td></tr>
<tr><td><code id="C_GP_cpp_+3A_response">response</code></td>
<td>
<p>A vector of observations at each design point.</p>
</td></tr>
<tr><td><code id="C_GP_cpp_+3A_theta">theta</code></td>
<td>
<p>vector of lengthscales</p>
</td></tr>
<tr><td><code id="C_GP_cpp_+3A_ki">Ki</code></td>
<td>
<p>inverse covariance matrix</p>
</td></tr>
<tr><td><code id="C_GP_cpp_+3A_ct">ct</code></td>
<td>
<p>Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The active subspace matrix C.
</p>

<hr>
<h2 id='C_Q'>Active subspace for second order linear model</h2><span id='topic+C_Q'></span>

<h3>Description</h3>

<p>Active subspace for second order linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_Q(design, response)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_Q_+3A_design">design</code></td>
<td>
<p>A matrix of design points, one in each row, in [-1,1]^d</p>
</td></tr>
<tr><td><code id="C_Q_+3A_response">response</code></td>
<td>
<p>A vector of observations at each design point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix corresponding to the active subspace C matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42) 
A &lt;- matrix(c(1, -1, 0, -1, 2, -1.5, 0, -1.5, 4), nrow = 3, byrow = TRUE)
b &lt;- c(1, 4, 9)

# Quadratic function
ftest &lt;- function(x, sd = 1e-6){
   if(is.null(dim(x))) x &lt;- matrix(x, nrow = 1)
   return(3 + drop(diag(x %*% A %*% t(x)) + x %*% b) + 
     rnorm(nrow(x), sd = sd))
}

ntrain &lt;- 10000
design &lt;- 2 * matrix(runif(ntrain * 3), ntrain) - 1
response &lt;- ftest(design)

C_hat &lt;- C_Q(design, response)

plot(design %*% eigen(C_hat)$vectors[,1], response)

# Test 
gfun &lt;- function(x){2 * A %*% t(x) + matrix(b, nrow = nrow(A), ncol = nrow(x))}
grads &lt;- gfun(design)
C_MC &lt;- tcrossprod(grads)/ntrain
C_true &lt;- 4/3 * A %*% A + tcrossprod(b)
subspace_dist(eigen(C_MC)$vectors[,1:2], eigen(C_true)$vectors[,1:2]) 
</code></pre>

<hr>
<h2 id='C_tr'>Expected variance of trace of C</h2><span id='topic+C_tr'></span>

<h3>Description</h3>

<p>Expected variance of trace of C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_tr(C, xnew, grad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_tr_+3A_c">C</code></td>
<td>
<p>A const_C object, the result of a call to <code><a href="#topic+C_GP">C_GP</a></code>.</p>
</td></tr>
<tr><td><code id="C_tr_+3A_xnew">xnew</code></td>
<td>
<p>The new design point</p>
</td></tr>
<tr><td><code id="C_tr_+3A_grad">grad</code></td>
<td>
<p>If <code>FALSE</code>, calculate variance of trace after update. If <code>TRUE</code>, returns the gradient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number giving the expected variance of the trace of C given the current design.
</p>


<h3>References</h3>

<p>N. Wycoff, M. Binois, S. Wild (2019+), Sequential Learning of Active Subspaces, preprint.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
################################################################################
### Variance of trace criterion landscape
################################################################################
    library(hetGP)
    set.seed(42)
    nvar &lt;- 2
    n &lt;- 20

    # theta gives the subspace direction
    f &lt;- function(x, theta = pi/6, nugget = 1e-6){
     if(is.null(dim(x))) x &lt;- matrix(x, 1)
     xact &lt;- cos(theta) * x[,1] - sin(theta) * x[,2]
     return(hetGP::f1d(xact) + 
       rnorm(n = nrow(x), sd = rep(nugget, nrow(x))))
    }

    design &lt;- matrix(signif(runif(nvar*n), 2), ncol = nvar)
    response &lt;- apply(design, 1, f)
    model &lt;- mleHomGP(design, response, lower = rep(1e-4, nvar),
                      upper = rep(0.5,nvar), known = list(g = 1e-4))
                      
    C_hat &lt;- C_GP(model)

    ngrid &lt;- 101
    xgrid &lt;- seq(0, 1,, ngrid)
    Xgrid &lt;- as.matrix(expand.grid(xgrid, xgrid))
    filled.contour(matrix(f(Xgrid), ngrid))

    Ctr_grid &lt;- apply(Xgrid, 1, C_tr, C = C_hat)
    filled.contour(matrix(Ctr_grid, ngrid), color.palette = terrain.colors,
                   plot.axes = {axis(1); axis(2); points(design, pch = 20)})

</code></pre>

<hr>
<h2 id='C_var'>Element-wise Cn+1 variance</h2><span id='topic+C_var'></span>

<h3>Description</h3>

<p>Element-wise Cn+1 variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_var(C, xnew, grad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_var_+3A_c">C</code></td>
<td>
<p>A const_C object, the result of a call to <code><a href="#topic+C_GP">C_GP</a></code>.</p>
</td></tr>
<tr><td><code id="C_var_+3A_xnew">xnew</code></td>
<td>
<p>The new design point</p>
</td></tr>
<tr><td><code id="C_var_+3A_grad">grad</code></td>
<td>
<p>If <code>FALSE</code>, calculate variance of update. If <code>TRUE</code>, returns the gradient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number giving the expected elementwise variance of C given the current design.
</p>


<h3>References</h3>

<p>N. Wycoff, M. Binois, S. Wild (2019+), Sequential Learning of Active Subspaces, preprint.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
### Norm of the variance of C criterion landscape
################################################################################
library(hetGP)
set.seed(42)
nvar &lt;- 2
n &lt;- 20

# theta gives the subspace direction
f &lt;- function(x, theta = pi/6, nugget = 1e-6){
 if(is.null(dim(x))) x &lt;- matrix(x, 1)
 xact &lt;- cos(theta) * x[,1] - sin(theta) * x[,2]
 return(hetGP::f1d(xact) 
   + rnorm(n = nrow(x), sd = rep(nugget, nrow(x))))
}

design &lt;- matrix(signif(runif(nvar*n), 2), ncol = nvar)
response &lt;- apply(design, 1, f)
model &lt;- mleHomGP(design, response, lower = rep(1e-4, nvar),
                  upper = rep(0.5,nvar), known = list(g = 1e-4))
                  
C_hat &lt;- C_GP(model)

ngrid &lt;- 51
xgrid &lt;- seq(0, 1,, ngrid)
Xgrid &lt;- as.matrix(expand.grid(xgrid, xgrid))
filled.contour(matrix(f(Xgrid), ngrid))

cvar_crit &lt;- function(C, xnew){
 return(sqrt(sum(C_var(C, xnew)^2)))
}

Cvar_grid &lt;- apply(Xgrid, 1, cvar_crit, C = C_hat)
filled.contour(matrix(Cvar_grid, ngrid), color.palette = terrain.colors,
               plot.axes = {axis(1); axis(2); points(design, pch = 20)})
</code></pre>

<hr>
<h2 id='C_var2'>Alternative Variance of Update</h2><span id='topic+C_var2'></span>

<h3>Description</h3>

<p>Defined as E[(C - E[C])^2], where A^2 = AA (not elementwise multiplication).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C_var2(C, xnew, grad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="C_var2_+3A_c">C</code></td>
<td>
<p>A const_C object, the result of a call to <code><a href="#topic+C_GP">C_GP</a></code>.</p>
</td></tr>
<tr><td><code id="C_var2_+3A_xnew">xnew</code></td>
<td>
<p>The new design point</p>
</td></tr>
<tr><td><code id="C_var2_+3A_grad">grad</code></td>
<td>
<p>If <code>FALSE</code>, calculate variance of update. If <code>TRUE</code>, returns the gradient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number giving the expected variance of C defined via matrix multiplication given the current design.
</p>


<h3>References</h3>

<p>N. Wycoff, M. Binois, S. Wild (2019+), Sequential Learning of Active Subspaces, preprint.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
### Norm of the variance of C criterion landscape
################################################################################
 
library(hetGP)
set.seed(42)
nvar &lt;- 2
n &lt;- 20

# theta gives the subspace direction
f &lt;- function(x, theta = pi/6, nugget = 1e-6){
 if(is.null(dim(x))) x &lt;- matrix(x, 1)
 xact &lt;- cos(theta) * x[,1] - sin(theta) * x[,2]
 return(hetGP::f1d(xact) + rnorm(n = nrow(x), sd = rep(nugget, nrow(x))))
}

design &lt;- matrix(signif(runif(nvar*n), 2), ncol = nvar)
response &lt;- apply(design, 1, f)
model &lt;- mleHomGP(design, response, lower = rep(1e-4, nvar),
                  upper = rep(0.5,nvar), known = list(g = 1e-4))
                  
C_hat &lt;- C_GP(model)

ngrid &lt;- 51
xgrid &lt;- seq(0, 1,, ngrid)
Xgrid &lt;- as.matrix(expand.grid(xgrid, xgrid))
filled.contour(matrix(f(Xgrid), ngrid))

cvar_crit &lt;- function(C, xnew){
 return(sqrt(sum(C_var(C, xnew)^2)))
}

Cvar_grid &lt;- apply(Xgrid, 1, cvar_crit, C = C_hat)
filled.contour(matrix(Cvar_grid, ngrid), color.palette = terrain.colors,
               plot.axes = {axis(1); axis(2); points(design, pch = 20)})

</code></pre>

<hr>
<h2 id='d1'>Get Integerodifferential Quantities</h2><span id='topic+d1'></span>

<h3>Description</h3>

<p>Returns an element related to an integral of a derivative of the desired kernel. See references for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d1(X, x, sigma, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d1_+3A_x">X</code></td>
<td>
<p>The design matrix</p>
</td></tr>
<tr><td><code id="d1_+3A_x">x</code></td>
<td>
<p>The point at which to evaluate.</p>
</td></tr>
<tr><td><code id="d1_+3A_sigma">sigma</code></td>
<td>
<p>The error variance of the model.</p>
</td></tr>
<tr><td><code id="d1_+3A_type">type</code></td>
<td>
<p>A string, one of &quot;Gaussian&quot;, &quot;Matern5_2&quot;, and &quot;Matern3_2&quot; indicating the covariance kernel to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scalar value given the integrated derivative.
</p>


<h3>References</h3>

<p>Mickael Binois, Robert B. Gramacy, Michael Ludkovski (2017), Practical Heteroscedastic Gaussian Process Modeling for Large Simulation Experiments, Journal of Computational and Graphical Statistics
</p>

<hr>
<h2 id='domain_to_R'>Rectangular Domain -&gt; Unbounded Domain</h2><span id='topic+domain_to_R'></span>

<h3>Description</h3>

<p>Given an m dimensional function whose inputs live in bounded intervals [a1, b1], ..., [am, bm], return a wrapped version of the function whose inputs live in R^m. Transformed using the logit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_to_R(f, domain)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="domain_to_R_+3A_f">f</code></td>
<td>
<p>The function to wrap, should have a single vector-valued input.</p>
</td></tr>
<tr><td><code id="domain_to_R_+3A_domain">domain</code></td>
<td>
<p>A list of real tuples, indicating the original domain of the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function wrapping f.
</p>

<hr>
<h2 id='domain_to_unit'>Change a function's inputs to live in [-1, 1]</h2><span id='topic+domain_to_unit'></span>

<h3>Description</h3>

<p>Given an m dimensional function whose inputs live in bounded intervals [a1, b1], ..., [am, bm], return a wrapped version of the function whose inputs live in [-1, 1], ..., [-1, 1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_to_unit(f, domain)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="domain_to_unit_+3A_f">f</code></td>
<td>
<p>The function to wrap, should have a single vector-valued input.</p>
</td></tr>
<tr><td><code id="domain_to_unit_+3A_domain">domain</code></td>
<td>
<p>A list of real tuples, indicating the original domain of the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function wrapping f.
</p>

<hr>
<h2 id='get_betagamma'>Quantities for Acquisition Functions</h2><span id='topic+get_betagamma'></span>

<h3>Description</h3>

<p>Create a single element of the BETA/GAMMA matrix. Used to compute acquisition functions and their gradients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_betagamma(C, xnew, grad = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_betagamma_+3A_c">C</code></td>
<td>
<p>A const_C object, the result of a call to C_GP</p>
</td></tr>
<tr><td><code id="get_betagamma_+3A_xnew">xnew</code></td>
<td>
<p>The new design point</p>
</td></tr>
<tr><td><code id="get_betagamma_+3A_grad">grad</code></td>
<td>
<p>If <code>FALSE</code>, calculate beta and gamma only. If <code>TRUE</code>, calculate their gradient too.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>grad == FALSE</code>, A numeric vector of length 2, whose first element of beta_ij and the second gamma_ij. 
If <code>grad == TRUE</code>, a list with 3 numeric vector elements, the first giving the gradient for beta_ij, and the second for gamma_ij,
and the third is the same vector as would have been returned if grad was <code>FALSE</code>: simply the values of beta and gamma.
</p>

<hr>
<h2 id='grad_est_subspace'>Estimate the Active Subspace of a Cheap Function using Gradients</h2><span id='topic+grad_est_subspace'></span>

<h3>Description</h3>

<p>Looks between [-1, 1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_est_subspace(f, r, m, M = NULL, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grad_est_subspace_+3A_f">f</code></td>
<td>
<p>The function to eval</p>
</td></tr>
<tr><td><code id="grad_est_subspace_+3A_r">r</code></td>
<td>
<p>The max dim of the active subspace</p>
</td></tr>
<tr><td><code id="grad_est_subspace_+3A_m">m</code></td>
<td>
<p>The dimension of the underlying/embedding space.</p>
</td></tr>
<tr><td><code id="grad_est_subspace_+3A_m">M</code></td>
<td>
<p>optional budget of evaluations, default to <code>2 * r * log(m)</code></p>
</td></tr>
<tr><td><code id="grad_est_subspace_+3A_scale">scale</code></td>
<td>
<p>Scale all gradients to have norm 1?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with sub, the active subspace, sv, the singular values (all m of them), fs, which gives function values, gs, function grads, and X, which gives sampled locations.
</p>

<hr>
<h2 id='grad_W_kappa_ij2'>Covariance of kernel computations</h2><span id='topic+grad_W_kappa_ij2'></span>

<h3>Description</h3>

<p>Computes gradient of Int(kappa_i(X, design1) . kappa_j(design2, X)) with respect to the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_W_kappa_ij2(design1, design2, theta, i1, i2, ct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grad_W_kappa_ij2_+3A_design1">design1</code></td>
<td>
<p>A vector representing a new point.</p>
</td></tr>
<tr><td><code id="grad_W_kappa_ij2_+3A_design2">design2</code></td>
<td>
<p>matrices of design points</p>
</td></tr>
<tr><td><code id="grad_W_kappa_ij2_+3A_theta">theta</code></td>
<td>
<p>lengthscales</p>
</td></tr>
<tr><td><code id="grad_W_kappa_ij2_+3A_i1">i1</code>, <code id="grad_W_kappa_ij2_+3A_i2">i2</code></td>
<td>
<p>index of the derivatives (WARNING: starts at 0)</p>
</td></tr>
<tr><td><code id="grad_W_kappa_ij2_+3A_ct">ct</code></td>
<td>
<p>Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of size nrow(design1) x nrow(design2)
</p>

<hr>
<h2 id='grad_W_kappa_ij2_w2'>Covariance of kernel computations</h2><span id='topic+grad_W_kappa_ij2_w2'></span>

<h3>Description</h3>

<p>Computes gradient of Int(kappa_i(X, design1) . kappa_j(design2, X)) with respect to the second argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad_W_kappa_ij2_w2(design1, design2, theta, i1, i2, ct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grad_W_kappa_ij2_w2_+3A_design1">design1</code></td>
<td>
<p>A vector representing a new point.</p>
</td></tr>
<tr><td><code id="grad_W_kappa_ij2_w2_+3A_design2">design2</code></td>
<td>
<p>matrices of design points</p>
</td></tr>
<tr><td><code id="grad_W_kappa_ij2_w2_+3A_theta">theta</code></td>
<td>
<p>lengthscales</p>
</td></tr>
<tr><td><code id="grad_W_kappa_ij2_w2_+3A_i1">i1</code>, <code id="grad_W_kappa_ij2_w2_+3A_i2">i2</code></td>
<td>
<p>index of the derivatives (WARNING: starts at 0)</p>
</td></tr>
<tr><td><code id="grad_W_kappa_ij2_w2_+3A_ct">ct</code></td>
<td>
<p>Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of size nrow(design1) x nrow(design2)
</p>

<hr>
<h2 id='logLikHessian'>Hessian of the log-likelihood with respect to lengthscales hyperparameters
Works for homGP and hetGP models from the hetGP package for now.</h2><span id='topic+logLikHessian'></span>

<h3>Description</h3>

<p>Hessian of the log-likelihood with respect to lengthscales hyperparameters
Works for homGP and hetGP models from the hetGP package for now.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLikHessian(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLikHessian_+3A_model">model</code></td>
<td>
<p>homGP model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix giving the Hessian of the GP loglikelihood.
</p>

<hr>
<h2 id='Lt_GP'>Active Subspace Prewarping</h2><span id='topic+Lt_GP'></span>

<h3>Description</h3>

<p>Computes a matrix square root of C = Lt 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lt_GP(..., C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lt_GP_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to C_GP, if C was not provided.</p>
</td></tr>
<tr><td><code id="Lt_GP_+3A_c">C</code></td>
<td>
<p>the result of a call to C_GP. If provided, all other arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix Lt which can be used for sensitivity prewarping, i.e. by computing Xw = X 
</p>

<hr>
<h2 id='n11_2_01'>f:[-1, 1] -&gt; R Becomes f:[0,1] -&gt; R</h2><span id='topic+n11_2_01'></span>

<h3>Description</h3>

<p>f:[-1, 1] -&gt; R Becomes f:[0,1] -&gt; R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n11_2_01(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n11_2_01_+3A_f">f</code></td>
<td>
<p>initial function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same function with domain shifted.
</p>

<hr>
<h2 id='plot.const_C'>Plot const_C objectc</h2><span id='topic+plot.const_C'></span>

<h3>Description</h3>

<p>Plot const_C objectc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'const_C'
plot(x, output = c("all", "matrix", "logvals", "projfn"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.const_C_+3A_x">x</code></td>
<td>
<p>A const_C object, the result of a call to C_GP</p>
</td></tr>
<tr><td><code id="plot.const_C_+3A_output">output</code></td>
<td>
<p>one of <code>"image"</code> (image of the C matrix), <code>"logvals"</code> (log-eigen values), 
<code>"projfn"</code> projected function on first eigen vector or all plots at once (default).</p>
</td></tr>
<tr><td><code id="plot.const_C_+3A_...">...</code></td>
<td>
<p>Additional parameters. Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='print.const_C'>Print const_C objects</h2><span id='topic+print.const_C'></span>

<h3>Description</h3>

<p>Print const_C objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'const_C'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.const_C_+3A_x">x</code></td>
<td>
<p>A const_C object, the result of a call to C_GP</p>
</td></tr>
<tr><td><code id="print.const_C_+3A_...">...</code></td>
<td>
<p>Additional parameters. Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='quick_C'>Covariance of kernel computations</h2><span id='topic+quick_C'></span>

<h3>Description</h3>

<p>Computes Int(kappa_i(X, design) . kappa_j(design, X)). This function is preferred for initialization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quick_C(measure, design, Ki, Kir, theta, xm, xv, ct, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quick_C_+3A_measure">measure</code></td>
<td>
<p>An integer giving the measure of integration. 0 for Lebesgue/Uniform on [0,1]^m, 1 for (truncated) Gaussian on [0,1]^m, 2 for Gaussian on R^m.</p>
</td></tr>
<tr><td><code id="quick_C_+3A_design">design</code></td>
<td>
<p>matrix of design points</p>
</td></tr>
<tr><td><code id="quick_C_+3A_ki">Ki</code></td>
<td>
<p>The inverse covariance matrix</p>
</td></tr>
<tr><td><code id="quick_C_+3A_kir">Kir</code></td>
<td>
<p>The inverse covariance matrix times the response.</p>
</td></tr>
<tr><td><code id="quick_C_+3A_theta">theta</code></td>
<td>
<p>lengthscales</p>
</td></tr>
<tr><td><code id="quick_C_+3A_xm">xm</code></td>
<td>
<p>The mean vector associated with the Gaussian measure. Ignored if uniform.</p>
</td></tr>
<tr><td><code id="quick_C_+3A_xv">xv</code></td>
<td>
<p>The variance vector associated with the Gaussian measure (diagonal of covariance matrix, vars assumed independent). Ignored if uniform.</p>
</td></tr>
<tr><td><code id="quick_C_+3A_ct">ct</code></td>
<td>
<p>Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix representing the result of the integration.
</p>

<hr>
<h2 id='subspace_dist'>Get the distance between subspaces defined as the ranges of A and B</h2><span id='topic+subspace_dist'></span>

<h3>Description</h3>

<p>Get the distance between subspaces defined as the ranges of A and B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subspace_dist(A, B, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subspace_dist_+3A_a">A</code></td>
<td>
<p>A matrix or const_C object.</p>
</td></tr>
<tr><td><code id="subspace_dist_+3A_b">B</code></td>
<td>
<p>Another matrix with the same number of rows as A, or const_C object of the same dimension.</p>
</td></tr>
<tr><td><code id="subspace_dist_+3A_r">r</code></td>
<td>
<p>A scalar integer, the dimension of the subspace to compare (only necessary if either A or B is a const_C object).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nonnegative scalar giving the cosine of the first principle angle between the two subspaces.
</p>

<hr>
<h2 id='update_C2'>Update Constantine's C, using update formula</h2><span id='topic+update_C2'></span>

<h3>Description</h3>

<p>Update Constantine's C, using update formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_C2(C, xnew, ynew)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_C2_+3A_c">C</code></td>
<td>
<p>A const_C object, the result of a call to <code><a href="#topic+C_GP">C_GP</a></code>.</p>
</td></tr>
<tr><td><code id="update_C2_+3A_xnew">xnew</code></td>
<td>
<p>The new design point</p>
</td></tr>
<tr><td><code id="update_C2_+3A_ynew">ynew</code></td>
<td>
<p>The new response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated C matrix, a const_C object.
</p>


<h3>References</h3>

<p>N. Wycoff, M. Binois, S. Wild (2019+), Sequential Learning of Active Subspaces, preprint.<br />
</p>

<hr>
<h2 id='update.const_C'>C update with new observations</h2><span id='topic+update.const_C'></span>

<h3>Description</h3>

<p>Update Constantine's C with new point(s) for a GP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'const_C'
update(object, Xnew, Znew, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.const_C_+3A_object">object</code></td>
<td>
<p>A const_C object, the result of a call to the C_GP function.</p>
</td></tr>
<tr><td><code id="update.const_C_+3A_xnew">Xnew</code></td>
<td>
<p>matrix (one point per row) corresponding to the new designs</p>
</td></tr>
<tr><td><code id="update.const_C_+3A_znew">Znew</code></td>
<td>
<p>vector of size <code>nrow(Xnew)</code> for the new responses at <code>Xnew</code></p>
</td></tr>
<tr><td><code id="update.const_C_+3A_...">...</code></td>
<td>
<p>not used (for consistency of update method)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated const_C object originally provided.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+C_GP">C_GP</a></code> to generate const_C objects from <code><a href="hetGP.html#topic+mleHomGP">mleHomGP</a></code> objects; <code><a href="#topic+update_C2">update_C2</a></code> for an update using faster expressions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
################################################################################
### Active subspace of a Gaussian process
################################################################################
library(hetGP); library(lhs)
set.seed(42)

nvar &lt;- 2
n &lt;- 100

# theta gives the subspace direction
f &lt;- function(x, theta, nugget = 1e-3){
  if(is.null(dim(x))) x &lt;- matrix(x, 1)
  xact &lt;- cos(theta) * x[,1] - sin(theta) * x[,2]
  return(hetGP::f1d(xact) + 
    rnorm(n = nrow(x), sd = rep(nugget, nrow(x))))
}

theta_dir &lt;- pi/6
act_dir &lt;- c(cos(theta_dir), -sin(theta_dir))

# Create design of experiments and initial GP model
design &lt;- X &lt;- matrix(signif(maximinLHS(n, nvar), 2), ncol = nvar)
response &lt;- Y &lt;- apply(design, 1, f, theta = theta_dir)
model &lt;- mleHomGP(design, response, known = list(beta0 = 0))

C_hat &lt;- C_GP(model)

print(C_hat)
print(subspace_dist(C_hat, matrix(act_dir, nrow = nvar), r = 1))

# New designs
Xnew &lt;- matrix(runif(2), 1)
Znew &lt;- f(Xnew, theta_dir)

C_new &lt;- update(C_hat, Xnew, Znew)
print(C_new)
subspace_dist(C_new, matrix(act_dir, nrow = nvar), r = 1)

</code></pre>

<hr>
<h2 id='W_kappa_ij'>Covariance of kernel computations</h2><span id='topic+W_kappa_ij'></span>

<h3>Description</h3>

<p>Computes Int(kappa_i(X, design) . kappa_j(design, X)). This function is preferred for initialization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_kappa_ij(design, theta, i1, i2, ct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="W_kappa_ij_+3A_design">design</code></td>
<td>
<p>matrix of design points</p>
</td></tr>
<tr><td><code id="W_kappa_ij_+3A_theta">theta</code></td>
<td>
<p>lengthscales</p>
</td></tr>
<tr><td><code id="W_kappa_ij_+3A_i1">i1</code>, <code id="W_kappa_ij_+3A_i2">i2</code></td>
<td>
<p>index of the derivatives (WARNING: starts at 0)</p>
</td></tr>
<tr><td><code id="W_kappa_ij_+3A_ct">ct</code></td>
<td>
<p>Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix representing the result of the integration.
</p>

<hr>
<h2 id='W_kappa_ij_up'>Covariance of kernel computations</h2><span id='topic+W_kappa_ij_up'></span>

<h3>Description</h3>

<p>Computes Int(kappa_i(X, design) . kappa_j(design, X)). This function is preferred for updates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_kappa_ij_up(W, design, theta, i1, i2, start, ct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="W_kappa_ij_up_+3A_w">W</code></td>
<td>
<p>The matrix to store the computation in</p>
</td></tr>
<tr><td><code id="W_kappa_ij_up_+3A_design">design</code></td>
<td>
<p>matrix of design points</p>
</td></tr>
<tr><td><code id="W_kappa_ij_up_+3A_theta">theta</code></td>
<td>
<p>lengthscales</p>
</td></tr>
<tr><td><code id="W_kappa_ij_up_+3A_i1">i1</code>, <code id="W_kappa_ij_up_+3A_i2">i2</code></td>
<td>
<p>index of the derivatives (WARNING: starts at 0)</p>
</td></tr>
<tr><td><code id="W_kappa_ij_up_+3A_start">start</code></td>
<td>
<p>The column/row index at which to start the computation (doesn't touch the start by start submatrix).</p>
</td></tr>
<tr><td><code id="W_kappa_ij_up_+3A_ct">ct</code></td>
<td>
<p>Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>W is modified in-place.
</p>

<hr>
<h2 id='W_kappa_ij2'>Covariance of kernel computations</h2><span id='topic+W_kappa_ij2'></span>

<h3>Description</h3>

<p>Computes Int(kappa_i(X, design1) . kappa_j(design2, X)). This function is preferred for initialization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_kappa_ij2(design1, design2, theta, i1, i2, ct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="W_kappa_ij2_+3A_design1">design1</code>, <code id="W_kappa_ij2_+3A_design2">design2</code></td>
<td>
<p>matrices of design points</p>
</td></tr>
<tr><td><code id="W_kappa_ij2_+3A_theta">theta</code></td>
<td>
<p>lengthscales</p>
</td></tr>
<tr><td><code id="W_kappa_ij2_+3A_i1">i1</code>, <code id="W_kappa_ij2_+3A_i2">i2</code></td>
<td>
<p>index of the derivatives (WARNING: starts at 0)</p>
</td></tr>
<tr><td><code id="W_kappa_ij2_+3A_ct">ct</code></td>
<td>
<p>Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of size nrow(design1) x nrow(design2)
</p>

<hr>
<h2 id='W_kappa_lk'>Covariance of kernel computations</h2><span id='topic+W_kappa_lk'></span>

<h3>Description</h3>

<p>Creates a submatrix of the same tensor as W_kappa_ij, but this time l,k give the indices of the observations, not variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_kappa_lk(design, theta, i1, i2, ct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="W_kappa_lk_+3A_design">design</code></td>
<td>
<p>matrix of design points</p>
</td></tr>
<tr><td><code id="W_kappa_lk_+3A_theta">theta</code></td>
<td>
<p>lengthscales</p>
</td></tr>
<tr><td><code id="W_kappa_lk_+3A_i1">i1</code>, <code id="W_kappa_lk_+3A_i2">i2</code></td>
<td>
<p>index of the observations (WARNING: starts at 0)</p>
</td></tr>
<tr><td><code id="W_kappa_lk_+3A_ct">ct</code></td>
<td>
<p>Covariance type, 1 means Gaussian, 2 means Matern 3/2, 3 means Matern 5/2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix representing the result of the integration.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
