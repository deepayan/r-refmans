<!DOCTYPE html><html><head><title>Help for package healthyAddress</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {healthyAddress}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.digit256'><p>Extract the n-th digit of a duocentehexaquinquagesimal number</p></a></li>
<li><a href='#.permitted_street_type_ord'><p>Street types allowed.</p></a></li>
<li><a href='#extract_flatNumberFirstLast'><p>Extract the flat number, number first/last from an address</p></a></li>
<li><a href='#extract_postcode'><p>Extract the postcode from the suffix of a string</p></a></li>
<li><a href='#HashStreetName'><p>Hash a street name quickly and accurately</p></a></li>
<li><a href='#healthyAddress-package'><p>Package for address standardization</p></a></li>
<li><a href='#match_StreetType'><p>Find the street type within an address</p></a></li>
<li><a href='#match_word'><p>Find word within a sentence</p></a></li>
<li><a href='#nany_lowercase'><p>Uppercase character vectors</p></a></li>
<li><a href='#postcode2ste'><p>In what states do postcodes lie?</p></a></li>
<li><a href='#read_ste_fst'><p>Get internal data</p></a></li>
<li><a href='#standardize_address'><p>Standard address</p></a></li>
<li><a href='#toupper_basic'><p>Uppercase</p></a></li>
<li><a href='#unique_Postcodes'><p>Unique postcodes of</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Convert Addresses to Standard Inputs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient tools for parsing and standardizing Australian 
    addresses from textual data. It utilizes optimized algorithms to accurately identify and 
    extract components of addresses, such as street names, types, and postcodes, especially  
    for large batched data in contexts where sending addresses to internet services may be 
    slow or inappropriate. The core functionality is built on fast string processing techniques 
    to handle variations in address formats and abbreviations commonly found in Australian 
    address data. Designed for data scientists, urban planners, and logistics analysts, the 
    package facilitates the cleaning and normalization of address information, supporting 
    better data integration and analysis in urban studies, geography, and related fields.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, fastmatch, fst, hutils, hutilscpp, magrittr, qs,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 10:36:33 UTC; hughp</td>
</tr>
<tr>
<td>Author:</td>
<td>Hugh Parsonage [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hugh Parsonage &lt;hugh.parsonage@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 17:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='.digit256'>Extract the n-th digit of a duocentehexaquinquagesimal number</h2><span id='topic+.digit256'></span>

<h3>Description</h3>

<p>Extract the n-th digit of a duocentehexaquinquagesimal number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.digit256(x, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".digit256_+3A_x">x</code></td>
<td>
<p><code>integer(n)</code></p>
</td></tr>
<tr><td><code id=".digit256_+3A_d">d</code></td>
<td>
<p><code>integer(1)</code> One of 0:3.  Other integers silently return <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>b = 256</code>
if </p>
<p style="text-align: center;"><code class="reqn">x = a_0 + a_1b + a_2b^2 + a_3b^3</code>
</p>

<p>then <code>.digit(x, d) = a_d</code>
</p>

<hr>
<h2 id='.permitted_street_type_ord'>Street types allowed.</h2><span id='topic+.permitted_street_type_ord'></span>

<h3>Description</h3>

<p>Street types allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.permitted_street_type_ord()
</code></pre>


<h3>Value</h3>

<p>A character vector, the permitted street codes. In order of
(approximate) occurrence; more common street types appear in the head
of the vector.
</p>

<hr>
<h2 id='extract_flatNumberFirstLast'>Extract the flat number, number first/last from an address</h2><span id='topic+extract_flatNumberFirstLast'></span>

<h3>Description</h3>

<p>Extract the flat number, number first/last from an address
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_flatNumberFirstLast(address)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_flatNumberFirstLast_+3A_address">address</code></td>
<td>
<p>A character vector from which the numbers are to be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> of three components: the flat number,
the number first, and number last.
</p>

<hr>
<h2 id='extract_postcode'>Extract the postcode from the suffix of a string</h2><span id='topic+extract_postcode'></span>

<h3>Description</h3>

<p>Extract the postcode from the suffix of a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_postcode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_postcode_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector the same length as <code>x</code>, giving the
postcode as it appears in the last 3 or 4 characters in each
string. Returns <code>NA_integer_</code> for other strings.
</p>
<p>There is no guarantee made that the postcode is a real postcode.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_postcode("3000")
extract_postcode("Melbourne Vic 3000")

</code></pre>

<hr>
<h2 id='HashStreetName'>Hash a street name quickly and accurately</h2><span id='topic+HashStreetName'></span><span id='topic+unHashStreetName'></span>

<h3>Description</h3>

<p>Hash a street name quickly and accurately
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HashStreetName(x)

unHashStreetName(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HashStreetName_+3A_x">x</code></td>
<td>
<p>A character vector of uppercase street names (without the street type).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>HashStreetName</code>, an integer vector the same length as <code>x</code>,
a hash of the input; for <code>unHashStreetName</code> the inverse operation.
</p>
<p>If the original <code>x</code> does not contain a recognized street name, the
result of <code>unHashStreetName</code> will be <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HashStreetName("FLINDERS")


</code></pre>

<hr>
<h2 id='healthyAddress-package'>Package for address standardization</h2><span id='topic+healthyAddress'></span><span id='topic+healthyAddress-package'></span>

<h3>Description</h3>

<p>Efficient tools for parsing and standardizing Australian addresses from textual data. It utilizes optimized algorithms to accurately identify and extract components of addresses, such as street names, types, and postcodes, especially for large batched data in contexts where sending addresses to internet services may be slow or inappropriate. The core functionality is built on fast string processing techniques to handle variations in address formats and abbreviations commonly found in Australian address data. Designed for data scientists, urban planners, and logistics analysts, the package facilitates the cleaning and normalization of address information, supporting better data integration and analysis in urban studies, geography, and related fields.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hugh Parsonage <a href="mailto:hugh.parsonage@gmail.com">hugh.parsonage@gmail.com</a>
</p>

<hr>
<h2 id='match_StreetType'>Find the street type within an address</h2><span id='topic+match_StreetType'></span>

<h3>Description</h3>

<p>Find the street type within an address
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_StreetType(address)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_StreetType_+3A_address">address</code></td>
<td>
<p>A character vector, every string an address.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements. The first element are the indices of
street type in <code>.permitted_street_type_ord()</code> that is found in the
address. The second element are the corresponding string positions of
the street so identified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cds &lt;- .permitted_street_type_ord()
head(cds)
match_StreetType("712 FLINDERS STREET MELBOURNE 3004")
#                 012345678901234
match_StreetType("712 FLINDERS ST MELBOURNE 3004")

</code></pre>

<hr>
<h2 id='match_word'>Find word within a sentence</h2><span id='topic+match_word'></span>

<h3>Description</h3>

<p>Find word within a sentence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_word(x, tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_word_+3A_x">x</code></td>
<td>
<p>A character vector of uppercase sentences.</p>
</td></tr>
<tr><td><code id="match_word_+3A_tbl">tbl</code></td>
<td>
<p>A table of words. Long vectors are not permitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector the same length as <code>x</code>, where the
<code>i</code>-th entry
is the integer position of the first word in <code>tbl</code>
detected in <code>x[i]</code>. Non-matches return <code>NA</code>. Words
are strings of uppercase separated by spaces.
</p>

<hr>
<h2 id='nany_lowercase'>Uppercase character vectors</h2><span id='topic+nany_lowercase'></span>

<h3>Description</h3>

<p>Ensures all elements of a character vector are uppercase;
no lowercase characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nany_lowercase(x, nThread = getOption("healthyAddress.nThread", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nany_lowercase_+3A_x">x</code></td>
<td>
<p>A character vector, of ASCII elements.</p>
</td></tr>
<tr><td><code id="nany_lowercase_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>nany_lowercase</code></dt><dd><p><code>FALSE</code> if any char in <code>x</code> is a lowercase letter.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>nany_lowercase("ABC")
nany_lowercase("ABC 123 /--")
nany_lowercase("ABC 123 /-- z")

</code></pre>

<hr>
<h2 id='postcode2ste'>In what states do postcodes lie?</h2><span id='topic+postcode2ste'></span>

<h3>Description</h3>

<p>While for most postcodes, the state enclosing it
is easy to evaluate (e.g. most postcodes in 2000-2999 are in NSW),
the general case is non-trivial. In particular, some postcodes
straddle state borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postcode2ste(Postcodes, result = c("integer", "character"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postcode2ste_+3A_postcodes">Postcodes</code></td>
<td>
<p>An integer vector of postcodes.</p>
</td></tr>
<tr><td><code id="postcode2ste_+3A_result">result</code></td>
<td>
<p>One of <code>"integer"</code> or <code>"character"</code>.
If <code>"character"</code> the abbreviated state names(s) are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, the minimal states that cover all postcodes given. For example,
if all postcodes lie within a single state a scalar integer/string of that
state is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vic_poa &lt;- c(3021L, 3084L, 3013L, 3147L, 3030L,
             3123L, 3070L, 3004L, 3250L, 3630L)

postcode2ste(vic_poa)
postcode2ste(vic_poa, result = "character")
postcode2ste(c(vic_poa, 2000L))
postcode2ste(3644L)

</code></pre>

<hr>
<h2 id='read_ste_fst'>Get internal data</h2><span id='topic+read_ste_fst'></span>

<h3>Description</h3>

<p>Get internal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ste_fst(
  ste = c("ACT", "NSW", "NT", "OT", "QLD", "SA", "TAS", "VIC", "WA"),
  columns = NULL,
  data_env = getOption("healthyAddress.data_env"),
  data_dir = getOption("healthyAddress.data_dir", tempfile()),
  rbind = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ste_fst_+3A_ste">ste</code></td>
<td>
<p>The abbreviated state name.</p>
</td></tr>
<tr><td><code id="read_ste_fst_+3A_columns">columns</code></td>
<td>
<p>Character vector of columns to select. If <code>NULL</code>, all columns are selected.</p>
</td></tr>
<tr><td><code id="read_ste_fst_+3A_data_env">data_env</code></td>
<td>
<p>The environment in which objects are cached. Mainly for
internal use.</p>
</td></tr>
<tr><td><code id="read_ste_fst_+3A_data_dir">data_dir</code></td>
<td>
<p>The file directory into which the downloaded files should be
stored. Defaults to a temporary directory. It is recommended to set the option
<code>healthyAddress.data_dir</code> so that subsequent calls to this function do not
result in unnecessary downloads.</p>
</td></tr>
<tr><td><code id="read_ste_fst_+3A_rbind">rbind</code></td>
<td>
<p>Whether or not to bind the list result should multiple states
be requested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing all the addresses in the given states.
</p>

<hr>
<h2 id='standardize_address'>Standard address</h2><span id='topic+standardize_address'></span><span id='topic+standard_address2'></span><span id='topic+standard_address3'></span>

<h3>Description</h3>

<p>Standardize an address from a free text expression into its
components as used in the PSMA (formerly, &quot;Public Sector for Mapping Agencies&quot;)
database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_address(
  Address,
  AddressLine2 = NULL,
  return.type = c("data.table", "integer"),
  integer_StreetType = FALSE,
  hash_StreetName = FALSE,
  check = 1L,
  nThread = getOption("healthyAddress.nThread", 1L)
)

standard_address2(Address, nThread = getOption("healthyAddres.nThread", 1L))

standard_address3(Line1, Line2, Postcode = NULL, KeepStreetName = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_address_+3A_address">Address</code></td>
<td>
<p>A character vector, either a full address or (if <code>AddressLine2</code>
is not <code>NULL</code>) the first line of an Australian address.</p>
</td></tr>
<tr><td><code id="standardize_address_+3A_addressline2">AddressLine2</code></td>
<td>
<p>Either <code>NULL</code> (the default) or a character vector,
the same length as <code>Address</code> giving the second line of the Address.</p>
</td></tr>
<tr><td><code id="standardize_address_+3A_return.type">return.type</code></td>
<td>
<p>Either <code>"data.table"</code> or <code>"integer"</code>.
<code>"data.table"</code> implies a table of columns separating the address components.
<code>"integer"</code> means an integer vector creating a bijection between the
address and the <code>PSMA</code> internal id.</p>
</td></tr>
<tr><td><code id="standardize_address_+3A_integer_streettype">integer_StreetType</code></td>
<td>
<p>Should the street type be returned as an integer
vector?</p>
</td></tr>
<tr><td><code id="standardize_address_+3A_hash_streetname">hash_StreetName</code></td>
<td>
<p>Should <code>STREET_NAME</code> be returned as an integer hash,
as in <code><a href="#topic+HashStreetName">HashStreetName</a></code>?</p>
</td></tr>
<tr><td><code id="standardize_address_+3A_check">check</code></td>
<td>
<p>An integer, whether the inputs should be checked for possibly
invalid addresses or addresses that may not be parsed correctly.</p>
</td></tr>
<tr><td><code id="standardize_address_+3A_nthread">nThread</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="standardize_address_+3A_line1">Line1</code>, <code id="standardize_address_+3A_line2">Line2</code>, <code id="standardize_address_+3A_postcode">Postcode</code></td>
<td>
<p>For addresses split by line. <code>Line1</code> is
assumed to end with the street type. The second line is only used to determine
<code>Postcode</code>, and then only if it is <code>NULL</code>, the default.</p>
</td></tr>
<tr><td><code id="standardize_address_+3A_keepstreetname">KeepStreetName</code></td>
<td>
<p>Should an additional character vector be included in
the result of the street name?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By convention observed in the PSMA, street names such as 'THE ESPLANADE' have
a street name of 'THE ESPLANADE' and an absent street type code.
</p>
<p>Non-addresses passed have unspecified behaviour, though usually the
numbers of the standard address will be 0 or NA. Postcodes may be negative
in some circumstances where a postcode is not detected,
though this should not be relied on.
</p>
<p>For maximum performance, consider setting <code>integer_StreetType</code> and
<code>hash_StreetName</code> to <code>TRUE</code>. It has been observed that joining
two tables together has been faster when using the hash of the standardized
street name, rather than the street name, even when taking into account
the hashing process.
</p>
<p>For performance reasons, addresses with more than 32 words are not supported.
</p>
<p>If a postcode-like number exists at the end of a <code>Address</code>, but is not
in fact a postcode, then <code>NA</code> will be in each field, except postcode,
which will have the value -1.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> containing columns indicating the components of the standard address:
</p>

<dl>
<dt><code>FLAT_NUMBER</code></dt><dd><p>The flat or unit number. This includes things like SHOP number.</p>
</dd>
<dt><code>NUMBER_FIRST</code></dt><dd><p>As used in the PSMA, this identified the first (or only) number
in the address range.</p>
</dd>
<dt><code>NUMBER_LAST</code></dt><dd><p>As used in the PSMA, if an address is marked as having
a range of street numbers, the last of the range.</p>
</dd>
<dt><code>NUMBER_SUFFIX</code></dt><dd><p>A <code>raw</code> vector. The suffix observed after the numbers. The PSMA
technically has multiple suffixes for each number component.</p>
</dd>
<dt><code>H0</code></dt><dd><p>If <code>hash_StreetName = TRUE</code>, the DJB2 hash (as used in
<code><a href="#topic+HashStreetName">HashStreetName</a></code> of the street name.). Observed to have performance
benefits.</p>
</dd>
<dt><code>STREET_NAME</code></dt><dd><p>The (uppercase) of the street name. Streets such
as 'THE ESPLANADE' or 'THE AVENUE' are treated as entirely made up of a street
name and have a <code>STREET_TYPE_CODE</code> of zero.</p>
</dd>
<dt><code>STREET_TYPE_CODE</code></dt><dd><p>An integer, the street type code marking the type
of street such as ROAD, STREET, AVENUE, etc. They code corresponds approximately
to the rank of their frequency in addresses.</p>
</dd>
<dt><code>STREET_TYPE</code></dt><dd><p>If <code>integer_StreetType = FALSE</code>, then the (uppercase)
standard name of the street type.</p>
</dd>
<dt><code>POSTCODE</code></dt><dd><p>An integer vector, the postcode observed.</p>
</dd>
</dl>


<hr>
<h2 id='toupper_basic'>Uppercase</h2><span id='topic+toupper_basic'></span>

<h3>Description</h3>

<p>Uppercase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toupper_basic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toupper_basic_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same as <code>toupper(x)</code> for ASCII entries. For implementation
reasons, strings wider than 32767 characters (bytes) will be ignored.
</p>

<hr>
<h2 id='unique_Postcodes'>Unique postcodes of</h2><span id='topic+unique_Postcodes'></span>

<h3>Description</h3>

<p>Unique postcodes of
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_Postcodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_Postcodes_+3A_x">x</code></td>
<td>
<p>An integer vector of postcodes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (sorted) integer vector of the unique, non-NA values in <code>x</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
