<!DOCTYPE html><html lang="en"><head><title>Help for package HMMextra0s</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HMMextra0s}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HMMextra0s-package'>
<p>Hidden Markov Models with Extra Zeros Hidden Markov Models (HMMs) with Extra Zeros</p></a></li>
<li><a href='#cumdist.hmm0norm'>
<p>Cumulative distribution of an HMM with Extra Zeros</p></a></li>
<li><a href='#hmm0norm'>
<p>Parameter Estimation of an HMM with Extra Zeros</p></a></li>
<li><a href='#hmm0norm2d'>
<p>Parameter Estimation of a bivariate HMM with Extra Zeros</p></a></li>
<li><a href='#Kii'>
<p>Tremor data in the Kii region in 2002 and 2003 for use in function hmm0norm2d</p></a></li>
<li><a href='#plotVitloc2d'>
<p>Plot the Classified 2-D Data of a Bivariate HMM With Extra Zeros</p></a></li>
<li><a href='#plotVitpath2d'>
<p>Plot the Viterbi Path of a Bivariate HMM With Extra Zeros</p></a></li>
<li><a href='#sim.hmm0norm'>
<p>Simulation of a 1-D HMM with Extra Zeros</p></a></li>
<li><a href='#sim.hmm0norm2d'>
<p>Simulation of a Bivariate HMM with Extra Zeros</p></a></li>
<li><a href='#Viterbi.hmm0norm'>
<p>Viterbi Path of a 1-D HMM with Extra Zeros</p></a></li>
<li><a href='#Viterbi.hmm0norm2d'>
<p>Viterbi Path of a Bivariate HMM with Extra Zeros</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hidden Markov Models with Extra Zeros</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, ellipse</td>
</tr>
<tr>
<td>Suggests:</td>
<td>HiddenMarkov</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Ting Wang, Wolfgang Hayek, and Alexander Pletzer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ting Wang &lt;ting.wang@otago.ac.nz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions for hidden Markov models with observations having extra zeros as defined in the following two publications, Wang, T., Zhuang, J., Obara, K. and Tsuruoka, H. (2016) &lt;<a href="https://doi.org/10.1111%2Frssc.12194">doi:10.1111/rssc.12194</a>&gt;; Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) &lt;<a href="https://doi.org/10.1029%2F2017JB015360">doi:10.1029/2017JB015360</a>&gt;. The observed response variable is either univariate or bivariate Gaussian conditioning on presence of events, and extra zeros mean that the response variable takes on the value zero if nothing is happening. Hence the response is modelled as a mixture distribution of a Bernoulli variable and a continuous variable. That is, if the Bernoulli variable takes on the value 1, then the response variable is Gaussian, and if the Bernoulli variable takes on the value 0, then the response is zero too. This package includes functions for simulation, parameter estimation, goodness-of-fit, the Viterbi algorithm, and plotting the classified 2-D data. Some of the functions in the package are based on those of the R package 'HiddenMarkov' by David Harte. This updated version has included an example dataset and R code examples to show how to transform the data into the objects needed in the main functions. We have also made changes to increase the speed of some of the functions.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.stats.otago.ac.nz/?people=ting_wang">https://www.stats.otago.ac.nz/?people=ting_wang</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-02 07:17:27 UTC; twang</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-03 04:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='HMMextra0s-package'>
Hidden Markov Models with Extra Zeros Hidden Markov Models (HMMs) with Extra Zeros
</h2><span id='topic+HMMextra0s-package'></span><span id='topic+HMMextra0s'></span>

<h3>Description</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> HMMextra0s</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Hidden Markov Models with Extra Zeros</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> mvtnorm, ellipse</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> HiddenMarkov</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-08-02</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Ting Wang, Wolfgang Hayek, and Alexander Pletzer</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Ting Wang &lt;ting.wang@otago.ac.nz&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Contains functions for hidden Markov models with observations having extra zeros as defined in the following two publications, Wang, T., Zhuang, J., Obara, K. and Tsuruoka, H. (2016) &lt;doi:10.1111/rssc.12194&gt;; Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) &lt;doi:10.1029/2017JB015360&gt;. The observed response variable is either univariate or bivariate Gaussian conditioning on presence of events, and extra zeros mean that the response variable takes on the value zero if nothing is happening. Hence the response is modelled as a mixture distribution of a Bernoulli variable and a continuous variable. That is, if the Bernoulli variable takes on the value 1, then the response variable is Gaussian, and if the Bernoulli variable takes on the value 0, then the response is zero too. This package includes functions for simulation, parameter estimation, goodness-of-fit, the Viterbi algorithm, and plotting the classified 2-D data. Some of the functions in the package are based on those of the R package 'HiddenMarkov' by David Harte. This updated version has included an example dataset and R code examples to show how to transform the data into the objects needed in the main functions. We have also made changes to increase the speed of some of the functions.</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
ZipData: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL(&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.stats.otago.ac.nz/?people=ting_wang</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2021-08-02 01:56:30 UTC; twang</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
HMMextra0s-package      Hidden Markov Models with Extra Zeros Hidden
                        Markov Models (HMMs) with Extra Zeros
Kii                     Tremor data in the Kii region in 2002 and 2003
                        for use in function hmm0norm2d
Viterbi.hmm0norm        Viterbi Path of a 1-D HMM with Extra Zeros
Viterbi.hmm0norm2d      Viterbi Path of a Bivariate HMM with Extra
                        Zeros
cumdist.hmm0norm        Cumulative distribution of an HMM with Extra
                        Zeros
hmm0norm                Parameter Estimation of an HMM with Extra Zeros
hmm0norm2d              Parameter Estimation of a bivariate HMM with
                        Extra Zeros
plotVitloc2d            Plot the Classified 2-D Data of a Bivariate HMM
                        With Extra Zeros
plotVitpath2d           Plot the Viterbi Path of a Bivariate HMM With
                        Extra Zeros
sim.hmm0norm            Simulation of a 1-D HMM with Extra Zeros
sim.hmm0norm2d          Simulation of a Bivariate HMM with Extra Zeros
</pre>
<p>This package contains functions to estimate the parameters of the HMMs with extra zeros using <code><a href="#topic+hmm0norm">hmm0norm</a></code> (1-D HMM) 
and <code><a href="#topic+hmm0norm2d">hmm0norm2d</a></code> (2-D HMM), to calculate the cumulative distribution of the 1-D HMM using <code><a href="#topic+cumdist.hmm0norm">cumdist.hmm0norm</a></code>, 
to estimate the Viterbi path using <code><a href="#topic+Viterbi.hmm0norm">Viterbi.hmm0norm</a></code> (1-D HMM) and <code><a href="#topic+Viterbi.hmm0norm2d">Viterbi.hmm0norm2d</a></code> (2-D HMM), to 
simulate this class of models using <code><a href="#topic+sim.hmm0norm">sim.hmm0norm</a></code> (1-D HMM) and <code><a href="#topic+sim.hmm0norm2d">sim.hmm0norm2d</a></code> (2-D HMM), to plot the 
classified 2-D data with different colours representing different hidden states using <code><a href="#topic+plotVitloc2d">plotVitloc2d</a></code>, and to plot the 
Viterbi path using <code><a href="#topic+plotVitloc2d">plotVitloc2d</a></code>.
</p>


<h3>Details</h3>

<p>This package is used to estimate the parameters, carry out simulations, and estimate the Viterbi path for 1-D and 2-D HMMs with extra 
zeros as defined in the two publications in the reference (also briefly defined below). It contains examples using simulated data for 
how to set up initial values for a data analysis and how to plot the results.
</p>
<p>An HMM is a statistical model in which the observed process is dependent on an unobserved Markov chain. A Markov chain is a sequence 
of states which exhibits a short-memory property such that the current state of the chain is dependent only on the previous state in 
the case of a first-order Markov chain. Assume that the Markov chain has <code class="reqn">m</code> states, where <code class="reqn">m</code> can be estimated from the data. 
Let <code class="reqn">S_t \in \{1,\cdots,m\}</code> denote the state of the Markov chain at time <code class="reqn">t</code>. The probability of a first-order Markov chain 
in state <code class="reqn">j</code> at time <code class="reqn">t</code> given the previous states is <code class="reqn">P(S_t=j|S_{t-1},\cdots,S_{1})=P(S_t=j|S_{t-1})</code>. 
These states are not observable. The observation <code class="reqn">Y_t</code> at time <code class="reqn">t</code> depends on the state <code class="reqn">S_t</code> of the Markov chain. 
</p>
<p>In this framework, we are interested in estimating the transition probability matrix <code class="reqn">\Gamma=(\gamma_{ij})_{m\times m}</code> of the 
Markov chain that describes the migration pattern and the density function <code class="reqn">f(y_t|S_t=i)</code> that gives the distribution feature of 
observations in state <code class="reqn">i</code>, where <code class="reqn">\gamma_{ij}=P(S_t=j|S_{t-1}=i)</code>.
</p>
<p>Let <code class="reqn">Z_t</code> be a Bernoulli variable, with <code class="reqn">Z_t=1</code> if an event is present at <code class="reqn">t</code>, and <code class="reqn">Z_t=0</code>, otherwise.
Let <code class="reqn">\mathbf{X}_t</code> be the response variable (e.g., location of the tremor cluster in 2D space) at time <code class="reqn">t</code>. 
We set <code class="reqn">P(Z_t=0|S_t=i)=1-p_i</code> and <code class="reqn">P(Z_t=1|S_t=i)=p_i</code>. We assume that, given <code class="reqn">Z_t=1</code> and <code class="reqn">S_t=i</code>, 
<code class="reqn">\mathbf{X}_t</code> follows a univariate or bivariate normal distribution, e.g. for a bivariate normal,
</p>
<p style="text-align: center;"><code class="reqn">
f(\mathbf{x}_t|Z_t=1, S_t=i)=\frac{1}{2\pi |\bm{\Sigma}_i|^{1/2}}\exp\left(-\frac{1}{2}
(\mathbf{x}_t-\bm{\mu}_i)^T\bm{\Sigma}_i^{-1}(\mathbf{x}_t-\bm{\mu}_i)\right).
</code>
</p>

<p>The joint probability density function of <code class="reqn">Z_t</code> and <code class="reqn">\mathbf{X}_t</code> conditional on the system being in state <code class="reqn">i</code> at time <code class="reqn">t</code> is
</p>
<p style="text-align: center;"><code class="reqn">
f(\mathbf{x}_t,z_t | S_t=i)=(1-p_i)^{1-z_t}\left[p_i\frac{1}{2\pi |\bm{\Sigma}_i|^{1/2}}\exp\left(-\frac{1}{2}(\mathbf{x}_t-\bm{\mu}_i)^T\bm{\Sigma}_i^{-1}(\mathbf{x}_t-\bm{\mu}_i)\right)\right]^{z_t},
</code>
</p>

<p>where <code class="reqn">p_i</code>, <code class="reqn">\bm{\mu}_i=E(\mathbf{X}_t|S_t=i,Z_t=1)</code> and <code class="reqn">\bm{\Sigma}_i=Var(\mathbf{X}_t|S_t=i,Z_t=1)</code> are parameters to be 
estimated.
</p>


<h3>Author(s)</h3>

<p>Ting Wang, Wolfgang Hayek, and Alexander Pletzer
</p>
<p>Maintainer: Ting Wang &lt;ting.wang@otago.ac.nz&gt;
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Obara, K. and Tsuruoka, H. (2016) Hidden Markov Modeling of Sparse Time Series from Non-volcanic Tremor Observations. Journal of the Royal Statistical Society, Series C, Applied Statistics, 66, Part 4, 691-715.
</p>
<p>Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) Identifying the recurrence patterns of non-volcanic tremors using a 2D hidden Markov model with extra zeros. Journal of Geophysical Research, doi: <a href="https://doi.org/10.1029/2017JB015360">10.1029/2017JB015360</a>.
</p>
<p>Some of the functions in the package are based on those of the R package &ldquo;HiddenMarkov&quot;:
</p>
<p>Harte, D. (2021) HiddenMarkov: Hidden Markov Models. R package version 1.8-13. URL: <a href="https://cran.r-project.org/package=HiddenMarkov">https://cran.r-project.org/package=HiddenMarkov</a>
</p>

<hr>
<h2 id='cumdist.hmm0norm'>
Cumulative distribution of an HMM with Extra Zeros
</h2><span id='topic+cumdist.hmm0norm'></span>

<h3>Description</h3>

<p>Calculates the cumulative distribution of an HMM with extra zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumdist.hmm0norm(x,HMMest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumdist.hmm0norm_+3A_x">x</code></td>
<td>
<p>x is a value at which the cumulative distribution is evaluated.</p>
</td></tr>
<tr><td><code id="cumdist.hmm0norm_+3A_hmmest">HMMest</code></td>
<td>
<p>is a list which contains pie, gamma, sig, mu, and delta (the HMM parameter estimates).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>is the calculated cumulative distribution.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Ting Wang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Obara, K. and Tsuruoka, H. (2016) Hidden Markov Modeling of Sparse Time Series from Non-volcanic Tremor Observations. Journal of the Royal Statistical Society, Series C, Applied Statistics, 66, Part 4, 691-715.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pie &lt;- c(0.002,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(0.3,0.7,0.2),nrow=1)
sig &lt;- matrix(c(0.2,0.1,0.1),nrow=1)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm(mu,sig,pie,gamma,delta, nsim=5000)
R &lt;- as.matrix(y$x,ncol=1)
Z &lt;- y$z
HMMEST &lt;- hmm0norm(R, Z, pie, gamma, mu, sig, delta)
xx &lt;- seq(0,1,0.05)
cumdist &lt;- apply(t(xx),2,cumdist.hmm0norm,HMMest=HMMEST)
</code></pre>

<hr>
<h2 id='hmm0norm'>
Parameter Estimation of an HMM with Extra Zeros
</h2><span id='topic+hmm0norm'></span>

<h3>Description</h3>

<p>Calculates the parameter estimates of a 1-D HMM with observations having extra zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm0norm(R, Z, pie, gamma, mu, sig, delta, tol=1e-6, print.level=1, fortran = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmm0norm_+3A_r">R</code></td>
<td>
<p>is the observed data. <code>R</code> is a <code class="reqn">T * 1</code> matrix, where <code class="reqn">T</code> is the number of observations.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_z">Z</code></td>
<td>
<p>is the binary data with the value 1 indicating that an event was observed and 0 otherwise. <code>Z</code> is a vector of length <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_pie">pie</code></td>
<td>
<p>is a vector of length <code class="reqn">m</code>, the <code class="reqn">j</code>th element of which is the probability of <code class="reqn">Z=1</code> when the process is in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_gamma">gamma</code></td>
<td>
<p>is the transition probability matrix (<code class="reqn">m * m</code>) of the hidden Markov chain.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_mu">mu</code></td>
<td>
<p>is a <code class="reqn">1 * m</code> matrix, the <code class="reqn">j</code>th element of which is the mean of the (Gaussian) distribution of the observations in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_sig">sig</code></td>
<td>
<p>is a <code class="reqn">1 * m</code> matrix, the <code class="reqn">j</code>th element of which is the standard deviation of the (Gaussian) distribution of the observations in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_delta">delta</code></td>
<td>
<p>is a vector of length <code class="reqn">m</code>, the initial distribution vector of the Markov chain.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_tol">tol</code></td>
<td>
<p>is the tolerance for testing convergence of the iterative estimation process. The default tolerance is 1e-6. For initial test of model fit to your data, a larger tolerance (e.g., 1e-3) should be used to save time.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_print.level">print.level</code></td>
<td>
<p>controls the amount of output being printed. Default is 1. If <code>print.level=1</code>, only the log likelihoods and the differences between the log likelihoods at each step of the iterative estimation process, and the final estimates are printed. If <code>print.level=2</code>, the log likelihoods, the differences between the log likelihoods, and the estimates at each step of the iterative estimation process are printed.</p>
</td></tr>
<tr><td><code id="hmm0norm_+3A_fortran">fortran</code></td>
<td>
<p>is logical, and determines whether Fortran code is used; default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pie</code></td>
<td>
<p>is the estimated probability of <code class="reqn">Z=1</code> when the process is in each state.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>is the estimated mean of the (Gaussian) distribution of the observations in each state.</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>is the estimated standard deviation of the (Gaussian) distribution of the observations in each state.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>is the estimated transition probability matrix of the hidden Markov chain.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>is the estimated initial distribution vector of the Markov chain.</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p>is the log likelihood.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ting Wang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Obara, K. and Tsuruoka, H. (2016) Hidden Markov Modeling of Sparse Time Series from Non-volcanic Tremor Observations. Journal of the Royal Statistical Society, Series C, Applied Statistics, 66, Part 4, 691-715.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pie &lt;- c(0.002,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(0.3,0.7,0.2),nrow=1)
sig &lt;- matrix(c(0.2,0.1,0.1),nrow=1)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm(mu,sig,pie,gamma,delta, nsim=5000)
R &lt;- as.matrix(y$x,ncol=1)
Z &lt;- y$z
yn &lt;- hmm0norm(R, Z, pie, gamma, mu, sig, delta)
yn
</code></pre>

<hr>
<h2 id='hmm0norm2d'>
Parameter Estimation of a bivariate HMM with Extra Zeros
</h2><span id='topic+hmm0norm2d'></span>

<h3>Description</h3>

<p>Calculates the parameter estimates of an HMM with bivariate observations having extra zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm0norm2d(R, Z, pie, gamma, mu, sig, delta, tol=1e-6, print.level=1, fortran = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmm0norm2d_+3A_r">R</code></td>
<td>
<p>is the observed data. <code>R</code> is a <code class="reqn">T * 2</code> matrix, where <code class="reqn">T</code> is the number of observations.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_z">Z</code></td>
<td>
<p>is the binary data with the value 1 indicating that an event was observed and 0 otherwise. <code>Z</code> is a vector of length <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_pie">pie</code></td>
<td>
<p>is a vector of length <code class="reqn">m</code>, the <code class="reqn">j</code>th element of which is the probability of <code class="reqn">Z=1</code> when the process is in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_gamma">gamma</code></td>
<td>
<p>is the transition probability matrix (<code class="reqn">m * m</code>) of the hidden Markov chain.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_mu">mu</code></td>
<td>
<p>is an <code class="reqn">m * 2</code> matrix, the <code class="reqn">j</code>th row of which is the mean of the bivariate (Gaussian) distribution of the observations in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_sig">sig</code></td>
<td>
<p>is a <code class="reqn">2 * 2 * m</code> array. The matrix <code>sig[,,j]</code> is the variance-covariance matrix of the bivariate (Gaussian) distribution of the observations in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_delta">delta</code></td>
<td>
<p>is a vector of length <code class="reqn">m</code>, the initial distribution vector of the Markov chain.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_tol">tol</code></td>
<td>
<p>is the tolerance for testing convergence of the iterative estimation process. Default is 1e-6. For initial test of model fit to your data, a larger tolerance (e.g., 1e-3) should be used to save time.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_print.level">print.level</code></td>
<td>
<p>controls the amount of output being printed. Default is 1. If <code>print.level=1</code>, only the log likelihoods and the differences between the log likelihoods at each step of the iterative estimation process, and the final estimates are printed. If <code>print.level=2</code>, the log likelihoods, the differences between the log likelihoods, and the estimates at each step of the iterative estimation process are printed.</p>
</td></tr>
<tr><td><code id="hmm0norm2d_+3A_fortran">fortran</code></td>
<td>
<p>is logical, and determines whether Fortran code is used; default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting up initial values for the real world data can be challenging, especially when the model is large (the number of states is big). 
In the example below, we include a simple way to set up initial values. If the model is large, the model fitting process should be repeated for
many different initial values. In the example below, we set the number of initial values to be <code class="reqn">N=2</code> for the ease of compilation. For real-world data 
analysis, taking the 2D model for the tremor data in Wang et al. (2018) for example, we used at least <code class="reqn">N=1000</code> initial values for the large models
with more than 15 hidden states. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pie</code></td>
<td>
<p>is the estimated probability of <code class="reqn">Z=1</code> when the process is in each state.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>is the estimated mean of the bivariate (Gaussian) distribution of the observations in each state.</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>is the estimated variance-covariance matrix of the bivariate (Gaussian) distribution of the observations in each state.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>is the estimated transition probability matrix of the hidden Markov chain.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>is the estimated initial distribution vector of the Markov chain.</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p>is the log likelihood.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ting Wang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) Identifying the recurrence patterns of non-volcanic tremors using a 2D hidden Markov model with extra zeros. Journal of Geophysical Research, doi: <a href="https://doi.org/10.1029/2017JB015360">10.1029/2017JB015360</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pie &lt;- c(0.002,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(35.03,137.01,
               35.01,137.29,
               35.15,137.39),byrow=TRUE,nrow=3)
sig &lt;- array(NA,dim=c(2,2,3))
sig[,,1] &lt;- matrix(c(0.005, -0.001,
                   -0.001,0.01),byrow=TRUE,nrow=2)
sig[,,2] &lt;- matrix(c(0.0007,-0.0002,
                    -0.0002,0.0006),byrow=TRUE,nrow=2)
sig[,,3] &lt;- matrix(c(0.002,0.0018,
                     0.0018,0.003),byrow=TRUE,nrow=2)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm2d(mu,sig,pie,gamma,delta, nsim=5000)
R &lt;- y$x
Z &lt;- y$z
yn &lt;- hmm0norm2d(R, Z, pie, gamma, mu, sig, delta)
yn

# Setting up initial values when analysing real-world data
## nk is the number of states for the fitted model
### In this example we use nk=3

LL &lt;- -10^200 ## A very small value to compare with
              ## the log likelihood from the model

nk = 3

gamma &lt;- array(NA,dim=c(nk,nk))
mu &lt;- array(NA,dim=c(nk,2))
sig &lt;- array(NA,dim=c(2,2,nk))
pie &lt;- array(NA,dim=c(1,nk))

kk &lt;- 1
N &lt;- 2
while(kk&lt;N)
{
  temp &lt;- matrix(runif(nk*nk,0,1),ncol=nk)
  diag(temp) = diag(temp) + rpois(1,6) * apply(temp, 1, sum)
  temp &lt;- temp * matrix(rep(1/apply(temp, 1, sum), ncol(temp)), ncol=ncol(temp), byrow=FALSE)
  gamma &lt;- temp

  R1min &lt;- min((R[,1])[R[,1]&gt;=1e-6])
  R1max &lt;- max((R[,1])[R[,1]&gt;=1e-6])
  R2min &lt;- min((R[,2])[R[,2]&gt;=1e-6])
  R2max &lt;- max((R[,2])[R[,2]&gt;=1e-6])
  temp &lt;- cbind(runif(nk,R1min,R1max),runif(nk,R2min,R2max))
  temp &lt;- temp[order(temp[,2]),]
  mu &lt;- temp
 
  sdR1 &lt;- sd((R[,1])[R[,1]&gt;=1e-6])
  sdR2 &lt;- sd((R[,2])[R[,2]&gt;=1e-6])
  for (j in 1:nk){
    temp &lt;- matrix(runif(4,0.0001,max(sdR1,sdR2)), ncol=2)
    temp[1,2] &lt;- temp[2,1] &lt;- runif(1,-1,1)* sqrt(prod(diag(temp)))
    sig[, ,j] &lt;- temp
  }

  pie &lt;- matrix(sort(c(runif(1, 0, 0.01),runif(nk-1, 0, 1))), nrow = 1, byrow = TRUE )

  delta &lt;- c(6,runif(nk-1, 0,1)) 
  delta &lt;- delta/sum(delta)

 tryCatch({
    temp &lt;- hmm0norm2d(R, Z, pie, gamma, mu, sig, delta)
    kk&lt;-kk+1
    if( LL &lt;= temp$LL){
      HMMest &lt;- temp
      LL =HMMest$LL
      eval(parse(text=paste('HMM',kk,'est = HMMest',sep="")))
#      eval(parse(text=paste('save(HMM',kk,'est, file="HMM',kk,'est.image")',sep='')))
## Uncomment the line above if you would like to save the result into a .image file.
    }
   }, error=function(e){})
 print(kk)
}


</code></pre>

<hr>
<h2 id='Kii'>
Tremor data in the Kii region in 2002 and 2003 for use in function hmm0norm2d
</h2><span id='topic+Kii'></span>

<h3>Description</h3>

<p>A data frame containing a subset (in years 2002 and 2003) of Kii tremor data used in Wang et al. (2018). The columns are named <code>"year"</code>, <code>"month"</code>, <code>"day"</code>, <code>"hour"</code>, <code>"lat"</code>, <code>"lon"</code>.
</p>
<p>We provide some R code in the Examples below for how to convert this dataset into the variables <code>R</code> and <code>Z</code> used in the function <code><a href="#topic+hmm0norm2d">hmm0norm2d</a></code>. This dataset can be obtained directly from the Slow Earthquake Database http://www-solid.eps.s.u-tokyo.ac.jp/~sloweq/.
</p>
<p>If you have your own way to convert the data into the variables <code>R</code> and <code>Z</code>, then you can go to the function <code><a href="#topic+hmm0norm2d">hmm0norm2d</a></code> directly. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Kii)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1112 rows, each row representing the hour in which tremor events occurred. It contains the following variables:
</p>

<dl>
<dt>year, month, day, hour</dt><dd><p>time of tremor occurrence.</p>
</dd>
<dt>lat</dt><dd><p>latitude of the tremor event in that hour.</p>
</dd>
<dt>lon</dt><dd><p>longitude of the tremor event in that hour.</p>
</dd>
</dl>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) Identifying the recurrence patterns of non-volcanic tremors using a 2D hidden Markov model with extra zeros. Journal of Geophysical Research, doi: <a href="https://doi.org/10.1029/2017JB015360">10.1029/2017JB015360</a>.
Obara, K., Tanaka, S., Maeda, T., &amp; Matsuzawa, T. (2010) Depth-dependent activity of non-volcanic tremor in southwest Japan, Geophysical Research Letters, 37, L13306. doi: <a href="https://doi.org/10.1029/2010GL043679">10.1029/2010GL043679</a>.
Maeda, T., &amp; Obara. K. (2009) Spatio-temporal distribution of seismic energy radiation from low-frequency tremor in western Shikoku, Japan, J. Geophys. Res., 114, B00A09, doi: <a href="https://doi.org/10.1029/2008JB006043">10.1029/2008JB006043</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmm0norm2d">hmm0norm2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Kii)
year &lt;- Kii$year
month &lt;- Kii$month
day &lt;- Kii$day
hour &lt;- Kii$hour
lat &lt;- Kii$lat
lon &lt;- Kii$lon

## Transform the time into days*100+hour. Can use other transformation.
## The purpose is to make sure that each hour of a day has a unique number.
xd &lt;- NULL
for (i in 1:nrow(Kii))
  xd[i] &lt;- julian(as.Date(paste(year[i],month[i],day[i],sep="-")))*100+hour[i]

## Create a unique number for each hour in the years 2002 and 2003
## This is to match with xd above, so that we can create the Z variable
## which is 0 for the hours without any tremor occurrence and
## 1 for the hours with tremor events.
a &lt;- seq( julian(as.Date("2002-01-01")), julian(as.Date("2002-12-31")), 1 )*100
b &lt;- seq( julian(as.Date("2003-01-01")), julian(as.Date("2003-12-31")), 1 )*100
aa &lt;- rep(a,each=24)+rep(0:23,times=length(a))
bb &lt;- rep(b,each=24)+rep(0:23,times=length(b))

## Combine all the tremor events which occurred 
## in the same hour to be one tremor cluster.
## Kii has maximum 4 events in the same hour 
## so we used the code below.
## One can adjust the code for regions with more 
## tremor events in the same hour.
## indt: actual time as in each hour
Time &lt;- c(aa,bb)
lt &lt;- length(Time)
indt &lt;- 1:lt

Tim &lt;- Lat &lt;- Lon &lt;- NULL
j &lt;- 1
while (j &lt;= nrow(Kii)-3){
  i &lt;- j
  if (xd[i+3]==xd[i] &amp; xd[i+2]==xd[i] &amp; xd[i+1]==xd[i]){
    Tim &lt;- append(Tim,xd[i])
    Lat &lt;- append(Lat,mean(lat[i:(i+3)]))
    Lon &lt;- append(Lon,mean(lon[i:(i+3)]))
    j &lt;- i+4
  }else{
    if (xd[i+2]==xd[i] &amp; xd[i+1]==xd[i]){
      Tim &lt;- append(Tim,xd[i])
      Lat &lt;- append(Lat,mean(lat[i:(i+2)]))
      Lon &lt;- append(Lon,mean(lon[i:(i+2)]))
      j &lt;- i+3
    }else{
      if (xd[i+1]==xd[i]){
        Tim &lt;- append(Tim,xd[i])
        Lat &lt;- append(Lat,mean(lat[i:(i+1)]))
        Lon &lt;- append(Lon,mean(lon[i:(i+1)]))
        j &lt;- i+2
      }else{
        Tim &lt;- append(Tim,xd[i])
        Lat &lt;- append(Lat,lat[i])
        Lon &lt;- append(Lon,lon[i])
        j &lt;- i+1
      }
    }
  }
}
Tim &lt;- append(Tim,xd[(nrow(Kii)-1):nrow(Kii)])
Lat &lt;- append(Lat,lat[(nrow(Kii)-1):nrow(Kii)])
Lon &lt;- append(Lon,lon[(nrow(Kii)-1):nrow(Kii)])

## Create a data frame in which each hour is a point
## Those hours when there was no tremor, we set the 
## number of tremors as 0

data1 &lt;- array(0,dim=c(lt,3))
Thour &lt;- NULL
for (i in 1:length(Tim)){
  use &lt;- Time==Tim[i]
  idtem &lt;- (1:lt)[use]
  Thour &lt;- append(Thour,idtem)
  data1[idtem,2] &lt;- Lat[i]
  data1[idtem,3] &lt;- Lon[i]
}
data1[,1] &lt;- indt ## Every hour is one time point

###########################################################
###########   Data for time series analysis   #############  
###########################################################
lt &lt;- length(indt)
Z &lt;- rep(0,lt)
Z[Thour] &lt;- 1
R &lt;- data1[,2:3]


###########################################################
# Setting up initial values for analysing real-world data
## nk is the number of states for the fitted model
### In this example we use nk=3
###########################################################

LL &lt;- -10^200 ## A very small value to compare with
## the log likelihood from the model

nk = 3

gamma &lt;- array(NA,dim=c(nk,nk))
mu &lt;- array(NA,dim=c(nk,2))
sig &lt;- array(NA,dim=c(2,2,nk))
pie &lt;- array(NA,dim=c(1,nk))

kk &lt;- 1
N &lt;- 2
while(kk&lt;N)
{
  temp &lt;- matrix(runif(nk*nk,0,1),ncol=nk)
  diag(temp) = diag(temp) + rpois(1,6) * apply(temp, 1, sum)
  temp &lt;- temp * matrix(rep(1/apply(temp, 1, sum), ncol(temp)), ncol=ncol(temp), byrow=FALSE)
  gamma &lt;- temp
  
  R1min &lt;- min((R[,1])[R[,1]&gt;=1e-6])
  R1max &lt;- max((R[,1])[R[,1]&gt;=1e-6])
  R2min &lt;- min((R[,2])[R[,2]&gt;=1e-6])
  R2max &lt;- max((R[,2])[R[,2]&gt;=1e-6])
  temp &lt;- cbind(runif(nk,R1min,R1max),runif(nk,R2min,R2max))
  temp &lt;- temp[order(temp[,2]),]
  mu &lt;- temp
  
  sdR1 &lt;- sd((R[,1])[R[,1]&gt;=1e-6])
  sdR2 &lt;- sd((R[,2])[R[,2]&gt;=1e-6])
  for (j in 1:nk){
    temp &lt;- matrix(runif(4,0.0001,max(sdR1,sdR2)), ncol=2)
    temp[1,2] &lt;- temp[2,1] &lt;- runif(1,-1,1)* sqrt(prod(diag(temp)))
    sig[, ,j] &lt;- temp
  }
  
  pie &lt;- matrix(sort(c(runif(1, 0, 0.01),runif(nk-1, 0, 1))), nrow = 1, byrow = TRUE )
  
  delta &lt;- c(6,runif(nk-1, 0,1)) 
  delta &lt;- delta/sum(delta)
  
  tryCatch({
    temp &lt;- hmm0norm2d(R, Z, pie, gamma, mu, sig, delta)
    kk&lt;-kk+1
    if( LL &lt;= temp$LL){
      HMMest &lt;- temp
      LL =HMMest$LL
      eval(parse(text=paste('HMM',kk,'est = HMMest',sep="")))
#      eval(parse(text=paste('save(HMM',kk,'est, file="HMM',kk,'est.image")',sep='')))
## Uncomment the line above if you would like to save the result into a .image file.
    }
  }, error=function(e){})
  print(kk)
}

</code></pre>

<hr>
<h2 id='plotVitloc2d'>
Plot the Classified 2-D Data of a Bivariate HMM With Extra Zeros
</h2><span id='topic+plotVitloc2d'></span>

<h3>Description</h3>

<p>Plot the classified 2-D data with different colours representing different hidden states (or different clusters) obtained from the Viterbi path and confidence contours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVitloc2d(object, R, Z, HMMest, CI.level=0.95, npoints=100, cols=NA, 
cex.lab=1.5, cex.axis=1.5, cex=1, cex.text=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotVitloc2d_+3A_object">object</code></td>
<td>
<p>is a list containing <code>y</code> (the estimated Viterbi path) and <code>v</code> (the estimated probability of each time point being in each state). This object is returned from running <code>Viterbi.hmm0norm2d(R, Z, HMMest)</code>.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_r">R</code></td>
<td>
<p>is the observed data. <code>R</code> is a <code class="reqn">T * 2</code> matrix, where <code class="reqn">T</code> is the number of observations.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_z">Z</code></td>
<td>
<p>is the binary data with the value 1 indicating that an event was observed and 0 otherwise. <code>Z</code> is a vector of length <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_hmmest">HMMest</code></td>
<td>
<p>is a list which contains pie, gamma, sig, mu, and delta (the bivariate HMM parameter estimates).</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_ci.level">CI.level</code></td>
<td>
<p>is a scalar or a vector, the confidence level for the ellipse contour of each state. Default is 0.95.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_npoints">npoints</code></td>
<td>
<p>is the number of points used in the ellipse. Default is 100.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_cols">cols</code></td>
<td>
<p>is a vector defines the colors to be used for different states. If col=NA, then the default colors will be used.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_cex.lab">cex.lab</code></td>
<td>
<p>specifies the size of the axis label text.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_cex.axis">cex.axis</code></td>
<td>
<p>specifies the size of the tick label numbers/text.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_cex">cex</code></td>
<td>
<p>specifies the size of the points.</p>
</td></tr>
<tr><td><code id="plotVitloc2d_+3A_cex.text">cex.text</code></td>
<td>
<p>specifies the size of the text indicting the state number.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ting Wang and Jiancang Zhuang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) Identifying the recurrence patterns of non-volcanic tremors using a 
2D hidden Markov model with extra zeros. Journal of Geophysical Research, doi: <a href="https://doi.org/10.1029/2017JB015360">10.1029/2017JB015360</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pie &lt;- c(0.008,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(35.03,137.01,
               35.01,137.29,
               35.15,137.39),byrow=TRUE,nrow=3)
sig &lt;- array(NA,dim=c(2,2,3))
sig[,,1] &lt;- matrix(c(0.005, -0.001,
                   -0.001,0.01),byrow=TRUE,nrow=2)
sig[,,2] &lt;- matrix(c(0.0007,-0.0002,
                    -0.0002,0.0006),byrow=TRUE,nrow=2)
sig[,,3] &lt;- matrix(c(0.002,0.0018,
                     0.0018,0.003),byrow=TRUE,nrow=2)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm2d(mu,sig,pie,gamma,delta, nsim=5000)
R &lt;- y$x
Z &lt;- y$z
HMMEST &lt;- hmm0norm2d(R, Z, pie, gamma, mu, sig, delta)
Viterbi3 &lt;- Viterbi.hmm0norm2d(R,Z,HMMEST)
plotVitloc2d(Viterbi3, R, Z,HMMEST)
</code></pre>

<hr>
<h2 id='plotVitpath2d'>
Plot the Viterbi Path of a Bivariate HMM With Extra Zeros
</h2><span id='topic+plotVitpath2d'></span>

<h3>Description</h3>

<p>Plot the 2-D data, Viterbi path and the probability of each time point being in each state over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVitpath2d(object, R, Z, HMMest, len.dat=96432, varb=8780,
  yearstart=2005, yearend=2012, cols=NA, cex.lab=1.5, cex.axis=1.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotVitpath2d_+3A_object">object</code></td>
<td>
<p>is a list containing <code>y</code> (the estimated Viterbi path) and <code>v</code> (the estimated probability of each time point being in each state). This object is returned from running <code>Viterbi.hmm0norm2d(R, Z, HMMest)</code>.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_r">R</code></td>
<td>
<p>is the observed data. <code>R</code> is a <code class="reqn">T * 2</code> matrix, where <code class="reqn">T</code> is the number of observations.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_z">Z</code></td>
<td>
<p>is the binary data with the value 1 indicating that an event was observed and 0 otherwise. <code>Z</code> is a vector of length <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_hmmest">HMMest</code></td>
<td>
<p>is a list which contains pie, gamma, sig, mu, and delta (the bivariate HMM parameter estimates).</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_len.dat">len.dat</code></td>
<td>
<p>is the length of the data, that is, the number of time points. Default is 96432.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_varb">varb</code></td>
<td>
<p>is an integer indicating the length of data that will be ploted on each page. The default is 8780.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_yearstart">yearstart</code></td>
<td>
<p>is the starting year of the data used. Default is 2005.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_yearend">yearend</code></td>
<td>
<p>is the end year of the data used. Default is 2012.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_cols">cols</code></td>
<td>
<p>is a vector defines the colors to be used for different states. If col=NA, then the default colors will be used.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_cex.lab">cex.lab</code></td>
<td>
<p>specifies the size of the axis label text.</p>
</td></tr>
<tr><td><code id="plotVitpath2d_+3A_cex.axis">cex.axis</code></td>
<td>
<p>specifies the size of the tick label numbers/text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned object has four panels. Top two panels: Observed latitudes and longitudes with the center <code class="reqn">\hat{\mu}_i</code> of each state overlaid as the red lines; third panel: tracked most likely state sequence of the HMM; bottom panel: the estimated probability of the data being in each state, with blank representing the probability of being in the last state (typically the plot looks better if the last state represents the background state with the minimum proportion of tremor occurrence). Some example plots are in the supplementary file of the reference Wang et al. (2018).
</p>


<h3>Author(s)</h3>

<p>Ting Wang and Jiancang Zhuang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) Identifying the recurrence patterns of non-volcanic tremors using a 2D 
hidden Markov model with extra zeros. Journal of Geophysical Research, doi: <a href="https://doi.org/10.1029/2017JB015360">10.1029/2017JB015360</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pie &lt;- c(0.008,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(35.03,137.01,
               35.01,137.29,
               35.15,137.39),byrow=TRUE,nrow=3)
sig &lt;- array(NA,dim=c(2,2,3))
sig[,,1] &lt;- matrix(c(0.005, -0.001,
                   -0.001,0.01),byrow=TRUE,nrow=2)
sig[,,2] &lt;- matrix(c(0.0007,-0.0002,
                    -0.0002,0.0006),byrow=TRUE,nrow=2)
sig[,,3] &lt;- matrix(c(0.002,0.0018,
                     0.0018,0.003),byrow=TRUE,nrow=2)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm2d(mu,sig,pie,gamma,delta, nsim=5000)
R &lt;- y$x
Z &lt;- y$z
HMMEST &lt;- hmm0norm2d(R, Z, pie, gamma, mu, sig, delta)
Viterbi3 &lt;- Viterbi.hmm0norm2d(R,Z,HMMEST)
plotVitpath2d(Viterbi3, R, Z,HMMEST,len.dat=5000,varb=5000,yearstart=2005, yearend=2005)
</code></pre>

<hr>
<h2 id='sim.hmm0norm'>
Simulation of a 1-D HMM with Extra Zeros
</h2><span id='topic+sim.hmm0norm'></span>

<h3>Description</h3>

<p>Simulates the observed process and the associated binary variable of a 1-D HMM with extra zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.hmm0norm(mu, sig, pie, gamma, delta, nsim = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.hmm0norm_+3A_pie">pie</code></td>
<td>
<p>is a vector of length <code class="reqn">m</code>, the <code class="reqn">j</code>th element of which is the probability of <code class="reqn">Z=1</code> when the process is in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm_+3A_gamma">gamma</code></td>
<td>
<p>is the transition probability matrix (<code class="reqn">m * m</code>) of the hidden Markov chain.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm_+3A_mu">mu</code></td>
<td>
<p>is a <code class="reqn">1 * m</code> matrix, the <code class="reqn">j</code>th element of which is the mean of the (Gaussian) distribution of the observations in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm_+3A_sig">sig</code></td>
<td>
<p>is a <code class="reqn">1 * m</code> matrix, the <code class="reqn">j</code>th element of which is the standard deviation of the (Gaussian) distribution of the observations in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm_+3A_delta">delta</code></td>
<td>
<p>is a vector of length <code class="reqn">m</code>, the initial distribution vector of the Markov chain.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm_+3A_nsim">nsim</code></td>
<td>
<p>is an integer, the number of observations to simulate.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm_+3A_seed">seed</code></td>
<td>
<p>is the seed for simulation. Default <code>seed=NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>is the simulated observed process.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>is the simulated binary data with the value 1 indicating that an event was observed and 0 otherwise.</p>
</td></tr>
<tr><td><code>mcy</code></td>
<td>
<p>is the simulated hidden Markov chain.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ting Wang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Obara, K. and Tsuruoka, H. (2016) Hidden Markov Modeling of Sparse Time Series from Non-volcanic Tremor Observations. Journal of the Royal Statistical Society, Series C, Applied Statistics, 66, Part 4, 691-715.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pie &lt;- c(0.002,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(0.3,0.7,0.2),nrow=1)
sig &lt;- matrix(c(0.2,0.1,0.1),nrow=1)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm(mu,sig,pie,gamma,delta, nsim=5000)
</code></pre>

<hr>
<h2 id='sim.hmm0norm2d'>
Simulation of a Bivariate HMM with Extra Zeros
</h2><span id='topic+sim.hmm0norm2d'></span>

<h3>Description</h3>

<p>Simulates the observed process and the associated binary variable of a bivariate HMM with extra zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.hmm0norm2d(mu, sig, pie, gamma, delta, nsim = 1, mc.hist = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.hmm0norm2d_+3A_pie">pie</code></td>
<td>
<p>is a vector of length <code class="reqn">m</code>, the <code class="reqn">j</code>th element of which is the probability of <code class="reqn">Z=1</code> when the process is in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm2d_+3A_gamma">gamma</code></td>
<td>
<p>is the transition probability matrix (<code class="reqn">m * m</code>) of the hidden Markov chain.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm2d_+3A_mu">mu</code></td>
<td>
<p>is an <code class="reqn">m * 2</code> matrix, the <code class="reqn">j</code>th row of which is the mean of the bivariate (Gaussian) distribution of the observations in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm2d_+3A_sig">sig</code></td>
<td>
<p>is a <code class="reqn">2 * 2 * m</code> array. The matrix <code>sig[,,j]</code> is the variance-covariance matrix of the bivariate (Gaussian) distribution of the observations in state <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm2d_+3A_delta">delta</code></td>
<td>
<p>is a vector of length <code class="reqn">m</code>, the initial distribution vector of the Markov chain.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm2d_+3A_nsim">nsim</code></td>
<td>
<p>is an integer, the number of observations to simulate.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm2d_+3A_mc.hist">mc.hist</code></td>
<td>
<p>is a vector containing the history of the hidden Markov chain. This is mainly used for forecasting. If we fit an HMM to the data, and obtained the Viterbi path for the data, we can let <code>mc.hist</code> equal to the Viterbi path and then forecast futrue steps by simulation.</p>
</td></tr>
<tr><td><code id="sim.hmm0norm2d_+3A_seed">seed</code></td>
<td>
<p>is the seed for simulation. Default <code>seed=NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>is the simulated observed process.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>is the simulated binary data with the value 1 indicating that an event was observed and 0 otherwise.</p>
</td></tr>
<tr><td><code>mcy</code></td>
<td>
<p>is the simulated hidden Markov chain.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ting Wang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) Identifying the recurrence patterns of non-volcanic tremors using a 2D hidden Markov model with extra zeros. Journal of Geophysical Research, doi: <a href="https://doi.org/10.1029/2017JB015360">10.1029/2017JB015360</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating a sequence of data without using any history.
pie &lt;- c(0.002,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(35.03,137.01,
               35.01,137.29,
               35.15,137.39),byrow=TRUE,nrow=3)
sig &lt;- array(NA,dim=c(2,2,3))
sig[,,1] &lt;- matrix(c(0.005, -0.001,
                   -0.001,0.01),byrow=TRUE,nrow=2)
sig[,,2] &lt;- matrix(c(0.0007,-0.0002,
                    -0.0002,0.0006),byrow=TRUE,nrow=2)
sig[,,3] &lt;- matrix(c(0.002,0.0018,
                     0.0018,0.003),byrow=TRUE,nrow=2)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm2d(mu,sig,pie,gamma,delta, nsim=5000)


## Forecast future tremor occurrences and locations when tremor occurs.
R &lt;- y$x
Z &lt;- y$z
HMMEST &lt;- hmm0norm2d(R, Z, pie, gamma, mu, sig, delta)
Viterbi3 &lt;- Viterbi.hmm0norm2d(R,Z,HMMEST)
y &lt;- sim.hmm0norm2d(mu,sig,pie,gamma,delta,nsim=2,mc.hist=Viterbi3$y)
# This only forecasts two steps forward when we use nsim=2. 
# One can increase nsim to get longer simulated forecasts.
</code></pre>

<hr>
<h2 id='Viterbi.hmm0norm'>
Viterbi Path of a 1-D HMM with Extra Zeros
</h2><span id='topic+Viterbi.hmm0norm'></span>

<h3>Description</h3>

<p>Finds the most probable sequence of hidden states of an observed process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Viterbi.hmm0norm(R, Z, HMMest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Viterbi.hmm0norm_+3A_r">R</code></td>
<td>
<p>is the observed data. <code>R</code> is a <code class="reqn">T * 1</code> matrix, where <code class="reqn">T</code> is the number of observations.</p>
</td></tr>
<tr><td><code id="Viterbi.hmm0norm_+3A_z">Z</code></td>
<td>
<p>is the binary data with the value 1 indicating that an event was observed and 0 otherwise. <code>Z</code> is a vector of length <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="Viterbi.hmm0norm_+3A_hmmest">HMMest</code></td>
<td>
<p>is a list which contains pie, gamma, sig, mu, and delta (the HMM parameter estimates).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>is the estimated Viterbi path.</p>
</td></tr> 
<tr><td><code>v</code></td>
<td>
<p>is the estimated probability of each time point being in each state.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ting Wang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Obara, K. and Tsuruoka, H. (2016) Hidden Markov Modeling of Sparse Time Series from Non-volcanic Tremor Observations. Journal of the Royal Statistical Society, Series C, Applied Statistics, 66, Part 4, 691-715.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pie &lt;- c(0.002,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(0.3,0.7,0.2),nrow=1)
sig &lt;- matrix(c(0.2,0.1,0.1),nrow=1)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm(mu,sig,pie,gamma,delta, nsim=5000)
R &lt;- as.matrix(y$x,ncol=1)
Z &lt;- y$z
HMMEST &lt;- hmm0norm(R, Z, pie, gamma, mu, sig, delta)
Viterbi3 &lt;- Viterbi.hmm0norm(R,Z,HMMEST)
</code></pre>

<hr>
<h2 id='Viterbi.hmm0norm2d'>
Viterbi Path of a Bivariate HMM with Extra Zeros
</h2><span id='topic+Viterbi.hmm0norm2d'></span>

<h3>Description</h3>

<p>Finds the most probable sequence of hidden states of an observed process of a bivariate HMM with extra zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Viterbi.hmm0norm2d(R, Z, HMMest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Viterbi.hmm0norm2d_+3A_r">R</code></td>
<td>
<p>is the observed data. <code>R</code> is a <code class="reqn">T * 2</code> matrix, where <code class="reqn">T</code> is the number of observations.</p>
</td></tr>
<tr><td><code id="Viterbi.hmm0norm2d_+3A_z">Z</code></td>
<td>
<p>is the binary data with the value 1 indicating that an event was observed and 0 otherwise. <code>Z</code> is a vector of length <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="Viterbi.hmm0norm2d_+3A_hmmest">HMMest</code></td>
<td>
<p>is a list which contains pie, gamma, sig, mu, and delta (the bivariate HMM parameter estimates).</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>is the estimated Viterbi path.</p>
</td></tr> 
<tr><td><code>v</code></td>
<td>
<p>is the estimated probability of each time point being in each state.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ting Wang
</p>


<h3>References</h3>

<p>Wang, T., Zhuang, J., Buckby, J., Obara, K. and Tsuruoka, H. (2018) Identifying the recurrence patterns of non-volcanic tremors using a 2D hidden Markov model with extra zeros. Journal of Geophysical Research, doi: <a href="https://doi.org/10.1029/2017JB015360">10.1029/2017JB015360</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pie &lt;- c(0.002,0.2,0.4)
gamma &lt;- matrix(c(0.99,0.007,0.003,
                  0.02,0.97,0.01,
                  0.04,0.01,0.95),byrow=TRUE, nrow=3)
mu &lt;- matrix(c(35.03,137.01,
               35.01,137.29,
               35.15,137.39),byrow=TRUE,nrow=3)
sig &lt;- array(NA,dim=c(2,2,3))
sig[,,1] &lt;- matrix(c(0.005, -0.001,
                   -0.001,0.01),byrow=TRUE,nrow=2)
sig[,,2] &lt;- matrix(c(0.0007,-0.0002,
                    -0.0002,0.0006),byrow=TRUE,nrow=2)
sig[,,3] &lt;- matrix(c(0.002,0.0018,
                     0.0018,0.003),byrow=TRUE,nrow=2)
delta &lt;- c(1,0,0)
y &lt;- sim.hmm0norm2d(mu,sig,pie,gamma,delta, nsim=5000)
R &lt;- y$x
Z &lt;- y$z
HMMEST &lt;- hmm0norm2d(R, Z, pie, gamma, mu, sig, delta)
Viterbi3 &lt;- Viterbi.hmm0norm2d(R,Z,HMMEST)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
