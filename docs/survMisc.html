<!DOCTYPE html><html><head><title>Help for package survMisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {survMisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asWide'><p>Convert an object to &quot;wide&quot; or &quot;long&quot; form.</p></a></li>
<li><a href='#autoplotTableAndPlot'><p>Arrange a survival plot with corresponding table and legend.</p></a></li>
<li><a href='#autoplotTen'><p>Generate a <code>ggplot</code> for a <code>survfit</code> or <code>ten</code> object</p></a></li>
<li><a href='#ci'><p><b>c</b>onfidence <b>i</b>ntervals for survival curves.</p></a></li>
<li><a href='#comp'><p>compare survival curves</p></a></li>
<li><a href='#COV'><p><b>cov</b>ariance matrix for survival data</p></a></li>
<li><a href='#cutp'><p><b>cut p</b>oint for a continuous variable in a</p>
model fit with <code>coxph</code> or <code>survfit</code>.</a></li>
<li><a href='#gastric'><p>gastric cancer trial data</p></a></li>
<li><a href='#gof'><p><b>g</b>oodness <b>o</b>f <b>f</b>it test for a <code>coxph</code> object</p></a></li>
<li><a href='#nc'><p>Add <b>n</b>umber <b>c</b>ensored.</p></a></li>
<li><a href='#predict'><p>predicted events</p></a></li>
<li><a href='#print'><p><code>print</code> methods</p></a></li>
<li><a href='#profLik'><p>Profile likelihood for coefficients in a <code>coxph</code> model</p></a></li>
<li><a href='#rsq'><p>r^2 measures for a a <code>coxph</code> or <code>survfit</code> model</p></a></li>
<li><a href='#sf'><p><b>s</b>urvival (or hazard) <b>f</b>unction</p>
based on <code class="reqn">e</code> and <code class="reqn">n</code>.</a></li>
<li><a href='#survMisc_package'><p>Miscellaneous Functions for Survival Analysis</p></a></li>
<li><a href='#ten'><p><b>t</b>ime, <b>e</b>vent(s) and <b>n</b>umber at risk.</p></a></li>
<li><a href='#xtable'><p><code>xtable</code> methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-07</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils, knitr, KMsurv, ggplot2,
data.table, zoo, grid, gridExtra, km.ci, xtable</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Dardis</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Dardis &lt;christopherdardis@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions for Survival Data</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to help in the analysis of
    right-censored survival data. These extend the methods available in
    package:survival.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dardisco/survMisc/issues">https://github.com/dardisco/survMisc/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'ten.R' 'nc.R' 'sf.R' 'ci.R' 'autoplotTAP.R' 'autoplotTen.R'
'print.R' 'asWide.R' 'COV.R' 'predict.R' 'comp.R' 'cutp.R'
'gastric.R' 'gof.R' 'onAttach.R' 'profLik.R' 'rsq.R'
'survMisc_package.R' 'xtable.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-07 15:42:53 UTC; cd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-07 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='asWide'>Convert an object to &quot;wide&quot; or &quot;long&quot; form.</h2><span id='topic+asWide'></span><span id='topic+asWide.ten'></span><span id='topic+asLong'></span><span id='topic+asLong.ten'></span>

<h3>Description</h3>

<p>Convert an object to &quot;wide&quot; or &quot;long&quot; form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asWide(x, ...)

## S3 method for class 'ten'
asWide(x, ...)

asLong(x, ...)

## S3 method for class 'ten'
asLong(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asWide_+3A_x">x</code></td>
<td>
<p>An object of class <code>ten</code> or <code>pred</code>.</p>
</td></tr>
<tr><td><code id="asWide_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>data.table</code> is returned, 
with the data in 'wide' or 'long' format.
<br />
There is one row for each time point.
<br />
For a <code>ten</code> object generated from a <code>numeric</code> or <code>Surv</code> object, 
this has columns:
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p><b>t</b>ime.</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>number of <b>e</b>vents.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p><b>n</b>umber at risk.</p>
</td></tr>
</table>
<p>If derived from a <code>survfit</code>, <code>coxph</code> or <code>formula</code> object, 
there are additional columns for <code>e</code> and <code>n</code>
for <em>each</em> covariate group.
</p>


<h3>Note</h3>

<p>Most methods for <code>ten</code> objects are designed for the 'long' form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("bmt", package="KMsurv")
require("survival")
t1 &lt;- ten(c1 &lt;- coxph(Surv(t2, d3) ~ z3*z10, data=bmt))
asWide(t1)

## End(Not run)
## Not run: 
asLong(asWide(t1))
stopifnot(asLong(asWide(t1)) == ten(ten(t1)))

## End(Not run)
</code></pre>

<hr>
<h2 id='autoplotTableAndPlot'>Arrange a survival plot with corresponding table and legend.</h2><span id='topic+autoplotTableAndPlot'></span><span id='topic+autoplot.tableAndPlot'></span>

<h3>Description</h3>

<p>Arrange a survival plot with corresponding table and legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tableAndPlot'
autoplot(object, ..., hideTabLeg = TRUE, tabHeight = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplotTableAndPlot_+3A_object">object</code></td>
<td>
<p>An object of class <code>"tableAndPlot"</code>, as returned by
<code>ggplot.Ten</code>.</p>
</td></tr>
<tr><td><code id="autoplotTableAndPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="autoplotTableAndPlot_+3A_hidetableg">hideTabLeg</code></td>
<td>
<p>Hide table legend.
<br />
If <code>hideTabLeg = TRUE</code> (the default), the table legend will not appear.</p>
</td></tr>
<tr><td><code id="autoplotTableAndPlot_+3A_tabheight">tabHeight</code></td>
<td>
<p>Table height, as a fraction/ proportion of the whole.
<br />
<code>tabHeight=0.25</code> (the default) makes the table 
<code class="reqn">0.25 = 25\%</code> of the whole plot height.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments to <code>plotHeigth</code> and <code>tabHeight</code> are
best specified as fractions adding to <code class="reqn">1</code>,
<br />
</p>


<h3>Value</h3>

<p>A graph, plotted with <code>gridExtra::grid.arrange</code>.
</p>


<h3>Note</h3>

<p>This method is called by <code><a href="#topic+print.tableAndPlot">print.tableAndPlot</a></code>
and by <code>print.stratTableAndPlot</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Dardis. Based on existing work by
R. Saccilotto, Abhijit Dasgupta, Gil Tomas and Mark Cowley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("kidney", package="KMsurv")
autoplot(survfit(Surv(time, delta) ~ type, data=kidney), type="fill")
autoplot(ten(survfit(Surv(time, delta) ~ type, data=kidney)), type="fill")
data("bmt", package="KMsurv")
s2 &lt;- survfit(Surv(time=t2, event=d3) ~ group, data=bmt)
autoplot(s2)

## End(Not run)
</code></pre>

<hr>
<h2 id='autoplotTen'>Generate a <code>ggplot</code> for a <code>survfit</code> or <code>ten</code> object</h2><span id='topic+autoplotTen'></span><span id='topic+autoplot'></span><span id='topic+autoplot.ten'></span><span id='topic+autoplot.stratTen'></span><span id='topic+autoplot.survfit'></span>

<h3>Description</h3>

<p>Generate a <code>ggplot</code> for a <code>survfit</code> or <code>ten</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot(object, ...)

## S3 method for class 'ten'
autoplot(
  object,
  ...,
  title = "Marks show times with censoring",
  type = c("single", "CI", "fill"),
  alpha = 0.05,
  ciLine = 10,
  censShape = 3,
  palette = c("Dark2", "Set2", "Accent", "Paired", "Pastel1", "Pastel2", "Set1",
    "Set3"),
  jitter = c("none", "noEvents", "all"),
  tabTitle = "Number at risk by time",
  xLab = "Time",
  timeTicks = c("major", "minor", "days", "months", "custom"),
  times = NULL,
  yLab = "Survival",
  yScale = c("perc", "frac"),
  legend = TRUE,
  legTitle = "Group",
  legLabs = NULL,
  legOrd = NULL,
  titleSize = 15,
  axisTitleSize = 15,
  axisLabSize = 10,
  survLineSize = 0.5,
  censSize = 5,
  legTitleSize = 10,
  legLabSize = 10,
  fillLineSize = 0.05,
  tabTitleSize = 15,
  tabLabSize = 5,
  nRiskSize = 5
)

## S3 method for class 'stratTen'
autoplot(
  object,
  ...,
  title = NULL,
  type = c("single", "CI", "fill"),
  alpha = 0.05,
  ciLine = 10,
  censShape = 3,
  palette = c("Dark2", "Set2", "Accent", "Paired", "Pastel1", "Pastel2", "Set1",
    "Set3"),
  jitter = c("none", "noEvents", "all"),
  tabTitle = "Number at risk by time",
  xLab = "Time",
  timeTicks = c("major", "minor", "days", "months", "custom"),
  times = NULL,
  yLab = "Survival",
  yScale = c("perc", "frac"),
  legend = TRUE,
  legTitle = "Group",
  legLabs = NULL,
  legOrd = NULL,
  titleSize = 15,
  axisTitleSize = 15,
  axisLabSize = 10,
  survLineSize = 0.5,
  censSize = 5,
  legTitleSize = 10,
  legLabSize = 10,
  fillLineSize = 0.05,
  tabTitleSize = 15,
  tabLabSize = 5,
  nRiskSize = 5
)

## S3 method for class 'survfit'
autoplot(
  object,
  ...,
  title = "Marks show times with censoring",
  type = c("single", "CI", "fill"),
  alpha = 0.05,
  ciLine = 10,
  censShape = 3,
  palette = c("Dark2", "Set2", "Accent", "Paired", "Pastel1", "Pastel2", "Set1",
    "Set3"),
  jitter = c("none", "noEvents", "all"),
  tabTitle = "Number at risk by time",
  xLab = "Time",
  timeTicks = c("major", "minor", "weeks", "months", "custom"),
  times = NULL,
  yLab = "Survival",
  yScale = c("perc", "frac"),
  legend = TRUE,
  legLabs = NULL,
  legOrd = NULL,
  legTitle = "Group",
  titleSize = 15,
  axisTitleSize = 15,
  axisLabSize = 10,
  survLineSize = 0.5,
  censSize = 5,
  legTitleSize = 10,
  legLabSize = 10,
  fillLineSize = 0.05,
  tabTitleSize = 15,
  tabLabSize = 5,
  nRiskSize = 5,
  pVal = FALSE,
  sigP = 1,
  pX = 0.1,
  pY = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplotTen_+3A_object">object</code></td>
<td>
<p>An object of class <code>survfit</code>, <code>ten</code> or <code>stratTen</code>.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_title">title</code></td>
<td>
<p>Title for survival plot.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_type">type</code></td>
<td>
<p><code>type="single"</code> (the default) plots single lines.
</p>

<dl>
<dt><code>type="CI"</code></dt><dd><p>Adds lines indicating
confidence intervals (taken from <code>upper</code> and <code>lower</code>
values of <code>survfit</code> object).
<br />
Higher values of <code>alpha</code> (opacity) are recommended for this,
e.g. <code>alpha=0.8</code>.</p>
</dd>
<dt><code>type="fill"</code></dt><dd><p>Adds filled rectangles from the survival lines to
the confidence intervals above.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="autoplotTen_+3A_alpha">alpha</code></td>
<td>
<p>Opacity of lines indicating confidence intervals
or filled rectangles. Should be in range <code class="reqn">0-1</code>. Lower = more transparent.
<br />
Larger values e.g. <code>alpha=0.7</code> are recommended for confidence
intervals.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_ciline">ciLine</code></td>
<td>
<p>Confidence interval line type. See 'line type specification' in 
<br />
?graphics::par</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_censshape">censShape</code></td>
<td>
<p>Shape of marks to indicate censored onservations.
<br /> 
Default is <code>3</code> which gives vertical ticks.
<br /> 
Use <code>censShape=10</code> for circular marks. See 
<br />
?graphics::points</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_palette">palette</code></td>
<td>
<p>Options are taken from
<a href="https://colorbrewer2.org/">color_brewer</a>.
</p>

<ul>
<li> <p><code>palette="Dark2"</code> (the default) is recommended for
<code>single</code> or <code>CI</code> plots.
</p>
</li>
<li> <p><code>palette="Set2"</code> is recommended for <code>type="fill"</code> plots.
</p>
</li></ul>
</td></tr>
<tr><td><code id="autoplotTen_+3A_jitter">jitter</code></td>
<td>
<p>By default, <code>jitter="none"</code>.
</p>

<ul>
<li><p> If <code>jitter="noEvents"</code>, adds some random, positive noise
to survival lines with no events (i.e. all observations censored).
This will bring them just above 1 on the y-axis, making them easier to see separately.
</p>
</li>
<li><p> If <code>jitter="all"</code> add some vertical 
and horizontal noise to all survival lines. This can prevent overlapping 
of lines for censoring.
</p>
</li></ul>
</td></tr>
<tr><td><code id="autoplotTen_+3A_tabtitle">tabTitle</code></td>
<td>
<p>Table title.
<br /> <br />
<b>&ndash;Axis arguments:</b></p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_xlab">xLab</code></td>
<td>
<p>Label for <code class="reqn">x</code> axis on survival plot.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_timeticks">timeTicks</code></td>
<td>
<p>Numbers to mark on the <code class="reqn">x</code> axis of 
the survival plot and the table.
</p>

<dl>
<dt><code>"major"</code></dt><dd> 
<p>(the default) only the major <code class="reqn">x</code>-axis (time) marks from the
survival plot are are labelled on the plot and table.</p>
</dd>
<dt><code>"minor"</code></dt><dd><p>minor axis marks are labelled instead.</p>
</dd>
<dt><code>"days"</code></dt><dd><p>scale is <code class="reqn">0, 7, 14, ..., t_{max}</code></p>
</dd>
<dt><code>"months"</code></dt><dd><p>scale is <code class="reqn">0, 12,, 24, ..., t_{max}</code></p>
</dd>
<dt><code>"custom"</code></dt><dd><p>scale is given by <code>times</code> below</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="autoplotTen_+3A_times">times</code></td>
<td>
<p>Vector of custom times to use for <code class="reqn">x</code> axis.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_ylab">yLab</code></td>
<td>
<p>Label for <code class="reqn">y</code> axis on survival plot.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_yscale">yScale</code></td>
<td>
<p>Display for point on <code class="reqn">y</code> axis:
</p>

<dl>
<dt><code>"perc"</code></dt><dd><p>Displays as percentages.</p>
</dd>
<dt><code>"frac"</code></dt><dd><p>Displays as fractions e.g. <code class="reqn">0, 0.1, 0.2, ..., 1.0.</code></p>
</dd>
</dl>

<p><b>&ndash;Legend arguments:</b>
<br /></p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_legend">legend</code></td>
<td>
<p>If <code>legend=FALSE</code>, no legends will be produced
for the plot or table.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_legtitle">legTitle</code></td>
<td>
<p>Legend title.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_leglabs">legLabs</code></td>
<td>
<p>Legend labels. These can be used to replace the names
of the covariate groups ('strata' in the case of a <code>survfit</code> object).
<br />
Should be given in the same order as those strata.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_legord">legOrd</code></td>
<td>
<p>Legend order.
<br /> <br />
<b>&ndash;Size arguments:</b>
<br />
Size arguments are passed to <code>ggplot2::element_text(size=)</code>.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_titlesize">titleSize</code></td>
<td>
<p>Title size for survival plot.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_axistitlesize">axisTitleSize</code></td>
<td>
<p>Title size for axes.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_axislabsize">axisLabSize</code></td>
<td>
<p>Title size for labels on axes.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_survlinesize">survLineSize</code></td>
<td>
<p>Survival line size.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_censsize">censSize</code></td>
<td>
<p>Size of marks to indicate censored onservations.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_legtitlesize">legTitleSize</code></td>
<td>
<p>Title size for legend.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_leglabsize">legLabSize</code></td>
<td>
<p>Legend labels width and height.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_filllinesize">fillLineSize</code></td>
<td>
<p>Line size surrouding filled boxes.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_tabtitlesize">tabTitleSize</code></td>
<td>
<p>Table title text size.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_tablabsize">tabLabSize</code></td>
<td>
<p>Table legend text size.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_nrisksize">nRiskSize</code></td>
<td>
<p>Number at risk - text size.
<br /> <br />
<b>&ndash;Arguments for autoplot.survfit only:</b>
<br /></p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_pval">pVal</code></td>
<td>
<p>If <code>pVal=TRUE</code>, adds <code class="reqn">p</code> value from
log-rank test to plot</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_sigp">sigP</code></td>
<td>
<p>No. of significant digits to display in <code class="reqn">p</code> value.
Typically <code class="reqn">1</code> to <code class="reqn">3</code>.</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_px">pX</code></td>
<td>
<p>Location of <code class="reqn">p</code> value on <code class="reqn">x</code> axis.
<br />
Should be in the range of <code class="reqn">0 - 1</code>,
where value is to be placed relative to the maximum observed
time.
<br />
E.g. <code>pX = 0.5</code> will place it half-way along <code class="reqn">x</code>-axis</p>
</td></tr>
<tr><td><code id="autoplotTen_+3A_py">pY</code></td>
<td>
<p>Location of <code class="reqn">p</code> value on <code class="reqn">y</code> axis.
<br />
Should be in the range of <code class="reqn">0 - 1</code>, as above.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>autoplot.survfit</code> may be deprecated after packageVersion 0.6.
Please try to use <code>autoplot.ten</code> instead.
</p>


<h3>Author(s)</h3>

<p>Chris Dardis. <code>autoplot.survfit</code> based on existing work by
R. Saccilotto, Abhijit Dasgupta, Gil Tomas and Mark Cowley.
</p>


<h3>See Also</h3>

<p>?ggplot2::ggplot_build
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples are slow to run; see vignette for output from these
## Not run: 
### autoplot.ten
data("kidney", package="KMsurv")
t1 &lt;- ten(survfit(Surv(time, delta) ~ type, data=kidney))
autoplot(t1)
autoplot(t1, type="fill", survLineSize=2, jitter="all")
autoplot(t1, timeTicks="months", 
 type="CI", jitter="all",
 legLabs=c("surgical", "percutaneous"),
 title="Time to infection following catheter placement \n
   by type of catheter, for dialysis patients",
 titleSize=10, censSize=2)$plot
t2 &lt;- ten(survfit(Surv(time=time, event=delta) ~ 1, data=kidney))
autoplot(t2, legLabs="")$plot
autoplot(t2, legend=FALSE)
data("rectum.dat", package="km.ci")
t3 &lt;- ten(survfit(Surv(time, status) ~ 1, data=rectum.dat))
## change confidence intervals to log Equal-Precision confidence bands
ci(t3, how="nair", tL=1, tU=40)
autoplot(t3, type="fill", legend=FALSE)$plot
## manually changing the output
t4 &lt;- ten(survfit(Surv(time, delta) ~ type, data=kidney))
(a4 &lt;- autoplot(t4, type="CI", alpha=0.8, survLineSize=2)$plot)
## change default colors
a4 + list(ggplot2::scale_color_manual(values=c("red", "blue")),
          ggplot2::scale_fill_manual(values=c("red", "blue")))
## change limits of y-axis
suppressMessages(a4 + ggplot2::scale_y_continuous(limits=c(0, 1)))

## End(Not run)
## Not run: 
data("pbc", package="survival")
t1 &lt;- ten(Surv(time, status==2) ~ trt + strata(edema), data=pbc, abbNames=FALSE)
autoplot(t1)

## End(Not run)
### autoplot.survfit
## Not run: 
data(kidney, package="KMsurv")
s1 &lt;- survfit(Surv(time, delta) ~ type, data=kidney)
autoplot(s1, type="fill", survLineSize=2)
autoplot(s1, type="CI", pVal=TRUE, pX=0.3,
 legLabs=c("surgical", "percutaneous"),
 title="Time to infection following catheter placement \n
   by type of catheter, for dialysis patients")$plot
s1 &lt;- survfit(Surv(time=time, event=delta) ~ 1, data=kidney)
autoplot(s1, legLabs="")$plot
autoplot(s1, legend=FALSE)$plot
data(rectum.dat, package="km.ci")
s1 &lt;- survfit(Surv(time, status) ~ 1, data=rectum.dat)
## change confidence intervals to log Equal-Precision confidence bands
if (require("km.ci")) {
 km.ci::km.ci(s1, method="logep")
 autoplot(s1, type="fill", legend=FALSE)$plot
}
## manually changing the output
s1 &lt;- survfit(Surv(time, delta) ~ type, data=kidney)
g1 &lt;- autoplot(s1, type="CI", alpha=0.8, survLineSize=2)$plot
## change default colors
g1 + ggplot2::scale_colour_manual(values=c("red", "blue")) +
    ggplot2::scale_fill_manual(values=c("red", "blue"))
## change limits of y-axis
g1 + ggplot2::scale_y_continuous(limits=c(0, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='ci'><b>c</b>onfidence <b>i</b>ntervals for survival curves.</h2><span id='topic+ci'></span><span id='topic+ci.ten'></span><span id='topic+ci.stratTen'></span>

<h3>Description</h3>

<p><b>c</b>onfidence <b>i</b>ntervals for survival curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(x, ...)

## S3 method for class 'ten'
ci(
  x,
  ...,
  CI = c("0.95", "0.9", "0.99"),
  how = c("point", "nair", "hall"),
  trans = c("log", "lin", "asi"),
  tL = NULL,
  tU = NULL,
  reCalc = FALSE
)

## S3 method for class 'stratTen'
ci(
  x,
  ...,
  CI = c("0.95", "0.9", "0.99"),
  how = c("point", "nair", "hall"),
  trans = c("log", "lin", "asi"),
  tL = NULL,
  tU = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_+3A_x">x</code></td>
<td>
<p>An object of class <code>ten</code>.</p>
</td></tr>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="ci_+3A_ci">CI</code></td>
<td>
<p>Confidence intervals. As the function currently relies on lookup
tables, currently only 90%, 95% (the default) and 99% are supported.</p>
</td></tr>
<tr><td><code id="ci_+3A_how">how</code></td>
<td>
<p>Method to use for confidence interval.
<br />
<code>point</code> (the default) uses pointwise confirence intervals.
<br />
The alternatives use confidence <em>bands</em> (see details).</p>
</td></tr>
<tr><td><code id="ci_+3A_trans">trans</code></td>
<td>
<p>Transformation to use.
<br />
The default is <code>trans="log"</code>.
<br />
Also supported are linear and arcsine-square root transformations.</p>
</td></tr>
<tr><td><code id="ci_+3A_tl">tL</code></td>
<td>
<p><b>L</b>ower time point. Used in construction of confidence bands.</p>
</td></tr>
<tr><td><code id="ci_+3A_tu">tU</code></td>
<td>
<p><b>U</b>pper time point. Used in construction of confidence bands.</p>
</td></tr>
<tr><td><code id="ci_+3A_recalc">reCalc</code></td>
<td>
<p>Recalcuate the values?
<br />
If <code>reCalc=FALSE</code> (the default) and the <code>ten</code> object already has
the calculated values stored as an <code>attribute</code>,
the value of the <code>attribute</code> is returned directly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the equations below
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2_s(t) = \frac{\hat{V}[\hat{S}(t)]}{\hat{S}^2(t)} </code>
</p>

<p>Where <code class="reqn">\hat{S}(t) </code> is the Kaplan-Meier survival estimate and
<code class="reqn">\hat{V}[\hat{S}(t)]</code> is Greenwood's estimate of its
variance.
<br />
The <b>pointwise</b> confidence intervals are valid for <em>individual</em>
times, e.g. <code>median</code> and <code><a href="stats.html#topic+quantile">quantile</a></code> values.
When plotted and joined for multiple points they tend to
be narrower than the <em>bands</em> described below.
Thus they tend to exaggerate the impression of certainty
when used to plot confidence intervals for a time range.
They should not be interpreted as giving the intervals
within which the <em>entire</em> survival function lies.
<br />
For a given significance level <code class="reqn">\alpha</code>,
they are calculated using the standard normal distribution <code class="reqn">Z</code>
as follows:
</p>

<ul>
<li><p> linear
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t) \pm Z_{1- \alpha} \sigma (t) \hat{S}(t)</code>
</p>

</li>
<li><p> log transform
</p>
<p style="text-align: center;"><code class="reqn"> [ \hat{S}(t)^{\frac{1}{\theta}}, \hat{S}(t)^{\theta} ] </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn"> \theta = \exp{ \frac{Z_{1- \alpha} \sigma (t)}{ \log{\hat{S}(t)}}} </code>
</p>

</li>
<li><p> arcsine-square root transform
<br />
upper:
<br />
</p>
<p style="text-align: center;"><code class="reqn"> \sin^2(\max[0, \arcsin{\sqrt{\hat{S}(t)}} -
  \frac{Z_{1- \alpha}\sigma(t)}{2}
  \sqrt{ \frac{\hat{S}(t)}{1-\hat{S}(t)}}]) </code>
</p>

<p>lower:
</p>
<p style="text-align: center;"><code class="reqn"> \sin^2(\min[\frac{\pi}{2}, \arcsin{\sqrt{\hat{S}(t)}} +
  \frac{Z_{1- \alpha}\sigma(t)}{2}
  \sqrt{ \frac{\hat{S}(t)}{1-\hat{S}(t)}}]) </code>
</p>

</li></ul>

<p>Confidence <b>bands</b> give the values within which the survival function
falls within a <em>range</em> of timepoints.
<br /> <br />
The time range under consideration is given so that
<code class="reqn">t_l \geq t_{min}</code>, the minimum or lowest event time and
<code class="reqn">t_u \leq t_{max}</code>, the maximum or largest event time.
<br />
For a sample size <code class="reqn">n</code> and <code class="reqn">0 &lt; a_l &lt; a_u &lt;1</code>:
</p>
<p style="text-align: center;"><code class="reqn">a_l = \frac{n\sigma^2_s(t_l)}{1+n\sigma^2_s(t_l)}</code>
</p>

<p style="text-align: center;"><code class="reqn">a_u = \frac{n\sigma^2_s(t_u)}{1+n\sigma^2_s(t_u)}</code>
</p>

<p>For the <b>Nair</b> or <b>equal precision</b> (<b>EP</b>) confidence bands,
we begin by obtaining the relevant
confidence coefficient <code class="reqn">c_{\alpha}</code>. This is obtained from
the upper <code class="reqn">\alpha</code>-th fractile of the random variable
</p>
<p style="text-align: center;"><code class="reqn">U = \sup{|W^o(x)\sqrt{[x(1-x)]}|, \quad a_l \leq x \leq a_u}</code>
</p>

<p>Where <code class="reqn">W^o</code> is a standard Brownian bridge.
<br />
The intervals are:
</p>

<ul>
<li><p> linear
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t) \pm c_{\alpha} \sigma_s(t) \hat{S}(t)</code>
</p>

</li>
<li><p> log transform (the default)
<br />
This uses <code class="reqn">\theta</code> as below:
</p>
<p style="text-align: center;"><code class="reqn">\theta = \exp{ \frac{c_{\alpha} \sigma_s(t)}{ \log{\hat{S}(t)}}}</code>
</p>

<p>And is given by:
</p>
<p style="text-align: center;"><code class="reqn">[\hat{S}(t)^{\frac{1}{\theta}}, \hat{S}(t)^{\theta}]</code>
</p>

</li>
<li><p> arcsine-square root transform
<br />
upper:
</p>
<p style="text-align: center;"><code class="reqn">\sin^2(\max[0, \arcsin{\sqrt{\hat{S}(t)}}
        - \frac{c_{\alpha}\sigma_s(t)}{2}
        \sqrt{ \frac{\hat{S}(t)}{1-\hat{S}(t)}}])</code>
</p>

<p>lower:
</p>
<p style="text-align: center;"><code class="reqn">\sin^2(\min[\frac{\pi}{2}, \arcsin{\sqrt{\hat{S}(t)}}
        + \frac{c_{\alpha}\sigma_s(t)}{2}
        \sqrt{ \frac{\hat{S}(t)}{1-\hat{S}(t)}}]) </code>
</p>

</li></ul>

<p>For the <b>Hall-Wellner</b> bands the confidence coefficient
<code class="reqn">k_{\alpha}</code>
is obtained from the upper <code class="reqn">\alpha</code>-th fractile of a
Brownian bridge.
<br />
In this case <code class="reqn">t_l</code> can be <code class="reqn">=0</code>.
<br />
The intervals are:
</p>

<ul>
<li><p> linear
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t) \pm
       k_{\alpha} \frac{1+n\sigma^2_s(t)}{\sqrt{n}} \hat{S}(t)</code>
</p>

</li>
<li><p> log transform
</p>
<p style="text-align: center;"><code class="reqn">[\hat{S}(t)^{\frac{1}{\theta}}, \hat{S}(t)^{\theta}]</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\theta = \exp{ \frac{k_{\alpha}[1+n\sigma^2_s(t)]}{
       \sqrt{n}\log{\hat{S}(t)}}} </code>
</p>

</li>
<li><p> arcsine-square root transform
<br />
upper:
</p>
<p style="text-align: center;"><code class="reqn"> \sin^2(\max[0, \arcsin{\sqrt{\hat{S}(t)}}
  - \frac{k_{\alpha}[1+n\sigma_s(t)]}{2\sqrt{n}}
  \sqrt{ \frac{\hat{S}(t)}{1-\hat{S}(t)}}]) </code>
</p>

<p>lower:
</p>
<p style="text-align: center;"><code class="reqn"> \sin^2(\min[\frac{\pi}{2}, \arcsin{\sqrt{\hat{S}(t)}}
  + \frac{k_{\alpha}[1+n\sigma^2_s(t)]}{2\sqrt{n}}
  \sqrt{ \frac{\hat{S}(t)}{1-\hat{S}(t)}}]) </code>
</p>

</li></ul>



<h3>Value</h3>

<p>The <code>ten</code> object is modified in place by the additional of a 
<code>data.table</code> as an <code>attribute</code>.
<br />
<code>attr(x, "ci")</code> is printed.
<br />
This A <code>survfit</code> object. The <code>upper</code> and <code>lower</code>
elements in the list (representing confidence intervals)
are modified from the original.
<br />
Other elements will also be shortened if the time range under consideration has been
reduced from the original.
</p>


<h3>Note</h3>


<ul>
<li><p> For the Nair and Hall-Wellner bands, the function currently
relies on the lookup tables in <code>package:km.ci</code>.
</p>
</li>
<li><p> Generally, the arcsin-square root transform has the best coverage properties.
</p>
</li>
<li><p> All bands have good coverage properties for samples as small as <code class="reqn">n=20</code>,
except for the <b>Nair</b> / <b>EP</b> bands with a linear transformation,
which perform poorly when <code class="reqn">n &lt; 200</code>.
</p>
</li></ul>



<h3>Source</h3>

<p>The function is loosely based on <code>km.ci::km.ci</code>.
</p>


<h3>References</h3>

<p>Nair V, 1984.
Confidence bands for survival functions with censored data: a comparative study.
<em>Technometrics</em>. <b>26</b>(3):265-75.
&lsquo;<span class="samp">&#8288;http://www.jstor.org/stable/1267553&#8288;</span>&rsquo; JSTOR
</p>
<p>Hall WJ, Wellner JA, 1980.
Confidence bands for a survival curve from censored data.
<em>Biometrika</em>. <b>67</b>(1):133-43.
&lsquo;<span class="samp">&#8288;http://www.jstor.org/stable/2335326&#8288;</span>&rsquo; JSTOR
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sf">sf</a></code>
</p>
<p><code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## K&amp;M 2nd ed. Section 4.3. Example 4.2, pg 105.
data("bmt", package="KMsurv")
b1 &lt;- bmt[bmt$group==1, ] # ALL patients
## K&amp;M 2nd ed. Section 4.4. Example 4.2 (cont.), pg 111.
## patients with ALL
t1 &lt;- ten(Surv(t2, d3) ~ 1, data=bmt[bmt$group==1, ])
ci(t1, how="nair", trans="lin", tL=100, tU=600)
## Table 4.5, pg. 111.
lapply(list("lin", "log", "asi"),
       function(x) ci(t1, how="nair", trans=x, tL=100, tU=600))
## Table 4.6, pg. 111.
lapply(list("lin", "log", "asi"),
       function(x) ci(t1, how="hall", trans=x, tL=100, tU=600))
t1 &lt;- ten(Surv(t2, d3) ~ group, data=bmt)
ci(t1, CI="0.95", how="nair", trans="lin", tL=100, tU=600)

## stratified model
data("pbc", package="survival")
t1 &lt;- ten(coxph(Surv(time, status==2) ~ log(bili) + age + strata(edema), data=pbc))
ci(t1)

</code></pre>

<hr>
<h2 id='comp'>compare survival curves</h2><span id='topic+comp'></span><span id='topic+comp.ten'></span>

<h3>Description</h3>

<p>compare survival curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp(x, ...)

## S3 method for class 'ten'
comp(x, ..., p = 1, q = 1, scores = seq.int(attr(x, "ncg")), reCalc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_+3A_x">x</code></td>
<td>
<p>A <code>tne</code> object</p>
</td></tr>
<tr><td><code id="comp_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="comp_+3A_p">p</code></td>
<td>
<p><code class="reqn">p</code> for Fleming-Harrington test</p>
</td></tr>
<tr><td><code id="comp_+3A_q">q</code></td>
<td>
<p><code class="reqn">q</code> for Fleming-Harrington test</p>
</td></tr>
<tr><td><code id="comp_+3A_scores">scores</code></td>
<td>
<p>scores for tests for trend</p>
</td></tr>
<tr><td><code id="comp_+3A_recalc">reCalc</code></td>
<td>
<p>Recalcuate the values?
<br />
If <code>reCalc=FALSE</code> (the default) and the <code>ten</code> object already has
the calculated values stored as an <code>attribute</code>,
the value of the <code>attribute</code> is returned directly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <b>log-rank</b> tests are formed from the following elements,
with values for each time where there is at least one event:
</p>

<ul>
<li> <p><code class="reqn">W_i</code>, the weights, given below.
</p>
</li>
<li> <p><code class="reqn">e_i</code>, the number of events (per time).
</p>
</li>
<li> <p><code class="reqn">\hat{e_i}</code>, the number of <em>predicted</em> events,
given by <code><a href="#topic+predict">predict</a></code>.
</p>
</li>
<li> <p><code class="reqn">COV_i</code>, the covariance matrix for time <code class="reqn">i</code>,
given by <code><a href="#topic+COV">COV</a></code>.
</p>
</li></ul>

<p>It is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">Q_i = \sum{W_i (e_i - \hat{e}_i)}^T
             \sum{W_i \hat{COV_i} W_i^{-1}}
             \sum{W_i (e_i - \hat{e}_i)}</code>
</p>

<p>If there are <code class="reqn">K</code> groups, then <code class="reqn">K-1</code> are selected (arbitrary).
<br />
Likewise the corresponding variance-covariance matrix is reduced to the
appropriate <code class="reqn">K-1 \times K-1</code> dimensions.
<br />
<code class="reqn">Q</code> is distributed as chi-square with <code class="reqn">K-1</code> degrees of freedom.
<br /> <br />
For <code class="reqn">2</code> covariate groups, we can use:
</p>

<ul>
<li> <p><code class="reqn">e_i</code> the number of events (per time).
</p>
</li>
<li> <p><code class="reqn">n_i</code> the number at risk overall.
</p>
</li>
<li> <p><code class="reqn">e1_i</code> the number of events in group <code class="reqn">1</code>.
</p>
</li>
<li> <p><code class="reqn">n1_i</code> the number at risk in group <code class="reqn">1</code>.
</p>
</li></ul>
 
<p>Then:
</p>
<p style="text-align: center;"><code class="reqn">Q = \frac{\sum{W_i [e1_i - n1_i (\frac{e_i}{n_i})]} }{
                \sqrt{\sum{W_i^2 \frac{n1_i}{n_i}
                           (1 - \frac{n1_i}{n_i})
                           (\frac{n_i - e_i}{n_i - 1}) e_i }}}</code>
</p>

<p>Below, for the Fleming-Harrington weights, 
<code class="reqn">\hat{S}(t)</code> is the Kaplan-Meier (product-limit) estimator.
<br />
Note that both <code class="reqn">p</code> and <code class="reqn">q</code> need to be <code class="reqn">\geq 0</code>.
<br /> <br />
The weights are given as follows:
</p>

<table>
<tr>
 <td style="text-align: center;">
 <code class="reqn">1</code> </td><td style="text-align: left;"> log-rank </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
 <code class="reqn">n_i</code> </td><td style="text-align: left;"> Gehan-Breslow generalized Wilcoxon </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
 <code class="reqn">\sqrt{n_i}</code> </td><td style="text-align: left;"> Tarone-Ware </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: center;">
 <code class="reqn">S1_i</code> </td><td style="text-align: left;"> Peto-Peto's modified survival estimate </td><td style="text-align: left;">
                   <code class="reqn">\bar{S}(t)=\prod{1 - \frac{e_i}{n_i + 1}}</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
 <code class="reqn">S2_i</code> </td><td style="text-align: left;"> modified Peto-Peto (by Andersen) </td><td style="text-align: left;">
                    <code class="reqn">\tilde{S}(t)=\bar{S} - \frac{n_i}{n_i + 1}</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
 <code class="reqn">FH_i</code> </td><td style="text-align: left;"> Fleming-Harrington </td><td style="text-align: left;">
                  The weight at <code class="reqn">t_0 = 1</code> and thereafter is:
                   <code class="reqn">\hat{S}(t_{i-1})^p [1-\hat{S}(t_{i-1})^q]</code>
</td>
</tr>

</table>

<p>The <b>supremum (Renyi)</b> family of tests are designed
to detect differences in survival curves which <em>cross</em>.
<br />
That is, an early difference in survival in favor of one group
is balanced by a later reversal.
<br />
The same weights as above are used.
<br />
They are calculated by finding
</p>
<p style="text-align: center;"><code class="reqn">Z(t_i) = \sum_{t_k \leq t_i} W(t_k)[e1_k - n1_k\frac{e_k}{n_k}], \quad i=1,2,...,k</code>
</p>

<p>(which is similar to the numerator used to find <code class="reqn">Q</code>
in the log-rank test for 2 groups above).
<br />
and it's variance:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2(\tau) = \sum_{t_k \leq \tau} W(t_k)^2 \frac{n1_k n2_k (n_k-e_k) e_k}{n_k^2 (n_k-1)} </code>
</p>

<p>where <code class="reqn">\tau</code> is the largest <code class="reqn">t</code>
where both groups have at least one subject at risk.
<br /> <br />
Then calculate:
</p>
<p style="text-align: center;"><code class="reqn"> Q = \frac{ \sup{|Z(t)|}}{\sigma(\tau)}, \quad t&lt;\tau </code>
</p>

<p>When the null hypothesis is true,
the distribution of <code class="reqn">Q</code> is approximately
</p>
<p style="text-align: center;"><code class="reqn">Q \sim \sup{|B(x)|, \quad 0 \leq x \leq 1}</code>
</p>

<p>And for a standard Brownian motion (Wiener) process:
</p>
<p style="text-align: center;"><code class="reqn">Pr[\sup|B(t)|&gt;x] = 1 - \frac{4}{\pi}
                          \sum_{k=0}^{\infty}
                          \frac{(- 1)^k}{2k + 1} \exp{\frac{-\pi^2(2k + 1)^2}{8x^2}}</code>
</p>

<p><b>Tests for trend</b> are designed to detect ordered differences in survival curves.
<br />
That is, for at least one group:
</p>
<p style="text-align: center;"><code class="reqn">S_1(t) \geq S_2(t) \geq ... \geq S_K(t) \quad t \leq \tau</code>
</p>

<p>where <code class="reqn">\tau</code> is the largest <code class="reqn">t</code> where all groups have at least one subject at risk.
The null hypothesis is that
</p>
<p style="text-align: center;"><code class="reqn">S_1(t) = S_2(t) = ... = S_K(t) \quad t \leq \tau</code>
</p>

<p>Scores used to construct the test are typically <code class="reqn">s = 1,2,...,K</code>,
but may be given as a vector representing a numeric characteristic of the group.
<br />
They are calculated by finding:
</p>
<p style="text-align: center;"><code class="reqn"> Z_j(t_i) = \sum_{t_i \leq \tau} W(t_i)[e_{ji} - n_{ji} \frac{e_i}{n_i}], 
                   \quad j=1,2,...,K</code>
</p>

<p>The test statistic is:
</p>
<p style="text-align: center;"><code class="reqn">Z = \frac{ \sum_{j=1}^K s_jZ_j(\tau)}{\sqrt{\sum_{j=1}^K \sum_{g=1}^K s_js_g \sigma_{jg}}} </code>
</p>

<p>where <code class="reqn">\sigma</code> is the the appropriate element in the
variance-covariance matrix (see <code><a href="#topic+COV">COV</a></code>).
<br />
If ordering is present, the statistic <code class="reqn">Z</code> will be greater than the 
upper <code class="reqn">\alpha</code>-th
percentile of a standard normal distribution.
</p>


<h3>Value</h3>

<p>The <code>tne</code> object is given
additional <code>attributes</code>.
<br />
The following are always added:
</p>
<table>
<tr><td><code>lrt</code></td>
<td>
<p>The <b>l</b>og-<b>r</b>ank family of <b>t</b>ests</p>
</td></tr>
<tr><td><code>lrw</code></td>
<td>
<p>The <b>l</b>og-<b>r</b>ank <b>w</b>eights (used in calculating the tests).</p>
</td></tr>
</table>
<p>An additional item depends on the number of covariate groups.
<br />
If this is <code class="reqn">=2</code>:
</p>
<table>
<tr><td><code>sup</code></td>
<td>
<p>The <b>sup</b>remum or Renyi family of tests</p>
</td></tr>
</table>
<p>and if this is <code class="reqn">&gt;2</code>:
</p>
<table>
<tr><td><code>tft</code></td>
<td>
<p>Tests for trend. This is given as a <code>list</code>, 
with the statistics and the scores used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Regarding the Fleming-Harrington weights: 
</p>

<ul>
<li> <p><code class="reqn">p = q = 0</code> gives the log-rank test, i.e. <code class="reqn">W=1</code>
</p>
</li>
<li> <p><code class="reqn">p=1, q=0</code> gives a version of the Mann-Whitney-Wilcoxon test
(tests if populations distributions are identical)
</p>
</li>
<li> <p><code class="reqn">p=0, q&gt;0</code> gives more weight to differences later on
</p>
</li>
<li> <p><code class="reqn">p&gt;0, q=0</code> gives more weight to differences early on
</p>
</li></ul>

<p>The example using <code>alloauto</code> data illustrates this.
Here the log-rank statistic
has a p-value of  around 0.5
as the late advantage of allogenic transplants
is offset by the high early mortality. However using
Fleming-Harrington weights of <code class="reqn">p=0, q=0.5</code>,
emphasising differences later in time, gives a p-value of 0.04.
<br />
Stratified models (<code>stratTen</code>) are <em>not</em> yet supported.
</p>


<h3>References</h3>

<p>Gehan A.
A Generalized Wilcoxon Test for Comparing Arbitrarily
Singly-Censored Samples.
Biometrika 1965 Jun. 52(1/2):203&ndash;23.
&lsquo;<span class="samp">&#8288;http://www.jstor.org/stable/2333825&#8288;</span>&rsquo; JSTOR
</p>
<p>Tarone RE, Ware J 1977
On Distribution-Free Tests for Equality of Survival Distributions.
<em>Biometrika</em>;<b>64</b>(1):156&ndash;60.
&lsquo;<span class="samp">&#8288;http://www.jstor.org/stable/2335790&#8288;</span>&rsquo; JSTOR
</p>
<p>Peto R, Peto J 1972
Asymptotically Efficient Rank Invariant Test Procedures.
<em>J Royal Statistical Society</em> <b>135</b>(2):186&ndash;207.
&lsquo;<span class="samp">&#8288;http://www.jstor.org/stable/2344317&#8288;</span>&rsquo; JSTOR
</p>
<p>Fleming TR, Harrington DP, O'Sullivan M 1987
Supremum Versions of the Log-Rank and Generalized Wilcoxon Statistics.
<em>J  American Statistical Association</em> <b>82</b>(397):312&ndash;20.
&lsquo;<span class="samp">&#8288;http://www.jstor.org/stable/2289169&#8288;</span>&rsquo; JSTOR
</p>
<p>Billingsly P 1999
<em>Convergence of Probability Measures.</em>
New York: John Wiley &amp; Sons.
&lsquo;<span class="samp">&#8288;http://dx.doi.org/10.1002/9780470316962&#8288;</span>&rsquo; Wiley (paywall)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two covariate groups
data("leukemia", package="survival")
f1 &lt;- survfit(Surv(time, status) ~ x, data=leukemia)
comp(ten(f1))
## K&amp;M 2nd ed. Example 7.2, Table 7.2, pp 209--210.
data("kidney", package="KMsurv")
t1 &lt;- ten(Surv(time=time, event=delta) ~ type, data=kidney)
comp(t1, p=c(0, 1, 1, 0.5, 0.5), q=c(1, 0, 1, 0.5, 2))
## see the weights used
attributes(t1)$lrw
## supremum (Renyi) test; two-sided; two covariate groups
## K&amp;M 2nd ed. Example 7.9, pp 223--226.
data("gastric", package="survMisc")
g1 &lt;- ten(Surv(time, event) ~ group, data=gastric)
comp(g1)
## Three covariate groups
## K&amp;M 2nd ed. Example 7.4, pp 212-214.
data("bmt", package="KMsurv")
b1 &lt;- ten(Surv(time=t2, event=d3) ~ group, data=bmt)
comp(b1, p=c(1, 0, 1), q=c(0, 1, 1))
## Tests for trend
## K&amp;M 2nd ed. Example 7.6, pp 217-218.
data("larynx", package="KMsurv")
l1 &lt;- ten(Surv(time, delta) ~ stage, data=larynx)
comp(l1)
attr(l1, "tft")
### see effect of F-H test
data("alloauto", package="KMsurv")
a1 &lt;- ten(Surv(time, delta) ~ type, data=alloauto)
comp(a1, p=c(0, 1), q=c(1, 1))

</code></pre>

<hr>
<h2 id='COV'><b>cov</b>ariance matrix for survival data</h2><span id='topic+COV'></span><span id='topic+COV.ten'></span><span id='topic+COV.stratTen'></span><span id='topic+COV.numeric'></span>

<h3>Description</h3>

<p><b>cov</b>ariance matrix for survival data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COV(x, ...)

## S3 method for class 'ten'
COV(x, ..., reCalc = FALSE)

## S3 method for class 'stratTen'
COV(x, ..., reCalc = FALSE)

## S3 method for class 'numeric'
COV(x, ..., n, ncg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="COV_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> vector of
<em>number of events</em>, <code class="reqn">e_t</code>.
These are assumed to be ordered by discrete times.
<br />
A method is available for objects of <code>class</code> <code>ten</code>.</p>
</td></tr>
<tr><td><code id="COV_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="COV_+3A_recalc">reCalc</code></td>
<td>
<p>Recalcuate the values?
<br />
If <code>reCalc=FALSE</code> (the default) and the <code>ten</code> object already has
the calculated values stored as an <code>attribute</code>,
the value of the <code>attribute</code> is returned directly.
<br /> <br />
<b>&ndash;Arguments for the numeric method:</b></p>
</td></tr>
<tr><td><code id="COV_+3A_n">n</code></td>
<td>
<p><b>n</b>umber at risk (total).</p>
</td></tr>
<tr><td><code id="COV_+3A_ncg">ncg</code></td>
<td>
<p><b>n</b>umber at risk, per <b>c</b>ovariate <b>g</b>roup.
<br />
If there are <code class="reqn">2</code> groups, this can be given as a <code>vector</code> with
the number at risk for group <code class="reqn">1</code>.
<br />
If there are <code class="reqn">\geq 2</code> groups, it is
a <code>matrix</code> with one column for each group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gives variance-covariance matrix for comparing survival
data for two or more groups.
<br />
Inputs are vectors corresponding to observations at a set of discrete
time points for right censored data, except for <code class="reqn">n1</code>,
the no. at risk by predictor.
<br />
This should be specified as a vector for one group,
otherwise as a matrix with each column corresponding to a group.
</p>


<h3>Value</h3>

<p>An <code>array</code>.
<br />
The first two dimensions = the number of covariate groups <code class="reqn">K</code>,
<code class="reqn">k = 1, 2, \ldots K</code>.
This is the square matrix below.
<br />
The third dimension is the number of observations
(discrete time points).
<br /> <br />
To calculate this, we use <code>x</code> (= <code class="reqn">e_t</code> below) and
<code class="reqn">n_1</code>, the number at risk in covariate group <code class="reqn">1</code>.
<br />
Where there are <code class="reqn">2</code> groups, the resulting sparse square matrix
(i.e. the non-diagonal elements are <code class="reqn">0</code>)
at time <code class="reqn">t</code> has diagonal elements:
</p>
<p style="text-align: center;"><code class="reqn">cov_t = - \frac{n_{0t} n_{1t} e_t (n_t - e_t)}{n_t^2(n_t-1)}</code>
</p>

<p>For <code class="reqn">\geq 2</code> groups, the resulting square matrix
has diagonal elements given by:
</p>
<p style="text-align: center;"><code class="reqn">cov_{kkt} = \frac{n_{kt}(n_t - n_{kt}) e_t(n_t - e_t)}{
                         n_t^2(n_t - 1)}</code>
</p>

<p>The off diagonal elements are:
</p>
<p style="text-align: center;"><code class="reqn">cov_{klt} = \frac{-n_{kt} n_{lt} e_t (n_t-e_t) }{
                        n_t^2(n_t-1)}</code>
</p>



<h3>Note</h3>

<p>Where the is just one subject at risk <code class="reqn">n=1</code> at 
the final timepoint, the equations above may produce <code>NaN</code>
due to division by zero. This is converted to <code>0</code> for 
simplicity.
</p>


<h3>See Also</h3>

<p>Called by <code><a href="#topic+comp">comp</a></code>
</p>
<p>The name of the function is capitalized 
to distinguish it from:
<br />
?stats::cov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two covariate groups
## K&amp;M. Example 7.2, pg 210, table 7.2 (last column).
## Not run: 
data("kidney", package="KMsurv")
k1 &lt;- with(kidney,
           ten(Surv(time=time, event=delta) ~ type))
COV(k1)[COV(k1) &gt; 0]

## End(Not run)
## Four covariate groups
## K&amp;M. Example 7.6, pg 217.
## Not run: 
data("larynx", package="KMsurv")
l1 &lt;- ten(Surv(time, delta) ~ stage, data=larynx)
rowSums(COV(l1), dims=2)

## End(Not run)
## example of numeric method
## Three covariate groups
## K&amp;M. Example 7.4, pg 212.
## Not run: 
data("bmt", package="KMsurv")
b1 &lt;- asWide(ten(Surv(time=t2, event=d3) ~ group, data=bmt))
rowSums(b1[, COV(x=e, n=n, ncg=matrix(data=c(n_1, n_2, n_3), ncol=3))], dims=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='cutp'><b>cut p</b>oint for a continuous variable in a
model fit with <code>coxph</code> or <code>survfit</code>.</h2><span id='topic+cutp'></span><span id='topic+cutp.coxph'></span><span id='topic+cutp.survfit'></span>

<h3>Description</h3>

<p><b>cut p</b>oint for a continuous variable in a
model fit with <code>coxph</code> or <code>survfit</code>.
</p>
<p>Determine the optimal cut point for a continuous variable
in a <code>coxph</code> or <code>survfit</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutp(x, ...)

## S3 method for class 'coxph'
cutp(x, ..., defCont = 3)

## S3 method for class 'survfit'
cutp(x, ..., defCont = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutp_+3A_x">x</code></td>
<td>
<p>A <code>survfit</code> or <code>coxph</code> object</p>
</td></tr>
<tr><td><code id="cutp_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="cutp_+3A_defcont">defCont</code></td>
<td>
<p><b>def</b>inition of a <b>cont</b>inuous variable.
<br />
If the variable has <code class="reqn">&gt;</code> <code>defCont</code> unique values, it
is treated as continuous and a cut point is determined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a cut point <code class="reqn">\mu</code>, of a predictor <code class="reqn">K</code>,
the variable is split
into two groups, those <code class="reqn">\geq \mu</code> and
those <code class="reqn">&lt; \mu</code>.
<br />
The score (or log-rank) statistic, <code class="reqn">sc</code>,
is calculated for each unique element
<code class="reqn">k</code> in <code class="reqn">K</code> and uses
</p>

<ul>
<li> <p><code class="reqn">e_i^+</code> the number of events
</p>
</li>
<li> <p><code class="reqn">n_i^+</code> the number at risk
</p>
</li></ul>

<p>in those above the cut point, respectively.
<br />
The basic statistic is 
</p>
<p style="text-align: center;"><code class="reqn">sc_k = \sum_{i=1}^D ( e_i^+ - n_i^+ \frac{e_i}{n_i} )</code>
</p>

<p><br />
The sum is taken across times with observed events, to <code class="reqn">D</code>,
the largest of these.
<br />
It is normalized (standardized), in the case of censoring,
by finding <code class="reqn">\sigma^2</code> which is:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2 = \frac{1}{D - 1}
                 \sum_i^D (1 - \sum_{j=1}^i \frac{1}{D+ 1 - j})^2</code>
</p>

<p>The test statistic is then
</p>
<p style="text-align: center;"><code class="reqn">Q = \frac{\max |sc_k|}{\sigma \sqrt{D-1}}</code>
</p>

<p>Under the null hypothesis that the chosen cut point
does <em>not</em> predict survival,
the distribution of <code class="reqn">Q</code> has a limiting distibution which
is the supremum of the
absolute value of a Brownian bridge:
</p>
<p style="text-align: center;"><code class="reqn">p = Pr(\sup Q \geq q) = 2 \sum_{i=1}^{\infty}
                             (-1)^{i + 1} \exp (-2 i^2 q^2)</code>
</p>



<h3>Value</h3>

<p>A <code>list</code> of <code>data.table</code>s.
<br />
There is one list element per continuous variable.
<br />
Each has a column with possible values of the cut point
(i.e. unique values of the variable), and the
additional columns:
</p>
<table>
<tr><td><code>U</code></td>
<td>
<p>The score (log-rank) test for a model with the variable 'cut'
into into those <code class="reqn">\geq</code> the cutpoint and those below.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>The test statistic.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The <code class="reqn">p</code>-value.</p>
</td></tr>
</table>
<p>The tables are ordered by <code class="reqn">p</code>-value, lowest first.
</p>


<h3>References</h3>

<p>Contal C, O'Quigley J, 1999.
An application of changepoint methods in studying the
effect of age on survival in breast cancer.
<em>Computational Statistics &amp; Data Analysis</em> <b>30</b>(3):253&ndash;70.
<a href="https://doi.org/10.1016/S0167-9473%2898%2900096-6">doi:10.1016/S0167-9473(98)00096-6</a>
</p>
<p>Mandrekar JN, Mandrekar, SJ, Cha SS, 2003.
Cutpoint Determination Methods in Survival Analysis using SAS.
<em>Proceedings of the 28th SAS Users Group International Conference (SUGI)</em>. Paper 261-28.
<a href="https://support.sas.com/resources/papers/proceedings/proceedings/sugi28/261-28.pdf">SAS (free)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Mandrekar et al. above
data("bmt", package="KMsurv")
b1 &lt;- bmt[bmt$group==1, ] # ALL patients
c1 &lt;- coxph(Surv(t2, d3) ~ z1, data=b1) # z1=age
c1 &lt;- cutp(c1)$z1
data.table::setorder(c1, "z1")
## [] below is used to print data.table to console
c1[]

## Not run: 
## compare to output from survival::coxph
matrix(
    unlist(
        lapply(26:30,
               function(i) c(i, summary(coxph(Surv(t2, d3) ~ z1 &gt;= i, data=b1))$sctest))),
    ncol=5,
    dimnames=list(c("age", "score_test", "df", "p")))
cutp(coxph(Surv(t2, d3) ~ z1, data=bmt[bmt$group==2, ]))$z1[]
cutp(coxph(Surv(t2, d3) ~ z1, data=bmt[bmt$group==3, ]))[[1]][]
## K&amp;M. Example 8.3, pg 273-274.
data("kidtran", package="KMsurv")
k1 &lt;- kidtran
## patients who are male and black
k2 &lt;- k1[k1$gender==1 &amp; k1$race==2, ]
c2 &lt;- coxph(Surv(time, delta) ~ age, data=k2)
print(cutp(c2))
## check significance of computed value
summary(coxph(Surv(time, delta) ~ age &gt;= 58, data=k2))
k3 &lt;- k1[k1$gender==2 &amp; k1$race==2, ]
c3 &lt;- coxph(Surv(time, delta) ~ age, data=k3)
print(cutp(c3))
## doesn't apply to binary variables e.g. gender
print(cutp(coxph(Surv(time, delta) ~ age + gender, data=k1)))

## End(Not run)

</code></pre>

<hr>
<h2 id='gastric'>gastric cancer trial data</h2><span id='topic+gastric'></span>

<h3>Description</h3>

<p>gastric cancer trial data
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> with <code class="reqn">90</code> rows (observations) and <code class="reqn">3</code> columns (variables).
</p>


<h3>Details</h3>

<p>Data from a trial of locally unresectable gastic cancer.
<br />
Patients (<code class="reqn">n=45</code> in each group) were randomized to one of two groups:
chemotheapy vs. chemotherapy + radiotherapy.
<br />
Columns are:
</p>

<dl>
<dt>time</dt><dd><p>Time, in days</p>
</dd>
<dt>event</dt><dd><p>Death</p>
</dd>
<dt>group</dt><dd><p>Treatment 
</p>

<dl>
<dt>0</dt><dd><p>chemotherapy</p>
</dd>
<dt>1</dt><dd><p>chemotherapy + radiotherapy</p>
</dd>
</dl>

</dd>
</dl>



<h3>Source</h3>

<p>Klein J, Moeschberger. Survival Analysis, 2nd edition. Springer 2003.
Example 7.9, pg 224.
</p>


<h3>References</h3>

<p>Gastrointestinal Tumor Study Group, 1982.
A comparison of combination chemotherapy and
combined modality therapy for locally advanced gastric carcinoma.
<em>Cancer</em>. <b>49</b>(9):1771-7. <br />
&lsquo;<span class="samp">&#8288;dx.doi.org/10.1002/1097-0142(19820501)49:9&lt;1771::AID-CNCR2820490907&gt;3.0.CO;2-M&#8288;</span>&rsquo; Wiley (free)
</p>
<p>Stablein DM, Koutrouvelis IA, 1985.
A two-sample test sensitive to crossing hazards in uncensored and singly censored data.
<em>Biometrics</em>. <b>41</b>(3):643-52. <br />
&lsquo;<span class="samp">&#8288;dx.doi.org/10.2307/2531284&#8288;</span>&rsquo; JSTOR
</p>


<h3>See Also</h3>

<p>Examples in <code><a href="#topic+comp">comp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("gastric", package="survMisc", verbose=TRUE)
head(gastric)

</code></pre>

<hr>
<h2 id='gof'><b>g</b>oodness <b>o</b>f <b>f</b>it test for a <code>coxph</code> object</h2><span id='topic+gof'></span><span id='topic+gof.coxph'></span>

<h3>Description</h3>

<p><b>g</b>oodness <b>o</b>f <b>f</b>it test for a <code>coxph</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(x, ...)

## S3 method for class 'coxph'
gof(x, ..., G = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_x">x</code></td>
<td>
<p>An object of class <code>coxph</code></p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented)</p>
</td></tr>
<tr><td><code id="gof_+3A_g">G</code></td>
<td>
<p>Number of <b>g</b>roups into which to divide risk score.
If <code>G=NULL</code> (the default), uses closest integer to
</p>
<p style="text-align: center;"><code class="reqn">G = \max(2, \quad \min(10, \quad \frac{ne}{40}))</code>
</p>

<p>where <code class="reqn">ne</code> is the number of events overall.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to verify the overall goodness of fit,
the risk score <code class="reqn">r_i</code> for each observation <code class="reqn">i</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">r_i = \hat{\beta} X_i</code>
</p>

<p>where <code class="reqn">\hat{\beta}</code> is the vector of fitted coefficients
and <code class="reqn">X_i</code> is the vector of predictor variables for
observation <code class="reqn">i</code>.
<br />
This risk score is then sorted and 'lumped' into
a grouping variable with <code class="reqn">G</code> groups,
(containing approximately equal numbers of observations).
<br />
The number of observed (<code class="reqn">e</code>) and expected (<code class="reqn">exp</code>) events in
each group are used to generate a <code class="reqn">Z</code> statistic for each group,
which is assumed to follow a normal distribution with
<code class="reqn">Z \sim N(0,1)</code>.
<br />
The indicator variable <code>indicG</code> is added to the
original model and the two models are compared to determine the
improvement in fit via the likelihood ratio test.
</p>


<h3>Value</h3>

<p>A <code>list</code> with elements:
</p>
<table>
<tr><td><code>groups</code></td>
<td>
<p>A <code>data.table</code> with one row per group <code class="reqn">G</code>.
The columns are </p>

<dl>
<dt>n</dt><dd><p>Number of observations</p>
</dd>
<dt>e</dt><dd><p>Number of events</p>
</dd>
<dt>exp</dt><dd><p>Number of events expected. This is
</p>
<p style="text-align: center;"><code class="reqn">exp = \sum e_i - M_i</code>
</p>

<p>where <code class="reqn">e_i</code> are the events and
<code class="reqn">M_i</code> are the martingale residuals
for each observation <code class="reqn">i</code></p>
</dd>
<dt>z</dt><dd><p><code class="reqn">Z</code> score, calculated as
</p>
<p style="text-align: center;"><code class="reqn"> Z = \frac{e - exp}{\sqrt{exp}}</code>
</p>

</dd>
<dt>p</dt><dd><p><code class="reqn">p</code>-value for <code class="reqn">Z</code>, which is
</p>
<p style="text-align: center;"><code class="reqn"> p = 2. \code{pnorm}(-|z|)</code>
</p>

<p>where <code>pnorm</code> is the normal distribution function
with mean <code class="reqn">\mu =0</code> and standard deviation <code class="reqn">\sigma =1</code>
and <code class="reqn">|z|</code> is the absolute value.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>lrTest</code></td>
<td>
<p>Likelihood-ratio test.
Tests the improvement in log-likelihood with addition
of an indicator variable with <code class="reqn">G-1</code> groups.
This is done with <code>survival:::anova.coxph</code>.
The test is distributed as chi-square with <code class="reqn">G-1</code> degrees of freedom</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The choice of <code class="reqn">G</code> is somewhat arbitrary but rarely should
be <code class="reqn">&gt; 10</code>.
<br />
As illustrated in the example, a larger value for
<code class="reqn">G</code> makes the <code class="reqn">Z</code> test for each group more likely to be significant.
This does <em>not</em> affect the significance of adding the
indicator variable <code>indicG</code> to the original model.
<br /> <br />
The <code class="reqn">Z</code> score is chosen for simplicity, as for large sample sizes
the Poisson distribution approaches the normal. Strictly speaking,
the Poisson would be more appropriate for <code class="reqn">e</code> and <code class="reqn">exp</code> as
per Counting Theory.
<br />
The <code class="reqn">Z</code> score may be somewhat conservative as the expected events
are calculated using the martingale residuals from the overall model,
rather than by group. This is likely to bring the expected events
closer to the observed events.
<br /> <br />
This test is similar to the Hosmer-Lemeshow test for logistic regression.
</p>


<h3>Source</h3>

<p>Method and example are from: <br />
May S, Hosmer DW 1998.
A simplified method of calculating an overall goodness-of-fit test
for the Cox proportional hazards model.
<em>Lifetime Data Analysis</em> <b>4</b>(2):109&ndash;20.
<a href="https://doi.org/10.1023/A%3A1009612305785">doi:10.1023/A:1009612305785</a>
</p>


<h3>References</h3>

<p>Default value for <code class="reqn">G</code> as per: <br />
May S, Hosmer DW 2004.
A cautionary note on the use of the Gronnesby and Borgan
goodness-of-fit test for the Cox proportional hazards model.
<em>Lifetime Data Analysis</em> <b>10</b>(3):283&ndash;91.
<a href="https://doi.org/10.1023/B%3ALIDA.0000036393.29224.1d">doi:10.1023/B:LIDA.0000036393.29224.1d</a>
</p>
<p>Changes to the <code>pbc</code> dataset in the example are as detailed in: <br />
Fleming T, Harrington D 2005.
<em>Counting Processes and Survival Analysis</em>.
New Jersey: Wiley and Sons. Chapter 4, section 4.6, pp 188.
<a href="https://doi.org/10.1002/9781118150672">doi:10.1002/9781118150672</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbc", package="survival")
pbc &lt;- pbc[!is.na(pbc$trt), ]
## make corrections as per Fleming
pbc[pbc$id==253, "age"] &lt;-  54.4
pbc[pbc$id==107, "protime"] &lt;-  10.7
### misspecified; should be log(bili) and log(protime) instead
c1 &lt;- coxph(Surv(time, status==2) ~
            age + log(albumin) + bili + edema + protime,
            data=pbc)
gof(c1, G=10)
gof(c1)

</code></pre>

<hr>
<h2 id='nc'>Add <b>n</b>umber <b>c</b>ensored.</h2><span id='topic+nc'></span><span id='topic+nc.ten'></span><span id='topic+nc.stratTen'></span>

<h3>Description</h3>

<p>Add <b>n</b>umber <b>c</b>ensored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc(x, ...)

## S3 method for class 'ten'
nc(x, ...)

## S3 method for class 'stratTen'
nc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_+3A_x">x</code></td>
<td>
<p>An object of class <code>ten</code> or <code>stratTen</code>.</p>
</td></tr>
<tr><td><code id="nc_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original object, with new column(s) added indicating the 
number censored at each time point, depending on <code>attr(x, "shape")</code>: 
</p>
<table>
<tr><td><code>"long"</code></td>
<td>
<p>the new column, <code>c</code>, gives
the number censored at each timepoint, by covariate group.</p>
</td></tr>
<tr><td><code>"wide"</code></td>
<td>
<p>new columns, beginning with <code>c_</code>, give
the number censored at each timepoint, by covariate group. 
There is an additional <code>nc</code> column giving 
the <em>total</em> number censored at each timepoint.</p>
</td></tr>
</table>
<p>A <code>stratTen</code> object has each <code>ten</code> element in the 
<code>list</code> modified as above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("kidney", package="KMsurv")
t1 &lt;- ten(survfit(Surv(time, delta) ~ type, data=kidney))
nc(t1)
nc(asWide(t1))

## stratified model
data("pbc", package="survival")
t1 &lt;- ten(coxph(Surv(time, status==2) ~ log(bili) + age + strata(edema), data=pbc))
nc(t1)

</code></pre>

<hr>
<h2 id='predict'>predicted events</h2><span id='topic+predict'></span><span id='topic+predict.ten'></span>

<h3>Description</h3>

<p>predicted events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ten'
predict(object, ..., eMP = TRUE, reCalc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>An object of class <code>ten</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="predict_+3A_emp">eMP</code></td>
<td>
<p>Add column(s) indicating
<b>e</b>vents <b>m</b>inus <b>p</b>redicted.</p>
</td></tr>
<tr><td><code id="predict_+3A_recalc">reCalc</code></td>
<td>
<p>Recalcuate the values?
<br />
If <code>reCalc=FALSE</code> (the default) and the <code>ten</code> object already has
the calculated values stored as an <code>attribute</code>,
the value of the <code>attribute</code> is returned directly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code class="reqn">K</code> covariate groups, We use <code class="reqn">ncg_{ik}</code>,
the number at risk for group <code class="reqn">k</code>,
to calculate the number of expected events:
</p>
<p style="text-align: center;"><code class="reqn">P_{ik} = \frac{e_i(ncg_{ik})}{n_i} \quad k=1, 2 \ldots K</code>
</p>



<h3>Value</h3>

<p>An <code>attribute</code>, <code>pred</code> is added
to <code>object</code>:
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p>Times with at least one observation</p>
</td></tr>
<tr><td><code>P_</code></td>
<td>
<p><b>p</b>redicted number of events</p>
</td></tr>
</table>
<p>And if <code>eMP==TRUE</code> (the default):
</p>
<table>
<tr><td><code>eMP_</code></td>
<td>
<p><b>e</b>vents <b>m</b>inus <b>p</b>redicted</p>
</td></tr>
</table>
<p>The names of the <code>object</code>'s covariate groups are
used to make the suffixes of the column names (i.e. after the
<code>_</code> character).
</p>


<h3>Note</h3>

<p>There is a predicted value for each unique time, for each covariate group.
</p>


<h3>See Also</h3>

<p>?survival::predict.coxph
methods(&quot;predict&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## K&amp;M. Example 7.2, Table 7.2, pp 209-210.
data("kidney", package="KMsurv")
k1 &lt;- ten(Surv(time=time, event=delta) ~ type, data=kidney)
predict(k1)
predict(asWide(k1))
stopifnot(predict(asWide(k1))[, sum(eMP_1 + eMP_2)] &lt;=
          .Machine$double.neg.eps)
## Three covariate groups
## K&amp;M. Example 7.4, pp 212-214.
data("bmt", package="KMsurv")
b1 &lt;- ten(Surv(time=t2, event=d3) ~ group, data=bmt)
predict(b1)
## one group only
predict(ten(Surv(time=t2, event=d3) ~ 1, data=bmt))

</code></pre>

<hr>
<h2 id='print'><code>print</code> methods</h2><span id='topic+print'></span><span id='topic+print.ten'></span><span id='topic+print.COV'></span><span id='topic+print.lrt'></span><span id='topic+print.sup'></span><span id='topic+print.tableAndPlot'></span><span id='topic+print.stratTableAndPlot'></span>

<h3>Description</h3>

<p><code>print</code> methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ten'
print(
  x,
  ...,
  maxRow = getOption("datatable.print.nrows", 50L),
  nRowP = getOption("datatable.print.topn", 5L),
  pRowNames = TRUE,
  maxCol = getOption("survMisc.maxCol", 8L),
  nColSP = getOption("survMisc.nColSP", 7L),
  sigDig = getOption("survMisc.sigDig", 2L)
)

## S3 method for class 'COV'
print(x, ..., n = 2L)

## S3 method for class 'lrt'
print(x, ..., dist = c("n", "c"))

## S3 method for class 'sup'
print(x, ...)

## S3 method for class 'tableAndPlot'
print(x, ..., hideTabLeg = TRUE, tabHeight = 0.25)

## S3 method for class 'stratTableAndPlot'
print(x, ..., hideTabLeg = TRUE, tabHeight = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>An object of class <code>ten</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).
<br /> <br />
<b>&ndash;print.ten</b></p>
</td></tr>
<tr><td><code id="print_+3A_maxrow">maxRow</code></td>
<td>
<p>Maximum number of rows to print.
<br />
If <code>nrow(x) &gt; maxRow</code>, just the first and last
<code>nRowP</code> (below) are printed.
<br />
The default value is that used by <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_nrowp">nRowP</code></td>
<td>
<p><b>N</b>umber of rows to <b>p</b>rint from
the start and end of the object. Used if <code>nrow(x) &gt; maxRow</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_prownames">pRowNames</code></td>
<td>
<p>Print row names? 
<br />
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_maxcol">maxCol</code></td>
<td>
<p>Maximum number of columns to print.
<br />
If <code>ncol(x) &gt; maxCol</code>, just the first <code>nColSP</code>
and last <code>maxCol - nColSP</code> columns are printed.</p>
</td></tr>
<tr><td><code id="print_+3A_ncolsp">nColSP</code></td>
<td>
<p><b>N</b>umber of <b>col</b>umns to <b>p</b>rint from
the <b>s</b>tart of the object. Used if Used if <code>ncol(x) &gt; maxCol</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_sigdig">sigDig</code></td>
<td>
<p><b>Sig</b>nificant <b>dig</b>its. This is passed as an argument to
<br />
?signif
<br />
when preparing the object for printing.
<br /> <br />
<b>&ndash;print.tableAndPlot</b> and <b>print.tableAndPlot</b></p>
</td></tr>
<tr><td><code id="print_+3A_n">n</code></td>
<td>
<p>Similar to <code>n</code> from e.g. 
<br />
?utils::head
<br /> <br />
<b>&ndash;print.lrt</b></p>
</td></tr>
<tr><td><code id="print_+3A_dist">dist</code></td>
<td>
<p>Which distribution to use for the statistics
when printing.
<br />
Default (<code>dist="n"</code>) prints <code class="reqn">Z</code> and <code class="reqn">p</code> values
based on the normal distribution. 
<br />
If <code>dist="c"</code>, gives values based on the 
<code class="reqn">\chi^2</code> distribution. 
<br />
The results are the same. The default value is typically 
easier to read. Both options are given for completeness.</p>
</td></tr>
<tr><td><code id="print_+3A_hidetableg">hideTabLeg</code></td>
<td>
<p>Hide table legend.</p>
</td></tr>
<tr><td><code id="print_+3A_tabheight">tabHeight</code></td>
<td>
<p>Table height (relative to whole plot).
<br /> <br />
<b>&ndash;print.COV</b></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints a <code>ten</code> object with 'nice' formatting.
<br />
Options may be set for a session using e.g.
<br />
options(survMisc.nColSP=4L)
<br />
It is similar to the behavior of <code>print.data.table</code> but
has additional arguments controlling the number of columns
sent to the terminal.
</p>


<h3>Value</h3>

<p>A printed representation of the object
is send to the terminal as a <em>side effect</em> of
calling the function.
<br />
The return value cannot be <code>assign</code>ed.
</p>


<h3>Note</h3>

<p>All numeric arguments to the function must be supplied as integers.
</p>


<h3>Author(s)</h3>

<p>Chris Dardis. Based on existing work by Brian Diggs.
</p>


<h3>See Also</h3>

<p>For <code>print.ten</code>:
</p>
<p>data.table:::print.data.table
</p>
<p>?stats::printCoefmat
</p>
<p>options()$datatable.print.nrows
</p>
<p>sapply(c(&quot;datatable.print.nrows&quot;, &quot;datatable.print.topn&quot;), getOption)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
(x &lt;- data.table::data.table(matrix(rnorm(1800), ncol=15, nrow=120)))
data.table::setattr(x, "class", c("ten", class(x)))
p1 &lt;- print(x)
stopifnot(is.null(p1))
x[1:80, ]
x[0, ]
(data.table::set(x, j=seq.int(ncol(x)), value=NULL))

</code></pre>

<hr>
<h2 id='profLik'>Profile likelihood for coefficients in a <code>coxph</code> model</h2><span id='topic+profLik'></span>

<h3>Description</h3>

<p>Profile likelihood for coefficients in a <code>coxph</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profLik(x, CI = 0.95, interval = 50, mult = c(0.1, 2), devNew = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profLik_+3A_x">x</code></td>
<td>
<p>A <code>coxph</code> model.</p>
</td></tr>
<tr><td><code id="profLik_+3A_ci">CI</code></td>
<td>
<p><b>C</b>onfidence <b>I</b>nterval.</p>
</td></tr>
<tr><td><code id="profLik_+3A_interval">interval</code></td>
<td>
<p>Number of points over which to evaluate coefficient.</p>
</td></tr>
<tr><td><code id="profLik_+3A_mult">mult</code></td>
<td>
<p><b>Mult</b>iplier. Coefficent will be multiplied by lower and upper
value and evaluated across this range.</p>
</td></tr>
<tr><td><code id="profLik_+3A_devnew">devNew</code></td>
<td>
<p>Open a new device for each plot. See 
<br />
?grDevices::dev.new</p>
</td></tr>
<tr><td><code id="profLik_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>graphics::plot.default</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots of range of values for coefficient in model with log-likelihoods
for the model with the coefficient fixed at these values.
<br /> <br />
For each coefficient a range of possible values is chosen, given by
<code class="reqn">\hat{B}*mult_{lower} - \hat{B}*mult_{upper}</code>.
A series of models are fit (given by <code>interval</code>).
The coefficient is included in the model as a
<em>fixed</em> term and the partial log-likelihood for the model is calculated.
<br /> <br />
A curve is plotted which gives the partial log-likelihood for each of these candidate values.
An appropriate confidence interval (CI) is given
by subtracting 1/2 the value of the appropriate quantile
of a chi-squared distribution with <code class="reqn">1</code> degree of freedom.
<br /> <br />
Two circles are also plotted giving the 95
</p>


<h3>Value</h3>

<p>One plot for each coefficient in the model.
</p>


<h3>References</h3>

<p>Example is from:
<b>T&amp;G</b>. 
Section 3.4.1, pg 57.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pbc", package="survival")
c1 &lt;- coxph(formula = Surv(time, status == 2) ~ age + edema + log(bili) +
                      log(albumin) + log(protime), data = pbc)
profLik(c1, col="red")

</code></pre>

<hr>
<h2 id='rsq'>r^2 measures for a a <code>coxph</code> or <code>survfit</code> model</h2><span id='topic+rsq'></span><span id='topic+rsq.coxph'></span><span id='topic+rsq.survfit'></span>

<h3>Description</h3>

<p>r^2 measures for a a <code>coxph</code> or <code>survfit</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsq(x, ...)

## S3 method for class 'coxph'
rsq(x, ..., sigD = 2)

## S3 method for class 'survfit'
rsq(x, ..., sigD = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsq_+3A_x">x</code></td>
<td>
<p>A <code>survfit</code> or <code>coxph</code> object.</p>
</td></tr>
<tr><td><code id="rsq_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="rsq_+3A_sigd">sigD</code></td>
<td>
<p><b>sig</b>nificant <b>d</b>igits (for ease of display).
If <code>sigD=NULL</code>, will return the original numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following elements:
</p>
<table>
<tr><td><code>cod</code></td>
<td>
<p>The <b>c</b>oefficient <b>o</b>f <b>d</b>etermination, which is
</p>
<p style="text-align: center;"><code class="reqn">R^2=1-\exp(\frac{2}{n}L_0-L_1)</code>
</p>

<p>where <code class="reqn">L_0</code> and <code class="reqn">L_1</code> are the log partial
likelihoods for the <em>null</em> and <em>full</em> models respectively
and <code class="reqn">n</code>
is the number of observations in the data set.</p>
</td></tr>
<tr><td><code>mer</code></td>
<td>
<p>The <b>m</b>easure of <b>e</b>xplained <b>r</b>andomness, which is:
</p>
<p style="text-align: center;"><code class="reqn">R^2_{mer}=1-\exp(\frac{2}{m}L_0-L_1)</code>
</p>

<p>where <code class="reqn">m</code> is the number of observed <em>events</em>.</p>
</td></tr>
<tr><td><code>mev</code></td>
<td>
<p>The <b>m</b>easure of <b>e</b>xplained <b>v</b>ariation (similar to
that for linear regression), which is:
</p>
<p style="text-align: center;"><code class="reqn">R^2=\frac{R^2_{mer}}{R^2_{mer} + \frac{\pi}{6}(1-R^2_{mer})}</code>
</p>

</td></tr>
</table>


<h3>References</h3>

<p>Nagelkerke NJD, 1991.
A Note on a General Definition of the Coefficient of Determination.
<em>Biometrika</em> <b>78</b>(3):691&ndash;92.
&lsquo;<span class="samp">&#8288;http://www.jstor.org/stable/2337038&#8288;</span>&rsquo; JSTOR
</p>
<p>O'Quigley J, Xu R, Stare J, 2005.
Explained randomness in proportional hazards models.
<em>Stat Med</em> <b>24</b>(3):479&ndash;89.
&lsquo;<span class="samp">&#8288;http://dx.doi.org/10.1002/sim.1946&#8288;</span>&rsquo; Wiley (paywall)
&lsquo;<span class="samp">&#8288;http://www.math.ucsd.edu/~rxu/igain2.pdf&#8288;</span>&rsquo; UCSD (free)
</p>
<p>Royston P, 2006.
Explained variation for survival models.
<em>The Stata Journal</em> <b>6</b>(1):83&ndash;96.
&lsquo;<span class="samp">&#8288;http://www.stata-journal.com/sjpdf.html?articlenum=st0098&#8288;</span>&rsquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("kidney", package="KMsurv")
c1 &lt;- coxph(Surv(time=time, event=delta) ~ type, data=kidney)
cbind(rsq(c1), rsq(c1, sigD=NULL))

</code></pre>

<hr>
<h2 id='sf'><b>s</b>urvival (or hazard) <b>f</b>unction
based on <code class="reqn">e</code> and <code class="reqn">n</code>.</h2><span id='topic+sf'></span><span id='topic+sf.default'></span><span id='topic+sf.ten'></span><span id='topic+sf.stratTen'></span><span id='topic+strat.Ten'></span><span id='topic+sf.numeric'></span>

<h3>Description</h3>

<p><b>s</b>urvival (or hazard) <b>f</b>unction
based on <code class="reqn">e</code> and <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf(x, ...)

## Default S3 method:
sf(x, ..., what = c("S", "H"), SCV = FALSE, times = NULL)

## S3 method for class 'ten'
sf(x, ..., what = c("S", "H"), SCV = FALSE, times = NULL, reCalc = FALSE)

## S3 method for class 'stratTen'
sf(x, ..., what = c("S", "H"), SCV = FALSE, times = NULL, reCalc = FALSE)

## S3 method for class 'numeric'
sf(
  x,
  ...,
  n = NULL,
  what = c("all", "S", "Sv", "H", "Hv"),
  SCV = FALSE,
  times = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_+3A_x">x</code></td>
<td>
<p>One of the following:
</p>

<dl>
<dt>default</dt><dd><p>A numeric vector of events status (assumed sorted by time).</p>
</dd>
<dt>numeric</dt><dd><p>Vectors of events and numbers at risk (assumed sorted by time).</p>
</dd>
<dt>ten</dt><dd><p>A <code>ten</code> object.</p>
</dd>
<dt>stratTen</dt><dd><p>A <code>stratTen</code> object.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sf_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="sf_+3A_what">what</code></td>
<td>
<p>See return, below.</p>
</td></tr>
<tr><td><code id="sf_+3A_scv">SCV</code></td>
<td>
<p>Include the <b>S</b>quared <b>C</b>oefficient of
<b>V</b>ariation, which is calcluated using
the mean <code class="reqn">\bar{x}</code> and
the variance <code class="reqn">\sigma_x^2</code>:
</p>
<p style="text-align: center;"><code class="reqn">SCV_x = \frac{\sigma_x^2}{\bar{x}^2}</code>
</p>

<p>This measure of <em>dispersion</em> is also referred to as
the 'standardized variance' or the 'noise'.</p>
</td></tr>
<tr><td><code id="sf_+3A_times">times</code></td>
<td>
<p>Times for which to calculate the function.
<br />
If <code>times=NULL</code> (the default), times are used for 
which at least one event occurred in at least one covariate group.</p>
</td></tr>
<tr><td><code id="sf_+3A_recalc">reCalc</code></td>
<td>
<p>Recalcuate the values?
<br />
If <code>reCalc=FALSE</code> (the default) and the <code>ten</code> object already has
the calculated values stored as an <code>attribute</code>,
the value of the <code>attribute</code> is returned directly.</p>
</td></tr>
<tr><td><code id="sf_+3A_n">n</code></td>
<td>
<p>Number at risk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table which is stored as an attribute of
the <code>ten</code> object. 
<br />
If <code>what="s"</code>, the <b>s</b>urvival is returned, based on the
Kaplan-Meier or product-limit estimator.
This is <code class="reqn">1</code> at <code class="reqn">t=0</code> and thereafter is given by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S}(t) = \prod_{t \leq t_i} (1-\frac{e_i}{n_i} )</code>
</p>

<p>If <code>what="sv"</code>, the <b>s</b>urvival <b>v</b>ariance is returned.
<br />
Greenwoods estimtor of the variance of the
Kaplan-Meier (product-limit) estimator is:
</p>
<p style="text-align: center;"><code class="reqn">Var[\hat{S}(t)] = [\hat{S}(t)]^2 \sum_{t_i \leq t}
                        \frac{e_i}{n_i (n_i - e_i)}</code>
</p>

<p>If <code>what="h"</code>, the <b>h</b>azard is returned,
based on the the Nelson-Aalen estimator.
This has a value of <code class="reqn">\hat{H}=0</code> at <code class="reqn">t=0</code>
and thereafter is given by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{H}(t) = \sum_{t \leq t_i} \frac{e_i}{n_i}</code>
</p>

<p>If <code>what="hv"</code>, the <b>h</b>azard <b>v</b>ariance is returned.
<br />
The variance of the Nelson-Aalen estimator is given by:
</p>
<p style="text-align: center;"><code class="reqn">Var[\hat{H}(t)] = \sum_{t_i \leq t} \frac{e_i}{n_i^2}</code>
</p>

<p>If <code>what="all"</code> (the default), <em>all</em> of the above
are returned in a <code>data.table</code>, along with:
<br />
Survival, based on the Nelson-Aalen hazard estimator <code class="reqn">H</code>, 
which is:
</p>
<p style="text-align: center;"><code class="reqn">\hat{S_{na}}=e^{H}</code>
</p>

<p>Hazard, based on the Kaplan-Meier survival estimator <code class="reqn">S</code>,
which is:
</p>
<p style="text-align: center;"><code class="reqn">\hat{H_{km}} = -\log{S}</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>data("kidney", package="KMsurv")
k1 &lt;- ten(Surv(time=time, event=delta) ~ type, data=kidney)
sf(k1)
sf(k1, times=1:10, reCalc=TRUE)
k2 &lt;- ten(with(kidney, Surv(time=time, event=delta)))
sf(k2)
## K&amp;M. Table 4.1A, pg 93.
## 6MP patients
data("drug6mp", package="KMsurv")
d1 &lt;- with(drug6mp, Surv(time=t2, event=relapse))
(d1 &lt;- ten(d1))
sf(x=d1$e, n=d1$n, what="S")

data("pbc", package="survival")
t1 &lt;- ten(Surv(time, status==2) ~ log(bili) + age + strata(edema), data=pbc)
sf(t1)

## K&amp;M. Table 4.2, pg 94.
data("bmt", package="KMsurv")
b1 &lt;- bmt[bmt$group==1, ] # ALL patients
t2 &lt;- ten(Surv(time=b1$t2, event=b1$d3))
with(t2, sf(x=e, n=n, what="Hv"))
## K&amp;M. Table 4.3, pg 97.
sf(x=t2$e, n=t2$n, what="all")

</code></pre>

<hr>
<h2 id='survMisc_package'>Miscellaneous Functions for Survival Analysis</h2><span id='topic+survMisc_package'></span><span id='topic+survMisc'></span>

<h3>Description</h3>

<p>Miscellaneous Functions for Survival Analysis
</p>

<table>
<tr>
 <td style="text-align: left;">
 Package: </td><td style="text-align: left;"> survMisc</td>
</tr>
<tr>
 <td style="text-align: left;">
 Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 0.5.5 </td>
</tr>
<tr>
 <td style="text-align: left;">
 Date: </td><td style="text-align: left;"> 2018-07-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes
</td>
</tr>

</table>

<p>A collection of functions for the analysis of survival data. These
extend the methods already available in <code>package:survival</code>.
<br />
The intent is to generate a workspace for some of the common tasks
arising in survival analysis.
<br /> <br />
There are references in many of the functions to the textbooks:
</p>

<table>
<tr>
 <td style="text-align: center;">
 <b>K&amp;M</b> </td><td style="text-align: left;"> Klein J, Moeschberger M (2003). 
                 <em>Survival Analysis</em>, 2nd edition. </td>
</tr>
<tr>
 <td style="text-align: center;">
            </td><td style="text-align: left;"> New York: Springer. 
                 <a href="https://doi.org/10.1007/b97377">doi:10.1007/b97377</a> </td>
</tr>
<tr>
 <td style="text-align: center;">
 <b>T&amp;G</b> </td><td style="text-align: left;"> Therneau TM, Grambsch PM (2000). 
                 <em>Modeling Survival Data: Extending the Cox Model</em>. </td>
</tr>
<tr>
 <td style="text-align: center;">
            </td><td style="text-align: left;"> New York: Springer. 
                 <a href="https://doi.org/10.1007/978-1-4757-3294-8">doi:10.1007/978-1-4757-3294-8</a>
</td>
</tr>

</table>



<h4>Notes for developers</h4>


<ul>
<li><p> This package should be regarded as 'in development' until
release 1.0, meaning that there may be changes to certain function
names and parameters, although I will try to keep this to a minimum.
As such it is recommended that other packages do <em>not</em> depend on or import from this
one until at least version 1.0.
</p>
</li>
<li><p> Naming tends to follow the <strong>camelCase</strong> convention; 
variables within functions are typically alphanumeric e.g. <code>a1 &lt;- 1</code>.
</p>
</li></ul>


<p>For bug reports, feature requests or suggestions for improvement,
please try to submit to <a href="https://github.com/dardisco/survMisc/issues">github</a>.
Otherwise email me at the address below.
</p>


<h3>Author(s)</h3>

<p>Chris Dardis <a href="mailto:christopherdardis@gmail.com">christopherdardis@gmail.com</a>
</p>

<hr>
<h2 id='ten'><b>t</b>ime, <b>e</b>vent(s) and <b>n</b>umber at risk.</h2><span id='topic+ten'></span><span id='topic+ten.numeric'></span><span id='topic+ten.Surv'></span><span id='topic+ten.coxph'></span><span id='topic+ten.survfit'></span><span id='topic+ten.formula'></span><span id='topic+ten.data.frame'></span><span id='topic+ten.data.table'></span><span id='topic+ten.ten'></span>

<h3>Description</h3>

<p><b>t</b>ime, <b>e</b>vent(s) and <b>n</b>umber at risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ten(x, ...)

## S3 method for class 'numeric'
ten(x, ...)

## S3 method for class 'Surv'
ten(x, ..., call = NULL)

## S3 method for class 'coxph'
ten(x, ..., abbNames = TRUE, contrasts.arg = NULL)

## S3 method for class 'survfit'
ten(x, ..., abbNames = TRUE, contrasts.arg = NULL)

## S3 method for class 'formula'
ten(x, ..., abbNames = TRUE, contrasts.arg = NULL)

## S3 method for class 'data.frame'
ten(x, ..., abbNames = TRUE, contrasts.arg = NULL, call = NULL)

## S3 method for class 'data.table'
ten(x, ..., abbNames = TRUE, mm = NULL, call = NULL)

## S3 method for class 'ten'
ten(x, ..., abbNames = NULL, call = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ten_+3A_x">x</code></td>
<td>
<p>For the default method, a <code>numeric</code> vector indicating an
<em>event</em> (or status).
<br />
Each element indicates whether an event occurred (<code>1</code>) or
not (<code>0</code>) for an observation.
<br />
These are assumed to be ordered by discrete times.
<br />
This is similar to the <code>event</code> argument for <code>Surv</code>
objects.
<br /> <br />
Methods are available for objects of class
<code>Surv</code>, <code>survfit</code>,
<code>coxph</code> and <code>formula</code>.</p>
</td></tr>
<tr><td><code id="ten_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
<tr><td><code id="ten_+3A_call">call</code></td>
<td>
<p>Used to pass the <code>call</code> from a <code>formula</code>
to the final <code>ten.data.table</code> method.</p>
</td></tr>
<tr><td><code id="ten_+3A_abbnames">abbNames</code></td>
<td>
<p><b>Abb</b>reviate names?
<br />
If <code>abbNames="TRUE"</code> (the default), 
the covariate groups are referred to by number. 
<br />
As the names for each covariate group are made by concatenating
the predictor names, the full names can become unwieldly.
<br />
If <code>abbNames="FALSE"</code>, the full names are given.
<br />
In either case, the <code>longNames</code> are given
as an <code>attribute</code> of the returned <code>ten</code> object.</p>
</td></tr>
<tr><td><code id="ten_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>Methods for handling factors.
<br />
A <code>list</code>. The <code>names</code> are the names of
columns of the <code>model.frame</code> containing
<code>factor</code>s.
<br />
The <em>values</em> are used as replacement
values for the <code>stats::contrasts</code> replacement function.
These should be functions (given as character strings)
or numeric matrices. 
<br />
This can be passed from
<code>survfit</code>, <code>coxph</code> and <code>formula</code> objects to:
<br />
?stats::model.matrix</p>
</td></tr>
<tr><td><code id="ten_+3A_mm">mm</code></td>
<td>
<p>Used to pass the <code>model.matrix</code> from a <code>formula</code>
to the final <code>ten.data.table</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with the additional <code>class</code>
<code>ten</code>. 
<br />
By default, the shape returned is 'long' i.e. there is one row for each unique 
timepoint per covariate group. 
<br />
The basic form, for a <code>numeric</code> or <code>Surv</code> object, has columns: 
</p>
<table>
<tr><td><code>t</code></td>
<td>
<p><b>t</b>ime.</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>number of <b>e</b>vents.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p><b>n</b>umber at risk.</p>
</td></tr>
</table>
<p>A <code>survfit</code>, <code>coxph</code> or <code>formula</code> object
will have additional columns:
</p>
<table>
<tr><td><code>cg</code></td>
<td>
<p><b>c</b>ovariate <b>g</b>roup.
This is formed by combining the variables; these
are separated by a comma ','.</p>
</td></tr>
<tr><td><code>ncg</code></td>
<td>
<p><b>n</b>umber at risk, by <b>c</b>ovariate <b>g</b>roup</p>
</td></tr>
</table>
<p><b>Special terms</b>.
<br /> <br />
The following are considered 'special'
terms in a survival model:
</p>
<table>
<tr><td><code>strata</code></td>
<td>
<p>For a stratified model, <code>ten</code> returns a <code>list</code> with
one element per strata, which is a <code>ten</code> object.
<br />
This has the class <code>stratTen</code>. The name of the 
list elements are those of the strata in the model.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>These terms are dropped.</p>
</td></tr>
<tr><td><code>tt</code></td>
<td>
<p>The variable is unchanged. That is, time-transform
terms are handled as if the the function
<code>tt(x)</code> was <code>identity(x)</code>.</p>
</td></tr>
</table>
<p><b>Attribures</b>.
<br />
The returned object will also have the following <code>attributes</code>:
</p>
<table>
<tr><td><code>shape</code></td>
<td>
<p>The default is <code>"long"</code> but 
is changed to <code>"wide"</code> when <code>asWide</code> is called on the object.</p>
</td></tr>
<tr><td><code>abbNames</code></td>
<td>
<p>Abbreviate names?</p>
</td></tr>
<tr><td><code>longNames</code></td>
<td>
<p>A <code>data.table</code> with two columns, showing the abbrevbiated 
and full names.</p>
</td></tr>
<tr><td><code>ncg</code></td>
<td>
<p>Number of covariate groups</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call used to generate the object</p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>The <code>model.matrix</code> used to generate to 
generate the object, if applicable.</p>
</td></tr>
</table>
<p>Additional attributes will be added by the following functions:
<br />
<code><a href="#topic+sf">sf</a></code>
<code><a href="#topic+ci">ci</a></code>
</p>


<h3>Note</h3>

<p>The methods for <code>data.frame</code> (for a model frame)
and <code>data.table</code> are not typically intended for interactive use.
<br /> <br />
Currently only binary status and right-censoring
are supported. 
<br /> <br />
In stratified models, only one level of stratification is supported
(i.e. strata cannot be 'nested' currently).
<br /> <br />
Partial matching is available for the
following arguments, based on the characters in bold:
</p>

<ul>
<li> <p><b>abb</b>Names
</p>
</li>
<li> <p><b>con</b>trasts.arg
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+asWide">asWide</a></code>
</p>
<p><code><a href="#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("survival")
## binary vector
ten(c(1, 0, 1, 0, 1))

## Surv object
df0 &lt;- data.frame(t=c(1, 1, 2, 3, 5, 8, 13, 21),
                  e=rep(c(0, 1), 4))
s1 &lt;- with(df0, Surv(t, e, type="right"))
ten(s1)
## some awkward values
suppressWarnings(
    s1 &lt;- Surv(time=c(Inf, -1, NaN, NA, 10, 12),
               event=c(c(NA, 1, 1, NaN, Inf, 0.75))))
ten(s1)

## coxph object
## K&amp;M. Section 1.2. Table 1.1, page 2.
data("hodg", package="KMsurv")
hodg &lt;- data.table::data.table(hodg)
data.table::setnames(hodg,
                     c(names(hodg)[!names(hodg) %in%
                                   c("score", "wtime")],
                       "Z1", "Z2"))
c1 &lt;- coxph(Surv(time=time, event=delta) ~ Z1 + Z2,
            data=hodg[gtype==1 &amp; dtype==1, ])
ten(c1)
data("bmt", package="KMsurv")
ten(c1 &lt;- coxph(Surv(t2, d3) ~ z3*z10, data=bmt))
## T&amp;G. Section 3.2, pg 47.
## stratified model
data("pbc", package="survival")
c1 &lt;- coxph(Surv(time, status==2) ~ log(bili) + age + strata(edema), data=pbc)
ten(c1)

## K&amp;M. Example 7.2, pg 210.
data("kidney", package="KMsurv")
with(kidney[kidney$type==2, ], ten(Surv(time=time, event=delta)))
s1 &lt;- survfit(Surv(time=time, event=delta) ~ type, data=kidney)
ten(s1)[e &gt; 0, ]

## A null model is passed to ten.Surv
(t1 &lt;- with(kidney, ten(Surv(time=time, event=delta) ~ 0)))
## but the original call is preserved
attr(t1, "call")
## survival::survfit doesn't accept interaction terms...
## Not run: 
    s1 &lt;- survfit(Surv(t2, d3) ~ z3*z10, data=bmt)
## End(Not run)
## but ten.formula does:
ten(Surv(time=t2, event=d3) ~ z3*z10, data=bmt)
## the same is true for the '.' (dot operator) in formulas
(t1 &lt;- ten(Surv(time=t2, event=d3) ~ ., data=bmt))
## impractical long names stored as an attribute
attr(t1, "longNames")

## not typically intended to be called directly
mf1 &lt;- stats::model.frame(Surv(time, status==2) ~ age + strata(edema) + strata(spiders), pbc, 
                          drop.unused.levels = TRUE)
ten(mf1)

</code></pre>

<hr>
<h2 id='xtable'><code>xtable</code> methods</h2><span id='topic+xtable'></span><span id='topic+xtable.table'></span><span id='topic+xtable.survfit'></span>

<h3>Description</h3>

<p><code>xtable</code> methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtable(
  x,
  caption = NULL,
  label = NULL,
  align = NULL,
  digits = NULL,
  display = NULL,
  ...
)

## S3 method for class 'table'
xtable(
  x,
  caption = paste0(paste(names(dimnames(x)), collapse = " $\\times$ "),
    "\\\\ chi-sq=", signif(suppressWarnings(stats::chisq.test(x)$p.value), digits)),
  label = NULL,
  align = c("l", rep("c", dim(x)[2])),
  digits = 2,
  display = NULL,
  ...
)

## S3 method for class 'survfit'
xtable(
  x,
  caption = paste0("Survival for ", deparse(x$call[[2]])),
  label = NULL,
  align = c("l", rep("c", 7)),
  digits = NULL,
  display = rep("fg", 8),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtable_+3A_x">x</code></td>
<td>
<p>An object with an xtable method.</p>
</td></tr>
<tr><td><code id="xtable_+3A_caption">caption</code></td>
<td>
<p>Caption.</p>
</td></tr>
<tr><td><code id="xtable_+3A_label">label</code></td>
<td>
<p>Label.</p>
</td></tr>
<tr><td><code id="xtable_+3A_align">align</code></td>
<td>
<p>Alignment of columns.</p>
</td></tr>
<tr><td><code id="xtable_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display.</p>
</td></tr>
<tr><td><code id="xtable_+3A_display">display</code></td>
<td>
<p>How to display - passed to <code>formatC</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_...">...</code></td>
<td>
<p>Additional arguments (not implemented).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>xtable</code>, suitable for use with/ parsing by LaTeX.
</p>


<h3>Note</h3>

<p><code>xtable.survfit</code> - this does <em>not</em> show the (restricted) mean survival, 
only the median with confidence intervals.
</p>


<h3>See Also</h3>

<p>? xtable
? xtable::print.xtable
methods(&quot;xtable&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("kidney", package="KMsurv")
xtable(with(kidney, table(delta, type)))

## K&amp;M. Example 7.2, pg 210.
xtable(survfit(Surv(time=time, event=delta) ~ type, data=kidney))


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
