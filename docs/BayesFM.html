<!DOCTYPE html><html><head><title>Help for package BayesFM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesFM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesFM'><p>BayesFM: Package for Bayesian Factor Modeling</p></a></li>
<li><a href='#befa'><p>Bayesian Exploratory Factor Analysis</p></a></li>
<li><a href='#plot.befa'><p>Plot object of class 'befa'</p></a></li>
<li><a href='#post.column.switch'><p>Perform column switchting on posterior MCMC sample</p></a></li>
<li><a href='#post.sign.switch'><p>Perform sign switchting on posterior MCMC sample</p></a></li>
<li><a href='#simul.dedic.facmod'><p>Generate synthetic data from a dedicated factor model</p></a></li>
<li><a href='#simul.nfac.prior'><p>Simulate prior distribution of number of latent factors</p></a></li>
<li><a href='#simul.R.prior'><p>Simulate prior distribution of factor correlation matrix</p></a></li>
<li><a href='#summary.befa'><p>Summarize 'befa' object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Inference for Factor Modeling</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of procedures to perform Bayesian analysis on a variety
    of factor models. Currently, it includes: "Bayesian Exploratory Factor 
    Analysis" (befa) from G. Conti, S. Frühwirth-Schnatter, J.J. Heckman, 
    R. Piatek (2014) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2014.06.008">doi:10.1016/j.jeconom.2014.06.008</a>&gt;, an approach to 
    dedicated factor analysis with stochastic search on the structure of the 
    factor loading matrix. The number of latent factors, as well as the 
    allocation of the manifest variables to the factors, are not fixed a priori 
    but determined during MCMC sampling.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 1.8.0), coda, ggplot2 (&ge; 2.1.0), gridExtra,
plyr (&ge; 1.8.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gfortran (&gt;= 4.6.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-09 07:16:09 UTC; remek</td>
</tr>
<tr>
<td>Author:</td>
<td>Rémi Piatek <a href="https://orcid.org/0000-0002-3474-1304"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rémi Piatek &lt;remi.piatek@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-13 21:50:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesFM'>BayesFM: Package for Bayesian Factor Modeling</h2><span id='topic+BayesFM-package'></span><span id='topic+BayesFM'></span>

<h3>Description</h3>

<p>The long-term goal of this package is to provide a collection of procedures
to perform Bayesian inference on a variety of factor models.
</p>


<h3>Details</h3>

<p>Currently, this package includes: Bayesian Exploratory Factor
Analysis (<code>befa</code>), as developed in Conti et al. (2014), an approach to
dedicated factor analysis with stochastic search on the structure of the
factor loading matrix. The number of latent factors, as well as the
allocation of the observed variables to the factors, are not fixed a priori
but determined during MCMC sampling. More approaches will be included in
future releases of this package.
</p>


<h3>Note</h3>

<p>You are very welcome to send me any comments or suggestions for 
improvements, and to share with me any problems you may encounter with the 
use of this package.
</p>


<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>References</h3>

<p>G. Conti, S. Frühwirth-Schnatter, J.J. Heckman, R. Piatek (2014):
&ldquo;Bayesian Exploratory Factor Analysis&rdquo;, <em>Journal of Econometrics</em>,
183(1), pages 31-57, <a href="https://doi.org/10.1016/j.jeconom.2014.06.008">doi:10.1016/j.jeconom.2014.06.008</a>.
</p>

<hr>
<h2 id='befa'>Bayesian Exploratory Factor Analysis</h2><span id='topic+befa'></span>

<h3>Description</h3>

<p>This function implements the Bayesian Exploratory Factor Analysis
(<code>befa</code>) approach developed in Conti et al. (CFSHP, 2014). It runs a
MCMC sampler for a factor model with dedicated factors, where each manifest
variable is allowed to load on at most one latent factor. The allocation of
the manifest variables to the latent factors is not fixed <em>a priori</em> but
determined stochastically during sampling. The minimum number of variables
dedicated to each factor can be controlled by the user to achieve the desired
level of identification. The manifest variables can be continuous or
dichotomous, and control variables can be introduced as covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>befa(model, data, burnin = 1000, iter = 10000, Nid = 3, Kmax, A0 = 10,
  B0 = 10, c0 = 2, C0 = 1, HW.prior = TRUE, nu0 = Kmax + 1, S0 = 1,
  kappa0 = 2, xi0 = 1, kappa = 1/Kmax, indp.tau0 = TRUE,
  rnd.step = TRUE, n.step = 5, search.delay = min(burnin, 10),
  R.delay = min(burnin, 100), dedic.start, alpha.start, sigma.start,
  beta.start, R.start, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="befa_+3A_model">model</code></td>
<td>
<p>This argument specifies the manifest variables and the covariates used
in the model (if any). It can be specified in two different ways:
</p>

<ul>
<li><p> A numeric matrix or a data frame containing the manifest
variables. This corresponds to a model without covariates,
and the argument <code>data</code> is not required.
</p>
</li>
<li><p> A list of model formulas. Each element of the list specifies
a manifest variable and its corresponding control variables (e.g.,
'<code>Y1 ~ X1 + X2</code>' to use <code>X1</code> and <code>X2</code> as control
variables for <code>Y1</code>).
If a formula has no left-hand side variable, covariates on the
right-hand side are included in all equations (e.g., '<code>~ X3</code>'
means that <code>X3</code> is used as a control variable for all the
manifest variables). Argument <code>data</code> can be passed to the
function in that case, otherwise parent data frame is used.
</p>
</li></ul>

<p>Binary manifest variables should be specified as logical vectors in
the data frame to be treated as dichotomous. <code>NA</code> values are
accepted in manifest variables only.</p>
</td></tr>
<tr><td><code id="befa_+3A_data">data</code></td>
<td>
<p>Data frame. If missing, parent data frame if used.</p>
</td></tr>
<tr><td><code id="befa_+3A_burnin">burnin</code></td>
<td>
<p>Burn-in period of the MCMC sampler.</p>
</td></tr>
<tr><td><code id="befa_+3A_iter">iter</code></td>
<td>
<p>Number of MCMC iterations saved for posterior inference (after
burn-in).</p>
</td></tr>
<tr><td><code id="befa_+3A_nid">Nid</code></td>
<td>
<p>Minimum number of manifest variables dedicated to each latent factor
for identification.</p>
</td></tr>
<tr><td><code id="befa_+3A_kmax">Kmax</code></td>
<td>
<p>Maximum number of latent factors. If missing, the maximum number of
factors that satisfies the identification condition determined by
<code>Nid</code> and the Ledermann bound is specified (see CFSHP,
section 2.2).</p>
</td></tr>
<tr><td><code id="befa_+3A_a0">A0</code></td>
<td>
<p>Scaling parameters of the variance of the Normal prior on the nonzero
factor loadings. Either a scalar or a numeric vector of length equal
to the number of manifest variables.</p>
</td></tr>
<tr><td><code id="befa_+3A_b0">B0</code></td>
<td>
<p>Variances of the Normal prior on the regression coefficients. Either a
scalar or a numeric vector of length equal to the number of
manifest variables.</p>
</td></tr>
<tr><td><code id="befa_+3A_c0">c0</code></td>
<td>
<p>Shape parameters of the Inverse-Gamma prior on the idiosyncratic
variances. Either a scalar or a numeric vector of length equal to the
number of manifest variables.</p>
</td></tr>
<tr><td><code id="befa_+3A_c0">C0</code></td>
<td>
<p>Scale parameters of the Inverse-Gamma prior on the idiosyncratic
variances. Either a scalar or a numeric vector of length equal to the
number of manifest variables.</p>
</td></tr>
<tr><td><code id="befa_+3A_hw.prior">HW.prior</code></td>
<td>
<p>If <code>TRUE</code>, implement Huang-Wand (2013) prior on the covariance
matrix of the factors in the expanded model, otherwise use an
Inverse-Wishart prior if <code>FALSE</code>, see CFSHP section 2.3.5.</p>
</td></tr>
<tr><td><code id="befa_+3A_nu0">nu0</code></td>
<td>
<p>Degrees of freedom of the Inverse-Wishart prior on the covariance
matrix of the latent factors in the expanded model.</p>
</td></tr>
<tr><td><code id="befa_+3A_s0">S0</code></td>
<td>
<p>Scale parameters of the Inverse-Wishart prior on the covariance matrix
of latent factors in the expanded model:
</p>

<ul>
<li><p> if <code>HW.prior = TRUE</code>, scale parameter of the Gamma
hyperprior distribution on the individual scales of the
Inverse-Wishart prior.
</p>
</li>
<li><p> if <code>HW.prior = FALSE</code>, diagonal elements of the scale
matrix of the Inverse-Wishart prior on the covariance matrix of
the latent factors in the expanded model.
</p>
</li></ul>

<p>Either a scalar or a numeric vector of length equal to <code>Kmax</code>.</p>
</td></tr>
<tr><td><code id="befa_+3A_kappa0">kappa0</code></td>
<td>
<p>First shape parameter of the Beta prior distribution on the
probability <code class="reqn">\tau_0</code> that a manifest variable does not load on any
factor.</p>
</td></tr>
<tr><td><code id="befa_+3A_xi0">xi0</code></td>
<td>
<p>Second shape parameter of the Beta prior distribution on the
probability <code class="reqn">\tau_0</code> that a manifest variable does not load on any
factor.</p>
</td></tr>
<tr><td><code id="befa_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameters of the Dirichlet prior distribution on the
indicators. Either a scalar or a numeric vector of length equal to
<code>Kmax</code>.</p>
</td></tr>
<tr><td><code id="befa_+3A_indp.tau0">indp.tau0</code></td>
<td>
<p>If <code>TRUE</code>, specify the alternative prior specification with
independent parameters <code class="reqn">\tau_{0m}</code> across manifest
variables <code class="reqn">m = 1, ..., M</code>, otherwise use a common parameter
<code class="reqn">\tau_0</code> if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="befa_+3A_rnd.step">rnd.step</code></td>
<td>
<p>If <code>TRUE</code>, select randomly the number of intermediate steps in
non-identified models at each MCMC iteration, otherwise use a fixed
number of steps if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="befa_+3A_n.step">n.step</code></td>
<td>
<p>Controls the number of intermediate steps in non-identified models:
</p>

<ul>
<li><p> if <code>rnd.step = TRUE</code>, average number of steps. The number
of steps is sampled at each MCMC iteration from
1+Poisson(<code>n.step</code>-1).
</p>
</li>
<li><p> if <code>rnd.step = FALSE</code>, fixed number of steps.
</p>
</li></ul>
</td></tr>
<tr><td><code id="befa_+3A_search.delay">search.delay</code></td>
<td>
<p>Number of MCMC iterations run with fixed indicator matrix (specified
in <code>dedic.start</code>) at beginning of MCMC sampling.</p>
</td></tr>
<tr><td><code id="befa_+3A_r.delay">R.delay</code></td>
<td>
<p>Number of MCMC iterations run with fixed correlation matrix (specified
in <code>dedic.start</code>) at beginning of MCMC sampling.</p>
</td></tr>
<tr><td><code id="befa_+3A_dedic.start">dedic.start</code></td>
<td>
<p>Starting values for the indicators. Vector of integers of length equal
to the number of manifest variables. Each element takes a value among
0, 1, ..., <code>Kmax</code>. If missing, random allocation of the manifest
variables to the maximum number of factors <code>Kmax</code>, with a minimum
of <code>Nid</code> manifest variables loading on each factor.</p>
</td></tr>
<tr><td><code id="befa_+3A_alpha.start">alpha.start</code></td>
<td>
<p>Starting values for the factor loadings. Numeric vector of length
equal to the number of manifest variables. If missing, sampled from a
Normal distribution with zero mean and variance <code>A0</code>.</p>
</td></tr>
<tr><td><code id="befa_+3A_sigma.start">sigma.start</code></td>
<td>
<p>Starting values for the idiosyncratic variances. Numeric vector of
length equal to the number of manifest variables. Sampled from prior
if missing.</p>
</td></tr>
<tr><td><code id="befa_+3A_beta.start">beta.start</code></td>
<td>
<p>Starting values for the regression coefficients. Numeric vector of
length equal to the total number of regression coefficients,
concatenated for all the manifest variables. Sampled from prior if
missing.</p>
</td></tr>
<tr><td><code id="befa_+3A_r.start">R.start</code></td>
<td>
<p>Starting values for the correlation matrix of the latent factors.
Numeric matrix with <code>Kmax</code> rows and columns, and unit diagonal
elements. If missing, identity matrix is used.</p>
</td></tr>
<tr><td><code id="befa_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, display information on the progress of the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Model specification.</strong> The model is specified as follows, for
each observation <code class="reqn">i = 1, ..., N</code>:
</p>
<p style="text-align: center;"><code class="reqn">Y^*_i = \beta X_i + \alpha \theta_i + \epsilon_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_i \sim \mathcal{N}(0, R)</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_i \sim \mathcal{N}(0, \Sigma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\Sigma = diag(\sigma^2_1, ..., \sigma^2_M)</code>
</p>

<p>where <code class="reqn">Y^*_i</code> is the <code class="reqn">M</code>-vector containing the latent
variables underlying the corresponding <code class="reqn">M</code> manifest variables
<code class="reqn">Y_i</code>, which can be continuous such that
<code class="reqn">Y_{im} = Y^*_{im}</code>, or binary with
<code class="reqn">Y_{im} = 1[Y^*_{im} &gt; 0]</code>, for <code class="reqn">m = 1, ..., M</code>.
The <code class="reqn">K</code>-vector <code class="reqn">\theta_i</code> contains the latent factors, and
<code class="reqn">\alpha</code> is the <code class="reqn">(M \times K)</code>-matrix of factor loadings.
The <code class="reqn">M</code>-vector <code class="reqn">\epsilon_i</code> is the vector of error terms.
Covariates can be included in the <code class="reqn">Q</code>-vector <code class="reqn">X_i</code> and are related to
the manifest variables through the <code class="reqn">(M \times Q)</code>-matrix of
regression coefficients <code class="reqn">\beta</code>. Intercept terms are automatically
included, but can be omitted in some or all equations using the usual syntax
for R formulae (e.g., 'Y1 ~ X1 - 1' specifies that that Y1 is regressed on X1
and no intercept is included in the corresponding equation).
</p>
<p>The number of latent factors <code class="reqn">K</code> is specified as <code>Kmax</code>. However,
during MCMC sampling the stochastic search process on the matrix <code class="reqn">\alpha</code>
may produce zero columns, thereby reducing the number of active factors.
</p>
<p>The covariance matrix <code class="reqn">R</code> of the latent factors is assumed to be a
correlation matrix for identification.
</p>
<p>Each row of the factor loading matrix <code class="reqn">\alpha</code> contains at most one
nonzero element (dedicated factor model). The allocation of the manifest
variables to the latent factors is indicated by the binary matrix
<code class="reqn">\Delta</code> with same dimensions as <code class="reqn">\alpha</code>, such that each row
<code class="reqn">\Delta_m</code> indicates which factor loading is different from zero, e.g.:
</p>
<p style="text-align: center;"><code class="reqn">\Delta_m = (0, .., 0, 1, 0, ..., 0) \equiv e_k</code>
</p>

<p>indicates that variable <code class="reqn">m</code> loads on the <code class="reqn">k</code>th factor, where
<code class="reqn">e_k</code> is a <code class="reqn">K</code>-vector that contains only zeros, besides its <code class="reqn">k</code>th
element that equals 1.
</p>
<p><strong>Identification.</strong> The function verifies that the maximum number of
latent factors <code>Kmax</code> does not exceed the Ledermann bound. It also
checks that <code>Kmax</code> is consistent with the identification restriction
specified with <code>Nid</code> (enough variables should be available to load on
the factors when <code>Kmax</code> is reached). The default value for <code>Kmax</code>
is the minimum between the Ledermann bound and the maximum number of factors
that can be loaded by <code>Nid</code> variables. The user is free to select the
level of identification, see CFSHP section 2.2 (non-identified models are
allowed with <code>Nid = 1</code>).
</p>
<p>Note that identification is achieved only with respect to the scale of the
latent factors. Non-identifiability problems may affect the posterior sample
because of column switching and sign switching of the factor loadings.
These issues can be addressed <em>a posteriori</em> with the functions
<code><a href="#topic+post.column.switch">post.column.switch</a></code> and <code><a href="#topic+post.sign.switch">post.sign.switch</a></code>.
</p>
<p><strong>Prior specification.</strong>
The indicators are assumed to have the following probabilities,
for <code class="reqn">k = 1, ..., K</code>:
</p>
<p style="text-align: center;"><code class="reqn">Prob(\Delta_m = e_k \mid \tau_k) = \tau_k</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau = (\tau_0, \tau_1, ..., \tau_K)</code>
</p>

<p>If <code>indp.tau0 = FALSE</code>, the probabilities are specified as:
</p>
<p style="text-align: center;"><code class="reqn">\tau = [\tau_0, (1-\tau_0)\tau^*_1, ..., (1-\tau_0)\tau^*_K]</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_0 \sim \mathcal{B}eta(\kappa_0, \xi_0)</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau^* = (\tau^*_1, ..., \tau^*_K) \sim \mathcal{D}ir(\kappa)</code>
</p>

<p>with <code class="reqn">\kappa_0</code> = <code>kappa0</code>, <code class="reqn">\xi_0</code> = <code>xi0</code> and
<code class="reqn">\kappa</code> = <code>kappa</code>.
Alternatively, if <code>indp.tau0 = TRUE</code>, the probabilities are specified
as:
</p>
<p style="text-align: center;"><code class="reqn">\tau_m = [\tau_{0m}, (1-\tau_{0m})\tau^*_1, ...,
        (1-\tau_{0m})\tau^*_K]</code>
</p>

<p style="text-align: center;"><code class="reqn">\tau_{0m} \sim \mathcal{B}eta(\kappa_0, \xi_0)</code>
</p>

<p>for each manifest variable <code class="reqn">m = 1, ..., M</code>.
</p>
<p>A normal-inverse-Gamma prior distribution is assumed on the nonzero factor
loadings and on the idiosyncratic variances:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2_m \sim \mathcal{I}nv-\mathcal{G}amma(c_{0m}, C_{0m})</code>
</p>

<p style="text-align: center;"><code class="reqn">\alpha_m^\Delta \mid \sigma^2_m \sim \mathcal{N}(0, A_{0m}\sigma^2_m)</code>
</p>

<p>where <code class="reqn">\alpha_m^\Delta</code> denotes the only nonzero loading in the <code class="reqn">m</code>th
row of <code class="reqn">\alpha</code>.
</p>
<p>For the regression coefficients, a multivariate Normal prior distribution is
assumed on each row <code class="reqn">m = 1, ..., M</code> of <code class="reqn">\beta</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_m \sim \mathcal{N}(0, B_0 I_Q)</code>
</p>

<p>The covariates can be different across manifest variables, implying zero
restrictions on the matrix <code class="reqn">\beta</code>. To specify covariates, use a list
of formulas as <code>model</code> (see example below). Intercept terms can be
introduced using
</p>
<p>To sample the correlation matrix <code class="reqn">R</code> of the latent factors, marginal data
augmentation is implemented (van Dyk and Meng, 2001), see CFSHP section 2.2.
Using the transformation <code class="reqn">\Omega = \Lambda^{1/2} R \Lambda^{1/2}</code>, the
parameters <code class="reqn">\Lambda = diag(\lambda_1, ..., \lambda_K)</code> are used as
<em>working parameters</em>. These parameters correspond to the variances of
the latent factors in an expanded version of the model where the factors do
not have unit variances. Two prior distributions can be specified on the
covariance matrix <code class="reqn">\Omega</code> in the expanded model:
</p>

<ul>
<li><p> If <code>HW.prior = FALSE</code>, inverse-Wishart distribution:
</p>
<p style="text-align: center;"><code class="reqn">\Omega \sim \mathcal{I}nv-\mathcal{W}ishart(\nu_0, diag(S_0))</code>
</p>

<p>with <code class="reqn">\nu_0</code> = <code>nu0</code> and <code class="reqn">S_0</code> = <code>S0</code>.
</p>
</li>
<li><p> If <code>HW.prior = TRUE</code>, Huang-Wand (2013) prior:
</p>
<p style="text-align: center;"><code class="reqn">\Omega \sim \mathcal{I}nv-\mathcal{W}ishart(\nu_0, W), \qquad
        W = diag(w_1, ..., w_K)</code>
</p>

<p style="text-align: center;"><code class="reqn">w_k \sim \mathcal{G}amma\left(\frac{1}{2},
        \frac{1}{2\nu^*S_{0k}}\right)</code>
</p>

<p>with <code class="reqn">\nu^*</code> = <code>nu0</code> - <code>Kmax</code> + 1, and the shape and
rate parameters are specified such that the mean of the gamma distribution
is equal to <code class="reqn">\nu^* S_{0k}</code>, for each <code class="reqn">k = 1, ..., K</code>.
</p>
</li></ul>

<p><strong>Missing values.</strong> Missing values (<code>NA</code>) are allowed in the
manifest variables. They are drawn from their corresponding conditional
distributions during MCMC sampling. Control variables with missing values
can be passed to the function. However, all the observations with at least
one missing value in the covariates are discarded from the sample (a warning
message is issued in that case).
</p>


<h3>Value</h3>

<p>The function returns an object of class '<code>befa</code>' containing the
MCMC draws of the model parameters saved in the following matrices (each
matrix has '<code>iter</code>' rows):
</p>

<ul>
<li> <p><code>alpha</code>: Factor loadings.
</p>
</li>
<li> <p><code>sigma</code>: Idiosyncratic variances.
</p>
</li>
<li> <p><code>R</code>: Correlation matrix of the latent factors (off-diagonal
elements only).
</p>
</li>
<li> <p><code>beta</code>: regression coefficients (if any).
</p>
</li>
<li> <p><code>dedic</code>: indicators (integers indicating on which factors the
manifest variable load).
</p>
</li></ul>

<p>The returned object also contains:
</p>

<ul>
<li> <p><code>nfac</code>: Vector of number of 'active' factors across MCMC
iterations (i.e., factors loaded by at least <code>Nid</code> manifest
variables).
</p>
</li>
<li> <p><code>MHacc</code>: Logical vector indicating accepted proposals of
Metropolis-Hastings algorithm.
</p>
</li></ul>

<p>The parameters <code>Kmax</code> and <code>Nid</code> are saved as object attributes, as
well as the function call and the number of mcmc iterations (<code>burnin</code>
and <code>iter</code>), and two logical variables indicating if the returned object
has been post processed to address the column switching problem
(<code>post.column.switch</code>) and the sign switching problem
(<code>post.sign.switch</code>).
</p>


<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>References</h3>

<p>G. Conti, S. Frühwirth-Schnatter, J.J. Heckman, R. Piatek (2014):
&ldquo;Bayesian Exploratory Factor Analysis&rdquo;, <em>Journal of Econometrics</em>,
183(1), pages 31-57, <a href="https://doi.org/10.1016/j.jeconom.2014.06.008">doi:10.1016/j.jeconom.2014.06.008</a>.
</p>
<p>A. Huang, M.P. Wand (2013):
&ldquo;Simple Marginally Noninformative Prior Distributions for Covariance
Matrices&rdquo;, <em>Bayesian Analysis</em>, 8(2), pages 439-452,
<a href="https://doi.org/10.1214/13-BA815">doi:10.1214/13-BA815</a>.
</p>
<p>D.A. van Dyk, X.-L. Meng (2001):
&ldquo;The Art of Data Augmentation&rdquo;,
<em>Journal of Computational and Graphical Statistics</em>, 10(1), pages 1-50,
<a href="https://doi.org/10.1198/10618600152418584">doi:10.1198/10618600152418584</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+post.column.switch">post.column.switch</a></code> and <code><a href="#topic+post.sign.switch">post.sign.switch</a></code>
for column switching and sign switching of the factor loading matrix and of
the correlation matrix of the latent factors to restore identification
<em>a posteriori</em>.
</p>
<p><code><a href="#topic+summary.befa">summary.befa</a></code> and <code><a href="#topic+plot.befa">plot.befa</a></code> to summarize
and plot the posterior results.
</p>
<p><code><a href="#topic+simul.R.prior">simul.R.prior</a></code> and <code><a href="#topic+simul.nfac.prior">simul.nfac.prior</a></code> to
simulate the prior distribution of the correlation matrix of the factors and
the prior distribution of the indicator matrix, respectively. This is useful
to perform prior sensitivity analysis and to understand the role of the
corresponding parameters in the factor search.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### model without covariates

set.seed(6)

# generate fake data with 15 manifest variables and 3 factors
N &lt;- 100    # number of observations
Y &lt;- simul.dedic.facmod(N, dedic = rep(1:3, each = 5))

# run MCMC sampler
# notice: 1000 MCMC iterations for illustration purposes only,
#  increase this number to obtain reliable posterior results!
mcmc &lt;- befa(Y, Kmax = 5, iter = 1000)

# post process MCMC draws to restore identification
mcmc &lt;- post.column.switch(mcmc)
mcmc &lt;- post.sign.switch(mcmc)

summary(mcmc)  # summarize posterior results
plot(mcmc)     # plot posterior results

# summarize highest posterior probability (HPP) model
summary(mcmc, what = 'hppm')

#### model with covariates

# generate covariates and regression coefficients
Xcov &lt;- cbind(1, matrix(rnorm(4*N), ncol = 4))
colnames(Xcov) &lt;- c('(Intercept)', paste0('X', 1:4))
beta &lt;- rbind(rnorm(15), rnorm(15), diag(3) %x% t(rnorm(5)))

# add covariates to previous model
Y &lt;- Y + Xcov %*% beta

# specify model
model &lt;- c('~ X1',                        # X1 covariate in all equations
           paste0('Y', 1:5,   ' ~ X2'),   # X2 covariate for Y1-Y5 only
           paste0('Y', 6:10,  ' ~ X3'),   # X3 covariate for Y6-Y10 only
           paste0('Y', 11:15, ' ~ X4'))   # X4 covariate for Y11-Y15 only
model &lt;- lapply(model, as.formula)        # make list of formulas

# run MCMC sampler, post process and summarize
mcmc &lt;- befa(model, data = data.frame(Y, Xcov), Kmax = 5, iter = 1000)
mcmc &lt;- post.column.switch(mcmc)
mcmc &lt;- post.sign.switch(mcmc)
mcmc.sum &lt;- summary(mcmc)
mcmc.sum

# compare posterior mean of regression coefficients to true values
beta.comp &lt;- cbind(beta[beta != 0], mcmc.sum$beta[, 'mean'])
colnames(beta.comp) &lt;- c('true', 'mcmc')
print(beta.comp, digits = 3)


</code></pre>

<hr>
<h2 id='plot.befa'>Plot object of class 'befa'</h2><span id='topic+plot.befa'></span>

<h3>Description</h3>

<p>This function makes different plots that are useful to assess the posterior
results: a trace plot of the number of latent factors (also showing
Metropolis-Hastings acceptance across MCMC replications), a histogram
of the posterior probabilities of the number of factors, heatmaps for the
inficator probabilities, the factor loading matrix, and the correlation
matrix of the latent factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'befa'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.befa_+3A_x">x</code></td>
<td>
<p>Object of class 'befa'.</p>
</td></tr>
<tr><td><code id="plot.befa_+3A_...">...</code></td>
<td>
<p>The following extra arguments can be specified:
</p>

<ul>
<li> <p><code>what</code>: How to summarize the posterior distribution?
</p>

<ul>
<li> <p><code>what = 'maxp'</code> (default): Only factor loadings with
highest posterior probability of being different from zero or
discarded from the model (if <code>dedic = 0</code>) are
summarized.
</p>
</li>
<li> <p><code>what = 'all'</code>: All factor loadings with corresponding
posterior probability to be allocated to a given factor (or
to be discarded from the model) larger than <code>min.prob</code>
are summarized.
</p>
</li>
<li> <p><code>what = 'hppm'</code>: Highest posterior probability models
with probability larger than <code>min.prob</code> are summarized.
</p>
</li></ul>

</li>
<li> <p><code>byfac</code>: Sort factor loadings by factors if <code>TRUE</code>,
otherwise by manifest variables if <code>FALSE</code> (default).
</p>
</li>
<li> <p><code>hpd.prob</code>: Probability used to compute the highest posterior
density intervals of the posterior distribution of the model
parameters (default: 0.95).
</p>
</li>
<li> <p><code>min.prob</code>: If <code>what = 'all'</code>, only factor loadings with
posterior probability of being dedicated to a given factor (or
discarded from the model) larger than this value are displayed.
If <code>what = 'hppm'</code>, only highest posterior probability models
with probability larger than this value are displayed. (default:
0.20)
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes graphs based on the summary results returned by
<code><a href="#topic+summary.befa">summary.befa</a></code>. It therefore accepts the same optional arguments
as this function.
</p>


<h3>Value</h3>

<p>No return value, called for side effects (plots the posterior results 
returned by <code><a href="#topic+summary.befa">summary.befa</a></code>).
</p>


<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.befa">summary.befa</a></code> to summarize posterior results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6)

# generate fake data with 15 manifest variables and 3 factors
Y &lt;- simul.dedic.facmod(N = 100, dedic = rep(1:3, each = 5))

# run MCMC sampler and post process output
# notice: 1000 MCMC iterations for illustration purposes only,
#  increase this number to obtain reliable posterior results!
mcmc &lt;- befa(Y, Kmax = 5, iter = 1000)
mcmc &lt;- post.column.switch(mcmc)
mcmc &lt;- post.sign.switch(mcmc)

# plot results for highest posterior probability model
plot(mcmc, what = 'hppm')

</code></pre>

<hr>
<h2 id='post.column.switch'>Perform column switchting on posterior MCMC sample</h2><span id='topic+post.column.switch'></span>

<h3>Description</h3>

<p>This function reorders the columns of the factor loading matrix for each MCMC
draw, as well as the rows and columns of the correlation matrix of the
factors, to restore the identification of the model <em>a posteriori</em> with
respect to the column switching problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post.column.switch(mcmc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post.column.switch_+3A_mcmc">mcmc</code></td>
<td>
<p>Object of class '<code>befa</code>'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reordering of the columns of the factor loading matrix is based
on the top elements of the columns (i.e., the first row containing a nonzero
factor loading in each nonzero column of <code class="reqn">\alpha</code>, starting from the top
of the matrix). At each MCMC iteration, the nonzero columns of <code class="reqn">\alpha</code>
are reordered such that the top elements appear in increasing order.
The rows and columns of the correlation matrix <code class="reqn">R</code> of the factors are
switched accordingly. See section 4.3 of CFSHP (p.42) for more details.
</p>


<h3>Value</h3>

<p>Same '<code>befa</code>' object as the one passed to the function, where
the indicators in the matrix <code>dedic</code>, as well as the rows and columns of
the correlation matrix of the factors saved in <code>draws</code>, have been
switched appropriately to restore the identification of the factor model with
respect to column switching.
</p>


<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>References</h3>

<p>G. Conti, S. Frühwirth-Schnatter, J.J. Heckman,
R. Piatek (2014): &ldquo;Bayesian Exploratory Factor Analysis&rdquo;,
<em>Journal of Econometrics</em>, 183(1), pages 31-57,
<a href="https://doi.org/10.1016/j.jeconom.2014.06.008">doi:10.1016/j.jeconom.2014.06.008</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+post.sign.switch">post.sign.switch</a></code> to restore identification a
posteriori with respect to the sign switching problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6)
Y &lt;- simul.dedic.facmod(N = 100, dedic = rep(1:3, each = 5))
mcmc &lt;- befa(Y, Kmax = 5, iter = 1000)
mcmc &lt;- post.column.switch(mcmc)

</code></pre>

<hr>
<h2 id='post.sign.switch'>Perform sign switchting on posterior MCMC sample</h2><span id='topic+post.sign.switch'></span>

<h3>Description</h3>

<p>This function performs a sign switch on the MCMC draws to restore the
consistency of the signs of the factors loadings and of the correlations of
the latent factors <em>a posteriori</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post.sign.switch(mcmc, benchmark = NULL, benchmark.threshold = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post.sign.switch_+3A_mcmc">mcmc</code></td>
<td>
<p>Object of class '<code>befa</code>'.</p>
</td></tr>
<tr><td><code id="post.sign.switch_+3A_benchmark">benchmark</code></td>
<td>
<p>Vector of integers of length equal to the maximum number of latent
factors. Each element indicates which factor loading is used as a
benchmark for the sign switch. If <code>NULL</code>, the factor loadings
with the highest posterior probabilities of being different from zero
in each column of the factor loading matrix are used as benchmarks.</p>
</td></tr>
<tr><td><code id="post.sign.switch_+3A_benchmark.threshold">benchmark.threshold</code></td>
<td>
<p>Minimum posterior probability for a factor loading to be considered
as a benchmark.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The signs of the factor loadings, as well as of the corresponding
correlations of the latent factors, are switched for each MCMC iteration such
that the factor loadings defined as <code>benchmark</code>s are positive. The sign
switch can only be performed if <code><a href="#topic+post.column.switch">post.column.switch</a></code> has been run
before. See section 4.3 (p.42) of CFSHP for more details.
</p>
<p>If a latent factor has no benchmarks, or if its benchmark is equal to zero at
some MCMC iteration, then no sign switch is performed on the corresponding
loadings and correlations for this particular factor or MCMC iteration.
</p>
<p>Note that in complicated models where the sampler visits several models with
different numbers of latent factors, it may not be relevant to use the
default value of <code>benchmark</code>, as the posterior probabilities that the
factor loadings are different from zero would be computed across models.
Instead, the user might consider finding the highest posterior probability
model first, and use its top elements in each column of the factor loading
matrix as benchmarks to perform the sign switch.
</p>


<h3>Value</h3>

<p>This function returns the same '<code>befa</code>' object, where the signs
of the factor loadings and of the factor correlations have been switched
appropriately to restore the identification of the factor model with respect
to sign switching.
</p>


<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>References</h3>

<p>G. Conti, S. Frühwirth-Schnatter, J.J. Heckman,
R. Piatek (2014): &ldquo;Bayesian Exploratory Factor Analysis&rdquo;,
<em>Journal of Econometrics</em>, 183(1), pages 31-57,
<a href="https://doi.org/10.1016/j.jeconom.2014.06.008">doi:10.1016/j.jeconom.2014.06.008</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+post.column.switch">post.column.switch</a></code> for column switching of the factor
loading matrix and of the correlation matrix of the latent factors to restore
identification <em>a posteriori</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6)
Y &lt;- simul.dedic.facmod(N = 100, dedic = rep(1:3, each = 5))
mcmc &lt;- befa(Y, Kmax = 5, iter = 1000)
mcmc &lt;- post.column.switch(mcmc)

# factor loadings corresponding to variables 1, 6, 11, 12 and 13 are
# used as benchmarks:
mcmc1 &lt;- post.sign.switch(mcmc, benchmark = c(1, 6, 11, 12, 13))

# factor loadings with the highest posterior probability of being different
# from zero in each column are used as benchmark:
mcmc2 &lt;- post.sign.switch(mcmc)

</code></pre>

<hr>
<h2 id='simul.dedic.facmod'>Generate synthetic data from a dedicated factor model</h2><span id='topic+simul.dedic.facmod'></span>

<h3>Description</h3>

<p>This function simulates data from a dedicated factor model. The parameters of
the model are either passed by the user or simulated by the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul.dedic.facmod(N, dedic, alpha, sigma, R, R.corr = TRUE,
  max.corr = 0.85, R.max.trial = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul.dedic.facmod_+3A_n">N</code></td>
<td>
<p>Number of observations in data set.</p>
</td></tr>
<tr><td><code id="simul.dedic.facmod_+3A_dedic">dedic</code></td>
<td>
<p>Vector of indicators. The number of manifest variables is equal to the
length of this vector, and the number of factors is equal to the
number of unique nonzero elements. Each integer element indicates on
which latent factor the corresponding variable loads uniquely.</p>
</td></tr>
<tr><td><code id="simul.dedic.facmod_+3A_alpha">alpha</code></td>
<td>
<p>Vector of factor loadings, should be of same length as <code>dedic</code>.
If missing, values are simulated (see details below).</p>
</td></tr>
<tr><td><code id="simul.dedic.facmod_+3A_sigma">sigma</code></td>
<td>
<p>Idiosyncratic variances, should be of same length as <code>dedic</code>.
If missing, values are simulated (see details below).</p>
</td></tr>
<tr><td><code id="simul.dedic.facmod_+3A_r">R</code></td>
<td>
<p>Covariance matrix of the latent factors.
If missing, values are simulated (see details below).</p>
</td></tr>
<tr><td><code id="simul.dedic.facmod_+3A_r.corr">R.corr</code></td>
<td>
<p>If TRUE, covariance matrix <code>R</code> is rescaled to be a correlation
matrix.</p>
</td></tr>
<tr><td><code id="simul.dedic.facmod_+3A_max.corr">max.corr</code></td>
<td>
<p>Maximum correlation allowed between the latent factors.</p>
</td></tr>
<tr><td><code id="simul.dedic.facmod_+3A_r.max.trial">R.max.trial</code></td>
<td>
<p>Maximum number of trials allowed to sample from the truncated
distribution of the covariance matrix of the latent factors
(accept/reject sampling scheme, to make sure <code>max.corr</code> is not
exceeded).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simulates data from the following dedicated factor
model, for <code class="reqn">i = 1, ..., N</code>:
</p>
<p style="text-align: center;"><code class="reqn">Y_i = \alpha \theta_i + \epsilon_i</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_i \sim \mathcal{N}(0, R)</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_i \sim \mathcal{N}(0, \Sigma)</code>
</p>

<p>where the <code class="reqn">K</code>-vector <code class="reqn">\theta_i</code> contains the latent factors, and
<code class="reqn">\alpha</code> is the <code class="reqn">(M \times K)</code>-matrix of factor loadings. Each
row <code class="reqn">m</code> of <code class="reqn">\alpha</code> contains only zeros, besides its element
indicated by the <code class="reqn">m</code>th element of <code>dedic</code> that is equal to the
<code class="reqn">m</code>th element of <code>alpha</code> (denoted <code class="reqn">\alpha_m^\Delta</code> below).
The <code class="reqn">M</code>-vector <code class="reqn">\epsilon_i</code> is the vector of error terms, with
<code class="reqn">\Sigma = diag(</code><code>sigma</code><code class="reqn">)</code>. <code class="reqn">M</code> is equal to the length of
the vector <code>dedic</code>, and <code class="reqn">K</code> is equal to the maximum value of this
vector.
</p>
<p>Only <code>N</code> and <code>dedic</code> are required, all the other parameters can be
missing, completely or partially. Missing values (<code>NA</code>) are
independently sampled from the following distributions, for each manifest
variable <code class="reqn">m = 1, ..., M</code>:
</p>
<p>Factor loadings:
</p>
<p style="text-align: center;"><code class="reqn">\alpha_m^\Delta = (-1)^{\phi_m}\sqrt{a_m}</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_m \sim \mathcal{B}er(0.5)</code>
</p>

<p style="text-align: center;"><code class="reqn">a_m \sim \mathcal{U}nif (0.04, 0.64)</code>
</p>

<p>Idiosyncratic variances:
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2_m \sim \mathcal{U}nif (0.2, 0.8)</code>
</p>

<p>For the variables that do not load on any factors (i.e., for which the
corresponding elements of <code>dedic</code> are equal to 0), it is specified that
<code class="reqn">\alpha_m^\Delta = 0</code> and <code class="reqn">\sigma^2_m = 1</code>.
</p>
<p>Covariance matrix of the latent factors:
</p>
<p style="text-align: center;"><code class="reqn">\Omega \sim \mathcal{I}nv-\mathcal{W}ishart(K+5, I_K)</code>
</p>

<p>which is rescaled to be a correlation matrix if <code>R.corr = TRUE</code>:
</p>
<p style="text-align: center;"><code class="reqn">R = \Lambda^{-1/2} \Omega \Lambda^{-1/2}</code>
</p>

<p style="text-align: center;"><code class="reqn">\Lambda = diag(\Omega)</code>
</p>

<p>Note that the distribution of the covariance matrix is truncated such that
all the off-diagonal elements of the implied correlation matrix <code class="reqn">R</code> are
below <code>max.corr</code> in absolute value. The truncation is also applied if
the covariance matrix is used instead of the correlation matrix (i.e., if
<code>R.corr = FALSE</code>).
</p>
<p>The distributions and the corresponding default values used to simulate the
model parameters are specified as in the Monte Carlo study of CFSHP, see
section 4.1 (p.43).
</p>


<h3>Value</h3>

<p>The function returns a data frame with <code>N</code> observations
simulated from the corresponding dedicated factor model.
The parameters used to generate the data are saved as attributes:
<code>dedic</code>, <code>alpha</code>, <code>sigma</code> and <code>R</code>.
</p>


<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>References</h3>

<p>G. Conti, S. Frühwirth-Schnatter, J.J. Heckman,
R. Piatek (2014): &ldquo;Bayesian Exploratory Factor Analysis&rdquo;,
<em>Journal of Econometrics</em>, 183(1), pages 31-57,
<a href="https://doi.org/10.1016/j.jeconom.2014.06.008">doi:10.1016/j.jeconom.2014.06.008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate 1000 observations from model with 4 factors and 20 variables
# (5 variables loading on each factor)
dat &lt;- simul.dedic.facmod(N = 1000, dedic = rep(1:4, each = 5))

# generate data set with 5000 observations from the following model:
dedic &lt;- rep(1:3, each = 4)        # 3 factors and 12 manifest variables
alpha &lt;- rep(c(1, NA, NA, NA), 3)  # set first loading to 1 for each factor,
                                   #   sample remaining loadings from default
sigma &lt;- rep(0.5, 12)              # idiosyncratic variances all set to 0.5
R &lt;- toeplitz(c(1, .6, .3))        # Toeplitz matrix
dat &lt;- simul.dedic.facmod(N = 5000, dedic, alpha, sigma, R)

</code></pre>

<hr>
<h2 id='simul.nfac.prior'>Simulate prior distribution of number of latent factors</h2><span id='topic+simul.nfac.prior'></span>

<h3>Description</h3>

<p>This function produces a sample from the prior distribution of the number of
latent factors. It depends on the prior parameters used for the distribution
of the indicators, on the size of the model (number of manifest variables
and maximum number of latent factors), and on the identification restriction
(minimum number of manifest variables dedicated to each factor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul.nfac.prior(nvar, Kmax, Nid = 3, kappa = 1/Kmax, nrep = 10^6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul.nfac.prior_+3A_nvar">nvar</code></td>
<td>
<p>Number of manifest variables.</p>
</td></tr>
<tr><td><code id="simul.nfac.prior_+3A_kmax">Kmax</code></td>
<td>
<p>Maximum number of latent factors.</p>
</td></tr>
<tr><td><code id="simul.nfac.prior_+3A_nid">Nid</code></td>
<td>
<p>Minimum number of manifest variables dedicated to each latent factor
for identification.</p>
</td></tr>
<tr><td><code id="simul.nfac.prior_+3A_kappa">kappa</code></td>
<td>
<p>Concentration parameter of the Dirichlet prior distribution on
the indicators.</p>
</td></tr>
<tr><td><code id="simul.nfac.prior_+3A_nrep">nrep</code></td>
<td>
<p>Number of Monte Carlo replications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the prior distribution of the number of
latent factors for models that fulfill the identification restriction
restriction that at least <code>Nid</code> manifest variables (or no variables) are
loading on each latent factor. Several (scalar) parameters <code>kappa</code> can
be passed to the function to simulate the prior for different prior parameter
values and compare the results.
</p>
<p>An accept/reject sampling scheme is used: a vector of probabilities is drawn
from a Dirichlet distribution with concentration parameter <code>kappa</code>, and
the <code>nvar</code> manifest variables are randomly allocated to the <code>Kmax</code>
latent factors. If each latent factor has at least <code>Nid</code> dedicated
variables or no variables at all, the identification requirement is fulfilled
and the draw is accepted. The number of factors loaded by at least <code>Nid</code>
manifest variables is returned as a draw from the prior distribution.
</p>
<p>Note that this function does not use the two-level prior distribution
implemented in CFSHP, where manifest variables can be discarded from the
model according to a given probability. Therefore, this function only help
understand the prior distribution conditional on all the manifest variables
being included into the model.
</p>


<h3>Value</h3>

<p>A list of length equal to the number of parameters specified in
<code>kappa</code> is returned, where each element of the list contains:
</p>

<ul>
<li> <p><code>nfac</code>: Vector of integers of length equal to the number of
accepted draws.
</p>
</li>
<li> <p><code>acc</code>: Acceptance rate of the accept/reject sampling scheme.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>References</h3>

<p>G. Conti, S. Frühwirth-Schnatter, J.J. Heckman, R. Piatek (2014):
&ldquo;Bayesian Exploratory Factor Analysis&rdquo;, <em>Journal of Econometrics</em>,
183(1), pages 31-57, <a href="https://doi.org/10.1016/j.jeconom.2014.06.008">doi:10.1016/j.jeconom.2014.06.008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># replicate first row of table 2 in CFSHP (p.44)
# note: use larger number of replications nrep to improve accuracy
prior.nfac &lt;- simul.nfac.prior(nvar = 15, Kmax = 5, kappa = c(.3, .7, 1), 
                               nrep = 10000)
summary(prior.nfac)
plot(prior.nfac)

</code></pre>

<hr>
<h2 id='simul.R.prior'>Simulate prior distribution of factor correlation matrix</h2><span id='topic+simul.R.prior'></span>

<h3>Description</h3>

<p>This function produces a sample of correlation matrices drawn from their
prior distribution induced in the identified version of the factor model,
given the prior distribution specified on the corresponding covariance
matrices of the factors in the expanded model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simul.R.prior(Kmax, nu0 = Kmax + 1, S0 = 1, HW.prior = TRUE,
  nrep = 10^5, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simul.R.prior_+3A_kmax">Kmax</code></td>
<td>
<p>Maximum number of latent factors.</p>
</td></tr>
<tr><td><code id="simul.R.prior_+3A_nu0">nu0</code></td>
<td>
<p>Degrees of freedom of the Inverse-Wishart prior on the covariance
matrix of the latent factors in the expanded model.</p>
</td></tr>
<tr><td><code id="simul.R.prior_+3A_s0">S0</code></td>
<td>
<p>Scale parameters of the Inverse-Wishart prior on the covariance matrix
of latent factors in the expanded model:
</p>

<ul>
<li><p> if <code>HW.prior = TRUE</code>, scale parameter of the Gamma
hyperprior distribution on the individual scales of the
Inverse-Wishart prior.
</p>
</li>
<li><p> if <code>HW.prior = FALSE</code>, diagonal elements of the scale
matrix of the Inverse-Wishart prior on the covariance matrix of
the latent factors in the expanded model.
</p>
</li></ul>

<p>Either a scalar or a numeric vector of length equal to <code>Kmax</code>.</p>
</td></tr>
<tr><td><code id="simul.R.prior_+3A_hw.prior">HW.prior</code></td>
<td>
<p>If <code>TRUE</code>, implement Huang-Wand (2013) prior on the covariance
matrix of the factors in the expanded model, otherwise use an
Inverse-Wishart prior if <code>FALSE</code>, see CFSHP section 2.3.5.</p>
</td></tr>
<tr><td><code id="simul.R.prior_+3A_nrep">nrep</code></td>
<td>
<p>Number of Monte Carlo replications.</p>
</td></tr>
<tr><td><code id="simul.R.prior_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, display information on the progress of the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance matrices are sampled from the prior distribution in the
expanded model, and transformed to produce the corresponding correlation
matrices. See section 2.3.5 of CFSHP (p.36-37), as well as the details of
the function <code><a href="#topic+befa">befa</a></code>.
</p>
<p>To compare several prior specifications, different values of the parameters
<code>nu0</code> and <code>S0</code> can be specified. The function then simulates for
each pair of these parameters. <code>nu0</code> and <code>S0</code> should therefore be
scalars or vectors of same length.
</p>


<h3>Value</h3>

<p>A list of length equal to the number of pairs of parameters
<code>nu0</code> and <code>S0</code>, where each element of the list is an array of
dimension (<code>Kmax</code>, <code>Kmax</code>, <code>nrep</code>) that contains the
correlation matrices of the latent factors drawn from the prior.
</p>


<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>References</h3>

<p>G. Conti, S. Frühwirth-Schnatter, J.J. Heckman, R. Piatek (2014):
&ldquo;Bayesian Exploratory Factor Analysis&rdquo;, <em>Journal of Econometrics</em>,
183(1), pages 31-57, <a href="https://doi.org/10.1016/j.jeconom.2014.06.008">doi:10.1016/j.jeconom.2014.06.008</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># partial reproduction of figure 1 in CFSHP (p.38)
# note: use larger number of replications nrep to increase smoothness
Kmax &lt;- 10
Rsim &lt;- simul.R.prior(Kmax, nu0 = Kmax + c(1, 2, 5), S0 = .5, nrep = 1000)
summary(Rsim)
plot(Rsim)

</code></pre>

<hr>
<h2 id='summary.befa'>Summarize 'befa' object</h2><span id='topic+summary.befa'></span>

<h3>Description</h3>

<p>Generic function summarizing the posterior results of a 'befa' object.
Optional arguments can be specified to customize the summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'befa'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.befa_+3A_object">object</code></td>
<td>
<p>Object of class 'befa'.</p>
</td></tr>
<tr><td><code id="summary.befa_+3A_...">...</code></td>
<td>
<p>The following extra arguments can be specified:
</p>

<ul>
<li> <p><code>what</code>: How to summarize the posterior distribution?
</p>

<ul>
<li> <p><code>what = 'maxp'</code> (default): Only factor loadings with
highest posterior probability of being different from zero or
discarded from the model (if <code>dedic = 0</code>) are
summarized.
</p>
</li>
<li> <p><code>what = 'all'</code>: All factor loadings with corresponding
posterior probability to be allocated to a given factor (or
to be discarded from the model) larger than <code>min.prob</code>
are summarized.
</p>
</li>
<li> <p><code>what = 'hppm'</code>: Highest posterior probability models
with probability larger than <code>min.prob</code> are summarized.
</p>
</li></ul>

</li>
<li> <p><code>byfac</code>: Sort factor loadings by factors if <code>TRUE</code>,
otherwise by manifest variables if <code>FALSE</code> (default).
</p>
</li>
<li> <p><code>hpd.prob</code>: Probability used to compute the highest posterior
density intervals of the posterior distribution of the model
parameters (default: 0.95).
</p>
</li>
<li> <p><code>min.prob</code>: If <code>what = 'all'</code>, only factor loadings with
posterior probability of being dedicated to a given factor (or
discarded from the model) larger than this value are displayed.
If <code>what = 'hppm'</code>, only highest posterior probability models
with probability larger than this value are displayed. (default:
0.20)
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function summarizes the posterior distribution of the parameters.
The algorithm may visit different configurations of the indicator matrix
<code class="reqn">\Delta</code> during sampling, where the manifest variables are allocated to
different latent factors. When the posterior distribution of the factor
loadings is summarized separately for each manifest variable
(<code>what = 'maxp'</code> or <code>what = 'all'</code>), the function provides the
latent factor each manifest variable is allocated to (<code>dedic</code>), and the
corresponding posterior probability (<code>prob</code>). If <code>dedic = 0</code>, then
<code>prob</code> corresponds to the posterior probability that the manifest
variable is discarded. Discarded variables are listed last if
<code>byfac = TRUE</code>. Low probability cases can be discarded by setting
<code>min.prob</code> appropriately (default is 0.20).
</p>
<p>Idiosyncratic variances, factor correlation matrix and regression
coefficients (if any) are summarized across all MCMC iterations if
<code>what = 'all'</code> or <code>what = 'maxp'</code>, and within each HPP model if
<code>what = 'hppm'</code>.
</p>
<p><strong>Highest posterior probability model.</strong>
The HPP model is the model with a given allocation of the measurements to the
latent factors (i.e., a given indicator matrix <code class="reqn">\Delta</code>) that is visited
most often by the algorithm.
</p>
<p>When specifying <code>what = 'hppm'</code>, the function sorts the models according
to the posterior frequencies of their indicator matrices in decreasing order.
Therefore, the first model returned (labeled 'm1') corresponds to the HPP
model.
Low probability models can be discarded by setting <code>min.prob</code>
appropriately(default is 0.20, implying that only models with a posterior
probability larger than 0.20 are displayed).
</p>
<p>HPP models can only be found if identification with respect to column
switching has been restored <em>a posteriori</em>. An error message is returned
if this is not the case.
</p>


<h3>Value</h3>

<p>If called directly, the summary is formatted and displayed on the
standard output. Otherwise if saved in an object, a list of the following
elements is returned:
</p>

<ul>
<li> <p><code>MHacc</code>: Metropolis-Hastings acceptance rate.
</p>
</li>
<li> <p><code>alpha</code>: Data frame (or list of data frames if
<code>what = 'hppm'</code>) containing posterior summary statistics for the
factor loadings.
</p>
</li>
<li> <p><code>sigma</code>: Data frame (or list of matrices if <code>what = 'hppm'</code>)
containing posterior summary statistics for the idiosyncratic
variances.
</p>
</li>
<li> <p><code>R</code>: Data frame (or list of data frames if <code>what = 'hppm'</code>)
containing posterior summary statistics for the factor correlations.
</p>
</li>
<li> <p><code>beta</code>: Data frame (or list of data frames if
<code>what = 'hppm'</code>) containing posterior summary statistics for the
regression coefficients (if any).
</p>
</li>
<li> <p><code>nfac</code> (only if <code>what = 'maxp'</code> or <code>what = 'all'</code>):
Table of posterior frequencies of numbers of factors.
</p>
</li>
<li> <p><code>hppm</code> (only if <code>what = 'hppm'</code>): List of the following
elements summarizing the different HPP models, sorted in decreasing
order of their posterior probabilities:
</p>

<ul>
<li> <p><code>prob</code>: Vector of posterior probabilities.
</p>
</li>
<li> <p><code>nfac</code>: Vector of numbers of factors.
</p>
</li>
<li> <p><code>dedic</code>: Data frame of factor indicators.
</p>
</li></ul>

</li></ul>

<p>Data frames of posterior summary statistics include the means (<code>mean</code>),
standard deviations (<code>sd</code>) and highest posterior density intervals
(<code>hpd.lo</code> and <code>hpd.up</code>, for the probability specified in
<code>hpd.prob</code>) of the corresponding parameters.
</p>
<p>For the factor loadings, the matrix may also include a column labeled
'<code>dedic</code>' indicating to which factors the corresponding manifest
variables are dedicated (a zero value means that the manifest variable does
not load on any factor), as well as a column labeled '<code>prob</code>' showing
the corresponding posterior probabilities that the manifest variables load on
these factors.
</p>
<p>Summary results are returned as lists of data frames for HPP models, where
the elements of the list are labeled as '<code>m1</code>, '<code>m2</code>', etc.
</p>


<h3>Author(s)</h3>

<p>Rémi Piatek <a href="mailto:remi.piatek@gmail.com">remi.piatek@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.befa">plot.befa</a></code> to plot posterior results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(6)

# generate fake data with 15 manifest variables and 3 factors
Y &lt;- simul.dedic.facmod(N = 100, dedic = rep(1:3, each = 5))

# run MCMC sampler and post process output
# notice: 1000 MCMC iterations for illustration purposes only,
#  increase this number to obtain reliable posterior results!
mcmc &lt;- befa(Y, Kmax = 5, iter = 1000)
mcmc &lt;- post.column.switch(mcmc)
mcmc &lt;- post.sign.switch(mcmc)

# summarize posterior results
summary(mcmc)

# summarize highest posterior probability (HPP) model
hppm.sum &lt;- summary(mcmc, what = 'hppm')

# print summary with 6-digit precision
print(hppm.sum, digits = 6)

# extract posterior means of the factor loadings in HPP model
alpha.mean &lt;- hppm.sum$alpha$m1$mean
print(alpha.mean)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
