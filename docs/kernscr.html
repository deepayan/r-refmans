<!DOCTYPE html><html><head><title>Help for package kernscr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kernscr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#kernscr-package'><p>kernscr: a package to perform Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks</p></a></li>
<li><a href='#Ahat'><p><code>Ahat</code> computation</p></a></li>
<li><a href='#cancer_pathways'><p>70 pathways from MSigDB c2CP</p></a></li>
<li><a href='#compute_all_tests'><p>Testing pathway risk association</p></a></li>
<li><a href='#dM'><p><code>dM</code></p></a></li>
<li><a href='#findRhoInterval'><p>Find an interval constraining the rho parameter for a non linear kernel</p></a></li>
<li><a href='#kernelEval'><p>Evaluation of kernels</p></a></li>
<li><a href='#lambda'><p>Lambda and its perturbation</p></a></li>
<li><a href='#M_vec'><p>M vector and its perturbation</p></a></li>
<li><a href='#PI_0'><p>PI_0</p></a></li>
<li><a href='#PI_1'><p>PI_2</p></a></li>
<li><a href='#PI_2'><p>PI_2</p></a></li>
<li><a href='#plot_kernscr_methodsplit'><p>Plotting functions used in the manuscript</p></a></li>
<li><a href='#sim_SCR_data'><p>Data Simulation Function</p></a></li>
<li><a href='#VTM'><p>VTM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Machine Score Test for Semi-Competing Risks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Boris P Hejblum &lt;boris.hejblum@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Kernel Machine Score Test for Pathway Analysis in the Presence of 
    Semi-Competing Risks. Method is detailed in: Neykov, Hejblum &amp; Sinnott (2018) 
    &lt;<a href="https://doi.org/10.1177%2F0962280216653427">doi:10.1177/0962280216653427</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, MASS, mvtnorm, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>readxl, org.Hs.eg.db</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/borishejblum/kernscr/issues">https://github.com/borishejblum/kernscr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-17 15:40:36 UTC; boris</td>
</tr>
<tr>
<td>Author:</td>
<td>Matey Neykov [aut],
  Boris P Hejblum [aut, cre],
  Jennifer A Sinnot [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-17 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='kernscr-package'>kernscr: a package to perform Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks</h2><span id='topic+kernscr-package'></span><span id='topic+kernscr'></span>

<h3>Description</h3>

<p>Kernel Machine Score Test for Pathway Analysis in the Presence of Semi-Competing Risks
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> kernscr</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-17</td>
</tr>
<tr>
 <td style="text-align: left;">
License:</td><td style="text-align: left;"> <a href="http://www.gnu.org/licenses/gpl-2.0.txt">GPL-2</a></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main function of the kernscr package is <code><a href="#topic+compute_all_tests">compute_all_tests</a></code>
</p>


<h3>Author(s)</h3>

<p>Matey Neykov, Boris P. Hejblum, Jennifer A. Sinnott
&mdash; Maintainer: Boris P. Hejblum
</p>


<h3>References</h3>

<p>Neykov M, Hejblum BP, Sinnot JA, Kernel Machine Score Test for
Pathway Analysis in the Presence of Semi-Competing Risks, <em>Stat Methods in Med Res</em>,
, 27(4): 1099-1114 (2018). &lt;doi: 10.1177/0962280216653427&gt;.
</p>

<hr>
<h2 id='Ahat'><code>Ahat</code> computation</h2><span id='topic+Ahat'></span>

<h3>Description</h3>

<p><code>Ahat</code> computation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ahat(all_times, failures, gamma_vec, U)
</code></pre>

<hr>
<h2 id='cancer_pathways'>70 pathways from MSigDB c2CP</h2><span id='topic+cancer_pathways'></span><span id='topic+vijver'></span>

<h3>Description</h3>

<p>70 pathways from MSigDB c2CP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("cancer_pathways")
</code></pre>


<h3>Format</h3>

<p>a list of 70 relevant pathways from an old version of MSigDB c2CP containing the Entrez IDs.
</p>


<h3>References</h3>

<p>MJ van de Vijver,YD He, LJ van't Veer, H Dai, AAM Hart, DW Voskuil,
A gene-expression signature as a predictor of survival in breast cancer,
<em>The New England Journal of Medicine</em>, 347(25):1999-2009, 2002.
</p>
<p>T Cai, G Tonini, X Lin, Kernel Machine Approach to Testing the
Significance of Multiple Genetic Markers for Risk Prediction, <em>Biometrics</em>,
67(3):975-986, 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("cancer_pathways")

if(interactive()){
##get the data from Vijver publication

#clinical data
import_xls_from_zip &lt;- function(urlPath, filename, zipname, skip=0){
 zipFile &lt;- paste0(zipname, ".zip")
 download.file(paste0(urlPath, zipFile), zipFile)
 unzip(zipFile, exdir="./temp_unzip")
 xlsFile &lt;- paste0("./temp_unzip/", filename, ".xls")
 res &lt;- readxl::read_xls(xlsFile, skip=skip)
 unlink(zipFile)
 unlink("./temp_unzip", recursive=TRUE)
 return(res)
}

BC_dat_clin &lt;- import_xls_from_zip2(urlPath="http://ccb.nki.nl/data/",
                                  filename="Table1_ClinicalData_Table",
                                  zipname="nejm_table1",
                                  skip=2
                                  )
BC_dat_clin &lt;- BC_dat_clin[order(BC_dat_clin$SampleID), ]
col2rmv &lt;- 1:ncol(BC_dat_clin)
BC_dat_clin$ID &lt;- paste0("S", BC_dat_clin$SampleID)
rownames(BC_dat_clin) &lt;- BC_dat_clin$ID
BC_dat_clin$evdeath &lt;- BC_dat_clin$EVENTdeath
BC_dat_clin$tsurv &lt;- BC_dat_clin$TIMEsurvival
BC_dat_clin$evmeta &lt;- BC_dat_clin$EVENTmeta
BC_dat_clin$tmeta&lt;- pmin(BC_dat_clin$TIMEsurvival, BC_dat_clin$TIMEmeta, na.rm=TRUE)
samples2rmv &lt;- c("S28", "S122", "S123", "S124", "S133", "S138", "S139", "S141", "S221", "S222",
                "S224", "S226", "S227", "S228", "S229", "S230", "S231", "S237", "S238", "S240",
                "S241", "S248", "S250", "S251", "S252", "S254", "S292", "S317", "S342", "S371",
                "S379", "S380", "S397", "S398", "S401")
BC_dat_clin &lt;- BC_dat_clin[-which(BC_dat_clin$ID %in% samples2rmv), -col2rmv]
head(BC_dat_clin)



#import genomics data
urlPath="http://ccb.nki.nl/data/"
zipFile &lt;- paste0("ZipFiles295Samples", ".zip")
download.file(paste0(urlPath, zipFile), zipFile)
unzip(zipFile, exdir="./temp_unzip")
unlink(zipFile)
unlink("./temp_unzip/Readme.txt", recursive=FALSE)
txtfiles &lt;- list.files("./temp_unzip/")
BC_dat_exp &lt;- NULL
for(f in txtfiles){
 temp_exp &lt;- read.delim(paste0("./temp_unzip/", f))
 if(f==txtfiles[1]){
   gene_id &lt;- as.character(temp_exp[-1, 1])
   gene_symbol &lt;- as.character(temp_exp[-1, 2])
 }
 temp_exp &lt;- temp_exp[-1, grep("Sample.", colnames(temp_exp))]
 colnames(temp_exp) &lt;- gsub("Sample.", "S", colnames(temp_exp))
 if(f==txtfiles[1]){
   BC_dat_exp &lt;- temp_exp
 }else{
   BC_dat_exp &lt;- cbind(BC_dat_exp, temp_exp)
 }
}
BC_dat_exp_all &lt;- cbind.data.frame("SYMBOL"=gene_symbol, BC_dat_exp[,  BC_dat_clin$ID])
unlink("./temp_unzip", recursive=TRUE)

# translating the pathways from Entrez ID to gene symbol
if (requireNamespace("org.Hs.eg.db", quietly = TRUE)){
 library(org.Hs.eg.db)
 x &lt;- org.Hs.egSYMBOL
 mapped_genes &lt;- mappedkeys(x)
 xx &lt;- as.list(x[mapped_genes])
 cancer_pathways_Symbol &lt;- lapply(cancer_pathways, function(v){unlist(xx[v])})
 sapply(cancer_pathways, function(x){length(intersect(x, rownames(BC_dat_exp)))/length(x)})
}
}

</code></pre>

<hr>
<h2 id='compute_all_tests'>Testing pathway risk association</h2><span id='topic+compute_all_tests'></span>

<h3>Description</h3>

<p>This functions computes p-values <code>frm</code> score tests of genetic pathway risk association in 5 different models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_all_tests(
  data,
  ind_gene = 7:ncol(data),
  num_perts = 1000,
  Ws = NULL,
  rho = NA,
  kernel = c("linear", "gaussian", "poly"),
  d = 2,
  pca_thres = 0.9,
  get_ptb_pvals = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_all_tests_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> of <code>N</code> rows and set up as the output from <code><a href="#topic+sim_SCR_data">sim_SCR_data</a></code> with columns:</p>

<ul>
<li><p><code>XR</code>: time to recurrence / death / censoring
</p>
</li>
<li><p><code>XD</code>: time to death / censoring
</p>
</li>
<li><p><code>DeltaR</code>: Indicator of censoring (0), recurrence (1), or death (2) for this earliest time <code>XR</code>
</p>
</li>
<li><p><code>DeltaD</code>: Indicator of censoring (0) or death (1)
</p>
</li>
<li><p><code>XPFS</code>: time to recurrence / death / censoring (=<code>XR</code>)
</p>
</li>
<li><p><code>DeltaPFS</code>: Indicator of censoring (0) or recurrence or death, whichever came first (1)
</p>
</li>
<li><p><code>Z_1,...,Z_P</code>: genomic variables
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_ind_gene">ind_gene</code></td>
<td>
<p>columns indices of genes in the pathway of interest. Default is <code>7:ncol(data)</code>).</p>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_num_perts">num_perts</code></td>
<td>
<p>number of perturbations used. Default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_ws">Ws</code></td>
<td>
<p>optional inputed perturbations, should be a vector of length <code>N x num_perts</code> containing
i.i.d. realization of a random variable with mean=0 and variance=1.</p>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_rho">rho</code></td>
<td>
<p>a vector of rhos, such as one found created from the range returned by <code><a href="#topic+findRhoInterval">findRhoInterval</a></code>,
used for tuning non-linear kernel. Only used if <code>kernel</code> is not <code>"linear"</code>. Default is <code>NA</code>.
Currently not available for use by user-defined kernels.</p>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_kernel">kernel</code></td>
<td>
<p>a character string indicating which kernel is used. Possible values (currently implemented) are
<code>"linear"</code>, <code>"gaussian"</code> or <code>"poly"</code>. Otherwise, this can also be a user defined kernel function.
See <code><a href="#topic+genericKernelEval">genericKernelEval</a></code>.</p>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_d">d</code></td>
<td>
<p>if <code>kernel</code> is <code>"poly"</code>, the polynomial power. Default is 2 (quadratic kernel).</p>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_pca_thres">pca_thres</code></td>
<td>
<p>a number between <code>0</code> and <code>1</code> giving the threshold to be used for PCA.
Default is <code>0.9</code>. If <code>NULL</code>, no PCA is performed.</p>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_get_ptb_pvals">get_ptb_pvals</code></td>
<td>
<p>a logical flag indicating whether perturbed p-values should be returned
as part of the results. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compute_all_tests_+3A_...">...</code></td>
<td>
<p>extra parameters to be passed to a user-defined kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a <code>vector</code> of p-values for 5 different models with names:</p>

<ul>
<li><p><code>"SCR"</code>: Semi-Competing Risks
</p>
</li>
<li><p><code>"PFS"</code>: Progression Free Survival
</p>
</li>
<li><p><code>"CR"</code>: Competing Risks
</p>
</li>
<li><p><code>"OS"</code>: Overall Survival
</p>
</li>
<li><p><code>"SCR_alt"</code>: SCR allowing different tuning parameters for the two event time processes
</p>
</li></ul>
<p> or else if <code>get_ptb_pvals</code> is <code>TRUE</code>, a <code>list</code> with 2 elements:</p>

<ul>
<li><p><code>"obs_pvals"</code>: a vector containing the observed p-values for each of the 5 models as described above
</p>
</li>
<li><p><code>"null_pvals_perts"</code>: a matrix of dimensions <code>num_perts x 5</code> containing the corresponding
perturbed p-values
</p>
</li></ul>



<h3>References</h3>

<p>Neykov M, Hejblum BP, Sinnot JA, Kernel Machine Score Test for Pathway Analysis in the
Presence of Semi-Competing Risks, submitted, 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First generate some Data
feat_m_fun &lt;- function(X){
 sin(X[,1]+X[,2]^2)-1
}
feat_d_fun &lt;-  function(X){
 (X[,4]-X[,5])^2/8
}
mydata &lt;- sim_SCR_data(data_size = 400, ncol_gene_mat = 20, feat_m = feat_m_fun,
                      feat_d = feat_d_fun, mu_cen = 40, cov=0.5)

#initial range
ind_gene &lt;- c(7:ncol(mydata))
my_rho_init &lt;- seq(0.01, 20, length=300)*length(ind_gene)
range(my_rho_init)

if(interactive()){
# compute the interval for rho
rho_set &lt;- findRhoInterval(tZ=t(mydata[,ind_gene]), rho_init = my_rho_init, kernel="gaussian")
rho_set
range(my_rho_init) # good to check that the interval produced here is strictly contained in rho_init
# otherwise, expand rho.init and rerun

rhos &lt;- exp(seq(log(rho_set[1]),log(rho_set[2]), length=50))

# run the tests with Gaussian kernel
compute_all_tests(data = mydata, num_perts=1000, rho=rhos, kernel="gaussian")
# run the tests with linear kernel
compute_all_tests(data=mydata, num_perts=1000, kernel="linear")
}

</code></pre>

<hr>
<h2 id='dM'><code>dM</code></h2><span id='topic+dM'></span>

<h3>Description</h3>

<p><code>dM</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dM(all_times, failures, gamma_vec, U)
</code></pre>

<hr>
<h2 id='findRhoInterval'>Find an interval constraining the rho parameter for a non linear kernel</h2><span id='topic+findRhoInterval'></span>

<h3>Description</h3>

<p>Find an interval constraining the rho parameter for a non linear kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findRhoInterval(
  tZ,
  rho_init = seq(0.01, 20, length = 300) * nrow(tZ),
  kernel = c("gaussian", "poly"),
  d = NA,
  rate_range = c(1.5, 4),
  pca_thres = 0.9,
  warning_suppress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findRhoInterval_+3A_tz">tZ</code></td>
<td>
<p>a <code>P x N</code> matrix of genomic covariates (i.e., the usual data array Z transposed)</p>
</td></tr>
<tr><td><code id="findRhoInterval_+3A_rho_init">rho_init</code></td>
<td>
<p>an initial large range of possible rhos, which will be considered to see if they are
reasonable tuning parameters for the kernel. Default is <code>seq(0.01, 20, length=300)*P</code>. See Details.</p>
</td></tr>
<tr><td><code id="findRhoInterval_+3A_kernel">kernel</code></td>
<td>
<p>character string specifying a nonlinear kernel. Currently supported options are:
<code>"gaussian"</code> or <code>"poly"</code></p>
</td></tr>
<tr><td><code id="findRhoInterval_+3A_d">d</code></td>
<td>
<p>if <code>kernel</code> is <code>"poly"</code>, the polynomial power (e.g. d=2 for quadratic kernel).
Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="findRhoInterval_+3A_rate_range">rate_range</code></td>
<td>
<p>a vector of length 2 indicating the range of alpha in the paper. Default is <code>c(1.5,4)</code>.</p>
</td></tr>
<tr><td><code id="findRhoInterval_+3A_pca_thres">pca_thres</code></td>
<td>
<p>a number between <code>0</code> and <code>1</code> giving the threshold to be used for PCA.
Default is <code>0.9</code>. If <code>NULL</code>, no PCA is performed.</p>
</td></tr>
<tr><td><code id="findRhoInterval_+3A_warning_suppress">warning_suppress</code></td>
<td>
<p>logical flag. Indicating whether the warnings should be suppress during
the linear model fitting step. Default is <code>TRUE</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will print <code>rho_init</code> range and the range of valid tuning parameters.
If that range butts up against either the upper or lower bound of <code>rho_init</code>, you can rerun this function
with a bigger <code>rho_init</code>.
</p>
<p>Finding the right tuning parameters includes a step of fitting a linear model which can fail
because some tuning parameters yield only one eigenvector. We want to eliminate those tuning parameters,
so this is OK. However, in case one want to suppress (numerous) annoying warning messages, use the
<code>warning_suppress</code> argument.
</p>


<h3>Value</h3>

<p>an upper and lower bound to look for rho
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First generate some Data
feat_m_fun &lt;- function(X){
 sin(X[,1]+X[,2]^2)-1
}
feat_d_fun &lt;-  function(X){
 (X[,4]-X[,5])^2/8
}
mydata &lt;- sim_SCR_data(data_size = 400, ncol_gene_mat = 20, feat_m = feat_m_fun,
                      feat_d = feat_d_fun, mu_cen = 30, cov=0.5)

#initial range
ind_gene &lt;- c(7:ncol(mydata))
my_rho_init &lt;- seq(0.01, 20, length=300)*length(ind_gene)
range(my_rho_init)

if(interactive()){
# compute the interval for rho
rho_set &lt;- findRhoInterval(tZ=t(mydata[,ind_gene]), rho_init = my_rho_init, kernel="gaussian")
rho_set
range(my_rho_init) # good to check that the interval produced here is strictly contained in rho_init
# otherwise, expand rho.init and rerun

#rhos &lt;- exp(seq(log(rho_set[1]),log(rho_set[2]), length=50))
}
</code></pre>

<hr>
<h2 id='kernelEval'>Evaluation of kernels</h2><span id='topic+kernelEval'></span><span id='topic+linKernelEval'></span><span id='topic+gaussKernelEval'></span><span id='topic+polyKernelEval'></span><span id='topic+genericKernelEval'></span><span id='topic+gaussKernelEval_multipleRhos'></span><span id='topic+polyKernelEval_multipleRhos'></span>

<h3>Description</h3>

<p>Evaluation of kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelEval(tZ, kernel = c("linear", "poly", "gaussian"), ...)

linKernelEval(tZ)

gaussKernelEval(tZ, sigma = 1)

polyKernelEval(tZ, a = 0, d = 2)

genericKernelEval(tZ, kernel_func, ...)

gaussKernelEval_multipleRhos(tZ, rho)

polyKernelEval_multipleRhos(tZ, rho, d = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernelEval_+3A_tz">tZ</code></td>
<td>
<p>a <code>P x N</code> matrix of genomic covariates (i.e., the usual data array Z transposed)</p>
</td></tr>
<tr><td><code id="kernelEval_+3A_kernel">kernel</code></td>
<td>
<p>which kernel is evaluated by <code>kerneval</code>. Possible values include currently implemented kernels
designated by a character string <code>"linear"</code>, <code>"poly"</code> and <code>"gaussian"</code>.
Otherwise can also be a user-defined function (see <code>kernel_func</code>).</p>
</td></tr>
<tr><td><code id="kernelEval_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to be passed to the evaluated kernel function.</p>
</td></tr>
<tr><td><code id="kernelEval_+3A_sigma">sigma</code></td>
<td>
<p>standard-deviation parameter for the <code>"gaussian"</code> kernel.</p>
</td></tr>
<tr><td><code id="kernelEval_+3A_a">a</code></td>
<td>
<p>TODO of the polynomial for the <code>"poly"</code>. Default is <code>0</code></p>
</td></tr>
<tr><td><code id="kernelEval_+3A_d">d</code></td>
<td>
<p>power of the polynomial.  Default is <code>2</code> (quadratic kernel).</p>
</td></tr>
<tr><td><code id="kernelEval_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a function, whose first argument should be <code>tZ</code></p>
</td></tr>
<tr><td><code id="kernelEval_+3A_rho">rho</code></td>
<td>
<p>either a single rho to evaluate the kernel at, or a vector of rhos</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kernelEval</code> works only for gaussian, polynomial and linear kernels currently.
</p>
<p><code>genericKernelEval</code>
</p>
<p>For <code>polyKernelEval_multipleRhos</code>, one should have <code>rho</code> &gt; 0 to get
basis of monomials up to degree <code>d</code>
</p>


<h3>Value</h3>

<p><code>kernelEval</code>, <code>linKernelEval</code>, <code>gaussKernelEval</code>, and <code>genericKernelEval</code>
return an <code>N x N</code> matrix with entries <code>K(Z[i,], Z[j,])</code> [persons i,j]
</p>
<p><code>gaussKernelEval_multipleRhos</code> and <code>polyKernelEval_multipleRhos</code> return
a matrix of dimension <code>Q x N^2</code>, where <code>Q</code> is the <code>length</code> of <code>rho</code>,
each row corresponds to a rho (puns!) to get the actual kernel matrix associated with a particular
value of rho, if output is <code>G</code>, take <code>matrix(G[i,], N)</code>
</p>

<hr>
<h2 id='lambda'>Lambda and its perturbation</h2><span id='topic+lambda'></span><span id='topic+lambda_pert'></span>

<h3>Description</h3>

<p>Lambda and its perturbation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(t, all_times, failures, gamma_vec, U)

lambda_pert(t, perturb_mat, all_times, failures, gamma_vec, U)
</code></pre>

<hr>
<h2 id='M_vec'>M vector and its perturbation</h2><span id='topic+M_vec'></span><span id='topic+M_vec_pert'></span>

<h3>Description</h3>

<p>M vector and its perturbation
</p>
<p>M vector perturbation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M_vec(t, all_times, failures, gamma_vec, U)

M_vec_pert(perturb_mat, t, all_times, failures, gamma_vec, U)
</code></pre>

<hr>
<h2 id='PI_0'>PI_0</h2><span id='topic+PI_0'></span>

<h3>Description</h3>

<p>PI_0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PI_0(t, all_times, gamma_vec, U)
</code></pre>

<hr>
<h2 id='PI_1'>PI_2</h2><span id='topic+PI_1'></span>

<h3>Description</h3>

<p>PI_2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PI_1(t, all_times, gamma_vec, U)
</code></pre>

<hr>
<h2 id='PI_2'>PI_2</h2><span id='topic+PI_2'></span>

<h3>Description</h3>

<p>PI_2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PI_2(t, all_times, gamma_vec, U)
</code></pre>

<hr>
<h2 id='plot_kernscr_methodsplit'>Plotting functions used in the manuscript</h2><span id='topic+plot_kernscr_methodsplit'></span><span id='topic+plot_kernscr_kernelsplit'></span>

<h3>Description</h3>

<p>Plotting functions used in the manuscript
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_kernscr_methodsplit(
  raw_melted,
  adj_melted,
  kernel,
  method,
  pathway_names = TRUE,
  title = NULL,
  raw_lower_threshold = round(log10(1/10000), 1),
  adj_lower_threshold = round(log10(1/10000 * 70), 1)
)

plot_kernscr_kernelsplit(
  raw_melted,
  adj_melted,
  kernel,
  method,
  pathway_names = TRUE,
  title = NULL,
  raw_lower_threshold = round(log10(1/10000), 1),
  adj_lower_threshold = NULL
)
</code></pre>

<hr>
<h2 id='sim_SCR_data'>Data Simulation Function</h2><span id='topic+sim_SCR_data'></span>

<h3>Description</h3>

<p>Data Simulation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_SCR_data(
  data_size,
  ncol_gene_mat,
  feat_m,
  feat_d,
  mu_cen,
  cov,
  lam_m = 1/15,
  lam_d = 1/20,
  norm_vcov = c(1, 0.5, 0.5, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_SCR_data_+3A_data_size">data_size</code></td>
<td>
<p>an integer giving the simulated sample size <code>N</code></p>
</td></tr>
<tr><td><code id="sim_SCR_data_+3A_ncol_gene_mat">ncol_gene_mat</code></td>
<td>
<p>an integer giving the simulated number of genomic covariates <code>P</code></p>
</td></tr>
<tr><td><code id="sim_SCR_data_+3A_feat_m">feat_m</code></td>
<td>
<p>a function that transforms the genomic features into the signal for the metastasis
process. This function should a matrix of dimensions <code>N X P</code> as its only argument.</p>
</td></tr>
<tr><td><code id="sim_SCR_data_+3A_feat_d">feat_d</code></td>
<td>
<p>a function that transforms the genomic features into the signal for the death
process. This function should a matrix of dimensions <code>N X P</code> as its only argument.</p>
</td></tr>
<tr><td><code id="sim_SCR_data_+3A_mu_cen">mu_cen</code></td>
<td>
<p>mean of the exponential censoring process</p>
</td></tr>
<tr><td><code id="sim_SCR_data_+3A_cov">cov</code></td>
<td>
<p>the correlation between the genomic covariates</p>
</td></tr>
<tr><td><code id="sim_SCR_data_+3A_lam_m">lam_m</code></td>
<td>
<p>baseline hazard constant for metastasis process. Default is <code>1/15</code>.</p>
</td></tr>
<tr><td><code id="sim_SCR_data_+3A_lam_d">lam_d</code></td>
<td>
<p>baseline hazard constant for death process. Default is <code>1/20</code>.</p>
</td></tr>
<tr><td><code id="sim_SCR_data_+3A_norm_vcov">norm_vcov</code></td>
<td>
<p>vector of length 4 of correlation between errors between the two processes on
the normal scale before being complementary-log-log-transformed. Default is <code>c(1,.5,.5,1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with columns:</p>

<ul>
<li><p><code>XR</code>: time to recurrence / death / censoring
</p>
</li>
<li><p><code>XD</code>: time to death / censoring
</p>
</li>
<li><p><code>DeltaR</code>: Indicator of censoring (0), recurrence (1), or death (2) for this earliest time <code>XR</code>
</p>
</li>
<li><p><code>DeltaD</code>: Indicator of censoring (0) or death (1)
</p>
</li>
<li><p><code>XPFS</code>: time to recurrence / death / censoring (=<code>XR</code>)
</p>
</li>
<li><p><code>DeltaPFS</code>: Indicator of censoring (0) or recurrence or death, whichever came first (1)
</p>
</li>
<li><p><code>Z_1,...,Z_P</code>: genomic variables
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>feat_m_fun &lt;- function(X){
 sin(X[,1]+X[,2]^2)-1
}
feat_d_fun &lt;-  function(X){
 (X[,4]-X[,5])^2/8
}
mydata &lt;- sim_SCR_data(data_size = 400, ncol_gene_mat = 20, feat_m = feat_m_fun,
                      feat_d = feat_d_fun, mu_cen = 30, cov=0.5)
head(mydata)
## how many experience both events
mean(mydata[,"DeltaR"]==1 &amp; mydata[,"DeltaD"]==1)
## how many only recur
mean(mydata[,"DeltaR"]==1 &amp; mydata[,"DeltaD"]==0)
## how many only die
mean(mydata[,"DeltaR"]==2 &amp; mydata[,"DeltaD"]==1)
## how many are censored
mean(mydata[,"DeltaR"]==0 &amp; mydata[,"DeltaD"]==0)


</code></pre>

<hr>
<h2 id='VTM'>VTM</h2><span id='topic+VTM'></span>

<h3>Description</h3>

<p>Repeats a vector as identical rows of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VTM(vc, dm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VTM_+3A_vc">vc</code></td>
<td>
<p>vector to be repeated</p>
</td></tr>
<tr><td><code id="VTM_+3A_dm">dm</code></td>
<td>
<p>number of times that <code>vc</code> should be repeated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of <code>dm</code> rows
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
