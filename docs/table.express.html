<!DOCTYPE html><html><head><title>Help for package table.express</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {table.express}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#table.express-package'><p>Building 'data.table' expressions with data manipulation verbs</p></a></li>
<li><a href='#arrange-table.express'><p>Arrange rows</p></a></li>
<li><a href='#chain'><p>Chain</p></a></li>
<li><a href='#distinct-table.express'><p>Rows with distinct combinations of columns</p></a></li>
<li><a href='#EagerExprBuilder'><p>Eager frame expression builder</p></a></li>
<li><a href='#end_expr'><p>End and evaluate expression</p></a></li>
<li><a href='#ExprBuilder'><p>Frame expression builder</p></a></li>
<li><a href='#extrema_by'><p>Find rows with extrema in specific columns</p></a></li>
<li><a href='#filter_on'><p>Filter with secondary indices</p></a></li>
<li><a href='#filter_sd'><p>Filter subset of data</p></a></li>
<li><a href='#filter-table.express'><p>Filter rows</p></a></li>
<li><a href='#frame_append'><p>Append expressions to the frame</p></a></li>
<li><a href='#group_by-table.express'><p>Grouping clauses</p></a></li>
<li><a href='#joins'><p>Joining verbs</p></a></li>
<li><a href='#key_by'><p>Set key to group by</p></a></li>
<li><a href='#mutate_sd'><p>Mutate subset of data</p></a></li>
<li><a href='#mutate-table.express'><p>Add or update columns</p></a></li>
<li><a href='#nest_expr'><p>Nest expressions as a functional chain</p></a></li>
<li><a href='#order_by-table.express'><p>Order by clause</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#select-table.express'><p>Select clause</p></a></li>
<li><a href='#start_expr'><p>Start expression</p></a></li>
<li><a href='#summarize-table.express'><p>Summarize columns</p></a></li>
<li><a href='#transmute_sd'><p>Transmute subset of data</p></a></li>
<li><a href='#transmute-table.express'><p>Compute new columns</p></a></li>
<li><a href='#where-table.express'><p>Where clause</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Build 'data.table' Expressions with Data Manipulation Verbs</td>
</tr>
<tr>
<td>Description:</td>
<td>A specialization of 'dplyr' data manipulation verbs that parse and build expressions
    which are ultimately evaluated by 'data.table', letting it handle all optimizations. A set of
    additional verbs is also provided to facilitate some common operations on a subset of the data.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, utils, data.table (&ge; 1.9.8), dplyr, magrittr,
R6, rlang (&ge; 0.3.1), tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rex, rmarkdown, testthat</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-02</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/asardaes/table.express/issues">https://github.com/asardaes/table.express/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL-2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://asardaes.github.io/table.express/">https://asardaes.github.io/table.express/</a>,
<a href="https://github.com/asardaes/table.express">https://github.com/asardaes/table.express</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'DELIMITERS-chain.R' 'DELIMITERS-end_expr.R'
'DELIMITERS-start_expr.R' 'R6-ExprBuilder.R'
'R6-EagerExprBuilder.R' 'UTILS-frame_append.R' 'UTILS-joins.R'
'UTILS-misc.R' 'UTILS-nest_expr.R' 'UTILS-tidyselect.R'
'VERBS-anti_join.R' 'VERBS-arrange.R' 'VERBS-distinct.R'
'VERBS-filter.R' 'VERBS-filter_on.R' 'VERBS-filter_sd.R'
'VERBS-full_join.R' 'VERBS-group_by.R' 'VERBS-inner_join.R'
'VERBS-key_by.R' 'VERBS-left_join.R' 'VERBS-max_by.R'
'VERBS-min_by.R' 'pkg.R' 'VERBS-mutate.R' 'VERBS-mutate_join.R'
'VERBS-mutate_sd.R' 'VERBS-order_by.R' 'VERBS-right_join.R'
'VERBS-select.R' 'VERBS-semi_join.R' 'VERBS-summarize.R'
'VERBS-transmute.R' 'VERBS-transmute_sd.R' 'VERBS-where.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-02 22:14:32 UTC; oso</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexis Sarda-Espinosa [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexis Sarda-Espinosa &lt;alexis.sarda@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-02 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='table.express-package'>Building 'data.table' expressions with data manipulation verbs</h2><span id='topic+table.express'></span><span id='topic+table.express-package'></span>

<h3>Description</h3>

<p>A specialization of <code><a href="dplyr.html#topic+dplyr-package">dplyr</a></code> verbs, as well as a set of custom ones, that
build expressions that can be used within a <code><a href="data.table.html#topic+data.table">data.table</a></code>'s
frame.
</p>


<h3>Note</h3>

<p>Note that since version 0.3.0, it is not possible to load <span class="pkg">table.express</span> and <span class="pkg">dtplyr</span> at
the same time, since they define the same <code>data.table</code> methods for many <span class="pkg">dplyr</span> generics.
</p>
<p>Bearing in mind that <code>data.table</code>s are also <code>data.frame</code>s, we have to consider that other
packages may uses <code>dplyr</code> internally without importing <code>data.table</code>. Since <code>dplyr</code>'s methods are
generic, calls to these methods in such packages would fail. The functions in this package try to
detect when this happens and delegate to the <code>data.frame</code> methods with a warning, which can be
safely ignored if you know that the error originates from a package that is not meant to work
with <code>data.table</code>. To avoid the warning, use <code>options(table.express.warn.cedta = FALSE)</code>.
</p>
<p>This software package was developed independently of any organization or institution that is or
has been associated with the author.
</p>


<h3>Author(s)</h3>

<p>Alexis Sarda-Espinosa
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://asardaes.github.io/table.express/">https://asardaes.github.io/table.express/</a>
</p>
</li>
<li> <p><a href="https://github.com/asardaes/table.express">https://github.com/asardaes/table.express</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/asardaes/table.express/issues">https://github.com/asardaes/table.express/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>require("data.table")

data("mtcars")

DT &lt;- as.data.table(mtcars)

# ====================================================================================
# Simple dplyr-like transformations

DT %&gt;%
    group_by(cyl) %&gt;%
    filter(vs == 0, am == 1) %&gt;%
    transmute(mean_mpg = mean(mpg)) %&gt;%
    arrange(-cyl)

# Equivalent to previous
DT %&gt;%
    start_expr %&gt;%
    transmute(mean_mpg = mean(mpg)) %&gt;%
    where(vs == 0, am == 1) %&gt;%
    group_by(cyl) %&gt;%
    order_by(-cyl) %&gt;%
    end_expr

# Modification by reference
DT %&gt;%
    where(gear %% 2 != 0, carb %% 2 == 0) %&gt;%
    mutate(wt_squared = wt ^ 2)

print(DT)

# Deletion by reference
DT %&gt;%
    mutate(wt_squared = NULL) %&gt;%
    print

# Support for tidyslect helpers

DT %&gt;%
    select(ends_with("t"))

# ====================================================================================
# Helpers to transform a subset of data

# Like DT[, (whole) := lapply(.SD, as.integer), .SDcols = whole]
whole &lt;- names(DT)[sapply(DT, function(x) { all(x %% 1 == 0) })]
DT %&gt;%
    mutate_sd(as.integer, .SDcols = whole)

sapply(DT, class)

# Like DT[, lapply(.SD, fun), .SDcols = ...]
DT %&gt;%
    transmute_sd((.COL - mean(.COL)) / sd(.COL),
                 .SDcols = setdiff(names(DT), whole))

# Filter several with the same condition
DT %&gt;%
    filter_sd(.COL == 1, .SDcols = c("vs", "am"))

# Using secondary indices, i.e. DT[.(4, 5), on = .(cyl, gear)]
DT %&gt;%
    filter_on(cyl = 4, gear = 5) # note we don't use ==

scale_undim &lt;- function(...) {
    as.numeric(scale(...)) # remove dimensions
}

# Chaining
DT %&gt;%
    start_expr %&gt;%
    mutate_sd(as.integer, .SDcols = whole) %&gt;%
    chain %&gt;%
    filter_sd(.COL == 1, .SDcols = c("vs", "am"), .collapse = `|`) %&gt;%
    transmute_sd(scale_undim, .SDcols = !is.integer(.COL)) %&gt;%
    end_expr

# The previous is quivalent to
DT[, (whole) := lapply(.SD, as.integer), .SDcols = whole
   ][vs == 1 | am == 1,
     lapply(.SD, scale_undim),
     .SDcols = names(DT)[sapply(DT, Negate(is.integer))]]

# Alternative to keep all columns (*copying* non-scaled ones)
scale_non_integers &lt;- function(x) {
    if (is.integer(x)) x else scale_undim(x)
}

DT %&gt;%
    filter_sd(.COL == 1, .SDcols = c("vs", "am"), .collapse = `|`) %&gt;%
    transmute_sd(everything(), scale_non_integers)

# Without copying non-scaled
DT %&gt;%
    where(vs == 1 | am == 1) %&gt;%
    mutate_sd(scale, .SDcols = names(DT)[sapply(DT, Negate(is.integer))])

print(DT)
</code></pre>

<hr>
<h2 id='arrange-table.express'>Arrange rows</h2><span id='topic+arrange-table.express'></span><span id='topic+arrange.ExprBuilder'></span><span id='topic+arrange.data.table'></span>

<h3>Description</h3>

<p>Alias for <a href="#topic+order_by-table.express">order_by-table.express</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
arrange(.data, ...)

## S3 method for class 'data.table'
arrange(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange-table.express_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="arrange-table.express_+3A_...">...</code></td>
<td>
<p>See <a href="#topic+order_by-table.express">order_by-table.express</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>

<hr>
<h2 id='chain'>Chain</h2><span id='topic+chain'></span><span id='topic+chain.ExprBuilder'></span>

<h3>Description</h3>

<p>Build a chain of similar objects/operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain(.data, ...)

## S3 method for class 'ExprBuilder'
chain(.data, ..., .parent_env = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain_+3A_.data">.data</code></td>
<td>
<p>Object to be chained.</p>
</td></tr>
<tr><td><code id="chain_+3A_...">...</code></td>
<td>
<p>Arguments for the specific methods.</p>
</td></tr>
<tr><td><code id="chain_+3A_.parent_env">.parent_env</code></td>
<td>
<p>See <code><a href="#topic+end_expr">end_expr()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chaining for <a href="#topic+ExprBuilder">ExprBuilder</a> is equivalent to calling <code><a href="#topic+end_expr">end_expr()</a></code> followed by <code><a href="#topic+start_expr">start_expr()</a></code>.
The ellipsis (<code>...</code>) is passed to both functions.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>

<hr>
<h2 id='distinct-table.express'>Rows with distinct combinations of columns</h2><span id='topic+distinct-table.express'></span><span id='topic+distinct.ExprBuilder'></span><span id='topic+distinct.data.table'></span>

<h3>Description</h3>

<p>Rows with distinct combinations of columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
distinct(
  .data,
  ...,
  .keep = TRUE,
  .n = 1L,
  .parse = getOption("table.express.parse", FALSE)
)

## S3 method for class 'data.table'
distinct(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct-table.express_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="distinct-table.express_+3A_...">...</code></td>
<td>
<p>Which columns to use to determine uniqueness.</p>
</td></tr>
<tr><td><code id="distinct-table.express_+3A_.keep">.keep</code></td>
<td>
<p>See details below.</p>
</td></tr>
<tr><td><code id="distinct-table.express_+3A_.n">.n</code></td>
<td>
<p>Indices of rows to return <em>for each</em> unique combination of the chosen columns. See
details.</p>
</td></tr>
<tr><td><code id="distinct-table.express_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>.keep = TRUE</code> (the default), the columns not mentioned in <code>...</code> are also kept. However, if
a new column is created in one of the expressions therein, <code>.keep</code> can also be set to a character
vector containing the names of <em>all</em> the columns that should be in the result in addition to the
ones mentioned in <code>...</code>. See the examples.
</p>
<p>The value of <code>.n</code> is only relevant when <code>.keep</code> is <em>not</em> <code>FALSE</code>. It is used to subset <code>.SD</code> in
the built <code>data.table</code> expression. For example, we could get 2 rows per combination by setting
<code>.n</code> to <code>1:2</code>, or get the last row instead of the first by using <code>.N</code>. If more than one index is
used, and not enough rows are found, some rows will have <code>NA</code>. Do note that, at least as of
version 1.12.2 of <code>data.table</code>, only expressions with single indices are internally optimized.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

# compare with .keep = TRUE
data.table::as.data.table(mtcars) %&gt;%
    distinct(amvs = am + vs, .keep = names(mtcars))

</code></pre>

<hr>
<h2 id='EagerExprBuilder'>Eager frame expression builder</h2><span id='topic+EagerExprBuilder'></span>

<h3>Description</h3>

<p>Like <a href="#topic+ExprBuilder">ExprBuilder</a>, but eager in some regards. This shouldn't be used directly.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ExprBuilder">table.express::ExprBuilder</a></code> -&gt; <code>EagerExprBuilder</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EagerExprBuilder-new"><code>EagerExprBuilder$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EagerExprBuilder-chain"><code>EagerExprBuilder$chain()</code></a>
</p>
</li>
<li> <p><a href="#method-EagerExprBuilder-chain_if_set"><code>EagerExprBuilder$chain_if_set()</code></a>
</p>
</li>
<li> <p><a href="#method-EagerExprBuilder-clone"><code>EagerExprBuilder$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="table.express" data-topic="ExprBuilder" data-id="eval"><a href='../../table.express/html/ExprBuilder.html#method-ExprBuilder-eval'><code>table.express::ExprBuilder$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="table.express" data-topic="ExprBuilder" data-id="print"><a href='../../table.express/html/ExprBuilder.html#method-ExprBuilder-print'><code>table.express::ExprBuilder$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="table.express" data-topic="ExprBuilder" data-id="seek_and_nestroy"><a href='../../table.express/html/ExprBuilder.html#method-ExprBuilder-seek_and_nestroy'><code>table.express::ExprBuilder$seek_and_nestroy()</code></a></span></li>
<li><span class="pkg-link" data-pkg="table.express" data-topic="ExprBuilder" data-id="set_by"><a href='../../table.express/html/ExprBuilder.html#method-ExprBuilder-set_by'><code>table.express::ExprBuilder$set_by()</code></a></span></li>
<li><span class="pkg-link" data-pkg="table.express" data-topic="ExprBuilder" data-id="set_i"><a href='../../table.express/html/ExprBuilder.html#method-ExprBuilder-set_i'><code>table.express::ExprBuilder$set_i()</code></a></span></li>
<li><span class="pkg-link" data-pkg="table.express" data-topic="ExprBuilder" data-id="set_j"><a href='../../table.express/html/ExprBuilder.html#method-ExprBuilder-set_j'><code>table.express::ExprBuilder$set_j()</code></a></span></li>
<li><span class="pkg-link" data-pkg="table.express" data-topic="ExprBuilder" data-id="tidy_select"><a href='../../table.express/html/ExprBuilder.html#method-ExprBuilder-tidy_select'><code>table.express::ExprBuilder$tidy_select()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-EagerExprBuilder-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>EagerExprBuilder$new(DT, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>DT</code></dt><dd><p>A <a href="data.table.html#topic+data.table-class">data.table::data.table</a>.</p>
</dd>
<dt><code>...</code></dt><dd><p>Ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EagerExprBuilder-chain"></a>



<h4>Method <code>chain()</code></h4>

<p>Override to abort if chaining is attempted.
</p>


<h5>Usage</h5>

<div class="r"><pre>EagerExprBuilder$chain(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EagerExprBuilder-chain_if_set"></a>



<h4>Method <code>chain_if_set()</code></h4>

<p>Override to abort if chaining is attempted.
</p>


<h5>Usage</h5>

<div class="r"><pre>EagerExprBuilder$chain_if_set(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EagerExprBuilder-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>EagerExprBuilder$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='end_expr'>End and evaluate expression</h2><span id='topic+end_expr'></span><span id='topic+end_expr.ExprBuilder'></span>

<h3>Description</h3>

<p>Finish the expression-building process and evaluate it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>end_expr(.data, ...)

## S3 method for class 'ExprBuilder'
end_expr(.data, ..., .by_ref = TRUE, .parent_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="end_expr_+3A_.data">.data</code></td>
<td>
<p>The expression.</p>
</td></tr>
<tr><td><code id="end_expr_+3A_...">...</code></td>
<td>
<p>Arguments for the specific methods.</p>
</td></tr>
<tr><td><code id="end_expr_+3A_.by_ref">.by_ref</code></td>
<td>
<p>If <code>FALSE</code>, <code><a href="data.table.html#topic+copy">data.table::copy()</a></code> is used before evaluation.</p>
</td></tr>
<tr><td><code id="end_expr_+3A_.parent_env">.parent_env</code></td>
<td>
<p>Optionally, the <em>enclosing</em> environment of the expression's evaluation
environment. Defaults to the caller environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+ExprBuilder">ExprBuilder</a> method returns a <a href="data.table.html#topic+data.table-class">data.table::data.table</a>.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>

<hr>
<h2 id='ExprBuilder'>Frame expression builder</h2><span id='topic+ExprBuilder'></span>

<h3>Description</h3>

<p>Build an expression that will be used inside a <a href="data.table.html#topic+data.table-class">data.table::data.table</a>'s frame. This
shouldn't be used directly.
</p>


<h3>Value</h3>

<p>In general, a modified <code>self</code> with extended expression.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>appends</code></dt><dd><p>Extra expressions that go at the end.</p>
</dd>
<dt><code>expr</code></dt><dd><p>The final expression that can be evaluated with <code><a href="base.html#topic+eval">base::eval()</a></code> or
<code><a href="rlang.html#topic+eval_bare">rlang::eval_bare()</a></code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ExprBuilder-new"><code>ExprBuilder$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-set_i"><code>ExprBuilder$set_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-set_j"><code>ExprBuilder$set_j()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-set_by"><code>ExprBuilder$set_by()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-chain"><code>ExprBuilder$chain()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-chain_if_set"><code>ExprBuilder$chain_if_set()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-seek_and_nestroy"><code>ExprBuilder$seek_and_nestroy()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-eval"><code>ExprBuilder$eval()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-tidy_select"><code>ExprBuilder$tidy_select()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-print"><code>ExprBuilder$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ExprBuilder-clone"><code>ExprBuilder$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ExprBuilder-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$new(
  DT,
  dt_pronouns = list(),
  nested = list(),
  verbose = getOption("table.express.verbose", FALSE)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>DT</code></dt><dd><p>A <a href="data.table.html#topic+data.table-class">data.table::data.table</a>.</p>
</dd>
<dt><code>dt_pronouns, nested</code></dt><dd><p>Internal parameters for joins.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Print more information during the process of building expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-set_i"></a>



<h4>Method <code>set_i()</code></h4>

<p>Set the <code>i</code> clause expression(s), starting a new frame if the current
one already has said expression set.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$set_i(value, chain_if_needed)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>A captured expression.</p>
</dd>
<dt><code>chain_if_needed</code></dt><dd><p>Whether chaining is allowed during this step.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-set_j"></a>



<h4>Method <code>set_j()</code></h4>

<p>Like <code>set_i</code> but for the <code>j</code> clause.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$set_j(value, chain_if_needed)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>A captured expression.</p>
</dd>
<dt><code>chain_if_needed</code></dt><dd><p>Whether chaining is allowed during this step.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-set_by"></a>



<h4>Method <code>set_by()</code></h4>

<p>Set the <code>by</code> clause expression.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$set_by(value, chain_if_needed)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>A captured expression.</p>
</dd>
<dt><code>chain_if_needed</code></dt><dd><p>Whether chaining is allowed during this step.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-chain"></a>



<h4>Method <code>chain()</code></h4>

<p>By default, start a new expression with the current one as its
parent. If <code>type = "pronoun"</code>, <code>dt</code> is used to start a new expression
that joins the current one.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$chain(type = "frame", next_dt, parent_env, to_eager = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>One of &quot;frame&quot;, &quot;pronoun&quot;.</p>
</dd>
<dt><code>next_dt</code></dt><dd><p>Next data table when chaining pronoun.</p>
</dd>
<dt><code>parent_env</code></dt><dd><p>Where to evaluate current expression when chaining
pronoun.</p>
</dd>
<dt><code>to_eager</code></dt><dd><p>Whether or not to use an <a href="#topic+EagerExprBuilder">EagerExprBuilder</a> in the
new chain</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-chain_if_set"></a>



<h4>Method <code>chain_if_set()</code></h4>

<p>Chain if any clause values are already set.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$chain_if_set(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Clause values.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-seek_and_nestroy"></a>



<h4>Method <code>seek_and_nestroy()</code></h4>

<p>Helper for <code>nest_expr</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$seek_and_nestroy(.exprs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>.exprs</code></dt><dd><p>List of expressions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-eval"></a>



<h4>Method <code>eval()</code></h4>

<p>Evaluate the final expression with <code>parent_env</code> as the enclosing
environment. If <code>by_ref = FALSE</code>, <code><a href="data.table.html#topic+copy">data.table::copy()</a></code> is called
before. The ellipsis' contents are assigned to the expression's
evaluation environment.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$eval(parent_env, by_ref, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parent_env</code></dt><dd><p>Enclosing environment.</p>
</dd>
<dt><code>by_ref</code></dt><dd><p>Flag to control deep copies.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional variables for the evaluation environment.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-tidy_select"></a>



<h4>Method <code>tidy_select()</code></h4>

<p>Evaluate a <code>tidyselect</code> call using the currently captured table.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$tidy_select(select_expr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>select_expr</code></dt><dd><p>The selection expression.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints the built <code>expr</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExprBuilder-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExprBuilder$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='extrema_by'>Find rows with extrema in specific columns</h2><span id='topic+extrema_by'></span><span id='topic+max_by'></span><span id='topic+max_by.ExprBuilder'></span><span id='topic+max_by.data.table'></span><span id='topic+min_by'></span><span id='topic+min_by.ExprBuilder'></span><span id='topic+min_by.data.table'></span>

<h3>Description</h3>

<p>Find rows with maxima/minima in given columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_by(.data, .col, ...)

## S3 method for class 'ExprBuilder'
max_by(
  .data,
  .col,
  ...,
  .some = FALSE,
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'data.table'
max_by(.data, .col, ..., .expr = FALSE)

min_by(.data, .col, ...)

## S3 method for class 'ExprBuilder'
min_by(
  .data,
  .col,
  ...,
  .some = FALSE,
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'data.table'
min_by(.data, .col, ..., .expr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrema_by_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="extrema_by_+3A_.col">.col</code></td>
<td>
<p>A character vector indicating the columns that will be searched for extrema.</p>
</td></tr>
<tr><td><code id="extrema_by_+3A_...">...</code></td>
<td>
<p>Optionally, columns to group by, either as characters or symbols.</p>
</td></tr>
<tr><td><code id="extrema_by_+3A_.some">.some</code></td>
<td>
<p>If <code>TRUE</code> the rows where <em>any</em> of the columns specified in <code>.col</code> have extrema are
returned.</p>
</td></tr>
<tr><td><code id="extrema_by_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="extrema_by_+3A_.expr">.expr</code></td>
<td>
<p>If the input is a <code>data.table</code> and <code>.expr</code> is <code>TRUE</code>, an instance of
<a href="#topic+EagerExprBuilder">EagerExprBuilder</a> will be returned. Useful if you want to add clauses to <code>j</code>, e.g. with
<a href="#topic+mutate-table.express">mutate-table.express</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These verbs implement the idiom shown <a href="https://stackoverflow.com/q/16573995/5793905">here</a> by
leveraging <code><a href="#topic+nest_expr">nest_expr()</a></code>. The whole nested expression is assigned to <code>i</code> in the <code>data.table</code>'s
frame. It is probably a good idea to use this on a frame that has no other frames preceding it
in the current expression, given that <code><a href="#topic+nest_expr">nest_expr()</a></code> uses the captured <code>data.table</code>, so consider
using <code><a href="#topic+chain">chain()</a></code> when needed.
</p>
<p>Several columns can be specified in <code>.col</code>, and depending on the value of <code>.some</code>, the rows with
all or some extrema are returned, using <code>&amp;</code> or <code>|</code> respectively. Depending on your data, using
more than one column might not make sense, resulting in an empty <code>data.table</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    max_by("mpg", "vs")

</code></pre>

<hr>
<h2 id='filter_on'>Filter with secondary indices</h2><span id='topic+filter_on'></span><span id='topic+filter_on.ExprBuilder'></span><span id='topic+filter_on.data.table'></span>

<h3>Description</h3>

<p>Helper to filter specifying the <code>on</code> part of the <a href="data.table.html#topic+data.table">data.table::data.table</a> query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_on(.data, ...)

## S3 method for class 'ExprBuilder'
filter_on(
  .data,
  ...,
  which = FALSE,
  nomatch = getOption("datatable.nomatch"),
  mult = "all",
  .negate = FALSE,
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'data.table'
filter_on(.data, ..., .expr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_on_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="filter_on_+3A_...">...</code></td>
<td>
<p>Key-value pairs, maybe with empty keys if the <code>data.table</code> already has them. See
details.</p>
</td></tr>
<tr><td><code id="filter_on_+3A_which">which</code>, <code id="filter_on_+3A_nomatch">nomatch</code>, <code id="filter_on_+3A_mult">mult</code></td>
<td>
<p>See <a href="data.table.html#topic+data.table">data.table::data.table</a>.</p>
</td></tr>
<tr><td><code id="filter_on_+3A_.negate">.negate</code></td>
<td>
<p>Whether to negate the expression and search only for rows that don't contain the
given values.</p>
</td></tr>
<tr><td><code id="filter_on_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="filter_on_+3A_.expr">.expr</code></td>
<td>
<p>If the input is a <code>data.table</code> and <code>.expr</code> is <code>TRUE</code>, an instance of
<a href="#topic+EagerExprBuilder">EagerExprBuilder</a> will be returned. Useful if you want to add clauses to <code>j</code>, e.g. with
<a href="#topic+mutate-table.express">mutate-table.express</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key-value pairs in '...' are processed as follows:
</p>

<ul>
<li><p> The names are used as <code>on</code> in the <code>data.table</code> frame. If any name is empty, <code>on</code> is left
missing.
</p>
</li>
<li><p> The values are packed in a list and used as <code>i</code> in the <code>data.table</code> frame.
</p>
</li></ul>

<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    filter_on(cyl = 4, gear = 5)

</code></pre>

<hr>
<h2 id='filter_sd'>Filter subset of data</h2><span id='topic+filter_sd'></span><span id='topic+filter_sd.ExprBuilder'></span><span id='topic+filter_sd.data.table'></span>

<h3>Description</h3>

<p>Helper to filter rows with the same condition applied to a subset of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_sd(.data, .SDcols, .how = Negate(is.na), ...)

## S3 method for class 'ExprBuilder'
filter_sd(
  .data,
  .SDcols,
  .how = Negate(is.na),
  ...,
  which,
  .collapse = `&amp;`,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE),
  .caller_env_n = 1L
)

## S3 method for class 'data.table'
filter_sd(.data, ..., .expr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_sd_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_.sdcols">.SDcols</code></td>
<td>
<p>See <a href="data.table.html#topic+data.table">data.table::data.table</a> and the details here.</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_.how">.how</code></td>
<td>
<p>The filtering function or predicate.</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_...">...</code></td>
<td>
<p>Possibly more arguments for <code>.how</code>.</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_which">which</code></td>
<td>
<p>Passed to <a href="data.table.html#topic+data.table">data.table::data.table</a>.</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_.collapse">.collapse</code></td>
<td>
<p>See <a href="#topic+where-table.express">where-table.express</a>.</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_.caller_env_n">.caller_env_n</code></td>
<td>
<p>Internal. Passed to <code><a href="rlang.html#topic+stack">rlang::caller_env()</a></code> to find the function specified in
<code>.how</code> and <a href="rlang.html#topic+call_standardise">standardize</a> its call.</p>
</td></tr>
<tr><td><code id="filter_sd_+3A_.expr">.expr</code></td>
<td>
<p>If the input is a <code>data.table</code> and <code>.expr</code> is <code>TRUE</code>, an instance of
<a href="#topic+EagerExprBuilder">EagerExprBuilder</a> will be returned. Useful if you want to add clauses to <code>j</code>, e.g. with
<a href="#topic+mutate-table.express">mutate-table.express</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds/chains an <code>i</code> expression that will be evaluated by <a href="data.table.html#topic+data.table">data.table::data.table</a>,
and it supports the <code>.COL</code> pronoun and lambdas as formulas. The <code>.how</code> condition is applied to
all <code>.SDcols</code>.
</p>
<p>Additionally, <code>.SDcols</code> supports:
</p>

<ul>
<li> <p><a href="tidyselect.html#topic+language">tidyselect::select_helpers</a>
</p>
</li>
<li><p> A predicate using the <code>.COL</code> pronoun that should return a single logical when <code>.COL</code> is
replaced by a <em>column</em> of the data.
</p>
</li>
<li><p> A formula using <code>.</code> or <code>.x</code> instead of the aforementioned <code>.COL</code>.
</p>
</li></ul>

<p>The caveat is that the expression is evaluated eagerly, i.e. with the currently captured
<code>data.table</code>. Consider using <code><a href="#topic+chain">chain()</a></code> to explicitly capture intermediate results as actual
<code>data.table</code>s.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    filter_sd(c("vs", "am"), ~ .x == 1)

</code></pre>

<hr>
<h2 id='filter-table.express'>Filter rows</h2><span id='topic+filter-table.express'></span><span id='topic+filter.ExprBuilder'></span><span id='topic+filter.data.table'></span>

<h3>Description</h3>

<p>Filter rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
filter(.data, ..., .preserve)

## S3 method for class 'data.table'
filter(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter-table.express_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="filter-table.express_+3A_...">...</code></td>
<td>
<p>See <a href="#topic+where-table.express">where-table.express</a>.</p>
</td></tr>
<tr><td><code id="filter-table.express_+3A_.preserve">.preserve</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+ExprBuilder">ExprBuilder</a> method is an alias for <a href="#topic+where-table.express">where-table.express</a>.
</p>
<p>The <a href="data.table.html#topic+data.table-class">data.table::data.table</a> method works eagerly like <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>

<hr>
<h2 id='frame_append'>Append expressions to the frame</h2><span id='topic+frame_append'></span>

<h3>Description</h3>

<p>Add named expressions for the <a href="data.table.html#topic+data.table-class">data.table::data.table</a> frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame_append(.data, ..., .parse = getOption("table.express.parse", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frame_append_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="frame_append_+3A_...">...</code></td>
<td>
<p>Expressions to add to the frame.</p>
</td></tr>
<tr><td><code id="frame_append_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data.table::data.table() %&gt;%
    start_expr %&gt;%
    frame_append(anything = "goes")

</code></pre>

<hr>
<h2 id='group_by-table.express'>Grouping clauses</h2><span id='topic+group_by-table.express'></span><span id='topic+group_by.ExprBuilder'></span><span id='topic+group_by.data.table'></span>

<h3>Description</h3>

<p>Grouping by columns of a <a href="data.table.html#topic+data.table">data.table::data.table</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
group_by(
  .data,
  ...,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'data.table'
group_by(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by-table.express_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="group_by-table.express_+3A_...">...</code></td>
<td>
<p>Clause for grouping on columns. The <code>by</code> inside the <code>data.table</code>'s frame.</p>
</td></tr>
<tr><td><code id="group_by-table.express_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="group_by-table.express_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Everything in <code>...</code> will be wrapped in a call to <code>list</code>.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    start_expr %&gt;%
    group_by(cyl, gear)

</code></pre>

<hr>
<h2 id='joins'>Joining verbs</h2><span id='topic+joins'></span><span id='topic+anti_join.ExprBuilder'></span><span id='topic+anti_join.data.table'></span><span id='topic+full_join.ExprBuilder'></span><span id='topic+full_join.data.table'></span><span id='topic+inner_join.ExprBuilder'></span><span id='topic+inner_join.data.table'></span><span id='topic+left_join.ExprBuilder'></span><span id='topic+left_join.data.table'></span><span id='topic+mutate_join'></span><span id='topic+mutate_join.ExprBuilder'></span><span id='topic+mutate_join.EagerExprBuilder'></span><span id='topic+mutate_join.data.table'></span><span id='topic+right_join.ExprBuilder'></span><span id='topic+right_join.data.table'></span><span id='topic+semi_join.ExprBuilder'></span><span id='topic+semi_join.data.table'></span>

<h3>Description</h3>

<p>Two-table joins. Check the
<a href="https://asardaes.github.io/table.express/articles/joins.html">&quot;Joining verbs&quot; vignette</a> for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
anti_join(x, y, ...)

## S3 method for class 'data.table'
anti_join(x, ..., .expr = FALSE)

## S3 method for class 'ExprBuilder'
full_join(x, y, ..., sort = TRUE, allow = TRUE, .parent_env)

## S3 method for class 'data.table'
full_join(x, ...)

## S3 method for class 'ExprBuilder'
inner_join(x, y, ...)

## S3 method for class 'data.table'
inner_join(x, ..., .expr = FALSE)

## S3 method for class 'ExprBuilder'
left_join(
  x,
  y,
  ...,
  nomatch,
  mult,
  roll,
  rollends,
  .parent_env,
  .to_eager = FALSE
)

## S3 method for class 'data.table'
left_join(x, y, ..., allow = FALSE, .expr = FALSE)

mutate_join(x, y, ...)

## S3 method for class 'ExprBuilder'
mutate_join(
  x,
  y,
  ...,
  .SDcols,
  mult,
  roll,
  rollends,
  allow = FALSE,
  .by_each = NULL,
  .parent_env
)

## S3 method for class 'EagerExprBuilder'
mutate_join(x, ..., .parent_env = rlang::caller_env())

## S3 method for class 'data.table'
mutate_join(x, y, ...)

## S3 method for class 'ExprBuilder'
right_join(
  x,
  y,
  ...,
  allow = FALSE,
  which,
  nomatch,
  mult,
  roll,
  rollends,
  .selecting,
  .framing
)

## S3 method for class 'data.table'
right_join(x, y, ..., allow = FALSE, .expr = FALSE, .selecting, .framing)

## S3 method for class 'ExprBuilder'
semi_join(x, y, ..., allow = FALSE, .eager = FALSE)

## S3 method for class 'data.table'
semi_join(x, y, ..., allow = FALSE, .eager = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joins_+3A_x">x</code></td>
<td>
<p>An <a href="#topic+ExprBuilder">ExprBuilder</a> instance.</p>
</td></tr>
<tr><td><code id="joins_+3A_y">y</code></td>
<td>
<p>A <a href="data.table.html#topic+data.table-class">data.table::data.table</a> or, for some verbs (see details), a call to
<code><a href="#topic+nest_expr">nest_expr()</a></code>.</p>
</td></tr>
<tr><td><code id="joins_+3A_...">...</code></td>
<td>
<p>Expressions for the <code>on</code> part of the join.</p>
</td></tr>
<tr><td><code id="joins_+3A_.expr">.expr</code></td>
<td>
<p>If the input is a <code>data.table</code> and <code>.expr</code> is <code>TRUE</code>, an instance of
<a href="#topic+EagerExprBuilder">EagerExprBuilder</a> will be returned. Useful if you want to add clauses to <code>j</code>, e.g. with
<a href="#topic+mutate-table.express">mutate-table.express</a>.</p>
</td></tr>
<tr><td><code id="joins_+3A_sort">sort</code></td>
<td>
<p>Passed to <a href="data.table.html#topic+merge">data.table::merge</a>.</p>
</td></tr>
<tr><td><code id="joins_+3A_allow">allow</code></td>
<td>
<p>Passed as <code><a href="data.table.html#topic+data.table">data.table</a></code>'s <code>allow.cartesian</code>.</p>
</td></tr>
<tr><td><code id="joins_+3A_.parent_env">.parent_env</code></td>
<td>
<p>See <code><a href="#topic+end_expr">end_expr()</a></code>.</p>
</td></tr>
<tr><td><code id="joins_+3A_nomatch">nomatch</code>, <code id="joins_+3A_mult">mult</code>, <code id="joins_+3A_roll">roll</code>, <code id="joins_+3A_rollends">rollends</code></td>
<td>
<p>See <a href="data.table.html#topic+data.table">data.table::data.table</a>.</p>
</td></tr>
<tr><td><code id="joins_+3A_.to_eager">.to_eager</code></td>
<td>
<p>Internal, should be left as <code>FALSE</code> in all external calls.</p>
</td></tr>
<tr><td><code id="joins_+3A_.sdcols">.SDcols</code></td>
<td>
<p>For <code>mutate_join</code>. See the details below.</p>
</td></tr>
<tr><td><code id="joins_+3A_.by_each">.by_each</code></td>
<td>
<p>For <code>mutate_join</code>. See the details below.</p>
</td></tr>
<tr><td><code id="joins_+3A_which">which</code></td>
<td>
<p>If <code>TRUE</code>, return the row numbers that matched in <code>x</code> instead of the result of the
join.</p>
</td></tr>
<tr><td><code id="joins_+3A_.selecting">.selecting</code></td>
<td>
<p>One or more expressions, possibly contained in a call to <code>list</code> or <code>.</code>, that
will be added to <code>j</code> in the same frame as the join.</p>
</td></tr>
<tr><td><code id="joins_+3A_.framing">.framing</code></td>
<td>
<p>Similar to <code>.selecting</code>, but added to the frame with <code><a href="#topic+frame_append">frame_append()</a></code>.</p>
</td></tr>
<tr><td><code id="joins_+3A_.eager">.eager</code></td>
<td>
<p>For <code>semi_join</code>. If <code>TRUE</code>, it uses <code><a href="#topic+nest_expr">nest_expr()</a></code> to build an expression like
<a href="https://stackoverflow.com/a/18971223/5793905">this</a> instead of the default one. This uses the
captured <code>data.table</code> eagerly, so use <code><a href="#topic+chain">chain()</a></code> when needed. The default is lazy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following joins support <code><a href="#topic+nest_expr">nest_expr()</a></code> in <code>y</code>:
</p>

<ul>
<li> <p><code>anti_join</code>
</p>
</li>
<li> <p><code>inner_join</code>
</p>
</li>
<li> <p><code>right_join</code>
</p>
</li></ul>

<p>The <code>full_join</code> method is really a wrapper for <code>data.table::merge</code> that specifies <code>all = TRUE</code>.
The expression in <code>x</code> gets evaluated, merged with <code>y</code>, and the result is captured in a new
<a href="#topic+ExprBuilder">ExprBuilder</a>. Useful in case you want to keep building expressions after the merge.
</p>


<h3>Mutating join</h3>

<p>The <a href="#topic+ExprBuilder">ExprBuilder</a> method for <code>mutate_join</code> implements the idiom described in <a href="https://stackoverflow.com/a/54313203/5793905">this link</a>. The columns specified in <code>.SDcols</code> are
those that will be added to <code>x</code> from <code>y</code>. The specification can be done by:
</p>

<ul>
<li><p> Using <a href="tidyselect.html#topic+language">tidyselect::select_helpers</a>.
</p>
</li>
<li><p> Passing a character vector. If the character is named, the names are taken as the new column
names for the values added to <code>x</code>.
</p>
</li>
<li><p> A list, using <code><a href="base.html#topic+list">base::list()</a></code> or <code>.()</code>, containing:
</p>

<ul>
<li><p> Column names, either as characters or symbols.
</p>
</li>
<li><p> Named calls expressing how the column should be summarized/modified before adding it to
<code>x</code>.
</p>
</li></ul>

</li></ul>

<p>The last case mentioned above is useful when the join returns many rows from <code>y</code> for each row
in <code>x</code>, so they can be summarized while joining. The value of <code>by</code> in the join depends on what
is passed to <code>.by_each</code>:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), <code>by</code> is set to <code>.EACHI</code> if a call is detected in any of the
expressions from the list in <code>.SDcols</code>
</p>
</li>
<li><p> If <code>TRUE</code>, <code>by</code> is always set to <code>.EACHI</code>
</p>
</li>
<li><p> If <code>FALSE</code>, <code>by</code> is never set to <code>.EACHI</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="data.table.html#topic+data.table">data.table::data.table</a>, <a href="dplyr.html#topic+mutate-joins">dplyr::join</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lhs &lt;- data.table::data.table(x = rep(c("b", "a", "c"), each = 3),
                              y = c(1, 3, 6),
                              v = 1:9)

rhs &lt;- data.table::data.table(x = c("c", "b"),
                              v = 8:7,
                              foo = c(4, 2))


rhs %&gt;%
    anti_join(lhs, x, v)


lhs %&gt;%
    inner_join(rhs, x)


# creates new data.table
lhs %&gt;%
    left_join(rhs, x)


# would modify lhs by reference
lhs %&gt;%
    start_expr %&gt;%
    mutate_join(rhs, x, .SDcols = c("foo", rhs.v = "v"))

# would modify rhs by reference, summarizing 'y' before adding it.
rhs %&gt;%
    start_expr %&gt;%
    mutate_join(lhs, x, .SDcols = .(y = mean(y)))


# creates new data.table
lhs %&gt;%
    right_join(rhs, x)


# keep only columns from lhs
lhs %&gt;%
    semi_join(rhs, x)

</code></pre>

<hr>
<h2 id='key_by'>Set key to group by</h2><span id='topic+key_by'></span><span id='topic+key_by.ExprBuilder'></span><span id='topic+key_by.data.table'></span>

<h3>Description</h3>

<p>Group by setting key of the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key_by(.data, ...)

## S3 method for class 'ExprBuilder'
key_by(
  .data,
  ...,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'data.table'
key_by(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key_by_+3A_.data">.data</code></td>
<td>
<p>Object to be grouped and subsequently keyed.</p>
</td></tr>
<tr><td><code id="key_by_+3A_...">...</code></td>
<td>
<p>Arguments for the specific methods.</p>
</td></tr>
<tr><td><code id="key_by_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="key_by_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Everything in <code>...</code> will be wrapped in a call to <code>list</code>. Its contents work like Clauses for
grouping on columns. The <code>keyby</code> inside the <a href="data.table.html#topic+data.table">data.table::data.table</a> frame.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    start_expr %&gt;%
    key_by(cyl, gear)

</code></pre>

<hr>
<h2 id='mutate_sd'>Mutate subset of data</h2><span id='topic+mutate_sd'></span><span id='topic+mutate_sd.ExprBuilder'></span><span id='topic+mutate_sd.EagerExprBuilder'></span><span id='topic+mutate_sd.data.table'></span>

<h3>Description</h3>

<p>Like <a href="#topic+mutate-table.express">mutate-table.express</a> but possibly recycling calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_sd(.data, .SDcols, .how = identity, ...)

## S3 method for class 'ExprBuilder'
mutate_sd(
  .data,
  .SDcols,
  .how = identity,
  ...,
  .pairwise = TRUE,
  .prefix,
  .suffix,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'EagerExprBuilder'
mutate_sd(.data, ..., .parent_env = rlang::caller_env())

## S3 method for class 'data.table'
mutate_sd(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_sd_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="mutate_sd_+3A_.sdcols">.SDcols</code></td>
<td>
<p>See <a href="data.table.html#topic+data.table">data.table::data.table</a> and the details here.</p>
</td></tr>
<tr><td><code id="mutate_sd_+3A_.how">.how</code></td>
<td>
<p>The function(s) or function call(s) that will perform the transformation. If many,
a list should be used, either with <code>list()</code> or <code>.()</code>. If the list is named, the names will be
used for the new columns' names. Lambdas specified as formulas are supported.</p>
</td></tr>
<tr><td><code id="mutate_sd_+3A_...">...</code></td>
<td>
<p>Possibly more arguments for <em>all</em> functions/calls in <code>.how</code>.</p>
</td></tr>
<tr><td><code id="mutate_sd_+3A_.pairwise">.pairwise</code></td>
<td>
<p>If <code>FALSE</code>, each function in <code>.how</code> is applied to each column in <code>.SDcols</code> (like
a cartesian product).</p>
</td></tr>
<tr><td><code id="mutate_sd_+3A_.prefix">.prefix</code>, <code id="mutate_sd_+3A_.suffix">.suffix</code></td>
<td>
<p>Only relevant when <code>.how</code> is a function: add a prefix or suffix to the new
column's name. If neither is missing, <code>.prefix</code> has preference.</p>
</td></tr>
<tr><td><code id="mutate_sd_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="mutate_sd_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="mutate_sd_+3A_.parent_env">.parent_env</code></td>
<td>
<p>See <code><a href="#topic+end_expr">end_expr()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works similar to <code><a href="#topic+transmute_sd">transmute_sd()</a></code> but keeps all columns and <em>can</em> modify by
reference, like <a href="#topic+mutate-table.express">mutate-table.express</a>. It can serve like
<a href="dplyr.html#topic+mutate_all">dplyr's scoped mutation variants</a> depending on what's given to <code>.SDcols</code>.
</p>
<p>Additionally, <code>.SDcols</code> supports:
</p>

<ul>
<li> <p><a href="tidyselect.html#topic+language">tidyselect::select_helpers</a>
</p>
</li>
<li><p> A predicate using the <code>.COL</code> pronoun that should return a single logical when <code>.COL</code> is
replaced by a <em>column</em> of the data.
</p>
</li>
<li><p> A formula using <code>.</code> or <code>.x</code> instead of the aforementioned <code>.COL</code>.
</p>
</li></ul>

<p>The caveat is that the expression is evaluated eagerly, i.e. with the currently captured
<code>data.table</code>. Consider using <code><a href="#topic+chain">chain()</a></code> to explicitly capture intermediate results as actual
<code>data.table</code>s.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    start_expr %&gt;%
    mutate_sd(c("mpg", "cyl"), ~ .x * 2)

</code></pre>

<hr>
<h2 id='mutate-table.express'>Add or update columns</h2><span id='topic+mutate-table.express'></span><span id='topic+mutate.ExprBuilder'></span><span id='topic+mutate.EagerExprBuilder'></span><span id='topic+mutate.data.table'></span>

<h3>Description</h3>

<p>Add or update columns of a <a href="data.table.html#topic+data.table-class">data.table::data.table</a>, possibly by reference using
<code><a href="data.table.html#topic+assign">:=</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
mutate(
  .data,
  ...,
  .sequential = FALSE,
  .unquote_names = TRUE,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'EagerExprBuilder'
mutate(.data, ..., .parent_env = rlang::caller_env())

## S3 method for class 'data.table'
mutate(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate-table.express_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="mutate-table.express_+3A_...">...</code></td>
<td>
<p>Mutation clauses.</p>
</td></tr>
<tr><td><code id="mutate-table.express_+3A_.sequential">.sequential</code></td>
<td>
<p>If <code>TRUE</code>, each expression in <code>...</code> is assigned to a nested body within curly braces to allow them to use variables created by previous expressions. The default is <code>FALSE</code> because enabling this may turn off some <a href="data.table.html#topic+datatable-optimize">data.table optimizations</a>.</p>
</td></tr>
<tr><td><code id="mutate-table.express_+3A_.unquote_names">.unquote_names</code></td>
<td>
<p>Passed to <code><a href="rlang.html#topic+defusing-advanced">rlang::enexprs()</a></code>. Set to <code>FALSE</code> if you want to pass the single
<code><a href="data.table.html#topic+assign">:=</a></code> expression.</p>
</td></tr>
<tr><td><code id="mutate-table.express_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="mutate-table.express_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="mutate-table.express_+3A_.parent_env">.parent_env</code></td>
<td>
<p>See <code><a href="#topic+end_expr">end_expr()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")
data.table::as.data.table(mtcars) %&gt;%
    start_expr %&gt;%
    mutate(mpg_squared = mpg ^ 2)

</code></pre>

<hr>
<h2 id='nest_expr'>Nest expressions as a functional chain</h2><span id='topic+nest_expr'></span>

<h3>Description</h3>

<p>Nest expressions as a functional chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_expr(
  ...,
  .start = TRUE,
  .end = .start,
  .parse = getOption("table.express.parse", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_expr_+3A_...">...</code></td>
<td>
<p>Expressions that will be part of the functional chain.</p>
</td></tr>
<tr><td><code id="nest_expr_+3A_.start">.start</code></td>
<td>
<p>Whether to add a <code><a href="#topic+start_expr">start_expr()</a></code> call at the beginning of the chain.</p>
</td></tr>
<tr><td><code id="nest_expr_+3A_.end">.end</code></td>
<td>
<p>Whether to add an <code><a href="#topic+end_expr">end_expr()</a></code> call at the end of the chain.</p>
</td></tr>
<tr><td><code id="nest_expr_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All expressions in <code>...</code> are &quot;collapsed&quot; with <code><a href="magrittr.html#topic+pipe">%&gt;%</a></code>, passing the
<a href="#topic+ExprBuilder">ExprBuilder</a>'s captured <code>data.table</code> as the initial parameter. Names are silently dropped.
</p>
<p>The chain is evaluated eagerly and saved in the <code>ExprBuilder</code> instance to be used during final
expression evaluation.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>

<hr>
<h2 id='order_by-table.express'>Order by clause</h2><span id='topic+order_by-table.express'></span><span id='topic+order_by'></span><span id='topic+order_by.ExprBuilder'></span><span id='topic+order_by.data.table'></span>

<h3>Description</h3>

<p>Clause for ordering rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_by(.data, ...)

## S3 method for class 'ExprBuilder'
order_by(
  .data,
  ...,
  .collapse,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'data.table'
order_by(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_by-table.express_+3A_.data">.data</code></td>
<td>
<p>The input data.</p>
</td></tr>
<tr><td><code id="order_by-table.express_+3A_...">...</code></td>
<td>
<p>Arguments for the specific methods.</p>
</td></tr>
<tr><td><code id="order_by-table.express_+3A_.collapse">.collapse</code></td>
<td>
<p>Ignored. See details.</p>
</td></tr>
<tr><td><code id="order_by-table.express_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="order_by-table.express_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+ExprBuilder">ExprBuilder</a> method dispatches to <a href="#topic+where-table.express">where-table.express</a>, but doesn't forward the <code>.collapse</code>
argument.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    order_by(-cyl, gear)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+starts_with'></span><span id='topic+ends_with'></span><span id='topic+contains'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+everything'></span><span id='topic+last_col'></span><span id='topic+anti_join'></span><span id='topic+arrange'></span><span id='topic+distinct'></span><span id='topic+filter'></span><span id='topic+full_join'></span><span id='topic+group_by'></span><span id='topic+inner_join'></span><span id='topic+left_join'></span><span id='topic++3A+3D'></span><span id='topic++25+3E+25'></span><span id='topic++25T+3E+25'></span><span id='topic++21+21'></span><span id='topic++21+21+21'></span><span id='topic+mutate'></span><span id='topic+right_join'></span><span id='topic+select'></span><span id='topic+semi_join'></span><span id='topic+summarize'></span><span id='topic+summarise'></span><span id='topic+transmute'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+assign">:=</a></code></p>
</dd>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter-joins">anti_join</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+distinct">distinct</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate-joins">full_join</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+mutate-joins">inner_join</a></code>, <code><a href="dplyr.html#topic+mutate-joins">left_join</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+mutate-joins">right_join</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+filter-joins">semi_join</a></code>, <code><a href="dplyr.html#topic+summarise">summarise</a></code>, <code><a href="dplyr.html#topic+summarise">summarize</a></code>, <code><a href="dplyr.html#topic+transmute">transmute</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code>, <code><a href="magrittr.html#topic+tee">%T&gt;%</a></code></p>
</dd>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+injection-operator">!!</a></code>, <code><a href="rlang.html#topic+splice-operator">!!!</a></code></p>
</dd>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

<hr>
<h2 id='select-table.express'>Select clause</h2><span id='topic+select-table.express'></span><span id='topic+select.ExprBuilder'></span><span id='topic+select.EagerExprBuilder'></span><span id='topic+select.data.table'></span>

<h3>Description</h3>

<p>Select columns of a <a href="data.table.html#topic+data.table-class">data.table::data.table</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
select(
  .data,
  ...,
  .negate = FALSE,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'EagerExprBuilder'
select(.data, ..., .parent_env = rlang::caller_env())

## S3 method for class 'data.table'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select-table.express_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="select-table.express_+3A_...">...</code></td>
<td>
<p>Clause for selecting columns. For <code>j</code> inside the <code>data.table</code>'s frame.</p>
</td></tr>
<tr><td><code id="select-table.express_+3A_.negate">.negate</code></td>
<td>
<p>Whether to negate the selection semantics and keep only columns that do <em>not</em>
match what's given in <code>...</code>.</p>
</td></tr>
<tr><td><code id="select-table.express_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="select-table.express_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="select-table.express_+3A_.parent_env">.parent_env</code></td>
<td>
<p>See <code><a href="#topic+end_expr">end_expr()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expressions in <code>...</code> support <a href="tidyselect.html#topic+language">tidyselect::select_helpers</a>.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    select(mpg:cyl)

</code></pre>

<hr>
<h2 id='start_expr'>Start expression</h2><span id='topic+start_expr'></span><span id='topic+start_expr.data.table'></span>

<h3>Description</h3>

<p>Start building an expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_expr(.data, ...)

## S3 method for class 'data.table'
start_expr(.data, ..., .verbose = getOption("table.express.verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_expr_+3A_.data">.data</code></td>
<td>
<p>Optionally, something to capture for the expression.</p>
</td></tr>
<tr><td><code id="start_expr_+3A_...">...</code></td>
<td>
<p>Arguments for the specific methods.</p>
</td></tr>
<tr><td><code id="start_expr_+3A_.verbose">.verbose</code></td>
<td>
<p>Whether to print more information during the expression-building process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="data.table.html#topic+data.table-class">data.table::data.table</a> method returns an <a href="#topic+ExprBuilder">ExprBuilder</a> instance.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>

<hr>
<h2 id='summarize-table.express'>Summarize columns</h2><span id='topic+summarize-table.express'></span><span id='topic+summarize.ExprBuilder'></span><span id='topic+summarise.ExprBuilder'></span><span id='topic+summarize.EagerExprBuilder'></span><span id='topic+summarise.EagerExprBuilder'></span><span id='topic+summarize.data.table'></span><span id='topic+summarise.data.table'></span>

<h3>Description</h3>

<p>Compute summaries for columns, perhaps by group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
summarize(
  .data,
  ...,
  .assume_optimized = NULL,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'ExprBuilder'
summarise(
  .data,
  ...,
  .assume_optimized = NULL,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'EagerExprBuilder'
summarize(.data, ..., .parent_env = rlang::caller_env())

## S3 method for class 'EagerExprBuilder'
summarise(.data, ..., .parent_env = rlang::caller_env())

## S3 method for class 'data.table'
summarize(.data, ...)

## S3 method for class 'data.table'
summarise(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize-table.express_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="summarize-table.express_+3A_...">...</code></td>
<td>
<p>Clauses for transmuting columns. For <code>j</code> inside the <code>data.table</code>'s frame.</p>
</td></tr>
<tr><td><code id="summarize-table.express_+3A_.assume_optimized">.assume_optimized</code></td>
<td>
<p>An optional character vector with function names that you know
<code>data.table</code> can optimize. This will be added to this set of known names:
min, max, mean, median, var, sd, sum, prod, first, last. Note that using those functions (and only those in
a given call to this function) will prevent the expressions from using variables created by
previous expressions.</p>
</td></tr>
<tr><td><code id="summarize-table.express_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="summarize-table.express_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="summarize-table.express_+3A_.parent_env">.parent_env</code></td>
<td>
<p>See <code><a href="#topic+end_expr">end_expr()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The built expression is similar to what <code>transmute</code> builds, but the function also checks that the
results have length 1.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>

<hr>
<h2 id='transmute_sd'>Transmute subset of data</h2><span id='topic+transmute_sd'></span><span id='topic+transmute_sd.ExprBuilder'></span><span id='topic+transmute_sd.EagerExprBuilder'></span><span id='topic+transmute_sd.data.table'></span>

<h3>Description</h3>

<p>Like <a href="#topic+transmute-table.express">transmute-table.express</a> but for a single call and maybe specifying <code>.SDcols</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transmute_sd(.data, .SDcols = everything(), .how = identity, ...)

## S3 method for class 'ExprBuilder'
transmute_sd(
  .data,
  .SDcols = everything(),
  .how = identity,
  ...,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'EagerExprBuilder'
transmute_sd(.data, ..., .parent_env = rlang::caller_env())

## S3 method for class 'data.table'
transmute_sd(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmute_sd_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="transmute_sd_+3A_.sdcols">.SDcols</code></td>
<td>
<p>See <a href="data.table.html#topic+data.table">data.table::data.table</a> and the details here.</p>
</td></tr>
<tr><td><code id="transmute_sd_+3A_.how">.how</code></td>
<td>
<p>The function(s) or function call(s) that will perform the transformation. If many,
a list should be used, either with <code>list()</code> or <code>.()</code>. If the list is named, the names will be
used for the new columns' names. Lambdas specified as formulas are supported.</p>
</td></tr>
<tr><td><code id="transmute_sd_+3A_...">...</code></td>
<td>
<p>Possibly more arguments for <em>all</em> functions/calls in <code>.how</code>.</p>
</td></tr>
<tr><td><code id="transmute_sd_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="transmute_sd_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="transmute_sd_+3A_.parent_env">.parent_env</code></td>
<td>
<p>See <code><a href="#topic+end_expr">end_expr()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like <a href="#topic+transmute-table.express">transmute-table.express</a>, this function never modifies the input by reference. This
function adds/chains a <code>select</code> expression that will be evaluated by <a href="data.table.html#topic+data.table">data.table::data.table</a>,
possibly specifying the helper function <code>.transmute_matching</code>, which is assigned to the final
expression's evaluation environment when calling <code><a href="#topic+end_expr">end_expr()</a></code> (i.e., <a href="#topic+ExprBuilder">ExprBuilder</a>'s <code>eval</code>
method).
</p>
<p>Said function supports two pronouns that can be used by <code>.how</code> and <code>.SDcols</code>:
</p>

<ul>
<li> <p><code>.COL</code>: the actual values of the column.
</p>
</li>
<li> <p><code>.COLNAME</code>: the name of the column currently being evaluated.
</p>
</li></ul>

<p>Additionally, lambdas specified as formulas are also supported. In those cases, <code>.x</code> is
equivalent to <code>.COL</code> and <code>.y</code> to <code>.COLNAME</code>.
</p>
<p>Unlike a call like <code>DT[, (vars) := expr]</code>, <code>.SDcols</code> can be created dynamically with an
expression that evaluates to something that would be used in place of <code>vars</code> <em>without</em> eagerly
using the captured <code>data.table</code>. See the examples here or in <a href="#topic+table.express-package">table.express-package</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    transmute_sd(~ grepl("^d", .y), ~ .x * 2)

data.table::as.data.table(mtcars) %&gt;%
    transmute_sd(~ is.numeric(.x), ~ .x * 2)

</code></pre>

<hr>
<h2 id='transmute-table.express'>Compute new columns</h2><span id='topic+transmute-table.express'></span><span id='topic+transmute.ExprBuilder'></span><span id='topic+transmute.EagerExprBuilder'></span><span id='topic+transmute.data.table'></span>

<h3>Description</h3>

<p>Compute and keep only new columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ExprBuilder'
transmute(
  .data,
  ...,
  .enlist = TRUE,
  .sequential = FALSE,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'EagerExprBuilder'
transmute(.data, ..., .parent_env = rlang::caller_env())

## S3 method for class 'data.table'
transmute(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transmute-table.express_+3A_.data">.data</code></td>
<td>
<p>An instance of <a href="#topic+ExprBuilder">ExprBuilder</a>.</p>
</td></tr>
<tr><td><code id="transmute-table.express_+3A_...">...</code></td>
<td>
<p>Clauses for transmuting columns. For <code>j</code> inside the <code>data.table</code>'s frame.</p>
</td></tr>
<tr><td><code id="transmute-table.express_+3A_.enlist">.enlist</code></td>
<td>
<p>See details.</p>
</td></tr>
<tr><td><code id="transmute-table.express_+3A_.sequential">.sequential</code></td>
<td>
<p>If <code>TRUE</code>, each expression in <code>...</code> is assigned to a nested body within curly braces to allow them to use variables created by previous expressions. The default is <code>FALSE</code> because enabling this may turn off some <a href="data.table.html#topic+datatable-optimize">data.table optimizations</a>.</p>
</td></tr>
<tr><td><code id="transmute-table.express_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="transmute-table.express_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
<tr><td><code id="transmute-table.express_+3A_.parent_env">.parent_env</code></td>
<td>
<p>See <code><a href="#topic+end_expr">end_expr()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Everything in <code>...</code> is wrapped in a call to <code>list</code> by default. If only one expression is given,
you can set <code>.enlist</code> to <code>FALSE</code> to skip the call to <code>list</code>.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    transmute(ans = mpg * 2)

</code></pre>

<hr>
<h2 id='where-table.express'>Where clause</h2><span id='topic+where-table.express'></span><span id='topic+where'></span><span id='topic+where.ExprBuilder'></span><span id='topic+where.data.table'></span>

<h3>Description</h3>

<p>Clause for subsetting rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(.data, ...)

## S3 method for class 'ExprBuilder'
where(
  .data,
  ...,
  which,
  .collapse = `&amp;`,
  .parse = getOption("table.express.parse", FALSE),
  .chain = getOption("table.express.chain", TRUE)
)

## S3 method for class 'data.table'
where(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where-table.express_+3A_.data">.data</code></td>
<td>
<p>The input data.</p>
</td></tr>
<tr><td><code id="where-table.express_+3A_...">...</code></td>
<td>
<p>Arguments for the specific methods.</p>
</td></tr>
<tr><td><code id="where-table.express_+3A_which">which</code></td>
<td>
<p>Passed to <a href="data.table.html#topic+data.table">data.table::data.table</a>.</p>
</td></tr>
<tr><td><code id="where-table.express_+3A_.collapse">.collapse</code></td>
<td>
<p>A boolean function which will be used to &quot;concatenate&quot; all conditions in <code>...</code>.</p>
</td></tr>
<tr><td><code id="where-table.express_+3A_.parse">.parse</code></td>
<td>
<p>Logical. Whether to apply <code><a href="rlang.html#topic+parse_expr">rlang::parse_expr()</a></code> to obtain the expressions.</p>
</td></tr>
<tr><td><code id="where-table.express_+3A_.chain">.chain</code></td>
<td>
<p>Logical. Should a new frame be automatically chained to the expression if the
clause being set already exists?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <a href="#topic+ExprBuilder">ExprBuilder</a>, the expressions in <code>...</code> can call <code><a href="#topic+nest_expr">nest_expr()</a></code>, and are eagerly nested if
they do.
</p>
<p>The <a href="data.table.html#topic+data.table-class">data.table::data.table</a> method is <strong>lazy</strong>, so it expects another verb to follow
<em>afterwards</em>.
</p>
<p>To see more examples, check the
<a href="https://asardaes.github.io/table.express/articles/table.express.html">vignette</a>, or the
<a href="#topic+table.express-package">table.express-package</a> entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtcars")

data.table::as.data.table(mtcars) %&gt;%
    start_expr %&gt;%
    where(vs == 0, am == 1)


data.table::as.data.table(mtcars) %&gt;%
    where(vs == 0) %&gt;%
    transmute(mpg = round(mpg))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
