<!DOCTYPE html><html lang="en"><head><title>Help for package WLogit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WLogit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#WLogit-package'>
<p>Variable Selection in High-Dimensional Logistic Regression</p>
Models using a Whitening Approach</a></li>
<li><a href='#beta'>
<p>True coefficients in the esample.</p></a></li>
<li><a href='#CalculPx'>
<p>Calculate the class-conditional probabilities.</p></a></li>
<li><a href='#CalculWeight'>
<p>Calculate the weight</p></a></li>
<li><a href='#Refit_glm'>
<p>Refit the logistic regression with chosen variables</p></a></li>
<li><a href='#test'>
<p>WLogit output</p></a></li>
<li><a href='#Thresholding'>
<p>Thresholding on a vector</p></a></li>
<li><a href='#top'><p>Thresholding to zero of the smallest values</p></a></li>
<li><a href='#top_thresh'><p>Thresholding to a given threshold of the smallest values</p></a></li>
<li><a href='#WhiteningLogit'>
<p>Variable selection in high-dimensional logistic regression models using a whitening approach</p></a></li>
<li><a href='#WorkingResp'>
<p>Calculate the working response</p></a></li>
<li><a href='#X'>
<p>Example of a design matrix of a logistic model</p></a></li>
<li><a href='#y'>
<p>Example of a binary response variable of a logistic model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variable Selection in High-Dimensional Logistic Regression
Models using a Whitening Approach</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Wencan Zhu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wencan Zhu &lt;wencan.zhu@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>It proposes a novel variable selection approach in classification problem that takes into account the correlations that may exist between the predictors of the design matrix in a high-dimensional logistic model. Our approach consists in rewriting the initial high-dimensional logistic model to remove the correlation between the predictors and in applying the generalized Lasso criterion.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cvCovEst, genlasso, tibble, MASS, ggplot2, Matrix, glmnet,
corpcor</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-17 06:44:04 UTC; chenxi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-17 07:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='WLogit-package'>
Variable Selection in High-Dimensional Logistic Regression
Models using a Whitening Approach
</h2><span id='topic+WLogit-package'></span><span id='topic+WLogit'></span>

<h3>Description</h3>

<p>It proposes a novel variable selection approach in classification problem that takes into account the correlations that may exist between the predictors of the design matrix in a high-dimensional logistic model. Our approach consists in rewriting the initial high-dimensional logistic model to remove the correlation between the predictors and in applying the generalized Lasso criterion.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> WLogit</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Variable Selection in High-Dimensional Logistic Regression
Models using a Whitening Approach</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-07-17</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Wencan Zhu</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Wencan Zhu &lt;wencan.zhu@yahoo.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> It proposes a novel variable selection approach in classification problem that takes into account the correlations that may exist between the predictors of the design matrix in a high-dimensional logistic model. Our approach consists in rewriting the initial high-dimensional logistic model to remove the correlation between the predictors and in applying the generalized Lasso criterion.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> cvCovEst, genlasso, tibble, MASS, ggplot2, Matrix, glmnet,
corpcor</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2023-07-17 07:06:43 UTC; mmip</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
CalculPx                Calculate the class-conditional probabilities.
CalculWeight            Calculate the weight
Refit_glm               Refit the logistic regression with chosen
                        variables
Thresholding            Thresholding on a vector
WLogit-package          Variable Selection in High-Dimensional Logistic
                        Regression Models using a Whitening Approach
WhiteningLogit          Variable selection in high-dimensional logistic
                        regression models using a whitening approach
WorkingResp             Calculate the working response
X                       Example of a design matrix of a logistic model
beta                    True coefficients in the esample.
test                    WLogit output
top                     Thresholding to zero of the smallest values
top_thresh              Thresholding to a given threshold of the
                        smallest values
y                       Example of a binary response variable of a
                        logistic model.
</pre>

<p>Further information is available in the following vignettes:<br /><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Vignettes</code> </td><td style="text-align: left;"> WLogit package (source, pdf)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package consists of functions: &quot;WhiteningLogit&quot;, &quot;CalculPx&quot;, &quot;CalculWeight&quot;, &quot;Refit_glm&quot;, &quot;top&quot;, &quot;top_thresh&quot;, &quot;WorkingResp&quot;, and &quot;Thresholding&quot;.
For further information on how to use these functions, 
we refer the reader to the vignette of the package.
</p>


<h3>Author(s)</h3>

<p>Wencan Zhu
</p>
<p>Maintainer: Wencan Zhu &lt;wencan.zhu@yahoo.com&gt;
</p>


<h3>References</h3>

<p>W. Zhu, C. Levy-Leduc, N. Ternes. &quot;Variable selection in high-dimensional logistic regression models using a whitening approach&quot;. (2022)
</p>

<hr>
<h2 id='beta'>
True coefficients in the esample.
</h2><span id='topic+beta'></span>

<h3>Description</h3>

<p>True coefficients in the esample given in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("beta")</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:500] 1 1 1 1 1 1 1 1 1 1 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beta)
plot(beta)
</code></pre>

<hr>
<h2 id='CalculPx'>
Calculate the class-conditional probabilities.
</h2><span id='topic+CalculPx'></span>

<h3>Description</h3>

<p>Calculate the probability for a repsonse to be 1 in the logistic regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculPx(X, beta, intercept = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculPx_+3A_x">X</code></td>
<td>

<p>Design matrix of the logistic model considered.
</p>
</td></tr>
<tr><td><code id="CalculPx_+3A_beta">beta</code></td>
<td>

<p>Vector of coefficients of the logistic model considered.
</p>
</td></tr>
<tr><td><code id="CalculPx_+3A_intercept">intercept</code></td>
<td>

<p>Whether there is the intercept
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>the probability for a repsonse to be 1</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wencan Zhu, Celine Levy-Leduc, Nils Ternes
</p>


<h3>See Also</h3>

<p> Please read <a href="https://hastie.su.domains/Papers/glmnet.pdf">https://hastie.su.domains/Papers/glmnet.pdf</a> for more details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(X)
data(beta)
CalculPx(X=X, beta=beta)


##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X, beta, intercept = 0) 
{
    prob &lt;- 1/(1 + exp(-(X %*% beta + intercept)))
    return(prob)
  }
</code></pre>

<hr>
<h2 id='CalculWeight'>
Calculate the weight
</h2><span id='topic+CalculWeight'></span>

<h3>Description</h3>

<p>Calculate the weight in the penalized weighted-
least-squares problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculWeight(Px)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculWeight_+3A_px">Px</code></td>
<td>

<p>The vector of estimated probability for each response to be 1.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wencan Zhu, Celine Levy-Leduc, Nils Ternes
</p>


<h3>See Also</h3>

<p> Please read <a href="https://hastie.su.domains/Papers/glmnet.pdf">https://hastie.su.domains/Papers/glmnet.pdf</a> for more details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(X)
data(beta)
px &lt;- CalculPx(X=X, beta=beta)
CalculWeight(px)
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (Px) 
{
    return(Px * (1 - Px))
  }
</code></pre>

<hr>
<h2 id='Refit_glm'>
Refit the logistic regression with chosen variables
</h2><span id='topic+Refit_glm'></span>

<h3>Description</h3>

<p>Refit the logistic regression with chosen variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Refit_glm(X, beta_pred, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Refit_glm_+3A_x">X</code></td>
<td>

<p>Design matrix of the logistic model considered.
</p>
</td></tr>
<tr><td><code id="Refit_glm_+3A_beta_pred">beta_pred</code></td>
<td>

<p>Predicted coefficients to be refited.
</p>
</td></tr>
<tr><td><code id="Refit_glm_+3A_y">y</code></td>
<td>

<p>Binary response
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>beta_refit</code></td>
<td>
<p>The new estimated coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wencan Zhu, Celine Levy-Leduc, Nils Ternes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(X)
data(y)
data(beta)
Refit_glm(X=X, beta_pred=beta, y=y)
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (X, beta_pred, y) 
{
    X_temp &lt;- X[, which(beta_pred != 0)]
    if (length(which(beta_pred != 0)) == 0) {
        coef_est &lt;- beta_pred
    }
    else if (is.null(ncol(X_temp))) {
        mydata &lt;- data.frame(Y = y, X_temp)
        colnames(mydata) &lt;- c("Y", "X")
        formula &lt;- paste0("Y~-1 +", paste0(colnames(mydata)[-which(colnames(mydata) == 
            "Y")], collapse = " + "))
        myform &lt;- as.formula(formula)
        mod_lm &lt;- glm(myform, data = mydata, family = "binomial")
        coef_est &lt;- mod_lm$coefficients
    }
    else {
        mydata &lt;- data.frame(Y = y, as.matrix(X_temp))
        formula &lt;- paste0("Y~-1 +", paste0(colnames(mydata)[-which(colnames(mydata) == 
            "Y")], collapse = " + "))
        myform &lt;- as.formula(formula)
        if (length(which(beta_pred != 0)) &gt;= length(y)) {
            mod_ridge &lt;- cv.glmnet(x = as.matrix(X_temp), y = y, 
                alpha = 0, intercept = FALSE, family = "binomial")
            opt_lambda &lt;- mod_ridge$lambda[which.min(mod_ridge$cvm)]
            coef_est &lt;- as.vector(glmnet(x = as.matrix(X), y = y, 
                alpha = 0, intercept = FALSE, family = "binomial", 
                lambda = opt_lambda)$beta)
        }
        else {
            mod_lm &lt;- glm(myform, data = mydata, family = "binomial")
            coef_est &lt;- mod_lm$coefficients
        }
    }
    beta_refit &lt;- rep(0, length(beta_pred))
    beta_refit[which(beta_pred != 0)] &lt;- coef_est
    return(beta_refit)
  }
</code></pre>

<hr>
<h2 id='test'>
WLogit output
</h2><span id='topic+test'></span>

<h3>Description</h3>

<p>The output of WLogit in the example given in the vignette. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("test")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 4
$ beta          : num [1:50, 1:500] 0 0 0 0 0 ...
$ lambda        : num [1:50] 100.8 80 73 58.9 56.7 ...
$ beta.min      : num [1:500] 0.0194 0.0348 0.0259 0.0287 0.0385 ...
$ log.likelihood: num [1:50] 57.7 57.7 57.7 57.7 57.7 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test)
str(test)
</code></pre>

<hr>
<h2 id='Thresholding'>
Thresholding on a vector
</h2><span id='topic+Thresholding'></span>

<h3>Description</h3>

<p>This function provides the thresholding (correction) given a vector. It calls the function <code><a href="#topic+top">top</a></code> or <code><a href="#topic+top_thresh">top_thresh</a></code> in the same package, and the output is the vector after correction with the optimal threshold parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Thresholding(X, y, coef, TOP)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Thresholding_+3A_x">X</code></td>
<td>

<p>Design matrix of the logistic model considered.
</p>
</td></tr>
<tr><td><code id="Thresholding_+3A_y">y</code></td>
<td>

<p>Binary response
</p>
</td></tr>
<tr><td><code id="Thresholding_+3A_coef">coef</code></td>
<td>

<p>Candidate vector to be corrected
</p>
</td></tr>
<tr><td><code id="Thresholding_+3A_top">TOP</code></td>
<td>

<p>The grill of thresholding
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>opt_top</code></td>
<td>
<p>The optimal threshold</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>the log-likelihood for each grill of thresholding</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wencan Zhu, Celine Levy-Leduc, Nils Ternes
</p>

<hr>
<h2 id='top'>Thresholding to zero of the smallest values</h2><span id='topic+top'></span>

<h3>Description</h3>

<p>This function keeps only the K largest values of the vector <code>sorted_vect</code> and sets the others to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top(vect, thresh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="top_+3A_vect">vect</code></td>
<td>

<p>vector to threshold
</p>
</td></tr>
<tr><td><code id="top_+3A_thresh">thresh</code></td>
<td>

<p>threshold
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the thresholded vector.
</p>


<h3>Author(s)</h3>

<p>Wencan Zhu, Celine Levy-Leduc, Nils Ternes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=sample(1:10,10)
thresh=3
top(x,thresh)
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (vect, thresh) 
{
    sorted_vect &lt;- sort(abs(vect), decreasing = TRUE)
    v = sorted_vect[thresh]
    ifelse(abs(vect) &gt;= v, vect, 0)
  }
</code></pre>

<hr>
<h2 id='top_thresh'>Thresholding to a given threshold of the smallest values</h2><span id='topic+top_thresh'></span>

<h3>Description</h3>

<p>This function keeps only the K largest values of the vector <code>vect</code> and sets the others to the smallest value among the K largest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_thresh(vect, thresh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="top_thresh_+3A_vect">vect</code></td>
<td>

<p>vector to threshold
</p>
</td></tr>
<tr><td><code id="top_thresh_+3A_thresh">thresh</code></td>
<td>

<p>threshold
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the thresholded vector.
</p>


<h3>Author(s)</h3>

<p>Wencan Zhu, Celine Levy-Leduc, Nils Ternes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=sample(1:10,10)
sorted_vect=sort(x,decreasing=TRUE)
thresh=3
top_thresh(x,thresh)

##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (vect, thresh) 
{
    sorted_vect &lt;- sort(vect, decreasing = TRUE)
    v = sorted_vect[thresh]
    ifelse(vect &gt;= v, vect, v)
  }
</code></pre>

<hr>
<h2 id='WhiteningLogit'>
Variable selection in high-dimensional logistic regression models using a whitening approach
</h2><span id='topic+WhiteningLogit'></span>

<h3>Description</h3>

<p>Variable selection in high-dimensional logistic regression models using a whitening approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WhiteningLogit(X = X, y = y, nlambda = 50, maxit = 100, gamma = 0.9999, 
top_grill=c(1:100))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WhiteningLogit_+3A_x">X</code></td>
<td>

<p>Design matrix of the logistic model considered.
</p>
</td></tr>
<tr><td><code id="WhiteningLogit_+3A_y">y</code></td>
<td>

<p>Binary response of the logistic model considered.
</p>
</td></tr>
<tr><td><code id="WhiteningLogit_+3A_nlambda">nlambda</code></td>
<td>

<p>Number of lambda
</p>
</td></tr>
<tr><td><code id="WhiteningLogit_+3A_maxit">maxit</code></td>
<td>

<p>Integer specifying the maximum number of steps for the generalized Lasso algorithm. It should not be smaller than nlambda.
</p>
</td></tr>
<tr><td><code id="WhiteningLogit_+3A_gamma">gamma</code></td>
<td>

<p>Parameter <code class="reqn">\gamma</code> defined in the paper Zhu et al. (2022) given in the references. Its default value is 0.95.</p>
</td></tr>
<tr><td><code id="WhiteningLogit_+3A_top_grill">top_grill</code></td>
<td>

<p>A grill of provided for the thresholding
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>different values of the parameter <code class="reqn">\lambda</code> considered.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>matrix of the estimations of <code class="reqn">\beta</code> for all the <code class="reqn">\lambda</code> considered.</p>
</td></tr>
<tr><td><code>beta.min</code></td>
<td>
<p>estimation of <code class="reqn">\beta</code> which minimize the MSE.</p>
</td></tr>
<tr><td><code>log.likelihood</code></td>
<td>
<p>Log-likelihood for all the <code class="reqn">\lambda</code> considered.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wencan Zhu, Celine Levy-Leduc, Nils Ternes
</p>


<h3>References</h3>

<p>W. Zhu, C. Levy-Leduc, N. Ternes. &quot;Variable selection in high-dimensional logistic regression models using a whitening approach&quot;. (2022)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X0 &lt;- matrix( rnorm(50*10,mean=0,sd=1), 50, 10)  
y0 &lt;- c(rep(1,25), rep(0,25))
mod &lt;- WhiteningLogit(X=X0, y=y0)
plot(mod$beta.min)

##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(X=X, y=y,
                   nlambda=50,
                   maxit=100,
                   gamma=0.9999,
                   top_grill=c(1:100)){
  
  p=ncol(X)
  n=nrow(X)
  
  mod_ridge &lt;- cv.glmnet(x=as.matrix(X), y=y, alpha=0.5, intercept=FALSE, family="binomial")
  pr_est &lt;- predict(mod_ridge, as.matrix(X), s = "lambda.min", type="response")
  beta_ini &lt;- predict(mod_ridge, as.matrix(X), s = "lambda.min", type="coefficients")[-1]
  diag_w &lt;- pr_est*(1-pr_est)
  square_root_w &lt;- diag(sqrt(as.vector(diag_w)), nrow=n)
  X_new &lt;- square_root_w
  
  Cov_est &lt;- cvCovEst(
    dat = X_new,
    estimators = c(
      linearShrinkLWEst, thresholdingEst, sampleCovEst
    ),
    estimator_params = list(
      thresholdingEst = list(gamma = seq(0.1, 0.3, 0.1))
    ),
    center = TRUE,
    scale = TRUE
  )
  
  Sigma_est &lt;- Cov_est$estimate
  
  SVD_new &lt;- fast.svd(Sigma_est)
  U_sigma_new &lt;- SVD_new$u
  D_sigma_new &lt;- SVD_new$d
  inv_transmat &lt;- U_sigma_new
  inv_diag_new &lt;- ifelse(D_sigma_new&lt;0.000001, 0, 1/sqrt(D_sigma_new))
  trans_mat &lt;- U_sigma_new
  
  
  if (p &lt;= 50) {
    top_grill &lt;- seq(1, p, 2)
  }else if (p &lt;= 200) {
    top_grill &lt;- c(1:50, seq(52, p, 2))
  }else if (p &lt;= 300) {
    top_grill &lt;- c(1:50, seq(52, 100, 2), seq(105, 200, 5), 
                   seq(210, p, 10))
  }else {
    top_grill &lt;- c(1:50, seq(52, 100, 2), seq(105, 200, 5), 
                   seq(210, 300, 10))
  }
  
  X_tilde &lt;- X
  
  beta_tilde_ini &lt;-  inv_transmat
  Px &lt;- CalculPx(X_tilde, beta=beta_tilde_ini)
  wt &lt;- CalculWeight(Px)
  # wt &lt;- ifelse(wt0==0, 0.0001, wt0)
  ystar &lt;- WorkingResp(y=y, Px=Px, X=X_tilde, beta=beta_tilde_ini)
  X_tilde_weighted &lt;- sweep(X, MARGIN=1, sqrt(wt), `*`)
  ystar_weighted &lt;- sqrt(wt)*ystar
  
  gen.model0 &lt;- genlasso(y=ystar_weighted, X=X_tilde_weighted, 
                         D=trans_mat, maxsteps = 50)
  parameter_tmp &lt;- beta_tilde_ini
  beta_final &lt;- matrix(NA, length(gen.model0$lambda), p)
  skip_i &lt;- TRUE
  eval_final &lt;- c()
  defaultW &lt;- getOption("warn") 
  
  options(warn = -1) 
  
  
  for(i in 1:length(gen.model0$lambda)){
    #inner loop
    epsilon=10
    j=0
    if(skip_i){parameter_tmp &lt;- beta_tilde_ini
    } else {parameter_tmp &lt;- parameter_current}
    skip_i &lt;-FALSE
    
    while(epsilon &gt; 0.001){
      j=j+1
      parameter_current &lt;- parameter_tmp
      Px &lt;- CalculPx(X_tilde, beta=parameter_current)
      wt0 &lt;- CalculWeight(Px)
      wt &lt;- ifelse(round(wt0,4)==0, 0.0001, wt)
      ystar &lt;- WorkingResp(y=y, Px=Px, X=X_tilde, beta=parameter_current)
      X_tilde_weighted &lt;- sweep(X, MARGIN=1, sqrt(wt), `*`)
      ystar_weighted &lt;- sqrt(wt)*ystar
      
      gen.model &lt;- genlasso(y=ystar_weighted, X=X_tilde_weighted, D=trans_mat, maxsteps =   maxit)
      
      if(gen.model0$lambda[i] &lt; min(gen.model$lambda)){
        parameter_tmp &lt;- parameter_current
        break
      } else {
        parameter_tmp &lt;- coef(gen.model, lambda=gen.model0$lambda[i],
                              type = "primal")$beta
        beta_current &lt;- parameter_tmp
        if(sum(is.na(parameter_tmp))&gt;0){
          skip_i &lt;-TRUE 
          parameter_tmp &lt;- rep(0,p)
          break}
        epsilon &lt;- max(abs(parameter_current-parameter_tmp))
        if(epsilon &gt;=100){
          skip_i &lt;-TRUE 
          break}
        if (j==maxit){
          skip_i &lt;-TRUE 
          break}
      }
    }
    
    if(skip_i){
      beta_final[i, ] &lt;- rep(NA, p)
      eval_final[i] &lt;- NA
    } else{
      
      correction &lt;- Thresholding(X_tilde, y, coef=parameter_tmp, TOP=top_grill)
      opt_top_tilde &lt;- correction$opt_top
      beta_tilde_opt &lt;- top_thresh(vect=parameter_tmp, thresh = opt_top_tilde)
      beta_final0 &lt;- trans_mat
      
      correction &lt;- Thresholding(X, y, coef=beta_final0, TOP=top_grill)
      opt_top_final &lt;- correction$opt_top
      beta_final[i, ] &lt;- beta_opt_final &lt;- top(vect=beta_final0, thresh = opt_top_final)
      
      beta_refit &lt;- Refit_glm(X=X, beta_pred = beta_opt_final, y=y)
      pr_est &lt;- CalculPx(X, beta_refit)
      ll &lt;- pr_est^y*(1-pr_est)^(1-y)
      #ll &lt;- ifelse(ll&lt;0.000001, 1, ll)
      eval_final[i] &lt;- -log(prod(ll))
      
    }
    beta.min &lt;- beta_final[which.min(eval_final), ]
  }
  options(warn = defaultW)
  return(list(beta=beta_final, lambda=gen.model0$lambda, beta.min=beta.min, 
              log.likelihood=eval_final))
}

</code></pre>

<hr>
<h2 id='WorkingResp'>
Calculate the working response  
</h2><span id='topic+WorkingResp'></span>

<h3>Description</h3>

<p>Calculate the working response in the iterative least square regression 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WorkingResp(y, Px, X, beta, intercept = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WorkingResp_+3A_x">X</code></td>
<td>

<p>Design matrix of the logistic model considered.
</p>
</td></tr>
<tr><td><code id="WorkingResp_+3A_y">y</code></td>
<td>

<p>Binary response of the logistic model considered.
</p>
</td></tr>
<tr><td><code id="WorkingResp_+3A_px">Px</code></td>
<td>

<p>The probability of the reponse to be 1</p>
</td></tr>
<tr><td><code id="WorkingResp_+3A_beta">beta</code></td>
<td>

<p>Vector of coefficients</p>
</td></tr>
<tr><td><code id="WorkingResp_+3A_intercept">intercept</code></td>
<td>

<p>If there is an intercept</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the vector of working response.
</p>


<h3>Author(s)</h3>

<p>Wencan Zhu, Celine Levy-Leduc, Nils Ternes
</p>


<h3>See Also</h3>

<p> Please read <a href="https://hastie.su.domains/Papers/glmnet.pdf">https://hastie.su.domains/Papers/glmnet.pdf</a> for more details
</p>

<hr>
<h2 id='X'>
Example of a design matrix of a logistic model</h2><span id='topic+X'></span>

<h3>Description</h3>

<p>It contains an example of a design matrix of a logistic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("X")</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:100, 1:500] -1.576 -0.476 -0.237 -0.398 0.284 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(X)
</code></pre>

<hr>
<h2 id='y'>
Example of a binary response variable of a logistic model.
</h2><span id='topic+y'></span>

<h3>Description</h3>

<p>It contains an example of a binary response variable of a logistic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("y")</code></pre>


<h3>Format</h3>

<p>The format is:
int [1:100] 0 1 0 1 1 0 0 0 1 1 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
