<!DOCTYPE html><html><head><title>Help for package pcds</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcds}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pcds-package'><p>pcds: A package for Proximity Catch Digraphs and Their Applications</p></a></li>
<li><a href='#.onAttach'><p>.onAttach start message</p></a></li>
<li><a href='#.onLoad'><p>.onLoad getOption package settings</p></a></li>
<li><a href='#angle.str2end'><p>The angles to draw arcs between two line segments</p></a></li>
<li><a href='#angle3pnts'><p>The angle between two line segments</p></a></li>
<li><a href='#arcsAS'><p>The arcs of Arc Slice Proximity Catch Digraph (AS-PCD)</p>
for a 2D data set - multiple triangle case</a></li>
<li><a href='#arcsAStri'><p>The arcs of Arc Slice Proximity Catch Digraph (AS-PCD)</p>
for 2D data - one triangle case</a></li>
<li><a href='#arcsCS'><p>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for 2D data - multiple triangle case</p></a></li>
<li><a href='#arcsCS1D'><p>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for 1D data - multiple interval case</p></a></li>
<li><a href='#arcsCSend.int'><p>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD)</p>
for 1D data - end-interval case</a></li>
<li><a href='#arcsCSint'><p>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for 1D data - one interval case</p></a></li>
<li><a href='#arcsCSmid.int'><p>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD)</p>
for 1D data - middle intervals case</a></li>
<li><a href='#arcsCStri'><p>The arcs of Central Similarity Proximity Catch Digraphs (CS-PCD) for 2D data - one triangle case</p></a></li>
<li><a href='#arcsPE'><p>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD)</p>
for 2D data - multiple triangle case</a></li>
<li><a href='#arcsPE1D'><p>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD)</p>
for 1D data - multiple interval case</a></li>
<li><a href='#arcsPEend.int'><p>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD) for 1D data - end-interval case</p></a></li>
<li><a href='#arcsPEint'><p>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD)</p>
for 1D data - one interval case</a></li>
<li><a href='#arcsPEmid.int'><p>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD) for 1D data - middle intervals case</p></a></li>
<li><a href='#arcsPEtri'><p>The arcs of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) for 2D data - one triangle case</a></li>
<li><a href='#area.polygon'><p>The area of a polygon in <code class="reqn">R^2</code></p></a></li>
<li><a href='#as.basic.tri'><p>The labels of the vertices of a triangle in the basic triangle form</p></a></li>
<li><a href='#ASarc.dens.tri'><p>Arc density of Arc Slice Proximity Catch Digraphs (AS-PCDs) - one triangle case</p></a></li>
<li><a href='#center.nondegPE'><p>Centers for non-degenerate asymptotic distribution of</p>
domination number of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</a></li>
<li><a href='#centerMc'><p>Parameterized center of an interval</p></a></li>
<li><a href='#centersMc'><p>Parameterized centers of intervals</p></a></li>
<li><a href='#circumcenter.basic.tri'><p>Circumcenter of a standard basic triangle form</p></a></li>
<li><a href='#circumcenter.tetra'><p>Circumcenter of a general tetrahedron</p></a></li>
<li><a href='#circumcenter.tri'><p>Circumcenter of a general triangle</p></a></li>
<li><a href='#cl2CCvert.reg'><p>The closest points to circumcenter in each <code class="reqn">CC</code>-vertex region</p>
in a triangle</a></li>
<li><a href='#cl2CCvert.reg.basic.tri'><p>The closest points to circumcenter in each <code class="reqn">CC</code>-vertex region</p>
in a standard basic triangle</a></li>
<li><a href='#cl2edges.std.tri'><p>The closest points in a data set to edges</p>
in the standard equilateral triangle</a></li>
<li><a href='#cl2edges.vert.reg.basic.tri'><p>The closest points among a data set in the vertex regions</p>
to the corresponding edges in a standard basic triangle</a></li>
<li><a href='#cl2edgesCCvert.reg'><p>The closest points in a data set to edges</p>
in each <code class="reqn">CC</code>-vertex region in a triangle</a></li>
<li><a href='#cl2edgesCMvert.reg'><p>The closest points in a data set to edges</p>
in each <code class="reqn">CM</code>-vertex region in a triangle</a></li>
<li><a href='#cl2edgesMvert.reg'><p>The closest points among a data set</p>
in the vertex regions to the respective edges in a triangle</a></li>
<li><a href='#cl2faces.vert.reg.tetra'><p>The closest points among a data set in the vertex regions</p>
to the respective faces in a tetrahedron</a></li>
<li><a href='#cl2Mc.int'><p>The closest points to center in each vertex region</p>
in an interval</a></li>
<li><a href='#CSarc.dens.test'><p>A test of segregation/association based on arc density of Central Similarity Proximity Catch Digraph</p>
(CS-PCD) for 2D data</a></li>
<li><a href='#CSarc.dens.test.int'><p>A test of uniformity of 1D data in a given interval based</p>
on Central Similarity Proximity Catch Digraph (CS-PCD)</a></li>
<li><a href='#CSarc.dens.test1D'><p>A test of segregation/association based on arc density of</p>
Central Similarity Proximity Catch Digraph
(CS-PCD) for 1D data</a></li>
<li><a href='#CSarc.dens.tri'><p>Arc density of Central Similarity Proximity Catch Digraphs (CS-PCDs) - one triangle case</p></a></li>
<li><a href='#dimension'><p>The dimension of a <code>vector</code> or matrix or a data frame</p></a></li>
<li><a href='#Dist'><p>The distance between two vectors, matrices, or data frames</p></a></li>
<li><a href='#dist.point2line'><p>The distance from a point to a line defined by two points</p></a></li>
<li><a href='#dist.point2plane'><p>The distance from a point to a plane spanned</p>
by three 3D points</a></li>
<li><a href='#dist.point2set'><p>Distance from a point to a set of finite cardinality</p></a></li>
<li><a href='#dom.num.exact'><p>Exact domination number (i.e., domination number</p>
by the exact algorithm)</a></li>
<li><a href='#dom.num.greedy'><p>Approximate domination number and approximate dominating set</p>
by the greedy algorithm</a></li>
<li><a href='#edge.reg.triCM'><p>The vertices of the <code class="reqn">CM</code>-edge region in a triangle</p>
that contains the point</a></li>
<li><a href='#fr2edgesCMedge.reg.std.tri'><p>The furthest points in a data set from edges</p>
in each <code class="reqn">CM</code>-edge region in the standard equilateral triangle</a></li>
<li><a href='#fr2vertsCCvert.reg'><p>The furthest points in a data set from vertices</p>
in each <code class="reqn">CC</code>-vertex region in a triangle</a></li>
<li><a href='#fr2vertsCCvert.reg.basic.tri'><p>The furthest points from vertices in each <code class="reqn">CC</code>-vertex region</p>
in a standard basic triangle</a></li>
<li><a href='#funsAB2CMTe'><p>The lines joining two vertices to the center of mass</p>
in standard equilateral triangle</a></li>
<li><a href='#funsAB2MTe'><p>The lines joining the three vertices of</p>
the standard equilateral triangle to a center, <code>M</code>, of it</a></li>
<li><a href='#funsCartBary'><p>Converts of a point in Cartesian coordinates to Barycentric coordinates</p>
and vice versa</a></li>
<li><a href='#funsCSEdgeRegs'><p>Each function is for the presence of an arc from a point in one of the edge regions</p>
to another for Central Similarity Proximity Catch Digraphs (CS-PCDs) - standard equilateral triangle case</a></li>
<li><a href='#funsCSGamTe'><p>The function <code>gammakCSstd.tri</code> is for <code class="reqn">k</code> (<code class="reqn">k=2,3,4,5</code>) points constituting a dominating set for Central Similarity</p>
Proximity Catch Digraphs (CS-PCDs) - standard equilateral triangle case</a></li>
<li><a href='#funsCSt1EdgeRegs'><p>Each function is for the presence of an arc from a point in one of the edge regions</p>
to another for Central Similarity Proximity Catch Digraphs (CS-PCDs) -
standard equilateral triangle case with <code class="reqn">t=1</code></a></li>
<li><a href='#funsIndDelTri'><p>Functions provide the indices of the Delaunay triangles</p>
where the points reside</a></li>
<li><a href='#funsMuVarCS1D'><p>Returning the mean and (asymptotic) variance of arc density of Central Similarity Proximity Catch Digraph (CS-PCD)</p>
for 1D data - middle interval case</a></li>
<li><a href='#funsMuVarCS2D'><p>Returns the mean and (asymptotic) variance of arc density of  Central Similarity Proximity Catch Digraph (CS-PCD)</p>
for 2D uniform data in one triangle</a></li>
<li><a href='#funsMuVarCSend.int'><p>Returns the mean and (asymptotic) variance of arc density of Central Similarity Proximity Catch Digraph (CS-PCD)</p>
for 1D data - end-interval case</a></li>
<li><a href='#funsMuVarPE1D'><p>Returns the mean and (asymptotic) variance of arc density of Proportional Edge Proximity</p>
Catch Digraph (PE-PCD) for 1D data - middle interval case</a></li>
<li><a href='#funsMuVarPE2D'><p>Returns the mean and (asymptotic) variance of arc density of</p>
Proportional Edge Proximity Catch Digraph (PE-PCD)
for 2D uniform data in one triangle</a></li>
<li><a href='#funsMuVarPEend.int'><p>Returns the mean and (asymptotic) variance of arc density of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) for 1D data - end-interval case</a></li>
<li><a href='#funsPDomNum2PE1D'><p>The functions for probability of domination number <code class="reqn">= 2</code> for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - middle interval case</a></li>
<li><a href='#funsRankOrderTe'><p>Returns the ranks and orders of points in decreasing distance</p>
to the edges of the triangle</a></li>
<li><a href='#funsTbMid2CC'><p>Two functions <code>lineD1CCinTb</code> and <code>lineD2CCinTb</code> which are of class <code>"TriLines"</code> &mdash;</p>
The lines joining the midpoints of edges to the circumcenter (<code class="reqn">CC</code>) in the standard basic triangle.</a></li>
<li><a href='#IarcASbasic.tri'><p>The indicator for the presence of an arc from a point to another</p>
for Arc Slice Proximity Catch Digraphs
(AS-PCDs) - standard basic triangle case</a></li>
<li><a href='#IarcASset2pnt.tri'><p>The indicator for the presence of an arc from a point in set <code>S</code> to the point <code>p</code> for</p>
Arc Slice Proximity Catch Digraphs (AS-PCDs) - one triangle case</a></li>
<li><a href='#IarcAStri'><p>The indicator for the presence of an arc from a point to another for</p>
Arc Slice Proximity Catch Digraphs (AS-PCDs) - one triangle case</a></li>
<li><a href='#IarcCS.Te.onesixth'><p>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch</p>
Digraphs (CS-PCDs) - first one-sixth of the standard equilateral triangle case</a></li>
<li><a href='#IarcCSbasic.tri'><p>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch</p>
Digraphs (CS-PCDs) - standard basic triangle case</a></li>
<li><a href='#IarcCSedge.reg.std.tri'><p>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch</p>
Digraphs (CS-PCDs) - standard equilateral triangle case</a></li>
<li><a href='#IarcCSend.int'><p>The indicator for the presence of an arc from a point to another for</p>
Central Similarity Proximity Catch Digraphs (CS-PCDs) - end-interval case</a></li>
<li><a href='#IarcCSint'><p>The indicator for the presence of an arc from a point to another for</p>
Central Similarity  Proximity Catch Digraphs (CS-PCDs) - one interval case</a></li>
<li><a href='#IarcCSmid.int'><p>The indicator for the presence of an arc from a point to another for Central Similarity</p>
Proximity Catch Digraphs (CS-PCDs) - middle interval case</a></li>
<li><a href='#IarcCSset2pnt.std.tri'><p>The indicator for the presence of an arc from a point in set <code>S</code> to the point <code>p</code> for Central Similarity</p>
Proximity Catch Digraphs (CS-PCDs) - standard equilateral triangle case</a></li>
<li><a href='#IarcCSset2pnt.tri'><p>The indicator for the presence of an arc from a point in set <code>S</code> to the point <code>p</code> for</p>
Central Similarity Proximity Catch Digraphs (CS-PCDs) - one triangle case</a></li>
<li><a href='#IarcCSstd.tri'><p>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch</p>
Digraphs (CS-PCDs) - standard equilateral triangle case</a></li>
<li><a href='#IarcCSt1.std.tri'><p>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch</p>
Digraphs (CS-PCDs) - standard equilateral triangle case with <code class="reqn">t=1</code></a></li>
<li><a href='#IarcCStri'><p>The indicator for the presence of an arc from one point to another for Central Similarity Proximity</p>
Catch Digraphs (CS-PCDs)</a></li>
<li><a href='#IarcCStri.alt'><p>An alternative to the function <code>IarcCStri</code> which yields the indicator</p>
for the presence of an arc from one point to another
for Central Similarity Proximity Catch Digraphs (CS-PCDs)</a></li>
<li><a href='#IarcPEbasic.tri'><p>The indicator for the presence of an arc from a point to another for</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard basic triangle case</a></li>
<li><a href='#IarcPEend.int'><p>The indicator for the presence of an arc from a point to another for</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs) - end-interval case</a></li>
<li><a href='#IarcPEint'><p>The indicator for the presence of an arc from a point to another for</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs) - one interval case</a></li>
<li><a href='#IarcPEmid.int'><p>The indicator for the presence of an arc from a point to another for Proportional Edge</p>
Proximity Catch Digraphs (PE-PCDs) - middle interval case</a></li>
<li><a href='#IarcPEset2pnt.std.tri'><p>The indicator for the presence of an arc from a point</p>
in set <code>S</code> to the point <code>p</code> or
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard equilateral triangle case</a></li>
<li><a href='#IarcPEset2pnt.tri'><p>The indicator for the presence of an arc from a point in set <code>S</code></p>
to the point <code>p</code> for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - one triangle case</a></li>
<li><a href='#IarcPEstd.tetra'><p>The indicator for the presence of an arc from a point to another for Proportional Edge Proximity Catch</p>
Digraphs (PE-PCDs) - standard regular tetrahedron case</a></li>
<li><a href='#IarcPEstd.tri'><p>The indicator for the presence of an arc from a point to another</p>
for Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard equilateral triangle case</a></li>
<li><a href='#IarcPEtetra'><p>The indicator for the presence of an arc from one 3D point to another 3D point for</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs)</a></li>
<li><a href='#IarcPEtri'><p>The indicator for the presence of an arc from a point to another</p>
for Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
one triangle case</a></li>
<li><a href='#Idom.num.up.bnd'><p>Indicator for an upper bound for the domination number</p>
by the exact algorithm</a></li>
<li><a href='#Idom.num1ASbasic.tri'><p>The indicator for a point being a dominating point for</p>
Arc Slice Proximity Catch Digraphs
(AS-PCDs) - standard basic triangle case</a></li>
<li><a href='#Idom.num1AStri'><p>The indicator for a point being a dominating point for Arc Slice Proximity Catch Digraphs</p>
(AS-PCDs) - one triangle case</a></li>
<li><a href='#Idom.num1CS.Te.onesixth'><p>The indicator for a point being a dominating point for Central Similarity Proximity Catch Digraphs (CS-PCDs)</p>
- first one-sixth of the standard equilateral triangle case</a></li>
<li><a href='#Idom.num1CSint'><p>The indicator for a point being a dominating point for Central Similarity</p>
Proximity Catch Digraphs (CS-PCDs) for an interval</a></li>
<li><a href='#Idom.num1CSstd.tri'><p>The indicator for a point being a dominating point for Central Similarity Proximity Catch Digraphs</p>
(CS-PCDs) - standard equilateral triangle case</a></li>
<li><a href='#Idom.num1CSt1std.tri'><p>The indicator for a point being a dominating point for Central Similarity Proximity Catch Digraphs</p>
(CS-PCDs) - standard equilateral triangle case with <code class="reqn">t=1</code></a></li>
<li><a href='#Idom.num1PEbasic.tri'><p>The indicator for a point being a dominating point or not for</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard basic triangle case</a></li>
<li><a href='#Idom.num1PEint'><p>The indicator for a point being a dominating point for Proportional Edge</p>
Proximity Catch Digraphs (PE-PCDs) for an interval</a></li>
<li><a href='#Idom.num1PEstd.tetra'><p>The indicator for a 3D point being a dominating point for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - standard regular tetrahedron case</a></li>
<li><a href='#Idom.num1PEtetra'><p>The indicator for a 3D point being a dominating point for Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
- one tetrahedron case</a></li>
<li><a href='#Idom.num1PEtri'><p>The indicator for a point being a dominating point for</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
one triangle case</a></li>
<li><a href='#Idom.num2ASbasic.tri'><p>The indicator for two points being a dominating set for Arc Slice Proximity Catch Digraphs</p>
(AS-PCDs) - standard basic triangle case</a></li>
<li><a href='#Idom.num2AStri'><p>The indicator for two points constituting a dominating set for Arc Slice Proximity Catch Digraphs</p>
(AS-PCDs) - one triangle case</a></li>
<li><a href='#Idom.num2CS.Te.onesixth'><p>The indicator for two points constituting a dominating set for Central Similarity Proximity Catch Digraphs</p>
(CS-PCDs) - first one-sixth of the standard equilateral triangle case</a></li>
<li><a href='#Idom.num2PEbasic.tri'><p>The indicator for two points being a dominating set for</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard basic triangle case</a></li>
<li><a href='#Idom.num2PEstd.tetra'><p>The indicator for two 3D points constituting a dominating set for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - standard regular tetrahedron case</a></li>
<li><a href='#Idom.num2PEtetra'><p>The indicator for two 3D points constituting a dominating set for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - one tetrahedron case</a></li>
<li><a href='#Idom.num2PEtri'><p>The indicator for two points constituting a dominating set for</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
one triangle case</a></li>
<li><a href='#Idom.num3PEstd.tetra'><p>The indicator for three 3D points constituting a dominating set for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - standard regular tetrahedron case</a></li>
<li><a href='#Idom.num3PEtetra'><p>The indicator for three 3D points constituting a dominating set for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - one tetrahedron case</a></li>
<li><a href='#Idom.numASup.bnd.tri'><p>Indicator for an upper bound for the domination number of Arc Slice Proximity Catch Digraph</p>
(AS-PCD) by the exact algorithm - one triangle case</a></li>
<li><a href='#Idom.numCSup.bnd.std.tri'><p>The indicator for <code>k</code> being an upper bound for the domination number of Central Similarity Proximity</p>
Catch Digraph (CS-PCD) by the exact algorithm - standard equilateral triangle case</a></li>
<li><a href='#Idom.numCSup.bnd.tri'><p>Indicator for an upper bound for the domination number of Central Similarity Proximity Catch Digraph</p>
(CS-PCD) by the exact algorithm - one triangle case</a></li>
<li><a href='#Idom.setAStri'><p>The indicator for the set of points <code>S</code> being a dominating set or not for Arc Slice Proximity</p>
Catch Digraphs (AS-PCDs) - one triangle case</a></li>
<li><a href='#Idom.setCSstd.tri'><p>The indicator for the set of points <code>S</code> being a dominating set or not for Central Similarity Proximity</p>
Catch Digraphs (CS-PCDs) - standard equilateral triangle case</a></li>
<li><a href='#Idom.setCStri'><p>The indicator for the set of points <code>S</code> being a dominating set or not for Central Similarity Proximity</p>
Catch Digraphs (CS-PCDs) - one triangle case</a></li>
<li><a href='#Idom.setPEstd.tri'><p>The indicator for the set of points <code>S</code> being a dominating set</p>
or not for Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard equilateral triangle case</a></li>
<li><a href='#Idom.setPEtri'><p>The indicator for the set of points <code>S</code> being a dominating set</p>
or not for Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
one triangle case</a></li>
<li><a href='#in.circle'><p>Check whether a point is inside a circle</p></a></li>
<li><a href='#in.tetrahedron'><p>Check whether a point is inside a tetrahedron</p></a></li>
<li><a href='#in.tri.all'><p>Check whether all points in a data set are inside the triangle</p></a></li>
<li><a href='#in.triangle'><p>Check whether a point is inside a triangle</p></a></li>
<li><a href='#inci.matAS'><p>Incidence matrix for Arc Slice Proximity Catch Digraphs (AS-PCDs)</p>
- multiple triangle case</a></li>
<li><a href='#inci.matAStri'><p>Incidence matrix for Arc Slice Proximity Catch Digraphs</p>
(AS-PCDs) - one triangle case</a></li>
<li><a href='#inci.matCS'><p>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs) - multiple triangle case</p></a></li>
<li><a href='#inci.matCS1D'><p>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs)</p>
for 1D data - multiple interval case</a></li>
<li><a href='#inci.matCSint'><p>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs)</p>
for 1D data - one interval case</a></li>
<li><a href='#inci.matCSstd.tri'><p>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs) - standard</p>
equilateral triangle case</a></li>
<li><a href='#inci.matCStri'><p>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs) - one triangle case</p></a></li>
<li><a href='#inci.matPE'><p>Incidence matrix for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - multiple triangle case</a></li>
<li><a href='#inci.matPE1D'><p>Incidence matrix for Proportional-Edge Proximity Catch Digraphs (PE-PCDs)</p>
for 1D data - multiple interval case</a></li>
<li><a href='#inci.matPEint'><p>Incidence matrix for Proportional-Edge Proximity Catch Digraphs (PE-PCDs)</p>
for 1D data - one interval case</a></li>
<li><a href='#inci.matPEstd.tri'><p>Incidence matrix for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - standard equilateral triangle case</a></li>
<li><a href='#inci.matPEtetra'><p>Incidence matrix for Proportional Edge Proximity Catch Digraphs (PE-PCDs) - one tetrahedron case</p></a></li>
<li><a href='#inci.matPEtri'><p>Incidence matrix for Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - one triangle case</a></li>
<li><a href='#index.six.Te'><p>Region index inside the Gamma-1 region</p></a></li>
<li><a href='#intersect.line.circle'><p>The points of intersection of a line and a circle</p></a></li>
<li><a href='#intersect.line.plane'><p>The point of intersection of a line and a plane</p></a></li>
<li><a href='#intersect2lines'><p>The point of intersection of two lines defined</p>
by two pairs of points</a></li>
<li><a href='#interval.indices.set'><p>Indices of the intervals where the 1D point(s) reside</p></a></li>
<li><a href='#is.in.data'><p>Check a point belong to a given data set</p></a></li>
<li><a href='#is.point'><p>Check the argument is a point of a given dimension</p></a></li>
<li><a href='#is.std.eq.tri'><p>Check whether a triangle is a standard equilateral triangle</p></a></li>
<li><a href='#kfr2vertsCCvert.reg'><p>The <code>k</code> furthest points in a data set from vertices</p>
in each <code class="reqn">CC</code>-vertex region in a triangle</a></li>
<li><a href='#kfr2vertsCCvert.reg.basic.tri'><p>The <code>k</code> furthest points from vertices</p>
in each <code class="reqn">CC</code>-vertex region in a standard basic triangle</a></li>
<li><a href='#Line'><p>The line joining two distinct 2D points</p>
<code>a</code> and <code>b</code></a></li>
<li><a href='#Line3D'><p>The line crossing 3D point <code>p</code></p>
in the direction of <code>vector</code> <code>v</code> (or if <code>v</code> is a point,
in direction of <code class="reqn">v-r_0</code>)</a></li>
<li><a href='#NASbasic.tri'><p>The vertices of the Arc Slice (AS) Proximity Region in the standard basic triangle</p></a></li>
<li><a href='#NAStri'><p>The vertices of the Arc Slice (AS) Proximity Region in a general triangle</p></a></li>
<li><a href='#NCSint'><p>The end points of the Central Similarity (CS) Proximity Region for a point - one interval case</p></a></li>
<li><a href='#NCStri'><p>The vertices of the Central Similarity (CS) Proximity Region in a general triangle</p></a></li>
<li><a href='#NPEbasic.tri'><p>The vertices of the Proportional Edge (PE) Proximity Region</p>
in a standard basic triangle</a></li>
<li><a href='#NPEint'><p>The end points of the Proportional Edge (PE) Proximity Region for a point - one interval case</p></a></li>
<li><a href='#NPEstd.tetra'><p>The vertices of the Proportional Edge (PE) Proximity Region in the standard regular tetrahedron</p></a></li>
<li><a href='#NPEtetra'><p>The vertices of the Proportional Edge (PE) Proximity Region in a tetrahedron</p></a></li>
<li><a href='#NPEtri'><p>The vertices of the Proportional Edge (PE) Proximity Region</p>
in a general triangle</a></li>
<li><a href='#num.arcsAS'><p>Number of arcs of Arc Slice Proximity Catch Digraphs (AS-PCDs)</p>
and related quantities of the induced subdigraphs
for points in the Delaunay triangles - multiple triangle case</a></li>
<li><a href='#num.arcsAStri'><p>Number of arcs of Arc Slice Proximity Catch Digraphs (AS-PCDs)</p>
and quantities related to the triangle - one triangle case</a></li>
<li><a href='#num.arcsCS'><p>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)</p>
and related quantities of the induced subdigraphs for points in the Delaunay triangles -
multiple triangle case</a></li>
<li><a href='#num.arcsCS1D'><p>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)</p>
and related quantities of the induced subdigraphs for points in the partition intervals -
multiple interval case</a></li>
<li><a href='#num.arcsCSend.int'><p>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs) - end-interval case</p></a></li>
<li><a href='#num.arcsCSint'><p>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)</p>
and quantities related to the interval - one interval case</a></li>
<li><a href='#num.arcsCSmid.int'><p>Number of Arcs of of Central Similarity Proximity Catch Digraphs (CS-PCDs) - middle interval case</p></a></li>
<li><a href='#num.arcsCSstd.tri'><p>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)</p>
and quantities related to the triangle - standard equilateral triangle case</a></li>
<li><a href='#num.arcsCStri'><p>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)</p>
and quantities related to the triangle - one triangle case</a></li>
<li><a href='#num.arcsPE'><p>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
and related quantities of the induced subdigraphs for points in the Delaunay triangles -
multiple triangle case</a></li>
<li><a href='#num.arcsPE1D'><p>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
and related quantities of the induced subdigraphs for points in the partition intervals -
multiple interval case</a></li>
<li><a href='#num.arcsPEend.int'><p>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs) - end-interval case</p></a></li>
<li><a href='#num.arcsPEint'><p>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
and quantities related to the interval - one interval case</a></li>
<li><a href='#num.arcsPEmid.int'><p>Number of Arcs for Proportional Edge Proximity Catch Digraphs (PE-PCDs) - middle interval case</p></a></li>
<li><a href='#num.arcsPEstd.tri'><p>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
and quantities related to the triangle - standard equilateral triangle case</a></li>
<li><a href='#num.arcsPEtetra'><p>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
and quantities related to the tetrahedron - one tetrahedron case</a></li>
<li><a href='#num.arcsPEtri'><p>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
and quantities related to the triangle - one triangle case</a></li>
<li><a href='#num.delaunay.tri'><p>Number of Delaunay triangles based on a 2D data set</p></a></li>
<li><a href='#paraline'><p>The line at a point <code>p</code> parallel to the line segment</p>
joining two distinct 2D points <code>a</code> and <code>b</code></a></li>
<li><a href='#paraline3D'><p>The line crossing the 3D point <code>p</code></p>
and parallel to line joining 3D points <code>a</code> and <code>b</code></a></li>
<li><a href='#paraplane'><p>The plane at a point and parallel to the plane spanned</p>
by three distinct 3D points <code>a</code>, <code>b</code>, and <code>c</code></a></li>
<li><a href='#Pdom.num2PE1Dasy'><p>The asymptotic probability of domination number <code class="reqn">= 2</code> for Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
- middle interval case</a></li>
<li><a href='#Pdom.num2PEtri'><p>Asymptotic probability that domination number of</p>
Proportional Edge Proximity Catch Digraphs (PE-PCDs) equals 2
where vertices of the digraph are uniform points in a triangle</a></li>
<li><a href='#PEarc.dens.test'><p>A test of segregation/association</p>
based on arc density of Proportional Edge Proximity Catch Digraph
(PE-PCD) for 2D data</a></li>
<li><a href='#PEarc.dens.test.int'><p>A test of uniformity of 1D data in a given interval based on Proportional Edge Proximity Catch Digraph</p>
(PE-PCD)</a></li>
<li><a href='#PEarc.dens.test1D'><p>A test of segregation/association based on arc density of</p>
Proportional Edge Proximity Catch Digraph
(PE-PCD) for 1D data</a></li>
<li><a href='#PEarc.dens.tetra'><p>Arc density of Proportional Edge Proximity Catch Digraphs (PE-PCDs) - one tetrahedron case</p></a></li>
<li><a href='#PEarc.dens.tri'><p>Arc density of Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) - one triangle case</a></li>
<li><a href='#PEdom.num'><p>The domination number of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) - multiple triangle case</a></li>
<li><a href='#PEdom.num.binom.test'><p>A test of segregation/association based on domination number of</p>
Proportional Edge Proximity Catch Digraph (PE-PCD) for 2D data -
Binomial Approximation</a></li>
<li><a href='#PEdom.num.binom.test1D'><p>A test of segregation/association based on domination number of</p>
Proportional Edge Proximity Catch Digraph
(PE-PCD) for 1D data - Binomial Approximation</a></li>
<li><a href='#PEdom.num.binom.test1Dint'><p>A test of uniformity for 1D data based on domination number of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) - Binomial Approximation</a></li>
<li><a href='#PEdom.num.nondeg'><p>The domination number of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) with non-degeneracy centers - multiple triangle case</a></li>
<li><a href='#PEdom.num.norm.test'><p>A test of segregation/association based on domination number of</p>
Proportional Edge Proximity Catch Digraph (PE-PCD) for 2D data -
Normal Approximation</a></li>
<li><a href='#PEdom.num.tetra'><p>The domination number of Proportional Edge Proximity Catch Digraph (PE-PCD) - one tetrahedron case</p></a></li>
<li><a href='#PEdom.num.tri'><p>The domination number of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) - one triangle case</a></li>
<li><a href='#PEdom.num1D'><p>The domination number of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) for 1D data</a></li>
<li><a href='#PEdom.num1Dnondeg'><p>The domination number of Proportional Edge Proximity Catch Digraph (PE-PCD) with</p>
non-degeneracy centers - multiple interval case</a></li>
<li><a href='#perpline'><p>The line passing through a point and perpendicular</p>
to the line segment joining two points</a></li>
<li><a href='#perpline2plane'><p>The line crossing the 3D point <code>p</code></p>
and perpendicular to the plane spanned by 3D points <code>a</code>,
<code>b</code>, and <code>c</code></a></li>
<li><a href='#Plane'><p>The plane passing through three distinct 3D points</p>
<code>a</code>, <code>b</code>, and <code>c</code></a></li>
<li><a href='#plot.Extrema'><p>Plot an <code>Extrema</code> <code>object</code></p></a></li>
<li><a href='#plot.Lines'><p>Plot a <code>Lines</code> <code>object</code></p></a></li>
<li><a href='#plot.Lines3D'><p>Plot a <code>Lines3D</code> <code>object</code></p></a></li>
<li><a href='#plot.NumArcs'><p>Plot a <code>NumArcs</code> <code>object</code></p></a></li>
<li><a href='#plot.Patterns'><p>Plot a <code>Patterns</code> <code>object</code></p></a></li>
<li><a href='#plot.PCDs'><p>Plot a <code>PCDs</code> <code>object</code></p></a></li>
<li><a href='#plot.Planes'><p>Plot a <code>Planes</code> <code>object</code></p></a></li>
<li><a href='#plot.TriLines'><p>Plot a <code>TriLines</code> <code>object</code></p></a></li>
<li><a href='#plot.Uniform'><p>Plot a <code>Uniform</code> <code>object</code></p></a></li>
<li><a href='#plotASarcs'><p>The plot of the arcs of Arc Slice Proximity Catch Digraph (AS-PCD)</p>
for a 2D data set -
multiple triangle case</a></li>
<li><a href='#plotASarcs.tri'><p>The plot of the arcs of Arc Slice Proximity Catch Digraph (AS-PCD)</p>
for a 2D data set - one triangle case</a></li>
<li><a href='#plotASregs'><p>The plot of the Arc Slice (AS) Proximity Regions for a 2D data set - multiple triangle case</p></a></li>
<li><a href='#plotASregs.tri'><p>The plot of the Arc Slice (AS) Proximity Regions for a 2D data set - one triangle case</p></a></li>
<li><a href='#plotCSarcs'><p>The plot of the arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for a</p>
2D data set - multiple triangle case</a></li>
<li><a href='#plotCSarcs.int'><p>The plot of the arcs of Central Similarity Proximity Catch Digraphs</p>
(CS-PCDs) for 1D data
(vertices jittered along <code class="reqn">y</code>-coordinate) - one interval case</a></li>
<li><a href='#plotCSarcs.tri'><p>The plot of the arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for a</p>
2D data set - one triangle case</a></li>
<li><a href='#plotCSarcs1D'><p>The plot of the arcs of Central Similarity Proximity Catch Digraphs</p>
(CS-PCDs) for 1D data
(vertices jittered along <code class="reqn">y</code>-coordinate) - multiple interval case</a></li>
<li><a href='#plotCSregs'><p>The plot of the Central Similarity (CS) Proximity Regions for a 2D data set - multiple triangle case</p></a></li>
<li><a href='#plotCSregs.int'><p>The plot of the Central Similarity (CS) Proximity Regions for a general interval</p>
(vertices jittered along <code class="reqn">y</code>-coordinate) - one interval case</a></li>
<li><a href='#plotCSregs.tri'><p>The plot of the Central Similarity (CS) Proximity Regions for a 2D data set - one triangle case</p></a></li>
<li><a href='#plotCSregs1D'><p>The plot of the Central Similarity (CS) Proximity Regions</p>
(vertices jittered along <code class="reqn">y</code>-coordinate)
- multiple interval case</a></li>
<li><a href='#plotDelaunay.tri'><p>The scatterplot of points from one class and</p>
plot of the Delaunay triangulation of the other class</a></li>
<li><a href='#plotIntervals'><p>The plot of the subintervals based on <code>Yp</code> points</p>
together with <code>Xp</code> points</a></li>
<li><a href='#plotPEarcs'><p>The plot of the arcs of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) for a 2D data set - multiple triangle case</a></li>
<li><a href='#plotPEarcs.int'><p>The plot of the arcs of Proportional Edge Proximity Catch Digraphs</p>
(PE-PCDs) for 1D data
(vertices jittered along <code class="reqn">y</code>-coordinate) - one interval case</a></li>
<li><a href='#plotPEarcs.tri'><p>The plot of the arcs of Proportional Edge Proximity Catch Digraph</p>
(PE-PCD) for a 2D data set - one triangle case</a></li>
<li><a href='#plotPEarcs1D'><p>The plot of the arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</p>
for 1D data (vertices jittered along <code class="reqn">y</code>-coordinate) - multiple interval case</a></li>
<li><a href='#plotPEregs'><p>The plot of the Proportional Edge (PE) Proximity Regions</p>
for a 2D data set - multiple triangle case</a></li>
<li><a href='#plotPEregs.int'><p>The plot of the Proportional Edge (PE) Proximity Regions for a general interval</p>
(vertices jittered along <code class="reqn">y</code>-coordinate) - one interval case</a></li>
<li><a href='#plotPEregs.std.tetra'><p>The plot of the Proportional Edge (PE) Proximity Regions for a 3D data set - standard</p>
regular tetrahedron case</a></li>
<li><a href='#plotPEregs.tetra'><p>The plot of the Proportional Edge (PE) Proximity Regions for a 3D data set - one tetrahedron case</p></a></li>
<li><a href='#plotPEregs.tri'><p>The plot of the Proportional Edge (PE) Proximity Regions</p>
for a 2D data set - one triangle case</a></li>
<li><a href='#plotPEregs1D'><p>The plot of the Proportional Edge (PE) Proximity Regions</p>
(vertices jittered along <code class="reqn">y</code>-coordinate)
- multiple interval case</a></li>
<li><a href='#print.Extrema'><p>Print a <code>Extrema</code> <code>object</code></p></a></li>
<li><a href='#print.Lines'><p>Print a <code>Lines</code> <code>object</code></p></a></li>
<li><a href='#print.Lines3D'><p>Print a <code>Lines3D</code> <code>object</code></p></a></li>
<li><a href='#print.NumArcs'><p>Print a <code>NumArcs</code> <code>object</code></p></a></li>
<li><a href='#print.Patterns'><p>Print a <code>Patterns</code> <code>object</code></p></a></li>
<li><a href='#print.PCDs'><p>Print a <code>PCDs</code> <code>object</code></p></a></li>
<li><a href='#print.Planes'><p>Print a <code>Planes</code> <code>object</code></p></a></li>
<li><a href='#print.summary.Extrema'><p>Print a summary of a <code>Extrema</code> <code>object</code></p></a></li>
<li><a href='#print.summary.Lines'><p>Print a summary of a <code>Lines</code> <code>object</code></p></a></li>
<li><a href='#print.summary.Lines3D'><p>Print a summary of a <code>Lines3D</code> <code>object</code></p></a></li>
<li><a href='#print.summary.NumArcs'><p>Print a summary of a <code>NumArcs</code> <code>object</code></p></a></li>
<li><a href='#print.summary.Patterns'><p>Print a summary of a <code>Patterns</code> <code>object</code></p></a></li>
<li><a href='#print.summary.PCDs'><p>Print a summary of a <code>PCDs</code> <code>object</code></p></a></li>
<li><a href='#print.summary.Planes'><p>Print a summary of a <code>Planes</code> <code>object</code></p></a></li>
<li><a href='#print.summary.TriLines'><p>Print a summary of a <code>TriLines</code> <code>object</code></p></a></li>
<li><a href='#print.summary.Uniform'><p>Print a summary of a <code>Uniform</code> <code>object</code></p></a></li>
<li><a href='#print.TriLines'><p>Print a <code>TriLines</code> <code>object</code></p></a></li>
<li><a href='#print.Uniform'><p>Print a <code>Uniform</code> <code>object</code></p></a></li>
<li><a href='#prj.cent2edges'><p>Projections of a point inside a triangle to its edges</p></a></li>
<li><a href='#prj.cent2edges.basic.tri'><p>Projections of a point inside the standard basic triangle form</p>
to its edges</a></li>
<li><a href='#prj.nondegPEcent2edges'><p>Projections of Centers for non-degenerate asymptotic distribution of</p>
domination number of Proportional Edge Proximity Catch Digraphs
(PE-PCDs) to its edges</a></li>
<li><a href='#radii'><p>The radii of points from one class with respect to points</p>
from the other class</a></li>
<li><a href='#radius'><p>The radius of a point from one class with respect</p>
to points from the other class</a></li>
<li><a href='#rassoc.circular'><p>Generation of points associated (in a radial or circular fashion)</p>
with a given set of points</a></li>
<li><a href='#rassoc.matern'><p>Generation of points associated (in a Matern-like fashion)</p>
to a given set of points</a></li>
<li><a href='#rassoc.multi.tri'><p>Generation of points associated (in a Type I fashion)</p>
with a given set of points</a></li>
<li><a href='#rassoc.std.tri'><p>Generation of points associated (in a Type I fashion)</p>
with the vertices of <code class="reqn">T_e</code></a></li>
<li><a href='#rassoc.tri'><p>Generation of points associated (in a Type I fashion)</p>
with the vertices of a triangle</a></li>
<li><a href='#rassocII.std.tri'><p>Generation of points associated (in a Type II fashion)</p>
with the edges of <code class="reqn">T_e</code></a></li>
<li><a href='#rel.edge.basic.tri'><p>The index of the edge region in a</p>
standard basic triangle form that contains a point</a></li>
<li><a href='#rel.edge.basic.triCM'><p>The index of the <code class="reqn">CM</code>-edge region</p>
in a standard basic triangle form that contains a point</a></li>
<li><a href='#rel.edge.std.triCM'><p>The index of the edge region in the standard equilateral triangle</p>
that contains a point</a></li>
<li><a href='#rel.edge.tri'><p>The index of the edge region in a triangle that contains the point</p></a></li>
<li><a href='#rel.edge.triCM'><p>The index of the <code class="reqn">CM</code>-edge region in a triangle</p>
that contains the point</a></li>
<li><a href='#rel.edges.tri'><p>The indices of the <code>M</code>-edge regions in a triangle</p>
that contains the points in a give data set</a></li>
<li><a href='#rel.edges.triCM'><p>The indices of the <code class="reqn">CM</code>-edge regions in a triangle</p>
that contains the points in a give data set</a></li>
<li><a href='#rel.vert.basic.tri'><p>The index of the vertex region in a standard basic triangle form</p>
that contains a given point</a></li>
<li><a href='#rel.vert.basic.triCC'><p>The index of the <code class="reqn">CC</code>-vertex region</p>
in a standard basic triangle form that contains a point</a></li>
<li><a href='#rel.vert.basic.triCM'><p>The index of the <code class="reqn">CM</code>-vertex region</p>
in a standard basic triangle form that contains a point</a></li>
<li><a href='#rel.vert.end.int'><p>The index of the vertex region in an end-interval</p>
that contains a given point</a></li>
<li><a href='#rel.vert.mid.int'><p>The index of the vertex region in a middle interval</p>
that contains a given point</a></li>
<li><a href='#rel.vert.std.tri'><p>The index of the vertex region in the standard equilateral triangle</p>
that contains a given point</a></li>
<li><a href='#rel.vert.std.triCM'><p>The index of the <code class="reqn">CM</code>-vertex region</p>
in the standard equilateral triangle that contains a given point</a></li>
<li><a href='#rel.vert.tetraCC'><p>The index of the <code class="reqn">CC</code>-vertex region in a tetrahedron</p>
that contains a point</a></li>
<li><a href='#rel.vert.tetraCM'><p>The index of the <code class="reqn">CM</code>-vertex region in a tetrahedron</p>
that contains a point</a></li>
<li><a href='#rel.vert.tri'><p>The index of the vertex region in a triangle</p>
that contains a given point</a></li>
<li><a href='#rel.vert.triCC'><p>The index of the <code class="reqn">CC</code>-vertex region in a triangle</p>
that contains a point</a></li>
<li><a href='#rel.vert.triCM'><p>The index of the <code class="reqn">CM</code>-vertex region in a triangle that contains a given point</p></a></li>
<li><a href='#rel.verts.tri'><p>The indices of the vertex regions in a triangle</p>
that contains the points in a give data set</a></li>
<li><a href='#rel.verts.tri.nondegPE'><p>The indices of the vertex regions in a triangle</p>
that contains the points in a give data set</a></li>
<li><a href='#rel.verts.triCC'><p>The indices of the <code class="reqn">CC</code>-vertex regions in a triangle</p>
that contains the points in a give data set.</a></li>
<li><a href='#rel.verts.triCM'><p>The indices of the <code class="reqn">CM</code>-vertex regions in a triangle</p>
that contains the points in a give data set</a></li>
<li><a href='#rel.verts.triM'><p>The alternative function for the indices of the M-vertex regions</p>
in a triangle that contains the points
in a give data set</a></li>
<li><a href='#rseg.circular'><p>Generation of points segregated (in a radial or circular fashion)</p>
from a given set of points</a></li>
<li><a href='#rseg.multi.tri'><p>Generation of points segregated (in a Type I fashion)</p>
from a given set of points</a></li>
<li><a href='#rseg.std.tri'><p>Generation of points segregated (in a Type I fashion)</p>
from the vertices of <code class="reqn">T_e</code></a></li>
<li><a href='#rseg.tri'><p>Generation of points segregated (in a Type I fashion)</p>
from the vertices of a triangle</a></li>
<li><a href='#rsegII.std.tri'><p>Generation of points segregated (in a Type II fashion)</p>
from the vertices of <code class="reqn">T_e</code></a></li>
<li><a href='#runif.basic.tri'><p>Generation of Uniform Points in the standard basic triangle</p></a></li>
<li><a href='#runif.multi.tri'><p>Generation of Uniform Points in the Convex Hull of Points</p></a></li>
<li><a href='#runif.std.tetra'><p>Generation of Uniform Points</p>
in the Standard Regular Tetrahedron <code class="reqn">T_h</code></a></li>
<li><a href='#runif.std.tri'><p>Generation of Uniform Points in the Standard Equilateral Triangle</p></a></li>
<li><a href='#runif.std.tri.onesixth'><p>Generation of Uniform Points in the first one-sixth of</p>
standard equilateral triangle</a></li>
<li><a href='#runif.tetra'><p>Generation of Uniform Points in a tetrahedron</p></a></li>
<li><a href='#runif.tri'><p>Generation of Uniform Points in a Triangle</p></a></li>
<li><a href='#seg.tri.support'><p>The auxiliary triangle to define the support of type I segregation</p></a></li>
<li><a href='#six.extremaTe'><p>The closest points among a data set</p>
in the standard equilateral triangle
to the median lines in the six  half edge regions</a></li>
<li><a href='#slope'><p>The slope of a line</p></a></li>
<li><a href='#summary.Extrema'><p>Return a summary of a <code>Extrema</code> <code>object</code></p></a></li>
<li><a href='#summary.Lines'><p>Return a summary of a <code>Lines</code> <code>object</code></p></a></li>
<li><a href='#summary.Lines3D'><p>Return a summary of a <code>Lines3D</code> <code>object</code></p></a></li>
<li><a href='#summary.NumArcs'><p>Return a summary of a <code>NumArcs</code> <code>object</code></p></a></li>
<li><a href='#summary.Patterns'><p>Return a summary of a <code>Patterns</code> <code>object</code></p></a></li>
<li><a href='#summary.PCDs'><p>Return a summary of a <code>PCDs</code> <code>object</code></p></a></li>
<li><a href='#summary.Planes'><p>Return a summary of a <code>Planes</code> <code>object</code></p></a></li>
<li><a href='#summary.TriLines'><p>Return a summary of a <code>TriLines</code> <code>object</code></p></a></li>
<li><a href='#summary.Uniform'><p>Return a summary of a <code>Uniform</code> <code>object</code></p></a></li>
<li><a href='#swamptrees'><p>Tree Species in a Swamp Forest</p></a></li>
<li><a href='#tri2std.basic.tri'><p>Converting a triangle to the standard basic triangle form form</p></a></li>
<li><a href='#Xin.convex.hullY'><p>Points from one class inside the convex hull of the points</p>
from the other class</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Proximity Catch Digraphs and Their Applications</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains the functions for construction and visualization of various families 
    of the proximity catch digraphs (PCDs), see (Ceyhan (2005) ISBN:978-3-639-19063-2),
    for computing the graph invariants for testing the patterns of segregation and association against complete spatial randomness (CSR)
    or uniformity in one, two and three dimensional cases.
    The package also has tools for generating points from these spatial patterns.
    The graph invariants used in testing spatial point data are the domination number (Ceyhan (2011)
    &lt;<a href="https://doi.org/10.1080%2F03610921003597211">doi:10.1080/03610921003597211</a>&gt;) and arc density (Ceyhan et al. (2006) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2005.03.002">doi:10.1016/j.csda.2005.03.002</a>&gt;;
    Ceyhan et al. (2007) &lt;<a href="https://doi.org/10.1002%2Fcjs.5550350106">doi:10.1002/cjs.5550350106</a>&gt;). The PCD families considered are Arc-Slice PCDs,
    Proportional-Edge PCDs, and Central Similarity PCDs. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>combinat, interp, gMOIP, plot3D, plotrix, Rdpack (&ge; 0.7)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, scatterplot3d, spatstat.random, rmarkdown, bookdown,
spelling</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 22:47:26 UTC; ezc0066</td>
</tr>
<tr>
<td>Author:</td>
<td>Elvan Ceyhan [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elvan Ceyhan &lt;elvanceyhan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pcds-package'>pcds: A package for Proximity Catch Digraphs and Their Applications</h2><span id='topic+pcds'></span><span id='topic+pcds-package'></span>

<h3>Description</h3>

<p><code>pcds</code> is a package for construction and
visualization of proximity catch digraphs (PCDs)
and computation of two graph invariants of the PCDs and
testing spatial patterns using these invariants.
</p>


<h3>Details</h3>

<p>The PCD families considered are Arc-Slice (AS) PCDs,
Proportional-Edge (PE) PCDs
and Central Similarity (CS) PCDs.
</p>
<p>The graph invariants used in testing spatial point data are
the domination number (Ceyhan (2011))
and arc density (Ceyhan et al. (2006); Ceyhan et al. (2007))
of for two-dimensional data.
</p>
<p>The <code>pcds</code> package also contains the functions
for generating patterns of segregation, association, CSR
(complete spatial randomness) and Uniform data
in one, two and three dimensional cases,
for testing these patterns
based on two invariants of various families of the proximity catch digraphs (PCDs),
(see (Ceyhan (2005)).
</p>
<p>Moreover, the package has visualization tools for these digraphs for 1D-3D vertices.
The AS-PCD and CS-PCD tools are provided for 1D and 2D data
and PE-PCD related tools are provided for 1D-3D data.
</p>


<h3>The <code>pcds</code> functions</h3>

<p>The <code>pcds</code> functions can be grouped as
Auxiliary Functions,
AS-PCD Functions,
PE-PCD Functions,
and CS-PCD Functions.
</p>


<h3>Auxiliary Functions</h3>

<p>Contains the auxiliary (or utility) functions for constructing and
visualizing Delaunay tessellations in 1D and 2D settings,
computing the domination number,
constructing the geometrical tools,
such as equation of lines for two points,
distances between lines and points, checking points inside the triangle etc.,
finding the (local) extrema (restricted to Delaunay cells
or vertex or edge regions in them).
</p>


<h3>Arc-Slice PCD Functions</h3>

<p>Contains the functions used in AS-PCD construction,
estimation of domination number,
arc density, etc in the 2D setting.
</p>


<h3>Proportional-Edge PCD Functions</h3>

<p>Contains the functions used in PE-PCD construction,
estimation of domination number,
arc density, etc in the 1D-3D settings.
</p>


<h3>Central-Similarity PCD Functions</h3>

<p>Contains the functions used in CS-PCD construction,
estimation of domination number,
arc density, etc in the 1D and 2D setting.
</p>


<h3>Point Generation Functions</h3>

<p>Contains functions for generation of points from uniform (or CSR),
segregation and association patterns.
</p>
<p>In all these functions points are vectors,
and data sets are either matrices or data frames.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Elvan Ceyhan <a href="mailto:elvanceyhan@gmail.com">elvanceyhan@gmail.com</a>
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>

<hr>
<h2 id='.onAttach'>.onAttach start message</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>.onAttach start message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>defunct</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>defunct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible()
</p>

<hr>
<h2 id='.onLoad'>.onLoad getOption package settings</h2><span id='topic+.onLoad'></span>

<h3>Description</h3>

<p>.onLoad getOption package settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onLoad(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onLoad_+3A_libname">libname</code></td>
<td>
<p>defunct</p>
</td></tr>
<tr><td><code id=".onLoad_+3A_pkgname">pkgname</code></td>
<td>
<p>defunct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getOption("pcds.name")
</code></pre>

<hr>
<h2 id='angle.str2end'>The angles to draw arcs between two line segments</h2><span id='topic+angle.str2end'></span>

<h3>Description</h3>

<p>Gives the two pairs of angles in radians or degrees to draw arcs between two vectors or line segments
for the <code><a href="plotrix.html#topic+draw.arc">draw.arc</a></code> function in the <code>plotrix</code> package.
The angles are provided with respect to the <code class="reqn">x</code>-axis in the coordinate system.
The line segments are <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code> when the argument is given as <code>a,b,c</code> in the function.
</p>
<p><code>radian</code> is a logical argument (default=<code>TRUE</code>) which yields the angle in radians if <code>TRUE</code>, and in degrees if <code>FALSE</code>.
The first pair of angles is for drawing arcs in the smaller angle between <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code>
and the second pair of angles is for drawing arcs in the counter-clockwise order from <code class="reqn">[ba]</code> to <code class="reqn">[bc]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle.str2end(a, b, c, radian = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle.str2end_+3A_a">a</code>, <code id="angle.str2end_+3A_b">b</code>, <code id="angle.str2end_+3A_c">c</code></td>
<td>
<p>Three 2D points which represent the intersecting line segments <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code>.</p>
</td></tr>
<tr><td><code id="angle.str2end_+3A_radian">radian</code></td>
<td>
<p>A logical argument (default=<code>TRUE</code>).
If <code>TRUE</code>, the smaller angle or counter-clockwise angle
between the line segments <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code> is provided in radians, else it is provided in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>small.arc.angles</code></td>
<td>
<p>Angles of <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code> with the <code class="reqn">x</code>-axis so that difference between them
is the smaller angle between <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code> </p>
</td></tr>
<tr><td><code>ccw.arc.angles</code></td>
<td>
<p>Angles of <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code> with the <code class="reqn">x</code>-axis so that difference between them
is the counter-clockwise angle between <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+angle3pnts">angle3pnts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(.3,.2); B&lt;-c(.6,.3); C&lt;-c(1,1)

pts&lt;-rbind(A,B,C)

Xp&lt;-c(B[1]+max(abs(C[1]-B[1]),abs(A[1]-B[1])),0)

angle.str2end(A,B,C)
angle.str2end(A,B,A)

angle.str2end(A,B,C,radian=FALSE)

#plot of the line segments
ang.rad&lt;-angle.str2end(A,B,C,radian=TRUE); ang.rad
ang.deg&lt;-angle.str2end(A,B,C,radian=FALSE); ang.deg
ang.deg1&lt;-ang.deg$s; ang.deg1
ang.deg2&lt;-ang.deg$c; ang.deg2

rad&lt;-min(Dist(A,B),Dist(B,C))

Xlim&lt;-range(pts[,1],Xp[1],B+Xp,B[1]+c(+rad,-rad))
Ylim&lt;-range(pts[,2],B[2]+c(+rad,-rad))
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

#plot for the smaller arc
plot(pts,pch=1,asp=1,xlab="x",ylab="y",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
L&lt;-rbind(B,B,B); R&lt;-rbind(A,C,B+Xp)
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
plotrix::draw.arc(B[1],B[2],radius=.3*rad,angle1=ang.rad$s[1],angle2=ang.rad$s[2])
plotrix::draw.arc(B[1],B[2],radius=.6*rad,angle1=0, angle2=ang.rad$s[1],lty=2,col=2)
plotrix::draw.arc(B[1],B[2],radius=.9*rad,angle1=0,angle2=ang.rad$s[2],col=3)
txt&lt;-rbind(A,B,C)
text(txt+cbind(rep(xd*.02,nrow(txt)),rep(-xd*.02,nrow(txt))),c("A","B","C"))

text(rbind(B)+.5*rad*c(cos(mean(ang.rad$s)),sin(mean(ang.rad$s))),
     paste(abs(round(ang.deg1[2]-ang.deg1[1],2))," degrees",sep=""))
text(rbind(B)+.6*rad*c(cos(ang.rad$s[1]/2),sin(ang.rad$s[1]/2)),paste(round(ang.deg1[1],2)),col=2)
text(rbind(B)+.9*rad*c(cos(ang.rad$s[2]/2),sin(ang.rad$s[2]/2)),paste(round(ang.deg1[2],2)),col=3)

#plot for the counter-clockwise arc
plot(pts,pch=1,asp=1,xlab="x",ylab="y",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
L&lt;-rbind(B,B,B); R&lt;-rbind(A,C,B+Xp)
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
plotrix::draw.arc(B[1],B[2],radius=.3*rad,angle1=ang.rad$c[1],angle2=ang.rad$c[2])
plotrix::draw.arc(B[1],B[2],radius=.6*rad,angle1=0, angle2=ang.rad$s[1],lty=2,col=2)
plotrix::draw.arc(B[1],B[2],radius=.9*rad,angle1=0,angle2=ang.rad$s[2],col=3)
txt&lt;-pts
text(txt+cbind(rep(xd*.02,nrow(txt)),rep(-xd*.02,nrow(txt))),c("A","B","C"))

text(rbind(B)+.5*rad*c(cos(mean(ang.rad$c)),sin(mean(ang.rad$c))),
     paste(abs(round(ang.deg2[2]-ang.deg2[1],2))," degrees",sep=""))
text(rbind(B)+.6*rad*c(cos(ang.rad$s[1]/2),sin(ang.rad$s[1]/2)),paste(round(ang.deg1[1],2)),col=2)
text(rbind(B)+.9*rad*c(cos(ang.rad$s[2]/2),sin(ang.rad$s[2]/2)),paste(round(ang.deg1[2],2)),col=3)


</code></pre>

<hr>
<h2 id='angle3pnts'>The angle between two line segments</h2><span id='topic+angle3pnts'></span>

<h3>Description</h3>

<p>Returns the angle in radians or degrees between two vectors or line segments at the point of
intersection. The line segments are <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code> when the arguments of the function are given as <code>a,b,c</code>.
<code>radian</code> is a logical argument (default=<code>TRUE</code>) which yields the angle in radians if <code>TRUE</code>, and in degrees if <code>FALSE</code>.
The smaller of the angle between the line segments is provided by the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle3pnts(a, b, c, radian = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle3pnts_+3A_a">a</code>, <code id="angle3pnts_+3A_b">b</code>, <code id="angle3pnts_+3A_c">c</code></td>
<td>
<p>Three 2D points which represent the intersecting line segments <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code>.
The smaller angle between these line segments is to be computed.</p>
</td></tr>
<tr><td><code id="angle3pnts_+3A_radian">radian</code></td>
<td>
<p>A logical argument (default=<code>TRUE</code>). If <code>TRUE</code>, the (smaller) angle between the line segments
<code class="reqn">[ba]</code> and <code class="reqn">[bc]</code> is provided in radians, else it is provided in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>angle in radians or degrees between the line segments <code class="reqn">[ba]</code> and <code class="reqn">[bc]</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+angle.str2end">angle.str2end</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(.3,.2); B&lt;-c(.6,.3); C&lt;-c(1,1)
pts&lt;-rbind(A,B,C)

angle3pnts(A,B,C)

angle3pnts(A,B,A)
round(angle3pnts(A,B,A),7)

angle3pnts(A,B,C,radian=FALSE)

#plot of the line segments
Xlim&lt;-range(pts[,1])
Ylim&lt;-range(pts[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

ang1&lt;-angle3pnts(A,B,C,radian=FALSE)
ang2&lt;-angle3pnts(B+c(1,0),B,C,radian=FALSE)

sa&lt;-angle.str2end(A,B,C,radian=FALSE)$s #small arc angles
ang1&lt;-sa[1]
ang2&lt;-sa[2]

plot(pts,asp=1,pch=1,xlab="x",ylab="y",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
L&lt;-rbind(B,B); R&lt;-rbind(A,C)
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
plotrix::draw.arc(B[1],B[2],radius=xd*.1,deg1=ang1,deg2=ang2)
txt&lt;-rbind(A,B,C)
text(txt+cbind(rep(xd*.05,nrow(txt)),rep(-xd*.02,nrow(txt))),c("A","B","C"))

text(rbind(B)+.15*xd*c(cos(pi*(ang2+ang1)/360),sin(pi*(ang2+ang1)/360)),
paste(round(abs(ang1-ang2),2)," degrees"))


</code></pre>

<hr>
<h2 id='arcsAS'>The arcs of Arc Slice Proximity Catch Digraph (AS-PCD)
for a 2D data set - multiple triangle case</h2><span id='topic+arcsAS'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of AS-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the AS-PCD are the data points in <code>Xp</code>
in the multiple triangle case.
</p>
<p>AS proximity regions are defined
with respect to the Delaunay triangles based on
<code>Yp</code> points, i.e., AS proximity regions are defined only
for <code>Xp</code> points
inside the convex hull of <code>Yp</code> points.
That is, arcs may exist for points only
inside the convex hull of <code>Yp</code> points.
It also provides various descriptions and quantities
about the arcs of the AS-PCD
such as number of arcs, arc density, etc.
</p>
<p>Vertex regions are based on the center <code>M="CC"</code>
for circumcenter of each Delaunay triangle
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the
interior of each Delaunay triangle;
default is <code>M="CC"</code> i.e., circumcenter of each triangle.
<code>M</code> must be entered in barycentric coordinates unless it is the circumcenter.
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
For the number of arcs, loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005, 2010)) for more on AS PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsAS(Xp, Yp, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsAS_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="arcsAS_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of
the Delaunay triangulation. The Delaunay
triangles partition the convex hull of <code>Yp</code> points.</p>
</td></tr>
<tr><td><code id="arcsAS_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> represents
the circumcenter of each Delaunay triangle
or 3D point in barycentric coordinates
which serves as a center in the interior of each Delaunay triangle;
default is <code>M="CC"</code> i.e., the circumcenter of each triangle.
<code>M</code> must be entered in barycentric coordinates
unless it is the circumcenter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph,
here, it is the center used to construct the vertex regions,
default is circumcenter, denoted as <code>"CC"</code>,
otherwise given in barycentric coordinates.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the Delaunay triangulation based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set
which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of AS-PCD for
2D data set <code>Xp</code> in the multiple triangle case
as the vertices of the digraph</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of AS-PCD for
2D data set <code>Xp</code> in the multiple triangle case
as the vertices of the digraph</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph:
number of vertices, number of partition points,
number of intervals, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsAStri">arcsAStri</a></code>, <code><a href="#topic+arcsPEtri">arcsPEtri</a></code>, <code><a href="#topic+arcsCStri">arcsCStri</a></code>,
<code><a href="#topic+arcsPE">arcsPE</a></code>, and <code><a href="#topic+arcsCS">arcsCS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-5;  #try also nx=20; nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

Arcs&lt;-arcsAS(Xp,Yp,M) #try also the default M with Arcs&lt;-arcsAS(Xp,Yp)
Arcs
summary(Arcs)
plot(Arcs)

arcsAS(Xp,Yp[1:3,],M)


</code></pre>

<hr>
<h2 id='arcsAStri'>The arcs of Arc Slice Proximity Catch Digraph (AS-PCD)
for 2D data - one triangle case</h2><span id='topic+arcsAStri'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of AS-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the AS-PCD are the data points in <code>Xp</code>
in the one triangle case.
</p>
<p>AS proximity regions are constructed
with respect to the triangle <code>tri</code>, i.e.,
arcs may exist for points only inside <code>tri</code>.
It also provides various descriptions
and quantities about the arcs of the AS-PCD
such as number of arcs, arc density, etc.
</p>
<p>Vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
The different consideration of circumcenter
vs any other interior center of the triangle
is because the projections from circumcenter are orthogonal to the edges,
while projections of <code>M</code> on the edges are on the extensions
of the lines connecting <code>M</code> and the vertices.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsAStri(Xp, tri, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsAStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="arcsAStri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise,
each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="arcsAStri_+3A_m">M</code></td>
<td>
<p>The center of the triangle.
<code>"CC"</code> stands for circumcenter of the triangle <code>tri</code>
or a 2D point in Cartesian coordinates or a 3D point in
barycentric coordinates which serves as a center
in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph,
here, it is the center used to construct the vertex regions.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the vertices of the support triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set
which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of AS-PCD
for 2D data set <code>Xp</code> as vertices of the digraph</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of AS-PCD
for 2D data set <code>Xp</code> as vertices of the digraph</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices,
number of partition points,
number of intervals, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsAS">arcsAS</a></code>, <code><a href="#topic+arcsPEtri">arcsPEtri</a></code>, <code><a href="#topic+arcsCStri">arcsCStri</a></code>,
<code><a href="#topic+arcsPE">arcsPE</a></code>, and <code><a href="#topic+arcsCS">arcsCS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);

Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also  M&lt;-c(1.6,1.2) or M&lt;-circumcenter.tri(Tr)

Arcs&lt;-arcsAStri(Xp,Tr,M) #try also Arcs&lt;-arcsAStri(Xp,Tr)
#uses the default center, namely circumcenter for M
Arcs
summary(Arcs)
plot(Arcs) #use plot(Arcs,asp=1) if M=CC

#can add vertex regions
#but we first need to determine center is the circumcenter or not,
#see the description for more detail.
CC&lt;-circumcenter.tri(Tr)
M = as.numeric(Arcs$parameters[[1]])
if (isTRUE(all.equal(M,CC)) || identical(M,"CC"))
{cent&lt;-CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
cent.name&lt;-"CC"
} else
{cent&lt;-M
cent.name&lt;-"M"
Ds&lt;-prj.cent2edges(Tr,M)
}
L&lt;-rbind(cent,cent,cent); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)

#now we add the vertex names and annotation
txt&lt;-rbind(Tr,cent,Ds)
xc&lt;-txt[,1]+c(-.02,.03,.02,.03,.04,-.03,-.01)
yc&lt;-txt[,2]+c(.02,.02,.03,.06,.04,.05,-.07)
txt.str&lt;-c("A","B","C",cent.name,"D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='arcsCS'>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for 2D data - multiple triangle case</h2><span id='topic+arcsCS'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of CS-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the CS-PCD are the data points in <code>Xp</code>
in the multiple triangle case.
</p>
<p>CS proximity regions are
defined with respect to the Delaunay triangles based on <code>Yp</code> points with expansion parameter <code class="reqn">t&gt;0</code> and
edge regions in each triangle are based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of each Delaunay triangle (default for <code class="reqn">M=(1,1,1)</code> which is the center of mass of
the triangle). Each Delaunay triangle is first converted to an (nonscaled) basic triangle so that
<code>M</code> will be the same type of center for each Delaunay triangle (this conversion is not necessary when <code>M</code> is <code class="reqn">CM</code>).
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
For the number of arcs, loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)) for more on CS-PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016)) for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsCS(Xp, Yp, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsCS_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="arcsCS_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="arcsCS_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="arcsCS_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates which serves as a center in the interior of each Delaunay
triangle, default for <code class="reqn">M=(1,1,1)</code> which is the center of mass of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, it is the center used to construct the edge regions.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is Delaunay triangulation based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of CS-PCD for 2D data set <code>Xp</code> as vertices of the digraph</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of CS-PCD for 2D data set <code>Xp</code> as vertices of the digraph</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of triangles, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsCStri">arcsCStri</a></code>, <code><a href="#topic+arcsAS">arcsAS</a></code> and <code><a href="#topic+arcsPE">arcsPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

tau&lt;-1.5  #try also tau&lt;-2

Arcs&lt;-arcsCS(Xp,Yp,tau,M)
#or use the default center Arcs&lt;-arcsCS(Xp,Yp,tau)
Arcs
summary(Arcs)
plot(Arcs)


</code></pre>

<hr>
<h2 id='arcsCS1D'>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for 1D data - multiple interval case</h2><span id='topic+arcsCS1D'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of CS-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the CS-PCD are the 1D data points in <code>Xp</code>
in the multiple interval case.
<code>Yp</code> determines the end points of the intervals.
</p>
<p>If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>For this function, CS proximity regions are constructed
data points inside or outside the intervals based
on <code>Yp</code> points with expansion parameter <code class="reqn">t&gt;0</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>. That is, for this function,
arcs may exist for points in the middle or end-intervals.
It also provides various descriptions and quantities about the arcs of the CS-PCD
such as number of arcs, arc density, etc.
</p>
<p>Equivalent to function <code><a href="#topic+arcsCS1D">arcsCS1D</a></code>.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsCS1D(Xp, Yp, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsCS1D_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="arcsCS1D_+3A_yp">Yp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the end points of the intervals.</p>
</td></tr>
<tr><td><code id="arcsCS1D_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="arcsCS1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, they are expansion and centrality parameters.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of the study region is performed, here, tessellation
is the intervalization of the real line based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of CS-PCD for 1D data</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of CS-PCD for 1D data</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of intervals, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsCSend.int">arcsCSend.int</a></code>, <code><a href="#topic+arcsCSmid.int">arcsCSmid.int</a></code>, <code><a href="#topic+arcsCS1D">arcsCS1D</a></code>, and <code><a href="#topic+arcsPE1D">arcsPE1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10;

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xr&lt;-range(a,b)
xf&lt;-(xr[2]-xr[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

Arcs&lt;-arcsCS1D(Xp,Yp,t,c)
Arcs
summary(Arcs)
plot(Arcs)

S&lt;-Arcs$S
E&lt;-Arcs$E

arcsCS1D(Xp,Yp,t,c)

arcsCS1D(Xp,Yp+10,t,c)

jit&lt;-.1
yjit&lt;-runif(nx,-jit,jit)

Xlim&lt;-range(a,b,Xp,Yp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),
main="arcs of CS-PCD for points (jittered along y-axis)\n in middle intervals ",
xlab=" ", ylab=" ", xlim=Xlim+xd*c(-.05,.05),ylim=3*c(-jit,jit),pch=".")
abline(h=0,lty=1)
points(Xp, yjit,pch=".",cex=3)
abline(v=Yp,lty=2)
arrows(S, yjit, E, yjit, length = .05, col= 4)

t&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10;
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

arcsCS1D(Xp,Yp,t,c)

</code></pre>

<hr>
<h2 id='arcsCSend.int'>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD)
for 1D data - end-interval case</h2><span id='topic+arcsCSend.int'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of CS-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the CS-PCD are the 1D data points in <code>Xp</code>
in the end-interval case.
<code>Yp</code> determines the end points of the end-intervals.
</p>
<p>For this function, CS proximity regions are constructed data points outside the intervals based on
<code>Yp</code> points with expansion parameter <code class="reqn">t&gt;0</code>. That is, for this function,
arcs may exist for points only inside end-intervals.
It also provides various descriptions and quantities about the arcs of the CS-PCD
such as number of arcs, arc density, etc.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsCSend.int(Xp, Yp, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsCSend.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="arcsCSend.int_+3A_yp">Yp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the end points of the intervals.</p>
</td></tr>
<tr><td><code id="arcsCSend.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, it is the expansion parameter.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the intervalization based on <code>Yp</code>.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitutes the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of CS-PCD for 1D data in the end-intervals</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of CS-PCD for 1D data in the end-intervals</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of intervals (which is 2 for end-intervals), number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsCSmid.int">arcsCSmid.int</a></code>, <code><a href="#topic+arcsCS1D">arcsCS1D</a></code> , <code><a href="#topic+arcsPEmid.int">arcsPEmid.int</a></code>,
<code><a href="#topic+arcsPEend.int">arcsPEend.int</a></code>  and <code><a href="#topic+arcsPE1D">arcsPE1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t&lt;-1.5
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xr&lt;-range(a,b)
xf&lt;-(xr[2]-xr[1])*.5

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

arcsCSend.int(Xp,Yp,t)

Arcs&lt;-arcsCSend.int(Xp,Yp,t)
Arcs
summary(Arcs)
plot(Arcs)

S&lt;-Arcs$S
E&lt;-Arcs$E

jit&lt;-.1
yjit&lt;-runif(nx,-jit,jit)

Xlim&lt;-range(a,b,Xp,Yp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),pch=".",
main="arcs of CS-PCD with vertices (jittered along y-axis)\n in end-intervals ",
     xlab=" ", ylab=" ",xlim=Xlim+xd*c(-.05,.05),ylim=3*c(-jit,jit))
abline(h=0,lty=1)
points(Xp, yjit,pch=".",cex=3)
abline(v=Yp,lty=2)
arrows(S, yjit, E, yjit, length = .05, col= 4)

arcsCSend.int(Xp,Yp,t)

</code></pre>

<hr>
<h2 id='arcsCSint'>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for 1D data - one interval case</h2><span id='topic+arcsCSint'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of CS-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the CS-PCD are the 1D data points in <code>Xp</code>
in the one interval case.
<code>int</code> determines the end points of the interval.
</p>
<p>For this function, CS proximity regions are constructed data points inside or outside the interval based
on <code>int</code> points with expansion parameter <code class="reqn">t &gt; 0</code> and centrality parameter <code class="reqn">c \in (0,1)</code>. That is, for this function,
arcs may exist for points in the middle or end-intervals.
It also provides various descriptions and quantities about the arcs of the CS-PCD
such as number of arcs, arc density, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsCSint(Xp, int, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsCSint_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="arcsCSint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two 1D points which constitutes the end points of the interval.</p>
</td></tr>
<tr><td><code id="arcsCSint_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="arcsCSint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, they are expansion and centrality parameters.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of the study region
is performed, here, tessellation
is the intervalization of the real line based on <code>int</code> points.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of CS-PCD for 1D data</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of CS-PCD for 1D data</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of intervals, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsCS1D">arcsCS1D</a></code>, <code><a href="#topic+arcsCSmid.int">arcsCSmid.int</a></code>, <code><a href="#topic+arcsCSend.int">arcsCSend.int</a></code>, and <code><a href="#topic+arcsPE1D">arcsPE1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b);

#n is number of X points
n&lt;-10; #try also n&lt;-20

xf&lt;-(int[2]-int[1])*.1

set.seed(1)
Xp&lt;-runif(n,a-xf,b+xf)

Arcs&lt;-arcsCSint(Xp,int,tau,c)
Arcs
summary(Arcs)
plot(Arcs)

Xp&lt;-runif(n,a+10,b+10)
Arcs=arcsCSint(Xp,int,tau,c)
Arcs
summary(Arcs)
plot(Arcs)

</code></pre>

<hr>
<h2 id='arcsCSmid.int'>The arcs of Central Similarity Proximity Catch Digraph (CS-PCD)
for 1D data - middle intervals case</h2><span id='topic+arcsCSmid.int'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of CS-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the CS-PCD are the 1D data points in <code>Xp</code>
in the middle interval case.
</p>
<p>For this function, CS proximity regions are constructed with respect to the intervals
based on <code>Yp</code> points with expansion parameter <code class="reqn">t&gt;0</code> and centrality parameter <code class="reqn">c \in (0,1)</code>. That is, for this
function, arcs may exist for points only inside the intervals.
It also provides various descriptions and quantities about the arcs of the CS-PCD
such as number of arcs, arc density, etc.
</p>
<p>Vertex regions are based on center <code class="reqn">M_c</code> of each middle interval.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsCSmid.int(Xp, Yp, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsCSmid.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="arcsCSmid.int_+3A_yp">Yp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the end points of the intervals.</p>
</td></tr>
<tr><td><code id="arcsCSmid.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="arcsCSmid.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, they are expansion and centrality parameters.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Points on which the tessellation of the study region is performed,
here, tessellation is the intervalization based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, i.e., <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of CS-PCD for 1D data in the middle intervals</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of CS-PCD for 1D data in the middle intervals</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of intervals, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsPEend.int">arcsPEend.int</a></code>, <code><a href="#topic+arcsPE1D">arcsPE1D</a></code>, <code><a href="#topic+arcsCSmid.int">arcsCSmid.int</a></code>,
<code><a href="#topic+arcsCSend.int">arcsCSend.int</a></code> and <code><a href="#topic+arcsCS1D">arcsCS1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t&lt;-1.5
c&lt;-.4
a&lt;-0; b&lt;-10

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

arcsCSmid.int(Xp,Yp,t,c)
arcsCSmid.int(Xp,Yp+10,t,c)

Arcs&lt;-arcsCSmid.int(Xp,Yp,t,c)
Arcs
summary(Arcs)
plot(Arcs)

S&lt;-Arcs$S
E&lt;-Arcs$E

jit&lt;-.1
yjit&lt;-runif(nx,-jit,jit)

Xlim&lt;-range(Xp,Yp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),
main="arcs of CS-PCD whose vertices (jittered along y-axis)\n in middle intervals ",
xlab=" ", ylab=" ", xlim=Xlim+xd*c(-.05,.05),ylim=3*c(-jit,jit),pch=".")
abline(h=0,lty=1)
points(Xp, yjit,pch=".",cex=3)
abline(v=Yp,lty=2)
arrows(S, yjit, E, yjit, length = .05, col= 4)

t&lt;-.5
c&lt;-.4
a&lt;-0; b&lt;-10;
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

arcsCSmid.int(Xp,Yp,t,c)

</code></pre>

<hr>
<h2 id='arcsCStri'>The arcs of Central Similarity Proximity Catch Digraphs (CS-PCD) for 2D data - one triangle case</h2><span id='topic+arcsCStri'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of CS-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the CS-PCD are the data points in <code>Xp</code>
in the one triangle case.
</p>
<p>CS proximity regions are constructed with respect to the triangle <code>tri</code> with expansion
parameter <code class="reqn">t&gt;0</code>, i.e., arcs may exist for points only inside <code>tri</code>.
It also provides various descriptions and quantities about the arcs of the CS-PCD
such as number of arcs, arc density, etc.
</p>
<p>Edge regions are based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of
the triangle <code>tri</code>; default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsCStri(Xp, tri, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsCStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="arcsCStri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="arcsCStri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="arcsCStri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code> or the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, the center <code>M</code> used to
construct the edge regions and the expansion parameter <code>t</code>.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the vertices of the support triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of CS-PCD for 2D data set <code>Xp</code> as vertices of the digraph</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of CS-PCD for 2D data set <code>Xp</code> as vertices of the digraph</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of triangles, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsCS">arcsCS</a></code>, <code><a href="#topic+arcsAStri">arcsAStri</a></code> and <code><a href="#topic+arcsPEtri">arcsPEtri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

t&lt;-1.5  #try also t&lt;-2

Arcs&lt;-arcsCStri(Xp,Tr,t,M)
#or try with the default center Arcs&lt;-arcsCStri(Xp,Tr,t); M= (Arcs$param)$c
Arcs
summary(Arcs)
plot(Arcs)

#can add edge regions
L&lt;-rbind(M,M,M); R&lt;-Tr
segments(L[,1], L[,2], R[,1], R[,2], lty=2)

#now we can add the vertex names and annotation
txt&lt;-rbind(Tr,M)
xc&lt;-txt[,1]+c(-.02,.03,.02,.03)
yc&lt;-txt[,2]+c(.02,.02,.03,.06)
txt.str&lt;-c("A","B","C","M")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='arcsPE'>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD)
for 2D data - multiple triangle case</h2><span id='topic+arcsPE'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of PE-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the PE-PCD are the data points in <code>Xp</code>
in the multiple triangle case.
</p>
<p>PE proximity regions are
defined with respect to the Delaunay triangles
based on <code>Yp</code> points with expansion parameter <code class="reqn">r \ge 1</code> and
vertex regions in each triangle are
based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates
in the interior of each Delaunay triangle or
based on circumcenter of each Delaunay triangle
(default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of the triangle).
Each Delaunay triangle is first converted to
an (nonscaled) basic triangle so that <code>M</code> will be the same
type of center for each Delaunay triangle
(this conversion is not necessary when <code>M</code> is <code class="reqn">CM</code>).
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
For the number of arcs, loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011))
for more on the PE-PCDs.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsPE(Xp, Yp, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsPE_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="arcsPE_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="arcsPE_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="arcsPE_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates
which serves as a center in the interior of each Delaunay
triangle or circumcenter of each Delaunay triangle
(for this, argument should be set as <code>M="CC"</code>),
default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph,
the center used to construct the vertex regions
and the expansion parameter.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation
of the study region is performed,
here, tessellation is the Delaunay triangulation based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set
which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of PE-PCD for 2D data set <code>Xp</code>
as vertices of the digraph</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of PE-PCD for 2D data set <code>Xp</code>
as vertices of the digraph</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title
in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices,
number of partition points,
number of triangles, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsPEtri">arcsPEtri</a></code>, <code><a href="#topic+arcsAS">arcsAS</a></code>,
and <code><a href="#topic+arcsCS">arcsCS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

r&lt;-1.5  #try also r&lt;-2

Arcs&lt;-arcsPE(Xp,Yp,r,M)
#or try with the default center Arcs&lt;-arcsPE(Xp,Yp,r)
Arcs
summary(Arcs)
plot(Arcs)


</code></pre>

<hr>
<h2 id='arcsPE1D'>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD)
for 1D data - multiple interval case</h2><span id='topic+arcsPE1D'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of PE-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the PE-PCD are the 1D data points in <code>Xp</code>
in the multiple interval case.
<code>Yp</code> determines the end points of the intervals.
</p>
<p>If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>For this function,
PE proximity regions are constructed data points inside or outside the intervals based
on <code>Yp</code> points with expansion parameter <code class="reqn">r \ge 1</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>. That is, for this function,
arcs may exist for points in the middle or end-intervals.
It also provides various descriptions and quantities about the arcs of the PE-PCD
such as number of arcs, arc density, etc.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsPE1D(Xp, Yp, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsPE1D_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="arcsPE1D_+3A_yp">Yp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the end points of the intervals.</p>
</td></tr>
<tr><td><code id="arcsPE1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="arcsPE1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, they are expansion and centrality parameters.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the intervalization of the real line based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of PE-PCD for 1D data</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of PE-PCD for 1D data</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of intervals, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsPEint">arcsPEint</a></code>, <code><a href="#topic+arcsPEmid.int">arcsPEmid.int</a></code>, <code><a href="#topic+arcsPEend.int">arcsPEend.int</a></code>, and <code><a href="#topic+arcsCS1D">arcsCS1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b);

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

Arcs&lt;-arcsPE1D(Xp,Yp,r,c)
Arcs
summary(Arcs)
plot(Arcs)


</code></pre>

<hr>
<h2 id='arcsPEend.int'>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD) for 1D data - end-interval case</h2><span id='topic+arcsPEend.int'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of PE-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the PE-PCD are the 1D data points in <code>Xp</code>
in the end-interval case.
<code>Yp</code> determines the end points of the end-intervals.
</p>
<p>For this function, PE proximity regions are constructed data points outside the intervals based on
<code>Yp</code> points with expansion parameter <code class="reqn">r \ge 1</code>. That is, for this function,
arcs may exist for points only inside end-intervals.
It also provides various descriptions and quantities about the arcs of the PE-PCD
such as number of arcs, arc density, etc.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsPEend.int(Xp, Yp, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsPEend.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="arcsPEend.int_+3A_yp">Yp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the end points of the intervals.</p>
</td></tr>
<tr><td><code id="arcsPEend.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, it is the expansion parameter.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the intervalization based on <code>Yp</code>.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitutes the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of PE-PCD for 1D data in the end-intervals</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of PE-PCD for 1D data in the end-intervals</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of intervals (which is 2 for end-intervals), number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsPEmid.int">arcsPEmid.int</a></code>, <code><a href="#topic+arcsPE1D">arcsPE1D</a></code> , <code><a href="#topic+arcsCSmid.int">arcsCSmid.int</a></code>,
<code><a href="#topic+arcsCSend.int">arcsCSend.int</a></code>  and <code><a href="#topic+arcsCS1D">arcsCS1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b);

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.5

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)  #try also Yp&lt;-runif(ny,a,b)+c(-10,10)

Arcs&lt;-arcsPEend.int(Xp,Yp,r)
Arcs
summary(Arcs)
plot(Arcs)

S&lt;-Arcs$S
E&lt;-Arcs$E

jit&lt;-.1
yjit&lt;-runif(nx,-jit,jit)

Xlim&lt;-range(a,b,Xp,Yp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),pch=".",
main="arcs of PE-PCDs for points (jittered along y-axis)\n in end-intervals ",
xlab=" ", ylab=" ", xlim=Xlim+xd*c(-.05,.05),ylim=3*c(-jit,jit))
abline(h=0,lty=1)
points(Xp, yjit,pch=".",cex=3)
abline(v=Yp,lty=2)
arrows(S, yjit, E, yjit, length = .05, col= 4)


</code></pre>

<hr>
<h2 id='arcsPEint'>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD)
for 1D data - one interval case</h2><span id='topic+arcsPEint'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of PE-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the PE-PCD are the 1D data points in <code>Xp</code>
in the one interval case.
<code>int</code> determines the end points of the interval.
</p>
<p>For this function, PE proximity regions are constructed data points inside or outside the interval based
on <code>int</code> points with expansion parameter <code class="reqn">r \ge 1</code> and centrality parameter <code class="reqn">c \in (0,1)</code>. That is, for this function,
arcs may exist for points in the middle or end-intervals.
It also provides various descriptions and quantities about the arcs of the PE-PCD
such as number of arcs, arc density, etc.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsPEint(Xp, int, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsPEint_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="arcsPEint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two 1D points which constitutes the end points of the interval.</p>
</td></tr>
<tr><td><code id="arcsPEint_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="arcsPEint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, they are expansion and centrality parameters.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the end points of the support interval <code>int</code>.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of PE-PCD for 1D data</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of PE-PCD for 1D data</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of intervals, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsPE1D">arcsPE1D</a></code>, <code><a href="#topic+arcsPEmid.int">arcsPEmid.int</a></code>, <code><a href="#topic+arcsPEend.int">arcsPEend.int</a></code>, and <code><a href="#topic+arcsCS1D">arcsCS1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b);

#n is number of X points
n&lt;-10; #try also n&lt;-20

xf&lt;-(int[2]-int[1])*.1

set.seed(1)
Xp&lt;-runif(n,a-xf,b+xf)

Arcs&lt;-arcsPEint(Xp,int,r,c)
Arcs
summary(Arcs)
plot(Arcs)


</code></pre>

<hr>
<h2 id='arcsPEmid.int'>The arcs of Proportional Edge Proximity Catch Digraph (PE-PCD) for 1D data - middle intervals case</h2><span id='topic+arcsPEmid.int'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of PE-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the PE-PCD are the 1D data points in <code>Xp</code>
in the middle interval case.
</p>
<p>For this function, PE proximity regions are constructed with respect to the intervals
based on <code>Yp</code> points with expansion parameter <code class="reqn">r \ge 1</code> and
centrality parameter <code class="reqn">c \in (0,1)</code>. That is, for this function,
arcs may exist for points only inside the intervals.
It also provides various descriptions and quantities about the arcs of the PE-PCD
such as number of arcs, arc density, etc.
</p>
<p>Vertex regions are based on center <code class="reqn">M_c</code> of each middle interval.
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsPEmid.int(Xp, Yp, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsPEmid.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="arcsPEmid.int_+3A_yp">Yp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the end points of the intervals.</p>
</td></tr>
<tr><td><code id="arcsPEmid.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="arcsPEmid.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph, here, they are expansion and centrality parameters.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the intervalization based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, i.e., <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set which constitute the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of PE-PCD for 1D data in the middle intervals</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of PE-PCD for 1D data in the middle intervals</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph: number of vertices, number of partition points,
number of intervals, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsPEend.int">arcsPEend.int</a></code>, <code><a href="#topic+arcsPE1D">arcsPE1D</a></code>, <code><a href="#topic+arcsCSmid.int">arcsCSmid.int</a></code>,
<code><a href="#topic+arcsCSend.int">arcsCSend.int</a></code> and <code><a href="#topic+arcsCS1D">arcsCS1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10;

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

Arcs&lt;-arcsPEmid.int(Xp,Yp,r,c)
Arcs
summary(Arcs)
plot(Arcs)

S&lt;-Arcs$S
E&lt;-Arcs$E

arcsPEmid.int(Xp,Yp,r,c)
arcsPEmid.int(Xp,Yp+10,r,c)

jit&lt;-.1
yjit&lt;-runif(nx,-jit,jit)

Xlim&lt;-range(Xp,Yp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),
main="arcs of PE-PCD for points (jittered along y-axis)\n in middle intervals ",
xlab=" ", ylab=" ", xlim=Xlim+xd*c(-.05,.05),ylim=3*c(-jit,jit),pch=".")
abline(h=0,lty=1)
points(Xp, yjit,pch=".",cex=3)
abline(v=Yp,lty=2)
arrows(S, yjit, E, yjit, length = .05, col= 4)


</code></pre>

<hr>
<h2 id='arcsPEtri'>The arcs of Proportional Edge Proximity Catch Digraph
(PE-PCD) for 2D data - one triangle case</h2><span id='topic+arcsPEtri'></span>

<h3>Description</h3>

<p>An object of class <code>"PCDs"</code>.
Returns arcs of PE-PCD as tails (or sources) and heads (or arrow ends)
and related parameters and the quantities of the digraph.
The vertices of the PE-PCD are the data points in <code>Xp</code>
in the one triangle case.
</p>
<p>PE proximity regions are constructed
with respect to the triangle <code>tri</code> with expansion
parameter <code class="reqn">r \ge 1</code>, i.e.,
arcs may exist only for points inside <code>tri</code>.
It also provides various descriptions
and quantities about the arcs of the PE-PCD
such as number of arcs, arc density, etc.
</p>
<p>Vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of
the triangle <code>tri</code> or based on the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.
When the center is the circumcenter, <code>CC</code>,
the vertex regions are constructed based on the
orthogonal projections to the edges,
while with any interior center <code>M</code>,
the vertex regions are constructed using the extensions
of the lines combining vertices with <code>M</code>.
<code>M</code>-vertex regions are recommended spatial inference,
due to geometry invariance property of the arc density
and domination number the PE-PCDs based on uniform data.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsPEtri(Xp, tri, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arcsPEtri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="arcsPEtri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="arcsPEtri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="arcsPEtri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>A description of the type of the digraph</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Parameters of the digraph,
the center <code>M</code> used to
construct the vertex regions and the expansion parameter <code>r</code>.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the vertices of the support triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>tess.name</code></td>
<td>
<p>Name of the tessellation points <code>tess.points</code></p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code> points</p>
</td></tr>
<tr><td><code>vert.name</code></td>
<td>
<p>Name of the data set
which constitutes the vertices of the digraph</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Tails (or sources) of the arcs of PE-PCD
for 2D data set <code>Xp</code>
as vertices of the digraph</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Heads (or arrow ends) of the arcs of PE-PCD
for 2D data set <code>Xp</code>
as vertices of the digraph</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>Text for <code>"main"</code> title
in the plot of the digraph</p>
</td></tr>
<tr><td><code>quant</code></td>
<td>
<p>Various quantities for the digraph:
number of vertices, number of partition points,
number of triangles, number of arcs, and arc density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arcsPE">arcsPE</a></code>, <code><a href="#topic+arcsAStri">arcsAStri</a></code>,
and <code><a href="#topic+arcsCStri">arcsCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

r&lt;-1.5  #try also r&lt;-2

Arcs&lt;-arcsPEtri(Xp,Tr,r,M)
#or try with the default center Arcs&lt;-arcsPEtri(Xp,Tr,r); M= (Arcs$param)$cent
Arcs
summary(Arcs)
plot(Arcs)

#can add vertex regions
#but we first need to determine center is the circumcenter or not,
#see the description for more detail.
CC&lt;-circumcenter.tri(Tr)
if (isTRUE(all.equal(M,CC)))
{cent&lt;-CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
cent.name&lt;-"CC"
} else
{cent&lt;-M
cent.name&lt;-"M"
Ds&lt;-prj.cent2edges(Tr,M)
}
L&lt;-rbind(cent,cent,cent); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)

#now we can add the vertex names and annotation
txt&lt;-rbind(Tr,cent,Ds)
xc&lt;-txt[,1]+c(-.02,.02,.02,.02,.03,-.03,-.01)
yc&lt;-txt[,2]+c(.02,.02,.03,.06,.04,.05,-.07)
txt.str&lt;-c("A","B","C","M","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='area.polygon'>The area of a polygon in <code class="reqn">R^2</code></h2><span id='topic+area.polygon'></span>

<h3>Description</h3>

<p>Returns the area of the polygon, <code>h</code>,
in the real plane <code class="reqn">R^{2}</code>; the vertices of the polygon <code>h</code>
must be provided in clockwise or counter-clockwise order,
otherwise the function does not yield
the area of the polygon. Also, the polygon could be convex or non-convex.
See (Weisstein (2019)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area.polygon(h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area.polygon_+3A_h">h</code></td>
<td>
<p>A <code>vector</code> of <code class="reqn">n</code> 2D points, stacked row-wise,
each row representing a vertex of the polygon,
where <code class="reqn">n</code> is the number of vertices of the polygon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>area of the polygon <code>h</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Weisstein EW (2019).
&ldquo;Polygon Area.&rdquo;
From MathWorld &mdash; A Wolfram Web Resource, <a href="http://mathworld.wolfram.com/PolygonArea.html">http://mathworld.wolfram.com/PolygonArea.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(0.5,.8);
Tr&lt;-rbind(A,B,C);
area.polygon(Tr)

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(.7,.6); D&lt;-c(0.3,.8);
h1&lt;-rbind(A,B,C,D);
#try also h1&lt;-rbind(A,B,D,C) or h1&lt;-rbind(A,C,B,D) or h1&lt;-rbind(A,D,C,B);
area.polygon(h1)

Xlim&lt;-range(h1[,1])
Ylim&lt;-range(h1[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(h1,xlab="",ylab="",main="A Convex Polygon with Four Vertices",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(h1)
xc&lt;-rbind(A,B,C,D)[,1]+c(-.03,.03,.02,-.01)
yc&lt;-rbind(A,B,C,D)[,2]+c(.02,.02,.02,.03)
txt.str&lt;-c("A","B","C","D")
text(xc,yc,txt.str)

#when the triangle is degenerate, it gives zero area
B&lt;-A+2*(C-A);
T2&lt;-rbind(A,B,C)
area.polygon(T2)


</code></pre>

<hr>
<h2 id='as.basic.tri'>The labels of the vertices of a triangle in the basic triangle form</h2><span id='topic+as.basic.tri'></span>

<h3>Description</h3>

<p>Labels the vertices of triangle, <code>tri</code>,
as <code class="reqn">ABC</code> so that <code class="reqn">AB</code> is the longest edge,
<code class="reqn">BC</code> is the second longest
and <code class="reqn">AC</code> is the shortest edge
(the order is as in the basic triangle).
</p>
<p>The standard basic triangle form is <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle. Hence, standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>The option <code>scaled</code> a logical argument
for scaling the resulting triangle or not.
If <code>scaled=TRUE</code>, then the resulting triangle is scaled
to be a regular basic triangle,
i.e., longest edge having unit length,
else (i.e., if <code>scaled=FALSE</code> which is the default),
the new triangle <code class="reqn">T(A,B,C)</code> is nonscaled,
i.e., the longest edge <code class="reqn">AB</code> may not be of unit length.
The vertices of the resulting triangle (whether scaled or not) is presented
in the order of vertices of the corresponding
basic triangle, however when scaled the triangle
is equivalent to the basic triangle <code class="reqn">T_b</code> up to translation and rotation.
That is, this function converts any triangle to a basic triangle
(up to translation and rotation),
so that the output triangle is $T(A',B',C')$
so that edges in decreasing length are $A'B'$, $B'C'$, and $A'C'$.
Most of the times,
the resulting triangle will still need to be translated
and/or rotated to be in the standard basic triangle form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.basic.tri(tri, scaled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.basic.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="as.basic.tri_+3A_scaled">scaled</code></td>
<td>
<p>A logical argument
for scaling the resulting basic triangle.
If <code>scaled=TRUE</code>, then the resulting triangle is
scaled to be a regular basic triangle, i.e.,
longest edge having unit length,
else the new triangle <code class="reqn">T(A,B,C)</code> is nonscaled.
The default is <code>scaled=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the basic triangle stacked row-wise
and labeled row-wise as <code class="reqn">A</code>, <code class="reqn">B</code>, <code class="reqn">C</code>.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>Description of the edges based on the vertices, i.e.,
<code>"Edges (in decreasing length are) AB, BC, and AC"</code>.</p>
</td></tr>
<tr><td><code>orig.order</code></td>
<td>
<p>Row order of the input triangle, <code>tri</code>,
when converted to the scaled version of the basic triangle</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);

as.basic.tri(rbind(A,B,C))
as.basic.tri(rbind(B,C,A))

A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
as.basic.tri(rbind(A,B,C))
as.basic.tri(rbind(A,C,B))
as.basic.tri(rbind(B,A,C))


</code></pre>

<hr>
<h2 id='ASarc.dens.tri'>Arc density of Arc Slice Proximity Catch Digraphs (AS-PCDs) - one triangle case</h2><span id='topic+ASarc.dens.tri'></span>

<h3>Description</h3>

<p>Returns the arc density of AS-PCD whose vertex set is the given 2D numerical data set, <code>Xp</code>,
(some of its members are) in the triangle <code>tri</code>.
</p>
<p>AS proximity regions are defined with respect to <code>tri</code>
and vertex regions are defined with the center <code>M="CC"</code> for circumcenter of <code>tri</code>;
or <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the
interior of the triangle <code>tri</code>; default is <code>M="CC"</code> i.e., circumcenter of <code>tri</code>.
For the number of arcs, loops are not allowed so arcs are only possible for points inside <code>tri</code>
for this function.
</p>
<p><code>in.tri.only</code> is a logical argument (default is <code>FALSE</code>) for considering only the points
inside the triangle or all the points as the vertices of the digraph.
if <code>in.tri.only=TRUE</code>, arc density is computed only for
the points inside the triangle (i.e., arc density of the subdigraph
induced by the vertices in the triangle is computed),
otherwise arc density of the entire digraph (i.e., digraph with all the vertices) is computed.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASarc.dens.tri(Xp, tri, M = "CC", in.tri.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASarc.dens.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="ASarc.dens.tri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="ASarc.dens.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center in the interior of <code>tri</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="ASarc.dens.tri_+3A_in.tri.only">in.tri.only</code></td>
<td>
<p>A logical argument (default is <code>in.tri.only=FALSE</code>)
for computing the arc density for only the points inside the triangle, <code>tri</code>.
That is,
if <code>in.tri.only=TRUE</code> arc density of the induced subdigraph with the vertices
inside <code>tri</code> is computed, otherwise
otherwise arc density of the entire digraph (i.e., digraph with all the vertices) is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Arc density of AS-PCD whose vertices are the 2D numerical data set, <code>Xp</code>;
AS proximity regions are defined with respect to the triangle <code>tri</code> and <code class="reqn">CC</code>-vertex regions.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ASarc.dens.tri">ASarc.dens.tri</a></code>, <code><a href="#topic+CSarc.dens.tri">CSarc.dens.tri</a></code>, and <code><a href="#topic+num.arcsAStri">num.arcsAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

set.seed(1)
n&lt;-10  #try also n&lt;-20

Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

narcs = num.arcsAStri(Xp,Tr,M)$num.arcs; narcs/(n*(n-1))
ASarc.dens.tri(Xp,Tr,M)
ASarc.dens.tri(Xp,Tr,M,in.tri.only = FALSE)

ASarc.dens.tri(Xp,Tr,M)


</code></pre>

<hr>
<h2 id='center.nondegPE'>Centers for non-degenerate asymptotic distribution of
domination number of Proportional Edge Proximity Catch Digraphs (PE-PCDs)</h2><span id='topic+center.nondegPE'></span>

<h3>Description</h3>

<p>Returns the centers
which yield nondegenerate asymptotic distribution for the domination number
of PE-PCD for uniform data in a triangle,
<code>tri</code><code class="reqn">=T(v_1,v_2,v_3)</code>.
</p>
<p>PE proximity region is defined with
respect to the triangle <code>tri</code>
with expansion parameter <code>r</code> in <code class="reqn">(1,1.5]</code>.
</p>
<p>Vertex regions are defined with the centers
that are output of this function.
Centers are stacked row-wise
with row number is corresponding to the vertex
row number in <code>tri</code>
(see the examples for an illustration). The center labels 1,2,3 correspond
to the vertices <code class="reqn">M_1</code>, <code class="reqn">M_2</code>, and <code class="reqn">M_3</code>
(which are the three centers for <code>r</code> in <code class="reqn">(1,1.5)</code>
which becomes center of mass
for <code class="reqn">r=1.5</code>.).
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center.nondegPE(tri, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center.nondegPE_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="center.nondegPE_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be in <code class="reqn">(1,1.5]</code> for this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The centers (stacked row-wise)
which give nondegenerate asymptotic distribution
for the domination number of PE-PCD for uniform data in a triangle, <code>tri</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
r&lt;-1.35

Ms&lt;-center.nondegPE(Tr,r)
Ms

Xlim&lt;-range(Tr[,1])
Ylim&lt;-range(Tr[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",
main="Centers of nondegeneracy\n for the PE-PCD in a triangle",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Ms,pch=".",col=1)
polygon(Ms,lty = 2)

xc&lt;-Tr[,1]+c(-.02,.02,.02)
yc&lt;-Tr[,2]+c(.02,.02,.03)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)

xc&lt;-Ms[,1]+c(-.04,.04,.03)
yc&lt;-Ms[,2]+c(.02,.02,.05)
txt.str&lt;-c("M1","M2","M3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='centerMc'>Parameterized center of an interval</h2><span id='topic+centerMc'></span>

<h3>Description</h3>

<p>Returns the (parameterized) center, <code class="reqn">M_c</code>,
of the interval, <code>int</code><code class="reqn">=(a,b)</code>,
parameterized by <code class="reqn">c \in (0,1)</code>
so that <code class="reqn">100c</code> % of the length of interval is to the left of <code class="reqn">M_c</code>
and <code class="reqn">100(1-c)</code> % of the length of the interval
is to the right of <code class="reqn">M_c</code>.
That is, for the interval, <code>int</code><code class="reqn">=(a,b)</code>,
the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.
</p>
<p>See also (Ceyhan (2012, 2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centerMc(int, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centerMc_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> with two entries representing an interval.</p>
</td></tr>
<tr><td><code id="centerMc_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code>
parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>,
the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(parameterized) center inside <code>int</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.<br /><br /> Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centersMc">centersMc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
a&lt;-0; b&lt;-10
int = c(a,b)
centerMc(int,c)

c&lt;-.3
a&lt;-2; b&lt;-4; int&lt;-c(a,b)
centerMc(int,c)

</code></pre>

<hr>
<h2 id='centersMc'>Parameterized centers of intervals</h2><span id='topic+centersMc'></span>

<h3>Description</h3>

<p>Returns the centers of the intervals based on
1D points in <code>Yp</code> parameterized by <code class="reqn">c \in (0,1)</code>
so that <code class="reqn">100c</code> % of the length of interval is to the left of <code class="reqn">M_c</code>
and <code class="reqn">100(1-c)</code> % of the length of the interval
is to the right of <code class="reqn">M_c</code>. That is, for an interval <code class="reqn">(a,b)</code>,
the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>
<code>Yp</code> is a <code>vector</code> of 1D points, not necessarily sorted.
</p>
<p>See also (Ceyhan (2012, 2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centersMc(Yp, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centersMc_+3A_yp">Yp</code></td>
<td>
<p>A <code>vector</code> real numbers that constitute the end points of intervals.</p>
</td></tr>
<tr><td><code id="centersMc_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code>
parameterizing the centers inside the intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>,
the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(parameterized) centers of the intervals
based on <code>Yp</code> points as a vector
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.<br /><br /> Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+centerMc">centerMc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10
c&lt;-.4  #try also c&lt;-runif(1)
Yp&lt;-runif(n)
centersMc(Yp,c)

c&lt;-.3  #try also c&lt;-runif(1)
Yp&lt;-runif(n,0,10)
centersMc(Yp,c)


</code></pre>

<hr>
<h2 id='circumcenter.basic.tri'>Circumcenter of a standard basic triangle form</h2><span id='topic+circumcenter.basic.tri'></span>

<h3>Description</h3>

<p>Returns the circumcenter of
a standard basic triangle form <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
given <code class="reqn">c_1</code>, <code class="reqn">c_2</code> where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle form
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle.
Hence, standard basic triangle form is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See (Weisstein (2019); Ceyhan (2010))
for triangle centers and
(Ceyhan et al. (2006); Ceyhan et al. (2007); Ceyhan (2011))
for the standard basic triangle form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circumcenter.basic.tri(c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circumcenter.basic.tri_+3A_c1">c1</code>, <code id="circumcenter.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers representing the top vertex
in standard basic triangle form <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>,
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>circumcenter of the standard basic triangle form
<code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
given <code class="reqn">c_1</code>, <code class="reqn">c_2</code> as the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.<br /><br /> Weisstein EW (2019).
&ldquo;Triangle Centers.&rdquo;
From MathWorld &mdash; A Wolfram Web Resource, <a href="http://mathworld.wolfram.com/TriangleCenter.html">http://mathworld.wolfram.com/TriangleCenter.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circumcenter.tri">circumcenter.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
#the vertices of the standard basic triangle form Tb
Tb&lt;-rbind(A,B,C)
CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter
CC

D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2; #midpoints of the edges
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tb[,1])
Ylim&lt;-range(Tb[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

oldpar &lt;- par(pty = "s")
plot(A,pch=".",asp=1,xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
points(rbind(CC))
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Tb,CC,D1,D2,D3)
xc&lt;-txt[,1]+c(-.03,.04,.03,.06,.06,-.03,0)
yc&lt;-txt[,2]+c(.02,.02,.03,-.03,.02,.04,-.03)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

#for an obtuse triangle
c1&lt;-.4; c2&lt;-.3;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
#the vertices of the standard basic triangle form Tb
Tb&lt;-rbind(A,B,C)
CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter
CC

D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2; #midpoints of the edges
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tb[,1],CC[1])
Ylim&lt;-range(Tb[,2],CC[2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
points(rbind(CC))
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Tb,CC,D1,D2,D3)
xc&lt;-txt[,1]+c(-.03,.03,.03,.07,.07,-.05,0)
yc&lt;-txt[,2]+c(.02,.02,.04,-.03,.03,.04,.06)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)
par(oldpar)


</code></pre>

<hr>
<h2 id='circumcenter.tetra'>Circumcenter of a general tetrahedron</h2><span id='topic+circumcenter.tetra'></span>

<h3>Description</h3>

<p>Returns the circumcenter a given tetrahedron <code>th</code>
with vertices stacked row-wise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circumcenter.tetra(th)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circumcenter.tetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row
representing a vertex of the tetrahedron.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>circumcenter of the tetrahedron <code>th</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circumcenter.tri">circumcenter.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
A&lt;-c(0,0,0)+runif(3,-.2,.2);
B&lt;-c(1,0,0)+runif(3,-.2,.2);
C&lt;-c(1/2,sqrt(3)/2,0)+runif(3,-.2,.2);
D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)+runif(3,-.2,.2);
tetra&lt;-rbind(A,B,C,D)

CC&lt;-circumcenter.tetra(tetra)
CC

Xlim&lt;-range(tetra[,1],CC[1])
Ylim&lt;-range(tetra[,2],CC[2])
Zlim&lt;-range(tetra[,3],CC[3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::scatter3D(tetra[,1],tetra[,2],tetra[,3], phi =0,theta=40, bty = "g",
main="Illustration of the Circumcenter\n in a Tetrahedron",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05), zlim=Zlim+zd*c(-.05,.05),
          pch = 20, cex = 1, ticktype = "detailed")
#add the vertices of the tetrahedron
plot3D::points3D(CC[1],CC[2],CC[3], add=TRUE)
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lwd=2)

plot3D::text3D(tetra[,1],tetra[,2],tetra[,3],
labels=c("A","B","C","D"), add=TRUE)

D1&lt;-(A+B)/2; D2&lt;-(A+C)/2; D3&lt;-(A+D)/2; D4&lt;-(B+C)/2; D5&lt;-(B+D)/2; D6&lt;-(C+D)/2;
L&lt;-rbind(D1,D2,D3,D4,D5,D6); R&lt;-matrix(rep(CC,6),byrow = TRUE,ncol=3)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lty = 2)

plot3D::text3D(CC[1],CC[2],CC[3], labels="CC", add=TRUE)


</code></pre>

<hr>
<h2 id='circumcenter.tri'>Circumcenter of a general triangle</h2><span id='topic+circumcenter.tri'></span>

<h3>Description</h3>

<p>Returns the circumcenter a given triangle, <code>tri</code>,
with vertices stacked row-wise.
See (Weisstein (2019); Ceyhan (2010))
for triangle centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circumcenter.tri(tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circumcenter.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>circumcenter of the triangle <code>tri</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Weisstein EW (2019).
&ldquo;Triangle Centers.&rdquo;
From MathWorld &mdash; A Wolfram Web Resource, <a href="http://mathworld.wolfram.com/TriangleCenter.html">http://mathworld.wolfram.com/TriangleCenter.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circumcenter.basic.tri">circumcenter.basic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);  #the vertices of the triangle Tr

CC&lt;-circumcenter.tri(Tr)  #the circumcenter
CC

D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2; #midpoints of the edges
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],CC[1])
Ylim&lt;-range(Tr[,2],CC[2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,asp=1,pch=".",xlab="",ylab="",main="Circumcenter of a triangle",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(rbind(CC))
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Tr,CC,Ds)
xc&lt;-txt[,1]+c(-.08,.08,.08,.12,-.09,-.1,-.09)
yc&lt;-txt[,2]+c(.02,-.02,.03,-.06,.02,.06,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);  #the vertices of the equilateral triangle Te
circumcenter.tri(Te)  #the circumcenter

A&lt;-c(0,0); B&lt;-c(0,1); C&lt;-c(2,0);
Tr&lt;-rbind(A,B,C);  #the vertices of the triangle T
circumcenter.tri(Tr)  #the circumcenter


</code></pre>

<hr>
<h2 id='cl2CCvert.reg'>The closest points to circumcenter in each <code class="reqn">CC</code>-vertex region
in a triangle</h2><span id='topic+cl2CCvert.reg'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest data points among the data set, <code>Xp</code>,
to circumcenter, <code class="reqn">CC</code>, in each <code class="reqn">CC</code>-vertex region
in the triangle <code>tri</code> <code class="reqn">=T(A,B,C)=</code>(vertex 1,vertex 2,vertex 3).
</p>
<p><code>ch.all.intri</code> is for checking whether all data points are
inside <code>tri</code> (default is <code>FALSE</code>).
If some of the data points are not inside <code>tri</code>
and <code>ch.all.intri=TRUE</code>, then the function yields
an error message.
If some of the data points are not inside <code>tri</code>
and <code>ch.all.intri=FALSE</code>, then the function yields
the closest points to <code class="reqn">CC</code> among the data points
in each <code class="reqn">CC</code>-vertex region of <code>tri</code>
(yields <code>NA</code> if
there are no data points inside <code>tri</code>).
</p>
<p>See also (Ceyhan (2005, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2CCvert.reg(Xp, tri, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2CCvert.reg_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="cl2CCvert.reg_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="cl2CCvert.reg_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>)
to check whether all data points are inside
the triangle <code>tri</code>. So, if it is <code>TRUE</code>,
the function checks if all data points are
inside the closure of the triangle (i.e., interior and boundary
combined) else it does not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>,
and <code class="reqn">C=3</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances from closest points to CC ..."</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
closest points to <code class="reqn">CC</code> in each <code class="reqn">CC</code>-vertex region</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>, can be a <code>matrix</code>
or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points,
here, it is <code>tri</code></p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of vertex regions</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is <code>"CC"</code> for this function</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the triangle, <code>tri</code>,
provided as a <code>list</code></p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code>tri</code></p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from closest points
in each <code class="reqn">CC</code>-vertex region to CC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl2CCvert.reg.basic.tri">cl2CCvert.reg.basic.tri</a></code>, <code><a href="#topic+cl2edges.vert.reg.basic.tri">cl2edges.vert.reg.basic.tri</a></code>,
<code><a href="#topic+cl2edgesMvert.reg">cl2edgesMvert.reg</a></code>, <code><a href="#topic+cl2edgesCMvert.reg">cl2edgesCMvert.reg</a></code>,
and  <code><a href="#topic+fr2edgesCMedge.reg.std.tri">fr2edgesCMedge.reg.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

Ext&lt;-cl2CCvert.reg(Xp,Tr)
Ext
summary(Ext)
plot(Ext)

c2CC&lt;-Ext

CC&lt;-circumcenter.tri(Tr)  #the circumcenter
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",
main="Closest Points in CC-Vertex Regions \n to the Circumcenter",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(c2CC$ext,pch=4,col=2)

txt&lt;-rbind(Tr,CC,Ds)
xc&lt;-txt[,1]+c(-.07,.08,.06,.12,-.1,-.1,-.09)
yc&lt;-txt[,2]+c(.02,-.02,.03,.0,.02,.06,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

Xp2&lt;-rbind(Xp,c(.2,.4))
cl2CCvert.reg(Xp2,Tr,ch.all.intri = FALSE)
#gives an error message if ch.all.intri = TRUE since not all points are in the triangle


</code></pre>

<hr>
<h2 id='cl2CCvert.reg.basic.tri'>The closest points to circumcenter in each <code class="reqn">CC</code>-vertex region
in a standard basic triangle</h2><span id='topic+cl2CCvert.reg.basic.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest data points among the data set, <code>Xp</code>,
to circumcenter, <code class="reqn">CC</code>, in each <code class="reqn">CC</code>-vertex region
in the standard basic triangle
<code class="reqn">T_b = T(A=(0,0),B=(1,0),C=(c_1,c_2))=</code>(vertex 1,vertex 2,vertex 3).
<code>ch.all.intri</code> is for
checking whether all data points are inside <code class="reqn">T_b</code>
(default is <code>FALSE</code>).
</p>
<p>See also (Ceyhan (2005, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2CCvert.reg.basic.tri(Xp, c1, c2, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2CCvert.reg.basic.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points.</p>
</td></tr>
<tr><td><code id="cl2CCvert.reg.basic.tri_+3A_c1">c1</code>, <code id="cl2CCvert.reg.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle.
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code></p>
</td></tr>
<tr><td><code id="cl2CCvert.reg.basic.tri_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument for
checking whether all data points are inside <code class="reqn">T_b</code>
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>,
and <code class="reqn">C=3</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances from closest points to ..."</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
closest points to <code class="reqn">CC</code> in each vertex region.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, here, it is <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of vertex regions</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is <code>"CC"</code> for this function.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the triangle, <code class="reqn">T_b</code>,
provided as a <code>list</code>.</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from closest points in each vertex region to CC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl2CCvert.reg">cl2CCvert.reg</a></code>, <code><a href="#topic+cl2edges.vert.reg.basic.tri">cl2edges.vert.reg.basic.tri</a></code>,
<code><a href="#topic+cl2edgesMvert.reg">cl2edgesMvert.reg</a></code>, <code><a href="#topic+cl2edgesCMvert.reg">cl2edgesCMvert.reg</a></code>,
and <code><a href="#topic+fr2edgesCMedge.reg.std.tri">fr2edgesCMedge.reg.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
n&lt;-15

set.seed(1)
Xp&lt;-runif.basic.tri(n,c1,c2)$g

Ext&lt;-cl2CCvert.reg.basic.tri(Xp,c1,c2)
Ext
summary(Ext)
plot(Ext)

c2CC&lt;-Ext

CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",
main="Closest Points in CC-Vertex Regions \n to the Circumcenter",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(Xp)
points(c2CC$ext,pch=4,col=2)

txt&lt;-rbind(Tb,CC,Ds)
xc&lt;-txt[,1]+c(-.03,.03,.02,.07,.06,-.05,.01)
yc&lt;-txt[,2]+c(.02,.02,.03,-.01,.03,.03,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

Xp2&lt;-rbind(Xp,c(.2,.4))
cl2CCvert.reg.basic.tri(Xp2,c1,c2,ch.all.intri = FALSE)
#gives an error message if ch.all.intri = TRUE
#since not all points are in the standard basic triangle


</code></pre>

<hr>
<h2 id='cl2edges.std.tri'>The closest points in a data set to edges
in the standard equilateral triangle</h2><span id='topic+cl2edges.std.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest points from the 2D data set, <code>Xp</code>,
to the edges in the
standard equilateral triangle
<code class="reqn">T_e=T(A=(0,0),B=(1,0),C=(1/2,\sqrt{3}/2))</code>.
</p>
<p><code>ch.all.intri</code> is for checking
whether all data points are inside <code class="reqn">T_e</code> (default is <code>FALSE</code>).
</p>
<p>If some of the data points are not inside <code class="reqn">T_e</code>
and <code>ch.all.intri=TRUE</code>, then the function yields
an error message.
If some of the data points are not inside <code class="reqn">T_e</code>
and <code>ch.all.intri=FALSE</code>, then the function yields
the closest points to edges
among the data points inside <code class="reqn">T_e</code> (yields <code>NA</code>
if there are no data points
inside <code class="reqn">T_e</code>).
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan and Priebe (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2edges.std.tri(Xp, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2edges.std.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points.</p>
</td></tr>
<tr><td><code id="cl2edges.std.tri_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>)
to check whether all data points are inside
the standard equilateral triangle <code class="reqn">T_e</code>.
So, if it is <code>TRUE</code>,
the function checks if all data points are
inside the closure of the triangle (i.e., interior and boundary
combined) else it does not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Edge labels as <code class="reqn">AB=3</code>, <code class="reqn">BC=1</code>, and <code class="reqn">AC=2</code>
for <code class="reqn">T_e</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances to Edges ..."</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, i.e., closest points to edges</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
which can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, i.e.,
the standard equilateral triangle <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of edge regions,
not required for this extrema,
hence it is <code>NULL</code> for this function</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
not required for this extrema, hence it is <code>NULL</code> for this function</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Edge regions inside the triangle, <code class="reqn">T_e</code>,
not required for this extrema, hence it is <code>NULL</code>
for this function</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the edge regions,
not required for this extrema,
hence it is <code>NULL</code>
for this function</p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the edge regions inside <code class="reqn">T_e</code>,
not required for this extrema,
hence it is <code>NULL</code> for this function</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from closest points
in each edge region to the corresponding edge</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl2edges.vert.reg.basic.tri">cl2edges.vert.reg.basic.tri</a></code>, <code><a href="#topic+cl2edgesMvert.reg">cl2edgesMvert.reg</a></code>,
<code><a href="#topic+cl2edgesCMvert.reg">cl2edgesCMvert.reg</a></code> and <code><a href="#topic+fr2edgesCMedge.reg.std.tri">fr2edgesCMedge.reg.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-20  #try also n&lt;-100
Xp&lt;-runif.std.tri(n)$gen.points

Ext&lt;-cl2edges.std.tri(Xp)
Ext
summary(Ext)
plot(Ext,asp=1)

ed.clo&lt;-Ext

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(0.5,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
CM&lt;-(A+B+C)/3
p1&lt;-(A+B)/2
p2&lt;-(B+C)/2
p3&lt;-(A+C)/2

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),
ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
points(Xp,xlab="",ylab="")
points(ed.clo$ext,pty=2,pch=4,col="red")

txt&lt;-rbind(Te,p1,p2,p3)
xc&lt;-txt[,1]+c(-.03,.03,.03,0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.02,0,0,0)
txt.str&lt;-c("A","B","C","re=1","re=2","re=3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='cl2edges.vert.reg.basic.tri'>The closest points among a data set in the vertex regions
to the corresponding edges in a standard basic triangle</h2><span id='topic+cl2edges.vert.reg.basic.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest data points among the data set, <code>Xp</code>,
to edge <code class="reqn">i</code> in <code>M</code>-vertex region <code class="reqn">i</code> for <code class="reqn">i=1,2,3</code>
in the standard basic triangle <code class="reqn">T_b=T(A=(0,0),B=(1,0),C=(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, and <code class="reqn">C=3</code>,
and corresponding edge labels are <code class="reqn">BC=1</code>, <code class="reqn">AC=2</code>, and <code class="reqn">AB=3</code>.
</p>
<p>Vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or based on the circumcenter of <code class="reqn">T_b</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle. Hence, standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2edges.vert.reg.basic.tri(Xp, c1, c2, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2edges.vert.reg.basic.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="cl2edges.vert.reg.basic.tri_+3A_c1">c1</code>, <code id="cl2edges.vert.reg.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="cl2edges.vert.reg.basic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or the circumcenter of <code class="reqn">T_b</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, and <code class="reqn">C=3</code>
(correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances to Edges in the Respective \eqn{M}-Vertex Regions"</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here, closest points to edges
in the corresponding vertex region.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, here, it is <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of vertex regions</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is <code>"M"</code> or <code>"CC"</code> for this function</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the triangle, <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances of closest points
in the vertex regions to corresponding edges.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl2edgesCMvert.reg">cl2edgesCMvert.reg</a></code>, <code><a href="#topic+cl2edgesMvert.reg">cl2edgesMvert.reg</a></code>,
and <code><a href="#topic+cl2edges.std.tri">cl2edges.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4;  c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C);

set.seed(1)
n&lt;-20
Xp&lt;-runif.basic.tri(n,c1,c2)$g

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.3)

Ext&lt;-cl2edges.vert.reg.basic.tri(Xp,c1,c2,M)
Ext
summary(Ext)
plot(Ext)

cl2e&lt;-Ext

Ds&lt;-prj.cent2edges.basic.tri(c1,c2,M)

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tb,pch=".",xlab="",ylab="",
main="Closest Points in M-Vertex Regions \n to the Opposite Edges",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
points(Xp,pch=1,col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(cl2e$ext,pch=3,col=2)

xc&lt;-Tb[,1]+c(-.02,.02,0.02)
yc&lt;-Tb[,2]+c(.02,.02,.02)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(-.02,.04,-.03,0)
yc&lt;-txt[,2]+c(-.02,.02,.02,-.03)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='cl2edgesCCvert.reg'>The closest points in a data set to edges
in each <code class="reqn">CC</code>-vertex region in a triangle</h2><span id='topic+cl2edgesCCvert.reg'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest data points among the data set, <code>Xp</code>,
to edge <code class="reqn">j</code> in <code class="reqn">CC</code>-vertex region <code class="reqn">j</code> for <code class="reqn">j=1,2,3</code>
in the triangle, <code>tri</code><code class="reqn">=T(A,B,C)</code>,
where <code class="reqn">CC</code> stands for circumcenter.
Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, and <code class="reqn">C=3</code>,
and corresponding edge labels are <code class="reqn">BC=1</code>, <code class="reqn">AC=2</code>, and <code class="reqn">AB=3</code>.
Function yields <code>NA</code>
if there are no data points in a <code class="reqn">CC</code>-vertex region.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2edgesCCvert.reg(Xp, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2edgesCCvert.reg_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="cl2edgesCCvert.reg_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, and <code class="reqn">C=3</code>
(correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances to Edges in the Respective CC-Vertex Regions"</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points,
here, closest points to edges in the respective vertex region.</p>
</td></tr>
<tr><td><code>ind.ext</code></td>
<td>
<p>Indices of the extrema points,<code>ext</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points,
i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points,
here, it is <code>tri</code></p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of vertex regions</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is <code>"CC"</code> for this function</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the triangle, <code>tri</code>,
provided as a <code>list</code></p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code>tri</code></p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances of closest points
in the vertex regions to corresponding edges</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl2edges.vert.reg.basic.tri">cl2edges.vert.reg.basic.tri</a></code>, <code><a href="#topic+cl2edgesCMvert.reg">cl2edgesCMvert.reg</a></code>,
<code><a href="#topic+cl2edgesMvert.reg">cl2edgesMvert.reg</a></code>, and <code><a href="#topic+cl2edges.std.tri">cl2edges.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

n&lt;-20  #try also n&lt;-100
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

Ext&lt;-cl2edgesCCvert.reg(Xp,Tr)
Ext
summary(Ext)
plot(Ext)

cl2e&lt;-Ext

CC&lt;-circumcenter.tri(Tr);
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1],CC[1])
Ylim&lt;-range(Tr[,2],Xp[,2],CC[2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,asp=1,pch=".",xlab="",ylab="",
main="Closest Points in CC-Vertex Regions \n to the Opposite Edges",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)

xc&lt;-Tr[,1]+c(-.02,.02,.02)
yc&lt;-Tr[,2]+c(.02,.02,.04)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)

points(Xp,pch=1,col=1)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(cl2e$ext,pch=3,col=2)

txt&lt;-rbind(CC,Ds)
xc&lt;-txt[,1]+c(-.04,.04,-.03,0)
yc&lt;-txt[,2]+c(-.05,.04,.06,-.08)
txt.str&lt;-c("CC","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='cl2edgesCMvert.reg'>The closest points in a data set to edges
in each <code class="reqn">CM</code>-vertex region in a triangle</h2><span id='topic+cl2edgesCMvert.reg'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest data points among the data set, <code>Xp</code>,
to edge <code class="reqn">j</code> in <code class="reqn">CM</code>-vertex region <code class="reqn">j</code> for <code class="reqn">j=1,2,3</code>
in the triangle, <code>tri</code><code class="reqn">=T(A,B,C)</code>,
where <code class="reqn">CM</code> stands for center of mass.
Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, and <code class="reqn">C=3</code>,
and corresponding edge labels are <code class="reqn">BC=1</code>, <code class="reqn">AC=2</code>, and <code class="reqn">AB=3</code>.
Function yields <code>NA</code>
if there are no data points in a <code class="reqn">CM</code>-vertex region.
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2010, 2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2edgesCMvert.reg(Xp, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2edgesCMvert.reg_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="cl2edgesCMvert.reg_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix
with each row representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, and <code class="reqn">C=3</code>
(correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances to Edges in the Respective CM-Vertex Regions"</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points,
here, closest points to edges in the respective vertex region.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points,
i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points,
here, it is <code>tri</code></p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of vertex regions</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is <code>"CM"</code> for this function</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the triangle, <code>tri</code>,
provided as a <code>list</code></p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code>tri</code></p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances of closest points
in the vertex regions to corresponding edges</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl2edges.vert.reg.basic.tri">cl2edges.vert.reg.basic.tri</a></code>, <code><a href="#topic+cl2edgesCCvert.reg">cl2edgesCCvert.reg</a></code>,
<code><a href="#topic+cl2edgesMvert.reg">cl2edgesMvert.reg</a></code>, and <code><a href="#topic+cl2edges.std.tri">cl2edges.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

n&lt;-20  #try also n&lt;-100
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

Ext&lt;-cl2edgesCMvert.reg(Xp,Tr)
Ext
summary(Ext)
plot(Ext)

cl2e&lt;-Ext

CM&lt;-(A+B+C)/3;
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",
main="Closest Points in CM-Vertex Regions \n to the Opposite Edges",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)

xc&lt;-Tr[,1]+c(-.02,.02,.02)
yc&lt;-Tr[,2]+c(.02,.02,.04)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)

points(Xp,pch=1,col=1)
L&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(cl2e$ext,pch=3,col=2)

txt&lt;-rbind(CM,Ds)
xc&lt;-txt[,1]+c(-.04,.04,-.03,0)
yc&lt;-txt[,2]+c(-.05,.04,.06,-.08)
txt.str&lt;-c("CM","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='cl2edgesMvert.reg'>The closest points among a data set
in the vertex regions to the respective edges in a triangle</h2><span id='topic+cl2edgesMvert.reg'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest data points among the data set, <code>Xp</code>,
to edge <code class="reqn">i</code> in <code>M</code>-vertex region <code class="reqn">i</code> for <code class="reqn">i=1,2,3</code>
in the triangle <code>tri</code><code class="reqn">=T(A,B,C)</code>.
Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, and <code class="reqn">C=3</code>,
and corresponding edge labels are
<code class="reqn">BC=1</code>, <code class="reqn">AC=2</code>, and <code class="reqn">AB=3</code>.
</p>
<p>Vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on the circumcenter of <code>tri</code>.
</p>
<p>Two methods of finding these extrema are provided in the function,
which can be chosen in the logical argument <code>alt</code>,
whose default is <code>alt=FALSE</code>.
When <code>alt=FALSE</code>, the function sequentially finds
the vertex region of the data point and then updates the minimum distance
to the opposite edge and the relevant extrema objects,
and when <code>alt=TRUE</code>, it first partitions the data set according
which vertex regions they reside, and
then finds the minimum distance to the opposite edge
and the relevant extrema on each partition.
Both options yield equivalent results for the extrema points and indices,
with the default being slightly ~ 20
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2edgesMvert.reg(Xp, tri, M, alt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2edgesMvert.reg_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="cl2edgesMvert.reg_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="cl2edgesMvert.reg_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>;
which may be entered as &quot;CC&quot; as well;</p>
</td></tr>
<tr><td><code id="cl2edgesMvert.reg_+3A_alt">alt</code></td>
<td>
<p>A logical argument for alternative method of
finding the closest points to the edges,
default <code>alt=FALSE</code>.
When <code>alt=FALSE</code>, the function sequentially finds
the vertex region of the data point and then the minimum distance
to the opposite edge and the relevant extrema objects,
and when <code>alt=TRUE</code>, it first partitions the data set according
which vertex regions they reside, and
then finds the minimum distance to the opposite edge
and the relevant extrema on each partition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, and <code class="reqn">C=3</code>
(correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances to Edges in the Respective \eqn{M}-Vertex Regions"</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
closest points to edges in the respective vertex region.</p>
</td></tr>
<tr><td><code>ind.ext</code></td>
<td>
<p>The data indices of extrema points, <code>ext</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, here, it is <code>tri</code></p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of vertex regions</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is <code>"M"</code> or <code>"CC"</code> for this function</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions
inside the triangle, <code>tri</code>, provided as a <code>list</code></p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code>tri</code></p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances of closest points
in the <code>M</code>-vertex regions to corresponding edges.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl2edges.vert.reg.basic.tri">cl2edges.vert.reg.basic.tri</a></code>, <code><a href="#topic+cl2edgesCMvert.reg">cl2edgesCMvert.reg</a></code>,
and <code><a href="#topic+cl2edges.std.tri">cl2edges.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);

Tr&lt;-rbind(A,B,C);
n&lt;-20  #try also n&lt;-100

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

Ext&lt;-cl2edgesMvert.reg(Xp,Tr,M)
Ext
summary(Ext)
plot(Ext)

cl2e&lt;-Ext

Ds&lt;-prj.cent2edges(Tr,M)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

plot(Tr,pch=".",xlab="",ylab="",
main="Closest Points in M-Vertex Regions \n to the Opposite Edges",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=1,col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(cl2e$ext,pch=3,col=2)

xc&lt;-Tr[,1]+c(-.02,.03,.02)
yc&lt;-Tr[,2]+c(.02,.02,.04)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(-.02,.05,-.02,-.01)
yc&lt;-txt[,2]+c(-.03,.02,.08,-.07)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='cl2faces.vert.reg.tetra'>The closest points among a data set in the vertex regions
to the respective faces in a tetrahedron</h2><span id='topic+cl2faces.vert.reg.tetra'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest data points among the data set, <code>Xp</code>,
to face <code class="reqn">i</code> in <code>M</code>-vertex region <code class="reqn">i</code> for <code class="reqn">i=1,2,3,4</code>
in the tetrahedron <code class="reqn">th=T(A,B,C,D)</code>.
Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, <code class="reqn">C=3</code>, and <code class="reqn">D=4</code>
and corresponding face labels are
<code class="reqn">BCD=1</code>, <code class="reqn">ACD=2</code>, <code class="reqn">ABD=3</code>, and <code class="reqn">ABC=4</code>.
</p>
<p>Vertex regions are based on center <code>M</code>
which can be the center of mass (<code>"CM"</code>)
or circumcenter (<code>"CC"</code>) of <code>th</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2faces.vert.reg.tetra(Xp, th, M = "CM")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2faces.vert.reg.tetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="cl2faces.vert.reg.tetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row
representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="cl2faces.vert.reg.tetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions
in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter
and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>, <code class="reqn">C=3</code>,
and <code class="reqn">D=4</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances from Closest Points to Faces ..."</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
closest points to faces in the respective vertex region.</p>
</td></tr>
<tr><td><code>ind.ext</code></td>
<td>
<p>The data indices of extrema points, <code>ext</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points,
here, it is <code>th</code></p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of vertex regions,
it is circumcenter of center of mass for this function</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, it is circumcenter <code>"CC"</code>
or center of mass <code>"CM"</code> for this function.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions
inside the tetrahedron <code>th</code> provided as a list.</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1","vr=2","vr=3","vr=4"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code>th</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from closest points
in each vertex region to the corresponding face.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fr2vertsCCvert.reg">fr2vertsCCvert.reg</a></code>, <code><a href="#topic+fr2edgesCMedge.reg.std.tri">fr2edgesCMedge.reg.std.tri</a></code>,
<code><a href="#topic+fr2vertsCCvert.reg.basic.tri">fr2vertsCCvert.reg.basic.tri</a></code> and <code><a href="#topic+kfr2vertsCCvert.reg">kfr2vertsCCvert.reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0);
D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
set.seed(1)
tetra&lt;-rbind(A,B,C,D)+matrix(runif(12,-.25,.25),ncol=3)
n&lt;-10  #try also n&lt;-20
Cent&lt;-"CC"  #try also "CM"

n&lt;-20  #try also n&lt;-100
Xp&lt;-runif.tetra(n,tetra)$g  #try also Xp&lt;-cbind(runif(n),runif(n),runif(n))

Ext&lt;-cl2faces.vert.reg.tetra(Xp,tetra,Cent)
Ext
summary(Ext)
plot(Ext)

clf&lt;-Ext$ext

if (Cent=="CC") {M&lt;-circumcenter.tetra(tetra)}
if (Cent=="CM") {M&lt;-apply(tetra,2,mean)}

Xlim&lt;-range(tetra[,1],Xp[,1],M[1])
Ylim&lt;-range(tetra[,2],Xp[,2],M[2])
Zlim&lt;-range(tetra[,3],Xp[,3],M[3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::scatter3D(Xp[,1],Xp[,2],Xp[,3], phi =0,theta=40, bty = "g",
main="Closest Pointsin CC-Vertex Regions \n to the Opposite Faces",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05), zlim=Zlim+zd*c(-.05,.05),
          pch = 20, cex = 1, ticktype = "detailed")
#add the vertices of the tetrahedron
plot3D::points3D(tetra[,1],tetra[,2],tetra[,3], add=TRUE)
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lwd=2)
plot3D::points3D(clf[,1],clf[,2],clf[,3], pch=4,col="red", add=TRUE)

plot3D::text3D(tetra[,1],tetra[,2],tetra[,3],
labels=c("A","B","C","D"), add=TRUE)

#for center of mass use #Cent&lt;-apply(tetra,2,mean)
D1&lt;-(A+B)/2; D2&lt;-(A+C)/2; D3&lt;-(A+D)/2;
D4&lt;-(B+C)/2; D5&lt;-(B+D)/2; D6&lt;-(C+D)/2;
L&lt;-rbind(D1,D2,D3,D4,D5,D6); R&lt;-rbind(M,M,M,M,M,M)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lty=2)


</code></pre>

<hr>
<h2 id='cl2Mc.int'>The closest points to center in each vertex region
in an interval</h2><span id='topic+cl2Mc.int'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the closest data points among the data set, <code>Xp</code>,
in each <code class="reqn">M_c</code>-vertex region
i.e., finds the closest points from right and left to <code class="reqn">M_c</code>
among points of the 1D data set <code>Xp</code> which reside in
in the interval <code>int</code><code class="reqn">=(a,b)</code>.
</p>
<p><code class="reqn">M_c</code> is based on the centrality parameter <code class="reqn">c \in (0,1)</code>,
so that <code class="reqn">100c</code> % of the length of interval is to the left of <code class="reqn">M_c</code>
and <code class="reqn">100(1-c)</code> % of the length of the interval
is to the right of <code class="reqn">M_c</code>.
That is, for the interval <code class="reqn">(a,b)</code>, <code class="reqn">M_c=a+c(b-a)</code>.
If there are no points from <code>Xp</code> to
the left of <code class="reqn">M_c</code> in the interval, then it yields <code>NA</code>,
and likewise for the right of <code class="reqn">M_c</code> in the interval.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl2Mc.int(Xp, int, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl2Mc.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points
from which closest points to <code class="reqn">M_c</code> are found
in the interval <code>int</code>.</p>
</td></tr>
<tr><td><code id="cl2Mc.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="cl2Mc.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code>
parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>,
the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex Labels are <code class="reqn">a=1</code> and <code class="reqn">b=2</code>
for the interval <code class="reqn">(a,b)</code>.</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances from ..."</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
closest points to <code class="reqn">M_c</code> in each vertex region</p>
</td></tr>
<tr><td><code>ind.ext</code></td>
<td>
<p>The data indices of extrema points, <code>ext</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data vector, <code>Xp</code>.</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points,
i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points,
here, it is <code>int</code>.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The (parameterized) center point used for
construction of vertex regions.</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the (parameterized) center, <code>cent</code>,
it is <code>"Mc"</code> for this function.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the interval, <code>int</code>,
provided as a list.</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code>int</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from closest points
in each vertex region to <code class="reqn">M_c</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl2CCvert.reg.basic.tri">cl2CCvert.reg.basic.tri</a></code> and <code><a href="#topic+cl2CCvert.reg">cl2CCvert.reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

Mc&lt;-centerMc(int,c)

nx&lt;-10
xr&lt;-range(a,b,Mc)
xf&lt;-(xr[2]-xr[1])*.5

Xp&lt;-runif(nx,a,b)

Ext&lt;-cl2Mc.int(Xp,int,c)
Ext
summary(Ext)
plot(Ext)

cMc&lt;-Ext

Xlim&lt;-range(a,b,Xp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),xlab="",pch=".",
main=paste("Closest Points in Mc-Vertex Regions \n to the Center Mc = ",Mc,sep=""),
  xlim=Xlim+xd*c(-.05,.05))
  abline(h=0)
abline(v=c(a,b,Mc),col=c(1,1,2),lty=2)
points(cbind(Xp,0))
points(cbind(c(cMc$ext),0),pch=4,col=2)
text(cbind(c(a,b,Mc)-.02*xd,-0.05),c("a","b",expression(M[c])))


</code></pre>

<hr>
<h2 id='CSarc.dens.test'>A test of segregation/association based on arc density of Central Similarity Proximity Catch Digraph
(CS-PCD) for 2D data</h2><span id='topic+CSarc.dens.test'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function which performs a hypothesis test of complete spatial
randomness (CSR) or uniformity of <code>Xp</code> points in the convex hull of <code>Yp</code> points against the alternatives
of segregation (where <code>Xp</code> points cluster away from <code>Yp</code> points) and association (where <code>Xp</code> points cluster around
<code>Yp</code> points) based on the normal approximation of the arc density of the CS-PCD for uniform 2D data
in the convex hull of <code>Yp</code> points.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value for the corresponding <code>alternative</code>,
the confidence interval, estimate and null value for the parameter of interest (which is the arc density),
and method and name of the data set used.
</p>
<p>Under the null hypothesis of uniformity of <code>Xp</code> points in the convex hull of <code>Yp</code> points, arc density
of CS-PCD whose vertices are <code>Xp</code> points equals to its expected value under the uniform distribution and
<code>alternative</code> could be two-sided, or left-sided (i.e., data is accumulated around the <code>Yp</code> points, or association)
or right-sided (i.e., data is accumulated around the centers of the triangles, or segregation).
</p>
<p>CS proximity region is constructed with the expansion parameter <code class="reqn">t&gt;0</code> and <code class="reqn">CM</code>-edge regions
(i.e., the test is not available for a general center <code class="reqn">M</code> at this version of the function).
</p>
<p>**Caveat:** This test is currently a conditional test, where <code>Xp</code> points are assumed to be random, while <code>Yp</code> points are
assumed to be fixed (i.e., the test is conditional on <code>Yp</code> points).
Furthermore, the test is a large sample test when <code>Xp</code> points are substantially larger than <code>Yp</code> points,
say at least 5 times more.
This test is more appropriate when supports of <code>Xp</code> and <code>Yp</code> has a substantial overlap.
Currently, the <code>Xp</code> points
outside the convex hull of <code>Yp</code> points
are handled with a convex hull correction factor, <code>ch.cor</code>,
which is derived under the assumption of
uniformity of <code>Xp</code> and <code>Yp</code> points in the study window,
(see the description below and the function code.)
However, in the special case of no <code>Xp</code> points in the convex hull of <code>Yp</code> points, arc density is taken to be 1,
as this is clearly a case of segregation. Removing the conditioning and extending it to the case of non-concurring supports is
an ongoing line of research of the author of the package.
</p>
<p><code>ch.cor</code> is for convex hull correction (default is <code>"no convex hull correction"</code>, i.e., <code>ch.cor=FALSE</code>)
which is recommended when both <code>Xp</code> and <code>Yp</code> have the same rectangular support.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSarc.dens.test(
  Xp,
  Yp,
  t,
  ch.cor = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSarc.dens.test_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test_+3A_ch.cor">ch.cor</code></td>
<td>
<p>A logical argument for convex hull correction, default <code>ch.cor=FALSE</code>,
recommended when both <code>Xp</code> and <code>Yp</code> have the same rectangular support.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval, default is <code>0.95</code>, for the arc density of CS-PCD based on
the 2D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding <code>alternative</code></p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the arc density at the given confidence level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., arc density</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter, i.e., the null arc density, which is usually the
mean arc density under uniform distribution.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEarc.dens.test">PEarc.dens.test</a></code> and <code><a href="#topic+CSarc.dens.test1D">CSarc.dens.test1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-100; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx),runif(nx))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

plotDelaunay.tri(Xp,Yp,xlab="",ylab = "")

CSarc.dens.test(Xp,Yp,t=.5)
CSarc.dens.test(Xp,Yp,t=.5,ch=TRUE)
#try also t=1.0 and 1.5 above


</code></pre>

<hr>
<h2 id='CSarc.dens.test.int'>A test of uniformity of 1D data in a given interval based
on Central Similarity Proximity Catch Digraph (CS-PCD)</h2><span id='topic+CSarc.dens.test.int'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function which performs a hypothesis test of uniformity of 1D
data in one interval based on the normal approximation of the arc density of the CS-PCD with expansion
parameter <code class="reqn">t&gt;0</code> and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding <code>alternative</code>, the confidence interval, estimate and null value for the parameter of interest
(which is the arc density), and method and name of the data set used.
</p>
<p>The null hypothesis is that data is
uniform in a finite interval (i.e., arc density of CS-PCD equals to its expected value under uniform
distribution) and <code>alternative</code> could be two-sided, or left-sided (i.e., data is accumulated around the end
points) or right-sided (i.e., data is accumulated around the mid point or center <code class="reqn">M_c</code>).
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSarc.dens.test.int(
  Xp,
  int,
  t,
  c = 0.5,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSarc.dens.test.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of CS-PCD.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test.int_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test.int_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval, default is <code>0.95</code>, for the arc density of CS-PCD based on
the 1D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding <code>alternative</code></p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the arc density at the given level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., arc density</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter, i.e., the null arc density, which is usually the
mean arc density under uniform distribution.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEarc.dens.test.int">PEarc.dens.test.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
t&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-10
Xp&lt;-runif(n,a,b)

num.arcsCSmid.int(Xp,int,t,c)
CSarc.dens.test.int(Xp,int,t,c)

num.arcsCSmid.int(Xp,int,t,c=.3)
CSarc.dens.test.int(Xp,int,t,c=.3)

num.arcsCSmid.int(Xp,int,t=1.5,c)
CSarc.dens.test.int(Xp,int,t=1.5,c)

Xp&lt;-runif(n,a-1,b+1)
num.arcsCSmid.int(Xp,int,t,c)
CSarc.dens.test.int(Xp,int,t,c)

c&lt;-.4
t&lt;-.5
a&lt;-0; b&lt;-10; int&lt;-c(a,b)
n&lt;-10  #try also n&lt;-20
Xp&lt;-runif(n,a,b)

CSarc.dens.test.int(Xp,int,t,c)


</code></pre>

<hr>
<h2 id='CSarc.dens.test1D'>A test of segregation/association based on arc density of
Central Similarity Proximity Catch Digraph
(CS-PCD) for 1D data</h2><span id='topic+CSarc.dens.test1D'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function
which performs a hypothesis test of complete spatial
randomness (CSR) or uniformity of <code>Xp</code> points in the range
(i.e., range) of <code>Yp</code> points against the alternatives
of segregation (where <code>Xp</code> points cluster away from <code>Yp</code> points)
and association (where <code>Xp</code> points cluster around
<code>Yp</code> points) based on the normal approximation of
the arc density of the CS-PCD for uniform 1D data.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value
for the corresponding <code>alternative</code>,
the confidence interval, estimate and null value for the parameter of interest
(which is the arc density),
and method and name of the data set used.
</p>
<p>Under the null hypothesis of uniformity of <code>Xp</code> points
in the range of <code>Yp</code> points, arc density
of CS-PCD whose vertices are <code>Xp</code> points equals to
its expected value under the uniform distribution and
<code>alternative</code> could be two-sided, or left-sided
(i.e., data is accumulated around the <code>Yp</code> points, or association)
or right-sided (i.e., data is accumulated around the centers of the intervals,
or segregation).
</p>
<p>CS proximity region is constructed with the expansion parameter <code class="reqn">t &gt; 0</code>
and centrality parameter <code>c</code> which yields
<code class="reqn">M</code>-vertex regions.
More precisely, for a middle interval <code class="reqn">(y_{(i)},y_{(i+1)})</code>, the center is
<code class="reqn">M=y_{(i)}+c(y_{(i+1)}-y_{(i)})</code> for the centrality parameter <code class="reqn">c \in (0,1)</code>.
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>**Caveat:** This test is currently a conditional test,
where <code>Xp</code> points are assumed to be random, while <code>Yp</code> points are
assumed to be fixed (i.e., the test is conditional on <code>Yp</code> points).
Furthermore, the test is a large sample test
when <code>Xp</code> points are substantially larger than <code>Yp</code> points,
say at least 5 times more.
This test is more appropriate when supports of <code>Xp</code> and <code>Yp</code>
have a substantial overlap.
Currently, the <code>Xp</code> points outside the range of <code>Yp</code> points
are handled with a range correction (or
end-interval correction) factor (see the description below and the function code.)
However, in the special case of no <code>Xp</code> points in the range of <code>Yp</code> points,
arc density is taken to be 1,
as this is clearly a case of segregation.
Removing the conditioning and extending it to the case of non-concurring supports is
an ongoing line of research of the author of the package.
</p>
<p><code>end.int.cor</code> is for end-interval correction,
recommended when both <code>Xp</code> and <code>Yp</code> have the same interval support
(default is &quot;no end-interval correction&quot;, i.e., <code>end.int.cor=FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSarc.dens.test1D(
  Xp,
  Yp,
  t,
  c = 0.5,
  support.int = NULL,
  end.int.cor = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSarc.dens.test1D_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test1D_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points which constitute the end points of the partition intervals.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test1D_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test1D_+3A_c">c</code></td>
<td>
<p>A positive real number which serves as the centrality parameter in CS proximity region;
must be in <code class="reqn">(0,1)</code> (default <code>c=.5</code>).</p>
</td></tr>
<tr><td><code id="CSarc.dens.test1D_+3A_support.int">support.int</code></td>
<td>
<p>Support interval <code class="reqn">(a,b)</code> with <code class="reqn">a&lt;b</code>.
Uniformity of <code>Xp</code> points in this interval is tested. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test1D_+3A_end.int.cor">end.int.cor</code></td>
<td>
<p>A logical argument for end-interval correction, default is <code>FALSE</code>,
recommended when both <code>Xp</code> and <code>Yp</code> have the same interval support.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test1D_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="CSarc.dens.test1D_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval, default is <code>0.95</code>, for the arc density
CS-PCD whose vertices are the 1D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding <code>alternative</code>.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the arc density at the given confidence level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., arc density</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter, i.e., the null arc density, which is usually the
mean arc density under uniform distribution.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CSarc.dens.test">CSarc.dens.test</a></code> and <code><a href="#topic+CSarc.dens.test.int">CSarc.dens.test.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int=c(a,b)

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

CSarc.dens.test1D(Xp,Yp,tau,c,int)
CSarc.dens.test1D(Xp,Yp,tau,c,int,alt="l")
CSarc.dens.test1D(Xp,Yp,tau,c,int,alt="g")

CSarc.dens.test1D(Xp,Yp,tau,c,int,end.int.cor = TRUE)

Yp2&lt;-runif(ny,a,b)+11
CSarc.dens.test1D(Xp,Yp2,tau,c,int)

n&lt;-10  #try also n&lt;-20
Xp&lt;-runif(n,a,b)
CSarc.dens.test1D(Xp,Yp,tau,c,int)

</code></pre>

<hr>
<h2 id='CSarc.dens.tri'>Arc density of Central Similarity Proximity Catch Digraphs (CS-PCDs) - one triangle case</h2><span id='topic+CSarc.dens.tri'></span>

<h3>Description</h3>

<p>Returns the arc density of CS-PCD whose vertex set is the given 2D numerical data set, <code>Xp</code>,
(some of its members are) in the triangle <code>tri</code>.
</p>
<p>CS proximity regions is defined with respect to <code>tri</code> with
expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of the triangle <code>tri</code>; default is
<code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
The function also provides arc density standardized by the mean and asymptotic variance of the arc density
of CS-PCD for uniform data in the triangle <code>tri</code>
only when <code>M</code> is the center of mass. For the number of arcs, loops are not allowed.
</p>
<p> is a logical argument (default is <code>FALSE</code>) for considering only the points
inside the triangle or all the points as the vertices of the digraph.
if <code>in.tri.only=TRUE</code>, arc density is computed only for
the points inside the triangle (i.e., arc density of the subdigraph
induced by the vertices in the triangle is computed),
otherwise arc density of the entire digraph (i.e., digraph with all the vertices) is computed.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014))
for more on CS-PCDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSarc.dens.tri(Xp, tri, t, M = c(1, 1, 1), in.tri.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSarc.dens.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="CSarc.dens.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="CSarc.dens.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="CSarc.dens.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="CSarc.dens.tri_+3A_in.tri.only">in.tri.only</code></td>
<td>
<p>A logical argument (default is <code>=FALSE</code>)
for computing the arc density for only the points inside the triangle, <code>tri</code>.
That is,
if <code>=TRUE</code> arc density of the induced subdigraph with the vertices
inside <code>tri</code> is computed, otherwise
otherwise arc density of the entire digraph (i.e., digraph with all the vertices) is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>arc.dens</code></td>
<td>
<p>Arc density of CS-PCD whose vertices are the 2D numerical data set, <code>Xp</code>;
CS proximity regions are defined with respect to the triangle <code>tri</code> and <code>M</code>-edge regions</p>
</td></tr>
<tr><td><code>std.arc.dens</code></td>
<td>
<p>Arc density standardized by the mean and asymptotic variance of the arc
density of CS-PCD for uniform data in the triangle <code>tri</code>.This will only be returned if <code>M</code> is the center of mass.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ASarc.dens.tri">ASarc.dens.tri</a></code>, <code><a href="#topic+PEarc.dens.tri">PEarc.dens.tri</a></code>, and <code><a href="#topic+num.arcsCStri">num.arcsCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

CSarc.dens.tri(Xp,Tr,t=.5,M)
CSarc.dens.tri(Xp,Tr,t=.5,M, in.tri.only= FALSE)
#try also t=1 and t=1.5 above


</code></pre>

<hr>
<h2 id='dimension'>The dimension of a <code>vector</code> or matrix or a data frame</h2><span id='topic+dimension'></span>

<h3>Description</h3>

<p>Returns the dimension (i.e., number of columns) of <code>x</code>,
which is a matrix or a <code>vector</code> or a data frame.
This is different than the <code>dim</code> function in base <code>R</code>,
in the sense that,
<code>dimension</code> gives only the number of columns of the argument <code>x</code>,
while <code>dim</code> gives the number of rows and
columns of <code>x</code>.
<code>dimension</code> also works for a scalar or a vector,
while <code>dim</code> yields <code>NULL</code> for such arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimension(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimension_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> or a matrix or a data frame
whose dimension is to be determined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dimension (i.e., number of columns) of <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.point">is.point</a></code> and <code><a href="base.html#topic+dim">dim</a></code>
from the base distribution of <code>R</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dimension(3)
dim(3)

A&lt;-c(1,2)
dimension(A)
dim(A)

B&lt;-c(2,3)
dimension(rbind(A,B,A))
dimension(cbind(A,B,A))

M&lt;-matrix(runif(20),ncol=5)
dimension(M)
dim(M)

dimension(c("a","b"))


</code></pre>

<hr>
<h2 id='Dist'>The distance between two vectors, matrices, or data frames</h2><span id='topic+Dist'></span>

<h3>Description</h3>

<p>Returns the Euclidean distance between <code>x</code> and <code>y</code>
which can be vectors
or matrices or data frames of any dimension (<code>x</code> and <code>y</code>
should be of same dimension).
</p>
<p>This function is different from the <code><a href="stats.html#topic+dist">dist</a></code> function
in the <code>stats</code> package of the standard <code>R</code> distribution.
<code>dist</code> requires its argument to be a data matrix
and <code><a href="stats.html#topic+dist">dist</a></code> computes
and returns the distance matrix computed
by using the specified distance measure
to compute the distances between the rows of a data matrix
(Becker et al. (1988)),
while <code>Dist</code> needs two arguments to find the distances between.
For two data matrices <code class="reqn">A</code> and <code class="reqn">B</code>,
<code>dist(rbind(as.vector(A), as.vector(B)))</code>
and <code>Dist(A,B)</code> yield the same result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dist(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dist_+3A_x">x</code>, <code id="Dist_+3A_y">y</code></td>
<td>
<p>Vectors, matrices or data frames
(both should be of the same type).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euclidean distance between <code>x</code> and <code>y</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Becker RA, Chambers JM, Wilks AR (1988).
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code> from the base package <code>stats</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Dist(B,C);
dist(rbind(B,C))

x&lt;-runif(10)
y&lt;-runif(10)
Dist(x,y)

xm&lt;-matrix(x,ncol=2)
ym&lt;-matrix(y,ncol=2)
Dist(xm,ym)
dist(rbind(as.vector(xm),as.vector(ym)))

Dist(xm,xm)


</code></pre>

<hr>
<h2 id='dist.point2line'>The distance from a point to a line defined by two points</h2><span id='topic+dist.point2line'></span>

<h3>Description</h3>

<p>Returns the distance from a point <code>p</code> to the line joining
points <code>a</code> and <code>b</code> in 2D space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.point2line(p, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.point2line_+3A_p">p</code></td>
<td>
<p>A 2D point, distance from <code>p</code> to the line
passing through points <code>a</code> and <code>b</code> are to be
computed.</p>
</td></tr>
<tr><td><code id="dist.point2line_+3A_a">a</code>, <code id="dist.point2line_+3A_b">b</code></td>
<td>
<p>2D points that determine the straight line
(i.e., through which the straight line passes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>dis</code></td>
<td>
<p>Distance from point <code>p</code> to the line
passing through <code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>cl2p</code></td>
<td>
<p>The closest point on the line
passing through <code>a</code> and <code>b</code> to the point <code>p</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.point2plane">dist.point2plane</a></code>, <code><a href="#topic+dist.point2set">dist.point2set</a></code>,
and <code><a href="#topic+Dist">Dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,2); B&lt;-c(2,3); P&lt;-c(3,1.5)

dpl&lt;-dist.point2line(P,A,B);
dpl
C&lt;-dpl$cl2p
pts&lt;-rbind(A,B,C,P)

xr&lt;-range(pts[,1])
xf&lt;-(xr[2]-xr[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100
lnAB&lt;-Line(A,B,x)
y&lt;-lnAB$y
int&lt;-lnAB$intercept #intercept
sl&lt;-lnAB$slope #slope

xsq&lt;-seq(min(A[1],B[1],P[1])-xf,max(A[1],B[1],P[1])+xf,l=5)
#try also l=10, 20, or 100
pline&lt;-(-1/sl)*(xsq-P[1])+P[2]
#line passing thru P and perpendicular to AB

Xlim&lt;-range(pts[,1],x)
Ylim&lt;-range(pts[,2],y)
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(rbind(P),asp=1,pch=1,xlab="x",ylab="y",
main="Illustration of the distance from P \n to the Line Crossing Points A and B",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(rbind(A,B),pch=1)
lines(x,y,lty=1,xlim=Xlim,ylim=Ylim)
int&lt;-round(int,2); sl&lt;-round(sl,2)
text(rbind((A+B)/2+xd*c(-.01,-.01)),ifelse(sl==0,paste("y=",int),
ifelse(sl==1,paste("y=x+",int),
ifelse(int==0,paste("y=",sl,"x"),paste("y=",sl,"x+",int)))))
text(rbind(A+xd*c(0,-.01),B+xd*c(.0,-.01),P+xd*c(.01,-.01)),c("A","B","P"))
lines(xsq,pline,lty=2)
segments(P[1],P[2], C[1], C[2], lty=1,col=2,lwd=2)
text(rbind(C+xd*c(-.01,-.01)),"C")
text(rbind((P+C)/2),col=2,paste("d=",round(dpl$dis,2)))


</code></pre>

<hr>
<h2 id='dist.point2plane'>The distance from a point to a plane spanned
by three 3D points</h2><span id='topic+dist.point2plane'></span>

<h3>Description</h3>

<p>Returns the distance from a point <code>p</code> to the plane
passing through points <code>a</code>, <code>b</code>, and <code>c</code> in 3D space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.point2plane(p, a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.point2plane_+3A_p">p</code></td>
<td>
<p>A 3D point, distance from <code>p</code> to the plane
passing through points <code>a</code>, <code>b</code>,
and <code>c</code> are to be computed.</p>
</td></tr>
<tr><td><code id="dist.point2plane_+3A_a">a</code>, <code id="dist.point2plane_+3A_b">b</code>, <code id="dist.point2plane_+3A_c">c</code></td>
<td>
<p>3D points that determine the plane
(i.e., through which the plane is passing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>dis</code></td>
<td>
<p>Distance from point <code>p</code> to the plane
spanned by 3D points <code>a</code>, <code>b</code>, and <code>c</code></p>
</td></tr>
<tr><td><code>cl2pl</code></td>
<td>
<p>The closest point on the plane
spanned by 3D points <code>a</code>, <code>b</code>,
and <code>c</code> to the point <code>p</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.point2line">dist.point2line</a></code>, <code><a href="#topic+dist.point2set">dist.point2set</a></code>,
and <code><a href="#topic+Dist">Dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(5,2,40)
P1&lt;-c(1,2,3); P2&lt;-c(3,9,12); P3&lt;-c(1,1,3);

dis&lt;-dist.point2plane(P,P1,P2,P3);
dis
Pr&lt;-dis$prj #projection on the plane

xseq&lt;-seq(0,10,l=5)  #try also l=10, 20, or 100
yseq&lt;-seq(0,10,l=5)  #try also l=10, 20, or 100

pl.grid&lt;-Plane(P1,P2,P3,xseq,yseq)$z

plot3D::persp3D(z = pl.grid, x = xseq, y = yseq, theta =225, phi = 30,
ticktype = "detailed",
expand = 0.7, facets = FALSE, scale = TRUE,
main="Point P and its Orthogonal Projection \n on the Plane Defined by P1, P2, P3")
#plane spanned by points P1, P2, P3
#add the vertices of the tetrahedron
plot3D::points3D(P[1],P[2],P[3], add=TRUE)
plot3D::points3D(Pr[1],Pr[2],Pr[3], add=TRUE)
plot3D::segments3D(P[1], P[2], P[3], Pr[1], Pr[2],Pr[3], add=TRUE,lwd=2)

plot3D::text3D(P[1]-.5,P[2],P[3]+1, c("P"),add=TRUE)
plot3D::text3D(Pr[1]-.5,Pr[2],Pr[3]+2, c("Pr"),add=TRUE)

persp(xseq,yseq,pl.grid, xlab="x",ylab="y",zlab="z",theta = -30,
phi = 30, expand = 0.5, col = "lightblue",
      ltheta = 120, shade = 0.05, ticktype = "detailed")



</code></pre>

<hr>
<h2 id='dist.point2set'>Distance from a point to a set of finite cardinality</h2><span id='topic+dist.point2set'></span>

<h3>Description</h3>

<p>Returns the Euclidean distance between a point <code>p</code>
and set of points <code>Yp</code> and the
closest point in set <code>Yp</code> to <code>p</code>.
Distance between a point and a set is by definition the distance
from the point to the closest point in the set.
<code>p</code> should be of finite dimension and <code>Yp</code> should
be of finite cardinality and <code>p</code>
and elements of <code>Yp</code> must have the same dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.point2set(p, Yp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.point2set_+3A_p">p</code></td>
<td>
<p>A <code>vector</code> (i.e., a point in <code class="reqn">R^d</code>).</p>
</td></tr>
<tr><td><code id="dist.point2set_+3A_yp">Yp</code></td>
<td>
<p>A set of <code class="reqn">d</code>-dimensional points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>Distance from point <code>p</code> to set <code>Yp</code></p>
</td></tr>
<tr><td><code>ind.cl.point</code></td>
<td>
<p>Index of the closest point in set <code>Yp</code>
to the point <code>p</code></p>
</td></tr>
<tr><td><code>closest.point</code></td>
<td>
<p>The closest point
in set <code>Yp</code> to the point <code>p</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.point2line">dist.point2line</a></code> and <code><a href="#topic+dist.point2plane">dist.point2plane</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
dist.point2set(c(1,2),Te)

X2&lt;-cbind(runif(10),runif(10))
dist.point2set(c(1,2),X2)

x&lt;-runif(1)
y&lt;-as.matrix(runif(10))
dist.point2set(x,y)
#this works, because x is a 1D point, and y is treated as a set of 10 1D points
#but will give an error message if y&lt;-runif(10) is used above


</code></pre>

<hr>
<h2 id='dom.num.exact'>Exact domination number (i.e., domination number
by the exact algorithm)</h2><span id='topic+dom.num.exact'></span>

<h3>Description</h3>

<p>Returns the (exact) domination number
based on the incidence matrix <code>Inc.Mat</code> of a graph
or a digraph
and the indices (i.e., row numbers of <code>Inc.Mat</code>)
for the corresponding (exact) minimum dominating set.
Here the row number in the incidence matrix corresponds
to the index of the vertex (i.e., index of the data
point). The function works whether loops are allowed
or not (i.e., whether the first diagonal is all 1 or
all 0). It takes a rather long time for large number of vertices
(i.e., large number of row numbers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dom.num.exact(Inc.Mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dom.num.exact_+3A_inc.mat">Inc.Mat</code></td>
<td>
<p>A square matrix consisting of 0's and 1's
which represents the incidence matrix of
a graph or digraph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>dom.num</code></td>
<td>
<p>The cardinality of the (exact) minimum dominating set,
i.e., (exact) domination number of the
graph or digraph whose incidence matrix <code>Inc.Mat</code> is given as input.</p>
</td></tr>
<tr><td><code>ind.mds</code></td>
<td>
<p>The vector of indices of the rows
in the incidence matrix <code>Inc.Mat</code> for the (exact) minimum dominating set.
The row numbers in the incidence matrix
correspond to the indices of the vertices
(i.e., indices of the data points).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dom.num.greedy">dom.num.greedy</a></code>, <code><a href="#topic+PEdom.num1D">PEdom.num1D</a></code>,
<code><a href="#topic+PEdom.num.tri">PEdom.num.tri</a></code>, <code><a href="#topic+PEdom.num.nondeg">PEdom.num.nondeg</a></code>,
and <code><a href="#topic+Idom.numCSup.bnd.tri">Idom.numCSup.bnd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10
M&lt;-matrix(sample(c(0,1),n^2,replace=TRUE),nrow=n)
diag(M)&lt;-1

dom.num.greedy(M)
Idom.num.up.bnd(M,2)
dom.num.exact(M)


</code></pre>

<hr>
<h2 id='dom.num.greedy'>Approximate domination number and approximate dominating set
by the greedy algorithm</h2><span id='topic+dom.num.greedy'></span>

<h3>Description</h3>

<p>Returns the (approximate) domination number
and the indices (i.e., row numbers) for the corresponding
(approximate) minimum dominating set
based on the incidence matrix <code>Inc.Mat</code> of a graph or a digraph
by using the greedy algorithm (Chvatal (1979)).
Here the row number in the incidence matrix corresponds
to the index of the vertex (i.e., index of the
data point). The function works
whether loops are allowed or not (i.e., whether the first diagonal
is all 1 or all 0).
This function may yield the actual domination number
or overestimates it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dom.num.greedy(Inc.Mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dom.num.greedy_+3A_inc.mat">Inc.Mat</code></td>
<td>
<p>A square matrix consisting of 0's and 1's
which represents the incidence matrix of
a graph or digraph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>dom.num</code></td>
<td>
<p>The cardinality of the (approximate) minimum dominating set
found by the greedy algorithm.
i.e., (approximate) domination number of the graph or digraph
whose incidence matrix <code>Inc.Mat</code> is given
as input.</p>
</td></tr>
<tr><td><code>ind.dom.set</code></td>
<td>
<p>Indices of the rows
in the incidence matrix <code>Inc.Mat</code> for the
((approximate) minimum dominating set).
The row numbers in the incidence matrix
correspond to the indices of the vertices
(i.e., indices of the data points).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Chvatal V (1979).
&ldquo;A greedy heuristic for the set-covering problem.&rdquo;
<em>Mathematics of Operations Research</em>, <b>4</b>(3), 233 &mdash; 235.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-5
M&lt;-matrix(sample(c(0,1),n^2,replace=TRUE),nrow=n)
diag(M)&lt;-1

dom.num.greedy(M)

</code></pre>

<hr>
<h2 id='edge.reg.triCM'>The vertices of the <code class="reqn">CM</code>-edge region in a triangle
that contains the point</h2><span id='topic+edge.reg.triCM'></span>

<h3>Description</h3>

<p>Returns the edge whose region contains point, <code>p</code>, in
the triangle <code>tri</code><code class="reqn">=T(A,B,C)</code>
with edge regions based on center of mass <code class="reqn">CM=(A+B+C)/3</code>.
</p>
<p>This function is related to <code><a href="#topic+rel.edge.triCM">rel.edge.triCM</a></code>,
but unlike <code><a href="#topic+rel.edge.triCM">rel.edge.triCM</a></code>
the related edges are given as vertices <code>ABC</code>
for <code class="reqn">re=3</code>, as <code>BCA</code> for <code class="reqn">re=1</code>
and as <code>CAB</code> for <code class="reqn">re=2</code>
where edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>,
and 2 for edge <code class="reqn">AC</code>.
The vertices are given one vertex in each row in the output,
e.g., <code class="reqn">ABC</code> is printed as <code>rbind(A,B,C)</code>,
where row 1 has the entries of vertex A,
row 2 has the entries of vertex B,
and row 3 has the entries of vertex C.
</p>
<p>If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
</p>
<p>Edge region for BCA is the triangle <code class="reqn">T(B,C,CM)</code>,
edge region CAB is <code class="reqn">T(A,C,CM)</code>, and edge region ABC is <code class="reqn">T(A,B,CM)</code>.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.reg.triCM(p, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.reg.triCM_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CM</code>-edge region it resides in is
to be determined in the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code id="edge.reg.triCM_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">CM</code>-edge region that contains point,
<code>p</code> in the triangle <code>tri</code>.
The related edges are given as
vertices <code>ABC</code> for <code class="reqn">re=3</code>,
as <code>BCA</code> for <code class="reqn">re=1</code> and as <code>CAB</code> for <code class="reqn">re=2</code>
where edges are labeled as 3
for edge <code class="reqn">AB</code>, 1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.edge.tri">rel.edge.tri</a></code>, <code><a href="#topic+rel.edge.triCM">rel.edge.triCM</a></code>,
<code><a href="#topic+rel.edge.basic.triCM">rel.edge.basic.triCM</a></code>, <code><a href="#topic+rel.edge.basic.tri">rel.edge.basic.tri</a></code>,
<code><a href="#topic+rel.edge.std.triCM">rel.edge.std.triCM</a></code>, and <code><a href="#topic+edge.reg.triCM">edge.reg.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

P&lt;-c(.4,.2)  #try also P&lt;-as.numeric(runif.tri(1,Tr)$g)
edge.reg.triCM(P,Tr)

P&lt;-c(1.8,.5)
edge.reg.triCM(P,Tr)

CM&lt;-(A+B+C)/3
p1&lt;-(A+B+CM)/3
p2&lt;-(B+C+CM)/3
p3&lt;-(A+C+CM)/3

Xlim&lt;-range(Tr[,1])
Ylim&lt;-range(Tr[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
L&lt;-Tr; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Tr,CM,p1,p2,p3)
xc&lt;-txt[,1]+c(-.02,.02,.02,-.05,0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.02,.02,0,0,0)
txt.str&lt;-c("A","B","C","CM","re=T(A,B,CM)","re=T(B,C,CM)","re=T(A,C,CM)")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='fr2edgesCMedge.reg.std.tri'>The furthest points in a data set from edges
in each <code class="reqn">CM</code>-edge region in the standard equilateral triangle</h2><span id='topic+fr2edgesCMedge.reg.std.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the furthest data points among the data set, <code>Xp</code>,
in each <code class="reqn">CM</code>-edge region from the edge in the
standard equilateral triangle
<code class="reqn">T_e=T(A=(0,0),B=(1,0),C=(1/2,\sqrt{3}/2))</code>.
</p>
<p><code>ch.all.intri</code> is for checking
whether all data points are inside <code class="reqn">T_e</code> (default is <code>FALSE</code>).
</p>
<p>See also (Ceyhan (2005)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fr2edgesCMedge.reg.std.tri(Xp, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr2edgesCMedge.reg.std.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points,
some could be inside and some could be outside standard equilateral triangle
<code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code id="fr2edgesCMedge.reg.std.tri_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument used
for checking whether all data points are inside <code class="reqn">T_e</code>
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Edge labels as <code class="reqn">AB=3</code>, <code class="reqn">BC=1</code>, and <code class="reqn">AC=2</code>
for <code class="reqn">T_e</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances to Edges"</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here, furthest points
from edges in each edge region.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, here, it is <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of edge regions.</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is center of mass <code>"CM"</code> for this function.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Edge regions inside the triangle, <code class="reqn">T_e</code>,
provided as a list.</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the edge regions
as <code>"er=1"</code>, <code>"er=2"</code>, and <code>"er=3"</code>.</p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the edge regions
inside <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from furthest points
in each edge region to the corresponding edge.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fr2vertsCCvert.reg.basic.tri">fr2vertsCCvert.reg.basic.tri</a></code>, <code><a href="#topic+fr2vertsCCvert.reg">fr2vertsCCvert.reg</a></code>,
<code><a href="#topic+fr2vertsCCvert.reg.basic.tri">fr2vertsCCvert.reg.basic.tri</a></code>, <code><a href="#topic+kfr2vertsCCvert.reg">kfr2vertsCCvert.reg</a></code>,
and <code><a href="#topic+cl2edges.std.tri">cl2edges.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-20
Xp&lt;-runif.std.tri(n)$gen.points

Ext&lt;-fr2edgesCMedge.reg.std.tri(Xp)
Ext
summary(Ext)
plot(Ext,asp=1)

ed.far&lt;-Ext

Xp2&lt;-rbind(Xp,c(.8,.8))
fr2edgesCMedge.reg.std.tri(Xp2)
fr2edgesCMedge.reg.std.tri(Xp2,ch.all.intri = FALSE)
#gives error if ch.all.intri = TRUE

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(0.5,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
CM&lt;-(A+B+C)/3
p1&lt;-(A+B)/2
p2&lt;-(B+C)/2
p3&lt;-(A+C)/2

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",
main="Furthest Points in CM-Edge Regions \n of Std Equilateral Triangle from its Edges",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
L&lt;-Te; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(Xp,xlab="",ylab="")
points(ed.far$ext,pty=2,pch=4,col="red")

txt&lt;-rbind(Te,CM,p1,p2,p3)
xc&lt;-txt[,1]+c(-.03,.03,.03,-.06,0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.02,.02,0,0,0)
txt.str&lt;-c("A","B","C","CM","re=2","re=3","re=1")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='fr2vertsCCvert.reg'>The furthest points in a data set from vertices
in each <code class="reqn">CC</code>-vertex region in a triangle</h2><span id='topic+fr2vertsCCvert.reg'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the furthest data points among the data set, <code>Xp</code>,
in each <code class="reqn">CC</code>-vertex region from the vertex in the
triangle, <code>tri</code><code class="reqn">=T(A,B,C)</code>.
Vertex region labels/numbers correspond
to the row number of the vertex in <code>tri</code>.
<code>ch.all.intri</code> is for checking
whether all data points are inside <code>tri</code> (default is <code>FALSE</code>).
</p>
<p>If some of the data points are not
inside <code>tri</code> and <code>ch.all.intri=TRUE</code>,
then the function yields
an error message.
If some of the data points are not inside <code>tri</code>
and <code>ch.all.intri=FALSE</code>, then the function yields
the closest points to edges among the data points
inside <code>tri</code> (yields <code>NA</code> if there are no data points
inside <code>tri</code>).
</p>
<p>See also (Ceyhan (2005, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fr2vertsCCvert.reg(Xp, tri, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr2vertsCCvert.reg_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="fr2vertsCCvert.reg_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="fr2vertsCCvert.reg_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>)
to check whether all data points are inside
the triangle <code>tri</code>. So, if it is <code>TRUE</code>,
the function checks if all data points are
inside the closure of the triangle (i.e., interior and boundary
combined) else it does not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>,
and <code class="reqn">C=3</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances from furthest points to ..."</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
furthest points from vertices in each <code class="reqn">CC</code>-vertex region in the
triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>, can be a <code>matrix</code>
or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, here,
it is the triangle <code>tri</code> for this function.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of edge regions.</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is circumcenter <code>"CC"</code> for this function</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>CC-Vertex regions inside the triangle, <code>tri</code>,
provided as a <code>list</code></p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code>tri</code></p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from furthest points
in each vertex region to the corresponding vertex</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fr2vertsCCvert.reg.basic.tri">fr2vertsCCvert.reg.basic.tri</a></code>, <code><a href="#topic+fr2edgesCMedge.reg.std.tri">fr2edgesCMedge.reg.std.tri</a></code>,
<code><a href="#topic+kfr2vertsCCvert.reg.basic.tri">kfr2vertsCCvert.reg.basic.tri</a></code> and <code><a href="#topic+kfr2vertsCCvert.reg">kfr2vertsCCvert.reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

Ext&lt;-fr2vertsCCvert.reg(Xp,Tr)
Ext
summary(Ext)
plot(Ext)

f2v&lt;-Ext

CC&lt;-circumcenter.tri(Tr)  #the circumcenter
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,xlab="",asp=1,ylab="",pch=".",
main="Furthest Points in CC-Vertex Regions \n from the Vertices",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(Xp)
points(rbind(f2v$ext),pch=4,col=2)

txt&lt;-rbind(Tr,CC,Ds)
xc&lt;-txt[,1]+c(-.06,.08,.05,.12,-.1,-.1,-.09)
yc&lt;-txt[,2]+c(.02,-.02,.05,.0,.02,.06,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

Xp2&lt;-rbind(Xp,c(.2,.4))
fr2vertsCCvert.reg(Xp2,Tr,ch.all.intri = FALSE)
#gives an error message if ch.all.intri = TRUE
#since not all points in the data set are in the triangle


</code></pre>

<hr>
<h2 id='fr2vertsCCvert.reg.basic.tri'>The furthest points from vertices in each <code class="reqn">CC</code>-vertex region
in a standard basic triangle</h2><span id='topic+fr2vertsCCvert.reg.basic.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the furthest data points among the data set, <code>Xp</code>,
in each <code class="reqn">CC</code>-vertex region from the
corresponding vertex in the standard basic triangle
<code class="reqn">T_b=T(A=(0,0),B=(1,0),C=(c_1,c_2))</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle. Hence, standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p><code>ch.all.intri</code> is for checking whether all data points are
inside <code class="reqn">T_b</code> (default is <code>FALSE</code>).
</p>
<p>See also (Ceyhan (2005, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fr2vertsCCvert.reg.basic.tri(Xp, c1, c2, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fr2vertsCCvert.reg.basic.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points.</p>
</td></tr>
<tr><td><code id="fr2vertsCCvert.reg.basic.tri_+3A_c1">c1</code>, <code id="fr2vertsCCvert.reg.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle.
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code></p>
</td></tr>
<tr><td><code id="fr2vertsCCvert.reg.basic.tri_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument for checking
whether all data points are inside <code class="reqn">T_b</code>
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>,
and <code class="reqn">C=3</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances from furthest points to ..."</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
furthest points from vertices in each vertex region.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, here, it is <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of edge regions.</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is circumcenter <code>"CC"</code> for this function.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the triangle, <code class="reqn">T_b</code>,
provided as a <code>list</code>.</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from furthest points
in each vertex region to the corresponding vertex.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fr2vertsCCvert.reg">fr2vertsCCvert.reg</a></code>, <code><a href="#topic+fr2edgesCMedge.reg.std.tri">fr2edgesCMedge.reg.std.tri</a></code>,
and <code><a href="#topic+kfr2vertsCCvert.reg">kfr2vertsCCvert.reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
n&lt;-20

set.seed(1)
Xp&lt;-runif.basic.tri(n,c1,c2)$g

Ext&lt;-fr2vertsCCvert.reg.basic.tri(Xp,c1,c2)
Ext
summary(Ext)
plot(Ext)

f2v&lt;-Ext

CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",
main="Furthest Points in CC-Vertex Regions \n from the Vertices",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(Xp)
points(rbind(f2v$ext),pch=4,col=2)

txt&lt;-rbind(Tb,CC,D1,D2,D3)
xc&lt;-txt[,1]+c(-.03,.03,0.02,.07,.06,-.05,.01)
yc&lt;-txt[,2]+c(.02,.02,.03,.01,.02,.02,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='funsAB2CMTe'>The lines joining two vertices to the center of mass
in standard equilateral triangle</h2><span id='topic+funsAB2CMTe'></span><span id='topic+lineA2CMinTe'></span><span id='topic+lineB2CMinTe'></span>

<h3>Description</h3>

<p>Two functions, <code>lineA2CMinTe</code> and <code>lineB2CMinTe</code>
of class <code>"TriLines"</code>.
Returns the <code>equation, slope, intercept</code>,
and <code class="reqn">y</code>-coordinates of the lines joining <code class="reqn">A</code> and <code class="reqn">CM</code> and
also <code class="reqn">B</code> and <code class="reqn">CM</code>.
</p>
<p><code>lineA2CMinTe</code> is the line joining <code class="reqn">A</code> to the center of mass, <code class="reqn">CM</code>,
and
<code>lineB2CMinTe</code> is the line joining <code class="reqn">B</code> to the center of mass, <code class="reqn">CM</code>,
in the standard equilateral triangle <code class="reqn">T_e=(A,B,C)</code>
with <code class="reqn">A=(0,0)</code>, <code class="reqn">B=(1,0)</code>, <code class="reqn">C=(1/2,\sqrt{3}/2)</code>;
<code class="reqn">x</code>-coordinates are provided in <code>vector</code> <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineA2CMinTe(x)

lineB2CMinTe(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsAB2CMTe_+3A_x">x</code></td>
<td>
<p>A single scalar or a <code>vector</code> of scalars
which is the argument of the functions
<code>lineA2CMinTe</code> and <code>lineB2CMinTe</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Longer description of the line.</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>Shorter description of the line
(to be inserted over the line in the plot).</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center chosen inside the standard equilateral triangle.</p>
</td></tr>
<tr><td><code>cent.name</code></td>
<td>
<p>The name of the center
inside the standard equilateral triangle.
It is <code>"CM"</code> for these two functions.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The triangle (it is the standard equilateral triangle
for this function).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The input vector, can be a scalar or a <code>vector</code> of scalars,
which constitute the <code class="reqn">x</code>-coordinates of the point(s) of interest
on the line.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The output vector,
will be a scalar if <code>x</code> is a scalar or a <code>vector</code> of scalars
if <code>x</code> is a <code>vector</code> of scalar,
constitutes the <code class="reqn">y</code>-coordinates of the point(s) of interest on the line.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>Slope of the line.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>Intercept of the line.</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lineA2MinTe">lineA2MinTe</a></code>, <code><a href="#topic+lineB2MinTe">lineB2MinTe</a></code>,
and <code><a href="#topic+lineC2MinTe">lineC2MinTe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for lineA2CMinTe
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
xfence&lt;-abs(A[1]-B[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,by = .1)  #try also by = .01

lnACM&lt;-lineA2CMinTe(x)
lnACM
summary(lnACM)
plot(lnACM)

CM&lt;-(A+B+C)/3;
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Te,pch=".",xlab="",ylab="",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
L&lt;-Te; R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Te,CM,D1,D2,D3,c(.25,lineA2CMinTe(.25)$y),c(.75,lineB2CMinTe(.75)$y))
xc&lt;-txt[,1]+c(-.02,.02,.02,.05,.05,-.03,.0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.02,.02,0,.02,-.04,0,0)
txt.str&lt;-c("A","B","C","CM","D1","D2","D3","lineA2CMinTe(x)","lineB2CMinTe(x)")
text(xc,yc,txt.str)

lineA2CMinTe(.25)$y



#Examples for lineB2CMinTe
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
xfence&lt;-abs(A[1]-B[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,by = .1)  #try also by = .01

lnBCM&lt;-lineB2CMinTe(x)
lnBCM
summary(lnBCM)
plot(lnBCM,xlab=" x",ylab="y")

lineB2CMinTe(.25)$y


</code></pre>

<hr>
<h2 id='funsAB2MTe'>The lines joining the three vertices of
the standard equilateral triangle to a center, <code>M</code>, of it</h2><span id='topic+funsAB2MTe'></span><span id='topic+lineA2MinTe'></span><span id='topic+lineB2MinTe'></span><span id='topic+lineC2MinTe'></span>

<h3>Description</h3>

<p>Three functions, <code>lineA2MinTe</code>, <code>lineB2MinTe</code> and <code>lineC2MinTe</code>
of class <code>"TriLines"</code>.
Returns the <code>equation, slope, intercept</code>,
and <code class="reqn">y</code>-coordinates of the lines joining <code class="reqn">A</code> and <code>M</code>,
<code class="reqn">B</code> and <code>M</code>, and also <code class="reqn">C</code> and <code>M</code>.
</p>
<p><code>lineA2MinTe</code> is the line joining <code class="reqn">A</code> to the center, <code>M</code>,
<code>lineB2MinTe</code> is the line joining <code class="reqn">B</code> to <code>M</code>,
and <code>lineC2MinTe</code> is the line joining C to <code>M</code>,
in the standard equilateral triangle <code class="reqn">T_e=(A,B,C)</code>
with <code class="reqn">A=(0,0)</code>, <code class="reqn">B=(1,0)</code>, <code class="reqn">C=(1/2,\sqrt{3}/2)</code>;
<code class="reqn">x</code>-coordinates are provided in <code>vector</code> <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineA2MinTe(x, M)

lineB2MinTe(x, M)

lineC2MinTe(x, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsAB2MTe_+3A_x">x</code></td>
<td>
<p>A single scalar or a <code>vector</code> of scalars.</p>
</td></tr>
<tr><td><code id="funsAB2MTe_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard equilateral triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Longer description of the line.</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>Shorter description of the line
(to be inserted over the line in the plot).</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center chosen inside the standard equilateral triangle.</p>
</td></tr>
<tr><td><code>cent.name</code></td>
<td>
<p>The name of the center
inside the standard equilateral triangle.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The triangle
(it is the standard equilateral triangle for this function).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The input vector, can be a scalar
or a <code>vector</code> of scalars,
which constitute the <code class="reqn">x</code>-coordinates of the point(s) of interest
on the line.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The output vector,
will be a scalar if <code>x</code> is a scalar
or a <code>vector</code> of scalars if <code>x</code> is
a <code>vector</code> of scalar,
constitutes the <code class="reqn">y</code>-coordinates of the point(s) of interest on the line.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>Slope of the line.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>Intercept of the line.</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lineA2CMinTe">lineA2CMinTe</a></code> and <code><a href="#topic+lineB2CMinTe">lineB2CMinTe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for lineA2MinTe
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)

M&lt;-c(.65,.2)  #try also M&lt;-c(1,1,1)

xfence&lt;-abs(A[1]-B[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,by = .1)  #try also by = .01

lnAM&lt;-lineA2MinTe(x,M)
lnAM
summary(lnAM)
plot(lnAM)

Ds&lt;-prj.cent2edges(Te,M)
#finds the projections from a point M=(m1,m2) to the edges on the
#extension of the lines joining M to the vertices in the triangle Te

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Te,pch=".",xlab="",ylab="",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
L&lt;-Te; R&lt;-rbind(M,M,M)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
L&lt;-Ds; R&lt;-rbind(M,M,M)
segments(L[,1], L[,2], R[,1], R[,2], lty = 3,col=2)

txt&lt;-rbind(Te,M,Ds,c(.25,lineA2MinTe(.25,M)$y),c(.4,lineB2MinTe(.4,M)$y),
c(.60,lineC2MinTe(.60,M)$y))
xc&lt;-txt[,1]+c(-.02,.02,.02,.02,.04,-.03,.0,0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.02,.05,.02,.03,-.03,0,0,0)
txt.str&lt;-c("A","B","C","M","D1","D2","D3","lineA2MinTe(x)","lineB2MinTe(x)","lineC2MinTe(x)")
text(xc,yc,txt.str)

lineA2MinTe(.25,M)



#Examples for lineB2MinTe
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)

M&lt;-c(.65,.2)  #try also M&lt;-c(1,1,1)

xfence&lt;-abs(A[1]-B[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,by = .5)  #try also by = .1

lnBM&lt;-lineB2MinTe(x,M)
lnBM
summary(lnBM)
plot(lnBM)



#Examples for lineC2MinTe
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)

M&lt;-c(.65,.2)  #try also M&lt;-c(1,1,1)

xfence&lt;-abs(A[1]-B[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,by = .5)
#try also by = .1

lnCM&lt;-lineC2MinTe(x,M)
lnCM
summary(lnCM)
plot(lnCM)


</code></pre>

<hr>
<h2 id='funsCartBary'>Converts of a point in Cartesian coordinates to Barycentric coordinates
and vice versa</h2><span id='topic+funsCartBary'></span><span id='topic+cart2bary'></span><span id='topic+bary2cart'></span>

<h3>Description</h3>

<p>Two functions: <code>cart2bary</code> and <code>bary2cart</code>.
</p>
<p><code>cart2bary</code> converts Cartesian coordinates of
a given point <code>P</code><code class="reqn">=(x,y)</code> to barycentric coordinates
(in the normalized form)
with respect to the triangle <code>tri</code><code class="reqn">=(v_1,v_2,v_3)</code>
with vertex labeling done row-wise in <code>tri</code>
(i.e., row <code class="reqn">i</code> corresponds to vertex <code class="reqn">v_i</code> for <code class="reqn">i=1,2,3</code>).
</p>
<p><code>bary2cart</code> converts barycentric coordinates of
the point <code>P</code><code class="reqn">=(t_1,t_2,t_3)</code>
(not necessarily normalized) to
Cartesian coordinates according to the coordinates of the triangle, <code>tri</code>.
For information on barycentric coordinates,
see (Weisstein (2019)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cart2bary(P, tri)

bary2cart(P, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsCartBary_+3A_p">P</code></td>
<td>
<p>A 2D point for <code>cart2bary</code>,
and a <code>vector</code> of three <code>numeric</code> entries for <code>bary2cart</code>.</p>
</td></tr>
<tr><td><code id="funsCartBary_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cart2bary</code> returns the barycentric coordinates
of a given point <code>P</code><code class="reqn">=(x,y)</code> and
<code>bary2cart</code> returns the Cartesian coordinates
of the point <code>P</code><code class="reqn">=(t_1,t_2,t_3)</code>
(not necessarily normalized).
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Weisstein EW (2019).
&ldquo;Barycentric Coordinates.&rdquo;
From MathWorld &mdash; A Wolfram Web Resource, <a href="http://mathworld.wolfram.com/BarycentricCoordinates.html">http://mathworld.wolfram.com/BarycentricCoordinates.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for cart2bary
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tr&lt;-rbind(A,B,C)

cart2bary(A,Tr)
cart2bary(c(.3,.2),Tr)



#Examples for bary2cart
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tr&lt;-rbind(A,B,C)

bary2cart(c(.3,.2,.5),Tr)
bary2cart(c(6,2,4),Tr)


</code></pre>

<hr>
<h2 id='funsCSEdgeRegs'>Each function is for the presence of an arc from a point in one of the edge regions
to another for Central Similarity Proximity Catch Digraphs (CS-PCDs) - standard equilateral triangle case</h2><span id='topic+funsCSEdgeRegs'></span><span id='topic+IarcCSstd.triRAB'></span><span id='topic+IarcCSstd.triRBC'></span><span id='topic+IarcCSstd.triRAC'></span>

<h3>Description</h3>

<p>Three indicator functions: <code>IarcCSstd.triRAB</code>, <code>IarcCSstd.triRBC</code> and <code>IarcCSstd.triRAC</code>.
</p>
<p>The function <code>IarcCSstd.triRAB</code> returns I(<code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code> for <code>p1</code> in <code class="reqn">RAB</code> (edge region for edge <code class="reqn">AB</code>,
i.e., edge 3) in the standard equilateral triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>;
</p>
<p><code>IarcCSstd.triRBC</code> returns I(<code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code> for <code>p1</code> in <code class="reqn">RBC</code> (edge region for edge <code class="reqn">BC</code>, i.e., edge 1) in <code class="reqn">T_e</code>;
and
</p>
<p><code>IarcCSstd.triRAC</code> returns I(<code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code> for <code>p1</code> in <code class="reqn">RAC</code> (edge region for edge <code class="reqn">AC</code>, i.e., edge 2) in <code class="reqn">T_e</code>.
That is, each function returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>, returns 0 otherwise.
</p>
<p>CS proximity region is defined with respect to <code class="reqn">T_e</code> whose vertices are also labeled as <code class="reqn">T_e=T(v=1,v=2,v=3)</code>
with expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code class="reqn">T_e</code>
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and <code>p1</code> is outside the corresponding edge region and <code>p2</code> is outside <code class="reqn">T_e</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their location (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSstd.triRAB(p1, p2, t, M)

IarcCSstd.triRBC(p1, p2, t, M)

IarcCSstd.triRAC(p1, p2, t, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsCSEdgeRegs_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="funsCSEdgeRegs_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="funsCSEdgeRegs_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="funsCSEdgeRegs_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the standard equilateral triangle <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each function returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for <code>p1</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>,
returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSt1.std.triRAB">IarcCSt1.std.triRAB</a></code>, <code><a href="#topic+IarcCSt1.std.triRBC">IarcCSt1.std.triRBC</a></code> and <code><a href="#topic+IarcCSt1.std.triRAC">IarcCSt1.std.triRAC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for IarcCSstd.triRAB
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
CM&lt;-(A+B+C)/3
T3&lt;-rbind(A,B,CM);

set.seed(1)
Xp&lt;-runif.std.tri(3)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

t&lt;-1

IarcCSstd.triRAB(Xp[1,],Xp[2,],t,M)
IarcCSstd.triRAB(c(.2,.5),Xp[2,],t,M)



#Examples for IarcCSstd.triRBC
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
CM&lt;-(A+B+C)/3
T1&lt;-rbind(B,C,CM);

set.seed(1)
Xp&lt;-runif.std.tri(3)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

t&lt;-1

IarcCSstd.triRBC(Xp[1,],Xp[2,],t,M)
IarcCSstd.triRBC(c(.2,.5),Xp[2,],t,M)



#Examples for IarcCSstd.triRAC
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
CM&lt;-(A+B+C)/3
T2&lt;-rbind(A,C,CM);

set.seed(1)
Xp&lt;-runif.std.tri(3)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

t&lt;-1

IarcCSstd.triRAC(Xp[1,],Xp[2,],t,M)
IarcCSstd.triRAC(c(.2,.5),Xp[2,],t,M)


</code></pre>

<hr>
<h2 id='funsCSGamTe'>The function <code>gammakCSstd.tri</code> is for <code class="reqn">k</code> (<code class="reqn">k=2,3,4,5</code>) points constituting a dominating set for Central Similarity
Proximity Catch Digraphs (CS-PCDs) - standard equilateral triangle case</h2><span id='topic+funsCSGamTe'></span><span id='topic+Idom.num2CSstd.tri'></span><span id='topic+Idom.num3CSstd.tri'></span><span id='topic+Idom.num4CSstd.tri'></span><span id='topic+Idom.num5CSstd.tri'></span><span id='topic+Idom.num6CSstd.tri'></span>

<h3>Description</h3>

<p>Four indicator functions: <code>Idom.num2CSstd.tri</code>, <code>Idom.num3CSstd.tri</code>, <code>Idom.num4CSstd.tri</code>, <code>Idom.num5CSstd.tri</code> and <code>Idom.num6CSstd.tri</code>.
</p>
<p>The function <code>gammakCSstd.tri</code> returns I({<code>p1</code>,...,<code>pk</code>} is a dominating set of the CS-PCD)
where vertices of CS-PCD are the 2D data set <code>Xp</code>, that is, returns 1 if {<code>p1</code>,...,<code>pk</code>}
is a dominating set of CS-PCD, returns 0 otherwise for <code class="reqn">k=2,3,4,5,6</code>.
</p>
<p>CS proximity region is constructed with respect to <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
with expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based on center of mass <code class="reqn">CM=(1/2,\sqrt{3}/6)</code>.
</p>
<p><code>ch.data.pnts</code> is for checking whether points <code>p1</code>,...,<code>pk</code> are data points in <code>Xp</code> or not
(default is <code>FALSE</code>), so by default this function checks whether the points <code>p1</code>,...,<code>pk</code> would be a
dominating set if they actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num2CSstd.tri(p1, p2, Xp, t, ch.data.pnts = FALSE)

Idom.num3CSstd.tri(p1, p2, p3, Xp, t, ch.data.pnts = FALSE)

Idom.num4CSstd.tri(p1, p2, p3, p4, Xp, t, ch.data.pnts = FALSE)

Idom.num5CSstd.tri(p1, p2, p3, p4, p5, Xp, t, ch.data.pnts = FALSE)

Idom.num6CSstd.tri(p1, p2, p3, p4, p5, p6, Xp, t, ch.data.pnts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsCSGamTe_+3A_p1">p1</code>, <code id="funsCSGamTe_+3A_p2">p2</code>, <code id="funsCSGamTe_+3A_p3">p3</code>, <code id="funsCSGamTe_+3A_p4">p4</code>, <code id="funsCSGamTe_+3A_p5">p5</code>, <code id="funsCSGamTe_+3A_p6">p6</code></td>
<td>
<p>The points {<code class="reqn">p1,\ldots,pk</code>} are <code class="reqn">k</code> 2D points
(for <code class="reqn">k=2,3,4,5,6</code>) to be tested for constituting a dominating set of the CS-PCD.</p>
</td></tr>
<tr><td><code id="funsCSGamTe_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="funsCSGamTe_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="funsCSGamTe_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for checking whether points {<code class="reqn">p1,\ldots,pk</code>} are
data points in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>gammakCSstd.tri</code> returns {<code>p1</code>,...,<code>pk</code>} is a dominating set of the CS-PCD) where
vertices of the CS-PCD are the 2D data set <code>Xp</code>), that is, returns 1 if {<code>p1</code>,...,<code>pk</code>}
is a dominating set of CS-PCD, returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1CSstd.tri">Idom.num1CSstd.tri</a></code>, <code><a href="#topic+Idom.num2PEtri">Idom.num2PEtri</a></code> and <code><a href="#topic+Idom.num2PEtetra">Idom.num2PEtetra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
#Examples for Idom.num2CSstd.tri
t&lt;-1.5
n&lt;-10 #try also 10, 20 (it may take longer for larger n)

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

Idom.num2CSstd.tri(Xp[1,],Xp[2,],Xp,t)
Idom.num2CSstd.tri(c(.2,.2),Xp[2,],Xp,t)

ind.gam2&lt;-vector()
for (i in 1:(n-1))
 for (j in (i+1):n)
 {if (Idom.num2CSstd.tri(Xp[i,],Xp[j,],Xp,t)==1)
  ind.gam2&lt;-rbind(ind.gam2,c(i,j))}

ind.gam2



#Examples for Idom.num3CSstd.tri
t&lt;-1.5
n&lt;-10 #try also 10, 20 (it may take longer for larger n)

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

Idom.num3CSstd.tri(Xp[1,],Xp[2,],Xp[3,],Xp,t)

ind.gam3&lt;-vector()
for (i in 1:(n-2))
 for (j in (i+1):(n-1))
   for (k in (j+1):n)
   {if (Idom.num3CSstd.tri(Xp[i,],Xp[j,],Xp[k,],Xp,t)==1)
    ind.gam3&lt;-rbind(ind.gam3,c(i,j,k))}

ind.gam3



#Examples for Idom.num4CSstd.tri
t&lt;-1.5
n&lt;-10 #try also 10, 20 (it may take longer for larger n)

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

Idom.num4CSstd.tri(Xp[1,],Xp[2,],Xp[3,],Xp[4,],Xp,t)

ind.gam4&lt;-vector()
for (i in 1:(n-3))
 for (j in (i+1):(n-2))
   for (k in (j+1):(n-1))
     for (l in (k+1):n)
     {if (Idom.num4CSstd.tri(Xp[i,],Xp[j,],Xp[k,],Xp[l,],Xp,t)==1)
      ind.gam4&lt;-rbind(ind.gam4,c(i,j,k,l))}

ind.gam4

Idom.num4CSstd.tri(c(.2,.2),Xp[2,],Xp[3,],Xp[4,],Xp,t,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE since not all points are data points in Xp



#Examples for Idom.num5CSstd.tri
t&lt;-1.5
n&lt;-10 #try also 10, 20 (it may take longer for larger n)

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

Idom.num5CSstd.tri(Xp[1,],Xp[2,],Xp[3,],Xp[4,],Xp[5,],Xp,t)

ind.gam5&lt;-vector()
for (i1 in 1:(n-4))
 for (i2 in (i1+1):(n-3))
   for (i3 in (i2+1):(n-2))
     for (i4 in (i3+1):(n-1))
       for (i5 in (i4+1):n)
       {if (Idom.num5CSstd.tri(Xp[i1,],Xp[i2,],Xp[i3,],Xp[i4,],Xp[i5,],Xp,t)==1)
        ind.gam5&lt;-rbind(ind.gam5,c(i1,i2,i3,i4,i5))}

ind.gam5

Idom.num5CSstd.tri(c(.2,.2),Xp[2,],Xp[3,],Xp[4,],Xp[5,],Xp,t,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE since not all points are data points in Xp



#Examples for Idom.num6CSstd.tri
t&lt;-1.5
n&lt;-10 #try also 10, 20 (it may take longer for larger n)

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

Idom.num6CSstd.tri(Xp[1,],Xp[2,],Xp[3,],Xp[4,],Xp[5,],Xp[6,],Xp,t)

ind.gam6&lt;-vector()
for (i1 in 1:(n-5))
 for (i2 in (i1+1):(n-4))
   for (i3 in (i2+1):(n-3))
     for (i4 in (i3+1):(n-2))
       for (i5 in (i4+1):(n-1))
         for (i6 in (i5+1):n)
         {if (Idom.num6CSstd.tri(Xp[i1,],Xp[i2,],Xp[i3,],Xp[i4,],Xp[i5,],Xp[i6,],Xp,t)==1)
          ind.gam6&lt;-rbind(ind.gam6,c(i1,i2,i3,i4,i5,i6))}

ind.gam6

Idom.num6CSstd.tri(c(.2,.2),Xp[2,],Xp[3,],Xp[4,],Xp[5,],Xp[6,],Xp,t,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE since not all points are data points in Xp


</code></pre>

<hr>
<h2 id='funsCSt1EdgeRegs'>Each function is for the presence of an arc from a point in one of the edge regions
to another for Central Similarity Proximity Catch Digraphs (CS-PCDs) -
standard equilateral triangle case with <code class="reqn">t=1</code></h2><span id='topic+funsCSt1EdgeRegs'></span><span id='topic+IarcCSt1.std.triRAB'></span><span id='topic+IarcCSt1.std.triRBC'></span><span id='topic+IarcCSt1.std.triRAC'></span>

<h3>Description</h3>

<p>Three indicator functions: <code>IarcCSt1.std.triRAB</code>, <code>IarcCSt1.std.triRBC</code> and <code>IarcCSt1.std.triRAC</code>.
</p>
<p>The function <code>IarcCSt1.std.triRAB</code> returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1)</code> for <code>p1</code> in <code class="reqn">RAB</code>
(edge region for edge <code class="reqn">AB</code>, i.e., edge 3) in the standard equilateral triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>;
</p>
<p><code>IarcCSt1.std.triRBC</code> returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1)</code> for <code>p1</code> in <code class="reqn">RBC</code> (edge region for edge <code class="reqn">BC</code>, i.e., edge 1) in <code class="reqn">T_e</code>;
and
</p>
<p><code>IarcCSt1.std.triRAC</code> returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1)</code> for <code>p1</code> in <code class="reqn">RAC</code> (edge region for edge <code class="reqn">AC</code>, i.e., edge 2) in <code class="reqn">T_e</code>.
</p>
<p>That is, each function returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1)</code>, returns 0 otherwise, where <code class="reqn">N_{CS}(x,t)</code> is the
CS proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">t=1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSt1.std.triRAB(p1, p2)

IarcCSt1.std.triRBC(p1, p2)

IarcCSt1.std.triRAC(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsCSt1EdgeRegs_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="funsCSt1EdgeRegs_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each function returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1))</code> for <code>p1</code>, that is,
returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSstd.triRAB">IarcCSstd.triRAB</a></code>, <code><a href="#topic+IarcCSstd.triRBC">IarcCSstd.triRBC</a></code> and <code><a href="#topic+IarcCSstd.triRAC">IarcCSstd.triRAC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for IarcCSt1.std.triRAB
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
CM&lt;-(A+B+C)/3
T3&lt;-rbind(A,B,CM);

set.seed(1)
Xp&lt;-runif.std.tri(10)$gen.points

IarcCSt1.std.triRAB(Xp[1,],Xp[2,])

IarcCSt1.std.triRAB(c(.2,.5),Xp[2,])



#Examples for IarcCSt1.std.triRBC
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
CM&lt;-(A+B+C)/3
T1&lt;-rbind(B,C,CM);

set.seed(1)
Xp&lt;-runif.std.tri(3)$gen.points

IarcCSt1.std.triRBC(Xp[1,],Xp[2,])

IarcCSt1.std.triRBC(c(.2,.5),Xp[2,])



#Examples for IarcCSt1.std.triRAC
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
CM&lt;-(A+B+C)/3
T2&lt;-rbind(A,C,CM);

set.seed(1)
Xp&lt;-runif.std.tri(3)$gen.points

IarcCSt1.std.triRAC(Xp[1,],Xp[2,])
IarcCSt1.std.triRAC(c(1,2),Xp[2,])


</code></pre>

<hr>
<h2 id='funsIndDelTri'>Functions provide the indices of the Delaunay triangles
where the points reside</h2><span id='topic+funsIndDelTri'></span><span id='topic+index.delaunay.tri'></span><span id='topic+indices.delaunay.tri'></span>

<h3>Description</h3>

<p>Two functions: <code>index.delaunay.tri</code> and <code>indices.delaunay.tri</code>.
</p>
<p><code>index.delaunay.tri</code> finds the index of the Delaunay triangle
in which the given point, <code>p</code>, resides.
</p>
<p><code>indices.delaunay.tri</code> finds the indices of triangles
for all the points in data set, <code>Xp</code>, as a vector.
</p>
<p>Delaunay triangulation is based on <code>Yp</code>
and <code>DTmesh</code> are the Delaunay triangles with default <code>NULL</code>.
The function returns <code>NA</code> for a point not inside the convex hull of <code>Yp</code>.
Number of <code>Yp</code> points (i.e., size of <code>Yp</code>)
should be at least three and the points
should be in general position so that Delaunay triangulation is (uniquely) defined.
</p>
<p>If the number of <code>Yp</code> points is 3,
then there is only one Delaunay triangle and the indices of all
the points inside this triangle are all 1.
</p>
<p>See (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016)) for more on Delaunay
triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.delaunay.tri(p, Yp, DTmesh = NULL)

indices.delaunay.tri(Xp, Yp, DTmesh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsIndDelTri_+3A_p">p</code></td>
<td>
<p>A 2D point; the index of the Delaunay triangle
in which <code>p</code> resides is to be
determined. It is an argument for <code>index.delaunay.tri</code>.</p>
</td></tr>
<tr><td><code id="funsIndDelTri_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
from which Delaunay triangulation is constructed.</p>
</td></tr>
<tr><td><code id="funsIndDelTri_+3A_dtmesh">DTmesh</code></td>
<td>
<p>Delaunay triangles based on <code>Yp</code>, default is <code>NULL</code>,
which is computed via <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function
in <code>interp</code> package. <code><a href="interp.html#topic+triangles">triangles</a></code> function yields
a triangulation data structure from the triangulation object
created by <code>tri.mesh</code>.</p>
</td></tr>
<tr><td><code id="funsIndDelTri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points
for which the indices of the Delaunay
triangles they reside is to be determined.
It is an argument for <code>indices.delaunay.tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>index.delaunay.tri</code> returns the index of the Delaunay triangle
in which the given point, <code>p</code>, resides
and <code>indices.delaunay.tri</code> returns the <code>vector</code> of indices of
the Delaunay triangles in which points in the data
set, <code>Xp</code>, reside.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for index.delaunay.tri
nx&lt;-20 #number of X points (target)
ny&lt;-5 #number of Y points (nontarget)
set.seed(1)
Yp&lt;-cbind(runif(ny),runif(ny))

Xp&lt;-runif.multi.tri(nx,Yp)$g #data under CSR in the convex hull of Ypoints
#try also Xp&lt;-cbind(runif(nx),runif(nx))

index.delaunay.tri(Xp[10,],Yp)

#or use
DTY&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")
#Delaunay triangulation
TRY&lt;-interp::triangles(DTY)[,1:3];
index.delaunay.tri(Xp[10,],Yp,DTY)

ind.DT&lt;-vector()
for (i in 1:nx)
 ind.DT&lt;-c(ind.DT,index.delaunay.tri(Xp[i,],Yp))
ind.DT

Xlim&lt;-range(Yp[,1],Xp[,1])
Ylim&lt;-range(Yp[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

DTY&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")
#Delaunay triangulation based on Y points

#plot of the data in the convex hull of Y points together with the Delaunay triangulation
plot(Xp,main=" ", xlab=" ", ylab=" ",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),type="n")
interp::plot.triSht(DTY, add=TRUE, do.points = TRUE,pch=16,col="blue")
points(Xp,pch=".",cex=3)
text(Xp,labels = factor(ind.DT))



#Examples for indices.delaunay.tri
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Yp&lt;-cbind(runif(ny),runif(ny))
Xp&lt;-runif.multi.tri(nx,Yp)$g #data under CSR in the convex hull of Ypoints
#try also Xp&lt;-cbind(runif(nx),runif(nx))

tr.ind&lt;-indices.delaunay.tri(Xp,Yp)  #indices of the Delaunay triangles
tr.ind

#or use
DTY&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")
#Delaunay triangulation based on Y points
tr.ind&lt;-indices.delaunay.tri(Xp,Yp,DTY)  #indices of the Delaunay triangles
tr.ind

Xlim&lt;-range(Yp[,1],Xp[,1])
Ylim&lt;-range(Yp[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

#plot of the data in the convex hull of Y points together with the Delaunay triangulation

oldpar &lt;- par(pty = "s")
plot(Xp,main=" ", xlab=" ", ylab=" ",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),pch=".")
interp::plot.triSht(DTY, add=TRUE, do.points = TRUE,pch=16,col="blue")
text(Xp,labels = factor(tr.ind))
par(oldpar)


</code></pre>

<hr>
<h2 id='funsMuVarCS1D'>Returning the mean and (asymptotic) variance of arc density of Central Similarity Proximity Catch Digraph (CS-PCD)
for 1D data - middle interval case</h2><span id='topic+funsMuVarCS1D'></span><span id='topic+muCS1D'></span><span id='topic+asy.varCS1D'></span>

<h3>Description</h3>

<p>Two functions: <code>muCS1D</code> and <code>asy.varCS1D</code>.
</p>
<p><code>muCS1D</code> returns the mean of the (arc) density of CS-PCD
and <code>asy.varCS1D</code> returns the (asymptotic) variance of the arc density of CS-PCD
for a given centrality parameter <code class="reqn">c \in (0,1)</code> and an expansion parameter <code class="reqn">t&gt;0</code> and 1D uniform data in a
finite interval <code class="reqn">(a,b)</code>, i.e., data from <code class="reqn">U(a,b)</code> distribution.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muCS1D(t, c)

asy.varCS1D(t, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsMuVarCS1D_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="funsMuVarCS1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>muCS1D</code> returns the mean and <code>asy.varCS1D</code> returns the asymptotic variance of the
arc density of CS-PCD for uniform data in an interval
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+muPE1D">muPE1D</a></code> and <code><a href="#topic+asy.varPE1D">asy.varPE1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for muCS1D
muCS1D(1.2,.4)
muCS1D(1.2,.6)

tseq&lt;-seq(0.01,5,by=.05)
cseq&lt;-seq(0.01,.99,by=.05)

ltseq&lt;-length(tseq)
lcseq&lt;-length(cseq)

mu.grid&lt;-matrix(0,nrow=ltseq,ncol=lcseq)
for (i in 1:ltseq)
  for (j in 1:lcseq)
  {
    mu.grid[i,j]&lt;-muCS1D(tseq[i],cseq[j])
  }

persp(tseq,cseq,mu.grid, xlab="t", ylab="c", zlab="mu(t,c)",theta = -30,
phi = 30, expand = 0.5, col = "lightblue", ltheta = 120,
shade = 0.05, ticktype = "detailed")



#Examples for asy.varCS1D
asy.varCS1D(1.2,.8)

tseq&lt;-seq(0.01,5,by=.05)
cseq&lt;-seq(0.01,.99,by=.05)

ltseq&lt;-length(tseq)
lcseq&lt;-length(cseq)

var.grid&lt;-matrix(0,nrow=ltseq,ncol=lcseq)
for (i in 1:ltseq)
  for (j in 1:lcseq)
  {
    var.grid[i,j]&lt;-asy.varCS1D(tseq[i],cseq[j])
  }

persp(tseq,cseq,var.grid, xlab="t", ylab="c", zlab="var(t,c)", theta = -30,
phi = 30, expand = 0.5, col = "lightblue", ltheta = 120,
shade = 0.05, ticktype = "detailed")


</code></pre>

<hr>
<h2 id='funsMuVarCS2D'>Returns the mean and (asymptotic) variance of arc density of  Central Similarity Proximity Catch Digraph (CS-PCD)
for 2D uniform data in one triangle</h2><span id='topic+funsMuVarCS2D'></span><span id='topic+muCS2D'></span><span id='topic+asy.varCS2D'></span>

<h3>Description</h3>

<p>Two functions: <code>muCS2D</code> and <code>asy.varCS2D</code>.
</p>
<p><code>muCS2D</code> returns the mean of the (arc) density of CS-PCD
and <code>asy.varCS2D</code> returns the asymptotic variance of the arc density of CS-PCD
with expansion parameter <code class="reqn">t&gt;0</code> for 2D uniform data in a triangle.
</p>
<p>CS proximity regions are defined with respect to the triangle and
vertex regions are based on center of mass, <code class="reqn">CM</code> of the triangle.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muCS2D(t)

asy.varCS2D(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsMuVarCS2D_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>muCS2D</code> returns the mean and <code>asy.varCS2D</code> returns the (asymptotic) variance of the
arc density of CS-PCD for uniform data in any triangle
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+muPE2D">muPE2D</a></code> and <code><a href="#topic+asy.varPE2D">asy.varPE2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for muCS2D
muCS2D(.5)

tseq&lt;-seq(0.01,5,by=.1)
ltseq&lt;-length(tseq)

mu&lt;-vector()
for (i in 1:ltseq)
{
  mu&lt;-c(mu,muCS2D(tseq[i]))
}

plot(tseq, mu,type="l",xlab="t",ylab=expression(mu(t)),lty=1,xlim=range(tseq))



#Examples for asy.varCS2D
asy.varCS2D(.5)

tseq&lt;-seq(0.01,10,by=.1)
ltseq&lt;-length(tseq)

asy.var&lt;-vector()
for (i in 1:ltseq)
{
  asy.var&lt;-c(asy.var,asy.varCS2D(tseq[i]))
}

oldpar &lt;- par(mar=c(5,5,4,2))
plot(tseq, asy.var,type="l",xlab="t",
    ylab=expression(paste(sigma^2,"(t)")),lty=1,xlim=range(tseq))
par(oldpar)


</code></pre>

<hr>
<h2 id='funsMuVarCSend.int'>Returns the mean and (asymptotic) variance of arc density of Central Similarity Proximity Catch Digraph (CS-PCD)
for 1D data - end-interval case</h2><span id='topic+funsMuVarCSend.int'></span><span id='topic+muCSend.int'></span><span id='topic+asy.varCSend.int'></span>

<h3>Description</h3>

<p>Two functions: <code>muCSend.int</code> and <code>asy.varCSend.int</code>.
</p>
<p><code>muCSend.int</code> returns the mean of the arc density of CS-PCD
and <code>asy.varCSend.int</code> returns the asymptotic variance of the arc density of CS-PCD
for a given expansion parameter <code class="reqn">t&gt;0</code>  for 1D uniform data in the left and right end-intervals
for the interval <code class="reqn">(a,b)</code>.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muCSend.int(t)

asy.varCSend.int(t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsMuVarCSend.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>funsMuVarCSend.int
</p>


<h3>Value</h3>

<p><code>muCSend.int</code> returns the mean and <code>asy.varCSend.int</code> returns the asymptotic variance of the
arc density of CS-PCD for uniform data in end-intervals
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+muPEend.int">muPEend.int</a></code> and <code><a href="#topic+asy.varPEend.int">asy.varPEend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Examples for muCSend.int
muCSend.int(1.2)

tseq&lt;-seq(0.01,5,by=.05)
ltseq&lt;-length(tseq)

mu.end&lt;-vector()
for (i in 1:ltseq)
{
  mu.end&lt;-c(mu.end,muCSend.int(tseq[i]))
}

oldpar &lt;- par(no.readonly = TRUE)
par(mar = c(5,4,4,2) + 0.1)
plot(tseq, mu.end,type="l",
ylab=expression(paste(mu,"(t)")),xlab="t",lty=1,xlim=range(tseq),ylim=c(0,1))
par(oldpar)

#Examples for asy.varCSend.int
asy.varCSend.int(1.2)

tseq&lt;-seq(.01,5,by=.05)
ltseq&lt;-length(tseq)

var.end&lt;-vector()
for (i in 1:ltseq)
{
  var.end&lt;-c(var.end,asy.varCSend.int(tseq[i]))
}

oldpar &lt;- par(no.readonly = TRUE)
par(mar=c(5,5,4,2))
plot(tseq, var.end,type="l",xlab="t",ylab=expression(paste(sigma^2,"(t)")),lty=1,xlim=range(tseq))
par(oldpar)

</code></pre>

<hr>
<h2 id='funsMuVarPE1D'>Returns the mean and (asymptotic) variance of arc density of Proportional Edge Proximity
Catch Digraph (PE-PCD) for 1D data - middle interval case</h2><span id='topic+funsMuVarPE1D'></span><span id='topic+mu1PE1D'></span><span id='topic+muPE1D'></span><span id='topic+fvar1'></span><span id='topic+fvar2'></span><span id='topic+asy.varPE1D'></span>

<h3>Description</h3>

<p>The functions <code>muPE1D</code> and <code>asy.varPE1D</code> and their auxiliary functions.
</p>
<p><code>muPE1D</code> returns the mean of the (arc) density of PE-PCD
and <code>asy.varPE1D</code> returns the (asymptotic) variance of the arc density of PE-PCD
for a given centrality parameter <code class="reqn">c \in (0,1)</code> and an expansion parameter <code class="reqn">r \ge 1</code> and for 1D uniform data in a
finite interval <code class="reqn">(a,b)</code>, i.e., data from <code class="reqn">U(a,b)</code> distribution.
</p>
<p><code>muPE1D</code> uses auxiliary (internal) function <code>mu1PE1D</code> which yields mean (i.e., expected value)
of the arc density of PE-PCD for a given <code class="reqn">c \in (0,1/2)</code> and <code class="reqn">r \ge 1</code>.
</p>
<p><code>asy.varPE1D</code> uses auxiliary (internal) functions <code>fvar1</code> which yields asymptotic variance
of the arc density of PE-PCD for <code class="reqn">c \in (1/4,1/2)</code> and <code class="reqn">r \ge 1</code>; and <code>fvar2</code> which yields asymptotic variance
of the arc density of PE-PCD for <code class="reqn">c \in (0,1/4)</code> and <code class="reqn">r \ge 1</code>.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu1PE1D(r, c)

muPE1D(r, c)

fvar1(r, c)

fvar2(r, c)

asy.varPE1D(r, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsMuVarPE1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="funsMuVarPE1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>.
For the interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>muPE1D</code> returns the mean and <code>asy.varPE1D</code> returns the asymptotic variance of the
arc density of PE-PCD for <code class="reqn">U(a,b)</code> data
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+muCS1D">muCS1D</a></code> and <code><a href="#topic+asy.varCS1D">asy.varCS1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for muPE1D
muPE1D(1.2,.4)
muPE1D(1.2,.6)

rseq&lt;-seq(1.01,5,by=.1)
cseq&lt;-seq(0.01,.99,by=.1)

lrseq&lt;-length(rseq)
lcseq&lt;-length(cseq)

mu.grid&lt;-matrix(0,nrow=lrseq,ncol=lcseq)
for (i in 1:lrseq)
  for (j in 1:lcseq)
  {
    mu.grid[i,j]&lt;-muPE1D(rseq[i],cseq[j])
  }

persp(rseq,cseq,mu.grid, xlab="r", ylab="c", zlab="mu(r,c)", theta = -30, phi = 30,
expand = 0.5, col = "lightblue", ltheta = 120, shade = 0.05, ticktype = "detailed")



#Examples for asy.varPE1D
asy.varPE1D(1.2,.8)

rseq&lt;-seq(1.01,5,by=.1)
cseq&lt;-seq(0.01,.99,by=.1)

lrseq&lt;-length(rseq)
lcseq&lt;-length(cseq)

var.grid&lt;-matrix(0,nrow=lrseq,ncol=lcseq)
for (i in 1:lrseq)
  for (j in 1:lcseq)
  {
    var.grid[i,j]&lt;-asy.varPE1D(rseq[i],cseq[j])
  }

persp(rseq,cseq,var.grid, xlab="r", ylab="c", zlab="var(r,c)", theta = -30, phi = 30,
expand = 0.5, col = "lightblue", ltheta = 120, shade = 0.05, ticktype = "detailed")


</code></pre>

<hr>
<h2 id='funsMuVarPE2D'>Returns the mean and (asymptotic) variance of arc density of
Proportional Edge Proximity Catch Digraph (PE-PCD)
for 2D uniform data in one triangle</h2><span id='topic+funsMuVarPE2D'></span><span id='topic+muPE2D'></span><span id='topic+asy.varPE2D'></span>

<h3>Description</h3>

<p>Two functions: <code>muPE2D</code> and <code>asy.varPE2D</code>.
</p>
<p><code>muPE2D</code> returns the mean of the (arc) density of PE-PCD
and <code>asy.varPE2D</code> returns the asymptotic variance
of the arc density of PE-PCD
for 2D uniform data in a triangle.
</p>
<p>PE proximity regions are defined
with expansion parameter <code class="reqn">r \ge 1</code>
with respect to the triangle
in which the points reside and
vertex regions are based on center of mass, <code class="reqn">CM</code> of the triangle.
</p>
<p>See also (Ceyhan et al. (2006)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muPE2D(r)

asy.varPE2D(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsMuVarPE2D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves
as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>muPE2D</code> returns the mean
and <code>asy.varPE2D</code> returns the (asymptotic) variance of the
arc density of PE-PCD for uniform data in any triangle.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+muCS2D">muCS2D</a></code> and <code><a href="#topic+asy.varCS2D">asy.varCS2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for muPE2D
muPE2D(1.2)

rseq&lt;-seq(1.01,5,by=.05)
lrseq&lt;-length(rseq)

mu&lt;-vector()
for (i in 1:lrseq)
{
  mu&lt;-c(mu,muPE2D(rseq[i]))
}

plot(rseq, mu,type="l",xlab="r",ylab=expression(mu(r)),lty=1,
xlim=range(rseq),ylim=c(0,1))



#Examples for asy.varPE2D
asy.varPE2D(1.2)

rseq&lt;-seq(1.01,5,by=.05)
lrseq&lt;-length(rseq)

avar&lt;-vector()
for (i in 1:lrseq)
{
  avar&lt;-c(avar,asy.varPE2D(rseq[i]))
}

oldpar &lt;- par(mar=c(5,5,4,2))
plot(rseq, avar,type="l",xlab="r",
ylab=expression(paste(sigma^2,"(r)")),lty=1,xlim=range(rseq))
par(oldpar)


</code></pre>

<hr>
<h2 id='funsMuVarPEend.int'>Returns the mean and (asymptotic) variance of arc density of Proportional Edge Proximity Catch Digraph
(PE-PCD) for 1D data - end-interval case</h2><span id='topic+funsMuVarPEend.int'></span><span id='topic+muPEend.int'></span><span id='topic+asy.varPEend.int'></span>

<h3>Description</h3>

<p>Two functions: <code>muPEend.int</code> and <code>asy.varPEend.int</code>.
</p>
<p><code>muPEend.int</code> returns the mean of the arc density of PE-PCD
and <code>asy.varPEend.int</code> returns the asymptotic variance of the arc density of PE-PCD
for a given expansion parameter <code class="reqn">r \ge 1</code> for 1D uniform data in the left and right end-intervals
for the interval <code class="reqn">(a,b)</code>.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muPEend.int(r)

asy.varPEend.int(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsMuVarPEend.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>muPEend.int</code> returns the mean and <code>asy.varPEend.int</code> returns the asymptotic variance of the
arc density of PE-PCD for uniform data in end-intervals
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+muCSend.int">muCSend.int</a></code> and <code><a href="#topic+asy.varCSend.int">asy.varCSend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for muPEend.int
muPEend.int(1.2)

rseq&lt;-seq(1.01,5,by=.1)
lrseq&lt;-length(rseq)

mu.end&lt;-vector()
for (i in 1:lrseq)
{
  mu.end&lt;-c(mu.end,muPEend.int(rseq[i]))
}

plot(rseq, mu.end,type="l",
ylab=expression(paste(mu,"(r)")),xlab="r",lty=1,xlim=range(rseq),ylim=c(0,1))



#Examples for asy.varPEend.int
asy.varPEend.int(1.2)

rseq&lt;-seq(1.01,5,by=.1)
lrseq&lt;-length(rseq)

var.end&lt;-vector()
for (i in 1:lrseq)
{
  var.end&lt;-c(var.end,asy.varPEend.int(rseq[i]))
}

oldpar &lt;- par(mar=c(5,5,4,2))
plot(rseq, var.end,type="l",
xlab="r",ylab=expression(paste(sigma^2,"(r)")),lty=1,xlim=range(rseq))
par(oldpar)


</code></pre>

<hr>
<h2 id='funsPDomNum2PE1D'>The functions for probability of domination number <code class="reqn">= 2</code> for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - middle interval case</h2><span id='topic+funsPDomNum2PE1D'></span><span id='topic+Pdom.num2AI'></span><span id='topic+Pdom.num2AII'></span><span id='topic+Pdom.num2AIII'></span><span id='topic+Pdom.num2AIV'></span><span id='topic+Pdom.num2A'></span><span id='topic+Pdom.num2Asym'></span><span id='topic+Pdom.num2BIII'></span><span id='topic+Pdom.num2B'></span><span id='topic+Pdom.num2Bsym'></span><span id='topic+Pdom.num2CIV'></span><span id='topic+Pdom.num2C'></span><span id='topic+Pdom.num2Csym'></span><span id='topic+Pdom.num2PE1D'></span>

<h3>Description</h3>

<p>The function <code>Pdom.num2PE1D</code> and its auxiliary functions.
</p>
<p>Returns <code class="reqn">P(\gamma=2)</code> for PE-PCD whose vertices are a uniform data set of size <code>n</code> in a finite interval
<code class="reqn">(a,b)</code> where <code class="reqn">\gamma</code> stands for the domination number.
</p>
<p>The PE proximity region <code class="reqn">N_{PE}(x,r,c)</code> is defined with respect to <code class="reqn">(a,b)</code> with centrality parameter <code class="reqn">c \in (0,1)</code>
and expansion parameter <code class="reqn">r \ge 1</code>.
</p>
<p>To compute the probability <code class="reqn">P(\gamma=2)</code> for PE-PCD in the 1D case,
we partition the domain <code class="reqn">(r,c)=(1,\infty) \times (0,1)</code>, and compute the probability for each partition
set. The sample size (i.e., number of vertices or data points) is a positive integer, <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pdom.num2AI(r, c, n)

Pdom.num2AII(r, c, n)

Pdom.num2AIII(r, c, n)

Pdom.num2AIV(r, c, n)

Pdom.num2A(r, c, n)

Pdom.num2Asym(r, c, n)

Pdom.num2BIII(r, c, n)

Pdom.num2B(r, c, n)

Pdom.num2Bsym(r, c, n)

Pdom.num2CIV(r, c, n)

Pdom.num2C(r, c, n)

Pdom.num2Csym(r, c, n)

Pdom.num2PE1D(r, c, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsPDomNum2PE1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="funsPDomNum2PE1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>.
For the interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="funsPDomNum2PE1D_+3A_n">n</code></td>
<td>
<p>A positive integer representing the size of the uniform data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">P(</code>domination number<code class="reqn">\le 1)</code> for PE-PCD whose vertices are a uniform data set of size <code>n</code> in a finite
interval <code class="reqn">(a,b)</code>
</p>


<h3>Auxiliary Functions for <code>Pdom.num2PE1D</code></h3>

<p>The auxiliary functions are <code>Pdom.num2AI, Pdom.num2AII, Pdom.num2AIII, Pdom.num2AIV, Pdom.num2A, Pdom.num2Asym, Pdom.num2BIII, Pdom.num2B, Pdom.num2B,
Pdom.num2Bsym, Pdom.num2CIV, Pdom.num2C</code>, and <code>Pdom.num2Csym</code>, each corresponding to a partition of the domain of
<code>r</code> and <code>c</code>. In particular, the domain partition is handled in 3 cases as
</p>
<p>CASE A: <code class="reqn">c \in ((3-\sqrt{5})/2, 1/2)</code>
</p>
<p>CASE B: <code class="reqn">c \in (1/4,(3-\sqrt{5})/2)</code> and
</p>
<p>CASE C: <code class="reqn">c \in (0,1/4)</code>.
</p>


<h3>Case A - <code class="reqn">c \in ((3-\sqrt{5})/2, 1/2)</code></h3>

<p>In Case A, we compute <code class="reqn">P(\gamma=2)</code> with
</p>
<p><code>Pdom.num2AIV(r,c,n)</code> if <code class="reqn">1 &lt; r &lt; (1-c)/c</code>;
</p>
<p><code>Pdom.num2AIII(r,c,n)</code> if <code class="reqn">(1-c)/c&lt; r &lt; 1/(1-c)</code>;
</p>
<p><code>Pdom.num2AII(r,c,n)</code> if <code class="reqn">1/(1-c)&lt; r &lt; 1/c</code>;
</p>
<p>and <code>Pdom.num2AI(r,c,n)</code> otherwise.
</p>
<p><code>Pdom.num2A(r,c,n)</code> combines these functions in Case A: <code class="reqn">c \in ((3-\sqrt{5})/2,1/2)</code>.
Due to the symmetry in the PE proximity regions, we use <code>Pdom.num2Asym(r,c,n)</code> for <code class="reqn">c</code> in
<code class="reqn">(1/2,(\sqrt{5}-1)/2)</code> with the same auxiliary functions
</p>
<p><code>Pdom.num2AIV(r,1-c,n)</code> if <code class="reqn">1 &lt; r &lt; c/(1-c)</code>;
</p>
<p><code>Pdom.num2AIII(r,1-c,n)</code> if <code class="reqn">(c/(1-c) &lt; r &lt; 1/c</code>;
</p>
<p><code>Pdom.num2AII(r,1-c,n)</code> if <code class="reqn">1/c &lt; r &lt; 1/(1-c)</code>;
</p>
<p>and <code>Pdom.num2AI(r,1-c,n)</code> otherwise.
</p>


<h3>Case B - <code class="reqn">c \in (1/4,(3-\sqrt{5})/2)</code></h3>

<p>In Case B, we compute <code class="reqn">P(\gamma=2)</code> with
</p>
<p><code>Pdom.num2AIV(r,c,n)</code> if <code class="reqn">1 &lt; r &lt; 1/(1-c)</code>;
</p>
<p><code>Pdom.num2BIII(r,c,n)</code> if <code class="reqn">1/(1-c) &lt; r &lt; (1-c)/c</code>;
</p>
<p><code>Pdom.num2AII(r,c,n)</code> if <code class="reqn">(1-c)/c &lt; r &lt; 1/c</code>;
</p>
<p>and <code>Pdom.num2AI(r,c,n)</code> otherwise.
</p>
<p><code>Pdom.num2B(r,c,n)</code> combines these functions in Case B: <code class="reqn">c \in (1/4,(3-\sqrt{5})/2)</code>.
Due to the symmetry in the PE proximity regions,
we use <code>Pdom.num2Bsym(r,c,n)</code> for <code>c</code> in
<code class="reqn">((\sqrt{5}-1)/2,3/4)</code> with the same auxiliary functions
</p>
<p><code>Pdom.num2AIV(r,1-c,n)</code> if <code class="reqn"> 1&lt; r &lt; 1/c</code>;
</p>
<p><code>Pdom.num2BIII(r,1-c,n)</code> if <code class="reqn">1/c &lt; r &lt; c/(1-c)</code>;
</p>
<p><code>Pdom.num2AII(r,1-c,n)</code> if <code class="reqn">c/(1-c) &lt; r &lt; 1/(1-c)</code>;
</p>
<p>and <code>Pdom.num2AI(r,1-c,n)</code> otherwise.
</p>


<h3>Case C - <code class="reqn">c \in (0,1/4)</code></h3>

<p>In Case C, we compute <code class="reqn">P(\gamma=2)</code> with
</p>
<p><code>Pdom.num2AIV(r,c,n)</code> if <code class="reqn">1&lt; r &lt; 1/(1-c)</code>;
</p>
<p><code>Pdom.num2BIII(r,c,n)</code> if <code class="reqn">1/(1-c) &lt; r &lt; (1-\sqrt{1-4 c})/(2 c)</code>;
</p>
<p><code>Pdom.num2CIV(r,c,n)</code> if <code class="reqn">(1-\sqrt{1-4 c})/(2 c) &lt; r &lt; (1+\sqrt{1-4 c})/(2 c)</code>;
</p>
<p><code>Pdom.num2BIII(r,c,n)</code> if <code class="reqn">(1+\sqrt{1-4 c})/(2 c) &lt; r &lt;1/(1-c)</code>;
</p>
<p><code>Pdom.num2AII(r,c,n)</code> if <code class="reqn">1/(1-c) &lt; r &lt; 1/c</code>;
</p>
<p>and <code>Pdom.num2AI(r,c,n)</code> otherwise.
</p>
<p><code>Pdom.num2C(r,c,n)</code> combines these functions in Case C: <code class="reqn">c \in (0,1/4)</code>.
Due to the symmetry in the PE proximity regions,
we use <code>Pdom.num2Csym(r,c,n)</code> for <code class="reqn">c \in (3/4,1)</code>
with the same auxiliary functions
</p>
<p><code>Pdom.num2AIV(r,1-c,n)</code> if <code class="reqn">1&lt; r &lt; 1/c</code>;
</p>
<p><code>Pdom.num2BIII(r,1-c,n)</code> if <code class="reqn">1/c &lt; r &lt; (1-\sqrt{1-4(1-c)})/(2(1-c))</code>;
</p>
<p><code>Pdom.num2CIV(r,1-c,n)</code> if <code class="reqn">(1-\sqrt{1-4(1-c)})/(2(1-c)) &lt; r &lt; (1+\sqrt{1-4(1-c)})/(2(1-c))</code>;
</p>
<p><code>Pdom.num2BIII(r,1-c,n)</code> if <code class="reqn">(1+\sqrt{1-4(1-c)})/(2(1-c)) &lt; r &lt; c/(1-c)</code>;
</p>
<p><code>Pdom.num2AII(r,1-c,n)</code> if <code class="reqn">c/(1-c)&lt; r &lt; 1/(1-c)</code>;
</p>
<p>and <code>Pdom.num2AI(r,1-c,n)</code> otherwise.
</p>
<p>Combining Cases A, B, and C, we get our main function <code>Pdom.num2PE1D</code> which computes <code class="reqn">P(\gamma=2)</code>
for any (<code>r,c</code>) in its domain.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pdom.num2PEtri">Pdom.num2PEtri</a></code> and  <code><a href="#topic+Pdom.num2PE1Dasy">Pdom.num2PE1Dasy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Examples for the main function Pdom.num2PE1D
r&lt;-2
c&lt;-.5

Pdom.num2PE1D(r,c,n=10)
Pdom.num2PE1D(r=1.5,c=1/1.5,n=100)

</code></pre>

<hr>
<h2 id='funsRankOrderTe'>Returns the ranks and orders of points in decreasing distance
to the edges of the triangle</h2><span id='topic+funsRankOrderTe'></span><span id='topic+rank.dist2edges.std.tri'></span><span id='topic+order.dist2edges.std.tri'></span>

<h3>Description</h3>

<p>Two functions: <code>rank.dist2edges.std.tri</code> and <code>order.dist2edges.std.tri</code>.
</p>
<p><code>rank.dist2edges.std.tri</code> finds the ranks of the distances of points
in data, <code>Xp</code>, to the edges of the standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
</p>
<p><code>dec</code> is a logical argument, default is <code>TRUE</code>,
so the ranks are for decreasing distances, if <code>FALSE</code> it will be
in increasing distances.
</p>
<p><code>order.dist2edges.std.tri</code> finds the orders of the distances of points
in data, <code>Xp</code>, to the edges of <code class="reqn">T_e</code>.
The arguments are as in <code>rank.dist2edges.std.tri</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank.dist2edges.std.tri(Xp, dec = TRUE)

order.dist2edges.std.tri(Xp, dec = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsRankOrderTe_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the data set
in which ranking in terms of the distance
to the edges of <code class="reqn">T_e</code> is performed.</p>
</td></tr>
<tr><td><code id="funsRankOrderTe_+3A_dec">dec</code></td>
<td>
<p>A logical argument
indicating the how the ranking will be performed.
If <code>TRUE</code>,
the ranks are for decreasing distances,
and if <code>FALSE</code> they will be in increasing distances,
default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>Distances from data points to the edges of <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>dist.rank</code></td>
<td>
<p>The ranks of the data points
in decreasing distances to the edges of <code class="reqn">T_e</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for rank.dist2edges.std.tri
n&lt;-10
set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

dec.dist&lt;-rank.dist2edges.std.tri(Xp)
dec.dist
dec.dist.rank&lt;-dec.dist[[2]]
#the rank of distances to the edges in decreasing order
dec.dist.rank

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",xlim=Xlim+xd*c(-.0,.01),
ylim=Ylim+yd*c(-.01,.01))
polygon(Te)
points(Xp,pch=".")
text(Xp,labels = factor(dec.dist.rank) )

inc.dist&lt;-rank.dist2edges.std.tri(Xp,dec = FALSE)
inc.dist
inc.dist.rank&lt;-inc.dist[[2]]
#the rank of distances to the edges in increasing order
inc.dist.rank
dist&lt;-inc.dist[[1]] #distances to the edges of the std eq. triangle
dist

plot(A,pch=".",xlab="",ylab="",xlim=Xlim,ylim=Ylim)
polygon(Te)
points(Xp,pch=".",xlab="",ylab="", main="",xlim=Xlim+xd*c(-.05,.05),
ylim=Ylim+yd*c(-.05,.05))
text(Xp,labels = factor(inc.dist.rank))



#Examples for order.dist2edges.std.tri
n&lt;-10
set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points  #try also Xp&lt;-cbind(runif(n),runif(n))

dec.dist&lt;-order.dist2edges.std.tri(Xp)
dec.dist
dec.dist.order&lt;-dec.dist[[2]]
#the order of distances to the edges in decreasing order
dec.dist.order

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",xlim=Xlim+xd*c(-.01,.01),
ylim=Ylim+yd*c(-.01,.01))
polygon(Te)
points(Xp,pch=".")
text(Xp[dec.dist.order,],labels = factor(1:n) )

inc.dist&lt;-order.dist2edges.std.tri(Xp,dec = FALSE)
inc.dist
inc.dist.order&lt;-inc.dist[[2]]
#the order of distances to the edges in increasing order
inc.dist.order
dist&lt;-inc.dist[[1]] #distances to the edges of the std eq. triangle
dist
dist[inc.dist.order] #distances in increasing order

plot(A,pch=".",xlab="",ylab="",xlim=Xlim+xd*c(-.05,.05),
ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
points(Xp,pch=".")
text(Xp[inc.dist.order,],labels = factor(1:n))


</code></pre>

<hr>
<h2 id='funsTbMid2CC'>Two functions <code>lineD1CCinTb</code> and <code>lineD2CCinTb</code> which are of class <code>"TriLines"</code> &mdash;
The lines joining the midpoints of edges to the circumcenter (<code class="reqn">CC</code>) in the standard basic triangle.</h2><span id='topic+funsTbMid2CC'></span><span id='topic+lineD1CCinTb'></span><span id='topic+lineD2CCinTb'></span>

<h3>Description</h3>

<p>Returns the <code>equation, slope, intercept</code>, and <code class="reqn">y</code>-coordinates of the lines
joining <code class="reqn">D_1</code> and <code class="reqn">CC</code> and also <code class="reqn">D_2</code> and <code class="reqn">CC</code>, in the standard basic triangle <code class="reqn">T_b=T(A=(0,0),B=(1,0),C=(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>
and <code class="reqn">D_1=(B+C)/2</code> and <code class="reqn">D_2=(A+C)/2</code> are the midpoints of edges <code class="reqn">BC</code> and <code class="reqn">AC</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling, preserving uniformity of the points in the
original triangle. Hence standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
<code class="reqn">x</code>-coordinates are provided in <code>vector</code> <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineD1CCinTb(x, c1, c2)

lineD2CCinTb(x, c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsTbMid2CC_+3A_x">x</code></td>
<td>
<p>A single scalar or a <code>vector</code> of scalars.</p>
</td></tr>
<tr><td><code id="funsTbMid2CC_+3A_c1">c1</code>, <code id="funsTbMid2CC_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers which constitute the vertex of the standard basic triangle
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Longer description of the line.</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>Shorter description of the line (to be inserted over the line in the plot).</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center chosen inside the standard equilateral triangle.</p>
</td></tr>
<tr><td><code>cent.name</code></td>
<td>
<p>The name of the center inside the standard basic triangle.
It is <code>"CC"</code> for these two functions.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The triangle (it is the standard basic triangle for this function).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The input vector, can be a scalar or a <code>vector</code> of scalars,
which constitute the <code class="reqn">x</code>-coordinates of the point(s) of interest on the line.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The output vector, will be a scalar if <code>x</code> is a scalar or a <code>vector</code> of scalars if <code>x</code> is a <code>vector</code> of scalar,
constitutes the <code class="reqn">y</code>-coordinates of the point(s) of interest on the line.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>Slope of the line.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>Intercept of the line.</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lineA2CMinTe">lineA2CMinTe</a></code>, <code><a href="#topic+lineB2CMinTe">lineB2CMinTe</a></code>, <code><a href="#topic+lineA2MinTe">lineA2MinTe</a></code>,
<code><a href="#topic+lineB2MinTe">lineB2MinTe</a></code>, and <code><a href="#topic+lineC2MinTe">lineC2MinTe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Examples for lineD1CCinTb
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);  #the vertices of the standard basic triangle Tb

Tb&lt;-rbind(A,B,C)

xfence&lt;-abs(A[1]-B[1])*.25 #how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,by=.1)  #try also by=.01

lnD1CC&lt;-lineD1CCinTb(x,c1,c2)
lnD1CC
summary(lnD1CC)
plot(lnD1CC)

CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter
CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2; #midpoints of the edges
Ds&lt;-rbind(D1,D2,D3)

x1&lt;-seq(0,1,by=.1)  #try also by=.01
y1&lt;-lineD1CCinTb(x1,c1,c2)$y

Xlim&lt;-range(Tb[,1],x1)
Ylim&lt;-range(Tb[,2],y1)
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)

txt&lt;-rbind(Tb,CC,D1,D2,D3)
xc&lt;-txt[,1]+c(-.03,.04,.03,.02,.09,-.08,0)
yc&lt;-txt[,2]+c(.02,.02,.04,.08,.03,.03,-.05)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

lines(x1,y1,type="l",lty=2)
text(.8,.5,"lineD1CCinTb")

c1&lt;-.4; c2&lt;-.6;
x1&lt;-seq(0,1,by=.1)  #try also by=.01
lineD1CCinTb(x1,c1,c2)



#Examples for lineD2CCinTb
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);  #the vertices of the standard basic triangle Tb

Tb&lt;-rbind(A,B,C)

xfence&lt;-abs(A[1]-B[1])*.25 #how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,by=.1)  #try also by=.01

lnD2CC&lt;-lineD2CCinTb(x,c1,c2)
lnD2CC
summary(lnD2CC)
plot(lnD2CC)

CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter
CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2; #midpoints of the edges
Ds&lt;-rbind(D1,D2,D3)

x2&lt;-seq(0,1,by=.1)  #try also by=.01
y2&lt;-lineD2CCinTb(x2,c1,c2)$y

Xlim&lt;-range(Tb[,1],x1)
Ylim&lt;-range(Tb[,2],y2)
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)

txt&lt;-rbind(Tb,CC,D1,D2,D3)
xc&lt;-txt[,1]+c(-.03,.04,.03,.02,.09,-.08,0)
yc&lt;-txt[,2]+c(.02,.02,.04,.08,.03,.03,-.05)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

lines(x2,y2,type="l",lty=2)
text(0,.5,"lineD2CCinTb")


</code></pre>

<hr>
<h2 id='IarcASbasic.tri'>The indicator for the presence of an arc from a point to another
for Arc Slice Proximity Catch Digraphs
(AS-PCDs) - standard basic triangle case</h2><span id='topic+IarcASbasic.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(p2 \in N_{AS}(p1))</code> for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code class="reqn">p2</code> is in <code class="reqn">N_{AS}(p1)</code>, returns 0
otherwise, where <code class="reqn">N_{AS}(x)</code> is the AS proximity region for point <code class="reqn">x</code>.
</p>
<p>AS proximity region is constructed in the standard basic triangle <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or based on circumcenter of <code class="reqn">T_b</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code class="reqn">T_b</code>.
<code>rv</code> is the index of the vertex region <code>p1</code> resides, with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are outside <code class="reqn">T_b</code>, the function returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the original triangle.
Hence standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcASbasic.tri(p1, p2, c1, c2, M = "CC", rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcASbasic.tri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose AS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcASbasic.tri_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the AS proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcASbasic.tri_+3A_c1">c1</code>, <code id="IarcASbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers representing the top vertex in standard basic triangle <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>,
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="IarcASbasic.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter or a 2D point in Cartesian coordinates or a 3D point in
barycentric coordinates which serves as a center in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="IarcASbasic.tri_+3A_rv">rv</code></td>
<td>
<p>The index of the <code>M</code>-vertex region in <code class="reqn">T_b</code> containing the point, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(p2 \in N_{AS}(p1))</code> for points <code>p1</code> and <code>p2</code>, that is, returns 1 if <code class="reqn">p2</code> is in <code class="reqn">N_{AS}(p1)</code>
(i.e., if there is an arc from <code>p1</code> to <code>p2</code>), returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcAStri">IarcAStri</a></code> and <code><a href="#topic+NAStri">NAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.2)

P1&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)
P2&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)
IarcASbasic.tri(P1,P2,c1,c2,M)

P1&lt;-c(.3,.2)
P2&lt;-c(.6,.2)
IarcASbasic.tri(P1,P2,c1,c2,M)

#or try
Rv&lt;-rel.vert.basic.triCC(P1,c1,c2)$rv
IarcASbasic.tri(P1,P2,c1,c2,M,Rv)

P1&lt;-c(.3,.2)
P2&lt;-c(.8,.2)
IarcASbasic.tri(P1,P2,c1,c2,M)

P3&lt;-c(.5,.4)
IarcASbasic.tri(P1,P3,c1,c2,M)

P4&lt;-c(1.5,.4)
IarcASbasic.tri(P1,P4,c1,c2,M)
IarcASbasic.tri(P4,P4,c1,c2,M)

c1&lt;-.4; c2&lt;-.6;
P1&lt;-c(.3,.2)
P2&lt;-c(.6,.2)
IarcASbasic.tri(P1,P2,c1,c2,M)


</code></pre>

<hr>
<h2 id='IarcASset2pnt.tri'>The indicator for the presence of an arc from a point in set <code>S</code> to the point <code>p</code> for
Arc Slice Proximity Catch Digraphs (AS-PCDs) - one triangle case</h2><span id='topic+IarcASset2pnt.tri'></span>

<h3>Description</h3>

<p>Returns I(<code class="reqn">pt \in N_{AS}(x)</code> for some <code class="reqn">x \in S</code>), that is, returns 1 if <code class="reqn">p</code> is in <code class="reqn">\cup_{x \in S}N_{AS}(x)</code>,
returns 0 otherwise, where <code class="reqn">N_{AS}(x)</code> is the AS proximity region for point <code class="reqn">x</code>.
</p>
<p>AS proximity regions are constructed with respect to the triangle, <code>tri</code><code class="reqn">=T(A,B,C)=</code><code>(rv=1,rv=2,rv=3)</code>,
and vertices of <code>tri</code> are also labeled as 1,2, and 3, respectively.
</p>
<p>Vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
</p>
<p>If <code>p</code> is not in <code>S</code> and either <code>p</code> or all points in <code>S</code> are outside <code>tri</code>, it returns 0,
but if <code>p</code> is in <code>S</code>, then it always returns 1 (i.e., loops are allowed).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcASset2pnt.tri(S, p, tri, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcASset2pnt.tri_+3A_s">S</code></td>
<td>
<p>A set of 2D points whose AS proximity regions are considered.</p>
</td></tr>
<tr><td><code id="IarcASset2pnt.tri_+3A_p">p</code></td>
<td>
<p>A 2D point. The function determines whether <code>p</code> is inside the union of AS proximity
regions of points in <code>S</code> or not.</p>
</td></tr>
<tr><td><code id="IarcASset2pnt.tri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="IarcASset2pnt.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center in the interior of <code>tri</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(pt \in \cup_{x in S}N_{AS}(x,r))</code>, that is, returns 1 if <code>p</code> is in <code>S</code> or inside <code class="reqn">N_{AS}(x)</code> for at least
one <code class="reqn">x</code> in <code>S</code>, returns 0 otherwise, where AS proximity region is constructed in <code>tri</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcAStri">IarcAStri</a></code>, <code><a href="#topic+IarcASset2pnt.tri">IarcASset2pnt.tri</a></code>, and <code><a href="#topic+IarcCSset2pnt.tri">IarcCSset2pnt.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$gen.points

S&lt;-rbind(Xp[1,],Xp[2,])  #try also S&lt;-c(1.5,1)

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

IarcASset2pnt.tri(S,Xp[3,],Tr,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,])
IarcASset2pnt.tri(S,Xp[3,],Tr,M)

IarcASset2pnt.tri(S,Xp[6,],Tr,M)

S&lt;-rbind(c(.1,.1),c(.3,.4),c(.5,.3))
IarcASset2pnt.tri(S,Xp[3,],Tr,M)

IarcASset2pnt.tri(c(.2,.5),Xp[2,],Tr,M)
IarcASset2pnt.tri(Xp,c(.2,.5),Tr,M)
IarcASset2pnt.tri(Xp,Xp[2,],Tr,M)
IarcASset2pnt.tri(c(.2,.5),c(.2,.5),Tr,M)
IarcASset2pnt.tri(Xp[5,],Xp[2,],Tr,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,],c(.2,.5))
IarcASset2pnt.tri(S,Xp[3,],Tr,M)

P&lt;-c(.4,.2)
S&lt;-Xp[c(1,3,4),]
IarcASset2pnt.tri(Xp,P,Tr,M)
IarcASset2pnt.tri(S,P,Tr,M)

IarcASset2pnt.tri(rbind(S,S),P,Tr,M)


</code></pre>

<hr>
<h2 id='IarcAStri'>The indicator for the presence of an arc from a point to another for
Arc Slice Proximity Catch Digraphs (AS-PCDs) - one triangle case</h2><span id='topic+IarcAStri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(p2 \in N_{AS}(p1))</code> for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code class="reqn">p2</code> is in <code class="reqn">N_{AS}(p1)</code>, returns 0
otherwise, where <code class="reqn">N_{AS}(x)</code> is the AS proximity region for point <code class="reqn">x</code>.
</p>
<p>AS proximity regions are constructed with respect to the triangle,
<code>tri</code><code class="reqn">=T(A,B,C)=</code><code>(rv=1,rv=2,rv=3)</code>,
and vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
<code>rv</code> is the index of the vertex region <code>p1</code> resides,
with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct
and either of them are outside <code>tri</code>, the function returns 0,
but if they are identical,
then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcAStri(p1, p2, tri, M = "CC", rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcAStri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose AS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcAStri_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is
inside the AS proximity region of <code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcAStri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise,
each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="IarcAStri_+3A_m">M</code></td>
<td>
<p>The center of the triangle.
<code>"CC"</code> stands for circumcenter of the triangle <code>tri</code>
or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates
which serves as a center in the interior of <code>tri</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="IarcAStri_+3A_rv">rv</code></td>
<td>
<p>The index of the <code>M</code>-vertex region in <code>tri</code>
containing the point, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(p2 \in N_{AS}(p1))</code> for <code>p1</code>, that is,
returns 1 if <code class="reqn">p2</code> is in <code class="reqn">N_{AS}(p1)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcASbasic.tri">IarcASbasic.tri</a></code>, <code><a href="#topic+IarcPEtri">IarcPEtri</a></code>, and <code><a href="#topic+IarcCStri">IarcCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);

Tr&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

P1&lt;-as.numeric(runif.tri(1,Tr)$g)
P2&lt;-as.numeric(runif.tri(1,Tr)$g)
IarcAStri(P1,P2,Tr,M)

P1&lt;-c(1.3,1.2)
P2&lt;-c(1.8,.5)
IarcAStri(P1,P2,Tr,M)
IarcAStri(P1,P1,Tr,M)

#or try
Rv&lt;-rel.vert.triCC(P1,Tr)$rv
IarcAStri(P1,P2,Tr,M,Rv)

P3&lt;-c(1.6,1.4)
IarcAStri(P1,P3,Tr,M)

P4&lt;-c(1.5,1.0)
IarcAStri(P1,P4,Tr,M)

P5&lt;-c(.5,1.0)
IarcAStri(P1,P5,Tr,M)
IarcAStri(P5,P5,Tr,M)

#or try
Rv&lt;-rel.vert.triCC(P5,Tr)$rv
IarcAStri(P5,P5,Tr,M,Rv)


</code></pre>

<hr>
<h2 id='IarcCS.Te.onesixth'>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch
Digraphs (CS-PCDs) - first one-sixth of the standard equilateral triangle case</h2><span id='topic+IarcCS.Te.onesixth'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1))</code> for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1)</code>,
returns 0 otherwise, where <code class="reqn">N_{CS}(x,t=1)</code> is the CS proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">t=1</code>.
</p>
<p>CS proximity region is defined with respect to the standard equilateral triangle
<code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> and edge regions are based on the center of mass <code class="reqn">CM=(1/2,\sqrt{3}/6)</code>.
Here <code>p1</code> must lie in the first one-sixth of <code class="reqn">T_e</code>, which is the triangle with vertices <code class="reqn">T(A,D_3,CM)=T((0,0),(1/2,0),CM)</code>.
If <code>p1</code> and <code>p2</code> are distinct and <code>p1</code> is outside of <code class="reqn">T(A,D_3,CM)</code> or <code>p2</code> is outside <code class="reqn">T_e</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCS.Te.onesixth(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCS.Te.onesixth_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCS.Te.onesixth_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1))</code> for <code>p1</code> in the first one-sixth of <code class="reqn">T_e</code>,
<code class="reqn">T(A,D_3,CM)</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSstd.tri">IarcCSstd.tri</a></code>
</p>

<hr>
<h2 id='IarcCSbasic.tri'>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch
Digraphs (CS-PCDs) - standard basic triangle case</h2><span id='topic+IarcCSbasic.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>,
returns 0 otherwise, where <code class="reqn">N_{CS}(x,t)</code> is the CS proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">r \ge 1</code>.
</p>
<p>CS proximity region is defined with respect to the standard basic triangle <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Edge regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in
barycentric coordinates in the interior of the standard basic triangle <code class="reqn">T_b</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_b</code>.
<code>re</code> is the index of the edge region <code>p1</code> resides, with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are outside <code class="reqn">T_b</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions (i.e., translation, rotation, and reflection) and scaling,
preserving uniformity of the points in the original triangle. Hence standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSbasic.tri(p1, p2, t, c1, c2, M = c(1, 1, 1), re = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSbasic.tri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCSbasic.tri_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcCSbasic.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region; must be <code class="reqn">\ge 1</code></p>
</td></tr>
<tr><td><code id="IarcCSbasic.tri_+3A_c1">c1</code>, <code id="IarcCSbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers which constitute the vertex of the standard basic triangle
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="IarcCSbasic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the standard basic triangle or circumcenter of <code class="reqn">T_b</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="IarcCSbasic.tri_+3A_re">re</code></td>
<td>
<p>The index of the edge region in <code class="reqn">T_b</code> containing the point, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>,
returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCStri">IarcCStri</a></code> and <code><a href="#topic+IarcCSstd.tri">IarcCSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)

tau&lt;-2

P1&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)
P2&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)
IarcCSbasic.tri(P1,P2,tau,c1,c2,M)

P1&lt;-c(.4,.2)
P2&lt;-c(.5,.26)
IarcCSbasic.tri(P1,P2,tau,c1,c2,M)
IarcCSbasic.tri(P1,P1,tau,c1,c2,M)

#or try
Re&lt;-rel.edge.basic.tri(P1,c1,c2,M)$re
IarcCSbasic.tri(P1,P2,tau,c1,c2,M,Re)
IarcCSbasic.tri(P1,P1,tau,c1,c2,M,Re)


</code></pre>

<hr>
<h2 id='IarcCSedge.reg.std.tri'>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch
Digraphs (CS-PCDs) - standard equilateral triangle case</h2><span id='topic+IarcCSedge.reg.std.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>,
returns 0 otherwise, where <code class="reqn">N_{CS}(x,t)</code> is the CS proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">t&gt;0</code>.
This function is equivalent to <code>IarcCSstd.tri</code>, except that it computes the indicator using the functions
<code>IarcCSstd.triRAB</code>, <code>IarcCSstd.triRBC</code> and <code>IarcCSstd.triRAC</code> which are edge-region specific indicator functions.
For example,
<code>IarcCSstd.triRAB</code> computes <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for points <code>p1</code> and <code>p2</code> when <code>p1</code>
resides in the edge region of edge <code class="reqn">AB</code>.
</p>
<p>CS proximity region is defined with respect to the standard equilateral triangle
<code class="reqn">T_e=T(v=1,v=2,v=3)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_e</code>.
<code>re</code> is the index of the edge region <code>p1</code> resides, with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are outside <code class="reqn">T_e</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSedge.reg.std.tri(p1, p2, t, M = c(1, 1, 1), re = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSedge.reg.std.tri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCSedge.reg.std.tri_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcCSedge.reg.std.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="IarcCSedge.reg.std.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the standard equilateral triangle <code class="reqn">T_e</code>; default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code id="IarcCSedge.reg.std.tri_+3A_re">re</code></td>
<td>
<p>The index of the edge region in <code class="reqn">T_e</code> containing the point, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for <code>p1</code>,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCStri">IarcCStri</a></code> and <code><a href="#topic+IarcPEstd.tri">IarcPEstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-3

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

t&lt;-1
IarcCSedge.reg.std.tri(Xp[1,],Xp[2,],t,M)
IarcCSstd.tri(Xp[1,],Xp[2,],t,M)

#or try
re&lt;-rel.edge.std.triCM(Xp[1,])$re
IarcCSedge.reg.std.tri(Xp[1,],Xp[2,],t,M,re=re)


</code></pre>

<hr>
<h2 id='IarcCSend.int'>The indicator for the presence of an arc from a point to another for
Central Similarity Proximity Catch Digraphs (CS-PCDs) - end-interval case</h2><span id='topic+IarcCSend.int'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(p_2</code> in <code class="reqn">N_{CS}(p_1,t))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>, that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{CS}(p_1,t)</code>, returns 0
otherwise, where <code class="reqn">N_{CS}(x,t)</code> is the CS proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">t&gt;0</code>
for the region outside the interval <code class="reqn">(a,b)</code>.
</p>
<p><code>rv</code> is the index of the end vertex region <code class="reqn">p_1</code> resides, with default=<code>NULL</code>,
and <code>rv=1</code> for left end-interval and <code>rv=2</code> for the right end-interval.
If <code class="reqn">p_1</code> and <code class="reqn">p_2</code> are distinct and either of them are inside interval <code>int</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSend.int(p1, p2, int, t, rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSend.int_+3A_p1">p1</code></td>
<td>
<p>A 1D point for which the CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCSend.int_+3A_p2">p2</code></td>
<td>
<p>A 1D point to check whether it is inside the proximity region or not.</p>
</td></tr>
<tr><td><code id="IarcCSend.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="IarcCSend.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="IarcCSend.int_+3A_rv">rv</code></td>
<td>
<p>Index of the end-interval containing the point, either <code>1,2</code> or <code>NULL</code> (default=<code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(p_2</code> in <code class="reqn">N_{CS}(p_1,t))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>, that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{CS}(p_1,t)</code>
(i.e., if there is an arc from <code class="reqn">p_1</code> to <code class="reqn">p_2</code>), returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSmid.int">IarcCSmid.int</a></code>, <code><a href="#topic+IarcPEmid.int">IarcPEmid.int</a></code>, and <code><a href="#topic+IarcPEend.int">IarcPEend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-0; b&lt;-10; int&lt;-c(a,b)
t&lt;-2

IarcCSend.int(15,17,int,t)
IarcCSend.int(15,15,int,t)

IarcCSend.int(1.5,17,int,t)
IarcCSend.int(1.5,1.5,int,t)

IarcCSend.int(-15,17,int,t)

IarcCSend.int(-15,-17,int,t)

a&lt;-0; b&lt;-10; int&lt;-c(a,b)
t&lt;-.5

IarcCSend.int(15,17,int,t)

</code></pre>

<hr>
<h2 id='IarcCSint'>The indicator for the presence of an arc from a point to another for
Central Similarity  Proximity Catch Digraphs (CS-PCDs) - one interval case</h2><span id='topic+IarcCSint'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(p_2</code> in <code class="reqn">N_{CS}(p_1,t,c))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>, that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{CS}(p_1,t,c)</code>,
returns 0 otherwise, where <code class="reqn">N_{CS}(x,t,c)</code> is the CS proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">t&gt;0</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>CS proximity region is constructed with respect to the
interval <code class="reqn">(a,b)</code>. This function works whether <code class="reqn">p_1</code> and <code class="reqn">p_2</code> are inside or outside the interval <code>int</code>.
</p>
<p>Vertex regions for middle intervals are based on the center associated with the centrality parameter
<code class="reqn">c \in (0,1)</code>. If <code class="reqn">p_1</code> and <code class="reqn">p_2</code> are identical, then it returns 1 regardless of their locations
(i.e., loops are allowed in the digraph).
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSint(p1, p2, int, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSint_+3A_p1">p1</code></td>
<td>
<p>A 1D point for which the proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCSint_+3A_p2">p2</code></td>
<td>
<p>A 1D point for which it is checked whether it resides in the proximity region
of <code class="reqn">p_1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcCSint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="IarcCSint_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="IarcCSint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(p_2</code> in <code class="reqn">N_{CS}(p_1,t,c))</code> for p2, that is, returns 1 if <code class="reqn">p_2</code> in <code class="reqn">N_{CS}(p_1,t,c)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSmid.int">IarcCSmid.int</a></code>, <code><a href="#topic+IarcCSend.int">IarcCSend.int</a></code> and <code><a href="#topic+IarcPEint">IarcPEint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
t&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

IarcCSint(7,5,int,t,c)
IarcCSint(17,17,int,t,c)
IarcCSint(15,17,int,t,c)
IarcCSint(1,3,int,t,c)

IarcCSint(-17,17,int,t,c)

IarcCSint(3,5,int,t,c)
IarcCSint(3,3,int,t,c)
IarcCSint(4,5,int,t,c)
IarcCSint(a,5,int,t,c)

c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

IarcCSint(7,5,int,t,c)

</code></pre>

<hr>
<h2 id='IarcCSmid.int'>The indicator for the presence of an arc from a point to another for Central Similarity
Proximity Catch Digraphs (CS-PCDs) - middle interval case</h2><span id='topic+IarcCSmid.int'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(p_2</code> in <code class="reqn">N_{CS}(p_1,t,c))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>, that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{CS}(p_1,t,c)</code>, returns 0
otherwise, where <code class="reqn">N_{CS}(x,t,c)</code> is the CS proximity region for point <code class="reqn">x</code> and is constructed with expansion
parameter <code class="reqn">t&gt;0</code> and centrality parameter <code class="reqn">c \in (0,1)</code> for the interval <code class="reqn">(a,b)</code>.
</p>
<p>CS proximity regions are defined with respect to the middle interval <code>int</code> and vertex regions are based
on the center associated with the centrality parameter <code class="reqn">c \in (0,1)</code>. For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the
parameterized center is <code class="reqn">M_c=a+c(b-a)</code>. <code>rv</code> is the index of the vertex region <code class="reqn">p_1</code> resides, with default=<code>NULL</code>.
</p>
<p>If <code class="reqn">p_1</code> and <code class="reqn">p_2</code> are distinct and either of them are outside interval <code>int</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations
(i.e., loops are allowed in the digraph).
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSmid.int(p1, p2, int, t, c = 0.5, rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSmid.int_+3A_p1">p1</code>, <code id="IarcCSmid.int_+3A_p2">p2</code></td>
<td>
<p>1D points; <code class="reqn">p_1</code> is the point for which the proximity region, <code class="reqn">N_{CS}(p_1,t,c)</code> is
constructed and <code class="reqn">p_2</code> is the point which the function is checking whether its inside
<code class="reqn">N_{CS}(p_1,t,c)</code> or not.</p>
</td></tr>
<tr><td><code id="IarcCSmid.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="IarcCSmid.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="IarcCSmid.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="IarcCSmid.int_+3A_rv">rv</code></td>
<td>
<p>Index of the end-interval containing the point, either <code>1,2</code> or <code>NULL</code> (default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(p_2</code> in <code class="reqn">N_{CS}(p_1,t,c))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code> that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{CS}(p_1,t,c)</code>,
returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSend.int">IarcCSend.int</a></code>, <code><a href="#topic+IarcPEmid.int">IarcPEmid.int</a></code>, and <code><a href="#topic+IarcPEend.int">IarcPEend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.5
t&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

IarcCSmid.int(7,5,int,t,c)
IarcCSmid.int(7,7,int,t,c)
IarcCSmid.int(7,5,int,t,c=.4)

IarcCSmid.int(1,3,int,t,c)

IarcCSmid.int(9,11,int,t,c)

IarcCSmid.int(19,1,int,t,c)
IarcCSmid.int(19,19,int,t,c)

IarcCSmid.int(3,5,int,t,c)

#or try
Rv&lt;-rel.vert.mid.int(3,int,c)$rv
IarcCSmid.int(3,5,int,t,c,rv=Rv)

IarcCSmid.int(7,5,int,t,c)

</code></pre>

<hr>
<h2 id='IarcCSset2pnt.std.tri'>The indicator for the presence of an arc from a point in set <code>S</code> to the point <code>p</code> for Central Similarity
Proximity Catch Digraphs (CS-PCDs) - standard equilateral triangle case</h2><span id='topic+IarcCSset2pnt.std.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> in <code class="reqn">N_{CS}(x,t)</code> for some <code class="reqn">x</code> in <code>S</code><code class="reqn">)</code>, that is, returns 1 if <code>p</code> is in <code class="reqn">\cup_{x in S} N_{CS}(x,t)</code>,
returns 0 otherwise, CS proximity region is constructed with respect to the standard equilateral triangle
<code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> with the expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based
on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the
interior of <code class="reqn">T_e</code>; default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_e</code> (which is equivalent to circumcenter of <code class="reqn">T_e</code>).
</p>
<p>Edges of <code class="reqn">T_e</code>, <code class="reqn">AB</code>, <code class="reqn">BC</code>, <code class="reqn">AC</code>, are also labeled as edges 3, 1, and 2, respectively.
If <code>p</code> is not in <code>S</code> and either <code>p</code> or all points in <code>S</code> are outside <code class="reqn">T_e</code>, it returns 0,
but if <code>p</code> is in <code>S</code>, then it always returns 1 regardless of its location (i.e., loops are allowed).
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSset2pnt.std.tri(S, p, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSset2pnt.std.tri_+3A_s">S</code></td>
<td>
<p>A set of 2D points. Presence of an arc from a point in <code>S</code> to point <code>p</code> is checked
by the function.</p>
</td></tr>
<tr><td><code id="IarcCSset2pnt.std.tri_+3A_p">p</code></td>
<td>
<p>A 2D point. Presence of an arc from a point in <code>S</code> to point <code>p</code> is checked
by the function.</p>
</td></tr>
<tr><td><code id="IarcCSset2pnt.std.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region in the
standard equilateral triangle <code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>.</p>
</td></tr>
<tr><td><code id="IarcCSset2pnt.std.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the standard equilateral triangle <code class="reqn">T_e</code>; default is <code class="reqn">M=(1,1,1)</code>
i.e., the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is in <code class="reqn">\cup_{x in S} N_{CS}(x,t))</code>, that is, returns 1 if <code>p</code> is in <code>S</code> or inside <code class="reqn">N_{CS}(x,t)</code> for at least
one <code class="reqn">x</code> in <code>S</code>, returns 0 otherwise. CS proximity region is constructed with respect to the standard
equilateral triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> with <code>M</code>-edge regions.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSset2pnt.tri">IarcCSset2pnt.tri</a></code>, <code><a href="#topic+IarcCSstd.tri">IarcCSstd.tri</a></code>, <code><a href="#topic+IarcCStri">IarcCStri</a></code>, and <code><a href="#topic+IarcPEset2pnt.std.tri">IarcPEset2pnt.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

t&lt;-.5

S&lt;-rbind(Xp[1,],Xp[2,])  #try also S&lt;-c(.5,.5)
IarcCSset2pnt.std.tri(S,Xp[3,],t,M)
IarcCSset2pnt.std.tri(S,Xp[3,],t=1,M)
IarcCSset2pnt.std.tri(S,Xp[3,],t=1.5,M)

S&lt;-rbind(c(.1,.1),c(.3,.4),c(.5,.3))
IarcCSset2pnt.std.tri(S,Xp[3,],t,M)


</code></pre>

<hr>
<h2 id='IarcCSset2pnt.tri'>The indicator for the presence of an arc from a point in set <code>S</code> to the point <code>p</code> for
Central Similarity Proximity Catch Digraphs (CS-PCDs) - one triangle case</h2><span id='topic+IarcCSset2pnt.tri'></span>

<h3>Description</h3>

<p>Returns I(<code>p</code> in <code class="reqn">N_{CS}(x,t)</code> for some <code class="reqn">x</code> in <code>S</code>),
that is, returns 1 if <code>p</code> in <code class="reqn">\cup_{x in S} N_{CS}(x,t)</code>,
returns 0 otherwise.
</p>
<p>CS proximity region is constructed with respect to the triangle <code>tri</code> with
the expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
</p>
<p>Edges of <code>tri</code><code class="reqn">=T(A,B,C)</code>, <code class="reqn">AB</code>, <code class="reqn">BC</code>, <code class="reqn">AC</code>, are also labeled as edges 3, 1, and 2, respectively.
If <code>p</code> is not in <code>S</code> and either <code>p</code> or all points in <code>S</code> are outside <code>tri</code>, it returns 0,
but if <code>p</code> is in <code>S</code>, then it always returns 1 regardless of its location (i.e., loops are allowed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSset2pnt.tri(S, p, tri, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSset2pnt.tri_+3A_s">S</code></td>
<td>
<p>A set of 2D points. Presence of an arc from a point in <code>S</code> to point <code>p</code> is checked
by the function.</p>
</td></tr>
<tr><td><code id="IarcCSset2pnt.tri_+3A_p">p</code></td>
<td>
<p>A 2D point. Presence of an arc from a point in <code>S</code> to point <code>p</code> is checked
by the function.</p>
</td></tr>
<tr><td><code id="IarcCSset2pnt.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="IarcCSset2pnt.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region
constructed in the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code id="IarcCSset2pnt.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>I(<code>p</code> is in <code class="reqn">\cup_{x in S} N_{CS}(x,t)</code>), that is, returns 1 if <code>p</code> is in <code>S</code> or inside <code class="reqn">N_{CS}(x,t)</code> for at least
one <code class="reqn">x</code> in <code>S</code>, returns 0 otherwise where CS proximity region is constructed with respect to the triangle <code>tri</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSset2pnt.std.tri">IarcCSset2pnt.std.tri</a></code>, <code><a href="#topic+IarcCStri">IarcCStri</a></code>, <code><a href="#topic+IarcCSstd.tri">IarcCSstd.tri</a></code>,
<code><a href="#topic+IarcASset2pnt.tri">IarcASset2pnt.tri</a></code>, and <code><a href="#topic+IarcPEset2pnt.tri">IarcPEset2pnt.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$gen.points

S&lt;-rbind(Xp[1,],Xp[2,])  #try also S&lt;-c(1.5,1)

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

tau&lt;-.5

IarcCSset2pnt.tri(S,Xp[3,],Tr,tau,M)
IarcCSset2pnt.tri(S,Xp[3,],Tr,t=1,M)
IarcCSset2pnt.tri(S,Xp[3,],Tr,t=1.5,M)

S&lt;-rbind(c(.1,.1),c(.3,.4),c(.5,.3))
IarcCSset2pnt.tri(S,Xp[3,],Tr,tau,M)


</code></pre>

<hr>
<h2 id='IarcCSstd.tri'>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch
Digraphs (CS-PCDs) - standard equilateral triangle case</h2><span id='topic+IarcCSstd.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>,
returns 0 otherwise, where <code class="reqn">N_{CS}(x,t)</code> is the CS proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">t &gt;0</code>.
</p>
<p>CS proximity region is defined with respect to the standard equilateral triangle
<code class="reqn">T_e=T(v=1,v=2,v=3)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> and vertex regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_e</code>.
<code>rv</code> is the index of the vertex region <code>p1</code> resides, with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are outside <code class="reqn">T_e</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSstd.tri(p1, p2, t, M = c(1, 1, 1), re = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSstd.tri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCSstd.tri_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcCSstd.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="IarcCSstd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the standard equilateral triangle <code class="reqn">T_e</code>; default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code id="IarcCSstd.tri_+3A_re">re</code></td>
<td>
<p>The index of the edge region in <code class="reqn">T_e</code> containing the point, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for points <code>p1</code> and <code>p2</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>,
returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCStri">IarcCStri</a></code>, <code><a href="#topic+IarcCSbasic.tri">IarcCSbasic.tri</a></code>, and <code><a href="#topic+IarcPEstd.tri">IarcPEstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
n&lt;-3

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2) or M=(A+B+C)/3

IarcCSstd.tri(Xp[1,],Xp[3,],t=2,M)
IarcCSstd.tri(c(0,1),Xp[3,],t=2,M)

#or try
Re&lt;-rel.edge.tri(Xp[1,],Te,M) $re
IarcCSstd.tri(Xp[1,],Xp[3,],t=2,M,Re)


</code></pre>

<hr>
<h2 id='IarcCSt1.std.tri'>The indicator for the presence of an arc from a point to another for Central Similarity Proximity Catch
Digraphs (CS-PCDs) - standard equilateral triangle case with <code class="reqn">t=1</code></h2><span id='topic+IarcCSt1.std.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1))</code> for points <code>p1</code> and <code>p2</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1)</code>,
returns 0 otherwise, where <code class="reqn">N_{CS}(x,t=1)</code> is the CS proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">t=1</code>.
</p>
<p>CS proximity region is defined with respect to the standard equilateral triangle
<code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> and edge regions are based on the center of mass <code class="reqn">CM=(1/2,\sqrt{3}/6)</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either are outside <code class="reqn">T_e</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCSt1.std.tri(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCSt1.std.tri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCSt1.std.tri_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t=1))</code> for <code>p1</code> in <code class="reqn">T_e</code> that is, returns 1 if <code>p2</code>
is in <code class="reqn">N_{CS}(p1,t=1)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcCSstd.tri">IarcCSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-3

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

IarcCSt1.std.tri(Xp[1,],Xp[2,])
IarcCSt1.std.tri(c(.2,.5),Xp[2,])


</code></pre>

<hr>
<h2 id='IarcCStri'>The indicator for the presence of an arc from one point to another for Central Similarity Proximity
Catch Digraphs (CS-PCDs)</h2><span id='topic+IarcCStri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for points <code>p1</code> and <code>p2</code>, that is,
returns 1 if <code>p2</code> is in <code class="reqn">NCS(p1,t)</code>,
returns 0 otherwise, where <code class="reqn">N_{CS}(x,t)</code> is the CS proximity region for point <code class="reqn">x</code> with the expansion parameter <code class="reqn">t&gt;0</code>.
</p>
<p>CS proximity region is constructed with respect to the triangle <code>tri</code> and
edge regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code>tri</code>
or based on the circumcenter of <code>tri</code>.
<code>re</code> is the index of the edge region <code>p</code> resides, with default=<code>NULL</code>
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are outside <code>tri</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCStri(p1, p2, tri, t, M, re = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCStri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCStri_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcCStri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="IarcCStri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="IarcCStri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code id="IarcCStri_+3A_re">re</code></td>
<td>
<p>Index of the <code>M</code>-edge region containing the point <code>p</code>,
either <code>1,2,3</code> or <code>NULL</code> (default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>I(<code>p2</code> is in <code class="reqn">NCS(p1,t)</code>) for <code>p1</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">NCS(p1,t)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcAStri">IarcAStri</a></code>, <code><a href="#topic+IarcPEtri">IarcPEtri</a></code>, <code><a href="#topic+IarcCStri">IarcCStri</a></code>, and <code><a href="#topic+IarcCSstd.tri">IarcCSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
tau&lt;-1.5

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

n&lt;-10
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

IarcCStri(Xp[1,],Xp[2,],Tr,tau,M)

P1&lt;-as.numeric(runif.tri(1,Tr)$g)
P2&lt;-as.numeric(runif.tri(1,Tr)$g)
IarcCStri(P1,P2,Tr,tau,M)

#or try
re&lt;-rel.edges.tri(P1,Tr,M)$re
IarcCStri(P1,P2,Tr,tau,M,re)


</code></pre>

<hr>
<h2 id='IarcCStri.alt'>An alternative to the function <code><a href="#topic+IarcCStri">IarcCStri</a></code> which yields the indicator
for the presence of an arc from one point to another
for Central Similarity Proximity Catch Digraphs (CS-PCDs)</h2><span id='topic+IarcCStri.alt'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for points <code>p1</code> and <code>p2</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>,
returns 0 otherwise, where <code class="reqn">N_{CS}(x,t)</code> is the CS proximity region for point <code class="reqn">x</code> with the expansion parameter <code class="reqn">t&gt;0</code>.
</p>
<p>CS proximity region is constructed with respect to the triangle <code>tri</code> and edge regions are based on the
center of mass, <code class="reqn">CM</code>. <code>re</code> is the index of the <code class="reqn">CM</code>-edge region <code>p</code> resides, with default=<code>NULL</code> but must be provided as
vertices <code class="reqn">(y_1,y_2,y_3)</code> for <code class="reqn">re=3</code> as rbind(y2,y3,y1) for <code class="reqn">re=1</code> and as rbind(y1,y3,y2) for <code class="reqn">re=2</code> for triangle <code class="reqn">T(y_1,y_2,y_3)</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are outside <code>tri</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcCStri.alt(p1, p2, tri, t, re = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcCStri.alt_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcCStri.alt_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines whether <code>p2</code> is inside the CS proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcCStri.alt_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="IarcCStri.alt_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="IarcCStri.alt_+3A_re">re</code></td>
<td>
<p>Index of the <code class="reqn">CM</code>-edge region containing the point <code>p</code>,
either <code>1,2,3</code> or <code>NULL</code>, default=<code>NULL</code> but
must be provided (row-wise) as vertices <code class="reqn">(y_1,y_2,y_3)</code> for <code>re=3</code> as <code class="reqn">(y_2,y_3,y_1)</code> for
<code>re=1</code> and as <code class="reqn">(y_1,y_3,y_2)</code> for <code>re=2</code> for triangle <code class="reqn">T(y_1,y_2,y_3)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{CS}(p1,t))</code> for <code>p1</code>, that is,
returns 1 if <code>p2</code> is in <code class="reqn">N_{CS}(p1,t)</code>, returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcAStri">IarcAStri</a></code>, <code><a href="#topic+IarcPEtri">IarcPEtri</a></code>, <code><a href="#topic+IarcCStri">IarcCStri</a></code>, and <code><a href="#topic+IarcCSstd.tri">IarcCSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.6,2);
Tr&lt;-rbind(A,B,C);
t&lt;-1.5

P1&lt;-c(.4,.2)
P2&lt;-c(1.8,.5)
IarcCStri(P1,P2,Tr,t,M=c(1,1,1))
IarcCStri.alt(P1,P2,Tr,t)

IarcCStri(P2,P1,Tr,t,M=c(1,1,1))
IarcCStri.alt(P2,P1,Tr,t)

#or try
re&lt;-rel.edges.triCM(P1,Tr)$re
IarcCStri(P1,P2,Tr,t,M=c(1,1,1),re)
IarcCStri.alt(P1,P2,Tr,t,re)


</code></pre>

<hr>
<h2 id='IarcPEbasic.tri'>The indicator for the presence of an arc from a point to another for
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard basic triangle case</h2><span id='topic+IarcPEbasic.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code>
for points <code>p1</code> and <code>p2</code>
in the standard basic triangle,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
and returns 0 otherwise,
where <code class="reqn">N_{PE}(x,r)</code> is the PE proximity region
for point <code class="reqn">x</code> with expansion parameter <code class="reqn">r \ge 1</code>.
</p>
<p>PE proximity region is defined
with respect to the standard basic triangle
<code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Vertex regions are based on the center,
<code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in
barycentric coordinates
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or based on circumcenter of <code class="reqn">T_b</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code class="reqn">T_b</code>.
<code>rv</code> is the index of the vertex region <code>p1</code> resides,
with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are
outside <code class="reqn">T_b</code>, it returns 0,
but if they are identical,
then it returns 1 regardless of their locations
(i.e., it allows loops).
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the original triangle.
Hence, standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2006)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEbasic.tri(p1, p2, r, c1, c2, M = c(1, 1, 1), rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEbasic.tri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose PE proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcPEbasic.tri_+3A_p2">p2</code></td>
<td>
<p>A 2D point.
The function determines whether <code>p2</code> is
inside the PE proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcPEbasic.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code></p>
</td></tr>
<tr><td><code id="IarcPEbasic.tri_+3A_c1">c1</code>, <code id="IarcPEbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle
adjacent to the shorter edges;
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEbasic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard basic triangle
or circumcenter of <code class="reqn">T_b</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="IarcPEbasic.tri_+3A_rv">rv</code></td>
<td>
<p>The index of the vertex region in <code class="reqn">T_b</code> containing the point,
either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code>
for points <code>p1</code> and <code>p2</code> in the standard basic triangle,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
and returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEtri">IarcPEtri</a></code> and <code><a href="#topic+IarcPEstd.tri">IarcPEstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)

r&lt;-2

P1&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)
P2&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)
IarcPEbasic.tri(P1,P2,r,c1,c2,M)

P1&lt;-c(.4,.2)
P2&lt;-c(.5,.26)
IarcPEbasic.tri(P1,P2,r,c1,c2,M)
IarcPEbasic.tri(P2,P1,r,c1,c2,M)

#or try
Rv&lt;-rel.vert.basic.tri(P1,c1,c2,M)$rv
IarcPEbasic.tri(P1,P2,r,c1,c2,M,Rv)


</code></pre>

<hr>
<h2 id='IarcPEend.int'>The indicator for the presence of an arc from a point to another for
Proportional Edge Proximity Catch Digraphs (PE-PCDs) - end-interval case</h2><span id='topic+IarcPEend.int'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(p_2 \in N_{PE}(p_1,r))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>, that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{PE}(p_1,r)</code>, returns 0
otherwise, where <code class="reqn">N_{PE}(x,r)</code> is the PE proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">r \ge 1</code>
for the region outside the interval <code class="reqn">(a,b)</code>.
</p>
<p><code>rv</code> is the index of the end vertex region <code class="reqn">p_1</code> resides, with default=<code>NULL</code>,
and <code>rv=1</code> for left end-interval and <code>rv=2</code> for the right end-interval.
If <code class="reqn">p_1</code> and <code class="reqn">p_2</code> are distinct and either of them are inside interval <code>int</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEend.int(p1, p2, int, r, rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEend.int_+3A_p1">p1</code></td>
<td>
<p>A 1D point whose PE proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcPEend.int_+3A_p2">p2</code></td>
<td>
<p>A 1D point. The function determines whether <code class="reqn">p_2</code> is inside the PE proximity region of
<code class="reqn">p_1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcPEend.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="IarcPEend.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEend.int_+3A_rv">rv</code></td>
<td>
<p>Index of the end-interval containing the point, either <code>1,2</code> or <code>NULL</code> (default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(p_2 \in N_{PE}(p_1,r))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>, that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{PE}(p_1,r)</code>
(i.e., if there is an arc from <code class="reqn">p_1</code> to <code class="reqn">p_2</code>), returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEmid.int">IarcPEmid.int</a></code>, <code><a href="#topic+IarcCSmid.int">IarcCSmid.int</a></code>, and <code><a href="#topic+IarcCSend.int">IarcCSend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-0; b&lt;-10; int&lt;-c(a,b)
r&lt;-2

IarcPEend.int(15,17,int,r)
IarcPEend.int(1.5,17,int,r)
IarcPEend.int(-15,17,int,r)

</code></pre>

<hr>
<h2 id='IarcPEint'>The indicator for the presence of an arc from a point to another for
Proportional Edge Proximity Catch Digraphs (PE-PCDs) - one interval case</h2><span id='topic+IarcPEint'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(p_2 \in N_{PE}(p_1,r,c))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>, that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{PE}(p_1,r,c)</code>,
returns 0 otherwise, where <code class="reqn">N_{PE}(x,r,c)</code> is the PE proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">r \ge 1</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>PE proximity region is constructed with respect to the
interval <code class="reqn">(a,b)</code>. This function works whether <code class="reqn">p_1</code> and <code class="reqn">p_2</code> are inside or outside the interval <code>int</code>.
</p>
<p>Vertex regions for middle intervals are based on the center associated with the centrality parameter <code class="reqn">c \in (0,1)</code>.
If <code class="reqn">p_1</code> and <code class="reqn">p_2</code> are identical, then it returns 1 regardless of their locations
(i.e., loops are allowed in the digraph).
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEint(p1, p2, int, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEint_+3A_p1">p1</code></td>
<td>
<p>A 1D point for which the proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcPEint_+3A_p2">p2</code></td>
<td>
<p>A 1D point for which it is checked whether it resides in the proximity region
of <code class="reqn">p_1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcPEint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="IarcPEint_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(p_2 \in N_{PE}(p_1,r,c))</code>, that is, returns 1 if <code class="reqn">p_2</code> in <code class="reqn">N_{PE}(p_1,r,c)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEmid.int">IarcPEmid.int</a></code>, <code><a href="#topic+IarcPEend.int">IarcPEend.int</a></code> and <code><a href="#topic+IarcCSint">IarcCSint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

IarcPEint(7,5,int,r,c)
IarcPEint(15,17,int,r,c)
IarcPEint(1,3,int,r,c)

</code></pre>

<hr>
<h2 id='IarcPEmid.int'>The indicator for the presence of an arc from a point to another for Proportional Edge
Proximity Catch Digraphs (PE-PCDs) - middle interval case</h2><span id='topic+IarcPEmid.int'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(p_2 \in N_{PE}(p_1,r,c))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>, that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{PE}(p_1,r,c)</code>, returns 0
otherwise, where <code class="reqn">N_{PE}(x,r,c)</code> is the PE proximity region for point <code class="reqn">x</code> and is constructed with expansion
parameter <code class="reqn">r \ge 1</code> and centrality parameter <code class="reqn">c \in (0,1)</code> for the interval <code class="reqn">(a,b)</code>.
</p>
<p>PE proximity regions are defined with respect to the middle interval <code>int</code> and vertex regions are based
on the center associated with the centrality parameter <code class="reqn">c \in (0,1)</code>. For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the
parameterized center is <code class="reqn">M_c=a+c(b-a)</code>. <code>rv</code> is the index of the vertex region <code class="reqn">p_1</code> resides, with default=<code>NULL</code>.
If <code class="reqn">p_1</code> and <code class="reqn">p_2</code> are distinct and either of them are outside interval <code>int</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations
(i.e., loops are allowed in the digraph).
</p>
<p>See also (Ceyhan (2012, 2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEmid.int(p1, x2, int, r, c = 0.5, rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEmid.int_+3A_p1">p1</code>, <code id="IarcPEmid.int_+3A_x2">x2</code></td>
<td>
<p>1D points; <code class="reqn">p_1</code> is the point for which the proximity region, <code class="reqn">N_{PE}(p_1,r,c)</code> is
constructed and <code class="reqn">p_2</code> is the point which the function is checking whether its inside
<code class="reqn">N_{PE}(p_1,r,c)</code> or not.</p>
</td></tr>
<tr><td><code id="IarcPEmid.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="IarcPEmid.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEmid.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="IarcPEmid.int_+3A_rv">rv</code></td>
<td>
<p>The index of the vertex region <code class="reqn">p_1</code> resides, with default=<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(p_2 \in N_{PE}(p_1,r,c))</code> for points <code class="reqn">p_1</code> and <code class="reqn">p_2</code> that is, returns 1 if <code class="reqn">p_2</code> is in <code class="reqn">N_{PE}(p_1,r,c)</code>,
returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.<br /><br /> Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEend.int">IarcPEend.int</a></code>, <code><a href="#topic+IarcCSmid.int">IarcCSmid.int</a></code>, and <code><a href="#topic+IarcCSend.int">IarcCSend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

IarcPEmid.int(7,5,int,r,c)
IarcPEmid.int(1,3,int,r,c)

</code></pre>

<hr>
<h2 id='IarcPEset2pnt.std.tri'>The indicator for the presence of an arc from a point
in set <code>S</code> to the point <code>p</code> or
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard equilateral triangle case</h2><span id='topic+IarcPEset2pnt.std.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> in <code class="reqn">N_{PE}(x,r)</code>
for some <code class="reqn">x</code> in <code>S</code><code class="reqn">)</code>
for <code>S</code>, in the standard equilateral triangle,
that is, returns 1 if <code>p</code> is in <code class="reqn">\cup_{x in S}N_{PE}(x,r)</code>,
and returns 0 otherwise.
</p>
<p>PE proximity region is constructed
with respect to the standard equilateral triangle
<code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
with the expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based
on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code>,
i.e., the center of mass of <code class="reqn">T_e</code>
(which is equivalent to the circumcenter for <code class="reqn">T_e</code>).
</p>
<p>Vertices of <code class="reqn">T_e</code> are also labeled as 1, 2, and 3,
respectively.
If <code>p</code> is not in <code>S</code> and either <code>p</code>
or all points in <code>S</code> are outside <code class="reqn">T_e</code>, it returns 0,
but if <code>p</code> is in <code>S</code>,
then it always returns 1 regardless of its location
(i.e., loops are allowed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEset2pnt.std.tri(S, p, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEset2pnt.std.tri_+3A_s">S</code></td>
<td>
<p>A set of 2D points.
Presence of an arc from a point in <code>S</code> to point <code>p</code> is checked
by the function.</p>
</td></tr>
<tr><td><code id="IarcPEset2pnt.std.tri_+3A_p">p</code></td>
<td>
<p>A 2D point.
Presence of an arc from a point in <code>S</code> to point <code>p</code> is checked
by the function.</p>
</td></tr>
<tr><td><code id="IarcPEset2pnt.std.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region in the
standard equilateral triangle <code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEset2pnt.std.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard equilateral triangle <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code>
i.e., the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is in <code class="reqn">U_{x in S} N_{PE}(x,r))</code>
for <code>S</code> in the standard equilateral triangle,
that is, returns 1 if <code>p</code> is in <code>S</code>
or inside <code class="reqn">N_{PE}(x,r)</code> for at least
one <code class="reqn">x</code> in <code>S</code>, and returns 0 otherwise.
PE proximity region is constructed with respect to the standard
equilateral triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
with <code>M</code>-vertex regions
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEset2pnt.tri">IarcPEset2pnt.tri</a></code>, <code><a href="#topic+IarcPEstd.tri">IarcPEstd.tri</a></code>,
<code><a href="#topic+IarcPEtri">IarcPEtri</a></code>, and <code><a href="#topic+IarcCSset2pnt.std.tri">IarcCSset2pnt.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

r&lt;-1.5

S&lt;-rbind(Xp[1,],Xp[2,])  #try also S&lt;-c(.5,.5)
IarcPEset2pnt.std.tri(S,Xp[3,],r,M)
IarcPEset2pnt.std.tri(S,Xp[3,],r=1,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,])
IarcPEset2pnt.std.tri(S,Xp[3,],r,M)

IarcPEset2pnt.std.tri(S,Xp[6,],r,M)
IarcPEset2pnt.std.tri(S,Xp[6,],r=1.25,M)

P&lt;-c(.4,.2)
S&lt;-Xp[c(1,3,4),]
IarcPEset2pnt.std.tri(Xp,P,r,M)


</code></pre>

<hr>
<h2 id='IarcPEset2pnt.tri'>The indicator for the presence of an arc from a point in set <code>S</code>
to the point <code>p</code> for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - one triangle case</h2><span id='topic+IarcPEset2pnt.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> in <code class="reqn">N_{PE}(x,r)</code>
for some <code class="reqn">x</code> in <code>S</code><code class="reqn">)</code>,
that is, returns 1 if <code>p</code> is in <code class="reqn">\cup_{x in S}N_{PE}(x,r)</code>,
and returns 0 otherwise.
</p>
<p>PE proximity region is constructed
with respect to the triangle <code>tri</code> with
the expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.
Vertices of <code>tri</code> are also labeled as 1, 2, and 3,
respectively.
</p>
<p>If <code>p</code> is not in <code>S</code> and either <code>p</code>
or all points in <code>S</code> are outside <code>tri</code>, it returns 0,
but if <code>p</code> is in <code>S</code>,
then it always returns 1 regardless of its location
(i.e., loops are allowed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEset2pnt.tri(S, p, tri, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEset2pnt.tri_+3A_s">S</code></td>
<td>
<p>A set of 2D points.
Presence of an arc from a point in <code>S</code> to point <code>p</code> is checked
by the function.</p>
</td></tr>
<tr><td><code id="IarcPEset2pnt.tri_+3A_p">p</code></td>
<td>
<p>A 2D point.
Presence of an arc from a point in <code>S</code> to point <code>p</code> is checked
by the function.</p>
</td></tr>
<tr><td><code id="IarcPEset2pnt.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="IarcPEset2pnt.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region
constructed in the triangle <code>tri</code>; must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEset2pnt.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is in <code class="reqn">U_{x in S} N_{PE}(x,r))</code>,
that is, returns 1 if <code>p</code> is in <code>S</code>
or inside <code class="reqn">N_{PE}(x,r)</code> for at least
one <code class="reqn">x</code> in <code>S</code>, and returns 0 otherwise,
where PE proximity region is constructed
with respect to the triangle <code>tri</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEset2pnt.std.tri">IarcPEset2pnt.std.tri</a></code>, <code><a href="#topic+IarcPEtri">IarcPEtri</a></code>,
<code><a href="#topic+IarcPEstd.tri">IarcPEstd.tri</a></code>, <code><a href="#topic+IarcASset2pnt.tri">IarcASset2pnt.tri</a></code>,
and <code><a href="#topic+IarcCSset2pnt.tri">IarcCSset2pnt.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$gen.points

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

r&lt;-1.5

S&lt;-rbind(Xp[1,],Xp[2,])  #try also S&lt;-c(1.5,1)

IarcPEset2pnt.tri(S,Xp[3,],Tr,r,M)
IarcPEset2pnt.tri(S,Xp[3,],r=1,Tr,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,])
IarcPEset2pnt.tri(S,Xp[3,],Tr,r,M)

S&lt;-rbind(c(.1,.1),c(.3,.4),c(.5,.3))
IarcPEset2pnt.tri(S,Xp[3,],Tr,r,M)

P&lt;-c(.4,.2)
S&lt;-Xp[c(1,3,4),]
IarcPEset2pnt.tri(Xp,P,Tr,r,M)


</code></pre>

<hr>
<h2 id='IarcPEstd.tetra'>The indicator for the presence of an arc from a point to another for Proportional Edge Proximity Catch
Digraphs (PE-PCDs) - standard regular tetrahedron case</h2><span id='topic+IarcPEstd.tetra'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code> for points <code>p1</code> and <code>p2</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
returns 0 otherwise, where <code class="reqn">N_{PE}(x,r)</code> is the PE proximity region for point <code class="reqn">x</code> with expansion parameter <code class="reqn">r \ge 1</code>.
</p>
<p>PE proximity region is defined with respect to the standard regular tetrahedron
<code class="reqn">T_h=T(v=1,v=2,v=3,v=4)=T((0,0,0),(1,0,0),(1/2,\sqrt{3}/2,0),(1/2,\sqrt{3}/6,\sqrt{6}/3))</code> and vertex regions
are based on the circumcenter (which is equivalent to the center of mass for standard regular tetrahedron)
of <code class="reqn">T_h</code>. <code>rv</code> is the index of the vertex region <code>p1</code> resides, with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are outside <code class="reqn">T_h</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEstd.tetra(p1, p2, r, rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEstd.tetra_+3A_p1">p1</code></td>
<td>
<p>A 3D point whose PE proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcPEstd.tetra_+3A_p2">p2</code></td>
<td>
<p>A 3D point. The function determines whether <code>p2</code> is inside the PE proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcPEstd.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEstd.tetra_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex region containing the point, either <code>1,2,3,4</code> (default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code> for points <code>p1</code> and <code>p2</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEtetra">IarcPEtetra</a></code>, <code><a href="#topic+IarcPEtri">IarcPEtri</a></code> and <code><a href="#topic+IarcPEint">IarcPEint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)

n&lt;-3  #try also n&lt;-20
Xp&lt;-runif.std.tetra(n)$g
r&lt;-1.5
IarcPEstd.tetra(Xp[1,],Xp[3,],r)
IarcPEstd.tetra(c(.4,.4,.4),c(.5,.5,.5),r)

#or try
RV&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv
IarcPEstd.tetra(Xp[1,],Xp[3,],r,rv=RV)

P1&lt;-c(.1,.1,.1)
P2&lt;-c(.5,.5,.5)
IarcPEstd.tetra(P1,P2,r)


</code></pre>

<hr>
<h2 id='IarcPEstd.tri'>The indicator for the presence of an arc from a point to another
for Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard equilateral triangle case</h2><span id='topic+IarcPEstd.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code>
for points <code>p1</code> and <code>p2</code>
in the standard equilateral triangle,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
and returns 0 otherwise,
where <code class="reqn">N_{PE}(x,r)</code> is the PE proximity region
for point <code class="reqn">x</code> with expansion parameter <code class="reqn">r \ge 1</code>.
</p>
<p>PE proximity region is defined
with respect to the standard equilateral triangle
<code class="reqn">T_e=T(v=1,v=2,v=3)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
and vertex regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_e</code>.
<code>rv</code> is the index of the vertex region <code>p1</code> resides,
with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct
and either of them are outside <code class="reqn">T_e</code>, it returns 0,
but if they are identical,
then it returns 1 regardless of their locations
(i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEstd.tri(p1, p2, r, M = c(1, 1, 1), rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEstd.tri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose PE proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcPEstd.tri_+3A_p2">p2</code></td>
<td>
<p>A 2D point. The function determines
whether <code>p2</code> is inside the PE proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcPEstd.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEstd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard equilateral triangle <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code id="IarcPEstd.tri_+3A_rv">rv</code></td>
<td>
<p>The index of the vertex region in <code class="reqn">T_e</code>
containing the point, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code>
for points <code>p1</code> and <code>p2</code>
in the standard equilateral triangle,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
and returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEtri">IarcPEtri</a></code>, <code><a href="#topic+IarcPEbasic.tri">IarcPEbasic.tri</a></code>,
and <code><a href="#topic+IarcCSstd.tri">IarcCSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
n&lt;-3

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

IarcPEstd.tri(Xp[1,],Xp[3,],r=1.5,M)
IarcPEstd.tri(Xp[1,],Xp[3,],r=2,M)

#or try
Rv&lt;-rel.vert.std.triCM(Xp[1,])$rv
IarcPEstd.tri(Xp[1,],Xp[3,],r=2,rv=Rv)

P1&lt;-c(.4,.2)
P2&lt;-c(.5,.26)
r&lt;-2
IarcPEstd.tri(P1,P2,r,M)


</code></pre>

<hr>
<h2 id='IarcPEtetra'>The indicator for the presence of an arc from one 3D point to another 3D point for
Proportional Edge Proximity Catch Digraphs (PE-PCDs)</h2><span id='topic+IarcPEtetra'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code> for 3D points <code>p1</code> and <code>p2</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
returns 0 otherwise, where <code class="reqn">N_{PE}(x,r)</code> is the PE proximity region for point <code class="reqn">x</code> with the expansion parameter <code class="reqn">r \ge 1</code>.
</p>
<p>PE proximity region is constructed with respect to the tetrahedron <code>th</code> and
vertex regions are based on the center <code>M</code> which is circumcenter (<code>"CC"</code>) or
center of mass (<code>"CM"</code>) of <code>th</code> with default=<code>"CM"</code>.
<code>rv</code> is the index of the vertex region <code>p1</code> resides, with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct and either of them are outside <code>th</code>, it returns 0,
but if they are identical, then it returns 1 regardless of their locations (i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEtetra(p1, p2, th, r, M = "CM", rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEtetra_+3A_p1">p1</code></td>
<td>
<p>A 3D point whose PE proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcPEtetra_+3A_p2">p2</code></td>
<td>
<p>A 3D point. The function determines whether <code>p2</code> is inside the PE proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcPEtetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="IarcPEtetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEtetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
<tr><td><code id="IarcPEtetra_+3A_rv">rv</code></td>
<td>
<p>Index of the <code>M</code>-vertex region containing the point, either <code>1,2,3,4</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code> for <code>p1</code>, that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEstd.tetra">IarcPEstd.tetra</a></code>, <code><a href="#topic+IarcPEtri">IarcPEtri</a></code> and <code><a href="#topic+IarcPEint">IarcPEint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-3  #try also n&lt;-20

Xp&lt;-runif.tetra(n,tetra)$g

M&lt;-"CM"  #try also M&lt;-"CC"
r&lt;-1.5

IarcPEtetra(Xp[1,],Xp[2,],tetra,r)  #uses the default M="CM"
IarcPEtetra(Xp[1,],Xp[2,],tetra,r,M)

IarcPEtetra(c(.4,.4,.4),c(.5,.5,.5),tetra,r,M)

#or try
RV&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv
IarcPEtetra(Xp[1,],Xp[3,],tetra,r,M,rv=RV)

P1&lt;-c(.1,.1,.1)
P2&lt;-c(.5,.5,.5)
IarcPEtetra(P1,P2,tetra,r,M)


</code></pre>

<hr>
<h2 id='IarcPEtri'>The indicator for the presence of an arc from a point to another
for Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
one triangle case</h2><span id='topic+IarcPEtri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code>
for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
and returns 0 otherwise,
where <code class="reqn">N_{PE}(x,r)</code> is the PE proximity region for point <code class="reqn">x</code>
with the expansion parameter <code class="reqn">r \ge 1</code>.
</p>
<p>PE proximity region is constructed
with respect to the triangle <code>tri</code> and
vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of <code>tri</code>
or based on the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.
<code>rv</code> is the index of the vertex region <code>p1</code> resides,
with default=<code>NULL</code>.
</p>
<p>If <code>p1</code> and <code>p2</code> are distinct
and either of them are outside <code>tri</code>, it returns 0,
but if they are identical,
then it returns 1 regardless of their locations
(i.e., it allows loops).
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IarcPEtri(p1, p2, tri, r, M = c(1, 1, 1), rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IarcPEtri_+3A_p1">p1</code></td>
<td>
<p>A 2D point whose PE proximity region is constructed.</p>
</td></tr>
<tr><td><code id="IarcPEtri_+3A_p2">p2</code></td>
<td>
<p>A 2D point.
The function determines whether <code>p2</code> is
inside the PE proximity region of
<code>p1</code> or not.</p>
</td></tr>
<tr><td><code id="IarcPEtri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="IarcPEtri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="IarcPEtri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="IarcPEtri_+3A_rv">rv</code></td>
<td>
<p>Index of the <code>M</code>-vertex region containing the point,
either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p2</code> is in <code class="reqn">N_{PE}(p1,r))</code>
for points <code>p1</code> and <code>p2</code>,
that is, returns 1 if <code>p2</code> is in <code class="reqn">N_{PE}(p1,r)</code>,
and returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcPEbasic.tri">IarcPEbasic.tri</a></code>, <code><a href="#topic+IarcPEstd.tri">IarcPEstd.tri</a></code>,
<code><a href="#topic+IarcAStri">IarcAStri</a></code>, and <code><a href="#topic+IarcCStri">IarcCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0);

r&lt;-1.5

n&lt;-3
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

IarcPEtri(Xp[1,],Xp[2,],Tr,r,M)

P1&lt;-as.numeric(runif.tri(1,Tr)$g)
P2&lt;-as.numeric(runif.tri(1,Tr)$g)
IarcPEtri(P1,P2,Tr,r,M)

P1&lt;-c(.4,.2)
P2&lt;-c(1.8,.5)
IarcPEtri(P1,P2,Tr,r,M)
IarcPEtri(P2,P1,Tr,r,M)

M&lt;-c(1.3,1.3)
r&lt;-2

#or try
Rv&lt;-rel.vert.tri(P1,Tr,M)$rv
IarcPEtri(P1,P2,Tr,r,M,Rv)


</code></pre>

<hr>
<h2 id='Idom.num.up.bnd'>Indicator for an upper bound for the domination number
by the exact algorithm</h2><span id='topic+Idom.num.up.bnd'></span>

<h3>Description</h3>

<p>Returns 1 if the domination number is
less than or equal to the prespecified value <code>k</code>
and also the indices
(i.e., row numbers) of a dominating set of size <code>k</code>
based on the incidence matrix <code>Inc.Mat</code> of a graph or
a digraph. Here the row number
in the incidence matrix corresponds to the index of the vertex
(i.e., index of the data point).
The function works whether loops are allowed or not
(i.e., whether the first diagonal is all 1 or all 0).
It takes a rather long time for large number of vertices
(i.e., large number of row numbers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num.up.bnd(Inc.Mat, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num.up.bnd_+3A_inc.mat">Inc.Mat</code></td>
<td>
<p>A square matrix consisting of 0's and 1's
which represents the incidence matrix of
a graph or digraph.</p>
</td></tr>
<tr><td><code id="Idom.num.up.bnd_+3A_k">k</code></td>
<td>
<p>A positive integer for the upper bound (to be checked)
for the domination number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>dom.up.bnd</code></td>
<td>
<p>The upper bound (to be checked) for the domination number.
It is prespecified as <code>k</code>
in the function arguments.</p>
</td></tr>
<tr><td><code>Idom.num.up.bnd</code></td>
<td>
<p>The indicator for the upper bound for
domination number of the graph or digraph being
the specified value <code>k</code> or not.
It returns 1 if the upper bound is <code>k</code>,
and 0 otherwise based on the incidence
matrix <code>Inc.Mat</code> of the graph or digraph.</p>
</td></tr>
<tr><td><code>ind.dom.set</code></td>
<td>
<p>Indices of the rows
in the incidence matrix <code>Inc.Mat</code>
that correspond to the vertices in the
dominating set of size <code>k</code> if it exists,
otherwise it yields <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dom.num.exact">dom.num.exact</a></code> and <code><a href="#topic+dom.num.greedy">dom.num.greedy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10
M&lt;-matrix(sample(c(0,1),n^2,replace=TRUE),nrow=n)
diag(M)&lt;-1

dom.num.greedy(M)
Idom.num.up.bnd(M,2)

for (k in 1:n)
print(c(k,Idom.num.up.bnd(M,k)))


</code></pre>

<hr>
<h2 id='Idom.num1ASbasic.tri'>The indicator for a point being a dominating point for
Arc Slice Proximity Catch Digraphs
(AS-PCDs) - standard basic triangle case</h2><span id='topic+Idom.num1ASbasic.tri'></span>

<h3>Description</h3>

<p>Returns I(<code>p</code> is a dominating point of the AS-PCD) where the vertices of the AS-PCD are the 2D data set <code>Xp</code>, that is, returns 1 if <code>p</code> is a dominating
point of AS-PCD, returns 0 otherwise. AS proximity regions are defined with respect to the standard basic triangle,
<code class="reqn">T_b</code>, <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling, preserving uniformity of the points in the
original triangle. Hence standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>Vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or based on circumcenter of <code class="reqn">T_b</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code class="reqn">T_b</code>.
Point, <code>p</code>, is in the vertex region of vertex <code>rv</code> (default is <code>NULL</code>); vertices are labeled as <code class="reqn">1,2,3</code>
in the order they are stacked row-wise.
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the point <code>p</code> would be a dominating point
if it actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1ASbasic.tri(p, Xp, c1, c2, M = "CC", rv = NULL, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1ASbasic.tri_+3A_p">p</code></td>
<td>
<p>A 2D point that is to be tested for being a dominating point or not of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1ASbasic.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1ASbasic.tri_+3A_c1">c1</code>, <code id="Idom.num1ASbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers which constitute the vertex of the standard basic triangle
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1ASbasic.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code class="reqn">T_b</code> or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1ASbasic.tri_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex whose region contains point <code>p</code>, <code>rv</code> takes the vertex labels as <code class="reqn">1,2,3</code> as
in the row order of the vertices in <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1ASbasic.tri_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point in <code>Xp</code> or not
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>I(<code>p</code> is a dominating point of the AS-PCD) where the vertices of the AS-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1AStri">Idom.num1AStri</a></code> and <code><a href="#topic+Idom.num1PEbasic.tri">Idom.num1PEbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
n&lt;-10

set.seed(1)
Xp&lt;-runif.basic.tri(n,c1,c2)$g

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.2)

Idom.num1ASbasic.tri(Xp[1,],Xp,c1,c2,M)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1ASbasic.tri(Xp[i,],Xp,c1,c2,M))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1

#or try
Rv&lt;-rel.vert.basic.triCC(Xp[1,],c1,c2)$rv
Idom.num1ASbasic.tri(Xp[1,],Xp,c1,c2,M,Rv)

Idom.num1ASbasic.tri(c(.2,.4),Xp,c1,c2,M)
Idom.num1ASbasic.tri(c(.2,.4),c(.2,.4),c1,c2,M)

Xp2&lt;-rbind(Xp,c(.2,.4))
Idom.num1ASbasic.tri(Xp[1,],Xp2,c1,c2,M)

CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter

if (dimension(M)==3) {M&lt;-bary2cart(M,Tb)}
#need to run this when M is given in barycentric coordinates

if (isTRUE(all.equal(M,CC)) || identical(M,"CC"))
{cent&lt;-CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
cent.name&lt;-"CC"
} else
{cent&lt;-M
cent.name&lt;-"M"
Ds&lt;-prj.cent2edges.basic.tri(c1,c2,M)
}

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-rbind(cent,cent,cent); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(Xp)
points(rbind(Xp[ind.gam1,]),pch=4,col=2)

txt&lt;-rbind(Tb,cent,Ds)
xc&lt;-txt[,1]+c(-.03,.03,.02,.06,.06,-0.05,.01)
yc&lt;-txt[,2]+c(.02,.02,.03,.0,.03,.03,-.03)
txt.str&lt;-c("A","B","C",cent.name,"D1","D2","D3")
text(xc,yc,txt.str)

Idom.num1ASbasic.tri(c(.4,.2),Xp,c1,c2,M)

Idom.num1ASbasic.tri(c(.5,.11),Xp,c1,c2,M)

Idom.num1ASbasic.tri(c(.5,.11),Xp,c1,c2,M,ch.data.pnt=FALSE)
#gives an error message if ch.data.pnt=TRUE since the point is not in the standard basic triangle


</code></pre>

<hr>
<h2 id='Idom.num1AStri'>The indicator for a point being a dominating point for Arc Slice Proximity Catch Digraphs
(AS-PCDs) - one triangle case</h2><span id='topic+Idom.num1AStri'></span>

<h3>Description</h3>

<p>Returns I(<code>p</code> is a dominating point of the AS-PCD whose vertices are the 2D data set <code>Xp</code>),
that is, returns 1 if <code>p</code> is a dominating point of AS-PCD, returns 0 otherwise.
Point, <code>p</code>, is in the region of vertex <code>rv</code> (default is <code>NULL</code>); vertices are labeled as <code class="reqn">1,2,3</code>
in the order they are stacked row-wise in <code>tri</code>.
</p>
<p>AS proximity regions are defined with respect to the
triangle <code>tri</code> and vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the point <code>p</code> would be a dominating point
if it actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1AStri(p, Xp, tri, M = "CC", rv = NULL, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1AStri_+3A_p">p</code></td>
<td>
<p>A 2D point that is to be tested for being a dominating point or not of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1AStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1AStri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.num1AStri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or
a 3D point in  barycentric coordinates which serves as a center in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1AStri_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex whose region contains point <code>p</code>, <code>rv</code> takes the vertex labels as <code class="reqn">1,2,3</code> as
in the row order of the vertices in <code>tri</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1AStri_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point in <code>Xp</code> or not
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>I(<code>p</code> is a dominating point of the AS-PCD whose vertices are the 2D data set <code>Xp</code>),
that is, returns 1 if <code>p</code> is a dominating point of the AS-PCD, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1ASbasic.tri">Idom.num1ASbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

Idom.num1AStri(Xp[1,],Xp,Tr,M)
Idom.num1AStri(Xp[1,],Xp[1,],Tr,M)
Idom.num1AStri(c(1.5,1.5),c(1.6,1),Tr,M)
Idom.num1AStri(c(1.6,1),c(1.5,1.5),Tr,M)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1AStri(Xp[i,],Xp,Tr,M))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1

#or try
Rv&lt;-rel.vert.triCC(Xp[1,],Tr)$rv
Idom.num1AStri(Xp[1,],Xp,Tr,M,Rv)

Idom.num1AStri(c(.2,.4),Xp,Tr,M)
Idom.num1AStri(c(.2,.4),c(.2,.4),Tr,M)

Xp2&lt;-rbind(Xp,c(.2,.4))
Idom.num1AStri(Xp[1,],Xp2,Tr,M)

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

CC&lt;-circumcenter.tri(Tr)  #the circumcenter

if (isTRUE(all.equal(M,CC)) || identical(M,"CC"))
{cent&lt;-CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
cent.name&lt;-"CC"
} else
{cent&lt;-M
cent.name&lt;-"M"
Ds&lt;-prj.cent2edges(Tr,M)
}

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp)
L&lt;-rbind(cent,cent,cent); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(rbind(Xp[ind.gam1,]),pch=4,col=2)

txt&lt;-rbind(Tr,cent,Ds)
xc&lt;-txt[,1]
yc&lt;-txt[,2]
txt.str&lt;-c("A","B","C",cent.name,"D1","D2","D3")
text(xc,yc,txt.str)

Idom.num1AStri(c(1.5,1.1),Xp,Tr,M)

Idom.num1AStri(c(1.5,1.1),Xp,Tr,M)

Idom.num1AStri(c(1.5,1.1),Xp,Tr,M,ch.data.pnt=FALSE)
#gives an error message if ch.data.pnt=TRUE since point p is not a data point in Xp


</code></pre>

<hr>
<h2 id='Idom.num1CS.Te.onesixth'>The indicator for a point being a dominating point for Central Similarity Proximity Catch Digraphs (CS-PCDs)
- first one-sixth of the standard equilateral triangle case</h2><span id='topic+Idom.num1CS.Te.onesixth'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is a dominating point of the 2D data set <code>Xp</code> of CS-PCD<code class="reqn">)</code> in the standard equilateral
triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>, that is, returns 1 if <code>p</code> is a dominating point of CS-PCD,
returns 0 otherwise.
</p>
<p>Point, <code>p</code>, must lie in the first one-sixth of <code class="reqn">T_e</code>, which is the triangle with vertices
<code class="reqn">T(A,D_3,CM)=T((0,0),(1/2,0),CM)</code>.
</p>
<p>CS proximity region is constructed with respect to <code class="reqn">T_e</code> with expansion parameter <code class="reqn">t=1</code>.
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the point <code>p</code> would be a dominating point if it actually were in the data
set.
</p>
<p>See also (Ceyhan (2005)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1CS.Te.onesixth(p, Xp, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1CS.Te.onesixth_+3A_p">p</code></td>
<td>
<p>A 2D point that is to be tested for being a dominating point or not of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1CS.Te.onesixth_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1CS.Te.onesixth_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point
in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of the CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1CSstd.tri">Idom.num1CSstd.tri</a></code> and <code><a href="#topic+Idom.num1CSt1std.tri">Idom.num1CSt1std.tri</a></code>
</p>

<hr>
<h2 id='Idom.num1CSint'>The indicator for a point being a dominating point for Central Similarity
Proximity Catch Digraphs (CS-PCDs) for an interval</h2><span id='topic+Idom.num1CSint'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is a dominating point of CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 1D data set <code>Xp</code>).
</p>
<p>CS proximity region is defined with respect to the interval <code>int</code> with an expansion parameter, <code class="reqn">t&gt;0</code>,
and a centrality parameter, <code class="reqn">c \in (0,1)</code>, so arcs may exist for <code>Xp</code> points inside the interval <code>int</code><code class="reqn">=(a,b)</code>.
</p>
<p>Vertex regions are based on the center associated with the centrality parameter <code class="reqn">c \in (0,1)</code>.
<code>rv</code> is the index of the vertex region <code>p</code> resides, with default=<code>NULL</code>.
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the point <code>p</code> would be a dominating point
if it actually were in the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1CSint(p, Xp, int, t, c = 0.5, rv = NULL, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1CSint_+3A_p">p</code></td>
<td>
<p>A 1D point that is to be tested for being a dominating point or not of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1CSint_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitutes the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1CSint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="Idom.num1CSint_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="Idom.num1CSint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1CSint_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex region in which the point resides, either <code>1,2</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="Idom.num1CSint_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point
in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 1D data set <code>Xp</code>),
that is, returns 1 if <code>p</code> is a dominating point, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1PEint">Idom.num1PEint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

Mc&lt;-centerMc(int,c)
n&lt;-10

set.seed(1)
Xp&lt;-runif(n,a,b)

Idom.num1CSint(Xp[5],Xp,int,t,c)

Idom.num1CSint(2,Xp,int,t,c,ch.data.pnt = FALSE)
#gives an error if ch.data.pnt = TRUE since p is not a data point in Xp

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1CSint(Xp[i],Xp,int,t,c))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1

domset&lt;-Xp[ind.gam1]
if (length(ind.gam1)==0)
{domset&lt;-NA}

#or try
Rv&lt;-rel.vert.mid.int(Xp[5],int,c)$rv
Idom.num1CSint(Xp[5],Xp,int,t,c,Rv)

Xlim&lt;-range(a,b,Xp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),xlab="",pch=".",xlim=Xlim+xd*c(-.05,.05))
abline(h=0)
abline(v=c(a,b,Mc),col=c(1,1,2),lty=2)
points(cbind(Xp,0))
points(cbind(domset,0),pch=4,col=2)
text(cbind(c(a,b,Mc),-0.1),c("a","b","Mc"))

Idom.num1CSint(Xp[5],Xp,int,t,c)

n&lt;-10
Xp2&lt;-runif(n,a+b,b+10)
Idom.num1CSint(5,Xp2,int,t,c)

</code></pre>

<hr>
<h2 id='Idom.num1CSstd.tri'>The indicator for a point being a dominating point for Central Similarity Proximity Catch Digraphs
(CS-PCDs) - standard equilateral triangle case</h2><span id='topic+Idom.num1CSstd.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is a dominating point of the CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 2D data set <code>Xp</code> in the standard equilateral
triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>, that is, returns 1 if <code>p</code> is a dominating point of CS-PCD,
returns 0 otherwise.
</p>
<p>CS proximity region is constructed with respect to <code class="reqn">T_e</code> with expansion parameter <code class="reqn">t&gt;0</code>
and edge regions are based on center of mass <code class="reqn">CM=(1/2,\sqrt{3}/6)</code>.
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>), so by default this
function checks whether the point <code>p</code> would be a dominating point if it actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1CSstd.tri(p, Xp, t, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1CSstd.tri_+3A_p">p</code></td>
<td>
<p>A 2D point that is to be tested for being a dominating point or not of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1CSstd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1CSstd.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="Idom.num1CSstd.tri_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point
in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of the CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1CSt1std.tri">Idom.num1CSt1std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
CM&lt;-(A+B+C)/3
Te&lt;-rbind(A,B,C);
t&lt;-1.5
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

Idom.num1CSstd.tri(Xp[3,],Xp,t)
Idom.num1CSstd.tri(c(1,2),c(1,2),t)
Idom.num1CSstd.tri(c(1,2),c(1,2),t,ch.data.pnt = TRUE)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1CSstd.tri(Xp[i,],Xp,t))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Te,pch=".",xlab="",ylab="",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
points(Xp)
L&lt;-Te; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE);
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(rbind(Xp[ind.gam1,]),pch=4,col=2)
#rbind is to insert the points correctly if there is only one dominating point

txt&lt;-rbind(Te,CM)
xc&lt;-txt[,1]+c(-.02,.02,.01,.05)
yc&lt;-txt[,2]+c(.02,.02,.03,.02)
txt.str&lt;-c("A","B","C","CM")
text(xc,yc,txt.str)

Idom.num1CSstd.tri(c(1,2),Xp,t,ch.data.pnt = FALSE)
#gives an error if ch.data.pnt = TRUE message since p is not a data point


</code></pre>

<hr>
<h2 id='Idom.num1CSt1std.tri'>The indicator for a point being a dominating point for Central Similarity Proximity Catch Digraphs
(CS-PCDs) - standard equilateral triangle case with <code class="reqn">t=1</code></h2><span id='topic+Idom.num1CSt1std.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is a dominating point of the CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 2D data set <code>Xp</code> in the standard equilateral
triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>, that is, returns 1 if <code>p</code> is a dominating point of CS-PCD,
returns 0 otherwise.
</p>
<p>Point, <code>p</code>, is in the edge region of edge re (default is <code>NULL</code>); vertices are labeled as <code class="reqn">1,2,3</code>
in the order they are stacked row-wise in <code class="reqn">T_e</code>, and the opposite edges are labeled with label of the vertices
(that is, edge numbering is <code>1,2</code>, and <code>3</code> for edges <code class="reqn">AB</code>, <code class="reqn">BC</code>, and <code class="reqn">AC</code>).
</p>
<p>CS proximity region is constructed with respect to <code class="reqn">T_e</code> with expansion parameter <code class="reqn">t=1</code>
and edge regions are based on center of mass <code class="reqn">CM=(1/2,\sqrt{3}/6)</code>.
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>), so by default this
function checks whether the point <code>p</code> would be a dominating point if it actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1CSt1std.tri(p, Xp, re = NULL, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1CSt1std.tri_+3A_p">p</code></td>
<td>
<p>A 2D point that is to be tested for being a dominating point or not of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1CSt1std.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1CSt1std.tri_+3A_re">re</code></td>
<td>
<p>The index of the edge region in <code class="reqn">T_e</code> containing the point, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="Idom.num1CSt1std.tri_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point
in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of the CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point, returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1CSstd.tri">Idom.num1CSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
CM&lt;-(A+B+C)/3
Te&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

Idom.num1CSt1std.tri(Xp[3,],Xp)

Idom.num1CSt1std.tri(c(1,2),c(1,2))
Idom.num1CSt1std.tri(c(1,2),c(1,2),ch.data.pnt = TRUE)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1CSt1std.tri(Xp[i,],Xp))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Te,pch=".",xlab="",ylab="",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
points(Xp)
L&lt;-Te; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE);
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(rbind(Xp[ind.gam1,]),pch=4,col=2)
#rbind is to insert the points correctly if there is only one dominating point

txt&lt;-rbind(Te,CM)
xc&lt;-txt[,1]+c(-.02,.02,.01,.05)
yc&lt;-txt[,2]+c(.02,.02,.03,.02)
txt.str&lt;-c("A","B","C","CM")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='Idom.num1PEbasic.tri'>The indicator for a point being a dominating point or not for
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard basic triangle case</h2><span id='topic+Idom.num1PEbasic.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is a dominating point
of the PE-PCD<code class="reqn">)</code>
where the vertices of the PE-PCD are the 2D data set <code>Xp</code>
for data in the standard basic triangle
<code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>,
that is, returns 1 if <code>p</code> is a dominating point of PE-PCD,
and returns 0 otherwise.
</p>
<p>PE proximity regions are defined
with respect to the standard basic triangle <code class="reqn">T_b</code>.
In the standard basic triangle, <code class="reqn">T_b</code>,
<code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle. Hence, standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>Vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian
coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of a standard basic triangle
to the edges on the extension of the lines joining <code>M</code>
to the vertices or based on the circumcenter of <code class="reqn">T_b</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_b</code>.
Point, <code>p</code>, is in the vertex region of vertex <code>rv</code>
(default is <code>NULL</code>);
vertices are labeled as <code class="reqn">1,2,3</code>
in the order they are stacked row-wise.
</p>
<p><code>ch.data.pnt</code> is for checking
whether point <code>p</code> is a data point in <code>Xp</code> or not
(default is <code>FALSE</code>),
so by default this function checks
whether the point <code>p</code> would be a dominating point
if it actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1PEbasic.tri(
  p,
  Xp,
  r,
  c1,
  c2,
  M = c(1, 1, 1),
  rv = NULL,
  ch.data.pnt = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1PEbasic.tri_+3A_p">p</code></td>
<td>
<p>A 2D point that is to be tested for being a dominating point
or not of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEbasic.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEbasic.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEbasic.tri_+3A_c1">c1</code>, <code id="Idom.num1PEbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEbasic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or the circumcenter of <code class="reqn">T_b</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEbasic.tri_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex whose region contains point <code>p</code>,
<code>rv</code> takes the vertex labels as <code class="reqn">1,2,3</code> as
in the row order of the vertices in <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEbasic.tri_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking
whether point <code>p</code> is a data point in <code>Xp</code> or not
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of the PE-PCD<code class="reqn">)</code>
where the vertices of the PE-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point,
and returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1ASbasic.tri">Idom.num1ASbasic.tri</a></code> and <code><a href="#topic+Idom.num1AStri">Idom.num1AStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.basic.tri(n,c1,c2)$g

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.3)
r&lt;-2

P&lt;-c(.4,.2)
Idom.num1PEbasic.tri(P,Xp,r,c1,c2,M)
Idom.num1PEbasic.tri(Xp[1,],Xp,r,c1,c2,M)

Idom.num1PEbasic.tri(c(1,1),Xp,r,c1,c2,M,ch.data.pnt = FALSE)
#gives an error message if ch.data.pnt = TRUE since point p=c(1,1) is not a data point in Xp

#or try
Rv&lt;-rel.vert.basic.tri(Xp[1,],c1,c2,M)$rv
Idom.num1PEbasic.tri(Xp[1,],Xp,r,c1,c2,M,Rv)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1PEbasic.tri(Xp[i,],Xp,r,c1,c2,M))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tb)}
#need to run this when M is given in barycentric coordinates

if (identical(M,circumcenter.tri(Tb)))
{
  plot(Tb,pch=".",asp=1,xlab="",ylab="",axes=TRUE,
  xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
  polygon(Tb)
  points(Xp,pch=1,col=1)
  Ds&lt;-rbind((B+C)/2,(A+C)/2,(A+B)/2)
} else
{plot(Tb,pch=".",xlab="",ylab="",axes=TRUE,
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
  polygon(Tb)
  points(Xp,pch=1,col=1)
  Ds&lt;-prj.cent2edges.basic.tri(c1,c2,M)}
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(rbind(Xp[ind.gam1,]),pch=4,col=2)

txt&lt;-rbind(Tb,M,Ds)
xc&lt;-txt[,1]+c(-.02,.02,.02,-.02,.03,-.03,.01)
yc&lt;-txt[,2]+c(.02,.02,.02,-.02,.02,.02,-.03)
txt.str&lt;-c("A","B","C","M","D1","D2","D3")
text(xc,yc,txt.str)

Idom.num1PEbasic.tri(c(.2,.1),Xp,r,c1,c2,M,ch.data.pnt=FALSE)
#gives an error message if ch.data.pnt=TRUE since point p is not a data point in Xp


</code></pre>

<hr>
<h2 id='Idom.num1PEint'>The indicator for a point being a dominating point for Proportional Edge
Proximity Catch Digraphs (PE-PCDs) for an interval</h2><span id='topic+Idom.num1PEint'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is a dominating point of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 1D data set <code>Xp</code>.
</p>
<p>PE proximity region is defined with respect to the interval <code>int</code> with an expansion parameter, <code class="reqn">r \ge 1</code>,
and a centrality parameter, <code class="reqn">c \in (0,1)</code>, so arcs may exist for <code>Xp</code> points inside the interval <code>int</code><code class="reqn">=(a,b)</code>.
</p>
<p>Vertex regions are based on the center associated with the centrality parameter <code class="reqn">c \in (0,1)</code>.
<code>rv</code> is the index of the vertex region <code>p</code> resides, with default=<code>NULL</code>.
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the point <code>p</code> would be a dominating point
if it actually were in the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1PEint(p, Xp, int, r, c = 0.5, rv = NULL, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1PEint_+3A_p">p</code></td>
<td>
<p>A 1D point that is to be tested for being a dominating point or not of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEint_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="Idom.num1PEint_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>; default <code>c=.5</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEint_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex region in which the point resides, either <code>1,2</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="Idom.num1PEint_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point
in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 1D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1PEtri">Idom.num1PEtri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10
int=c(a,b)

Mc&lt;-centerMc(int,c)

n&lt;-10

set.seed(1)
Xp&lt;-runif(n,a,b)

Idom.num1PEint(Xp[5],Xp,int,r,c)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1PEint(Xp[i],Xp,int,r,c))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1

domset&lt;-Xp[ind.gam1]
if (length(ind.gam1)==0)
{domset&lt;-NA}

#or try
Rv&lt;-rel.vert.mid.int(Xp[5],int,c)$rv
Idom.num1PEint(Xp[5],Xp,int,r,c,Rv)

Xlim&lt;-range(a,b,Xp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),xlab="",pch=".",xlim=Xlim+xd*c(-.05,.05))
abline(h=0)
points(cbind(Xp,0))
abline(v=c(a,b,Mc),col=c(1,1,2),lty=2)
points(cbind(domset,0),pch=4,col=2)
text(cbind(c(a,b,Mc),-0.1),c("a","b","Mc"))

Idom.num1PEint(2,Xp,int,r,c,ch.data.pnt = FALSE)
#gives an error message if ch.data.pnt = TRUE since point p is not a data point in Xp


</code></pre>

<hr>
<h2 id='Idom.num1PEstd.tetra'>The indicator for a 3D point being a dominating point for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - standard regular tetrahedron case</h2><span id='topic+Idom.num1PEstd.tetra'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is a dominating point of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code> in the
standard regular tetrahedron <code class="reqn">T_h=T((0,0,0),(1,0,0),(1/2,\sqrt{3}/2,0),(1/2,\sqrt{3}/6,\sqrt{6}/3))</code>, that is,
returns 1 if <code>p</code> is a dominating point of PE-PCD, returns 0 otherwise.
</p>
<p>Point, <code>p</code>, is in the vertex region of vertex <code>rv</code> (default is <code>NULL</code>); vertices are labeled as <code>1,2,3,4</code>
in the order they are stacked row-wise in <code class="reqn">T_h</code>.
</p>
<p>PE proximity region is constructed with respect to the tetrahedron <code class="reqn">T_h</code> with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on center of mass <code class="reqn">CM</code> (equivalent to circumcenter in this case).
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the point <code>p</code> would be a dominating point
if it actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1PEstd.tetra(p, Xp, r, rv = NULL, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1PEstd.tetra_+3A_p">p</code></td>
<td>
<p>A 3D point that is to be tested for being a dominating point or not of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEstd.tetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEstd.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEstd.tetra_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex whose region contains point <code>p</code>, <code>rv</code> takes the vertex labels
as <code>1,2,3,4</code> as in the row order of the vertices in standard regular tetrahedron, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEstd.tetra_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point
in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1PEtetra">Idom.num1PEtetra</a></code>, <code><a href="#topic+Idom.num1PEtri">Idom.num1PEtri</a></code> and <code><a href="#topic+Idom.num1PEbasic.tri">Idom.num1PEbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)

n&lt;-5 #try also n&lt;-20
Xp&lt;-runif.std.tetra(n)$g  #try also Xp&lt;-cbind(runif(n),runif(n),runif(n))
r&lt;-1.5

P&lt;-c(.4,.1,.2)
Idom.num1PEstd.tetra(Xp[1,],Xp,r)
Idom.num1PEstd.tetra(P,Xp,r)

Idom.num1PEstd.tetra(Xp[1,],Xp,r)
Idom.num1PEstd.tetra(Xp[1,],Xp[1,],r)

#or try
RV&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv
Idom.num1PEstd.tetra(Xp[1,],Xp,r,rv=RV)

Idom.num1PEstd.tetra(c(-1,-1,-1),Xp,r)
Idom.num1PEstd.tetra(c(-1,-1,-1),c(-1,-1,-1),r)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1PEstd.tetra(Xp[i,],Xp,r))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1
g1.pts&lt;-Xp[ind.gam1,]

Xlim&lt;-range(tetra[,1],Xp[,1])
Ylim&lt;-range(tetra[,2],Xp[,2])
Zlim&lt;-range(tetra[,3],Xp[,3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::scatter3D(Xp[,1],Xp[,2],Xp[,3], phi =0,theta=40, bty = "g",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05), zlim=Zlim+zd*c(-.05,.05),
         pch = 20, cex = 1, ticktype = "detailed")
#add the vertices of the tetrahedron
plot3D::points3D(tetra[,1],tetra[,2],tetra[,3], add=TRUE)
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lwd=2)
if (length(g1.pts)!=0)
{
  if (length(g1.pts)==3) g1.pts&lt;-matrix(g1.pts,nrow=1)
  plot3D::points3D(g1.pts[,1],g1.pts[,2],g1.pts[,3], pch=4,col="red", add=TRUE)}

plot3D::text3D(tetra[,1],tetra[,2],tetra[,3], labels=c("A","B","C","D"), add=TRUE)

CM&lt;-apply(tetra,2,mean)
D1&lt;-(A+B)/2; D2&lt;-(A+C)/2; D3&lt;-(A+D)/2; D4&lt;-(B+C)/2; D5&lt;-(B+D)/2; D6&lt;-(C+D)/2;
L&lt;-rbind(D1,D2,D3,D4,D5,D6); R&lt;-matrix(rep(CM,6),ncol=3,byrow=TRUE)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lty=2)

P&lt;-c(.4,.1,.2)
Idom.num1PEstd.tetra(P,Xp,r)

Idom.num1PEstd.tetra(c(-1,-1,-1),Xp,r,ch.data.pnt = FALSE)
#gives an error message if ch.data.pnt = TRUE


</code></pre>

<hr>
<h2 id='Idom.num1PEtetra'>The indicator for a 3D point being a dominating point for Proportional Edge Proximity Catch Digraphs (PE-PCDs)
- one tetrahedron case</h2><span id='topic+Idom.num1PEtetra'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is a dominating point of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 2D data set <code>Xp</code> in the tetrahedron <code>th</code>, that is,
returns 1 if <code>p</code> is a dominating point of PE-PCD, returns 0 otherwise.
</p>
<p>Point, <code>p</code>, is in the vertex region of vertex <code>rv</code> (default is <code>NULL</code>); vertices are labeled as <code>1,2,3,4</code>
in the order they are stacked row-wise in <code>th</code>.
</p>
<p>PE proximity region is constructed with respect to the tetrahedron <code>th</code> with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on center of mass (<code>M="CM"</code>) or circumcenter (<code>M="CC"</code>) only.
and vertex regions are based on center of mass <code class="reqn">CM</code> (equivalent to circumcenter in this case).
</p>
<p><code>ch.data.pnt</code> is for checking whether point <code>p</code> is a data point in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the point <code>p</code> would be a dominating point
if it actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1PEtetra(p, Xp, th, r, M = "CM", rv = NULL, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1PEtetra_+3A_p">p</code></td>
<td>
<p>A 3D point that is to be tested for being a dominating point or not of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtetra_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex whose region contains point <code>p</code>, <code>rv</code> takes the vertex labels as <code>1,2,3,4</code> as
in the row order of the vertices in standard tetrahedron, default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtetra_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking whether point <code>p</code> is a data point
in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1PEstd.tetra">Idom.num1PEstd.tetra</a></code>, <code><a href="#topic+Idom.num1PEtri">Idom.num1PEtri</a></code> and <code><a href="#topic+Idom.num1PEbasic.tri">Idom.num1PEbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-5 #try also n&lt;-20

Xp&lt;-runif.tetra(n,tetra)$g  #try also Xp&lt;-cbind(runif(n),runif(n),runif(n))

M&lt;-"CM"; cent&lt;-apply(tetra,2,mean)  #center of mass
#try also M&lt;-"CC"; cent&lt;-circumcenter.tetra(tetra)  #circumcenter

r&lt;-2

P&lt;-c(.4,.1,.2)
Idom.num1PEtetra(Xp[1,],Xp,tetra,r,M)
Idom.num1PEtetra(P,Xp,tetra,r,M)

#or try
RV&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv
Idom.num1PEtetra(Xp[1,],Xp,tetra,r,M,rv=RV)

Idom.num1PEtetra(c(-1,-1,-1),Xp,tetra,r,M)
Idom.num1PEtetra(c(-1,-1,-1),c(-1,-1,-1),tetra,r,M)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1PEtetra(Xp[i,],Xp,tetra,r,M))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1
g1.pts&lt;-Xp[ind.gam1,]

Xlim&lt;-range(tetra[,1],Xp[,1],cent[1])
Ylim&lt;-range(tetra[,2],Xp[,2],cent[2])
Zlim&lt;-range(tetra[,3],Xp[,3],cent[3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::scatter3D(Xp[,1],Xp[,2],Xp[,3], phi =0,theta=40, bty = "g",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05), zlim=Zlim+zd*c(-.05,.05),
         pch = 20, cex = 1, ticktype = "detailed")
#add the vertices of the tetrahedron
plot3D::points3D(tetra[,1],tetra[,2],tetra[,3], add=TRUE)
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lwd=2)
if (length(g1.pts)!=0)
{plot3D::points3D(g1.pts[,1],g1.pts[,2],g1.pts[,3], pch=4,col="red", add=TRUE)}

plot3D::text3D(tetra[,1],tetra[,2],tetra[,3], labels=c("A","B","C","D"), add=TRUE)

D1&lt;-(A+B)/2; D2&lt;-(A+C)/2; D3&lt;-(A+D)/2; D4&lt;-(B+C)/2; D5&lt;-(B+D)/2; D6&lt;-(C+D)/2;
L&lt;-rbind(D1,D2,D3,D4,D5,D6); R&lt;-rbind(cent,cent,cent,cent,cent,cent)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lty=2)

P&lt;-c(.4,.1,.2)
Idom.num1PEtetra(P,Xp,tetra,r,M)

Idom.num1PEtetra(c(-1,-1,-1),Xp,tetra,r,M,ch.data.pnt = FALSE)
#gives an error message if ch.data.pnt = TRUE since p is not a data point


</code></pre>

<hr>
<h2 id='Idom.num1PEtri'>The indicator for a point being a dominating point for
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
one triangle case</h2><span id='topic+Idom.num1PEtri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>p</code> is
a dominating point of the PE-PCD<code class="reqn">)</code>
where the vertices of the PE-PCD are the 2D data set <code>Xp</code>
in the triangle <code>tri</code>, that is,
returns 1 if <code>p</code> is a dominating point of PE-PCD,
and returns 0 otherwise.
</p>
<p>Point, <code>p</code>, is in the vertex region of vertex <code>rv</code>
(default is <code>NULL</code>); vertices are labeled as <code class="reqn">1,2,3</code>
in the order they are stacked row-wise in <code>tri</code>.
</p>
<p>PE proximity region is constructed
with respect to the triangle <code>tri</code>
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.
</p>
<p><code>ch.data.pnt</code> is for checking
whether point <code>p</code> is a data point in <code>Xp</code>
or not (default is <code>FALSE</code>),
so by default this function checks
whether the point <code>p</code> would be a dominating point
if it actually were in the data set.
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num1PEtri(p, Xp, tri, r, M = c(1, 1, 1), rv = NULL, ch.data.pnt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num1PEtri_+3A_p">p</code></td>
<td>
<p>A 2D point that is to be tested for being a dominating point
or not of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtri_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex whose region contains point <code>p</code>,
<code>rv</code> takes the vertex labels as <code class="reqn">1,2,3</code> as
in the row order of the vertices in <code>tri</code>.</p>
</td></tr>
<tr><td><code id="Idom.num1PEtri_+3A_ch.data.pnt">ch.data.pnt</code></td>
<td>
<p>A logical argument for checking
whether point <code>p</code> is a data point
in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>p</code> is a dominating point of the PE-PCD<code class="reqn">)</code>
where the vertices of the PE-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if <code>p</code> is a dominating point,
and returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num1PEbasic.tri">Idom.num1PEbasic.tri</a></code> and <code><a href="#topic+Idom.num1AStri">Idom.num1AStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

r&lt;-1.5  #try also r&lt;-2

Idom.num1PEtri(Xp[1,],Xp,Tr,r,M)
Idom.num1PEtri(c(1,2),c(1,2),Tr,r,M)
Idom.num1PEtri(c(1,2),c(1,2),Tr,r,M,ch.data.pnt = TRUE)

gam.vec&lt;-vector()
for (i in 1:n)
{gam.vec&lt;-c(gam.vec,Idom.num1PEtri(Xp[i,],Xp,Tr,r,M))}

ind.gam1&lt;-which(gam.vec==1)
ind.gam1

#or try
Rv&lt;-rel.vert.tri(Xp[1,],Tr,M)$rv
Idom.num1PEtri(Xp[1,],Xp,Tr,r,M,Rv)

Ds&lt;-prj.cent2edges(Tr,M)

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

Xlim&lt;-range(Tr[,1],Xp[,1],M[1])
Ylim&lt;-range(Tr[,2],Xp[,2],M[2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",axes=TRUE,
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=1,col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(rbind(Xp[ind.gam1,]),pch=4,col=2)
#rbind is to insert the points correctly if there is only one dominating point

txt&lt;-rbind(Tr,M,Ds)
xc&lt;-txt[,1]+c(-.02,.03,.02,-.02,.04,-.03,.0)
yc&lt;-txt[,2]+c(.02,.02,.05,-.03,.04,.06,-.07)
txt.str&lt;-c("A","B","C","M","D1","D2","D3")
text(xc,yc,txt.str)

P&lt;-c(1.4,1)
Idom.num1PEtri(P,P,Tr,r,M)
Idom.num1PEtri(Xp[1,],Xp,Tr,r,M)

Idom.num1PEtri(c(1,2),Xp,Tr,r,M,ch.data.pnt = FALSE)
#gives an error message if ch.data.pnt = TRUE since p is not a data point


</code></pre>

<hr>
<h2 id='Idom.num2ASbasic.tri'>The indicator for two points being a dominating set for Arc Slice Proximity Catch Digraphs
(AS-PCDs) - standard basic triangle case</h2><span id='topic+Idom.num2ASbasic.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of AS-PCD<code class="reqn">)</code> where vertices of AS-PCD are the 2D
data set <code>Xp</code>), that is, returns 1 if {<code>p1,p2</code>} is a dominating set of AS-PCD, returns 0 otherwise.
</p>
<p>AS proximity regions are defined with respect to the standard basic triangle <code class="reqn">T_b=T(c(0,0),c(1,0),c(c1,c2))</code>,
In the standard basic triangle, <code class="reqn">T_b</code>, <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling, preserving uniformity of the points in the
original triangle. Hence standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>Point, <code>p1</code>, is in the vertex region of vertex <code>rv1</code> (default is <code>NULL</code>)
and point, <code>p2</code>, is in the vertex region of vertex <code>rv2</code> (default is <code>NULL</code>); vertices are labeled as <code class="reqn">1,2,3</code>
in the order they are stacked row-wise.
</p>
<p>Vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or based on circumcenter of <code class="reqn">T_b</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code class="reqn">T_b</code>.
</p>
<p><code>ch.data.pnts</code> is for checking whether points <code>p1</code> and <code>p2</code> are data points in <code>Xp</code> or not
(default is <code>FALSE</code>), so by default this function checks whether the points <code>p1</code> and <code>p2</code> would be a
dominating set if they actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num2ASbasic.tri(
  p1,
  p2,
  Xp,
  c1,
  c2,
  M = "CC",
  rv1 = NULL,
  rv2 = NULL,
  ch.data.pnts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num2ASbasic.tri_+3A_p1">p1</code>, <code id="Idom.num2ASbasic.tri_+3A_p2">p2</code></td>
<td>
<p>Two 2D points to be tested for constituting a dominating set of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2ASbasic.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2ASbasic.tri_+3A_c1">c1</code>, <code id="Idom.num2ASbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers which constitute the vertex of the standard basic triangle
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2ASbasic.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code class="reqn">T_b</code> or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2ASbasic.tri_+3A_rv1">rv1</code>, <code id="Idom.num2ASbasic.tri_+3A_rv2">rv2</code></td>
<td>
<p>The indices of the vertices whose regions contains <code>p1</code> and <code>p2</code>, respectively.
They take the vertex labels as <code class="reqn">1,2,3</code> as in the row order of the vertices in <code class="reqn">T_b</code>
(default is <code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="Idom.num2ASbasic.tri_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for checking whether points <code>p1</code> and <code>p2</code> are data points in <code>Xp</code> or not
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the AS-PCD<code class="reqn">)</code> where the vertices of AS-PCD are the 2D data set <code>Xp</code>),
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of AS-PCD, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num2AStri">Idom.num2AStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
n&lt;-10

set.seed(1)
Xp&lt;-runif.basic.tri(n,c1,c2)$g

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.2)

Idom.num2ASbasic.tri(Xp[1,],Xp[2,],Xp,c1,c2,M)
Idom.num2ASbasic.tri(Xp[1,],Xp[1,],Xp,c1,c2,M)  #one point can not a dominating set of size two

Idom.num2ASbasic.tri(c(.2,.4),c(.2,.5),rbind(c(.2,.4),c(.2,.5)),c1,c2,M)

ind.gam2&lt;-vector()
for (i in 1:(n-1))
  for (j in (i+1):n)
  {if (Idom.num2ASbasic.tri(Xp[i,],Xp[j,],Xp,c1,c2,M)==1)
   ind.gam2&lt;-rbind(ind.gam2,c(i,j))}
ind.gam2

#or try
rv1&lt;-rel.vert.basic.triCC(Xp[1,],c1,c2)$rv
rv2&lt;-rel.vert.basic.triCC(Xp[2,],c1,c2)$rv
Idom.num2ASbasic.tri(Xp[1,],Xp[2,],Xp,c1,c2,M,rv1,rv2)
Idom.num2ASbasic.tri(c(.2,.4),Xp[2,],Xp,c1,c2,M,rv1,rv2)

#or try
rv1&lt;-rel.vert.basic.triCC(Xp[1,],c1,c2)$rv
Idom.num2ASbasic.tri(Xp[1,],Xp[2,],Xp,c1,c2,M,rv1)

#or try
Rv2&lt;-rel.vert.basic.triCC(Xp[2,],c1,c2)$rv
Idom.num2ASbasic.tri(Xp[1,],Xp[2,],Xp,c1,c2,M,rv2=Rv2)

Idom.num2ASbasic.tri(c(.3,.2),c(.35,.25),Xp,c1,c2,M)


</code></pre>

<hr>
<h2 id='Idom.num2AStri'>The indicator for two points constituting a dominating set for Arc Slice Proximity Catch Digraphs
(AS-PCDs) - one triangle case</h2><span id='topic+Idom.num2AStri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the AS-PCD<code class="reqn">)</code> where vertices of the AS-PCD are
the 2D data set <code>Xp</code>), that is, returns 1 if {<code>p1,p2</code>} is a dominating set of AS-PCD, returns 0 otherwise.
</p>
<p>AS proximity regions are defined with respect to the triangle <code>tri</code>.
Point, <code>p1</code>, is in the region of vertex <code>rv1</code> (default is <code>NULL</code>)
and point, <code>p2</code>, is in the region of vertex <code>rv2</code> (default is <code>NULL</code>); vertices (and hence <code>rv1</code> and <code>rv2</code>)
are labeled as <code class="reqn">1,2,3</code> in the order they are stacked row-wise in <code>tri</code>.
</p>
<p>Vertex regions are based on
the center <code>M="CC"</code> for circumcenter of <code>tri</code>; or <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of the triangle <code>tri</code>;
default is <code>M="CC"</code> the circumcenter of <code>tri</code>.
</p>
<p><code>ch.data.pnts</code> is for checking whether points <code>p1</code> and <code>p2</code> are data
points in <code>Xp</code> or not (default is <code>FALSE</code>), so by default this function checks whether the points <code>p1</code> and <code>p2</code>
would constitute dominating set if they actually were in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num2AStri(
  p1,
  p2,
  Xp,
  tri,
  M = "CC",
  rv1 = NULL,
  rv2 = NULL,
  ch.data.pnts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num2AStri_+3A_p1">p1</code>, <code id="Idom.num2AStri_+3A_p2">p2</code></td>
<td>
<p>Two 2D points to be tested for constituting a dominating set of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2AStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2AStri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.num2AStri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or
a 3D point in  barycentric coordinates which serves as a center in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2AStri_+3A_rv1">rv1</code>, <code id="Idom.num2AStri_+3A_rv2">rv2</code></td>
<td>
<p>The indices of the vertices whose regions contains <code>p1</code> and <code>p2</code>, respectively.
They take the vertex labels as <code class="reqn">1,2,3</code> as in the row order of the vertices in <code>tri</code>
(default is <code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="Idom.num2AStri_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for checking whether points <code>p1</code> and <code>p2</code> are data points in <code>Xp</code> or not
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the AS-PCD<code class="reqn">)</code> where vertices of the AS-PCD are the 2D data set <code>Xp</code>),
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of AS-PCD, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num2ASbasic.tri">Idom.num2ASbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

Idom.num2AStri(Xp[1,],Xp[2,],Xp,Tr,M)
Idom.num2AStri(Xp[1,],Xp[1,],Xp,Tr,M)  #same two points cannot be a dominating set of size 2

Idom.num2AStri(c(.2,.4),Xp[2,],Xp,Tr,M)
Idom.num2AStri(c(.2,.4),c(.2,.5),Xp,Tr,M)
Idom.num2AStri(c(.2,.4),c(.2,.5),rbind(c(.2,.4),c(.2,.5)),Tr,M)

#or try
rv1&lt;-rel.vert.triCC(c(.2,.4),Tr)$rv
rv2&lt;-rel.vert.triCC(c(.2,.5),Tr)$rv
Idom.num2AStri(c(.2,.4),c(.2,.5),rbind(c(.2,.4),c(.2,.5)),Tr,M,rv1,rv2)

ind.gam2&lt;-vector()
for (i in 1:(n-1))
  for (j in (i+1):n)
  {if (Idom.num2AStri(Xp[i,],Xp[j,],Xp,Tr,M)==1)
   ind.gam2&lt;-rbind(ind.gam2,c(i,j))}
ind.gam2

#or try
rv1&lt;-rel.vert.triCC(Xp[1,],Tr)$rv
rv2&lt;-rel.vert.triCC(Xp[2,],Tr)$rv
Idom.num2AStri(Xp[1,],Xp[2,],Xp,Tr,M,rv1,rv2)

#or try
rv1&lt;-rel.vert.triCC(Xp[1,],Tr)$rv
Idom.num2AStri(Xp[1,],Xp[2,],Xp,Tr,M,rv1)

#or try
Rv2&lt;-rel.vert.triCC(Xp[2,],Tr)$rv
Idom.num2AStri(Xp[1,],Xp[2,],Xp,Tr,M,rv2=Rv2)

Idom.num2AStri(c(1.3,1.2),c(1.35,1.25),Xp,Tr,M)


</code></pre>

<hr>
<h2 id='Idom.num2CS.Te.onesixth'>The indicator for two points constituting a dominating set for Central Similarity Proximity Catch Digraphs
(CS-PCDs) - first one-sixth of the standard equilateral triangle case</h2><span id='topic+Idom.num2CS.Te.onesixth'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 2D data set <code>Xp</code>),
that is, returns 1 if <code>p</code> is a dominating point of CS-PCD, returns 0 otherwise.
</p>
<p>CS proximity region is
constructed with respect to the standard equilateral triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> and
with expansion parameter <code class="reqn">t=1</code>. Point, <code>p1</code>, must lie in the first one-sixth of <code class="reqn">T_e</code>, which is the triangle with
vertices <code class="reqn">T(A,D_3,CM)=T((0,0),(1/2,0),CM)</code>.
</p>
<p><code>ch.data.pnts</code> is for checking whether points <code>p1</code> and <code>p2</code> are data points in <code>Xp</code> or not
(default is <code>FALSE</code>), so by default this function checks whether the points <code>p1</code> and <code>p2</code> would be a
dominating set if they actually were in the data set.
</p>
<p>See also (Ceyhan (2005)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num2CS.Te.onesixth(p1, p2, Xp, ch.data.pnts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num2CS.Te.onesixth_+3A_p1">p1</code>, <code id="Idom.num2CS.Te.onesixth_+3A_p2">p2</code></td>
<td>
<p>Two 2D points to be tested for constituting a dominating set of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2CS.Te.onesixth_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitutes the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2CS.Te.onesixth_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for checking whether points <code>p1</code> and <code>p2</code> are
data points in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the 2D data set <code>Xp</code>),
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of CS-PCD, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num2CSstd.tri">Idom.num2CSstd.tri</a></code>
</p>

<hr>
<h2 id='Idom.num2PEbasic.tri'>The indicator for two points being a dominating set for
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard basic triangle case</h2><span id='topic+Idom.num2PEbasic.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>{<code>p1,p2</code>} is
a dominating set of the PE-PCD<code class="reqn">)</code>
where the vertices of the PE-PCD are the 2D data set <code>Xp</code>
in the standard basic triangle
<code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>,
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of PE-PCD,
and returns 0 otherwise.
</p>
<p>PE proximity regions are defined with respect to <code class="reqn">T_b</code>.
In the standard basic triangle, <code class="reqn">T_b</code>,
<code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle.
Hence, standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>Vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian
coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of a standard basic triangle <code class="reqn">T_b</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_b</code>.
Point, <code>p1</code>,
is in the vertex region of vertex <code>rv1</code>
(default is <code>NULL</code>);
and point, <code>p2</code>,
is in the vertex region of vertex <code>rv2</code>
(default is <code>NULL</code>);
vertices are labeled as <code class="reqn">1,2,3</code>
in the order they are stacked row-wise.
</p>
<p><code>ch.data.pnts</code> is for checking
whether points <code>p1</code> and <code>p2</code> are both data points
in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks
whether the points <code>p1</code> and <code>p2</code> would constitute
a dominating set
if they both were actually in the data set.
</p>
<p>See also (Ceyhan (2005, 2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num2PEbasic.tri(
  p1,
  p2,
  Xp,
  r,
  c1,
  c2,
  M = c(1, 1, 1),
  rv1 = NULL,
  rv2 = NULL,
  ch.data.pnts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num2PEbasic.tri_+3A_p1">p1</code>, <code id="Idom.num2PEbasic.tri_+3A_p2">p2</code></td>
<td>
<p>Two 2D points to be tested for
constituting a dominating set of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2PEbasic.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2PEbasic.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2PEbasic.tri_+3A_c1">c1</code>, <code id="Idom.num2PEbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle.
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2PEbasic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or the circumcenter of <code class="reqn">T_b</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2PEbasic.tri_+3A_rv1">rv1</code>, <code id="Idom.num2PEbasic.tri_+3A_rv2">rv2</code></td>
<td>
<p>The indices of the vertices
whose regions contains <code>p1</code> and <code>p2</code>, respectively.
They take the vertex labels as <code class="reqn">1,2,3</code> as
in the row order of the vertices in <code class="reqn">T_b</code>
(default is <code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="Idom.num2PEbasic.tri_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for
checking whether points <code>p1</code> and <code>p2</code>
are data points in <code>Xp</code> or not
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the PE-PCD<code class="reqn">)</code>
where the vertices of the PE-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of PE-PCD,
and returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num2PEtri">Idom.num2PEtri</a></code>, <code><a href="#topic+Idom.num2ASbasic.tri">Idom.num2ASbasic.tri</a></code>,
and <code><a href="#topic+Idom.num2AStri">Idom.num2AStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.basic.tri(n,c1,c2)$g

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.3)

r&lt;-2

Idom.num2PEbasic.tri(Xp[1,],Xp[2,],Xp,r,c1,c2,M)

Idom.num2PEbasic.tri(c(1,2),c(1,3),rbind(c(1,2),c(1,3)),r,c1,c2,M)
Idom.num2PEbasic.tri(c(1,2),c(1,3),rbind(c(1,2),c(1,3)),r,c1,c2,M,
ch.data.pnts = TRUE)

ind.gam2&lt;-vector()
for (i in 1:(n-1))
  for (j in (i+1):n)
  {if (Idom.num2PEbasic.tri(Xp[i,],Xp[j,],Xp,r,c1,c2,M)==1)
   ind.gam2&lt;-rbind(ind.gam2,c(i,j))}
ind.gam2

#or try
rv1&lt;-rel.vert.basic.tri(Xp[1,],c1,c2,M)$rv;
rv2&lt;-rel.vert.basic.tri(Xp[2,],c1,c2,M)$rv;
Idom.num2PEbasic.tri(Xp[1,],Xp[2,],Xp,r,c1,c2,M,rv1,rv2)

#or try
rv1&lt;-rel.vert.basic.tri(Xp[1,],c1,c2,M)$rv;
Idom.num2PEbasic.tri(Xp[1,],Xp[2,],Xp,r,c1,c2,M,rv1)

#or try
rv2&lt;-rel.vert.basic.tri(Xp[2,],c1,c2,M)$rv;
Idom.num2PEbasic.tri(Xp[1,],Xp[2,],Xp,r,c1,c2,M,rv2=rv2)

Idom.num2PEbasic.tri(c(1,2),Xp[2,],Xp,r,c1,c2,M,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE since not both points are data points in Xp


</code></pre>

<hr>
<h2 id='Idom.num2PEstd.tetra'>The indicator for two 3D points constituting a dominating set for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - standard regular tetrahedron case</h2><span id='topic+Idom.num2PEstd.tetra'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code> in the standard regular
tetrahedron <code class="reqn">T_h=T((0,0,0),(1,0,0),(1/2,\sqrt{3}/2,0),(1/2,\sqrt{3}/6,\sqrt{6}/3))</code>, that is,
returns 1 if {<code>p1,p2</code>} is a dominating set of PE-PCD, returns 0 otherwise.
</p>
<p>Point, <code>p1</code>, is in the region of vertex <code>rv1</code> (default is <code>NULL</code>) and point, <code>p2</code>, is in the region of vertex <code>rv2</code>
(default is <code>NULL</code>); vertices (and hence <code>rv1</code> and <code>rv2</code>) are labeled as <code>1,2,3,4</code> in the order they are stacked
row-wise in <code class="reqn">T_h</code>.
</p>
<p>PE proximity region is constructed with respect to the tetrahedron <code class="reqn">T_h</code> with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on center of mass <code class="reqn">CM</code> (equivalent to circumcenter in this case).
</p>
<p><code>ch.data.pnts</code> is for checking whether points <code>p1</code> and <code>p2</code> are data points in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the points <code>p1</code> and <code>p2</code> would constitute a dominating set
if they actually were both in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num2PEstd.tetra(
  p1,
  p2,
  Xp,
  r,
  rv1 = NULL,
  rv2 = NULL,
  ch.data.pnts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num2PEstd.tetra_+3A_p1">p1</code>, <code id="Idom.num2PEstd.tetra_+3A_p2">p2</code></td>
<td>
<p>Two 3D points to be tested for constituting a dominating set of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2PEstd.tetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2PEstd.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2PEstd.tetra_+3A_rv1">rv1</code>, <code id="Idom.num2PEstd.tetra_+3A_rv2">rv2</code></td>
<td>
<p>The indices of the vertices whose regions contains <code>p1</code> and <code>p2</code>, respectively.
They take the vertex labels as <code>1,2,3,4</code> as in the row order of the vertices in <code class="reqn">T_h</code>
(default is <code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="Idom.num2PEstd.tetra_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for checking whether points <code>p1</code> and <code>p2</code> are
data points in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code>),
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of PE-PCD, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num2PEtetra">Idom.num2PEtetra</a></code>, <code><a href="#topic+Idom.num2PEtri">Idom.num2PEtri</a></code> and <code><a href="#topic+Idom.num2PEbasic.tri">Idom.num2PEbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)

n&lt;-5 #try also n&lt;-20
Xp&lt;-runif.std.tetra(n)$g  #try also Xp&lt;-cbind(runif(n),runif(n),runif(n))
r&lt;-1.5

Idom.num2PEstd.tetra(Xp[1,],Xp[2,],Xp,r)

ind.gam2&lt;-vector()
for (i in 1:(n-1))
 for (j in (i+1):n)
 {if (Idom.num2PEstd.tetra(Xp[i,],Xp[j,],Xp,r)==1)
  ind.gam2&lt;-rbind(ind.gam2,c(i,j))}

ind.gam2

#or try
rv1&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv;rv2&lt;-rel.vert.tetraCC(Xp[2,],tetra)$rv
Idom.num2PEstd.tetra(Xp[1,],Xp[2,],Xp,r,rv1,rv2)

#or try
rv1&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv;
Idom.num2PEstd.tetra(Xp[1,],Xp[2,],Xp,r,rv1)

#or try
rv2&lt;-rel.vert.tetraCC(Xp[2,],tetra)$rv
Idom.num2PEstd.tetra(Xp[1,],Xp[2,],Xp,r,rv2=rv2)

P1&lt;-c(.1,.1,.1)
P2&lt;-c(.4,.1,.2)
Idom.num2PEstd.tetra(P1,P2,Xp,r)

Idom.num2PEstd.tetra(c(-1,-1,-1),Xp[2,],Xp,r,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE
#since not both points, p1 and p2, are data points in Xp


</code></pre>

<hr>
<h2 id='Idom.num2PEtetra'>The indicator for two 3D points constituting a dominating set for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - one tetrahedron case</h2><span id='topic+Idom.num2PEtetra'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code> in the tetrahedron <code>th</code>, that is,
returns 1 if {<code>p1,p2</code>} is a dominating set of PE-PCD, returns 0 otherwise.
</p>
<p>Point, <code>p1</code>, is in the region of vertex <code>rv1</code> (default is <code>NULL</code>) and point, <code>p2</code>, is in the region of vertex <code>rv2</code>
(default is <code>NULL</code>); vertices (and hence <code>rv1</code> and <code>rv2</code>) are labeled as <code>1,2,3,4</code> in the order they are stacked
row-wise in <code>th</code>.
</p>
<p>PE proximity region is constructed with respect to the tetrahedron <code>th</code> with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on center of mass (<code>M="CM"</code>) or circumcenter (<code>M="CC"</code>) only.
</p>
<p><code>ch.data.pnts</code> is for checking whether points <code>p1</code> and <code>p2</code> are both data points in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the points <code>p1</code> and <code>p2</code> would constitute a dominating set
if they actually were both in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num2PEtetra(
  p1,
  p2,
  Xp,
  th,
  r,
  M = "CM",
  rv1 = NULL,
  rv2 = NULL,
  ch.data.pnts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num2PEtetra_+3A_p1">p1</code>, <code id="Idom.num2PEtetra_+3A_p2">p2</code></td>
<td>
<p>Two 3D points to be tested for constituting a dominating set of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtetra_+3A_rv1">rv1</code>, <code id="Idom.num2PEtetra_+3A_rv2">rv2</code></td>
<td>
<p>The indices of the vertices whose regions contains <code>p1</code> and <code>p2</code>, respectively.
They take the vertex labels as <code>1,2,3,4</code> as in the row order of the vertices in <code>th</code>
(default is <code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="Idom.num2PEtetra_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for checking whether both points <code>p1</code> and <code>p2</code> are
data points in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code>),
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of PE-PCD, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num2PEstd.tetra">Idom.num2PEstd.tetra</a></code>, <code><a href="#topic+Idom.num2PEtri">Idom.num2PEtri</a></code> and <code><a href="#topic+Idom.num2PEbasic.tri">Idom.num2PEbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-5

set.seed(1)
Xp&lt;-runif.tetra(n,tetra)$g  #try also Xp&lt;-cbind(runif(n),runif(n),runif(n))

M&lt;-"CM";  #try also M&lt;-"CC";
r&lt;-1.5

Idom.num2PEtetra(Xp[1,],Xp[2,],Xp,tetra,r,M)
Idom.num2PEtetra(c(-1,-1,-1),Xp[2,],Xp,tetra,r,M)

ind.gam2&lt;-ind.gamn2&lt;-vector()
for (i in 1:(n-1))
 for (j in (i+1):n)
 {if (Idom.num2PEtetra(Xp[i,],Xp[j,],Xp,tetra,r,M)==1)
 {ind.gam2&lt;-rbind(ind.gam2,c(i,j))
 }
 }
ind.gam2

#or try
rv1&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv;rv2&lt;-rel.vert.tetraCC(Xp[2,],tetra)$rv
Idom.num2PEtetra(Xp[1,],Xp[2,],Xp,tetra,r,M,rv1,rv2)

#or try
rv1&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv;
Idom.num2PEtetra(Xp[1,],Xp[2,],Xp,tetra,r,M,rv1)

#or try
rv2&lt;-rel.vert.tetraCC(Xp[2,],tetra)$rv
Idom.num2PEtetra(Xp[1,],Xp[2,],Xp,tetra,r,M,rv2=rv2)

P1&lt;-c(.1,.1,.1)
P2&lt;-c(.4,.1,.2)
Idom.num2PEtetra(P1,P2,Xp,tetra,r,M)

Idom.num2PEtetra(c(-1,-1,-1),Xp[2,],Xp,tetra,r,M,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE
#since not both points, p1 and p2, are data points in Xp


</code></pre>

<hr>
<h2 id='Idom.num2PEtri'>The indicator for two points constituting a dominating set for
Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
one triangle case</h2><span id='topic+Idom.num2PEtri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>{<code>p1,p2</code>} is
a dominating set of the PE-PCD<code class="reqn">)</code>
where the vertices of the PE-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of PE-PCD,
and returns 0 otherwise.
</p>
<p>Point, <code>p1</code>, is in the region of vertex <code>rv1</code>
(default is <code>NULL</code>) and point, <code>p2</code>, is
in the region of vertex <code>rv2</code>
(default is <code>NULL</code>); vertices (and hence <code>rv1</code> and <code>rv2</code>)
are labeled as <code class="reqn">1,2,3</code> in the order they are stacked
row-wise in <code>tri</code>.
</p>
<p>PE proximity regions are defined
with respect to the triangle <code>tri</code> and vertex regions
are based on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.
</p>
<p><code>ch.data.pnts</code> is
for checking whether points <code>p1</code> and <code>p2</code> are data points
in <code>Xp</code> or not
(default is <code>FALSE</code>),
so by default this function checks
whether the points <code>p1</code> and <code>p2</code> would be a
dominating set if they actually were in the data set.
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num2PEtri(
  p1,
  p2,
  Xp,
  tri,
  r,
  M = c(1, 1, 1),
  rv1 = NULL,
  rv2 = NULL,
  ch.data.pnts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num2PEtri_+3A_p1">p1</code>, <code id="Idom.num2PEtri_+3A_p2">p2</code></td>
<td>
<p>Two 2D points to be tested for constituting
a dominating set of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="Idom.num2PEtri_+3A_rv1">rv1</code>, <code id="Idom.num2PEtri_+3A_rv2">rv2</code></td>
<td>
<p>The indices of the vertices
whose regions contains <code>p1</code> and <code>p2</code>, respectively.
They take the vertex labels as <code class="reqn">1,2,3</code>
as in the row order of the vertices in <code>tri</code>
(default is <code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="Idom.num2PEtri_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for
checking whether points <code>p1</code> and <code>p2</code> are
data points in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code>{<code>p1,p2</code>} is a dominating set of the PE-PCD<code class="reqn">)</code>
where the vertices of the PE-PCD are the 2D data set <code>Xp</code>,
that is, returns 1 if {<code>p1,p2</code>} is a dominating set of PE-PCD,
and returns 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num2PEbasic.tri">Idom.num2PEbasic.tri</a></code>, <code><a href="#topic+Idom.num2AStri">Idom.num2AStri</a></code>,
and <code><a href="#topic+Idom.num2PEtetra">Idom.num2PEtetra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

r&lt;-1.5  #try also r&lt;-2

Idom.num2PEtri(Xp[1,],Xp[2,],Xp,Tr,r,M)

ind.gam2&lt;-vector()
for (i in 1:(n-1))
  for (j in (i+1):n)
  {if (Idom.num2PEtri(Xp[i,],Xp[j,],Xp,Tr,r,M)==1)
   ind.gam2&lt;-rbind(ind.gam2,c(i,j))}
ind.gam2

#or try
rv1&lt;-rel.vert.tri(Xp[1,],Tr,M)$rv;
rv2&lt;-rel.vert.tri(Xp[2,],Tr,M)$rv
Idom.num2PEtri(Xp[1,],Xp[2,],Xp,Tr,r,M,rv1,rv2)

Idom.num2PEtri(Xp[1,],c(1,2),Xp,Tr,r,M,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE
#since not both points, p1 and p2, are data points in Xp


</code></pre>

<hr>
<h2 id='Idom.num3PEstd.tetra'>The indicator for three 3D points constituting a dominating set for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - standard regular tetrahedron case</h2><span id='topic+Idom.num3PEstd.tetra'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(\{</code><code>p1,p2,pt3</code>} is a dominating set of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code> in the standard regular
tetrahedron <code class="reqn">T_h=T((0,0,0),(1,0,0),(1/2,\sqrt{3}/2,0),(1/2,\sqrt{3}/6,\sqrt{6}/3))</code>, that is,
returns 1 if {<code>p1,p2,pt3</code>} is a dominating set of PE-PCD, returns 0 otherwise.
</p>
<p>Point, <code>p1</code>, is in the region of vertex <code>rv1</code> (default is <code>NULL</code>), point, <code>p2</code>, is in the region of vertex <code>rv2</code>
(default is <code>NULL</code>); point, <code>pt3</code>), is in the region of vertex <code>rv3</code>) (default is <code>NULL</code>); vertices (and hence <code>rv1, rv2</code> and
<code>rv3</code>) are labeled as <code>1,2,3,4</code> in the order they are stacked row-wise in <code class="reqn">T_h</code>.
</p>
<p>PE proximity region is constructed with
respect to the tetrahedron <code class="reqn">T_h</code> with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on center of mass <code class="reqn">CM</code> (equivalent to circumcenter in this case).
</p>
<p><code>ch.data.pnts</code> is for checking whether points <code>p1</code>, <code>p2</code> and <code>pt3</code> are all data points in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the points <code>p1</code>, <code>p2</code> and <code>pt3</code> would constitute a dominating set
if they actually were all in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num3PEstd.tetra(
  p1,
  p2,
  pt3,
  Xp,
  r,
  rv1 = NULL,
  rv2 = NULL,
  rv3 = NULL,
  ch.data.pnts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num3PEstd.tetra_+3A_p1">p1</code>, <code id="Idom.num3PEstd.tetra_+3A_p2">p2</code>, <code id="Idom.num3PEstd.tetra_+3A_pt3">pt3</code></td>
<td>
<p>Three 3D points to be tested for constituting a dominating set of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num3PEstd.tetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num3PEstd.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num3PEstd.tetra_+3A_rv1">rv1</code>, <code id="Idom.num3PEstd.tetra_+3A_rv2">rv2</code>, <code id="Idom.num3PEstd.tetra_+3A_rv3">rv3</code></td>
<td>
<p>The indices of the vertices whose regions contains <code>p1</code>, <code>p2</code> and <code>pt3</code>,
respectively.
They take the vertex labels as <code>1,2,3,4</code> as in the row order of the vertices in <code class="reqn">T_h</code>
(default is <code>NULL</code> for all).</p>
</td></tr>
<tr><td><code id="Idom.num3PEstd.tetra_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for checking whether points <code>p1</code> and <code>p2</code> are
data points in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(\{</code><code>p1,p2,pt3</code>} is a dominating set of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code>),
that is, returns 1 if {<code>p1,p2,pt3</code>} is a dominating set of PE-PCD, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num3PEtetra">Idom.num3PEtetra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-5 #try 20, 40, 100 (larger n may take a long time)
Xp&lt;-runif.std.tetra(n)$g  #try also Xp&lt;-cbind(runif(n),runif(n),runif(n))
r&lt;-1.25

Idom.num3PEstd.tetra(Xp[1,],Xp[2,],Xp[3,],Xp,r)

ind.gam3&lt;-vector()
for (i in 1:(n-2))
 for (j in (i+1):(n-1))
   for (k in (j+1):n)
 {if (Idom.num3PEstd.tetra(Xp[i,],Xp[j,],Xp[k,],Xp,r)==1)
  ind.gam3&lt;-rbind(ind.gam3,c(i,j,k))}

ind.gam3

#or try
rv1&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv; rv2&lt;-rel.vert.tetraCC(Xp[2,],tetra)$rv;
rv3&lt;-rel.vert.tetraCC(Xp[3,],tetra)$rv
Idom.num3PEstd.tetra(Xp[1,],Xp[2,],Xp[3,],Xp,r,rv1,rv2,rv3)

#or try
rv1&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv;
Idom.num3PEstd.tetra(Xp[1,],Xp[2,],Xp[3,],Xp,r,rv1)

#or try
rv2&lt;-rel.vert.tetraCC(Xp[2,],tetra)$rv
Idom.num3PEstd.tetra(Xp[1,],Xp[2,],Xp[3,],Xp,r,rv2=rv2)

P1&lt;-c(.1,.1,.1)
P2&lt;-c(.3,.3,.3)
P3&lt;-c(.4,.1,.2)
Idom.num3PEstd.tetra(P1,P2,P3,Xp,r)

Idom.num3PEstd.tetra(Xp[1,],c(1,1,1),Xp[3,],Xp,r,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE since not all points are data points in Xp


</code></pre>

<hr>
<h2 id='Idom.num3PEtetra'>The indicator for three 3D points constituting a dominating set for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - one tetrahedron case</h2><span id='topic+Idom.num3PEtetra'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(\{</code><code>p1,p2,pt3</code>} is a dominating set of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code> in the tetrahedron <code>th</code>, that is,
returns 1 if {<code>p1,p2,pt3</code>} is a dominating set of PE-PCD, returns 0 otherwise.
</p>
<p>Point, <code>p1</code>, is in the region of vertex <code>rv1</code> (default is <code>NULL</code>), point, <code>p2</code>, is in the region of vertex <code>rv2</code>
(default is <code>NULL</code>); point, <code>pt3</code>), is in the region of vertex <code>rv3</code>) (default is <code>NULL</code>); vertices (and hence <code>rv1, rv2</code> and
<code>rv3</code>) are labeled as <code>1,2,3,4</code> in the order they are stacked row-wise in <code>th</code>.
</p>
<p>PE proximity region is constructed with
respect to the tetrahedron <code>th</code> with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on center of mass <code class="reqn">CM</code> (equivalent to circumcenter in this case).
</p>
<p><code>ch.data.pnts</code> is for checking whether points <code>p1</code>, <code>p2</code> and <code>pt3</code> are all data points in <code>Xp</code> or not (default is <code>FALSE</code>),
so by default this function checks whether the points <code>p1</code>, <code>p2</code> and <code>pt3</code> would constitute a dominating set
if they actually were all in the data set.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.num3PEtetra(
  p1,
  p2,
  pt3,
  Xp,
  th,
  r,
  M = "CM",
  rv1 = NULL,
  rv2 = NULL,
  rv3 = NULL,
  ch.data.pnts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.num3PEtetra_+3A_p1">p1</code>, <code id="Idom.num3PEtetra_+3A_p2">p2</code>, <code id="Idom.num3PEtetra_+3A_pt3">pt3</code></td>
<td>
<p>Three 3D points to be tested for constituting a dominating set of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num3PEtetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.num3PEtetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="Idom.num3PEtetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.num3PEtetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
<tr><td><code id="Idom.num3PEtetra_+3A_rv1">rv1</code>, <code id="Idom.num3PEtetra_+3A_rv2">rv2</code>, <code id="Idom.num3PEtetra_+3A_rv3">rv3</code></td>
<td>
<p>The indices of the vertices whose regions contains <code>p1</code>, <code>p2</code> and <code>pt3</code>,
respectively.
They take the vertex labels as <code>1,2,3,4</code> as in the row order of the vertices in <code>th</code>
( default is <code>NULL</code> for all).</p>
</td></tr>
<tr><td><code id="Idom.num3PEtetra_+3A_ch.data.pnts">ch.data.pnts</code></td>
<td>
<p>A logical argument for checking whether points <code>p1</code> and <code>p2</code> are
data points in <code>Xp</code> or not (default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(\{</code><code>p1,p2,pt3</code>} is a dominating set of the PE-PCD<code class="reqn">)</code> where the vertices of the PE-PCD are the 3D data set <code>Xp</code>),
that is, returns 1 if {<code>p1,p2,pt3</code>} is a dominating set of PE-PCD, returns 0 otherwise
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.num3PEstd.tetra">Idom.num3PEstd.tetra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-5 #try 20, 40, 100 (larger n may take a long time)
Xp&lt;-runif.tetra(n,tetra)$g

M&lt;-"CM";  #try also M&lt;-"CC";
r&lt;-1.25

Idom.num3PEtetra(Xp[1,],Xp[2,],Xp[3,],Xp,tetra,r,M)

ind.gam3&lt;-vector()
for (i in 1:(n-2))
 for (j in (i+1):(n-1))
   for (k in (j+1):n)
   {if (Idom.num3PEtetra(Xp[i,],Xp[j,],Xp[k,],Xp,tetra,r,M)==1)
    ind.gam3&lt;-rbind(ind.gam3,c(i,j,k))}

ind.gam3

#or try
rv1&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv; rv2&lt;-rel.vert.tetraCC(Xp[2,],tetra)$rv;
rv3&lt;-rel.vert.tetraCC(Xp[3,],tetra)$rv
Idom.num3PEtetra(Xp[1,],Xp[2,],Xp[3,],Xp,tetra,r,M,rv1,rv2,rv3)

#or try
rv1&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv;
Idom.num3PEtetra(Xp[1,],Xp[2,],Xp[3,],Xp,tetra,r,M,rv1)

#or try
rv2&lt;-rel.vert.tetraCC(Xp[2,],tetra)$rv
Idom.num3PEtetra(Xp[1,],Xp[2,],Xp[3,],Xp,tetra,r,M,rv2=rv2)

P1&lt;-c(.1,.1,.1)
P2&lt;-c(.3,.3,.3)
P3&lt;-c(.4,.1,.2)
Idom.num3PEtetra(P1,P2,P3,Xp,tetra,r,M)

Idom.num3PEtetra(Xp[1,],c(1,1,1),Xp[3,],Xp,tetra,r,M,ch.data.pnts = FALSE)
#gives an error message if ch.data.pnts = TRUE since not all points are data points in Xp


</code></pre>

<hr>
<h2 id='Idom.numASup.bnd.tri'>Indicator for an upper bound for the domination number of Arc Slice Proximity Catch Digraph
(AS-PCD) by the exact algorithm - one triangle case</h2><span id='topic+Idom.numASup.bnd.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>domination number of AS-PCD whose vertices are the data points <code>Xp</code> is less than or equal to <code>k</code><code class="reqn">)</code>,
that is, returns 1 if the domination number of AS-PCD is less than the prespecified value <code>k</code>, returns 0
otherwise. It also provides the vertices (i.e., data points) in a dominating set of size <code>k</code> of AS-PCD.
</p>
<p>AS proximity regions are constructed with respect to the triangle <code>tri</code> and
vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
</p>
<p>The vertices of <code>tri</code>angle, <code>tri</code>,
are labeled as <code class="reqn">1,2,3</code> according to the row number the vertex is recorded in <code>tri</code>.
Loops are allowed in the digraph.
It takes a long time for large number of vertices (i.e., large number of row numbers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.numASup.bnd.tri(Xp, k, tri, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.numASup.bnd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.numASup.bnd.tri_+3A_k">k</code></td>
<td>
<p>A positive integer to be tested for an upper bound for the domination number of AS-PCDs.</p>
</td></tr>
<tr><td><code id="Idom.numASup.bnd.tri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.numASup.bnd.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center in the interior of <code>tri</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>domUB</code></td>
<td>
<p>The suggested upper bound (to be checked) for the domination number of AS-PCD.
It is prespecified as <code>k</code> in the function arguments.</p>
</td></tr>
<tr><td><code>Idom.num.up.bnd</code></td>
<td>
<p>The indicator for the upper bound for domination number of AS-PCD being the
specified value <code>k</code> or not. It returns 1 if the upper bound is <code>k</code>, and 0 otherwise.</p>
</td></tr>
<tr><td><code>ind.dom.set</code></td>
<td>
<p>The vertices (i.e., data points) in the dominating set of size <code>k</code> if it exists,
otherwise it yields <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.numCSup.bnd.tri">Idom.numCSup.bnd.tri</a></code>, <code><a href="#topic+Idom.numCSup.bnd.std.tri">Idom.numCSup.bnd.std.tri</a></code>, <code><a href="#topic+Idom.num.up.bnd">Idom.num.up.bnd</a></code>,
and <code><a href="#topic+dom.num.exact">dom.num.exact</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);

Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$gen.points

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

Idom.numASup.bnd.tri(Xp,1,Tr)

for (k in 1:n)
  print(c(k,Idom.numASup.bnd.tri(Xp,k,Tr,M)))

Idom.numASup.bnd.tri(Xp,k=4,Tr,M)

P&lt;-c(.4,.2)
Idom.numASup.bnd.tri(P,1,Tr,M)

Idom.numASup.bnd.tri(rbind(Xp,Xp),k=2,Tr,M)


</code></pre>

<hr>
<h2 id='Idom.numCSup.bnd.std.tri'>The indicator for <code>k</code> being an upper bound for the domination number of Central Similarity Proximity
Catch Digraph (CS-PCD) by the exact algorithm - standard equilateral triangle case</h2><span id='topic+Idom.numCSup.bnd.std.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>domination number of CS-PCD is less than or equal to <code>k</code><code class="reqn">)</code> where the vertices of the CS-PCD are the data points <code>Xp</code>,
that is, returns 1 if the domination number of CS-PCD is less than the prespecified value <code>k</code>, returns 0
otherwise. It also provides the vertices (i.e., data points) in a dominating set of size <code>k</code> of CS-PCD.
</p>
<p>CS proximity region is constructed with respect to the standard equilateral triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> with
expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_e</code> (which is equivalent to the circumcenter of <code class="reqn">T_e</code>).
</p>
<p>Edges of <code class="reqn">T_e</code>, <code class="reqn">AB</code>, <code class="reqn">BC</code>, <code class="reqn">AC</code>, are also labeled as 3, 1, and 2, respectively.
Loops are allowed in the digraph.
It takes a long time for large number of vertices (i.e., large number of row numbers).
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.numCSup.bnd.std.tri(Xp, k, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.numCSup.bnd.std.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.numCSup.bnd.std.tri_+3A_k">k</code></td>
<td>
<p>A positive integer representing an upper bound for the domination number of CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.numCSup.bnd.std.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region in the
standard equilateral triangle <code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>.</p>
</td></tr>
<tr><td><code id="Idom.numCSup.bnd.std.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the standard equilateral triangle <code class="reqn">T_e</code>; default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>domUB</code></td>
<td>
<p>The upper bound <code>k</code> (to be checked) for the domination number of CS-PCD. It is prespecified
as <code>k</code> in the function arguments.</p>
</td></tr>
<tr><td><code>Idom.num.up.bnd</code></td>
<td>
<p>The indicator for the upper bound for domination number of CS-PCD being the
specified value <code>k</code> or not. It returns 1 if the upper bound is <code>k</code>, and 0 otherwise.</p>
</td></tr>
<tr><td><code>ind.domset</code></td>
<td>
<p>The vertices (i.e., data points) in the dominating set of size <code>k</code> if it exists,
otherwise it is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.numCSup.bnd.tri">Idom.numCSup.bnd.tri</a></code>, <code><a href="#topic+Idom.num.up.bnd">Idom.num.up.bnd</a></code>, <code><a href="#topic+Idom.numASup.bnd.tri">Idom.numASup.bnd.tri</a></code>,
and <code><a href="#topic+dom.num.exact">dom.num.exact</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

t&lt;-.5

Idom.numCSup.bnd.std.tri(Xp,1,t,M)

for (k in 1:n)
  print(c(k,Idom.numCSup.bnd.std.tri(Xp,k,t,M)$Idom.num.up.bnd))
  print(c(k,Idom.numCSup.bnd.std.tri(Xp,k,t,M)$domUB))


</code></pre>

<hr>
<h2 id='Idom.numCSup.bnd.tri'>Indicator for an upper bound for the domination number of Central Similarity Proximity Catch Digraph
(CS-PCD) by the exact algorithm - one triangle case</h2><span id='topic+Idom.numCSup.bnd.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code>domination number of CS-PCD is less than or equal to <code>k</code><code class="reqn">)</code> where the vertices of the CS-PCD are the data points <code>Xp</code>,
that is, returns 1 if the domination number of CS-PCD is less than the prespecified value <code>k</code>, returns 0
otherwise. It also provides the vertices (i.e., data points) in a dominating set of size <code>k</code> of CS-PCD.
</p>
<p>CS proximity region is constructed with respect to the triangle <code>tri</code><code class="reqn">=T(A,B,C)</code> with
expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
</p>
<p>Edges of <code>tri</code>, <code class="reqn">AB</code>, <code class="reqn">BC</code>, <code class="reqn">AC</code>, are also labeled as 3, 1, and 2, respectively.
Loops are allowed in the digraph.
</p>
<p>See also (Ceyhan (2012)).
</p>
<p>Caveat: It takes a long time for large number of vertices (i.e., large number of row numbers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.numCSup.bnd.tri(Xp, k, tri, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.numCSup.bnd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.numCSup.bnd.tri_+3A_k">k</code></td>
<td>
<p>A positive integer to be tested for an upper bound for the domination number of CS-PCDs.</p>
</td></tr>
<tr><td><code id="Idom.numCSup.bnd.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.numCSup.bnd.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region in the
triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code id="Idom.numCSup.bnd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates which serves as a
center in the interior of the triangle <code>tri</code>; default is <code class="reqn">M=(1,1,1)</code>, i.e.
the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>domUB</code></td>
<td>
<p>The upper bound <code>k</code> (to be checked) for the domination number of CS-PCD. It is prespecified
as <code>k</code> in the function arguments.</p>
</td></tr>
<tr><td><code>Idom.num.up.bnd</code></td>
<td>
<p>The indicator for the upper bound for domination number of CS-PCD being the
specified value <code>k</code> or not. It returns 1 if the upper bound is <code>k</code>, and 0 otherwise.</p>
</td></tr>
<tr><td><code>ind.domset</code></td>
<td>
<p>The vertices (i.e., data points) in the dominating set of size <code>k</code> if it exists,
otherwise it is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.numCSup.bnd.std.tri">Idom.numCSup.bnd.std.tri</a></code>, <code><a href="#topic+Idom.num.up.bnd">Idom.num.up.bnd</a></code>, <code><a href="#topic+Idom.numASup.bnd.tri">Idom.numASup.bnd.tri</a></code>,
and <code><a href="#topic+dom.num.exact">dom.num.exact</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$gen.points

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

t&lt;-.5

Idom.numCSup.bnd.tri(Xp,1,Tr,t,M)

for (k in 1:n)
  print(c(k,Idom.numCSup.bnd.tri(Xp,k,Tr,t,M)))


</code></pre>

<hr>
<h2 id='Idom.setAStri'>The indicator for the set of points <code>S</code> being a dominating set or not for Arc Slice Proximity
Catch Digraphs (AS-PCDs) - one triangle case</h2><span id='topic+Idom.setAStri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>S</code> a dominating set of AS-PCD<code class="reqn">)</code>, that is, returns 1 if <code>S</code> is a dominating set of AS-PCD,
returns 0 otherwise.
</p>
<p>AS-PCD has vertex set <code>Xp</code> and AS proximity region is constructed with vertex
regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>
whose vertices are also labeled as edges 1, 2, and 3, respectively.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.setAStri(S, Xp, tri, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.setAStri_+3A_s">S</code></td>
<td>
<p>A set of 2D points which is to be tested for being a dominating set for the AS-PCDs.</p>
</td></tr>
<tr><td><code id="Idom.setAStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.setAStri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.setAStri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center in the interior of <code>tri</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>S</code> a dominating set of AS-PCD<code class="reqn">)</code>, that is, returns 1 if <code>S</code> is a dominating set of AS-PCD whose
vertices are the data points in <code>Xp</code>; returns 0 otherwise, where AS proximity region is constructed in
the triangle <code>tri</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IarcASset2pnt.tri">IarcASset2pnt.tri</a></code>, <code><a href="#topic+Idom.setPEtri">Idom.setPEtri</a></code> and <code><a href="#topic+Idom.setCStri">Idom.setCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);

Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$gen.points

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

S&lt;-rbind(Xp[1,],Xp[2,])
Idom.setAStri(S,Xp,Tr,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,])
Idom.setAStri(S,Xp,Tr,M)

S&lt;-rbind(c(.1,.1),c(.3,.4),c(.5,.3))
Idom.setAStri(S,Xp,Tr,M)

Idom.setAStri(c(.2,.5),Xp,Tr,M)
Idom.setAStri(c(.2,.5),c(.2,.5),Tr,M)
Idom.setAStri(Xp[5,],Xp[2,],Tr,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,],c(.2,.5))
Idom.setAStri(S,Xp[3,],Tr,M)

Idom.setAStri(Xp,Xp,Tr,M)

P&lt;-c(.4,.2)
S&lt;-Xp[c(1,3,4),]
Idom.setAStri(Xp,P,Tr,M)
Idom.setAStri(S,P,Tr,M)
Idom.setAStri(S,Xp,Tr,M)

Idom.setAStri(rbind(S,S),Xp,Tr,M)


</code></pre>

<hr>
<h2 id='Idom.setCSstd.tri'>The indicator for the set of points <code>S</code> being a dominating set or not for Central Similarity Proximity
Catch Digraphs (CS-PCDs) - standard equilateral triangle case</h2><span id='topic+Idom.setCSstd.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>S</code> a dominating set of the CS-PCD<code class="reqn">)</code> where the vertices of the CS-PCD are the data set <code>Xp</code>), that is,
returns 1 if <code>S</code> is a dominating set of CS-PCD, returns 0 otherwise.
</p>
<p>CS proximity region is constructed
with respect to the standard equilateral triangle <code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> with
expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_e</code> (which is equivalent to the circumcenter of <code class="reqn">T_e</code>).
</p>
<p>Edges of <code class="reqn">T_e</code>, <code class="reqn">AB</code>, <code class="reqn">BC</code>, <code class="reqn">AC</code>, are also labeled as 3, 1, and 2, respectively.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.setCSstd.tri(S, Xp, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.setCSstd.tri_+3A_s">S</code></td>
<td>
<p>A set of 2D points which is to be tested for being a dominating set for the CS-PCDs.</p>
</td></tr>
<tr><td><code id="Idom.setCSstd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.setCSstd.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region in the
standard equilateral triangle <code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>.</p>
</td></tr>
<tr><td><code id="Idom.setCSstd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the standard equilateral triangle <code class="reqn">T_e</code>; default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>S</code> a dominating set of the CS-PCD<code class="reqn">)</code>, that is, returns 1 if <code>S</code> is a dominating set of CS-PCD,
returns 0 otherwise, where CS proximity region is constructed in the standard equilateral triangle <code class="reqn">T_e</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.setCStri">Idom.setCStri</a></code> and <code><a href="#topic+Idom.setPEstd.tri">Idom.setPEstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

t&lt;-.5

S&lt;-rbind(Xp[1,],Xp[2,])
Idom.setCSstd.tri(S,Xp,t,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,])
Idom.setCSstd.tri(S,Xp,t,M)


</code></pre>

<hr>
<h2 id='Idom.setCStri'>The indicator for the set of points <code>S</code> being a dominating set or not for Central Similarity Proximity
Catch Digraphs (CS-PCDs) - one triangle case</h2><span id='topic+Idom.setCStri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>S</code> a dominating set of CS-PCD whose vertices are the data set <code>Xp</code><code class="reqn">)</code>, that is,
returns 1 if <code>S</code> is a dominating set of CS-PCD, returns 0 otherwise.
</p>
<p>CS proximity region is constructed with
respect to the triangle <code>tri</code> with the expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based
on the center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>; default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
</p>
<p>The triangle <code>tri</code><code class="reqn">=T(A,B,C)</code> has edges <code class="reqn">AB</code>, <code class="reqn">BC</code>, <code class="reqn">AC</code> which are also labeled as edges 3, 1, and 2, respectively.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.setCStri(S, Xp, tri, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.setCStri_+3A_s">S</code></td>
<td>
<p>A set of 2D points which is to be tested for being a dominating set for the CS-PCDs.</p>
</td></tr>
<tr><td><code id="Idom.setCStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="Idom.setCStri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.setCStri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region
constructed in the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code id="Idom.setCStri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>S</code> a dominating set of the CS-PCD<code class="reqn">)</code>, that is, returns 1 if <code>S</code> is a dominating set of CS-PCD whose
vertices are the data points in <code>Xp</code>; returns 0 otherwise, where CS proximity region is constructed in
the triangle <code>tri</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.setCSstd.tri">Idom.setCSstd.tri</a></code>, <code><a href="#topic+Idom.setPEtri">Idom.setPEtri</a></code> and <code><a href="#topic+Idom.setAStri">Idom.setAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$gen.points

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

tau&lt;-.5
S&lt;-rbind(Xp[1,],Xp[2,])
Idom.setCStri(S,Xp,Tr,tau,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,])
Idom.setCStri(S,Xp,Tr,tau,M)


</code></pre>

<hr>
<h2 id='Idom.setPEstd.tri'>The indicator for the set of points <code>S</code> being a dominating set
or not for Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
standard equilateral triangle case</h2><span id='topic+Idom.setPEstd.tri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>S</code> a dominating set of PE-PCD
whose vertices are the data points <code>Xp</code><code class="reqn">)</code>
for <code>S</code> in the standard equilateral triangle,
that is,
returns 1 if <code>S</code> is a dominating set of PE-PCD,
and returns 0 otherwise.
</p>
<p>PE proximity region is constructed
with respect to the standard equilateral triangle
<code class="reqn">T_e=T(A,B,C)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> with
expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_e</code>
(which is also equivalent to the circumcenter of <code class="reqn">T_e</code>).
Vertices of <code class="reqn">T_e</code> are also labeled as 1, 2, and 3,
respectively.
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.setPEstd.tri(S, Xp, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.setPEstd.tri_+3A_s">S</code></td>
<td>
<p>A set of 2D points
whose PE proximity regions are considered.</p>
</td></tr>
<tr><td><code id="Idom.setPEstd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitutes the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.setPEstd.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region in the
standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.setPEstd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard equilateral triangle <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>S</code> a dominating set of PE-PCD<code class="reqn">)</code> for <code>S</code>
in the standard equilateral triangle,
that is, returns 1 if <code>S</code> is a dominating set of PE-PCD,
and returns 0 otherwise,
where PE proximity region is constructed in the standard equilateral triangle <code class="reqn">T_e</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.setPEtri">Idom.setPEtri</a></code> and <code><a href="#topic+Idom.setCSstd.tri">Idom.setCSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

r&lt;-1.5

S&lt;-rbind(Xp[1,],Xp[2,])
Idom.setPEstd.tri(S,Xp,r,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,],c(.2,.5))
Idom.setPEstd.tri(S,Xp[3,],r,M)


</code></pre>

<hr>
<h2 id='Idom.setPEtri'>The indicator for the set of points <code>S</code> being a dominating set
or not for Proportional Edge Proximity Catch Digraphs (PE-PCDs) -
one triangle case</h2><span id='topic+Idom.setPEtri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">I(</code><code>S</code> a dominating set of PE-PCD
whose vertices are the data set <code>Xp</code><code class="reqn">)</code>, that is,
returns 1 if <code>S</code> is a dominating set of PE-PCD,
and returns 0 otherwise.
</p>
<p>PE proximity region is constructed with
respect to the triangle <code>tri</code>
with the expansion parameter <code class="reqn">r \ge 1</code> and vertex regions are based
on the center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.
The triangle <code>tri</code><code class="reqn">=T(A,B,C)</code> has edges <code class="reqn">AB</code>, <code class="reqn">BC</code>, <code class="reqn">AC</code>
which are also labeled as edges 3, 1, and 2, respectively.
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Idom.setPEtri(S, Xp, tri, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Idom.setPEtri_+3A_s">S</code></td>
<td>
<p>A set of 2D points which is to be tested for
being a dominating set for the PE-PCDs.</p>
</td></tr>
<tr><td><code id="Idom.setPEtri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="Idom.setPEtri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="Idom.setPEtri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region
constructed in the triangle <code>tri</code>; must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="Idom.setPEtri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">I(</code><code>S</code> a dominating set of PE-PCD<code class="reqn">)</code>,
that is, returns 1 if <code>S</code> is a dominating set of PE-PCD whose
vertices are the data points in <code>Xp</code>; and returns 0 otherwise,
where PE proximity region is constructed in
the triangle <code>tri</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Idom.setPEstd.tri">Idom.setPEstd.tri</a></code>, <code><a href="#topic+IarcPEset2pnt.tri">IarcPEset2pnt.tri</a></code>,
<code><a href="#topic+Idom.setCStri">Idom.setCStri</a></code>, and <code><a href="#topic+Idom.setAStri">Idom.setAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$gen.points

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

r&lt;-1.5

S&lt;-rbind(Xp[1,],Xp[2,])
Idom.setPEtri(S,Xp,Tr,r,M)

S&lt;-rbind(Xp[1,],Xp[2,],Xp[3,],Xp[5,])
Idom.setPEtri(S,Xp,Tr,r,M)

S&lt;-rbind(c(.1,.1),c(.3,.4),c(.5,.3))
Idom.setPEtri(S,Xp,Tr,r,M)


</code></pre>

<hr>
<h2 id='in.circle'>Check whether a point is inside a circle</h2><span id='topic+in.circle'></span>

<h3>Description</h3>

<p>Checks if the point <code>p</code> lies
in the circle with center <code>cent</code> and radius <code>rad</code>,
denoted as <code>C(cent,rad)</code>.
So, it returns 1 or <code>TRUE</code> if <code>p</code> is
inside the circle, and 0 otherwise.
</p>
<p><code>boundary</code> is a logical argument (default=<code>FALSE</code>)
to include boundary or not, so if it is <code>TRUE</code>,
the function checks if the point, <code>p</code>,
lies in the closure of the circle (i.e., interior and
boundary combined) else it checks
if <code>p</code> lies in the interior of the circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.circle(p, cent, rad, boundary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.circle_+3A_p">p</code></td>
<td>
<p>A 2D point to be checked
whether it is inside the circle or not.</p>
</td></tr>
<tr><td><code id="in.circle_+3A_cent">cent</code></td>
<td>
<p>A 2D point in Cartesian coordinates
which serves as the center of the circle.</p>
</td></tr>
<tr><td><code id="in.circle_+3A_rad">rad</code></td>
<td>
<p>A positive real number
which serves as the radius of the circle.</p>
</td></tr>
<tr><td><code id="in.circle_+3A_boundary">boundary</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>)
to include boundary or not, so if it is <code>TRUE</code>,
the function checks if the point, <code>p</code>,
lies in the closure of the circle (i.e., interior and
boundary combined); else,
it checks if <code>p</code> lies in the interior of the circle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Indicator for the point <code>p</code> being
inside the circle or not, i.e., returns 1 or <code>TRUE</code>
if <code>p</code> is inside the circle, and 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+in.triangle">in.triangle</a></code>, <code><a href="#topic+in.tetrahedron">in.tetrahedron</a></code>, and
<code><a href="interp.html#topic+on.convex.hull">on.convex.hull</a></code> from the <code>interp</code> package
for documentation for <code>in.convex.hull</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cent&lt;-c(1,1); rad&lt;-1; p&lt;-c(1.4,1.2)
#try also cent&lt;-runif(2); rad&lt;-runif(1); p&lt;-runif(2);

in.circle(p,cent,rad)

p&lt;-c(.4,-.2)
in.circle(p,cent,rad)

p&lt;-c(1,0)
in.circle(p,cent,rad)
in.circle(p,cent,rad,boundary=FALSE)


</code></pre>

<hr>
<h2 id='in.tetrahedron'>Check whether a point is inside a tetrahedron</h2><span id='topic+in.tetrahedron'></span>

<h3>Description</h3>

<p>Checks if the point <code>p</code> lies
in the tetrahedron, <code>th</code>,
using the barycentric coordinates, generally denoted as
<code class="reqn">(\alpha,\beta,\gamma)</code>.
If all (normalized or non-normalized) barycentric coordinates are positive
then the point <code>p</code> is inside the tetrahedron,
if all are nonnegative with one or more are zero,
then <code>p</code> falls on the boundary.
If some of the barycentric coordinates are negative,
then <code>p</code> falls outside the tetrahedron.
</p>
<p><code>boundary</code> is a logical argument (default=<code>FALSE</code>)
to include boundary or not, so if it is <code>TRUE</code>,
the function checks if the point, <code>p</code>,
lies in the closure of the tetrahedron (i.e., interior and boundary
combined) else it checks if <code>p</code> lies
in the interior of the tetrahedron.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.tetrahedron(p, th, boundary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.tetrahedron_+3A_p">p</code></td>
<td>
<p>A 3D point to be checked
whether it is inside the tetrahedron or not.</p>
</td></tr>
<tr><td><code id="in.tetrahedron_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row
representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="in.tetrahedron_+3A_boundary">boundary</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>)
to include boundary or not, so if it is <code>TRUE</code>,
the function checks if the point, <code>p</code>,
lies in the closure of the tetrahedron (i.e., interior and boundary
combined); else, it checks if <code>p</code>
lies in the interior of the tetrahedron.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>in.tetra</code></td>
<td>
<p>A logical output, if the point, <code>p</code>,
is inside the tetrahedron, <code>th</code>, it is <code>TRUE</code>,
else it is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>barycentric</code></td>
<td>
<p>The barycentric coordinates of the point <code>p</code>
with respect to the tetrahedron, <code>th</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+in.triangle">in.triangle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0);
D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3); P&lt;-c(.1,.1,.1)
tetra&lt;-rbind(A,B,C,D)

in.tetrahedron(P,tetra,boundary = FALSE)

in.tetrahedron(C,tetra)
in.tetrahedron(C,tetra,boundary = FALSE)

n1&lt;-5; n2&lt;-5; n&lt;-n1+n2
Xp&lt;-rbind(cbind(runif(n1),runif(n1,0,sqrt(3)/2),runif(n1,0,sqrt(6)/3)),
          runif.tetra(n2,tetra)$g)

in.tetra&lt;-vector()
for (i in 1:n)
{in.tetra&lt;-c(in.tetra,in.tetrahedron(Xp[i,],tetra,boundary = TRUE)$in.tetra) }

in.tetra
dat.tet&lt;-Xp[in.tetra,]
if (is.vector(dat.tet)) {dat.tet&lt;-matrix(dat.tet,nrow=1)}

Xlim&lt;-range(tetra[,1],Xp[,1])
Ylim&lt;-range(tetra[,2],Xp[,2])
Zlim&lt;-range(tetra[,3],Xp[,3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::scatter3D(Xp[,1],Xp[,2],Xp[,3], phi=40,theta=40,
bty = "g", pch = 20, cex = 1,
ticktype="detailed",xlim=Xlim+xd*c(-.05,.05),
ylim=Ylim+yd*c(-.05,.05),zlim=Zlim+zd*c(-.05,.05))
#add the vertices of the tetrahedron
plot3D::points3D(tetra[,1],tetra[,2],tetra[,3], add=TRUE)
plot3D::points3D(dat.tet[,1],dat.tet[,2],dat.tet[,3],pch=4, add=TRUE)
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lwd=2)

plot3D::text3D(tetra[,1],tetra[,2],tetra[,3],
labels=c("A","B","C","D"), add=TRUE)

in.tetrahedron(P,tetra) #this works fine


</code></pre>

<hr>
<h2 id='in.tri.all'>Check whether all points in a data set are inside the triangle</h2><span id='topic+in.tri.all'></span>

<h3>Description</h3>

<p>Checks if all the data points in the 2D data set, <code>Xp</code>,
lie in the triangle, <code>tri</code>,
using the barycentric coordinates,
generally denoted as <code class="reqn">(\alpha,\beta,\gamma)</code>.
</p>
<p>If all (normalized or non-normalized) barycentric coordinates of a point
are positive then the point is
inside the triangle, if all are nonnegative with one or more are zero,
then the point falls in the boundary.
If some of the barycentric coordinates are negative,
then the point falls outside the triangle.
</p>
<p><code>boundary</code> is a logical argument (default=<code>TRUE</code>)
to include boundary or not, so if it is <code>TRUE</code>,
the function checks if a point lies in the closure of the triangle
(i.e., interior and boundary combined);
else, it checks if the point lies in the interior of the triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.tri.all(Xp, tri, boundary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.tri.all_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points.</p>
</td></tr>
<tr><td><code id="in.tri.all_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="in.tri.all_+3A_boundary">boundary</code></td>
<td>
<p>A logical parameter (default=<code>FALSE</code>)
to include boundary or not, so if it is <code>TRUE</code>,
the function checks if a point lies in the closure of the triangle
(i.e., interior and boundary combined)
else it checks if the point lies in the interior of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical output,
if all data points in <code>Xp</code> are inside the triangle, <code>tri</code>,
the output is <code>TRUE</code>,
else it is <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+in.triangle">in.triangle</a></code> and <code><a href="interp.html#topic+on.convex.hull">on.convex.hull</a></code>
from the <code>interp</code> package for documentation for <code>in.convex.hull</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2); p&lt;-c(1.4,1.2)

Tr&lt;-rbind(A,B,C)

in.tri.all(p,Tr)

#for the vertex A
in.tri.all(A,Tr)
in.tri.all(A,Tr,boundary = FALSE)

#for a point on the edge AB
D3&lt;-(A+B)/2
in.tri.all(D3,Tr)
in.tri.all(D3,Tr,boundary = FALSE)

#data set
n&lt;-10
Xp&lt;-cbind(runif(n),runif(n))
in.tri.all(Xp,Tr,boundary = TRUE)

Xp&lt;-runif.std.tri(n)$gen.points
in.tri.all(Xp,Tr)
in.tri.all(Xp,Tr,boundary = FALSE)

Xp&lt;-runif.tri(n,Tr)$g
in.tri.all(Xp,Tr)
in.tri.all(Xp,Tr,boundary = FALSE)


</code></pre>

<hr>
<h2 id='in.triangle'>Check whether a point is inside a triangle</h2><span id='topic+in.triangle'></span>

<h3>Description</h3>

<p>Checks if the point <code>p</code> lies in the triangle,
<code>tri</code>, using the barycentric
coordinates, generally denoted as <code class="reqn">(\alpha,\beta,\gamma)</code>.
</p>
<p>If all (normalized or non-normalized)
barycentric coordinates are positive then the point <code>p</code> is
inside the triangle,
if all are nonnegative with one or more are zero,
then <code>p</code> falls in the boundary. If some of the
barycentric coordinates are negative,
then <code>p</code> falls outside the triangle.
</p>
<p><code>boundary</code> is a logical argument (default=<code>TRUE</code>)
to include boundary or not, so if it is <code>TRUE</code>,
the function checks if the point, <code>p</code>,
lies in the closure of the triangle (i.e., interior and boundary
combined); else, it checks if <code>p</code> lies
in the interior of the triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.triangle(p, tri, boundary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in.triangle_+3A_p">p</code></td>
<td>
<p>A 2D point to be checked
whether it is inside the triangle or not.</p>
</td></tr>
<tr><td><code id="in.triangle_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="in.triangle_+3A_boundary">boundary</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>)
to include boundary or not, so if it is <code>TRUE</code>,
the function checks if the point, <code>p</code>,
lies in the closure of the triangle (i.e., interior and boundary
combined); else, it checks if <code>p</code>
lies in the interior of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>in.tri</code></td>
<td>
<p>A logical output, it is <code>TRUE</code>,
if the point, <code>p</code>, is inside the triangle, <code>tri</code>,
else it is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>barycentric</code></td>
<td>
<p>The barycentric coordinates <code class="reqn">(\alpha,\beta,\gamma)</code>
of the point <code>p</code> with respect to
the triangle, <code>tri</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+in.tri.all">in.tri.all</a></code> and <code><a href="interp.html#topic+on.convex.hull">on.convex.hull</a></code>
from the <code>interp</code> package for documentation for <code>in.convex.hull</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2); p&lt;-c(1.4,1.2)
Tr&lt;-rbind(A,B,C)
in.triangle(p,Tr)

p&lt;-c(.4,-.2)
in.triangle(p,Tr)

#for the vertex A
in.triangle(A,Tr)
in.triangle(A,Tr,boundary = FALSE)

#for a point on the edge AB
D3&lt;-(A+B)/2
in.triangle(D3,Tr)
in.triangle(D3,Tr,boundary = FALSE)

#for a NA entry point
p&lt;-c(NA,.2)
in.triangle(p,Tr)


</code></pre>

<hr>
<h2 id='inci.matAS'>Incidence matrix for Arc Slice Proximity Catch Digraphs (AS-PCDs)
- multiple triangle case</h2><span id='topic+inci.matAS'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the AS-PCD
whose vertices are a given 2D numerical data set, <code>Xp</code>,
in the convex hull of <code>Yp</code> which is partitioned
by the Delaunay triangles based on <code>Yp</code> points.
</p>
<p>AS proximity regions are defined with respect to
the Delaunay triangles based on <code>Yp</code> points and vertex
regions are based on the center <code>M="CC"</code>
for circumcenter of each Delaunay triangle
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the
interior of each Delaunay triangle;
default is <code>M="CC"</code> i.e., circumcenter of each triangle.
</p>
<p>Each Delaunay triangle is first converted to
an (nonscaled) basic triangle so that <code>M</code> will be the same
type of center for each Delaunay triangle
(this conversion is not necessary when <code>M</code> is <code class="reqn">CM</code>).
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
For the incidence matrix loops are allowed,
so the diagonal entries are all equal to 1.
</p>
<p>See (Ceyhan (2005, 2010))
for more on AS-PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation
and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matAS(Xp, Yp, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matAS_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="inci.matAS_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="inci.matAS_+3A_m">M</code></td>
<td>
<p>The center of the triangle.
<code>"CC"</code> stands for circumcenter of each Delaunay triangle or 3D point in barycentric
coordinates which serves as a center in the interior of each Delaunay triangle;
default is <code>M="CC"</code> i.e., the circumcenter of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the AS-PCD whose vertices are the 2D data set, <code>Xp</code>,
and AS proximity regions are defined in the Delaunay triangles based on <code>Yp</code> points.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matAStri">inci.matAStri</a></code>, <code><a href="#topic+inci.matPE">inci.matPE</a></code>, and <code><a href="#topic+inci.matCS">inci.matCS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-"CC"  #try also M&lt;-c(1,1,1)

IM&lt;-inci.matAS(Xp,Yp,M)
IM
dom.num.greedy(IM)  #try also dom.num.exact(IM)  #this might take a long time for large  nx

IM&lt;-inci.matAS(Xp,Yp[1:3,],M)

inci.matAS(Xp,rbind(Yp,Yp))


</code></pre>

<hr>
<h2 id='inci.matAStri'>Incidence matrix for Arc Slice Proximity Catch Digraphs
(AS-PCDs) - one triangle case</h2><span id='topic+inci.matAStri'></span>

<h3>Description</h3>

<p>Returns the incidence matrix of the AS-PCD
whose vertices are the given 2D numerical data set, <code>Xp</code>,
in the triangle <code>tri</code><code class="reqn">=T(v=1,v=2,v=3)</code>.
</p>
<p>AS proximity regions are defined with respect to the triangle <code>tri</code><code class="reqn">=T(v=1,v=2,v=3)</code> and
vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matAStri(Xp, tri, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matAStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of AS-PCD.</p>
</td></tr>
<tr><td><code id="inci.matAStri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="inci.matAStri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center in the interior of <code>tri</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the AS-PCD whose vertices are the 2D data set, <code>Xp</code>,
and AS proximity regions are defined with respect to the triangle <code>tri</code> and
vertex regions based on the center <code>M</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matAS">inci.matAS</a></code>, <code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, and <code><a href="#topic+inci.matCStri">inci.matCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

IM&lt;-inci.matAStri(Xp,Tr,M)
IM

dom.num.greedy(IM)
dom.num.exact(IM)


</code></pre>

<hr>
<h2 id='inci.matCS'>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs) - multiple triangle case</h2><span id='topic+inci.matCS'></span>

<h3>Description</h3>

<p>Returns the incidence matrix of Central Similarity Proximity Catch Digraph (CS-PCD) whose vertices are the
data points in <code>Xp</code> in the multiple triangle case.
</p>
<p>CS proximity regions are defined with respect to the
Delaunay triangles based on <code>Yp</code> points with expansion parameter <code class="reqn">t&gt;0</code> and edge regions in each triangle are
based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of each Delaunay
triangle (default for <code class="reqn">M=(1,1,1)</code> which is the center of mass of the triangle).
Each Delaunay triangle is first converted to an (nonscaled) basic triangle so that <code>M</code> will be the same
type of center for each Delaunay triangle (this conversion is not necessary when <code>M</code> is <code class="reqn">CM</code>).
</p>
<p>Convex hull of <code>Yp</code> is partitioned by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles whose union constitutes the
convex hull of <code>Yp</code> points). For the incidence matrix loops are allowed,
so the diagonal entries are all equal to 1.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)) for more on CS-PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016)) for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matCS(Xp, Yp, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matCS_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="inci.matCS_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="inci.matCS_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="inci.matCS_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates which serves as a center in the interior of each Delaunay
triangle, default for <code class="reqn">M=(1,1,1)</code> which is the center of mass of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the CS-PCD with vertices being 2D data set, <code>Xp</code>.
CS proximity regions are constructed with respect to the Delaunay triangles and <code>M</code>-edge regions.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matCStri">inci.matCStri</a></code>, <code><a href="#topic+inci.matCSstd.tri">inci.matCSstd.tri</a></code>, <code><a href="#topic+inci.matAS">inci.matAS</a></code>,
and <code><a href="#topic+inci.matPE">inci.matPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

t&lt;-1.5  #try also t&lt;-2

IM&lt;-inci.matCS(Xp,Yp,t,M)
IM
dom.num.greedy(IM) #try also dom.num.exact(IM)  #takes a very long time for large nx, try smaller nx
Idom.num.up.bnd(IM,3)  #takes a very long time for large nx, try smaller nx


</code></pre>

<hr>
<h2 id='inci.matCS1D'>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs)
for 1D data - multiple interval case</h2><span id='topic+inci.matCS1D'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the CS-PCD
for a given 1D numerical data set, <code>Xp</code>,
as the vertices of the digraph and
<code>Yp</code> determines the end points of the intervals (in the multi-interval case).
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>CS proximity region is constructed
with an expansion parameter <code class="reqn">t&gt;0</code> and a centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matCS1D(Xp, Yp, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matCS1D_+3A_xp">Xp</code></td>
<td>
<p>a set of 1D points which constitutes the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="inci.matCS1D_+3A_yp">Yp</code></td>
<td>
<p>a set of 1D points which constitutes the end points of the intervals
that partition the real line.</p>
</td></tr>
<tr><td><code id="inci.matCS1D_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="inci.matCS1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the CS-PCD with vertices being 1D data set, <code>Xp</code>,
and <code>Yp</code> determines the end points of the intervals (the multi-interval case)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matCS1D">inci.matCS1D</a></code>, <code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, and <code><a href="#topic+inci.matPE">inci.matPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10;
nx&lt;-10; ny&lt;-4

set.seed(1)
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

IM&lt;-inci.matCS1D(Xp,Yp,t,c)
IM
dom.num.greedy(IM)

dom.num.exact(IM)  #might take a long time depending on nx

Idom.num.up.bnd(IM,5)

Arcs&lt;-arcsCS1D(Xp,Yp,t,c)
Arcs
summary(Arcs)
plot(Arcs)

inci.matCS1D(Xp,Yp+10,t,c)

t&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10;
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

inci.matCS1D(Xp,Yp,t,c)

</code></pre>

<hr>
<h2 id='inci.matCSint'>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs)
for 1D data - one interval case</h2><span id='topic+inci.matCSint'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the CS-PCD for a given 1D numerical data set, <code>Xp</code>,
as the vertices of the digraph and <code>int</code> determines the end points of the interval (in the one interval case).
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>CS proximity region is constructed
with an expansion parameter <code class="reqn">t &gt; 0</code> and a centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matCSint(Xp, int, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matCSint_+3A_xp">Xp</code></td>
<td>
<p>a set of 1D points which constitutes the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="inci.matCSint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="inci.matCSint_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="inci.matCSint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the CS-PCD with vertices being 1D data set, <code>Xp</code>,
and <code>int</code> determines the end points of the intervals (in the one interval case)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matCS1D">inci.matCS1D</a></code>, <code><a href="#topic+inci.matPE1D">inci.matPE1D</a></code>,
<code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, and <code><a href="#topic+inci.matPE">inci.matPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
t&lt;-1
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

xf&lt;-(int[2]-int[1])*.1

set.seed(123)

n&lt;-10
Xp&lt;-runif(n,a-xf,b+xf)

IM&lt;-inci.matCSint(Xp,int,t,c)
IM

dom.num.greedy(IM)
Idom.num.up.bnd(IM,3)
dom.num.exact(IM)

inci.matCSint(Xp,int+10,t,c)


</code></pre>

<hr>
<h2 id='inci.matCSstd.tri'>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs) - standard
equilateral triangle case</h2><span id='topic+inci.matCSstd.tri'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the CS-PCD whose vertices are the given 2D numerical data set, <code>Xp</code>,
in the standard equilateral triangle <code class="reqn">T_e=T(v=1,v=2,v=3)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>.
</p>
<p>CS proximity region is defined with respect to the standard equilateral triangle
<code class="reqn">T_e=T(v=1,v=2,v=3)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_e</code>.
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matCSstd.tri(Xp, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matCSstd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="inci.matCSstd.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="inci.matCSstd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates.
which serves as a center in the interior of the standard equilateral triangle <code class="reqn">T_e</code>; default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the CS-PCD with vertices being 2D data set, <code>Xp</code> and CS proximity
regions are defined in the standard equilateral triangle <code class="reqn">T_e</code> with <code>M</code>-edge regions.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matCStri">inci.matCStri</a></code>, <code><a href="#topic+inci.matCS">inci.matCS</a></code> and <code><a href="#topic+inci.matPEstd.tri">inci.matPEstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

inc.mat&lt;-inci.matCSstd.tri(Xp,t=1.25,M)
inc.mat
sum(inc.mat)-n
num.arcsCSstd.tri(Xp,t=1.25)

dom.num.greedy(inc.mat) #try also dom.num.exact(inc.mat)  #might take a long time for large n
Idom.num.up.bnd(inc.mat,1)


</code></pre>

<hr>
<h2 id='inci.matCStri'>Incidence matrix for Central Similarity Proximity Catch Digraphs (CS-PCDs) - one triangle case</h2><span id='topic+inci.matCStri'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the CS-PCD whose vertices are the given 2D numerical data set, <code>Xp</code>,
in the triangle <code>tri</code><code class="reqn">=T(v=1,v=2,v=3)</code>.
</p>
<p>CS proximity regions are constructed with respect to triangle <code>tri</code>
with expansion parameter <code class="reqn">t&gt;0</code> and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matCStri(Xp, tri, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matCStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of CS-PCD.</p>
</td></tr>
<tr><td><code id="inci.matCStri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="inci.matCStri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="inci.matCStri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the CS-PCD with vertices being 2D data set, <code>Xp</code>,
in the triangle <code>tri</code> with edge regions based on center <code>M</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matCS">inci.matCS</a></code>, <code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, and  <code><a href="#topic+inci.matAStri">inci.matAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);

Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

IM&lt;-inci.matCStri(Xp,Tr,t=1.25,M)
IM
dom.num.greedy(IM) #try also dom.num.exact(IM)
Idom.num.up.bnd(IM,3)

inci.matCStri(Xp,Tr,t=1.5,M)


</code></pre>

<hr>
<h2 id='inci.matPE'>Incidence matrix for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - multiple triangle case</h2><span id='topic+inci.matPE'></span>

<h3>Description</h3>

<p>Returns the incidence matrix of
Proportional Edge Proximity Catch Digraph (PE-PCD)
whose vertices are the data points in <code>Xp</code>
in the multiple triangle case.
</p>
<p>PE proximity regions are
defined with respect to the Delaunay triangles
based on <code>Yp</code> points with expansion parameter <code class="reqn">r \ge 1</code> and
vertex regions in each triangle are
based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates
in the interior of each Delaunay triangle
or based on circumcenter of each Delaunay triangle
(default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of the triangle).
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
For the incidence matrix loops are allowed,
so the diagonal entries are all equal to 1.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011))
for more on the PE-PCDs.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matPE(Xp, Yp, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matPE_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="inci.matPE_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="inci.matPE_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="inci.matPE_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates
which serves as a center in the interior of each Delaunay
triangle or circumcenter of each Delaunay triangle
(for this, argument should be set as <code>M="CC"</code>),
default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the PE-PCD
with vertices being 2D data set, <code>Xp</code>.
PE proximity regions are constructed
with respect to the Delaunay triangles and <code>M</code>-vertex regions.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, <code><a href="#topic+inci.matPEstd.tri">inci.matPEstd.tri</a></code>,
<code><a href="#topic+inci.matAS">inci.matAS</a></code>, and <code><a href="#topic+inci.matCS">inci.matCS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

r&lt;-1.5  #try also r&lt;-2

IM&lt;-inci.matPE(Xp,Yp,r,M)
IM
dom.num.greedy(IM)
#try also dom.num.exact(IM)
#might take a long time in this brute-force fashion ignoring the
#disconnected nature of the digraph inherent by the geometric construction of it


</code></pre>

<hr>
<h2 id='inci.matPE1D'>Incidence matrix for Proportional-Edge Proximity Catch Digraphs (PE-PCDs)
for 1D data - multiple interval case</h2><span id='topic+inci.matPE1D'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the PE-PCD
for a given 1D numerical data set, <code>Xp</code>,
as the vertices of the digraph
and <code>Yp</code> determines the end points of the intervals (in the multi-interval case).
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>PE proximity region is constructed
with an expansion parameter <code class="reqn">r \ge 1</code> and a centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matPE1D(Xp, Yp, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matPE1D_+3A_xp">Xp</code></td>
<td>
<p>a set of 1D points which constitutes the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="inci.matPE1D_+3A_yp">Yp</code></td>
<td>
<p>a set of 1D points which constitutes the end points of the intervals
that partition the real line.</p>
</td></tr>
<tr><td><code id="inci.matPE1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="inci.matPE1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the PE-PCD with vertices being 1D data set, <code>Xp</code>,
and <code>Yp</code> determines the end points of the intervals (in the multi-interval case)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matCS1D">inci.matCS1D</a></code>, <code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, and <code><a href="#topic+inci.matPE">inci.matPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10;
nx&lt;-10; ny&lt;-4

set.seed(1)
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

IM&lt;-inci.matPE1D(Xp,Yp,r,c)
IM

dom.num.greedy(IM)
Idom.num.up.bnd(IM,6)
dom.num.exact(IM)


</code></pre>

<hr>
<h2 id='inci.matPEint'>Incidence matrix for Proportional-Edge Proximity Catch Digraphs (PE-PCDs)
for 1D data - one interval case</h2><span id='topic+inci.matPEint'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the PE-PCD for a given 1D numerical data set, <code>Xp</code>,
as the vertices of the digraph and <code>int</code> determines the end points of the interval (in the one interval case).
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>PE proximity region is constructed
with an expansion parameter <code class="reqn">r \ge 1</code> and a centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matPEint(Xp, int, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matPEint_+3A_xp">Xp</code></td>
<td>
<p>a set of 1D points which constitutes the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="inci.matPEint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="inci.matPEint_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="inci.matPEint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the PE-PCD with vertices being 1D data set, <code>Xp</code>,
and <code>int</code> determines the end points of the intervals (in the one interval case)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matCSint">inci.matCSint</a></code>, <code><a href="#topic+inci.matPE1D">inci.matPE1D</a></code>, <code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, and <code><a href="#topic+inci.matPE">inci.matPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

xf&lt;-(int[2]-int[1])*.1

set.seed(123)

n&lt;-10
Xp&lt;-runif(n,a-xf,b+xf)

IM&lt;-inci.matPEint(Xp,int,r,c)
IM

dom.num.greedy(IM)
Idom.num.up.bnd(IM,6)
dom.num.exact(IM)

inci.matPEint(Xp,int+10,r,c)


</code></pre>

<hr>
<h2 id='inci.matPEstd.tri'>Incidence matrix for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - standard equilateral triangle case</h2><span id='topic+inci.matPEstd.tri'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the PE-PCD
whose vertices are the given 2D numerical data set, <code>Xp</code>,
in the standard equilateral triangle
<code class="reqn">T_e=T(v=1,v=2,v=3)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>.
</p>
<p>PE proximity region is constructed
with respect to the standard equilateral triangle <code class="reqn">T_e</code> with
expansion parameter <code class="reqn">r \ge 1</code> and vertex regions are based on
the center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of <code class="reqn">T_e</code>; default is <code class="reqn">M=(1,1,1)</code>,
i.e., the center of mass of <code class="reqn">T_e</code>.
Loops are allowed,
so the diagonal entries are all equal to 1.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matPEstd.tri(Xp, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matPEstd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="inci.matPEstd.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="inci.matPEstd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard equilateral triangle <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the PE-PCD with vertices
being 2D data set, <code>Xp</code>
in the standard equilateral triangle where PE proximity
regions are defined with <code>M</code>-vertex regions.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, <code><a href="#topic+inci.matPE">inci.matPE</a></code>,
and <code><a href="#topic+inci.matCSstd.tri">inci.matCSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
n&lt;-10

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

inc.mat&lt;-inci.matPEstd.tri(Xp,r=1.25,M)
inc.mat
sum(inc.mat)-n
num.arcsPEstd.tri(Xp,r=1.25)

dom.num.greedy(inc.mat)
Idom.num.up.bnd(inc.mat,2) #try also dom.num.exact(inc.mat)


</code></pre>

<hr>
<h2 id='inci.matPEtetra'>Incidence matrix for Proportional Edge Proximity Catch Digraphs (PE-PCDs) - one tetrahedron case</h2><span id='topic+inci.matPEtetra'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the PE-PCD whose vertices are the given 3D numerical data set, <code>Xp</code>,
in the tetrahedron <code class="reqn">th=T(v=1,v=2,v=3,v=4)</code>.
</p>
<p>PE proximity regions are constructed with respect to tetrahedron
<code>th</code> with expansion parameter <code class="reqn">r \ge 1</code> and vertex regions are based on the center <code>M</code> which is circumcenter (<code>"CC"</code>)
or center of mass (<code>"CM"</code>) of <code>th</code> with default=<code>"CM"</code>.
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matPEtetra(Xp, th, r, M = "CM")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matPEtetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitute the vertices of PE-PCD.</p>
</td></tr>
<tr><td><code id="inci.matPEtetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="inci.matPEtetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="inci.matPEtetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the PE-PCD with vertices being 3D data set, <code>Xp</code>,
in the tetrahedron <code>th</code> with vertex regions based on circumcenter or center of mass
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matPEtri">inci.matPEtri</a></code>, <code><a href="#topic+inci.matPE1D">inci.matPE1D</a></code>, and  <code><a href="#topic+inci.matPE">inci.matPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-5

Xp&lt;-runif.tetra(n,tetra)$g  #try also Xp&lt;-c(.5,.5,.5)

M&lt;-"CM"  #try also M&lt;-"CC"
r&lt;-1.5

IM&lt;-inci.matPEtetra(Xp,tetra,r=1.25)  #uses the default M="CM"
IM&lt;-inci.matPEtetra(Xp,tetra,r=1.25,M)
IM
dom.num.greedy(IM)
Idom.num.up.bnd(IM,3) #try also dom.num.exact(IM)  #this might take a long time for large n


</code></pre>

<hr>
<h2 id='inci.matPEtri'>Incidence matrix for Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - one triangle case</h2><span id='topic+inci.matPEtri'></span>

<h3>Description</h3>

<p>Returns the incidence matrix for the PE-PCD
whose vertices are the given 2D numerical data set, <code>Xp</code>,
in the triangle <code>tri</code><code class="reqn">=T(v=1,v=2,v=3)</code>.
</p>
<p>PE proximity regions are constructed with respect to triangle <code>tri</code>
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.
Loops are allowed, so the diagonal entries are all equal to 1.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inci.matPEtri(Xp, tri, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inci.matPEtri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of PE-PCD.</p>
</td></tr>
<tr><td><code id="inci.matPEtri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="inci.matPEtri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="inci.matPEtri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix for the PE-PCD
with vertices being 2D data set, <code>Xp</code>,
in the triangle <code>tri</code> with vertex regions based on center <code>M</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inci.matPE">inci.matPE</a></code>, <code><a href="#topic+inci.matCStri">inci.matCStri</a></code>,
and  <code><a href="#topic+inci.matAStri">inci.matAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)
IM&lt;-inci.matPEtri(Xp,Tr,r=1.25,M)

IM
dom.num.greedy(IM) #try also dom.num.exact(IM)
Idom.num.up.bnd(IM,3)


</code></pre>

<hr>
<h2 id='index.six.Te'>Region index inside the Gamma-1 region</h2><span id='topic+index.six.Te'></span>

<h3>Description</h3>

<p>Returns the region index of the point <code>p</code>
for the 6 regions in standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>,
starting with 1 on the first one-sixth of the triangle,
and numbering follows the counter-clockwise direction
(see the plot in the examples).
These regions are in the inner hexagon
which is the Gamma-1 region for CS-PCD with <code class="reqn">t=1</code>
if <code>p</code> is not in any of the 6 regions the function returns <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.six.Te(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index.six.Te_+3A_p">p</code></td>
<td>
<p>A 2D point whose index for the 6 regions
in standard equilateral triangle <code class="reqn">T_e</code> is determined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rel An integer between 1-6 (inclusive) or <code>NA</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif.std.tri.onesixth">runif.std.tri.onesixth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(.4,.2)
index.six.Te(P)

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(0.5,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
CM&lt;-(A+B+C)/3
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

h1&lt;-c(1/2,sqrt(3)/18); h2&lt;-c(2/3, sqrt(3)/9); h3&lt;-c(2/3, 2*sqrt(3)/9);
h4&lt;-c(1/2, 5*sqrt(3)/18); h5&lt;-c(1/3, 2*sqrt(3)/9); h6&lt;-c(1/3, sqrt(3)/9);

r1&lt;-(h1+h6+CM)/3;r2&lt;-(h1+h2+CM)/3;r3&lt;-(h2+h3+CM)/3;
r4&lt;-(h3+h4+CM)/3;r5&lt;-(h4+h5+CM)/3;r6&lt;-(h5+h6+CM)/3;

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
L&lt;-Te; R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
polygon(rbind(h1,h2,h3,h4,h5,h6))

txt&lt;-rbind(h1,h2,h3,h4,h5,h6)
xc&lt;-txt[,1]+c(-.02,.02,.02,0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.02,0,0,0)
txt.str&lt;-c("h1","h2","h3","h4","h5","h6")
text(xc,yc,txt.str)

txt&lt;-rbind(Te,CM,r1,r2,r3,r4,r5,r6)
xc&lt;-txt[,1]+c(-.02,.02,.02,0,0,0,0,0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.02,0,0,0,0,0,0,0)
txt.str&lt;-c("A","B","C","CM","1","2","3","4","5","6")
text(xc,yc,txt.str)

n&lt;-10  #try also n&lt;-40
Xp&lt;-runif.std.tri(n)$gen.points

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

rsix&lt;-vector()
for (i in 1:n)
  rsix&lt;-c(rsix,index.six.Te(Xp[i,]))
rsix

plot(A,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
points(Xp,pch=".")
L&lt;-Te; R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
polygon(rbind(h1,h2,h3,h4,h5,h6))
text(Xp,labels=factor(rsix))

txt&lt;-rbind(Te,CM)
xc&lt;-txt[,1]+c(-.02,.02,.02,0)
yc&lt;-txt[,2]+c(.02,.02,.02,-.05)
txt.str&lt;-c("A","B","C","CM")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='intersect.line.circle'>The points of intersection of a line and a circle</h2><span id='topic+intersect.line.circle'></span>

<h3>Description</h3>

<p>Returns the intersection point(s) of a line and a circle. The line is determined by the two points
<code>p1</code> and <code>p2</code> and the circle is centered at point <code>cent</code> and has radius <code>rad</code>.
If the circle does not intersect the line, the function yields <code>NULL</code>;
if the circle intersects at only one point, it yields only that point;
otherwise it yields both intersection points as output.
When there are two intersection points, they are listed in the order of the <code class="reqn">x</code>-coordinates of <code>p1</code> and <code>p2</code>;
and if the <code class="reqn">x</code>-coordinates of <code>p1</code> and <code>p2</code> are equal, intersection points are listed in the order of
<code class="reqn">y</code>-coordinates of <code>p1</code> and <code>p2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect.line.circle(p1, p2, cent, rad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect.line.circle_+3A_p1">p1</code>, <code id="intersect.line.circle_+3A_p2">p2</code></td>
<td>
<p>2D points that determine the straight line (i.e., through which the straight line passes).</p>
</td></tr>
<tr><td><code id="intersect.line.circle_+3A_cent">cent</code></td>
<td>
<p>A 2D point representing the center of the circle.</p>
</td></tr>
<tr><td><code id="intersect.line.circle_+3A_rad">rad</code></td>
<td>
<p>A positive real number representing the radius of the circle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>point(s) of intersection between the circle and the line (if they do not intersect, the function
yields <code>NULL</code> as the output)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect2lines">intersect2lines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P1&lt;-c(.3,.2)*100
P2&lt;-c(.6,.3)*100
cent&lt;-c(1.1,1.1)*100
rad&lt;-2*100

intersect.line.circle(P1,P2,cent,rad)
intersect.line.circle(P2,P1,cent,rad)
intersect.line.circle(P1,P1+c(0,1),cent,rad)
intersect.line.circle(P1+c(0,1),P1,cent,rad)

dist.point2line(cent,P1,P2)
rad2&lt;-dist.point2line(cent,P1,P2)$d
intersect.line.circle(P1,P2,cent,rad2)
intersect.line.circle(P1,P2,cent,rad=.8)
intersect.line.circle(P1,P2,cent,rad=.78)

#plot of the line and the circle
A&lt;-c(.3,.2); B&lt;-c(.6,.3); cent&lt;-c(1,1); rad&lt;-2 #check dist.point2line(cent,A,B)$dis, .3

IPs&lt;-intersect.line.circle(A,B,cent,rad)

xr&lt;-range(A[1],B[1],cent[1])
xf&lt;-(xr[2]-xr[1])*.1 #how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-rad-xf,xr[2]+rad+xf,l=20)  #try also l=100
lnAB&lt;-Line(A,B,x)
y&lt;-lnAB$y

Xlim&lt;-range(x,cent[1])
Ylim&lt;-range(y,A[2],B[2],cent[2]-rad,cent[2]+rad)
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(rbind(A,B,cent),pch=1,asp=1,xlab="x",ylab="y",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
lines(x,y,lty=1)
interp::circles(cent[1],cent[2],rad)
IP.txt&lt;-c()
if (!is.null(IPs))
{
  for (i in 1:(length(IPs)/2))
    IP.txt&lt;-c(IP.txt,paste("I",i, sep = ""))
}
txt&lt;-rbind(A,B,cent,IPs)
text(txt+cbind(rep(xd*.03,nrow(txt)),rep(-yd*.03,nrow(txt))),c("A","B","M",IP.txt))


</code></pre>

<hr>
<h2 id='intersect.line.plane'>The point of intersection of a line and a plane</h2><span id='topic+intersect.line.plane'></span>

<h3>Description</h3>

<p>Returns the point of the intersection of the line
determined by the 3D points <code class="reqn">p_1</code> and <code class="reqn">p_2</code>
and the plane spanned
by 3D points <code>p3</code>, <code>p4</code>, and <code>p5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect.line.plane(p1, p2, p3, p4, p5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect.line.plane_+3A_p1">p1</code>, <code id="intersect.line.plane_+3A_p2">p2</code></td>
<td>
<p>3D points that determine the straight line
(i.e., through which the straight line passes).</p>
</td></tr>
<tr><td><code id="intersect.line.plane_+3A_p3">p3</code>, <code id="intersect.line.plane_+3A_p4">p4</code>, <code id="intersect.line.plane_+3A_p5">p5</code></td>
<td>
<p>3D points that determine the plane
(i.e., through which the plane passes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coordinates of the point of intersection the line
determined by the 3D points <code class="reqn">p_1</code> and <code class="reqn">p_2</code> and the
plane determined by 3D points <code>p3</code>, <code>p4</code>, and <code>p5</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect2lines">intersect2lines</a></code> and <code><a href="#topic+intersect.line.circle">intersect.line.circle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
L1&lt;-c(2,4,6); L2&lt;-c(1,3,5);
A&lt;-c(1,10,3); B&lt;-c(1,1,3); C&lt;-c(3,9,12)

Pint&lt;-intersect.line.plane(L1,L2,A,B,C)
Pint
pts&lt;-rbind(L1,L2,A,B,C,Pint)

tr&lt;-max(Dist(L1,L2),Dist(L1,Pint),Dist(L2,Pint))
tf&lt;-tr*1.1 #how far to go at the lower and upper ends in the x-coordinate
tsq&lt;-seq(-tf,tf,l=5)  #try also l=10, 20, or 100

lnAB3D&lt;-Line3D(L1,L2,tsq)
xl&lt;-lnAB3D$x
yl&lt;-lnAB3D$y
zl&lt;-lnAB3D$z

xr&lt;-range(pts[,1]); yr&lt;-range(pts[,2])
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
yf&lt;-(yr[2]-yr[1])*.1
#how far to go at the lower and upper ends in the y-coordinate
xp&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100
yp&lt;-seq(yr[1]-yf,yr[2]+yf,l=5)  #try also l=10, 20, or 100

plABC&lt;-Plane(A,B,C,xp,yp)
z.grid&lt;-plABC$z

res&lt;-persp(xp,yp,z.grid, xlab="x",ylab="y",zlab="z",theta = -30,
phi = 30, expand = 0.5,
col = "lightblue", ltheta = 120, shade = 0.05, ticktype = "detailed")
lines (trans3d(xl, yl, zl, pmat = res), col = 3)

Xlim&lt;-range(xl,pts[,1])
Ylim&lt;-range(yl,pts[,2])
Zlim&lt;-range(zl,pts[,3])

xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::persp3D(z = z.grid, x = xp, y = yp, theta =225, phi = 30,
ticktype = "detailed"
,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),zlim=Zlim+zd*c(-.1,.1),
expand = 0.7, facets = FALSE, scale = TRUE)
        #plane spanned by points A, B, C
#add the defining points
plot3D::points3D(pts[,1],pts[,2],pts[,3], pch = ".", col = "black",
bty = "f", cex = 5,add=TRUE)
plot3D::points3D(Pint[1],Pint[2],Pint[3], pch = "*", col = "red",
bty = "f", cex = 5,add=TRUE)
plot3D::lines3D(xl, yl, zl, bty = "g", cex = 2,
ticktype = "detailed",add=TRUE)


</code></pre>

<hr>
<h2 id='intersect2lines'>The point of intersection of two lines defined
by two pairs of points</h2><span id='topic+intersect2lines'></span>

<h3>Description</h3>

<p>Returns the intersection of two lines,
first line passing through points <code>p1</code> and <code>q1</code>
and second line passing through points <code>p2</code> and <code>q2</code>.
The points are chosen so that lines are well
defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect2lines(p1, q1, p2, q2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect2lines_+3A_p1">p1</code>, <code id="intersect2lines_+3A_q1">q1</code></td>
<td>
<p>2D points that determine the first straight line
(i.e., through which the first straight line passes).</p>
</td></tr>
<tr><td><code id="intersect2lines_+3A_p2">p2</code>, <code id="intersect2lines_+3A_q2">q2</code></td>
<td>
<p>2D points that determine the second straight line
(i.e., through which the second straight line passes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coordinates of the point of intersection of the two lines,
first passing through points <code>p1</code> and <code>q1</code>
and second passing through points <code>p2</code> and <code>q2</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect.line.circle">intersect.line.circle</a></code> and <code><a href="#topic+dist.point2line">dist.point2line</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(-1.22,-2.33); B&lt;-c(2.55,3.75); C&lt;-c(0,6); D&lt;-c(3,-2)

ip&lt;-intersect2lines(A,B,C,D)
ip
pts&lt;-rbind(A,B,C,D,ip)
xr&lt;-range(pts[,1])
xf&lt;-abs(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100
lnAB&lt;-Line(A,B,x)
lnCD&lt;-Line(C,D,x)

y1&lt;-lnAB$y
y2&lt;-lnCD$y
Xlim&lt;-range(x,pts)
Ylim&lt;-range(y1,y2,pts)
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
pf&lt;-c(xd,-yd)*.025

#plot of the line joining A and B
plot(rbind(A,B,C,D),pch=1,xlab="x",ylab="y",
main="Point of Intersection of Two Lines",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
lines(x,y1,lty=1,col=1)
lines(x,y2,lty=1,col=2)
text(rbind(A+pf,B+pf),c("A","B"))
text(rbind(C+pf,D+pf),c("C","D"))
text(rbind(ip+pf),c("intersection\n point"))


</code></pre>

<hr>
<h2 id='interval.indices.set'>Indices of the intervals where the 1D point(s) reside</h2><span id='topic+interval.indices.set'></span>

<h3>Description</h3>

<p>Returns the indices of intervals for all the points in 1D data set,
<code>Xp</code>, as a vector.
</p>
<p>Intervals are based on <code>Yp</code> and left end interval is labeled as 1,
the next interval as 2, and so on.
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval.indices.set(Xp, Yp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval.indices.set_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points for which the indices of intervals are to be determined.</p>
</td></tr>
<tr><td><code id="interval.indices.set_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points from which intervals are constructed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>vector</code> of indices of the intervals in which points in the 1D data set, <code>Xp</code>, reside
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1
Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)  #try also Yp&lt;-runif(ny,a+1,b-1)

ind&lt;-interval.indices.set(Xp,Yp)
ind

jit&lt;-.1
yjit&lt;-runif(nx,-jit,jit)

Xlim&lt;-range(a,b,Xp,Yp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0), xlab=" ", ylab=" ",xlim=Xlim+xd*c(-.05,.05),ylim=3*c(-jit,jit),pch=".")
abline(h=0)
points(Xp, yjit,pch=".",cex=3)
abline(v=Yp,lty=2)
text(Xp,yjit,labels=factor(ind))


</code></pre>

<hr>
<h2 id='is.in.data'>Check a point belong to a given data set</h2><span id='topic+is.in.data'></span>

<h3>Description</h3>

<p>returns <code>TRUE</code> if the point <code>p</code> of any dimension is inside the data set <code>Xp</code> of the same dimension as <code>p</code>;
otherwise returns <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.in.data(p, Xp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.in.data_+3A_p">p</code></td>
<td>
<p>A 2D point for which the function checks membership to the data set <code>Xp</code>.</p>
</td></tr>
<tr><td><code id="is.in.data_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>p</code> belongs to the data set <code>Xp</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10
Xp&lt;-cbind(runif(n),runif(n))

P&lt;-Xp[7,]
is.in.data(P,Xp)
is.in.data(P,Xp[7,])

P&lt;-Xp[7,]+10^(-7)
is.in.data(P,Xp)

P&lt;-Xp[7,]+10^(-9)
is.in.data(P,Xp)

is.in.data(P,P)

is.in.data(c(2,2),c(2,2))

#for 1D data
n&lt;-10
Xp&lt;-runif(n)

P&lt;-Xp[7]
is.in.data(P,Xp[7])  #this works because both entries are treated as 1D vectors but
#is.in.data(P,Xp) does not work since entries are treated as vectors of different dimensions

Xp&lt;-as.matrix(Xp)
is.in.data(P,Xp)
#this works, because P is a 1D point, and Xp is treated as a set of 10 1D points

P&lt;-Xp[7]+10^(-7)
is.in.data(P,Xp)

P&lt;-Xp[7]+10^(-9)
is.in.data(P,Xp)

is.in.data(P,P)

#for 3D data
n&lt;-10
Xp&lt;-cbind(runif(n),runif(n),runif(n))

P&lt;-Xp[7,]
is.in.data(P,Xp)
is.in.data(P,Xp[7,])

P&lt;-Xp[7,]+10^(-7)
is.in.data(P,Xp)

P&lt;-Xp[7,]+10^(-9)
is.in.data(P,Xp)

is.in.data(P,P)

n&lt;-10
Xp&lt;-cbind(runif(n),runif(n))
P&lt;-Xp[7,]
is.in.data(P,Xp)


</code></pre>

<hr>
<h2 id='is.point'>Check the argument is a point of a given dimension</h2><span id='topic+is.point'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if the argument <code>p</code>
is a <code>numeric</code> point of dimension <code>dim</code>
(default is <code>dim=2</code>); otherwise returns <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.point(p, dim = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.point_+3A_p">p</code></td>
<td>
<p>A <code>vector</code> to be checked
to see it is a point of dimension <code>dim</code> or not.</p>
</td></tr>
<tr><td><code id="is.point_+3A_dim">dim</code></td>
<td>
<p>A positive integer
representing the dimension of the argument <code>p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>p</code> is a <code>vector</code> of dimension <code>dim</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dimension">dimension</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(-1.22,-2.33); B&lt;-c(2.55,3.75,4)
is.point(A)
is.point(A,1)

is.point(B)
is.point(B,3)


</code></pre>

<hr>
<h2 id='is.std.eq.tri'>Check whether a triangle is a standard equilateral triangle</h2><span id='topic+is.std.eq.tri'></span>

<h3>Description</h3>

<p>Checks whether the triangle, <code>tri</code>,
is the standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.std.eq.tri(tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.std.eq.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>tri</code> is a standard equilateral triangle,
else <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)  #try adding +10^(-16) to each vertex
is.std.eq.tri(Te)

is.std.eq.tri(rbind(B,C,A))

Tr&lt;-rbind(A,B,-C)
is.std.eq.tri(Tr)

A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
is.std.eq.tri(Tr)


</code></pre>

<hr>
<h2 id='kfr2vertsCCvert.reg'>The <code>k</code> furthest points in a data set from vertices
in each <code class="reqn">CC</code>-vertex region in a triangle</h2><span id='topic+kfr2vertsCCvert.reg'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the <code>k</code> furthest data points among the data set, <code>Xp</code>,
in each <code class="reqn">CC</code>-vertex region from the vertex in the
triangle, <code>tri</code><code class="reqn">=T(A,B,C)</code>, vertices are stacked row-wise.
Vertex region labels/numbers correspond to the
row number of the vertex in <code>tri</code>.
</p>
<p><code>ch.all.intri</code> is for checking
whether all data points are inside <code>tri</code> (default is <code>FALSE</code>).
If some of the data points are not inside <code>tri</code>
and <code>ch.all.intri=TRUE</code>, then the function yields
an error message.
If some of the data points are not inside <code>tri</code>
and <code>ch.all.intri=FALSE</code>, then the function yields
the closest points to edges
among the data points inside <code>tri</code> (yields <code>NA</code> if there are no data points
inside <code>tri</code>).
</p>
<p>In the extrema, <code class="reqn">ext</code>, in the output,
the first <code>k</code> entries are the <code>k</code> furthest points from vertex 1,
second <code>k</code> entries are <code>k</code> furthest points are from vertex 2, and
last <code>k</code> entries are the <code>k</code> furthest points from vertex 3.
If data size does not allow, <code>NA</code>'s are inserted
for some or all of the <code>k</code> furthest points for each vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfr2vertsCCvert.reg(Xp, tri, k, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfr2vertsCCvert.reg_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="kfr2vertsCCvert.reg_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="kfr2vertsCCvert.reg_+3A_k">k</code></td>
<td>
<p>A positive integer. <code>k</code> furthest data points
in each <code class="reqn">CC</code>-vertex region are to be found if exists, else
<code>NA</code> are provided for (some of) the <code>k</code> furthest points.</p>
</td></tr>
<tr><td><code id="kfr2vertsCCvert.reg_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>)
to check whether all data points are inside
the triangle <code>tri</code>. So, if it is <code>TRUE</code>,
the function checks if all data points are
inside the closure of the triangle (i.e., interior and boundary
combined) else it does not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>,
and <code class="reqn">C=3</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A shorter description of the distances
as <code>"Distances of k furthest points in the vertex regions
 to Vertices"</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here, <code>k</code> furthest points
from vertices in each <code class="reqn">CC</code>-vertex region in
the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, it is <code>tri</code> for this function.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of vertex regions</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is circumcenter <code>"CC"</code> for this function.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the triangle, <code>tri</code>,
provided as a <code>list</code></p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions
inside <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from <code>k</code> furthest points
in each vertex region to the corresponding vertex
(each row representing a vertex in <code>tri</code>).
Among the distances the first <code>k</code> entries are the distances
from the <code>k</code> furthest points from vertex 1 to vertex 1,
second <code>k</code> entries are distances from the <code>k</code> furthest
points from vertex 2 to vertex 2,
and the last <code>k</code> entries are the distances
from the <code>k</code> furthest points
from vertex 3 to vertex 3.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fr2vertsCCvert.reg.basic.tri">fr2vertsCCvert.reg.basic.tri</a></code>, <code><a href="#topic+fr2vertsCCvert.reg.basic.tri">fr2vertsCCvert.reg.basic.tri</a></code>,
<code><a href="#topic+fr2vertsCCvert.reg">fr2vertsCCvert.reg</a></code>, and <code><a href="#topic+fr2edgesCMedge.reg.std.tri">fr2edgesCMedge.reg.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20
k&lt;-3

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

Ext&lt;-kfr2vertsCCvert.reg(Xp,Tr,k)
Ext
summary(Ext)
plot(Ext)

Xp2&lt;-rbind(Xp,c(.2,.4))
kfr2vertsCCvert.reg(Xp2,Tr,k)
#try also kfr2vertsCCvert.reg(Xp2,Tr,k,ch.all.intri = TRUE)

kf2v&lt;-Ext

CC&lt;-circumcenter.tri(Tr)  #the circumcenter
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",
main=paste(k," Furthest Points in CC-Vertex Regions \n from the Vertices",sep=""),
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(Xp)
points(kf2v$ext,pch=4,col=2)

txt&lt;-rbind(Tr,CC,Ds)
xc&lt;-txt[,1]+c(-.06,.08,.05,.12,-.1,-.1,-.09)
yc&lt;-txt[,2]+c(.02,-.02,.04,.0,.02,.06,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='kfr2vertsCCvert.reg.basic.tri'>The <code>k</code> furthest points from vertices
in each <code class="reqn">CC</code>-vertex region in a standard basic triangle</h2><span id='topic+kfr2vertsCCvert.reg.basic.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the <code>k</code> furthest data points
among the data set, <code>Xp</code>,
in each <code class="reqn">CC</code>-vertex region from the vertex in the
standard basic triangle <code class="reqn">T_b=T(A=(0,0),B=(1,0),C=(c_1,c_2))</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle. Hence, standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p><code>ch.all.intri</code> is for checking whether all data points are
inside <code class="reqn">T_b</code> (default is <code>FALSE</code>).
In the extrema, <code class="reqn">ext</code>, in the output,
the first <code>k</code> entries are the <code>k</code> furthest points from vertex 1,
second <code>k</code> entries are <code>k</code> furthest points are from vertex 2, and
last <code>k</code> entries are the <code>k</code> furthest points from vertex 3
If data size does not allow, <code>NA</code>'s are inserted for some
or all of the <code>k</code> furthest points for each vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfr2vertsCCvert.reg.basic.tri(Xp, c1, c2, k, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfr2vertsCCvert.reg.basic.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
representing the set of data points.</p>
</td></tr>
<tr><td><code id="kfr2vertsCCvert.reg.basic.tri_+3A_c1">c1</code>, <code id="kfr2vertsCCvert.reg.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle.
adjacent to the shorter edges;
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code></p>
</td></tr>
<tr><td><code id="kfr2vertsCCvert.reg.basic.tri_+3A_k">k</code></td>
<td>
<p>A positive integer. <code>k</code> furthest data points
in each <code class="reqn">CC</code>-vertex region are to be found if exists, else
<code>NA</code> are provided for (some of) the <code>k</code> furthest points.</p>
</td></tr>
<tr><td><code id="kfr2vertsCCvert.reg.basic.tri_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument for checking
whether all data points are inside <code class="reqn">T_b</code>
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Vertex labels are <code class="reqn">A=1</code>, <code class="reqn">B=2</code>,
and <code class="reqn">C=3</code> (correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A shorter description of the distances
as <code>"Distances of k furthest points in the vertex regions to Vertices"</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
<code>k</code> furthest points from vertices in each vertex region.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>, can be a <code>matrix</code>
or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points,
here, it is <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of edge regions.</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is circumcenter <code>"CC"</code> for this function.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>Vertex regions inside the triangle, <code class="reqn">T_b</code>,
provided as a <code>list</code>.</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the vertex regions
as <code>"vr=1"</code>, <code>"vr=2"</code>, and <code>"vr=3"</code></p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the vertex regions inside <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from <code>k</code> furthest points
in each vertex region to the corresponding vertex
(each row representing a vertex).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fr2vertsCCvert.reg.basic.tri">fr2vertsCCvert.reg.basic.tri</a></code>, <code><a href="#topic+fr2vertsCCvert.reg">fr2vertsCCvert.reg</a></code>,
<code><a href="#topic+fr2edgesCMedge.reg.std.tri">fr2edgesCMedge.reg.std.tri</a></code>, and <code><a href="#topic+kfr2vertsCCvert.reg">kfr2vertsCCvert.reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
n&lt;-20
k&lt;-3

set.seed(1)
Xp&lt;-runif.basic.tri(n,c1,c2)$g

Ext&lt;-kfr2vertsCCvert.reg.basic.tri(Xp,c1,c2,k)
Ext
summary(Ext)
plot(Ext)

kf2v&lt;-Ext

CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",
main=paste(k," Furthest Points in CC-Vertex Regions \n from the Vertices",sep=""),
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
points(Xp)
points(kf2v$ext,pch=4,col=2)

txt&lt;-rbind(Tb,CC,Ds)
xc&lt;-txt[,1]+c(-.03,.03,.02,.07,.06,-.05,.01)
yc&lt;-txt[,2]+c(.02,.02,.03,-.02,.02,.03,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='Line'>The line joining two distinct 2D points
<code>a</code> and <code>b</code></h2><span id='topic+Line'></span>

<h3>Description</h3>

<p>An object of class <code>"Lines"</code>.
Returns the <code>equation, slope, intercept</code>,
and <code class="reqn">y</code>-coordinates of the line crossing two
distinct 2D points <code>a</code> and <code>b</code>
with <code class="reqn">x</code>-coordinates provided in <code>vector</code> <code>x</code>.
</p>
<p>This function is different from the <code><a href="stats.html#topic+line">line</a></code> function
in the standard <code>stats</code> package
in <code>R</code> in the sense that <code>Line(a,b,x)</code> fits the line passing
through points <code>a</code> and <code>b</code>
and returns various quantities (see below) for this line and <code>x</code> is
the <code class="reqn">x</code>-coordinates of the points
we want to find on the <code>Line(a,b,x)</code>
while <code>line(a,b)</code> fits the line robustly
whose <code class="reqn">x</code>-coordinates are in <code>a</code>
and <code class="reqn">y</code>-coordinates are in <code>b</code>.
</p>
<p><code>Line(a,b,x)</code> and <code>line(x,Line(A,B,x)$y)</code>
would yield the same straight line
(i.e., the line with the same coefficients.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Line(a, b, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Line_+3A_a">a</code>, <code id="Line_+3A_b">b</code></td>
<td>
<p>2D points that determine the straight line
(i.e., through which the straight line passes).</p>
</td></tr>
<tr><td><code id="Line_+3A_x">x</code></td>
<td>
<p>A scalar or a <code>vector</code> of scalars
representing the <code class="reqn">x</code>-coordinates of the line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A description of the line</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>The input points <code>a</code> and <code>b</code>
through which the straight line passes
(stacked row-wise, i.e., row 1 is point <code>a</code>
and row 2 is point <code>b</code>).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The input scalar or <code>vector</code>
which constitutes the <code class="reqn">x</code>-coordinates of the point(s) of interest
on the line.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The output scalar or <code>vector</code>
which constitutes the <code class="reqn">y</code>-coordinates of the point(s) of interest
on the line. If <code>x</code> is a scalar,
then <code>y</code> will be a scalar
and if <code>x</code> is a <code>vector</code> of scalars,
then <code>y</code> will be a <code>vector</code> of scalars.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>Slope of the line, <code>Inf</code> is allowed,
passing through points <code>a</code> and <code>b</code> </p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>Intercept of the line
passing through points <code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line
passing through points <code>a</code> and <code>b</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slope">slope</a></code>, <code><a href="#topic+paraline">paraline</a></code>,
<code><a href="#topic+perpline">perpline</a></code>, <code><a href="stats.html#topic+line">line</a></code>
in the generic <code>stats</code> package and and <code><a href="#topic+Line3D">Line3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(-1.22,-2.33); B&lt;-c(2.55,3.75)

xr&lt;-range(A,B);
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100

lnAB&lt;-Line(A,B,x)
lnAB
summary(lnAB)
plot(lnAB)

line(A,B)
#this takes vector A as the x points and vector B as the y points and fits the line
#for example, try
x=runif(100); y=x+(runif(100,-.05,.05))
plot(x,y)
line(x,y)

x&lt;-lnAB$x
y&lt;-lnAB$y
Xlim&lt;-range(x,A,B)
if (!is.na(y[1])) {Ylim&lt;-range(y,A,B)} else {Ylim&lt;-range(A,B)}
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
pf&lt;-c(xd,-yd)*.025

#plot of the line joining A and B
plot(rbind(A,B),pch=1,xlab="x",ylab="y",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
if (!is.na(y[1])) {lines(x,y,lty=1)} else {abline(v=A[1])}
text(rbind(A+pf,B+pf),c("A","B"))
int&lt;-round(lnAB$intercep,2)  #intercept
sl&lt;-round(lnAB$slope,2)  #slope
text(rbind((A+B)/2+pf*3),ifelse(is.na(int),paste("x=",A[1]),
ifelse(sl==0,paste("y=",int),
ifelse(sl==1,ifelse(sign(int)&lt;0,paste("y=x",int),paste("y=x+",int)),
ifelse(sign(int)&lt;0,paste("y=",sl,"x",int),paste("y=",sl,"x+",int))))))


</code></pre>

<hr>
<h2 id='Line3D'>The line crossing 3D point <code>p</code>
in the direction of <code>vector</code> <code>v</code> (or if <code>v</code> is a point,
in direction of <code class="reqn">v-r_0</code>)</h2><span id='topic+Line3D'></span>

<h3>Description</h3>

<p>An object of class <code>"Lines3D"</code>.
Returns the equation, <code class="reqn">x</code>-, <code class="reqn">y</code>-,
and <code class="reqn">z</code>-coordinates of the line crossing 3D point <code class="reqn">r_0</code>
in the direction of <code>vector</code> <code>v</code>
(of if <code>v</code> is a point, in the direction of <code class="reqn">v-r_0</code>)
with the parameter <code>t</code> being provided in <code>vector</code> <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Line3D(p, v, t, dir.vec = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Line3D_+3A_p">p</code></td>
<td>
<p>A 3D point through
which the straight line passes.</p>
</td></tr>
<tr><td><code id="Line3D_+3A_v">v</code></td>
<td>
<p>A 3D <code>vector</code>
which determines the direction of the straight line
(i.e., the straight line would be
parallel to this vector) if the <code>dir.vec=TRUE</code>,
otherwise it is 3D point and <code class="reqn">v-r_0</code> determines the direction of the
the straight line.</p>
</td></tr>
<tr><td><code id="Line3D_+3A_t">t</code></td>
<td>
<p>A scalar or a <code>vector</code> of scalars
representing the parameter of the coordinates of the line
(for the form: <code class="reqn">x=p_0 + a t</code>, <code class="reqn">y=y_0 + b t</code>,
and <code class="reqn">z=z_0 + c t</code> where <code class="reqn">r_0=(p_0,y_0,z_0)</code>
and <code class="reqn">v=(a,b,c)</code> if <code>dir.vec=TRUE</code>,
else <code class="reqn">v-r_0=(a,b,c)</code>).</p>
</td></tr>
<tr><td><code id="Line3D_+3A_dir.vec">dir.vec</code></td>
<td>
<p>A logical argument about <code>v</code>,
if <code>TRUE</code> <code>v</code> is treated as a vector,
else <code>v</code> is treated as a point
and so the direction <code>vector</code> is taken to be <code class="reqn">v-r_0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A description of the line</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line</p>
</td></tr>
<tr><td><code>pts</code></td>
<td>
<p>The input points that determine a line and/or a plane,
<code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>pnames</code></td>
<td>
<p>The names of the input points
that determine a line and/or a plane,
<code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>vecs</code></td>
<td>
<p>The point <code>p</code>
and the <code>vector</code> <code>v</code>
(if <code>dir.vec=TRUE</code>) or the point <code>v</code>
(if <code>dir.vec=FALSE</code>). The first row is <code>p</code>
and the second row is <code>v</code>.</p>
</td></tr>
<tr><td><code>vec.names</code></td>
<td>
<p>The names of the point <code>p</code>
and the <code>vector</code> <code>v</code> (if <code>dir.vec=TRUE</code>)
or the point <code>v</code> (if <code>dir.vec=FALSE</code>).</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code>, <code>z</code></td>
<td>
<p>The <code class="reqn">x</code>-, <code class="reqn">y</code>-,
and <code class="reqn">z</code>-coordinates of the point(s) of interest on the line.</p>
</td></tr>
<tr><td><code>tsq</code></td>
<td>
<p>The scalar or the <code>vector</code> of the parameter
in defining each coordinate of the line for the form:
<code class="reqn">x=p_0 + a t</code>, <code class="reqn">y=y_0 + b t</code>, and <code class="reqn">z=z_0 + c t</code>
where <code class="reqn">r_0=(p_0,y_0,z_0)</code> and <code class="reqn">v=(a,b,c)</code>
if <code>dir.vec=TRUE</code>, else <code class="reqn">v-r_0=(a,b,c)</code>.</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line passing through point <code>p</code>
in the direction of the <code>vector</code> <code>v</code> (if <code>dir.vec=TRUE</code>)
else in the direction of <code class="reqn">v-r_0</code>.
The line equation is in the form: <code class="reqn">x=p_0 + a t</code>, <code class="reqn">y=y_0 + b t</code>,
and <code class="reqn">z=z_0 + c t</code> where
<code class="reqn">r_0=(p_0,y_0,z_0)</code> and <code class="reqn">v=(a,b,c)</code> if <code>dir.vec=TRUE</code>,
else <code class="reqn">v-r_0=(a,b,c)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+line">line</a></code>, <code><a href="#topic+paraline3D">paraline3D</a></code>,
and <code><a href="#topic+Plane">Plane</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,10,3); B&lt;-c(1,1,3);

vecs&lt;-rbind(A,B)

Line3D(A,B,.1)
Line3D(A,B,.1,dir.vec=FALSE)

tr&lt;-range(vecs);
tf&lt;-(tr[2]-tr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
tsq&lt;-seq(-tf*10-tf,tf*10+tf,l=5)  #try also l=10, 20, or 100

lnAB3D&lt;-Line3D(A,B,tsq)
#try also lnAB3D&lt;-Line3D(A,B,tsq,dir.vec=FALSE)
lnAB3D
summary(lnAB3D)
plot(lnAB3D)

x&lt;-lnAB3D$x
y&lt;-lnAB3D$y
z&lt;-lnAB3D$z

zr&lt;-range(z)
zf&lt;-(zr[2]-zr[1])*.2
Bv&lt;-B*tf*5

Xlim&lt;-range(x)
Ylim&lt;-range(y)
Zlim&lt;-range(z)

xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

Dr&lt;-A+min(tsq)*B

plot3D::lines3D(x, y, z, phi = 0, bty = "g",
main="Line Crossing A \n in the Direction of OB",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),
zlim=Zlim+zd*c(-.1,.1),
        pch = 20, cex = 2, ticktype = "detailed")
plot3D::arrows3D(Dr[1],Dr[2],Dr[3]+zf,Dr[1]+Bv[1],
Dr[2]+Bv[2],Dr[3]+zf+Bv[3], add=TRUE)
plot3D::points3D(A[1],A[2],A[3],add=TRUE)
plot3D::arrows3D(A[1],A[2],A[3]-2*zf,A[1],A[2],A[3],lty=2, add=TRUE)
plot3D::text3D(A[1],A[2],A[3]-2*zf,labels="initial point",add=TRUE)
plot3D::text3D(A[1],A[2],A[3]+zf/2,labels=expression(r[0]),add=TRUE)
plot3D::arrows3D(Dr[1]+Bv[1]/2,Dr[2]+Bv[2]/2,Dr[3]+3*zf+Bv[3]/2,
Dr[1]+Bv[1]/2,Dr[2]+Bv[2]/2,Dr[3]+zf+Bv[3]/2,lty=2, add=TRUE)
plot3D::text3D(Dr[1]+Bv[1]/2,Dr[2]+Bv[2]/2,Dr[3]+3*zf+Bv[3]/2,
labels="direction vector",add=TRUE)
plot3D::text3D(Dr[1]+Bv[1]/2,Dr[2]+Bv[2]/2,
Dr[3]+zf+Bv[3]/2,labels="v",add=TRUE)
plot3D::text3D(0,0,0,labels="O",add=TRUE)


</code></pre>

<hr>
<h2 id='NASbasic.tri'>The vertices of the Arc Slice (AS) Proximity Region in the standard basic triangle</h2><span id='topic+NASbasic.tri'></span>

<h3>Description</h3>

<p>Returns the end points of the line segments and arc-slices that constitute the boundary of
AS proximity region for a point in the standard basic triangle <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or based on circumcenter of <code class="reqn">T_b</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code class="reqn">T_b</code>.
<code>rv</code> is the index of the vertex region <code>p</code> resides, with default=<code>NULL</code>.
</p>
<p>If <code>p</code> is outside <code class="reqn">T_b</code>, it returns <code>NULL</code> for the proximity region.
<code>dec</code> is the number of decimals (default is 4) to round the barycentric coordinates when checking whether
the end points fall on the boundary of the triangle <code class="reqn">T_b</code> or not (so as not to miss the intersection points
due to precision in the decimals).
</p>
<p>Any given triangle can be mapped to the standard basic triangle
by a combination of rigid body motions (i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the original triangle. Hence standard basic triangle is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NASbasic.tri(p, c1, c2, M = "CC", rv = NULL, dec = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NASbasic.tri_+3A_p">p</code></td>
<td>
<p>A 2D point whose AS proximity region is to be computed.</p>
</td></tr>
<tr><td><code id="NASbasic.tri_+3A_c1">c1</code>, <code id="NASbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers representing the top vertex in standard basic triangle <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>,
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="NASbasic.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code class="reqn">T_b</code> or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="NASbasic.tri_+3A_rv">rv</code></td>
<td>
<p>The index of the <code>M</code>-vertex region containing the point, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="NASbasic.tri_+3A_dec">dec</code></td>
<td>
<p>a positive integer the number of decimals (default is 4) to round the barycentric coordinates when checking whether
the end points fall on the boundary of the triangle <code class="reqn">T_b</code> or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>L</code>, <code>R</code></td>
<td>
<p>The end points of the line segments on the boundary of the AS proximity region.
Each row in <code>L</code> and <code>R</code> constitute a line segment on the boundary.</p>
</td></tr>
<tr><td><code>Arc.Slices</code></td>
<td>
<p>The end points of the arc-slices on the circular parts of the AS proximity region.
Here points in row 1 and row 2 constitute the end points of one arc-slice, points on row 3 and row 4
constitute the end points for the next arc-slice and so on.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NAStri">NAStri</a></code> and <code><a href="#topic+IarcASbasic.tri">IarcASbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6  #try also c1&lt;-.2; c2&lt;-.2;
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)

set.seed(1)
M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.2)

P1&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g);  #try also P1&lt;-c(.3,.2)
NASbasic.tri(P1,c1,c2)  #default with M="CC"
NASbasic.tri(P1,c1,c2,M)

#or try
Rv&lt;-rel.vert.basic.triCC(P1,c1,c2)$rv
NASbasic.tri(P1,c1,c2,M,Rv)

NASbasic.tri(c(3,5),c1,c2,M)

P2&lt;-c(.5,.4)
NASbasic.tri(P2,c1,c2,M)

P3&lt;-c(1.5,.4)
NASbasic.tri(P3,c1,c2,M)

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

#plot of the NAS region
P1&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g);
CC&lt;-circumcenter.basic.tri(c1,c2)

if (isTRUE(all.equal(M,CC)) || identical(M,"CC"))
{cent&lt;-CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
cent.name&lt;-"CC"
rv&lt;-rel.vert.basic.triCC(P1,c1,c2)$rv
} else
{cent&lt;-M
cent.name&lt;-"M"
Ds&lt;-prj.cent2edges.basic.tri(c1,c2,M)
rv&lt;-rel.vert.basic.tri(P1,c1,c2,M)$rv
}
RV&lt;-Tb[rv,]
rad&lt;-Dist(P1,RV)

Int.Pts&lt;-NASbasic.tri(P1,c1,c2,M)

Xlim&lt;-range(Tb[,1],P1[1]+rad,P1[1]-rad)
Ylim&lt;-range(Tb[,2],P1[2]+rad,P1[2]-rad)
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
points(rbind(Tb,P1,rbind(Int.Pts$L,Int.Pts$R)))
L&lt;-rbind(cent,cent,cent); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
interp::circles(P1[1],P1[2],rad,lty=2)
L&lt;-Int.Pts$L; R&lt;-Int.Pts$R
segments(L[,1], L[,2], R[,1], R[,2], lty=1,col=2)
Arcs&lt;-Int.Pts$a;
if (!is.null(Arcs))
{
  K&lt;-nrow(Arcs)/2
  for (i in 1:K)
  {A1&lt;-Arcs[2*i-1,]; A2&lt;-Arcs[2*i,];
  angles&lt;-angle.str2end(A1,P1,A2)$c

  plotrix::draw.arc(P1[1],P1[2],rad,angle1=angles[1],angle2=angles[2],col=2)
  }
}

#proximity region with the triangle (i.e., for labeling the vertices of the NAS)
IP.txt&lt;-intpts&lt;-c()
if (!is.null(Int.Pts$a))
{
 intpts&lt;-unique(round(Int.Pts$a,7))
  #this part is for labeling the intersection points of the spherical
  for (i in 1:(length(intpts)/2))
    IP.txt&lt;-c(IP.txt,paste("I",i+1, sep = ""))
}
txt&lt;-rbind(Tb,P1,cent,intpts)
txt.str&lt;-c("A","B","C","P1",cent.name,IP.txt)
text(txt+cbind(rep(xd*.02,nrow(txt)),rep(-xd*.03,nrow(txt))),txt.str)

c1&lt;-.4; c2&lt;-.6;
P1&lt;-c(.3,.2)
NASbasic.tri(P1,c1,c2,M)


</code></pre>

<hr>
<h2 id='NAStri'>The vertices of the Arc Slice (AS) Proximity Region in a general triangle</h2><span id='topic+NAStri'></span>

<h3>Description</h3>

<p>Returns the end points of the line segments and arc-slices that constitute the boundary of AS proximity
region for a point in the triangle <code>tri</code><code class="reqn">=T(A,B,C)=</code><code>(rv=1,rv=2,rv=3)</code>.
</p>
<p>Vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
<code>rv</code> is the index of the vertex region <code>p1</code> resides,
with default=<code>NULL</code>.
</p>
<p>If <code>p</code> is outside of <code>tri</code>, it returns <code>NULL</code> for the proximity region.
<code>dec</code> is the number of decimals (default is 4) to round the barycentric coordinates when checking the points
fall on the boundary of the triangle <code>tri</code> or not (so as not to miss the intersection points due to precision
in the decimals).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NAStri(p, tri, M = "CC", rv = NULL, dec = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NAStri_+3A_p">p</code></td>
<td>
<p>A 2D point whose AS proximity region is to be computed.</p>
</td></tr>
<tr><td><code id="NAStri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="NAStri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or a 3D point in
barycentric coordinates which serves as a center in the interior of the triangle <code>tri</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="NAStri_+3A_rv">rv</code></td>
<td>
<p>Index of the <code>M</code>-vertex region containing the point <code>p</code>, either <code>1,2,3</code> or
<code>NULL</code> (default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="NAStri_+3A_dec">dec</code></td>
<td>
<p>a positive integer the number of decimals (default is 4) to round the
barycentric coordinates when checking whether
the end points fall on the boundary of the triangle <code>tri</code> or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>L</code>, <code>R</code></td>
<td>
<p>End points of the line segments on the boundary of the AS proximity region.
Each row in <code>L</code> and <code>R</code> constitute a pair of points that determine a line segment on the boundary.</p>
</td></tr>
<tr><td><code>arc.slices</code></td>
<td>
<p>The end points of the arc-slices on the circular parts of the AS proximity region.
Here points in rows 1 and 2 constitute the end points of the first arc-slice, points on rows 3 and 4
constitute the end points for the next arc-slice and so on.</p>
</td></tr>
<tr><td><code>Angles</code></td>
<td>
<p>The angles (in radians) between the vectors joining arc slice end points to the point <code>p</code>
with the horizontal line crossing the point <code>p</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NASbasic.tri">NASbasic.tri</a></code>, <code><a href="#topic+NPEtri">NPEtri</a></code>, <code><a href="#topic+NCStri">NCStri</a></code> and <code><a href="#topic+IarcAStri">IarcAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(.6,.2)

P1&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also P1&lt;-c(1.3,1.2)
NAStri(P1,Tr,M)

#or try
Rv&lt;-rel.vert.triCC(P1,Tr)$rv
NAStri(P1,Tr,M,Rv)

NAStri(c(3,5),Tr,M)

P2&lt;-c(1.5,1.4)
NAStri(P2,Tr,M)

P3&lt;-c(1.5,.4)
NAStri(P3,Tr,M)

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

CC&lt;-circumcenter.tri(Tr)  #the circumcenter

if (isTRUE(all.equal(M,CC)) || identical(M,"CC"))
{cent&lt;-CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
cent.name&lt;-"CC"
rv&lt;-rel.vert.triCC(P1,Tr)$rv
} else
{cent&lt;-M
cent.name&lt;-"M"
Ds&lt;-prj.cent2edges(Tr,M)
rv&lt;-rel.vert.tri(P1,Tr,M)$rv
}
RV&lt;-Tr[rv,]
rad&lt;-Dist(P1,RV)

Int.Pts&lt;-NAStri(P1,Tr,M)

#plot of the NAS region
Xlim&lt;-range(Tr[,1],P1[1]+rad,P1[1]-rad)
Ylim&lt;-range(Tr[,2],P1[2]+rad,P1[2]-rad)
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",asp=1,xlab="",ylab="",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
#asp=1 must be the case to have the arc properly placed in the figure
polygon(Tr)
points(rbind(Tr,P1,rbind(Int.Pts$L,Int.Pts$R)))
L&lt;-rbind(cent,cent,cent); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
interp::circles(P1[1],P1[2],rad,lty=2)
L&lt;-Int.Pts$L; R&lt;-Int.Pts$R
segments(L[,1], L[,2], R[,1], R[,2], lty=1,col=2)
Arcs&lt;-Int.Pts$a;
if (!is.null(Arcs))
{
  K&lt;-nrow(Arcs)/2
  for (i in 1:K)
  {A1&lt;-Int.Pts$arc[2*i-1,]; A2&lt;-Int.Pts$arc[2*i,];
  angles&lt;-angle.str2end(A1,P1,A2)$c

  test.ang1&lt;-angles[1]+(.01)*(angles[2]-angles[1])
  test.Pnt&lt;-P1+rad*c(cos(test.ang1),sin(test.ang1))
  if (!in.triangle(test.Pnt,Tr,boundary = TRUE)$i) {angles&lt;-c(min(angles),max(angles)-2*pi)}
  plotrix::draw.arc(P1[1],P1[2],rad,angle1=angles[1],angle2=angles[2],col=2)
  }
}

#proximity region with the triangle (i.e., for labeling the vertices of the NAS)
IP.txt&lt;-intpts&lt;-c()
if (!is.null(Int.Pts$a))
{
 intpts&lt;-unique(round(Int.Pts$a,7))
  #this part is for labeling the intersection points of the spherical
  for (i in 1:(length(intpts)/2))
    IP.txt&lt;-c(IP.txt,paste("I",i+1, sep = ""))
}
txt&lt;-rbind(Tr,P1,cent,intpts)
txt.str&lt;-c("A","B","C","P1",cent.name,IP.txt)
text(txt+cbind(rep(xd*.02,nrow(txt)),rep(-xd*.03,nrow(txt))),txt.str)

P1&lt;-c(.3,.2)
NAStri(P1,Tr,M)


</code></pre>

<hr>
<h2 id='NCSint'>The end points of the Central Similarity (CS) Proximity Region for a point - one interval case</h2><span id='topic+NCSint'></span>

<h3>Description</h3>

<p>Returns the end points of the interval which constitutes the CS proximity region for a point in the
interval <code>int</code><code class="reqn">=(a,b)=</code><code>(rv=1,rv=2)</code>.
</p>
<p>CS proximity region is constructed with respect to the interval <code>int</code>
with expansion parameter <code class="reqn">t&gt;0</code> and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>Vertex regions are based on the (parameterized) center, <code class="reqn">M_c</code>,
which is <code class="reqn">M_c=a+c(b-a)</code> for the interval, <code>int</code><code class="reqn">=(a,b)</code>.
The CS proximity region is constructed whether <code>x</code> is inside or outside the interval <code>int</code>.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCSint(x, int, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NCSint_+3A_x">x</code></td>
<td>
<p>A 1D point for which CS proximity region is constructed.</p>
</td></tr>
<tr><td><code id="NCSint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="NCSint_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="NCSint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The interval which constitutes the CS proximity region for the point <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPEint">NPEint</a></code> and <code><a href="#topic+NCStri">NCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
t&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

NCSint(7,int,t,c)
NCSint(17,int,t,c)
NCSint(1,int,t,c)
NCSint(-1,int,t,c)

NCSint(3,int,t,c)
NCSint(4,int,t,c)
NCSint(a,int,t,c)

</code></pre>

<hr>
<h2 id='NCStri'>The vertices of the Central Similarity (CS) Proximity Region in a general triangle</h2><span id='topic+NCStri'></span>

<h3>Description</h3>

<p>Returns the vertices of the CS proximity region (which is itself a triangle) for a point in the
triangle <code>tri</code><code class="reqn">=T(A,B,C)=</code><code>(rv=1,rv=2,rv=3)</code>.
</p>
<p>CS proximity region is defined with respect to the triangle <code>tri</code>
with expansion parameter <code class="reqn">t&gt;0</code> and edge regions based on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
</p>
<p>Edge regions are labeled as <code>1,2,3</code> rowwise for the corresponding vertices
of the triangle <code>tri</code>. <code>re</code> is the index of the edge region <code>p</code> resides, with default=<code>NULL</code>.
If <code>p</code> is outside of <code>tri</code>, it returns <code>NULL</code> for the proximity region.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCStri(p, tri, t, M = c(1, 1, 1), re = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NCStri_+3A_p">p</code></td>
<td>
<p>A 2D point whose CS proximity region is to be computed.</p>
</td></tr>
<tr><td><code id="NCStri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="NCStri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="NCStri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="NCStri_+3A_re">re</code></td>
<td>
<p>Index of the <code>M</code>-edge region containing the point <code>p</code>,
either <code>1,2,3</code> or <code>NULL</code> (default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vertices of the triangular region which constitutes the CS proximity region with expansion parameter
<code class="reqn">t&gt;0</code> and center <code>M</code> for a point <code>p</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPEtri">NPEtri</a></code>, <code><a href="#topic+NAStri">NAStri</a></code>, and  <code><a href="#topic+IarcCStri">IarcCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
tau&lt;-1.5

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

n&lt;-3
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

NCStri(Xp[1,],Tr,tau,M)

P1&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also P1&lt;-c(.4,.2)
NCStri(P1,Tr,tau,M)

#or try
re&lt;-rel.edges.tri(P1,Tr,M)$re
NCStri(P1,Tr,tau,M,re)


</code></pre>

<hr>
<h2 id='NPEbasic.tri'>The vertices of the Proportional Edge (PE) Proximity Region
in a standard basic triangle</h2><span id='topic+NPEbasic.tri'></span>

<h3>Description</h3>

<p>Returns the vertices of the PE proximity region
(which is itself a triangle) for a point in the
standard basic triangle
<code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))=</code><code>(rv=1,rv=2,rv=3)</code>.
</p>
<p>PE proximity region is defined with respect
to the standard basic triangle <code class="reqn">T_b</code>
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions based on center <code class="reqn">M=(m_1,m_2)</code> in
Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of the basic
triangle <code class="reqn">T_b</code> or based on the circumcenter of <code class="reqn">T_b</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_b</code>.
</p>
<p>Vertex regions are labeled as <code class="reqn">1,2,3</code> rowwise for the vertices
of the triangle <code class="reqn">T_b</code>. <code>rv</code> is the index of the vertex region
<code>p</code> resides, with default=<code>NULL</code>.
If <code>p</code> is outside of <code>tri</code>,
it returns <code>NULL</code> for the proximity region.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPEbasic.tri(p, r, c1, c2, M = c(1, 1, 1), rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPEbasic.tri_+3A_p">p</code></td>
<td>
<p>A 2D point whose PE proximity region is to be computed.</p>
</td></tr>
<tr><td><code id="NPEbasic.tri_+3A_r">r</code></td>
<td>
<p>A positive real number which serves
as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="NPEbasic.tri_+3A_c1">c1</code>, <code id="NPEbasic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
representing the top vertex in standard basic triangle
<code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>,
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="NPEbasic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point
in barycentric coordinates
which serves as a center
in the interior of the standard basic triangle <code class="reqn">T_b</code>
or the circumcenter of <code class="reqn">T_b</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="NPEbasic.tri_+3A_rv">rv</code></td>
<td>
<p>Index of the <code>M</code>-vertex region
containing the point <code>p</code>, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vertices of the triangular region
which constitutes the PE proximity region with expansion parameter
r and center <code>M</code> for a point <code>p</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPEtri">NPEtri</a></code>, <code><a href="#topic+NAStri">NAStri</a></code>, <code><a href="#topic+NCStri">NCStri</a></code>,
and <code><a href="#topic+IarcPEbasic.tri">IarcPEbasic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.2)

r&lt;-2

P1&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also P1&lt;-c(.4,.2)
NPEbasic.tri(P1,r,c1,c2,M)

#or try
Rv&lt;-rel.vert.basic.tri(P1,c1,c2,M)$rv
NPEbasic.tri(P1,r,c1,c2,M,Rv)

P1&lt;-c(1.4,1.2)
P2&lt;-c(1.5,1.26)
NPEbasic.tri(P1,r,c1,c2,M) #gives an error if M=c(1.3,1.3)
#since center is not the circumcenter or not in the interior of the triangle


</code></pre>

<hr>
<h2 id='NPEint'>The end points of the Proportional Edge (PE) Proximity Region for a point - one interval case</h2><span id='topic+NPEint'></span>

<h3>Description</h3>

<p>Returns the end points of the interval which constitutes the PE proximity region for a point in the
interval <code>int</code><code class="reqn">=(a,b)=</code><code>(rv=1,rv=2)</code>. PE proximity region is constructed with respect to the interval <code>int</code>
with expansion parameter <code class="reqn">r \ge 1</code> and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>Vertex regions are based on the (parameterized) center, <code class="reqn">M_c</code>,
which is <code class="reqn">M_c=a+c(b-a)</code> for the interval, <code>int</code><code class="reqn">=(a,b)</code>.
The PE proximity region is constructed whether <code>x</code> is inside or outside the interval <code>int</code>.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPEint(x, int, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPEint_+3A_x">x</code></td>
<td>
<p>A 1D point for which PE proximity region is constructed.</p>
</td></tr>
<tr><td><code id="NPEint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="NPEint_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="NPEint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The interval which constitutes the PE proximity region for the point <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NCSint">NCSint</a></code>, <code><a href="#topic+NPEtri">NPEtri</a></code> and <code><a href="#topic+NPEtetra">NPEtetra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

NPEint(7,int,r,c)
NPEint(17,int,r,c)
NPEint(1,int,r,c)
NPEint(-1,int,r,c)

</code></pre>

<hr>
<h2 id='NPEstd.tetra'>The vertices of the Proportional Edge (PE) Proximity Region in the standard regular tetrahedron</h2><span id='topic+NPEstd.tetra'></span>

<h3>Description</h3>

<p>Returns the vertices of the PE proximity region (which is itself a tetrahedron) for a point in the
standard regular tetrahedron <code class="reqn">T_h=T((0,0,0),(1,0,0),(1/2,\sqrt{3}/2,0),(1/2,\sqrt{3}/6,\sqrt{6}/3))=</code>
<code>(rv=1,rv=2,rv=3,rv=4)</code>.
</p>
<p>PE proximity region is defined with respect to the tetrahedron <code class="reqn">T_h</code>
with expansion parameter <code class="reqn">r \ge 1</code> and vertex regions based on the circumcenter of <code class="reqn">T_h</code> (which is equivalent
to the center of mass in the standard regular tetrahedron).
</p>
<p>Vertex regions are labeled as <code>1,2,3,4</code> rowwise for the vertices of the tetrahedron <code class="reqn">T_h</code>.
<code>rv</code> is the index of the vertex region <code>p</code> resides, with default=<code>NULL</code>.
If <code>p</code> is outside of <code class="reqn">T_h</code>, it returns <code>NULL</code> for the proximity region.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPEstd.tetra(p, r, rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPEstd.tetra_+3A_p">p</code></td>
<td>
<p>A 3D point whose PE proximity region is to be computed.</p>
</td></tr>
<tr><td><code id="NPEstd.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="NPEstd.tetra_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex region containing the point, either <code>1,2,3,4</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vertices of the tetrahedron which constitutes the PE proximity region with expansion parameter
<code>r</code> and circumcenter (or center of mass) for a point <code>p</code> in the standard regular tetrahedron
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPEtetra">NPEtetra</a></code>, <code><a href="#topic+NPEtri">NPEtri</a></code> and <code><a href="#topic+NPEint">NPEint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)

n&lt;-3
Xp&lt;-runif.std.tetra(n)$g
r&lt;-1.5
NPEstd.tetra(Xp[1,],r)

#or try
RV&lt;-rel.vert.tetraCC(Xp[1,],tetra)$rv
NPEstd.tetra(Xp[1,],r,rv=RV)

NPEstd.tetra(c(-1,-1,-1),r,rv=NULL)


</code></pre>

<hr>
<h2 id='NPEtetra'>The vertices of the Proportional Edge (PE) Proximity Region in a tetrahedron</h2><span id='topic+NPEtetra'></span>

<h3>Description</h3>

<p>Returns the vertices of the PE proximity region (which is itself a tetrahedron) for a point in the
tetrahedron <code>th</code>.
</p>
<p>PE proximity region is defined with respect to the tetrahedron <code>th</code>
with expansion parameter <code class="reqn">r \ge 1</code> and vertex regions based on the center <code>M</code> which is circumcenter (<code>"CC"</code>) or
center of mass (<code>"CM"</code>) of <code>th</code> with default=<code>"CM"</code>.
</p>
<p>Vertex regions are labeled as <code>1,2,3,4</code> rowwise for the vertices of the tetrahedron <code>th</code>.
<code>rv</code> is the index of the vertex region <code>p</code> resides, with default=<code>NULL</code>.
If <code>p</code> is outside of <code>th</code>, it returns <code>NULL</code> for the proximity region.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPEtetra(p, th, r, M = "CM", rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPEtetra_+3A_p">p</code></td>
<td>
<p>A 3D point whose PE proximity region is to be computed.</p>
</td></tr>
<tr><td><code id="NPEtetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="NPEtetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="NPEtetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
<tr><td><code id="NPEtetra_+3A_rv">rv</code></td>
<td>
<p>Index of the vertex region containing the point, either <code>1,2,3,4</code> (default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vertices of the tetrahedron which constitutes the PE proximity region with expansion parameter
<code>r</code> and circumcenter (or center of mass) for a point <code>p</code> in the tetrahedron
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPEstd.tetra">NPEstd.tetra</a></code>, <code><a href="#topic+NPEtri">NPEtri</a></code> and <code><a href="#topic+NPEint">NPEint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
set.seed(1)
tetra&lt;-rbind(A,B,C,D)+matrix(runif(12,-.25,.25),ncol=3)
n&lt;-3  #try also n&lt;-20

Xp&lt;-runif.tetra(n,tetra)$g

M&lt;-"CM"  #try also M&lt;-"CC"
r&lt;-1.5

NPEtetra(Xp[1,],tetra,r)  #uses the default M="CM"
NPEtetra(Xp[1,],tetra,r,M="CC")

#or try
RV&lt;-rel.vert.tetraCM(Xp[1,],tetra)$rv
NPEtetra(Xp[1,],tetra,r,M,rv=RV)

P1&lt;-c(.1,.1,.1)
NPEtetra(P1,tetra,r,M)


</code></pre>

<hr>
<h2 id='NPEtri'>The vertices of the Proportional Edge (PE) Proximity Region
in a general triangle</h2><span id='topic+NPEtri'></span>

<h3>Description</h3>

<p>Returns the vertices of the PE proximity region
(which is itself a triangle) for a point in the
triangle <code>tri</code><code class="reqn">=T(A,B,C)=</code><code>(rv=1,rv=2,rv=3)</code>.
</p>
<p>PE proximity region is defined with respect to the triangle <code>tri</code>
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.
</p>
<p>Vertex regions are labeled as <code class="reqn">1,2,3</code>
rowwise for the vertices
of the triangle <code>tri</code>.
<code>rv</code> is the index of the vertex region <code>p</code> resides,
with default=<code>NULL</code>.
If <code>p</code> is outside of <code>tri</code>,
it returns <code>NULL</code> for the proximity region.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPEtri(p, tri, r, M = c(1, 1, 1), rv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NPEtri_+3A_p">p</code></td>
<td>
<p>A 2D point whose PE proximity region is to be computed.</p>
</td></tr>
<tr><td><code id="NPEtri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="NPEtri_+3A_r">r</code></td>
<td>
<p>A positive real number which serves
as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="NPEtri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="NPEtri_+3A_rv">rv</code></td>
<td>
<p>Index of the <code>M</code>-vertex region
containing the point <code>p</code>, either <code>1,2,3</code> or <code>NULL</code>
(default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vertices of the triangular region
which constitutes the PE proximity region with expansion parameter
<code>r</code> and center <code>M</code> for a point <code>p</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NPEbasic.tri">NPEbasic.tri</a></code>, <code><a href="#topic+NAStri">NAStri</a></code>,
<code><a href="#topic+NCStri">NCStri</a></code>, and <code><a href="#topic+IarcPEtri">IarcPEtri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

r&lt;-1.5

n&lt;-3
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

NPEtri(Xp[3,],Tr,r,M)

P1&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also P1&lt;-c(.4,.2)
NPEtri(P1,Tr,r,M)

M&lt;-c(1.3,1.3)
r&lt;-2

P1&lt;-c(1.4,1.2)
P2&lt;-c(1.5,1.26)
NPEtri(P1,Tr,r,M)
NPEtri(P2,Tr,r,M)

#or try
Rv&lt;-rel.vert.tri(P1,Tr,M)$rv
NPEtri(P1,Tr,r,M,Rv)


</code></pre>

<hr>
<h2 id='num.arcsAS'>Number of arcs of Arc Slice Proximity Catch Digraphs (AS-PCDs)
and related quantities of the induced subdigraphs
for points in the Delaunay triangles - multiple triangle case</h2><span id='topic+num.arcsAS'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs and
various other quantities related to the Delaunay triangles
for Arc Slice Proximity Catch Digraph (AS-PCD)
whose vertices are the data points in <code>Xp</code>
in the multiple triangle case (with triangulation based on <code>Yp</code> points).
</p>
<p>AS proximity regions are defined with respect to the
Delaunay triangles based on <code>Yp</code> points
and vertex regions in each triangle
are based on the center <code>M="CC"</code> for circumcenter of each Delaunay triangle
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the
interior of each Delaunay triangle;
default is <code>M="CC"</code> i.e., circumcenter of each triangle.
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
For the number of arcs, loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005, 2010))
for more on AS-PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation
and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsAS(Xp, Yp, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsAS_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsAS_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="num.arcsAS_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of
each Delaunay triangle or 3D point in barycentric
coordinates which serves as a center in the interior of each Delaunay triangle;
default is <code>M="CC"</code> i.e., the circumcenter of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and related quantities for the induced subdigraphs in the Delaunay triangles</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Total number of arcs in all triangles,
i.e., the number of arcs for the entire AS-PCD</p>
</td></tr>
<tr><td><code>num.in.conv.hull</code></td>
<td>
<p>Number of <code>Xp</code> points in the convex hull of <code>Yp</code> points</p>
</td></tr>
<tr><td><code>num.in.tris</code></td>
<td>
<p>The vector of number of <code>Xp</code> points
in the Delaunay triangles based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>weight.vec</code></td>
<td>
<p>The <code>vector</code> of the areas of Delaunay triangles
based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>The <code>vector</code> of the number of arcs of
the components of the AS-PCD in the
Delaunay triangles based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>del.tri.ind</code></td>
<td>
<p>A matrix of indices of Delaunay triangles based on <code>Yp</code> points,
each column corresponds to the vector of indices of the vertices of
one of the Delaunay triangle.</p>
</td></tr>
<tr><td><code>data.tri.ind</code></td>
<td>
<p>A <code>vector</code> of indices of vertices of
the Delaunay triangles in which data points reside,
i.e., column number of <code>del.tri.ind</code> for each <code>Xp</code> point.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the Delaunay triangulation based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsAStri">num.arcsAStri</a></code>, <code><a href="#topic+num.arcsPE">num.arcsPE</a></code>, and <code><a href="#topic+num.arcsCS">num.arcsCS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-15; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx),runif(nx))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-"CC"  #try also M&lt;-c(1,1,1)
Narcs = num.arcsAS(Xp,Yp,M)
Narcs
summary(Narcs)
plot(Narcs)


</code></pre>

<hr>
<h2 id='num.arcsAStri'>Number of arcs of Arc Slice Proximity Catch Digraphs (AS-PCDs)
and quantities related to the triangle - one triangle case</h2><span id='topic+num.arcsAStri'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs of Arc Slice Proximity Catch Digraphs (AS-PCDs)
whose vertices are the 2D data set, <code>Xp</code>.
It also provides number of vertices (i.e., number of data points inside the triangle)
and indices of the data points that reside in the triangle.
</p>
<p>The data points could be inside or outside a general
triangle <code>tri</code><code class="reqn">=T(A,B,C)=</code><code>(rv=1,rv=2,rv=3)</code>,
with vertices of <code>tri</code> stacked row-wise.
</p>
<p>AS proximity regions are defined with respect to the triangle <code>tri</code>
and vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
For the number of arcs, loops are not allowed,
so arcs are only possible for points inside the triangle, <code>tri</code>.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsAStri(Xp, tri, M = "CC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsAStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute
the vertices of the digraph (i.e., AS-PCD).</p>
</td></tr>
<tr><td><code id="num.arcsAStri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise,
each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="num.arcsAStri_+3A_m">M</code></td>
<td>
<p>The center of the triangle.
<code>"CC"</code> stands for circumcenter of the triangle <code>tri</code>
or a 2D point in Cartesian coordinates or
a 3D point in barycentric coordinates which serves as a center
in the interior of <code>tri</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and quantities related to the triangle</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Number of arcs of the AS-PCD</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>Number of arcs of the induced subdigraph of the AS-PCD
for vertices in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>num.in.tri</code></td>
<td>
<p>Number of <code>Xp</code> points in the triangle, <code>tri</code></p>
</td></tr>
<tr><td><code>ind.in.tri</code></td>
<td>
<p>The vector of indices of the <code>Xp</code> points
that reside in the triangle</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the vertices of the support triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsAS">num.arcsAS</a></code>, <code><a href="#topic+num.arcsPEtri">num.arcsPEtri</a></code>,
and <code><a href="#topic+num.arcsCStri">num.arcsCStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

n&lt;-10  #try also n&lt;-20
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

Narcs = num.arcsAStri(Xp,Tr,M)
Narcs
summary(Narcs)
plot(Narcs)


</code></pre>

<hr>
<h2 id='num.arcsCS'>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)
and related quantities of the induced subdigraphs for points in the Delaunay triangles -
multiple triangle case</h2><span id='topic+num.arcsCS'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs and various other quantities related to the Delaunay triangles
for Central Similarity Proximity Catch Digraph
(CS-PCD) whose vertices are the data points in <code>Xp</code>
in the multiple triangle case.
</p>
<p>CS proximity regions are defined with respect to the
Delaunay triangles based on <code>Yp</code> points with expansion parameter <code class="reqn">t&gt;0</code> and edge regions in each triangle
is based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of each
Delaunay triangle or based on circumcenter of each Delaunay triangle (default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of the triangle).
Each Delaunay triangle is first converted to an (nonscaled) basic triangle so that <code>M</code> will be the same
type of center for each Delaunay triangle (this conversion is not necessary when <code>M</code> is <code class="reqn">CM</code>).
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
For the number of arcs, loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)) for more on CS-PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016)) for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsCS(Xp, Yp, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsCS_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsCS_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="num.arcsCS_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="num.arcsCS_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates which serves as a center in the interior of each Delaunay
triangle, default for <code class="reqn">M=(1,1,1)</code> which is the center of mass of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and related quantities for the induced subdigraphs in the Delaunay triangles</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Total number of arcs in all triangles, i.e., the number of arcs for the entire CS-PCD</p>
</td></tr>
<tr><td><code>num.in.conv.hull</code></td>
<td>
<p>Number of <code>Xp</code> points in the convex hull of <code>Yp</code> points</p>
</td></tr>
<tr><td><code>num.in.tris</code></td>
<td>
<p>The vector of number of <code>Xp</code> points in the Delaunay triangles based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>weight.vec</code></td>
<td>
<p>The <code>vector</code> of the areas of Delaunay triangles based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>The <code>vector</code> of the number of arcs of the components of the CS-PCD in the
Delaunay triangles based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>del.tri.ind</code></td>
<td>
<p>A matrix of indices of vertices of the Delaunay triangles based on <code>Yp</code> points,
each column corresponds to the vector of indices of the vertices of one triangle.</p>
</td></tr>
<tr><td><code>data.tri.ind</code></td>
<td>
<p>A <code>vector</code> of indices of vertices of the Delaunay triangles in which data points reside,
i.e., column number of <code>del.tri.ind</code> for each <code>Xp</code> point.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the Delaunay triangulation based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsCStri">num.arcsCStri</a></code>, <code><a href="#topic+num.arcsCSstd.tri">num.arcsCSstd.tri</a></code>, <code><a href="#topic+num.arcsPE">num.arcsPE</a></code>,
and <code><a href="#topic+num.arcsAS">num.arcsAS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx),runif(nx))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

Narcs = num.arcsCS(Xp,Yp,t=1,M)
Narcs
summary(Narcs)
plot(Narcs)


</code></pre>

<hr>
<h2 id='num.arcsCS1D'>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)
and related quantities of the induced subdigraphs for points in the partition intervals -
multiple interval case</h2><span id='topic+num.arcsCS1D'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs and various other quantities related to the partition intervals
for Central Similarity Proximity Catch Digraph
(CS-PCD) whose vertices are the data points in <code>Xp</code>
in the multiple interval case.
</p>
<p>For this function, CS proximity regions are constructed data points inside or outside the intervals based
on <code>Yp</code> points with expansion parameter <code class="reqn">t \ge 0</code> and centrality parameter <code class="reqn">c \in (0,1)</code>. That is, for this function,
arcs may exist for points in the middle or end-intervals.
</p>
<p>Range (or convex hull) of <code>Yp</code> (i.e., the interval <code class="reqn">(\min(Yp),\max(Yp))</code>)
is partitioned by the spacings based on
<code>Yp</code> points (i.e., multiple intervals are these partition intervals
based on the order statistics of <code>Yp</code> points
whose union constitutes the range of <code>Yp</code> points).
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
For the number of arcs, loops are not counted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsCS1D(Xp, Yp, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsCS1D_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsCS1D_+3A_yp">Yp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the end points of the partition intervals.</p>
</td></tr>
<tr><td><code id="num.arcsCS1D_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region;
must be <code class="reqn">&gt; 0</code>.</p>
</td></tr>
<tr><td><code id="num.arcsCS1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside the middle (partition) intervals
with the default <code>c=.5</code>.
For an interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and related quantities for the induced subdigraphs in the partition intervals</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Total number of arcs in all intervals (including the end-intervals),
i.e., the number of arcs for the entire CS-PCD</p>
</td></tr>
<tr><td><code>num.in.range</code></td>
<td>
<p>Number of <code>Xp</code> points in the range or convex hull of <code>Yp</code> points</p>
</td></tr>
<tr><td><code>num.in.ints</code></td>
<td>
<p>The vector of number of <code>Xp</code> points in the partition intervals (including the end-intervals)
based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>weight.vec</code></td>
<td>
<p>The <code>vector</code> of the lengths of the middle partition intervals (i.e., end-intervals excluded)
based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>int.num.arcs</code></td>
<td>
<p>The <code>vector</code> of the number of arcs of the components of the CS-PCD in the
partition intervals (including the end-intervals) based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>part.int</code></td>
<td>
<p>A list of partition intervals based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>data.int.ind</code></td>
<td>
<p>A <code>vector</code> of indices of partition intervals in which data points reside,
i.e., column number of <code>part.int</code> is provided for each <code>Xp</code> point. Partition intervals are numbered from left to right
with 1 being the left end-interval.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the partition intervals based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsCSint">num.arcsCSint</a></code>, <code><a href="#topic+num.arcsCSmid.int">num.arcsCSmid.int</a></code>,
<code><a href="#topic+num.arcsCSend.int">num.arcsCSend.int</a></code>, and <code><a href="#topic+num.arcsPE1D">num.arcsPE1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau&lt;-1.5
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b);

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

Narcs = num.arcsCS1D(Xp,Yp,tau,c)
Narcs
summary(Narcs)
plot(Narcs)

</code></pre>

<hr>
<h2 id='num.arcsCSend.int'>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs) - end-interval case</h2><span id='topic+num.arcsCSend.int'></span>

<h3>Description</h3>

<p>Returns the number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs) whose
vertices are a 1D numerical data set, <code>Xp</code>, outside the interval <code>int</code><code class="reqn">=(a,b)</code>.
</p>
<p>CS proximity region is constructed only with expansion parameter <code class="reqn">t&gt;0</code> for points outside the interval <code class="reqn">(a,b)</code>.
</p>
<p>End vertex regions are based on the end points of the interval,
i.e., the corresponding end vertex region is an interval as <code class="reqn">(-\infty,a)</code> or <code class="reqn">(b,\infty)</code> for the interval <code class="reqn">(a,b)</code>.
For the number of arcs, loops are not allowed, so arcs are only possible for points outside
the interval, <code>int</code>, for this function.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsCSend.int(Xp, int, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsCSend.int_+3A_xp">Xp</code></td>
<td>
<p>A <code>vector</code> of 1D points which constitute the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="num.arcsCSend.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="num.arcsCSend.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of arcs for the CS-PCD with vertices being 1D data set, <code>Xp</code>,
expansion parameter, <code>t</code>, for the end-intervals.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsCSmid.int">num.arcsCSmid.int</a></code>, <code><a href="#topic+num.arcsPEmid.int">num.arcsPEmid.int</a></code>, and <code><a href="#topic+num.arcsPEend.int">num.arcsPEend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-5
XpL&lt;-runif(n,a-5,a)
XpR&lt;-runif(n,b,b+5)
Xp&lt;-c(XpL,XpR)

num.arcsCSend.int(Xp,int,t=2)

num.arcsCSend.int(Xp,int,t=1.2)

num.arcsCSend.int(Xp,int,t=4)

num.arcsCSend.int(Xp,int,t=2+5)
#num.arcsCSend.int(Xp,int,t=c(-5,15))

n&lt;-10  #try also n&lt;-20
Xp2&lt;-runif(n,a-5,b+5)
num.arcsCSend.int(Xp2,int,t=2)

t&lt;-.5
num.arcsCSend.int(Xp,int,t)

</code></pre>

<hr>
<h2 id='num.arcsCSint'>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)
and quantities related to the interval - one interval case</h2><span id='topic+num.arcsCSint'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)
whose vertices are the
data points in <code>Xp</code> in the one middle interval case.
It also provides number of vertices
(i.e., number of data points inside the intervals)
and indices of the data points that reside in the intervals.
</p>
<p>The data points could be inside or outside the interval is <code>int</code><code class="reqn">=(a,b)</code>.
</p>
<p>CS proximity region is constructed
with an expansion parameter <code class="reqn">t&gt;0</code> and a centrality parameter <code class="reqn">c \in (0,1)</code>.
CS proximity region is constructed for both points inside and outside the interval, hence
the arcs may exist for all points inside or outside the interval.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsCSint(Xp, int, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsCSint_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitute the vertices of CS-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsCSint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="num.arcsCSint_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="num.arcsCSint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and quantities related to the interval</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Total number of arcs in all intervals (including the end-intervals),
i.e., the number of arcs for the entire CS-PCD</p>
</td></tr>
<tr><td><code>num.in.range</code></td>
<td>
<p>Number of <code>Xp</code> points in the interval <code>int</code></p>
</td></tr>
<tr><td><code>num.in.ints</code></td>
<td>
<p>The vector of number of <code>Xp</code> points in the partition intervals (including the end-intervals)</p>
</td></tr>
<tr><td><code>int.num.arcs</code></td>
<td>
<p>The <code>vector</code> of the number of arcs of the components of the CS-PCD in the
partition intervals (including the end-intervals)</p>
</td></tr>
<tr><td><code>data.int.ind</code></td>
<td>
<p>A <code>vector</code> of indices of partition intervals in which data points reside.
Partition intervals are numbered from left to right with 1 being the left end-interval.</p>
</td></tr>
<tr><td><code>ind.left.end</code>, <code>ind.mid</code>, <code>ind.right.end</code></td>
<td>
<p>Indices of data points in the left end-interval,
middle interval, and right end-interval (respectively)</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the end points of the support interval <code>int</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsCSmid.int">num.arcsCSmid.int</a></code>, <code><a href="#topic+num.arcsCSend.int">num.arcsCSend.int</a></code>,
and <code><a href="#topic+num.arcsPEint">num.arcsPEint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
t&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-10
set.seed(1)
Xp&lt;-runif(n,a,b)
Narcs = num.arcsCSint(Xp,int,t,c)
Narcs
summary(Narcs)
plot(Narcs)

</code></pre>

<hr>
<h2 id='num.arcsCSmid.int'>Number of Arcs of of Central Similarity Proximity Catch Digraphs (CS-PCDs) - middle interval case</h2><span id='topic+num.arcsCSmid.int'></span>

<h3>Description</h3>

<p>Returns the number of arcs of of Central Similarity Proximity Catch Digraphs (CS-PCDs) whose vertices are
the given 1D numerical data set, <code>Xp</code>.
</p>
<p>CS proximity region <code class="reqn">N_{CS}(x,t,c)</code> is defined with respect to the interval
<code>int</code><code class="reqn">=(a,b)</code> for this function. CS proximity region is constructed with expansion parameter <code class="reqn">t&gt;0</code> and
centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>Vertex regions are based on the center associated with the centrality parameter <code class="reqn">c \in (0,1)</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code> and for the number of arcs,
loops are not allowed so arcs are only possible for points inside the middle interval <code>int</code> for this function.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsCSmid.int(Xp, int, t, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsCSmid.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of CS-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsCSmid.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="num.arcsCSmid.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="num.arcsCSmid.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of arcs for the CS-PCD whose vertices are the 1D data set, <code>Xp</code>,
with expansion parameter, <code class="reqn">r \ge 1</code>, and centrality parameter, <code class="reqn">c \in (0,1)</code>. PE proximity regions are defined only
for <code>Xp</code> points inside the interval <code>int</code>, i.e., arcs are possible for such points only.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsCSend.int">num.arcsCSend.int</a></code>, <code><a href="#topic+num.arcsPEmid.int">num.arcsPEmid.int</a></code>, and <code><a href="#topic+num.arcsPEend.int">num.arcsPEend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
t&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-10
Xp&lt;-runif(n,a,b)
num.arcsCSmid.int(Xp,int,t,c)

num.arcsCSmid.int(Xp,int,t,c=.3)

num.arcsCSmid.int(Xp,int,t=1.5,c)

#num.arcsCSmid.int(Xp,int,t,c+5) #gives error
#num.arcsCSmid.int(Xp,int,t,c+10)

n&lt;-10  #try also n&lt;-20
Xp&lt;-runif(n,a-5,b+5)
num.arcsCSint(Xp,int,t,c)

Xp&lt;-runif(n,a+10,b+10)
num.arcsCSmid.int(Xp,int,t,c)

n&lt;-10
Xp&lt;-runif(n,a,b)
num.arcsCSmid.int(Xp,int,t,c)

</code></pre>

<hr>
<h2 id='num.arcsCSstd.tri'>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)
and quantities related to the triangle - standard equilateral triangle case</h2><span id='topic+num.arcsCSstd.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)
whose vertices are the
given 2D numerical data set, <code>Xp</code>.
It also provides number of vertices
(i.e., number of data points inside the standard equilateral triangle <code class="reqn">T_e</code>)
and indices of the data points that reside in <code class="reqn">T_e</code>.
</p>
<p>CS proximity region <code class="reqn">N_{CS}(x,t)</code> is defined with respect to the standard
equilateral triangle <code class="reqn">T_e=T(v=1,v=2,v=3)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code> with expansion parameter <code class="reqn">t&gt;0</code>
and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code class="reqn">T_e</code>.
For the number of arcs, loops are not allowed so
arcs are only possible for points inside <code class="reqn">T_e</code> for this function.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsCSstd.tri(Xp, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsCSstd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="num.arcsCSstd.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="num.arcsCSstd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates.
which serves as a center in the interior of the standard equilateral triangle <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and quantities related to the standard equilateral triangle</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Number of arcs of the CS-PCD</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>Number of arcs of the induced subdigraph of the CS-PCD
for vertices in the standard equilateral triangle <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>num.in.tri</code></td>
<td>
<p>Number of <code>Xp</code> points in the standard equilateral triangle, <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>ind.in.tri</code></td>
<td>
<p>The vector of indices of the <code>Xp</code> points that reside in <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the vertices of the support triangle <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsCStri">num.arcsCStri</a></code>, <code><a href="#topic+num.arcsCS">num.arcsCS</a></code>, and <code><a href="#topic+num.arcsPEstd.tri">num.arcsPEstd.tri</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

Narcs = num.arcsCSstd.tri(Xp,t=.5,M)
Narcs
summary(Narcs)
oldpar &lt;- par(pty="s")
plot(Narcs,asp=1)
par(oldpar)


</code></pre>

<hr>
<h2 id='num.arcsCStri'>Number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)
and quantities related to the triangle - one triangle case</h2><span id='topic+num.arcsCStri'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs of Central Similarity Proximity Catch Digraphs (CS-PCDs)
whose vertices are the
given 2D numerical data set, <code>Xp</code>.
It also provides number of vertices
(i.e., number of data points inside the triangle)
and indices of the data points that reside in the triangle.
</p>
<p>CS proximity region <code class="reqn">N_{CS}(x,t)</code> is defined with respect to the triangle, <code>tri</code>  with expansion parameter <code class="reqn">t&gt;0</code>
and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
For the number of arcs, loops are not allowed so
arcs are only possible for points inside <code>tri</code> for this function.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsCStri(Xp, tri, t, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsCStri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of CS-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsCStri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="num.arcsCStri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="num.arcsCStri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>; default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and quantities related to the triangle</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Number of arcs of the CS-PCD</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>Number of arcs of the induced subdigraph of the CS-PCD
for vertices in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>num.in.tri</code></td>
<td>
<p>Number of <code>Xp</code> points in the triangle, <code>tri</code></p>
</td></tr>
<tr><td><code>ind.in.tri</code></td>
<td>
<p>The vector of indices of the <code>Xp</code> points that reside in the triangle</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the vertices of the support triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsCSstd.tri">num.arcsCSstd.tri</a></code>, <code><a href="#topic+num.arcsCS">num.arcsCS</a></code>, <code><a href="#topic+num.arcsPEtri">num.arcsPEtri</a></code>,
and <code><a href="#topic+num.arcsAStri">num.arcsAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

n&lt;-10  #try also n&lt;-20
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

Narcs = num.arcsCStri(Xp,Tr,t=.5,M)
Narcs
summary(Narcs)
plot(Narcs)


</code></pre>

<hr>
<h2 id='num.arcsPE'>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)
and related quantities of the induced subdigraphs for points in the Delaunay triangles -
multiple triangle case</h2><span id='topic+num.arcsPE'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs and various other quantities related to the Delaunay triangles
for Proportional Edge Proximity Catch Digraph
(PE-PCD) whose vertices are the data points in <code>Xp</code>
in the multiple triangle case.
</p>
<p>PE proximity regions are defined with respect to the
Delaunay triangles based on <code>Yp</code> points
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions in each triangle
is based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of each
Delaunay triangle or based on circumcenter of each Delaunay triangle
(default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of the triangle).
Each Delaunay triangle is first converted to
an (nonscaled) basic triangle so that <code>M</code> will be the same
type of center for each Delaunay triangle
(this conversion is not necessary when <code>M</code> is <code class="reqn">CM</code>).
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
For the number of arcs, loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2006))
for more on PE-PCDs.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsPE(Xp, Yp, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsPE_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsPE_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="num.arcsPE_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="num.arcsPE_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates
which serves as a center in the interior of each Delaunay
triangle or circumcenter of each Delaunay triangle
(for this, argument should be set as <code>M="CC"</code>),
default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and related quantities for the induced subdigraphs in the Delaunay triangles</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Total number of arcs in all triangles,
i.e., the number of arcs for the entire PE-PCD</p>
</td></tr>
<tr><td><code>num.in.conv.hull</code></td>
<td>
<p>Number of <code>Xp</code> points
in the convex hull of <code>Yp</code> points</p>
</td></tr>
<tr><td><code>num.in.tris</code></td>
<td>
<p>The vector of number of <code>Xp</code> points
in the Delaunay triangles based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>weight.vec</code></td>
<td>
<p>The <code>vector</code> of the areas of
Delaunay triangles based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>The <code>vector</code> of the number of arcs
of the components of the PE-PCD in the
Delaunay triangles based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>del.tri.ind</code></td>
<td>
<p>A matrix of indices of vertices of
the Delaunay triangles based on <code>Yp</code> points,
each column corresponds to the vector of
indices of the vertices of one triangle.</p>
</td></tr>
<tr><td><code>data.tri.ind</code></td>
<td>
<p>A <code>vector</code> of indices of vertices of
the Delaunay triangles in which data points reside,
i.e., column number of <code>del.tri.ind</code> for each <code>Xp</code> point.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the Delaunay triangulation based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsPEtri">num.arcsPEtri</a></code>, <code><a href="#topic+num.arcsPEstd.tri">num.arcsPEstd.tri</a></code>,
<code><a href="#topic+num.arcsCS">num.arcsCS</a></code>, and <code><a href="#topic+num.arcsAS">num.arcsAS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx),runif(nx))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

Narcs = num.arcsPE(Xp,Yp,r=1.25,M)
Narcs
summary(Narcs)
plot(Narcs)


</code></pre>

<hr>
<h2 id='num.arcsPE1D'>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)
and related quantities of the induced subdigraphs for points in the partition intervals -
multiple interval case</h2><span id='topic+num.arcsPE1D'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs and various other quantities related to the partition intervals
for Proportional Edge Proximity Catch Digraph
(PE-PCD) whose vertices are the data points in <code>Xp</code>
in the multiple interval case.
</p>
<p>For this function,
PE proximity regions are constructed data points inside or outside the intervals based
on <code>Yp</code> points with expansion parameter <code class="reqn">r \ge 1</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>. That is, for this function,
arcs may exist for points in the middle or end-intervals.
</p>
<p>Range (or convex hull) of <code>Yp</code> (i.e., the interval <code class="reqn">(\min(Yp),\max(Yp))</code>)
is partitioned by the spacings based on
<code>Yp</code> points (i.e., multiple intervals are these partition intervals
based on the order statistics of <code>Yp</code> points
whose union constitutes the range of <code>Yp</code> points).
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
For the number of arcs, loops are not counted.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsPE1D(Xp, Yp, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsPE1D_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsPE1D_+3A_yp">Yp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the end points of the partition intervals.</p>
</td></tr>
<tr><td><code id="num.arcsPE1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="num.arcsPE1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside the middle (partition) intervals
with the default <code>c=.5</code>.
For an interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and related quantities for the induced subdigraphs in the partition intervals</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Total number of arcs in all intervals (including the end-intervals),
i.e., the number of arcs for the entire PE-PCD</p>
</td></tr>
<tr><td><code>num.in.range</code></td>
<td>
<p>Number of <code>Xp</code> points in the range or convex hull of <code>Yp</code> points</p>
</td></tr>
<tr><td><code>num.in.ints</code></td>
<td>
<p>The vector of number of <code>Xp</code> points in the partition intervals (including the end-intervals)
based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>weight.vec</code></td>
<td>
<p>The <code>vector</code> of the lengths of the middle partition intervals (i.e., end-intervals excluded)
based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>int.num.arcs</code></td>
<td>
<p>The <code>vector</code> of the number of arcs of the components of the PE-PCD in the
partition intervals (including the end-intervals) based on <code>Yp</code> points</p>
</td></tr>
<tr><td><code>part.int</code></td>
<td>
<p>A matrix with columns corresponding to the partition intervals based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>data.int.ind</code></td>
<td>
<p>A <code>vector</code> of indices of partition intervals in which data points reside,
i.e., column number of <code>part.int</code> is provided for each <code>Xp</code> point. Partition intervals are numbered from left to right
with 1 being the left end-interval.</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation is the partition intervals based on <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsPEint">num.arcsPEint</a></code>, <code><a href="#topic+num.arcsPEmid.int">num.arcsPEmid.int</a></code>, <code><a href="#topic+num.arcsPEend.int">num.arcsPEend.int</a></code>,
and <code><a href="#topic+num.arcsCS1D">num.arcsCS1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b);

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

Narcs = num.arcsPE1D(Xp,Yp,r,c)
Narcs
summary(Narcs)
plot(Narcs)


</code></pre>

<hr>
<h2 id='num.arcsPEend.int'>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs) - end-interval case</h2><span id='topic+num.arcsPEend.int'></span>

<h3>Description</h3>

<p>Returns the number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs) whose
vertices are a 1D numerical data set, <code>Xp</code>, outside the interval <code>int</code><code class="reqn">=(a,b)</code>.
</p>
<p>PE proximity region is constructed only with expansion parameter <code class="reqn">r \ge 1</code> for points outside the interval <code class="reqn">(a,b)</code>.
End vertex regions are based on the end points of the interval,
i.e., the corresponding vertex region is an interval as <code class="reqn">(-\infty,a)</code> or <code class="reqn">(b,\infty)</code> for the interval <code class="reqn">(a,b)</code>.
For the number of arcs, loops are not allowed, so arcs are only possible for points outside
the interval, <code>int</code>, for this function.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsPEend.int(Xp, int, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsPEend.int_+3A_xp">Xp</code></td>
<td>
<p>A <code>vector</code> of 1D points which constitute the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="num.arcsPEend.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="num.arcsPEend.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of arcs for the PE-PCD with vertices being 1D data set, <code>Xp</code>,
expansion parameter, <code class="reqn">r \ge 1</code>, for the end-intervals.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsPEmid.int">num.arcsPEmid.int</a></code>, <code><a href="#topic+num.arcsPE1D">num.arcsPE1D</a></code>, <code><a href="#topic+num.arcsCSmid.int">num.arcsCSmid.int</a></code>, and <code><a href="#topic+num.arcsCSend.int">num.arcsCSend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-5
XpL&lt;-runif(n,a-5,a)
XpR&lt;-runif(n,b,b+5)
Xp&lt;-c(XpL,XpR)

r&lt;-1.2
num.arcsPEend.int(Xp,int,r)
num.arcsPEend.int(Xp,int,r=2)


</code></pre>

<hr>
<h2 id='num.arcsPEint'>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)
and quantities related to the interval - one interval case</h2><span id='topic+num.arcsPEint'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs of Proportional Edge Proximity Catch Digraph (PE-PCD)
whose vertices are the
data points in <code>Xp</code> in the one middle interval case.
It also provides number of vertices
(i.e., number of data points inside the intervals)
and indices of the data points that reside in the intervals.
</p>
<p>The data points could be inside or outside the interval is <code>int</code><code class="reqn">=(a,b)</code>.
PE proximity region is constructed
with an expansion parameter <code class="reqn">r \ge 1</code> and a centrality parameter <code class="reqn">c \in (0,1)</code>.
<code>int</code> determines the end points of the interval.
</p>
<p>The PE proximity region is constructed for both points inside and outside the interval,
hence
the arcs may exist for all points inside or outside the interval.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsPEint(Xp, int, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsPEint_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitute the vertices of PE-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsPEint_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="num.arcsPEint_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="num.arcsPEint_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and quantities related to the interval</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Total number of arcs in all intervals (including the end-intervals),
i.e., the number of arcs for the entire PE-PCD</p>
</td></tr>
<tr><td><code>num.in.range</code></td>
<td>
<p>Number of <code>Xp</code> points in the interval <code>int</code></p>
</td></tr>
<tr><td><code>num.in.ints</code></td>
<td>
<p>The vector of number of <code>Xp</code> points in the partition intervals (including the end-intervals)</p>
</td></tr>
<tr><td><code>int.num.arcs</code></td>
<td>
<p>The <code>vector</code> of the number of arcs of the components of the PE-PCD in the
partition intervals (including the end-intervals)</p>
</td></tr>
<tr><td><code>data.int.ind</code></td>
<td>
<p>A <code>vector</code> of indices of partition intervals in which data points reside.
Partition intervals are numbered from left to right with 1 being the left end-interval.</p>
</td></tr>
<tr><td><code>ind.left.end</code>, <code>ind.mid</code>, <code>ind.right.end</code></td>
<td>
<p>Indices of data points in the left end-interval,
middle interval, and right end-interval (respectively)</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the end points of the support interval <code>int</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsPEmid.int">num.arcsPEmid.int</a></code>, <code><a href="#topic+num.arcsPEend.int">num.arcsPEend.int</a></code>,
and <code><a href="#topic+num.arcsCSint">num.arcsCSint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

xf&lt;-(int[2]-int[1])*.1

set.seed(123)

n&lt;-10
Xp&lt;-runif(n,a-xf,b+xf)
Narcs = num.arcsPEint(Xp,int,r,c)
Narcs
summary(Narcs)
plot(Narcs)


</code></pre>

<hr>
<h2 id='num.arcsPEmid.int'>Number of Arcs for Proportional Edge Proximity Catch Digraphs (PE-PCDs) - middle interval case</h2><span id='topic+num.arcsPEmid.int'></span>

<h3>Description</h3>

<p>Returns the number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs) whose vertices are the
given 1D numerical data set, <code>Xp</code>. PE proximity region <code class="reqn">N_{PE}(x,r,c)</code> is defined with respect to the interval
<code>int</code><code class="reqn">=(a,b)</code> for this function.
</p>
<p>PE proximity region is constructed with expansion parameter <code class="reqn">r \ge 1</code> and
centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>Vertex regions are based on the center associated with the centrality parameter <code class="reqn">c \in (0,1)</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code> and for the number of arcs,
loops are not allowed so arcs are only possible for points inside the middle interval <code>int</code> for this function.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsPEmid.int(Xp, int, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsPEmid.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of PE-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsPEmid.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="num.arcsPEmid.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="num.arcsPEmid.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of arcs for the PE-PCD whose vertices are the 1D data set, <code>Xp</code>,
with expansion parameter, <code class="reqn">r \ge 1</code>, and centrality parameter, <code class="reqn">c \in (0,1)</code>. PE proximity regions are defined only
for <code>Xp</code> points inside the interval <code>int</code>, i.e., arcs are possible for such points only.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsPEend.int">num.arcsPEend.int</a></code>, <code><a href="#topic+num.arcsPE1D">num.arcsPE1D</a></code>, <code><a href="#topic+num.arcsCSmid.int">num.arcsCSmid.int</a></code>, and <code><a href="#topic+num.arcsCSend.int">num.arcsCSend.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-10
Xp&lt;-runif(n,a,b)
num.arcsPEmid.int(Xp,int,r,c)
num.arcsPEmid.int(Xp,int,r=1.5,c)


</code></pre>

<hr>
<h2 id='num.arcsPEstd.tri'>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)
and quantities related to the triangle - standard equilateral triangle case</h2><span id='topic+num.arcsPEstd.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs of
Proportional Edge Proximity Catch Digraphs (PE-PCDs)
whose vertices are the
given 2D numerical data set, <code>Xp</code>
in the standard equilateral triangle.
It also provides number of vertices
(i.e., number of data points inside the standard equilateral triangle <code class="reqn">T_e</code>)
and indices of the data points that reside in <code class="reqn">T_e</code>.
</p>
<p>PE proximity region <code class="reqn">N_{PE}(x,r)</code> is defined
with respect to the standard equilateral triangle
<code class="reqn">T_e=T(v=1,v=2,v=3)=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code class="reqn">T_e</code>.
For the number of arcs, loops are not allowed so
arcs are only possible for points inside <code class="reqn">T_e</code> for this function.
</p>
<p>See also (Ceyhan et al. (2006)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsPEstd.tri(Xp, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsPEstd.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsPEstd.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter for PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="num.arcsPEstd.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard equilateral triangle <code class="reqn">T_e</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e.
the center of mass of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and quantities related to the standard equilateral triangle</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Number of arcs of the PE-PCD</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>Number of arcs of the induced subdigraph of the PE-PCD
for vertices in the standard equilateral triangle <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>num.in.tri</code></td>
<td>
<p>Number of <code>Xp</code> points
in the standard equilateral triangle, <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>ind.in.tri</code></td>
<td>
<p>The vector of indices of the <code>Xp</code> points
that reside in <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the vertices of the support triangle <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsPEtri">num.arcsPEtri</a></code>, <code><a href="#topic+num.arcsPE">num.arcsPE</a></code>,
and <code><a href="#topic+num.arcsCSstd.tri">num.arcsCSstd.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-c(.6,.2)  #try also M&lt;-c(1,1,1)

Narcs = num.arcsPEstd.tri(Xp,r=1.25,M)
Narcs
summary(Narcs)
oldpar &lt;- par(pty="s")
plot(Narcs,asp=1)
par(oldpar)


</code></pre>

<hr>
<h2 id='num.arcsPEtetra'>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)
and quantities related to the tetrahedron - one tetrahedron case</h2><span id='topic+num.arcsPEtetra'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs of
Proportional Edge Proximity Catch Digraphs (PE-PCDs)
whose vertices are the
given 3D numerical data set, <code>Xp</code>.
It also provides number of vertices
(i.e., number of data points inside the tetrahedron)
and indices of the data points that reside in the tetrahedron.
</p>
<p>PE proximity region is constructed with respect to the tetrahedron <code>th</code> and
vertex regions are based on the center <code>M</code> which is circumcenter (<code>"CC"</code>) or
center of mass (<code>"CM"</code>) of <code>th</code> with default=<code>"CM"</code>.
For the number of arcs, loops are not
allowed so arcs are only possible for points inside the tetrahedron <code>th</code> for this function.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsPEtetra(Xp, th, r, M = "CM")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsPEtetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitute the vertices of PE-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsPEtetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="num.arcsPEtetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="num.arcsPEtetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and quantities related to the tetrahedron</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Number of arcs of the PE-PCD</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>Number of arcs of the induced subdigraph of the PE-PCD
for vertices in the tetrahedron <code>th</code></p>
</td></tr>
<tr><td><code>num.in.tetra</code></td>
<td>
<p>Number of <code>Xp</code> points in the tetrahedron, <code>th</code></p>
</td></tr>
<tr><td><code>ind.in.tetra</code></td>
<td>
<p>The vector of indices of the <code>Xp</code> points that reside in the tetrahedron</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed, here,
tessellation points are the vertices of the support tetrahedron <code>th</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsPEtri">num.arcsPEtri</a></code>, <code><a href="#topic+num.arcsCStri">num.arcsCStri</a></code>,
and <code><a href="#topic+num.arcsAStri">num.arcsAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)

n&lt;-10  #try also n&lt;-20
set.seed(1)
Xp&lt;-runif.tetra(n,tetra)$g

M&lt;-"CM"  #try also M&lt;-"CC"
r&lt;-1.25

Narcs = num.arcsPEtetra(Xp,tetra,r,M)
Narcs
summary(Narcs)
#plot(Narcs)


</code></pre>

<hr>
<h2 id='num.arcsPEtri'>Number of arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)
and quantities related to the triangle - one triangle case</h2><span id='topic+num.arcsPEtri'></span>

<h3>Description</h3>

<p>An object of class <code>"NumArcs"</code>.
Returns the number of arcs of
Proportional Edge Proximity Catch Digraphs (PE-PCDs)
whose vertices are the
given 2D numerical data set, <code>Xp</code>.
It also provides number of vertices
(i.e., number of data points inside the triangle)
and indices of the data points that reside in the triangle.
</p>
<p>PE proximity region <code class="reqn">N_{PE}(x,r)</code> is defined
with respect to the triangle, <code>tri</code>
with expansion parameter <code class="reqn">r \ge 1</code> and vertex regions are
based on the center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code> or
based on circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.
For the number of arcs, loops are not
allowed so arcs are only possible for points
inside the triangle <code>tri</code> for this function.
</p>
<p>See also (Ceyhan (2005, 2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.arcsPEtri(Xp, tri, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.arcsPEtri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of PE-PCD.</p>
</td></tr>
<tr><td><code id="num.arcsPEtri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="num.arcsPEtri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="num.arcsPEtri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A short description of the output: number of arcs
and quantities related to the triangle</p>
</td></tr>
<tr><td><code>num.arcs</code></td>
<td>
<p>Number of arcs of the PE-PCD</p>
</td></tr>
<tr><td><code>tri.num.arcs</code></td>
<td>
<p>Number of arcs of the induced subdigraph of the PE-PCD
for vertices in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>num.in.tri</code></td>
<td>
<p>Number of <code>Xp</code> points in the triangle, <code>tri</code></p>
</td></tr>
<tr><td><code>ind.in.tri</code></td>
<td>
<p>The vector of indices of the <code>Xp</code> points
that reside in the triangle</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>Tessellation points, i.e., points on which the tessellation of
the study region is performed,
here, tessellation points are the vertices of the support triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>Vertices of the digraph, <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2016).
&ldquo;Edge Density of New Graph Types Based on a Random Digraph Family.&rdquo;
<em>Statistical Methodology</em>, <b>33</b>, 31-54.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num.arcsPEstd.tri">num.arcsPEstd.tri</a></code>, <code><a href="#topic+num.arcsPE">num.arcsPE</a></code>,
<code><a href="#topic+num.arcsCStri">num.arcsCStri</a></code>, and <code><a href="#topic+num.arcsAStri">num.arcsAStri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

n&lt;-10  #try also n&lt;-20
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

Narcs = num.arcsPEtri(Xp,Tr,r=1.25,M)
Narcs
summary(Narcs)
plot(Narcs)


</code></pre>

<hr>
<h2 id='num.delaunay.tri'>Number of Delaunay triangles based on a 2D data set</h2><span id='topic+num.delaunay.tri'></span>

<h3>Description</h3>

<p>Returns the number of Delaunay triangles
based on the 2D set of points <code>Yp</code>.
See (Okabe et al. (2000); Sinclair (2016))
for more on Delaunay triangulation and
the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.delaunay.tri(Yp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num.delaunay.tri_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of Delaunay triangles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of Delaunay triangles based on <code>Yp</code> points.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotDelaunay.tri">plotDelaunay.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ny&lt;-10

set.seed(1)
Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

num.delaunay.tri(Yp)

</code></pre>

<hr>
<h2 id='paraline'>The line at a point <code>p</code> parallel to the line segment
joining two distinct 2D points <code>a</code> and <code>b</code></h2><span id='topic+paraline'></span>

<h3>Description</h3>

<p>An object of class <code>"Lines"</code>.
Returns the <code>equation, slope, intercept</code>,
and <code class="reqn">y</code>-coordinates of the line crossing the
point <code>p</code> and parallel to the line
passing through the points <code>a</code> and <code>b</code> with
<code class="reqn">x</code>-coordinates are provided in <code>vector</code> <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paraline(p, a, b, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paraline_+3A_p">p</code></td>
<td>
<p>A 2D point at which the parallel line to line segment
joining <code>a</code> and <code>b</code> crosses.</p>
</td></tr>
<tr><td><code id="paraline_+3A_a">a</code>, <code id="paraline_+3A_b">b</code></td>
<td>
<p>2D points that determine the line segment
(the line will be parallel to this line segment).</p>
</td></tr>
<tr><td><code id="paraline_+3A_x">x</code></td>
<td>
<p>A scalar or a <code>vector</code> of scalars
representing the <code class="reqn">x</code>-coordinates of the line parallel to
<code>ab</code> and crossing <code>p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>Description of the line
passing through point <code>p</code> and parallel to line segment joining
<code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line
passing through point <code>p</code> and parallel to
line segment joining <code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>The input points <code>p</code>, <code>a</code>, and <code>b</code>
(stacked row-wise, i.e., point <code>p</code> is in row 1,
point <code>a</code> is in row 2
and point <code>b</code> is in row 3).
Line parallel to <code>ab</code> crosses p.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The input vector.
It can be a scalar or a <code>vector</code> of scalars,
which constitute the <code class="reqn">x</code>-coordinates of the point(s) of interest
on the line passing through point
<code>p</code> and parallel to line segment joining <code>a</code> and <code>b</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The output scalar or <code>vector</code>
which constitutes the <code class="reqn">y</code>-coordinates of the point(s) of interest
on the line passing through point <code>p</code>
and parallel to line segment joining <code>a</code> and <code>b</code>.
If <code>x</code> is a scalar, then <code>y</code> will be a scalar
and if <code>x</code> is a <code>vector</code> of scalars,
then <code>y</code> will be a <code>vector</code> of scalars.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>Slope of the line, <code>Inf</code> is allowed,
passing through point <code>p</code> and parallel to
line segment joining <code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>Intercept of the line
passing through point <code>p</code> and parallel to line segment
joining <code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line
passing through point <code>p</code> and parallel to line segment joining
<code>a</code> and <code>b</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slope">slope</a></code>, <code><a href="#topic+Line">Line</a></code>, and <code><a href="#topic+perpline">perpline</a></code>,
<code><a href="stats.html#topic+line">line</a></code> in the generic <code>stats</code> package,
and <code><a href="#topic+paraline3D">paraline3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1.1,1.2); B&lt;-c(2.3,3.4); p&lt;-c(.51,2.5)

paraline(p,A,B,.45)

pts&lt;-rbind(A,B,p)
xr&lt;-range(pts[,1])
xf&lt;-(xr[2]-xr[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100

plnAB&lt;-paraline(p,A,B,x)
plnAB
summary(plnAB)
plot(plnAB)

y&lt;-plnAB$y
Xlim&lt;-range(x,pts[,1])
if (!is.na(y[1])) {Ylim&lt;-range(y,pts[,2])} else {Ylim&lt;-range(pts[,2])}
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
pf&lt;-c(xd,-yd)*.025

plot(A,pch=".",xlab="",ylab="",main="Line Crossing P and Parallel to AB",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(pts)
txt.str&lt;-c("A","B","p")
text(pts+rbind(pf,pf,pf),txt.str)

segments(A[1],A[2],B[1],B[2],lty=2)
if (!is.na(y[1])) {lines(x,y,type="l",lty=1,xlim=Xlim,ylim=Ylim)} else {abline(v=p[1])}
tx&lt;-(A[1]+B[1])/2;
if (!is.na(y[1])) {ty&lt;-paraline(p,A,B,tx)$y} else {ty=p[2]}
text(tx,ty,"line parallel to AB\n and crossing p")


</code></pre>

<hr>
<h2 id='paraline3D'>The line crossing the 3D point <code>p</code>
and parallel to line joining 3D points <code>a</code> and <code>b</code></h2><span id='topic+paraline3D'></span>

<h3>Description</h3>

<p>An object of class <code>"Lines3D"</code>.
Returns the equation, <code class="reqn">x</code>-, <code class="reqn">y</code>-,
and <code class="reqn">z</code>-coordinates of the line crossing 3D point <code>p</code>
and parallel to the line
joining 3D points <code>a</code> and <code>b</code>
(i.e., the line is in the direction of <code>vector</code> <code>b</code>-<code>a</code>)
with the parameter <code>t</code>
being provided in <code>vector</code> <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paraline3D(p, a, b, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paraline3D_+3A_p">p</code></td>
<td>
<p>A 3D point through
which the straight line passes.</p>
</td></tr>
<tr><td><code id="paraline3D_+3A_a">a</code>, <code id="paraline3D_+3A_b">b</code></td>
<td>
<p>3D points
which determine the straight line to which
the line passing through point <code>p</code> would be
parallel (i.e., <code class="reqn">b-a</code> determines the direction of the straight line
passing through <code>p</code>).</p>
</td></tr>
<tr><td><code id="paraline3D_+3A_t">t</code></td>
<td>
<p>A scalar or a <code>vector</code> of scalars
representing the parameter of the coordinates of the line
(for the form: <code class="reqn">x=p_0 + A t</code>, <code class="reqn">y=y_0 + B t</code>,
and <code class="reqn">z=z_0 + C t</code> where <code class="reqn">p=(p_0,y_0,z_0)</code>
and <code class="reqn">b-a=(A,B,C)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A description of the line</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>The input points
that determine the line to which the line
crossing point <code>p</code> would be parallel.</p>
</td></tr>
<tr><td><code>pnames</code></td>
<td>
<p>The names of the input points
that determine the line to which the line crossing point <code>p</code> would
be parallel.</p>
</td></tr>
<tr><td><code>vecs</code></td>
<td>
<p>The points <code>p</code>, <code>a</code>,
and <code>b</code> stacked row-wise in this order.</p>
</td></tr>
<tr><td><code>vec.names</code></td>
<td>
<p>The names of the points <code>p</code>, <code>a</code>, and <code>b</code>.</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code>, <code>z</code></td>
<td>
<p>The <code class="reqn">x</code>-, <code class="reqn">y</code>-, and
<code class="reqn">z</code>-coordinates of the point(s) of interest
on the line parallel to the line
determined by points <code>a</code> and <code>b</code>.</p>
</td></tr>
<tr><td><code>tsq</code></td>
<td>
<p>The scalar or the <code>vector</code> of the parameter in
defining each coordinate of the line for the form:
<code class="reqn">x=p_0 + A t</code>, <code class="reqn">y=y_0 + B t</code>, and <code class="reqn">z=z_0 + C t</code>
where <code class="reqn">p=(p_0,y_0,z_0)</code> and <code class="reqn">b-a=(A,B,C)</code>.</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line
passing through point <code>p</code> and parallel to the line
joining points <code>a</code> and <code>b</code>
(i.e., in the direction of the <code>vector</code> <code>b</code>-<code>a</code>).
The line equation is in the form: <code class="reqn">x=p_0 + A t</code>, <code class="reqn">y=y_0 + B t</code>, and
<code class="reqn">z=z_0 + C t</code> where <code class="reqn">p=(p_0,y_0,z_0)</code> and <code class="reqn">b-a=(A,B,C)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Line3D">Line3D</a></code>, <code><a href="#topic+perpline2plane">perpline2plane</a></code>,
and <code><a href="#topic+paraline">paraline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(1,10,4); Q&lt;-c(1,1,3); R&lt;-c(3,9,12)

vecs&lt;-rbind(P,R-Q)
pts&lt;-rbind(P,Q,R)
paraline3D(P,Q,R,.1)

tr&lt;-range(pts,vecs);
tf&lt;-(tr[2]-tr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
tsq&lt;-seq(-tf*10-tf,tf*10+tf,l=5)  #try also l=10, 20, or 100

pln3D&lt;-paraline3D(P,Q,R,tsq)
pln3D
summary(pln3D)
plot(pln3D)

x&lt;-pln3D$x
y&lt;-pln3D$y
z&lt;-pln3D$z

zr&lt;-range(z)
zf&lt;-(zr[2]-zr[1])*.2
Qv&lt;-(R-Q)*tf*5

Xlim&lt;-range(x,pts[,1])
Ylim&lt;-range(y,pts[,2])
Zlim&lt;-range(z,pts[,3])

xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

Dr&lt;-P+min(tsq)*(R-Q)

plot3D::lines3D(x, y, z, phi = 0, bty = "g",
main="Line Crossing P \n in the direction of R-Q",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),
zlim=Zlim+zd*c(-.1,.1)+c(-zf,zf),
        pch = 20, cex = 2, ticktype = "detailed")
plot3D::arrows3D(Dr[1],Dr[2],Dr[3]+zf,Dr[1]+Qv[1],
Dr[2]+Qv[2],Dr[3]+zf+Qv[3], add=TRUE)
plot3D::points3D(pts[,1],pts[,2],pts[,3],add=TRUE)
plot3D::text3D(pts[,1],pts[,2],pts[,3],labels=c("P","Q","R"),add=TRUE)
plot3D::arrows3D(P[1],P[2],P[3]-2*zf,P[1],P[2],P[3],lty=2, add=TRUE)
plot3D::text3D(P[1],P[2],P[3]-2*zf,labels="initial point",add=TRUE)
plot3D::arrows3D(Dr[1]+Qv[1]/2,Dr[2]+Qv[2]/2,
Dr[3]+3*zf+Qv[3]/2,Dr[1]+Qv[1]/2,
Dr[2]+Qv[2]/2,Dr[3]+zf+Qv[3]/2,lty=2, add=TRUE)
plot3D::text3D(Dr[1]+Qv[1]/2,Dr[2]+Qv[2]/2,Dr[3]+3*zf+Qv[3]/2,
labels="direction vector",add=TRUE)
plot3D::text3D(Dr[1]+Qv[1]/2,Dr[2]+Qv[2]/2,
Dr[3]+zf+Qv[3]/2,labels="R-Q",add=TRUE)


</code></pre>

<hr>
<h2 id='paraplane'>The plane at a point and parallel to the plane spanned
by three distinct 3D points <code>a</code>, <code>b</code>, and <code>c</code></h2><span id='topic+paraplane'></span>

<h3>Description</h3>

<p>An object of class <code>"Planes"</code>.
Returns the equation and <code class="reqn">z</code>-coordinates of the plane
passing through point <code>p</code> and parallel to the plane spanned
by three distinct 3D points <code>a</code>, <code>b</code>,
and <code>c</code> with <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates are provided
in vectors <code>x</code> and <code>y</code>,
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paraplane(p, a, b, c, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paraplane_+3A_p">p</code></td>
<td>
<p>A 3D point which the plane parallel to the plane spanned by
three distinct 3D points <code>a</code>, <code>b</code>, and <code>c</code> crosses.</p>
</td></tr>
<tr><td><code id="paraplane_+3A_a">a</code>, <code id="paraplane_+3A_b">b</code>, <code id="paraplane_+3A_c">c</code></td>
<td>
<p>3D points that determine the plane to which the plane
crossing point <code>p</code> is parallel to.</p>
</td></tr>
<tr><td><code id="paraplane_+3A_x">x</code>, <code id="paraplane_+3A_y">y</code></td>
<td>
<p>Scalars or <code>vectors</code> of scalars
representing the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the plane parallel to
the plane spanned by points <code>a</code>, <code>b</code>,
and <code>c</code> and passing through point <code>p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>Description of the plane passing through point <code>p</code>
and parallel to plane spanned by points
<code>a</code>, <code>b</code> and <code>c</code></p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>The input points <code>a</code>, <code>b</code>, <code>c</code>, and <code>p</code>.
Plane is parallel to the plane spanned by <code>a</code>, <code>b</code>, and <code>c</code>
and passes through point <code>p</code> (stacked row-wise,
i.e., row 1 is point <code>a</code>, row 2 is point <code>b</code>,
row 3 is point <code>c</code>, and row 4 is point <code>p</code>).</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>The input vectors which constitutes the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the point(s) of interest on the
plane. <code>x</code> and <code>y</code> can be scalars or vectors of scalars.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The output <code>vector</code>
which constitutes the <code class="reqn">z</code>-coordinates of the point(s) of interest on the plane.
If <code>x</code> and <code>y</code> are scalars, <code>z</code> will be a scalar and
if <code>x</code> and <code>y</code> are vectors of scalars,
then <code>z</code> needs to be a <code>matrix</code> of scalars,
containing the <code class="reqn">z</code>-coordinate for each pair of <code>x</code> and <code>y</code> values.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>Coefficients of the plane (in the <code class="reqn">z = A x+B y+C</code> form).</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the plane in long form</p>
</td></tr>
<tr><td><code>equation2</code></td>
<td>
<p>Equation of the plane in short form,
to be inserted on the plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Plane">Plane</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Q&lt;-c(1,10,3); R&lt;-c(1,1,3); S&lt;-c(3,9,12); P&lt;-c(1,1,0)

pts&lt;-rbind(Q,R,S,P)
paraplane(P,Q,R,S,.1,.2)

xr&lt;-range(pts[,1]); yr&lt;-range(pts[,2])
xf&lt;-(xr[2]-xr[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
yf&lt;-(yr[2]-yr[1])*.25
#how far to go at the lower and upper ends in the y-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100
y&lt;-seq(yr[1]-yf,yr[2]+yf,l=5)  #try also l=10, 20, or 100

plP2QRS&lt;-paraplane(P,Q,R,S,x,y)
plP2QRS
summary(plP2QRS)
plot(plP2QRS,theta = 225, phi = 30, expand = 0.7, facets = FALSE, scale = TRUE)

paraplane(P,Q,R,Q+R,.1,.2)

z.grid&lt;-plP2QRS$z

plQRS&lt;-Plane(Q,R,S,x,y)
plQRS
pl.grid&lt;-plQRS$z

zr&lt;-max(z.grid)-min(z.grid)
Pts&lt;-rbind(Q,R,S,P)+rbind(c(0,0,zr*.1),c(0,0,zr*.1),
c(0,0,zr*.1),c(0,0,zr*.1))
Mn.pts&lt;-apply(Pts[1:3,],2,mean)

plot3D::persp3D(z = pl.grid, x = x, y = y, theta =225, phi = 30,
ticktype = "detailed",
main="Plane Crossing Points Q, R, S\n and Plane Passing P Parallel to it")
#plane spanned by points Q, R, S
plot3D::persp3D(z = z.grid, x = x, y = y,add=TRUE)
#plane parallel to the original plane and passing thru point \code{P}

plot3D::persp3D(z = z.grid, x = x, y = y, theta =225, phi = 30,
ticktype = "detailed",
main="Plane Crossing Point P \n and Parallel to the Plane Crossing Q, R, S")
#plane spanned by points Q, R, S
#add the defining points
plot3D::points3D(Pts[,1],Pts[,2],Pts[,3], add=TRUE)
plot3D::text3D(Pts[,1],Pts[,2],Pts[,3], c("Q","R","S","P"),add=TRUE)
plot3D::text3D(Mn.pts[1],Mn.pts[2],Mn.pts[3],plP2QRS$equation,add=TRUE)
plot3D::polygon3D(Pts[1:3,1],Pts[1:3,2],Pts[1:3,3], add=TRUE)


</code></pre>

<hr>
<h2 id='Pdom.num2PE1Dasy'>The asymptotic probability of domination number <code class="reqn">= 2</code> for Proportional Edge Proximity Catch Digraphs (PE-PCDs)
- middle interval case</h2><span id='topic+Pdom.num2PE1Dasy'></span>

<h3>Description</h3>

<p>Returns the asymptotic <code class="reqn">P(</code>domination number<code class="reqn">\le 1)</code> for PE-PCD whose vertices are a uniform
data set in a finite interval <code class="reqn">(a,b)</code>.
</p>
<p>The PE proximity region <code class="reqn">N_{PE}(x,r,c)</code> is defined with respect to <code class="reqn">(a,b)</code> with centrality parameter <code>c</code>
in <code class="reqn">(0,1)</code> and expansion parameter <code class="reqn">r=1/\max(c,1-c)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pdom.num2PE1Dasy(c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pdom.num2PE1Dasy_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>.
For the interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The asymptotic <code class="reqn">P(</code>domination number<code class="reqn">\le 1)</code> for PE-PCD whose vertices are a uniform data set in a finite
interval <code class="reqn">(a,b)</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pdom.num2PE1D">Pdom.num2PE1D</a></code> and <code><a href="#topic+Pdom.num2PEtri">Pdom.num2PEtri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.5

Pdom.num2PE1Dasy(c)

Pdom.num2PE1Dasy(c=1/1.5)
Pdom.num2PE1D(r=1.5,c=1/1.5,n=10)
Pdom.num2PE1D(r=1.5,c=1/1.5,n=100)

</code></pre>

<hr>
<h2 id='Pdom.num2PEtri'>Asymptotic probability that domination number of
Proportional Edge Proximity Catch Digraphs (PE-PCDs) equals 2
where vertices of the digraph are uniform points in a triangle</h2><span id='topic+Pdom.num2PEtri'></span>

<h3>Description</h3>

<p>Returns <code class="reqn">P(</code>domination number<code class="reqn">=2)</code>
for PE-PCD for uniform data in a triangle,
when the sample size <code class="reqn">n</code> goes to
infinity (i.e., asymptotic probability of domination number <code class="reqn">= 2</code>).
</p>
<p>PE proximity regions are constructed
with respect to the triangle
with the expansion parameter <code class="reqn">r \ge 1</code> and
<code class="reqn">M</code>-vertex regions where <code class="reqn">M</code> is the vertex
that renders the asymptotic distribution of the domination
number non-degenerate for the given value of <code>r</code> in <code class="reqn">(1,1.5]</code>.
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pdom.num2PEtri(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pdom.num2PEtri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be in <code class="reqn">(1,1.5]</code> to attain non-degenerate asymptotic distribution
for the domination number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">P(</code>domination number<code class="reqn">=2)</code>
for PE-PCD for uniform data on an triangle as the sample size <code class="reqn">n</code>
goes to infinity
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pdom.num2PE1D">Pdom.num2PE1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Pdom.num2PEtri(r=1.5)
Pdom.num2PEtri(r=1.4999999999)

Pdom.num2PEtri(r=1.5) / Pdom.num2PEtri(r=1.4999999999)

rseq&lt;-seq(1.01,1.49999999999,l=20)  #try also l=100
lrseq&lt;-length(rseq)

pg2&lt;-vector()
for (i in 1:lrseq)
{
  pg2&lt;-c(pg2,Pdom.num2PEtri(rseq[i]))
}

plot(rseq, pg2,type="l",xlab="r",
ylab=expression(paste("P(", gamma, "=2)")),
     lty=1,xlim=range(rseq)+c(0,.01),ylim=c(0,1))
points(rbind(c(1.50,Pdom.num2PEtri(1.50))),pch=".",cex=3)


</code></pre>

<hr>
<h2 id='PEarc.dens.test'>A test of segregation/association
based on arc density of Proportional Edge Proximity Catch Digraph
(PE-PCD) for 2D data</h2><span id='topic+PEarc.dens.test'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function
which performs a hypothesis test of complete spatial
randomness (CSR) or uniformity of <code>Xp</code> points
in the convex hull of <code>Yp</code> points against the alternatives
of segregation (where <code>Xp</code> points cluster
away from <code>Yp</code> points) and association
(where <code>Xp</code> points cluster around
<code>Yp</code> points) based on the normal approximation
of the arc density of the PE-PCD for uniform 2D data.
</p>
<p>The function yields the test statistic,
<code class="reqn">p</code>-value for the corresponding <code>alternative</code>,
the confidence interval,
estimate and null value for the parameter of interest
(which is the arc density),
and method and name of the data set used.
</p>
<p>Under the null hypothesis of uniformity of <code>Xp</code> points
in the convex hull of <code>Yp</code> points, arc density
of PE-PCD whose vertices are <code>Xp</code> points equals
to its expected value under the uniform distribution and
<code>alternative</code> could be two-sided, or left-sided
(i.e., data is accumulated around the <code>Yp</code> points, or association)
or right-sided (i.e., data is accumulated
around the centers of the triangles,
or segregation).
</p>
<p>PE proximity region is constructed
with the expansion parameter <code class="reqn">r \ge 1</code> and <code class="reqn">CM</code>-vertex regions
(i.e., the test is not available for a general center <code class="reqn">M</code>
at this version of the function).
</p>
<p>**Caveat:** This test is currently a conditional test,
where <code>Xp</code> points are assumed to be random,
while <code>Yp</code> points are
assumed to be fixed (i.e., the test is conditional on <code>Yp</code> points).
Furthermore,
the test is a large sample test when <code>Xp</code> points
are substantially larger than <code>Yp</code> points,
say at least 5 times more.
This test is more appropriate when supports of <code>Xp</code>
and <code>Yp</code> have a substantial overlap.
Currently, the <code>Xp</code> points
outside the convex hull of <code>Yp</code> points
are handled with a convex hull correction factor, <code>ch.cor</code>,
which is derived under the assumption of
uniformity of <code>Xp</code> and <code>Yp</code> points in the study window,
(see the description below and the function code.)
However, in the special case of no <code>Xp</code> points
in the convex hull of <code>Yp</code> points,
arc density is taken to be 1,
as this is clearly a case of segregation.
Removing the conditioning and extending it to
the case of non-concurring supports is
an ongoing topic of research of the author of the package.
</p>
<p><code>ch.cor</code> is for convex hull correction
(default is <code>"no convex hull correction"</code>, i.e., <code>ch.cor=FALSE</code>)
which is recommended
when both <code>Xp</code> and <code>Yp</code> have the same rectangular support.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006))
for more on the test based on the arc density of PE-PCDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEarc.dens.test(
  Xp,
  Yp,
  r,
  ch.cor = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEarc.dens.test_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test_+3A_ch.cor">ch.cor</code></td>
<td>
<p>A logical argument for convex hull correction,
default <code>ch.cor=FALSE</code>,
recommended when both <code>Xp</code> and <code>Yp</code>
have the same rectangular support.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test,
one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval,
default is <code>0.95</code>, for the arc density of PE-PCD based on
the 2D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test
for the corresponding <code>alternative</code></p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the arc density
at the given confidence level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., arc density</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter,
i.e., the null arc density, which is usually the
mean arc density under uniform distribution.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test,
one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CSarc.dens.test">CSarc.dens.test</a></code> and <code><a href="#topic+PEarc.dens.test1D">PEarc.dens.test1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-100; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx),runif(nx))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

plotDelaunay.tri(Xp,Yp,xlab="",ylab="")

PEarc.dens.test(Xp,Yp,r=1.25)
PEarc.dens.test(Xp,Yp,r=1.25,ch=TRUE)
#since Y points are not uniform, convex hull correction is invalid here


</code></pre>

<hr>
<h2 id='PEarc.dens.test.int'>A test of uniformity of 1D data in a given interval based on Proportional Edge Proximity Catch Digraph
(PE-PCD)</h2><span id='topic+PEarc.dens.test.int'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code>.
This is an <code>"htest"</code> (i.e., hypothesis test) function which performs a hypothesis test of uniformity of 1D data
in one interval based on the normal approximation of the arc density of the PE-PCD with expansion parameter <code class="reqn">r \ge 1</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding <code>alternative</code>, the confidence interval, estimate and null value for the parameter of interest
(which is the arc density), and method and name of the data set used.
</p>
<p>The null hypothesis is that data is
uniform in a finite interval (i.e., arc density of PE-PCD equals to its expected value under uniform
distribution) and <code>alternative</code> could be two-sided, or left-sided (i.e., data is accumulated around the end
points) or right-sided (i.e., data is accumulated around the mid point or center <code class="reqn">M_c</code>).
</p>
<p>See also (Ceyhan (2012, 2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEarc.dens.test.int(
  Xp,
  int,
  r,
  c = 0.5,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEarc.dens.test.int_+3A_xp">Xp</code></td>
<td>
<p>A set or <code>vector</code> of 1D points which constitute the vertices of PE-PCD.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test.int_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test.int_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval, default is <code>0.95</code>, for the arc density of PE-PCD based on
the 1D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding <code>alternative</code></p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the arc density at the given confidence level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., arc density</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter, i.e., the null arc density, which is usually the
mean arc density under uniform distribution.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.<br /><br /> Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CSarc.dens.test.int">CSarc.dens.test.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-100  #try also n&lt;-20, 1000
Xp&lt;-runif(n,a,b)

PEarc.dens.test.int(Xp,int,r,c)
PEarc.dens.test.int(Xp,int,r,c,alt="g")
PEarc.dens.test.int(Xp,int,r,c,alt="l")


</code></pre>

<hr>
<h2 id='PEarc.dens.test1D'>A test of segregation/association based on arc density of
Proportional Edge Proximity Catch Digraph
(PE-PCD) for 1D data</h2><span id='topic+PEarc.dens.test1D'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function
which performs a hypothesis test of complete spatial
randomness (CSR) or uniformity of <code>Xp</code> points in the range
(i.e., range) of <code>Yp</code> points against the alternatives
of segregation (where <code>Xp</code> points cluster away from <code>Yp</code> points)
and association (where <code>Xp</code> points cluster around
<code>Yp</code> points) based on the normal approximation of
the arc density of the PE-PCD for uniform 1D data.
</p>
<p>The function yields the test statistic,
<code class="reqn">p</code>-value for the corresponding <code>alternative</code>,
the confidence interval, estimate and null value
for the parameter of interest (which is the arc density),
and method and name of the data set used.
</p>
<p>Under the null hypothesis of uniformity of <code>Xp</code> points
in the range of <code>Yp</code> points, arc density
of PE-PCD whose vertices are <code>Xp</code> points equals
to its expected value under the uniform distribution and
<code>alternative</code> could be two-sided, or left-sided
(i.e., data is accumulated around the <code>Yp</code> points, or association)
or right-sided (i.e., data is accumulated around the centers of the intervals,
or segregation).
</p>
<p>PE proximity region is constructed with the expansion parameter <code class="reqn">r \ge 1</code>
and centrality parameter <code>c</code> which yields
<code class="reqn">M</code>-vertex regions.
More precisely, for a middle interval <code class="reqn">(y_{(i)},y_{(i+1)})</code>, the center is
<code class="reqn">M=y_{(i)}+c(y_{(i+1)}-y_{(i)})</code> for the centrality parameter <code class="reqn">c \in (0,1)</code>.
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>**Caveat:** This test is currently a conditional test,
where <code>Xp</code> points are assumed to be random, while <code>Yp</code> points are
assumed to be fixed (i.e., the test is conditional on <code>Yp</code> points).
Furthermore, the test is a large sample test
when <code>Xp</code> points are substantially larger than <code>Yp</code> points,
say at least 5 times more.
This test is more appropriate when supports of <code>Xp</code> and <code>Yp</code>
have a substantial overlap.
Currently, the <code>Xp</code> points outside the range of <code>Yp</code> points
are handled with a range correction (or
end-interval correction) factor (see the description below and the function code.)
However, in the special case of no <code>Xp</code> points in the range of <code>Yp</code> points,
arc density is taken to be 1,
as this is clearly a case of segregation.
Removing the conditioning and extending it to the case of non-concurring supports is
an ongoing line of research of the author of the package.
</p>
<p><code>end.int.cor</code> is for end-interval correction,
(default is &quot;no end-interval correction&quot;, i.e., <code>end.int.cor=FALSE</code>),
recommended when both <code>Xp</code> and <code>Yp</code> have the same interval support.
</p>
<p>See also (Ceyhan (2012)) for
more on the uniformity test based on the arc
density of PE-PCDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEarc.dens.test1D(
  Xp,
  Yp,
  r,
  c = 0.5,
  support.int = NULL,
  end.int.cor = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEarc.dens.test1D_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test1D_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points which constitute the end points of the partition intervals.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test1D_+3A_c">c</code></td>
<td>
<p>A positive real number which serves as the centrality parameter in PE proximity region;
must be in <code class="reqn">(0,1)</code> (default <code>c=.5</code>).</p>
</td></tr>
<tr><td><code id="PEarc.dens.test1D_+3A_support.int">support.int</code></td>
<td>
<p>Support interval <code class="reqn">(a,b)</code> with <code class="reqn">a&lt;b</code>.
Uniformity of <code>Xp</code> points in this interval is tested. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test1D_+3A_end.int.cor">end.int.cor</code></td>
<td>
<p>A logical argument for end-interval correction, default is <code>FALSE</code>,
recommended when both <code>Xp</code> and <code>Yp</code> have the same interval support.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test1D_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.test1D_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval, default is <code>0.95</code>, for the arc density
PE-PCD whose vertices are the 1D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding <code>alternative</code>.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the arc density at the given confidence level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., arc density</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter, i.e., the null arc density, which is usually the
mean arc density under uniform distribution.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEarc.dens.test">PEarc.dens.test</a></code>, <code><a href="#topic+PEdom.num.binom.test1D">PEdom.num.binom.test1D</a></code>, and <code><a href="#topic+PEarc.dens.test.int">PEarc.dens.test.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int=c(a,b)

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

PEarc.dens.test1D(Xp,Yp,r,c,int)
#try also PEarc.dens.test1D(Xp,Yp,r,c,int,alt="l") and PEarc.dens.test1D(Xp,Yp,r,c,int,alt="g")

PEarc.dens.test1D(Xp,Yp,r,c,int,end.int.cor = TRUE)


</code></pre>

<hr>
<h2 id='PEarc.dens.tetra'>Arc density of Proportional Edge Proximity Catch Digraphs (PE-PCDs) - one tetrahedron case</h2><span id='topic+PEarc.dens.tetra'></span>

<h3>Description</h3>

<p>Returns the arc density of PE-PCD whose vertex set is the given 2D numerical data set, <code>Xp</code>,
(some of its members are) in the tetrahedron <code>th</code>.
</p>
<p>PE proximity region is constructed with respect to the tetrahedron <code>th</code> and
vertex regions are based on the center <code>M</code> which is circumcenter (<code>"CC"</code>) or
center of mass (<code>"CM"</code>) of <code>th</code> with default=<code>"CM"</code>.
For the number of arcs, loops are not
allowed so arcs are only possible for points inside the tetrahedron <code>th</code> for this function.
</p>
<p><code>th.cor</code> is a logical argument for tetrahedron correction (default is <code>TRUE</code>), if <code>TRUE</code>, only the points
inside the tetrahedron are considered (i.e., digraph induced by these vertices are considered) in computing
the arc density, otherwise all points are considered (for the number of vertices in the denominator of arc
density).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEarc.dens.tetra(Xp, th, r, M = "CM", th.cor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEarc.dens.tetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEarc.dens.tetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="PEarc.dens.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.tetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.tetra_+3A_th.cor">th.cor</code></td>
<td>
<p>A logical argument for computing the arc density for only the points inside the tetrahedron,
<code>th</code>. (default is <code>th.cor=FALSE</code>), i.e., if <code>th.cor=TRUE</code> only the induced digraph
with the vertices inside <code>th</code> are considered in the computation of arc density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Arc density of PE-PCD whose vertices are the 2D numerical data set, <code>Xp</code>;
PE proximity regions are defined with respect to the tetrahedron <code>th</code> and <code>M</code>-vertex regions
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEarc.dens.tri">PEarc.dens.tri</a></code> and <code><a href="#topic+num.arcsPEtetra">num.arcsPEtetra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tetra(n,tetra)$g

M&lt;-"CM"  #try also M&lt;-"CC"
r&lt;-1.5

num.arcsPEtetra(Xp,tetra,r,M)
PEarc.dens.tetra(Xp,tetra,r,M)
PEarc.dens.tetra(Xp,tetra,r,M,th.cor = FALSE)


</code></pre>

<hr>
<h2 id='PEarc.dens.tri'>Arc density of Proportional Edge Proximity Catch Digraphs
(PE-PCDs) - one triangle case</h2><span id='topic+PEarc.dens.tri'></span>

<h3>Description</h3>

<p>Returns the arc density of PE-PCD
whose vertex set is the given 2D numerical data set, <code>Xp</code>,
(some of its members are) in the triangle <code>tri</code>.
</p>
<p>PE proximity regions is defined with respect to <code>tri</code> with
expansion parameter <code class="reqn">r \ge 1</code> and vertex regions are
based on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code> or based on
circumcenter of <code>tri</code>; default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.
The function also provides arc density standardized
by the mean and asymptotic variance of the arc density
of PE-PCD for uniform data in the triangle <code>tri</code>
only when <code>M</code> is the center of mass.
For the number of arcs, loops are not allowed.
</p>
<p><code>in.tri.only</code> is a logical argument (default is <code>FALSE</code>) for considering only the points
inside the triangle or all the points as the vertices of the digraph.
if <code>in.tri.only=TRUE</code>, arc density is computed only for
the points inside the triangle (i.e., arc density of the subdigraph
induced by the vertices in the triangle is computed),
otherwise arc density of the entire digraph (i.e., digraph with all the vertices) is computed.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEarc.dens.tri(Xp, tri, r, M = c(1, 1, 1), in.tri.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEarc.dens.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEarc.dens.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="PEarc.dens.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="PEarc.dens.tri_+3A_in.tri.only">in.tri.only</code></td>
<td>
<p>A logical argument (default is <code>in.tri.only=FALSE</code>)
for computing the arc density for only the points inside the triangle, <code>tri</code>.
That is,
if <code>in.tri.only=TRUE</code> arc density of the induced subdigraph with the vertices
inside <code>tri</code> is computed, otherwise
otherwise arc density of the entire digraph (i.e., digraph with all the vertices) is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>arc.dens</code></td>
<td>
<p>Arc density of PE-PCD
whose vertices are the 2D numerical data set, <code>Xp</code>;
PE proximity regions are defined
with respect to the triangle <code>tri</code> and <code>M</code>-vertex regions</p>
</td></tr>
<tr><td><code>std.arc.dens</code></td>
<td>
<p>Arc density standardized
by the mean and asymptotic variance of the arc
density of PE-PCD for uniform data in the triangle <code>tri</code>.
This will only be returned, if <code>M</code> is the center of mass.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ASarc.dens.tri">ASarc.dens.tri</a></code>, <code><a href="#topic+CSarc.dens.tri">CSarc.dens.tri</a></code>,
and <code><a href="#topic+num.arcsPEtri">num.arcsPEtri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

num.arcsPEtri(Xp,Tr,r=1.5,M)
PEarc.dens.tri(Xp,Tr,r=1.5,M)
PEarc.dens.tri(Xp,Tr,r=1.5,M,in.tri.only = TRUE)


</code></pre>

<hr>
<h2 id='PEdom.num'>The domination number of Proportional Edge Proximity Catch Digraph
(PE-PCD) - multiple triangle case</h2><span id='topic+PEdom.num'></span>

<h3>Description</h3>

<p>Returns the domination number,
indices of a minimum dominating set of PE-PCD whose vertices are the data
points in <code>Xp</code> in the multiple triangle case
and domination numbers for the Delaunay triangles
based on <code>Yp</code> points.
</p>
<p>PE proximity regions are defined
with respect to the Delaunay triangles based on <code>Yp</code> points
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions in each triangle are
based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates
in the interior of each Delaunay triangle or based on
circumcenter of each Delaunay triangle (default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of the
triangle). Each Delaunay triangle is first converted to
an (nonscaled) basic triangle so that <code>M</code> will be the
same type of center for each Delaunay triangle
(this conversion is not necessary when <code>M</code> is <code class="reqn">CM</code>).
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
Loops are allowed for the domination number.
</p>
<p>See (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011, 2012))
for more on the domination number of PE-PCDs.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and
the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num(Xp, Yp, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEdom.num_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="PEdom.num_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates
which serves as a center in the interior of each Delaunay
triangle or circumcenter of each Delaunay triangle
(for this, argument should be set as <code>M="CC"</code>),
default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of each triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>dom.num</code></td>
<td>
<p>Domination number of the PE-PCD
whose vertices are <code>Xp</code> points.
PE proximity regions are constructed
with respect to the Delaunay triangles
based on the <code>Yp</code> points with expansion parameter <code class="reqn">r \ge 1</code>.</p>
</td></tr>
</table>
<p>#</p>
<table>
<tr><td><code>mds</code></td>
<td>
<p>A minimum dominating set of the PE-PCD
whose vertices are <code>Xp</code> points</p>
</td></tr>
<tr><td><code>ind.mds</code></td>
<td>
<p>The vector of data indices of the minimum dominating set
of the PE-PCD whose vertices are <code>Xp</code> points.</p>
</td></tr>
<tr><td><code>tri.dom.nums</code></td>
<td>
<p>The vector of domination numbers
of the PE-PCD components
for the Delaunay triangles.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.tri">PEdom.num.tri</a></code>, <code><a href="#topic+PEdom.num.tetra">PEdom.num.tetra</a></code>,
<code><a href="#topic+dom.num.exact">dom.num.exact</a></code>, and <code><a href="#topic+dom.num.greedy">dom.num.greedy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)
r&lt;-1.5  #try also r&lt;-2
PEdom.num(Xp,Yp,r,M)


</code></pre>

<hr>
<h2 id='PEdom.num.binom.test'>A test of segregation/association based on domination number of
Proportional Edge Proximity Catch Digraph (PE-PCD) for 2D data -
Binomial Approximation</h2><span id='topic+PEdom.num.binom.test'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function
which performs a hypothesis test of complete spatial
randomness (CSR) or uniformity of <code>Xp</code> points
in the convex hull of <code>Yp</code> points against the alternatives
of segregation (where <code>Xp</code> points cluster away from <code>Yp</code> points
i.e., cluster around the centers of the Delaunay triangles)
and association (where <code>Xp</code> points cluster around <code>Yp</code> points)
based on the (asymptotic) binomial distribution of the
domination number of PE-PCD for uniform 2D data
in the convex hull of <code>Yp</code> points.
</p>
<p>The function yields the test statistic,
<code class="reqn">p</code>-value for the corresponding <code>alternative</code>,
the confidence interval,
estimate and null value for the parameter of interest
(which is <code class="reqn">Pr(</code>domination number<code class="reqn">\le 2)</code>),
and method and name of the data set used.
</p>
<p>Under the null hypothesis of uniformity of <code>Xp</code> points
in the convex hull of <code>Yp</code> points, probability of success
(i.e., <code class="reqn">Pr(</code>domination number<code class="reqn">\le 2)</code>) equals
to its expected value under the uniform distribution) and
<code>alternative</code> could be two-sided, or right-sided
(i.e., data is accumulated
around the <code>Yp</code> points, or association)
or left-sided (i.e., data is accumulated
around the centers of the triangles, or segregation).
</p>
<p>PE proximity region is constructed
with the expansion parameter <code class="reqn">r \ge 1</code> and <code class="reqn">M</code>-vertex regions
where <code class="reqn">M</code> is a center
that yields non-degenerate asymptotic distribution
of the domination number.
</p>
<p>The test statistic is based on the binomial distribution,
when success is defined as domination number being less than
or equal to 2 in the one triangle case
(i.e., number of failures is equal
to number of times restricted domination number = 3
in the triangles).
That is, the test statistic is based on the domination number
for <code>Xp</code> points inside convex hull of <code>Yp</code> points
for the PE-PCD and default convex hull correction, <code>ch.cor</code>,
is <code>FALSE</code> where <code>M</code> is the center
that yields nondegenerate asymptotic distribution
for the domination number.
For this approximation to work,
number of <code>Xp</code> points must be at least 7 times more than
number of <code>Yp</code> points.
</p>
<p>PE proximity region is constructed
with the expansion parameter <code class="reqn">r \ge 1</code> and <code class="reqn">CM</code>-vertex regions
(i.e., the test is not available for a general center <code class="reqn">M</code>
at this version of the function).
</p>
<p>**Caveat:** This test is currently a conditional test,
where <code>Xp</code> points are assumed to be random,
while <code>Yp</code> points are
assumed to be fixed (i.e., the test is conditional on <code>Yp</code> points).
Furthermore, the test is a large sample test
when <code>Xp</code> points are substantially larger than <code>Yp</code> points,
say at least 7 times more.
This test is more appropriate
when supports of <code>Xp</code> and <code>Yp</code> have a substantial overlap.
Currently, the <code>Xp</code> points
outside the convex hull of <code>Yp</code> points
are handled with a convex hull correction factor
(see the description below and the function code.)
Removing the conditioning
and extending it to the case of non-concurring supports is
an ongoing topic of research of the author of the package.
</p>
<p>See also (Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num.binom.test(
  Xp,
  Yp,
  r,
  ch.cor = FALSE,
  ndt = NULL,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num.binom.test_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be in <code class="reqn">(1,1.5]</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test_+3A_ch.cor">ch.cor</code></td>
<td>
<p>A logical argument for convex hull correction,
default <code>ch.cor=FALSE</code>,
recommended when both <code>Xp</code> and <code>Yp</code>
have the same rectangular support.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test_+3A_ndt">ndt</code></td>
<td>
<p>Number of Delaunay triangles based on <code>Yp</code> points,
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test,
one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval,
default is <code>0.95</code>, for the probability of success
(i.e., <code class="reqn">Pr(</code>domination number<code class="reqn">=3)</code> for PE-PCD
whose vertices are the 2D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test
for the corresponding <code>alternative</code></p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval
for <code class="reqn">Pr(</code>Domination Number<code class="reqn">\le 2)</code>
at the given level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>A <code>vector</code> with two entries:
first is is the estimate of the parameter, i.e.,
<code class="reqn">Pr(</code>Domination Number<code class="reqn">=3)</code> and second is the domination number</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter,
i.e., the null value for <code class="reqn">Pr(</code>Domination Number<code class="reqn">\le 2)</code></p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test,
one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.norm.test">PEdom.num.norm.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-100; ny&lt;-5 #try also nx&lt;-1000; ny&lt;-10
r&lt;-1.4  #try also r&lt;-1.5

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

plotDelaunay.tri(Xp,Yp,xlab="",ylab="")
PEdom.num.binom.test(Xp,Yp,r) #try also #PEdom.num.binom.test(Xp,Yp,r,alt="l") and
# PEdom.num.binom.test(Xp,Yp,r,alt="g")
PEdom.num.binom.test(Xp,Yp,r,ch=TRUE)

#or try
ndt&lt;-num.delaunay.tri(Yp)
PEdom.num.binom.test(Xp,Yp,r,ndt=ndt)
#values might differ due to the random of choice of the three centers M1,M2,M3
#for the non-degenerate asymptotic distribution of the domination number


</code></pre>

<hr>
<h2 id='PEdom.num.binom.test1D'>A test of segregation/association based on domination number of
Proportional Edge Proximity Catch Digraph
(PE-PCD) for 1D data - Binomial Approximation</h2><span id='topic+PEdom.num.binom.test1D'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function
which performs a hypothesis test of complete spatial
randomness (CSR) or uniformity of <code>Xp</code> points
within the partition intervals based on <code>Yp</code> points (both residing in the
support interval <code class="reqn">(a,b)</code>).
The test is for testing the spatial interaction between <code>Xp</code> and <code>Yp</code> points.
</p>
<p>The null hypothesis is uniformity of <code>Xp</code> points on <code class="reqn">(y_{\min},y_{\max})</code> (by default)
where <code class="reqn">y_{\min}</code> and <code class="reqn">y_{\max}</code> are minimum and maximum of <code>Yp</code> points, respectively.
<code>Yp</code> determines the end points of the intervals
(i.e., partition the real line via its spacings called intervalization)
where end points are the order statistics of <code>Yp</code> points.
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>The alternatives are segregation (where <code>Xp</code> points cluster away from <code>Yp</code> points
i.e., cluster around the centers of the
partition intervals) and association (where <code>Xp</code>
points cluster around <code>Yp</code> points).
The test is based on the (asymptotic) binomial
distribution of the domination number of PE-PCD
for uniform 1D data in the partition intervals based on <code>Yp</code> points.
</p>
<p>The test by default is restricted to the range of <code>Yp</code> points,
and so ignores <code>Xp</code> points outside this range.
However, a correction for the <code>Xp</code> points outside
the range of <code>Yp</code> points is available by setting
<code>end.int.cor=TRUE</code>,
which is recommended when both <code>Xp</code> and <code>Yp</code>
have the same interval support.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value for the corresponding
alternative, the confidence interval,
estimate and null value for the parameter of interest (which is
<code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code>),
and method and name of the data set used.
</p>
<p>Under the null hypothesis of uniformity of <code>Xp</code> points in the intervals
based on <code>Yp</code> points, probability of success
(i.e., <code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code>) equals to its expected value) and
<code>alternative</code> could be two-sided, or left-sided
(i.e., data is accumulated around the <code>Yp</code> points, or association)
or right-sided (i.e., data is accumulated around
the centers of the partition intervals, or segregation).
</p>
<p>PE proximity region is constructed with the expansion parameter <code class="reqn">r \ge 1</code>
and centrality parameter <code>c</code> which yields
<code class="reqn">M</code>-vertex regions. More precisely,
for a middle interval <code class="reqn">(y_{(i)},y_{(i+1)})</code>, the center is
<code class="reqn">M=y_{(i)}+c(y_{(i+1)}-y_{(i)})</code> for the centrality parameter <code>c</code>.
For a given <code class="reqn">c \in (0,1)</code>, the
expansion parameter <code class="reqn">r</code> is taken to be <code class="reqn">1/\max(c,1-c)</code>
which yields non-degenerate asymptotic distribution of the
domination number.
</p>
<p>The test statistic is based on the binomial distribution,
when success is defined as domination number being less than or
equal to 1 in the one interval case
(i.e., number of successes is equal to
domination number <code class="reqn">\le 1</code> in the partition intervals).
That is, the test statistic is based on the domination number
for <code>Xp</code> points inside range of <code>Yp</code> points
(the domination numbers are summed over the <code class="reqn">|Yp|-1</code> middle intervals)
for the PE-PCD and default end-interval correction, <code>end.int.cor</code>, is <code>FALSE</code>
and the center <code class="reqn">Mc</code> is chosen so that asymptotic distribution
for the domination number is nondegenerate.
For this test to work, <code>Xp</code> must be at least 10 times more than <code>Yp</code> points
(or <code>Xp</code> must be at least 5 or more per partition interval).
Probability of success is the exact probability of success for the binomial distribution.
</p>
<p>**Caveat:** This test is currently a conditional test,
where <code>Xp</code> points are assumed to be random, while <code>Yp</code> points are
assumed to be fixed (i.e., the test is conditional on <code>Yp</code> points).
This test is more appropriate when supports of <code>Xp</code>
and <code>Yp</code> have a substantial overlap.
Currently, the <code>Xp</code> points outside the range of <code>Yp</code> points
are handled with an end-interval correction factor
(see the description below and the function code.)
Removing the conditioning and extending it to the case of non-concurring supports is
an ongoing line of research of the author of the package.
</p>
<p>See also (Ceyhan (2020))
for more on the uniformity test based on the arc
density of PE-PCDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num.binom.test1D(
  Xp,
  Yp,
  c = 0.5,
  support.int = NULL,
  end.int.cor = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num.binom.test1D_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1D_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points which constitute the end points of the partition intervals.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1D_+3A_c">c</code></td>
<td>
<p>A positive real number
which serves as the centrality parameter in PE proximity region;
must be in <code class="reqn">(0,1)</code> (default <code>c=.5</code>).</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1D_+3A_support.int">support.int</code></td>
<td>
<p>Support interval <code class="reqn">(a,b)</code> with <code class="reqn">a&lt;b</code>.
Uniformity of <code>Xp</code> points in this interval is tested. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1D_+3A_end.int.cor">end.int.cor</code></td>
<td>
<p>A logical argument for end-interval correction, default is <code>FALSE</code>,
recommended when both <code>Xp</code> and <code>Yp</code> have the same interval support.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1D_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test,
one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1D_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval, default is <code>0.95</code>,
for the probability of success
(i.e., <code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code> for PE-PCD
whose vertices are the 1D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding <code>alternative</code>.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for <code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code> at the given level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>A <code>vector</code> with two entries: first is is the estimate of the parameter, i.e.,
<code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code> and second is the domination number</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter, i.e., the null value for <code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code></p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2020).
&ldquo;Domination Number of an Interval Catch Digraph Family and Its Use for Testing Uniformity.&rdquo;
<em>Statistics</em>, <b>54(2)</b>, 310-339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.binom.test">PEdom.num.binom.test</a></code> and <code><a href="#topic+PEdom.num1D">PEdom.num1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a&lt;-0; b&lt;-10; supp&lt;-c(a,b)
c&lt;-.4

r&lt;-1/max(c,1-c)

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)
PEdom.num.binom.test1D(Xp,Yp,c,supp)
PEdom.num.binom.test1D(Xp,Yp,c,supp,alt="l")
PEdom.num.binom.test1D(Xp,Yp,c,supp,alt="g")
PEdom.num.binom.test1D(Xp,Yp,c,supp,end=TRUE)


</code></pre>

<hr>
<h2 id='PEdom.num.binom.test1Dint'>A test of uniformity for 1D data based on domination number of Proportional Edge Proximity Catch Digraph
(PE-PCD) - Binomial Approximation</h2><span id='topic+PEdom.num.binom.test1Dint'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function which performs a hypothesis test of
uniformity of <code>Xp</code> points in the support interval <code class="reqn">(a,b)</code>).
</p>
<p>The support interval <code class="reqn">(a,b)</code> is partitioned as <code>(b-a)*(0:nint)/nint</code>
where <code>nint=round(sqrt(nx),0)</code> and <code>nx</code> is number of <code>Xp</code> points, and the test is for testing the uniformity of <code>Xp</code>
points in the interval <code class="reqn">(a,b)</code>.
</p>
<p>The null hypothesis is uniformity of <code>Xp</code> points on <code class="reqn">(a,b)</code>.
The alternative is deviation of distribution of <code>Xp</code> points from uniformity. The test is based on the (asymptotic) binomial
distribution of the domination number of PE-PCD for uniform 1D data in the partition intervals based on partition of <code class="reqn">(a,b)</code>.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value for the corresponding
alternative, the confidence interval, estimate and null value for the parameter of interest (which is
<code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code>), and method and name of the data set used.
</p>
<p>Under the null hypothesis of uniformity of <code>Xp</code> points in the support interval, probability of success
(i.e., <code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code>) equals to its expected value) and
<code>alternative</code> could be two-sided, or left-sided (i.e., data is accumulated around the end points of the partition
intervals of the support) or right-sided (i.e., data is accumulated around the centers of the partition intervals).
</p>
<p>PE proximity region is constructed with the expansion parameter <code class="reqn">r \ge 1</code> and centrality parameter <code>c</code> which yields
<code class="reqn">M</code>-vertex regions. More precisely <code class="reqn">M_c=a+c(b-a)</code> for the centrality parameter <code>c</code> and for a given <code class="reqn">c \in (0,1)</code>, the
expansion parameter <code class="reqn">r</code> is taken to be <code class="reqn">1/\max(c,1-c)</code> which yields non-degenerate asymptotic distribution of the
domination number.
</p>
<p>The test statistic is based on the binomial distribution, when success is defined as domination number being less than
or equal to 1 in the one interval case (i.e., number of failures is equal to number of times restricted domination number = 1
in the intervals).
That is, the test statistic is based on the domination number for <code>Xp</code> points inside the partition intervals
for the PE-PCD. For this approach to work, <code>Xp</code> must be large for each partition interval,
but 5 or more per partition interval seems to work in practice.
</p>
<p>Probability of success is chosen in the following way for various parameter choices.
<code>asy.bin</code> is a logical argument for the use of asymptotic probability of success for the binomial distribution,
default is <code>asy.bin=FALSE</code>.  When <code>asy.bin=TRUE</code>, asymptotic probability of success for the binomial distribution is used.
When <code>asy.bin=FALSE</code>, the finite sample probability of success for the binomial distribution is used with number
of trials equals to expected number of <code>Xp</code> points per partition interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num.binom.test1Dint(
  Xp,
  support.int,
  c = 0.5,
  asy.bin = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num.binom.test1Dint_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1Dint_+3A_support.int">support.int</code></td>
<td>
<p>Support interval <code class="reqn">(a,b)</code> with <code class="reqn">a&lt;b</code>.
Uniformity of <code>Xp</code> points in this interval is tested.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1Dint_+3A_c">c</code></td>
<td>
<p>A positive real number which serves as the centrality parameter in PE proximity region;
must be in <code class="reqn">(0,1)</code> (default <code>c=.5</code>).</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1Dint_+3A_asy.bin">asy.bin</code></td>
<td>
<p>A logical argument for the use of asymptotic probability of success for the binomial distribution,
default <code>asy.bin=FALSE</code>. When <code>asy.bin=TRUE</code>, asymptotic probability of success for the binomial distribution is used.
When <code>asy.bin=FALSE</code>, the finite sample asymptotic probability of success for the binomial distribution is used with number
of trials equals to expected number of <code>Xp</code> points per partition interval.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1Dint_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.binom.test1Dint_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval, default is <code>0.95</code>, for the probability of success
(i.e., <code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code> for PE-PCD whose vertices are the 1D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding <code>alternative</code></p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for <code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code> at the given level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>A <code>vector</code> with two entries: first is is the estimate of the parameter, i.e.,
<code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code> and second is the domination number</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter, i.e., the null value for <code class="reqn">Pr(</code>domination number<code class="reqn">\le 1)</code></p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.binom.test">PEdom.num.binom.test</a></code>, <code><a href="#topic+PEdom.num1D">PEdom.num1D</a></code> and <code><a href="#topic+PEdom.num1Dnondeg">PEdom.num1Dnondeg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a&lt;-0; b&lt;-10; supp&lt;-c(a,b)
c&lt;-.4

r&lt;-1/max(c,1-c)

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-runif(nx,a,b)

PEdom.num.binom.test1Dint(Xp,supp,c,alt="t")
PEdom.num.binom.test1Dint(Xp,support.int = supp,c=c,alt="t")
PEdom.num.binom.test1Dint(Xp,supp,c,alt="l")
PEdom.num.binom.test1Dint(Xp,supp,c,alt="g")
PEdom.num.binom.test1Dint(Xp,supp,c,alt="t",asy.bin = TRUE)


</code></pre>

<hr>
<h2 id='PEdom.num.nondeg'>The domination number of Proportional Edge Proximity Catch Digraph
(PE-PCD) with non-degeneracy centers - multiple triangle case</h2><span id='topic+PEdom.num.nondeg'></span>

<h3>Description</h3>

<p>Returns the domination number,
indices of a minimum dominating set of PE-PCD
whose vertices are the data
points in <code>Xp</code> in the multiple triangle case
and domination numbers for the Delaunay triangles based on <code>Yp</code> points
when PE-PCD is constructed with vertex regions
based on non-degeneracy centers.
</p>
<p>PE proximity regions are defined
with respect to the Delaunay triangles based on <code>Yp</code> points
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions in each triangle are
based on the center <code class="reqn">M</code>
which is one of the 3 centers
that renders the asymptotic distribution of domination number
to be non-degenerate for a given value of <code>r</code> in <code class="reqn">(1,1.5)</code>
and <code>M</code> is center of mass for <code class="reqn">r=1.5</code>.
</p>
<p>Convex hull of <code>Yp</code> is partitioned
by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
Loops are allowed for the domination number.
</p>
<p>See (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011, 2012))
more on the domination number of PE-PCDs.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and
the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num.nondeg(Xp, Yp, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num.nondeg_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEdom.num.nondeg_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="PEdom.num.nondeg_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be in <code class="reqn">(1,1.5]</code> here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>dom.num</code></td>
<td>
<p>Domination number of the PE-PCD
whose vertices are <code>Xp</code> points. PE proximity regions are
constructed with respect to the Delaunay triangles
based on the <code>Yp</code> points with expansion parameter <code class="reqn">r in (1,1.5]</code>.</p>
</td></tr>
</table>
<p>#</p>
<table>
<tr><td><code>mds</code></td>
<td>
<p>A minimum dominating set of the PE-PCD
whose vertices are <code>Xp</code> points.</p>
</td></tr>
<tr><td><code>ind.mds</code></td>
<td>
<p>The data indices of the minimum dominating set of the PE-PCD
whose vertices are <code>Xp</code> points.</p>
</td></tr>
<tr><td><code>tri.dom.nums</code></td>
<td>
<p>Domination numbers of the PE-PCD components
for the Delaunay triangles.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.tri">PEdom.num.tri</a></code>, <code><a href="#topic+PEdom.num.tetra">PEdom.num.tetra</a></code>,
<code><a href="#topic+dom.num.exact">dom.num.exact</a></code>, and <code><a href="#topic+dom.num.greedy">dom.num.greedy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

r&lt;-1.5  #try also r&lt;-2

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

PEdom.num.nondeg(Xp,Yp,r)


</code></pre>

<hr>
<h2 id='PEdom.num.norm.test'>A test of segregation/association based on domination number of
Proportional Edge Proximity Catch Digraph (PE-PCD) for 2D data -
Normal Approximation</h2><span id='topic+PEdom.num.norm.test'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> (i.e., hypothesis test) function
which performs a hypothesis test of complete spatial
randomness (CSR) or uniformity of <code>Xp</code> points
in the convex hull of <code>Yp</code> points against the alternatives
of segregation (where <code>Xp</code> points cluster
away from <code>Yp</code> points i.e.,
cluster around the centers of the Delaunay
triangles) and association (where <code>Xp</code> points cluster
around <code>Yp</code> points) based on the normal approximation
to the binomial distribution of the domination number of PE-PCD
for uniform 2D data
in the convex hull of <code>Yp</code> points
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value
for the corresponding <code>alternative</code>,
the confidence interval, estimate and null value
for the parameter of interest
(which is <code class="reqn">Pr(</code>domination number<code class="reqn">\le 2)</code>),
and method and name of the data set used.
</p>
<p>Under the null hypothesis of uniformity of <code>Xp</code> points
in the convex hull of <code>Yp</code> points, probability of success
(i.e., <code class="reqn">Pr(</code>domination number<code class="reqn">\le 2)</code>) equals
to its expected value under the uniform distribution) and
<code>alternative</code> could be two-sided, or right-sided
(i.e., data is accumulated around the <code>Yp</code> points, or association)
or left-sided (i.e., data is accumulated
around the centers of the triangles,
or segregation).
</p>
<p>PE proximity region is constructed
with the expansion parameter <code class="reqn">r \ge 1</code>
and <code class="reqn">M</code>-vertex regions where M
is a center that yields non-degenerate asymptotic distribution of
the domination number.
</p>
<p>The test statistic is based on the normal approximation
to the binomial distribution,
when success is defined as domination number being less than
or equal to 2 in the one triangle case
(i.e., number of failures is equal to number of times
restricted domination number = 3
in the triangles).
That is, the test statistic is
based on the domination number for <code>Xp</code> points
inside convex hull of <code>Yp</code>
points for the PE-PCD and default convex hull correction, <code>ch.cor</code>,
is <code>FALSE</code>
where <code>M</code> is the center
that yields nondegenerate asymptotic distribution
for the domination number.
</p>
<p>For this approximation to work,
number of <code>Yp</code> points must be at least 5
(i.e., about 7 or more Delaunay triangles)
and number of <code>Xp</code> points must be at least 7 times more than
the number of <code>Yp</code> points.
</p>
<p>See also (Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num.norm.test(
  Xp,
  Yp,
  r,
  ch.cor = FALSE,
  ndt = NULL,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num.norm.test_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEdom.num.norm.test_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="PEdom.num.norm.test_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be in <code class="reqn">(1,1.5]</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.norm.test_+3A_ch.cor">ch.cor</code></td>
<td>
<p>A logical argument for convex hull correction,
default <code>ch.cor=FALSE</code>,
recommended when both <code>Xp</code> and <code>Yp</code>
have the same rectangular support.</p>
</td></tr>
<tr><td><code id="PEdom.num.norm.test_+3A_ndt">ndt</code></td>
<td>
<p>Number of Delaunay triangles based on <code>Yp</code> points,
default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.norm.test_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test,
one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.norm.test_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence interval,
default is <code>0.95</code>, for the domination number of
PE-PCD whose vertices are the 2D data set <code>Xp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test
for the corresponding <code>alternative</code></p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the domination number
at the given level <code>conf.level</code> and
depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>A <code>vector</code> with two entries:
first is the domination number,
and second is the estimate of the parameter, i.e.,
<code class="reqn">Pr(</code>Domination Number<code class="reqn">=3)</code></p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized value for the parameter,
i.e., the null value for expected domination number</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test,
one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.binom.test">PEdom.num.binom.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-100; ny&lt;-5 #try also nx&lt;-1000; ny&lt;-10
r&lt;-1.5  #try also r&lt;-2 or r&lt;-1.25

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

plotDelaunay.tri(Xp,Yp,xlab="",ylab="")
PEdom.num.norm.test(Xp,Yp,r) #try also PEdom.num.norm.test(Xp,Yp,r, alt="l")

PEdom.num.norm.test(Xp,Yp,1.25,ch=TRUE)

#or try
ndt&lt;-num.delaunay.tri(Yp)
PEdom.num.norm.test(Xp,Yp,r,ndt=ndt)
#values might differ due to the random of choice of the three centers M1,M2,M3
#for the non-degenerate asymptotic distribution of the domination number


</code></pre>

<hr>
<h2 id='PEdom.num.tetra'>The domination number of Proportional Edge Proximity Catch Digraph (PE-PCD) - one tetrahedron case</h2><span id='topic+PEdom.num.tetra'></span>

<h3>Description</h3>

<p>Returns the domination number of PE-PCD whose vertices are the data points in <code>Xp</code>.
</p>
<p>PE proximity region is defined with respect to the tetrahedron <code>th</code> with expansion parameter <code class="reqn">r \ge 1</code> and
vertex regions are based on the center <code>M</code> which is circumcenter (<code>"CC"</code>) or center of mass (<code>"CM"</code>) of <code>th</code>
with default=<code>"CM"</code>.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num.tetra(Xp, th, r, M = "CM")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num.tetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points which constitute the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="PEdom.num.tetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="PEdom.num.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.tetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>dom.num</code></td>
<td>
<p>Domination number of PE-PCD with vertex set = <code>Xp</code> and expansion parameter <code class="reqn">r \ge 1</code> and center <code>M</code></p>
</td></tr>
<tr><td><code>mds</code></td>
<td>
<p>A minimum dominating set of PE-PCD with vertex set = <code>Xp</code> and expansion parameter <code class="reqn">r \ge 1</code> and center <code>M</code></p>
</td></tr>
<tr><td><code>ind.mds</code></td>
<td>
<p>Indices of the minimum dominating set <code>mds</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.tri">PEdom.num.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-10  #try also n&lt;-20

Xp&lt;-runif.tetra(n,tetra)$g

M&lt;-"CM"  #try also M&lt;-"CC"
r&lt;-1.25

PEdom.num.tetra(Xp,tetra,r,M)

P1&lt;-c(.5,.5,.5)
PEdom.num.tetra(P1,tetra,r,M)


</code></pre>

<hr>
<h2 id='PEdom.num.tri'>The domination number of Proportional Edge Proximity Catch Digraph
(PE-PCD) - one triangle case</h2><span id='topic+PEdom.num.tri'></span>

<h3>Description</h3>

<p>Returns the domination number of PE-PCD
whose vertices are the data points in <code>Xp</code>.
</p>
<p>PE proximity region is defined
with respect to the triangle <code>tri</code>
with expansion parameter <code class="reqn">r \ge 1</code> and
vertex regions are constructed with center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates
in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>.
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011, 2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num.tri(Xp, tri, r, M = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the digraph.</p>
</td></tr>
<tr><td><code id="PEdom.num.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="PEdom.num.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">(1,1,1)</code>, i.e., the center of mass.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>dom.num</code></td>
<td>
<p>Domination number of PE-PCD with vertex set = <code>Xp</code>
and expansion parameter <code class="reqn">r \ge 1</code> and center <code>M</code></p>
</td></tr>
<tr><td><code>mds</code></td>
<td>
<p>A minimum dominating set of PE-PCD with vertex set = <code>Xp</code>
and expansion parameter <code class="reqn">r \ge 1</code> and center <code>M</code></p>
</td></tr>
<tr><td><code>ind.mds</code></td>
<td>
<p>Indices of the minimum dominating set <code>mds</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.nondeg">PEdom.num.nondeg</a></code>, <code><a href="#topic+PEdom.num">PEdom.num</a></code>,
and <code><a href="#topic+PEdom.num1D">PEdom.num1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2)
Tr&lt;-rbind(A,B,C)
n&lt;-10  #try also n&lt;-20
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1,1,1)

r&lt;-1.4

PEdom.num.tri(Xp,Tr,r,M)
IM&lt;-inci.matPEtri(Xp,Tr,r,M)
dom.num.greedy #try also dom.num.exact(IM)

gr.gam&lt;-dom.num.greedy(IM)
gr.gam
Xp[gr.gam$i,]

PEdom.num.tri(Xp,Tr,r,M=c(.4,.4))


</code></pre>

<hr>
<h2 id='PEdom.num1D'>The domination number of Proportional Edge Proximity Catch Digraph
(PE-PCD) for 1D data</h2><span id='topic+PEdom.num1D'></span>

<h3>Description</h3>

<p>Returns the domination number,
a minimum dominating set of PE-PCD whose vertices are the 1D data set <code>Xp</code>,
and the domination numbers for partition intervals based on <code>Yp</code>.
</p>
<p><code>Yp</code> determines the end points of the intervals
(i.e., partition the real line via intervalization).
It also includes the domination numbers in the end-intervals,
with interval label 1 for the left end-interval
and $|Yp|+1$ for the right end-interval.
</p>
<p>If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>PE proximity region is constructed with expansion parameter <code class="reqn">r \ge 1</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num1D(Xp, Yp, r, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num1D_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEdom.num1D_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points which constitute the end points of the intervals which
partition the real line.</p>
</td></tr>
<tr><td><code id="PEdom.num1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="PEdom.num1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code> (default <code>c=.5</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>dom.num</code></td>
<td>
<p>Domination number of PE-PCD with vertex set <code>Xp</code> and expansion parameter <code class="reqn">r \ge 1</code> and
centrality parameter <code class="reqn">c \in (0,1)</code>.</p>
</td></tr>
<tr><td><code>mds</code></td>
<td>
<p>A minimum dominating set of the PE-PCD.</p>
</td></tr>
<tr><td><code>ind.mds</code></td>
<td>
<p>The data indices of the minimum dominating set of the PE-PCD whose vertices are <code>Xp</code> points.</p>
</td></tr>
<tr><td><code>int.dom.nums</code></td>
<td>
<p>Domination numbers of the PE-PCD components for the partition intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.nondeg">PEdom.num.nondeg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a&lt;-0; b&lt;-10
c&lt;-.4
r&lt;-2

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

PEdom.num1D(Xp,Yp,r,c)

PEdom.num1D(Xp,Yp,r,c=.25)
PEdom.num1D(Xp,Yp,r=1.25,c)


</code></pre>

<hr>
<h2 id='PEdom.num1Dnondeg'>The domination number of Proportional Edge Proximity Catch Digraph (PE-PCD) with
non-degeneracy centers - multiple interval case</h2><span id='topic+PEdom.num1Dnondeg'></span>

<h3>Description</h3>

<p>Returns the domination number,
a minimum dominating set of PE-PCD whose vertices are the 1D data set <code>Xp</code>,
and the domination numbers for partition intervals based on <code>Yp</code>
when PE-PCD is constructed with vertex regions based on non-degeneracy centers.
</p>
<p><code>Yp</code> determines the end points of the intervals
(i.e., partition the real line via intervalization).
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>PE proximity regions are defined with respect to the intervals based on <code>Yp</code> points with
expansion parameter <code class="reqn">r \ge 1</code> and
vertex regions in each interval are based on the centrality parameter <code>c</code>
which is one of the 2 values of <code>c</code> (i.e., <code class="reqn">c \in \{(r-1)/r,1/r\}</code>)
that renders the asymptotic distribution of domination number
to be non-degenerate for a given value of <code>r</code> in <code class="reqn">(1,2)</code>
and <code>c</code> is center of mass for <code class="reqn">r=2</code>.
These values are called non-degeneracy centrality parameters
and the corresponding centers are called
nondegeneracy centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PEdom.num1Dnondeg(Xp, Yp, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PEdom.num1Dnondeg_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="PEdom.num1Dnondeg_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points which constitute the end points of the intervals which
partition the real line.</p>
</td></tr>
<tr><td><code id="PEdom.num1Dnondeg_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be in <code class="reqn">(1,2]</code> here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>dom.num</code></td>
<td>
<p>Domination number of PE-PCD with vertex set <code>Xp</code>
and expansion parameter <code class="reqn">r in (1,2]</code> and
centrality parameter <code class="reqn">c \in \{(r-1)/r,1/r\}</code>.</p>
</td></tr>
<tr><td><code>mds</code></td>
<td>
<p>A minimum dominating set of the PE-PCD.</p>
</td></tr>
<tr><td><code>ind.mds</code></td>
<td>
<p>The data indices of the minimum dominating set of the PE-PCD
whose vertices are <code>Xp</code> points.</p>
</td></tr>
<tr><td><code>int.dom.nums</code></td>
<td>
<p>Domination numbers of the PE-PCD components for the partition intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PEdom.num.nondeg">PEdom.num.nondeg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a&lt;-0; b&lt;-10
r&lt;-1.5

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

PEdom.num1Dnondeg(Xp,Yp,r)
PEdom.num1Dnondeg(Xp,Yp,r=1.25)


</code></pre>

<hr>
<h2 id='perpline'>The line passing through a point and perpendicular
to the line segment joining two points</h2><span id='topic+perpline'></span>

<h3>Description</h3>

<p>An object of class <code>"Lines"</code>.
Returns the <code>equation, slope, intercept</code>,
and <code class="reqn">y</code>-coordinates of the line crossing
the point <code>p</code> and perpendicular to the line
passing through the points <code>a</code> and <code>b</code>
with <code class="reqn">x</code>-coordinates are provided in <code>vector</code> <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perpline(p, a, b, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perpline_+3A_p">p</code></td>
<td>
<p>A 2D point at which the perpendicular line to line segment
joining <code>a</code> and <code>b</code> crosses.</p>
</td></tr>
<tr><td><code id="perpline_+3A_a">a</code>, <code id="perpline_+3A_b">b</code></td>
<td>
<p>2D points that determine the line segment
(the line will be perpendicular to this line segment).</p>
</td></tr>
<tr><td><code id="perpline_+3A_x">x</code></td>
<td>
<p>A scalar or a <code>vector</code> of scalars
representing the <code class="reqn">x</code>-coordinates of the line perpendicular to
line joining <code>a</code> and <code>b</code> and crossing <code>p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>Description of the line
passing through point <code>p</code> and perpendicular to line joining
<code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line
passing through point <code>p</code> and perpendicular to line joining
<code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>The input points <code>a</code> and <code>b</code>
(stacked row-wise, i.e., row 1 is point <code>a</code>
and row 2 is point <code>b</code>).
Line passing through point <code>p</code> is perpendicular
to line joining <code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The input vector, can be a scalar or a <code>vector</code> of scalars,
which constitute the <code class="reqn">x</code>-coordinates of the point(s) of interest
on the line passing through point <code>p</code> and
perpendicular to line joining
<code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The output <code>vector</code>
which constitutes the <code class="reqn">y</code>-coordinates of the point(s) of interest
on the line passing through point <code>p</code>
and perpendicular to line joining
<code>a</code> and <code>b</code>. If <code>x</code> is a scalar,
then <code>y</code> will be a scalar
and if <code>x</code> is a <code>vector</code> of scalars,
then <code>y</code> will be a <code>vector</code> of scalars.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>Slope of the line passing through point <code>p</code>
and perpendicular to line joining
<code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>Intercept of the line passing through point <code>p</code>
and perpendicular to line joining
<code>a</code> and <code>b</code></p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line passing through point <code>p</code>
and perpendicular to line joining
<code>a</code> and <code>b</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slope">slope</a></code>, <code><a href="#topic+Line">Line</a></code>, and <code><a href="#topic+paraline">paraline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1.1,1.2); B&lt;-c(2.3,3.4); p&lt;-c(.51,2.5)

perpline(p,A,B,.45)

pts&lt;-rbind(A,B,p)
xr&lt;-range(pts[,1])
xf&lt;-(xr[2]-xr[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100

plnAB&lt;-perpline(p,A,B,x)
plnAB
summary(plnAB)
plot(plnAB,asp=1)

y&lt;-plnAB$y
Xlim&lt;-range(x,pts[,1])
if (!is.na(y[1])) {Ylim&lt;-range(y,pts[,2])} else {Ylim&lt;-range(pts[,2])}
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
pf&lt;-c(xd,-yd)*.025

plot(A,asp=1,pch=".",xlab="",ylab="",
main="Line Crossing p and Perpendicular to AB",
xlim=Xlim+xd*c(-.5,.5),ylim=Ylim+yd*c(-.05,.05))
points(pts)
txt.str&lt;-c("A","B","p")
text(pts+rbind(pf,pf,pf),txt.str)

segments(A[1],A[2],B[1],B[2],lty=2)
if (!is.na(y[1])) {lines(x,y,type="l",lty=1,
xlim=Xlim,ylim=Ylim)} else {abline(v=p[1])}
tx&lt;-p[1]+abs(xf-p[1])/2;
if (!is.na(y[1])) {ty&lt;-perpline(p,A,B,tx)$y} else {ty=p[2]}
text(tx,ty,"line perpendicular to AB\n and crossing p")


</code></pre>

<hr>
<h2 id='perpline2plane'>The line crossing the 3D point <code>p</code>
and perpendicular to the plane spanned by 3D points <code>a</code>,
<code>b</code>, and <code>c</code></h2><span id='topic+perpline2plane'></span>

<h3>Description</h3>

<p>An object of class <code>"Lines3D"</code>.
Returns the equation, <code class="reqn">x</code>-, <code class="reqn">y</code>-,
and <code class="reqn">z</code>-coordinates of the line crossing 3D point <code>p</code>
and perpendicular to the plane
spanned by 3D points <code>a</code>, <code>b</code>, and <code>c</code>
(i.e., the line is in the direction of normal <code>vector</code> of this plane)
with the parameter <code>t</code> being provided in <code>vector</code> <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perpline2plane(p, a, b, c, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perpline2plane_+3A_p">p</code></td>
<td>
<p>A 3D point through which the straight line passes.</p>
</td></tr>
<tr><td><code id="perpline2plane_+3A_a">a</code>, <code id="perpline2plane_+3A_b">b</code>, <code id="perpline2plane_+3A_c">c</code></td>
<td>
<p>3D points which determine the plane to
which the line passing through point <code>p</code> would be
perpendicular (i.e., the normal <code>vector</code> of this plane
determines the direction of the straight line
passing through <code>p</code>).</p>
</td></tr>
<tr><td><code id="perpline2plane_+3A_t">t</code></td>
<td>
<p>A scalar or a <code>vector</code> of scalars
representing the parameter of the coordinates of the line
(for the form: <code class="reqn">x=p_0 + A t</code>, <code class="reqn">y=y_0 + B t</code>,
and <code class="reqn">z=z_0 + C t</code> where <code class="reqn">p=(p_0,y_0,z_0)</code>
and normal vector<code class="reqn">=(A,B,C)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A description of the line</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the line</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>The input points that determine the line and plane,
line crosses point <code>p</code> and plane is determined
by 3D points <code>a</code>, <code>b</code>, and <code>c</code>.</p>
</td></tr>
<tr><td><code>pnames</code></td>
<td>
<p>The names of the input points
that determine the line and plane; line would be perpendicular
to the plane.</p>
</td></tr>
<tr><td><code>vecs</code></td>
<td>
<p>The point <code>p</code> and normal vector.</p>
</td></tr>
<tr><td><code>vec.names</code></td>
<td>
<p>The names of the point <code>p</code>
and the second entry is &quot;normal vector&quot;.</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code>, <code>z</code></td>
<td>
<p>The <code class="reqn">x</code>-, <code class="reqn">y</code>-,
and <code class="reqn">z</code>-coordinates of the point(s) of interest
on the line perpendicular to the plane
determined by points <code>a</code>, <code>b</code>, and <code>c</code>.</p>
</td></tr>
<tr><td><code>tsq</code></td>
<td>
<p>The scalar or the <code>vector</code> of the parameter
in defining each coordinate of the line for the form:
<code class="reqn">x=p_0 + A t</code>, <code class="reqn">y=y_0 + B t</code>, and <code class="reqn">z=z_0 + C t</code>
where <code class="reqn">p=(p_0,y_0,z_0)</code> and normal vector<code class="reqn">=(A,B,C)</code>.</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the line passing through point <code>p</code>
and perpendicular to the plane determined by
points <code>a</code>, <code>b</code>, and <code>c</code> (i.e.,
line is in the direction of the normal <code>vector</code> N of the plane).
The line equation
is in the form: <code class="reqn">x=p_0 + A t</code>, <code class="reqn">y=y_0 + B t</code>,
and <code class="reqn">z=z_0 + C t</code> where <code class="reqn">p=(p_0,y_0,z_0)</code>
and normal vector<code class="reqn">=(A,B,C)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Line3D">Line3D</a></code>, <code><a href="#topic+paraline3D">paraline3D</a></code>,
and <code><a href="#topic+perpline">perpline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(1,1,1); Q&lt;-c(1,10,4); R&lt;-c(1,1,3); S&lt;-c(3,9,12)

cf&lt;-as.numeric(Plane(Q,R,S,1,1)$coeff)
a&lt;-cf[1]; b&lt;-cf[2]; c&lt;- -1;

vecs&lt;-rbind(Q,c(a,b,c))
pts&lt;-rbind(P,Q,R,S)
perpline2plane(P,Q,R,S,.1)

tr&lt;-range(pts,vecs);
tf&lt;-(tr[2]-tr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
tsq&lt;-seq(-tf*10-tf,tf*10+tf,l=5)  #try also l=10, 20, or 100

pln2pl&lt;-perpline2plane(P,Q,R,S,tsq)
pln2pl
summary(pln2pl)
plot(pln2pl,theta = 225, phi = 30, expand = 0.7,
facets = FALSE, scale = TRUE)

xc&lt;-pln2pl$x
yc&lt;-pln2pl$y
zc&lt;-pln2pl$z

zr&lt;-range(zc)
zf&lt;-(zr[2]-zr[1])*.2
Rv&lt;- -c(a,b,c)*zf*5

Dr&lt;-(Q+R+S)/3

pts2&lt;-rbind(Q,R,S)
xr&lt;-range(pts2[,1],xc); yr&lt;-range(pts2[,2],yc)
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
yf&lt;-(yr[2]-yr[1])*.1
#how far to go at the lower and upper ends in the y-coordinate
xs&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100
ys&lt;-seq(yr[1]-yf,yr[2]+yf,l=5)  #try also l=10, 20, or 100

plQRS&lt;-Plane(Q,R,S,xs,ys)
z.grid&lt;-plQRS$z

Xlim&lt;-range(xc,xs,pts[,1])
Ylim&lt;-range(yc,ys,pts[,2])
Zlim&lt;-range(zc,z.grid,pts[,3])

xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::persp3D(z = z.grid, x = xs, y = ys, theta =225, phi = 30,
main="Line Crossing P and \n Perpendicular to the Plane Defined by Q, R, S",
col="lightblue", ticktype = "detailed",
        xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),
        zlim=Zlim+zd*c(-.05,.05))
        #plane spanned by points Q, R, S
plot3D::lines3D(xc, yc, zc, bty = "g",pch = 20, cex = 2,col="red",
ticktype = "detailed",add=TRUE)
plot3D::arrows3D(Dr[1],Dr[2],Dr[3],Dr[1]+Rv[1],Dr[2]+Rv[2],
Dr[3]+Rv[3], add=TRUE)
plot3D::points3D(pts[,1],pts[,2],pts[,3],add=TRUE)
plot3D::text3D(pts[,1],pts[,2],pts[,3],labels=c("P","Q","R","S"),add=TRUE)
plot3D::arrows3D(P[1],P[2],P[3]-zf,P[1],P[2],P[3],lty=2, add=TRUE)
plot3D::text3D(P[1],P[2],P[3]-zf,labels="initial point",add=TRUE)
plot3D::text3D(P[1],P[2],P[3]+zf/2,labels="P",add=TRUE)
plot3D::arrows3D(Dr[1],Dr[2],Dr[3],Dr[1]+Rv[1]/2,Dr[2]+Rv[2]/2,
Dr[3]+Rv[3]/2,lty=2, add=TRUE)
plot3D::text3D(Dr[1]+Rv[1]/2,Dr[2]+Rv[2]/2,Dr[3]+Rv[3]/2,
labels="normal vector",add=TRUE)

</code></pre>

<hr>
<h2 id='Plane'>The plane passing through three distinct 3D points
<code>a</code>, <code>b</code>, and <code>c</code></h2><span id='topic+Plane'></span>

<h3>Description</h3>

<p>An object of class <code>"Planes"</code>.
Returns the equation and <code class="reqn">z</code>-coordinates of the plane
passing through three distinct 3D points <code>a</code>, <code>b</code>, and <code>c</code>
with <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates are provided
in vectors <code>x</code> and <code>y</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plane(a, b, c, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plane_+3A_a">a</code>, <code id="Plane_+3A_b">b</code>, <code id="Plane_+3A_c">c</code></td>
<td>
<p>3D points that determine the plane
(i.e., through which the plane is passing).</p>
</td></tr>
<tr><td><code id="Plane_+3A_x">x</code>, <code id="Plane_+3A_y">y</code></td>
<td>
<p>Scalars or vectors of scalars
representing the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the plane.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>desc</code></td>
<td>
<p>A description of the plane</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>The input points <code>a</code>, <code>b</code>,
and <code>c</code> through which the plane is passing
(stacked row-wise, i.e., row 1 is point <code>a</code>,
row 2 is point <code>b</code> and row 3 is point <code>c</code>).</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>The input vectors which constitutes the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the point(s) of interest on the
plane. <code>x</code> and <code>y</code> can be scalars or vectors of scalars.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>The output <code>vector</code>
which constitutes the <code class="reqn">z</code>-coordinates of the point(s) of interest
on the plane.
If <code>x</code> and <code>y</code> are scalars, <code>z</code> will be a scalar and
if <code>x</code> and <code>y</code> are vectors of scalars,
then <code>z</code> needs to be a <code>matrix</code> of scalars,
containing the <code class="reqn">z</code>-coordinate
for each pair of <code>x</code> and <code>y</code> values.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>Coefficients of the plane (in the <code class="reqn">z = A x+B y+C</code> form).</p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p>Equation of the plane in long form</p>
</td></tr>
<tr><td><code>equation2</code></td>
<td>
<p>Equation of the plane in short form,
to be inserted on the plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paraplane">paraplane</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P1&lt;-c(1,10,3); P2&lt;-c(1,1,3); P3&lt;-c(3,9,12) #also try P2=c(2,2,3)

pts&lt;-rbind(P1,P2,P3)
Plane(P1,P2,P3,.1,.2)

xr&lt;-range(pts[,1]); yr&lt;-range(pts[,2])
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
yf&lt;-(yr[2]-yr[1])*.1
#how far to go at the lower and upper ends in the y-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5)  #try also l=10, 20, or 100
y&lt;-seq(yr[1]-yf,yr[2]+yf,l=5)  #try also l=10, 20, or 100

plP123&lt;-Plane(P1,P2,P3,x,y)
plP123
summary(plP123)
plot(plP123,theta = 225, phi = 30, expand = 0.7, facets = FALSE, scale = TRUE)

z.grid&lt;-plP123$z

persp(x,y,z.grid, xlab="x",ylab="y",zlab="z",
theta = -30, phi = 30, expand = 0.5, col = "lightblue",
      ltheta = 120, shade = 0.05, ticktype = "detailed")

zr&lt;-max(z.grid)-min(z.grid)
Pts&lt;-rbind(P1,P2,P3)+rbind(c(0,0,zr*.1),c(0,0,zr*.1),c(0,0,zr*.1))
Mn.pts&lt;-apply(Pts,2,mean)

plot3D::persp3D(z = z.grid, x = x, y = y,theta = 225, phi = 30, expand = 0.3,
main = "Plane Crossing Points P1, P2, and P3", facets = FALSE, scale = TRUE)
#plane spanned by points P1, P2, P3
#add the defining points
plot3D::points3D(Pts[,1],Pts[,2],Pts[,3], add=TRUE)
plot3D::text3D(Pts[,1],Pts[,2],Pts[,3], c("P1","P2","P3"),add=TRUE)
plot3D::text3D(Mn.pts[1],Mn.pts[2],Mn.pts[3],plP123$equation,add=TRUE)
#plot3D::polygon3D(Pts[,1],Pts[,2],Pts[,3], add=TRUE)


</code></pre>

<hr>
<h2 id='plot.Extrema'>Plot an <code>Extrema</code> <code>object</code></h2><span id='topic+plot.Extrema'></span>

<h3>Description</h3>

<p>Plots the data points and extrema
among these points together with the reference object
(e.g., boundary of the support region)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Extrema'
plot(x, asp = NA, xlab = "", ylab = "", zlab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Extrema_+3A_x">x</code></td>
<td>
<p>Object of class <code>Extrema</code>.</p>
</td></tr>
<tr><td><code id="plot.Extrema_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value,
giving the aspect ratio for <code class="reqn">y</code>-axis to <code class="reqn">x</code>-axis
<code class="reqn">y/x</code> for the 2D case,
it is redundant in the 3D case (default is <code>NA</code>),
see the official help for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.Extrema_+3A_xlab">xlab</code>, <code id="plot.Extrema_+3A_ylab">ylab</code>, <code id="plot.Extrema_+3A_zlab">zlab</code></td>
<td>
<p>Titles
for the <code class="reqn">x</code> and <code class="reqn">y</code> axes in the 2D case,
and <code class="reqn">x</code>, <code class="reqn">y</code>, and <code class="reqn">z</code> axes in the 3D case,
respectively (default is <code>""</code> for all).</p>
</td></tr>
<tr><td><code id="plot.Extrema_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Extrema">print.Extrema</a></code>,
<code><a href="#topic+summary.Extrema">summary.Extrema</a></code>,
and <code><a href="#topic+print.summary.Extrema">print.summary.Extrema</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10
Xp&lt;-runif.std.tri(n)$gen.points
Ext&lt;-cl2edges.std.tri(Xp)
Ext
plot(Ext,asp=1)


</code></pre>

<hr>
<h2 id='plot.Lines'>Plot a <code>Lines</code> <code>object</code></h2><span id='topic+plot.Lines'></span>

<h3>Description</h3>

<p>Plots the line together with the defining <code>points</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lines'
plot(x, asp = NA, xlab = "x", ylab = "y", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Lines_+3A_x">x</code></td>
<td>
<p>Object of class <code>Lines</code>.</p>
</td></tr>
<tr><td><code id="plot.Lines_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value, giving the aspect ratio
for <code class="reqn">y</code>-axis to <code class="reqn">x</code>-axis <code class="reqn">y/x</code> (default is <code>NA</code>),
see the official help for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.Lines_+3A_xlab">xlab</code>, <code id="plot.Lines_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default is <code>xlab="x"</code> and <code>ylab="y"</code>).</p>
</td></tr>
<tr><td><code id="plot.Lines_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Lines">print.Lines</a></code>, <code><a href="#topic+summary.Lines">summary.Lines</a></code>,
and <code><a href="#topic+print.summary.Lines">print.summary.Lines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(-1.22,-2.33); B&lt;-c(2.55,3.75)
xr&lt;-range(A,B);
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=3) #try also l=10, 20 or 100

lnAB&lt;-Line(A,B,x)
lnAB
plot(lnAB)


</code></pre>

<hr>
<h2 id='plot.Lines3D'>Plot a <code>Lines3D</code> <code>object</code></h2><span id='topic+plot.Lines3D'></span>

<h3>Description</h3>

<p>Plots the line together with the defining vectors
(i.e., the initial and direction vectors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lines3D'
plot(x, xlab = "x", ylab = "y", zlab = "z", phi = 40, theta = 40, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Lines3D_+3A_x">x</code></td>
<td>
<p>Object of class <code>Lines3D</code>.</p>
</td></tr>
<tr><td><code id="plot.Lines3D_+3A_xlab">xlab</code>, <code id="plot.Lines3D_+3A_ylab">ylab</code>, <code id="plot.Lines3D_+3A_zlab">zlab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code>, <code class="reqn">y</code>, and <code class="reqn">z</code> axes,
respectively (default is <code>xlab="x"</code>, <code>ylab="y"</code>
and <code>zlab="z"</code>).</p>
</td></tr>
<tr><td><code id="plot.Lines3D_+3A_theta">theta</code>, <code id="plot.Lines3D_+3A_phi">phi</code></td>
<td>
<p>The angles defining the viewing direction.
<code>theta</code> gives the azimuthal direction and <code>phi</code> the colatitude.
See <code><a href="plot3D.html#topic+persp3D">persp3D</a></code> for more details.</p>
</td></tr>
<tr><td><code id="plot.Lines3D_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Lines3D">print.Lines3D</a></code>, <code><a href="#topic+summary.Lines3D">summary.Lines3D</a></code>,
and <code><a href="#topic+print.summary.Lines3D">print.summary.Lines3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(1,10,3); Q&lt;-c(1,1,3);
vecs&lt;-rbind(P,Q)
Line3D(P,Q,.1)
Line3D(P,Q,.1,dir.vec=FALSE)

tr&lt;-range(vecs);
tf&lt;-(tr[2]-tr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
tsq&lt;-seq(-tf*10-tf,tf*10+tf,l=3) #try also l=10, 20 or 100

lnPQ3D&lt;-Line3D(P,Q,tsq)
lnPQ3D
plot(lnPQ3D)


</code></pre>

<hr>
<h2 id='plot.NumArcs'>Plot a <code>NumArcs</code> <code>object</code></h2><span id='topic+plot.NumArcs'></span>

<h3>Description</h3>

<p>Plots the scatter plot of the data points (i.e. vertices of the PCDs)
and the Delaunay tessellation of the nontarget points marked with number of arcs
in the centroid of the Delaunay cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NumArcs'
plot(x, Jit = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.NumArcs_+3A_x">x</code></td>
<td>
<p>Object of class <code>NumArcs</code>.</p>
</td></tr>
<tr><td><code id="plot.NumArcs_+3A_jit">Jit</code></td>
<td>
<p>A positive real number
that determines the amount of jitter along the <code class="reqn">y</code>-axis,
default is 0.1, for the 1D case,
the vertices of the PCD are jittered
according to <code class="reqn">U(-Jit,Jit)</code> distribution
along the <code class="reqn">y</code>-axis where
<code>Jit</code> equals to the range of vertices
and the interval end points; it is redundant in the 2D case.</p>
</td></tr>
<tr><td><code id="plot.NumArcs_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.NumArcs">print.NumArcs</a></code>, <code><a href="#topic+summary.NumArcs">summary.NumArcs</a></code>,
and <code><a href="#topic+print.summary.NumArcs">print.summary.NumArcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10
Xp&lt;-runif.tri(n,Tr)$g
M&lt;-as.numeric(runif.tri(1,Tr)$g)
Arcs&lt;-arcsAStri(Xp,Tr,M)
Arcs
plot(Arcs)


</code></pre>

<hr>
<h2 id='plot.Patterns'>Plot a <code>Patterns</code> <code>object</code></h2><span id='topic+plot.Patterns'></span>

<h3>Description</h3>

<p>Plots the points generated from the pattern
(color coded for each class) together with the
study window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Patterns'
plot(x, asp = NA, xlab = "x", ylab = "y", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Patterns_+3A_x">x</code></td>
<td>
<p>Object of class <code>Patterns</code>.</p>
</td></tr>
<tr><td><code id="plot.Patterns_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value,
giving the aspect ratio for <code class="reqn">y</code>-axis to <code class="reqn">x</code>-axis <code class="reqn">y/x</code>
(default is <code>NA</code>),
see the official help for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.Patterns_+3A_xlab">xlab</code>, <code id="plot.Patterns_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default is <code>xlab="x"</code> and <code>ylab="y"</code>).</p>
</td></tr>
<tr><td><code id="plot.Patterns_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Patterns">print.Patterns</a></code>,
<code><a href="#topic+summary.Patterns">summary.Patterns</a></code>,
and <code><a href="#topic+print.summary.Patterns">print.summary.Patterns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-10; #try also 100 and 1000
ny&lt;-5; #try also 1
e&lt;-.15;
Y&lt;-cbind(runif(ny),runif(ny))
#with default bounding box (i.e., unit square)

Xdt&lt;-rseg.circular(nx,Y,e)
Xdt
plot(Xdt,asp=1)


</code></pre>

<hr>
<h2 id='plot.PCDs'>Plot a <code>PCDs</code> <code>object</code></h2><span id='topic+plot.PCDs'></span>

<h3>Description</h3>

<p>Plots the vertices and the arcs
of the PCD together with the vertices
and boundaries of the partition
cells (i.e., intervals in the 1D case
and triangles in the 2D case)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCDs'
plot(x, Jit = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PCDs_+3A_x">x</code></td>
<td>
<p>Object of class <code>PCDs</code>.</p>
</td></tr>
<tr><td><code id="plot.PCDs_+3A_jit">Jit</code></td>
<td>
<p>A positive real number
that determines the amount of jitter along the <code class="reqn">y</code>-axis,
default is 0.1, for the 1D case,
the vertices of the PCD are jittered
according to <code class="reqn">U(-Jit,Jit)</code> distribution
along the <code class="reqn">y</code>-axis where
<code>Jit</code> equals to the range of vertices
and the interval end points; it is redundant in the 2D case.</p>
</td></tr>
<tr><td><code id="plot.PCDs_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.PCDs">print.PCDs</a></code>, <code><a href="#topic+summary.PCDs">summary.PCDs</a></code>,
and <code><a href="#topic+print.summary.PCDs">print.summary.PCDs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10
Xp&lt;-runif.tri(n,Tr)$g
M&lt;-as.numeric(runif.tri(1,Tr)$g)
Arcs&lt;-arcsAStri(Xp,Tr,M)
Arcs
plot(Arcs)


</code></pre>

<hr>
<h2 id='plot.Planes'>Plot a <code>Planes</code> <code>object</code></h2><span id='topic+plot.Planes'></span>

<h3>Description</h3>

<p>Plots the plane together with the defining 3D <code>points</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Planes'
plot(
  x,
  x.grid.size = 10,
  y.grid.size = 10,
  xlab = "x",
  ylab = "y",
  zlab = "z",
  phi = 40,
  theta = 40,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Planes_+3A_x">x</code></td>
<td>
<p>Object of class <code>Planes</code>.</p>
</td></tr>
<tr><td><code id="plot.Planes_+3A_x.grid.size">x.grid.size</code>, <code id="plot.Planes_+3A_y.grid.size">y.grid.size</code></td>
<td>
<p>the size of the grids
for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, default is 10 for both</p>
</td></tr>
<tr><td><code id="plot.Planes_+3A_xlab">xlab</code>, <code id="plot.Planes_+3A_ylab">ylab</code>, <code id="plot.Planes_+3A_zlab">zlab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code>, <code class="reqn">y</code>,
and <code class="reqn">z</code> axes,
respectively (default is <code>xlab="x"</code>, <code>ylab="y"</code>,
and <code>zlab="z"</code>).</p>
</td></tr>
<tr><td><code id="plot.Planes_+3A_theta">theta</code>, <code id="plot.Planes_+3A_phi">phi</code></td>
<td>
<p>The angles defining the viewing direction,
default is 40 for both.
<code>theta</code> gives the azimuthal direction and
<code>phi</code> the colatitude. see <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Planes_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Planes">print.Planes</a></code>,
<code><a href="#topic+summary.Planes">summary.Planes</a></code>,
and <code><a href="#topic+print.summary.Planes">print.summary.Planes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(1,10,3); Q&lt;-c(1,1,3); C&lt;-c(3,9,12)
pts&lt;-rbind(P,Q,C)

xr&lt;-range(pts[,1]); yr&lt;-range(pts[,2])
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
yf&lt;-(yr[2]-yr[1])*.1
#how far to go at the lower and upper ends in the y-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5) #try also l=10, 20 or 100
y&lt;-seq(yr[1]-yf,yr[2]+yf,l=5) #try also l=10, 20 or 100

plPQC&lt;-Plane(P,Q,C,x,y)
plPQC
plot(plPQC,theta = 225, phi = 30, expand = 0.7,
facets = FALSE, scale = TRUE)


</code></pre>

<hr>
<h2 id='plot.TriLines'>Plot a <code>TriLines</code> <code>object</code></h2><span id='topic+plot.TriLines'></span>

<h3>Description</h3>

<p>Plots the line together with the defining triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TriLines'
plot(x, xlab = "x", ylab = "y", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.TriLines_+3A_x">x</code></td>
<td>
<p>Object of class <code>TriLines</code>.</p>
</td></tr>
<tr><td><code id="plot.TriLines_+3A_xlab">xlab</code>, <code id="plot.TriLines_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default is <code>xlab="x"</code> and <code>ylab="y"</code>).</p>
</td></tr>
<tr><td><code id="plot.TriLines_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.TriLines">print.TriLines</a></code>,
<code><a href="#topic+summary.TriLines">summary.TriLines</a></code>,
and <code><a href="#topic+print.summary.TriLines">print.summary.TriLines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
xfence&lt;-abs(A[1]-B[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,l=3)

lnACM&lt;-lineA2CMinTe(x)
lnACM
plot(lnACM)

</code></pre>

<hr>
<h2 id='plot.Uniform'>Plot a <code>Uniform</code> <code>object</code></h2><span id='topic+plot.Uniform'></span>

<h3>Description</h3>

<p>Plots the points generated from the uniform distribution
together with the support region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Uniform'
plot(x, asp = NA, xlab = "x", ylab = "y", zlab = "z", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Uniform_+3A_x">x</code></td>
<td>
<p>Object of class <code>Uniform</code>.</p>
</td></tr>
<tr><td><code id="plot.Uniform_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value,
giving the aspect ratio for <code class="reqn">y</code>-axis to <code class="reqn">x</code>-axis
<code class="reqn">y/x</code> for the 2D case,
it is redundant in the 3D case (default is <code>NA</code>),
see the official help for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.Uniform_+3A_xlab">xlab</code>, <code id="plot.Uniform_+3A_ylab">ylab</code>, <code id="plot.Uniform_+3A_zlab">zlab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes
in the 2D case,
and <code class="reqn">x</code>, <code class="reqn">y</code>, and <code class="reqn">z</code> axes in the 3D case,
respectively (default is <code>xlab="x"</code>, <code>ylab="y"</code>,
and <code>zlab="z"</code>).</p>
</td></tr>
<tr><td><code id="plot.Uniform_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Uniform">print.Uniform</a></code>,
<code><a href="#topic+summary.Uniform">summary.Uniform</a></code>,
and <code><a href="#topic+print.summary.Uniform">print.summary.Uniform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10 #try also 20, 100, and 1000
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C)

Xdt&lt;-runif.tri(n,Tr)
Xdt
plot(Xdt,asp=1)


</code></pre>

<hr>
<h2 id='plotASarcs'>The plot of the arcs of Arc Slice Proximity Catch Digraph (AS-PCD)
for a 2D data set -
multiple triangle case</h2><span id='topic+plotASarcs'></span>

<h3>Description</h3>

<p>Plots the arcs of AS-PCD whose vertices are the data points
in <code>Xp</code> and Delaunay triangles based on <code>Yp</code> points.
</p>
<p>AS proximity regions are constructed with respect to the Delaunay triangles
based on <code>Yp</code> points, i.e.,
AS proximity regions are defined only for <code>Xp</code> points
inside the convex hull of <code>Yp</code> points.
That is, arcs may exist for <code>Xp</code> points only
inside the convex hull of <code>Yp</code> points.
If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>Vertex regions are based on the center <code>M="CC"</code>
for circumcenter of each Delaunay triangle or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the
interior of each Delaunay triangle; default is <code>M="CC"</code> i.e.,
circumcenter of each triangle.
When the center is the circumcenter, <code>CC</code>,
the vertex regions are constructed based on the
orthogonal projections to the edges,
while with any interior center <code>M</code>,
the vertex regions are constructed using the extensions
of the lines combining vertices with <code>M</code>.
</p>
<p>Convex hull of <code>Yp</code> is partitioned by
the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
Loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005, 2010))
for more on AS-PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotASarcs(
  Xp,
  Yp,
  M = "CC",
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotASarcs_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="plotASarcs_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of
the Delaunay triangulation. The Delaunay
triangles partition the convex hull of <code>Yp</code> points.</p>
</td></tr>
<tr><td><code id="plotASarcs_+3A_m">M</code></td>
<td>
<p>The center of the triangle.
<code>"CC"</code> stands for circumcenter of each Delaunay triangle
or 3D point in barycentric coordinates
which serves as a center in the interior of each Delaunay triangle;
default is <code>M="CC"</code> i.e., the circumcenter of each triangle.</p>
</td></tr>
<tr><td><code id="plotASarcs_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value, giving the aspect ratio for <code class="reqn">y</code> axis
to <code class="reqn">x</code>-axis <code class="reqn">y/x</code> (default is <code>NA</code>),
see the official help page for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotASarcs_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotASarcs_+3A_xlab">xlab</code>, <code id="plotASarcs_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotASarcs_+3A_xlim">xlim</code>, <code id="plotASarcs_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2,
giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotASarcs_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of the AS-PCD for a 2D data set <code>Xp</code>
where AS proximity regions
are defined with respect to the Delaunay triangles based on <code>Yp</code> points;
also plots the Delaunay triangles
based on <code>Yp</code> points.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotASarcs.tri">plotASarcs.tri</a></code>, <code><a href="#topic+plotPEarcs.tri">plotPEarcs.tri</a></code>, <code><a href="#topic+plotPEarcs">plotPEarcs</a></code>,
<code><a href="#topic+plotCSarcs.tri">plotCSarcs.tri</a></code>, and <code><a href="#topic+plotCSarcs">plotCSarcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

plotASarcs(Xp,Yp,M,asp=1,xlab="",ylab="")

plotASarcs(Xp,Yp[1:3,],M,asp=1,xlab="",ylab="")


</code></pre>

<hr>
<h2 id='plotASarcs.tri'>The plot of the arcs of Arc Slice Proximity Catch Digraph (AS-PCD)
for a 2D data set - one triangle case</h2><span id='topic+plotASarcs.tri'></span>

<h3>Description</h3>

<p>Plots the arcs of AS-PCD whose vertices are the data points, <code>Xp</code>
and also the triangle <code>tri</code>.
AS proximity regions are constructed
with respect to the triangle <code>tri</code>,
i.e., only for <code>Xp</code> points inside the triangle <code>tri</code>.
If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>Vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
When the center is the circumcenter, <code>CC</code>,
the vertex regions are constructed based on the
orthogonal projections to the edges,
while with any interior center <code>M</code>,
the vertex regions are constructed using the extensions
of the lines combining vertices with <code>M</code>.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotASarcs.tri(
  Xp,
  tri,
  M = "CC",
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  vert.reg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotASarcs.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the AS-PCD.</p>
</td></tr>
<tr><td><code id="plotASarcs.tri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise,
each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="plotASarcs.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle.
<code>"CC"</code> stands for circumcenter of the triangle <code>tri</code>
or a 2D point in Cartesian coordinates or a 3D point in
barycentric coordinates which serves as a center
in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="plotASarcs.tri_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value, giving the aspect ratio for <code class="reqn">y</code> axis
to <code class="reqn">x</code>-axis <code class="reqn">y/x</code> (default is <code>NA</code>),
see the official help page for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotASarcs.tri_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotASarcs.tri_+3A_xlab">xlab</code>, <code id="plotASarcs.tri_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotASarcs.tri_+3A_xlim">xlim</code>, <code id="plotASarcs.tri_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2,
giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotASarcs.tri_+3A_vert.reg">vert.reg</code></td>
<td>
<p>A logical argument to add vertex regions to the plot,
default is <code>vert.reg=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotASarcs.tri_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of the AS-PCD for a 2D data set <code>Xp</code>
where AS proximity regions
are defined with respect to the triangle <code>tri</code>;
also plots the triangle <code>tri</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotASarcs">plotASarcs</a></code>, <code><a href="#topic+plotPEarcs.tri">plotPEarcs.tri</a></code>, <code><a href="#topic+plotPEarcs">plotPEarcs</a></code>,
<code><a href="#topic+plotCSarcs.tri">plotCSarcs.tri</a></code>, and <code><a href="#topic+plotCSarcs">plotCSarcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g  #try also Xp&lt;-cbind(runif(n,1,2),runif(n,0,2))

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also  #M&lt;-c(1.6,1.2)

plotASarcs.tri(Xp,Tr,M,main="Arcs of AS-PCD",xlab="",ylab="")

plotASarcs.tri(Xp,Tr,M,main="Arcs of AS-PCD",xlab="",ylab="",vert.reg = TRUE)

# or try the default center
#plotASarcs.tri(Xp,Tr,asp=1,main="arcs of AS-PCD",xlab="",ylab="",vert.reg = TRUE);
#M = (arcsAStri(Xp,Tr)$param)$c #the part "M = as.numeric(arcsAStri(Xp,Tr)$param)" is optional,
#for the below annotation of the plot

#can add vertex labels and text to the figure (with vertex regions)
#but first we need to determine whether the center used for vertex regions is CC or not
#see the description for more detail.
CC&lt;-circumcenter.tri(Tr)

if (isTRUE(all.equal(M,CC)) || identical(M,"CC"))
{cent&lt;-CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
cent.name&lt;-"CC"
} else
{cent&lt;-M
cent.name&lt;-"M"
Ds&lt;-prj.cent2edges(Tr,M)
}

#now we add the vertex names and annotation
txt&lt;-rbind(Tr,cent,Ds)
xc&lt;-txt[,1]+c(-.02,.02,.02,.01,.05,-0.03,-.01)
yc&lt;-txt[,2]+c(.02,.02,.02,.07,.02,.05,-.06)
txt.str&lt;-c("A","B","C",cent.name,"D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='plotASregs'>The plot of the Arc Slice (AS) Proximity Regions for a 2D data set - multiple triangle case</h2><span id='topic+plotASregs'></span>

<h3>Description</h3>

<p>Plots the <code>Xp</code> points in and outside of the convex hull of <code>Yp</code> points and also plots the AS proximity regions
for <code>Xp</code> points and Delaunay triangles based on <code>Yp</code> points.
</p>
<p>AS proximity regions are constructed with respect
to the Delaunay triangles based on <code>Yp</code> points (these triangles partition the convex hull of <code>Yp</code> points),
i.e., AS proximity regions are only defined for <code>Xp</code> points inside the convex hull of <code>Yp</code> points.
</p>
<p>Vertex regions are based on the center <code>M="CC"</code>
for circumcenter of each Delaunay triangle
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the
interior of each Delaunay triangle; default is <code>M="CC"</code> i.e., circumcenter of each triangle.
</p>
<p>See (Ceyhan (2005, 2010)) for more on AS-PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016)) for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotASregs(
  Xp,
  Yp,
  M = "CC",
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotASregs_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points for which AS proximity regions are constructed.</p>
</td></tr>
<tr><td><code id="plotASregs_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangulation. The Delaunay
triangles partition the convex hull of <code>Yp</code> points.</p>
</td></tr>
<tr><td><code id="plotASregs_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of each Delaunay triangle or 3D point in barycentric
coordinates which serves as a center in the interior of each Delaunay triangle;
default is <code>M="CC"</code> i.e., the circumcenter of each triangle.</p>
</td></tr>
<tr><td><code id="plotASregs_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotASregs_+3A_xlab">xlab</code>, <code id="plotASregs_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotASregs_+3A_xlim">xlim</code>, <code id="plotASregs_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotASregs_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the <code>Xp</code> points, Delaunay triangles based on <code>Yp</code> and also the AS proximity regions
for <code>Xp</code> points inside the convex hull of <code>Yp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotASregs.tri">plotASregs.tri</a></code>, <code><a href="#topic+plotPEregs.tri">plotPEregs.tri</a></code>, <code><a href="#topic+plotPEregs">plotPEregs</a></code>,
<code><a href="#topic+plotCSregs.tri">plotCSregs.tri</a></code>, and <code><a href="#topic+plotCSregs">plotCSregs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-10 ; ny&lt;-5

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3) #or M="CC"

plotASregs(Xp,Yp,M,xlab="",ylab="")

plotASregs(Xp,Yp[1:3,],M,xlab="",ylab="")

Xp&lt;-c(.5,.5)
plotASregs(Xp,Yp,M,xlab="",ylab="")


</code></pre>

<hr>
<h2 id='plotASregs.tri'>The plot of the Arc Slice (AS) Proximity Regions for a 2D data set - one triangle case</h2><span id='topic+plotASregs.tri'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the triangle <code>tri</code> and also the AS proximity regions
for points in data set <code>Xp</code>.
</p>
<p>AS proximity regions are defined with respect to the triangle <code>tri</code>,
so AS proximity regions are defined only for points inside the triangle <code>tri</code> and
vertex regions are based on the center, <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on circumcenter of  <code>tri</code>;
default is <code>M="CC"</code>, i.e., circumcenter of <code>tri</code>.
When vertex regions are constructed with circumcenter, <code>CC</code>,
the vertex regions are constructed based on the
orthogonal projections to the edges, while with any interior center <code>M</code>,
the vertex regions are constructed using the extensions
of the lines combining vertices with <code>M</code>.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotASregs.tri(
  Xp,
  tri,
  M = "CC",
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  vert.reg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotASregs.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points for which AS proximity regions are constructed.</p>
</td></tr>
<tr><td><code id="plotASregs.tri_+3A_tri">tri</code></td>
<td>
<p>Three 2D points, stacked row-wise, each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="plotASregs.tri_+3A_m">M</code></td>
<td>
<p>The center of the triangle. <code>"CC"</code> stands for circumcenter of the triangle <code>tri</code> or a 2D point in Cartesian coordinates or a 3D point in
barycentric coordinates which serves as a center in the interior of the triangle <code class="reqn">T_b</code>;
default is <code>M="CC"</code> i.e., the circumcenter of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="plotASregs.tri_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotASregs.tri_+3A_xlab">xlab</code>, <code id="plotASregs.tri_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotASregs.tri_+3A_xlim">xlim</code>, <code id="plotASregs.tri_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotASregs.tri_+3A_vert.reg">vert.reg</code></td>
<td>
<p>A logical argument to add vertex regions to the plot, default is <code>vert.reg=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotASregs.tri_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the AS proximity regions for points inside the triangle <code>tri</code> (and only the points outside <code>tri</code>)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotASregs">plotASregs</a></code>, <code><a href="#topic+plotPEregs.tri">plotPEregs.tri</a></code>, <code><a href="#topic+plotPEregs">plotPEregs</a></code>,
<code><a href="#topic+plotCSregs.tri">plotCSregs.tri</a></code>, and <code><a href="#topic+plotCSregs">plotCSregs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp0&lt;-runif.tri(n,Tr)$g
M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also  #M&lt;-c(1.6,1.2);

plotASregs.tri(Xp0,Tr,M,main="Proximity Regions for AS-PCD", xlab="",ylab="")
Xp = Xp0[1,]
plotASregs.tri(Xp,Tr,M,main="Proximity Regions for AS-PCD", xlab="",ylab="")

#can plot the arcs of the AS-PCD
#plotASarcs.tri(Xp,Tr,M,main="Arcs of AS-PCD",xlab="",ylab="")

plotASregs.tri(Xp,Tr,M,main="Proximity Regions for AS-PCD", xlab="",ylab="",vert.reg=TRUE)

# or try the default center
#plotASregs.tri(Xp,Tr,main="Proximity Regions for AS-PCD", xlab="",ylab="",vert.reg=TRUE);
M = (arcsAStri(Xp,Tr)$param)$c #the part "M = as.numeric(arcsAStri(Xp,Tr)$param)" is optional,
#for the below annotation of the plot

#can add vertex labels and text to the figure (with vertex regions)
#but first we need to determine whether the center used for vertex regions is CC or not
#see the description for more detail.
CC&lt;-circumcenter.tri(Tr)
#Arcs&lt;-arcsAStri(Xp,Tr,M)
#M = as.numeric(Arcs$parameters)
if (isTRUE(all.equal(M,CC)) || identical(M,"CC"))
{cent&lt;-CC
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
cent.name&lt;-"CC"
} else
{cent&lt;-M
cent.name&lt;-"M"
Ds&lt;-prj.cent2edges(Tr,M)
}

#now we add the vertex names and annotation
txt&lt;-rbind(Tr,cent,Ds)
xc&lt;-txt[,1]+c(-.02,.03,.03,.03,.05,-0.03,-.01)
yc&lt;-txt[,2]+c(.02,.02,.02,.07,.02,.05,-.06)
txt.str&lt;-c("A","B","C",cent.name,"D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='plotCSarcs'>The plot of the arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for a
2D data set - multiple triangle case</h2><span id='topic+plotCSarcs'></span>

<h3>Description</h3>

<p>Plots the arcs of Central Similarity Proximity Catch Digraph (CS-PCD)
whose vertices are the data
points in <code>Xp</code> in the multiple triangle case and the Delaunay triangles
based on <code>Yp</code> points.
If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>CS proximity regions are defined with respect to the Delaunay triangles
based on <code>Yp</code> points with
expansion parameter <code class="reqn">t&gt;0</code> and edge regions in each triangle are
based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of each Delaunay triangle
(default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of the triangle).
</p>
<p>Convex hull of <code>Yp</code> is partitioned by the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles whose union constitutes the
convex hull of <code>Yp</code> points). Loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)) more on the CS-PCDs.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016)) for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCSarcs(
  Xp,
  Yp,
  t,
  M = c(1, 1, 1),
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCSarcs_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="plotCSarcs_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="plotCSarcs_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="plotCSarcs_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates which serves as a center in the interior of each Delaunay
triangle, default for <code class="reqn">M=(1,1,1)</code> which is the center of mass of each triangle.</p>
</td></tr>
<tr><td><code id="plotCSarcs_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value, giving the aspect ratio <code class="reqn">y/x</code> (default is <code>NA</code>), see the official help page for <code>asp</code> by typing &quot;<code>? asp</code>&quot;</p>
</td></tr>
<tr><td><code id="plotCSarcs_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotCSarcs_+3A_xlab">xlab</code>, <code id="plotCSarcs_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSarcs_+3A_xlim">xlim</code>, <code id="plotCSarcs_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges (default=<code>NULL</code> for both)</p>
</td></tr>
<tr><td><code id="plotCSarcs_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of the CS-PCD whose vertices are the points in data set <code>Xp</code> and the Delaunay
triangles based on <code>Yp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCSarcs.tri">plotCSarcs.tri</a></code>, <code><a href="#topic+plotASarcs">plotASarcs</a></code>, and <code><a href="#topic+plotPEarcs">plotPEarcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)
t&lt;-1.5  #try also t&lt;-2

plotCSarcs(Xp,Yp,t,M,xlab="",ylab="")


</code></pre>

<hr>
<h2 id='plotCSarcs.int'>The plot of the arcs of Central Similarity Proximity Catch Digraphs
(CS-PCDs) for 1D data
(vertices jittered along <code class="reqn">y</code>-coordinate) - one interval case</h2><span id='topic+plotCSarcs.int'></span>

<h3>Description</h3>

<p>Plots the arcs of CS-PCD whose vertices are the 1D points, <code>Xp</code>.
CS proximity regions are constructed with
expansion parameter <code class="reqn">t &gt; 0</code> and centrality parameter <code class="reqn">c \in (0,1)</code>
and the intervals are based on the
interval <code>int</code><code class="reqn">=(a,b)</code>
That is, data set <code>Xp</code>
constitutes the vertices of the digraph
and <code>int</code> determines the end points of the interval.
If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>For better visualization, a uniform jitter from <code class="reqn">U(-Jit,Jit)</code> (default for <code class="reqn">Jit=.1</code>) is added to
the <code class="reqn">y</code>-direction where <code>Jit</code> equals to the range of <code class="reqn">\{</code><code>Xp</code>, <code>int</code><code class="reqn">\}</code>
multiplied by <code>Jit</code> with default for <code class="reqn">Jit=.1</code>).
<code>center</code> is a logical argument, if <code>TRUE</code>, plot includes the center of the interval <code>int</code>
as a vertical line in the plot, else center of the interval is not plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCSarcs.int(
  Xp,
  int,
  t,
  c = 0.5,
  Jit = 0.1,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  center = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCSarcs.int_+3A_xp">Xp</code></td>
<td>
<p>A <code>vector</code> of 1D points constituting the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two 1D points constituting the end points of the interval.</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center of the interval
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_jit">Jit</code></td>
<td>
<p>A positive real number that determines the amount of jitter along the <code class="reqn">y</code>-axis, default=<code>0.1</code> and
<code>Xp</code> points are jittered according to <code class="reqn">U(-Jit,Jit)</code> distribution along the <code class="reqn">y</code>-axis where <code>Jit</code> equals to
the range of range of <code class="reqn">\{</code><code>Xp</code>, <code>int</code><code class="reqn">\}</code> multiplied by <code>Jit</code>).</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_xlab">xlab</code>, <code id="plotCSarcs.int_+3A_ylab">ylab</code></td>
<td>
<p>Titles of the <code class="reqn">x</code> and <code class="reqn">y</code> axes in the plot (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_xlim">xlim</code>, <code id="plotCSarcs.int_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_center">center</code></td>
<td>
<p>A logical argument, if <code>TRUE</code>, plot includes the center of the interval <code>int</code>
as a vertical line in the plot, else center of the interval is not plotted.</p>
</td></tr>
<tr><td><code id="plotCSarcs.int_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of CS-PCD whose vertices are the 1D data set <code>Xp</code> in which vertices are jittered
along <code class="reqn">y</code>-axis for better visualization.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCSarcs1D">plotCSarcs1D</a></code> and <code><a href="#topic+plotPEarcs.int">plotPEarcs.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

#n is number of X points
n&lt;-10;  #try also n&lt;-20;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(n,a-xf,b+xf)

Xlim=range(Xp,int)
Ylim=3*c(-1,1)

jit&lt;-.1
plotCSarcs.int(Xp,int,t=tau,c,jit,xlab="",ylab="",xlim=Xlim,ylim=Ylim)

set.seed(1)
plotCSarcs.int(Xp,int,t=1.5,c=.3,jit,xlab="",ylab="",center=TRUE)
set.seed(1)
plotCSarcs.int(Xp,int,t=2,c=.4,jit,xlab="",ylab="",center=TRUE)

</code></pre>

<hr>
<h2 id='plotCSarcs.tri'>The plot of the arcs of Central Similarity Proximity Catch Digraph (CS-PCD) for a
2D data set - one triangle case</h2><span id='topic+plotCSarcs.tri'></span>

<h3>Description</h3>

<p>Plots the arcs of CS-PCD whose vertices are the data points, <code>Xp</code>
and the triangle <code>tri</code>. CS proximity regions
are constructed with respect to the triangle <code>tri</code>
with expansion parameter <code class="reqn">t&gt;0</code>, i.e., arcs may exist only
for <code>Xp</code> points inside the triangle <code>tri</code>.
If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>Edge regions are based on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>; default
is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCSarcs.tri(
  Xp,
  tri,
  t,
  M = c(1, 1, 1),
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  edge.reg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCSarcs.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value, giving the aspect ratio <code class="reqn">y/x</code> (default is <code>NA</code>), see the official help page for <code>asp</code> by
typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_xlab">xlab</code>, <code id="plotCSarcs.tri_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_xlim">xlim</code>, <code id="plotCSarcs.tri_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_edge.reg">edge.reg</code></td>
<td>
<p>A logical argument to add edge regions to the plot, default is <code>edge.reg=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotCSarcs.tri_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of the CS-PCD whose vertices are the points in data set <code>Xp</code> and the triangle <code>tri</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCSarcs">plotCSarcs</a></code>, <code><a href="#topic+plotPEarcs.tri">plotPEarcs.tri</a></code> and <code><a href="#topic+plotASarcs.tri">plotASarcs.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

t&lt;-1.5  #try also t&lt;-2

plotCSarcs.tri(Xp,Tr,t,M,main="Arcs of CS-PCD with t=1.5",
xlab="",ylab="",edge.reg = TRUE)

# or try the default center
#plotCSarcs.tri(Xp,Tr,t,main="Arcs of CS-PCD with t=1.5",xlab="",ylab="",edge.reg = TRUE);
#M=(arcsCStri(Xp,Tr,r)$param)$c #the part "M=(arcsPEtri(Xp,Tr,r)$param)$cent" is optional,
#for the below annotation of the plot

#can add vertex labels and text to the figure (with edge regions)
txt&lt;-rbind(Tr,M)
xc&lt;-txt[,1]+c(-.02,.02,.02,.03)
yc&lt;-txt[,2]+c(.02,.02,.02,.03)
txt.str&lt;-c("A","B","C","M")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='plotCSarcs1D'>The plot of the arcs of Central Similarity Proximity Catch Digraphs
(CS-PCDs) for 1D data
(vertices jittered along <code class="reqn">y</code>-coordinate) - multiple interval case</h2><span id='topic+plotCSarcs1D'></span>

<h3>Description</h3>

<p>Plots the arcs of CS-PCD whose vertices are the 1D points, <code>Xp</code>.
CS proximity regions are constructed with
expansion parameter <code class="reqn">t&gt;0</code> and centrality parameter <code class="reqn">c \in (0,1)</code>
and the intervals are based on <code>Yp</code> points (i.e.
the intervalization is based on <code>Yp</code> points).
That is, data set <code>Xp</code>
constitutes the vertices of the digraph
and <code>Yp</code> determines the end points of the intervals.
If there are duplicates of <code>Yp</code> or <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>For better visualization, a uniform jitter from <code class="reqn">U(-Jit,Jit)</code>
(default for <code class="reqn">Jit=.1</code>) is added to
the <code class="reqn">y</code>-direction where <code>Jit</code> equals to
the range of <code>Xp</code> and <code>Yp</code> multiplied by <code>Jit</code> with default for <code class="reqn">Jit=.1</code>).
</p>
<p><code>centers</code> is a logical argument, if <code>TRUE</code>,
plot includes the centers of the intervals
as vertical lines in the plot,
else centers of the intervals are not plotted.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCSarcs1D(
  Xp,
  Yp,
  t,
  c = 0.5,
  Jit = 0.1,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  centers = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCSarcs1D_+3A_xp">Xp</code></td>
<td>
<p>A <code>vector</code> of 1D points constituting the vertices of the CS-PCD.</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_yp">Yp</code></td>
<td>
<p>A <code>vector</code> of 1D points constituting the end points of the intervals.</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_jit">Jit</code></td>
<td>
<p>A positive real number that determines the amount of jitter along the <code class="reqn">y</code>-axis, default=<code>0.1</code> and
<code>Xp</code> points are jittered according to <code class="reqn">U(-Jit,Jit)</code> distribution along the <code class="reqn">y</code>-axis where <code>Jit</code> equals to the range of <code>Xp</code> and <code>Yp</code> multiplied by
<code>Jit</code>).</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_xlab">xlab</code>, <code id="plotCSarcs1D_+3A_ylab">ylab</code></td>
<td>
<p>Titles of the <code class="reqn">x</code> and <code class="reqn">y</code> axes in the plot (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_xlim">xlim</code>, <code id="plotCSarcs1D_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_centers">centers</code></td>
<td>
<p>A logical argument, if <code>TRUE</code>, plot includes the centers of the intervals
as vertical lines in the plot, else centers of the intervals are not plotted.</p>
</td></tr>
<tr><td><code id="plotCSarcs1D_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of CS-PCD whose vertices are the 1D data set <code>Xp</code> in which vertices are jittered
along <code class="reqn">y</code>-axis for better visualization.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEarcs1D">plotPEarcs1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t&lt;-1.5
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xr&lt;-range(a,b)
xf&lt;-(xr[2]-xr[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

Xlim=range(Xp,Yp)
Ylim=c(-.2,.2)

jit&lt;-.1

plotCSarcs1D(Xp,Yp,t,c,jit,xlab="",ylab="",xlim=Xlim,ylim=Ylim)

set.seed(1)
plotCSarcs1D(Xp,Yp,t=1.5,c=.3,jit,main="t=1.5, c=.3",xlab="",ylab="",centers=TRUE)
set.seed(1)
plotCSarcs1D(Xp,Yp,t=2,c=.3,jit,main="t=2, c=.3",xlab="",ylab="",centers=TRUE)
set.seed(1)
plotCSarcs1D(Xp,Yp,t=1.5,c=.5,jit,main="t=1.5, c=.5",xlab="",ylab="",centers=TRUE)
set.seed(1)
plotCSarcs1D(Xp,Yp,t=2,c=.5,jit,main="t=2, c=.5",xlab="",ylab="",centers=TRUE)

</code></pre>

<hr>
<h2 id='plotCSregs'>The plot of the Central Similarity (CS) Proximity Regions for a 2D data set - multiple triangle case</h2><span id='topic+plotCSregs'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the Delaunay triangles based on <code>Yp</code> points which partition
the convex hull of <code>Yp</code> points and also plots the CS proximity regions
for <code>Xp</code> points and the Delaunay triangles based on <code>Yp</code> points.
</p>
<p>CS proximity regions are constructed with respect to the Delaunay triangles with the expansion parameter <code class="reqn">t&gt;0</code>.
</p>
<p>Edge regions in each triangle is based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of each Delaunay triangle
(default for <code class="reqn">M=(1,1,1)</code> which is the center of mass of the triangle).
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)) more on the CS proximity regions.
Also see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016)) for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCSregs(
  Xp,
  Yp,
  t,
  M = c(1, 1, 1),
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCSregs_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points for which CS proximity regions are constructed.</p>
</td></tr>
<tr><td><code id="plotCSregs_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="plotCSregs_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="plotCSregs_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code> or the circumcenter of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="plotCSregs_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value, giving the aspect ratio <code class="reqn">y/x</code> (default is <code>NA</code>), see the official help page for <code>asp</code> by
typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotCSregs_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotCSregs_+3A_xlab">xlab</code>, <code id="plotCSregs_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSregs_+3A_xlim">xlim</code>, <code id="plotCSregs_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSregs_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the <code>Xp</code> points, Delaunay triangles based on <code>Yp</code> and also the CS proximity regions
for <code>Xp</code> points inside the convex hull of <code>Yp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCSregs.tri">plotCSregs.tri</a></code>, <code><a href="#topic+plotASregs">plotASregs</a></code> and <code><a href="#topic+plotPEregs">plotPEregs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)
tau&lt;-1.5  #try also tau&lt;-2

plotCSregs(Xp,Yp,tau,M,xlab="",ylab="")


</code></pre>

<hr>
<h2 id='plotCSregs.int'>The plot of the Central Similarity (CS) Proximity Regions for a general interval
(vertices jittered along <code class="reqn">y</code>-coordinate) - one interval case</h2><span id='topic+plotCSregs.int'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the interval <code>int</code>
and also the CS proximity regions (which are also intervals).
CS proximity regions are constructed with expansion parameter <code class="reqn">t &gt; 0</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>For better visualization, a uniform jitter from <code class="reqn">U(-Jit,Jit)</code>
(default is <code class="reqn">Jit=.1</code>) times range of proximity
regions and <code>Xp</code>) is added to the <code class="reqn">y</code>-direction.
#' If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
<code>center</code> is a logical argument, if <code>TRUE</code>,
plot includes the
center of the interval as a vertical line in the plot,
else center of the interval is not plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCSregs.int(
  Xp,
  int,
  t,
  c = 0.5,
  Jit = 0.1,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  center = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCSregs.int_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points for which CS proximity regions are to be constructed.</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_jit">Jit</code></td>
<td>
<p>A positive real number that determines the amount of jitter along the <code class="reqn">y</code>-axis, default=<code>0.1</code> and
<code>Xp</code> points are jittered according to <code class="reqn">U(-Jit,Jit)</code> distribution along the <code class="reqn">y</code>-axis where <code>Jit</code> equals to the range of <code>Xp</code> and proximity region
intervals multiplied by <code>Jit</code>).</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_xlab">xlab</code>, <code id="plotCSregs.int_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_xlim">xlim</code>, <code id="plotCSregs.int_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges.</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_center">center</code></td>
<td>
<p>A logical argument, if <code>TRUE</code>, plot includes the center of the interval
as a vertical line in the plot, else center of the interval is not plotted.</p>
</td></tr>
<tr><td><code id="plotCSregs.int_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the CS proximity regions for 1D points in or outside the interval <code>int</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCSregs1D">plotCSregs1D</a></code>, <code><a href="#topic+plotCSregs">plotCSregs</a></code>, and <code><a href="#topic+plotPEregs.int">plotPEregs.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-.4
tau&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-10
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(n,a-xf,b+xf)  #try also Xp&lt;-runif(n,a-5,b+5)

plotCSregs.int(7,int,tau,c,xlab="x",ylab="")

plotCSregs.int(Xp,int,tau,c,xlab="x",ylab="")

plotCSregs.int(17,int,tau,c,xlab="x",ylab="")
plotCSregs.int(1,int,tau,c,xlab="x",ylab="")
plotCSregs.int(4,int,tau,c,xlab="x",ylab="")

plotCSregs.int(-7,int,tau,c,xlab="x",ylab="")

</code></pre>

<hr>
<h2 id='plotCSregs.tri'>The plot of the Central Similarity (CS) Proximity Regions for a 2D data set - one triangle case</h2><span id='topic+plotCSregs.tri'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the triangle <code>tri</code> and also the CS proximity regions which are also
triangular for points inside the triangle <code>tri</code> with edge regions are based on the center of mass CM.
</p>
<p>CS proximity regions are defined with respect to the triangle <code>tri</code>
with expansion parameter <code class="reqn">t&gt;0</code>, so CS proximity regions are defined only for points inside the
triangle <code>tri</code>.
</p>
<p>Edge regions are based on center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2007); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCSregs.tri(
  Xp,
  tri,
  t,
  M = c(1, 1, 1),
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  edge.reg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCSregs.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points for which CS proximity regions are constructed.</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code> i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value, giving the aspect ratio <code class="reqn">y/x</code> (default is <code>NA</code>),
see the official help page for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_xlab">xlab</code>, <code id="plotCSregs.tri_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_xlim">xlim</code>, <code id="plotCSregs.tri_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_edge.reg">edge.reg</code></td>
<td>
<p>A logical argument to add edge regions to the plot, default is <code>edge.reg=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotCSregs.tri_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the CS proximity regions for points inside the triangle <code>tri</code>
(and just the points outside <code>tri</code>)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2014).
&ldquo;Comparison of Relative Density of Two Random Geometric Digraph Families in Testing Spatial Clustering.&rdquo;
<em>TEST</em>, <b>23(1)</b>, 100-134.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCSregs">plotCSregs</a></code>, <code><a href="#topic+plotASregs.tri">plotASregs.tri</a></code> and <code><a href="#topic+plotPEregs.tri">plotPEregs.tri</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp0&lt;-runif.tri(n,Tr)$g
M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

t&lt;-.5  #try also t&lt;-2

plotCSregs.tri(Xp0,Tr,t,M,main="Proximity Regions for CS-PCD", xlab="",ylab="")

Xp = Xp0[1,]
plotCSregs.tri(Xp,Tr,t,M,main="CS Proximity Regions with t=.5", xlab="",ylab="",edge.reg=TRUE)

# or try the default center
plotCSregs.tri(Xp,Tr,t,main="CS Proximity Regions with t=.5", xlab="",ylab="",edge.reg=TRUE);
#M=(arcsCStri(Xp,Tr,r)$param)$c #the part "M=(arcsPEtri(Xp,Tr,r)$param)$cent" is optional,
#for the below annotation of the plot

#can add vertex labels and text to the figure (with edge regions)
txt&lt;-rbind(Tr,M)
xc&lt;-txt[,1]+c(-.02,.02,.02,.02)
yc&lt;-txt[,2]+c(.02,.02,.02,.03)
txt.str&lt;-c("A","B","C","M")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='plotCSregs1D'>The plot of the Central Similarity (CS) Proximity Regions
(vertices jittered along <code class="reqn">y</code>-coordinate)
- multiple interval case</h2><span id='topic+plotCSregs1D'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the intervals
based on <code>Yp</code> points and also the CS proximity regions
(which are also intervals).
If there are duplicates of <code>Yp</code> or <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>CS proximity region is constructed with expansion parameter <code class="reqn">t&gt;0</code> and
centrality parameter <code class="reqn">c \in (0,1)</code>.
For better visualization, a uniform jitter from <code class="reqn">U(-Jit,Jit)</code>
(default is <code class="reqn">Jit=.1</code>) times range of <code>Xp</code> and
<code>Yp</code> and the proximity regions (intervals)) is added to the
<code class="reqn">y</code>-direction.
</p>
<p><code>centers</code> is a logical argument, if <code>TRUE</code>,
plot includes the centers of the intervals as vertical lines in the plot,
else centers of the intervals are not plotted.
</p>
<p>See also (Ceyhan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCSregs1D(
  Xp,
  Yp,
  t,
  c = 0.5,
  Jit = 0.1,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  centers = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCSregs1D_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points for which CS proximity regions are plotted.</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points which constitute the end points of the intervals which
partition the real line.</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_t">t</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in CS proximity region.</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_jit">Jit</code></td>
<td>
<p>A positive real number that determines the amount of jitter along the <code class="reqn">y</code>-axis, default=<code>0.1</code> and
<code>Xp</code> points are jittered according to <code class="reqn">U(-Jit,Jit)</code> distribution along the <code class="reqn">y</code>-axis where <code>Jit</code> equals to the range of <code>Xp</code> and <code>Yp</code> and the
proximity regions (intervals) multiplied by <code>Jit</code>).</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_xlab">xlab</code>, <code id="plotCSregs1D_+3A_ylab">ylab</code></td>
<td>
<p>Titles of the <code class="reqn">x</code> and <code class="reqn">y</code> axes in the plot (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_xlim">xlim</code>, <code id="plotCSregs1D_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_centers">centers</code></td>
<td>
<p>A logical argument, if <code>TRUE</code>, plot includes the centers of the intervals
as vertical lines in the plot, else centers of the intervals are not plotted.</p>
</td></tr>
<tr><td><code id="plotCSregs1D_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the CS proximity regions for 1D points located in the middle or end-intervals
based on <code>Yp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCSregs.int">plotCSregs.int</a></code> and <code><a href="#topic+plotPEregs1D">plotPEregs1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10;

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xr&lt;-range(a,b)
xf&lt;-(xr[2]-xr[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

plotCSregs1D(Xp,Yp,t,c,xlab="",ylab="")

plotCSregs1D(Xp,Yp+10,t,c,xlab="",ylab="")

</code></pre>

<hr>
<h2 id='plotDelaunay.tri'>The scatterplot of points from one class and
plot of the Delaunay triangulation of the other class</h2><span id='topic+plotDelaunay.tri'></span>

<h3>Description</h3>

<p>Plots the scatter plot of <code>Xp</code> points together
with the Delaunay triangles based on the <code>Yp</code> points.
Both sets of points are of 2D.
</p>
<p>See (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDelaunay.tri(
  Xp,
  Yp,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDelaunay.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points whose scatterplot is to be plotted.</p>
</td></tr>
<tr><td><code id="plotDelaunay.tri_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="plotDelaunay.tri_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotDelaunay.tri_+3A_xlab">xlab</code>, <code id="plotDelaunay.tri_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotDelaunay.tri_+3A_xlim">xlim</code>, <code id="plotDelaunay.tri_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2,
giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both)</p>
</td></tr>
<tr><td><code id="plotDelaunay.tri_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scatterplot of <code>Xp</code> points
and the Delaunay triangulation of <code>Yp</code> points.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+plot.triSht">plot.triSht</a></code> in <code>interp</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

plotDelaunay.tri(Xp,Yp,xlab="",ylab="",main="X points and Delaunay Triangulation of Y points")


</code></pre>

<hr>
<h2 id='plotIntervals'>The plot of the subintervals based on <code>Yp</code> points
together with <code>Xp</code> points</h2><span id='topic+plotIntervals'></span>

<h3>Description</h3>

<p>Plots the <code>Xp</code> points
and the intervals based on <code>Yp</code> points.
If there are duplicates of <code>Yp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotIntervals(
  Xp,
  Yp,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotIntervals_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points whose scatter-plot is provided.</p>
</td></tr>
<tr><td><code id="plotIntervals_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points
which constitute the end points of the intervals which
partition the real line.</p>
</td></tr>
<tr><td><code id="plotIntervals_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotIntervals_+3A_xlab">xlab</code>, <code id="plotIntervals_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotIntervals_+3A_xlim">xlim</code>, <code id="plotIntervals_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2,
giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotIntervals_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the intervals based on <code>Yp</code> points
and also scatter plot of <code>Xp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEregs1D">plotPEregs1D</a></code> and <code><a href="#topic+plotDelaunay.tri">plotDelaunay.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a&lt;-0; b&lt;-10;

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-runif(nx,a,b)
Yp&lt;-runif(ny,a,b)

plotIntervals(Xp,Yp,xlab="",ylab="")


</code></pre>

<hr>
<h2 id='plotPEarcs'>The plot of the arcs of Proportional Edge Proximity Catch Digraph
(PE-PCD) for a 2D data set - multiple triangle case</h2><span id='topic+plotPEarcs'></span>

<h3>Description</h3>

<p>Plots the arcs of Proportional Edge Proximity Catch Digraph
(PE-PCD) whose vertices are the data
points in <code>Xp</code> in the multiple triangle case
and the Delaunay triangles based on <code>Yp</code> points.
If there are duplicates of  <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>PE proximity regions are defined
with respect to the Delaunay triangles based on <code>Yp</code> points
with expansion parameter <code class="reqn">r \ge 1</code>
and vertex regions in each triangle are
based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of each Delaunay triangle
or based on circumcenter of
each Delaunay triangle (default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of the triangle).
</p>
<p>Convex hull of <code>Yp</code> is partitioned by
the Delaunay triangles based on <code>Yp</code> points
(i.e., multiple triangles are the set of these Delaunay triangles
whose union constitutes the
convex hull of <code>Yp</code> points).
Loops are not allowed so arcs are only possible
for points inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011))
for more on the PE-PCDs.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEarcs(
  Xp,
  Yp,
  r,
  M = c(1, 1, 1),
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEarcs_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="plotPEarcs_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="plotPEarcs_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEarcs_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates
which serves as a center in the interior of each Delaunay
triangle or circumcenter of each Delaunay triangle
(for this, argument should be set as <code>M="CC"</code>),
default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of each triangle.</p>
</td></tr>
<tr><td><code id="plotPEarcs_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value,
giving the aspect ratio <code class="reqn">y/x</code> (default is <code>NA</code>),
see the official help page for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotPEarcs_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEarcs_+3A_xlab">xlab</code>, <code id="plotPEarcs_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEarcs_+3A_xlim">xlim</code>, <code id="plotPEarcs_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2,
giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEarcs_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of the PE-PCD
whose vertices are the points in data set <code>Xp</code> and the Delaunay
triangles based on <code>Yp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEarcs.tri">plotPEarcs.tri</a></code>, <code><a href="#topic+plotASarcs">plotASarcs</a></code>,
and <code><a href="#topic+plotCSarcs">plotCSarcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)

r&lt;-1.5  #try also r&lt;-2

plotPEarcs(Xp,Yp,r,M,xlab="",ylab="")


</code></pre>

<hr>
<h2 id='plotPEarcs.int'>The plot of the arcs of Proportional Edge Proximity Catch Digraphs
(PE-PCDs) for 1D data
(vertices jittered along <code class="reqn">y</code>-coordinate) - one interval case</h2><span id='topic+plotPEarcs.int'></span>

<h3>Description</h3>

<p>Plots the arcs of PE-PCD whose vertices are the 1D points, <code>Xp</code>.
PE proximity regions are constructed with
expansion parameter <code class="reqn">r \ge 1</code> and centrality parameter <code class="reqn">c \in (0,1)</code>
and the intervals are based on the interval <code>int</code><code class="reqn">=(a,b)</code>
That is, data set <code>Xp</code>
constitutes the vertices of the digraph
and <code>int</code> determines the end points of the interval.
If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>For better visualization, a uniform jitter from <code class="reqn">U(-Jit,Jit)</code>
(default for <code class="reqn">Jit=.1</code>) is added to
the <code class="reqn">y</code>-direction where <code>Jit</code> equals to
the range of <code class="reqn">\{</code><code>Xp</code>, <code>int</code><code class="reqn">\}</code>
multiplied by <code>Jit</code> with default for <code class="reqn">Jit=.1</code>).
<code>center</code> is a logical argument, if <code>TRUE</code>,
plot includes the center of the interval <code>int</code>
as a vertical line in the plot,
else center of the interval is not plotted.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEarcs.int(
  Xp,
  int,
  r,
  c = 0.5,
  Jit = 0.1,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  center = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEarcs.int_+3A_xp">Xp</code></td>
<td>
<p>A <code>vector</code> of 1D points constituting the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two 1D points constituting the end points of the interval.</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center of the interval
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_jit">Jit</code></td>
<td>
<p>A positive real number that determines the amount of jitter along the <code class="reqn">y</code>-axis, default=<code>0.1</code> and
<code>Xp</code> points are jittered according to <code class="reqn">U(-Jit,Jit)</code> distribution along the <code class="reqn">y</code>-axis where <code>Jit</code> equals to
the range of range of <code class="reqn">\{</code><code>Xp</code>, <code>int</code><code class="reqn">\}</code> multiplied by <code>Jit</code>).</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_xlab">xlab</code>, <code id="plotPEarcs.int_+3A_ylab">ylab</code></td>
<td>
<p>Titles of the <code class="reqn">x</code> and <code class="reqn">y</code> axes in the plot (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_xlim">xlim</code>, <code id="plotPEarcs.int_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_center">center</code></td>
<td>
<p>A logical argument, if <code>TRUE</code>, plot includes the center of the interval <code>int</code>
as a vertical line in the plot, else center of the interval is not plotted.</p>
</td></tr>
<tr><td><code id="plotPEarcs.int_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of PE-PCD whose vertices are the 1D data set <code>Xp</code> in which vertices are jittered
along <code class="reqn">y</code>-axis for better visualization.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEarcs1D">plotPEarcs1D</a></code> and <code><a href="#topic+plotCSarcs.int">plotCSarcs.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

#n is number of X points
n&lt;-10;  #try also n&lt;-20;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(n,a-xf,b+xf)

Xlim=range(Xp,int)
Ylim=.1*c(-1,1)

jit&lt;-.1
set.seed(1)
plotPEarcs.int(Xp,int,r=1.5,c=.3,jit,xlab="",ylab="",center=TRUE)
set.seed(1)
plotPEarcs.int(Xp,int,r=2,c=.3,jit,xlab="",ylab="",center=TRUE)


</code></pre>

<hr>
<h2 id='plotPEarcs.tri'>The plot of the arcs of Proportional Edge Proximity Catch Digraph
(PE-PCD) for a 2D data set - one triangle case</h2><span id='topic+plotPEarcs.tri'></span>

<h3>Description</h3>

<p>Plots the arcs of PE-PCD whose vertices are the data points, <code>Xp</code>
and the triangle <code>tri</code>.
PE proximity regions
are constructed with respect to the triangle <code>tri</code>
with expansion parameter <code class="reqn">r \ge 1</code>, i.e., arcs may exist only
for <code>Xp</code> points inside the triangle <code>tri</code>.
If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>Vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.
When the center is the circumcenter, <code>CC</code>,
the vertex regions are constructed based on the
orthogonal projections to the edges,
while with any interior center <code>M</code>,
the vertex regions are constructed using the extensions
of the lines combining vertices with <code>M</code>.
<code>M</code>-vertex regions are recommended spatial inference,
due to geometry invariance property of the arc density
and domination number the PE-PCDs based on uniform data.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEarcs.tri(
  Xp,
  tri,
  r,
  M = c(1, 1, 1),
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  vert.reg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEarcs.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value,
giving the aspect ratio <code class="reqn">y/x</code> (default is <code>NA</code>),
see the official help page for <code>asp</code> by
typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_xlab">xlab</code>, <code id="plotPEarcs.tri_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_xlim">xlim</code>, <code id="plotPEarcs.tri_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2,
giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_vert.reg">vert.reg</code></td>
<td>
<p>A logical argument to add vertex regions to the plot,
default is <code>vert.reg=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPEarcs.tri_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of the PE-PCD
whose vertices are the points in data set <code>Xp</code>
and the triangle <code>tri</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotASarcs.tri">plotASarcs.tri</a></code>, <code><a href="#topic+plotCSarcs.tri">plotCSarcs.tri</a></code>,
and <code><a href="#topic+plotPEarcs">plotPEarcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20

set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)
#try also M&lt;-c(1.6,1.0) or M&lt;-circumcenter.tri(Tr)
r&lt;-1.5  #try also r&lt;-2
plotPEarcs.tri(Xp,Tr,r,M,main="Arcs of PE-PCD with r = 1.5",
xlab="",ylab="",vert.reg = TRUE)

# or try the default center
#plotPEarcs.tri(Xp,Tr,r,main="Arcs of PE-PCD with r = 1.5",
#xlab="",ylab="",vert.reg = TRUE);
#M=(arcsPEtri(Xp,Tr,r)$param)$cent
#the part "M=(arcsPEtri(Xp,Tr,r)$param)$cent" is optional,
#for the below annotation of the plot

#can add vertex labels and text to the figure (with vertex regions)
ifelse(isTRUE(all.equal(M,circumcenter.tri(Tr))),
{Ds&lt;-rbind((B+C)/2,(A+C)/2,(A+B)/2); cent.name="CC"},
{Ds&lt;-prj.cent2edges(Tr,M); cent.name="M"})

txt&lt;-rbind(Tr,M,Ds)
xc&lt;-txt[,1]+c(-.02,.02,.02,.02,.04,-0.03,-.01)
yc&lt;-txt[,2]+c(.02,.02,.02,.07,.02,.04,-.06)
txt.str&lt;-c("A","B","C",cent.name,"D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='plotPEarcs1D'>The plot of the arcs of Proportional Edge Proximity Catch Digraphs (PE-PCDs)
for 1D data (vertices jittered along <code class="reqn">y</code>-coordinate) - multiple interval case</h2><span id='topic+plotPEarcs1D'></span>

<h3>Description</h3>

<p>Plots the arcs of PE-PCD whose vertices are the 1D points, <code>Xp</code>.
PE proximity regions are constructed with
expansion parameter <code class="reqn">r \ge 1</code> and centrality parameter <code class="reqn">c \in (0,1)</code>
and the intervals are based on <code>Yp</code> points (i.e.
the intervalization is based on <code>Yp</code> points).
That is, data set <code>Xp</code>
constitutes the vertices of the digraph and <code>Yp</code> determines the end points of the intervals.
If there are duplicates of <code>Yp</code> or <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>For better visualization,
a uniform jitter from <code class="reqn">U(-Jit,Jit)</code> (default for <code class="reqn">Jit=.1</code>) is added to
the <code class="reqn">y</code>-direction where <code>Jit</code> equals to the range of <code>Xp</code>
and <code>Yp</code> multiplied by <code>Jit</code> with default for <code class="reqn">Jit=.1</code>).
<code>centers</code> is a logical argument, if <code>TRUE</code>,
plot includes the centers of the intervals
as vertical lines in the plot,
else centers of the intervals are not plotted.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEarcs1D(
  Xp,
  Yp,
  r,
  c = 0.5,
  Jit = 0.1,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  centers = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEarcs1D_+3A_xp">Xp</code></td>
<td>
<p>A <code>vector</code> of 1D points constituting the vertices of the PE-PCD.</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_yp">Yp</code></td>
<td>
<p>A <code>vector</code> of 1D points constituting the end points of the intervals.</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_jit">Jit</code></td>
<td>
<p>A positive real number that determines the amount of jitter along the <code class="reqn">y</code>-axis, default=<code>0.1</code> and
<code>Xp</code> points are jittered according to <code class="reqn">U(-Jit,Jit)</code> distribution along the <code class="reqn">y</code>-axis
where <code>Jit</code> equals to the range of the union of <code>Xp</code> and <code>Yp</code> points multiplied by <code>Jit</code>).</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_xlab">xlab</code>, <code id="plotPEarcs1D_+3A_ylab">ylab</code></td>
<td>
<p>Titles of the <code class="reqn">x</code> and <code class="reqn">y</code> axes in the plot (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_xlim">xlim</code>, <code id="plotPEarcs1D_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_centers">centers</code></td>
<td>
<p>A logical argument, if <code>TRUE</code>, plot includes the centers of the intervals
as vertical lines in the plot, else centers of the intervals are not plotted.</p>
</td></tr>
<tr><td><code id="plotPEarcs1D_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the arcs of PE-PCD whose vertices are the 1D data set <code>Xp</code> in which vertices are jittered
along <code class="reqn">y</code>-axis for better visualization.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEarcs.int">plotPEarcs.int</a></code> and <code><a href="#topic+plotCSarcs1D">plotCSarcs1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

Xlim=range(Xp,Yp)
Ylim=.1*c(-1,1)

jit&lt;-.1

set.seed(1)
plotPEarcs1D(Xp,Yp,r=1.5,c=.3,jit,xlab="",ylab="",centers=TRUE)
set.seed(1)
plotPEarcs1D(Xp,Yp,r=2,c=.3,jit,xlab="",ylab="",centers=TRUE)


</code></pre>

<hr>
<h2 id='plotPEregs'>The plot of the Proportional Edge (PE) Proximity Regions
for a 2D data set - multiple triangle case</h2><span id='topic+plotPEregs'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the Delaunay triangles
based on <code>Yp</code> points which partition
the convex hull of <code>Yp</code> points and also plots the PE proximity regions
for <code>Xp</code> points and the Delaunay triangles based on <code>Yp</code> points.
</p>
<p>PE proximity regions are constructed
with respect to the Delaunay triangles with the expansion parameter
<code class="reqn">r \ge 1</code>.
</p>
<p>Vertex regions in each triangle is
based on the center <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of each Delaunay triangle
or based on circumcenter of
each Delaunay triangle (default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of the triangle).
</p>
<p>See (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011))
for more on the PE proximity regions.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEregs(
  Xp,
  Yp,
  r,
  M = c(1, 1, 1),
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEregs_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
for which PE proximity regions are constructed.</p>
</td></tr>
<tr><td><code id="plotPEregs_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
<tr><td><code id="plotPEregs_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs_+3A_m">M</code></td>
<td>
<p>A 3D point in barycentric coordinates
which serves as a center in the interior of each Delaunay
triangle or circumcenter of each Delaunay triangle
(for this, argument should be set as <code>M="CC"</code>),
default for <code class="reqn">M=(1,1,1)</code>
which is the center of mass of each triangle.</p>
</td></tr>
<tr><td><code id="plotPEregs_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value,
giving the aspect ratio <code class="reqn">y/x</code> (default is <code>NA</code>),
see the official help page for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotPEregs_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs_+3A_xlab">xlab</code>, <code id="plotPEregs_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default=<code>NULL</code> for both)</p>
</td></tr>
<tr><td><code id="plotPEregs_+3A_xlim">xlim</code>, <code id="plotPEregs_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2,
giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEregs_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the <code>Xp</code> points,
Delaunay triangles based on <code>Yp</code> points
and also the PE proximity regions
for <code>Xp</code> points inside the convex hull of <code>Yp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEregs.tri">plotPEregs.tri</a></code>, <code><a href="#topic+plotASregs">plotASregs</a></code>,
and <code><a href="#topic+plotCSregs">plotCSregs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),
runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-c(1,1,1)  #try also M&lt;-c(1,2,3)
r&lt;-1.5  #try also r&lt;-2

plotPEregs(Xp,Yp,r,M,xlab="",ylab="")


</code></pre>

<hr>
<h2 id='plotPEregs.int'>The plot of the Proportional Edge (PE) Proximity Regions for a general interval
(vertices jittered along <code class="reqn">y</code>-coordinate) - one interval case</h2><span id='topic+plotPEregs.int'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the interval <code>int</code>
and also the PE proximity regions (which are also intervals).
PE proximity regions are constructed with expansion parameter <code class="reqn">r \ge 1</code>
and centrality parameter <code class="reqn">c \in (0,1)</code>.
</p>
<p>For better visualization, a uniform jitter from <code class="reqn">U(-Jit,Jit)</code>
(default is <code class="reqn">Jit=.1</code>) times range of proximity
regions and <code>Xp</code>) is added to the <code class="reqn">y</code>-direction.
If there are duplicates of <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
<code>center</code> is a logical argument, if <code>TRUE</code>, plot includes the
center of the interval as a vertical line in the plot,
else center of the interval is not plotted.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEregs.int(
  Xp,
  int,
  r,
  c = 0.5,
  Jit = 0.1,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  center = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEregs.int_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points for which PE proximity regions are to be constructed.</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing
the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_jit">Jit</code></td>
<td>
<p>A positive real number that determines the amount of jitter along the <code class="reqn">y</code>-axis, default=<code>0.1</code> and
<code>Xp</code> points are jittered according to <code class="reqn">U(-Jit,Jit)</code> distribution along the <code class="reqn">y</code>-axis
where <code>Jit</code> equals to the range of the union of <code>Xp</code> and <code>Yp</code> points multiplied by <code>Jit</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_xlab">xlab</code>, <code id="plotPEregs.int_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_xlim">xlim</code>, <code id="plotPEregs.int_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges.</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_center">center</code></td>
<td>
<p>A logical argument, if <code>TRUE</code>, plot includes the center of the interval
as a vertical line in the plot, else center of the interval is not plotted.</p>
</td></tr>
<tr><td><code id="plotPEregs.int_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the PE proximity regions for 1D points in or outside the interval <code>int</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEregs1D">plotPEregs1D</a></code>, <code><a href="#topic+plotCSregs.int">plotCSregs.int</a></code>, and <code><a href="#topic+plotCSregs.int">plotCSregs.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
r&lt;-2
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

n&lt;-10
xf&lt;-(int[2]-int[1])*.1
Xp&lt;-runif(n,a-xf,b+xf)  #try also Xp&lt;-runif(n,a-5,b+5)
plotPEregs.int(Xp,int,r,c,xlab="x",ylab="")

plotPEregs.int(7,int,r,c,xlab="x",ylab="")


</code></pre>

<hr>
<h2 id='plotPEregs.std.tetra'>The plot of the Proportional Edge (PE) Proximity Regions for a 3D data set - standard
regular tetrahedron case</h2><span id='topic+plotPEregs.std.tetra'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the standard regular tetrahedron
<code class="reqn">T_h=T((0,0,0),(1,0,0),(1/2,\sqrt{3}/2,0),(1/2,\sqrt{3}/6,\sqrt{6}/3))</code> and also the PE proximity regions
for points in data set <code>Xp</code>.
</p>
<p>PE proximity regions are defined with respect to the standard regular tetrahedron <code class="reqn">T_h</code>
with expansion parameter <code class="reqn">r \ge 1</code>, so PE proximity regions are defined only for points inside <code class="reqn">T_h</code>.
</p>
<p>Vertex regions are based on circumcenter (which is equivalent to the center of mass for the standard
regular tetrahedron) of <code class="reqn">T_h</code>.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEregs.std.tetra(
  Xp,
  r,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEregs.std.tetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points for which PE proximity regions are constructed.</p>
</td></tr>
<tr><td><code id="plotPEregs.std.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs.std.tetra_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs.std.tetra_+3A_xlab">xlab</code>, <code id="plotPEregs.std.tetra_+3A_ylab">ylab</code>, <code id="plotPEregs.std.tetra_+3A_zlab">zlab</code></td>
<td>
<p>titles for the <code class="reqn">x</code>, <code class="reqn">y</code>, and <code class="reqn">z</code> axes, respectively (default=<code>NULL</code> for all).</p>
</td></tr>
<tr><td><code id="plotPEregs.std.tetra_+3A_xlim">xlim</code>, <code id="plotPEregs.std.tetra_+3A_ylim">ylim</code>, <code id="plotPEregs.std.tetra_+3A_zlim">zlim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>-, <code class="reqn">y</code>-, and <code class="reqn">z</code>-coordinate ranges
(default=<code>NULL</code> for all).</p>
</td></tr>
<tr><td><code id="plotPEregs.std.tetra_+3A_...">...</code></td>
<td>
<p>Additional <code>scatter3D</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the PE proximity regions for points inside the standard regular tetrahedron <code class="reqn">T_h</code>
(and just the points outside <code class="reqn">T_h</code>)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEregs">plotPEregs</a></code>, <code><a href="#topic+plotASregs.tri">plotASregs.tri</a></code>, <code><a href="#topic+plotASregs">plotASregs</a></code>,
<code><a href="#topic+plotCSregs.tri">plotCSregs.tri</a></code>, and <code><a href="#topic+plotCSregs">plotCSregs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
r&lt;-1.5

n&lt;-3  #try also n&lt;-20
Xp&lt;-runif.std.tetra(n)$g  #try also Xp[,1]&lt;-Xp[,1]+1

plotPEregs.std.tetra(Xp[1:3,],r)

P1&lt;-c(.1,.1,.1)
plotPEregs.std.tetra(rbind(P1,P1),r)


</code></pre>

<hr>
<h2 id='plotPEregs.tetra'>The plot of the Proportional Edge (PE) Proximity Regions for a 3D data set - one tetrahedron case</h2><span id='topic+plotPEregs.tetra'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the tetrahedron <code>th</code> and also the PE proximity regions  (which are also
tetrahedrons) for points inside the tetrahedron <code>th</code>.
</p>
<p>PE proximity regions are constructed with respect to
tetrahedron <code>th</code> with expansion parameter <code class="reqn">r \ge 1</code> and vertex regions are based on the center <code>M</code> which is
circumcenter (<code>"CC"</code>) or center of mass (<code>"CM"</code>) of <code>th</code> with default=<code>"CM"</code>, so PE proximity regions are defined
only for points inside the tetrahedron <code>th</code>.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEregs.tetra(
  Xp,
  th,
  r,
  M = "CM",
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEregs.tetra_+3A_xp">Xp</code></td>
<td>
<p>A set of 3D points for which PE proximity regions are constructed.</p>
</td></tr>
<tr><td><code id="plotPEregs.tetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row representing a vertex of the tetrahedron.</p>
</td></tr>
<tr><td><code id="plotPEregs.tetra_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs.tetra_+3A_m">M</code></td>
<td>
<p>The center to be used in the construction of the vertex regions in the tetrahedron, <code>th</code>.
Currently it only takes <code>"CC"</code> for circumcenter and <code>"CM"</code> for center of mass; default=<code>"CM"</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs.tetra_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs.tetra_+3A_xlab">xlab</code>, <code id="plotPEregs.tetra_+3A_ylab">ylab</code>, <code id="plotPEregs.tetra_+3A_zlab">zlab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code>, <code class="reqn">y</code>, and <code class="reqn">z</code> axes, respectively (default=<code>NULL</code> for all).</p>
</td></tr>
<tr><td><code id="plotPEregs.tetra_+3A_xlim">xlim</code>, <code id="plotPEregs.tetra_+3A_ylim">ylim</code>, <code id="plotPEregs.tetra_+3A_zlim">zlim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>-, <code class="reqn">y</code>-, and <code class="reqn">z</code>-coordinate ranges
(default=<code>NULL</code> for all).</p>
</td></tr>
<tr><td><code id="plotPEregs.tetra_+3A_...">...</code></td>
<td>
<p>Additional <code>scatter3D</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the PE proximity regions for points inside the tetrahedron <code>th</code>
(and just the points outside <code>th</code>)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEregs.std.tetra">plotPEregs.std.tetra</a></code>, <code><a href="#topic+plotPEregs.tri">plotPEregs.tri</a></code> and <code><a href="#topic+plotPEregs.int">plotPEregs.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
set.seed(1)
tetra&lt;-rbind(A,B,C,D)+matrix(runif(12,-.25,.25),ncol=3) #adding jitter to make it non-regular

n&lt;-5  #try also n&lt;-20
Xp&lt;-runif.tetra(n,tetra)$g  #try also Xp[,1]&lt;-Xp[,1]+1

M&lt;-"CM"  #try also M&lt;-"CC"
r&lt;-1.5

plotPEregs.tetra(Xp,tetra,r) #uses the default M="CM"
plotPEregs.tetra(Xp,tetra,r,M="CC")

plotPEregs.tetra(Xp[1,],tetra,r)  #uses the default M="CM"
plotPEregs.tetra(Xp[1,],tetra,r,M)


</code></pre>

<hr>
<h2 id='plotPEregs.tri'>The plot of the Proportional Edge (PE) Proximity Regions
for a 2D data set - one triangle case</h2><span id='topic+plotPEregs.tri'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the triangle <code>tri</code>
and also the PE proximity regions
for points in data set <code>Xp</code>.
</p>
<p>PE proximity regions are defined
with respect to the triangle <code>tri</code>
with expansion parameter <code class="reqn">r \ge 1</code>,
so PE proximity regions are defined only for points inside the
triangle <code>tri</code>.
</p>
<p>Vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
or based on the circumcenter of <code>tri</code>;
default is <code class="reqn">M=(1,1,1)</code>, i.e.,
the center of mass of <code>tri</code>.
When the center is the circumcenter, <code>CC</code>,
the vertex regions are constructed based on the
orthogonal projections to the edges,
while with any interior center <code>M</code>,
the vertex regions are constructed using the extensions
of the lines combining vertices with <code>M</code>.
<code>M</code>-vertex regions are recommended spatial inference,
due to geometry invariance property of the arc density
and domination number the PE-PCDs based on uniform data.
</p>
<p>See also (Ceyhan (2005); Ceyhan et al. (2006); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEregs.tri(
  Xp,
  tri,
  r,
  M = c(1, 1, 1),
  asp = NA,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  vert.reg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEregs.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
for which PE proximity regions are constructed.</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>
which may be entered as &quot;CC&quot; as well;
default is <code class="reqn">M=(1,1,1)</code>, i.e., the center of mass of <code>tri</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_asp">asp</code></td>
<td>
<p>A <code>numeric</code> value,
giving the aspect ratio <code class="reqn">y/x</code> (default is <code>NA</code>),
see the official help page for <code>asp</code> by typing &quot;<code>? asp</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_xlab">xlab</code>, <code id="plotPEregs.tri_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes,
respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_xlim">xlim</code>, <code id="plotPEregs.tri_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2,
giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_vert.reg">vert.reg</code></td>
<td>
<p>A logical argument to add vertex regions to the plot,
default is <code>vert.reg=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs.tri_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the PE proximity regions for points
inside the triangle <code>tri</code>
(and just the points outside <code>tri</code>)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEregs">plotPEregs</a></code>, <code><a href="#topic+plotASregs.tri">plotASregs.tri</a></code>,
and <code><a href="#topic+plotCSregs.tri">plotCSregs.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10

set.seed(1)
Xp0&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)
#try also M&lt;-c(1.6,1.0) or M = circumcenter.tri(Tr)
r&lt;-1.5  #try also r&lt;-2

plotPEregs.tri(Xp0,Tr,r,M)
Xp = Xp0[1,]
plotPEregs.tri(Xp,Tr,r,M)

plotPEregs.tri(Xp,Tr,r,M,
main="PE Proximity Regions with r = 1.5",
xlab="",ylab="",vert.reg = TRUE)

# or try the default center
#plotPEregs.tri(Xp,Tr,r,main="PE Proximity Regions with r = 1.5",xlab="",ylab="",vert.reg = TRUE);
#M=(arcsPEtri(Xp,Tr,r)$param)$c
#the part "M=(arcsPEtri(Xp,Tr,r)$param)$cent" is optional,
#for the below annotation of the plot

#can add vertex labels and text to the figure (with vertex regions)
ifelse(isTRUE(all.equal(M,circumcenter.tri(Tr))),
       {Ds&lt;-rbind((B+C)/2,(A+C)/2,(A+B)/2); cent.name="CC"},
       {Ds&lt;-prj.cent2edges(Tr,M); cent.name&lt;-"M"})

txt&lt;-rbind(Tr,M,Ds)
xc&lt;-txt[,1]+c(-.02,.02,.02,.02,.03,-0.03,-.01)
yc&lt;-txt[,2]+c(.02,.02,.02,.07,.02,.05,-.06)
txt.str&lt;-c("A","B","C",cent.name,"D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='plotPEregs1D'>The plot of the Proportional Edge (PE) Proximity Regions
(vertices jittered along <code class="reqn">y</code>-coordinate)
- multiple interval case</h2><span id='topic+plotPEregs1D'></span>

<h3>Description</h3>

<p>Plots the points in and outside of the intervals
based on <code>Yp</code> points and also the PE proximity regions
(i.e., intervals).
PE proximity region is constructed with expansion parameter <code class="reqn">r \ge 1</code> and
centrality parameter <code class="reqn">c \in (0,1)</code>.
If there are duplicates of <code>Yp</code> or <code>Xp</code> points,
only one point is retained for each duplicate value,
and a warning message is printed.
</p>
<p>For better visualization, a uniform jitter from <code class="reqn">U(-Jit,Jit)</code>
(default is <code class="reqn">Jit=.1</code>) times range of <code>Xp</code>
and <code>Yp</code> and the proximity regions (intervals)) is added to the
<code class="reqn">y</code>-direction.
</p>
<p><code>centers</code> is a logical argument, if <code>TRUE</code>,
plot includes the centers of the intervals as vertical lines in the plot,
else centers of the intervals are not plotted.
</p>
<p>See also (Ceyhan (2012)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPEregs1D(
  Xp,
  Yp,
  r,
  c = 0.5,
  Jit = 0.1,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  xlim = NULL,
  ylim = NULL,
  centers = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPEregs1D_+3A_xp">Xp</code></td>
<td>
<p>A set of 1D points for which PE proximity regions are plotted.</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_yp">Yp</code></td>
<td>
<p>A set of 1D points which constitute the end points of the intervals which
partition the real line.</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_r">r</code></td>
<td>
<p>A positive real number which serves as the expansion parameter in PE proximity region;
must be <code class="reqn">\ge 1</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code> parameterizing the center inside middle intervals
with the default <code>c=.5</code>.
For the interval, <code class="reqn">(a,b)</code>, the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_jit">Jit</code></td>
<td>
<p>A positive real number that determines the amount of jitter along the <code class="reqn">y</code>-axis, default=<code>0.1</code> and
<code>Xp</code> points are jittered according to <code class="reqn">U(-Jit,Jit)</code> distribution along the <code class="reqn">y</code>-axis
where <code>Jit</code> equals to the range of the union of <code>Xp</code> and <code>Yp</code> points multiplied by <code>Jit</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_main">main</code></td>
<td>
<p>An overall title for the plot (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_xlab">xlab</code>, <code id="plotPEregs1D_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the <code class="reqn">x</code> and <code class="reqn">y</code> axes, respectively (default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_xlim">xlim</code>, <code id="plotPEregs1D_+3A_ylim">ylim</code></td>
<td>
<p>Two <code>numeric</code> vectors of length 2, giving the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinate ranges
(default=<code>NULL</code> for both).</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_centers">centers</code></td>
<td>
<p>A logical argument, if <code>TRUE</code>, plot includes the centers of the intervals
as vertical lines in the plot, else centers of the intervals are not plotted (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plotPEregs1D_+3A_...">...</code></td>
<td>
<p>Additional <code>plot</code> parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of the PE proximity regions for 1D points located in the middle or end-intervals
based on <code>Yp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPEregs1D">plotPEregs1D</a></code>, <code><a href="#topic+plotCSregs.int">plotCSregs.int</a></code>, and <code><a href="#topic+plotCSregs1D">plotCSregs1D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r&lt;-2
c&lt;-.4
a&lt;-0; b&lt;-10; int&lt;-c(a,b);

#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-15; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
xf&lt;-(int[2]-int[1])*.1

Xp&lt;-runif(nx,a-xf,b+xf)
Yp&lt;-runif(ny,a,b)

plotPEregs1D(Xp,Yp,r,c,xlab="x",ylab="")


</code></pre>

<hr>
<h2 id='print.Extrema'>Print a <code>Extrema</code> <code>object</code></h2><span id='topic+print.Extrema'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code>
of class <code>"Extrema"</code>
and also the <code>type</code>
(i.e. a brief description) of the extrema).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Extrema'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Extrema_+3A_x">x</code></td>
<td>
<p>A <code>Extrema</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.Extrema_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Extrema"</code>
and also the <code>type</code>
(i.e. a brief description) of the extrema).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Extrema">summary.Extrema</a></code>,
<code><a href="#topic+print.summary.Extrema">print.summary.Extrema</a></code>,
and <code><a href="#topic+plot.Extrema">plot.Extrema</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10
Xp&lt;-runif.std.tri(n)$gen.points
Ext&lt;-cl2edges.std.tri(Xp)
Ext
print(Ext)

typeof(Ext)
attributes(Ext)


</code></pre>

<hr>
<h2 id='print.Lines'>Print a <code>Lines</code> <code>object</code></h2><span id='topic+print.Lines'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code>
of class <code>"Lines"</code>
and also the <code>coefficients</code> of the line
(in the form: <code>y = slope * x + intercept</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lines'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Lines_+3A_x">x</code></td>
<td>
<p>A <code>Lines</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.Lines_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Lines"</code>
and the <code>coefficients</code> of the line
(in the form: <code>y = slope * x + intercept</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Lines">summary.Lines</a></code>, <code><a href="#topic+print.summary.Lines">print.summary.Lines</a></code>,
and <code><a href="#topic+plot.Lines">plot.Lines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-c(-1.22,-2.33); B&lt;-c(2.55,3.75)
xr&lt;-range(A,B);
xf&lt;-(xr[2]-xr[1])*.1 #how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=3) #try also l=10, 20 or 100

lnAB&lt;-Line(A,B,x)
lnAB
print(lnAB)

typeof(lnAB)
attributes(lnAB)

</code></pre>

<hr>
<h2 id='print.Lines3D'>Print a <code>Lines3D</code> <code>object</code></h2><span id='topic+print.Lines3D'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code>
of class <code>"Lines3D"</code>,
the <code>coefficients</code> of the line
(in the form: <code>x=x0 + A*t</code>, <code>y=y0 + B*t</code>,
and <code>z=z0 + C*t</code>),
and the initial point together with the direction vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lines3D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Lines3D_+3A_x">x</code></td>
<td>
<p>A <code>Lines3D</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.Lines3D_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Lines3D"</code>,
the <code>coefficients</code> of the line
(in the form: <code>x=x0 + A*t</code>, <code>y=y0 + B*t</code>,
and <code>z=z0 + C*t</code>),
and the initial point together with the direction vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Lines3D">summary.Lines3D</a></code>,
<code><a href="#topic+print.summary.Lines3D">print.summary.Lines3D</a></code>,
and <code><a href="#topic+plot.Lines3D">plot.Lines3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(1,10,3); Q&lt;-c(1,1,3);
vecs&lt;-rbind(P,Q)
Line3D(P,Q,.1)
Line3D(P,Q,.1,dir.vec=FALSE)

tr&lt;-range(vecs);
tf&lt;-(tr[2]-tr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
tsq&lt;-seq(-tf*10-tf,tf*10+tf,l=3) #try also l=10, 20 or 100

lnPQ3D&lt;-Line3D(P,Q,tsq)
lnPQ3D
print(lnPQ3D)

typeof(lnPQ3D)
attributes(lnPQ3D)


</code></pre>

<hr>
<h2 id='print.NumArcs'>Print a <code>NumArcs</code> <code>object</code></h2><span id='topic+print.NumArcs'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code>
of class <code>"NumArcs"</code>
and also the <code>desc</code> (i.e. a brief description) of the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NumArcs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.NumArcs_+3A_x">x</code></td>
<td>
<p>A <code>NumArcs</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.NumArcs_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"NumArcs"</code>
and also the <code>desc</code> (i.e. a brief description)
of the output: number of arcs in the proximity catch digraph (PCD) and
related quantities in the induced subdigraphs for points in the Delaunay cells.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.NumArcs">summary.NumArcs</a></code>, <code><a href="#topic+print.summary.NumArcs">print.summary.NumArcs</a></code>,
and <code><a href="#topic+plot.NumArcs">plot.NumArcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-15; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx),runif(nx))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

M&lt;-"CC"  #try also M&lt;-c(1,1,1)

Narcs&lt;-num.arcsAS(Xp,Yp,M)
Narcs
print(Narcs)

typeof(Narcs)
attributes(Narcs)


</code></pre>

<hr>
<h2 id='print.Patterns'>Print a <code>Patterns</code> <code>object</code></h2><span id='topic+print.Patterns'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code>
of class <code>"Patterns"</code>
and also the <code>type</code> (or description) of the pattern).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Patterns'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Patterns_+3A_x">x</code></td>
<td>
<p>A <code>Patterns</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.Patterns_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Patterns"</code>
and also the <code>type</code> (or description) of the pattern).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Patterns">summary.Patterns</a></code>,
<code><a href="#topic+print.summary.Patterns">print.summary.Patterns</a></code>,
and <code><a href="#topic+plot.Patterns">plot.Patterns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-10; #try also 20, 100, and 1000
ny&lt;-5; #try also 1
e&lt;-.15;
Y&lt;-cbind(runif(ny),runif(ny))
#with default bounding box (i.e., unit square)

Xdt&lt;-rseg.circular(nx,Y,e)
Xdt
print(Xdt)

typeof(Xdt)
attributes(Xdt)


</code></pre>

<hr>
<h2 id='print.PCDs'>Print a <code>PCDs</code> <code>object</code></h2><span id='topic+print.PCDs'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code>
of class <code>"PCDs"</code>
and also the <code>type</code> (i.e. a brief description)
of the proximity catch digraph (PCD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCDs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PCDs_+3A_x">x</code></td>
<td>
<p>A <code>PCDs</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.PCDs_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"PCDs"</code>
and also the <code>type</code> (i.e. a brief description)
of the proximity catch digraph (PCD).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.PCDs">summary.PCDs</a></code>,
<code><a href="#topic+print.summary.PCDs">print.summary.PCDs</a></code>,
and <code><a href="#topic+plot.PCDs">plot.PCDs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10
Xp&lt;-runif.tri(n,Tr)$g
M&lt;-as.numeric(runif.tri(1,Tr)$g)
Arcs&lt;-arcsAStri(Xp,Tr,M)
Arcs
print(Arcs)

typeof(Arcs)
attributes(Arcs)


</code></pre>

<hr>
<h2 id='print.Planes'>Print a <code>Planes</code> <code>object</code></h2><span id='topic+print.Planes'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code>
of class <code>"Planes"</code>
and also the <code>coefficients</code> of the plane
(in the form: <code>z = A*x + B*y + C</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Planes'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Planes_+3A_x">x</code></td>
<td>
<p>A <code>Planes</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.Planes_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Planes"</code>
and the <code>coefficients</code> of the plane
(in the form: <code>z = A*x + B*y + C</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Planes">summary.Planes</a></code>,
<code><a href="#topic+print.summary.Planes">print.summary.Planes</a></code>,
and <code><a href="#topic+plot.Planes">plot.Planes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(1,10,3); Q&lt;-c(1,1,3); C&lt;-c(3,9,12)
pts&lt;-rbind(P,Q,C)

xr&lt;-range(pts[,1]); yr&lt;-range(pts[,2])
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
yf&lt;-(yr[2]-yr[1])*.1
#how far to go at the lower and upper ends in the y-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5) #try also l=10, 20 or 100
y&lt;-seq(yr[1]-yf,yr[2]+yf,l=5) #try also l=10, 20 or 100

plPQC&lt;-Plane(P,Q,C,x,y)
plPQC
print(plPQC)

typeof(plPQC)
attributes(plPQC)


</code></pre>

<hr>
<h2 id='print.summary.Extrema'>Print a summary of a <code>Extrema</code> <code>object</code></h2><span id='topic+print.summary.Extrema'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.Extrema'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.Extrema_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.Extrema"</code>,
generated by <code>summary.Extrema</code>.</p>
</td></tr>
<tr><td><code id="print.summary.Extrema_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Extrema">print.Extrema</a></code>,
<code><a href="#topic+summary.Extrema">summary.Extrema</a></code>,
and <code><a href="#topic+plot.Extrema">plot.Extrema</a></code>
</p>

<hr>
<h2 id='print.summary.Lines'>Print a summary of a <code>Lines</code> <code>object</code></h2><span id='topic+print.summary.Lines'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.Lines'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.Lines_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.Lines"</code>,
generated by <code>summary.Lines</code>.</p>
</td></tr>
<tr><td><code id="print.summary.Lines_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Lines">print.Lines</a></code>, <code><a href="#topic+summary.Lines">summary.Lines</a></code>,
and <code><a href="#topic+plot.Lines">plot.Lines</a></code>
</p>

<hr>
<h2 id='print.summary.Lines3D'>Print a summary of a <code>Lines3D</code> <code>object</code></h2><span id='topic+print.summary.Lines3D'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.Lines3D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.Lines3D_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.Lines3D"</code>,
generated by <code>summary.Lines3D</code>.</p>
</td></tr>
<tr><td><code id="print.summary.Lines3D_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Lines3D">print.Lines3D</a></code>,
<code><a href="#topic+summary.Lines3D">summary.Lines3D</a></code>,
and <code><a href="#topic+plot.Lines3D">plot.Lines3D</a></code>
</p>

<hr>
<h2 id='print.summary.NumArcs'>Print a summary of a <code>NumArcs</code> <code>object</code></h2><span id='topic+print.summary.NumArcs'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.NumArcs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.NumArcs_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.NumArcs"</code>, generated by <code>summary.NumArcs</code>.</p>
</td></tr>
<tr><td><code id="print.summary.NumArcs_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.NumArcs">print.NumArcs</a></code>, <code><a href="#topic+summary.NumArcs">summary.NumArcs</a></code>,
and <code><a href="#topic+plot.NumArcs">plot.NumArcs</a></code>
</p>

<hr>
<h2 id='print.summary.Patterns'>Print a summary of a <code>Patterns</code> <code>object</code></h2><span id='topic+print.summary.Patterns'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.Patterns'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.Patterns_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.Patterns"</code>,
generated by <code>summary.Patterns</code>.</p>
</td></tr>
<tr><td><code id="print.summary.Patterns_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Patterns">print.Patterns</a></code>,
<code><a href="#topic+summary.Patterns">summary.Patterns</a></code>,
and <code><a href="#topic+plot.Patterns">plot.Patterns</a></code>
</p>

<hr>
<h2 id='print.summary.PCDs'>Print a summary of a <code>PCDs</code> <code>object</code></h2><span id='topic+print.summary.PCDs'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.PCDs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.PCDs_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.PCDs"</code>, generated by <code>summary.PCDs</code>.</p>
</td></tr>
<tr><td><code id="print.summary.PCDs_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.PCDs">print.PCDs</a></code>,
<code><a href="#topic+summary.PCDs">summary.PCDs</a></code>,
and <code><a href="#topic+plot.PCDs">plot.PCDs</a></code>
</p>

<hr>
<h2 id='print.summary.Planes'>Print a summary of a <code>Planes</code> <code>object</code></h2><span id='topic+print.summary.Planes'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.Planes'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.Planes_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.Planes"</code>,
generated by <code>summary.Planes</code>.</p>
</td></tr>
<tr><td><code id="print.summary.Planes_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Planes">print.Planes</a></code>,
<code><a href="#topic+summary.Planes">summary.Planes</a></code>,
and <code><a href="#topic+plot.Planes">plot.Planes</a></code>
</p>

<hr>
<h2 id='print.summary.TriLines'>Print a summary of a <code>TriLines</code> <code>object</code></h2><span id='topic+print.summary.TriLines'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.TriLines'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.TriLines_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.TriLines"</code>,
generated by <code>summary.TriLines</code>.</p>
</td></tr>
<tr><td><code id="print.summary.TriLines_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.TriLines">print.TriLines</a></code>,
<code><a href="#topic+summary.TriLines">summary.TriLines</a></code>,
and <code><a href="#topic+plot.TriLines">plot.TriLines</a></code>
</p>

<hr>
<h2 id='print.summary.Uniform'>Print a summary of a <code>Uniform</code> <code>object</code></h2><span id='topic+print.summary.Uniform'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.Uniform'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.Uniform_+3A_x">x</code></td>
<td>
<p>An <code>object</code> of class <code>"summary.Uniform"</code>,
generated by <code>summary.Uniform</code>.</p>
</td></tr>
<tr><td><code id="print.summary.Uniform_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Uniform">print.Uniform</a></code>,
<code><a href="#topic+summary.Uniform">summary.Uniform</a></code>,
and <code><a href="#topic+plot.Uniform">plot.Uniform</a></code>
</p>

<hr>
<h2 id='print.TriLines'>Print a <code>TriLines</code> <code>object</code></h2><span id='topic+print.TriLines'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code>
of class <code>"TriLines"</code>
and also the <code>coefficients</code> of the line
(in the form: <code>y = slope * x + intercept</code>),
and the vertices of the triangle
with respect to which the line is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TriLines'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TriLines_+3A_x">x</code></td>
<td>
<p>A <code>TriLines</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.TriLines_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"TriLines"</code> ,
the <code>coefficients</code> of the line
(in the form: <code>y = slope * x + intercept</code>),
and the vertices of the triangle
with respect to which the line is defined.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.TriLines">summary.TriLines</a></code>,
<code><a href="#topic+print.summary.TriLines">print.summary.TriLines</a></code>,
and <code><a href="#topic+plot.TriLines">plot.TriLines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
xfence&lt;-abs(A[1]-B[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,l=3)

lnACM&lt;-lineA2CMinTe(x)
lnACM
print(lnACM)

typeof(lnACM)
attributes(lnACM)


</code></pre>

<hr>
<h2 id='print.Uniform'>Print a <code>Uniform</code> <code>object</code></h2><span id='topic+print.Uniform'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the <code>object</code> of class <code>"Uniform"</code>
and also the <code>type</code>
(i.e. a brief description) of the uniform distribution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Uniform'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Uniform_+3A_x">x</code></td>
<td>
<p>A <code>Uniform</code> <code>object</code>.</p>
</td></tr>
<tr><td><code id="print.Uniform_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method <code>'print'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Uniform"</code>
and also the <code>type</code>
(i.e. a brief description) of the uniform distribution).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Uniform">summary.Uniform</a></code>,
<code><a href="#topic+print.summary.Uniform">print.summary.Uniform</a></code>,
and <code><a href="#topic+plot.Uniform">plot.Uniform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10 #try also 20, 100, and 1000
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C)

Xdt&lt;-runif.tri(n,Tr)
Xdt
print(Xdt)

typeof(Xdt)
attributes(Xdt)


</code></pre>

<hr>
<h2 id='prj.cent2edges'>Projections of a point inside a triangle to its edges</h2><span id='topic+prj.cent2edges'></span>

<h3>Description</h3>

<p>Returns the projections from a general center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in
barycentric coordinates in the interior of a triangle to the edges
on the extension of the lines joining
<code>M</code> to the vertices (see the examples for an illustration).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prj.cent2edges(tri, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prj.cent2edges_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="prj.cent2edges_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three projection points (stacked row-wise)
from a general center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of a triangle to the edges on
the extension of the lines joining <code>M</code> to the vertices;
row <code class="reqn">i</code> is the projection  point into edge <code class="reqn">i</code>, for <code class="reqn">i=1,2,3</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prj.cent2edges.basic.tri">prj.cent2edges.basic.tri</a></code> and <code><a href="#topic+prj.nondegPEcent2edges">prj.nondegPEcent2edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

Ds&lt;-prj.cent2edges(Tr,M)  #try also prj.cent2edges(Tr,M=c(1,1))
Ds

Xlim&lt;-range(Tr[,1])
Ylim&lt;-range(Tr[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

plot(Tr,pch=".",xlab="",ylab="",
main="Projection of Center M on the edges of a triangle",axes=TRUE,
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]
yc&lt;-Tr[,2]
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(-.02,.04,-.04,-.02)
yc&lt;-txt[,2]+c(-.02,.04,.04,-.06)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='prj.cent2edges.basic.tri'>Projections of a point inside the standard basic triangle form
to its edges</h2><span id='topic+prj.cent2edges.basic.tri'></span>

<h3>Description</h3>

<p>Returns the projections
from a general center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in
barycentric coordinates
in the interior of the standard basic triangle form
<code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
to the edges on the extension of the lines joining <code>M</code>
to the vertices (see the examples for an illustration).
In the standard basic triangle form <code class="reqn">T_b</code>,
<code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle form
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle. Hence, standard basic triangle form is useful
for simulation studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prj.cent2edges.basic.tri(c1, c2, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prj.cent2edges.basic.tri_+3A_c1">c1</code>, <code id="prj.cent2edges.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle form
adjacent to the shorter edges; <code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="prj.cent2edges.basic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard basic triangle form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three projection points (stacked row-wise)
from a general center <code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of a standard basic triangle form to the edges on
the extension of the lines joining <code>M</code> to the vertices;
row <code class="reqn">i</code> is the projection  point into edge <code class="reqn">i</code>, for <code class="reqn">i=1,2,3</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prj.cent2edges">prj.cent2edges</a></code> and <code><a href="#topic+prj.nondegPEcent2edges">prj.nondegPEcent2edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C);

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.2)

Ds&lt;-prj.cent2edges.basic.tri(c1,c2,M)
Ds

Xlim&lt;-range(Tb[,1])
Ylim&lt;-range(Tb[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tb)}
#need to run this when M is given in barycentric coordinates

plot(Tb,pch=".",xlab="",ylab="",axes=TRUE,
xlim=Xlim+xd*c(-.1,.1),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
L&lt;-rbind(M,M,M); R&lt;-Tb
segments(L[,1], L[,2], R[,1], R[,2], lty = 3,col=2)

xc&lt;-Tb[,1]+c(-.04,.05,.04)
yc&lt;-Tb[,2]+c(.02,.02,.03)
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(-.02,.03,-.03,0)
yc&lt;-txt[,2]+c(-.02,.02,.02,-.03)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='prj.nondegPEcent2edges'>Projections of Centers for non-degenerate asymptotic distribution of
domination number of Proportional Edge Proximity Catch Digraphs
(PE-PCDs) to its edges</h2><span id='topic+prj.nondegPEcent2edges'></span>

<h3>Description</h3>

<p>Returns the projections
from center <code>cent</code> to the edges on the extension of the lines
joining <code>cent</code> to the vertices
in the triangle, <code>tri</code>. Here M is one of the three centers
which gives nondegenerate asymptotic distribution
of the domination number of PE-PCD for uniform data in <code>tri</code>
for a given expansion parameter <code>r</code> in <code class="reqn">(1,1.5]</code>.
The center label <code>cent</code> values <code>1,2,3</code> correspond
to the vertices <code class="reqn">M_1</code>, <code class="reqn">M_2</code>,
and <code class="reqn">M_3</code> (i.e., row numbers in the
output of <code>center.nondegPE(tri,r)</code>); default for <code>cent</code> is 1.
<code>cent</code> becomes center of mass <code class="reqn">CM</code> for <code class="reqn">r=1.5</code>.
</p>
<p>See also (Ceyhan (2005); Ceyhan and Priebe (2007); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prj.nondegPEcent2edges(tri, r, cent = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prj.nondegPEcent2edges_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="prj.nondegPEcent2edges_+3A_r">r</code></td>
<td>
<p>A positive real number which serves
as the expansion parameter in PE proximity region;
must be in <code class="reqn">(1,1.5]</code> for this function.</p>
</td></tr>
<tr><td><code id="prj.nondegPEcent2edges_+3A_cent">cent</code></td>
<td>
<p>Index of the center (as <code class="reqn">1,2,3</code>
corresponding to <code class="reqn">M_1,\,M_2,\,M_3</code>)
which gives nondegenerate asymptotic
distribution of the domination number of PE-PCD
for uniform data in <code>tri</code> for expansion parameter <code>r</code>
in <code class="reqn">(1,1.5]</code>;
default <code>cent=1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three projection points (stacked row-wise)
from one of the centers (as <code class="reqn">1,2,3</code> corresponding to
<code class="reqn">M_1,\,M_2,\,M_3</code>)
which gives nondegenerate asymptotic distribution of
the domination number of PE-PCD for
uniform data in <code>tri</code> for expansion parameter <code>r</code> in <code class="reqn">(1,1.5]</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE (2007).
&ldquo;On the Distribution of the Domination Number of a New Family of Parametrized Random Digraphs.&rdquo;
<em>Model Assisted Statistics and Applications</em>, <b>1(4)</b>, 231-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prj.cent2edges.basic.tri">prj.cent2edges.basic.tri</a></code> and <code><a href="#topic+prj.cent2edges">prj.cent2edges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
r&lt;-1.35

prj.nondegPEcent2edges(Tr,r,cent=2)

Ms&lt;-center.nondegPE(Tr,r)
M1=Ms[1,]

Ds&lt;-prj.nondegPEcent2edges(Tr,r,cent=1)

Xlim&lt;-range(Tr[,1])
Ylim&lt;-range(Tr[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",
main="Projections from a non-degeneracy center\n to the edges of the triangle",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Ms,pch=".",col=1)
polygon(Ms,lty = 2)

xc&lt;-Tr[,1]+c(-.02,.03,.02)
yc&lt;-Tr[,2]+c(-.02,.04,.04)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)

txt&lt;-Ms
xc&lt;-txt[,1]+c(-.02,.04,-.04)
yc&lt;-txt[,2]+c(-.02,.04,.04)
txt.str&lt;-c("M1","M2","M3")
text(xc,yc,txt.str)

points(Ds,pch=4,col=2)
L&lt;-rbind(M1,M1,M1); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2,lwd=2,col=4)
txt&lt;-Ds
xc&lt;-txt[,1]+c(-.02,.04,-.04)
yc&lt;-txt[,2]+c(-.02,.04,.04)
txt.str&lt;-c("D1","D2","D3")
text(xc,yc,txt.str)

prj.nondegPEcent2edges(Tr,r,cent=3)
#gives an error message if center index, cent, is different from 1, 2 or 3
prj.nondegPEcent2edges(Tr,r=1.49,cent=2)
#gives an error message if r&gt;1.5


</code></pre>

<hr>
<h2 id='radii'>The radii of points from one class with respect to points
from the other class</h2><span id='topic+radii'></span>

<h3>Description</h3>

<p>Returns the radii of the balls centered at <code>x</code> points
where radius of an <code>x</code> point equals to the minimum distance
to <code>y</code> points (i.e., distance to the closest <code>y</code> point).
That is, for each <code>x</code> point <code class="reqn">radius= \min_{y \in Y}(d(x,y))</code>.
<code>x</code> and <code>y</code> points must be of the same dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radii(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radii_+3A_x">x</code></td>
<td>
<p>A set of <code class="reqn">d</code>-dimensional points
for which the radii are computed. Radius of an <code>x</code> point equals to the
distance to the closest <code>y</code> point.</p>
</td></tr>
<tr><td><code id="radii_+3A_y">y</code></td>
<td>
<p>A set of <code class="reqn">d</code>-dimensional points
representing the reference points for the balls. That is, radius
of an <code>x</code> point is defined
as the minimum distance to the <code>y</code> points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>rad</code></td>
<td>
<p>A <code>vector</code> whose entries are the radius values
for the <code>x</code> points. Radius of an <code>x</code> point equals to
the distance to the closest <code>y</code> point</p>
</td></tr>
<tr><td><code>index.of.clYp</code></td>
<td>
<p>A <code>vector</code> of indices of
the closest <code>y</code> points to the <code>x</code> points.
The <code class="reqn">i</code>-th entry in this
<code>vector</code> is the index of the closest <code>y</code> point
to <code class="reqn">i</code>-th <code>x</code> point.</p>
</td></tr>
<tr><td><code>closest.Yp</code></td>
<td>
<p>A <code>vector</code> of the closest <code>y</code> points
to the <code>x</code> points. The <code class="reqn">i</code>-th entry in this
<code>vector</code> or <code class="reqn">i</code>-th row in the matrix is the closest <code>y</code> point
to <code class="reqn">i</code>-th <code>x</code> point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radius">radius</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-10
ny&lt;-5
X&lt;-cbind(runif(nx),runif(nx))
Y&lt;-cbind(runif(ny),runif(ny))
Rad&lt;-radii(X,Y)
Rad
rd&lt;-Rad$rad

Xlim&lt;-range(X[,1]-rd,X[,1]+rd,Y[,1])
Ylim&lt;-range(X[,2]-rd,X[,2]+rd,Y[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(rbind(Y),asp=1,pch=16,col=2,xlab="",ylab="",
main="Circles Centered at Class X Points with \n Radius Equal to the Distance to Closest Y Point",
axes=TRUE, xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(rbind(X))
interp::circles(X[,1],X[,2],Rad$rad,lty=1,lwd=1,col=4)

#For 1D data
nx&lt;-10
ny&lt;-5
Xm&lt;-as.matrix(X)
Ym&lt;-as.matrix(Y)
radii(Xm,Ym)  #this works as Xm and Ym are treated as 1D data sets
#but will give error if radii(X,Y) is used
#as X and Y are treated as vectors (i.e., points)

#For 3D data
nx&lt;-10
ny&lt;-5
X&lt;-cbind(runif(nx),runif(nx),runif(nx))
Y&lt;-cbind(runif(ny),runif(ny),runif(ny))
radii(X,Y)


</code></pre>

<hr>
<h2 id='radius'>The radius of a point from one class with respect
to points from the other class</h2><span id='topic+radius'></span>

<h3>Description</h3>

<p>Returns the radius for the ball centered
at point <code>p</code> with radius=min distance to <code>Y</code> points.
That is, for the point <code>p</code> <code class="reqn">radius= \min_{y \in Y}d(p,y)</code>
(i.e., distance from <code>p</code> to the closest <code>Y</code> point).
The point <code>p</code> and <code>Y</code> points must be of same dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radius(p, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radius_+3A_p">p</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional point for which radius is computed.
Radius of <code>p</code> equals to the
distance to the closest <code>Y</code> point to <code>p</code>.</p>
</td></tr>
<tr><td><code id="radius_+3A_y">Y</code></td>
<td>
<p>A set of <code class="reqn">d</code>-dimensional points
representing the reference points for the balls. That is, radius
of the point <code>p</code> is defined
as the minimum distance to the <code>Y</code> points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>rad</code></td>
<td>
<p>Radius value for the point, <code>p</code>
defined as <code class="reqn">\min_{y in Y} d(p,y)</code></p>
</td></tr>
<tr><td><code>index.of.clYpnt</code></td>
<td>
<p>Index of the closest <code>Y</code> points
to the point <code>p</code></p>
</td></tr>
<tr><td><code>closest.Ypnt</code></td>
<td>
<p>The closest <code>Y</code> point to the point <code>p</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radii">radii</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);

ny&lt;-10
Y&lt;-cbind(runif(ny),runif(ny))
radius(A,Y)

nx&lt;-10
X&lt;-cbind(runif(nx),runif(nx))
rad&lt;-rep(0,nx)
for (i in 1:nx)
rad[i]&lt;-radius(X[i,],Y)$rad

Xlim&lt;-range(X[,1]-rad,X[,1]+rad,Y[,1])
Ylim&lt;-range(X[,2]-rad,X[,2]+rad,Y[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(rbind(Y),asp=1,pch=16,col=2,xlab="",ylab="",
main="Circles Centered at Class X Points with \n Radius Equal to the Distance to Closest Y Point",
axes=TRUE, xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(rbind(X))
interp::circles(X[,1],X[,2],rad,lty=1,lwd=1,col=4)

#For 1D data
ny&lt;-5
Y&lt;-runif(ny)
Ym = as.matrix(Y)
radius(1,Ym)  #this works as Y is treated as 1D data sets
#but will give error if radius(1,Y) is used
#as Y is treated as a vector (i.e., points)

#For 3D data
ny&lt;-5
X&lt;-runif(3)
Y&lt;-cbind(runif(ny),runif(ny),runif(ny))
radius(X,Y)


</code></pre>

<hr>
<h2 id='rassoc.circular'>Generation of points associated (in a radial or circular fashion)
with a given set of points</h2><span id='topic+rassoc.circular'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> 2D points uniformly
in <code class="reqn">(a_1-e,a_1+e) \times (a_1-e,a_1+e) \cap U_i B(y_i,e)</code>
(<code class="reqn">a_1</code> and <code class="reqn">b1</code> are denoted as
<code>a1</code> and <code>b1</code> as arguments)
where <code class="reqn">Y_p=(y_1,y_2,\ldots,y_{n_y})</code> with
<code class="reqn">n_y</code> being number of <code>Yp</code> points
for various values of <code>e</code> under the association pattern
and <code class="reqn">B(y_i,e)</code> is the ball centered at <code class="reqn">y_i</code> with radius <code>e</code>.
</p>
<p><code>e</code> must be positive
and very large values of <code>e</code> provide patterns close to CSR.
<code>a1</code> is defaulted
to the minimum of the <code class="reqn">x</code>-coordinates of the <code>Yp</code> points,
<code>a2</code> is defaulted
to the maximum of the <code class="reqn">x</code>-coordinates of the <code>Yp</code> points,
<code>b1</code> is defaulted
to the minimum of the <code class="reqn">y</code>-coordinates of the <code>Yp</code> points,
<code>b2</code> is defaulted
to the maximum of the <code class="reqn">y</code>-coordinates of the <code>Yp</code> points.
This function is also very similar to <code><a href="#topic+rassoc.matern">rassoc.matern</a></code>,
where <code>rassoc.circular</code>
needs the study window to be specified,
while <code><a href="#topic+rassoc.matern">rassoc.matern</a></code> does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassoc.circular(
  n,
  Yp,
  e,
  a1 = min(Yp[, 1]),
  a2 = max(Yp[, 1]),
  b1 = min(Yp[, 2]),
  b2 = max(Yp[, 2])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassoc.circular_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points
to be generated.</p>
</td></tr>
<tr><td><code id="rassoc.circular_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points representing the reference points.
The generated points are associated
(in a circular or radial fashion) with these points.</p>
</td></tr>
<tr><td><code id="rassoc.circular_+3A_e">e</code></td>
<td>
<p>A positive real number
representing the radius of the balls centered at <code>Yp</code> points.
Only these balls are allowed for the generated points
(i.e., generated points would be in the union of these balls).</p>
</td></tr>
<tr><td><code id="rassoc.circular_+3A_a1">a1</code>, <code id="rassoc.circular_+3A_a2">a2</code></td>
<td>
<p>Real numbers
representing the range of <code class="reqn">x</code>-coordinates in the region
(default is the range of <code class="reqn">x</code>-coordinates of the <code>Yp</code> points).</p>
</td></tr>
<tr><td><code id="rassoc.circular_+3A_b1">b1</code>, <code id="rassoc.circular_+3A_b2">b2</code></td>
<td>
<p>Real numbers
representing the range of <code class="reqn">y</code>-coordinates in the region
(default is the range of <code class="reqn">y</code>-coordinates of the <code>Yp</code> points).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Radial attraction parameter of the association pattern</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of attraction points <code>Yp</code>,
i.e., points with which generated points are associated.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points
associated with <code>Yp</code> points</p>
</td></tr>
<tr><td><code>tri.Yp</code></td>
<td>
<p>Logical output for triangulation
based on <code>Yp</code> points should be implemented or not.
if <code>TRUE</code> triangulation based on <code>Yp</code> points is
to be implemented (default is set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and the number of attraction
(i.e., <code>Yp</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible range of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the generated points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rseg.circular">rseg.circular</a></code>, <code><a href="#topic+rassoc.std.tri">rassoc.std.tri</a></code>,
<code><a href="#topic+rassocII.std.tri">rassocII.std.tri</a></code>, <code><a href="#topic+rassoc.matern">rassoc.matern</a></code>,
and <code><a href="#topic+rassoc.multi.tri">rassoc.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-1000; ny&lt;-10;

e&lt;-.15;
#with default bounding box (i.e., unit square)
Y&lt;-cbind(runif(ny),runif(ny))

Xdt&lt;-rassoc.circular(nx,Y,e)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

Xdt&lt;-Xdt$gen.points
Xlim&lt;-range(Xdt[,1],Y[,1]);
Ylim&lt;-range(Xdt[,2],Y[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Y,asp=1,xlab="x",ylab="y",
main="Circular Association of X points with Y Points",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01),
     pch=16,col=2,lwd=2)
points(Xdt)

#with default bounding box (i.e., unit square)
Xlim&lt;-range(Xdt[,1],Y[,1]);
Ylim&lt;-range(Xdt[,2],Y[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Y,asp=1,xlab="x",ylab="y",
main="Circular Association of X points with Y Points",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01),pch=16,
     col=2,lwd=2)
points(Xdt)

#with a rectangular bounding box
a1&lt;-0; a2&lt;-10;
b1&lt;-0; b2&lt;-5;
e&lt;-1.1;  #try also e&lt;-5; #pattern very close to CSR!

Y&lt;-cbind(runif(ny,a1,a2),runif(ny,b1,b2))
#try also Y&lt;-cbind(runif(ny,a1,a2/2),runif(ny,b1,b2/2))

Xdt&lt;-rassoc.circular(nx,Y,e,a1,a2,b1,b2)$gen.points
Xlim&lt;-range(Xdt[,1],Y[,1]);
Ylim&lt;-range(Xdt[,2],Y[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Y,asp=1,xlab="x",ylab="y",
main="Circular Association of X points with Y Points",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01),
     pch=16,col=2,lwd=2)
points(Xdt)


</code></pre>

<hr>
<h2 id='rassoc.matern'>Generation of points associated (in a Matern-like fashion)
to a given set of points</h2><span id='topic+rassoc.matern'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> 2D points uniformly in <code class="reqn">\cup B(y_i,e)</code>
where <code class="reqn">Y_p=(y_1,y_2,\ldots,y_{n_y})</code>
with <code class="reqn">n_y</code> being number of <code>Yp</code> points
for various values of <code>e</code> under the association pattern
and <code class="reqn">B(y_i,e)</code> is the ball centered
at <code class="reqn">y_i</code> with radius <code>e</code>.
</p>
<p>The pattern resembles the Matern cluster pattern
(see <code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code> in the
<code>spatstat.random</code> package for further information
(Baddeley and Turner (2005)).
<code>rMatClust(kappa, scale, mu, win)</code> in the simplest
case generates a uniform Poisson point process of &quot;parent&quot; points
with intensity <code>kappa</code>.
Then each parent point is replaced by a random cluster of
&quot;offspring&quot; points, the number of points per cluster
being Poisson(<code>mu</code>) distributed,
and their positions being placed
and uniformly inside a disc of radius scale centered on the parent point.
The resulting point pattern is a realization of the classical
&quot;stationary Matern cluster process&quot; generated inside the
window <code>win</code>.
</p>
<p>The main difference of <code>rassoc.matern</code>
and <code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>
is that the parent points are <code>Yp</code> points
which are given beforehand
and we do not discard them in the end in <code>rassoc.matern</code>
and the offspring points are the points associated
with the reference points, <code>Yp</code>;
<code>e</code> must be positive and very large values of <code>e</code>
provide patterns close to CSR.
</p>
<p>This function is also very similar to <code><a href="#topic+rassoc.circular">rassoc.circular</a></code>,
where <code><a href="#topic+rassoc.circular">rassoc.circular</a></code> needs the study window to be specified,
while <code>rassoc.matern</code> does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassoc.matern(n, Yp, e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassoc.matern_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of points to be generated.</p>
</td></tr>
<tr><td><code id="rassoc.matern_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points representing the reference points.
The generated points are associated
(in a Matern-cluster like fashion) with these points.</p>
</td></tr>
<tr><td><code id="rassoc.matern_+3A_e">e</code></td>
<td>
<p>A positive real number representing the radius of the balls
centered at <code>Yp</code> points.
Only these balls are allowed for the generated points
(i.e., generated points would be in the union of these balls).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Radial (i.e., circular) attraction parameter
of the association pattern.</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of attraction points <code>Yp</code>,
i.e., points with which generated points are associated.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points associated
with <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tri.Yp</code></td>
<td>
<p>Logical output for triangulation
based on <code>Yp</code> points should be implemented or not.
if <code>TRUE</code> triangulation based on <code>Yp</code> points is
to be implemented (default is set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and the number of
attraction (i.e., <code>Yp</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the generated points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Baddeley AJ, Turner R (2005).
&ldquo;spatstat: An R Package for Analyzing Spatial Point Patterns.&rdquo;
<em>Journal of Statistical Software</em>, <b>12(6)</b>, 1-42.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassoc.circular">rassoc.circular</a></code>, <code><a href="#topic+rassoc.std.tri">rassoc.std.tri</a></code>,
<code><a href="#topic+rassocII.std.tri">rassocII.std.tri</a></code>, <code><a href="#topic+rassoc.multi.tri">rassoc.multi.tri</a></code>,
<code><a href="#topic+rseg.circular">rseg.circular</a></code>, and <code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>
in the <code>spatstat.random</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-1000; ny&lt;-10;

e&lt;-.15;
 #try also e&lt;-1.1; #closer to CSR than association, as e is large

#Y points uniform in unit square
Y&lt;-cbind(runif(ny),runif(ny))

Xdt&lt;-rassoc.matern(nx,Y,e)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

Xdt&lt;-Xdt$gen.points
Xlim&lt;-range(Xdt[,1],Y[,1]);
Ylim&lt;-range(Xdt[,2],Y[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Y,asp=1,xlab="x",ylab="y",
main="Matern-like Association of X points with Y Points",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01),
     pch=16,col=2,lwd=2)
points(Xdt)

a1&lt;-0; a2&lt;-10;
b1&lt;-0; b2&lt;-5;
e&lt;-1.1;

#Y points uniform in a rectangle
Y&lt;-cbind(runif(ny,a1,a2),runif(ny,b1,b2))
#try also Y&lt;-cbind(runif(ny,a1,a2/2),runif(ny,b1,b2/2))

Xdt&lt;-rassoc.matern(nx,Y,e)$gen.points
Xlim&lt;-range(Xdt[,1],Y[,1]);
Ylim&lt;-range(Xdt[,2],Y[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Y,asp=1,xlab="x",ylab="y",
main="Matern-like Association of X points with Y Points",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01),pch=16,col=2,lwd=2)
points(Xdt)


</code></pre>

<hr>
<h2 id='rassoc.multi.tri'>Generation of points associated (in a Type I fashion)
with a given set of points</h2><span id='topic+rassoc.multi.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> points uniformly in the support
for Type I association in the convex hull of set of points, <code>Yp</code>.
<code>delta</code> is the parameter of association
(that is, only <code class="reqn">\delta 100</code> % area around each vertex in each Delaunay
triangle is allowed for point generation).
</p>
<p><code>delta</code> corresponds to <code>eps</code>
in the standard equilateral triangle
<code class="reqn">T_e</code> as <code class="reqn">delta=4eps^2/3</code>
(see <code>rseg.std.tri</code>  function).
</p>
<p>If <code>Yp</code> consists only of 3 points,
then the function behaves like the
function <code><a href="#topic+rassoc.tri">rassoc.tri</a></code>.
</p>
<p><code>DTmesh</code> must be the Delaunay triangulation of <code>Yp</code>
and <code>DTr</code> must be the corresponding Delaunay triangles
(both <code>DTmesh</code> and <code>DTr</code> are <code>NULL</code> by default).
If <code>NULL</code>, <code>DTmesh</code> is computed via
<code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> and <code>DTr</code> is computed via
<code><a href="interp.html#topic+triangles">triangles</a></code> function in <code>interp</code> package.
</p>
<p><code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function yields
the triangulation nodes with their neighbours,
and creates a triangulation object,
and <code><a href="interp.html#topic+triangles">triangles</a></code> function yields
a triangulation data structure from the triangulation object created
by <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>
(the first three columns are the vertex indices of the Delaunay triangles).
</p>
<p>See (Ceyhan et al. (2006); Ceyhan et al. (2007); Ceyhan (2011))
for more on the association pattern.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassoc.multi.tri(n, Yp, delta, DTmesh = NULL, DTr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassoc.multi.tri_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of points to be generated.</p>
</td></tr>
<tr><td><code id="rassoc.multi.tri_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
from which Delaunay triangulation is constructed.</p>
</td></tr>
<tr><td><code id="rassoc.multi.tri_+3A_delta">delta</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code>.
<code>delta</code> is the parameter of association
(that is, only <code class="reqn">\delta 100</code> % area around vertices of
each Delaunay triangle is allowed for point generation).</p>
</td></tr>
<tr><td><code id="rassoc.multi.tri_+3A_dtmesh">DTmesh</code></td>
<td>
<p>Delaunay triangulation of <code>Yp</code>, default is <code>NULL</code>,
which is computed via <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function
in <code>interp</code> package. <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function yields
the triangulation nodes with their neighbours, and
creates a triangulation object.</p>
</td></tr>
<tr><td><code id="rassoc.multi.tri_+3A_dtr">DTr</code></td>
<td>
<p>Delaunay triangles based on <code>Yp</code>, default is <code>NULL</code>,
which is computed via <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function
in <code>interp</code> package. <code><a href="interp.html#topic+triangles">triangles</a></code> function yields
a triangulation data structure from the triangulation object created
by <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Attraction parameter, <code>delta</code>,
of the Type I association pattern.
<code>delta</code> is in <code class="reqn">(0,1)</code> and
only <code class="reqn">\delta 100</code> % of the area around vertices of each Delaunay triangle
is allowed for point generation.</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of points <code>Yp</code>;
reference points, i.e., points with which generated points are associated.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points
associated with <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tri.Y</code></td>
<td>
<p>Logical output,
<code>TRUE</code> if triangulation based on
<code>Yp</code> points should be implemented.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points
and the number of reference (i.e., <code>Yp</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the reference points, which are the
<code>Yp</code> points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassoc.circular">rassoc.circular</a></code>, <code><a href="#topic+rassoc.std.tri">rassoc.std.tri</a></code>,
<code><a href="#topic+rassocII.std.tri">rassocII.std.tri</a></code>, and <code><a href="#topic+rseg.multi.tri">rseg.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Yp&lt;-cbind(runif(ny),runif(ny))
del&lt;-.4

Xdt&lt;-rassoc.multi.tri(nx,Yp,del)
Xdt
summary(Xdt)
plot(Xdt)

#or use
DTY&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")
#Delaunay triangulation based on Y points
TRY&lt;-interp::triangles(DTY)[,1:3];
Xp&lt;-rassoc.multi.tri(nx,Yp,del,DTY,TRY)$g
#data under CSR in the convex hull of Ypoints

Xlim&lt;-range(Yp[,1])
Ylim&lt;-range(Yp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

#plot of the data in the convex hull of Y points together with the Delaunay triangulation
DTY&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")
#Delaunay triangulation based on Y points

plot(Xp,main="Points from Type I Association \n in Multipe Triangles",
xlab=" ", ylab=" ",xlim=Xlim+xd*c(-.05,.05),
ylim=Ylim+yd*c(-.05,.05),type="n")
interp::plot.triSht(DTY, add=TRUE,
do.points=TRUE,col="blue")
points(Xp,pch=".",cex=3)


</code></pre>

<hr>
<h2 id='rassoc.std.tri'>Generation of points associated (in a Type I fashion)
with the vertices of <code class="reqn">T_e</code></h2><span id='topic+rassoc.std.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> points uniformly
in the standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
under the type I association alternative
for <code>eps</code> in <code class="reqn">(0,\sqrt{3}/3=0.5773503]</code>.
The allowed triangular regions around the vertices are determined
by the parameter <code>eps</code>.
</p>
<p>In the type I association, the triangular support regions
around the vertices are determined by
the parameter <code>eps</code>
where <code class="reqn">\sqrt{3}/3</code>-<code>eps</code> serves as the height of these triangles
(see examples for a sample plot.)
</p>
<p>See also (Ceyhan et al. (2006); Ceyhan et al. (2007); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassoc.std.tri(n, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassoc.std.tri_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of points to be generated.</p>
</td></tr>
<tr><td><code id="rassoc.std.tri_+3A_eps">eps</code></td>
<td>
<p>A positive real number
representing the parameter of type I association
(where <code class="reqn">\sqrt{3}/3</code>-<code>eps</code>
serves as the height of the triangular support regions
around the vertices).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The attraction parameter of the association pattern,
<code>eps</code>,
where <code class="reqn">\sqrt{3}/3</code>-<code>eps</code> serves
as the height of the triangular support regions around the vertices</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of points <code>Y</code>;
reference points, i.e., points
with which generated points are associated (i.e., vertices of <code class="reqn">T_e</code>).</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points
associated with <code>Y</code> points (i.e., vertices of <code class="reqn">T_e</code>).</p>
</td></tr>
<tr><td><code>tri.Y</code></td>
<td>
<p>Logical output for triangulation
based on <code>Y</code> points should be implemented or not.
if <code>TRUE</code> triangulation based on <code>Y</code> points is
to be implemented (default is set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern.</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points
and the number of reference (i.e., <code>Y</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the reference points, which are the
vertices of <code class="reqn">T_e</code> here</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rseg.circular">rseg.circular</a></code>, <code><a href="#topic+rassoc.circular">rassoc.circular</a></code>,
<code><a href="#topic+rsegII.std.tri">rsegII.std.tri</a></code>, and <code><a href="#topic+rseg.multi.tri">rseg.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-100  #try also n&lt;-20 or n&lt;-100 or 1000
eps&lt;-.25  #try also .15, .5, .75

set.seed(1)
Xdt&lt;-rassoc.std.tri(n,eps)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

Xp&lt;-Xdt$gen.points
plot(Te,pch=".",xlab="",ylab="",
main="Type I association in the \n standard equilateral triangle",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
polygon(Te)
points(Xp)

#The support for the Type I association alternative
sr&lt;-(sqrt(3)/3-eps)/(sqrt(3)/2)
C1&lt;-C+sr*(A-C); C2&lt;-C+sr*(B-C)
A1&lt;-A+sr*(B-A); A2&lt;-A+sr*(C-A)
B1&lt;-B+sr*(A-B); B2&lt;-B+sr*(C-B)
supp&lt;-rbind(A1,B1,B2,C2,C1,A2)

plot(Te,asp=1,pch=".",xlab="",ylab="",
main="Support of the Type I Association",
xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
if (sr&lt;=.5)
{
  polygon(Te,col=5)
  polygon(supp,col=0)
} else
{
  polygon(Te,col=0,lwd=2.5)
  polygon(rbind(A,A1,A2),col=5,border=NA)
  polygon(rbind(B,B1,B2),col=5,border=NA)
  polygon(rbind(C,C1,C2),col=5,border=NA)
}
points(Xp)


</code></pre>

<hr>
<h2 id='rassoc.tri'>Generation of points associated (in a Type I fashion)
with the vertices of a triangle</h2><span id='topic+rassoc.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> points uniformly in the support
for Type I association in a given triangle, <code>tri</code>.
<code>delta</code> is the parameter of association
(that is, only <code class="reqn">\delta 100</code> % area around each vertex in
the triangle is allowed for point generation).
<code>delta</code> corresponds to <code>eps</code>
in the standard equilateral triangle
<code class="reqn">T_e</code> as <code class="reqn">delta=4eps^2/3</code>
(see <code>rseg.std.tri</code> function).
</p>
<p>See (Ceyhan et al. (2006); Ceyhan et al. (2007); Ceyhan (2011)) for more on
the association pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassoc.tri(n, tri, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassoc.tri_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points
to be generated from the association pattern
in the triangle, <code>tri</code>.</p>
</td></tr>
<tr><td><code id="rassoc.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="rassoc.tri_+3A_delta">delta</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code>.
<code>delta</code> is the parameter of association
(that is, only <code class="reqn">\delta 100</code> % area around vertices of
the triangle is allowed for point generation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title
for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Attraction parameter, <code>delta</code>,
of the Type I association pattern.
<code>delta</code> is in <code class="reqn">(0,1)</code> and
only <code class="reqn">\delta 100</code> % of the area around vertices of
the triangle <code>tri</code>
is allowed for point generation.</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of points,
i.e., vertices of <code>tri</code>;
reference points, i.e., points
with which generated points are associated.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points
associated with the vertices of <code>tri</code>.</p>
</td></tr>
<tr><td><code>tri.Y</code></td>
<td>
<p>Logical output, <code>TRUE</code> if triangulation
based on <code>Yp</code> points should be implemented.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points
and the number of reference (i.e., <code>Yp</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>- and
<code class="reqn">y</code>-coordinates of the reference points, which are the
<code>Yp</code> points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rseg.tri">rseg.tri</a></code>, <code><a href="#topic+rassoc.std.tri">rassoc.std.tri</a></code>,
<code><a href="#topic+rassocII.std.tri">rassocII.std.tri</a></code>, and <code><a href="#topic+rassoc.multi.tri">rassoc.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-100
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C)
del&lt;-.4

Xdt&lt;-rassoc.tri(n,Tr,del)
Xdt
summary(Xdt)
plot(Xdt)

Xp&lt;-Xdt$g
Xlim&lt;-range(Tr[,1])
Ylim&lt;-range(Tr[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",
main="Points from Type I Association \n in one Triangle",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp)
xc&lt;-Tr[,1]+c(-.02,.02,.02)
yc&lt;-Tr[,2]+c(.02,.02,.03)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rassocII.std.tri'>Generation of points associated (in a Type II fashion)
with the edges of <code class="reqn">T_e</code></h2><span id='topic+rassocII.std.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> points uniformly
in the standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
under the type II association alternative for <code>eps</code>
in <code class="reqn">(0,\sqrt{3}/6=0.2886751]</code>.
</p>
<p>In the type II association, the annular allowed regions
around the edges are determined by
the parameter <code>eps</code>
where <code class="reqn">\sqrt{3}/6</code>-<code>eps</code> is the distance
from the interior triangle
(i.e., forbidden region for association) to <code class="reqn">T_e</code>
(see examples for a sample plot.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassocII.std.tri(n, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassocII.std.tri_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of points to be generated.</p>
</td></tr>
<tr><td><code id="rassocII.std.tri_+3A_eps">eps</code></td>
<td>
<p>A positive real number
representing the parameter of type II association
(where <code class="reqn">\sqrt{3}/6</code>-<code>eps</code>
is the distance from the interior triangle distance
from the interior triangle to <code class="reqn">T_e</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title
for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The attraction parameter, <code>eps</code>,
of the association pattern,
where <code class="reqn">\sqrt{3}/6</code>-<code>eps</code>
is the distance from the interior triangle to <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of points <code>Y</code>;
reference points, i.e.,
points with which generated points are associated
(i.e., vertices of <code class="reqn">T_e</code>).</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points associated
with <code>Y</code> points (i.e., edges of <code class="reqn">T_e</code>).</p>
</td></tr>
<tr><td><code>tri.Y</code></td>
<td>
<p>Logical output for triangulation
based on <code>Y</code> points should be implemented or not.
if <code>TRUE</code> triangulation based on <code>Y</code> points is
to be implemented (default is set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and
the number of reference (i.e., <code>Y</code>) points,
which is 3 here.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the reference points,
which are the vertices of <code class="reqn">T_e</code> here.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rseg.circular">rseg.circular</a></code>, <code><a href="#topic+rassoc.circular">rassoc.circular</a></code>,
<code><a href="#topic+rsegII.std.tri">rsegII.std.tri</a></code>, and <code><a href="#topic+rseg.multi.tri">rseg.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-100  #try also n&lt;-20 or n&lt;-100 or 1000
eps&lt;-.2  #try also .25, .1

set.seed(1)
Xdt&lt;-rassocII.std.tri(n,eps)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

Xp&lt;-Xdt$gen.points
plot(Te,pch=".",xlab="",ylab="",
main="Type II association in the \n standard equilateral triangle",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
polygon(Te)
points(Xp)

#The support for the Type II association alternative
A1&lt;-c(1/2-eps*sqrt(3),sqrt(3)/6-eps);
B1&lt;-c(1/2+eps*sqrt(3),sqrt(3)/6-eps);
C1&lt;-c(1/2,sqrt(3)/6+2*eps);
supp&lt;-rbind(A1,B1,C1)

plot(Te,asp=1,pch=".",xlab="",ylab="",
main="Support of the Type II Association",
xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
polygon(Te,col=5)
polygon(supp,col=0)
points(Xp)


</code></pre>

<hr>
<h2 id='rel.edge.basic.tri'>The index of the edge region in a
standard basic triangle form that contains a point</h2><span id='topic+rel.edge.basic.tri'></span>

<h3>Description</h3>

<p>Returns the index of the edge
whose region contains point, <code>p</code>, in
the standard basic triangle form
<code class="reqn">T_b=T(A=(0,0),B=(1,0),C=(c_1,c_2))</code>
and edge regions based on center
<code class="reqn">M=(m_1,m_2)</code> in Cartesian coordinates
or <code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the standard basic triangle form <code class="reqn">T_b</code>.
</p>
<p>Edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.
If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
Edge region 1 is the triangle <code class="reqn">T(B,C,M)</code>,
edge region 2 is <code class="reqn">T(A,C,M)</code>,
and edge region 3 is <code class="reqn">T(A,B,M)</code>.
In the standard basic triangle form
<code class="reqn">T_b</code> <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle form
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle.
Hence, standard basic triangle form is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.edge.basic.tri(p, c1, c2, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.edge.basic.tri_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code>M</code>-edge region it resides in is
to be determined in the
standard basic triangle form <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="rel.edge.basic.tri_+3A_c1">c1</code>, <code id="rel.edge.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the upper vertex of the standard basic triangle form
(i.e., the vertex adjacent to the shorter edges of <code class="reqn">T_b</code>);
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and
<code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="rel.edge.basic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard basic triangle form <code class="reqn">T_b</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>re</code></td>
<td>
<p>Index of the <code>M</code>-edge region that contains point, <code>p</code>
in the standard basic triangle form <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row labels are <code class="reqn">A</code>, <code class="reqn">B</code>, and <code class="reqn">C</code>
with edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>Description of the edge labels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.edge.triCM">rel.edge.triCM</a></code>, <code><a href="#topic+rel.edge.tri">rel.edge.tri</a></code>,
<code><a href="#topic+rel.edge.basic.tri">rel.edge.basic.tri</a></code>, <code><a href="#topic+rel.edge.std.triCM">rel.edge.std.triCM</a></code>,
and <code><a href="#topic+edge.reg.triCM">edge.reg.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C);
M&lt;-c(.6,.2)

P&lt;-c(.4,.2)
rel.edge.basic.tri(P,c1,c2,M)

A&lt;-c(0,0);B&lt;-c(1,0);C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.basic.tri(n,c1,c2)$g

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.2)

re&lt;-vector()
for (i in 1:n)
  re&lt;-c(re,rel.edge.basic.tri(Xp[i,],c1,c2,M)$re)
re

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tb,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(Xp,pch=".")
polygon(Tb)
L&lt;-Tb; R&lt;-rbind(M,M,M)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(re))

txt&lt;-rbind(Tb,M)
xc&lt;-txt[,1]+c(-.03,.03,.02,0)
yc&lt;-txt[,2]+c(.02,.02,.02,-.03)
txt.str&lt;-c("A","B","C","M")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.edge.basic.triCM'>The index of the <code class="reqn">CM</code>-edge region
in a standard basic triangle form that contains a point</h2><span id='topic+rel.edge.basic.triCM'></span>

<h3>Description</h3>

<p>Returns the index of the edge
whose region contains point, <code>p</code>, in the
standard basic triangle form
<code class="reqn">T_b=T(A=(0,0),B=(1,0),C=(c_1,c_2)</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code> with
edge regions based on center of mass <code class="reqn">CM=(A+B+C)/3</code>.
</p>
<p>Edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.
If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
Edge region 1 is the triangle <code class="reqn">T(B,C,CM)</code>,
edge region 2 is <code class="reqn">T(A,C,CM)</code>,
and edge region 3 is <code class="reqn">T(A,B,CM)</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle form
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the original triangle.
Hence, standard basic triangle form is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.edge.basic.triCM(p, c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.edge.basic.triCM_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CM</code>-edge region it resides in is
to be determined in the
standard basic triangle form <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="rel.edge.basic.triCM_+3A_c1">c1</code>, <code id="rel.edge.basic.triCM_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the upper vertex of the standard basic triangle form
(i.e., the vertex adjacent to the shorter edges of <code class="reqn">T_b</code>);
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and
<code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>re</code></td>
<td>
<p>Index of the <code class="reqn">CM</code>-edge region that contains point, <code>p</code>
in the standard basic triangle form <code class="reqn">T_b</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row labels are <code class="reqn">A=(0,0)</code>, <code class="reqn">B=(1,0)</code>, and <code class="reqn">C=(c_1,c_2)</code>
with edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>Description of the edge labels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.edge.triCM">rel.edge.triCM</a></code>, <code><a href="#topic+rel.edge.tri">rel.edge.tri</a></code>,
<code><a href="#topic+rel.edge.basic.tri">rel.edge.basic.tri</a></code>, <code><a href="#topic+rel.edge.std.triCM">rel.edge.std.triCM</a></code>, and <code><a href="#topic+edge.reg.triCM">edge.reg.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
P&lt;-c(.4,.2)
rel.edge.basic.triCM(P,c1,c2)

A&lt;-c(0,0);B&lt;-c(1,0);C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
CM&lt;-(A+B+C)/3

rel.edge.basic.triCM(A,c1,c2)
rel.edge.basic.triCM(B,c1,c2)
rel.edge.basic.triCM(C,c1,c2)
rel.edge.basic.triCM(CM,c1,c2)

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.basic.tri(n,c1,c2)$g

re&lt;-vector()
for (i in 1:n)
  re&lt;-c(re,rel.edge.basic.triCM(Xp[i,],c1,c2)$re)
re

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tb,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(Xp,pch=".")
polygon(Tb)
L&lt;-Tb; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(re))

txt&lt;-rbind(Tb,CM)
xc&lt;-txt[,1]+c(-.03,.03,.02,0)
yc&lt;-txt[,2]+c(.02,.02,.02,-.04)
txt.str&lt;-c("A","B","C","CM")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.edge.std.triCM'>The index of the edge region in the standard equilateral triangle
that contains a point</h2><span id='topic+rel.edge.std.triCM'></span>

<h3>Description</h3>

<p>Returns the index of the edge
whose region contains point, <code>p</code>, in
the standard equilateral triangle
<code class="reqn">T_e=T(A=(0,0),B=(1,0),C=(1/2,\sqrt{3}/2))</code>
with edge regions based on
center of mass <code class="reqn">CM=(A+B+C)/3</code>.
</p>
<p>Edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>,
and 2 for edge <code class="reqn">AC</code>.
If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
Edge region 1 is the triangle <code class="reqn">T(B,C,M)</code>,
edge region 2 is <code class="reqn">T(A,C,M)</code>,
and edge region 3 is <code class="reqn">T(A,B,M)</code>.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.edge.std.triCM(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.edge.std.triCM_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CM</code>-edge region it resides in is
to be determined in the
the standard equilateral triangle <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>re</code></td>
<td>
<p>Index of the <code class="reqn">CM</code>-edge region that contains point,
<code>p</code> in the standard equilateral triangle <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the standard equilateral triangle <code class="reqn">T_e</code>,
where row labels are <code class="reqn">A</code>, <code class="reqn">B</code>, and <code class="reqn">C</code>
with edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>Description of the edge labels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.edge.triCM">rel.edge.triCM</a></code>, <code><a href="#topic+rel.edge.tri">rel.edge.tri</a></code>,
<code><a href="#topic+rel.edge.basic.triCM">rel.edge.basic.triCM</a></code>, <code><a href="#topic+rel.edge.basic.tri">rel.edge.basic.tri</a></code>,
and <code><a href="#topic+edge.reg.triCM">edge.reg.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(.4,.2)
rel.edge.std.triCM(P)

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(0.5,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
CM&lt;-(A+B+C)/3

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.std.tri(n)$gen.points

re&lt;-vector()
for (i in 1:n)
  re&lt;-c(re,rel.edge.std.triCM(Xp[i,])$re)
re

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Te,asp=1,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
points(Xp,pch=".")
polygon(Te)
L&lt;-Te; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(re))

txt&lt;-rbind(Te,CM)
xc&lt;-txt[,1]+c(-.03,.03,.03,-.06)
yc&lt;-txt[,2]+c(.02,.02,.02,.03)
txt.str&lt;-c("A","B","C","CM")
text(xc,yc,txt.str)

p1&lt;-(A+B+CM)/3
p2&lt;-(B+C+CM)/3
p3&lt;-(A+C+CM)/3

plot(Te,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
polygon(Te)
L&lt;-Te; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Te,CM,p1,p2,p3)
xc&lt;-txt[,1]+c(-.03,.03,.03,-.06,0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.02,.03,0,0,0)
txt.str&lt;-c("A","B","C","CM","re=3","re=1","re=2")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.edge.tri'>The index of the edge region in a triangle that contains the point</h2><span id='topic+rel.edge.tri'></span>

<h3>Description</h3>

<p>Returns the index of the edge
whose region contains point, <code>p</code>, in
the triangle <code>tri</code><code class="reqn">=T(A,B,C)</code>
with edge regions based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>.
</p>
<p>Edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.
If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
Edge region 1 is the triangle <code class="reqn">T(B,C,M)</code>,
edge region 2 is <code class="reqn">T(A,C,M)</code>,
and edge region 3 is <code class="reqn">T(A,B,M)</code>.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.edge.tri(p, tri, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.edge.tri_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code>M</code>-edge region it resides in
is to be determined in the triangle
<code>tri</code>.</p>
</td></tr>
<tr><td><code id="rel.edge.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="rel.edge.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>re</code></td>
<td>
<p>Index of the <code>M</code>-edge region
that contains point, <code>p</code> in the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row labels are <code class="reqn">A</code>, <code class="reqn">B</code>, and <code class="reqn">C</code>
with edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>Description of the edge labels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.edge.triCM">rel.edge.triCM</a></code>, <code><a href="#topic+rel.edge.basic.triCM">rel.edge.basic.triCM</a></code>,
<code><a href="#topic+rel.edge.basic.tri">rel.edge.basic.tri</a></code>, <code><a href="#topic+rel.edge.std.triCM">rel.edge.std.triCM</a></code>,
and <code><a href="#topic+edge.reg.triCM">edge.reg.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

P&lt;-c(1.4,1.2)
M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

rel.edge.tri(P,Tr,M)

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.tri(n,Tr)$g

re&lt;-vector()
for (i in 1:n)
  re&lt;-c(re,rel.edge.tri(Xp[i,],Tr,M)$re)
re

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}

plot(Tr,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".")
L&lt;-Tr; R&lt;-rbind(M,M,M)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(re))

txt&lt;-rbind(Tr,M)
xc&lt;-txt[,1]
yc&lt;-txt[,2]
txt.str&lt;-c("A","B","C","M")
text(xc,yc,txt.str)

p1&lt;-(A+B+M)/3
p2&lt;-(B+C+M)/3
p3&lt;-(A+C+M)/3

plot(Tr,xlab="",ylab="", main="Illustration of M-edge regions in a triangle",
axes=TRUE,pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
L&lt;-Tr; R&lt;-rbind(M,M,M)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Tr,M,p1,p2,p3)
xc&lt;-txt[,1]+c(-.02,.02,.02,.02,.02,.02,.02)
yc&lt;-txt[,2]+c(.02,.02,.04,.05,.02,.02,.02)
txt.str&lt;-c("A","B","C","M","re=3","re=1","re=2")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.edge.triCM'>The index of the <code class="reqn">CM</code>-edge region in a triangle
that contains the point</h2><span id='topic+rel.edge.triCM'></span>

<h3>Description</h3>

<p>Returns the index of the edge
whose region contains point, <code>p</code>, in
the triangle <code>tri</code><code class="reqn">=T(A,B,C)</code>
with edge regions based on center of mass <code class="reqn">CM=(A+B+C)/3</code>.
</p>
<p>Edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.
If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
Edge region 1 is the triangle <code class="reqn">T(B,C,CM)</code>,
edge region 2 is <code class="reqn">T(A,C,CM)</code>, and
edge region 3 is <code class="reqn">T(A,B,CM)</code>.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.edge.triCM(p, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.edge.triCM_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CM</code>-edge region it resides in is
to be determined in the triangle
<code>tri</code>.</p>
</td></tr>
<tr><td><code id="rel.edge.triCM_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with three elements
</p>
<table>
<tr><td><code>re</code></td>
<td>
<p>Index of the <code class="reqn">CM</code>-edge region that contains point, <code>p</code>
in the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row labels are <code class="reqn">A</code>, <code class="reqn">B</code>, and <code class="reqn">C</code>
with edges are labeled as 3 for edge <code class="reqn">AB</code>,
1 for edge <code class="reqn">BC</code>, and 2 for edge <code class="reqn">AC</code>.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>Description of the edge labels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.edge.tri">rel.edge.tri</a></code>, <code><a href="#topic+rel.edge.basic.triCM">rel.edge.basic.triCM</a></code>,
<code><a href="#topic+rel.edge.basic.tri">rel.edge.basic.tri</a></code>, <code><a href="#topic+rel.edge.std.triCM">rel.edge.std.triCM</a></code>,
and <code><a href="#topic+edge.reg.triCM">edge.reg.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
P&lt;-c(1.4,1.2)
rel.edge.triCM(P,Tr)

P&lt;-c(1.5,1.61)
rel.edge.triCM(P,Tr)

CM&lt;-(A+B+C)/3

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.tri(n,Tr)$g

re&lt;-vector()
for (i in 1:n)
  re&lt;-c(re,rel.edge.triCM(Xp[i,],Tr)$re)
re

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(Xp,pch=".")
polygon(Tr)
L&lt;-Tr; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(re))

txt&lt;-rbind(Tr,CM)
xc&lt;-txt[,1]
yc&lt;-txt[,2]
txt.str&lt;-c("A","B","C","CM")
text(xc,yc,txt.str)

p1&lt;-(A+B+CM)/3
p2&lt;-(B+C+CM)/3
p3&lt;-(A+C+CM)/3

plot(Tr,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
L&lt;-Tr; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Tr,CM,p1,p2,p3)
xc&lt;-txt[,1]+c(-.02,.02,.02,.02,.02,.02,.02)
yc&lt;-txt[,2]+c(.02,.02,.04,.05,.02,.02,.02)
txt.str&lt;-c("A","B","C","CM","re=3","re=1","re=2")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.edges.tri'>The indices of the <code>M</code>-edge regions in a triangle
that contains the points in a give data set</h2><span id='topic+rel.edges.tri'></span>

<h3>Description</h3>

<p>Returns the indices of the edges
whose regions contain the points in data set <code>Xp</code> in
a triangle <code>tri</code><code class="reqn">=T(A,B,C)</code>
and edge regions are based on the center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>
(see the plots in the example for illustrations).
</p>
<p>The vertices of the  triangle <code>tri</code> are labeled as
<code class="reqn">1=A</code>, <code class="reqn">2=B</code>, and <code class="reqn">3=C</code> also
according to the row number the vertex is recorded in <code>tri</code>
and the corresponding edges are <code class="reqn">1=BC</code>, <code class="reqn">2=AC</code>, and <code class="reqn">3=AB</code>.
</p>
<p>If a point in <code>Xp</code> is not inside <code>tri</code>,
then the function yields <code>NA</code> as output for that entry.
The corresponding edge region is the polygon
with the vertex, <code>M</code>,
and vertices other than the non-adjacent vertex,
i.e., edge region 1 is the triangle
<code class="reqn">T(B,M,C)</code>, edge region 2 is <code class="reqn">T(A,M,C)</code>
and edge region 3 is <code class="reqn">T(A,B,M)</code>.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.edges.tri(Xp, tri, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.edges.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points
for which indices of the edge regions
containing them are to be determined.</p>
</td></tr>
<tr><td><code id="rel.edges.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="rel.edges.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>re</code></td>
<td>
<p>Indices (i.e., a <code>vector</code> of indices) of the edges
whose region contains points in <code>Xp</code>
in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index opposite to edge
whose index is given in re.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>Description of the edge labels as
<code>"Edge labels are AB=3, BC=1, and AC=2"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.edges.triCM">rel.edges.triCM</a></code>, <code><a href="#topic+rel.verts.tri">rel.verts.tri</a></code>,
and <code><a href="#topic+rel.verts.tri.nondegPE">rel.verts.tri.nondegPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

M&lt;-c(1.6,1.2)

P&lt;-c(.4,.2)
rel.edges.tri(P,Tr,M)

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.2)

(re&lt;-rel.edges.tri(Xp,Tr,M))

D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

plot(Tr,pch=".",xlab="",ylab="",
main="Scatterplot of data points \n and the M-edge regions",axes=TRUE,
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".",col=1)
L&lt;-Tr; R&lt;-rbind(M,M,M)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]+c(-.02,.03,.02)
yc&lt;-Tr[,2]+c(.02,.02,.04)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(.05,.06,-.05,-.02)
yc&lt;-txt[,2]+c(.03,.03,.05,-.08)
txt.str&lt;-c("M","re=2","re=3","re=1")
text(xc,yc,txt.str)
text(Xp,labels=factor(re$re))


</code></pre>

<hr>
<h2 id='rel.edges.triCM'>The indices of the <code class="reqn">CM</code>-edge regions in a triangle
that contains the points in a give data set</h2><span id='topic+rel.edges.triCM'></span>

<h3>Description</h3>

<p>Returns the indices of the edges
whose regions contain the points in data set <code>Xp</code> in
a triangle <code>tri</code><code class="reqn">=(A,B,C)</code>
and edge regions are based on the center of mass <code class="reqn">CM</code> of <code>tri</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of the  triangle <code>tri</code> are labeled as
<code class="reqn">1=A</code>, <code class="reqn">2=B</code>, and <code class="reqn">3=C</code> also
according to the row number the vertex is recorded in <code>tri</code>
and the corresponding edges are <code class="reqn">1=BC</code>, <code class="reqn">2=AC</code>, and <code class="reqn">3=AB</code>.
</p>
<p>If a point in <code>Xp</code> is not inside <code>tri</code>,
then the function yields <code>NA</code> as output for that entry.
The corresponding edge region is the polygon
with the vertex, <code class="reqn">CM</code>,
and vertices other than the non-adjacent vertex,
i.e., edge region 1 is the triangle <code class="reqn">T(B,CM,C)</code>,
edge region 2 is <code class="reqn">T(A,CM,C)</code> and edge region 3 is <code class="reqn">T(A,B,CM)</code>.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.edges.triCM(Xp, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.edges.triCM_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points
for which indices of the edge regions
containing them are to be determined.</p>
</td></tr>
<tr><td><code id="rel.edges.triCM_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>re</code></td>
<td>
<p>Indices (i.e., a <code>vector</code> of indices) of the edges
whose region contains points in <code>Xp</code>
in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p>Description of the edge labels as
<code>"Edge labels are AB=3, BC=1, and AC=2"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.edges.tri">rel.edges.tri</a></code>, <code><a href="#topic+rel.verts.tri">rel.verts.tri</a></code>,
and <code><a href="#topic+rel.verts.tri.nondegPE">rel.verts.tri.nondegPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

P&lt;-c(.4,.2)
rel.edges.triCM(P,Tr)

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

re&lt;-rel.edges.triCM(Xp,Tr)
re
CM&lt;-(A+B+C)/3
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".",col=1)
L&lt;-Tr; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]+c(-.02,.03,.02)
yc&lt;-Tr[,2]+c(.02,.02,.04)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)

txt&lt;-rbind(CM,Ds)
xc&lt;-txt[,1]+c(.05,.06,-.05,-.02)
yc&lt;-txt[,2]+c(.03,.03,.05,-.08)
txt.str&lt;-c("CM","re=2","re=3","re=1")
text(xc,yc,txt.str)
text(Xp,labels=factor(re$re))


</code></pre>

<hr>
<h2 id='rel.vert.basic.tri'>The index of the vertex region in a standard basic triangle form
that contains a given point</h2><span id='topic+rel.vert.basic.tri'></span>

<h3>Description</h3>

<p>Returns the index of the related vertex
in the standard basic triangle form
whose region contains point <code>p</code>.
The standard basic triangle form is <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>..
</p>
<p>Vertex regions are based on the general center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates
in the interior of the standard basic triangle form <code class="reqn">T_b</code>.
Vertices of the standard basic triangle form <code class="reqn">T_b</code> are labeled
according to the row number the
vertex is recorded, i.e., as 1=(0,0), 2=(1,0),and <code class="reqn">3=(c_1,c_2)</code>.
</p>
<p>If the point, <code>p</code>, is not inside <code class="reqn">T_b</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon
with the vertex, <code>M</code>, and projections from <code>M</code>
to the edges on the lines joining vertices and <code>M</code>.
That is, <code>rv=1</code> has vertices <code class="reqn">(0,0),D_3,M,D_2</code>;
<code>rv=2</code> has vertices <code class="reqn">(1,0),D_1,M,D_3</code>; and
<code class="reqn">rv=3</code> has vertices <code class="reqn">(c_1,c_2),D_2,M,D_1</code>
(see the illustration in the examples).
</p>
<p>Any given triangle can be mapped to the standard basic triangle form
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the original triangle.
Hence, standard basic triangle form is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.basic.tri(p, c1, c2, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.basic.tri_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code>M</code>-vertex region it resides in is
to be determined in the
standard basic triangle form <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.basic.tri_+3A_c1">c1</code>, <code id="rel.vert.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the vertex of the standard basic triangle form
adjacent to the shorter edges;
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.basic.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard basic triangle form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the vertex whose region contains point, <code>p</code>;
index of the vertex is the same as the row
number in the standard basic triangle form, <code class="reqn">T_b</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the standard basic triangle form, <code class="reqn">T_b</code>,
where row number corresponds to the vertex index <code>rv</code>
with <code>rv=1</code> is row <code class="reqn">1=(0,0)</code>, <code>rv=2</code> is row <code class="reqn">2=(1,0)</code>,
and <code class="reqn">rv=3</code> is row <code class="reqn">3=(c_1,c_2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.basic.triCM">rel.vert.basic.triCM</a></code>, <code><a href="#topic+rel.vert.tri">rel.vert.tri</a></code>,
<code><a href="#topic+rel.vert.triCC">rel.vert.triCC</a></code>, <code><a href="#topic+rel.vert.basic.triCC">rel.vert.basic.triCC</a></code>,
<code><a href="#topic+rel.vert.triCM">rel.vert.triCM</a></code>, and <code><a href="#topic+rel.vert.std.triCM">rel.vert.std.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C);
M&lt;-c(.6,.2)

P&lt;-c(.4,.2)
rel.vert.basic.tri(P,c1,c2,M)

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.basic.tri(n,c1,c2)$g

M&lt;-as.numeric(runif.basic.tri(1,c1,c2)$g)  #try also M&lt;-c(.6,.2)

Rv&lt;-vector()
for (i in 1:n)
{ Rv&lt;-c(Rv,rel.vert.basic.tri(Xp[i,],c1,c2,M)$rv)}
Rv

Ds&lt;-prj.cent2edges.basic.tri(c1,c2,M)

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tb)}
#need to run this when M is given in barycentric coordinates

plot(Tb,pch=".",xlab="",ylab="",axes=TRUE,
xlim=Xlim+xd*c(-.1,.1),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
points(Xp,pch=".",col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tb[,1]+c(-.04,.05,.04)
yc&lt;-Tb[,2]+c(.02,.02,.03)
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(-.02,.04,-.03,0)
yc&lt;-txt[,2]+c(-.02,.02,.02,-.03)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)
text(Xp,labels=factor(Rv))


</code></pre>

<hr>
<h2 id='rel.vert.basic.triCC'>The index of the <code class="reqn">CC</code>-vertex region
in a standard basic triangle form that contains a point</h2><span id='topic+rel.vert.basic.triCC'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in
the standard basic triangle form <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>
and vertex regions are
based on the circumcenter <code class="reqn">CC</code> of <code class="reqn">T_b</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of the standard basic triangle form <code class="reqn">T_b</code> are labeled as
<code class="reqn">1=(0,0)</code>, <code class="reqn">2=(1,0)</code>,and <code class="reqn">3=(c_1,c_2)</code>
also according to the row number the vertex is recorded in <code class="reqn">T_b</code>.
If the point, <code>p</code>, is not inside <code class="reqn">T_b</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon
whose interior points are closest to that vertex.
</p>
<p>Any given triangle can be mapped to the standard basic triangle form
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the original triangle.
Hence, standard basic triangle form is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.basic.triCC(p, c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.basic.triCC_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CC</code>-vertex region
it resides in is to be determined in the
standard basic triangle form <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.basic.triCC_+3A_c1">c1</code>, <code id="rel.vert.basic.triCC_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the upper vertex of the standard basic triangle form
(i.e., the vertex adjacent to the shorter edges of <code class="reqn">T_b</code>); <code class="reqn">c_1</code>
must be in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the <code class="reqn">CC</code>-vertex region that contains point,
<code>p</code> in the standard basic triangle form <code class="reqn">T_b</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>
with row <code class="reqn">1=(0,0)</code>, row <code class="reqn">2=(1,0)</code>, and row <code class="reqn">3=(c_1,c_2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.triCM">rel.vert.triCM</a></code>, <code><a href="#topic+rel.vert.tri">rel.vert.tri</a></code>,
<code><a href="#topic+rel.vert.triCC">rel.vert.triCC</a></code>, <code><a href="#topic+rel.vert.basic.triCM">rel.vert.basic.triCM</a></code>,
<code><a href="#topic+rel.vert.basic.tri">rel.vert.basic.tri</a></code>, and <code><a href="#topic+rel.vert.std.triCM">rel.vert.std.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6;  #try also c1&lt;-.5; c2&lt;-.5;

P&lt;-c(.3,.2)
rel.vert.basic.triCC(P,c1,c2)

A&lt;-c(0,0);B&lt;-c(1,0);C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
CC&lt;-circumcenter.basic.tri(c1,c2)  #the circumcenter
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tb[,1])
Ylim&lt;-range(Tb[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tb,asp=1,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Tb,CC,Ds)
xc&lt;-txt[,1]+c(-.03,.03,0.02,-.01,.05,-.05,.01)
yc&lt;-txt[,2]+c(.02,.02,.03,.06,.03,.03,-.03)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

RV1&lt;-(A+D3+CC+D2)/4
RV2&lt;-(B+D3+CC+D1)/4
RV3&lt;-(C+D2+CC+D1)/4

txt&lt;-rbind(RV1,RV2,RV3)
xc&lt;-txt[,1]
yc&lt;-txt[,2]
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.basic.tri(n,c1,c2)$g

Rv&lt;-vector()
for (i in 1:n)
  Rv&lt;-c(Rv,rel.vert.basic.triCC(Xp[i,],c1,c2)$rv)
Rv

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tb,asp=1,xlab="",pch=".",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(Xp,pch=".")
polygon(Tb)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(Rv))

txt&lt;-rbind(Tb,CC,Ds)
xc&lt;-txt[,1]+c(-.03,.03,0.02,-.01,.05,-.05,.01)
yc&lt;-txt[,2]+c(.02,.02,.03,.06,.03,.03,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.vert.basic.triCM'>The index of the <code class="reqn">CM</code>-vertex region
in a standard basic triangle form that contains a point</h2><span id='topic+rel.vert.basic.triCM'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in
the standard basic triangle form <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>
and vertex regions are
based on the center of mass CM=((1+c1)/3,c2/3) of <code class="reqn">T_b</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of the standard basic triangle form <code class="reqn">T_b</code>
are labeled as
<code class="reqn">1=(0,0)</code>, <code class="reqn">2=(1,0)</code>,and <code class="reqn">3=(c_1,c_2)</code>
also according to the row number the vertex is recorded in <code class="reqn">T_b</code>.
If the point, <code>p</code>, is not inside <code class="reqn">T_b</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon with the vertex, <code class="reqn">CM</code>, and
midpoints of the edges adjacent to the vertex.
</p>
<p>Any given triangle can be mapped to the standard basic triangle form
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the original triangle.
Hence, standard basic triangle form is useful for simulation
studies under the uniformity hypothesis.
</p>
<p>See also (Ceyhan (2005, 2010); Ceyhan et al. (2006))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.basic.triCM(p, c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.basic.triCM_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CM</code>-vertex region it resides in
is to be determined in the
standard basic triangle form <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.basic.triCM_+3A_c1">c1</code>, <code id="rel.vert.basic.triCM_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers
which constitute the upper vertex of the standard basic triangle form
(i.e., the vertex adjacent to the shorter edges of <code class="reqn">T_b</code>);
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and
<code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the <code class="reqn">CM</code>-vertex region that contains point, <code>p</code>
in the standard basic triangle form <code class="reqn">T_b</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>
with row <code class="reqn">1=(0,0)</code>, row <code class="reqn">2=(1,0)</code>, and row <code class="reqn">3=(c_1,c_2)</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>
<p>#' @author Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.triCM">rel.vert.triCM</a></code>, <code><a href="#topic+rel.vert.tri">rel.vert.tri</a></code>, <code><a href="#topic+rel.vert.triCC">rel.vert.triCC</a></code>,
<code><a href="#topic+rel.vert.basic.triCC">rel.vert.basic.triCC</a></code>, <code><a href="#topic+rel.vert.basic.tri">rel.vert.basic.tri</a></code>, and <code><a href="#topic+rel.vert.std.triCM">rel.vert.std.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
P&lt;-c(.4,.2)
rel.vert.basic.triCM(P,c1,c2)

A&lt;-c(0,0);B&lt;-c(1,0);C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C)
CM&lt;-(A+B+C)/3
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.basic.tri(n,c1,c2)$g

Rv&lt;-vector()
for (i in 1:n)
  Rv&lt;-c(Rv,rel.vert.basic.triCM(Xp[i,],c1,c2)$rv)
Rv

Xlim&lt;-range(Tb[,1],Xp[,1])
Ylim&lt;-range(Tb[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tb,xlab="",ylab="",axes="T",pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(Xp,pch=".")
polygon(Tb)
L&lt;-Ds; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(Rv))

txt&lt;-rbind(Tb,CM,Ds)
xc&lt;-txt[,1]+c(-.03,.03,.02,-.01,.06,-.05,.0)
yc&lt;-txt[,2]+c(.02,.02,.02,.04,.02,.02,-.03)
txt.str&lt;-c("A","B","C","CM","D1","D2","D3")
text(xc,yc,txt.str)

plot(Tb,xlab="",ylab="",axes="T",pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tb)
L&lt;-Ds; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

RV1&lt;-(A+D3+CM+D2)/4
RV2&lt;-(B+D3+CM+D1)/4
RV3&lt;-(C+D2+CM+D1)/4

txt&lt;-rbind(RV1,RV2,RV3)
xc&lt;-txt[,1]
yc&lt;-txt[,2]
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(Tb,CM,Ds)
xc&lt;-txt[,1]+c(-.03,.03,.02,-.01,.04,-.03,.0)
yc&lt;-txt[,2]+c(.02,.02,.02,.04,.02,.02,-.03)
txt.str&lt;-c("A","B","C","CM","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.vert.end.int'>The index of the vertex region in an end-interval
that contains a given point</h2><span id='topic+rel.vert.end.int'></span>

<h3>Description</h3>

<p>Returns the index of the vertex in the interval, <code>int</code>,
whose end interval contains the 1D point <code>p</code>,
that is, it finds the index of the vertex for the point, <code>p</code>, outside
the interval <code>int</code><code class="reqn">=(a,b)=</code>(vertex 1,vertex 2);
vertices of interval are labeled as 1 and 2
according to their order in the interval.
</p>
<p>If the point, <code>p</code>, is inside <code>int</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is an interval
as <code class="reqn">(-\infty,a)</code> or <code class="reqn">(b,\infty)</code> for the interval <code class="reqn">(a,b)</code>.
Then if <code class="reqn">p&lt;a</code>, then <code>rv=1</code> and if <code class="reqn">p&gt;b</code>,
then <code>rv=2</code>.
Unlike <code><a href="#topic+rel.vert.mid.int">rel.vert.mid.int</a></code>, centrality parameter (i.e., center
of the interval is not relevant for <code>rel.vert.end.int</code>.)
</p>
<p>See also (Ceyhan (2012, 2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.end.int(p, int)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.end.int_+3A_p">p</code></td>
<td>
<p>A 1D point whose end interval region is provided by the function.</p>
</td></tr>
<tr><td><code id="rel.vert.end.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the end vertex whose region contains point, <code>p</code>.</p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>The vertices of the interval as a <code>vector</code>
where position of the vertex corresponds to
the vertex index as <code>int=(rv=1,rv=2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.<br /><br /> Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.mid.int">rel.vert.mid.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a&lt;-0; b&lt;-10; int&lt;-c(a,b)

rel.vert.end.int(-6,int)
rel.vert.end.int(16,int)

n&lt;-10
xf&lt;-(int[2]-int[1])*.5
XpL&lt;-runif(n,a-xf,a)
XpR&lt;-runif(n,b,b+xf)
Xp&lt;-c(XpL,XpR)
rel.vert.end.int(Xp[1],int)

Rv&lt;-vector()
for (i in 1:length(Xp))
  Rv&lt;-c(Rv,rel.vert.end.int(Xp[i],int)$rv)
Rv

Xlim&lt;-range(a,b,Xp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),xlab="",pch=".",xlim=Xlim+xd*c(-.05,.05))
abline(h=0)
abline(v=c(a,b),col=1,lty = 2)
points(cbind(Xp,0))
text(cbind(Xp,0.1),labels=factor(Rv))
text(cbind(c(a,b),-0.1),c("rv=1","rv=2"))

jit&lt;-.1
yjit&lt;-runif(length(Xp),-jit,jit)

Xlim&lt;-range(a,b,Xp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(a,0),
main="vertex region indices for the points\n in the end intervals",
     xlab=" ", ylab=" ",pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=3*range(yjit))
points(Xp, yjit,xlim=Xlim+xd*c(-.05,.05),pch=".",cex=3)
abline(h=0)
abline(v=c(a,b),lty = 2)
text(Xp,yjit,labels=factor(Rv))
text(cbind(c(a,b),-.01),c("rv=1","rv=2"))


</code></pre>

<hr>
<h2 id='rel.vert.mid.int'>The index of the vertex region in a middle interval
that contains a given point</h2><span id='topic+rel.vert.mid.int'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in
the interval <code>int</code><code class="reqn">=(a,b)=</code>(vertex 1,vertex 2)
with (parameterized) center <code class="reqn">M_c</code> associated with
the centrality parameter <code class="reqn">c \in (0,1)</code>;
vertices of interval are labeled as 1 and 2 according to their
order in the interval <code>int</code>.
If the point, <code>p</code>, is not inside <code>int</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the interval <code class="reqn">(a,b)</code>
as <code class="reqn">(a,M_c)</code> and <code class="reqn">(M_c,b)</code>
where <code class="reqn">M_c=a+c(b-a)</code>.
</p>
<p>See also (Ceyhan (2012, 2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.mid.int(p, int, c = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.mid.int_+3A_p">p</code></td>
<td>
<p>A 1D point. The vertex region <code>p</code> resides is to be found.</p>
</td></tr>
<tr><td><code id="rel.vert.mid.int_+3A_int">int</code></td>
<td>
<p>A <code>vector</code> of two real numbers representing an interval.</p>
</td></tr>
<tr><td><code id="rel.vert.mid.int_+3A_c">c</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code>
parameterizing the center inside <code>int</code><code class="reqn">=(a,b)</code>
with the default <code>c=.5</code>.
For the interval, <code>int</code><code class="reqn">=(a,b)</code>,
the parameterized center is <code class="reqn">M_c=a+c(b-a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the vertex in the interval <code>int</code>
whose region contains point, <code>p</code>.</p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>The vertices of the interval as a <code>vector</code>
where position of the vertex corresponds to
the vertex index as <code>int=(rv=1,rv=2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2012).
&ldquo;The Distribution of the Relative Arc Density of a Family of Interval Catch Digraph Based on Uniform Data.&rdquo;
<em>Metrika</em>, <b>75(6)</b>, 761-793.<br /><br /> Ceyhan E (2016).
&ldquo;Density of a Random Interval Catch Digraph Family and its Use for Testing Uniformity.&rdquo;
<em>REVSTAT</em>, <b>14(4)</b>, 349-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.end.int">rel.vert.end.int</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c&lt;-.4
a&lt;-0; b&lt;-10; int = c(a,b)

Mc&lt;-centerMc(int,c)

rel.vert.mid.int(6,int,c)

n&lt;-20  #try also n&lt;-40
xr&lt;-range(a,b,Mc)
xf&lt;-(int[2]-int[1])*.5
Xp&lt;-runif(n,a,b)

Rv&lt;-vector()
for (i in 1:n)
  Rv&lt;-c(Rv,rel.vert.mid.int(Xp[i],int,c)$rv)
Rv

jit&lt;-.1
yjit&lt;-runif(n,-jit,jit)

Xlim&lt;-range(a,b,Xp)
xd&lt;-Xlim[2]-Xlim[1]

plot(cbind(Mc,0),main="vertex region indices for the points", xlab=" ",
ylab=" ", xlim=Xlim+xd*c(-.05,.05),ylim=3*range(yjit),pch=".",cex=3)
abline(h=0)
points(Xp,yjit)
abline(v=c(a,b,Mc),lty = 2,col=c(1,1,2))
text(Xp,yjit,labels=factor(Rv))
text(cbind(c(a,b,Mc),.02),c("rv=1","rv=2","Mc"))


</code></pre>

<hr>
<h2 id='rel.vert.std.tri'>The index of the vertex region in the standard equilateral triangle
that contains a given point</h2><span id='topic+rel.vert.std.tri'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
with vertex regions are constructed with center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of <code class="reqn">T_e</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of triangle, <code class="reqn">T_e</code>, are labeled as <code class="reqn">1,2,3</code>
according to the row number the vertex is recorded in <code class="reqn">T_e</code>.
If the point, <code>p</code>, is not inside <code class="reqn">T_e</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon with the vertex, <code>M</code>, and
projections from <code>M</code> to the edges on the lines
joining vertices and <code>M</code>.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.std.tri(p, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.std.tri_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code>M</code>-vertex region it resides in is
to be determined in the
standard equilateral triangle <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.std.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center
in the interior of the standard equilateral triangle <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the vertex whose region contains point, <code>p</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle, <code class="reqn">T_e</code>,
where row number corresponds to the vertex index in <code>rv</code>
with row <code class="reqn">1=(0,0)</code>, row <code class="reqn">2=(1,0)</code>, and row <code class="reqn">3=(1/2,\sqrt{3}/2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.std.triCM">rel.vert.std.triCM</a></code>, <code><a href="#topic+rel.vert.tri">rel.vert.tri</a></code>, <code><a href="#topic+rel.vert.triCC">rel.vert.triCC</a></code>,
<code><a href="#topic+rel.vert.basic.triCC">rel.vert.basic.triCC</a></code>, <code><a href="#topic+rel.vert.triCM">rel.vert.triCM</a></code>,
and <code><a href="#topic+rel.vert.basic.tri">rel.vert.basic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
n&lt;-20  #try also n&lt;-40

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

M&lt;-as.numeric(runif.std.tri(1)$g)  #try also M&lt;-c(.6,.2)

rel.vert.std.tri(Xp[1,],M)

Rv&lt;-vector()
for (i in 1:n)
  Rv&lt;-c(Rv,rel.vert.std.tri(Xp[i,],M)$rv)
Rv

Ds&lt;-prj.cent2edges(Te,M)

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Te)}
#need to run this when M is given in barycentric coordinates

plot(Te,asp=1,pch=".",xlab="",ylab="",axes=TRUE,
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
points(Xp,pch=".",col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Te,M)
xc&lt;-txt[,1]+c(-.02,.03,.02,0)
yc&lt;-txt[,2]+c(.02,.02,.03,.05)
txt.str&lt;-c("A","B","C","M")
text(xc,yc,txt.str)
text(Xp,labels=factor(Rv))


</code></pre>

<hr>
<h2 id='rel.vert.std.triCM'>The index of the <code class="reqn">CM</code>-vertex region
in the standard equilateral triangle that contains a given point</h2><span id='topic+rel.vert.std.triCM'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
with vertex regions are constructed with center of mass CM
(see the plots in the example for illustrations).
</p>
<p>The vertices of triangle, <code class="reqn">T_e</code>, are labeled as <code class="reqn">1,2,3</code>
according to the row number the vertex is recorded in <code class="reqn">T_e</code>.
If the point, <code>p</code>, is not inside <code class="reqn">T_e</code>, then the
function yields <code>NA</code> as output.
The corresponding vertex region is the polygon with the vertex, <code class="reqn">CM</code>, and
midpoints of the edges adjacent to the vertex.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.std.triCM(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.std.triCM_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CM</code>-vertex region it resides
in is to be determined in the
standard equilateral triangle <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the vertex whose region contains point, <code>p</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle, <code class="reqn">T_e</code>,
where row number corresponds to the vertex index in <code>rv</code>
with row <code class="reqn">1=(0,0)</code>, row <code class="reqn">2=(1,0)</code>, and row <code class="reqn">3=(1/2,\sqrt{3}/2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.basic.triCM">rel.vert.basic.triCM</a></code>, <code><a href="#topic+rel.vert.tri">rel.vert.tri</a></code>,
<code><a href="#topic+rel.vert.triCC">rel.vert.triCC</a></code>, <code><a href="#topic+rel.vert.basic.triCC">rel.vert.basic.triCC</a></code>,
<code><a href="#topic+rel.vert.triCM">rel.vert.triCM</a></code>, and <code><a href="#topic+rel.vert.basic.tri">rel.vert.basic.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)

n&lt;-20  #try also n&lt;-40

set.seed(1)
Xp&lt;-runif.std.tri(n)$gen.points

rel.vert.std.triCM(Xp[1,])

Rv&lt;-vector()
for (i in 1:n)
  Rv&lt;-c(Rv,rel.vert.std.triCM(Xp[i,])$rv)
Rv

CM&lt;-(A+B+C)/3
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Te,asp=1,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
points(Xp,pch=".",col=1)
L&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Te,CM)
xc&lt;-txt[,1]+c(-.02,.03,.02,0)
yc&lt;-txt[,2]+c(.02,.02,.03,.05)
txt.str&lt;-c("A","B","C","CM")
text(xc,yc,txt.str)
text(Xp,labels=factor(Rv))


</code></pre>

<hr>
<h2 id='rel.vert.tetraCC'>The index of the <code class="reqn">CC</code>-vertex region in a tetrahedron
that contains a point</h2><span id='topic+rel.vert.tetraCC'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in
a tetrahedron <code class="reqn">th=T(A,B,C,D)</code>
and vertex regions are based on the circumcenter <code class="reqn">CC</code> of <code>th</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of the tetrahedron <code>th</code> are labeled as
<code class="reqn">1=A</code>, <code class="reqn">2=B</code>, <code class="reqn">3=C</code>, and <code class="reqn">4=C</code> also
according to the row number the vertex is recorded in <code>th</code>.
</p>
<p>If the point, <code>p</code>, is not inside <code>th</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon
whose interior points are closest to that vertex.
If <code>th</code> is regular tetrahedron,
then <code class="reqn">CC</code> and <code class="reqn">CM</code> (center of mass) coincide.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.tetraCC(p, th)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.tetraCC_+3A_p">p</code></td>
<td>
<p>A 3D point for which <code class="reqn">CC</code>-vertex region it resides in is
to be determined in the
tetrahedron <code>th</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.tetraCC_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row
representing a vertex of the tetrahedron.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the <code class="reqn">CC</code>-vertex region
that contains point, <code>p</code> in the tetrahedron <code>th</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the tetrahedron,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.tetraCM">rel.vert.tetraCM</a></code> and <code><a href="#topic+rel.vert.triCC">rel.vert.triCC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
A&lt;-c(0,0,0)+runif(3,-.2,.2);
B&lt;-c(1,0,0)+runif(3,-.2,.2);
C&lt;-c(1/2,sqrt(3)/2,0)+runif(3,-.2,.2);
D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)+runif(3,-.2,.2);
tetra&lt;-rbind(A,B,C,D)

n&lt;-20  #try also n&lt;-40

Xp&lt;-runif.tetra(n,tetra)$g

rel.vert.tetraCC(Xp[1,],tetra)

Rv&lt;-vector()
for (i in 1:n)
 Rv&lt;-c(Rv,rel.vert.tetraCC(Xp[i,],tetra)$rv)
Rv

CC&lt;-circumcenter.tetra(tetra)
CC

Xlim&lt;-range(tetra[,1],Xp[,1],CC[1])
Ylim&lt;-range(tetra[,2],Xp[,2],CC[2])
Zlim&lt;-range(tetra[,3],Xp[,3],CC[3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::scatter3D(tetra[,1],tetra[,2],tetra[,3],
phi =0,theta=40, bty = "g",
main="Scatterplot of data points \n and CC-vertex regions",
xlim=Xlim+xd*c(-.05,.05), ylim=Ylim+yd*c(-.05,.05),
zlim=Zlim+zd*c(-.05,.05),
          pch = 20, cex = 1, ticktype = "detailed")
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],
add=TRUE,lwd=2)
#add the data points
plot3D::points3D(Xp[,1],Xp[,2],Xp[,3],pch=".",cex=3, add=TRUE)

plot3D::text3D(tetra[,1],tetra[,2],tetra[,3],
labels=c("A","B","C","D"), add=TRUE)
plot3D::text3D(CC[1],CC[2],CC[3], labels=c("CC"), add=TRUE)

D1&lt;-(A+B)/2; D2&lt;-(A+C)/2; D3&lt;-(A+D)/2; D4&lt;-(B+C)/2;
D5&lt;-(B+D)/2; D6&lt;-(C+D)/2;
L&lt;-rbind(D1,D2,D3,D4,D5,D6); R&lt;-matrix(rep(CC,6),ncol=3,byrow=TRUE)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],
add=TRUE,lty = 2)

F1&lt;-intersect.line.plane(A,CC,B,C,D)
L&lt;-matrix(rep(F1,4),ncol=3,byrow=TRUE); R&lt;-rbind(D4,D5,D6,CC)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],col=2,
add=TRUE,lty = 2)

F2&lt;-intersect.line.plane(B,CC,A,C,D)
L&lt;-matrix(rep(F2,4),ncol=3,byrow=TRUE); R&lt;-rbind(D2,D3,D6,CC)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],col=3,
add=TRUE,lty = 2)

F3&lt;-intersect.line.plane(C,CC,A,B,D)
L&lt;-matrix(rep(F3,4),ncol=3,byrow=TRUE); R&lt;-rbind(D3,D5,D6,CC)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],col=4,
add=TRUE,lty = 2)

F4&lt;-intersect.line.plane(D,CC,A,B,C)
L&lt;-matrix(rep(F4,4),ncol=3,byrow=TRUE); R&lt;-rbind(D1,D2,D4,CC)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],col=5,
add=TRUE,lty = 2)

plot3D::text3D(Xp[,1],Xp[,2],Xp[,3], labels=factor(Rv), add=TRUE)


</code></pre>

<hr>
<h2 id='rel.vert.tetraCM'>The index of the <code class="reqn">CM</code>-vertex region in a tetrahedron
that contains a point</h2><span id='topic+rel.vert.tetraCM'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in
a tetrahedron <code class="reqn">th=T(A,B,C,D)</code>
and vertex regions are
based on the center of mass <code class="reqn">CM=(A+B+C+D)/4</code> of <code>th</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of the tetrahedron <code>th</code> are labeled as
<code class="reqn">1=A</code>, <code class="reqn">2=B</code>, <code class="reqn">3=C</code>, and <code class="reqn">4=C</code> also
according to the row number the vertex is recorded in <code>th</code>.
</p>
<p>If the point, <code>p</code>, is not inside <code>th</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the simplex with the vertex, <code class="reqn">CM</code>, and
midpoints of the edges adjacent to the vertex.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.tetraCM(p, th)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.tetraCM_+3A_p">p</code></td>
<td>
<p>A 3D point for which <code class="reqn">CM</code>-vertex region it resides in is
to be determined in the
tetrahedron <code>th</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.tetraCM_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row
representing a vertex of the tetrahedron.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the <code class="reqn">CM</code>-vertex region that contains point, <code>p</code>
in the tetrahedron <code>th</code></p>
</td></tr>
<tr><td><code>th</code></td>
<td>
<p>The vertices of the tetrahedron,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.tetraCC">rel.vert.tetraCC</a></code> and <code><a href="#topic+rel.vert.triCM">rel.vert.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0);
D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)

n&lt;-20  #try also n&lt;-40

Xp&lt;-runif.std.tetra(n)$g

rel.vert.tetraCM(Xp[1,],tetra)

Rv&lt;-vector()
for (i in 1:n)
  Rv&lt;-c(Rv, rel.vert.tetraCM(Xp[i,],tetra)$rv )
Rv

Xlim&lt;-range(tetra[,1],Xp[,1])
Ylim&lt;-range(tetra[,2],Xp[,2])
Zlim&lt;-range(tetra[,3],Xp[,3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

CM&lt;-apply(tetra,2,mean)

plot3D::scatter3D(tetra[,1],tetra[,2],tetra[,3], phi =0,theta=40, bty = "g",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05), zlim=Zlim+zd*c(-.05,.05),
          pch = 20, cex = 1, ticktype = "detailed")
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lwd=2)
#add the data points
plot3D::points3D(Xp[,1],Xp[,2],Xp[,3],pch=".",cex=3, add=TRUE)

plot3D::text3D(tetra[,1],tetra[,2],tetra[,3],
labels=c("A","B","C","D"), add=TRUE)
plot3D::text3D(CM[1],CM[2],CM[3], labels=c("CM"), add=TRUE)

D1&lt;-(A+B)/2; D2&lt;-(A+C)/2; D3&lt;-(A+D)/2; D4&lt;-(B+C)/2; D5&lt;-(B+D)/2; D6&lt;-(C+D)/2;
L&lt;-rbind(D1,D2,D3,D4,D5,D6); R&lt;-matrix(rep(CM,6),ncol=3,byrow=TRUE)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3], add=TRUE,lty = 2)

F1&lt;-intersect.line.plane(A,CM,B,C,D)
L&lt;-matrix(rep(F1,4),ncol=3,byrow=TRUE); R&lt;-rbind(D4,D5,D6,CM)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],col=2,
add=TRUE,lty = 2)

F2&lt;-intersect.line.plane(B,CM,A,C,D)
L&lt;-matrix(rep(F2,4),ncol=3,byrow=TRUE); R&lt;-rbind(D2,D3,D6,CM)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],col=3,
add=TRUE,lty = 2)

F3&lt;-intersect.line.plane(C,CM,A,B,D)
L&lt;-matrix(rep(F3,4),ncol=3,byrow=TRUE); R&lt;-rbind(D3,D5,D6,CM)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],col=4,
add=TRUE,lty = 2)

F4&lt;-intersect.line.plane(D,CM,A,B,C)
L&lt;-matrix(rep(F4,4),ncol=3,byrow=TRUE); R&lt;-rbind(D1,D2,D4,CM)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],col=5,
add=TRUE,lty = 2)

plot3D::text3D(Xp[,1],Xp[,2],Xp[,3], labels=factor(Rv), add=TRUE)


</code></pre>

<hr>
<h2 id='rel.vert.tri'>The index of the vertex region in a triangle
that contains a given point</h2><span id='topic+rel.vert.tri'></span>

<h3>Description</h3>

<p>Returns the index of the related vertex
in the triangle, <code>tri</code>,
whose region contains point <code>p</code>.
</p>
<p>Vertex regions are based on the general center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or
<code class="reqn">M=(\alpha,\beta,\gamma)</code> in barycentric coordinates
in the interior of the triangle <code>tri</code>.
Vertices of the triangle <code>tri</code> are labeled
according to the row number the vertex is recorded.
</p>
<p>If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon
with the vertex, <code>M</code>, and projections from <code>M</code>
to the edges on the lines joining vertices
and <code>M</code> (see the illustration in the examples).
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.tri(p, tri, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.tri_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code>M</code>-vertex region
it resides in is to be determined in the
triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="rel.vert.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the vertex whose region contains point, <code>p</code>;
index of the vertex is the same as the row
number in the triangle, <code>tri</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle, <code>tri</code>,
where row number corresponds to the vertex index <code>rv</code>
with <code>rv=1</code> is row 1, <code>rv=2</code> is row 2, and <code class="reqn">rv=3</code> is is row 3.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.triCM">rel.vert.triCM</a></code>, <code><a href="#topic+rel.vert.triCC">rel.vert.triCC</a></code>,
<code><a href="#topic+rel.vert.basic.triCC">rel.vert.basic.triCC</a></code>, <code><a href="#topic+rel.vert.basic.triCM">rel.vert.basic.triCM</a></code>,
<code><a href="#topic+rel.vert.basic.tri">rel.vert.basic.tri</a></code>, and <code><a href="#topic+rel.vert.std.triCM">rel.vert.std.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
M&lt;-c(1.6,1.0)

P&lt;-c(1.5,1.6)
rel.vert.tri(P,Tr,M)
#try also rel.vert.tri(P,Tr,M=c(2,2))
#center is not in the interior of the triangle

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also M&lt;-c(1.6,1.0)

Rv&lt;-vector()
for (i in 1:n)
{Rv&lt;-c(Rv,rel.vert.tri(Xp[i,],Tr,M)$rv)}
Rv

Ds&lt;-prj.cent2edges(Tr,M)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

plot(Tr,pch=".",xlab="",ylab="",
main="Illustration of M-Vertex Regions\n in a Triangle",axes=TRUE,
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".",col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]
yc&lt;-Tr[,2]
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(-.02,.04,-.04,0)
yc&lt;-txt[,2]+c(-.02,.04,.05,-.08)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)
text(Xp,labels=factor(Rv))


</code></pre>

<hr>
<h2 id='rel.vert.triCC'>The index of the <code class="reqn">CC</code>-vertex region in a triangle
that contains a point</h2><span id='topic+rel.vert.triCC'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in
a triangle <code>tri</code><code class="reqn">=(A,B,C)</code>
and vertex regions are based on the circumcenter <code class="reqn">CC</code> of <code>tri</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of the  triangle <code>tri</code> are labeled as
<code class="reqn">1=A</code>, <code class="reqn">2=B</code>, and <code class="reqn">3=C</code> also
according to the row number the vertex is recorded in <code>tri</code>.
If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon
whose interior points are closest to that vertex.
If <code>tri</code> is equilateral triangle,
then <code class="reqn">CC</code> and <code class="reqn">CM</code> (center of mass) coincide.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.triCC(p, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.triCC_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CC</code>-vertex region it resides in is
to be determined in the
triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.triCC_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the <code class="reqn">CC</code>-vertex region that contains point, <code>p</code>
in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.tri">rel.vert.tri</a></code>, <code><a href="#topic+rel.vert.triCM">rel.vert.triCM</a></code>,
<code><a href="#topic+rel.vert.basic.triCM">rel.vert.basic.triCM</a></code>, <code><a href="#topic+rel.vert.basic.triCC">rel.vert.basic.triCC</a></code>,
<code><a href="#topic+rel.vert.basic.tri">rel.vert.basic.tri</a></code>, and <code><a href="#topic+rel.vert.std.triCM">rel.vert.std.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

P&lt;-c(1.3,1.2)
rel.vert.triCC(P,Tr)

CC&lt;-circumcenter.tri(Tr)  #the circumcenter
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],CC[1])
Ylim&lt;-range(Tr[,2],CC[2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,asp=1,xlab="",ylab="",pch=".",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

txt&lt;-rbind(Tr,CC,Ds)
xc&lt;-txt[,1]+c(-.07,.08,.06,.12,-.1,-.1,-.09)
yc&lt;-txt[,2]+c(.02,-.02,.03,.0,.02,.06,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)

RV1&lt;-(A+.5*(D3-A)+A+.5*(D2-A))/2
RV2&lt;-(B+.5*(D3-B)+B+.5*(D1-B))/2
RV3&lt;-(C+.5*(D2-C)+C+.5*(D1-C))/2

txt&lt;-rbind(RV1,RV2,RV3)
xc&lt;-txt[,1]
yc&lt;-txt[,2]
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.tri(n,Tr)$g

Rv&lt;-vector()
for (i in 1:n)
  Rv&lt;-c(Rv,rel.vert.triCC(Xp[i,],Tr)$rv)
Rv

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,asp=1,xlab="",ylab="",
main="Illustration of CC-Vertex Regions\n in a Triangle",
pch=".",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".")
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(Rv))

txt&lt;-rbind(Tr,CC,Ds)
xc&lt;-txt[,1]+c(-.07,.08,.06,.12,-.1,-.1,-.09)
yc&lt;-txt[,2]+c(.02,-.02,.03,.0,.02,.06,-.04)
txt.str&lt;-c("A","B","C","CC","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.vert.triCM'>The index of the <code class="reqn">CM</code>-vertex region in a triangle that contains a given point</h2><span id='topic+rel.vert.triCM'></span>

<h3>Description</h3>

<p>Returns the index of the vertex
whose region contains point <code>p</code> in
the triangle <code>tri</code><code class="reqn">=(y_1,y_2,y_3)</code>
with vertex regions are constructed with center of mass <code class="reqn">CM=(y_1+y_2+y_3)/3</code>
(see the plots in the example for illustrations).
</p>
<p>The vertices of triangle, <code>tri</code>,
are labeled as <code class="reqn">1,2,3</code>
according to the row number the vertex is recorded in <code>tri</code>.
If the point, <code>p</code>, is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon with the vertex, <code class="reqn">CM</code>,
and midpoints of the edges adjacent to the vertex.
</p>
<p>See (Ceyhan (2005, 2010))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.vert.triCM(p, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.vert.triCM_+3A_p">p</code></td>
<td>
<p>A 2D point for which <code class="reqn">CM</code>-vertex region it resides in
is to be determined in the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code id="rel.vert.triCM_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Index of the <code class="reqn">CM</code>-vertex region that contains point,
<code>p</code> in the triangle <code>tri</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.vert.tri">rel.vert.tri</a></code>, <code><a href="#topic+rel.vert.triCC">rel.vert.triCC</a></code>, <code><a href="#topic+rel.vert.basic.triCM">rel.vert.basic.triCM</a></code>,
<code><a href="#topic+rel.vert.basic.triCC">rel.vert.basic.triCC</a></code>, <code><a href="#topic+rel.vert.basic.tri">rel.vert.basic.tri</a></code>, and <code><a href="#topic+rel.vert.std.triCM">rel.vert.std.triCM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.6,2);
Tr&lt;-rbind(A,B,C);
P&lt;-c(1.4,1.2)
rel.vert.triCM(P,Tr)

n&lt;-20  #try also n&lt;-40
Xp&lt;-runif.tri(n,Tr)$g

Rv&lt;-vector()
for (i in 1:n)
  Rv&lt;-c(Rv,rel.vert.triCM(Xp[i,],Tr)$rv)
Rv

CM&lt;-(A+B+C)/3
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,xlab="",ylab="",axes=TRUE,pch=".",xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".")
L&lt;-Ds; R&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE)
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)
text(Xp,labels=factor(Rv))

txt&lt;-rbind(Tr,CM,D1,D2,D3)
xc&lt;-txt[,1]+c(-.02,.02,.02,-.02,.02,-.01,-.01)
yc&lt;-txt[,2]+c(-.02,-.04,.06,-.02,.02,.06,-.06)
txt.str&lt;-c("rv=1","rv=2","rv=3","CM","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rel.verts.tri'>The indices of the vertex regions in a triangle
that contains the points in a give data set</h2><span id='topic+rel.verts.tri'></span>

<h3>Description</h3>

<p>Returns the indices of the vertices
whose regions contain the points in data set <code>Xp</code> in
a triangle <code>tri</code><code class="reqn">=T(A,B,C)</code>.
</p>
<p>Vertex regions are based on center <code class="reqn">M=(m_1,m_2)</code>
in Cartesian coordinates or <code class="reqn">M=(\alpha,\beta,\gamma)</code>
in barycentric coordinates in the interior of the triangle
to the edges on the extension of the lines joining <code>M</code> to the vertices
or based on the circumcenter of <code>tri</code>.
Vertices of triangle <code>tri</code> are labeled as <code class="reqn">1,2,3</code>
according to the row number the vertex is recorded.
</p>
<p>If a point in <code>Xp</code> is not inside <code>tri</code>,
then the function yields <code>NA</code> as output for that entry.
The corresponding vertex region is the polygon with the vertex, <code>M</code>, and
projection points from <code>M</code> to the edges crossing the vertex
(as the output of <code>prj.cent2edges(Tr,M)</code>)
or <code class="reqn">CC</code>-vertex region
(see the examples for an illustration).
</p>
<p>See also (Ceyhan (2005, 2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.verts.tri(Xp, tri, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.verts.tri_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points
for which indices of the vertex regions containing them are to be determined.</p>
</td></tr>
<tr><td><code id="rel.verts.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix
with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="rel.verts.tri_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>
or the circumcenter of <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Indices of the vertices
whose regions contains points in <code>Xp</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.verts.triCM">rel.verts.triCM</a></code>, <code><a href="#topic+rel.verts.triCC">rel.verts.triCC</a></code>,
and <code><a href="#topic+rel.verts.tri.nondegPE">rel.verts.tri.nondegPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
M&lt;-c(1.6,1.0)

P&lt;-c(.4,.2)
rel.verts.tri(P,Tr,M)

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-as.numeric(runif.tri(1,Tr)$g)  #try also  #M&lt;-c(1.6,1.0)

rel.verts.tri(Xp,Tr,M)
rel.verts.tri(rbind(Xp,c(2,2)),Tr,M)

rv&lt;-rel.verts.tri(Xp,Tr,M)
rv

ifelse(identical(M,circumcenter.tri(Tr)),
Ds&lt;-rbind((B+C)/2,(A+C)/2,(A+B)/2),Ds&lt;-prj.cent2edges(Tr,M))

Xlim&lt;-range(Tr[,1],M[1],Xp[,1])
Ylim&lt;-range(Tr[,2],M[2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

if (dimension(M)==3) {M&lt;-bary2cart(M,Tr)}
#need to run this when M is given in barycentric coordinates

plot(Tr,pch=".",xlab="",ylab="",
main="Scatterplot of data points \n and M-vertex regions in a triangle",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".",col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]
yc&lt;-Tr[,2]
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(.02,.04,-.03,0)
yc&lt;-txt[,2]+c(.07,.04,.05,-.07)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)
text(Xp,labels=factor(rv$rv))


</code></pre>

<hr>
<h2 id='rel.verts.tri.nondegPE'>The indices of the vertex regions in a triangle
that contains the points in a give data set</h2><span id='topic+rel.verts.tri.nondegPE'></span>

<h3>Description</h3>

<p>Returns the indices of the vertices
whose regions contain the points in data set <code>Xp</code> in
a triangle <code>tri</code><code class="reqn">=(A,B,C)</code>
and vertex regions are based on the center <code>cent</code>
which yields nondegenerate asymptotic
distribution of the domination number of PE-PCD
for uniform data in <code>tri</code>
for expansion parameter <code>r</code> in <code class="reqn">(1,1.5]</code>.
</p>
<p>Vertices of triangle <code>tri</code> are labeled as <code class="reqn">1,2,3</code>
according to the row number the vertex is recorded
if a point in <code>Xp</code> is not inside <code>tri</code>,
then the function yields <code>NA</code> as output for that entry.
The corresponding vertex region is the polygon with the vertex, <code>cent</code>,
and projection points on the edges.
The center label <code>cent</code> values <code>1,2,3</code>
correspond to the vertices <code class="reqn">M_1</code>, <code class="reqn">M_2</code>, and <code class="reqn">M_3</code>;
with default 1 (see the examples for an illustration).
</p>
<p>See also (Ceyhan (2005, 2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.verts.tri.nondegPE(Xp, tri, r, cent = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.verts.tri.nondegPE_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points
for which indices of the vertex regions
containing them are to be determined.</p>
</td></tr>
<tr><td><code id="rel.verts.tri.nondegPE_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="rel.verts.tri.nondegPE_+3A_r">r</code></td>
<td>
<p>A positive real number
which serves as the expansion parameter in PE proximity region;
must be in <code class="reqn">(1,1.5]</code> for this function.</p>
</td></tr>
<tr><td><code id="rel.verts.tri.nondegPE_+3A_cent">cent</code></td>
<td>
<p>Index of the center
(as <code class="reqn">1,2,3</code> corresponding to <code class="reqn">M_1,\,M_2,\,M_3</code>)
which gives nondegenerate asymptotic
distribution of the domination number of PE-PCD
for uniform data in <code>tri</code>
for expansion parameter <code>r</code> in <code class="reqn">(1,1.5]</code>;
default <code>cent=1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Indices (i.e., a <code>vector</code> of indices)
of the vertices whose region contains points in <code>Xp</code>
in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.verts.triCM">rel.verts.triCM</a></code>, <code><a href="#topic+rel.verts.triCC">rel.verts.triCC</a></code>,
and <code><a href="#topic+rel.verts.tri">rel.verts.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
r&lt;-1.35
cent&lt;-2

P&lt;-c(1.4,1.0)
rel.verts.tri.nondegPE(P,Tr,r,cent)

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

rel.verts.tri.nondegPE(Xp,Tr,r,cent)
rel.verts.tri.nondegPE(rbind(Xp,c(2,2)),Tr,r,cent)

rv&lt;-rel.verts.tri.nondegPE(Xp,Tr,r,cent)

M&lt;-center.nondegPE(Tr,r)[cent,];
Ds&lt;-prj.nondegPEcent2edges(Tr,r,cent)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".",col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]+c(-.03,.05,.05)
yc&lt;-Tr[,2]+c(-.06,.02,.05)
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(.02,.04,-.03,0)
yc&lt;-txt[,2]+c(.07,.03,.05,-.07)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)
text(Xp,labels=factor(rv$rv))


</code></pre>

<hr>
<h2 id='rel.verts.triCC'>The indices of the <code class="reqn">CC</code>-vertex regions in a triangle
that contains the points in a give data set.</h2><span id='topic+rel.verts.triCC'></span>

<h3>Description</h3>

<p>Returns the indices of the vertices
whose regions contain the points in data set <code>Xp</code> in
a triangle <code>tri</code><code class="reqn">=(A,B,C)</code>
and vertex regions are based on the circumcenter <code class="reqn">CC</code> of <code>tri</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of the  triangle <code>tri</code> are labeled as
<code class="reqn">1=A</code>, <code class="reqn">2=B</code>, and <code class="reqn">3=C</code> also
according to the row number the vertex is recorded in <code>tri</code>.
If a point in <code>Xp</code> is not inside <code>tri</code>,
then the function yields <code>NA</code> as output.
The corresponding vertex region is the polygon
whose interior points are closest to that vertex.
If <code>tri</code> is equilateral triangle,
then <code class="reqn">CC</code> and <code class="reqn">CM</code> (center of mass) coincide.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.verts.triCC(Xp, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.verts.triCC_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points
for which indices of the vertex regions
containing them are to be determined.</p>
</td></tr>
<tr><td><code id="rel.verts.triCC_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix
with each row representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Indices (i.e., a <code>vector</code> of indices) of the vertices
whose region contains points in <code>Xp</code>
in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.verts.triCM">rel.verts.triCM</a></code>, <code><a href="#topic+rel.verts.tri">rel.verts.tri</a></code>,
and <code><a href="#topic+rel.verts.tri.nondegPE">rel.verts.tri.nondegPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

P&lt;-c(.4,.2)
rel.verts.triCC(P,Tr)

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

rel.verts.triCC(Xp,Tr)
rel.verts.triCC(rbind(Xp,c(2,2)),Tr)

(rv&lt;-rel.verts.triCC(Xp,Tr))

CC&lt;-circumcenter.tri(Tr)
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1],CC[1])
Ylim&lt;-range(Tr[,2],Xp[,2],CC[2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",asp=1,xlab="",ylab="",
main="Scatterplot of data points \n and the CC-vertex regions",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".",col=1)
L&lt;-matrix(rep(CC,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]
yc&lt;-Tr[,2]
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(CC,Ds)
xc&lt;-txt[,1]+c(.04,.04,-.03,0)
yc&lt;-txt[,2]+c(-.07,.04,.06,-.08)
txt.str&lt;-c("CC","D1","D2","D3")
text(xc,yc,txt.str)
text(Xp,labels=factor(rv$rv))


</code></pre>

<hr>
<h2 id='rel.verts.triCM'>The indices of the <code class="reqn">CM</code>-vertex regions in a triangle
that contains the points in a give data set</h2><span id='topic+rel.verts.triCM'></span>

<h3>Description</h3>

<p>Returns the indices of the vertices
whose regions contain the points in data set <code>Xp</code> in
a triangle <code>tri</code><code class="reqn">=(A,B,C)</code>
and vertex regions are based on the center of mass <code class="reqn">CM</code> of <code>tri</code>.
(see the plots in the example for illustrations).
</p>
<p>The vertices of the  triangle <code>tri</code> are labeled as
<code class="reqn">1=A</code>, <code class="reqn">2=B</code>, and <code class="reqn">3=C</code> also
according to the row number the vertex is recorded in <code>tri</code>.
If a point in <code>Xp</code> is not inside <code>tri</code>,
then the function yields <code>NA</code> as output for that entry.
The corresponding vertex region is the polygon
with the vertex, <code class="reqn">CM</code>,
and midpoints the edges crossing the vertex.
</p>
<p>See also (Ceyhan (2005, 2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.verts.triCM(Xp, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.verts.triCM_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points
for which indices of the vertex regions
containing them are to be determined.</p>
</td></tr>
<tr><td><code id="rel.verts.triCM_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Indices (i.e., a <code>vector</code> of indices) of the vertices
whose region contains points in <code>Xp</code>
in the triangle <code>tri</code></p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2012).
&ldquo;An investigation of new graph invariants related to the domination number of random proximity catch digraphs.&rdquo;
<em>Methodology and Computing in Applied Probability</em>, <b>14(2)</b>, 299-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.verts.tri">rel.verts.tri</a></code>, <code><a href="#topic+rel.verts.triCC">rel.verts.triCC</a></code>,
and <code><a href="#topic+rel.verts.tri.nondegPE">rel.verts.tri.nondegPE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);

P&lt;-c(.4,.2)
rel.verts.triCM(P,Tr)

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

rv&lt;-rel.verts.triCM(Xp,Tr)
rv

CM&lt;-(A+B+C)/3
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

Xlim&lt;-range(Tr[,1],Xp[,1])
Ylim&lt;-range(Tr[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".",col=1)
L&lt;-matrix(rep(CM,3),ncol=2,byrow=TRUE); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]+c(-.04,.05,.05)
yc&lt;-Tr[,2]+c(-.05,.05,.03)
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(CM,Ds)
xc&lt;-txt[,1]+c(.04,.04,-.03,0)
yc&lt;-txt[,2]+c(-.07,.04,.06,-.08)
txt.str&lt;-c("CM","D1","D2","D3")
text(xc,yc,txt.str)
text(Xp,labels=factor(rv$rv))


</code></pre>

<hr>
<h2 id='rel.verts.triM'>The alternative function for the indices of the M-vertex regions
in a triangle that contains the points
in a give data set</h2><span id='topic+rel.verts.triM'></span>

<h3>Description</h3>

<p>An alternative function to the function <code><a href="#topic+rel.verts.tri">rel.verts.tri</a></code>
when the center M is not the circumcenter falling outside the triangle.
This function only works for a center <code class="reqn">M</code> in the interior of the triangle,
with the projections of <code class="reqn">M</code> to the edges
along the lines joining <code class="reqn">M</code> to the vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.verts.triM(Xp, tri, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.verts.triM_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points representing the set of data points
for which indices of the vertex regions
containing them are to be determined.</p>
</td></tr>
<tr><td><code id="rel.verts.triM_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="rel.verts.triM_+3A_m">M</code></td>
<td>
<p>A 2D point in Cartesian coordinates
or a 3D point in barycentric coordinates
which serves as a center in the interior of the triangle <code>tri</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>rv</code></td>
<td>
<p>Indices of the vertices
whose regions contains points in <code>Xp</code>.</p>
</td></tr>
<tr><td><code>tri</code></td>
<td>
<p>The vertices of the triangle,
where row number corresponds to the vertex index in <code>rv</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.verts.tri">rel.verts.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
M&lt;-c(1.6,1.0)

P&lt;-c(.4,.2)
rel.verts.triM(P,Tr,M)

n&lt;-20  #try also n&lt;-40
set.seed(1)
Xp&lt;-runif.tri(n,Tr)$g

M&lt;-c(1.6,1.0)  #try also M&lt;-c(1.3,1.3)

(rv&lt;-rel.verts.tri(Xp,Tr,M))
rel.verts.triM(rbind(Xp,c(2,2)),Tr,M)

Ds&lt;-prj.cent2edges(Tr,M)

Xlim&lt;-range(Tr[,1])
Ylim&lt;-range(Tr[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp,pch=".",col=1)
L&lt;-rbind(M,M,M); R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty = 2)

xc&lt;-Tr[,1]+c(-.03,.05,.05)
yc&lt;-Tr[,2]+c(-.06,.02,.05)
txt.str&lt;-c("rv=1","rv=2","rv=3")
text(xc,yc,txt.str)

txt&lt;-rbind(M,Ds)
xc&lt;-txt[,1]+c(.02,.04,-.03,0)
yc&lt;-txt[,2]+c(.07,.03,.05,-.07)
txt.str&lt;-c("M","D1","D2","D3")
text(xc,yc,txt.str)
text(Xp,labels=factor(rv$rv))


</code></pre>

<hr>
<h2 id='rseg.circular'>Generation of points segregated (in a radial or circular fashion)
from a given set of points</h2><span id='topic+rseg.circular'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> 2D points uniformly
in <code class="reqn">(a_1-e,a_1+e) \times (a_1-e,a_1+e) \setminus B(y_i,e)</code>
(<code class="reqn">a_1</code> and <code class="reqn">b1</code> are denoted as <code>a1</code> and <code>b1</code>
as arguments) where
<code class="reqn">Y_p=(y_1,y_2,\ldots,y_{n_y})</code>
with <code class="reqn">n_y</code> being number of <code>Yp</code> points
for various values of <code>e</code>
under the segregation pattern
and <code class="reqn">B(y_i,e)</code> is the ball centered at <code class="reqn">y_i</code>
with radius <code>e</code>.
</p>
<p>Positive values of <code>e</code> yield realizations from the segregation pattern
and nonpositive values of <code>e</code> provide
a type of complete spatial randomness (CSR),
<code>e</code> should not be too large
to make the support of generated points empty,
<code>a1</code> is defaulted
to the minimum of the <code class="reqn">x</code>-coordinates of the <code>Yp</code> points,
<code>a2</code> is defaulted
to the maximum of the <code class="reqn">x</code>-coordinates of the <code>Yp</code> points,
<code>b1</code> is defaulted
to the minimum of the <code class="reqn">y</code>-coordinates of the <code>Yp</code> points,
<code>b2</code> is defaulted
to the maximum of the <code class="reqn">y</code>-coordinates of the <code>Yp</code> points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rseg.circular(
  n,
  Yp,
  e,
  a1 = min(Yp[, 1]),
  a2 = max(Yp[, 1]),
  b1 = min(Yp[, 2]),
  b2 = max(Yp[, 2])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rseg.circular_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points to be generated.</p>
</td></tr>
<tr><td><code id="rseg.circular_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points representing the reference points.
The generated points are segregated
(in a circular or radial fashion) from these points.</p>
</td></tr>
<tr><td><code id="rseg.circular_+3A_e">e</code></td>
<td>
<p>A positive real number
representing the radius of the balls centered at <code>Yp</code> points.
These balls are forbidden for the generated points
(i.e., generated points would be in the complement of union of these
balls).</p>
</td></tr>
<tr><td><code id="rseg.circular_+3A_a1">a1</code>, <code id="rseg.circular_+3A_a2">a2</code></td>
<td>
<p>Real numbers representing
the range of <code class="reqn">x</code>-coordinates in the region
(default is the range of <code class="reqn">x</code>-coordinates of the <code>Yp</code> points).</p>
</td></tr>
<tr><td><code id="rseg.circular_+3A_b1">b1</code>, <code id="rseg.circular_+3A_b2">b2</code></td>
<td>
<p>Real numbers representing
the range of <code class="reqn">y</code>-coordinates in the region
(default is the range of <code class="reqn">y</code>-coordinates of the <code>Yp</code> points).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Radial
(i.e., circular) exclusion parameter of the segregation pattern</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points <code>Yp</code>,
i.e., points from which generated points are
segregated.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points segregated
from <code>Yp</code> points</p>
</td></tr>
<tr><td><code>tri.Yp</code></td>
<td>
<p>Logical output for triangulation
based on <code>Yp</code> points should be implemented or not.
if <code>TRUE</code> triangulation based on <code>Yp</code> points is
to be implemented (default is set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and
the number of reference (i.e., <code>Yp</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the generated points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassoc.circular">rassoc.circular</a></code>, <code><a href="#topic+rseg.std.tri">rseg.std.tri</a></code>,
<code><a href="#topic+rsegII.std.tri">rsegII.std.tri</a></code>, and <code><a href="#topic+rseg.multi.tri">rseg.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-1000; ny&lt;-10
e&lt;-.15;  #try also e&lt;- -.1; #a negative e provides a CSR realization
#with default bounding box (i.e., unit square)
Y&lt;-cbind(runif(ny),runif(ny))

Xdt&lt;-rseg.circular(nx,Y,e)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

#with default bounding box (i.e., unit square)
Y&lt;-cbind(runif(ny),runif(ny))
Xdt&lt;-Xdt$gen.points
Xlim&lt;-range(Xdt[,1],Y[,1]);
Ylim&lt;-range(Xdt[,2],Y[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Y,asp=1,pch=16,col=2,lwd=2, xlab="x",ylab="y",
     main="Circular Segregation of X points from Y Points",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
points(Xdt)

#with a rectangular bounding box
a1&lt;-0; a2&lt;-10;
b1&lt;-0; b2&lt;-5;
e&lt;-1.5;
Y&lt;-cbind(runif(ny,a1,a2),runif(ny,b1,b2))
#try also Y&lt;-cbind(runif(ny,a1,a2/2),runif(ny,b1,b2/2))

Xdt&lt;-rseg.circular(nx,Y,e,a1,a2,b1,b2)$gen.points
Xlim&lt;-range(Xdt[,1],Y[,1]); Ylim&lt;-range(Xdt[,2],Y[,2])

plot(Y,pch=16,asp=1,col=2,lwd=2, xlab="x",ylab="y",
     main="Circular Segregation of X points from Y Points",
     xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
points(Xdt)


</code></pre>

<hr>
<h2 id='rseg.multi.tri'>Generation of points segregated (in a Type I fashion)
from a given set of points</h2><span id='topic+rseg.multi.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> points uniformly in the support
for Type I segregation in the convex hull of
set of points, <code>Yp</code>.
</p>
<p><code>delta</code> is the parameter of segregation
(that is, <code class="reqn">\delta 100</code> % of the area around each vertex
in each Delaunay
triangle is forbidden for point generation).
<code>delta</code> corresponds to <code>eps</code>
in the standard equilateral triangle
<code class="reqn">T_e</code> as <code class="reqn">delta=4 eps ^2/3</code> (see <code>rseg.std.tri</code> function).
</p>
<p>If <code>Yp</code> consists only of 3 points,
then the function behaves like the
function <code><a href="#topic+rseg.tri">rseg.tri</a></code>.
</p>
<p><code>DTmesh</code> must be the Delaunay triangulation of <code>Yp</code>
and <code>DTr</code> must be the corresponding Delaunay triangles
(both <code>DTmesh</code> and <code>DTr</code> are <code>NULL</code> by default).
If <code>NULL</code>, <code>DTmesh</code> is computed
via <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>
and <code>DTr</code> is computed via <code><a href="interp.html#topic+triangles">triangles</a></code>
function in <code>interp</code> package.
</p>
<p><code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function yields the triangulation nodes
with their neighbours,
and creates a triangulation object,
and <code><a href="interp.html#topic+triangles">triangles</a></code> function
yields a triangulation data structure
from the triangulation object created
by <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> (the first three columns are
the vertex indices of the Delaunay triangles.)
</p>
<p>See (Ceyhan et al. (2006); Ceyhan et al. (2007); Ceyhan (2011))
for more on the segregation pattern.
Also, see (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rseg.multi.tri(n, Yp, delta, DTmesh = NULL, DTr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rseg.multi.tri_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of points to be generated.</p>
</td></tr>
<tr><td><code id="rseg.multi.tri_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
from which Delaunay triangulation is constructed.</p>
</td></tr>
<tr><td><code id="rseg.multi.tri_+3A_delta">delta</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code>.
<code>delta</code> is the parameter of segregation
(that is, <code class="reqn">\delta 100</code> 
each Delaunay triangle is forbidden for point generation).</p>
</td></tr>
<tr><td><code id="rseg.multi.tri_+3A_dtmesh">DTmesh</code></td>
<td>
<p>Delaunay triangulation of <code>Yp</code>,
default is <code>NULL</code>,
which is computed via <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function
in <code>interp</code> package.
<code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function yields
the triangulation nodes with their neighbours, and
creates a triangulation object.</p>
</td></tr>
<tr><td><code id="rseg.multi.tri_+3A_dtr">DTr</code></td>
<td>
<p>Delaunay triangles based on <code>Yp</code>,
default is <code>NULL</code>,
which is computed via <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function
in <code>interp</code> package.
<code><a href="interp.html#topic+triangles">triangles</a></code> function yields
a triangulation data structure from the triangulation object created
by <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title
for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Exclusion parameter, <code>delta</code>,
of the Type I segregation pattern.
<code>delta</code> is in <code class="reqn">(0,1)</code> and
<code class="reqn">\delta 100</code> % area around vertices of each Delaunay triangle
is forbidden for point generation.</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of points <code>Yp</code>;
reference points, i.e.,
points from which generated points are segregated.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points segregated
from <code>Yp</code> points.</p>
</td></tr>
<tr><td><code>tri.Y</code></td>
<td>
<p>Logical output, <code>TRUE</code>,
if triangulation based on <code>Yp</code> points should be implemented.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points
and the number of reference (i.e., <code>Yp</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the reference points,
which are the <code>Yp</code> points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rseg.circular">rseg.circular</a></code>, <code><a href="#topic+rseg.std.tri">rseg.std.tri</a></code>,
<code><a href="#topic+rsegII.std.tri">rsegII.std.tri</a></code>, and <code><a href="#topic+rassoc.multi.tri">rassoc.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-1000; ny&lt;-10;

set.seed(1)
Yp&lt;-cbind(runif(ny),runif(ny))
del&lt;-.4

Xdt&lt;-rseg.multi.tri(nx,Yp,del)
Xdt
summary(Xdt)
plot(Xdt)

#or use
DTY&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")
#Delaunay triangulation based on Y points
TRY&lt;-interp::triangles(DTY)[,1:3];
Xp&lt;-rseg.multi.tri(nx,Yp,del,DTY,TRY)$gen.points
#data under CSR in the convex hull of Ypoints

Xlim&lt;-range(Yp[,1])
Ylim&lt;-range(Yp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

#plot of the data in the convex hull of Y points together with the Delaunay triangulation
DTY&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")
#Delaunay triangulation based on Y points

oldpar &lt;- par(pty="s")
plot(Xp,main="Points from Type I Segregation \n in Multipe Triangles",
xlab=" ", ylab=" ",xlim=Xlim+xd*c(-.05,.05),
ylim=Ylim+yd*c(-.05,.05),type="n")
interp::plot.triSht(DTY, add=TRUE,
do.points=TRUE,col="blue")
points(Xp,pch=".",cex=3)
par(oldpar)


</code></pre>

<hr>
<h2 id='rseg.std.tri'>Generation of points segregated (in a Type I fashion)
from the vertices of <code class="reqn">T_e</code></h2><span id='topic+rseg.std.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> points uniformly
in the standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
under the type I segregation alternative for <code>eps</code>
in <code class="reqn">(0,\sqrt{3}/3=0.5773503]</code>.
</p>
<p>In the type I segregation, the triangular forbidden regions
around the vertices are determined by
the parameter <code>eps</code>
which serves as the height of these triangles
(see examples for a sample plot.)
</p>
<p>See also (Ceyhan et al. (2006); Ceyhan et al. (2007); Ceyhan (2011)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rseg.std.tri(n, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rseg.std.tri_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of points to be generated.</p>
</td></tr>
<tr><td><code id="rseg.std.tri_+3A_eps">eps</code></td>
<td>
<p>A positive real number
representing the parameter of type I segregation (which is the
height of the triangular forbidden regions around the vertices).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The exclusion parameter, <code>eps</code>,
of the segregation pattern, which is the height
of the triangular forbidden regions around the vertices </p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of points <code>Y</code>;
reference points, i.e., points
from which generated points are segregated
(i.e., vertices of <code class="reqn">T_e</code>).</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points segregated
from <code>Y</code> points (i.e., vertices of <code class="reqn">T_e</code>).</p>
</td></tr>
<tr><td><code>tri.Y</code></td>
<td>
<p>Logical output for triangulation
based on <code>Y</code> points should be implemented or not.
if <code>TRUE</code> triangulation based on <code>Y</code> points is
to be implemented (default is set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and
the number of reference (i.e., <code>Y</code>) points, which is 3 here.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the reference points,
which are the vertices of <code class="reqn">T_e</code> here.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rseg.circular">rseg.circular</a></code>, <code><a href="#topic+rassoc.circular">rassoc.circular</a></code>,
<code><a href="#topic+rsegII.std.tri">rsegII.std.tri</a></code>, and <code><a href="#topic+rseg.multi.tri">rseg.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-100
eps&lt;-.3  #try also .15, .5, .75

set.seed(1)
Xdt&lt;-rseg.std.tri(n,eps)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

Xp&lt;-Xdt$gen.points

plot(Te,asp=1,pch=".",xlab="",ylab="",
main="Type I segregation in the \n standard equilateral triangle",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
polygon(Te)
points(Xp)

#The support for the Type I segregation alternative
sr&lt;-eps/(sqrt(3)/2)
C1&lt;-C+sr*(A-C); C2&lt;-C+sr*(B-C)
A1&lt;-A+sr*(B-A); A2&lt;-A+sr*(C-A)
B1&lt;-B+sr*(A-B); B2&lt;-B+sr*(C-B)
supp&lt;-rbind(A1,B1,B2,C2,C1,A2)

plot(Te,asp=1,pch=".",xlab="",ylab="",
main="Support of the Type I Segregation",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
if (sr&lt;=.5)
{
  polygon(Te)
  polygon(supp,col=5)
} else
{
  polygon(Te,col=5,lwd=2.5)
  polygon(rbind(A,A1,A2),col=0,border=NA)
  polygon(rbind(B,B1,B2),col=0,border=NA)
  polygon(rbind(C,C1,C2),col=0,border=NA)
}
points(Xp)


</code></pre>

<hr>
<h2 id='rseg.tri'>Generation of points segregated (in a Type I fashion)
from the vertices of a triangle</h2><span id='topic+rseg.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> points uniformly in the support
for Type I segregation in a given triangle, <code>tri</code>.
</p>
<p><code>delta</code> is the parameter of segregation (that is,
<code class="reqn">\delta 100</code> % of the area around each vertex
in the triangle is forbidden for point generation).
<code>delta</code> corresponds to <code>eps</code> in the
standard equilateral triangle <code class="reqn">T_e</code> as <code class="reqn">delta=4 eps^2/3</code>
(see <code>rseg.std.tri</code>  function).
</p>
<p>See (Ceyhan et al. (2006); Ceyhan et al. (2007); Ceyhan (2011))
for more on the segregation pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rseg.tri(n, tri, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rseg.tri_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points
to be generated from the segregation pattern
in the triangle, <code>tri</code>.</p>
</td></tr>
<tr><td><code id="rseg.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
<tr><td><code id="rseg.tri_+3A_delta">delta</code></td>
<td>
<p>A positive real number in <code class="reqn">(0,1)</code>.
<code>delta</code> is the parameter of segregation (that is,
<code class="reqn">\delta 100</code> % area around vertices of
each Delaunay triangle is forbidden for point generation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title
for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Exclusion parameter, <code>delta</code>,
of the Type I segregation pattern.
<code>delta</code> is in <code class="reqn">(0,1)</code> and
<code class="reqn">\delta 100</code> % area around vertices of
the triangle <code>tri</code> is forbidden for point generation.</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of points, i.e., vertices of <code>tri</code>;
reference points, i.e., points
from which generated points are segregated.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points segregated
from the vertices of <code>tri</code>.</p>
</td></tr>
<tr><td><code>tri.Y</code></td>
<td>
<p>Logical output,
if <code>TRUE</code> the triangle <code>tri</code> is also plotted when the
corresponding plot function from the <code>Patterns</code> object is called.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points
and the number of reference (i.e., vertex of <code>tri</code>,
which is 3 here).</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the reference points,
which are the vertices of the triangle <code>tri</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2011).
&ldquo;Spatial Clustering Tests Based on Domination Number of a New Random Digraph Family.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>40(8)</b>, 1363-1395.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassoc.tri">rassoc.tri</a></code>, <code><a href="#topic+rseg.std.tri">rseg.std.tri</a></code>,
<code><a href="#topic+rsegII.std.tri">rsegII.std.tri</a></code>, and <code><a href="#topic+rseg.multi.tri">rseg.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-100
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C)
del&lt;-.4

Xdt&lt;-rseg.tri(n,Tr,del)
Xdt
summary(Xdt)
plot(Xdt)

Xp&lt;-Xdt$g
Xlim&lt;-range(Tr[,1])
Ylim&lt;-range(Tr[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tr,pch=".",xlab="",ylab="",
main="Points from Type I Segregation \n in one Triangle",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp)
xc&lt;-Tr[,1]+c(-.02,.02,.02)
yc&lt;-Tr[,2]+c(.02,.02,.03)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='rsegII.std.tri'>Generation of points segregated (in a Type II fashion)
from the vertices of <code class="reqn">T_e</code></h2><span id='topic+rsegII.std.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Patterns"</code>.
Generates <code>n</code> points uniformly
in the standard equilateral triangle
<code class="reqn">T_e=T((0,0),(1,0),(1/2,\sqrt{3}/2))</code>
under the type II segregation alternative
for <code>eps</code> in <code class="reqn">(0,\sqrt{3}/6=0.2886751]</code>.
</p>
<p>In the type II segregation, the annular forbidden regions
around the edges are determined by
the parameter <code>eps</code> which is the distance from the interior triangle
(i.e., support for the segregation)
to <code class="reqn">T_e</code> (see examples for a sample plot.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsegII.std.tri(n, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsegII.std.tri_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of points to be generated.</p>
</td></tr>
<tr><td><code id="rsegII.std.tri_+3A_eps">eps</code></td>
<td>
<p>A positive real number
representing the parameter of type II segregation (which is the
distance from the interior triangle points to the boundary of <code class="reqn">T_e</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The exclusion parameter,
<code>eps</code>, of the segregation pattern,
which is the distance from the interior triangle to <code class="reqn">T_e</code></p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of points <code>Y</code>;
reference points, i.e., points
from which generated points are segregated (i.e., vertices of <code class="reqn">T_e</code>).</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points
segregated from <code>Y</code> points
(i.e., vertices of <code class="reqn">T_e</code>).</p>
</td></tr>
<tr><td><code>tri.Y</code></td>
<td>
<p>Logical output for triangulation
based on <code>Y</code> points should be implemented or not.
if <code>TRUE</code> triangulation based on <code>Y</code> points is to be implemented
(default is set to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and
the number of reference (i.e., <code>Y</code>) points, which is 3 here.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the reference points,
which are the vertices of <code class="reqn">T_e</code> here</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rseg.circular">rseg.circular</a></code>, <code><a href="#topic+rassoc.circular">rassoc.circular</a></code>,
<code><a href="#topic+rseg.std.tri">rseg.std.tri</a></code>, and <code><a href="#topic+rseg.multi.tri">rseg.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-10  #try also n&lt;-20 or n&lt;-100 or 1000
eps&lt;-.15  #try also .2

set.seed(1)
Xdt&lt;-rsegII.std.tri(n,eps)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

Xp&lt;-Xdt$gen.points

plot(Te,pch=".",xlab="",ylab="",
main="Type II segregation in the \n standard equilateral triangle",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
polygon(Te)
points(Xp)

#The support for the Type II segregation alternative
C1&lt;-c(1/2,sqrt(3)/2-2*eps);
A1&lt;-c(eps*sqrt(3),eps); B1&lt;-c(1-eps*sqrt(3),eps);
supp&lt;-rbind(A1,B1,C1)

plot(Te,asp=1,pch=".",xlab="",ylab="",
main="Support of the Type II Segregation",
     xlim=Xlim+xd*c(-.01,.01),ylim=Ylim+yd*c(-.01,.01))
  polygon(Te)
  polygon(supp,col=5)
points(Xp)

</code></pre>

<hr>
<h2 id='runif.basic.tri'>Generation of Uniform Points in the standard basic triangle</h2><span id='topic+runif.basic.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Uniform"</code>.
Generates <code>n</code> points uniformly
in the standard basic triangle <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code>
and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the basic
triangle by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the original triangle
(Ceyhan (2005); Ceyhan et al. (2007); Ceyhan et al. (2006)).
Hence, standard basic triangle is useful for simulation studies
under the uniformity hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.basic.tri(n, c1, c2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.basic.tri_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of uniform points
to be generated in the standard basic triangle.</p>
</td></tr>
<tr><td><code id="runif.basic.tri_+3A_c1">c1</code>, <code id="runif.basic.tri_+3A_c2">c2</code></td>
<td>
<p>Positive real numbers representing the top vertex
in standard basic triangle
<code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>,
<code class="reqn">c_1</code> must be in <code class="reqn">[0,1/2]</code>, <code class="reqn">c_2&gt;0</code> and
<code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>The vertices of the support
of the uniformly generated points,
it is the standard basic triangle <code class="reqn">T_b</code> for this function</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points uniformly
in the standard basic triangle</p>
</td></tr>
<tr><td><code>out.region</code></td>
<td>
<p>The outer region which contains the support region,
<code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and the number
of vertices of the support points (here it is 3).</p>
</td></tr>
<tr><td><code>txt4pnts</code></td>
<td>
<p>Description of the two numbers in <code>num.points</code>.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the support, Tb</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2005).
<em>An Investigation of Proximity Catch Digraphs in Delaunay Tessellations, also available as technical monograph titled Proximity Catch Digraphs: Auxiliary Tools, Properties, and Applications</em>.
Ph.D. thesis, The Johns Hopkins University, Baltimore, MD, 21218.<br /><br /> Ceyhan E, Priebe CE, Marchette DJ (2007).
&ldquo;A new family of random graphs for testing spatial segregation.&rdquo;
<em>Canadian Journal of Statistics</em>, <b>35(1)</b>, 27-50.<br /><br /> Ceyhan E, Priebe CE, Wierman JC (2006).
&ldquo;Relative density of the random <code class="reqn">r</code>-factor proximity catch digraphs for testing spatial patterns of segregation and association.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>50(8)</b>, 1925-1964.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif.std.tri">runif.std.tri</a></code>, <code><a href="#topic+runif.tri">runif.tri</a></code>,
and <code><a href="#topic+runif.multi.tri">runif.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);
Tb&lt;-rbind(A,B,C);
n&lt;-100

set.seed(1)
runif.basic.tri(1,c1,c2)
Xdt&lt;-runif.basic.tri(n,c1,c2)
Xdt
summary(Xdt)
plot(Xdt)

Xp&lt;-runif.basic.tri(n,c1,c2)$g

Xlim&lt;-range(Tb[,1])
Ylim&lt;-range(Tb[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Tb,xlab="",ylab="",xlim=Xlim+xd*c(-.01,.01),
ylim=Ylim+yd*c(-.01,.01),type="n")
polygon(Tb)
points(Xp)


</code></pre>

<hr>
<h2 id='runif.multi.tri'>Generation of Uniform Points in the Convex Hull of Points</h2><span id='topic+runif.multi.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Uniform"</code>.
Generates <code>n</code> points uniformly
in the Convex Hull of set of points, <code>Yp</code>.
That is, generates uniformly in each of the triangles
in the Delaunay triangulation of <code>Yp</code>, i.e.,
in the multiple triangles partitioning the convex hull of <code>Yp</code>.
</p>
<p>If <code>Yp</code> consists only of 3 points,
then the function behaves like the
function <code><a href="#topic+runif.tri">runif.tri</a></code>.
</p>
<p><code>DTmesh</code> is the Delaunay triangulation of <code>Yp</code>,
default is <code>DTmesh=NULL</code>.
<code>DTmesh</code> yields triangulation nodes with neighbours
(result of <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function
from <code>interp</code> package).
</p>
<p>See (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.multi.tri(n, Yp, DTmesh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.multi.tri_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of uniform points to be generated
in the convex hull of the point set <code>Yp</code>.</p>
</td></tr>
<tr><td><code id="runif.multi.tri_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
whose convex hull is the support of the uniform points to be generated.</p>
</td></tr>
<tr><td><code id="runif.multi.tri_+3A_dtmesh">DTmesh</code></td>
<td>
<p>Triangulation nodes with neighbours
(result of <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code> function from
<code>interp</code> package).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title
for the plot of the point pattern</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>The points
which constitute the vertices of the triangulation and
whose convex hull determines the support of the generated points.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points uniformly
in the convex hull of <code>Yp</code></p>
</td></tr>
<tr><td><code>out.region</code></td>
<td>
<p>The outer region which contains the support region,
<code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and
the number of vertices in the triangulation
(i.e., size of <code>Yp</code>) points.</p>
</td></tr>
<tr><td><code>txt4pnts</code></td>
<td>
<p>Description of the two numbers in <code>num.points</code></p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the points in Yp</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif.tri">runif.tri</a></code>, <code><a href="#topic+runif.std.tri">runif.std.tri</a></code>,
and <code><a href="#topic+runif.basic.tri">runif.basic.tri</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-100; ny&lt;-4;  #try also nx&lt;-1000; ny&lt;-10;
set.seed(1)
Yp&lt;-cbind(runif(ny,0,10),runif(ny,0,10))

Xdt&lt;-runif.multi.tri(nx,Yp)
#data under CSR in the convex hull of Ypoints
Xdt
summary(Xdt)
plot(Xdt)

Xp&lt;-Xdt$g
#or use
DTY&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")
#Delaunay triangulation based on Y points
Xp&lt;-runif.multi.tri(nx,Yp,DTY)$g
#data under CSR in the convex hull of Ypoints

Xlim&lt;-range(Yp[,1])
Ylim&lt;-range(Yp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

#plot of the data in the convex hull of Y points together with the Delaunay triangulation
plot(Xp, xlab=" ", ylab=" ",
main="Uniform Points in Convex Hull of Y Points",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),type="n")
interp::plot.triSht(DTY, add=TRUE,
do.points = TRUE,pch=16,col="blue")
points(Xp,pch=".",cex=3)

Yp&lt;-rbind(c(.3,.2),c(.4,.5),c(.14,.15))
runif.multi.tri(nx,Yp)


</code></pre>

<hr>
<h2 id='runif.std.tetra'>Generation of Uniform Points
in the Standard Regular Tetrahedron <code class="reqn">T_h</code></h2><span id='topic+runif.std.tetra'></span>

<h3>Description</h3>

<p>An object of class <code>"Uniform"</code>.
Generates <code>n</code> points uniformly in the standard regular tetrahedron
<code class="reqn">T_h=T((0,0,0),(1,0,0),(1/2,\sqrt{3}/2,0),(1/2,\sqrt{3}/6,\sqrt{6}/3))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.std.tetra(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.std.tetra_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of uniform points to be generated in the
standard regular tetrahedron <code class="reqn">T_h</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>The vertices of the support region
of the uniformly generated points, it is the
standard regular tetrahedron <code class="reqn">T_h</code> for this function</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points uniformly
in the standard regular tetrahedron <code class="reqn">T_h</code>.</p>
</td></tr>
<tr><td><code>out.region</code></td>
<td>
<p>The outer region which contains the support region,
<code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and the number
of vertices of the support points (here it is 4).</p>
</td></tr>
<tr><td><code>txt4pnts</code></td>
<td>
<p>Description of the two numbers in <code>num.points</code></p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code>, <code>zlimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-, <code class="reqn">y</code>-,
and <code class="reqn">z</code>-coordinates of the support, <code class="reqn">T_h</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif.tetra">runif.tetra</a></code>, <code><a href="#topic+runif.tri">runif.tri</a></code>,
and <code><a href="#topic+runif.multi.tri">runif.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0,0); B&lt;-c(1,0,0); C&lt;-c(1/2,sqrt(3)/2,0); D&lt;-c(1/2,sqrt(3)/6,sqrt(6)/3)
tetra&lt;-rbind(A,B,C,D)
n&lt;-100

set.seed(1)
Xdt&lt;-runif.std.tetra(n)
Xdt
summary(Xdt)
plot(Xdt)

Xp&lt;-runif.std.tetra(n)$g

Xlim&lt;-range(tetra[,1])
Ylim&lt;-range(tetra[,2])
Zlim&lt;-range(tetra[,3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::scatter3D(Xp[,1],Xp[,2],Xp[,3],
phi =20,theta=15, bty = "g", pch = 20, cex = 1,
ticktype = "detailed",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),
zlim=Zlim+zd*c(-.05,.05))
#add the vertices of the tetrahedron
plot3D::points3D(tetra[,1],tetra[,2],tetra[,3], add=TRUE)
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],
add=TRUE,lwd=2)

plot3D::text3D(tetra[,1]+c(.05,0,0,0),tetra[,2],tetra[,3],
labels=c("A","B","C","D"), add=TRUE)

s3d&lt;-scatterplot3d::scatterplot3d(Xp, highlight.3d=TRUE,xlab="x",
ylab="y",zlab="z", col.axis="blue", col.grid="lightblue",
               main="3D Scatterplot of the data", pch=20)
s3d$points3d(tetra,pch=20,col="blue")


</code></pre>

<hr>
<h2 id='runif.std.tri'>Generation of Uniform Points in the Standard Equilateral Triangle</h2><span id='topic+runif.std.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Uniform"</code>.
Generates <code>n</code> points uniformly
in the standard equilateral triangle <code class="reqn">T_e=T(A,B,C)</code>
with vertices <code class="reqn">A=(0,0)</code>, <code class="reqn">B=(1,0)</code>, and <code class="reqn">C=(1/2,\sqrt{3}/2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.std.tri(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.std.tri_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of uniform points
to be generated in the standard equilateral triangle <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>The vertices of the support region of
the uniformly generated points, it is the
standard equilateral triangle <code class="reqn">T_e</code> for this function</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points uniformly
in the standard equilateral triangle <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code>out.region</code></td>
<td>
<p>The outer region which contains the support region,
<code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and the number
of vertices of the support points (here it is 3).</p>
</td></tr>
<tr><td><code>txt4pnts</code></td>
<td>
<p>Description of the two numbers in <code>num.points</code></p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the support, <code class="reqn">T_e</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif.basic.tri">runif.basic.tri</a></code>, <code><a href="#topic+runif.tri">runif.tri</a></code>,
and <code><a href="#topic+runif.multi.tri">runif.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
n&lt;-100

set.seed(1)
Xdt&lt;-runif.std.tri(n)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

Xp&lt;-runif.std.tri(n)$gen.points
plot(Te,asp=1,pch=".",xlab="",ylab="",xlim=Xlim+xd*c(-.01,.01),
ylim=Ylim+yd*c(-.01,.01))
polygon(Te)
points(Xp)


</code></pre>

<hr>
<h2 id='runif.std.tri.onesixth'>Generation of Uniform Points in the first one-sixth of
standard equilateral triangle</h2><span id='topic+runif.std.tri.onesixth'></span>

<h3>Description</h3>

<p>An object of class <code>"Uniform"</code>.
Generates <code>n</code> points uniformly
in the first 1/6th of the standard equilateral triangle <code class="reqn">T_e=(A,B,C)</code>
with vertices with <code class="reqn">A=(0,0)</code>; <code class="reqn">B=(1,0)</code>, <code class="reqn">C=(1/2,\sqrt{3}/2)</code>
(see the examples below).
The first 1/6th of the standard equilateral triangle is the triangle with vertices
<code class="reqn">A=(0,0)</code>, <code class="reqn">(1/2,0)</code>, <code class="reqn">C=(1/2,\sqrt{3}/6)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.std.tri.onesixth(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.std.tri.onesixth_+3A_n">n</code></td>
<td>
<p>a positive integer representing number of uniform points
to be generated
in the first one-sixth of <code class="reqn">T_e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>The vertices of the support of
the uniformly generated points</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of uniformly generated points
in the first 1/6th of
the standard equilateral triangle.</p>
</td></tr>
<tr><td><code>out.region</code></td>
<td>
<p>The outer region for the one-sixth of <code class="reqn">T_e</code>,
which is just <code class="reqn">T_e</code> here.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points
and the number of vertices of the support (i.e., <code>Y</code>) points.</p>
</td></tr>
<tr><td><code>txt4pnts</code></td>
<td>
<p>Description of the two numbers in <code>num.points</code>.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the generated,
support and outer region points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif.std.tri">runif.std.tri</a></code>, <code><a href="#topic+runif.basic.tri">runif.basic.tri</a></code>,
<code><a href="#topic+runif.tri">runif.tri</a></code>, and <code><a href="#topic+runif.multi.tri">runif.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C);
CM&lt;-(A+B+C)/3;
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)
nx&lt;-100  #try also nx&lt;-1000

#data generation step
set.seed(1)
Xdt&lt;-runif.std.tri.onesixth(nx)
Xdt
summary(Xdt)
plot(Xdt,asp=1)

Xd&lt;-Xdt$gen.points

#plot of the data with the regions in the equilateral triangle
Xlim&lt;-range(Te[,1])
Ylim&lt;-range(Te[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(Te,asp=1,pch=".",xlim=Xlim+xd*c(-.01,.01),
ylim=Ylim+yd*c(-.01,.01),xlab=" ",ylab=" ",
     main="first 1/6th of the \n standard equilateral triangle")
polygon(Te)
L&lt;-Te; R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
polygon(rbind(A,D3,CM),col=5)
points(Xd)

#letter annotation of the plot
txt&lt;-rbind(A,B,C,CM,D1,D2,D3)
xc&lt;-txt[,1]+c(-.02,.02,.02,.04,.05,-.03,0)
yc&lt;-txt[,2]+c(.02,.02,.02,.03,0,.03,-.03)
txt.str&lt;-c("A","B","C","CM","D1","D2","D3")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='runif.tetra'>Generation of Uniform Points in a tetrahedron</h2><span id='topic+runif.tetra'></span>

<h3>Description</h3>

<p>An object of class <code>"Uniform"</code>.
Generates <code>n</code> points uniformly
in the general tetrahedron <code>th</code>
whose vertices are stacked row-wise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.tetra(n, th)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.tetra_+3A_n">n</code></td>
<td>
<p>A positive integer
representing the number of uniform points
to be generated in the tetrahedron.</p>
</td></tr>
<tr><td><code id="runif.tetra_+3A_th">th</code></td>
<td>
<p>A <code class="reqn">4 \times 3</code> matrix with each row
representing a vertex of the tetrahedron.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title
for the plot of the point pattern</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>The vertices of the support of
the uniformly generated points,
it is the tetrahedron' <code>th</code> for this function</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points uniformly
in the tetrahedron, <code>th</code>.</p>
</td></tr>
<tr><td><code>out.region</code></td>
<td>
<p>The outer region
which contains the support region,
<code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and the number
of vertices of the support points (here it is 4).</p>
</td></tr>
<tr><td><code>txt4pnts</code></td>
<td>
<p>Description of the two numbers in <code>num.points</code></p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code>, <code>zlimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-, <code class="reqn">y</code>-,
and <code class="reqn">z</code>-coordinates of the support, <code>th</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif.std.tetra">runif.std.tetra</a></code> and <code><a href="#topic+runif.tri">runif.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-sample(1:12,3); B&lt;-sample(1:12,3);
C&lt;-sample(1:12,3); D&lt;-sample(1:12,3)
tetra&lt;-rbind(A,B,C,D)

n&lt;-100

set.seed(1)
Xdt&lt;-runif.tetra(n,tetra)
Xdt
summary(Xdt)
plot(Xdt)

Xp&lt;-Xdt$g

Xlim&lt;-range(tetra[,1],Xp[,1])
Ylim&lt;-range(tetra[,2],Xp[,2])
Zlim&lt;-range(tetra[,3],Xp[,3])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
zd&lt;-Zlim[2]-Zlim[1]

plot3D::scatter3D(Xp[,1],Xp[,2],Xp[,3],
theta =225, phi = 30, bty = "g",
main="Uniform Points in a Tetrahedron",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),
zlim=Zlim+zd*c(-.05,.05),
          pch = 20, cex = 1, ticktype = "detailed")
#add the vertices of the tetrahedron
plot3D::points3D(tetra[,1],tetra[,2],tetra[,3], add=TRUE)
L&lt;-rbind(A,A,A,B,B,C); R&lt;-rbind(B,C,D,C,D,D)
plot3D::segments3D(L[,1], L[,2], L[,3], R[,1], R[,2],R[,3],
add=TRUE,lwd=2)

plot3D::text3D(tetra[,1],tetra[,2],tetra[,3],
labels=c("A","B","C","D"), add=TRUE)

s3d&lt;-scatterplot3d::scatterplot3d(Xp, highlight.3d=TRUE,
xlab="x",ylab="y",zlab="z", col.axis="blue", col.grid="lightblue",
                    main="3D Scatterplot of the data", pch=20)
 s3d$points3d(tetra,pch=20,col="blue")
 

</code></pre>

<hr>
<h2 id='runif.tri'>Generation of Uniform Points in a Triangle</h2><span id='topic+runif.tri'></span>

<h3>Description</h3>

<p>An object of class <code>"Uniform"</code>.
Generates <code>n</code> points uniformly in a given triangle, <code>tri</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.tri(n, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.tri_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of uniform points
to be generated in the triangle.</p>
</td></tr>
<tr><td><code id="runif.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>tess.points</code></td>
<td>
<p>The vertices of the support of
the uniformly generated points, it is the triangle
<code>tri</code> for this function</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points uniformly
in the triangle, <code>tri</code>.</p>
</td></tr>
<tr><td><code>out.region</code></td>
<td>
<p>The outer region which contains the support region,
<code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern
from which points are to be generated</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers,
which are the number of generated points and the number
of vertices of the support points (here it is 3).</p>
</td></tr>
<tr><td><code>txt4pnts</code></td>
<td>
<p>Description of the two numbers in <code>num.points</code></p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The ranges of the <code class="reqn">x</code>-
and <code class="reqn">y</code>-coordinates of the support, <code>tri</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif.std.tri">runif.std.tri</a></code>, <code><a href="#topic+runif.basic.tri">runif.basic.tri</a></code>,
and <code><a href="#topic+runif.multi.tri">runif.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-100
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C)

Xdt&lt;-runif.tri(n,Tr)
Xdt
summary(Xdt)
plot(Xdt)

Xp&lt;-Xdt$g
Xlim&lt;-range(Tr[,1])
Ylim&lt;-range(Tr[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]
plot(Tr,pch=".",xlab="",ylab="",main="Uniform Points in One Triangle",
     xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
points(Xp)
xc&lt;-Tr[,1]+c(-.02,.02,.02)
yc&lt;-Tr[,2]+c(.02,.02,.04)
txt.str&lt;-c("A","B","C")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='seg.tri.support'>The auxiliary triangle to define the support of type I segregation</h2><span id='topic+seg.tri.support'></span>

<h3>Description</h3>

<p>Returns the triangle whose intersection
with a general triangle gives the support for
type I segregation given the <code>delta</code>
(i.e., <code class="reqn">\delta 100</code> % area of a triangle around the
vertices is chopped off).
See the plot in the examples.
</p>
<p>Caveat: the vertices of this triangle may be
outside the triangle, <code>tri</code>, depending on the value of
<code>delta</code> (i.e., for small values of <code>delta</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg.tri.support(delta, tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seg.tri.support_+3A_delta">delta</code></td>
<td>
<p>A positive real number between 0 and 1
that determines the percentage of area of the triangle
around the vertices forbidden for point generation.</p>
</td></tr>
<tr><td><code id="seg.tri.support_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vertices of the triangle (stacked row-wise)
whose intersection with a general triangle
gives the support for type I segregation for the given <code>delta</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rseg.std.tri">rseg.std.tri</a></code> and <code><a href="#topic+rseg.multi.tri">rseg.multi.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#for a general triangle
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
delta&lt;-.3  #try also .5,.75,.85
Tseg&lt;-seg.tri.support(delta,Tr)

Xlim&lt;-range(Tr[,1],Tseg[,1])
Ylim&lt;-range(Tr[,2],Tseg[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

oldpar &lt;- par(pty="s")
plot(Tr,pch=".",xlab="",ylab="",
main="segregation support is the intersection\n of these two triangles",
axes=TRUE,xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05))
polygon(Tr)
polygon(Tseg,lty=2)

txt&lt;-rbind(Tr,Tseg)
xc&lt;-txt[,1]+c(-.03,.03,.03,.06,.04,-.04)
yc&lt;-txt[,2]+c(.02,.02,.04,-.03,0,0)
txt.str&lt;-c("A","B","C","T1","T2","T3")
text(xc,yc,txt.str)
par(oldpar)


</code></pre>

<hr>
<h2 id='six.extremaTe'>The closest points among a data set
in the standard equilateral triangle
to the median lines in the six  half edge regions</h2><span id='topic+six.extremaTe'></span>

<h3>Description</h3>

<p>An object of class <code>"Extrema"</code>.
Returns the six closest points among the data set, <code>Xp</code>,
in the standard equilateral triangle
<code class="reqn">T_e=T(A=(0,0),B=(1,0),C=(1/2,\sqrt{3}/2))</code> in half edge regions.
In particular,
in regions <code class="reqn">r_1</code> and <code class="reqn">r_6</code>,
it finds the closest point
in each region to the line segment <code class="reqn">[A,CM]</code>
in regions <code class="reqn">r_2</code> and <code class="reqn">r_3</code>,
it finds the closest point
in each region to the line segment <code class="reqn">[B,CM]</code> and
in regions <code class="reqn">r_4</code> and <code class="reqn">r_5</code>,
it finds the closest point
in each region to the line segment <code class="reqn">[C,CM]</code>
where <code class="reqn">CM=(A+B+C)/3</code> is the center of mass.
</p>
<p>See the example for this function or example for
<code>index.six.Te</code> function.
If there is no data point in region <code class="reqn">r_i</code>,
then it returns &quot;<code>NA</code> <code>NA</code>&quot; for <code class="reqn">i</code>-th row in the extrema.
<code>ch.all.intri</code> is for checking
whether all data points are in <code class="reqn">T_e</code> (default is <code>FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>six.extremaTe(Xp, ch.all.intri = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="six.extremaTe_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
among which the closest points in the standard equilateral triangle
to the median lines in 6 half edge regions.</p>
</td></tr>
<tr><td><code id="six.extremaTe_+3A_ch.all.intri">ch.all.intri</code></td>
<td>
<p>A logical argument
for checking whether all data points are in <code class="reqn">T_e</code>
(default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>txt1</code></td>
<td>
<p>Region labels as r1-r6
(correspond to row number in Extremum Points).</p>
</td></tr>
<tr><td><code>txt2</code></td>
<td>
<p>A short description of the distances
as <code>"Distances to Line Segments (A,CM), (B,CM),
and (C,CM) in the six regions r1-r6"</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of the extrema points</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the extrema</p>
</td></tr>
<tr><td><code>ext</code></td>
<td>
<p>The extrema points, here,
closest points in each of regions <code>r1-r6</code> to the line segments
joining vertices to the center of mass, <code class="reqn">CM</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The input data, <code>Xp</code>,
can be a <code>matrix</code> or <code>data frame</code></p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of data points, i.e., size of <code>Xp</code></p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>Support of the data points, here, it is <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code>cent</code></td>
<td>
<p>The center point used for construction of edge regions.</p>
</td></tr>
<tr><td><code>ncent</code></td>
<td>
<p>Name of the center, <code>cent</code>,
it is center of mass <code>"CM"</code> for this function.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>The six regions, <code>r1-r6</code>
and edge regions inside the triangle, <code class="reqn">T_e</code>, provided as a list.</p>
</td></tr>
<tr><td><code>region.names</code></td>
<td>
<p>Names of the regions
as <code>"r1"</code>-<code>"r6"</code> and
names of the edge regions as <code>"er=1"</code>, <code>"er=2"</code>,
and <code>"er=3"</code>.</p>
</td></tr>
<tr><td><code>region.centers</code></td>
<td>
<p>Centers of mass of the regions <code>r1-r6</code>
and of edge regions inside <code class="reqn">T_e</code>.</p>
</td></tr>
<tr><td><code>dist2ref</code></td>
<td>
<p>Distances from closest points
in each of regions <code>r1-r6</code> to the line segments
joining vertices to the center of mass, <code class="reqn">CM</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.six.Te">index.six.Te</a></code> and <code><a href="#topic+cl2edges.std.tri">cl2edges.std.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-20  #try also n&lt;-100
Xp&lt;-runif.std.tri(n)$gen.points

Ext&lt;-six.extremaTe(Xp)
Ext
summary(Ext)
plot(Ext)

sixt&lt;-Ext

A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(0.5,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
CM&lt;-(A+B+C)/3
D1&lt;-(B+C)/2; D2&lt;-(A+C)/2; D3&lt;-(A+B)/2;
Ds&lt;-rbind(D1,D2,D3)

h1&lt;-c(1/2,sqrt(3)/18); h2&lt;-c(2/3, sqrt(3)/9); h3&lt;-c(2/3, 2*sqrt(3)/9);
h4&lt;-c(1/2, 5*sqrt(3)/18); h5&lt;-c(1/3, 2*sqrt(3)/9); h6&lt;-c(1/3, sqrt(3)/9);

r1&lt;-(h1+h6+CM)/3;r2&lt;-(h1+h2+CM)/3;r3&lt;-(h2+h3+CM)/3;
r4&lt;-(h3+h4+CM)/3;r5&lt;-(h4+h5+CM)/3;r6&lt;-(h5+h6+CM)/3;

Xlim&lt;-range(Te[,1],Xp[,1])
Ylim&lt;-range(Te[,2],Xp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

plot(A,pch=".",xlab="",ylab="",axes=TRUE,xlim=Xlim+xd*c(-.05,.05),
ylim=Ylim+yd*c(-.05,.05))
polygon(Te)
L&lt;-Te; R&lt;-Ds
segments(L[,1], L[,2], R[,1], R[,2], lty=2)
polygon(rbind(h1,h2,h3,h4,h5,h6))
points(Xp)
points(sixt$ext,pty=2,pch=4,col="red")

txt&lt;-rbind(Te,r1,r2,r3,r4,r5,r6)
xc&lt;-txt[,1]+c(-.02,.02,.02,0,0,0,0,0,0)
yc&lt;-txt[,2]+c(.02,.02,.03,0,0,0,0,0,0)
txt.str&lt;-c("A","B","C","1","2","3","4","5","6")
text(xc,yc,txt.str)


</code></pre>

<hr>
<h2 id='slope'>The slope of a line</h2><span id='topic+slope'></span>

<h3>Description</h3>

<p>Returns the slope of the line
joining two distinct 2D points <code>a</code> and <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slope_+3A_a">a</code>, <code id="slope_+3A_b">b</code></td>
<td>
<p>2D points that determine the straight line
(i.e., through which the straight line passes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Slope of the line joining 2D points <code>a</code> and <code>b</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Line">Line</a></code>, <code><a href="#topic+paraline">paraline</a></code>,
and <code><a href="#topic+perpline">perpline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-c(-1.22,-2.33); B&lt;-c(2.55,3.75)
slope(A,B)

slope(c(1,2),c(2,3))

</code></pre>

<hr>
<h2 id='summary.Extrema'>Return a summary of a <code>Extrema</code> <code>object</code></h2><span id='topic+summary.Extrema'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>,
the <code>type</code> of the extrema (i.e. the description
of the extrema), extrema points,
distances from extrema to the reference <code>object</code>
(e.g. boundary of a triangle),
some of the data points (from which extrema is found).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Extrema'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Extrema_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>Extrema</code>.</p>
</td></tr>
<tr><td><code id="summary.Extrema_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Extrema"</code>,
the <code>type</code> of the extrema (i.e. the description
of the extrema), extrema points,
distances from extrema to the reference <code>object</code>
(e.g. boundary of a triangle),
some of the data points (from which extrema is found).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Extrema">print.Extrema</a></code>,
<code><a href="#topic+print.summary.Extrema">print.summary.Extrema</a></code>,
and <code><a href="#topic+plot.Extrema">plot.Extrema</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10
Xp&lt;-runif.std.tri(n)$gen.points
Ext&lt;-cl2edges.std.tri(Xp)
Ext
summary(Ext)


</code></pre>

<hr>
<h2 id='summary.Lines'>Return a summary of a <code>Lines</code> <code>object</code></h2><span id='topic+summary.Lines'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>,
the defining <code>points</code>, selected <code class="reqn">x</code>
and <code class="reqn">y</code> points on the line,
equation of the line, and <code>coefficients</code> of the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lines'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Lines_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>Lines</code>.</p>
</td></tr>
<tr><td><code id="summary.Lines_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Lines"</code>,
the defining <code>points</code>, selected <code class="reqn">x</code>
and <code class="reqn">y</code> points on the line,
equation of the line, and <code>coefficients</code> of the line
(in the form: <code>y = slope * x + intercept</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Lines">print.Lines</a></code>, <code><a href="#topic+print.summary.Lines">print.summary.Lines</a></code>,
and <code><a href="#topic+plot.Lines">plot.Lines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-c(-1.22,-2.33); B&lt;-c(2.55,3.75)
xr&lt;-range(A,B);
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=3) #try also l=10, 20 or 100

lnAB&lt;-Line(A,B,x)
lnAB
summary(lnAB)

</code></pre>

<hr>
<h2 id='summary.Lines3D'>Return a summary of a <code>Lines3D</code> <code>object</code></h2><span id='topic+summary.Lines3D'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>, the defining vectors (i.e., initial and direction vectors),
selected <code class="reqn">x</code>, <code class="reqn">y</code>, and <code class="reqn">z</code> points on the line,
equation of the line (in parametric form), and <code>coefficients</code> of the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lines3D'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Lines3D_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>Lines3D</code>.</p>
</td></tr>
<tr><td><code id="summary.Lines3D_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>call</code> of the function defining the <code>object</code>,
the defining vectors (i.e., initial and direction vectors),
selected <code class="reqn">x</code>, <code class="reqn">y</code>, and <code class="reqn">z</code> points on the line,
equation of the line (in parametric form),
and <code>coefficients</code> of the line
(for the form: <code>x=x0 + A*t</code>, <code>y=y0 + B*t</code>,
and <code>z=z0 + C*t</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Lines3D">print.Lines3D</a></code>,
<code><a href="#topic+print.summary.Lines3D">print.summary.Lines3D</a></code>,
and <code><a href="#topic+plot.Lines3D">plot.Lines3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(1,10,3); Q&lt;-c(1,1,3);
vecs&lt;-rbind(P,Q)
Line3D(P,Q,.1)
Line3D(P,Q,.1,dir.vec=FALSE)

tr&lt;-range(vecs);
tf&lt;-(tr[2]-tr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
tsq&lt;-seq(-tf*10-tf,tf*10+tf,l=3) #try also l=10, 20 or 100

lnPQ3D&lt;-Line3D(P,Q,tsq)
lnPQ3D
summary(lnPQ3D)


</code></pre>

<hr>
<h2 id='summary.NumArcs'>Return a summary of a <code>NumArcs</code> <code>object</code></h2><span id='topic+summary.NumArcs'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>,
the description of the output, <code>desc</code>:
number of arcs in the proximity catch digraph (PCD) and
related quantities in the induced subdigraphs for points in the Delaunay cells.
In the one Delaunay cell case, the function provides
the total number of arcs in the digraph,
vertices of Delaunay cell, and
indices of target points in the Delaunay cell.
</p>
<p>In the multiple Delaunay cell case, the function provides
total number of arcs in the digraph,
number of arcs for the induced digraphs for points in the Delaunay cells,
vertices of Delaunay cells or indices of points that form the the Delaunay cells,
indices of target points in the convex hull of nontarget points,
indices of Delaunay cells in which points reside,
and area or length of the the Delaunay cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NumArcs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NumArcs_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>NumArcs</code>.</p>
</td></tr>
<tr><td><code id="summary.NumArcs_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"NumArcs"</code>,
the <code>desc</code> of the output:
total number of arcs in the digraph.
Moreover, in the one Delaunay cell case, the function also provides
vertices of Delaunay cell, and
indices of target points in the Delaunay cell;
and in the multiple Delaunay cell case, it also provides
number of arcs for the induced subdigraphs for points in the Delaunay cells,
vertices of Delaunay cells or indices of points that form the the Delaunay cells,
indices of target points in the convex hull of nontarget points,
indices of Delaunay cells in which points reside,
and area or length of the the Delaunay cells.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.NumArcs">print.NumArcs</a></code>, <code><a href="#topic+print.summary.NumArcs">print.summary.NumArcs</a></code>,
and <code><a href="#topic+plot.NumArcs">plot.NumArcs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10
Xp&lt;-runif.tri(n,Tr)$g
M&lt;-as.numeric(runif.tri(1,Tr)$g)
Arcs&lt;-arcsAStri(Xp,Tr,M)
Arcs
summary(Arcs)


</code></pre>

<hr>
<h2 id='summary.Patterns'>Return a summary of a <code>Patterns</code> <code>object</code></h2><span id='topic+summary.Patterns'></span>

<h3>Description</h3>

<p>Returns the below information
about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>,
the <code>type</code> of the pattern, <code>parameters</code> of the pattern,
study window, some sample points from the generated pattern,
reference points (if any for the bivariate pattern),
and number of points for each class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Patterns'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Patterns_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>Patterns</code>.</p>
</td></tr>
<tr><td><code id="summary.Patterns_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Patterns"</code>,
the <code>type</code> of the pattern, <code>parameters</code> of the pattern,
study window, some sample points from the generated pattern,
reference points (if any for the bivariate pattern),
and number of points for each class
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Patterns">print.Patterns</a></code>,
<code><a href="#topic+print.summary.Patterns">print.summary.Patterns</a></code>,
and <code><a href="#topic+plot.Patterns">plot.Patterns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nx&lt;-10; #try also 10, 100, and 1000
ny&lt;-5; #try also 1
e&lt;-.15;
Y&lt;-cbind(runif(ny),runif(ny))
#with default bounding box (i.e., unit square)

Xdt&lt;-rseg.circular(nx,Y,e)
Xdt
summary(Xdt)


</code></pre>

<hr>
<h2 id='summary.PCDs'>Return a summary of a <code>PCDs</code> <code>object</code></h2><span id='topic+summary.PCDs'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>,
the <code>type</code> of the proximity catch digraph (PCD),
(i.e. the description of the PCD),
some of the partition
(i.e. intervalization in the 1D case and triangulation
in the 2D case) points
(i.e., vertices of the intervals or the triangles),
parameter(s) of the PCD, and various quantities
(number of vertices,
number of arcs and arc density of the PCDs,
number of vertices for the partition and number of partition cells
(i.e., intervals or triangles)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PCDs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.PCDs_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>PCDs</code>.</p>
</td></tr>
<tr><td><code id="summary.PCDs_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"PCDs"</code>,
the <code>type</code> of the proximity catch digraph (PCD),
(i.e. the description of the PCD), some of the partition
(i.e. intervalization in the 1D case and triangulation
in the 2D case) points
(i.e., vertices of the intervals or the triangles),
parameter(s) of the PCD, and various quantities
(number of vertices,
number of arcs and arc density of the PCDs,
number of vertices for the partition
and number of partition cells
(i.e., intervals or triangles)).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.PCDs">print.PCDs</a></code>,
<code><a href="#topic+print.summary.PCDs">print.summary.PCDs</a></code>,
and <code><a href="#topic+plot.PCDs">plot.PCDs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,C);
n&lt;-10
Xp&lt;-runif.tri(n,Tr)$g
M&lt;-as.numeric(runif.tri(1,Tr)$g)
Arcs&lt;-arcsAStri(Xp,Tr,M)
Arcs
summary(Arcs)


</code></pre>

<hr>
<h2 id='summary.Planes'>Return a summary of a <code>Planes</code> <code>object</code></h2><span id='topic+summary.Planes'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>,
the defining 3D <code>points</code>, selected <code class="reqn">x</code>, <code class="reqn">y</code>,
and <code class="reqn">z</code> points on
the plane, equation of the plane, and <code>coefficients</code> of the plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Planes'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Planes_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>Planes</code>.</p>
</td></tr>
<tr><td><code id="summary.Planes_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Planes"</code>,
the defining 3D <code>points</code>, selected <code class="reqn">x</code>, <code class="reqn">y</code>,
and <code class="reqn">z</code> points on the plane,
equation of the plane, and <code>coefficients</code> of the plane
(in the form: <code>z = A*x + B*y + C</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Planes">print.Planes</a></code>,
<code><a href="#topic+print.summary.Planes">print.summary.Planes</a></code>,
and <code><a href="#topic+plot.Planes">plot.Planes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P&lt;-c(1,10,3); Q&lt;-c(1,1,3); C&lt;-c(3,9,12)
pts&lt;-rbind(P,Q,C)

xr&lt;-range(pts[,1]); yr&lt;-range(pts[,2])
xf&lt;-(xr[2]-xr[1])*.1
#how far to go at the lower and upper ends in the x-coordinate
yf&lt;-(yr[2]-yr[1])*.1
#how far to go at the lower and upper ends in the y-coordinate
x&lt;-seq(xr[1]-xf,xr[2]+xf,l=5) #try also l=10, 20 or 100
y&lt;-seq(yr[1]-yf,yr[2]+yf,l=5) #try also l=10, 20 or 100

plPQC&lt;-Plane(P,Q,C,x,y)
plPQC
summary(plPQC)


</code></pre>

<hr>
<h2 id='summary.TriLines'>Return a summary of a <code>TriLines</code> <code>object</code></h2><span id='topic+summary.TriLines'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>,
the defining <code>points</code>,
selected <code class="reqn">x</code> and <code class="reqn">y</code> points on the line,
equation of the line, together with the vertices of the triangle,
and <code>coefficients</code> of the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TriLines'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.TriLines_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>TriLines</code>.</p>
</td></tr>
<tr><td><code id="summary.TriLines_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"TriLines"</code>,
the defining <code>points</code>,
selected <code class="reqn">x</code> and <code class="reqn">y</code> points on the line,
equation of the line,
together with the vertices of the triangle,
and <code>coefficients</code> of the line
(in the form: <code>y = slope * x + intercept</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.TriLines">print.TriLines</a></code>,
<code><a href="#topic+print.summary.TriLines">print.summary.TriLines</a></code>,
and <code><a href="#topic+plot.TriLines">plot.TriLines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
Te&lt;-rbind(A,B,C)
xfence&lt;-abs(A[1]-B[1])*.25
#how far to go at the lower and upper ends in the x-coordinate
x&lt;-seq(min(A[1],B[1])-xfence,max(A[1],B[1])+xfence,l=3)

lnACM&lt;-lineA2CMinTe(x)
lnACM
summary(lnACM)


</code></pre>

<hr>
<h2 id='summary.Uniform'>Return a summary of a <code>Uniform</code> <code>object</code></h2><span id='topic+summary.Uniform'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>,
the <code>type</code> of the pattern (i.e. the description
of the uniform distribution), study window,
vertices of the support of the Uniform distribution,
some sample points generated from the uniform distribution,
and the number of points (i.e., number of generated
points and the number of vertices of the support
of the uniform distribution.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Uniform'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Uniform_+3A_object">object</code></td>
<td>
<p>An <code>object</code> of class <code>Uniform</code>.</p>
</td></tr>
<tr><td><code id="summary.Uniform_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the <code>object</code> of class <code>"Uniform"</code>,
the <code>type</code> of the pattern (i.e. the description
of the uniform distribution), study window,
vertices of the support of the Uniform distribution,
some sample points generated from the uniform distribution,
and the number of points (i.e., number of generated
points and the number of vertices of
the support of the uniform distribution.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Uniform">print.Uniform</a></code>,
<code><a href="#topic+print.summary.Uniform">print.summary.Uniform</a></code>,
and <code><a href="#topic+plot.Uniform">plot.Uniform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n&lt;-10 #try also 20, 100, and 1000
A&lt;-c(1,1); B&lt;-c(2,0); R&lt;-c(1.5,2);
Tr&lt;-rbind(A,B,R)

Xdt&lt;-runif.tri(n,Tr)
Xdt
summary(Xdt)


</code></pre>

<hr>
<h2 id='swamptrees'>Tree Species in a Swamp Forest</h2><span id='topic+swamptrees'></span>

<h3>Description</h3>

<p>Locations and species classification of trees in a plot in the Savannah River, SC, USA.
Locations are given in meters, rounded to the nearest 0.1 decimal.
The data come from a one-hectare (200-by-50m) plot in the Savannah River Site.
The 734 mapped stems included 156 Carolina ashes (Fraxinus caroliniana),
215 water tupelos (Nyssa aquatica), 205 swamp tupelos (Nyssa sylvatica),
98 bald cypresses (Taxodium distichum)
and 60 stems from 8 additional three species (labeled as Others (OT)).
The plots were set up by Bill Good and their spatial patterns
described in (Good and Whipple (1982)),
the plots have been maintained and resampled
by Rebecca Sharitz and her colleagues of the Savannah River Ecology Laboratory.
The data and some of its description are borrowed from the swamp data entry in the <code>dixon</code>
package in the CRAN repository.
</p>
<p>See also (Good and Whipple (1982); Jones et al. (1994); Dixon (2002)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swamptrees)
</code></pre>


<h3>Format</h3>

<p>A data frame with 734 rows and 4 variables
</p>


<h3>Details</h3>

<p>Text describing the variable (i.e., column) names in the data set.
</p>

<ul>
<li><p> x,y:  x and y (i.e., Cartesian) coordinates of the trees
</p>
</li>
<li><p> live: a categorical variable that indicates the tree is alive (labeled as 1) or dead (labeled as 0)
</p>
</li>
<li><p> sp: species label of the trees:
</p>

<dl>
<dt>FX: </dt><dd><p>Carolina ash (Fraxinus caroliniana)</p>
</dd>
<dt>NS: </dt><dd><p>Swamp tupelo (Nyssa sylvatica)</p>
</dd>
<dt>NX: </dt><dd><p>Water tupelo (Nyssa aquatica)</p>
</dd>
<dt>TD: </dt><dd><p>Bald cypress (Taxodium distichum)</p>
</dd>
<dt>OT: </dt><dd><p>Other species</p>
</dd>
</dl>

</li></ul>



<h3>Source</h3>

<p><a href="https://pdixon.stat.iastate.edu/datasets/goodplot1.txt">Prof. Philip Dixon's website</a>
</p>


<h3>References</h3>

<p>Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.<br /><br /> Good BJ, Whipple SA (1982).
&ldquo;Tree spatial patterns: South Carolina bottomland and swamp forests.&rdquo;
<em>Bulletin of the Torrey Botanical Club</em>, <b>109(4)</b>, 529-536.<br /><br /> Jones RH, Sharitz RR, James SM, Dixon PM (1994).
&ldquo;Tree population dynamics in seven South Carolina mixed-species forests.&rdquo;
<em>Bulletin of the Torrey Botanical Club</em>, <b>121(4)</b>, 360-368.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swamptrees)
plot(swamptrees$x,swamptrees$y, col=as.numeric(swamptrees$sp),pch=19,
xlab='',ylab='',main='Swamp Trees')

</code></pre>

<hr>
<h2 id='tri2std.basic.tri'>Converting a triangle to the standard basic triangle form form</h2><span id='topic+tri2std.basic.tri'></span>

<h3>Description</h3>

<p>This function transforms any triangle, <code>tri</code>,
to the standard basic triangle form.
</p>
<p>The standard basic triangle form is <code class="reqn">T_b=T((0,0),(1,0),(c_1,c_2))</code>
where <code class="reqn">c_1</code> is in <code class="reqn">[0,1/2]</code>,
<code class="reqn">c_2&gt;0</code> and <code class="reqn">(1-c_1)^2+c_2^2 \le 1</code>.
</p>
<p>Any given triangle can be mapped to the standard basic triangle form
by a combination of rigid body motions
(i.e., translation, rotation and reflection) and scaling,
preserving uniformity of the points in the
original triangle. Hence, standard basic triangle form is useful for simulation
studies under the uniformity hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri2std.basic.tri(tri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri2std.basic.tri_+3A_tri">tri</code></td>
<td>
<p>A <code class="reqn">3 \times 2</code> matrix with each row
representing a vertex of the triangle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>Cvec</code></td>
<td>
<p>The nontrivial vertex <code class="reqn">C=(c_1,c_2)</code>
in the standard basic triangle form <code class="reqn">T_b</code>.</p>
</td></tr>
<tr><td><code>orig.order</code></td>
<td>
<p>Row order of the input triangle, <code>tri</code>,
when converted to the standard basic triangle form <code class="reqn">T_b</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c1&lt;-.4; c2&lt;-.6
A&lt;-c(0,0); B&lt;-c(1,0); C&lt;-c(c1,c2);

tri2std.basic.tri(rbind(A,B,C))
tri2std.basic.tri(rbind(B,C,A))

A&lt;-c(1,1); B&lt;-c(2,0); C&lt;-c(1.5,2);
tri2std.basic.tri(rbind(A,B,C))
tri2std.basic.tri(rbind(A,C,B))
tri2std.basic.tri(rbind(B,A,C))


</code></pre>

<hr>
<h2 id='Xin.convex.hullY'>Points from one class inside the convex hull of the points
from the other class</h2><span id='topic+Xin.convex.hullY'></span>

<h3>Description</h3>

<p>Given two 2D data sets, <code>Xp</code> and <code>Yp</code>,
it returns the <code>Xp</code> points
inside the convex hull of <code>Yp</code> points.
</p>
<p>See (Okabe et al. (2000); Ceyhan (2010); Sinclair (2016))
for more on Delaunay triangulation and the corresponding algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xin.convex.hullY(Xp, Yp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xin.convex.hullY_+3A_xp">Xp</code></td>
<td>
<p>A set of 2D points
which constitute the data set.</p>
</td></tr>
<tr><td><code id="Xin.convex.hullY_+3A_yp">Yp</code></td>
<td>
<p>A set of 2D points
which constitute the vertices of the Delaunay triangles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Xp</code> points inside the convex hull of <code>Yp</code> points
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Extension of One-Dimensional Proximity Regions to Higher Dimensions.&rdquo;
<em>Computational Geometry: Theory and Applications</em>, <b>43(9)</b>, 721-748.<br /><br /> Okabe A, Boots B, Sugihara K, Chiu SN (2000).
<em>Spatial Tessellations: Concepts and Applications of Voronoi Diagrams</em>.
Wiley, New York.<br /><br /> Sinclair D (2016).
&ldquo;S-hull: a fast radial sweep-hull routine for Delaunay triangulation.&rdquo;
1604.01428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotDelaunay.tri">plotDelaunay.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#nx is number of X points (target) and ny is number of Y points (nontarget)
nx&lt;-20; ny&lt;-5;  #try also nx&lt;-40; ny&lt;-10 or nx&lt;-1000; ny&lt;-10;

set.seed(1)
Xp&lt;-cbind(runif(nx,0,1),runif(nx,0,1))
Yp&lt;-cbind(runif(ny,0,.25),runif(ny,0,.25))+cbind(c(0,0,0.5,1,1),c(0,1,.5,0,1))
#try also Yp&lt;-cbind(runif(ny,0,1),runif(ny,0,1))

DT&lt;-interp::tri.mesh(Yp[,1],Yp[,2],duplicate="remove")

Xlim&lt;-range(Xp[,1],Yp[,1])
Ylim&lt;-range(Xp[,2],Yp[,2])
xd&lt;-Xlim[2]-Xlim[1]
yd&lt;-Ylim[2]-Ylim[1]

Xch&lt;-Xin.convex.hullY(Xp,Yp)

plot(Xp,main=" ", xlab=" ", ylab=" ",
xlim=Xlim+xd*c(-.05,.05),ylim=Ylim+yd*c(-.05,.05),pch=".",cex=3)
interp::convex.hull(DT,plot.it = TRUE, add = TRUE)  # or try polygon(Yp[ch$i,])
points(Xch,pch=4,col="red")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
