<!DOCTYPE html><html lang="en"><head><title>Help for package gllvm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gllvm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AICc'><p>Corrected Akaike information criterion and number of observations</p></a></li>
<li><a href='#anova.gllvm'><p>Analysis Of Deviance for gllvm</p></a></li>
<li><a href='#beetle'><p>ground beetle assemblages</p></a></li>
<li><a href='#coefplot.gllvm'><p>Plot covariate coefficients and confidence intervals</p></a></li>
<li><a href='#confint.gllvm'><p>Confidence intervals for model parameters</p></a></li>
<li><a href='#ecoCoefs'><p>Functions to extract ecological quantities of the latent variables from a GLLVM, if species are a quadratic function of the latent variables.</p></a></li>
<li><a href='#eSpider'><p>Hunting spider data</p></a></li>
<li><a href='#fungi'><p>Wood-decaying fungi data</p></a></li>
<li><a href='#getEnvironCov.gllvm'><p>Extract species covariances due to environmental random effects from gllvm object</p></a></li>
<li><a href='#getLoadings.gllvm'><p>Extract loadings</p></a></li>
<li><a href='#getLV.gllvm'><p>Extract latent variables</p></a></li>
<li><a href='#getPredictErr.gllvm'><p>Extract prediction errors for latent variables from gllvm object</p></a></li>
<li><a href='#getResidualCor.gllvm'><p>Extract residual correlations from gllvm object</p></a></li>
<li><a href='#getResidualCov.gllvm'><p>Extract residual covariance matrix from gllvm object</p></a></li>
<li><a href='#gllvm'><p>Generalized Linear Latent Variable Models</p></a></li>
<li><a href='#kelpforest'><p>Kelp Forest community Dynamics: Cover of sessile organisms, Uniform Point Contact</p></a></li>
<li><a href='#logLik.gllvm'><p>Log-likelihood of gllvm</p></a></li>
<li><a href='#microbialdata'><p>Microbial community data</p></a></li>
<li><a href='#ordiplot.gllvm'><p>Plot latent variables from gllvm model</p></a></li>
<li><a href='#phyloplot.gllvm'><p>Plot phylogenetic random effects from gllvm</p></a></li>
<li><a href='#plot.gllvm'><p>Plot Diagnostics for an gllvm Object</p></a></li>
<li><a href='#predict.gllvm'><p>Predict Method for gllvm Fits</p></a></li>
<li><a href='#predictLVs.gllvm'><p>Predict latent variables for gllvm Fits</p></a></li>
<li><a href='#randomCoefplot.gllvm'><p>Plot random slope coefficients</p></a></li>
<li><a href='#residuals.gllvm'><p>Dunn-Smyth residuals for gllvm model</p></a></li>
<li><a href='#se.gllvm'><p>Standard errors for gllvm model</p></a></li>
<li><a href='#simulate.gllvm'><p>Simulate data from gllvm fit</p></a></li>
<li><a href='#Skabbholmen'><p>Skabbholmen island data</p></a></li>
<li><a href='#summary.gllvm'><p>Summarizing gllvm model fits</p></a></li>
<li><a href='#varPartitioning.gllvm'><p>Calculate variance partitioning</p></a></li>
<li><a href='#vcov.gllvm'><p>Returns variance-covariance matrix of coefficients in a GLLVM.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Linear Latent Variable Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of multivariate data using generalized linear latent variable models (gllvm). 
      Estimation is performed using either the Laplace method, variational approximations, or extended variational approximations, implemented via TMB (Kristensen et al. (2016), &lt;<a href="https://doi.org/10.18637%2Fjss.v070.i05">doi:10.18637/jss.v070.i05</a>&gt;). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Matrix, statmod, fishMod, mgcv, alabama, nloptr, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), TMB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jenniniku.github.io/gllvm/">https://jenniniku.github.io/gllvm/</a>,
<a href="https://github.com/JenniNiku/gllvm">https://github.com/JenniNiku/gllvm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JenniNiku/gllvm/issues">https://github.com/JenniNiku/gllvm/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, gclus, corrplot, lattice,
mvabund, ape, parallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-26 19:10:01 UTC; jemaelni</td>
</tr>
<tr>
<td>Author:</td>
<td>Jenni Niku [aut, cre],
  Wesley Brooks [aut],
  Riki Herliansyah [aut],
  Francis K.C. Hui [aut],
  Pekka Korhonen [aut],
  Sara Taskinen [aut],
  Bert van der Veen [aut],
  David I. Warton [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-26 19:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='AICc'>Corrected Akaike information criterion and number of observations</h2><span id='topic+AICc'></span><span id='topic+AICc.gllvm'></span><span id='topic+nobs'></span><span id='topic+nobs.gllvm'></span>

<h3>Description</h3>

<p>Calculates corrected Akaike information criterion for small sample sizes, and extracts number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
AICc(object, ...)

## S3 method for class 'gllvm'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AICc_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="AICc_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jenni Niku, Bert van der Veen
</p>

<hr>
<h2 id='anova.gllvm'>Analysis Of Deviance for gllvm</h2><span id='topic+anova.gllvm'></span>

<h3>Description</h3>

<p>Computes an analysis of deviance table for two generalized linear latent variable model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="anova.gllvm_+3A_...">...</code></td>
<td>
<p>one or more objects of class 'gllvm'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes likelihood-ratio test for two or more gllvm models.
Test results makes sense only for nested models.
Notice also that this test is not designed for testing models which have
degrees of freedom difference larger than 20. For such models
the P-value should be treated as very approximate.
</p>


<h3>Author(s)</h3>

<p>Jenni Niku
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- antTraits$abund
X &lt;- antTraits$env
TR &lt;- antTraits$traits
# Fit gllvm model
fit1 &lt;- gllvm(y, X, TR, formula = ~ Bare.ground + Shrub.cover, family = poisson())
fit2 &lt;- gllvm(y, X, TR, formula = ~ Bare.ground + Shrub.cover +
             (Bare.ground + Shrub.cover) : Webers.length, family = poisson())
# Test if the model with fourth corner interaction terms is significantly
# better using likelihood-ratio test:
anova(fit1, fit2)

</code></pre>

<hr>
<h2 id='beetle'>ground beetle assemblages</h2><span id='topic+beetle'></span>

<h3>Description</h3>

<p>These data describe the abundance of ground beetle assemblages from the Scottish landscape alongside with the environmental data and species traits. The data includes abundances of 68 species of ground beetle species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(beetle)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Y</dt><dd><p>A data frame of species composition of the ground-beetle assemblages.</p>
</dd>
<dt>X</dt><dd><p>A data frame of study design variables and environmental data.</p>
</dd>
</dl>

<dl>
<dt>SiteCode</dt><dd><p>Unique id for sample.</p>
</dd> 
<dt>Landuse</dt><dd><p>Land use type.</p>
</dd>
<dt>Grid</dt><dd><p>Grid where sample were collected.</p>
</dd>
<dt>Area</dt><dd><p>sampling area in Scotland.</p>
</dd>
<dt>Samplingyear</dt><dd><p>Sampling year</p>
</dd>
<dt>Texture</dt><dd><p>1, peat; 2, peaty loam; 3, loamy sand; 4, sandy loam; 5, sandy clay loam; 6, sandy silt loam; 7, silty clay</p>
</dd>
<dt>Org</dt><dd><p>organic content (% loss of organic content on ignition), log10 transformed</p>
</dd>
<dt>pH</dt><dd><p>soil pH</p>
</dd>
<dt>AvailP</dt><dd><p>available P (mg/L), log10 transformed</p>
</dd>
<dt>AvailK</dt><dd><p>available K (mg/L)</p>
</dd>
<dt>Moist</dt><dd><p> percentage moisture content</p>
</dd>
<dt>Bare</dt><dd><p> percentage cover estimate of bare ground in 11 1-m2 quadrats, arcsine transformed</p>
</dd>
<dt>Litter</dt><dd><p> percentage cover estimate of litter cover in 11 1-m2 quadrats, log10 transformed</p>
</dd>
<dt>Bryophyte</dt><dd><p> percentage cover estimate of bryophytes in 11 1-m2 quadrats, arcsine transformed</p>
</dd>
<dt>Plants.m2</dt><dd><p> number of reproductive stems (ﬂowering or fruiting) in 11 1-m2 quadrats</p>
</dd>
<dt>Canopy</dt><dd><p> height canopy height (cm) in 11 1-m2 quadrats</p>
</dd>
<dt>Stemdensity</dt><dd><p> number of stems (ramets) in 100 cm2</p>
</dd>
<dt>Biom_l5</dt><dd><p> dry mass (g) of biomass 0–5 cm from soil surface in 400 cm2</p>
</dd>
<dt>Biom_m5</dt><dd><p> dry mass (g) of biomass .5 cm from soil surface in 400 cm2, log10 transformed</p>
</dd>
<dt>Reprobiom</dt><dd><p> biomass of reproductive parts (ﬂowers and fruits) in 100 cm2, log10 transformed</p>
</dd>
<dt>Elevation</dt><dd><p> elevation in m a.s.l.</p>
</dd>
<dt>Management</dt><dd><p> management intensity index (see Materials and Methods: Environmental data)</p>
</dd>
</dl>

<dl>
<dt>TR</dt><dd><p>A data frame of the species names and species morphological and life trait characteristics.</p>
</dd>
</dl>

<dl>
<dt>SPECIES</dt><dd><p>Species names.</p>
</dd> 
<dt>CODE</dt><dd><p>Species codes corresponding species names in abundance matrix</p>
</dd>
<dt>LYW</dt><dd><p> diameter of the eye, measured from above</p>
</dd>
<dt>LAL</dt><dd><p> length of the antenna</p>
</dd>
<dt>LPW</dt><dd><p> maximum width of the pronotum</p>
</dd>
<dt>LPH</dt><dd><p> maximum depth (“vaulting”) of the pronotum</p>
</dd>
<dt>LEW</dt><dd><p> maximum width of the elytra</p>
</dd>
<dt>LFL</dt><dd><p> length of the metafemur (with the articulation segments), from the coxa to the apex</p>
</dd>
<dt>LTR</dt><dd><p> length of the metatrochanter</p>
</dd>
<dt>LRL</dt><dd><p> length of the metatarsi</p>
</dd>
<dt>LFW</dt><dd><p> maximum width of the metafemur</p>
</dd>
<dt>LTL</dt><dd><p> total length (length of the pronotum in the medial line plus length of the elytra, from the medial ridge of the scutellum to the apex)</p>
</dd>
<dt>CLG</dt><dd><p> color of the legs (1, pale; 2, black; 3, metallic)</p>
</dd>
<dt>CLB</dt><dd><p> color of the body (1, pale; 2, black; 3, metallic)</p>
</dd>
<dt>WIN</dt><dd><p> wing development (1, apterous or brachypterous; 2, dimorphic; 3, macropterous)</p>
</dd>
<dt>PRS</dt><dd><p> shape of the pronotum (1, oval; 2, cordiform; 3, trapezoidal)</p>
</dd>
<dt>OVE</dt><dd><p> overwintering (1, only adults; 2, adults and larvae or only larvae)</p>
</dd>
<dt>FOA</dt><dd><p> food of the adult (1, mostly Collembola; 2, generalist predator; 3, mostly plant material)</p>
</dd>
<dt>DAY</dt><dd><p> daily activity (1, only diurnal; 2, nocturnal)</p>
</dd>
<dt>BRE</dt><dd><p> breeding season (1, spring; 2, summer; 3, autumn or winter)</p>
</dd>
<dt>EME</dt><dd><p> main period of emergence of the adults (1, spring; 2, summer; 3, autumn)</p>
</dd>
<dt>ACT</dt><dd><p> main period of adult activity (1, autumn; 2, summer only)</p>
</dd>
</dl>




<h3>Details</h3>

<p>Beetles were sampled with two parallel rows of nine pitfall traps (diameter 7.5 cm, 2 m apart) at each site, starting in early May.
</p>
<p>Detailed description of the data available in the reference and in the Ecological Archives E082-012.
</p>


<h3>References</h3>

<p>Ignacio Ribera, Sylvain Dolédec, Iain S. Downie, and Garth N. Foster. 2001. Effect of land disturbance and stress on species traits of ground beetle assemblages. Ecology 82:1112-1129.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(beetle)
# Abundance matrix
Y &lt;- beetle$Y
# Environmental data
X &lt;- beetle$X
# Species traits
TR &lt;- beetle$TR

## End(Not run)
</code></pre>

<hr>
<h2 id='coefplot.gllvm'>Plot covariate coefficients and confidence intervals</h2><span id='topic+coefplot.gllvm'></span><span id='topic+coefplot'></span>

<h3>Description</h3>

<p>Plots covariate coefficients and their confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
coefplot(
  object,
  y.label = TRUE,
  which.Xcoef = NULL,
  order = TRUE,
  cex.ylab = 0.5,
  cex.xlab = 1.3,
  mfrow = NULL,
  mar = c(4, 6, 2, 1),
  xlim.list = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefplot.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_y.label">y.label</code></td>
<td>
<p>logical, if <code>TRUE</code> (default) colnames of y with respect to coefficients are added to plot.</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_which.xcoef">which.Xcoef</code></td>
<td>
<p>vector indicating which covariate coefficients will be plotted. Can be vector of covariate names or numbers. Default is <code>NULL</code> when all covariate coefficients are plotted.</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_order">order</code></td>
<td>
<p>logical, whether or not coefficients are ordered, defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_cex.ylab">cex.ylab</code></td>
<td>
<p>the magnification to be used for axis annotation relative to the current setting of cex.</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_cex.xlab">cex.xlab</code></td>
<td>
<p>the magnification to be used for axis annotation.</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_mfrow">mfrow</code></td>
<td>
<p>same as <code>mfrow</code> in <code>par</code>. If <code>NULL</code> (default) it is determined automatically.</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_mar">mar</code></td>
<td>
<p>vector of length 4, which defines the margin sizes: <code>c(bottom, left, top, right)</code>. Defaults to <code>c(4,5,2,1)</code>.</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_xlim.list">xlim.list</code></td>
<td>
<p>list of vectors with length of two to define the intervals for an x axis in each covariate plot. Defaults to NULL when the interval is defined by the range of point estimates and confidence intervals</p>
</td></tr>
<tr><td><code id="coefplot.gllvm_+3A_...">...</code></td>
<td>
<p>additional graphical arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;, Francis K.C. Hui, Sara Taskinen, Bert van der Veen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract subset of the microbial data to be used as an example
data(microbialdata)
X &lt;- microbialdata$Xenv
y &lt;- microbialdata$Y[, order(colMeans(microbialdata$Y &gt; 0), 
                     decreasing = TRUE)[21:40]]
fit &lt;- gllvm(y, X, formula = ~ pH + Phosp, family = poisson())
coefplot(fit)
## Not run: 
# Fit  gllvm model with environmental covariances and reduced rank
fitRR &lt;- gllvm(y = y, X = X, num.RR = 2, family = "negative.binomial")
coefplot(fitRR)

## End(Not run)
</code></pre>

<hr>
<h2 id='confint.gllvm'>Confidence intervals for model parameters</h2><span id='topic+confint.gllvm'></span><span id='topic+confint'></span>

<h3>Description</h3>

<p>Computes confidence intervals for  parameters in a fitted gllvm model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="confint.gllvm_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals, a vector of names. Examples of options are &quot;beta0&quot;, &quot;Xcoef&quot;,theta&quot;, &quot;phi&quot;. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.gllvm_+3A_level">level</code></td>
<td>
<p>the confidence level. Scalar between 0 and 1.</p>
</td></tr>
<tr><td><code id="confint.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
X &lt;- as.matrix(antTraits$env[,1:2])
# Fit gllvm model
fit &lt;- gllvm(y = y, X = X, family = poisson())
# 95 % confidence intervals for coefficients of X variables
confint(fit, level = 0.95, parm = "Xcoef")

## End(Not run)
</code></pre>

<hr>
<h2 id='ecoCoefs'>Functions to extract ecological quantities of the latent variables from a GLLVM, if species are a quadratic function of the latent variables.</h2><span id='topic+ecoCoefs'></span><span id='topic+optima.gllvm'></span><span id='topic+optima'></span><span id='topic+tolerances'></span><span id='topic+tolerances.gllvm'></span>

<h3>Description</h3>

<p>Extracts species optima and tolerances, potentially with standard errors (derived with the Delta method).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
optima(object, sd.errors = TRUE, ...)

## S3 method for class 'gllvm'
tolerances(object, sd.errors = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ecoCoefs_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="ecoCoefs_+3A_sd.errors">sd.errors</code></td>
<td>
<p>logical. If <code>TRUE</code>, also returns standard errors.</p>
</td></tr>
<tr><td><code id="ecoCoefs_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently no separate method for calculating species maxima or gradient length are implemented.
Gradient length can be inferred from the standard deviation of the latent variables, which is reported by <code><a href="#topic+summary.gllvm">summary.gllvm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Bert van der Veen
</p>

<hr>
<h2 id='eSpider'>Hunting spider data</h2><span id='topic+eSpider'></span>

<h3>Description</h3>

<p>Extended dataset of counts of hunting spiders in a dune area in the Netherlands, measured at 100 pitfall traps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eSpider)
</code></pre>


<h3>Format</h3>


<dl>
<dt>abund</dt><dd><p>A data frame with abundances of 12 hunting spider species measured at 100 sites.</p>
</dd>
<dt>X</dt><dd><p>A matrix of 26 predictor variables at 28 of the 100 sites.</p>
</dd>
<dt>nonNA</dt><dd><p>An vector of indices indicating at which sites the predictor variables were measured.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Counts of hunting spiders in a dune area in the Netherlands, measured with 100 different pitfall traps. This dataset was published with permission from the CANOCO FORTRAN package (version 4 or higher) example datasets.
</p>
<p>Species names have been abbreviated, corresponding to: 
Alopacce = <em>Alopecosa accentuata</em>, Alopcune = <em>Alopecosa cuneata</em>, Alopfabr = <em>Alopecosa fabrilis</em>, Arctlute = <em>Arctosa lutetiana</em>, Arctperi = <em>Arctosa perita</em>, Auloalbi = <em>Aulonia albimana</em>, Pardlugu = <em>Pardosa lugubris</em>, Pardmont = <em>Pardosa monticola</em>, Pardnigr = <em>Pardosa nigriceps</em>, Pardpull = <em>Pardosa pullata</em>, Trocterr = <em>Trochosa terricola</em>, Zoraspin = <em>Zora spinimana</em>.
</p>
<p>Environmental measurements were taken at 28 of the 100 pitfall traps measuring soil properties(Water content: &quot;conWate&quot;, Humus content: &quot;conHumu&quot;, Acidity (pH-KCl)), vegetation (&quot;BareSand&quot;: percentage bare sand, &quot;FallTwig&quot;: cover on the ground by leaves and twigs, &quot;CovMoss&quot;: cover by mosses and lichens, &quot;CovHerb&quot;: cover by the herb and grass layer (including maximum height, minimum height, &quot;CovCala&quot;: cover by <em>Calamagrostis epigejos</em>, cover by <em>Carex arenaria</em>, &quot;CovFest&quot;: cover by <em>Festuca ovina</em>, &quot;CovCory&quot;: cover by <em>Corynephorus canescens</em>, &quot;CovUrti&quot;: cover by <em>Urtica dioica</em>, &quot;CovMoeh&quot;: cover by <em>Moehringia trinervia</em>), &quot;CovShru&quot;: cover by the shrub layer (minimum and maximum height, and &quot;CovLigu&quot;: cover by <em>Ligustrum vulgare</em>), &quot;CovTree&quot;: cover by the tree layer (including maximum height, cover by <em>Populus tremula</em> or <em>Crataegus monogyna</em>)), and light properties (&quot;LuxGrey&quot;: lux at equal grey sky, &quot;LuxSun&quot;: lux at cloudless sky, &quot;LuxRef&quot;: lux by reflection of the soil surface)
</p>
<p>The original publication of Canonical Correspondence Analysis used standardized versions of the <code>log</code> and <code>log1p</code> transformed predictors &quot;ConWate&quot;, &quot;BareSand&quot;, &quot;FallTwig&quot;,  &quot;CovMoss&quot;, &quot;CovHerb&quot;, &quot;LuxRef&quot;.
</p>


<h3>References</h3>

<p>ter Braak, C.J.F. and Smilauer, P.  (1998).  CANOCO reference manual and user's guide to CANOCO for Windows: software for canonical community ordination (version 4). Microcomputer Power, New York, New York, USA.
ter Braak, C.J.F. (1986). Canonical correspondence analysis: a new eigenvector technique for multivariate direct gradient analysis. Ecology, 67(5), 1167-1179.
Van der Aart, P. J. M. and Smeenk-Enserink, N. (1975). Correlations between distributions of hunting spiders (<em>Lycosidae</em>, <em>Ctenidae</em>) and environmental characteristics in a dune area. Netherlands Journal of Zoology, 25(1), 1-45.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eSpider)
Y &lt;- eSpider$abund[eSpider$nonNA, ]
X &lt;- eSpider$X[eSpider$nonNA, ]
model &lt;- gllvm(y = Y, X = X, 
    lv.formula = ~log(ConWate) + log1p(BareSand) + log1p(FallTwig) + 
    log1p(CovMoss) + log1p(CovHerb) + log(LuxRef),
    num.RR = 2, 
    family = "poisson")
</code></pre>

<hr>
<h2 id='fungi'>Wood-decaying fungi data</h2><span id='topic+fungi'></span>

<h3>Description</h3>

<p>Dataset of 1666 binary observations for 215 fungal species, in different 53 European Beech forests spread across 8 regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fungi)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Y</dt><dd><p>A data frame with the presence-absences of 215 fungal species measured at 1666 logs.</p>
</dd>
<dt>X</dt><dd><p>A data frame of 8 predictor variables.</p>
</dd>
</dl>

<dl>
<dt>DBH.CM</dt><dd><p>Diameter at breast height (cm)</p>
</dd> 
<dt>AVERDP</dt><dd><p>Decay stage of logs on a 1-5 scale</p>
</dd>
<dt>CONNECT10</dt><dd><p>Connectivity of the surrounding forest at 10km scale</p>
</dd>
<dt>TEMPR</dt><dd><p>Annual temperature range in degrees Celsius</p>
</dd>
<dt>PRECIP</dt><dd><p>Annual precipitation in milimeters</p>
</dd>
<dt>log.Area</dt><dd><p>ln(area in hectares) of reserves</p>
</dd>
<dt>REGION</dt><dd><p>Site groups identified based on spatial clusters</p>
</dd>
<dt>RESERVE</dt><dd><p>Site name</p>
</dd>
</dl>

<dl>
<dt>TR</dt><dd><p>A data frame of the traits used in Abrego et al. (2022).</p>
</dd>
<dt>tree</dt><dd><p>The phylogenetic tree.</p>
</dd>
<dt>C</dt><dd><p>The phylogenetic covariance matrix.</p>
</dd>
<dt>dist</dt><dd><p>The phylogenetic distance matrix.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Observations of fungi species inhabiting European beech logs, in different European countries. The countries have been grouped in eight different regions. Logs were surveyed in 53 different reserves (or sites). Included environment and trait covariates are limited to those analyzed in the original article, though more are available in the published dataset on datadryad.org.
</p>


<h3>References</h3>

<p>Abrego, N., Bässler, C., Christensen, M., and Heilmann‐Clausen, J. (2022). Traits and phylogenies modulate the environmental responses of wood‐inhabiting fungal communities across spatial scales. Journal of Ecology, 110(4), 784-798.
</p>
<p>Abrego, N., Bässler, C., Christensen, M., and Heilmann-Clausen, J. (2022). Data and code from: Traits and phylogenies modulate the environmental responses of wood-inhabiting fungal communities across spatial scales [Dataset]. Dryad. https://doi.org/10.5061/dryad.t76hdr82r
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fungi)
Y &lt;- fungi$Y
X &lt;- fungi$X
TR &lt;- fungi$TR
C &lt;- fungi$C
dist &lt;- fungi$dist

#model &lt;- gllvm(y = Y, X = cbind(int = 1, X), TR = TR, 
#        formula = ~DBH.CM + AVERDP + I(AVERDP^2) + CONNECT10 + TEMPR + PRECIP + 
#        log.AREA + (DBH.CM + AVERDP + I(AVERDP^2) + CONNECT10 + TEMPR + PRECIP + 
#        log.AREA):(FB.type + Sp.log.vol.µ3 + Lifestyle), 
#        family = "binomial", num.lv = 0, studyDesign = X[,c("REGION", "RESERVE")], 
#                     colMat = list(C, dist = dist), colMat.rho.struct = "term", 
#                     row.eff = ~(1 | REGION/RESERVE), sd.errors = FALSE, 
#                     randomX = ~int + DBH.CM + AVERDP + I(AVERDP^2) + 
#                                CONNECT10 + TEMPR + PRECIP + log.AREA, 
#                     beta0com = TRUE, nn.colMat = 10, maxit = 20000)

## End(Not run)
</code></pre>

<hr>
<h2 id='getEnvironCov.gllvm'>Extract species covariances due to environmental random effects from gllvm object</h2><span id='topic+getEnvironCov.gllvm'></span><span id='topic+getEnvironCov'></span><span id='topic+getEnvironCor'></span><span id='topic+getEnvironCor.gllvm'></span>

<h3>Description</h3>

<p>Calculates the species environment covariance matrix for a gllvm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
getEnvironCov(object, x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEnvironCov.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="getEnvironCov.gllvm_+3A_x">x</code></td>
<td>
<p>(optional) vector of covariate values to calculate the covariance for. Defaults to a vector of 1s. If both 'randomX' and random species effects are present in the model this should be a list of length two.</p>
</td></tr>
<tr><td><code id="getEnvironCov.gllvm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Species covariance matrix due to the environment is calculated.
</p>
<p>Covariances due to the covariates can only be calculated when random effects are included in the model, and are thus limited to reduced rank models (those including constrained and concurrent ordinations) fitted with random slopes, models fitted with random effects via the formula interface, or the fourth corner model fitted with random slopes.
For full rank models with random slopes, i.e., with the formula interface or the fourth corner model, the covariances of species are formulated as:
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_e = kronecker(C\rho + (1-\rho)I_p, R),</code>
</p>

<p>where <code class="reqn">C</code> is a correlation matrix for the columns in the response (e.g., a Phylogenetic matrix), <code class="reqn">\rho</code> the signal parameter, and R the covariance matrix for the random effects. Here, </p>
<p style="text-align: center;"><code class="reqn">I = kronecker(I_p, x)</code>
</p>
<p>, with x a vector of covariate values for each of the random effects, which defaults to a vector of 1s.
when there are covariate-specific phylogenetic signal parameters in the model, this is instead:
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_e = kronecker(x_i', I_m)*bdiag(L_k)*kronecker(\Sigma_r, I_m)*bdiag(L_k')*kronecker(x_i, I_m),</code>
</p>

<p>where <code class="reqn">bdiag(L_k)</code> is a block-diagonal lower triangular matrix, and each <code class="reqn">L_k</code> the lower triangular matrix of the covariance matrix for each covariate.
</p>
<p>For reduced rank models, the covariance is separately defined for the different variance structures of the canonical coefficients in the package. With LV-specific variances, we have:
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_e = \Theta*S*\Theta',</code>
</p>

<p>where <code class="reqn">\Theta</code> is the matrix of loadings, and S the (diagonal) covariance matrix for the canonical coefficients. With predictor-specific variances, we instead have:
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_e = \sum^K_{k=1} \Theta(I_d*\sigma_k^2)\Theta',</code>
</p>

<p>with I_d an identity matrix for the number of constrained and informed latent variables, and <code class="reqn">\sigma_k^2</code> the variance per predictor for the canonical coefficients. When correlations are included, we have:
</p>
<p style="text-align: center;"><code class="reqn">\Sigma_e = kronecker(x_i', I_m)kronecker(\Sigma,\Theta\Theta')kronecker(x_i, I_m).</code>
</p>

<p>Expressions for the quadratic models in the package are determined similarly but not documented here for brevity.
</p>


<h3>Value</h3>

<p>Function returns the following components:
</p>
<table role = "presentation">
<tr><td><code>cov</code></td>
<td>
<p>species covariances due to covariates</p>
</td></tr>
<tr><td><code>trace.randomB</code></td>
<td>
<p> trace of the covariance matrix due to random canonical coefficients</p>
</td></tr>
<tr><td><code>trace.randomB.quad</code></td>
<td>
<p> trace of the covariance matrix components due to squared model terms</p>
</td></tr>
<tr><td><code>trace.col.eff</code></td>
<td>
<p> trace of the covariance matrix due to random column (species) effects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bert van der Veen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEnvironCor">getEnvironCor</a></code> ,<code><a href="#topic+getResidualCov.gllvm">getResidualCov.gllvm</a></code>, <code><a href="#topic+getResidualCor.gllvm">getResidualCor.gllvm</a></code>,.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example with the spider dataset
data(eSpider)
y = eSpider$abund[eSpider$nonNA,]
X = eSpider$X[eSpider$nonNA,]
fit &lt;- gllvm(y, X = scale(X), num.RR = 2, 
            randomB = "P", family = "negative.binomial")
envcov &lt;- getEnvironCov(fit)
envcov$trace.randomB
# As proportion of variance in the model
envcov$trace.randomB/sum(envcov$trace.randomB)

## End(Not run)
</code></pre>

<hr>
<h2 id='getLoadings.gllvm'>Extract loadings</h2><span id='topic+getLoadings.gllvm'></span><span id='topic+getLoadings'></span>

<h3>Description</h3>

<p>Extract loadings (species scores) from a gllvm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
getLoadings(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLoadings.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="getLoadings.gllvm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function retrieves the loadings a.k.a. species scores for a GLLVM. For the optima of a quadratic response model, see <code><a href="#topic+optima.gllvm">optima.gllvm</a></code>
</p>

<hr>
<h2 id='getLV.gllvm'>Extract latent variables</h2><span id='topic+getLV.gllvm'></span><span id='topic+getLV'></span>

<h3>Description</h3>

<p>Extract latent variables from gllvm object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
getLV(object, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLV.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="getLV.gllvm_+3A_type">type</code></td>
<td>
<p>type of latent variable scores to retrieve from a gllvm object. For models with unconstrained latent variables, defaults to &quot;residual&quot;. For models with constrained latent variables, defaults to conditional. Alternatively, &quot;marginal&quot; returns linear combination scores without residual error.</p>
</td></tr>
<tr><td><code id="getLV.gllvm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function retrieves the site scores for a GLLVM. Each type corresponds to a separate term of the model. For a GLLVM with unconstrained latent variables
the default is &quot;residual&quot;. &quot;Residual&quot; scores represent the error term in concurrent ordination, and are not available for constrained ordination.
</p>
<p>For GLLVMs with informed latent variables, &quot;conditional&quot; returns the complete site scores, due to both fixed- and latent effects,
where the latent effect is always scaled by the diagonal of the species loadings so that it can be small relative to the fixed-effects. &quot;Conditional&quot;
here means conditional on the random-effect i.e. the residual.
</p>
<p>Type &quot;marginal&quot;  returns linear combination scores, i.e. the site scores only due to fixed-effects. These are available for constrained and concurrent ordination.
</p>
<p>If both unconstrained and constrained latent variables are included in the model, type &quot;marginal&quot; returns linear combination scores for constrained latent variables
but &quot;residual&quot; scores for unconstrained latent variables.
</p>

<hr>
<h2 id='getPredictErr.gllvm'>Extract prediction errors for latent variables from gllvm object</h2><span id='topic+getPredictErr.gllvm'></span><span id='topic+getPredictErr'></span>

<h3>Description</h3>

<p>Calculates the prediction errors for latent variables and random effects for gllvm model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
getPredictErr(object, CMSEP = TRUE, cov = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPredictErr.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="getPredictErr.gllvm_+3A_cmsep">CMSEP</code></td>
<td>
<p>logical, if <code>TRUE</code> conditional mean squared errors for predictions are calculated. If <code>FALSE</code>, prediction errors are based on covariances of the variational distributions for <code>method ="VA"</code> and <code>method ="EVA"</code>.</p>
</td></tr>
<tr><td><code id="getPredictErr.gllvm_+3A_cov">cov</code></td>
<td>
<p>if <code>TRUE</code>, return as covariances/variances of predictions. Otherwise <code>FALSE</code> (default) return as standard errors of predictions.</p>
</td></tr>
<tr><td><code id="getPredictErr.gllvm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates conditional mean squared errors for predictions.
If variational approximation is used, prediction errors can be based on covariances 
of the variational distributions, and therefore they do not take into account 
the uncertainty in the estimation of (fixed) parameters.
</p>


<h3>Value</h3>

<p>Function returns following components:
</p>
<table role = "presentation">
<tr><td><code>lvs</code></td>
<td>
<p>prediction errors for latent variables</p>
</td></tr>
<tr><td><code>row.effects</code></td>
<td>
<p>prediction errors for random row effects if included</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francis K.C. Hui, Jenni Niku, David I. Warton
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
# Fit gllvm model
fit &lt;- gllvm(y = y, family = poisson())
# prediction errors for latent variables:
getPredictErr(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='getResidualCor.gllvm'>Extract residual correlations from gllvm object</h2><span id='topic+getResidualCor.gllvm'></span><span id='topic+getResidualCor'></span>

<h3>Description</h3>

<p>Calculates the residual correlation matrix for gllvm model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
getResidualCor(object, adjust = 1, x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getResidualCor.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="getResidualCor.gllvm_+3A_adjust">adjust</code></td>
<td>
<p>The type of adjustment used for  negative binomial and binomial distribution when computing residual correlation matrix. Options are 0 (no adjustment), 1 (the default adjustment) and 2 (alternative adjustment for NB distribution). See details.</p>
</td></tr>
<tr><td><code id="getResidualCor.gllvm_+3A_x">x</code></td>
<td>
<p>(optional) vector of covariate values to calculate the covariance for, when applicable.</p>
</td></tr>
<tr><td><code id="getResidualCor.gllvm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residual correlation matrix is calculated based on the residual covariance matrix, see details from <code><a href="#topic+getResidualCov.gllvm">getResidualCov.gllvm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Francis K.C. Hui, Jenni Niku, David I. Warton
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#'# Extract subset of the microbial data to be used as an example
data(microbialdata)
y &lt;- microbialdata$Y[, order(colMeans(microbialdata$Y &gt; 0), 
                     decreasing = TRUE)[21:40]]
fit &lt;- gllvm(y, family = poisson())
fit$logL
cr &lt;- getResidualCor(fit)
cr[1:5,1:5]
## Not run: 
# Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
# Fit gllvm model
fit &lt;- gllvm(y = y, family = poisson())
# residual correlations:
cr &lt;- getResidualCor(fit)
# Plot residual correlations:
install.packages("corrplot", "gclus")
library(corrplot)
library(gclus)
corrplot(cr[order.single(cr), order.single(cr)], diag = F,
  type = "lower", method = "square", tl.cex = 0.8, tl.srt = 45, tl.col = "red")
  
## End(Not run)

</code></pre>

<hr>
<h2 id='getResidualCov.gllvm'>Extract residual covariance matrix from gllvm object</h2><span id='topic+getResidualCov.gllvm'></span><span id='topic+getResidualCov'></span>

<h3>Description</h3>

<p>Calculates the residual covariance matrix for gllvm model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
getResidualCov(object, adjust = 1, x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getResidualCov.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="getResidualCov.gllvm_+3A_adjust">adjust</code></td>
<td>
<p>The type of adjustment used for  negative binomial, binomial and normal distribution when computing residual correlation matrix. Options are 0 (no adjustment), 1 (the default adjustment) and 2 (alternative adjustment for NB distribution), see details.</p>
</td></tr>
<tr><td><code id="getResidualCov.gllvm_+3A_x">x</code></td>
<td>
<p>(optional) vector of covariate values to calculate the covariance for, when applicable.</p>
</td></tr>
<tr><td><code id="getResidualCov.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residual covariance matrix, storing information on species co-occurrence that is not explained by the environmental variables (if included), is calculated using the matrix of latent variables loadings, that is, <code class="reqn">\Theta\Theta'</code>, and the dispersion parameter related to the distribution of choice, is applicable (e.g. in the case of negative-binomial distributed responses).
</p>
<p>When the responses are modelled using the negative binomial distribution, the residual variances for each species must be adjusted for overdispersion. The two possible adjustment terms are <code class="reqn">log(\phi_j + 1)</code> (<code>adjust = 1</code>) and <code class="reqn">\psi^{(1)}(1/\phi_j)</code> (<code>adjust = 2</code>), where <code class="reqn">\psi^{(1)}</code> is the trigamma function.
</p>
<p>The negative binomial model can be written using different parameterizations. 
The residual covariance with <code>adjust = 1</code> can be obtained using the lognormal-Poisson parametrization, that is,
</p>
<p style="text-align: center;"><code class="reqn">Y_{ij} \sim Poisson(\mu_{ij} \lambda_j),</code>
</p>

<p>where <code class="reqn">\lambda_j \sim lognormal(-\sigma^2/2, \sigma^2)</code> and <code class="reqn">\sigma^2 = log(\phi_j + 1)</code> and <code class="reqn">log(\mu_{ij}) = \eta_{ij}</code>. Now <code class="reqn">E[Y_{ij}] = \mu_{ij}</code> and variance <code class="reqn">V(\mu_{ij}) = \mu_{ij} + \mu_{ij}^2 (exp(\sigma^2) - 1) = \mu_{ij} + \mu_{ij}^2 \phi_j</code>, which are the same as for the NB distribution.
Therefore, on linear predictor scale, we have the variance 
</p>
<p style="text-align: center;"><code class="reqn">V(log(\mu_{ij} \lambda_j)) = V(log\mu_{ij}) + V(log\lambda_j) = V(u_i'\theta_j) + \sigma^2 = \theta_j'\theta_j + log(\phi_j + 1).</code>
</p>

<p>which leads to the residual covariance matrix <code class="reqn">\Theta \Theta' + \Psi</code>, where <code class="reqn">\Psi</code> is the diagonal matrix with <code class="reqn">log(\phi_j + 1)</code> as diagonal elements (<code>adjust = 1</code>).
</p>
<p>Or, for a GLLVM where species are a quadratic function of the latent variables, we instead have
</p>
<p style="text-align: center;"><code class="reqn">V(log(\mu_{ij} \lambda_j)) = V(log\mu_{ij}) + V(log\lambda_j) = V(u_i'\theta_j-u_i' D_j u_i) + \sigma^2 </code>
</p>

<p style="text-align: center;"><code class="reqn"> = \theta_j'\theta_j + 2diag(D_j)'diag(D_j)log(\phi_j + 1).</code>
</p>

<p>which leads to the residual covariance matrix <code class="reqn">\Theta \Theta' + 2 \Gamma_j \Gamma_j' + diag(\Phi)</code>, where <code class="reqn">\Gamma_j</code> holds the quadratic coefficients.
Since the quadratic coefficients are constrained to be positive, the residual covariance in the latter case is, given the same coefficients on the linear term, equal or more positive than in the linear case.
</p>
<p>The residual covariance matrix with <code>adjust = 2</code> can be obtained by using Poisson-Gamma parametri-zation
</p>
<p style="text-align: center;"><code class="reqn">Y_{ij} \sim Poisson(\mu_{ij} \lambda_j),</code>
</p>

<p>where <code class="reqn">\lambda_j \sim Gamma(1/\phi_j, 1/\phi_j)</code> and <code class="reqn">\mu_{ij}</code> is as above. The mean and the variance are of similar form as above and we have that
</p>
<p style="text-align: center;"><code class="reqn">V(log(\mu_{ij} \lambda_j)) = V(log\mu_{ij}) + V(log\lambda_j) = \theta_j'\theta_j + \psi^{(1)}(1/\phi_j),</code>
</p>

<p>where <code class="reqn">\psi^{(1)}</code> is the trigamma function.
</p>
<p>In the case of binomial distribution, the adjustment terms (<code>adjust = 1</code>) are 1 for probit link and <code class="reqn">\pi^2/3</code> for logit link.
These are obtained by treating binomial model as latent variable model. Assume
</p>
<p style="text-align: center;"><code class="reqn">Y^*_{ij} = \eta_{ij} + e_{ij},</code>
</p>

<p>where <code class="reqn">e_{ij} \sim N(0, 1)</code> for probit model, and <code class="reqn">e_{ij} \sim logistic(0, 1)</code> for logit model.
Then binary response is defined as <code class="reqn">Y_{ij} = 1</code>, if <code class="reqn">Y^*_{ij} &gt; 0</code> and 0 otherwise.
Now we have that <code class="reqn">\mu_{ij} = P(Y_{ij} = 1) = P(Y^*_{ij} &gt; 0) = P(\eta_{ij} &gt; -e_{ij}) = P(e_{ij} &lt;= \eta_{ij})</code> which leads to probit and logit models.
On linear predictor scale we then have that
</p>
<p style="text-align: center;"><code class="reqn">V(\eta_{ij} + e_{ij}) = V(\eta_{ij}) + V(e_{ij}).</code>
</p>

<p>For the probit model, the residual covariance matrix is then <code class="reqn">\Theta\Theta' + I_m</code>, and for the logit model <code class="reqn">\Theta\Theta' + \pi^2/3 I_m</code>.
Similarly as above, for a GLLVM where species are a quadratic function of the latent variables, the term <code class="reqn">2\Gamma_j\Gamma_j'</code> is added to the residual covariance matrix.
</p>
<p>For normal distribution, we can write
</p>
<p style="text-align: center;"><code class="reqn">Y_{ij} = \eta_{ij} + e_{ij},</code>
</p>

<p>where <code class="reqn">e_{ij} \sim N(0, \phi_j^2)</code> and thus we have that
</p>
<p style="text-align: center;"><code class="reqn">V(\eta_{ij} + e_{ij}) = V(\eta_{ij}) + V(e_{ij}).</code>
</p>

<p>For the gaussian model, the residual covariance matrix is then <code class="reqn">\Theta\Theta' + diag(\Phi^2)</code>.
</p>


<h3>Value</h3>

<p>Function returns following components:
</p>
<table role = "presentation">
<tr><td><code>cov</code></td>
<td>
<p>residual covariance matrix</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>trace of the residual covariance matrix, the total variance explained</p>
</td></tr>
<tr><td><code>var.q</code></td>
<td>
<p>trace of the residual covariance matrix per latent variable, variance explained per latent variable</p>
</td></tr>
<tr><td><code>var.q2</code></td>
<td>
<p>trace of the squared term of the residual covariance matrix per latent variable, for quadratic responses. Variance explained per latent variable by the quadratic term</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francis K.C. Hui, Jenni Niku, David I. Warton, Bert van der Veen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
# Fit gllvm model
fit &lt;- gllvm(y = y, family = poisson())
# residual covariance:
rescov &lt;- getResidualCov(fit)
rescov$cov
# Trace of the covariance matrix
rescov$trace
# Variance explained per latent variable
rescov$var.q

## End(Not run)
</code></pre>

<hr>
<h2 id='gllvm'>Generalized Linear Latent Variable Models</h2><span id='topic+gllvm'></span>

<h3>Description</h3>

<p>Fits generalized linear latent variable model for multivariate data. The model can be fitted using Laplace approximation method or variational
approximation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gllvm(
  y = NULL,
  X = NULL,
  TR = NULL,
  data = NULL,
  formula = NULL,
  family,
  num.lv = NULL,
  num.lv.c = 0,
  num.RR = 0,
  lv.formula = NULL,
  lvCor = NULL,
  studyDesign = NULL,
  dist = list(matrix(0)),
  distLV = matrix(0),
  colMat = NULL,
  colMat.rho.struct = "single",
  corWithin = FALSE,
  corWithinLV = FALSE,
  quadratic = FALSE,
  row.eff = FALSE,
  sd.errors = TRUE,
  offset = NULL,
  method = "VA",
  randomB = FALSE,
  randomX = NULL,
  beta0com = FALSE,
  zeta.struc = "species",
  plot = FALSE,
  link = "probit",
  Ntrials = 1,
  Power = 1.1,
  seed = NULL,
  scale.X = TRUE,
  return.terms = TRUE,
  gradient.check = FALSE,
  disp.formula = NULL,
  control = list(reltol = 1e-08, reltol.c = 1e-08, TMB = TRUE, optimizer = ifelse((num.RR
    + num.lv.c) == 0 | randomB != FALSE, "optim", "alabama"), max.iter = 6000, maxit =
    6000, trace = FALSE, optim.method = NULL, nn.colMat = 10),
  control.va = list(Lambda.struc = "unstructured", Ab.struct = ifelse(is.null(colMat),
    "blockdiagonal", "MNunstructured"), Ab.struct.rank = 1, Ar.struc = "diagonal",
    diag.iter = 1, Ab.diag.iter = 0, Lambda.start = c(0.3, 0.3, 0.3), NN = 3),
  control.start = list(starting.val = "res", n.init = 1, n.init.max = 10, jitter.var = 0,
    jitter.var.br = 0, start.fit = NULL, start.lvs = NULL, randomX.start = "res",
    quad.start = 0.01, start.struc = "LV", scalmax = 10, MaternKappa = 1.5, rangeP =
    NULL, zetacutoff = NULL),
  setMap = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gllvm_+3A_y">y</code></td>
<td>
<p>(n x m) matrix of responses.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_x">X</code></td>
<td>
<p>matrix or data.frame of environmental covariates.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_tr">TR</code></td>
<td>
<p>matrix or data.frame of trait covariates.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_data">data</code></td>
<td>
<p>data in long format, that is, matrix of responses, environmental and trait covariates and row index named as &quot;id&quot;. When used, model needs to be defined using formula. This is alternative data input for y, X and TR.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted (for fixed-effects predictors).</p>
</td></tr>
<tr><td><code id="gllvm_+3A_family">family</code></td>
<td>
<p>distribution function for responses. Options are <code>"negative.binomial"</code> (with log link), <code>poisson(link = "log")</code>, <code>binomial(link = "probit")</code> (and also with <code>link = "logit"</code> when <code>method = "LA"</code> or <code>method = "EVA"</code>), zero-inflated poisson (<code>"ZIP"</code>), zero-inflated negative-binomial (<code>"ZINB"</code>), <code>gaussian(link = "identity")</code>, Tweedie (<code>"tweedie"</code>) (with log link, for <code>"LA"</code> and <code>"EVA"</code>-method), <code>"gamma"</code> (with log link), <code>"exponential"</code> (with log link), beta (<code>"beta"</code>) (with logit and probit link, for <code>"LA"</code> and  <code>"EVA"</code>-method), <code>"ordinal"</code> (with <code>"VA"</code> and <code>"EVA"</code>-method), beta hurdle <code>"betaH"</code> (for <code>"VA"</code> and <code>"EVA"</code>-method) and <code>"orderedBeta"</code> (for <code>"VA"</code> and <code>"EVA"</code>-method). Note: <code>"betaH"</code> and <code>"orderedBeta"</code> with <code>"VA"</code>-method are actually fitted using a hybrid approach such that EVA is applied to the beta distribution part of the likelihood.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_num.lv">num.lv</code></td>
<td>
<p>number of latent variables, d, in gllvm model. Non-negative integer, less than number of response variables (m). Defaults to 2, if <code>num.lv.c=0</code> and <code>num.RR=0</code>, otherwise 0.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_num.lv.c">num.lv.c</code></td>
<td>
<p>number of latent variables, d, in gllvm model to inform, i.e., with residual term. Non-negative integer, less than number of response (m) and equal to, or less than, the number of predictor variables (k). Defaults to 0. Requires specification of &quot;lv.formula&quot; in combination with &quot;X&quot; or &quot;datayx&quot;. Can be used in combination with num.lv and fixed-effects, but not with traits.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_num.rr">num.RR</code></td>
<td>
<p>number of latent variables, d, in gllvm model to constrain, without residual term (reduced rank regression). Cannot yet be combined with traits.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_lv.formula">lv.formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted (for latent variables).</p>
</td></tr>
<tr><td><code id="gllvm_+3A_lvcor">lvCor</code></td>
<td>
<p>correlation structure for latent variables, defaults to <code>NULL</code> Correlation structure for latent variables can be defined via formula, eg. <code>~struc(1|groups)</code>, where option to 'struc' are <code>corAR1</code> (AR(1) covariance), <code>corExp</code> (exponentially decaying, see argument '<code>dist</code>') and <code>corCS</code> (compound symmetry). The grouping variable needs to be included either in <code>studyDesign</code>. Works at the moment only with unconstrained ordination without quadratic term.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_studydesign">studyDesign</code></td>
<td>
<p>variables related to eg. sampling/study design, used for defining correlation structure of the latent variables and row effects.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_dist">dist</code></td>
<td>
<p>list of length equal to the number of row effects with correlation structure <code>corExp</code> that holds the matrix of coordinates or time points.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_distlv">distLV</code></td>
<td>
<p>matrix of coordinates or time points used for LV correlation structure <code>corExp</code>.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_colmat">colMat</code></td>
<td>
<p>either a list of length 2 with matrix of similarity for the column effects and named matrix &quot;dist&quot; of pairwise distances (of columns, to use in selecting nearest neighbours) for a sparse approximation of the matrix inverse in the likelihood, or only a (p.d.) matrix of similarity for the column effects for a normal inverse calculation.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_colmat.rho.struct">colMat.rho.struct</code></td>
<td>
<p>either <code>single</code> (default) or <code>term</code> indicating whether the signal parameter should be shared for covariates, or not.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_corwithin">corWithin</code></td>
<td>
<p>logical. Vector of length equal to the number of row effects. For structured row effects with correlation, If <code>TRUE</code>, correlation is set between row effects of the observation units within group. Correlation and groups can be defined using <code>row.eff</code>. Defaults to <code>FALSE</code>, when correlation is set for row parameters between groups.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_corwithinlv">corWithinLV</code></td>
<td>
<p>logical. For LVs with correlation, If <code>TRUE</code>, correlation is set between rows of the observation units within group. Defaults to <code>FALSE</code>, when correlation is set for rows between groups.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_quadratic">quadratic</code></td>
<td>
<p>either <code>FALSE</code>(default), <code>TRUE</code>, or <code>LV</code>. If <code>FALSE</code> models species responses as a linear function of the latent variables. If <code>TRUE</code> models species responses as a quadratic function of the latent variables. If <code>LV</code> assumes species all have the same quadratic coefficient per latent variable.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_row.eff">row.eff</code></td>
<td>
<p><code>FALSE</code>, <code>fixed</code>, <code>"random"</code> or formula to define the structure for the community level row effects, indicating whether row effects are included in the model as a fixed or as a random effects. Defaults to <code>FALSE</code> when row effects are not included. Structured random row effects can be defined via formula, eg. <code>~(1|groups)</code>, when unique row effects are set for each group, not for all rows, the grouping variable needs to be included in <code>studyDesign</code>. Correlation structure between random group effects/intercepts can also be set using <code>~struc(1|groups)</code>, where option to 'struc' are <code>corAR1</code> (AR(1) covariance), <code>corExp</code> (exponentially decaying, see argument '<code>dist</code>') and <code>corCS</code> (compound symmetry). Correlation structure can be set between or within groups, see argument '<code>corWithin</code>'.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_sd.errors">sd.errors</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) standard errors for parameter estimates are calculated.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_offset">offset</code></td>
<td>
<p>vector or matrix of offset terms.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_method">method</code></td>
<td>
<p>model can be fitted using Laplace approximation method (<code>method = "LA"</code>) or variational approximation method (<code>method = "VA"</code>), or with extended variational approximation method (<code>method = "EVA"</code>) when VA is not applicable. If particular model has not been implemented using the selected method, model is fitted using the alternative method as a default. Defaults to <code>"VA"</code>.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_randomb">randomB</code></td>
<td>
<p>either <code>FALSE</code>(default), &quot;LV&quot;, &quot;P&quot;, &quot;single&quot;, or &quot;iid&quot;. Fits concurrent or constrained ordination (i.e. models with num.lv.c or num.RR) with random slopes for the predictors. &quot;LV&quot; assumes LV-specific variance parameters, &quot;P&quot; predictor specific, and &quot;single&quot; the same across LVs and predictors.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_randomx">randomX</code></td>
<td>
<p>formula for species specific random effects of environmental variables in fourth corner model. Defaults to <code>NULL</code>, when random slopes are not included.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_beta0com">beta0com</code></td>
<td>
<p>logical. If <code>FALSE</code> column-specific intercepts are assumed. If <code>TRUE</code>, column-specific intercepts are collected to a common value.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_zeta.struc">zeta.struc</code></td>
<td>
<p>structure for cut-offs in the ordinal model. Either &quot;common&quot;, for the same cut-offs for all species, or &quot;species&quot; for species-specific cut-offs. For the latter, classes are arbitrary per species, each category per species needs to have at least one observations. Defaults to &quot;species&quot;.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> ordination plots will be printed in each iteration step when <code>TMB = FALSE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_link">link</code></td>
<td>
<p>link function for binomial family if <code>method = "LA"</code> and beta family. Options are &quot;logit&quot; and &quot;probit&quot;.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_ntrials">Ntrials</code></td>
<td>
<p>number of trials for binomial family.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_power">Power</code></td>
<td>
<p>fixed power parameter in Tweedie model. Scalar from interval (1,2). Defaults to 1.1. If set to NULL it is estimated (note: experimental).</p>
</td></tr>
<tr><td><code id="gllvm_+3A_seed">seed</code></td>
<td>
<p>a single seed value if <code>n.init=1</code>, and a seed value vector of length <code>n.init</code> if <code>n.init&gt;1</code>. Defaults to <code>NULL</code>, when new seed is not set for single initial fit and seeds are is randomly generated if multiple initial fits are set.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_scale.x">scale.X</code></td>
<td>
<p>logical. If <code>TRUE</code>, covariates are scaled when fourth corner model is fitted.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_return.terms">return.terms</code></td>
<td>
<p>logical. If <code>TRUE</code> 'terms' object is returned.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_gradient.check">gradient.check</code></td>
<td>
<p>logical. If <code>TRUE</code> gradients are checked for large values (&gt;0.01) even if the optimization algorithm did converge.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_disp.formula">disp.formula</code></td>
<td>
<p>a vector of indices, or alternatively formula, for the grouping of dispersion parameters (e.g. in a negative-binomial distribution, ZINB, tweedie), shape parameters (gamma, Beta, ordered Beta, hurdle Beta models) or variance parameters (gaussian distribution). Defaults to NULL so that all species have their own dispersion parameter. Is only allowed to include categorical variables. If a formula, data should be included as named rows in y.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_control">control</code></td>
<td>
<p>A list with the following arguments controlling the optimization:
</p>

<dl>
<dt><em>reltol</em>: </dt><dd><p> convergence criteria for log-likelihood, defaults to 1e-8.</p>
</dd>
<dt><em>reltol.c</em>: </dt><dd><p> convergence criteria for equality constraints in ordination with predictors, defaults to 1e-8.</p>
</dd>  
<dt><em>TMB</em>: </dt><dd><p> logical, if <code>TRUE</code> model will be fitted using Template Model Builder (TMB). TMB is always used if <code>method = "LA"</code>.  Defaults to <code>TRUE</code>.</p>
</dd>
<dt><em>optimizer</em>: </dt><dd><p> if <code>TMB=TRUE</code>, log-likelihood can be optimized using <code>"<a href="stats.html#topic+optim">optim</a>"</code> (default) or <code>"<a href="stats.html#topic+nlminb">nlminb</a>"</code>. For ordination with predictors (num.RR&gt;0 or num.lv.c&gt;0) this can additionally be one of <code>alabama</code>(default), <code>nloptr(agl)</code> or <code>nloptr(sqp)</code>.</p>
</dd>
<dt><em>max.iter</em>: </dt><dd><p> maximum number of iterations when <code>TMB = FALSE</code> or for <code>optimizer = "nlminb"</code> when <code>TMB = TRUE</code>, defaults to 6000.</p>
</dd>
<dt><em>maxit</em>: </dt><dd><p> maximum number of iterations for optimizer, defaults to 6000.</p>
</dd>
<dt><em>trace</em>: </dt><dd><p> logical, if <code>TRUE</code> in each iteration step information on current step will be printed. Defaults to <code>FALSE</code>. Only with <code>TMB = FALSE</code>.</p>
</dd>
<dt><em>optim.method</em>: </dt><dd><p> optimization method to be used if optimizer is <code>"<a href="stats.html#topic+optim">optim</a>"</code>,<code>"alabama"</code>, or  <code>"<a href="nloptr.html#topic+nloptr">nloptr</a>"</code>, but the latter two are only available in combination with at least two latent variables (i.e., num.RR+num.lv.c&gt;1). Defaults to <code>"BFGS"</code>, but to <code>"L-BFGS-B"</code> for Tweedie family due the limited-memory use. For optimizer='alabama' this can be any <code>"<a href="stats.html#topic+optim">optim</a>"</code> method, or  <code>"<a href="stats.html#topic+nlminb">nlminb</a>"</code>. If optimizer = 'nloptr(agl)' this can be one of: &quot;NLOPT_LD_CCSAQ&quot;, &quot;NLOPT_LD_SLSQP&quot;, &quot;NLOPT_LD_TNEWTON_PRECOND&quot; (default), &quot;NLOPT_LD_TNEWTON&quot;, &quot;NLOPT_LD_MMA&quot;.</p>
</dd>
<dt><em>nn.colMat</em>: </dt><dd><p>number of nearest neighbours for calculating inverse of &quot;colMat&quot;, defaults to 10. If set to the number of columns in the response data, a standard inverse is used instead.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gllvm_+3A_control.va">control.va</code></td>
<td>
<p>A list with the following arguments controlling the variational approximation method:
</p>

<dl>
<dt><em>Lambda.struc</em>: </dt><dd><p> covariance structure of VA distributions for latent variables when <code>method = "VA"</code>, &quot;unstructured&quot; or &quot;diagonal&quot;.</p>
</dd>
<dt><em>Ab.struct</em>: </dt><dd><p> covariance structure of VA distributions for random slopes when <code>method = "VA"</code>, ordered in terms of complexity: &quot;diagonal&quot;, &quot;MNdiagonal&quot; (only with colMat), &quot;blockdiagonal&quot; (default without colMat), &quot;MNunstructured&quot; (default, only with colMat), &quot;diagonalCL1&quot; ,&quot;CL1&quot; (only with colMat), &quot;CL2&quot; (only with colMat),&quot;diagonalCL2&quot; (only with colMat), or &quot;unstructured&quot; (only with colMat).</p>
</dd>
<dt><em>Ab.struct.rank</em>: </dt><dd><p>number of columns for the cholesky of the variational covariance matrix to use, defaults to 1. Only applicable with &quot;MNunstructured&quot;, &quot;diagonalCL1&quot;, &quot;CL1&quot;,&quot;diagonalCL2&quot;, and &quot;unstructured&quot;.</p>
</dd>
<dt><em>Ar.struc</em>: </dt><dd><p> covariance structure of VA distributions for random row effects when <code>method = "VA"</code>, &quot;unstructured&quot; or &quot;diagonal&quot;. Defaults to &quot;diagonal&quot;.</p>
</dd>
<dt><em>diag.iter</em>: </dt><dd><p> non-negative integer which can sometimes be used to speed up the updating of variational (covariance) parameters in VA method. Can sometimes improve the accuracy. If <code>TMB = TRUE</code> either 0 or 1. Defaults to 1.</p>
</dd>
<dt><em>Ab.diag.iter</em>: </dt><dd><p> As above, but for variational covariance of random slopes.</p>
</dd>
<dt><em>Lambda.start</em>: </dt><dd><p> starting values for variances in VA distributions for latent variables, random row effects and random slopes in variational approximation method. Defaults to 0.3.</p>
</dd>
<dt><em>NN</em>: </dt><dd><p> Number of nearest neighbors for NN variational covariance. Defaults to ...</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gllvm_+3A_control.start">control.start</code></td>
<td>
<p>A list with the following arguments controlling the starting values:
</p>

<dl>
<dt><em>starting.val</em>: </dt><dd><p> starting values can be generated by fitting model without latent variables, and applying factorial analysis to residuals to get starting values for latent variables and their coefficients (<code>starting.val = "res"</code>). Another options are to use zeros as a starting values (<code>starting.val = "zero"</code>) or initialize starting values for latent variables with (n x num.lv) matrix. Defaults to <code>"res"</code>, which is recommended.</p>
</dd>
<dt><em>n.init</em>: </dt><dd><p> number of initial runs. Uses multiple runs and picks up the one giving highest log-likelihood value. Defaults to 1.</p>
</dd>
<dt><em>n.init.max</em>: </dt><dd><p> maximum number of refits try try for n.init without improvement, defaults to 10.</p>
</dd>
<dt><em>start.fit</em>: </dt><dd><p> object of class 'gllvm' which can be given as starting parameters for count data (poisson, NB, or ZIP).</p>
</dd>
<dt><em>start.lvs</em>: </dt><dd><p> initialize starting values for latent variables with (n x num.lv) matrix. Defaults to <code>NULL</code>.</p>
</dd>
<dt><em>jitter.var</em>: </dt><dd><p> jitter variance for starting values of latent variables. Defaults to 0, meaning no jittering.</p>
</dd>
<dt><em>jitter.var.br</em>: </dt><dd><p> jitter variance for starting values of random slopes. Defaults to 0, meaning no jittering.</p>
</dd>
<dt><em>randomX.start</em>: </dt><dd><p> starting value method for the random slopes. Options are <code>"zero"</code> and <code>"res"</code>. Defaults to <code>"res"</code>.</p>
</dd>
<dt><em>start.struc</em>: </dt><dd><p> starting value method for the quadratic term. Options are <code>"LV"</code> (default) and <code>"all"</code>.</p>
</dd>
<dt><em>quad.start</em>: </dt><dd><p> starting values for quadratic coefficients. Defaults to 0.01.</p>
</dd>
<dt><em>MaternKappa</em>: </dt><dd><p> Starting value for smoothness parameter kappa of Matern covariance function. Defaults to 3/2.</p>
</dd>
<dt><em>scalmax</em>: </dt><dd><p> Sets starting value for the scale parameter for the coordinates. Defaults to 10, when the starting value for scale parameter scales the distances of coordinates between 0-10.</p>
</dd>
<dt><em>rangeP</em>: </dt><dd><p> Sets starting value for the range parameter for the correlation structure.</p>
</dd>
<dt><em>zetacutoff</em>: </dt><dd><p> Either vector of length 2 or a matrix of dimension (a number of species x 2). Sets starting value for the cutoff parameters of the ordered beta model.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gllvm_+3A_setmap">setMap</code></td>
<td>
<p>under development, not properly tested, except for ordinal beta cutoffs (zeta) and for rho_lvc. a list of a set of parameters to be fixed. Parameters to be fixed need to be defined with factors. Other arguments may overwrite these definitions.</p>
</td></tr>
<tr><td><code id="gllvm_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits generalized linear latent variable models as in Hui et al. (2015 and 2017) and Niku et al. (2017).
Method can be used with two types of latent variable models depending on covariates. If only
site related environmental covariates are used, the expectation of response <code class="reqn">Y_{ij}</code> is determined by
</p>
<p style="text-align: center;"><code class="reqn">g(\mu_{ij}) = \eta_{ij} = \alpha_i + \beta_{0j} + x_i'\beta_j + u_i'\theta_j,</code>
</p>

<p>where <code class="reqn">g(.)</code> is a known link function, <code class="reqn">u_i</code> are <code class="reqn">d</code>-variate latent variables (<code class="reqn">d</code>&lt;&lt;<code class="reqn">m</code>), <code class="reqn">\alpha_i</code> is an optional community level row effect
at site <code class="reqn">i</code>, and it can be fixed or random effect (also other structures are possible, see below), <code class="reqn">\beta_{0j}</code> is an intercept term for species <code class="reqn">j</code>, <code class="reqn">\beta_j</code> and <code class="reqn">\theta_j</code> are column
specific coefficients related to covariates and the latent variables, respectively.
</p>


<h4>Quadratic model</h4>

<p>Alternatively, a more complex version of the model can be fitted with <code>quadratic = TRUE</code>, where species are modeled as a quadratic function of the latent variables:
</p>
<p style="text-align: center;"><code class="reqn">g(\mu_{ij}) = \eta_{ij} = \alpha_i + \beta_{0j} + x_i'\beta_j + u_i'\theta_j - u_i' D_j u_i</code>
</p>
<p>.
Here, D_j is a diagonal matrix of positive only quadratic coefficients, so that the model generates concave shapes only. This implementation follows
the ecological theoretical model where species are generally recognized to exhibit non-linear response curves.
For a model with quadratic responses, quadratic coefficients are assumed to be the same for all species: </p>
<p style="text-align: center;"><code class="reqn">D_j = D</code>
</p>
<p>. This model requires less information
per species and can be expected to be more applicable to most datasets. The quadratic coefficients D can be used to calculate the length of 
ecological gradients.
For quadratic responses, it can be useful to provide the latent variables estimated with a GLLVM with linear responses, or estimated with (Detrended) Correspondence Analysis.
The latent variables can then be passed to the <code>start.lvs</code> argument inside the <code>control.start</code> list, which in many cases gives good results. 
</p>



<h4>Ordination with predictors</h4>

<p>For GLLVMs with both linear and quadratic response model, a series of predictors <code class="reqn">x_{lv}</code> can be included to explain the latent variables:
</p>
<p style="text-align: center;"><code class="reqn">g(\mu_{ij}) = \alpha_i + \beta_{0j} + x_i'\beta_j + (B' x_{lv,i} + \epsilon_i)' \gamma_j - (B' x_{lv,i} + \epsilon_i)' D_j (B' x_{lv,i} + \epsilon_i) ,</code>
</p>

<p>where <code class="reqn">z_i = B' x_{lv,i} + \epsilon_i</code> are latent variables informed by the predictors, but not constrained compared to unconstrained ordination as in methods such as CCA or RDA.
Omitting the predictors results in an unconstrained ordination, and omitting <code class="reqn">\epsilon_i</code> in the usual constrained ordination, which can also be fitted.
</p>



<h4>Fourth corner model</h4>

<p>An alternative model is the fourth corner model (Brown et al., 2014, Warton et al., 2015) which will be fitted if also trait covariates
are included. The expectation of response <code class="reqn">Y_{ij}</code> is
</p>
<p style="text-align: center;"><code class="reqn">g(\mu_{ij}) = \alpha_i + \beta_{0j} + x_i'(\beta_x + b_j) + TR_j'\beta_t + vec(B)*kronecker(TR_j,X_i) + u_i'\theta_j - u_i'D_ju_i</code>
</p>

<p>where g(.), <code class="reqn">u_i</code>, <code class="reqn">\beta_{0j}</code> and <code class="reqn">\theta_j</code> are defined as above. Vectors <code class="reqn">\beta_x</code> and <code class="reqn">\beta_t</code> are the main effects
or coefficients related to environmental and trait covariates, respectively, matrix <code class="reqn">B</code> includes interaction terms. Vectors <code class="reqn">b_j</code> are 
optional species-specific random slopes for environmental covariates.
The interaction/fourth corner terms are optional as well as are the main effects of trait covariates.
</p>



<h4>Structured row effects</h4>

<p>In addition to the sample-specific community level random effects, <code class="reqn">\alpha_i</code>, it is also possible to set arbitrary structure/design for the row effects. 
That is, assume that observations / rows <code class="reqn">i=1,...,n</code> in the data matrix are from groups <code class="reqn">t=1,...,T</code>, so that each row <code class="reqn">i</code> belongs to one of the groups, denote <code class="reqn">G(i) \in \{1,...,T\}</code>. Each group <code class="reqn">t</code> has a number of observations <code class="reqn">n_t</code>, so that <code class="reqn">\sum_{t=1}^{T} n_t =n</code>.
Now we can set random intercept for each group <code class="reqn">t</code>, (see argument '<code>row.eff</code>'):
</p>
<p style="text-align: center;"><code class="reqn">g(\mu_{ij}) = \eta_{ij} = \alpha_{G(i)} + \beta_{0j} + x_i'\beta_j + u_i'\theta_j,</code>
</p>

<p>There is also a possibility to set correlation structure for the random intercepts between groups, so that <code class="reqn">(\alpha_{1},...,\alpha_{T})^\top \sim N(0, \Sigma_r)</code>. That might be the case, for example, when the groups are spatially or temporally dependent.
Another option is to set row specific random intercepts <code class="reqn">\alpha_i</code>, but to set the correlation structure for the observations within groups, (see argument '<code>corWithin</code>'). That is, we can set <code class="reqn">corr(\alpha_{i},\alpha_{i'}) = C(i,i') \neq 0</code> according to some correlation function <code class="reqn">C</code>, when <code class="reqn">G(i)=G(i')</code>.
This model is restricted to the case, where each group has equal number of observations (rows), that is <code class="reqn">n_t=n_{t'}</code> for all <code class="reqn">t,t' \in \{1,...,T\}</code>.
</p>
<p>The correlation structures available in the package are 
</p>

<dl>
<dt><code>corAR1</code> </dt><dd><p> autoregressive process of order 1.</p>
</dd>
<dt><code>corExp</code> </dt><dd><p> exponentially decaying, see argument '<code>dist</code>'.</p>
</dd>
<dt><code>corCS</code> </dt><dd><p> compound symmetry.</p>
</dd>
</dl>
  



<h4>Starting values</h4>

<p>The method is sensitive for the choices of initial values of the latent variables. Therefore it is
recommendable to use multiple runs and pick up the one giving the highest log-likelihood value (see argument '<code>n.init</code>').
However, sometimes this is computationally too demanding, and default option
<code>starting.val = "res"</code> is recommended. For more details on different starting value methods, see Niku et al., (2018).
</p>

<p>Models are implemented using TMB (Kristensen et al., 2015) applied to variational approximation (Hui et al., 2017), extended variational approximation (Korhonen et al., 2021) and Laplace approximation (Niku et al., 2017).
</p>
<p>With ordinal family response classes must start from 0 or 1.
</p>


<h4>Distributions</h4>

<p>Mean and variance for distributions are defined as follows.
</p>

<dl>
<dt>For count data <code>family = poisson()</code>:</dt><dd><p>Expectation <code class="reqn">E[Y_{ij}] = \mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \mu_{ij}</code>, or</p>
</dd>
<dt> <code>family = "negative.binomial"</code>:</dt><dd><p> Expectation <code class="reqn">E[Y_{ij}] = \mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \mu_{ij}+\mu_{ij}^2\phi_j</code>, or</p>
</dd>
<dt> <code>family = "ZIP"</code>:</dt><dd><p> Expectation <code class="reqn">E[Y_{ij}] = (1-p)\mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \mu_{ij}(1-p_j)(1+\mu_{ij}p)</code>.</p>
</dd>
<dt> <code>family = "ZINB"</code>:</dt><dd><p> Expectation <code class="reqn">E[Y_{ij}] = (1-p)\mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \mu_{ij}(1-p_j)(1+\mu_{ij}(\phi_j+p_j))</code>.</p>
</dd>
<dt>For binary data <code>family = binomial()</code>:</dt><dd><p> Expectation <code class="reqn">E[Y_{ij}] = \mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \mu_{ij}(1-\mu_{ij})</code>.</p>
</dd>
<dt>For percent cover data <code class="reqn">0 &lt; Y_{ij} &lt; 1</code> <code>family = "beta"</code>:</dt><dd><p> Expectation <code class="reqn">E[Y_{ij}] = \mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \mu_{ij}(1-\mu_{ij})//(1+\phi_j)</code>.</p>
</dd>
<dt>For positive continuous data <code>family = "gamma"</code>:</dt><dd><p>Expectation <code class="reqn">E[Y_{ij}] = \mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \mu_{ij}^2/\phi_j</code>, where <code class="reqn">\phi_j</code> is species specific shape parameter.</p>
</dd>
<dt>For non-negative  continuous data <code>family = "exponential"</code>:</dt><dd><p>Expectation <code class="reqn">E[Y_{ij}] = \mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \mu_{ij}^2</code>.</p>
</dd>
<dt>For non-negative continuous or biomass data <code>family = "tweedie"</code></dt><dd><p> Expectation <code class="reqn">E[Y_{ij}] = \mu_{ij}</code>, variance <code class="reqn">V(\mu_{ij}) = \phi_j*\mu_{ij}^\nu</code>, where <code class="reqn">\nu</code> is a power parameter of Tweedie distribution. See details Dunn and Smyth (2005).</p>
</dd>
<dt>For ordinal data <code>family = "ordinal"</code>:</dt><dd><p> Cumulative probit model, see Hui et.al. (2016).</p>
</dd>
<dt>For normal distributed data <code>family = gaussian()</code>:</dt><dd><p> Expectation <code class="reqn">E[Y_{ij}] = \mu_{ij}</code>, variance <code class="reqn">V(y_{ij}) = \phi_j^2.</code></p>
</dd>
</dl>




<h3>Value</h3>

<p>An object of class &quot;gllvm&quot; includes the following components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p> function call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> (n x m) matrix of responses.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p> matrix or data.frame of environmental covariates.</p>
</td></tr>
<tr><td><code>X.design</code></td>
<td>
<p> design matrix of environmental covariates.</p>
</td></tr>
<tr><td><code>lv.X</code></td>
<td>
<p> design matrix or data.frame of environmental covariates for latent variables.</p>
</td></tr>
<tr><td><code>lv.X.design</code></td>
<td>
<p> design matrix or data.frame of environmental covariates for latent variables.</p>
</td></tr>
<tr><td><code>TR</code></td>
<td>
<p> Trait matrix.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> Formula for predictors.</p>
</td></tr>
<tr><td><code>lv.formula</code></td>
<td>
<p> Formula of latent variables in constrained and concurrent ordination.</p>
</td></tr>
<tr><td><code>randomX</code></td>
<td>
<p> Formula for species specific random effects in fourth corner model.</p>
</td></tr>
<tr><td><code>Xd</code></td>
<td>
<p> design matrix for species specific random effects in fourth corner model.</p>
</td></tr>
<tr><td><code>randomB</code></td>
<td>
<p> Boolean flag for random slopes in constrained and concurrent ordination.</p>
</td></tr>
<tr><td><code>num.lv</code></td>
<td>
<p> Number of unconstrained latent variables.</p>
</td></tr>
<tr><td><code>num.lv.c</code></td>
<td>
<p> Number of latent variables in concurrent ordination.</p>
</td></tr>
<tr><td><code>num.RR</code></td>
<td>
<p> Number of latent variables in constrained ordination.</p>
</td></tr>
<tr><td><code>Ntrials</code></td>
<td>
<p> Number of trials in a binomial model.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> Method used for integration.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p> Response distribution.</p>
</td></tr>
<tr><td><code>row.eff</code></td>
<td>
<p> Type of row effect used.</p>
</td></tr>
<tr><td><code>n.init</code></td>
<td>
<p> Number of model runs for best fit.</p>
</td></tr>
<tr><td><code>disp.group</code></td>
<td>
<p> Groups for dispersion parameters.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p> List of standard errors.</p>
</td></tr>
<tr><td><code>lvs</code></td>
<td>
<p> Latent variables.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p> List of parameters
</p>

<dl>
<dt>theta </dt><dd><p> latent variables' loadings relative to the diagonal entries of loading matrix</p>
</dd>
<dt>sigma.lv </dt><dd><p> diagonal entries of latent variables' loading matrix</p>
</dd>
<dt>LvXcoef </dt><dd><p> Predictor coefficients (or predictions for random slopes) related to latent variables, i.e. canonical coefficients</p>
</dd>
<dt>beta0 </dt><dd><p> column specific intercepts</p>
</dd>
<dt>Xcoef </dt><dd><p> coefficients related to environmental covariates X</p>
</dd>
<dt>B </dt><dd><p> coefficients in fourth corner model, and RE means</p>
</dd>
<dt>Br</dt><dd><p> column random effects</p>
</dd>
<dt>sigmaB</dt><dd><p> scale parameters for column-specific random effects</p>
</dd>
<dt>rho.sp</dt><dd><p> (positive) correlation parameter for influence strength of &quot;colMat&quot;</p>
</dd>
<dt>row.params.random </dt><dd><p> row-specific random effects</p>
</dd>
<dt>row.params.fixed </dt><dd><p> row-specific fixed effects</p>
</dd>
<dt>sigma </dt><dd><p> scale parameters for row-specific random effects</p>
</dd>
<dt>phi </dt><dd><p> dispersion parameters <code class="reqn">\phi</code> for negative binomial or Tweedie family, probability of zero inflation for ZIP family, standard deviation for gaussian family or shape parameter for gamma/beta family</p>
</dd>
<dt>inv.phi </dt><dd><p> dispersion parameters <code class="reqn">1/\phi</code> for negative binomial</p>
</dd>
</dl>
</td></tr>
<tr><td><code>Power</code></td>
<td>
<p> power parameter <code class="reqn">\nu</code> for Tweedie family</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p> list of standard errors of parameters</p>
</td></tr>
<tr><td><code>prediction.errors</code></td>
<td>
<p> list of prediction covariances for latent variables and variances for random row effects when method <code>"LA"</code> is used</p>
</td></tr>
<tr><td><code>A</code>, <code>Ar</code>, <code>Ab_lv</code>, <code>spArs</code></td>
<td>
<p> covariance matrices for variational densities of latent variables, random row effects, random slopes, and colum effects respectively</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p> Seed used for calculating starting values</p>
</td></tr>
<tr><td><code>TMBfn</code></td>
<td>
<p> TMB objective and derivative functions</p>
</td></tr>
<tr><td><code>logL</code></td>
<td>
<p> log likelihood</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p> convergence code of optimizer</p>
</td></tr>
<tr><td><code>quadratic</code></td>
<td>
<p> flag for quadratic model</p>
</td></tr>
<tr><td><code>Hess</code></td>
<td>
<p> List holding matrices of second derivatives</p>
</td></tr>
<tr><td><code>beta0com</code></td>
<td>
<p> Flag for common intercept</p>
</td></tr>
<tr><td><code>cstruc</code></td>
<td>
<p> Correlation structure for row effects</p>
</td></tr>
<tr><td><code>cstruclv</code></td>
<td>
<p> Correlation structure for LVs</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p> Matrix of coordinates or time points used for row effects</p>
</td></tr>
<tr><td><code>distLV</code></td>
<td>
<p> Matrix of coordinates or time points used for LVs</p>
</td></tr>
<tr><td><code>col.eff</code></td>
<td>
<p> list of components for column random effects</p>
</td></tr>
</table>

<dl>
<dt>Ab.struct </dt><dd><p> variational covariance structure of fitted model</p>
</dd>
<dt>Ab.struct.rank </dt><dd><p>fitted rank of variational covariance matrix</p>
</dd>
<dt>col.eff </dt><dd><p>flag indicating if column random effects are included</p>
</dd>
<dt>spdr </dt><dd><p> design matrix</p>
</dd>
<dt>colMat.rho.struct </dt><dd><p> character vector for signal parameter</p>
</dd>
</dl>

<table role = "presentation">
<tr><td><code>terms</code></td>
<td>
<p> Terms object for main predictors</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p> starting values for model</p>
</td></tr>
<tr><td><code>optim.method</code></td>
<td>
<p> Optimization method when using 'optim', 'alabama', or 'nloptr'</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If function gives warning: 'In f(x, order = 0) : value out of range in 'lgamma&rdquo;, optimizer have visited an area where gradients become too big. It is automatically fixed by trying another step in the optimization process, and can be ignored if errors do not occur.
</p>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;, Wesley Brooks, Riki Herliansyah, Francis K.C. Hui, Pekka Korhonen, Sara Taskinen, Bert van der Veen, David I. Warton
</p>


<h3>References</h3>

<p>Brown, A. M., Warton, D. I., Andrew, N. R., Binns, M., Cassis, G., and Gibb, H. (2014). The fourth-corner solution - using predictive models to understand how species traits interact with the environment. Methods in Ecology and Evolution, 5:344-352.
</p>
<p>Dunn, P. K. and Smyth, G. K. (2005).  Series evaluation of tweedie exponential dispersion model densities. Statistics and Computing, 15:267-280.
</p>
<p>Hui, F. K. C., Taskinen, S., Pledger, S., Foster, S. D., and Warton, D. I. (2015).  Model-based approaches to unconstrained ordination. Methods in Ecology and Evolution, 6:399-411.
</p>
<p>Hui, F. K. C., Warton, D., Ormerod, J., Haapaniemi, V., and Taskinen, S. (2017).  Variational approximations for generalized linear latent variable models. Journal of Computational and Graphical Statistics. Journal of Computational and Graphical Statistics, 26:35-43.
</p>
<p>Kasper Kristensen, Anders Nielsen, Casper W. Berg, Hans Skaug, Bradley M. Bell (2016). TMB: Automatic Differentiation and Laplace Approximation. Journal of Statistical Software, 70(5), 1-21.
</p>
<p>Korhonen, P., Hui, F. K. C., Niku, J., and Taskinen, S. (2021). Fast, universal estimation of latent variable models using extended variational approximations. Stat Comput 33, 26 (2023).
</p>
<p>Niku, J., Warton,  D. I., Hui, F. K. C., and Taskinen, S. (2017). Generalized linear latent variable models for multivariate count and biomass data in ecology. Journal of Agricultural, Biological, and Environmental Statistics, 22:498-522.
</p>
<p>Niku, J., Brooks, W., Herliansyah, R., Hui, F. K. C., Taskinen, S., and Warton,  D. I. (2018). Efficient estimation of generalized linear latent variable models. PLoS One, 14(5):1-20.
</p>
<p>Warton, D. I., Guillaume Blanchet, F., O'Hara, R. B., Ovaskainen, O., Taskinen, S., Walker, S. C. and Hui, F. K. C. (2015). So many variables: Joint modeling in community ecology. Trends in Ecology &amp; Evolution, 30:766-779.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefplot.gllvm">coefplot.gllvm</a></code>, <code><a href="#topic+confint.gllvm">confint.gllvm</a></code>, <code><a href="#topic+ordiplot.gllvm">ordiplot.gllvm</a></code>, <code><a href="#topic+plot.gllvm">plot.gllvm</a></code>, <code><a href="#topic+summary.gllvm">summary.gllvm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract subset of the microbial data to be used as an example
data(microbialdata)
X &lt;- microbialdata$Xenv
y &lt;- microbialdata$Y[, order(colMeans(microbialdata$Y &gt; 0), 
                     decreasing = TRUE)[21:40]]
fit &lt;- gllvm(y, X, formula = ~ pH + Phosp, family = poisson())
fit$logL
ordiplot(fit)
coefplot(fit)


# Inclusion of structured random row effect
sDesign&lt;-data.frame(Site = microbialdata$Xenv$Site)
fit &lt;- gllvm(y, X, formula = ~ pH + Phosp, family = poisson(), 
            studyDesign=sDesign, row.eff=~(1|Site))

## Load a dataset from the mvabund package
library(mvabund)
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
X &lt;- as.matrix(antTraits$env)
TR &lt;- antTraits$traits
# Fit model with environmental covariates Bare.ground and Shrub.cover
fit &lt;- gllvm(y, X, formula = ~ Bare.ground + Shrub.cover,
            family = poisson())
ordiplot(fit)
coefplot.gllvm(fit)

## Example 1: Fit model with two unconstrained latent variables
# Using variational approximation:
fitv0 &lt;- gllvm(y, family = "negative.binomial", method = "VA")
ordiplot(fitv0)
plot(fitv0, mfrow = c(2,2))
summary(fitv0)
confint(fitv0)

## Example 1a: Fit concurrent ordination model with two latent variables and with 
# quadratic response model
# We scale and centre the  predictors to improve convergence
fity1 &lt;- gllvm(y, X = scale(X), family = "negative.binomial", 
              num.lv.c=2, method="VA")
ordiplot(fity1, biplot = TRUE)

#'## Example 1b: Fit constrained ordination model with two latent variables and with 
# random canonical coefficients
fity2 &lt;- gllvm(y, X = scale(X), family = "negative.binomial", 
              num.RR=2, randomB="LV", method="VA")
              
# Using Laplace approximation: (this line may take about 30 sec to run)
fitl0 &lt;- gllvm(y, family = "negative.binomial", method = "LA")
ordiplot(fitl0)

# Poisson family:
fit.p &lt;- gllvm(y, family = poisson(), method = "LA")
ordiplot(fit.p)
# Use poisson model as a starting parameters for ZIP-model, this line 
# may take few minutes to run
fit.z &lt;- gllvm(y, family = "ZIP", method = "LA", 
              control.start = list(start.fit = fit.p))
ordiplot(fit.z)


## Example 2: gllvm with environmental variables
# Fit model with two latent variables and all environmental covariates,
fitvX &lt;- gllvm(formula = y ~ X, family = "negative.binomial")
ordiplot(fitvX, biplot = TRUE)
coefplot.gllvm(fitvX)
# Fit model with environmental covariates Bare.ground and Shrub.cover
fitvX2 &lt;- gllvm(y, X, formula = ~ Bare.ground + Shrub.cover,
 family = "negative.binomial")
ordiplot(fitvX2)
coefplot.gllvm(fitvX2)
# Use 5 initial runs and pick the best one
fitvX_5 &lt;- gllvm(y, X, formula = ~ Bare.ground + Shrub.cover,
 family = "negative.binomial", control.start=list(n.init = 5, jitter.var = 0.1))
ordiplot(fitvX_5)
coefplot.gllvm(fitvX_5)

## Example 3: Data in long format
# Reshape data to long format:
datalong &lt;- reshape(data.frame(cbind(y,X)), direction = "long",
                   varying = colnames(y), v.names = "y")
head(datalong)
fitvLong &lt;- gllvm(data = datalong, formula = y ~ Bare.ground + Shrub.cover,
               family = "negative.binomial")

## Example 4: Fourth corner model
# Fit fourth corner model with two latent variables
fitF1 &lt;- gllvm(y = y, X = X, TR = TR, family = "negative.binomial")
coefplot.gllvm(fitF1)
# Fourth corner can be plotted also with next lines
#fourth = fitF1$fourth.corner
#library(lattice)
#a = max( abs(fourth) )
#colort = colorRampPalette(c("blue","white","red"))
#plot.4th = levelplot(t(as.matrix(fourth)), xlab = "Environmental Variables",
#              ylab = "Species traits", col.regions = colort(100),
#              at = seq( -a, a, length = 100), scales = list( x = list(rot = 45)))
#print(plot.4th)

# Specify model using formula
fitF2 &lt;- gllvm(y = y, X = X, TR = TR,
 formula = ~ Bare.ground + Canopy.cover * (Pilosity + Webers.length),
 family = "negative.binomial")
ordiplot(fitF2)
coefplot.gllvm(fitF2)

## Include species specific random slopes to the fourth corner model
fitF3 &lt;- gllvm(y = y, X = X, TR = TR,
 formula = ~ Bare.ground + Canopy.cover * (Pilosity + Webers.length),
 family = "negative.binomial", randomX = ~ Bare.ground + Canopy.cover, 
 control.start = list(n.init = 3))
ordiplot(fitF3)
coefplot.gllvm(fitF3)


## Example 5: Fit Tweedie model
# Load coral data
data(tikus)
ycoral &lt;- tikus$abund
# Let's consider only years 1981 and 1983
ycoral &lt;- ycoral[((tikus$x$time == 81) + (tikus$x$time == 83)) &gt; 0, ]
# Exclude species which have observed at less than 4 sites
ycoral &lt;- ycoral[-17, (colSums(ycoral &gt; 0) &gt; 4)]
# Fit Tweedie model for coral data (this line may take few minutes to run)
fit.twe &lt;- gllvm(y = ycoral, family = "tweedie", method = "EVA", seed=111)
fit.twe

## Example 6: Random row effects
fitRand &lt;- gllvm(y, family = "negative.binomial", row.eff = "random")
ordiplot(fitRand, biplot = TRUE)

</code></pre>

<hr>
<h2 id='kelpforest'>Kelp Forest community Dynamics: Cover of sessile organisms, Uniform Point Contact</h2><span id='topic+kelpforest'></span>

<h3>Description</h3>

<p>These data describe the cover of sessile invertebrates, understory macroalgae, and bottom substrate types as determined by a uniform point contact method. The presence of over 150 taxa of sessile invertebrates and macroalgae are recorded at 80 uniformly spaced points along permanent 40m x 2m transects. Multiple species can be recorded at any given point. Percent cover of a given species on a transect can be estimated from UPC observations as the fraction of total points at which that species was present x 100. The total percent cover of all species combined using this method can exceed 100%; however, the percent cover of any single species cannot exceed 100%. This specific version of the data includes 61 species of macroalgae, 69 species of sessile invertebrates, and two species of plants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kelpforest)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Y</dt><dd><p>A data frame with the percent cover records of 132 sessile invertebrates and understory macroalgae measured at 836 permanent transects.</p>
</dd>
<dt>X</dt><dd><p>A data frame of study design variables and predictors.</p>
</dd>
</dl>

<dl>
<dt>SITE</dt><dd><p>Kelp forest site</p>
</dd> 
<dt>YEAR</dt><dd><p>Sampling year</p>
</dd>
<dt>TRANSECT</dt><dd><p>Permanent transect identifying number (unique within site), nested within sites</p>
</dd>
<dt>KELP_FRONDS</dt><dd><p>A number of stipes of giant kelp</p>
</dd>
<dt>PERCENT_ROCKY</dt><dd><p>percent rock coverage</p>
</dd>
</dl>

<dl>
<dt>SPinfo</dt><dd><p>A data frame of the species information including species names, group and taxonomy.</p>
</dd>
</dl>

<dl>
<dt>SP_CODE</dt><dd><p>Species codes corresponding species names in abundance matrix</p>
</dd> 
<dt>GROUP</dt><dd><p>Species group; algae, invertebrate or plant</p>
</dd>
<dt>COMMON_NAME, SCIENTIFIC_NAME</dt><dd><p>Species' common and scientific names</p>
</dd>
<dt>TAXON_KINGDOM,TAXON_PHYLUM,TAXON_CLASS,TAXON_ORDER,TAXON_FAMILY, TAXON_GENUS</dt><dd><p>Species taxonomic information</p>
</dd>
</dl>




<h3>Details</h3>

<p>These data are part of SBC LTERs kelp forest monitoring program, which began in 2000 and was designed to track long-term patterns in species abundance and diversity of reef-associated organisms in the Santa Barbara Channel, California, USA. The sampling locations in this dataset include nine reef sites along the mainland coast of the Santa Barbara Channel and at two sites on the north side of Santa Cruz Island. These sites reflect several oceanographic regimes in the channel and vary in distance from sources of terrestrial runoff. Data collection began in 2000 and this dataset is updated annually.
</p>
<p>The time period of data collection varied among the 11 kelp forest sites. Sampling at BULL, CARP, and NAPL began in 2000, sampling at the other 6 mainland sites (AHND, AQUE, IVEE, GOLB, ABUR, MOHK) began in 2001 (transects 3, 5, 6, 7, 8 at IVEE were added in 2011). Data collection at the two Santa Cruz Island sites (SCTW and SCDI) began in 2004.
</p>
<p>Detailed description of the data available in the reference and the website  https://sbclter.msi.ucsb.edu/data/catalog/package/?package=knb-lter-sbc.15
</p>


<h3>References</h3>

<p>Reed, D, R. Miller. 2023. SBC LTER: Reef: Kelp Forest Community Dynamics: Cover of sessile organisms, Uniform Point Contact ver 33. Environmental Data Initiative. https://doi.org/10.6073/pasta/0af1a5b0d9dde5b4e5915c0012ccf99c. (Accessed: 2023-12-01).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(kelpforest)
Y &lt;- kelpforest$Y
X &lt;- kelpforest$X
SPinfo &lt;- kelpforest$SPinfo

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.gllvm'>Log-likelihood of gllvm</h2><span id='topic+logLik.gllvm'></span><span id='topic+logLik'></span>

<h3>Description</h3>

<p>Extracts Log-likelihood from 'gllvm' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="logLik.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David I. Warton, Jenni Niku
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
# Fit gllvm model
fit &lt;- gllvm(y = y, family = poisson())
# log-Likelihood:
logLik(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='microbialdata'>Microbial community data</h2><span id='topic+microbialdata'></span>

<h3>Description</h3>

<p>Microbial community data consist of abundances of 985 bacteria species measured at 56 soil sample sites from three regions, Kilpisjarvi (Finland), Ny-Alesund (Norway), and Mayrhofen (Austria). In addition to bacteria counts, three continuous environmental variables (pH, available phosphorous and soil organic matter) were measured from each soil sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(microbialdata)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Y</dt><dd><p>A data frame with abundances of 985 bacteria species measured at 56 soil sample sites</p>
</dd>
<dt>X</dt><dd><p>Environmental variables SOM: soil organic matter, pH: soil pH value and Phosp: available phosphorus and information from the samples, including Region: sampling region (Kilpisjarvi (Finland), Ny-Alesund (Norway), and Mayrhofen (Austria).), Site: sampling site and Soiltype: soil sample type (top soil (T) or bottom soil (B))</p>
</dd>
</dl>


<h3>References</h3>

<p>Kumar, M., Brader, G., Sessitsch, A., Mäki, A., van Elsas, J.D., and Nissinen, R. (2017). Plants Assemble Species Specific Bacterial Communities from Common Core Taxa in Three Arcto-Alpine Climate Zones. Frontiers in Microbiology, 8:12.
</p>
<p>Niku, J., Warton,  D. I., Hui, F. K. C., and Taskinen, S. (2017). Generalized linear latent variable models for multivariate count and biomass data in ecology. Journal of Agricultural, Biological, and Environmental Statistics, 22:498-522.
</p>

<hr>
<h2 id='ordiplot.gllvm'>Plot latent variables from gllvm model</h2><span id='topic+ordiplot.gllvm'></span><span id='topic+ordiplot'></span>

<h3>Description</h3>

<p>Plots latent variables and their corresponding coefficients (biplot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
ordiplot(
  object,
  biplot = FALSE,
  ind.spp = NULL,
  alpha = 0.5,
  main = NULL,
  which.lvs = c(1, 2),
  predict.region = FALSE,
  level = 0.95,
  jitter = FALSE,
  jitter.amount = 0.2,
  s.colors = 1,
  s.cex = 1.2,
  symbols = FALSE,
  cex.spp = 0.7,
  spp.colors = "blue",
  arrow.scale = 0.8,
  arrow.spp.scale = 0.8,
  arrow.ci = TRUE,
  arrow.lty = "solid",
  fac.center = FALSE,
  spp.arrows = NULL,
  spp.arrows.lty = "dashed",
  cex.env = 0.7,
  lab.dist = 0.1,
  lwd.ellips = 0.5,
  col.ellips = 4,
  lty.ellips = 1,
  type = NULL,
  rotate = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordiplot.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_biplot">biplot</code></td>
<td>
<p><code>TRUE</code> if both latent variables and their coefficients are plotted, <code>FALSE</code> if only latent variables.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_ind.spp">ind.spp</code></td>
<td>
<p>the number of response variables (usually, species) to include on the biplot. The default is none, or all if <code>biplot = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_alpha">alpha</code></td>
<td>
<p>a numeric scalar between 0 and 1 that is used to control the relative scaling of the latent variables and their coefficients, when constructing a biplot.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_main">main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_which.lvs">which.lvs</code></td>
<td>
<p>indices of two latent variables to be plotted if number of the latent variables is more than 2. A vector with length of two. Defaults to <code>c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_predict.region">predict.region</code></td>
<td>
<p>if <code>TRUE</code> or <code>"sites"</code> prediction regions for the predicted latent variables are plotted, defaults to <code>FALSE</code>. EXTENSION UNDER DEVELOPMENT: if <code>"species"</code> uncertainty estimate regions for the estimated latent variable loadings are plotted. Works only if <code>biplot = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_level">level</code></td>
<td>
<p>level for prediction regions.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_jitter">jitter</code></td>
<td>
<p>if <code>TRUE</code>, jittering is applied on points.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_jitter.amount">jitter.amount</code></td>
<td>
<p>numeric, positive value indicating an amount of jittering for each point, defaults to 0.2 (jitter range).</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_s.colors">s.colors</code></td>
<td>
<p>colors for sites</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_s.cex">s.cex</code></td>
<td>
<p>size of site labels</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_symbols">symbols</code></td>
<td>
<p>logical, if <code>TRUE</code> sites are plotted using symbols, if <code>FALSE</code> (default) site numbers are used</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_cex.spp">cex.spp</code></td>
<td>
<p>size of species labels in biplot</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_spp.colors">spp.colors</code></td>
<td>
<p>colors for sites, defaults to <code>"blue"</code></p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_arrow.scale">arrow.scale</code></td>
<td>
<p>positive value, to scale arrows</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_arrow.spp.scale">arrow.spp.scale</code></td>
<td>
<p>positive value, to scale arrows of species</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_arrow.ci">arrow.ci</code></td>
<td>
<p>represent statistical uncertainty for arrows in constrained or concurrent ordination using confidence or prediction interval? Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_arrow.lty">arrow.lty</code></td>
<td>
<p>linetype for arrows in constrained</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_fac.center">fac.center</code></td>
<td>
<p>logical. If <code>TRUE</code> place labels for binary variables at their estimated location.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_spp.arrows">spp.arrows</code></td>
<td>
<p>plot species scores as arrows if outside of the range of the plot? Defaults to <code>FALSE</code> for linear response models and <code>TRUE</code> for quadratic response models.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_spp.arrows.lty">spp.arrows.lty</code></td>
<td>
<p>linetype for species arrows</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_cex.env">cex.env</code></td>
<td>
<p>size of labels for arrows in constrained ordination</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_lab.dist">lab.dist</code></td>
<td>
<p>distance between label and arrow heads. Value between 0 and 1</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_lwd.ellips">lwd.ellips</code></td>
<td>
<p>line width for prediction ellipses. See graphical parameter lwd.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_col.ellips">col.ellips</code></td>
<td>
<p>colors for prediction ellipses.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_lty.ellips">lty.ellips</code></td>
<td>
<p>line type for prediction ellipses. See graphical parameter lty.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_type">type</code></td>
<td>
<p>which type of ordination plot to construct. Options are &quot;residual&quot;, &quot;conditional&quot;, and &quot;marginal&quot;. Defaults to &quot;residual&quot; for GLLVMs with unconstrained latent variables and &quot;conditional&quot; otherwise.</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_rotate">rotate</code></td>
<td>
<p>logical, if <code>TRUE</code> (default) latent variables are rotated to their principal direction using singular value decomposition</p>
</td></tr>
<tr><td><code id="ordiplot.gllvm_+3A_...">...</code></td>
<td>
<p>additional graphical arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function constructs a scatter plot of two latent variables, i.e. an ordination plot. 
Latent variables are re-rotated to their principal direction using singular value decomposition,
so that the first plotted latent variable does not have to be the first latent variable in the model.
If only one latent variable is in the fitted model, latent variables are plotted against their corresponding row indices.
The latent variables are labeled using the row index of the response matrix y.
</p>
<p>Coefficients related to latent variables are plotted in the same figure with the latent
variables if <code>biplot = TRUE</code>. They are labeled using the column names of y. The number
of latent variable coefficients to be plotted can be controlled by ind.spp. An argument alpha
is used to control the relative scaling of the latent variables and their coefficients.
If <code>alpha = 0.5</code>, the latent variables and their coefficients are on the same scale.
For details for constructing a biplot, see Gabriel (1971).
</p>
<p>For a quadratic response model, species optima are plotted. Any species scores that are outside the range 
of the predicted site scores are not directly plotted, but their main direction is indicated with arrows instead.
This ensures that the plot remains on a reasonable scale.
</p>
<p>Effects of environmental variables in constrained ordination are indicated with arrows.
If any of the arrows exceeds the range of the plot, arrows are scaled to 80
but so that the relative contribution of predictors is maintained.
If standard errors are available in the provided model, the slopes of environmental variables
for which the 95
are slightly less intensely coloured.
</p>
<p>For constrained ordination, a conditional plot includes both fixed- and random-effects to 
optimally represent species co-occurrence patterns, corresponding to &quot;conditional&quot; site scores in <code><a href="#topic+getLV.gllvm">getLV.gllvm</a></code>.
Marginal corresponds to an ordination plot that excludes residual patterns (i.e. excluding the random-effect),
so that it is only available with num.lv.c&gt;0 or num.RR&gt;0. A conditional plot requires num.lv.c&gt;0. 
The &quot;residual&quot; type corresponds to an ordination diagram of only residual patterns. 
See <a href="#topic+getLV.gllvm">getLV.gllvm</a> for details.
</p>


<h3>Note</h3>

<p>- If error is occurred when using <code>ordiplot()</code>, try full name of the function <code>ordiplot.gllvm()</code> as functions named 'ordiplot' might be found in other packages as well.
</p>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;, Francis K.C. Hui, Bert van der Veen
</p>


<h3>References</h3>

<p>Gabriel, K. R. (1971). The biplot graphic display of matrices with application to principal component analysis. Biometrika, 58, 453-467.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLV.gllvm">getLV.gllvm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#'# Extract subset of the microbial data to be used as an example
data(microbialdata)
y &lt;- microbialdata$Y[, order(colMeans(microbialdata$Y &gt; 0), 
                     decreasing = TRUE)[21:40]]
fit &lt;- gllvm(y, family = poisson())
fit$logL
ordiplot(fit, predict.region = TRUE)
## Not run: 
#'## Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
fit &lt;- gllvm(y, family = poisson())
# Ordination plot:
ordiplot(fit)
# Biplot with 10 species
ordiplot(fit, biplot = TRUE, ind.spp = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='phyloplot.gllvm'>Plot phylogenetic random effects from gllvm</h2><span id='topic+phyloplot.gllvm'></span><span id='topic+phyloplot'></span>

<h3>Description</h3>

<p>Plots phylogenetic random effects with the phylogeny, and community effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
phyloplot(
  object,
  tree,
  comm.eff = TRUE,
  row.eff = FALSE,
  which.Xcoef = NULL,
  xlim = NULL,
  level = 0.95,
  col = c("#E69F00", "white", "#009E73"),
  col.sym = TRUE,
  mar.spec = c(3, 2, 0, 0),
  mar.phy = c(0, 2, 2, 0),
  mar.comm = c(3, 0.5, 2, 1.5),
  cex = 0.6,
  lwd = 1,
  col.edge = "black",
  pch = "x",
  heights = c(0.55, 0.35),
  widths = c(0.64, 0.1),
  phy.place = "top",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phyloplot.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_tree">tree</code></td>
<td>
<p>an object of class &rdquo;</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_comm.eff">comm.eff</code></td>
<td>
<p>logical, defaults to <code>TRUE</code>. If present in the model, should community effects be plotted?</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_row.eff">row.eff</code></td>
<td>
<p>logical, defaults to <code>FALSE</code>. If present in the model, should row effects (e.g., community responses to covariates) be included?</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_which.xcoef">which.Xcoef</code></td>
<td>
<p>List of length 2 with names to subset the effects to plot. The first vector is for the species plot, the second for community effects.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_xlim">xlim</code></td>
<td>
<p>vector of length two. Limits for the x-axis of the caterpillar plot. Defaults to NULL, in which case the limits are chosen based on the confidence intervals.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_level">level</code></td>
<td>
<p>the confidence level. Scalar between 0 and 1.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_col">col</code></td>
<td>
<p>vector of three colors (defaults to <code>c("#E69F00","white","#009E73")</code>) passed to <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code> for species random effects.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_col.sym">col.sym</code></td>
<td>
<p>logical, defaults to <code>TRUE</code>. Then, the color scale of the species random effects plot is symmetrical (so that zero is nearly in the middle), so that both the lower and upper limit are determined by the largest absolute value. If <code>FALSE</code>, the lower and upper limits are determined by the smallest and largest values, respectively.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_mar.spec">mar.spec</code></td>
<td>
<p>vector of length 4, which defines the margins sizes for the species random effects plot. Defaults to <code>c(3, 2, 0, 0)</code>.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_mar.phy">mar.phy</code></td>
<td>
<p>vector of length 4, which defines the margins sizes for plotting the phylogeny. Defaults to <code>c(0, 2, 2, 0)</code>.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_mar.comm">mar.comm</code></td>
<td>
<p>vector of length 4, which defines the margins sizes for the caterpillar plot. Defaults to <code>c(3, 0.5, 2, 1.5)</code>.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_cex">cex</code></td>
<td>
<p>the magnification to be used for text in the plot. Defaults to 0.6.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_lwd">lwd</code></td>
<td>
<p>line thickness for the branches in the phylogeny and the confidence intervals in the caterpillar plot. Defaults to 1.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_col.edge">col.edge</code></td>
<td>
<p>character. Color of branches in the phylogeny.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_pch">pch</code></td>
<td>
<p>symbol used in the catter pillar plot. Defaults to &quot;x&quot;.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_heights">heights</code></td>
<td>
<p>vector of length two. Relative row heights, defaults to <code>c(0.55, 0.35)</code>.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_widths">widths</code></td>
<td>
<p>vector of length two. Relative column widths, defaults to <code>c(0.64, 0.10)</code>.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_phy.place">phy.place</code></td>
<td>
<p>not (yet) in use.</p>
</td></tr>
<tr><td><code id="phyloplot.gllvm_+3A_...">...</code></td>
<td>
<p>additional not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots phylogenetically structured random effects together with the phylogeny,
and with community-level effects (i.e., effects that are the same across species).
If standard errors have been calculated for the model, the prediction intervals for
species random effects are checked, and crossed out (i.e., displayed as white) if
they cross zero.
</p>


<h3>Author(s)</h3>

<p>Bert van der Veen
</p>


<h3>References</h3>

<p>van der Veen, B., O'Hara, R.B. (2024). Fast fitting of Fast fitting of phylogenetic mixed effects models. arXiv.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load dataset
data(fungi)
Y &lt;- fungi$Y
# Scale the predictor
X &lt;- fungi$X
X[,"DBH.CM"] &lt;- scale(X[, "DBH.CM"])
tree &lt;- fungi$tree # the tree
colMat &lt;- fungi$C # e.g., from ape::vcv(tree)
dist &lt;- fungi$dist # e.g., from ape::cophenetic.phylo(tree)
order &lt;- gllvm:::findOrder(covMat = colMat, distMat = dist, nn = 15,
                           order = order(dist[1:length(tree$tip.label), nrow(dist)],
                           decreasing = TRUE))$order
order &lt;- tree$tip.label[order]
model &lt;- gllvm(y = Y[,order], X = X,
                formula = ~(DBH.CM|1), beta0com = TRUE,
                family = "binomial", num.lv = 0, nn.colMat = 15,
                colMat = list(colMat[order,order], dist = dist[order,order]), 
                colMat.rho.struct = "term")
phyloplot(model, tree)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.gllvm'>Plot Diagnostics for an gllvm Object</h2><span id='topic+plot.gllvm'></span>

<h3>Description</h3>

<p>Five plots (selectable by which) are currently available: a plot of residuals against
linear predictors of fitted values, a Normal Q-Q plot of residuals with a simulated point-wise 95% confidence interval envelope, residuals against row index and column index and scale location plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
plot(
  x,
  which = 1:5,
  caption = c("Residuals vs linear predictors", "Normal Q-Q", "Residuals vs row",
    "Residuals vs column", "Scale-Location"),
  var.colors = NULL,
  add.smooth = TRUE,
  envelopes = TRUE,
  reps = 150,
  envelope.col = c("blue", "lightblue"),
  n.plot = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gllvm_+3A_x">x</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_which">which</code></td>
<td>
<p>if a subset of the plots is required, specify a subset of the numbers 1:5, see caption below.</p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_caption">caption</code></td>
<td>
<p>captions to appear above the plots.</p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_var.colors">var.colors</code></td>
<td>
<p>colors for responses, vector with length of number of response variables or 1. Defaults to NULL, when different responses have different colors.</p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_add.smooth">add.smooth</code></td>
<td>
<p>logical with default <code>TRUE</code>. Indicates if a smoother should be added.</p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_envelopes">envelopes</code></td>
<td>
<p>logical, indicating if simulated point-wise confidence interval envelope will be added to Q-Q plot, defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_reps">reps</code></td>
<td>
<p>number of replications when simulating confidence envelopes for normal Q-Q plot</p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_envelope.col">envelope.col</code></td>
<td>
<p>colors for envelopes, vector with length of two</p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_n.plot">n.plot</code></td>
<td>
<p>number of species (response variables) to be plotted. Defaults to <code>NULL</code> when all response variables are plotted. Might be useful when data is very high dimensional.</p>
</td></tr>
<tr><td><code id="plot.gllvm_+3A_...">...</code></td>
<td>
<p>additional graphical arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot.gllvm is used for model diagnostics. Dunn-Smyth residuals (randomized quantile residuals) (Dunn and Smyth, 1996) are used in plots. Colors indicate different species.
</p>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;
</p>


<h3>References</h3>

<p>Dunn, P. K., and Smyth, G. K. (1996). Randomized quantile residuals. Journal of Computational and Graphical Statistics, 5, 236-244.
</p>
<p>Hui, F. K. C., Taskinen, S., Pledger, S., Foster, S. D., and Warton, D. I. (2015).  Model-based approaches to unconstrained ordination. Methods in Ecology and Evolution, 6:399-411.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gllvm">gllvm</a></code>, <code><a href="#topic+residuals.gllvm">residuals.gllvm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Fit gllvm model with Poisson family
data(microbialdata)
X &lt;- microbialdata$Xenv
y &lt;- microbialdata$Y[, order(colMeans(microbialdata$Y &gt; 0), 
                     decreasing = TRUE)[21:40]]
fit &lt;- gllvm(y, X, formula = ~ pH + Phosp, family = poisson())
# Plot residuals
plot(fit, mfrow = c(3,2))


## End(Not run)
</code></pre>

<hr>
<h2 id='predict.gllvm'>Predict Method for gllvm Fits</h2><span id='topic+predict.gllvm'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>Obtains predictions from a fitted generalized linear latent variable model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
predict(
  object,
  newX = NULL,
  newTR = NULL,
  newLV = NULL,
  type = "link",
  level = 1,
  offset = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="predict.gllvm_+3A_newx">newX</code></td>
<td>
<p>A new data frame of environmental variables. If omitted, the original matrix of environmental variables is used.</p>
</td></tr>
<tr><td><code id="predict.gllvm_+3A_newtr">newTR</code></td>
<td>
<p>A new data frame of traits for each response taxon. If omitted, the original matrix of traits is used.</p>
</td></tr>
<tr><td><code id="predict.gllvm_+3A_newlv">newLV</code></td>
<td>
<p>A new matrix of latent variables.  If omitted, the original matrix of latent variables is used. Note that number of rows/sites must be the same for <code>newX</code> (if X covariates are included in the model).</p>
</td></tr>
<tr><td><code id="predict.gllvm_+3A_type">type</code></td>
<td>
<p>the type of prediction required. The default (<code>"link"</code>) is on the scale of the linear predictors; the alternative <code>"response"</code> is on the scale of the response variable. that is, the predictions for the binomial model are predicted probabilities. In case of ordinal data, <code>type = "response"</code> gives predicted probabilities for each level of ordinal variable.</p>
</td></tr>
<tr><td><code id="predict.gllvm_+3A_level">level</code></td>
<td>
<p>specification for how to predict. Level one (<code>level = 1</code>) attempts to use the predicted site scores from variational approximations or laplace approximation or given site scores in <code>newLV</code>. Level 0 sets the latent variable to zero. Defaults to 1.</p>
</td></tr>
<tr><td><code id="predict.gllvm_+3A_offset">offset</code></td>
<td>
<p>specification whether of not offset values are included to the predictions in case they are in the model, defaults to <code>TRUE</code> when offset values that are used to fit the model are included to the predictions. Alternatives are matrix/vector (number of rows must match with the <code>newX</code>) of new offset values or <code>FALSE</code>, when offsets are ignored.</p>
</td></tr>
<tr><td><code id="predict.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newX</code>, <code>newTR</code> and <code>newLV</code> are omitted the predictions are based on the data used for fitting the model. Notice that <code>newTR</code> need to match with the number of species in the original data.
Instead, new sites can be specified in <code>newX</code>. If predictors <code>newX</code> (and <code>newTR</code>) are given, and <code>newLV</code> is not, latent variables are not used in the predictions.
</p>


<h3>Value</h3>

<p>A matrix containing requested predictor types.
</p>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;,  David Warton
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
X &lt;- scale(antTraits$env[, 1:3])
# Fit gllvm model
fit &lt;- gllvm(y = y, X, family = poisson())
# fitted values
predfit &lt;- predict(fit, type = "response")

# linear predictors
predlin &lt;- predict(fit)
# Predict new sites:
# Generate matrix of environmental variables for 10 new sites
xnew &lt;- cbind(rnorm(10), rnorm(10), rnorm(10))
colnames(xnew) &lt;- colnames(X)
predfit &lt;- predict(fit, newX = xnew, type = "response", level = 0)

TR &lt;- (antTraits$tr[, 1:3])
fitt &lt;- gllvm(y = y, X, TR, family = poisson())
# linear predictors
predlin &lt;- predict(fitt)
# Predict new sites:
# Generate matrix of environmental variables for 10 new sites
xnew &lt;- cbind(rnorm(10), rnorm(10), rnorm(10))
colnames(xnew) &lt;- colnames(X)
# Generate matrix of traits for species
trnew &lt;- data.frame(Femur.length = rnorm(41), No.spines = rnorm(41),
 Pilosity = factor(sample(0:3, 41, replace = TRUE)))
predfit &lt;- predict(fitt, newX = xnew, newTR = trnew, type = "response", level = 0)

</code></pre>

<hr>
<h2 id='predictLVs.gllvm'>Predict latent variables for gllvm Fits</h2><span id='topic+predictLVs.gllvm'></span><span id='topic+predictLVs'></span>

<h3>Description</h3>

<p>Obtains predictions for latent variables from a fitted generalized linear latent variable model object. Currently works only for the variational approximation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
predictLVs(object, newX = NULL, newY = object$y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictLVs.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="predictLVs.gllvm_+3A_newx">newX</code></td>
<td>
<p>A new data frame of environmental variables. If omitted, the original matrix of environmental variables is used.</p>
</td></tr>
<tr><td><code id="predictLVs.gllvm_+3A_newy">newY</code></td>
<td>
<p>A new response data. Defaults to the dataset used for original model fit.</p>
</td></tr>
<tr><td><code id="predictLVs.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obtains predictions for latent variables from a fitted generalized linear latent variable model object.
</p>


<h3>Value</h3>

<p>A matrix containing requested predictor types.
</p>


<h3>Author(s)</h3>

<p>David Warton, Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
X &lt;- scale(antTraits$env[, 1:3])
# Fit gllvm model
fit &lt;- gllvm(y = y, X, family = poisson())
# fitted values
predLVs &lt;- predictLVs.gllvm(fit)

</code></pre>

<hr>
<h2 id='randomCoefplot.gllvm'>Plot random slope coefficients</h2><span id='topic+randomCoefplot.gllvm'></span><span id='topic+randomCoefplot'></span>

<h3>Description</h3>

<p>Plots random slopes and their prediction intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
randomCoefplot(
  object,
  y.label = TRUE,
  which.Xcoef = NULL,
  cex.ylab = 0.5,
  mfrow = NULL,
  mar = c(4, 6, 2, 1),
  xlim.list = NULL,
  order = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomCoefplot.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="randomCoefplot.gllvm_+3A_y.label">y.label</code></td>
<td>
<p>logical, if <code>TRUE</code> (default) colnames of y with respect to coefficients are added to plot.</p>
</td></tr>
<tr><td><code id="randomCoefplot.gllvm_+3A_which.xcoef">which.Xcoef</code></td>
<td>
<p>fector indicating which covariate coefficients will be plotted. Can be vector of covariate names or numbers. Default is NULL when all covariate coefficients are plotted.</p>
</td></tr>
<tr><td><code id="randomCoefplot.gllvm_+3A_cex.ylab">cex.ylab</code></td>
<td>
<p>the magnification to be used for axis annotation relative to the current setting of cex.</p>
</td></tr>
<tr><td><code id="randomCoefplot.gllvm_+3A_mfrow">mfrow</code></td>
<td>
<p>same as <code>mfrow</code> in <code>par</code>. If <code>NULL</code> (default) it is determined automatically.</p>
</td></tr>
<tr><td><code id="randomCoefplot.gllvm_+3A_mar">mar</code></td>
<td>
<p>vector of length 4, which defines the margin sizes: <code>c(bottom, left, top, right)</code>. Defaults to <code>c(4,5,2,1)</code>.</p>
</td></tr>
<tr><td><code id="randomCoefplot.gllvm_+3A_xlim.list">xlim.list</code></td>
<td>
<p>list of vectors with length of two to define the intervals for x axis in each covariate plot. Defaults to NULL when the interval is defined by the range of point estimates and confidence intervals</p>
</td></tr>
<tr><td><code id="randomCoefplot.gllvm_+3A_order">order</code></td>
<td>
<p>logical, if <code>TRUE</code> (default), coefficients are sorted according to the point estimates</p>
</td></tr>
<tr><td><code id="randomCoefplot.gllvm_+3A_...">...</code></td>
<td>
<p>additional graphical arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;, Francis K.C. Hui, Bert van der Veen, Sara Taskinen,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
X &lt;- as.matrix(antTraits$env)
TR &lt;- antTraits$traits
# Fit model with random slopes
fitF &lt;- gllvm(y = y, X = X, TR = TR,
 formula = ~ Bare.ground + Bare.ground : Webers.length,
 family = poisson(), randomX = ~ Bare.ground)
randomCoefplot(fitF)

## End(Not run)

</code></pre>

<hr>
<h2 id='residuals.gllvm'>Dunn-Smyth residuals for gllvm model</h2><span id='topic+residuals.gllvm'></span>

<h3>Description</h3>

<p>Calculates Dunn-Smyth residuals for gllvm model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="residuals.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes Dunn-Smyth residuals (randomized quantile residuals, Dunn and Smyth, 1996) for gllvm model.
For the observation <code class="reqn">Y_{ij}</code> Dunn-Smyth residuals are defined as
</p>
<p style="text-align: center;"><code class="reqn">r_{ij}=\Phi^{-1}(u_{ij}F_{ij}(y_{ij})  + (1-u_{ij})F_{ij}^-(y_{ij})),</code>
</p>

<p>where <code class="reqn">\Phi(.)</code> and <code class="reqn">F_{ij}(.)</code> are the cumulative probability functions of the standard normal
distribution, <code class="reqn">F_{ij}^-(y))</code> is the limit as <code class="reqn">F_{ij}(y)</code> is approached from the negative side, and <code class="reqn">u_{ij}</code> has been
generated at random from the standard uniform distribution.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>matrix of residuals</p>
</td></tr>
<tr><td><code>linpred</code></td>
<td>
<p>matrix of linear predictors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;
</p>


<h3>References</h3>

<p>Dunn, P. K., and Smyth, G. K. (1996). Randomized quantile residuals. Journal of Computational and Graphical Statistics, 5, 236-244.
</p>
<p>Hui, F. K. C., Taskinen, S., Pledger, S., Foster, S. D., and Warton, D. I. (2015).  Model-based approaches to unconstrained ordination. Methods in Ecology and Evolution, 6:399-411.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
# Fit gllvm model
fit &lt;- gllvm(y = y, family = poisson())
# residuals
res &lt;- residuals(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='se.gllvm'>Standard errors for gllvm model</h2><span id='topic+se.gllvm'></span><span id='topic+se'></span>

<h3>Description</h3>

<p>Calculates Hessian and standard errors for gllvm model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
se(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="se.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="se.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes Hessian and standard errors for gllvm model.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sd</code></td>
<td>
<p> list of standard errors of parameters</p>
</td></tr>
<tr><td><code>Hess</code></td>
<td>
<p> list including Hessian matrix and approximative covariance matrix of parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;
</p>


<h3>References</h3>

<p>Dunn, P. K., and Smyth, G. K. (1996). Randomized quantile residuals. Journal of Computational and Graphical Statistics, 5, 236-244.
</p>
<p>Hui, F. K. C., Taskinen, S., Pledger, S., Foster, S. D., and Warton, D. I. (2015).  Model-based approaches to unconstrained ordination. Methods in Ecology and Evolution, 6:399-411.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eSpider)
mod &lt;- gllvm(eSpider$abund, num.lv = 2, family = "poisson", sd.errors = FALSE)
# Calculate standard errors after fitting
sdErr &lt;- se(mod)
# Store the standard errors in the right place
mod$sd &lt;-sdErr$sd
# Store the Hessian in the right place
mod$Hess &lt;- sdErr$Hess
</code></pre>

<hr>
<h2 id='simulate.gllvm'>Simulate data from gllvm fit</h2><span id='topic+simulate.gllvm'></span><span id='topic+simulate'></span>

<h3>Description</h3>

<p>Generate new data using the fitted values of the parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
simulate(object, nsim = 1, seed = NULL, conditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="simulate.gllvm_+3A_nsim">nsim</code></td>
<td>
<p>an optional positive integer specifying the number of simulated datasets. Defaults to 1.</p>
</td></tr>
<tr><td><code id="simulate.gllvm_+3A_seed">seed</code></td>
<td>
<p>an optional integer to set seed number, passed to set.seed. Defaults to a random seed number.</p>
</td></tr>
<tr><td><code id="simulate.gllvm_+3A_conditional">conditional</code></td>
<td>
<p>if <code>conditional = FALSE</code> simulates marginally over the latent variables.</p>
</td></tr>
<tr><td><code id="simulate.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>simulate function for gllvm objects.
</p>


<h3>Value</h3>

<p>A matrix containing generated data.
</p>


<h3>Author(s)</h3>

<p>David Warton, Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
X &lt;- scale(antTraits$env[, 1:3])
# Fit gllvm model
fit &lt;- gllvm(y = y, X, family = poisson())
# Simulate data
newdata &lt;- simulate(fit)

</code></pre>

<hr>
<h2 id='Skabbholmen'>Skabbholmen island data</h2><span id='topic+Skabbholmen'></span>

<h3>Description</h3>

<p>Dataset of ordinal observations of plants, on the island Skabbholmen in the Stocholm archipelago. Includes 65 unique sites and 70 species, surveyed in two different years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Skabbholmen)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Y</dt><dd><p>A data frame with ordinal of 70 plant species measured at 126 plots.</p>
</dd>
<dt>X</dt><dd><p>A matrix of 2 predictor variables at 126 plots.</p>
</dd>
<dt>species</dt><dd><p>A matrix of full species names and abbreviations used in the community data (Y).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Observations of vascular plant cover in 126 one-square-meter plots divided over four transects. The ordinal responses are on a five-degree Hult-Sernander-Du Rietz scale, and were originally recorded by Wolfgang and Cramer (1987) and additionally analyzed by ter Braak (1987). There is a total of 64 unique sites, that were surveyed in two different years (1978 and 1984), but two plots were only surveyed in one year (thus bringing the total number of rows in the data to 126). The plots were located on an elevation gradient, running from the shoreline to the edge of old-growth forest. Elevation to the shoreline was recorded in centimeters during the sampling in 1978.
</p>
<p>This dataset was published with permission from the CANOCO FORTRAN package example datasets.
</p>


<h3>References</h3>

<p>ter Braak, C.J.F. and Smilauer, P.  (1998).  CANOCO reference manual and user's guide to CANOCO for Windows: software for canonical community ordination (version 4). Microcomputer Power, New York, New York, USA.
</p>
<p>Jongman, E., &amp; Jongman, S. R. R. (1995). Data analysis in community and landscape ecology. Cambridge university press.
</p>
<p>ter Braak, C.J.F. (1987). The analysis of vegetation-environment relationships by canonical correspondence analysis. Vegetatio, 69(1), 69-77.
</p>
<p>Cramer, W. &amp; Hytteborn, H. (1987). The separation of fluctuation and long-term change in vegetation dynamics of a rising seashore. Vegetatio, 69, 157–167.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Uncomment the example
#data(Skabbholmen)
#Y &lt;- Skabbholmen$Y
#X &lt;- Skabbholmen$X
#model &lt;- gllvm(y = Y, X = X, 
#    num.RR = 2, 
#    family = "ordinal",
#    zeta.struc="common",
#    row.eff=~(1|transectID))
</code></pre>

<hr>
<h2 id='summary.gllvm'>Summarizing gllvm model fits</h2><span id='topic+summary.gllvm'></span><span id='topic+print.summary.gllvm'></span><span id='topic+plot.summary.gllvm'></span>

<h3>Description</h3>

<p>A summary of the fitted 'gllvm' object, including function call, distribution family and model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
summary(
  object,
  by = "all",
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  dispersion = FALSE,
  spp.intercepts = FALSE,
  row.intercepts = FALSE,
  Lvcoefs = FALSE,
  rotate = TRUE,
  type = NULL,
  ...
)

## S3 method for class 'summary.gllvm'
print(x, ...)

## S3 method for class 'summary.gllvm'
plot(x, component = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'</p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_by">by</code></td>
<td>
<p>By = &quot;all&quot; (default) will return a Wald statistics per predictor and LV if the ordination includes predictors, by = &quot;terms&quot; will return a multivariate Wald statistic per predictor (displayed at first LV), and by = &quot;LV&quot; will do the same but per dimension (displayed at first predictors).</p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing</p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>If <code>TRUE</code>, significance stars are printed for each coefficient, defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_dispersion">dispersion</code></td>
<td>
<p>option to return dispersion parameters, defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_spp.intercepts">spp.intercepts</code></td>
<td>
<p>option to return species intercepts, defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_row.intercepts">row.intercepts</code></td>
<td>
<p>option to return row intercepts, defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_lvcoefs">Lvcoefs</code></td>
<td>
<p>option to return species scores in the ordination, defaults to <code>FALSE</code>. Returns species optima for quadratic model.</p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_rotate">rotate</code></td>
<td>
<p>defaults to <code>TRUE</code>. If <code>TRUE</code> rotates the output of the latent variables to principal direction, so that it coincides with the ordiplot results. If both unconstrained and constrained latent variables are included, predictor slopes are not rotated.</p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_type">type</code></td>
<td>
<p>to match &quot;type&quot; in <code><a href="#topic+ordiplot.gllvm">ordiplot.gllvm</a></code></p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_x">x</code></td>
<td>
<p>a summary object</p>
</td></tr>
<tr><td><code id="summary.gllvm_+3A_component">component</code></td>
<td>
<p>component to be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Various options are available to include extra parameter estimates in the summary, which have been excluded by default, for readability.
</p>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;, Bert van der Veen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load a dataset from the mvabund package
data(antTraits, package = "mvabund")
y &lt;- as.matrix(antTraits$abund)
# Fit gllvm model
fit &lt;- gllvm(y = y, family = poisson())
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='varPartitioning.gllvm'>Calculate variance partitioning</h2><span id='topic+varPartitioning.gllvm'></span><span id='topic+varPartitioning'></span><span id='topic+VP'></span><span id='topic+plotVarPartitioning'></span><span id='topic+plotVP'></span>

<h3>Description</h3>

<p>Calculates variance partitioning for gllvm object with function <code>varPartitioning()</code>.
</p>
<p>Function <code>plotVarPartitioning()</code> (alias <code>plotVP()</code>) plots the results of variance partitioning of a fitted gllvm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
varPartitioning(
  object,
  group = NULL,
  groupnames = NULL,
  adj.cov = TRUE,
  grouplvs = FALSE,
  ...
)

plotVarPartitioning(
  VP,
  main = "Variance Partitioning",
  xlab = "Response",
  ylab = "Variance proportion",
  legend.text = NULL,
  args.legend = list(cex = 0.7, x = "topright", bty = "n", inset = c(0, -0.15)),
  mar = c(4, 4, 6, 2),
  ...
)

plotVP(VP, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varPartitioning.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_group">group</code></td>
<td>
<p>a vector of integers identifying grouping of X covariates, the default is to use model terms formula and lv.formula.</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_groupnames">groupnames</code></td>
<td>
<p>a vector of strings given as names for the groups defined in group</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_adj.cov">adj.cov</code></td>
<td>
<p>logical, whether or not to adjust co-variation within the group</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_grouplvs">grouplvs</code></td>
<td>
<p>logical, whether or not to group latent variables to one group</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_...">...</code></td>
<td>
<p>additional graphical arguments passed to the barplot function</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_vp">VP</code></td>
<td>
<p>a variance partitioning object for a gllvm produced by function varPartitioning.</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_main">main</code></td>
<td>
<p>main title</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_legend.text">legend.text</code></td>
<td>
<p>a vector of names for the groups, as a default 'groupnames' from varPartitioning. If FALSE, legend not printed.</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_args.legend">args.legend</code></td>
<td>
<p>a list of additional arguments to pass to <code>legend()</code>.</p>
</td></tr>
<tr><td><code id="varPartitioning.gllvm_+3A_mar">mar</code></td>
<td>
<p>Margins of the plot. Default <code>c(4,4,6,2)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variance for the linear predictor for response j can be calculated as 
</p>
<p style="text-align: center;"><code class="reqn">Var(\eta_j) = \sum_k \beta_{jk}^2*var(z_{.k}) + 2 \sum_{(k1=1,...,K-1)} \sum_{(k2=k1+1,...,K)}  \beta_{j(k1)}\beta_{j(k2)} Cov(Z_{.k1},Z_{.k2}) , </code>
</p>

<p>where <code class="reqn">z_{.k}</code> is a vector consisting of predictor/latent variable/row effect etc values for all sampling units i.
If <code class="reqn">z_{.k}</code>s are not correlated, covariance term is 0 and thus the variance explained of a response j for predictor <code class="reqn">z_{.k}</code> is given as <code class="reqn">\beta_{jk}^2*var(z_{.k})/Var(\eta_j)</code>.
</p>
<p>In case of correlated predictors, it is advised to group them into a same group. The variance explained is calculated for the correlated group of predictors together and adjusted with the covariance term.
</p>


<h3>Author(s)</h3>

<p>Jenni Niku &lt;jenni.m.e.niku@jyu.fi&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extract subset of the microbial data to be used as an example
data(microbialdata)
X &lt;- microbialdata$Xenv
y &lt;- microbialdata$Y[, order(colMeans(microbialdata$Y &gt; 0), 
                     decreasing = TRUE)[21:40]]
fit &lt;- gllvm(y, X[,1:3], formula = ~ pH + Phosp, family = poisson(), 
             studyDesign = X[,4:5], row.eff = ~(1|Site))
VP &lt;- varPartitioning(fit)
plotVarPartitioning(VP)

## Not run: 
# Plot the result of  variance partitioning
plotVP(VP, col = palette(hcl.colors(5, "Roma")))


## End(Not run)

</code></pre>

<hr>
<h2 id='vcov.gllvm'>Returns variance-covariance matrix of coefficients in a GLLVM.</h2><span id='topic+vcov.gllvm'></span><span id='topic+vcov'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the parameters from a GLLVM. If the variance-covariance matrix was not calculated after model fitting, this function will have to calculate the variance-covariance matrix, which may be computational intensive for a large number of species and/or sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllvm'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.gllvm_+3A_object">object</code></td>
<td>
<p>an object of class 'gllvm'.</p>
</td></tr>
<tr><td><code id="vcov.gllvm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the variance-covariance matrix of a GLLVM object using <code><a href="#topic+se.gllvm">se.gllvm</a></code>, which may be computational intensive with many parameters.The parameters might have unintuitive names. Fixed-effects coefficients are labeled &quot;b&quot;, and are ordered per species as: 1) intercepts 2) fixed-effects slopes. Coefficients of the latent variables are labled &quot;lambda&quot; (linear coefficients) or &quot;lambda2&quot;.
</p>


<h3>Author(s)</h3>

<p>Bert van der Veen
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
