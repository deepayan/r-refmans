<!DOCTYPE html><html><head><title>Help for package DrDimont</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DrDimont}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#calculate_interaction_score'><p>[INTERNAL] Calls a python script to calculate interaction score for combined graphs</p></a></li>
<li><a href='#check_connection'><p>[INTERNAL] Check connection</p></a></li>
<li><a href='#check_drug_target'><p>[INTERNAL] Check drug target interaction data</p></a></li>
<li><a href='#check_drug_targets_in_layers'><p>[INTERNAL] Check drug target and layer data</p></a></li>
<li><a href='#check_input'><p>Check pipeline input data for required format</p></a></li>
<li><a href='#check_layer'><p>[INTERNAL] Check layer input</p></a></li>
<li><a href='#check_sensible_connections'><p>[INTERNAL] Check connection and layer data</p></a></li>
<li><a href='#chunk'><p>[INTERNAL] Create chunks from a vector for parallel computing</p></a></li>
<li><a href='#chunk_2gether'><p>[INTERNAL] Create chunks from two vectors for parallel computing</p></a></li>
<li><a href='#combine_graphs'><p>[INTERNAL] Combine graphs by adding inter-layer edges</p></a></li>
<li><a href='#combined_graphs_example'><p>Combined graphs</p></a></li>
<li><a href='#compute_correlation_matrices'><p>Computes correlation matrices for specified network layers</p></a></li>
<li><a href='#compute_drug_response_scores'><p>Calculate drug response score</p></a></li>
<li><a href='#corPvalueStudentParallel'><p>[INTERNAL] Compute p-values for upper triangle of correlation matrix in parallel</p></a></li>
<li><a href='#correlation_matrices_example'><p>Correlation matrices</p></a></li>
<li><a href='#create_unique_layer_node_ids'><p>[INTERNAL] Assign node IDs to the biological identifiers across a graph layer</p></a></li>
<li><a href='#determine_drug_targets'><p>Determine drug target nodes in network</p></a></li>
<li><a href='#differential_graph_example'><p>Differential graph</p></a></li>
<li><a href='#drdimont_settings'><p>Create global settings variable for DrDimont pipeline</p></a></li>
<li><a href='#drug_gene_interactions'><p>Drug-gene interactions</p></a></li>
<li><a href='#drug_response_scores_example'><p>Drug response score</p></a></li>
<li><a href='#drug_target_edges_example'><p>Drug target nodes in combined network</p></a></li>
<li><a href='#find_targets'><p>[INTERNAL] Filter drug target nodes</p></a></li>
<li><a href='#generate_combined_graphs'><p>Combines individual layers to a single graph</p></a></li>
<li><a href='#generate_differential_score_graph'><p>Compute difference of interaction score of two groups</p></a></li>
<li><a href='#generate_individual_graphs'><p>Builds graphs from specified network layers</p></a></li>
<li><a href='#generate_interaction_score_graphs'><p>Computes interaction score for combined graphs</p></a></li>
<li><a href='#generate_reduced_graph'><p>[INERNAL] Generate a reduced iGraph from adjacency matrices</p></a></li>
<li><a href='#get_layer'><p>[INTERNAL] Fetch layer by name from layer object</p></a></li>
<li><a href='#get_layer_setting'><p>[INTERNAL] Get layer (and group) settings</p></a></li>
<li><a href='#graph_metrics'><p>[INTERNAL] Analysis of metrics of an iGraph object</p></a></li>
<li><a href='#individual_graphs_example'><p>Individual graphs</p></a></li>
<li><a href='#install_python_dependencies'><p>Installs python dependencies needed for interaction score computation</p></a></li>
<li><a href='#inter_layer_edgelist_by_id'><p>[INTERNAL] Inter layer connections by identifiers</p></a></li>
<li><a href='#inter_layer_edgelist_by_table'><p>[INTERNAL] Interaction table to iGraph graph object</p></a></li>
<li><a href='#interaction_score_graphs_example'><p>Interaction score graphs</p></a></li>
<li><a href='#layers_example'><p>Formatted layers object</p></a></li>
<li><a href='#load_interaction_score_output'><p>[INTERNAL] Loads output of python script for interaction score calculation</p></a></li>
<li><a href='#make_connection'><p>Specify connection between two individual layers</p></a></li>
<li><a href='#make_drug_target'><p>Reformat drug-target-interaction data</p></a></li>
<li><a href='#make_layer'><p>Creates individual molecular layers from raw data and unique identifiers</p></a></li>
<li><a href='#metabolite_data'><p>Metabolomics data</p></a></li>
<li><a href='#metabolite_protein_interactions'><p>Metabolite protein interaction data</p></a></li>
<li><a href='#mrna_data'><p>mRNA expression data</p></a></li>
<li><a href='#network_reduction_by_p_value'><p>[INTERNAL] Reduce the the entries in an adjacency matrix by thresholding on p-values</p></a></li>
<li><a href='#network_reduction_by_pickHardThreshold'><p>[INTERNAL] Reduces network based on WGCNA::pickHardThreshold function</p></a></li>
<li><a href='#phosphosite_data'><p>Phosphosite data</p></a></li>
<li><a href='#protein_data'><p>Protein data</p></a></li>
<li><a href='#return_errors'><p>Return detected errors in the input data</p></a></li>
<li><a href='#run_pipeline'><p>Execute all DrDimont pipeline steps sequentially</p></a></li>
<li><a href='#sample_size'><p>[INTERNAL] Sample size for correlation computation</p></a></li>
<li><a href='#set_cluster'><p>[INTERNAL] Create and register cluster</p></a></li>
<li><a href='#shutdown_cluster'><p>[INTERNAL] Shutdown cluster and remove corresponding connections</p></a></li>
<li><a href='#target_edge_list'><p>[INTERNAL] Get edges adjacent to target nodes</p></a></li>
<li><a href='#write_interaction_score_input'><p>[INTERNAL] Write edge lists and combined graphs to files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Drug Response Prediction from Differential Multi-Omics Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>While it has been well established that drugs affect and help
  patients differently, personalized drug response predictions remain 
  challenging. Solutions based on single omics measurements have been proposed, 
  and networks provide means to incorporate molecular interactions into reasoning. 
  However, how to integrate the wealth of information contained in multiple omics 
  layers still poses a complex problem. 
  We present a novel network analysis pipeline, DrDimont, Drug response prediction 
  from Differential analysis of multi-omics networks. It allows for comparative 
  conclusions between two conditions and translates them into differential drug 
  response predictions. DrDimont focuses on molecular interactions. It establishes 
  condition-specific networks from correlation within an omics layer that are 
  then reduced and combined into heterogeneous, multi-omics molecular networks. 
  A novel semi-local, path-based integration step ensures integrative conclusions. 
  Differential predictions are derived from comparing the condition-specific 
  integrated networks. DrDimont's predictions are explainable, i.e., molecular 
  differences that are the source of high differential drug scores can be retrieved.
  Our proposed pipeline leverages multi-omics data for differential predictions,
  e.g. on drug response, and includes prior information on interactions.
  The case study presented in the vignette uses data published by
  Krug (2020) &lt;<a href="https://doi.org/10.1016%2Fj.cell.2020.10.036">doi:10.1016/j.cell.2020.10.036</a>&gt;. The package license applies only
  to the software and explicitly not to the included data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, dplyr, stringr, WGCNA, Rfast, readr, tibble, tidyr,
magrittr, rlang, utils, stats, reticulate</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-23 14:30:04 UTC; work</td>
</tr>
<tr>
<td>Author:</td>
<td>Katharina Baum <a href="https://orcid.org/0000-0001-7256-0566"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre],
  Pauline Hiort <a href="https://orcid.org/0000-0002-3530-7358"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Julian Hugo <a href="https://orcid.org/0000-0003-3355-1071"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Spoorthi Kashyap <a href="https://orcid.org/0000-0002-5474-8183"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nataniel Müller <a href="https://orcid.org/0000-0002-0275-3992"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Justus Zeinert <a href="https://orcid.org/0000-0003-3918-0507"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Katharina Baum &lt;katharina.baum@hpi.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-23 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>Evaluates and returns the output of the function on the right hand 
side with the left hand side as first argument.
</p>

<hr>
<h2 id='calculate_interaction_score'>[INTERNAL] Calls a python script to calculate interaction score for combined graphs</h2><span id='topic+calculate_interaction_score'></span>

<h3>Description</h3>

<p>[INTERNAL] The interaction score is computed and saved in an additional 'interaction_weight'
edge attribute. This function expects the combined graphs for both groups along with their corresponding drug
target and node lists to be saved at 'saving_path'. Graphs and drug targets should be weighted edge lists
in 'gml' and 'tsv' format, respectively. Node files should contain one node id per line.
The script for calculating the interaction score is called with 'python_executable'. An
alternate script can be specified with 'script_path'.
The score for an edge is computed as the sum of the average product of weights along all simple
paths of length l (over all path lengths up to 'max_path_length') between the source and target node of the edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_interaction_score(
  max_path_length,
  total_edges,
  saving_path,
  conda = FALSE,
  script_path = NULL,
  int_score_mode = "auto",
  cluster_address = "auto",
  graphB_null = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_interaction_score_+3A_max_path_length">max_path_length</code></td>
<td>
<p>[int] Integer of maximum length of simple paths to include in the
<code><a href="#topic+generate_interaction_score_graphs">generate_interaction_score_graphs</a></code> computation. (default: 3)</p>
</td></tr>
<tr><td><code id="calculate_interaction_score_+3A_total_edges">total_edges</code></td>
<td>
<p>Vector with total edges in each group</p>
</td></tr>
<tr><td><code id="calculate_interaction_score_+3A_saving_path">saving_path</code></td>
<td>
<p>[string] Path to save intermediate output of DrDimont's functions.
Default is current working directory. Directory to use for writing intermediate data
when passing input and  output between Python and R.</p>
</td></tr>
<tr><td><code id="calculate_interaction_score_+3A_conda">conda</code></td>
<td>
<p>[bool] Specifying if python is installed in a conda environment. Set TRUE if python is installed
with conda, else python dependencies are assumed to be installed with pip. (default: FALSE)</p>
</td></tr>
<tr><td><code id="calculate_interaction_score_+3A_script_path">script_path</code></td>
<td>
<p>[string] Path to the interaction score Python script. Set NULL to use package
internal script (default).</p>
</td></tr>
<tr><td><code id="calculate_interaction_score_+3A_int_score_mode">int_score_mode</code></td>
<td>
<p>[&quot;auto&quot;|&quot;sequential&quot;|&quot;ray&quot;] Whether to compute interaction
score in parallel using the Ray python library or sequentially. When 'auto' it depends on the
graph sizes. (default: &quot;auto&quot;)</p>
</td></tr>
<tr><td><code id="calculate_interaction_score_+3A_cluster_address">cluster_address</code></td>
<td>
<p>[string] Local node IP-address of Ray if executed on a cluster.
On a cluster: Start ray with <code>ray start --head --num-cpus 32</code> on the console before DrDimont execution.
It should work with &quot;auto&quot;, if it does not specify IP-address given by the <code>ray start</code> command. (default: &quot;auto&quot;)</p>
</td></tr>
<tr><td><code id="calculate_interaction_score_+3A_graphb_null">graphB_null</code></td>
<td>
<p>[bool] Specifying if graphB of 'groupB' is given (FALSE) or not (TRUE). (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does not return anything, instead calls Python script which outputs 'gml' files
</p>

<hr>
<h2 id='check_connection'>[INTERNAL] Check connection</h2><span id='topic+check_connection'></span>

<h3>Description</h3>

<p>[INTERNAL] Checks if the data given to create an inter-layer connection is valid and has the
right input format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_connection(connection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_connection_+3A_connection">connection</code></td>
<td>
<p>[list] Connection to check. Created by <code><a href="#topic+make_connection">make_connection</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string vector containing error messages.
</p>

<hr>
<h2 id='check_drug_target'>[INTERNAL] Check drug target interaction data</h2><span id='topic+check_drug_target'></span>

<h3>Description</h3>

<p>[INTERNAL] Checks if the data used to define interaction between drugs and
targets is valid and formatted correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_drug_target(drug_target_interactions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_drug_target_+3A_drug_target_interactions">drug_target_interactions</code></td>
<td>
<p>[list] A named list of the drug interaction data. Created by
<code><a href="#topic+make_drug_target">make_drug_target</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string vector containing error messages.
</p>

<hr>
<h2 id='check_drug_targets_in_layers'>[INTERNAL] Check drug target and layer data</h2><span id='topic+check_drug_targets_in_layers'></span>

<h3>Description</h3>

<p>[INTERNAL] Checks if the parameters supplied in 'drug_target_interactions' makes
sense in the context of the defined layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_drug_targets_in_layers(drug_target_interactions, layers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_drug_targets_in_layers_+3A_drug_target_interactions">drug_target_interactions</code></td>
<td>
<p>[list] A named list of the drug interaction data. Created by
<code><a href="#topic+make_drug_target">make_drug_target</a></code></p>
</td></tr>
<tr><td><code id="check_drug_targets_in_layers_+3A_layers">layers</code></td>
<td>
<p>[list] List of layers to check. Individual layers are created by
<code><a href="#topic+make_layer">make_layer</a></code> and need to be wrapped in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string vector containing error messages.
</p>

<hr>
<h2 id='check_input'>Check pipeline input data for required format</h2><span id='topic+check_input'></span>

<h3>Description</h3>

<p>Checks if input data is valid and formatted correctly. This function is a
wrapper for other check functions to be executed as first step of the DrDimont pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_input(layers, inter_layer_connections, drug_target_interactions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_input_+3A_layers">layers</code></td>
<td>
<p>[list] List of layers to check. Individual layers were created by
<code><a href="#topic+make_layer">make_layer</a></code> and need to be wrapped in a list.</p>
</td></tr>
<tr><td><code id="check_input_+3A_inter_layer_connections">inter_layer_connections</code></td>
<td>
<p>[list] A list containing connections between layers. Each
connection was created by <code><a href="#topic+make_connection">make_connection</a></code> and wrapped in a list.</p>
</td></tr>
<tr><td><code id="check_input_+3A_drug_target_interactions">drug_target_interactions</code></td>
<td>
<p>[list] A named list of the drug interaction data. Created by
<code><a href="#topic+make_drug_target">make_drug_target</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string vector containing error messages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(layers_example)
data(metabolite_protein_interactions)
data(drug_gene_interactions)
data

all_layers &lt;- layers_example

all_inter_layer_connections = list(
    make_connection(from='mrna', to='protein', connect_on='gene_name', weight=1),
    make_connection(from='protein', to='phosphosite', connect_on='gene_name', weight=1),
    make_connection(from='protein', to='metabolite',
    connect_on=metabolite_protein_interactions, weight='combined_score'))

all_drug_target_interactions &lt;- make_drug_target(
                                    target_molecules="protein",
                                    interaction_table=drug_gene_interactions,
                                    match_on="gene_name")

return_errors(check_input(layers=all_layers,
    inter_layer_connections=all_inter_layer_connections,
    drug_target_interactions=all_drug_target_interactions))

</code></pre>

<hr>
<h2 id='check_layer'>[INTERNAL] Check layer input</h2><span id='topic+check_layer'></span>

<h3>Description</h3>

<p>[INTERNAL] Checks if the data used to create a network layer is valid and has the right
format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_layer(layer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_layer_+3A_layer">layer</code></td>
<td>
<p>[list] Named list of layer to check. Created by <code><a href="#topic+make_layer">make_layer</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string vector containing error messages.
</p>

<hr>
<h2 id='check_sensible_connections'>[INTERNAL] Check connection and layer data</h2><span id='topic+check_sensible_connections'></span>

<h3>Description</h3>

<p>[INTERNAL] Checks if the connection defined in 'connection' makes sense in
context of the defined layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sensible_connections(connection, layers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_sensible_connections_+3A_connection">connection</code></td>
<td>
<p>[list] Connection to check. Created by <code><a href="#topic+make_connection">make_connection</a></code></p>
</td></tr>
<tr><td><code id="check_sensible_connections_+3A_layers">layers</code></td>
<td>
<p>[list] List of layers to check. Individual layers are created by
<code><a href="#topic+make_layer">make_layer</a></code> and need to be wrapped in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string vector containing error messages.
</p>

<hr>
<h2 id='chunk'>[INTERNAL] Create chunks from a vector for parallel computing</h2><span id='topic+chunk'></span>

<h3>Description</h3>

<p>[INTERNAL] Create chunks from a vector for parallel computing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk(x, chunk_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_+3A_x">x</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="chunk_+3A_chunk_size">chunk_size</code></td>
<td>
<p>[int] Length of chunks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of chunks of length chunk_size
</p>


<h3>Source</h3>

<p>https://stackoverflow.com/questions/3318333/split-a-vector-into-chunks
</p>

<hr>
<h2 id='chunk_2gether'>[INTERNAL] Create chunks from two vectors for parallel computing</h2><span id='topic+chunk_2gether'></span>

<h3>Description</h3>

<p>[INTERNAL] Create chunks from two vectors for parallel computing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk_2gether(x, y, chunk_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_2gether_+3A_x">x</code>, <code id="chunk_2gether_+3A_y">y</code></td>
<td>
<p>Vectors</p>
</td></tr>
<tr><td><code id="chunk_2gether_+3A_chunk_size">chunk_size</code></td>
<td>
<p>[int] Length of chunks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists. Each second level list contains a list of chunks of length chunk_size of each
input vector.
</p>


<h3>Source</h3>

<p>modified from: https://stackoverflow.com/questions/3318333/split-a-vector-into-chunks
</p>

<hr>
<h2 id='combine_graphs'>[INTERNAL] Combine graphs by adding inter-layer edges</h2><span id='topic+combine_graphs'></span>

<h3>Description</h3>

<p>[INTERNAL] Creates the union of all graphs and adds the inter-layer edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_graphs(graphs, inter_layer_edgelists)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_graphs_+3A_graphs">graphs</code></td>
<td>
<p>[list] List of iGraph objects</p>
</td></tr>
<tr><td><code id="combine_graphs_+3A_inter_layer_edgelists">inter_layer_edgelists</code></td>
<td>
<p>[list] List of data frames containing inter-layer edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iGraph object which is the union of the input graphs with isolated nodes removed.
</p>

<hr>
<h2 id='combined_graphs_example'>Combined graphs</h2><span id='topic+combined_graphs_example'></span>

<h3>Description</h3>

<p>Exemplary intermediate pipeline output: Combined graphs example data built by
<code><a href="#topic+generate_combined_graphs">generate_combined_graphs</a></code>. Combined graphs were built
using the <a href="#topic+individual_graphs_example">individual_graphs_example</a> and:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combined_graphs_example
</code></pre>


<h3>Format</h3>

<p>A named list with 2 items.
</p>

<dl>
<dt>graphs</dt><dd><p>A named list with two groups.</p>
</dd>
</dl>

<dl>
<dt>groupA</dt><dd><p>Graph associated with 'groupA'</p>
</dd>
<dt>groupB</dt><dd><p>Graph associated with 'groupB'</p>
</dd>
</dl>

<dl>
<dt>annotations</dt><dd><p>A data frame of mappings of assigned node IDs to the
user-provided component identifiers for all nodes in 'groupA' and 'groupB' together
and all layers</p>
</dd>
</dl>

<dl>
<dt>both</dt><dd><p>Data frame</p>
</dd>
</dl>




<h3>Details</h3>

<p><code>inter_layer_connections = list(
         make_connection(from='mrna', to='protein', connect_on='gene_name', weight=1),
         make_connection(from='protein', to='phosphosite', connect_on='gene_name', weight=1),
         make_connection(from='protein', to='metabolite', connect_on=metabolite_protein_interactions, weight='combined_score'))</code>
</p>
<p>A subset of the original data by Krug et al. (2020) and randomly sampled metabolite
data from <code><a href="#topic+layers_example">layers_example</a></code> was used to generate the correlation
matrices, individual graphs and combined graphs. They were created from data
stratified by estrogen receptor (ER) status: 'groupA' contains data of ER+
patients and 'groupB' of ER- patients.
</p>


<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and
Targeted Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>

<hr>
<h2 id='compute_correlation_matrices'>Computes correlation matrices for specified network layers</h2><span id='topic+compute_correlation_matrices'></span>

<h3>Description</h3>

<p>Constructs and returns a correlation/adjacency matrices for each network layer
and each group. The adjacency matrix of correlations is computed using <a href="WGCNA.html#topic+cor">cor</a>.
The handling of missing data can be specified. Optionally, the adjacency matrices of the
correlations can be saved. Each node is mapped to the biological identifiers given in the
layers and the mapping table is returned as 'annotations'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_correlation_matrices(layers, settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_correlation_matrices_+3A_layers">layers</code></td>
<td>
<p>[list] Named list with different network layers containing data and identifiers for both
groups (generated from <code><a href="#topic+make_layer">make_layer</a></code>)</p>
</td></tr>
<tr><td><code id="compute_correlation_matrices_+3A_settings">settings</code></td>
<td>
<p>[list] A named list containing pipeline settings. The settings list has to be
initialized by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code>. Items in the named list can be
adjusted as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested named list with first-level elements 'correlation_matrices' and 'annotations'. The second
level elements are 'groupA' and 'groupB' (and 'both' at 'annotations'). These contain a named list of matrix
objects ('correlation_matrices') and data frames ('annotations') mapping the graph node IDs to biological
identifiers. The third level elements are the layer names given by the user.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

example_settings &lt;- drdimont_settings(
                        handling_missing_data=list(
                            default="all.obs"))

# mini example with reduced mRNA layer for shorter runtime:
data(mrna_data)
reduced_mrna_layer &lt;- make_layer(name="mrna",
                          data_groupA=mrna_data$groupA[1:5,2:6],
                          data_groupB=mrna_data$groupB[1:5,2:6],
                          identifiers_groupA=data.frame(gene_name=mrna_data$groupA$gene_name[1:5]),
                          identifiers_groupB=data.frame(gene_name=mrna_data$groupB$gene_name[1:5]))

example_correlation_matrices &lt;- compute_correlation_matrices(
                                    layers=list(reduced_mrna_layer), 
                                    settings=example_settings)

# to run all layers use layers=layers_example from data(layers_example) 
# in compute_correlation_matrices()

</code></pre>

<hr>
<h2 id='compute_drug_response_scores'>Calculate drug response score</h2><span id='topic+compute_drug_response_scores'></span>

<h3>Description</h3>

<p>This function takes the differential graph (generated in
<code><a href="#topic+generate_differential_score_graph">generate_differential_score_graph</a></code>), the a drug targets object (containing target node names and
drugs and their targets; generated in <code><a href="#topic+determine_drug_targets">determine_drug_targets</a></code>) and the supplied
drug-target interaction table (formatted in <code><a href="#topic+make_drug_target">make_drug_target</a></code>) to calculate the
differential drug response score. The score is the mean or median of all differential scores of the
edges adjacent to all drug target nodes of a particular drug.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_drug_response_scores(differential_graph, drug_targets, settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_drug_response_scores_+3A_differential_graph">differential_graph</code></td>
<td>
<p>iGraph graph object containing differential scores for all edges.
(output of <code><a href="#topic+generate_differential_score_graph">generate_differential_score_graph</a></code>)</p>
</td></tr>
<tr><td><code id="compute_drug_response_scores_+3A_drug_targets">drug_targets</code></td>
<td>
<p>[list] Named list containing two elements ('target_nodes' and
'drugs_to_target_nodes'). 'targets' from output of <code><a href="#topic+determine_drug_targets">determine_drug_targets</a></code>. 'target_nodes' is a
vector containing network node names of the nodes that are targeted by the available drugs.
'drugs_to_target_nodes' is a dictionary-like list that maps drugs to the nodes that they
target.</p>
</td></tr>
<tr><td><code id="compute_drug_response_scores_+3A_settings">settings</code></td>
<td>
<p>[list] A named list containing pipeline settings. The settings list has to be
initialized by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code>. Items in the named list can be
adjusted as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing drug name and associated differential (integrated) drug response score
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drug_target_edges_example)
data(differential_graph_example)

example_settings &lt;- drdimont_settings()

example_drug_response_scores &lt;- compute_drug_response_scores(
                                    differential_graph=differential_graph_example,
                                    drug_targets=drug_target_edges_example$targets,
                                    settings=example_settings)

</code></pre>

<hr>
<h2 id='corPvalueStudentParallel'>[INTERNAL] Compute p-values for upper triangle of correlation matrix in parallel</h2><span id='topic+corPvalueStudentParallel'></span>

<h3>Description</h3>

<p>[INTERNAL] Compute p-values for upper triangle of correlation matrix in parallel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corPvalueStudentParallel(adjacency_matrix, number_of_samples, chunk_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corPvalueStudentParallel_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>[matrix] Adjacency matrix of correlations computed using <code><a href="WGCNA.html#topic+cor">cor</a></code> in
<code><a href="#topic+compute_correlation_matrices">compute_correlation_matrices</a></code></p>
</td></tr>
<tr><td><code id="corPvalueStudentParallel_+3A_number_of_samples">number_of_samples</code></td>
<td>
<p>[matrix] Matrix of number of samples used in computation of each correlation value. Computed applying
<code><a href="#topic+sample_size">sample_size</a></code></p>
</td></tr>
<tr><td><code id="corPvalueStudentParallel_+3A_chunk_size">chunk_size</code></td>
<td>
<p>[int] Smallest unit of work in parallel computation (number of p-values to compute)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of p-values for upper triangle
</p>

<hr>
<h2 id='correlation_matrices_example'>Correlation matrices</h2><span id='topic+correlation_matrices_example'></span>

<h3>Description</h3>

<p>Exemplary intermediate pipeline output: Correlation matrices example data built by
<code><a href="#topic+compute_correlation_matrices">compute_correlation_matrices</a></code> using <a href="#topic+layers_example">layers_example</a>
data and settings:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_matrices_example
</code></pre>


<h3>Format</h3>

<p>A named list with 2 items.
</p>

<dl>
<dt>correlation_matrices</dt><dd><p>A named list with two groups.</p>
</dd>
</dl>

<dl>
<dt>groupA</dt><dd><p>Correlation matrices associated with 'groupA'</p>
</dd>
</dl>

<dl>
<dt>mrna</dt><dd><p>Correlation matrix</p>
</dd>
<dt>protein</dt><dd><p>Correlation matrix</p>
</dd>
<dt>phosphosite</dt><dd><p>Correlation matrix</p>
</dd>
<dt>metabolite</dt><dd><p>Correlation matrix</p>
</dd>
</dl>

<dl>
<dt>groupB</dt><dd><p>same structure as 'groupA'</p>
</dd>
</dl>

<dl>
<dt>annotations</dt><dd><p>A named list containing data frames of mappings of assigned node IDs to the
user-provided component identifiers for nodes in 'groupA' or 'groupB' and all nodes</p>
</dd>
</dl>

<dl>
<dt>groupA</dt><dd><p>Annotations associated with 'groupA'</p>
</dd>
</dl>

<dl>
<dt>mrna</dt><dd><p>Data frame</p>
</dd>
<dt>protein</dt><dd><p>Data frame</p>
</dd>
<dt>phosphosite</dt><dd><p>Data frame</p>
</dd>
<dt>metabolite</dt><dd><p>Data frame</p>
</dd>
</dl>

<dl>
<dt>groupB</dt><dd><p>same structure as 'groupA'</p>
</dd>
<dt>both</dt><dd><p>same structure as 'groupA'</p>
</dd>
</dl>




<h3>Details</h3>

<p><code>settings &lt;- drdimont_settings(
                         handling_missing_data=list(
                             default="pairwise.complete.obs",
                             mrna="all.obs"))</code>
</p>
<p>A subset of the original data from Krug et al. (2020) and randomly sampled metabolite
data in <a href="#topic+layers_example">layers_example</a> was used to generate the correlation
matrices. They were created from data stratified by estrogen receptor (ER) status:
'groupA' contains data of ER+ patients and 'groupB' of ER- patients.
</p>


<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and
Targeted Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>

<hr>
<h2 id='create_unique_layer_node_ids'>[INTERNAL] Assign node IDs to the biological identifiers across a graph layer</h2><span id='topic+create_unique_layer_node_ids'></span>

<h3>Description</h3>

<p>[INTERNAL] This function takes two data frames of (biological) identifiers of nodes.
Each data frame corresponds to the identifiers of the components contained in the single-layer
network of a sample group. This function outputs the same data frames, with an added column ('node_id')
that contains node IDs which can later be used as 'name' parameter for an iGraph graph.
Node IDs begin with the defined 'prefix' and an underscore. If a molecule is present in both
groups, the node ID will be the same across the whole layer, allowing to easily combine the
graphs of both groups in <code><a href="#topic+generate_differential_score_graph">generate_differential_score_graph</a></code> to calculate
differential scores of identical nodes in both sample groups.
The function is used by the high-level wrapper <a href="#topic+generate_individual_graphs">generate_individual_graphs</a> to
create annotations, which uniquely define nodes across the network layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_unique_layer_node_ids(identifiersA, identifiersB, layer_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_unique_layer_node_ids_+3A_identifiersa">identifiersA</code>, <code id="create_unique_layer_node_ids_+3A_identifiersb">identifiersB</code></td>
<td>
<p>[data.frame] Containing the biological identifiers of each
group of the same network layer.</p>
</td></tr>
<tr><td><code id="create_unique_layer_node_ids_+3A_layer_name">layer_name</code></td>
<td>
<p>[string] Name of layer that the node ids are created for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an named list. Elements 'groupA' and 'groupB' contain the input
data frames with an additional column 'node_id'. 'both' contains all unique node IDs assigned
across the network layer.
</p>

<hr>
<h2 id='determine_drug_targets'>Determine drug target nodes in network</h2><span id='topic+determine_drug_targets'></span>

<h3>Description</h3>

<p>Finds node IDs of network nodes in 'graphs' that are targeted by a drug in
'drug_target_interactions'. Returns list of node ids and list of adjacent edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_drug_targets(graphs, annotations, drug_target_interactions, settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_drug_targets_+3A_graphs">graphs</code></td>
<td>
<p>[list] A named list with elements 'groupA' and 'groupB' containing the combined graphs
of each group as iGraph object ('graphs' from output of <code><a href="#topic+generate_combined_graphs">generate_combined_graphs</a></code>)</p>
</td></tr>
<tr><td><code id="determine_drug_targets_+3A_annotations">annotations</code></td>
<td>
<p>[list] List of data frames that map node IDs to identifiers. Contains 'both'
with unique identifiers across the whole data (output of <code><a href="#topic+generate_combined_graphs">generate_combined_graphs</a></code>)</p>
</td></tr>
<tr><td><code id="determine_drug_targets_+3A_drug_target_interactions">drug_target_interactions</code></td>
<td>
<p>[list] Named list specifying drug target interactions for drug response
score computation</p>
</td></tr>
<tr><td><code id="determine_drug_targets_+3A_settings">settings</code></td>
<td>
<p>[list] A named list containing pipeline settings. The settings list has to be
initialized by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code>. Items in the named list can be
adjusted as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with elements 'targets' and 'edgelists'.
'targets' is a named list with elements 'target_nodes' and 'drugs_to_target_nodes'.
'target_nodes' is a data frame with column 'node_id' (unique node IDs in the iGraph object
targeted by drugs) and columns 'groupA' and 'groupB' (bool values specifying whether the
node is contained in the combined graph of the group). Element 'drugs_to_target_nodes' contains
a named list mapping drug names to a vector of their target node IDs.
'edgelists' contains elements 'groupA' and 'groupB' containing each a list of
edges adjacent to drug target nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drug_gene_interactions)
data(combined_graphs_example)

example_settings &lt;- drdimont_settings()

example_drug_target_interactions &lt;- make_drug_target(target_molecules='protein',
                                        interaction_table=drug_gene_interactions,
                                        match_on='gene_name')

example_drug_target_edges &lt;- determine_drug_targets(
                                 graphs=combined_graphs_example$graphs,
                                 annotations=combined_graphs_example$annotations,
                                 drug_target_interactions=example_drug_target_interactions,
                                 settings=example_settings)

</code></pre>

<hr>
<h2 id='differential_graph_example'>Differential graph</h2><span id='topic+differential_graph_example'></span>

<h3>Description</h3>

<p>Exemplary intermediate pipeline output: Differential score graph example data built by
<code><a href="#topic+generate_differential_score_graph">generate_differential_score_graph</a></code> using the
<a href="#topic+interaction_score_graphs_example">interaction_score_graphs_example</a>.
Consists of one graph containing edge attributes: the differential correlation values as
'differential_score' and the differential interaction score as 'differential_interaction_score'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differential_graph_example
</code></pre>


<h3>Format</h3>

<p>An iGraph graph object.
</p>


<h3>Details</h3>

<p>A subset of the original data by Krug et al. (2020) and randomly sampled metabolite
data from <code><a href="#topic+layers_example">layers_example</a></code> was used to generate the correlation
matrices, individual graphs and combined graphs. They were created from data
stratified by estrogen receptor (ER) status: 'groupA' contains data of ER+
patients and 'groupB' of ER- patients.
</p>


<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and Targeted
Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>

<hr>
<h2 id='drdimont_settings'>Create global settings variable for DrDimont pipeline</h2><span id='topic+drdimont_settings'></span>

<h3>Description</h3>

<p>Allows creating a global &lsquo;settings' variable used in DrDimont&rsquo;s
<code><a href="#topic+run_pipeline">run_pipeline</a></code> function and step-wise execution.
Default parameters can be changed within the function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drdimont_settings(
  saving_path = tempdir(),
  save_data = FALSE,
  correlation_method = "spearman",
  handling_missing_data = "all.obs",
  reduction_method = "pickHardThreshold",
  r_squared_cutoff = 0.85,
  cut_vector = seq(0.2, 0.8, by = 0.01),
  mean_number_edges = NULL,
  edge_density = NULL,
  p_value_adjustment_method = "BH",
  reduction_alpha = 0.05,
  n_threads = 1,
  parallel_chunk_size = 10^6,
  print_graph_info = TRUE,
  conda = FALSE,
  max_path_length = 3,
  int_score_mode = "auto",
  cluster_address = "auto",
  median_drug_response = FALSE,
  absolute_difference = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drdimont_settings_+3A_saving_path">saving_path</code></td>
<td>
<p>[string] Path to save intermediate output of DrDimont's functions. Default is temporary folder.</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_save_data">save_data</code></td>
<td>
<p>[bool] 
Save intermediate data such as correlation_matrices, individual_graphs, etc. during exectution of DrDimont. (default: FALSE)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_correlation_method">correlation_method</code></td>
<td>
<p>[&quot;pearson&quot;|&quot;spearman&quot;|&quot;kendall&quot;] 
Correlation method used for graph generation. Argument is passed to <code><a href="WGCNA.html#topic+cor">cor</a></code>. 
(default: spearman)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_handling_missing_data">handling_missing_data</code></td>
<td>
<p>[&quot;all.obs&quot;|&quot;pairwise.complete.obs&quot;] 
Method for handling of missing data during correlation matrix computation. Argument is passed 
to <code><a href="WGCNA.html#topic+cor">cor</a></code>. Can be a single character string if the same for all layers, else 
a named list mapping layer names to methods, e.g, 
<code>handling_missing_data=list(mrna="all.obs", protein="pairwise.complete.obs")</code>.
Layers may be omitted if a method is mapped to 'default', e.g,
<code>handling_missing_data=list(default="pairwise.complete.obs")</code>. (default: all.obs)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_reduction_method">reduction_method</code></td>
<td>
<p>[&quot;pickHardThreshold&quot;|&quot;p_value&quot;]
Reduction method for reducing networks. 'p_value' for hard thresholding based on the statistical
significance of the computed correlation. 'pickHardThreshold' for a cutoff based on the scale-freeness
criterion (calls <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code>). Can be a single character string if the same
for all layers, else a named list mapping layer names to methods (see <code>handling_missing_data</code> setting).
Layers may be omitted if a method is mapped to 'default'. (default: pickHardThreshold)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_r_squared_cutoff">r_squared_cutoff</code></td>
<td>
<p>pickHardThreshold setting: [float|named list]
Minimum scale free topology fitting index R^2 for reduction using
<code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code>.
Can be a single float number if the same for all layers, else a named list mapping layer names to a cutoff
(see <code>handling_missing_data</code> setting) or a named list in a named list mapping groupA or groupB and layer
names to a cutoff, e.g., 
<code>r_squared_cutoff=list(groupA=list(mrna=0.85, protein=0.8), groupB=list(mrna=0.9, protein=0.85))</code>.
Layers/groups may be omitted if a cutoff is mapped to 'default'. (default: 0.85)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_cut_vector">cut_vector</code></td>
<td>
<p>pickHardThreshold setting: [sequence of float|named list]
Vector of hard threshold cuts for which the scale free topology fit indices are calculated during
reduction with <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code>.
Can be a single regular sequence if the same for all layers, else a named list mapping layer names 
to a cut vector or a named list in a named list mapping groupA or groupB and layer names to a cut 
vector (see <code>r_squared_cutoff</code> setting). Layers/groups may be omitted if a vector is mapped
to 'default'. (default: seq(0.2, 0.8, by = 0.01))</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_mean_number_edges">mean_number_edges</code></td>
<td>
<p>pickHardThreshold setting: [int|named list] 
Maximal mean number edges threshold to find a suitable edge weight cutoff employing
<code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code> to reduce the network to at most the specified mean number of edges.
Can be a single int number if the same for all layers, else a named list mapping layer names to a mean number of edges or
a named list in a named list mapping groupA or groupB and layer names to a cutoff (see <code>r_squared_cutoff</code> setting).
Attention: This parameter overwrites the 'r_squared_cutoff' and 'edge_density' parameters if not set to NULL. (default: NULL)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_edge_density">edge_density</code></td>
<td>
<p>pickHardThreshold setting: [float|named list] 
Maximal network edge density to find a suitable edge weight cutoff employing
<code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code> to reduce the network to at most the specified edge density.
Can be a single float number if the same for all layers, else a named list mapping layer names to a mean number of edges or
a named list in a named list mapping groupA or groupB and layer names to a cutoff (see <code>r_squared_cutoff</code> setting).
Attention: This parameter overwrites the 'r_squared_cutoff' parameter if not set to NULL. (default: NULL)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_p_value_adjustment_method">p_value_adjustment_method</code></td>
<td>
<p>p_value setting: [&quot;holm&quot;|&quot;hochberg&quot;|&quot;hommel&quot;|&quot;bonferroni&quot;|&quot;BH&quot;|&quot;BY&quot;|&quot;fdr&quot;|&quot;none&quot;]
Correction method applied to p-values. Passed to <a href="stats.html#topic+p.adjust">p.adjust</a>. (default: &quot;BH&quot;)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_reduction_alpha">reduction_alpha</code></td>
<td>
<p>p_value setting: [float] 
Significance value for correlation p-values
during reduction. Not-significant edges are dropped. (default: 0.05)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_n_threads">n_threads</code></td>
<td>
<p>p_value setting: [int] 
Number of threads for parallel computation of p-values during p-value reduction. (default: 1)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_parallel_chunk_size">parallel_chunk_size</code></td>
<td>
<p>p_value setting: [int] 
Number of p-values in smallest work unit when computing in parallel
during network reduction with method 'p_value'. (default: 10^6)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_print_graph_info">print_graph_info</code></td>
<td>
<p>[bool] 
Print summary of the reduced graph to the console after network generation. (default: TRUE)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_conda">conda</code></td>
<td>
<p>[bool] 
Python installation in conda environment. Set TRUE if Python is installed with conda. (default: FALSE)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_max_path_length">max_path_length</code></td>
<td>
<p>[int] 
Integer of maximum length of simple paths to include in the
<code><a href="#topic+generate_interaction_score_graphs">generate_interaction_score_graphs</a></code> computation. (default: 3)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_int_score_mode">int_score_mode</code></td>
<td>
<p>[&quot;auto&quot;|&quot;sequential&quot;|&quot;ray&quot;] 
Interaction score sequential or parallel (&quot;ray&quot;) computation. For parallel computation the Python library Ray ist used. 
When set to 'auto' computation depends on the  graph sizes. (default: &quot;auto&quot;)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_cluster_address">cluster_address</code></td>
<td>
<p>[string] Local node IP-address of Ray if executed on a cluster.
On a cluster: Start ray with <code>ray start --head --num-cpus 32</code> on the console before DrDimont execution.
It should work with &quot;auto&quot;, if it does not specify IP-address given by the <code>ray start</code> command. (default: &quot;auto&quot;)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_median_drug_response">median_drug_response</code></td>
<td>
<p>[bool] 
Computation of median (instead of mean) of a drug's targets differential scores (default: FALSE)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_absolute_difference">absolute_difference</code></td>
<td>
<p>[bool] 
Computation of drug response scores based on absolute differential scores (instead of the actual differential
scores) (default: FALSE)</p>
</td></tr>
<tr><td><code id="drdimont_settings_+3A_...">...</code></td>
<td>
<p>Supply additional settings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of the settings for the pipeline
</p>


<h3>Examples</h3>

<pre><code class='language-R'>settings &lt;- drdimont_settings(
                correlation_method="spearman",
                handling_missing_data=list(
                    default="pairwise.complete.obs",
                    mrna="all.obs"),
                reduction_method="pickHardThreshold",
                max_path_length=3)

</code></pre>

<hr>
<h2 id='drug_gene_interactions'>Drug-gene interactions</h2><span id='topic+drug_gene_interactions'></span>

<h3>Description</h3>

<p>Data frame providing interactions of drugs with genes. The data was downloaded from
The Drug Gene Interaction Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drug_gene_interactions
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 columns.
</p>

<dl>
<dt>gene_name</dt><dd><p>Gene names of targeted protein-coding genes.</p>
</dd>
<dt>drug_name</dt><dd><p>Drug-names with known interactions.</p>
</dd>
<dt>drug_chembl_id</dt><dd><p>ChEMBL ID of drugs.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Drug Gene Interaction Database: <a href="https://www.dgidb.org/">https://www.dgidb.org/</a>
</p>
<p>ChEMBL IDs: <a href="https://www.ebi.ac.uk/chembl">https://www.ebi.ac.uk/chembl</a>
</p>

<hr>
<h2 id='drug_response_scores_example'>Drug response score</h2><span id='topic+drug_response_scores_example'></span>

<h3>Description</h3>

<p>Exemplary final pipeline output: Drug response score data frame. This contains drugs and the
calculated differential drug response score. The score was calculated by
<code><a href="#topic+compute_drug_response_scores">compute_drug_response_scores</a></code> using
<a href="#topic+differential_graph_example">differential_graph_example</a>, <a href="#topic+drug_target_edges_example">drug_target_edges_example</a> and
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drug_response_scores_example
</code></pre>


<h3>Format</h3>

<p>Data frame with two columns
</p>

<dl>
<dt>drug_name</dt><dd><p>Names of drugs</p>
</dd>
<dt>drug_response_scores</dt><dd><p>Associated differential drug response scores</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>drug_target_interaction &lt;- make_drug_target(target_molecules='protein',
             interaction_table=drug_gene_interactions,
             match_on='gene_name')</code>
</p>
<p>A subset of the original data by Krug et al. (2020) and randomly sampled metabolite
data from <code><a href="#topic+layers_example">layers_example</a></code> was used to generate the correlation
matrices, individual graphs and combined graphs, interaction score graphs and differential
score graph. They were created from data stratified by estrogen receptor (ER) status:
'groupA' contains data of ER+ patients and 'groupB' of ER- patients. Drug-gene
interactions were used from The Drug Gene Interaction Database.
</p>


<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and Targeted
Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>
<p>The Drug Gene Interaction Database: <a href="https://www.dgidb.org/">https://www.dgidb.org/</a>
</p>

<hr>
<h2 id='drug_target_edges_example'>Drug target nodes in combined network</h2><span id='topic+drug_target_edges_example'></span>

<h3>Description</h3>

<p>Exemplary intermediate pipeline output: Drug targets detected in the combined
graphs. A named list with elements 'targets' and 'edgelists'. This was created with
<code><a href="#topic+determine_drug_targets">determine_drug_targets</a></code> using the <a href="#topic+combined_graphs_example">combined_graphs_example</a>
and:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drug_target_edges_example
</code></pre>


<h3>Format</h3>

<p>A named list with 2 items.
</p>

<dl>
<dt>targets</dt><dd><p>A named list</p>
</dd>
</dl>

<dl>
<dt>target_nodes</dt><dd><p>data frame with column 'node_id' (unique node IDs in the graph targeted by
drugs) and columns 'groupA' and 'groupB' (bool values specifying whether the node is
contained in the combined graph of the group)</p>
</dd>
<dt>drugs_to_target_nodes</dt><dd><p>Element 'drugs_to_target_nodes' contains a named list mapping drug
names to a vector of their target node IDs.</p>
</dd>
</dl>

<dl>
<dt>edgelists</dt><dd><p>Contains elements 'groupA' and 'groupB' containing each a data frame of edges
adjacent to drug target nodes each. Each edgelist data frame contains columns 'from', 'to' and
'weight'.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>drug_target_interactions &lt;- make_drug_target(target_molecules='protein',
             interaction_table=drug_gene_interactions,
             match_on='gene_name')</code>
</p>
<p>Drug-gene interactions to calculate this output were used from
The Drug Gene Interaction Database.
</p>


<h3>Source</h3>

<p>The Drug Gene Interaction Database: <a href="https://www.dgidb.org/">https://www.dgidb.org/</a>
</p>

<hr>
<h2 id='find_targets'>[INTERNAL] Filter drug target nodes</h2><span id='topic+find_targets'></span>

<h3>Description</h3>

<p>[INTERNAL] Based on the supplied target molecules, interaction table, graph and
annotation this function returns a data frame containing nodes in the network targeted by a
drug and a list containing the drug names as names and a vector of node IDs as keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_targets(graphs, target_molecules, interaction_table, annotation, on)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_targets_+3A_graphs">graphs</code></td>
<td>
<p>[list] List of two iGraph graph objects (one for each group)</p>
</td></tr>
<tr><td><code id="find_targets_+3A_target_molecules">target_molecules</code></td>
<td>
<p>[string] Identifies the type of the target molecules (e.g.,
'protein'). The string must be contained in the 'type' column of the annotation data frame.</p>
</td></tr>
<tr><td><code id="find_targets_+3A_interaction_table">interaction_table</code></td>
<td>
<p>[data.frame] Specifying the interaction of drugs and target molecules.
Must contain a column 'drug_name' containing drug names/identifiers and a column named like
the character string given in the 'on' argument, which must be an identifier for the targeted
molecule.</p>
</td></tr>
<tr><td><code id="find_targets_+3A_annotation">annotation</code></td>
<td>
<p>[data.frame] Contains the annotation for all the nodes contained in the
combined network. Must contain a column 'node_id' (vertex IDs in iGraph graph object) and a
column named like the character string given in the 'on' argument, which must be an identifier
for the targeted molecule.</p>
</td></tr>
<tr><td><code id="find_targets_+3A_on">on</code></td>
<td>
<p>[string] Defines the ID that is used to match drugs to their targets. Both
supplied data frames ('annotation' and 'interaction_table') must contain a column named like
this character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list. Element 'target_nodes' is a data frame with column 'node_id' (unique node
IDs in the iGraph graph object that are targeted by drugs) and columns 'groupA' and 'groupB'
(bool values specifying whether the node is contained in the combined graph of the group).
Element 'drugs_to_target_nodes' contains a named list: elements are 'drug_names' and contain a
vector of node IDs that are their specific targets.
</p>

<hr>
<h2 id='generate_combined_graphs'>Combines individual layers to a single graph</h2><span id='topic+generate_combined_graphs'></span>

<h3>Description</h3>

<p>Individual graphs created by <code><a href="#topic+generate_individual_graphs">generate_individual_graphs</a></code>
are combined to a single graph per group according to 'inter_layer_connections'. Returns a
list of combined graphs along with their annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_combined_graphs(
  graphs,
  annotations,
  inter_layer_connections,
  settings
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_combined_graphs_+3A_graphs">graphs</code></td>
<td>
<p>[list] A named list (elements 'groupA' and 'groupB'). Each element contains a list of
iGraph objects ('graphs' from output of <code><a href="#topic+generate_individual_graphs">generate_individual_graphs</a></code>).</p>
</td></tr>
<tr><td><code id="generate_combined_graphs_+3A_annotations">annotations</code></td>
<td>
<p>[list] A named list (elements 'groupA', 'groupB' and 'both'). Each element contains a
list of data frames mapping each node IDs to identifiers. 'both' contains unique identifiers across the
whole data. ('annotations' from output of <code><a href="#topic+generate_individual_graphs">generate_individual_graphs</a></code>)</p>
</td></tr>
<tr><td><code id="generate_combined_graphs_+3A_inter_layer_connections">inter_layer_connections</code></td>
<td>
<p>[list] Named list with specified inter-layer connections. Names are
layer names and elements are connections (<a href="#topic+make_connection">make_connection</a>).</p>
</td></tr>
<tr><td><code id="generate_combined_graphs_+3A_settings">settings</code></td>
<td>
<p>[list] A named list containing pipeline settings. The settings list has to be
initialized by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code>. Items in the named list can be
adjusted as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list (elements 'graphs' and sub-elements '$groupA' and
'$groupB', and 'annotations' and sub-element 'both'). Contains the igraph objects of the combined
network and their annotations for both groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(individual_graphs_example)
data(metabolite_protein_interactions)

example_inter_layer_connections = list(make_connection(from='mrna', to='protein',
                                           connect_on='gene_name', weight=1),
                                       make_connection(from='protein', to='phosphosite',
                                           connect_on='gene_name', weight=1),
                                       make_connection(from='protein', to='metabolite',
                                           connect_on=metabolite_protein_interactions,
                                           weight='combined_score'))

example_settings &lt;- drdimont_settings()

example_combined_graphs &lt;- generate_combined_graphs(
                               graphs=individual_graphs_example$graphs,
                               annotations=individual_graphs_example$annotations,
                               inter_layer_connections=example_inter_layer_connections,
                               settings=example_settings)

</code></pre>

<hr>
<h2 id='generate_differential_score_graph'>Compute difference of interaction score of two groups</h2><span id='topic+generate_differential_score_graph'></span>

<h3>Description</h3>

<p>Computes the absolute difference of interaction scores between
the two groups. Returns a single graph with the differential score and the
differential interaction score as edge attributes. The interaction score
is computed by <code><a href="#topic+generate_interaction_score_graphs">generate_interaction_score_graphs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_differential_score_graph(interaction_score_graphs, settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_differential_score_graph_+3A_interaction_score_graphs">interaction_score_graphs</code></td>
<td>
<p>[list] Named list with elements 'groupA' and
'groupB' containing iGraph objects with weight and interaction_weight as edge attributes (output of
<code><a href="#topic+generate_interaction_score_graphs">generate_interaction_score_graphs</a></code>)</p>
</td></tr>
<tr><td><code id="generate_differential_score_graph_+3A_settings">settings</code></td>
<td>
<p>[list] A named list containing pipeline settings. The settings list has to be
initialized by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code>. Items in the named list can be
adjusted as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iGraph object with 'differential_score' and 'differential_interaction_score' as edge attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(interaction_score_graphs_example)

example_settings &lt;- drdimont_settings()

example_differential_score_graph &lt;- generate_differential_score_graph(
                                        interaction_score_graphs=interaction_score_graphs_example,
                                        settings=example_settings)

</code></pre>

<hr>
<h2 id='generate_individual_graphs'>Builds graphs from specified network layers</h2><span id='topic+generate_individual_graphs'></span>

<h3>Description</h3>

<p>Constructs and returns two graphs for each network layer, where nodes
correspond to the rows in the measurement data. Graphs are initially complete and
edges are weighted by correlation values of the measurements across columns. The
number of edges is then reduced by either a threshold on the p-value of the
correlation or a minimum scale-free fit index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_individual_graphs(correlation_matrices, layers, settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_individual_graphs_+3A_correlation_matrices">correlation_matrices</code></td>
<td>
<p>[list] List of correlation matrices generated with
code<a href="#topic+compute_correlation_matrices">compute_correlation_matrices</a></p>
</td></tr>
<tr><td><code id="generate_individual_graphs_+3A_layers">layers</code></td>
<td>
<p>[list] Named list with different network layers containing data and
identifiers for both groups (generated from <code><a href="#topic+make_layer">make_layer</a></code>)</p>
</td></tr>
<tr><td><code id="generate_individual_graphs_+3A_settings">settings</code></td>
<td>
<p>[list] A named list containing pipeline settings. The settings list has to be
initialized by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code>. Items in the named list can be
adjusted as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested named list with first-level elements 'graphs' and 'annotations'. The second
level elements are 'groupA' and 'groupB' (and 'both' at 'annotations'). These contain a list of
iGraph objects ('graphs') and data frames ('annotations') mapping the graph node IDs to biological
identifiers. The third level elements are layer names given by the user.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(layers_example)
data(correlation_matrices_example)

example_settings &lt;- drdimont_settings(
                        handling_missing_data=list(
                            default="pairwise.complete.obs",
                            mrna="all.obs"),
                        reduction_method="pickHardThreshold",
                        r_squared=list(default=0.65, metabolite=0.1),
                        cut_vector=list(default=seq(0.2, 0.5, 0.01)))

example_individual_graphs &lt;- generate_individual_graphs(
                                 correlation_matrices=correlation_matrices_example,
                                 layers=layers_example, 
                                 settings=example_settings)

graph_metrics(example_individual_graphs$graphs$groupA$mrna)
graph_metrics(example_individual_graphs$graphs$groupB$mrna)

</code></pre>

<hr>
<h2 id='generate_interaction_score_graphs'>Computes interaction score for combined graphs</h2><span id='topic+generate_interaction_score_graphs'></span>

<h3>Description</h3>

<p>Writes the input data (combined graphs for both groups in 'gml' format and
lists of edges adjacent to drug targets for both groups in 'tsv' format) to files and calls a Python script
for calculating the interaction scores. Output files written by the Python script are two graphs in 'gml'
format containing the interaction score as an additional 'interaction_weight' edge attribute.
These are loaded and returned in a named list.
ATTENTION: Data exchange via files is mandatory and takes a long time for large data. Interaction
score computation is expensive and slow because it involves finding all simple paths up to a
certain length between source and target node of the drug target edges. Don't set the parameter 'max_path_length'
in <code><a href="#topic+drdimont_settings">drdimont_settings</a></code> to a large value and only consider this step if your graphs have approximately
2 million edges or less. Computation is initiated by <code><a href="#topic+calculate_interaction_score">calculate_interaction_score</a></code>.
The Python script is parallelized using Ray. Use the <code><a href="#topic+drdimont_settings">drdimont_settings</a></code> parameter 'int_score_mode' to force sequential
or parallel computation. Refer to the Ray documentation if you encounter problems with running
the Python script in parallel. DISCLAIMER: Depending on the operating system Python comes
pre-installed or has to be installed manually. Use DrDimont's <code><a href="#topic+install_python_dependencies">install_python_dependencies</a></code> 
to install a virtual Python or conda environment containing the required Python packages. 
You can use the parameter 'conda' in <code><a href="#topic+drdimont_settings">drdimont_settings</a></code> to specify if Python packages 
were installed with conda ('conda=TRUE'), else a virtual environment installed with pip is 
assumed (default: 'conda=FALSE').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_interaction_score_graphs(graphs, drug_target_edgelists, settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_interaction_score_graphs_+3A_graphs">graphs</code></td>
<td>
<p>[list] A named list with elements 'groupA' and 'groupB' containing the combined graphs
of each group as iGraph object ('graphs' from output of <code><a href="#topic+generate_combined_graphs">generate_combined_graphs</a></code>)</p>
</td></tr>
<tr><td><code id="generate_interaction_score_graphs_+3A_drug_target_edgelists">drug_target_edgelists</code></td>
<td>
<p>[list] A named list (elements 'groupA' and 'groupB'). Each element
contains the list of edges adjacent to drug targets as a data frame (columns 'from', 'to' and
'weight'). 'edgelists' from output of <code><a href="#topic+determine_drug_targets">determine_drug_targets</a></code></p>
</td></tr>
<tr><td><code id="generate_interaction_score_graphs_+3A_settings">settings</code></td>
<td>
<p>[list] A named list containing pipeline settings. The settings list has to be
initialized by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code>. Items in the named list can be
adjusted as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list (elements 'groupA' and 'groupB'). Each element contains an iGraph object
containing the interaction scores as interaction_weight attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(combined_graphs_example)
data(drug_target_edges_example)

example_settings &lt;- drdimont_settings()


example_interaction_score_graphs &lt;- generate_interaction_score_graphs(
                                        graphs=combined_graphs_example$graphs,
                                        drug_target_edgelists=drug_target_edges_example$edgelists,
                                        settings=example_settings)


</code></pre>

<hr>
<h2 id='generate_reduced_graph'>[INERNAL] Generate a reduced iGraph from adjacency matrices</h2><span id='topic+generate_reduced_graph'></span>

<h3>Description</h3>

<p>[INTERNAL] A wrapper functions that calls the functions to generate a network from
correlation data and reduce the network by a given method. Correlation/adjacency matrices are
computed in <code><a href="#topic+compute_correlation_matrices">compute_correlation_matrices</a></code>. Graph generation uses
<code><a href="igraph.html#topic+graph.adjacency">graph.adjacency</a></code> internally. Methods implemented are
<a href="#topic+network_reduction_by_p_value">network_reduction_by_p_value</a> (reduction by statistical significance of correlation)
and <a href="#topic+network_reduction_by_pickHardThreshold">network_reduction_by_pickHardThreshold</a> (using WGCNA function
<a href="WGCNA.html#topic+pickHardThreshold.fromSimilarity">pickHardThreshold.fromSimilarity</a> that finds a suitable cutoff value to get a scale-free
network). If no method is given, no reduction will be performed. When using the reduction method
'p_value' the user can specify an alpha significance value and a method for p-value adjustment.
When using the reduction by 'pickHardThreshold' a R^2 cutoff and a cut vector can be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_reduced_graph(
  adjacency_matrix,
  measurement_data,
  identifiers,
  handling_missing_data = "all.obs",
  reduction_method = "pickHardTreshold",
  r_squared_cutoff = 0.85,
  cut_vector = seq(0.2, 0.8, by = 0.01),
  mean_number_edges = NULL,
  edge_density = NULL,
  p_value_adjustment_method = "BH",
  reduction_alpha = 0.05,
  n_threads = 1,
  parallel_chunk_size = 10^6,
  print_graph_info = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_reduced_graph_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>[matrix] Adjacency matrix of correlations computed using <code><a href="WGCNA.html#topic+cor">cor</a></code> in
<code><a href="#topic+compute_correlation_matrices">compute_correlation_matrices</a></code></p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_measurement_data">measurement_data</code></td>
<td>
<p>[data.frame] Data frame containing the respective raw data (e.g. mRNA expression data,
protein abundance, etc.) to the adjacency matrix. Analyzed components (e.g. genes) in rows, samples (e.g. patients)
in columns.</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_identifiers">identifiers</code></td>
<td>
<p>[data.frame] Data frame containing  biological identifiers and the corresponding node ID
created in <code><a href="#topic+compute_correlation_matrices">compute_correlation_matrices</a></code> via <a href="#topic+create_unique_layer_node_ids">create_unique_layer_node_ids</a>.
The column containing node IDs has to be named 'node_id'.</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_handling_missing_data">handling_missing_data</code></td>
<td>
<p>[&quot;all.obs&quot;|&quot;pairwise.complete.obs&quot;] Specifying the handling
of missing data during correlation matrix computation. (default: all.obs)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_reduction_method">reduction_method</code></td>
<td>
<p>[&quot;pickHardThreshold&quot;|&quot;p_value&quot;] A character string specifying the method to be used for network
reduction. 'p_value' for hard thresholding based on the statistical significance of the
computed correlation. 'pickHardThreshold' for a cutoff based on the scale-freeness criterion
(calls <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code>). (default: pickHardThreshold)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_r_squared_cutoff">r_squared_cutoff</code></td>
<td>
<p>[float] A number indicating the desired minimum scale free topology fitting index R^2 for reduction
using <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code>. (default: 0.85)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_cut_vector">cut_vector</code></td>
<td>
<p>[sequence of float] A vector of hard threshold cuts for which the scale free topology fit indices are to
be calculated during reduction with <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code>. (default: seq(0.2, 0.8, by = 0.01))</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_mean_number_edges">mean_number_edges</code></td>
<td>
<p>[int] Find a suitable edge weight cutoff employing <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code> to reduce
the network to at most the specified mean number of edges. Attention: This parameter overwrites the 'r_squared_cutoff' and
'edge_density' parameters if not set to NULL. (default: NULL)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_edge_density">edge_density</code></td>
<td>
<p>[float] Find a suitable edge weight cutoff employing <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code> to reduce the
network to at most the specified edge density. Attention: This parameter overwrites the 'r_squared_cutoff' parameter if not set
to NULL. (default: NULL)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_p_value_adjustment_method">p_value_adjustment_method</code></td>
<td>
<p>[&quot;holm&quot;|&quot;hochberg&quot;|&quot;hommel&quot;|&quot;bonferroni&quot;|&quot;BH&quot;|&quot;BY&quot;|&quot;fdr&quot;|&quot;none&quot;] String
of the correction method applied to p-values. Passed to <a href="stats.html#topic+p.adjust">p.adjust</a>. (default: &quot;BH&quot;)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_reduction_alpha">reduction_alpha</code></td>
<td>
<p>[float] A number indicating the significance value for correlation p-values
during reduction. Not-significant edges are dropped. (default: 0.05)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_n_threads">n_threads</code></td>
<td>
<p>[int] Number of threads for parallel computation of p-values during p-value reduction.
(default: 1)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_parallel_chunk_size">parallel_chunk_size</code></td>
<td>
<p>[int] Number of p-values in smallest work unit when computing in parallel
during network reduction with method 'p_value'. (default: 10^6)</p>
</td></tr>
<tr><td><code id="generate_reduced_graph_+3A_print_graph_info">print_graph_info</code></td>
<td>
<p>[bool] Specifying if a summary of the reduced graph should be printed to
the console after network generation. (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>iGraph graph object of the reduced network.
</p>

<hr>
<h2 id='get_layer'>[INTERNAL] Fetch layer by name from layer object</h2><span id='topic+get_layer'></span>

<h3>Description</h3>

<p>[INTERNAL] Get a layer by its name from a layer object 
created with <code><a href="#topic+make_layer">make_layer</a></code>, e.g., <code><a href="#topic+layers_example">layers_example</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_layer(name, layers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_layer_+3A_name">name</code></td>
<td>
<p>The layer to fetch</p>
</td></tr>
<tr><td><code id="get_layer_+3A_layers">layers</code></td>
<td>
<p>A layers object <code><a href="#topic+layers_example">layers_example</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the layer along with layer names
</p>

<hr>
<h2 id='get_layer_setting'>[INTERNAL] Get layer (and group) settings</h2><span id='topic+get_layer_setting'></span>

<h3>Description</h3>

<p>Returns specified setting for a specific network layer (and group).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_layer_setting(layer, group, settings, setting_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_layer_setting_+3A_layer">layer</code></td>
<td>
<p>[list] A network layer created by <code><a href="#topic+make_layer">make_layer</a></code></p>
</td></tr>
<tr><td><code id="get_layer_setting_+3A_group">group</code></td>
<td>
<p>[string] A network group</p>
</td></tr>
<tr><td><code id="get_layer_setting_+3A_settings">settings</code></td>
<td>
<p>[list] Named list of settings created by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code></p>
</td></tr>
<tr><td><code id="get_layer_setting_+3A_setting_name">setting_name</code></td>
<td>
<p>[string] String indicating the setting to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Setting value(s) for this layer (and group)
</p>

<hr>
<h2 id='graph_metrics'>[INTERNAL] Analysis of metrics of an iGraph object</h2><span id='topic+graph_metrics'></span>

<h3>Description</h3>

<p>[INTERNAL] This helper function prints or returns multiple metrics of arbitrary
iGraph graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_metrics(graph, verbose = TRUE, return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_metrics_+3A_graph">graph</code></td>
<td>
<p>[igraph] iGraph object to analyze.</p>
</td></tr>
<tr><td><code id="graph_metrics_+3A_verbose">verbose</code></td>
<td>
<p>[bool] If TRUE graph information is printed.</p>
</td></tr>
<tr><td><code id="graph_metrics_+3A_return">return</code></td>
<td>
<p>[bool] If TRUE graph information is returned from function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of metrics including vertex count, edge count, number of components,
size of largest component and the relative frequency of zero degree vertices.
</p>

<hr>
<h2 id='individual_graphs_example'>Individual graphs</h2><span id='topic+individual_graphs_example'></span>

<h3>Description</h3>

<p>Exemplary intermediate pipeline output: Individual graphs example data built by
<code><a href="#topic+generate_individual_graphs">generate_individual_graphs</a></code>. Graphs were created from
<a href="#topic+correlation_matrices_example">correlation_matrices_example</a> and
reduced by the 'pickHardThreshold' reduction method. Used settings were:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>individual_graphs_example
</code></pre>


<h3>Format</h3>

<p>A named list with 2 items.
</p>

<dl>
<dt>graphs</dt><dd><p>A named list with two groups.</p>
</dd>
</dl>

<dl>
<dt>groupA</dt><dd><p>Graphs associated with 'groupA'</p>
</dd>
</dl>

<dl>
<dt>mrna</dt><dd><p>Graph</p>
</dd>
<dt>protein</dt><dd><p>Graph</p>
</dd>
<dt>phosphosite</dt><dd><p>Graph</p>
</dd>
<dt>metabolite</dt><dd><p>Graph</p>
</dd>
</dl>

<dl>
<dt>groupB</dt><dd><p>same structure as 'groupA'</p>
</dd>
</dl>

<dl>
<dt>annotations</dt><dd><p>A named list containing data frames of mappings of assigned node IDs to the
user-provided component identifiers for nodes in 'groupA' or 'groupB' and all nodes</p>
</dd>
</dl>

<dl>
<dt>groupA</dt><dd><p>Annotations associated with 'groupA'</p>
</dd>
</dl>

<dl>
<dt>mrna</dt><dd><p>Data frame</p>
</dd>
<dt>protein</dt><dd><p>Data frame</p>
</dd>
<dt>phosphosite</dt><dd><p>Data frame</p>
</dd>
<dt>metabolite</dt><dd><p>Data frame</p>
</dd>
</dl>

<dl>
<dt>groupB</dt><dd><p>same structure as 'groupA'</p>
</dd>
<dt>both</dt><dd><p>same structure as 'groupA'</p>
</dd>
</dl>




<h3>Details</h3>

<p><code>settings &lt;- drdimont_settings(
                        reduction_method=list(default="pickHardThreshold"),
                        r_squared=list(
                            default=0.8,
                            groupA=list(metabolite=0.45),
                            groupB=list(metabolite=0.15)),
                        cut_vector=list(
                            default=seq(0.3, 0.7, 0.01),
                            metabolite=seq(0.1, 0.65, 0.01)))</code>
</p>
<p>A subset of the original data by Krug et al. (2020) and randomly sampled metabolite
data from <code><a href="#topic+layers_example">layers_example</a></code> was used to generate the correlation
matrices and individual graphs. They were created from data stratified by estrogen
receptor (ER) status: 'groupA' contains data of ER+ patients and 'groupB' of
ER- patients.
</p>


<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and
Targeted Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>

<hr>
<h2 id='install_python_dependencies'>Installs python dependencies needed for interaction score computation</h2><span id='topic+install_python_dependencies'></span>

<h3>Description</h3>

<p>Uses pip (default) or conda as specified to 
install all required Python modules. The Python packages are installed 
into a virtual Python or conda environment called 'r-DrDimont'. 
The following requirements are installed: numpy, tqdm, python-igraph and ray.
The environment is created with reticulate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_python_dependencies(package_manager = "pip")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_python_dependencies_+3A_package_manager">package_manager</code></td>
<td>
<p>[&quot;pip&quot;|&quot;conda&quot;] Package manager to use (default: pip)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to install python dependencies
</p>

<hr>
<h2 id='inter_layer_edgelist_by_id'>[INTERNAL] Inter layer connections by identifiers</h2><span id='topic+inter_layer_edgelist_by_id'></span>

<h3>Description</h3>

<p>[INTERNAL] Returns an edge list defining the connections between two layers of the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_layer_edgelist_by_id(annotation_A, annotation_B, connection, weight = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter_layer_edgelist_by_id_+3A_annotation_a">annotation_A</code>, <code id="inter_layer_edgelist_by_id_+3A_annotation_b">annotation_B</code></td>
<td>
<p>[data.frame] Annotation tables specifying the identifiers of
the nodes of a network</p>
</td></tr>
<tr><td><code id="inter_layer_edgelist_by_id_+3A_connection">connection</code></td>
<td>
<p>[string] String of identifier to connect on</p>
</td></tr>
<tr><td><code id="inter_layer_edgelist_by_id_+3A_weight">weight</code></td>
<td>
<p>[int|vector] Integer or vector specifying the weight of the inter-layer connections.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns from, to and weight
</p>

<hr>
<h2 id='inter_layer_edgelist_by_table'>[INTERNAL] Interaction table to iGraph graph object</h2><span id='topic+inter_layer_edgelist_by_table'></span>

<h3>Description</h3>

<p>[INTERNAL] Returns an edge list defining the connections between two layers of the network
based on an
interaction table supplied by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_layer_edgelist_by_table(
  annotation_A,
  annotation_B,
  interaction_table,
  weight_column
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter_layer_edgelist_by_table_+3A_annotation_a">annotation_A</code>, <code id="inter_layer_edgelist_by_table_+3A_annotation_b">annotation_B</code></td>
<td>
<p>[data.frame] Annotation tables specifying the identifiers of
the nodes of a network</p>
</td></tr>
<tr><td><code id="inter_layer_edgelist_by_table_+3A_interaction_table">interaction_table</code></td>
<td>
<p>[data.frame] Table specifying the interaction / connections between the two layers</p>
</td></tr>
<tr><td><code id="inter_layer_edgelist_by_table_+3A_weight_column">weight_column</code></td>
<td>
<p>[string] Name of the column in 'interaction_table' giving the weight of the
inter-layer edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns from, to and weight
</p>

<hr>
<h2 id='interaction_score_graphs_example'>Interaction score graphs</h2><span id='topic+interaction_score_graphs_example'></span>

<h3>Description</h3>

<p>Exemplary intermediate pipeline output: Interaction score graphs example data built by
<code><a href="#topic+generate_interaction_score_graphs">generate_interaction_score_graphs</a></code> using <a href="#topic+combined_graphs_example">combined_graphs_example</a>
and <a href="#topic+drug_target_edges_example">drug_target_edges_example</a>.
A named list (elements 'groupA' and 'groupB'). Each element contains an iGraph
object containing edge attributes: the correlation values as 'weight' and the
interaction score as 'interactionweight'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction_score_graphs_example
</code></pre>


<h3>Format</h3>

<p>A named list with 2 items.
</p>

<dl>
<dt>groupA</dt><dd><p>iGraph graph object containing the interaction score as weight for groupA.</p>
</dd>
<dt>groupB</dt><dd></dd>
</dl>



<h3>Details</h3>

<p>A subset of the original data by Krug et al. (2020) and randomly sampled metabolite
data from <code><a href="#topic+layers_example">layers_example</a></code> was used to generate the correlation
matrices, individual graphs and combined graphs. They were created from data
stratified by estrogen receptor (ER) status: 'groupA' contains data of ER+
patients and 'groupB' of ER- patients. Drug-gene interactions were used from
The Drug Gene Interaction Database.
</p>


<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and Targeted
Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>
<p>The Drug Gene Interaction Database: <a href="https://www.dgidb.org/">https://www.dgidb.org/</a>
</p>

<hr>
<h2 id='layers_example'>Formatted layers object</h2><span id='topic+layers_example'></span>

<h3>Description</h3>

<p>Exemplary intermediate pipeline output containing a correctly formatted layers list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layers_example
</code></pre>


<h3>Format</h3>

<p>A list with 4 items. Each layer list contains 2 groups and a 'name' element. Each group
contains 'data' and 'identifiers'. The structure for one individual layer:
</p>

<dl>
<dt>groupA</dt><dd><p>Data associated with 'groupA'</p>
</dd>
</dl>

<dl>
<dt>data</dt><dd><p>Raw data. Components (e.g. genes or proteins) in columns, samples in rows</p>
</dd>
<dt>identifiers</dt><dd><p>Data frame containing one column per ID</p>
</dd>
</dl>

<dl>
<dt>groupB</dt><dd><p>Data associated with 'groupB'</p>
</dd>
</dl>

<dl>
<dt>data</dt><dd><p>see above</p>
</dd>
<dt>identifiers</dt><dd><p>see above</p>
</dd>
</dl>

<dl>
<dt>name</dt><dd><p>Name of the layer</p>
</dd>
</dl>



<h3>Details</h3>

<p>List containing four layer items created by <code><a href="#topic+make_layer">make_layer</a></code>.
Each layer contains 'data' and 'identifiers' stratified by group and a 'name'
element giving the layer name. The data contained in this example refers to mRNA,
protein, phosphosite and metabolite layers. The mRNA, protein and phosphosite
data was adapted and reduced from Krug et al. (2020) containing data from the
Clinical Proteomic Tumor Analysis Consortium (CPTAC). The metabolite data was
sampled randomly to generate distributions similar to those reported, e.g., in
Terunuma et al. (2014). The 'data' elements contain the raw data with samples as columns
and molecular entities as rows. The 'identifiers' elements contain layer specific identifiers
for the molecular entities, e.g, gene_name.
</p>


<h3>Source</h3>

<p>Terunuma, Atsushi et al. “MYC-driven accumulation of 2-hydroxyglutarate
is associated with breast cancer prognosis.” The Journal of clinical investigation
vol. 124,1 (2014): 398-412. doi:10.1172/JCI71180
</p>
<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis
and Targeted Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>

<hr>
<h2 id='load_interaction_score_output'>[INTERNAL] Loads output of python script for interaction score calculation</h2><span id='topic+load_interaction_score_output'></span>

<h3>Description</h3>

<p>[INTERNAL] Loads data generated by <code><a href="#topic+calculate_interaction_score">calculate_interaction_score</a></code>. Python output files are
graphs in 'gml' format for each of both groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_interaction_score_output(saving_path, graphB_null)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_interaction_score_output_+3A_saving_path">saving_path</code></td>
<td>
<p>[string] Path to save intermediate output of DrDimont's functions. Default is current working directory.
Directory to use for writing intermediate data when passing input and output between Python and R.
Directory to load python output from</p>
</td></tr>
<tr><td><code id="load_interaction_score_output_+3A_graphb_null">graphB_null</code></td>
<td>
<p>[bool] Specifying if graphB of 'groupB' is given (FALSE) or not (TRUE). (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list (elements 'groupA' and 'groupB'). Each element contains an iGraph object
containing the interaction score as edge attribute.
</p>

<hr>
<h2 id='make_connection'>Specify connection between two individual layers</h2><span id='topic+make_connection'></span>

<h3>Description</h3>

<p>Helper function to transform input data to the required pipeline input format. This helper
function creates a list that specifies the connection between two layers.
The connection can be based on IDs present in the identifiers of both layer or an interaction
table containing a mapping of the connections and edge weights.
Additionally, the supplied input is checked. Allows easy conversion of raw data into the
structure accepted by <code><a href="#topic+run_pipeline">run_pipeline</a></code>.
</p>
<p>__IMPORTANT:__ If a connection is established based on <code>id</code> this ID has to be present in
the identifiers of both layers, they have to be named identically and the IDs have to be formatted
identically as these are matched by an inner join operation (refer to <code><a href="#topic+make_layer">make_layer</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_connection(from, to, connect_on, weight = 1, group = "both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_connection_+3A_from">from</code></td>
<td>
<p>[string] Name of the layer from which the connection should be established</p>
</td></tr>
<tr><td><code id="make_connection_+3A_to">to</code></td>
<td>
<p>[string] Name of the layer to which the connection should be established</p>
</td></tr>
<tr><td><code id="make_connection_+3A_connect_on">connect_on</code></td>
<td>
<p>[string|table] Specifies how the two layers should be connected. This can be based on a
mutual ID or a table specifying interactions. Mutual ID: Character string specifying the name of an identifier
that is present in both layers (e.g., 'NCBI ID' to connect proteins and mRNA). Interaction table: A table mapping
two identifiers of two layers. The columns have exactly the same names as the identifiers of the layers. The table has to
contain an additional column specifying the weight between two components/nodes (see 'weight' argument)</p>
</td></tr>
<tr><td><code id="make_connection_+3A_weight">weight</code></td>
<td>
<p>[int|string] Specifies the edge weight between the layers. This can be supplied as a number
applied to every connection or a column name of the interaction table.
Fixed weight: A umber specifying the weight of every connection between the layers.
Based on interaction table: Character string specifying the name of a column in the
table passed as the 'by' parameter which is used as edge weight. (default: 1)</p>
</td></tr>
<tr><td><code id="make_connection_+3A_group">group</code></td>
<td>
<p>[&quot;A&quot;|&quot;B&quot;|&quot;both&quot;] Group for which to apply the connection. One of 'both', 'A' or 'B'. (default: &quot;both&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list (i.e., an inter-layer connection), that can be supplied to
<code><a href="#topic+run_pipeline">run_pipeline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(metabolite_protein_interactions)

example_inter_layer_connections = list(make_connection(from='mrna', to='protein',
                                           connect_on='gene_name', weight=1),
                                       make_connection(from='protein', to='phosphosite',
                                           connect_on='gene_name', weight=1),
                                       make_connection(from='protein', to='metabolite',
                                           connect_on=metabolite_protein_interactions,
                                           weight='combined_score'))

</code></pre>

<hr>
<h2 id='make_drug_target'>Reformat drug-target-interaction data</h2><span id='topic+make_drug_target'></span>

<h3>Description</h3>

<p>Function to transform input data to required input format for
<code><a href="#topic+run_pipeline">run_pipeline</a></code>. Here the data that is needed to define drug-target interactions is
formatted. When the reformatted output is passed to <code><a href="#topic+run_pipeline">run_pipeline</a></code> as
<code>drug_target_interactions</code> argument, the differential integrated drug response score can be
calculated for all the supplied drugs in <code>interaction_table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_drug_target(target_molecules, interaction_table, match_on)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_drug_target_+3A_target_molecules">target_molecules</code></td>
<td>
<p>[string] Name of layer containing the drug targets. This name has to match the
corresponding named item in the list of layers supplied to <code><a href="#topic+run_pipeline">run_pipeline</a></code>.</p>
</td></tr>
<tr><td><code id="make_drug_target_+3A_interaction_table">interaction_table</code></td>
<td>
<p>[data.frame] Has to contain two columns. A column called 'drug_name' containing
names or identifiers of drugs. And a column with a name that matches an identifier in the layer supplied
in 'target_molecules'. Additional columns will be ignored in the pipeline.
For example, if drugs target proteins and an identifier called 'ncbi_id' was supplied in layer creation of
the protein layer (see <code><a href="#topic+make_layer">make_layer</a></code>), this column should be called
'ncbi_id' and contain the corresponding IDs of protein-drug targets. Any other ID present in
the constructed layer could also be used.</p>
</td></tr>
<tr><td><code id="make_drug_target_+3A_match_on">match_on</code></td>
<td>
<p>[string] Column name of the data frame supplied in 'interaction_table' that is used for
matching drugs and target nodes in the graph (e.g. 'ncbi_id').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of the input parameters in input format of <code><a href="#topic+run_pipeline">run_pipeline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(drug_gene_interactions)

example_drug_target_interactions &lt;- make_drug_target(target_molecules='protein',
                                        interaction_table=drug_gene_interactions,
                                        match_on='gene_name')

</code></pre>

<hr>
<h2 id='make_layer'>Creates individual molecular layers from raw data and unique identifiers</h2><span id='topic+make_layer'></span>

<h3>Description</h3>

<p>Helper function to transform input data to required pipeline input format. Additionally, the
supplied input is checked. Allows easy conversion of raw data into the structure accepted by
<code><a href="#topic+run_pipeline">run_pipeline</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_layer(
  name,
  data_groupA,
  data_groupB,
  identifiers_groupA,
  identifiers_groupB
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_layer_+3A_name">name</code></td>
<td>
<p>[string] Name of the layer.</p>
</td></tr>
<tr><td><code id="make_layer_+3A_data_groupa">data_groupA</code>, <code id="make_layer_+3A_data_groupb">data_groupB</code></td>
<td>
<p>[data.frame] Data frame containing raw molecular data of each group
(each stratum). Analyzed components (e.g. genes) in columns, samples (e.g. patients) in rows.</p>
</td></tr>
<tr><td><code id="make_layer_+3A_identifiers_groupa">identifiers_groupA</code>, <code id="make_layer_+3A_identifiers_groupb">identifiers_groupB</code></td>
<td>
<p>[data.frame] Data frame containing component identifiers
(columns) of each component (rows) in the same order as the molecular data frame of each group.
These identifiers are used to (a) interconnect graphs and (b) match drugs to drug targets.
Must contain a column 'type' which identifies the nature of the component (e.g., &quot;protein&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list containing the supplied data for each group (i.e., the data set for one
layer), that can be supplied to <code><a href="#topic+run_pipeline">run_pipeline</a></code> and 'name' giving the name of the
layer. Each sub-list contains the 'data' and the 'identifiers'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(protein_data)

example_protein_layer &lt;- make_layer(
                             name="protein",
                             data_groupA=protein_data$groupA[, c(-1,-2)],
                             data_groupB=protein_data$groupB[, c(-1,-2)],
                             identifiers_groupA=data.frame(
                                 gene_name=protein_data$groupA$gene_name,
                                 ref_seq=protein_data$groupA$ref_seq),
                             identifiers_groupB=data.frame(
                                 gene_name=protein_data$groupB$gene_name,
                                 ref_seq=protein_data$groupB$ref_seq))

</code></pre>

<hr>
<h2 id='metabolite_data'>Metabolomics data</h2><span id='topic+metabolite_data'></span>

<h3>Description</h3>

<p>Metabolomics analysis of breast cancer patients data sampled randomly to
generate distributions similar to those reported (e.g., in Terunuma et al. (2014)).
The data is stratified by estrogen receptor (ER) expression status ('groupA' = ER+, 'groupB' = ER-). 
The data was reduced to 50 metabolites. 
For each group a data frame is given containing the raw data with the metabolites as rows and the
samples as columns. The first three columns contain the metabolite identifiers
(biochemical_name, metabolon_id and pubchem_id).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metabolite_data
</code></pre>


<h3>Format</h3>


<dl>
<dt>groupA</dt><dd><p>ER+ data; data.frame: first three columns contain metabolite identifiers
biochemical_name, metabolon_id and pubchem_id;
other columns are samples containing the quantified metabolite data per metabolite</p>
</dd>
<dt>groupB</dt><dd><p>ER- data; data.frame: first three columns contain metabolite identifiers
biochemical_name, metabolon_id and pubchem_id;
other columns are samples containing the quantified metabolite data per metabolite</p>
</dd>
</dl>



<h3>Source</h3>

<p>Terunuma, Atsushi et al. “MYC-driven accumulation of 2-hydroxyglutarate is associated
with breast cancer prognosis.”
The Journal of clinical investigation vol. 124,1 (2014): 398-412. doi:10.1172/JCI71180
</p>
<p><a href="https://www.metabolon.com">https://www.metabolon.com</a>
</p>
<p>Pubchem IDs: <a href="https://pubchem.ncbi.nlm.nih.gov">https://pubchem.ncbi.nlm.nih.gov</a>
</p>
<p>MetaboAnalyst: <a href="https://www.metaboanalyst.ca/faces/upload/ConvertView.xhtml">https://www.metaboanalyst.ca/faces/upload/ConvertView.xhtml</a>
</p>

<hr>
<h2 id='metabolite_protein_interactions'>Metabolite protein interaction data</h2><span id='topic+metabolite_protein_interactions'></span>

<h3>Description</h3>

<p>Data frame providing interactions of metabolites and proteins. The data was taken
from the STITCH Database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metabolite_protein_interactions
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns.
</p>

<dl>
<dt>pubchem_id</dt><dd><p>Pubchem IDs defining interacting metabolites</p>
</dd>
<dt>gene_name</dt><dd><p>gene names defining interacting proteins</p>
</dd>
<dt>combined_score</dt><dd><p>Score describing the strength of metabolite-protein interaction</p>
</dd>
</dl>



<h3>Source</h3>

<p>STITCH DB: <a href="http://stitch.embl.de/">http://stitch.embl.de/</a>
</p>
<p>Pubchem IDs: <a href="https://pubchem.ncbi.nlm.nih.gov">https://pubchem.ncbi.nlm.nih.gov</a>
</p>
<p>STRING DB: <a href="https://string-db.org/">https://string-db.org/</a>
</p>

<hr>
<h2 id='mrna_data'>mRNA expression data</h2><span id='topic+mrna_data'></span>

<h3>Description</h3>

<p>mRNA analysis of breast cancer patients data from Krug et al. (2020) (data from the Clinical
Proteomic Tumor Analysis Consortium (CPTAC)). The data is stratified by estrogen receptor (ER)
expression status ('groupA' = ER+, 'groupB' = ER-). The data was reduced to 50 genes.
For each group a data frame is given containing the raw data with the mRNA/gene as rows and the
samples as columns. The first column contains the gene identifiers (gene_name).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrna_data
</code></pre>


<h3>Format</h3>


<dl>
<dt>groupA</dt><dd><p>ER+ data; data.frame: first column contains mRNA/gene identifier gene_name;
other columns are samples containing the quantified mRNA data per gene</p>
</dd>
<dt>groupB</dt><dd><p>ER- data; data.frame: first column contains mRNA/gene identifier gene_name;
other columns are samples containing the quantified mRNA data per gene</p>
</dd>
</dl>



<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and Targeted
Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>

<hr>
<h2 id='network_reduction_by_p_value'>[INTERNAL] Reduce the the entries in an adjacency matrix by thresholding on p-values</h2><span id='topic+network_reduction_by_p_value'></span>

<h3>Description</h3>

<p>[INTERNAL] This function reduces an adjacency matrix of correlations based on p-values.
If computations are done non-parallel <code><a href="WGCNA.html#topic+corPvalueStudent">corPvalueStudent</a></code> is used. If computations
are done in parallel, our own parallel implementation (<code><a href="#topic+corPvalueStudentParallel">corPvalueStudentParallel</a></code>)
of this function to calculate Student asymptotic p-values taking the number of samples into account is used.
P-values are adjusted using <a href="stats.html#topic+p.adjust">p.adjust</a> function. The upper triangle without diagonal entries
of the adjacency matrix is passed for faster computation. P-values can be adjusted using one
of several methods. A significance threshold 'alpha' can be set. All value entries below this threshold within the
initial adjacency matrix will be set to NA. If a default cluster is registered with the 'parallel' package the
computation will happen in parallel automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_reduction_by_p_value(
  adjacency_matrix,
  number_of_samples,
  p_value_adjustment_method = "BH",
  reduction_alpha = 0.05,
  parallel_chunk_size = 10^6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_reduction_by_p_value_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>[matrix] Adjacency matrix of correlations computed using <code><a href="WGCNA.html#topic+cor">cor</a></code> in
<code><a href="#topic+compute_correlation_matrices">compute_correlation_matrices</a></code></p>
</td></tr>
<tr><td><code id="network_reduction_by_p_value_+3A_number_of_samples">number_of_samples</code></td>
<td>
<p>[int|matrix] The number of samples used to calculate the correlation matrix. Computed applying
<code><a href="#topic+sample_size">sample_size</a></code></p>
</td></tr>
<tr><td><code id="network_reduction_by_p_value_+3A_p_value_adjustment_method">p_value_adjustment_method</code></td>
<td>
<p>[&quot;holm&quot;|&quot;hochberg&quot;|&quot;hommel&quot;|&quot;bonferroni&quot;|&quot;BH&quot;|&quot;BY&quot;|&quot;fdr&quot;|&quot;none&quot;] String
of the correction method applied to p-values. Passed to <a href="stats.html#topic+p.adjust">p.adjust</a>. (default: &quot;BH&quot;)</p>
</td></tr>
<tr><td><code id="network_reduction_by_p_value_+3A_reduction_alpha">reduction_alpha</code></td>
<td>
<p>[float] A number indicating the significance value for correlation p-values
during reduction. Not-significant edges are dropped. (default: 0.05)</p>
</td></tr>
<tr><td><code id="network_reduction_by_p_value_+3A_parallel_chunk_size">parallel_chunk_size</code></td>
<td>
<p>[int] Number of p-values in smallest work unit when computing in parallel
during network reduction with method 'p_value'. (default: 10^6)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reduced adjacency matrix with NA's at martix entries with p-values below threshold.
</p>


<h3>Source</h3>

<p><code><a href="WGCNA.html#topic+corPvalueStudent">corPvalueStudent</a></code>
</p>

<hr>
<h2 id='network_reduction_by_pickHardThreshold'>[INTERNAL] Reduces network based on WGCNA::pickHardThreshold function</h2><span id='topic+network_reduction_by_pickHardThreshold'></span>

<h3>Description</h3>

<p>[INTERNAL] This function uses <code><a href="WGCNA.html#topic+pickHardThreshold.fromSimilarity">pickHardThreshold.fromSimilarity</a></code> to analyze
scale free topology for multiple hard thresholds. A cutoff is estimated, if no cutoff is
found the function terminates with an error message. All values below the cutoff will be set to NA and the
reduced adjacency is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_reduction_by_pickHardThreshold(
  adjacency_matrix,
  r_squared_cutoff = 0.85,
  cut_vector = seq(0.2, 0.8, by = 0.01),
  mean_number_edges = NULL,
  edge_density = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_reduction_by_pickHardThreshold_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>[matrix] Adjacency matrix of correlations computed using <code><a href="WGCNA.html#topic+cor">cor</a></code> in
<code><a href="#topic+compute_correlation_matrices">compute_correlation_matrices</a></code></p>
</td></tr>
<tr><td><code id="network_reduction_by_pickHardThreshold_+3A_r_squared_cutoff">r_squared_cutoff</code></td>
<td>
<p>[float] A number indicating the desired minimum scale free topology fitting index R^2 for reduction
using <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code>. (default: 0.85)</p>
</td></tr>
<tr><td><code id="network_reduction_by_pickHardThreshold_+3A_cut_vector">cut_vector</code></td>
<td>
<p>[sequence of float] A vector of hard threshold cuts for which the scale free topology fit indices are to
be calculated during reduction with <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code>. (default: seq(0.2, 0.8, by = 0.01))</p>
</td></tr>
<tr><td><code id="network_reduction_by_pickHardThreshold_+3A_mean_number_edges">mean_number_edges</code></td>
<td>
<p>[int] Find a suitable edge weight cutoff employing <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code> to reduce
the network to at most the specified mean number of edges. Attention: This parameter overwrites the 'r_squared_cutoff' and
'edge_density' parameters if not set to NULL. (default: NULL)</p>
</td></tr>
<tr><td><code id="network_reduction_by_pickHardThreshold_+3A_edge_density">edge_density</code></td>
<td>
<p>[float] Find a suitable edge weight cutoff employing <code><a href="WGCNA.html#topic+pickHardThreshold">pickHardThreshold</a></code> to reduce the
network to at most the specified edge density. Attention: This parameter overwrites the 'r_squared_cutoff' parameter if not set
to NULL. (default: NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reduced adjacency matrix of correlations with NA's inserted at positions below
estimated cutoff.
</p>


<h3>Source</h3>

<p>The original implementation of pickHardThreshold is used from
<code><a href="WGCNA.html#topic+pickHardThreshold.fromSimilarity">pickHardThreshold.fromSimilarity</a></code>
</p>

<hr>
<h2 id='phosphosite_data'>Phosphosite data</h2><span id='topic+phosphosite_data'></span>

<h3>Description</h3>

<p>Phosphosite analysis of breast cancer patients data from Krug et al. (2020) (data from the Clinical
Proteomic Tumor Analysis Consortium (CPTAC)). The data is stratified by estrogen receptor (ER)
expression status ('groupA' = ER+, 'groupB' = ER-). The data was reduced to 50 genes.
For each group a data frame is given containing the raw data with the phosphosites as rows and the
samples as columns. The first three columns contain the phosphosite and protein identifiers
(site_id, ref_seq and gene_name).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phosphosite_data
</code></pre>


<h3>Format</h3>


<dl>
<dt>groupA</dt><dd><p>ER+ data; data.frame: first three columns contain phosphosite and protein identifiers
site_id, ref_seq and gene_name;
other columns are samples containing the quantified phosphosite data per phosphosite</p>
</dd>
<dt>groupB</dt><dd><p>ER- data; data.frame: first three columns contain phosphosite and protein identifiers
site_id, ref_seq and gene_name;
other columns are samples containing the quantified phosphosite data per phosphosite</p>
</dd>
</dl>



<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and Targeted
Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>

<hr>
<h2 id='protein_data'>Protein data</h2><span id='topic+protein_data'></span>

<h3>Description</h3>

<p>Protein analysis of breast cancer patients data from Krug et al. (2020) (data from the Clinical
Proteomic Tumor Analysis Consortium (CPTAC)). The data is stratified by estrogen receptor (ER)
expression status ('groupA' = ER+, 'groupB' = ER-). The data was reduced to 50 genes.
For each group a data frame is given containing the raw data with the proteins as rows and the
samples as columns. The first two columns contain the protein identifiers
(ref_seq and gene_name).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protein_data
</code></pre>


<h3>Format</h3>


<dl>
<dt>groupA</dt><dd><p>ER+ data; data.frame: first two columns contain protein identifiers ref_seq and gene_name;
other columns are samples containing the quantified proteomics data per protein</p>
</dd>
<dt>groupB</dt><dd><p>ER- data; data.frame: first two columns contain protein identifiers ref_seq and gene_name;
other columns are samples containing the quantified proteomics data per protein</p>
</dd>
</dl>



<h3>Source</h3>

<p>Krug, Karsten et al. “Proteogenomic Landscape of Breast Cancer Tumorigenesis and Targeted
Therapy.” Cell vol. 183,5 (2020): 1436-1456.e31. doi:10.1016/j.cell.2020.10.036
</p>

<hr>
<h2 id='return_errors'>Return detected errors in the input data</h2><span id='topic+return_errors'></span>

<h3>Description</h3>

<p>Throws an error in case errors have been passed to the function. Messages
describing the detected errors are printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_errors(errors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_errors_+3A_errors">errors</code></td>
<td>
<p>[string] Character string vector containing error messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, writes error messages to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(layers_example)
data(metabolite_protein_interactions)
data(drug_gene_interactions)
data

all_layers &lt;- layers_example

all_inter_layer_connections = list(
    make_connection(from='mrna', to='protein', connect_on='gene_name', weight=1),
    make_connection(from='protein', to='phosphosite', connect_on='gene_name', weight=1),
    make_connection(from='protein', to='metabolite',
    connect_on=metabolite_protein_interactions, weight='combined_score'))

all_drug_target_interactions &lt;- make_drug_target(
                                    target_molecules="protein",
                                    interaction_table=drug_gene_interactions,
                                    match_on="gene_name")

return_errors(check_input(layers=all_layers,
    inter_layer_connections=all_inter_layer_connections,
    drug_target_interactions=all_drug_target_interactions))


</code></pre>

<hr>
<h2 id='run_pipeline'>Execute all DrDimont pipeline steps sequentially</h2><span id='topic+run_pipeline'></span>

<h3>Description</h3>

<p>This wrapper function executes all necessary steps to generate differential integrated
drug response scores from the formatted input data. The following input data is required
(and detailed below):
</p>
<p>* Layers of stratified molecular data.
</p>
<p>* Additional connections between the layers.
</p>
<p>* Interactions between drugs and nodes in the network.
</p>
<p>* Settings for pipeline execution.
</p>
<p>As this function runs through all steps of the DrDimont pipeline it can take a long time to complete,
especially if the supplied molecular data is rather large. Several prompts will be printed to supply
information on how the pipeline is proceeding. Calculation of the interaction score by
<code><a href="#topic+generate_interaction_score_graphs">generate_interaction_score_graphs</a></code> requires saving large-scale graphs to file and calling
a Python script. This handover may take time.
</p>
<p>Eventually a data frame is returned containing the supplied drug name and its associated
differential drug response score computed by DrDimont.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_pipeline(
  layers,
  inter_layer_connections,
  drug_target_interactions,
  settings
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_pipeline_+3A_layers">layers</code></td>
<td>
<p>[list] Named list with different network layers containing data and identifiers for
both groups. The required input format is a list with names corresponding to the content of
the respective layer (e.g., &quot;protein&quot;). Each named element has to contain the molecular data
and corresponding identifiers formatted by <code><a href="#topic+make_layer">make_layer</a></code>.</p>
</td></tr>
<tr><td><code id="run_pipeline_+3A_inter_layer_connections">inter_layer_connections</code></td>
<td>
<p>[list] A list with specified inter-layer connections. This list
contains one or more elements defining individual inter-layer connections created by
<code><a href="#topic+make_connection">make_connection</a></code>.</p>
</td></tr>
<tr><td><code id="run_pipeline_+3A_drug_target_interactions">drug_target_interactions</code></td>
<td>
<p>[list] A list specifying drug-target interactions for drug response
score computation. The required input format of this list is created by
<code><a href="#topic+make_drug_target">make_drug_target</a></code>. The drug response score is calculated for all drugs contained
in this object.</p>
</td></tr>
<tr><td><code id="run_pipeline_+3A_settings">settings</code></td>
<td>
<p>[list] A named list containing pipeline settings. The settings list has to be
initialized by <code><a href="#topic+drdimont_settings">drdimont_settings</a></code>. Items in the named list can be
adjusted as desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing drug name and associated differential integrated drug response score.
If Python is not installed or the interaction score computation fails for some other reason, NULL
is returned instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(drug_gene_interactions)
data(metabolite_protein_interactions)
data(layers_example)

example_inter_layer_connections = list(make_connection(from='mrna', to='protein',
                                           connect_on='gene_name', weight=1),
                                       make_connection(from='protein', to='phosphosite',
                                           connect_on='gene_name', weight=1),
                                       make_connection(from='protein', to='metabolite',
                                           connect_on=metabolite_protein_interactions,
                                           weight='combined_score'))

example_drug_target_interactions &lt;- make_drug_target(target_molecules='protein',
                                        interaction_table=drug_gene_interactions,
                                        match_on='gene_name')

example_settings &lt;- drdimont_settings(
                        handling_missing_data=list(
                            default="pairwise.complete.obs",
                            mrna="all.obs"),
                        reduction_method="pickHardThreshold",
                        r_squared=list(default=0.65, metabolite=0.1),
                        cut_vector=list(default=seq(0.2, 0.65, 0.01)))


run_pipeline(
    layers=layers_example, 
    inter_layer_connections=example_inter_layer_connections, 
    drug_target_interactions=example_drug_target_interactions, 
    settings=example_settings)


</code></pre>

<hr>
<h2 id='sample_size'>[INTERNAL] Sample size for correlation computation</h2><span id='topic+sample_size'></span>

<h3>Description</h3>

<p>[INTERNAL] Depending on how missing data is handled in correlation matrix computation,
the number of samples used is returned. If 'all.obs' is specified the number of rows (i.e. samples)
of the original data is returned. If 'pairwise.complete.obs' is specified the crossproduct of a
matrix indicating the non-NA values is returned as matrix. This implementation was adopted
from <code><a href="WGCNA.html#topic+corAndPvalue">corAndPvalue</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_size(measurement_data, handling_missing_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_size_+3A_measurement_data">measurement_data</code></td>
<td>
<p>[data.frame] Data frame containing the respective raw data (e.g. mRNA expression data,
protein abundance, etc.) to the adjacency matrix. Analyzed components (e.g. genes) in rows, samples (e.g. patients)
in columns.</p>
</td></tr>
<tr><td><code id="sample_size_+3A_handling_missing_data">handling_missing_data</code></td>
<td>
<p>[&quot;all.obs&quot;|&quot;pairwise.complete.obs&quot;] Specifying the handling
of missing data during correlation matrix computation. (default: all.obs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For 'all.obs' returns an integer indicating the number of samples in the supplied
matrix (i.e. number of rows). For 'pairwise.complete.obs' returns a matrix in the same size
of the correlation matrix indicating the number of samples for each correlation calculation.
</p>


<h3>Source</h3>

<p>Method to calculate samples in 'pairwise.complete.obs' adopted and improved from
<code><a href="WGCNA.html#topic+corAndPvalue">corAndPvalue</a></code>
</p>

<hr>
<h2 id='set_cluster'>[INTERNAL] Create and register cluster</h2><span id='topic+set_cluster'></span>

<h3>Description</h3>

<p>[INTERNAL] Helper function to create and register a cluster for parallel
computation of p-value reduction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_cluster(n_threads)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_cluster_+3A_n_threads">n_threads</code></td>
<td>
<p>[int] Number of nodes in the cluster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called internally to create cluster
</p>

<hr>
<h2 id='shutdown_cluster'>[INTERNAL] Shutdown cluster and remove corresponding connections</h2><span id='topic+shutdown_cluster'></span>

<h3>Description</h3>

<p>[INTERNAL] Run this if the pipeline fails during parallel 
computation to clean the state. If a cluster is registered, this functions 
stops it and removes corresponding connections. Ignores errors. Has no effect 
if no cluster is registered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shutdown_cluster()
</code></pre>


<h3>Value</h3>

<p>No return value, called internally to shutdown cluster
</p>

<hr>
<h2 id='target_edge_list'>[INTERNAL] Get edges adjacent to target nodes</h2><span id='topic+target_edge_list'></span>

<h3>Description</h3>

<p>[INTERNAL] Based on the supplied graph and target nodes this function returns a
list of edges that are directly adjacent to target nodes. These edges can be used for further
computation to compute the integrated interaction scores and differential scores in the networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_edge_list(graph, target_nodes, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target_edge_list_+3A_graph">graph</code></td>
<td>
<p>[igraph] Combined graph (iGraph graph object) for a specific group</p>
</td></tr>
<tr><td><code id="target_edge_list_+3A_target_nodes">target_nodes</code></td>
<td>
<p>[data.frame] Has column 'node_id' (unique node IDs in the iGraph graph
object that are targeted by drugs) and columns 'groupA' and 'groupB' (bool values specifying
whether the node is contained in the combined graph of the group)</p>
</td></tr>
<tr><td><code id="target_edge_list_+3A_group">group</code></td>
<td>
<p>[string] Indicates which group 'groupA' or 'groupB' is analyzed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge list as a data frame.
</p>

<hr>
<h2 id='write_interaction_score_input'>[INTERNAL] Write edge lists and combined graphs to files</h2><span id='topic+write_interaction_score_input'></span>

<h3>Description</h3>

<p>[INTERNAL] Writes the combined graphs and the drug target edge lists to files for
passing them to the python interaction score script.
Graphs are saved as 'gml' file. Edge lists are saved as 'tsv' file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_interaction_score_input(
  combined_graphs,
  drug_target_edgelists,
  saving_path
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_interaction_score_input_+3A_combined_graphs">combined_graphs</code></td>
<td>
<p>[list] A named list (elements 'groupA' and 'groupB'). Each element contains the
entire combined network (layers + inter-layer connections) as iGraph graph object.</p>
</td></tr>
<tr><td><code id="write_interaction_score_input_+3A_drug_target_edgelists">drug_target_edgelists</code></td>
<td>
<p>[list] A named list (elements 'groupA' and 'groupB'). Each element
contains the list of edges to be considered in the interaction score calculation as data frame (columns 'from', 'to' and 'weight')</p>
</td></tr>
<tr><td><code id="write_interaction_score_input_+3A_saving_path">saving_path</code></td>
<td>
<p>[string] Path to save intermediate output of DrDimont's functions.
Default is current working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used internally
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
