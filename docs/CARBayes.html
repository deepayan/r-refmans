<!DOCTYPE html><html lang="en"><head><title>Help for package CARBayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CARBayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CARBayes-package'>
<p>Spatial Generalised Linear Mixed Models for Areal Unit Data</p></a></li>
<li><a href='#fitted.CARBayes'>
<p>Extract the fitted values from a model.</p></a></li>
<li><a href='#highlight.borders'>
<p>Creates an sf data.frame object (from the sf package) identifying a subset of borders</p>
between neighbouring areas.</a></li>
<li><a href='#logLik.CARBayes'>
<p>Extract the estimated loglikelihood from a fitted model.</p></a></li>
<li><a href='#model.matrix.CARBayes'>
<p>Extract the model (design) matrix from a model.</p></a></li>
<li><a href='#MVS.CARleroux'>
<p>Fit a multivariate spatial generalised linear mixed model to data, where the</p>
random effects are modelled by a multivariate conditional autoregressive model.</a></li>
<li><a href='#print.CARBayes'>
<p>Print a summary of a fitted CARBayes model to the screen.</p></a></li>
<li><a href='#residuals.CARBayes'>
<p>Extract the residuals from a model.</p></a></li>
<li><a href='#S.CARbym'>
<p>Fit a spatial generalised linear mixed model to data, where the random effects</p>
have a BYM conditional autoregressive prior.</a></li>
<li><a href='#S.CARdissimilarity'>
<p>Fit a spatial generalised linear mixed model to data, where the random effects</p>
have a localised conditional autoregressive prior.</a></li>
<li><a href='#S.CARleroux'>
<p>Fit a spatial generalised linear mixed model to data, where the random effects</p>
have a Leroux conditional autoregressive prior.</a></li>
<li><a href='#S.CARlocalised'>
<p>Fit a spatial generalised linear mixed model to data, where a set of spatially</p>
smooth random effects  are augmented with a piecewise constant intercept process.</a></li>
<li><a href='#S.CARmultilevel'>
<p>Fit a spatial generalised linear mixed model  to multi-level areal unit data,</p>
where the spatial random effects have a Leroux conditional autoregressive
prior.</a></li>
<li><a href='#S.glm'>
<p>Fit a generalised linear model to data.</p></a></li>
<li><a href='#S.RAB'>
<p>Fit a spatial generalised linear model with anisotropic basis functions to data</p>
for computationally efficient localised spatial smoothing, where the parameters
are estimated by penalised maximum likelihood estimation with a ridge regression
penalty.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Generalised Linear Mixed Models for Areal Unit Data</td>
</tr>
<tr>
<td>Version:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Duncan Lee</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Duncan Lee &lt;Duncan.Lee@glasgow.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a class of univariate and multivariate spatial generalised linear mixed models for areal unit data, with inference in a Bayesian setting using Markov chain Monte Carlo (MCMC) simulation using a single or multiple Markov chains. The response variable can be binomial, Gaussian, multinomial, Poisson or zero-inflated Poisson (ZIP), and spatial autocorrelation is modelled by a set of random effects that are assigned a conditional autoregressive (CAR) prior distribution. A number of different models are available for univariate spatial data, including models with no random effects as well as random effects modelled by different types of CAR prior, including the BYM model (Besag et al., 1991, &lt;<a href="https://doi.org/10.1007%2FBF00116466">doi:10.1007/BF00116466</a>&gt;) and Leroux model (Leroux et al., 2000, &lt;<a href="https://doi.org/10.1007%2F978-1-4612-1284-3_4">doi:10.1007/978-1-4612-1284-3_4</a>&gt;). Additionally,  a multivariate CAR (MCAR) model for multivariate spatial data is available, as is a two-level hierarchical model for modelling data relating to individuals within areas. Full details are given in the vignette accompanying this package. The initial creation of this package was supported by the Economic and Social Research Council (ESRC) grant RES-000-22-4256, and on-going development has been supported by the Engineering and Physical Science Research Council (EPSRC) grant EP/J017442/1, ESRC grant ES/K006460/1, Innovate UK / Natural Environment Research Council (NERC) grant NE/N007352/1 and the TB Alliance. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>MASS, R (&ge; 3.5.0), Rcpp (&ge; 0.11.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>CARBayesdata, coda, dplyr, GGally, glmnet, igraph, mapview,
MCMCpack, parallel, RColorBrewer, sf, spam, spdep, stats,
truncnorm, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/duncanplee/CARBayes">https://github.com/duncanplee/CARBayes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/duncanplee/CARBayes/issues">https://github.com/duncanplee/CARBayes/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 10:34:09 UTC; duncanlee</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-08 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CARBayes-package'>
Spatial Generalised Linear Mixed Models for Areal Unit Data
</h2><span id='topic+CARBayes-package'></span><span id='topic+CARBayes'></span>

<h3>Description</h3>

<p>Implements a class of univariate and multivariate spatial generalised linear mixed 
models for areal unit data, with inference in a Bayesian setting using Markov chain 
Monte Carlo (MCMC) simulation using a single or multiple Markov chains. The response 
variable can be binomial, Gaussian, multinomial, Poisson or zero-inflated Poisson 
(ZIP), and spatial autocorrelation is modelled by  a set of random effects that 
are assigned a conditional autoregressive (CAR) prior distribution. A number of 
different models are available for univariate spatial data, including models with 
no random effects as well as random effects modelled by different types of CAR 
prior, including the BYM model (Besag et al., 1991, &lt;doi:10.1007/BF00116466&gt;) 
and the Leroux model (Leroux et al., 2000, &lt;doi:10.1007/978-1-4612-1284-3_4&gt;). 
Additionally,  a multivariate CAR (MCAR) model for multivariate spatial data is 
available, as is a two-level hierarchical  model for modelling data relating to 
individuals within areas. Full details are given in the vignette accompanying this 
package. The initial creation of this package was supported by the Economic and 
Social Research Council (ESRC) grant RES-000-22-4256, and on-going development 
has been supported by the Engineering and Physical Science Research Council (EPSRC) 
grant EP/J017442/1, ESRC grant ES/K006460/1, Innovate UK / Natural Environment 
Research Council (NERC) grant NE/N007352/1 and the TB Alliance.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CARBayes</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 6.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Maintainer: Duncan Lee &lt;Duncan.Lee@glasgow.ac.uk&gt;
</p>


<h3>References</h3>

<p>Besag, J. and  York, J and Mollie, A (1991). Bayesian image restoration with two 
applications in spatial statistics. Annals of the Institute of Statistics and 
Mathematics 43, 1-59.
</p>
<p>Gelfand, A and Vounatsou, P (2003). Proper multivariate conditional autoregressive
models for spatial data analysis, Biostatistics, 4, 11-25.
</p>
<p>Kavanagh, L., D. Lee, and G. Pryce (2016). Is Poverty Decentralising? Quantifying 
Uncertainty in the Decentralisation of Urban Poverty, Annals of the American 
Association of Geographers, 106, 1286-1298.
</p>
<p>Lee, D. and Mitchell, R (2012). Boundary detection in disease mapping studies. 
Biostatistics, 13, 415-426.
</p>
<p>Lee, D and Sarran, C  (2015). Controlling for unmeasured confounding and spatial 
misalignment in long-term air pollution and health studies, Environmetrics, 26, 
477-487.
</p>
<p>Lee, D (2024). Computationally efficient localised spatial smoothing of disease 
rates using anisotropic basis functions and penalised regression fitting, 
Spatial Statistics, 59, 100796.
</p>
<p>Leroux B, Lei X, Breslow N (2000). &quot;Estimation of Disease Rates in SmallAreas: A 
New Mixed Model for Spatial Dependence.&quot; In M Halloran, D Berry (eds.), 
<em>Statistical Models in Epidemiology, the Environment and Clinical Trials</em>,
pp. 179-191. Springer-Verlag, New York.
</p>
<p>Roberts, G and Rosenthal, J (1998). Optimal scaling of discrete approximations to
the Langevin diffusions, Journal of the Royal Statistical Society Series B 60, 
255-268.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the examples in the function specific help files and in the vignette
## accompanying this package.
</code></pre>

<hr>
<h2 id='fitted.CARBayes'>
Extract the fitted values from a model.
</h2><span id='topic+fitted.CARBayes'></span>

<h3>Description</h3>

<p>This function takes a CARBayes object and returns the vector of fitted
values (posterior means).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'CARBayes'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.CARBayes_+3A_object">object</code></td>
<td>

<p>A CARBayes fitted model object.
</p>
</td></tr>
<tr><td><code id="fitted.CARBayes_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>

<hr>
<h2 id='highlight.borders'>
Creates an sf data.frame object (from the sf package) identifying a subset of borders 
between neighbouring areas.
</h2><span id='topic+highlight.borders'></span>

<h3>Description</h3>

<p>Creates an sf data.frame object (from the sf package) identifying a subset of borders 
between neighbouring areas, which allows them to be overlayed on a map. 
An example is given in the vignette accompanying this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight.borders(border.locations, sfdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="highlight.borders_+3A_border.locations">border.locations</code></td>
<td>

<p>A K by K matrix, where K is the number of areas, containing 3 distinct values: 
NA for non-neighbouring areas; 0 for borders between neighbouring areas to be 
highlighted on a map; and 1 for borders between neighbouring areas not to be 
highlighted on a map.
</p>
</td></tr>
<tr><td><code id="highlight.borders_+3A_sfdata">sfdata</code></td>
<td>

<p>An sf data.frame (from the sf package) object used for plotting the data and 
creating the original neighbourhood matrix W.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf data.frame object from the sf package, which contains the vertices of all the 
borders to be highlighted on the map.  The mapping can be done using the mapview
package, see the vignette accompanying this package for an example.
</p>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the vignette accompanying this package for an example of its use.
</code></pre>

<hr>
<h2 id='logLik.CARBayes'>
Extract the estimated loglikelihood from a fitted model.
</h2><span id='topic+logLik.CARBayes'></span>

<h3>Description</h3>

<p>This function takes a CARBayes object and returns the estimated loglikelihood
(posterior means).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'CARBayes'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.CARBayes_+3A_object">object</code></td>
<td>

<p>A CARBayes fitted model object.
</p>
</td></tr>
<tr><td><code id="logLik.CARBayes_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>

<hr>
<h2 id='model.matrix.CARBayes'>
Extract the model (design) matrix from a model.
</h2><span id='topic+model.matrix.CARBayes'></span>

<h3>Description</h3>

<p>This function takes a CARBayes object and returns the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'CARBayes'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrix.CARBayes_+3A_object">object</code></td>
<td>

<p>A CARBayes fitted model object.
</p>
</td></tr>
<tr><td><code id="model.matrix.CARBayes_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>

<hr>
<h2 id='MVS.CARleroux'>
Fit a multivariate spatial generalised linear mixed model to data, where the 
random effects are modelled by a multivariate conditional autoregressive model.
</h2><span id='topic+MVS.CARleroux'></span>

<h3>Description</h3>

<p>Fit a multivariate spatial generalised linear mixed model to areal unit data, 
where the response variable can be binomial, Gaussian, multinomial or Poisson. 
The linear predictor is modelled by known covariates and a vector of random 
effects. The latter account for both spatial and between variable correlation, 
via a Kronecker product formulation. Spatial correlation is captured by the 
conditional autoregressive (CAR) prior proposed by Leroux et al. (2000), and 
between variable correlation is captured by a between variable covariance 
matrix with no fixed structure. This is a type of multivariate conditional 
autoregressive (MCAR) model. Further details are given in the vignette accompanying 
this package. Independent (over space) random effects can be obtained by 
setting rho=0, while the intrinsic MCAR model can be obtained by setting 
rho=1. Inference is conducted in a Bayesian setting using Markov chain Monte 
Carlo (MCMC) simulation. Missing (NA) values are allowed in the response, and 
posterior predictive distributions are created for the missing values using 
data augmentation. These are saved in the &quot;samples&quot; argument in the output of 
the function and are denoted by &quot;Y&quot;. For the multinomial model the first 
category in the multinomial data (first column of the response matrix) is 
taken as the baseline, and the covariates are linearly related to the log of 
the ratio (theta_j / theta_1) for j=1,...,J, where theta_j is the probability 
of being in category j. For a full model specification see the vignette 
accompanying this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVS.CARleroux(formula, family, data=NULL,  trials=NULL, W, burnin, n.sample, 
thin=1, n.chains=1, n.cores=1, prior.mean.beta=NULL, prior.var.beta=NULL, 
prior.nu2=NULL, prior.Sigma.df=NULL, prior.Sigma.scale=NULL, rho=NULL, MALA=TRUE, 
verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MVS.CARleroux_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function. The 
response and the offset (if included) should be matrices of dimension K*J, where
K is the number of spatial units and J is the number of different variables 
(categories in the multinomial model). The covariates should each be a K*1 vector,
and different regression parameters are estimated for each of the J variables. 
Missing (NA) values are allowed in the response.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_family">family</code></td>
<td>

<p>One of either &quot;binomial&quot;, &quot;gaussian&quot;, &quot;multinomial&quot;, or &quot;poisson&quot;, which 
respectively specify a binomial likelihood model with a logistic link function, 
a Gaussian likelihood model with an identity link function, a multinomial 
likelihood model with a logistic link function, or a Poisson likelihood model 
with a log link function. 
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_trials">trials</code></td>
<td>

<p>Only used if family=&quot;binomial&quot; or family=&quot;multinomial&quot;. For the binomial family it
is a K*J matrix matrix the same dimension as the response. A the multinomial family
it is a vector of length K.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_w">W</code></td>
<td>

<p>A non-negative K by K neighbourhood matrix (where K is the number of spatial 
units). Typically a binary specification is used, where the jkth element 
equals one if areas (j, k) are spatially close (e.g. share a common border) 
and is zero otherwise. The matrix can be non-binary, but each row must contain 
at least one non-zero entry.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period in each chain.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_n.sample">n.sample</code></td>
<td>

<p>The overall number of MCMC samples to generate in each chain.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_thin">thin</code></td>
<td>

<p>The level of thinning to apply to the MCMC samples in each chain to reduce their 
autocorrelation. Defaults to 1 (no thinning).
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_n.chains">n.chains</code></td>
<td>

<p>The number of MCMC chains to run when fitting the model. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_n.cores">n.cores</code></td>
<td>

<p>The number of computer cores to run the MCMC chains on. Must be less than or 
equal to n.chains. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_prior.mean.beta">prior.mean.beta</code></td>
<td>

<p>A vector of prior means for the regression parameters beta (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_prior.var.beta">prior.var.beta</code></td>
<td>

<p>A vector of prior variances for the regression parameters beta (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_prior.nu2">prior.nu2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for nu2. Defaults to c(1, 0.01) and only used if family=&quot;Gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_prior.sigma.df">prior.Sigma.df</code></td>
<td>

<p>The degrees of freedom for the Inverse-Wishart prior formulation for the 
covariance matrix Sigma. This prior formulation follows the marginally 
weakly-informative specification proposed by Huang and Wand (2013). Defaults 
to 2, which corresponds to non-informative uniform priors on the interval [-1,1]
being assigned to each correlation parameter within the Sigma matrix. 
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_prior.sigma.scale">prior.Sigma.scale</code></td>
<td>

<p>The J times 1  vector of prior scales for the  square roots of the diagonal 
elements of the covariance matrix Sigma. This prior formulation is the marginally 
weakly-informative prior specification proposed by Huang and Wand (2013). Thus,
the jth element of this vector is the scale parameter for the zero centred
half-t prior (with shape given by prior.Sigma.df) assumed for the standard 
deviation of the random effects corresponding to the jth outcome. Defaults to 
a vector of values of 100,000.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_rho">rho</code></td>
<td>

<p>The value in the interval [0, 1] that the spatial dependence parameter rho is 
fixed at if it should not be estimated. If this arugment is NULL then rho is
estimated in the model.
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_mala">MALA</code></td>
<td>

<p>Logical, should the function use Metropolis adjusted Langevin algorithm 
(MALA) updates (TRUE, default) or simple random walk updates (FALSE) for 
the regression parameters. Not applicable if family=&quot;gaussian&quot; or  
family=&quot;multinomial&quot;.  
</p>
</td></tr>
<tr><td><code id="MVS.CARleroux_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary.results</code></td>
<td>
<p>A summary table of the parameters.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A list containing the MCMC samples from the model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>A matrix of fitted values based on posterior means from the model.
Each row of a matrix relates to an area and each column to a response (category).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A list with 2 elements, where each element is a matrix of a type  
of residuals. Each row of a matrix relates to an area and each column to a 
response (category). The types of residual are &quot;response&quot; (raw), and 
&quot;pearson&quot;.</p>
</td></tr>
<tr><td><code>modelfit</code></td>
<td>
<p>Model fit criteria including the Deviance Information Criterion 
(DIC) and its corresponding estimated effective number of parameters (p.d), the Log 
Marginal Predictive Likelihood (LMPL), the Watanabe-Akaike Information Criterion 
(WAIC) and its corresponding estimated number of effective parameters (p.w), and 
the loglikelihood.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>The acceptance probabilities for the parameters.</p>
</td></tr>
<tr><td><code>localised.structure</code></td>
<td>
<p>NULL, for compatability with other models.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A text string describing the model fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>A vector giving details of the numbers of MCMC samples generated.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix of covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>References</h3>

<p>Gelfand, A and Vounatsou, P (2003). Proper multivariate conditional autoregressive
models for spatial data analysis, Biostatistics, 4, 11-25.
</p>
<p>Huang, A., and Wand, M (2013). Simple Marginally Noninformative Prior Distributions 
for Covariance Matrices. Bayesian Analysis, 8, 439-452.
</p>
<p>Kavanagh, L., D. Lee, and G. Pryce (2016). Is Poverty Decentralising? Quantifying 
Uncertainty in the Decentralisation of Urban Poverty, Annals of the American 
Association of Geographers, 106, 1286-1298.
</p>
<p>Leroux B, Lei X, Breslow N (2000). &quot;Estimation of Disease Rates in SmallAreas: A 
New Mixed Model for Spatial Dependence.&quot; In M Halloran, D Berry (eds.), 
<em>Statistical Models in Epidemiology, the Environment and Clinical Trials</em>,
pp. 179-191. Springer-Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#### Run the model on simulated data on a lattice
#################################################
#### Load other libraries required
library(MASS)

#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)

#### set up distance and neighbourhood (W, based on sharing a common border) matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;-array(0, c(K,K))
W[distance==1] &lt;-1 
K &lt;- nrow(W)

#### Generate the correlation structures
Q.W &lt;- 0.99 * (diag(apply(W, 2, sum)) - W) + 0.01 * diag(rep(1,K))
Q.W.inv &lt;- solve(Q.W)

Sigma &lt;- matrix(c(1,0.5,0, 0.5,1,0.3, 0, 0.3, 1), nrow=3)
Sigma.inv &lt;- solve(Sigma)
J &lt;- nrow(Sigma)
N.all &lt;- K * J

precision.phi &lt;- kronecker(Q.W, Sigma.inv)
var.phi &lt;- solve(precision.phi)

#### Generate the covariate component
x1 &lt;- rnorm(K)
x2 &lt;- rnorm(K)
XB &lt;- cbind(0.1 * x1 - 0.1*x2, -0.1 * x1 + 0.1*x2, 0.1 * x1 - 0.1*x2)

#### Generate the random effects
phi &lt;- mvrnorm(n=1, mu=rep(0,N.all), Sigma=var.phi)


#### Generate the response data
lp &lt;-as.numeric(t(XB)) + phi
prob &lt;- exp(lp) / (1 + exp(lp))
trials.vec &lt;- rep(100,N.all)
Y.vec &lt;- rbinom(n=N.all, size=trials.vec, prob=prob)

#### Turn the data and trials into matrices where each row is an area.
Y &lt;- matrix(Y.vec, nrow=K, ncol=J, byrow=TRUE)
trials &lt;- matrix(trials.vec, nrow=K, ncol=J, byrow=TRUE)

#### Run the Leroux model
formula &lt;- Y ~ x1 + x2
## Not run: model &lt;- MVS.CARleroux(formula=formula, family="binomial", 
trials=trials, W=W, burnin=20000, n.sample=100000)
## End(Not run)

#### Toy example for checking
model &lt;- MVS.CARleroux(formula=formula, family="binomial", 
trials=trials, W=W, burnin=10, n.sample=50)
</code></pre>

<hr>
<h2 id='print.CARBayes'>
Print a summary of a fitted CARBayes model to the screen.
</h2><span id='topic+print.CARBayes'></span>

<h3>Description</h3>

<p>This function takes a CARBayes object and returns a summary of the fitted model.
The summary includes, for selected parameters, posterior means and 95 percent 
credible intervals, the effective number of independent samples and the Geweke 
convergence diagnostic in the form of a Z-score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CARBayes'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.CARBayes_+3A_x">x</code></td>
<td>

<p>A CARBayes fitted model object.
</p>
</td></tr>
<tr><td><code id="print.CARBayes_+3A_...">...</code></td>
<td>

<p>Ignored.s
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>

<hr>
<h2 id='residuals.CARBayes'>
Extract the residuals from a model.
</h2><span id='topic+residuals.CARBayes'></span>

<h3>Description</h3>

<p>This function takes a CARBayes object and returns a set of residuals. The 
allowable types of residual are &quot;response&quot; (raw) and &quot;pearson&quot; (the default).
In each case the fitted values are based on posterior means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'CARBayes'
residuals(object, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.CARBayes_+3A_object">object</code></td>
<td>

<p>A CARBayes fitted model object.
</p>
</td></tr>
<tr><td><code id="residuals.CARBayes_+3A_type">type</code></td>
<td>

<p>A text string and one of &quot;response&quot; or &quot;pearson&quot;. If this
argument is omitted the default is &quot;pearson&quot;.
</p>
</td></tr>
<tr><td><code id="residuals.CARBayes_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>

<hr>
<h2 id='S.CARbym'>
Fit a spatial generalised linear mixed model to data, where the random effects 
have a BYM conditional autoregressive prior.
</h2><span id='topic+S.CARbym'></span>

<h3>Description</h3>

<p>Fit a spatial generalised linear mixed model to areal unit data, where the response
variable can be binomial, Poisson, or zero-inflated Poisson (ZIP). 
Note, a Gaussian likelihood is not allowed because of a lack of identifiability 
among the parameters. The linear predictor is modelled by known covariates and 2 
vectors of random effects. The latter are modelled by the BYM conditional 
autoregressive prior proposed by Besag et al. (1991), and further details are 
given in the vignette accompanying this package. Inference is conducted in a 
Bayesian setting using Markov chain Monte Carlo (MCMC) simulation. Missing (NA) 
values are allowed in the response, and posterior predictive distributions are 
created for the missing values using data augmentation. These are saved in the
&quot;samples&quot; argument in the output of the function and are denoted by &quot;Y&quot;. For 
the ZIP model covariates can be used to estimate the probability of an observation 
being a structural zero, via a logistic regression equation. For a full model 
specification see the vignette accompanying this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S.CARbym(formula, formula.omega=NULL, family, data=NULL, trials=NULL, W, burnin, 
n.sample, thin=1, n.chains=1, n.cores=1, prior.mean.beta=NULL, 
prior.var.beta=NULL,  prior.tau2=NULL, prior.sigma2=NULL, prior.mean.delta=NULL, 
prior.var.delta=NULL, MALA=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S.CARbym_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function. The 
response, offset and each covariate are vectors of length K*1. The response can 
contain missing (NA) values.  
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_formula.omega">formula.omega</code></td>
<td>

<p>A one-sided formula object with no response variable (left side of the &quot;~&quot;) 
needed, specifying the covariates in the logistic regression model for 
modelling the probability of an observation being a structural zero. Each 
covariate (or an offset) needs to be a vector of length K*1. Only required for 
zero-inflated Poisson models.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_family">family</code></td>
<td>

<p>One of either &quot;binomial&quot;,&quot;poisson&quot; or &quot;zip&quot;, which respectively specify a binomial 
likelihood model with a logistic link function, a Poisson likelihood model with a 
log link function, or a zero-inflated Poisson model with a log link function. 
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
for each area. Only used if family=&quot;binomial&quot;. 
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_w">W</code></td>
<td>

<p>A non-negative K by K neighbourhood matrix (where K is the number of spatial units). 
Typically a binary specification is used, where the jkth element equals one if 
areas (j, k) are spatially close (e.g. share a common border) and is zero otherwise. 
The matrix can be non-binary, but each row must contain at least one non-zero entry.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_n.sample">n.sample</code></td>
<td>

<p>The overall number of MCMC samples to generate in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_thin">thin</code></td>
<td>

<p>The level of thinning to apply to the MCMC samples in each chain to reduce their 
autocorrelation. Defaults to 1 (no thinning).
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_n.chains">n.chains</code></td>
<td>

<p>The number of MCMC chains to run when fitting the model. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_n.cores">n.cores</code></td>
<td>

<p>The number of computer cores to run the MCMC chains on. Must be less than or 
equal to n.chains. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_prior.mean.beta">prior.mean.beta</code></td>
<td>

<p>A vector of prior means for the regression parameters beta (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_prior.var.beta">prior.var.beta</code></td>
<td>

<p>A vector of prior variances for the regression parameters beta (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>  
<tr><td><code id="S.CARbym_+3A_prior.tau2">prior.tau2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for tau2. Defaults to c(1, 0.01).  
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_prior.sigma2">prior.sigma2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale)
prior for sigma2. Defaults to c(1, 0.01).  
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_prior.mean.delta">prior.mean.delta</code></td>
<td>

<p>A vector of prior means for the regression parameters delta (Gaussian priors are 
assumed) for the zero probability logistic regression component of the model. 
Defaults to a vector of zeros. Only used if family=&quot;multinomial&quot;.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_prior.var.delta">prior.var.delta</code></td>
<td>

<p>A vector of prior variances for the regression parameters delta (Gaussian priors 
are assumed) for the zero probability logistic regression component of the model. 
Defaults to a vector with values 100,000. Only used if family=&quot;multinomial&quot;.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_mala">MALA</code></td>
<td>

<p>Logical, should the function use Metropolis adjusted Langevin algorithm (MALA) 
updates (TRUE, default) or simple random walk updates (FALSE) for the regression
parameters.
</p>
</td></tr>
<tr><td><code id="S.CARbym_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary.results</code></td>
<td>
<p>A summary table of the parameters.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A list containing the MCMC samples from the model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values based on posterior means from the model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A matrix with 2 columns where each column is a type of 
residual and each row relates to an area. The types are &quot;response&quot; (raw), 
and &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code>modelfit</code></td>
<td>
<p>Model fit criteria including the Deviance Information Criterion 
(DIC) and its corresponding estimated effective number of parameters (p.d), the Log 
Marginal Predictive Likelihood (LMPL), the Watanabe-Akaike Information Criterion 
(WAIC) and its corresponding estimated number of effective parameters (p.w), and
the loglikelihood.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>The acceptance probabilities for the parameters.</p>
</td></tr>
<tr><td><code>localised.structure</code></td>
<td>
<p>NULL, for compatability with other models.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A text string describing the model fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>A vector giving details of the numbers of MCMC samples generated.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix of covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>References</h3>

<p>Besag, J., J. York, and A. Mollie (1991). Bayesian image restoration with two 
applications in spatial statistics. Annals of the Institute of Statistics and 
Mathematics 43, 1-59.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#### Run the model on simulated data on a lattice
#################################################
#### Load other libraries required
library(MASS)

#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)

#### set up distance and neighbourhood (W, based on sharing a common border) matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;-array(0, c(K,K))
W[distance==1] &lt;-1 	
	
#### Generate the covariates and response data
x1 &lt;- rnorm(K)
x2 &lt;- rnorm(K)
theta &lt;- rnorm(K, sd=0.05)
phi &lt;- mvrnorm(n=1, mu=rep(0,K), Sigma=0.4 * exp(-0.1 * distance))
logit &lt;- x1 + x2 + theta + phi
prob &lt;- exp(logit) / (1 + exp(logit))
trials &lt;- rep(50,K)
Y &lt;- rbinom(n=K, size=trials, prob=prob)


#### Run the BYM model
formula &lt;- Y ~ x1 + x2
## Not run: model &lt;- S.CARbym(formula=formula, family="binomial", trials=trials,
W=W, burnin=20000, n.sample=100000)
## End(Not run)

#### Toy example for checking
model &lt;- S.CARbym(formula=formula, family="binomial", trials=trials,
W=W, burnin=20, n.sample=50)
</code></pre>

<hr>
<h2 id='S.CARdissimilarity'>
Fit a spatial generalised linear mixed model to data, where the random effects 
have a localised conditional autoregressive prior.
</h2><span id='topic+S.CARdissimilarity'></span>

<h3>Description</h3>

<p>Fit a spatial generalised linear mixed model to areal unit data, where the response
variable can be binomial, Gaussian or Poisson. The linear predictor is modelled by
known covariates and a vector of random effects. The latter are modelled by the 
localised conditional autoregressive prior proposed by Lee and Mitchell (2012), 
and further details are given in the vignette accompanying this package. Inference
is conducted in a Bayesian setting using Markov chain Monte Carlo (MCMC) simulation.
Missing (NA) values are allowed in the response, and posterior predictive distributions
are created for the missing values using data augmentation. These are saved in the
&quot;samples&quot; argument in the output of the function and are denoted by &quot;Y&quot;. For a full 
model specification see the vignette accompanying this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S.CARdissimilarity(formula, family, data=NULL,  trials=NULL, W, Z, W.binary=TRUE, 
burnin, n.sample, thin=1, n.chains=1, n.cores=1, prior.mean.beta=NULL, 
prior.var.beta=NULL, prior.nu2=NULL, prior.tau2=NULL, MALA=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S.CARdissimilarity_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function. The 
response, offset and each covariate is a vector of length K*1. The response can 
contain missing (NA) values.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_family">family</code></td>
<td>

<p>One of either &quot;binomial&quot;, &quot;gaussian&quot; or &quot;poisson&quot;, which respectively specify a 
binomial likelihood model with a logistic link function, a Gaussian likelihood 
model with an identity link function, or a Poisson likelihood model with a 
log link function. 
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
for each area. Only used if family=&quot;binomial&quot;. 
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_w">W</code></td>
<td>

<p>A non-negative K by K neighbourhood matrix (where K is the number of spatial units). 
Typically a binary specification is used, where the jkth element equals one if 
areas (j, k) are spatially close (e.g. share a common border) and is zero otherwise. 
For this model only the matrix must be binary.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_z">Z</code></td>
<td>

<p>A list, where each element is a K by K matrix of non-negative dissimilarity metrics.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_w.binary">W.binary</code></td>
<td>

<p>Logical, should the estimated neighbourhood matrix have only binary (0,1) values.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_n.sample">n.sample</code></td>
<td>

<p>The overall number of MCMC samples to generate in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_thin">thin</code></td>
<td>

<p>The level of thinning to apply to the MCMC samples in each chain to reduce their 
autocorrelation. Defaults to 1 (no thinning).
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_n.chains">n.chains</code></td>
<td>

<p>The number of MCMC chains to run when fitting the model. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_n.cores">n.cores</code></td>
<td>

<p>The number of computer cores to run the MCMC chains on. Must be less than or 
equal to n.chains. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_prior.mean.beta">prior.mean.beta</code></td>
<td>

<p>A vector of prior means for the regression parameters beta (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_prior.var.beta">prior.var.beta</code></td>
<td>

<p>A vector of prior variances for the regression parameters beta (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>  
<tr><td><code id="S.CARdissimilarity_+3A_prior.nu2">prior.nu2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for nu2. Defaults to c(1, 0.01) and only used if family=&quot;Gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_prior.tau2">prior.tau2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for tau2. Defaults to c(1, 0.01).  
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_mala">MALA</code></td>
<td>

<p>Logical, should the function use Metropolis adjusted Langevin algorithm (MALA) 
updates (TRUE, default) or simple random walk updates (FALSE) for the regression
parameters. Not applicable if family=&quot;gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="S.CARdissimilarity_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary.results</code></td>
<td>
<p>A summary table of the parameters.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A list containing the MCMC samples from the model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values based on posterior means from the model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A matrix with 2 columns where each column is a type of 
residual and each row relates to an area. The types are &quot;response&quot; (raw), 
and &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code>modelfit</code></td>
<td>
<p>Model fit criteria including the Deviance Information Criterion 
(DIC) and its corresponding estimated effective number of parameters (p.d), the Log 
Marginal Predictive Likelihood (LMPL), the Watanabe-Akaike Information Criterion 
(WAIC) and its corresponding estimated number of effective parameters (p.w), and
the loglikelihood.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>The acceptance probabilities for the parameters.</p>
</td></tr>
<tr><td><code>localised.structure</code></td>
<td>
<p>A list containing two matrices: W.posterior contains 
posterior medians for each element w_kj of the K by K neighbourhood matrix W; 
W.border.prob contains posterior probabilities that each w_kj element of the K by K
neighbourhood matrix W equals zero. This corresponds to the posterior probability
of a boundary in the random effects surface. The latter is only present if 
W.binary=TRUE, otherwise it is missing (NA). In all cases W elements that
correspond to two non-neighbouring areas have NA values.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A text string describing the model fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>A vector giving details of the numbers of MCMC samples generated.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix of covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>References</h3>

<p>Lee, D. and R. Mitchell (2012). Boundary detection in disease mapping studies. 
Biostatistics, 13, 415-426.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#### Run the model on simulated data on a lattice
#################################################
#### Load other libraries required
library(MASS)

#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)

#### Split the area into two groups between which there will be a boundary.
groups &lt;-rep(1, K) 
groups[Grid$Var1&gt;5] &lt;- 2

#### set up distance and neighbourhood (W, based on sharing a common border) matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;-array(0, c(K,K))
W[distance==1] &lt;-1 	
	
#### Generate the response data
phi &lt;- mvrnorm(n=1, mu=groups, Sigma=0.2 * exp(-0.1 * distance))
logit &lt;- phi
prob &lt;- exp(logit) / (1 + exp(logit))
trials &lt;- rep(50,K)
Y &lt;- rbinom(n=K, size=trials, prob=prob)


#### Generate a dissimilarity metric
dissimilarity &lt;- cbind(groups) + rnorm(K, sd=0.2)
dissimilarity.matrix &lt;- as.matrix(dist(cbind(dissimilarity, dissimilarity), 
method="manhattan", diag=TRUE, upper=TRUE)) * W/2

Z &lt;- list(dissimilarity.matrix=dissimilarity.matrix)

#### Run the localised smoothing model
formula &lt;- Y ~ 1
## Not run: model &lt;- S.CARdissimilarity(formula=formula, family="binomial",
trials=trials, W=W, Z=Z, W.binary=TRUE, burnin=20000, n.sample=100000)
## End(Not run)

#### Toy example for checking
model &lt;- S.CARdissimilarity(formula=formula, family="binomial",
trials=trials, W=W, Z=Z, W.binary=TRUE, burnin=10, n.sample=50)
</code></pre>

<hr>
<h2 id='S.CARleroux'>
Fit a spatial generalised linear mixed model to data, where the random effects 
have a Leroux conditional autoregressive prior.
</h2><span id='topic+S.CARleroux'></span>

<h3>Description</h3>

<p>Fit a spatial generalised linear mixed model to areal unit data, where the response
variable can be binomial, Gaussian, Poisson or zero-inflated Poisson (ZIP). The 
linear predictor is modelled by known covariates and a vector of random effects. 
The latter are modelled by the conditional autoregressive prior proposed by 
Leroux et al. (2000), and further details are given in the vignette accompanying 
this package. Independent random effects can be obtained by setting rho=0, while 
the intrinsic CAR model can be obtained by setting rho=1. Inference is conducted 
in a Bayesian setting using Markov chain Monte Carlo (MCMC) simulation. Missing 
(NA) values are allowed in the response, and posterior predictive distributions 
are created for the missing values using data augmentation. These are saved in 
the&quot;samples&quot; argument in the output of the function and are denoted by &quot;Y&quot;. For 
the ZIP model covariates can be used to estimate the probability of an observation 
being a structural zero, via a logistic regression equation. For a full model 
specification see the vignette accompanying this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S.CARleroux(formula, formula.omega=NULL, family, data=NULL,  trials=NULL, W, 
burnin, n.sample, thin=1, n.chains=1,  n.cores=1, prior.mean.beta=NULL, 
prior.var.beta=NULL, prior.nu2=NULL, prior.tau2=NULL, prior.mean.delta=NULL, 
prior.var.delta=NULL, rho=NULL, MALA=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S.CARleroux_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function. The 
response, offset and each covariate is a vector of length K*1. The response can 
contain missing (NA) values.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_formula.omega">formula.omega</code></td>
<td>

<p>A one-sided formula object with no response variable (left side of the &quot;~&quot;) 
needed, specifying the covariates in the logistic regression model for 
modelling the probability of an observation being a structural zero. Each 
covariate (or an offset) needs to be a vector of length K*1. Only required for 
zero-inflated Poisson models.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_family">family</code></td>
<td>

<p>One of either &quot;binomial&quot;, &quot;gaussian&quot;, &quot;poisson&quot; or &quot;zip&quot;, which respectively 
specify a binomial likelihood model with a logistic link function, 
a Gaussian likelihood model with an identity link function, a Poisson likelihood 
model with a log link function, or a zero-inflated Poisson model with a log link 
function. 
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
for each area. Only used if family=&quot;binomial&quot;. 
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_w">W</code></td>
<td>
<p>A non-negative K by K neighbourhood matrix (where K is the number of 
spatial units). Typically a binary specification is used, where the jkth 
element equals one if areas (j, k) are spatially close (e.g. share a common 
border) and is zero otherwise. The matrix can be non-binary, but each row must 
contain at least one non-zero entry.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_n.sample">n.sample</code></td>
<td>

<p>The overall number of MCMC samples to generate in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_thin">thin</code></td>
<td>

<p>The level of thinning to apply to the MCMC samples in each chain to reduce their 
autocorrelation. Defaults to 1 (no thinning).
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_n.chains">n.chains</code></td>
<td>

<p>The number of MCMC chains to run when fitting the model. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_n.cores">n.cores</code></td>
<td>

<p>The number of computer cores to run the MCMC chains on. Must be less than or 
equal to n.chains. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_prior.mean.beta">prior.mean.beta</code></td>
<td>

<p>A vector of prior means for the regression parameters beta (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_prior.var.beta">prior.var.beta</code></td>
<td>

<p>A vector of prior variances for the regression parameters beta (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>  
<tr><td><code id="S.CARleroux_+3A_prior.nu2">prior.nu2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for nu2. Defaults to c(1, 0.01) and only used if family=&quot;Gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_prior.tau2">prior.tau2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for tau2. Defaults to c(1, 0.01).  
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_prior.mean.delta">prior.mean.delta</code></td>
<td>

<p>A vector of prior means for the regression parameters delta (Gaussian priors are 
assumed) for the zero probability logistic regression component of the model. 
Defaults to a vector of zeros. Only used if family=&quot;multinomial&quot;.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_prior.var.delta">prior.var.delta</code></td>
<td>

<p>A vector of prior variances for the regression parameters delta (Gaussian priors 
are assumed) for the zero probability logistic regression component of the model. 
Defaults to a vector with values 100,000. Only used if family=&quot;multinomial&quot;.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_rho">rho</code></td>
<td>

<p>The value in the interval [0, 1] that the spatial dependence parameter rho is 
fixed at if it should not be estimated. If this arugment is NULL then rho is
estimated in the model.
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_mala">MALA</code></td>
<td>

<p>Logical, should the function use Metropolis adjusted Langevin algorithm 
(MALA) updates (TRUE, default) or simple random walk updates (FALSE) for 
the regression parameters. Not applicable if family=&quot;gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="S.CARleroux_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary.results</code></td>
<td>
<p>A summary table of the parameters.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A list containing the MCMC samples from the model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values based on posterior means from the model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A matrix with 2 columns where each column is a type of 
residual and each row relates to an area. The types are &quot;response&quot; (raw), 
and &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code>modelfit</code></td>
<td>
<p>Model fit criteria including the Deviance Information Criterion 
(DIC) and its corresponding estimated effective number of parameters (p.d), the Log 
Marginal Predictive Likelihood (LMPL), the Watanabe-Akaike Information Criterion 
(WAIC) and its corresponding estimated number of effective parameters (p.w), and
the loglikelihood.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>The acceptance probabilities for the parameters.</p>
</td></tr>
<tr><td><code>localised.structure</code></td>
<td>
<p>NULL, for compatability with other models.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model. If family=&quot;zip&quot; this also includes the zero probability
logistic regression formula.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A text string describing the model fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>A vector giving details of the numbers of MCMC samples generated.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix of covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>References</h3>

<p>Leroux B, Lei X, Breslow N (2000). &quot;Estimation of Disease Rates in SmallAreas: A 
New Mixed Model for Spatial Dependence.&quot; In M Halloran, D Berry (eds.), 
<em>Statistical Models in Epidemiology, the Environment and Clinical Trials</em>,
pp. 179-191. Springer-Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#### Run the model on simulated data on a lattice
#################################################
#### Load other libraries required
library(MASS)

#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)

#### set up distance and neighbourhood (W, based on sharing a common border) matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;-array(0, c(K,K))
W[distance==1] &lt;-1 	
	
#### Generate the covariates and response data
x1 &lt;- rnorm(K)
x2 &lt;- rnorm(K)
theta &lt;- rnorm(K, sd=0.05)
phi &lt;- mvrnorm(n=1, mu=rep(0,K), Sigma=0.4 * exp(-0.1 * distance))
logit &lt;- x1 + x2 + theta + phi
prob &lt;- exp(logit) / (1 + exp(logit))
trials &lt;- rep(50,K)
Y &lt;- rbinom(n=K, size=trials, prob=prob)


#### Run the Leroux model
formula &lt;- Y ~ x1 + x2
## Not run: model &lt;- S.CARleroux(formula=formula, family="binomial", 
trials=trials, W=W, burnin=20000, n.sample=100000)
## End(Not run)

#### Toy example for checking
model &lt;- S.CARleroux(formula=formula, family="binomial", 
trials=trials, W=W, burnin=10, n.sample=50)
</code></pre>

<hr>
<h2 id='S.CARlocalised'>
Fit a spatial generalised linear mixed model to data, where a set of spatially 
smooth random effects  are augmented with a piecewise constant intercept process.
</h2><span id='topic+S.CARlocalised'></span>

<h3>Description</h3>

<p>Fit a spatial generalised linear mixed model to areal unit data, where the response
variable can be binomial or Poisson. Note, a Gaussian likelihood is not allowed 
because of a lack of identifiability among the parameters. The linear predictor is 
modelled by known covariates, a vector of random effects and a piecewise constant 
intercept process. The random effects are modelled by an intrinsic CAR prior, while 
the piecewise constant intercept process was proposed by Lee and Sarran (2015), and 
allow neighbouring areas to have very different values. Further details are given 
in the vignette accompanying this package. Inference is conducted in a Bayesian 
setting using Markov chain Monte Carlo (MCMC) simulation. Missing (NA) values are 
not allowed in this model. For a full model specification see the vignette 
accompanying this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S.CARlocalised(formula, family, data=NULL, G, trials=NULL, W, burnin, n.sample, 
thin=1, n.chains=1, n.cores=1, prior.mean.beta=NULL, prior.var.beta=NULL,
prior.tau2=NULL,prior.delta=NULL, MALA=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S.CARlocalised_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function. The 
response, offset and each covariate is a vector of length K*1.The  response 
cannot contain missing (NA) values.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_family">family</code></td>
<td>

<p>One of either &quot;binomial&quot; or &quot;poisson&quot;, which respectively specify a 
binomial likelihood model with a logistic link function, or a Poisson likelihood 
model with a log link function. 
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_g">G</code></td>
<td>

<p>The maximum number of distinct intercept terms (groups) to allow in the model.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
for each area. Only used if family=&quot;binomial&quot;. 
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_w">W</code></td>
<td>

<p>A non-negative K by K neighbourhood matrix (where K is the number of spatial units). 
Typically a binary specification is used, where the jkth element equals one if areas 
(j, k) are spatially close (e.g. share a common border) and is zero otherwise. The 
matrix can be non-binary, but each row must contain at least one non-zero entry.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_n.sample">n.sample</code></td>
<td>

<p>The overall number of MCMC samples to generate in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_thin">thin</code></td>
<td>

<p>The level of thinning to apply to the MCMC samples in each chain to reduce their 
autocorrelation. Defaults to 1 (no thinning).
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_n.chains">n.chains</code></td>
<td>

<p>The number of MCMC chains to run when fitting the model. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_n.cores">n.cores</code></td>
<td>

<p>The number of computer cores to run the MCMC chains on. Must be less than or 
equal to n.chains. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_prior.mean.beta">prior.mean.beta</code></td>
<td>

<p>A vector of prior means for the regression parameters beta (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_prior.var.beta">prior.var.beta</code></td>
<td>

<p>A vector of prior variances for the regression parameters beta (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>  
<tr><td><code id="S.CARlocalised_+3A_prior.tau2">prior.tau2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for tau2. Defaults to c(1, 0.01).  
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_prior.delta">prior.delta</code></td>
<td>

<p>The prior maximum for the cluster smoothing parameter delta. Defaults to 10.  
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_mala">MALA</code></td>
<td>

<p>Logical, should the function use Metropolis adjusted Langevin algorithm 
(MALA) updates (TRUE, default) or simple random walk updates (FALSE) for 
the regression parameters.   
</p>
</td></tr>
<tr><td><code id="S.CARlocalised_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary.results</code></td>
<td>
<p>A summary table of the parameters.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A list containing the MCMC samples from the model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values based on posterior means from the model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A matrix with 2 columns where each column is a type of 
residual and each row relates to an area. The types are &quot;response&quot; (raw), 
and &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code>modelfit</code></td>
<td>
<p>Model fit criteria including the Deviance Information Criterion 
(DIC) and its corresponding estimated effective number of parameters (p.d), the Log 
Marginal Predictive Likelihood (LMPL), the Watanabe-Akaike Information Criterion 
(WAIC) and its corresponding estimated number of effective parameters (p.w), and
the loglikelihood.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>The acceptance probabilities for the parameters.</p>
</td></tr>
<tr><td><code>localised.structure</code></td>
<td>
<p>A vector giving the posterior median of which intercept 
group each area is in.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A text string describing the model fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>A vector giving details of the numbers of MCMC samples generated.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix of covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>References</h3>

<p>Lee, D and Sarran, C  (2015). Controlling for unmeasured confounding and spatial 
misalignment in long-term air pollution and health studies, Environmetrics, 26, 
477-487.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#### Run the model on simulated data on a lattice
#################################################
#### Load other libraries required
library(MASS)

#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)

#### Split the area into two groups between which there will be a boundary.
groups &lt;-rep(1, K) 
groups[Grid$Var1&gt;5] &lt;- 2

#### set up distance and neighbourhood (W, based on sharing a common border) matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;-array(0, c(K,K))
W[distance==1] &lt;-1 
	
#### Generate the response data
phi &lt;- mvrnorm(n=1, mu=groups, Sigma=0.2 * exp(-0.1 * distance))
logit &lt;- phi
prob &lt;- exp(logit) / (1 + exp(logit))
trials &lt;- rep(50,K)
Y &lt;- rbinom(n=K, size=trials, prob=prob)


#### Run the localised smoothing model
formula &lt;- Y ~ 1
## Not run: model &lt;- S.CARlocalised(formula=formula, family="binomial", trials=trials,
G=2, W=W,burnin=20000, n.sample=100000)
## End(Not run)

#### Toy example for checking
model &lt;- S.CARlocalised(formula=formula, family="binomial", trials=trials,
G=2, W=W,burnin=10, n.sample=50)
</code></pre>

<hr>
<h2 id='S.CARmultilevel'>
Fit a spatial generalised linear mixed model  to multi-level areal unit data, 
where the spatial random effects have a Leroux conditional autoregressive 
prior.
</h2><span id='topic+S.CARmultilevel'></span>

<h3>Description</h3>

<p>Fit a spatial generalised linear mixed model to multi-level areal unit data, where
the response variable can be binomial, Gaussian or Poisson. The data are 
structured with individuals within areal units, and different numbers of individuals
are allowed within each areal unit. The linear predictor is modelled by
known covariates (either individual or areal level) and a vector of areal level
random effects that are modelled by the conditional autoregressive prior 
proposed by Leroux et al. (2000). Independent random effects can be obtained 
by setting rho=0, while the intrinsic CAR model can be obtained by setting 
rho=1. Inference is conducted in a Bayesian setting using Markov chain Monte 
Carlo (MCMC) simulation. Missing (NA) values are allowed in the response, and 
posterior predictive  distributions are created for the missing values using 
data augmentation. These are  saved in the &quot;samples&quot; argument in the output 
of the function and are denoted by &quot;Y&quot;. For a full model specification see 
the vignette accompanying this package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    S.CARmultilevel(formula, family, data=NULL,  trials=NULL, W, ind.area, 
    burnin, n.sample, thin=1, n.chains=1, n.cores=1, prior.mean.beta=NULL, 
    prior.var.beta=NULL, prior.nu2=NULL, prior.tau2=NULL, rho=NULL, MALA=TRUE, 
    verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S.CARmultilevel_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function.
The response, offset and each covariate are vectors with length equal to
the number of individuals. The response can contain missing (NA) values.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_family">family</code></td>
<td>

<p>One of either &quot;binomial&quot;, &quot;gaussian&quot;, or &quot;poisson&quot;, which respectively 
specify a binomial likelihood model with a logistic link function, a 
Gaussian likelihood model with an identity link function, or a Poisson 
likelihood model with a log link function. 
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
for each individual. Only used if family=&quot;binomial&quot;. 
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_w">W</code></td>
<td>
<p>A non-negative K by K neighbourhood matrix (where K is the number of 
spatial units). Typically a binary specification is used, where the jkth 
element equals one if areas (j, k) are spatially close (e.g. share a common 
border) and is zero otherwise. The matrix can be non-binary, but each row must 
contain at least one non-zero entry.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_ind.area">ind.area</code></td>
<td>

<p>A vector of integers the same length as the number of data points (individuals) 
giving which spatial unit (nunmbered from 1 to K to align with the rows of
the W matrix) each individual belongs to.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_n.sample">n.sample</code></td>
<td>

<p>The overall number of MCMC samples to generate in each chain.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_thin">thin</code></td>
<td>

<p>The level of thinning to apply to the MCMC samples in each chain to reduce their 
autocorrelation. Defaults to 1 (no thinning).
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_n.chains">n.chains</code></td>
<td>

<p>The number of MCMC chains to run when fitting the model. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_n.cores">n.cores</code></td>
<td>

<p>The number of computer cores to run the MCMC chains on. Must be less than or 
equal to n.chains. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_prior.mean.beta">prior.mean.beta</code></td>
<td>

<p>A vector of prior means for the regression parameters beta (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_prior.var.beta">prior.var.beta</code></td>
<td>

<p>A vector of prior variances for the regression parameters beta (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>  
<tr><td><code id="S.CARmultilevel_+3A_prior.nu2">prior.nu2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for nu2. Defaults to c(1, 0.01) and only used if family=&quot;Gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_prior.tau2">prior.tau2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for tau2. Defaults to c(1, 0.01).  
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_rho">rho</code></td>
<td>

<p>The value in the interval [0, 1] that the spatial dependence parameter rho is 
fixed at if it should not be estimated. If this arugment is NULL then rho is
estimated in the model.
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_mala">MALA</code></td>
<td>

<p>Logical, should the function use Metropolis adjusted Langevin algorithm 
(MALA) updates (TRUE, default) or simple random walk updates (FALSE) for 
the regression parameters. Not applicable if family=&quot;gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="S.CARmultilevel_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary.results</code></td>
<td>
<p>A summary table of the parameters.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A list containing the MCMC samples from the model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values based on posterior means from the model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A matrix with 2 columns where each column is a type of 
residual and each row relates to an area. The types are &quot;response&quot; (raw), 
and &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code>modelfit</code></td>
<td>
<p>Model fit criteria including the Deviance Information Criterion 
(DIC) and its corresponding estimated effective number of parameters (p.d), the Log 
Marginal Predictive Likelihood (LMPL), the Watanabe-Akaike Information Criterion 
(WAIC) and its corresponding estimated number of effective parameters (p.w), and
the loglikelihood.</p>
</td></tr>
<tr><td><code>localised.structure</code></td>
<td>
<p>NULL, for compatability with other models.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A text string describing the model fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>A vector giving details of the numbers of MCMC samples generated.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix of covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#### Run the model on simulated data on a lattice
#################################################
    
#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)
    
#### set up distance and neighbourhood (W, based on sharing a common border) matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;-array(0, c(K,K))
W[distance==1] &lt;-1 	

#### Generate the number of individuals per area and which individuals to which areas
n &lt;- sample(5:30, K, replace=TRUE)
n.total &lt;- sum(n)
ind.area.temp &lt;- rep(1:K, n)
ind.area &lt;- sample(ind.area.temp, n.total, replace=FALSE)

#### Generate the covariates and response data
x1 &lt;- rnorm(n.total)
x2 &lt;- rnorm(n.total)
phi &lt;- mvrnorm(n=1, mu=rep(0,K), Sigma=0.4 * exp(-0.1 * distance))
phi.extend &lt;- phi[ind.area]
logit &lt;- x1 + x2 + phi.extend
prob &lt;- exp(logit) / (1 + exp(logit))
trials &lt;- rep(50,n.total)
Y &lt;- rbinom(n=n.total, size=trials, prob=prob)
    
    
#### Run the model
formula &lt;- Y ~ x1 + x2
## Not run: model &lt;- S.CARmultilevel(formula=formula, family="binomial", ind.area=ind.area,
                trials=trials, W=W, burnin=20000, n.sample=100000)
## End(Not run)
                
#### Toy example for checking
model &lt;- S.CARmultilevel(formula=formula, family="binomial", ind.area=ind.area,
                trials=trials, W=W, burnin=10, n.sample=50)
</code></pre>

<hr>
<h2 id='S.glm'>
Fit a generalised linear model to data.
</h2><span id='topic+S.glm'></span>

<h3>Description</h3>

<p>Fit a generalised linear model to data, where the response variable 
can be binomial, Gaussian, multinomial, Poisson or zero-inflated Poisson (ZIP). 
Inference is conducted in a Bayesian setting using Markov chain Monte Carlo 
(MCMC)  simulation. Missing (NA) values are allowed in the response, and posterior 
predictive  distributions are created  for the missing values via data 
augmentation. These are  saved in the &quot;samples&quot; argument in the output of the 
function and are denoted by &quot;Y&quot;.  For the multinomial model the first category 
in the multinomial data (first column of the response matrix) is taken as the 
baseline, and the covariates are linearly related to the log of the ratio 
(theta_j / theta_1) for j=1,...,J, where theta_j is the probability of being in 
category j. For the ZIP model covariates can be used to estimate the probability
of an observation being a structural zero, via a logistic regression equation.
For a full model specification see the vignette accompanying this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S.glm(formula, formula.omega=NULL, family, data=NULL,  trials=NULL, burnin, 
n.sample, thin=1, n.chains=1, n.cores=1, prior.mean.beta=NULL, 
prior.var.beta=NULL, prior.nu2=NULL, prior.mean.delta=NULL, prior.var.delta=NULL, 
MALA=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S.glm_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function. The 
response, offset and each covariate are vectors of length K*1. For the multinomial 
model the response and the offset (if included) should be matrices of dimension 
K*J, where K is the number of spatial units and J is the number of different 
variables (categories in the multinomial model). The covariates should each be a 
K*1 vector, and different regression parameters are estimated for each of the 
J variables. The response can contain missing (NA) values.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_formula.omega">formula.omega</code></td>
<td>

<p>A one-sided formula object with no response variable (left side of the &quot;~&quot;) 
needed, specifying the covariates in the logistic regression model for 
modelling the probability of an observation being a structural zero. Each 
covariate (or an offset) needs to be a vector of length K*1. Only required for 
zero-inflated Poisson models.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_family">family</code></td>
<td>

<p>One of either &quot;binomial&quot;, &quot;gaussian&quot;, &quot;multinomial&quot;, &quot;poisson&quot; or &quot;zip&quot;, which 
respectively specify a binomial likelihood model with a logistic link function, 
a Gaussian likelihood model with an identity link function, a multinomial 
likelihood model with a logistic link function, a Poisson likelihood model 
with a log link function, or a zero-inflated Poisson model with a log link 
function. 
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
for each data point. Only used if family=&quot;binomial&quot; or family=&quot;multinomial&quot;. 
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_burnin">burnin</code></td>
<td>

<p>The number of MCMC samples to discard as the burn-in period in each chain.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_n.sample">n.sample</code></td>
<td>

<p>The overall number of MCMC samples to generate in each chain.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_thin">thin</code></td>
<td>

<p>The level of thinning to apply to the MCMC samples in each chain to reduce their 
autocorrelation. Defaults to 1 (no thinning).
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_n.chains">n.chains</code></td>
<td>

<p>The number of MCMC chains to run when fitting the model. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_n.cores">n.cores</code></td>
<td>

<p>The number of computer cores to run the MCMC chains on. Must be less than or 
equal to n.chains. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_prior.mean.beta">prior.mean.beta</code></td>
<td>

<p>A vector of prior means for the regression parameters beta (Gaussian priors are 
assumed). Defaults to a vector of zeros.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_prior.var.beta">prior.var.beta</code></td>
<td>

<p>A vector of prior variances for the regression parameters beta (Gaussian priors 
are assumed). Defaults to a vector with values 100,000.
</p>
</td></tr>  
<tr><td><code id="S.glm_+3A_prior.nu2">prior.nu2</code></td>
<td>

<p>The prior shape and scale in the form of c(shape, scale) for an Inverse-Gamma(shape, scale) 
prior for nu2. Defaults to c(1, 0.01) and only used if family=&quot;Gaussian&quot;.   
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_prior.mean.delta">prior.mean.delta</code></td>
<td>

<p>A vector of prior means for the regression parameters delta (Gaussian priors are 
assumed) for the zero probability logistic regression component of the model. 
Defaults to a vector of zeros. Only used if family=&quot;multinomial&quot;.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_prior.var.delta">prior.var.delta</code></td>
<td>

<p>A vector of prior variances for the regression parameters delta (Gaussian priors 
are assumed) for the zero probability logistic regression component of the model. 
Defaults to a vector with values 100,000. Only used if family=&quot;multinomial&quot;.
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_mala">MALA</code></td>
<td>

<p>Logical, should the function use Metropolis adjusted Langevin algorithm (MALA) 
updates (TRUE, default) or simple random walk updates (FALSE) for the regression 
parameters. Not applicable if family=&quot;gaussian&quot; or family=&quot;multinomial&quot;.   
</p>
</td></tr>
<tr><td><code id="S.glm_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary.results</code></td>
<td>
<p>A summary table of the parameters.</p>
</td></tr>
<tr><td><code>samples</code></td>
<td>
<p>A list containing the MCMC samples from the model.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values based on posterior means from the model. 
For the univariate data models this is a vector, while for the multivariate data 
models this is a matrix.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>If the family is &quot;binomial&quot;, &quot;gaussian&quot; or &quot;poisson&quot;,
then this is a matrix with 2 columns, where each column is a type of residual and 
each row relates to an area. The types are &quot;response&quot; (raw), and &quot;pearson&quot;. If 
family is &quot;multinomial&quot;, then this is a list with 2 elements, where 
each element is a matrix of residuals of a different type. Each row of a matrix 
relates to an area and each column to a cateogry within the multinomial response. 
The types of residual are &quot;response&quot; (raw), and &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code>modelfit</code></td>
<td>
<p>Model fit criteria including the Deviance Information Criterion 
(DIC) and its corresponding estimated effective number of parameters (p.d), the Log 
Marginal Predictive Likelihood (LMPL), the Watanabe-Akaike Information Criterion 
(WAIC) and its corresponding estimated number of effective parameters (p.w), and
the loglikelihood.</p>
</td></tr>
<tr><td><code>localised.structure</code></td>
<td>
<p>NULL, for compatability with other models.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model. If family=&quot;zip&quot; this also includes the zero probability
logistic regression formula.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A text string describing the model fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>A vector giving details of the numbers of MCMC samples generated.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix of covariates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#### Run the model on simulated data on a lattice
#################################################
#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)

#### Generate the covariates and response data
x1 &lt;- rnorm(K)
x2 &lt;- rnorm(K)
logit &lt;- x1 + x2
prob &lt;- exp(logit) / (1 + exp(logit))
trials &lt;- rep(50,K)
Y &lt;- rbinom(n=K, size=trials, prob=prob)

#### Run the model
formula &lt;- Y ~ x1 + x2
## Not run: model &lt;- S.glm(formula=formula, family="binomial", trials=trials, 
burnin=20000, n.sample=100000)
## End(Not run)

#### Toy example for checking
model &lt;- S.glm(formula=formula, family="binomial", trials=trials, 
burnin=10, n.sample=50)
</code></pre>

<hr>
<h2 id='S.RAB'>
Fit a spatial generalised linear model with anisotropic basis functions to data
for computationally efficient localised spatial smoothing, where the parameters 
are estimated by penalised maximum likelihood estimation with a ridge regression 
penalty.
</h2><span id='topic+S.RAB'></span>

<h3>Description</h3>

<p>Fit a spatial generalised linear model to areal unit data, where the response
variable can be binomial, Gaussian or Poisson. The linear predictor is modelled 
by known covariates and a set of K anisotropic spatial basis functions. The basis
functions are constructed from the set of geodesic distances between all pairs of 
areal units and a vector of ancillary data V, and the latter should have a similar
spatial pattern to the residual (after covariate adjustment) spatial structure in 
the data on the linear predictor scale. Parameter estimtion is carried out via 
penalised maximum likelihood methods, and the basis function coefficients are
constrained by a ridge regression penalty to prevent overfitting. The glmnet 
package is used for parameter estimation. Missing (NA) values are allowed in the 
response, and predictions are made for these values. This model implements localised
spatial smoothing and allows for boundaries in the data surface using a 
computationally efficient approach. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S.RAB(formula, family, data=NULL, trials=NULL, W, V, nlambda=100, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="S.RAB_+3A_formula">formula</code></td>
<td>

<p>A formula for the covariate part of the model using the syntax of the
lm() function. Offsets can be included here using the offset() function. The 
response, offset and each covariate is a vector of length K*1. The response can 
contain missing (NA) values.
</p>
</td></tr>
<tr><td><code id="S.RAB_+3A_family">family</code></td>
<td>

<p>One of either &quot;binomial&quot;, &quot;gaussian&quot;, or &quot;poisson&quot;, which respectively 
specify a binomial likelihood model with a logistic link function, 
a Gaussian likelihood model with an identity link function, or a Poisson likelihood 
model with a log link function. 
</p>
</td></tr>
<tr><td><code id="S.RAB_+3A_data">data</code></td>
<td>

<p>An optional data.frame containing the  variables in the formula.
</p>
</td></tr>
<tr><td><code id="S.RAB_+3A_trials">trials</code></td>
<td>

<p>A vector the same length as the response containing the total number of trials 
for each area. Only used if family=&quot;binomial&quot;. 
</p>
</td></tr>
<tr><td><code id="S.RAB_+3A_w">W</code></td>
<td>
<p>A non-negative K by K neighbourhood matrix (where K is the number of 
spatial units). Typically a binary specification is used, where the jkth 
element equals one if areas (j, k) are spatially close (e.g. share a common 
border) and is zero otherwise. The matrix can be non-binary, but each row must 
contain at least one non-zero entry.
</p>
</td></tr>
<tr><td><code id="S.RAB_+3A_v">V</code></td>
<td>

<p>A vector of ancillary data of length K, which should have a similar spatial 
pattern to the residual (after covariate adjustment) spatial structure in 
the data on the linear predictor scale.
</p>
</td></tr>
<tr><td><code id="S.RAB_+3A_nlambda">nlambda</code></td>
<td>

<p>The number of possible values to use for the penalty parameter lambda in the glmnet()
estimation function. Defaults to 100.
</p>
</td></tr>
<tr><td><code id="S.RAB_+3A_verbose">verbose</code></td>
<td>

<p>Logical, should the function update the user on its progress.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>beta.hat</code></td>
<td>
<p>The estimated regression parameters.</p>
</td></tr>
<tr><td><code>sigma2.hat</code></td>
<td>
<p>The estimated error variance in the Gaussian data likelihood 
model. If a Gaussian model is not specified it is NA.</p>
</td></tr>
<tr><td><code>lambda.hat</code></td>
<td>
<p>The estimated ridge regression penalty parameter.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>The level of residual spatial autocorrelation as measured by
Moran's I statistic.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values from the model.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A matrix with 2 columns where each column is a type of 
residual and each row relates to an area. The types are &quot;response&quot; (raw), 
and &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula (as a text string) for the response, covariate and 
offset parts of the model.</p>
</td></tr>
<tr><td><code>model.string</code></td>
<td>
<p>A text string describing the model fit.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The design matrix of covariates and spatial basis functions.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The fitted model object from the glmnet() function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Lee
</p>


<h3>References</h3>

<p>Lee, D (2024). Computationally efficient localised spatial smoothing of disease 
rates using anisotropic basis functions and penalised regression fitting, 
Spatial Statistics, 59, 100796.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#### Run the model on simulated data on a lattice
#################################################
#### Load other libraries required
library(MASS)

#### Set up a square lattice region
x.easting &lt;- 1:10
x.northing &lt;- 1:10
Grid &lt;- expand.grid(x.easting, x.northing)
K &lt;- nrow(Grid)

#### set up distance and neighbourhood (W, based on sharing a common border) matrices
distance &lt;- as.matrix(dist(Grid))
W &lt;-array(0, c(K,K))
W[distance==1] &lt;-1 	
	
#### Generate the spatial covariance structure
dists &lt;- as.numeric(distance[upper.tri(distance)])
dists.quant &lt;- quantile(dists, 0.05)
rho &lt;- log(0.75) / -dists.quant
Sigma &lt;- exp(-rho * distance)

#### Generate the boundaries
groups &lt;-rep(0, K) 
groups[Grid$Var2&gt;5] &lt;- 1

#### Generate the covariates and response data
x1 &lt;- rnorm(K)
x2 &lt;- rnorm(K)
phi &lt;- mvrnorm(n=1, mu=rep(0,K), Sigma=0.1 * exp(-rho * distance))
logit &lt;- x1 +  x2 + phi + 0.4 * groups
prob &lt;- exp(logit) / (1 + exp(logit))
trials &lt;- rep(100,K)
Y &lt;- rbinom(n=K, size=trials, prob=prob)

#### Generate the ancillary data
V &lt;- rnorm(n=K, mean=phi + 0.4*groups , sd=rep(0.05,K))

#### Run the RAB model
mod &lt;- S.RAB(formula=Y~x1+x2, family="binomial", data=NULL, trials=trials, W=W, 
        V=V, nlambda=50, verbose=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
