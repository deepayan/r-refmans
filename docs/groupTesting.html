<!DOCTYPE html><html lang="en"><head><title>Help for package groupTesting</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {groupTesting}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#array.gt.simulation'><p>Simulating Array-Based Group Testing Data</p></a></li>
<li><a href='#glm.gt'><p>EM Algorithm for Fitting Regression Models to Group Testing Data</p></a></li>
<li><a href='#glmLink'><p>Link Functions in the Class of Generalized Linear Models</p></a></li>
<li><a href='#hier.gt.simulation'><p>Simulating Hierarchical Group Testing Data</p></a></li>
<li><a href='#mle.prop.eff'><p>Efficiency of the Proportion Estimator Calculated from Group Testing Data</p></a></li>
<li><a href='#prop.gt'><p>EM Algorithm to Estimate the Prevalence of a Disease from Group Testing Data</p></a></li>
<li><a href='#waldTest'><p>Wald Chi-Square Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simulating and Modeling Group (Pooled) Testing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Md S. Warasi &lt;msarker@radford.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an expectation-maximization (EM) algorithm using the approach introduced in Warasi (2023) &lt;<a href="https://doi.org/10.1080%2F03610918.2021.2009867">doi:10.1080/03610918.2021.2009867</a>&gt;. The EM algorithm can be used to estimate the prevalence (overall proportion) of a disease and to estimate a binary regression model from among the class of generalized linear models based on group testing data. The estimation framework we consider offers a flexible and general approach; i.e., its application is not limited to any specific group testing protocol. Consequently, the EM algorithm can model data arising from simple pooling as well as advanced pooling such as hierarchical testing, array testing, and quality control pooling. Also, provided are functions that can be used to conduct the Wald tests described in Buse (1982) &lt;<a href="https://doi.org/10.1080%2F00031305.1982.10482817">doi:10.1080/00031305.1982.10482817</a>&gt; and to simulate the group testing data described in Kim et al. (2007) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2007.00817.x">doi:10.1111/j.1541-0420.2007.00817.x</a>&gt;. We offer a function to compute relative efficiency measures, which can be used to optimize the maximum likelihood estimator of disease prevalence.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>binGroup2, pracma, stats, parallel</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-17 15:02:23 UTC; msarker</td>
</tr>
<tr>
<td>Author:</td>
<td>Md S. Warasi [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-17 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='array.gt.simulation'>Simulating Array-Based Group Testing Data</h2><span id='topic+array.gt.simulation'></span>

<h3>Description</h3>

<p>This function simulates two-dimensional array-based group testing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array.gt.simulation(
  N,
  p = 0.1,
  protocol = c("A2", "A2M"),
  n,
  Se,
  Sp,
  assayID,
  Yt = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="array.gt.simulation_+3A_n">N</code></td>
<td>
<p>The number of individuals to be tested.</p>
</td></tr>
<tr><td><code id="array.gt.simulation_+3A_p">p</code></td>
<td>
<p>A vector of length N consisting of individual disease probabilities.</p>
</td></tr>
<tr><td><code id="array.gt.simulation_+3A_protocol">protocol</code></td>
<td>
<p>Either &quot;A2&quot; or &quot;A2M&quot;, where &quot;A2&quot; (&quot;A2M&quot;) refers to the two-dimensional array without (with) testing the members of an array as a single pooled sample.</p>
</td></tr>
<tr><td><code id="array.gt.simulation_+3A_n">n</code></td>
<td>
<p>The row (or column) size of the arrays.</p>
</td></tr>
<tr><td><code id="array.gt.simulation_+3A_se">Se</code></td>
<td>
<p>A vector of assay sensitivities.</p>
</td></tr>
<tr><td><code id="array.gt.simulation_+3A_sp">Sp</code></td>
<td>
<p>A vector of assay specificities.</p>
</td></tr>
<tr><td><code id="array.gt.simulation_+3A_assayid">assayID</code></td>
<td>
<p>A vector of assay identification numbers.</p>
</td></tr>
<tr><td><code id="array.gt.simulation_+3A_yt">Yt</code></td>
<td>
<p>A vector of individual true disease statuses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the array testing protocol outlined in Kim et al. (2007). Under this protocol, <code class="reqn">N</code> individuals are assigned to <code class="reqn">m</code> non-overlapping <code class="reqn">n</code>-by-<code class="reqn">n</code> matrices such that <code class="reqn">N=mn^2</code>. From each matrix, <code class="reqn">n</code> pools are formed using the row specimens and another <code class="reqn">n</code> pools are formed using the column specimens. In stage 1, the <code class="reqn">2n</code> pools are tested. In stage 2, individual testing is used for case identification according to the strategy described in Kim et al. (2007). This is a 2-stage protocol called <em>Square Array without Master Pool Testing</em> and denoted by <code class="reqn">A2(n:1)</code> in Kim et al. (2007). A variant (3-stage protocol) is also presented in Kim et al. (2007) which employs testing the <code class="reqn">n^2</code> array members together as an initial pooled unit before implementing the 2-stage array. If the initial pooled test is negative, the procedure stops (i.e., the 2-stage array is not needed). However, if the pooled test is positive, the 2-stage protocol is used as before. This 3-stage approach is called <em>Square Array with Master Pool Testing</em> and is denoted by <code class="reqn">A2(n^2:n:1)</code>. See Kim et al. (2007) for more details.
</p>
<p><code>N</code> should be divisible by the array size <code class="reqn">n^2</code>. When not divisible, the remainder individuals are tested one by one (i.e., individual testing).
</p>
<p><code>p</code> is a vector of individual disease probabilities. When all individuals have the same probability of disease, say, 0.10, <code>p</code> can be specified as rep(0.10, N) or p=0.10.
</p>
<p>For &quot;A2&quot; and &quot;A2M&quot;, the pool sizes used are <code>c(n, 1)</code> and <code>c(n^2, n, 1)</code>, respectively.
</p>
<p>For &quot;A2&quot;, <code>Se</code> is <code>c(Se1, Se2)</code>, where <code>Se1</code> is the sensitivity of the assay used for both row and column pools, and <code>Se2</code> is the sensitivity of the assay used for individual testing. For &quot;A2M&quot;, <code>Se</code> is <code>c(Se1, Se2, Se3)</code>, where <code>Se1</code> is for the initial array pool, <code>Se2</code> is for the row and column pools, and <code>Se3</code> is for individual testing. <code>Sp</code> is specified in the same manner.
</p>
<p>For &quot;A2&quot;, <code>assayID</code> is <code>c(1, 1)</code> when the same assay is used for row/column pool testing as well as for individual testing, and assayID is <code>c(1, 2)</code> when assay 1 is used for row/column pool testing and assay 2 is used for individual testing. In the same manner, <code>assayID</code> is specified for &quot;A2M&quot; as <code>c(1, 1, 1)</code>, <code>c(1, 2, 3)</code>, and in many other ways.
</p>
<p>When available, the individual true disease statuses (1 for positive and 0 for negative) can be used in simulating the group testing data through argument <code>Yt</code>. When an input is entered for <code>Yt</code>, argument <code>p</code> will be ignored.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>gtData</code></td>
<td>
<p>The simulated group testing data.</p>
</td></tr>
<tr><td><code>testsExp</code></td>
<td>
<p>The number of tests expended in the simulation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim HY, Hudgens M, Dreyfuss J, Westreich D, and Pilcher C (2007). Comparison of Group Testing Algorithms for Case Identification in the Presence of Testing Error. <em>Biometrics</em>, 63(4), 1152–1163.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hier.gt.simulation">hier.gt.simulation</a></code> for simulation of the hierarchical group testing data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(groupTesting)

## Example 1: Square Array without Master Pool Testing (i.e., 2-Stage Array)
N &lt;- 48              # Sample size
protocol &lt;- "A2"     # 2-stage array
n &lt;- 4               # Row/column size
Se &lt;- c(0.95, 0.95)  # Sensitivities in stages 1-2
Sp &lt;- c(0.98, 0.98)  # Specificities in stages 1-2
assayID &lt;- c(1, 1)   # The same assay in both stages

# (a) Homogeneous population
pHom &lt;- 0.10         # Overall prevalence
array.gt.simulation(N=N,p=pHom,protocol=protocol,n=n,Se=Se,Sp=Sp,assayID=assayID)

# Alternatively, the individual true statuses can be used as: 
yt &lt;- rbinom( N, size=1, prob=0.1 )
array.gt.simulation(N=N,protocol=protocol,n=n,Se=Se,Sp=Sp,assayID=assayID,Yt=yt)

# (b) Heterogeneous population (regression)
param &lt;- c(-3,2,1)
x1 &lt;- rnorm(N, mean=0, sd=.75)
x2 &lt;- rbinom(N, size=1, prob=0.5)
X &lt;- cbind(1, x1, x2)
pReg &lt;- exp(X%*%param)/(1+exp(X%*%param)) # Logit
array.gt.simulation(N=N,p=pReg,protocol=protocol,n=n,Se=Se,Sp=Sp,assayID=assayID)

# The above examples with different assays
Se &lt;- c(0.95, 0.98)
Sp &lt;- c(0.97, 0.99)
assayID &lt;- c(1, 2)
array.gt.simulation(N,pHom,protocol,n,Se,Sp,assayID)
array.gt.simulation(N,pReg,protocol,n,Se,Sp,assayID)

## Example 2: Square Array with Master Pool Testing (i.e., 3-Stage Array)
N &lt;- 48
protocol &lt;- "A2M"
n &lt;- 4
Se &lt;- c(0.95, 0.95, 0.95)
Sp &lt;- c(0.98, 0.98, 0.98)
assayID &lt;- c(1, 1, 1)    # The same assay in 3 stages

# (a) Homogeneous population
pHom &lt;- 0.10
array.gt.simulation(N,pHom,protocol,n,Se,Sp,assayID)

# (b) Heterogeneous population (regression)
param &lt;- c(-3,2,1)
x1 &lt;- rnorm(N, mean=0, sd=.75)
x2 &lt;- rbinom(N, size=1, prob=0.5)
X &lt;- cbind(1, x1, x2)
pReg &lt;- exp(X%*%param)/(1+exp(X%*%param)) # Logit
array.gt.simulation(N,pReg,protocol,n,Se,Sp,assayID)

# The above examples with different assays:
Se &lt;- c(0.95, 0.98, 0.98)
Sp &lt;- c(0.97, 0.98, 0.92)
assayID &lt;- 1:3
array.gt.simulation(N,pHom,protocol,n,Se,Sp,assayID)
array.gt.simulation(N,pReg,protocol,n,Se,Sp,assayID)

</code></pre>

<hr>
<h2 id='glm.gt'>EM Algorithm for Fitting Regression Models to Group Testing Data</h2><span id='topic+glm.gt'></span>

<h3>Description</h3>

<p>This function implements an expectation-maximization (EM) algorithm to fit regression models to group testing data, where pooled responses are related to individual covariates through a link function in the generalized linear model (GLM) family. The EM algorithm, which is outlined in Warasi (2023), finds the maximum likelihood estimate (MLE) for the vector of regression coefficients, <strong>beta</strong>. The EM algorithm can model pooling data observed from <strong>any</strong> group testing protocol used in practice, including hierarchical and array testing (Kim et al., 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.gt(
  beta0,
  gtData,
  X,
  g,
  dg = NULL,
  d2g = NULL,
  grdMethod = c("central", "forward", "backward"),
  covariance = FALSE,
  nburn = 2000,
  ngit = 5000,
  maxit = 200,
  tol = 0.001,
  tracing = TRUE,
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm.gt_+3A_beta0">beta0</code></td>
<td>
<p>An initial value for the regression coefficients.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_gtdata">gtData</code></td>
<td>
<p>A matrix or data.frame consisting of the pooled test outcomes and other information from a group testing application. Needs to be specified as shown in the example below.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_x">X</code></td>
<td>
<p>The design matrix.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_g">g</code></td>
<td>
<p>An inverse link function in the GLM family.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_dg">dg</code></td>
<td>
<p>The first derivate of <code>g</code>. When NULL, a finite-difference approximation will be used.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_d2g">d2g</code></td>
<td>
<p>The second derivate of <code>g</code>. When NULL, a finite-difference approximation will be used.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_grdmethod">grdMethod</code></td>
<td>
<p>The finite-difference approximation method to be used for <code>dg</code> and <code>d2g</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_covariance">covariance</code></td>
<td>
<p>When TRUE, the covariance matrix is calculated at the MLE.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_nburn">nburn</code></td>
<td>
<p>The number of initial Gibbs iterates to be discarded.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_ngit">ngit</code></td>
<td>
<p>The number of Gibbs iterates to be used in the E-step after discarding <code>nburn</code> iterates as a burn-in period.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of EM steps (iterations) allowed in the EM algorithm.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance used in the EM algorithm.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_tracing">tracing</code></td>
<td>
<p>When TRUE, progress in the EM algorithm is displayed.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level to be used for the Wald confidence interval.</p>
</td></tr>
<tr><td><code id="glm.gt_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="stats.html#topic+optim">optim</a></code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gtData</code> must be specified as follows. Columns 1-5 consist of the pooled test outcomes (0 for negative and 1 for positive), pool sizes, pool-specific sensitivities, pool-specific specificities, and assay identification (ID) numbers, respectively. From column 6 onward, the pool member ID numbers need to be specified. Note that the ID numbers must start with 1 and increase consecutively up to <code>N</code>, the total number of individuals tested. <strong>For smaller pools, incomplete ID numbers must be filled out by -9 or any non-positive numbers</strong> as shown in the example below. The design matrix <code>X</code> consists of invidual covariate information, such as age, sex, and symptoms, of the pool members located in column 6 onward.</p>

<table>
<tr>
 <td style="text-align: center;">
    </td><td style="text-align: center;"> Z </td><td style="text-align: center;"> psz </td><td style="text-align: center;"> Se </td><td style="text-align: center;"> Sp </td><td style="text-align: center;"> Assay </td><td style="text-align: center;"> Mem1 </td><td style="text-align: center;"> Mem2 </td><td style="text-align: center;"> Mem3 </td><td style="text-align: center;"> Mem4 </td><td style="text-align: center;"> Mem5 </td><td style="text-align: center;"> Mem6 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> 6 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:2 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 9 </td><td style="text-align: center;"> 10 </td><td style="text-align: center;"> 11 </td><td style="text-align: center;"> 12 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:3 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 0.95 </td><td style="text-align: center;"> 0.96 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:4 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 0.95 </td><td style="text-align: center;"> 0.96 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:5 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 0.95 </td><td style="text-align: center;"> 0.96 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:6 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:7 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:8 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:9 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>This is an example of <code>gtData</code>, where 12 individuals are assigned to 2 non-overlapping initial pools and then tested based on the 3-stage hierarchical protocol. The test outcomes, <code>Z</code>, from 9 pools are in column 1. In three stages, different pool sizes (6, 2, and 1), sensitivities, specificities, and assays are used. The ID numbers of the pool members are shown in columns 6-11. The row names and column names are not required. Note that the EM algorithm can accommodate any group testing data including those described in Kim et al. (2007). For individual testing data, the pool size in column 2 is 1 for all pools.
</p>
<p><code>X</code> is an <code class="reqn">N</code>x<code class="reqn">k</code> design matrix, where each column represents a vector of individual covariate values. For an intercept model, the first column values must be 1. The column (covariate) names of X, such as 'age' and 'sex', will be displayed in the estimation summary. When column names are missing (NULL), the names that will be displayed by default are 'Intercept', 'x1', 'x2', and so on.
</p>
<p>The EM algorithm implements a Gibbs sampler to approximate the expectation in the E-step. Under each EM iteration, <code>ngit</code> Gibbs samples are retained for these purposes after discarding the initial <code>nburn</code> samples.
</p>
<p><code>g</code> relates the pooled responses Z (column 1 in <code>gtData</code>) to <code>X</code>. <code>dg</code> and <code>d2g</code> can be specified analogously. These characteristics can be obtained from <code><a href="#topic+glmLink">glmLink</a></code> for the common links: logit, probit, and complementary log-log.
</p>
<p><code>grdMethod</code> is used only when dg and d2g are NULL, where a finite-difference approximation is implemented by the function <code>fderiv</code> from the package 'pracma'.
</p>
<p>The optimization routine <code><a href="stats.html#topic+optim">optim</a></code> is used to complete the M-step with the default method 'Nelder-Mead'. The argument ... allows the user to change the default method as well as other arguments in <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
<p>The covariance matrix is calculated by an appeal to the missing data principle and the method outlined in Louis (1982).
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>param</code></td>
<td>
<p>The MLE of the regression coefficients.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>Estimated covariance matrix for the regression coefficients.</p>
</td></tr>
<tr><td><code>iterUsed</code></td>
<td>
<p>The number of EM iterations needed for convergence.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>0 if the EM algorithm converges successfully and 1 if the iteration limit <code>maxit</code> has been reached.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>Estimation summary with Wald confidence interval.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim HY, Hudgens M, Dreyfuss J, Westreich D, and Pilcher C. (2007). Comparison of Group Testing Algorithms for Case Identification in the Presence of Testing Error. <em>Biometrics</em>, 63:1152-1163.
</p>
<p>Louis T. (1982). Finding the Observed Information Matrix when Using the EM algorithm. <em>Journal of the Royal Statistical Society: Series B</em>, 44:226-233.
</p>
<p>Vansteelandt S, Goetghebeur E, and Verstraeten T. (2000). Regression Models for Disease Prevalence with Diagnostic Tests on Pools of Serum Samples. <em>Biometrics</em>, 56:1126-1133.
</p>
<p>Warasi M. (2023). groupTesting: An R Package for Group Testing Estimation. <em>Communications in Statistics-Simulation and Computation</em>, 52:6210-6224.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hier.gt.simulation">hier.gt.simulation</a></code> and <code><a href="#topic+array.gt.simulation">array.gt.simulation</a></code> for group testing data simulation, and <code><a href="#topic+prop.gt">prop.gt</a></code> for estimation of a disease prevalence from group testing data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(groupTesting)

## To illustrate 'glm.gt', we use data simulated  
## by the functions 'hier.gt.simulation' and 'array.gt.simulation'.

## Note: The simulated data-structures are consistent  
## with the data-structure required for 'gtData'.

## Example 1: MLE from 3-stage hierarchical group testing data.
## The data used is simulated by 'hier.gt.simulation'. 

N &lt;- 200              # Sample size
S &lt;- 3                # 3-stage hierarchical testing
psz &lt;- c(6,2,1)       # Pool sizes used in stages 1-3
Se &lt;- c(.95,.95,.98)  # Sensitivities in stages 1-3
Sp &lt;- c(.95,.98,.96)  # Specificities in stages 1-3
assayID &lt;- c(1,2,3)   # Assays used in stages 1-3
param.t &lt;- c(-3,2,1)  # The TRUE parameter to be estimated

# Simulating covariates:
set.seed(123)
x1 &lt;- rnorm(N, mean=0, sd=0.75)
x2 &lt;- rbinom(N, size=1, prob=0.5)
X &lt;- cbind(1, x1, x2)
colnames( X ) &lt;- c("Intercept", "Predictor 1", "Predictor 2")
# Note: Because the 1st column of X is 1, intercept model will be fit.

# Specifying logit inverse link:
g &lt;- function(t){exp(t)/(1+exp(t))}  
pReg &lt;- g(X%*%param.t)

# Simulating test responses:
gtOut &lt;- hier.gt.simulation(N,pReg,S,psz,Se,Sp,assayID)$gtData

# Fitting the model (with intercept):
param0 &lt;- param.t + 0.2   # Initial value
res &lt;- glm.gt(beta0=param0,gtData=gtOut,X=X,
              g=g,dg=NULL,d2g=NULL,
              grdMethod="central",covariance=TRUE,
              nburn=2000,ngit=5000,maxit=200,
              tol=1e-03,tracing=TRUE,conf.level=0.95)

# Note: Because dg and d2g are NULL (i.e., the exact derivatives
#       are not given), numerical derivatives are used.

# Estimation results:
# &gt; res

# $param
# [1] -2.840802  1.992916  0.677176

# $covariance
#            [,1]        [,2]        [,3]
# [1,]  0.2134439 -0.10147555 -0.16693776
# [2,] -0.1014756  0.16855122  0.02997113
# [3,] -0.1669378  0.02997113  0.26324589

# $iterUsed
# [1] 10

# $convergence
# [1] 0

# $summary
#             Estimate Std.Err 95%lower 95%upper
# Intercept     -2.841   0.462   -3.746   -1.935
# Predictor 1    1.993   0.411    1.188    2.798
# Predictor 2    0.677   0.513   -0.328    1.683

## Example 2: MLE from two-dimensional array testing data.
## The data used is simulated by 'array.gt.simulation'. 

N &lt;- 200            # Sample size
protocol &lt;- "A2"     # 2-stage array without testing initial master pool
n &lt;- 5               # Row/column size
Se &lt;- c(0.95, 0.95)  # Sensitivities
Sp &lt;- c(0.98, 0.98)  # Specificities
assayID &lt;- c(1, 1)   # The same assay in both stages
param &lt;- c(-4,1,1)   # The TRUE parameter to be estimated

# Simulating data:
set.seed(123)
x1 &lt;- runif(N)
x2 &lt;- rnorm(N, mean=0, sd=0.5)
x3 &lt;- rbinom(N, size=1, prob=0.5)
X &lt;- cbind(x1, x2, x3)
# Note: Because the 1st column of X is not 1, 
#       the model without intercept will be fit.

# Finding g, dg, and d2g from the function 'glmLink':  
res0 &lt;- glmLink(fn.name="logit")  
g &lt;- res0$g            # Logit inverse link g()
dg &lt;- res0$dg          # The exact first derivate of g
d2g &lt;- res0$d2g        # The exact second derivate of g
pReg &lt;- g(X%*%param)   # Individual probabilities
gtOut &lt;- array.gt.simulation(N,pReg,protocol,n,Se,Sp,assayID)$gtData

# Fitting the model (without intercept):
param0 &lt;- param + 0.2 
res &lt;- glm.gt(beta0=param0,gtData=gtOut,X=X,g=g,                  
              dg=dg,d2g=d2g,covariance=TRUE,
              nburn=2000,ngit=5000,maxit=200,
              tol=1e-03,tracing=TRUE,conf.level=0.95)
print(res)


## Example 3: MLE from non-overlapping initial pooled responses.
## The data used is simulated by 'hier.gt.simulation'.

## Note: With initial pooled responses, our MLE is equivalent  
## to the MLE in Vansteelandt et al. (2000).

N &lt;- 1000             # Sample size
psz &lt;- 5              # Pool size
S &lt;- 1                # 1-stage testing
Se &lt;- 0.95            # Sensitivity
Sp &lt;- 0.99            # Specificity
assayID &lt;- 1          # Assay used for all pools
param &lt;- c(-3,2,1)    # The TRUE parameter to be estimated

# Simulating data:
set.seed(123)
x1 &lt;- rnorm(N, mean=0, sd=0.75)
x2 &lt;- rbinom(N, size=1, prob=0.5)
X &lt;- cbind(1, x1, x2)

# Finding g, dg, and d2g by the function 'glmLink':  
res0 &lt;- glmLink(fn.name="probit")  # Probit link
g &lt;- res0$g
dg &lt;- res0$dg
d2g &lt;- res0$d2g
pReg &lt;- g(X%*%param)
gtOut &lt;- hier.gt.simulation(N,pReg,S,psz,Se,Sp,assayID)$gtData

# Fitting the model:
param0 &lt;- param + 0.2
res &lt;- glm.gt(beta0=param0,gtData=gtOut,X=X,g=g,                 
                 dg=dg,d2g=d2g,covariance=TRUE,
                 nburn=2000,ngit=5000,maxit=200,
                 tol=1e-03,tracing=TRUE,conf.level=0.95)
print(res)

## Example 4: MLE from individual (one-by-one) testing data.
## The data used is simulated by 'hier.gt.simulation'.

N &lt;- 1000             # Sample size
psz &lt;- 1              # Pool size 1 (i.e., individual testing)
S &lt;- 1                # 1-stage testing
Se &lt;- 0.95            # Sensitivity
Sp &lt;- 0.99            # Specificity
assayID &lt;- 1          # Assay used for all pools
param &lt;- c(-3,2,1)    # The TRUE parameter to be estimated

# Simulating data:
set.seed(123)
x1 &lt;- rnorm(N, mean=0, sd=0.75)
x2 &lt;- rbinom(N, size=1, prob=0.5)
X &lt;- cbind(1, x1, x2)
g &lt;- function(t){exp(t)/(1+exp(t))}  # Inverse logit 
pReg &lt;- g(X%*%param)
gtOut &lt;- hier.gt.simulation(N,pReg,S,psz,Se,Sp,assayID)$gtData

# Fitting the model:
param0 &lt;- param + 0.2 
res &lt;- glm.gt(beta0=param0,gtData=gtOut,
              X=X,g=g,dg=NULL,d2g=NULL,
              grdMethod="central",covariance=TRUE,
              nburn=2000,ngit=5000,maxit=200,
              tol=1e-03,tracing=TRUE,conf.level=0.95)
print(res)

## Example 5: Using pooled testing data.

# Pooled test outcomes:
Z &lt;- c(1, 0, 1, 0, 1, 0, 1, 0, 0)     

# Design matrix, X:
x1 &lt;- c(0.8,1.2,0.4,1.5,1.8,1.8,0.1,1.6,0.2,0.2,1.8,0.2)
x2 &lt;- c(31,56,45,64,26,47,22,60,35,41,32,41)
X &lt;- cbind(x1, x2)

# Pool sizes used:
psz &lt;- c(6, 6, 2, 2, 2, 1, 1, 1, 1)

# Pool-specific Se &amp; Sp:
Se &lt;- c(.90, .90, .95, .95, .95, .92, .92, .92, .92)
Sp &lt;- c(.92, .92, .96, .96, .96, .90, .90, .90, .90)

# Assays used:
Assay &lt;- c(1, 1, 2, 2, 2, 3, 3, 3, 3)

# Pool members:
Memb &lt;- rbind( 
   c(1, 2,  3,  4,  5,  6),
   c(7, 8,  9, 10, 11, 12),
   c(1, 2, -9, -9, -9, -9),
   c(3, 4, -9, -9, -9, -9),
   c(5, 6, -9, -9, -9, -9),
   c(1,-9, -9, -9, -9, -9),
   c(2,-9, -9, -9, -9, -9),
   c(5,-9, -9, -9, -9, -9),
   c(6,-9, -9, -9, -9, -9)
)
# The data-structure suited for 'gtData':
gtOut &lt;- cbind(Z, psz, Se, Sp, Assay, Memb)

# Fitting the model with logit link:
g &lt;- function(t){exp(t)/(1+exp(t))} 
param0 &lt;- c(0, 0)      
res &lt;- glm.gt(beta0=param0,gtData=gtOut,X=X,                  
              g=g,dg=NULL,d2g=NULL,
              grdMethod="central",covariance=TRUE,
              nburn=2000,ngit=5000,maxit=200,
              tol=1e-03,tracing=TRUE,conf.level=0.95)
print(res)


</code></pre>

<hr>
<h2 id='glmLink'>Link Functions in the Class of Generalized Linear Models</h2><span id='topic+glmLink'></span>

<h3>Description</h3>

<p>This function provides characteristics of common link functions (logit, probit, and comlementary log-log). Specifically, based on the link name, the function with its inverse, first derivative, and second derivative is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmLink(fn.name = c("logit", "probit", "cloglog"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmLink_+3A_fn.name">fn.name</code></td>
<td>
<p>One of the three: &quot;logit&quot;, &quot;probit&quot;, and &quot;cloglog&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>g</code></td>
<td>
<p>The link function corresponding to &quot;logit&quot;, &quot;probit&quot;, or &quot;cloglog&quot;.</p>
</td></tr>
<tr><td><code>dg</code></td>
<td>
<p>The first derivative of g.</p>
</td></tr>
<tr><td><code>d2g</code></td>
<td>
<p>The second derivative of g.</p>
</td></tr>
<tr><td><code>gInv</code></td>
<td>
<p>The inverse of g.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(groupTesting)

## Try:
glmLink("logit")

</code></pre>

<hr>
<h2 id='hier.gt.simulation'>Simulating Hierarchical Group Testing Data</h2><span id='topic+hier.gt.simulation'></span>

<h3>Description</h3>

<p>This function simulates hierarchical group testing data with any number of hierarchical stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hier.gt.simulation(N, p = 0.1, S, psz, Se, Sp, assayID, Yt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hier.gt.simulation_+3A_n">N</code></td>
<td>
<p>The number of individuals to be tested.</p>
</td></tr>
<tr><td><code id="hier.gt.simulation_+3A_p">p</code></td>
<td>
<p>A vector of length N consisting of individual disease probabilities.</p>
</td></tr>
<tr><td><code id="hier.gt.simulation_+3A_s">S</code></td>
<td>
<p>The number of stages used in testing, where <code>S</code> &gt;= 1.</p>
</td></tr>
<tr><td><code id="hier.gt.simulation_+3A_psz">psz</code></td>
<td>
<p>A vector of pool sizes in stages 1-<code>S</code>.</p>
</td></tr>
<tr><td><code id="hier.gt.simulation_+3A_se">Se</code></td>
<td>
<p>A vector of assay sensitivities in stages 1-<code>S</code>.</p>
</td></tr>
<tr><td><code id="hier.gt.simulation_+3A_sp">Sp</code></td>
<td>
<p>A vector of assay specificities in stages 1-<code>S</code>.</p>
</td></tr>
<tr><td><code id="hier.gt.simulation_+3A_assayid">assayID</code></td>
<td>
<p>A vector of the identification numbers of the assays used in stages 1-<code>S</code>.</p>
</td></tr>
<tr><td><code id="hier.gt.simulation_+3A_yt">Yt</code></td>
<td>
<p>A vector of individual true disease statuses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the <code class="reqn">S</code>-stage hierarchical testing protocol outlined in Kim et al. (2007). Under this protocol, <code class="reqn">N</code> individual specimens are first assigned to <code class="reqn">m</code> non-overlapping pools, where each initial pool size is <code class="reqn">c</code>; i.e., <code class="reqn">N=mc</code>. The initial pools are tested in stage 1. If a pooled test is negative, all members in the pool are diagnosed as negative. However, if a pooled test is positive, the pool members are split into non-overlapping subpools to be tested in the next stage. This procedure is continued. Note that individual testing is used in the final stage, <code class="reqn">S</code>, for case identification.
</p>
<p><code>S</code> is a positive integer, <code>S</code> &gt;= 1. When <code>S</code>=1, only the non-overlapping initial pools are tested in stage 1.
</p>
<p>If <code>N</code> is not divisible by the initial pool size <code class="reqn">c</code>, we implement the following policy to test the remainder individuals: (1) when <code>S</code>=1, simply test the remainder pool once as a pooled sample; (2) when <code>S</code>&gt;1, test the remainder pool based on 2-stage hierarchical testing.
</p>
<p><code>p</code> is a vector of individual disease probabilities. When all individuals have the same probability of disease, say, 0.10, p can be specified as p=rep(0.10, N) or p=0.10.
</p>
<p><code>psz</code> is a vector of length <code>S</code>, where the first element is the stage-1 pool size, the second element is the stage-2 pool size, and so on. Pool size at any stage must be divisible by the pool size used at the next stage. For example, <code>psz</code> can be specified as <code>c(12,3,1)</code> but not as <code>c(12,5,1)</code>.
</p>
<p>When <code>psz</code> is a vector of length 1, test responses are simulated only from the initial pools.
</p>
<p><code>Se</code> is a vector of length <code>S</code>, where the first element is the sensitivity of the assay used in stage 1, the second element is sensitivity of the assay in stage 2, and so on.
</p>
<p><code>Sp</code> is a vector of length <code>S</code>, where the first element is the specificity of the assay used in stage 1, the second element is specificity of the assay in stage 2, and so on.
</p>
<p><code>assayID</code> is a vector of length <code>S</code>, where the first element is the ID of the assay in stage 1, the second element is the ID of the assay in stage 2, and so on.
</p>
<p>When available, the individual true disease statuses (1 for positive and 0 for negative) can be used in simulating the group testing data through argument <code>Yt</code>. When an input is entered for <code>Yt</code>, argument <code>p</code> will be ignored.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>gtData</code></td>
<td>
<p>The simulated group testing data.</p>
</td></tr>
<tr><td><code>testsExp</code></td>
<td>
<p>The number of tests expended.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim HY, Hudgens M, Dreyfuss J, Westreich D, and Pilcher C (2007). Comparison of Group Testing Algorithms for Case Identification in the Presence of Testing Error. <em>Biometrics</em>, 63(4), 1152–1163.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+array.gt.simulation">array.gt.simulation</a></code> for simulation of the array-based group testing data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(groupTesting)

## Example 1: Two-stage hierarchical (Dorfman) testing
N &lt;- 50              # Sample size
psz &lt;- c(5, 1)       # Pool sizes used in stages 1 and 2
S &lt;- 2               # The number of stages
Se &lt;- c(0.95, 0.95)  # Sensitivities in stages 1-2
Sp &lt;- c(0.98, 0.98)  # Specificities in stages 1-2
assayID &lt;- c(1, 1)   # The same assay in both stages

# (a) Homogeneous population
pHom &lt;- 0.10         # Overall prevalence
hier.gt.simulation(N=N,p=pHom,S=S,psz=psz,Se=Se,Sp=Sp,assayID=assayID)

# Alternatively, the individual true statuses can be used as: 
yt &lt;- rbinom( N, size=1, prob=0.1 )
hier.gt.simulation(N=N,S=S,psz=psz,Se=Se,Sp=Sp,assayID=assayID,Yt=yt)

# (b) Heterogeneous population (regression)
param &lt;- c(-3,2,1)
x1 &lt;- rnorm(N, mean=0, sd=.75)
x2 &lt;- rbinom(N, size=1, prob=0.5)
X &lt;- cbind(1, x1, x2)
pReg &lt;- exp(X%*%param)/(1+exp(X%*%param)) # Logit
hier.gt.simulation(N=N,p=pReg,S=S,psz=psz,Se=Se,Sp=Sp,assayID=assayID)

## Example 2: Initial (1-stage) pooled testing data
N &lt;- 50
S &lt;- 1
Se &lt;- 0.95
Sp &lt;- 0.98
assayID &lt;- 1

# (a) Homogeneous population 
pHom &lt;- 0.10   # Overall prevalence

# a(i) Pooled testing
psz &lt;- 5       # pool size    
hier.gt.simulation(N,pHom,S,psz,Se,Sp,assayID)

# a(ii) Inidividual testing
psz &lt;- 1       # pool size    
hier.gt.simulation(N,pHom,S,psz,Se,Sp,assayID)

# (b) Heterogeneous population (regression)
param &lt;- c(-3,2,1)
x1 &lt;- rnorm(N, mean=0, sd=.75)
x2 &lt;- rbinom(N, size=1, prob=0.5)
X &lt;- cbind(1, x1, x2)
pReg &lt;- exp(X%*%param)/(1+exp(X%*%param))  # Logit

# b(i) Pooled testing
psz &lt;- 5
hier.gt.simulation(N,pReg,S,psz,Se,Sp,assayID)

# b(ii) Individual testing
psz &lt;- 1
hier.gt.simulation(N,pReg,S,psz,Se,Sp,assayID)

## Example 3: Data with other configurations
N &lt;- 48
p &lt;- 0.10
Se &lt;- c(.90, .95, .92, .90, .99)
Sp &lt;- c(.96, .96, .90, .92, .95)
Assay &lt;- 1:5

# Initial pooled testing, using the first element of Se, Sp &amp; Assay
pszH1 &lt;- 4
hier.gt.simulation(N=N,p=p,S=1,psz=pszH1,Se=Se,Sp=Sp,assayID=Assay)

pszH2 &lt;- c(4,1)       # Two-stage, using first 2 elements of Se, Sp &amp; Assay
hier.gt.simulation(N=N,p=p,S=2,psz=pszH2,Se=Se,Sp=Sp,assayID=Assay)

pszH4 &lt;- c(16,8,2,1)  # Four-stage, using first 4 elements of Se, Sp &amp; Assay
hier.gt.simulation(N=N,p=p,S=4,psz=pszH4,Se=Se,Sp=Sp,assayID=Assay)

pszH3 &lt;- c(12,2,1)    # Three-stage, using first 3 elements of Se, Sp &amp; Assay
Assay3 &lt;- c(2,1,3)    # Array ID numbers do not need to be in order
hier.gt.simulation(N=N,p=p,S=3,psz=pszH3,Se=Se,Sp=Sp,assayID=Assay3)

# Works with a remainder pool of 2 individuals
N &lt;- 50
psz &lt;- c(12,2,1)
hier.gt.simulation(N=N,p=p,S=3,psz=psz,Se=Se,Sp=Sp,assayID=Assay)

</code></pre>

<hr>
<h2 id='mle.prop.eff'>Efficiency of the Proportion Estimator Calculated from Group Testing Data</h2><span id='topic+mle.prop.eff'></span>

<h3>Description</h3>

<p>This function provides relative efficiency results for the maximum likelihood estimator of disease prevalence (proportion), <code class="reqn">p</code>. The estimator, <code class="reqn">\hat{p}</code>, is calculated using test responses from commonly used group testing protocols. The relative efficiency values measure how effective group testing is for estimating the prevalence when compared to individual testing. The function also calculates expected testing and estimation costs. Please refer to Warasi and Das (2024), where the statistical methods were introduced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.prop.eff(
  p,
  Se,
  Sp,
  initial.psz,
  protocol = c("MPT", "H2", "H3", "H4", "A2", "A2M"),
  criterion = c("RTE", "REE", "RCE"),
  N = 800,
  ngit = 3000,
  maxit = 200,
  tol = 0.001,
  nrep = 3000,
  seed = NULL,
  ncore = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle.prop.eff_+3A_p">p</code></td>
<td>
<p>Proportion of individuals truly positive for a disease (i.e., disease prevalence).</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_se">Se</code></td>
<td>
<p>Assay sensitivity, a scalar value.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_sp">Sp</code></td>
<td>
<p>Assay specificity, a scalar value.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_initial.psz">initial.psz</code></td>
<td>
<p>A vector of initial pool sizes.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_protocol">protocol</code></td>
<td>
<p>One of the six group testing protocols, where 'MPT' is the default.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_criterion">criterion</code></td>
<td>
<p>One of the three optimization criteria, where 'RTE' is the default.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_n">N</code></td>
<td>
<p>Number of individuals to be tested using group testing (i.e., sample size).</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_ngit">ngit</code></td>
<td>
<p>Number of Gibbs iterates used in the EM algorithm.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterates in the EM algorithm.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance for the EM algorithm.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_nrep">nrep</code></td>
<td>
<p>Number of repetitions used in the proposed computation algorithm.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_seed">seed</code></td>
<td>
<p>A single seed value, an integer.</p>
</td></tr>
<tr><td><code id="mle.prop.eff_+3A_ncore">ncore</code></td>
<td>
<p>Number of CPU cores to be used in computing, where ncore =&gt; 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mle.prop.eff</code> computes three measures of efficiency: relative testing efficiency (RTE), relative estimation efficiency (REE), and relative cost efficiency (RCE). These measures can be calculated for six common group testing protocols: master pool testing (MPT), hierarchical testing with two, three, and four stages (H2, H3, and H4), and array testing without and with master pool testing (A2 and A2M). For more information on these protocols, refer to Kim et al. (2007). We use the term 'relative efficiency' because these measures compare group testing (numerator) with the usual one-at-a-time, i.e., individual testing (denominator).
</p>
<p>In the paper, we defined 'RTE' and discussed how it can be calculated for both common and more complex group testing protocols. For the five multistage protocols (H2, H3, H4, A2, and A2M), our function provides RTE values based on the analytic expressions of Kim et al. (2007). These expressions have been coded by Hitt et al. (2023) in their R package 'binGroup2'. We developed R code to restructure the output obtained from binGroup2, so it is consistent with our proposed method.
</p>
<p>Based on the expressions in our article, we analytically calculate REE for MPT and H2 and also compute RCE for MPT. For other scenarios, we determine REE and RCE based on our proposed computation algorithm.
</p>
<p>The expected costs, <code class="reqn">E[T]</code>, <code class="reqn">E[(\hat{p} - p)^2]</code>, and <code class="reqn">E[T(\hat{p} - p)^2]</code>, are calculated for a given <code class="reqn">N</code>, the number of individuals to be tested. The 'MPT' and 'H2' protocols require that <code class="reqn">N</code> is completely divisible by the initial pool size <code class="reqn">k</code>. If this is not the case, the integer that is closest to <code class="reqn">N</code> and divisible by <code class="reqn">k</code> will be used. It is worth noting that <code class="reqn">N</code> is also used in the computation algorithm, where a large-sample assumption is made. We found that <code class="reqn">N = 800</code> may be sufficient in most scenarios for the validity of this assumption, although we used <code class="reqn">N = 1200</code> in the article; for more information, refer to Warasi and Das (2024).
</p>
<p>Arguments 'ngit', 'maxit', and 'tol' are used in the EM algorithm. We found that 'ngit = 3000' Gibbs iterates are generally sufficient, but using a bigger 'ngit' may be more reliable. The default choices for 'maxit' and 'tol' are also reasonable.
</p>
<p>Argument 'nrep' is necessary for the validity of the law of large numbers in the computation algorithm. While a larger choice of 'nrep' is generally preferable, our paper suggests that 5000 repetitions may be sufficient in most scenarios. Note that 'nrep = 3000' or so may also provide reasonable approximations.
</p>
<p>Execution of 'RCE' for multistage protocols (H2, H3, H4, A2, and A2M) is quite slow because it uses Gibbs samplers in the computation algorithm. For the same reason, execution of 'REE' for H3, H4, A2, and A2M is also slow. To overcome this limitation, we included the <code>ncore</code> argument, which enables users to perform the computing tasks using parallel CPUs through the <code>parallel</code> package. The program works with <code>ncore = 1</code> or with any larger choice of <code>ncore</code>.
</p>
<p>Specifying a 'seed' ensures reproducibility of the results produced by our function, whether one uses a single core or multiple cores. Note that the seed value is used only when the computation algorithm is implemented.
</p>


<h3>Value</h3>

<p>A list with three matrix objects labeled as &quot;efficiency&quot;, &quot;expected_cost&quot;, &quot;iterations&quot;:
</p>

<ul>
<li> <p><strong>&quot;efficiency&quot;</strong>: A matrix that reports the relative efficiency results: RTE, REE, and RCE.
</p>
</li>
<li> <p><strong>&quot;expected_cost&quot;</strong>: A matrix reporting the expected costs: <code class="reqn">E[T]</code>, <code class="reqn">E[(\hat{p} - p)^2]</code>, and <code class="reqn">E[T(\hat{p} - p)^2]</code>, corresponding to the criteria RTE, REE, and RCE, respectively.
</p>
</li>
<li> <p><strong>&quot;iterations&quot;</strong>: A matrix that provides the cumulative running average of the estimates (sample means) of <code class="reqn">E[(\hat{p} - p)^2]</code> and <code class="reqn">E[T(\hat{p} - p)^2]</code> when the computation algorithm is used. These running estimates can be useful for verification of the 'law of large numbers', as demonstrated in the Web Appendix of the article Warasi and Das (2024). In each row of the matrix, the first 1, 2, or 3 columns are for pool size(s) and the remaining 'nrep' columns provide the running averages; see the examples.
</p>
</li></ul>

<p>These results are provided for all possible pooling configurations within the specified range of initial pool sizes. The stage-specific pool sizes are also included in the results.
</p>


<h3>References</h3>


<ul>
<li><p> Kim HY, Hudgens M, Dreyfuss J, Westreich D, and Pilcher C. (2007). Comparison of Group Testing Algorithms for Case Identification in the Presence of Testing Error. <em>Biometrics</em>, 63:1152-1163.
</p>
</li>
<li><p> Zhang W, Liu A, Li Q, Albert P. (2020). Incorporating Retesting Outcomes for Estimation of Disease Prevalence. <em>Statistics in Medicine</em>, 39:687-697.
</p>
</li>
<li><p> Warasi and Das (2024). Optimizing Disease Surveillance Through Pooled Testing with Application to Infectious Diseases. <em>Journal of Agricultural, Biological and Environmental Statistics</em>. In press.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(groupTesting)

## Gonorrhea data information:
p0 &lt;- 0.041       # True prevalence  
Se &lt;- 0.913       # Assay sensitivity
Sp &lt;- 0.993       # Assay specificity
psz &lt;- 2:6        # A range of initial pool sizes
 
 
## Example 1: Two-stage hierarchical testing (H2)  

## REE (using closed-form expressions)
res &lt;- mle.prop.eff(p=p0, Se=Se, Sp=Sp, initial.psz=psz, protocol="H2", criterion="REE")

## Output

# &gt; res
# $efficiency
#      PSZ.S1 PSZ.S2    REE
# [1,]      2      1 0.8920
# [2,]      3      1 0.8932
# [3,]      4      1 0.8975
# [4,]      5      1 0.9034
# [5,]      6      1 0.9104

# $expected_cost
# PSZ.S1 PSZ.S2 E[(phat-p)^2]
# [1,]      2      1  5.731668e-05
# [2,]      3      1  5.732655e-05
# [3,]      4      1  5.767260e-05
# [4,]      5      1  5.805423e-05
# [5,]      6      1  5.864758e-05

# $iterations
# NULL


## RTE (using closed-form expressions)
mle.prop.eff(p=p0, Se=Se, Sp=Sp, initial.psz=psz, protocol="H2", criterion="RTE")

## RCE (using the computation algorithm)
# res &lt;- mle.prop.eff(p=p0, Se=Se, Sp=Sp, initial.psz=psz, protocol="H2", seed=123, 
#   criterion="RCE", N=800, ngit=3000, maxit=200, tol=0.001, nrep=3000, ncore=4)

# Note: For 'H2' protocol, get cumulative running averages as:
# res2 &lt;- res$iterations[ ,-(1:2)] 
# Now, plot each row; for example: plot(res2[1, ], type='l')
#
# Execution of 'RCE' for H2 is slow, as discussed in the 'details' section.
# The computing challenge can be overcome using multiple CPU cores as shown above. 


## Example 2: Three-stage hierarchical testing (H3)

## REE (using the computation algorithm)
# res &lt;- mle.prop.eff(p=p0, Se=Se, Sp=Sp, initial.psz=psz, protocol="H3", seed=123, 
#   criterion="REE", N=800, ngit=3000, maxit=200, tol=0.001, nrep=3000, ncore=4)
#
# Note: For 'H3' protocol, get cumulative running averages as:
# res2 &lt;- res$iterations[ ,-(1:3)]  # Now, plot each row: plot(res2[1, ], type='l')

## RTE (using closed-form expressions)
# res &lt;- mle.prop.eff(p=p0, Se=Se, Sp=Sp, initial.psz=psz, protocol="H3",  
#   criterion="RTE", N=800, ngit=3000, maxit=200, tol=0.001, nrep=3000, ncore=4)

## RCE (using the computation algorithm)
# res &lt;- mle.prop.eff(p=p0, Se=Se, Sp=Sp, initial.psz=psz, protocol="H3", seed=123, 
#   criterion="RCE", N=800, ngit=3000, maxit=200, tol=0.001, nrep=3000, ncore=4)



</code></pre>

<hr>
<h2 id='prop.gt'>EM Algorithm to Estimate the Prevalence of a Disease from Group Testing Data</h2><span id='topic+prop.gt'></span>

<h3>Description</h3>

<p>This function implements an expectation-maximization (EM) algorithm to find the maximum likelihood estimate (MLE) of a disease prevalence, p, based on group testing data. The EM algorithm, which is outlined in Warasi (2023), can model pooling data observed from <strong>any</strong> group testing protocol used in practice, including hierarchical and array testing (Kim et al., 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop.gt(
  p0,
  gtData,
  covariance = FALSE,
  nburn = 2000,
  ngit = 5000,
  maxit = 200,
  tol = 0.001,
  tracing = TRUE,
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prop.gt_+3A_p0">p0</code></td>
<td>
<p>An initial value of the prevalence.</p>
</td></tr>
<tr><td><code id="prop.gt_+3A_gtdata">gtData</code></td>
<td>
<p>A matrix or data.frame consisting of the pooled test outcomes and other information from a group testing application. Needs to be specified as shown in the example below.</p>
</td></tr>
<tr><td><code id="prop.gt_+3A_covariance">covariance</code></td>
<td>
<p>When TRUE, the variance is calculated at the MLE.</p>
</td></tr>
<tr><td><code id="prop.gt_+3A_nburn">nburn</code></td>
<td>
<p>The number of initial Gibbs iterates to be discarded.</p>
</td></tr>
<tr><td><code id="prop.gt_+3A_ngit">ngit</code></td>
<td>
<p>The number of Gibbs iterates to be used in the E-step after discarding the initial iterates as a burn-in period.</p>
</td></tr>
<tr><td><code id="prop.gt_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of EM steps (iterations) allowed in the EM algorithm.</p>
</td></tr>
<tr><td><code id="prop.gt_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance used in the EM algorithm.</p>
</td></tr>
<tr><td><code id="prop.gt_+3A_tracing">tracing</code></td>
<td>
<p>When TRUE, progress in the EM algorithm is displayed.</p>
</td></tr>
<tr><td><code id="prop.gt_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level to be used for the Wald confidence interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gtData</code> must be specified as follows. Columns 1-5 consist of the pooled test outcomes (0 for negative and 1 for positive), pool sizes, pool-specific sensitivities, pool-specific specificities, and assay ID numbers, respectively. From column 6 onward, the pool member ID numbers need to be specified. Note that the ID numbers must start with 1 and increase consecutively up to <code>N</code>, the total number of individuals tested. <strong>For smaller pools, incomplete ID numbers must be filled out by -9 or any non-positive numbers</strong> as shown in the example below.</p>

<table>
<tr>
 <td style="text-align: center;">
    </td><td style="text-align: center;"> Z </td><td style="text-align: center;"> psz </td><td style="text-align: center;"> Se </td><td style="text-align: center;"> Sp </td><td style="text-align: center;"> Assay </td><td style="text-align: center;"> Mem1 </td><td style="text-align: center;"> Mem2 </td><td style="text-align: center;"> Mem3 </td><td style="text-align: center;"> Mem4 </td><td style="text-align: center;"> Mem5 </td><td style="text-align: center;"> Mem6 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> 6 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:2 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 7 </td><td style="text-align: center;"> 8 </td><td style="text-align: center;"> 9 </td><td style="text-align: center;"> 10 </td><td style="text-align: center;"> 11 </td><td style="text-align: center;"> 12 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:3 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 0.95 </td><td style="text-align: center;"> 0.96 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:4 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 0.95 </td><td style="text-align: center;"> 0.96 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 4 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:5 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 0.95 </td><td style="text-align: center;"> 0.96 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:6 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:7 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 2 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:8 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 5 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
   Pool:9 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0.92 </td><td style="text-align: center;"> 0.90 </td><td style="text-align: center;"> 3 </td><td style="text-align: center;"> 6 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td><td style="text-align: center;"> -9 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>This is an example of <code>gtData</code>, where 12 individuals are assigned to 2 non-overlapping initial pools and then tested based on the 3-stage hierarchical protocol. The test outcomes, <code>Z</code>, from 9 pools are in column 1. In three stages, different pool sizes (6, 2, and 1), sensitivities, specificities, and assays are used. The ID numbers of the pool members are shown in columns 6-11. The row names and column names are not required. Note that the EM algorithm can accommodate any group testing data including those described in Kim et al. (2007). For individual testing data, the pool size in column 2 is 1 for all pools.
</p>
<p>The EM algorithm implements a Gibbs sampler to approximate quantities required to complete the E-step. Under each EM iteration, <code>ngit</code> Gibbs samples are retained for these purposes after discarding the initial <code>nburn</code> samples.
</p>
<p>The variance of the MLE is calculated by an appeal to the missing data principle and the method outlined in Louis (1982).
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>param</code></td>
<td>
<p>The MLE of the disease prevalence.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>Estimated variance for the disease prevalence.</p>
</td></tr>
<tr><td><code>iterUsed</code></td>
<td>
<p>The number of EM iterations used for convergence.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>0 if the EM algorithm converges successfully and 1 if the iteration limit <code>maxit</code> has been reached.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>Estimation summary with Wald confidence interval.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kim HY, Hudgens M, Dreyfuss J, Westreich D, and Pilcher C. (2007). Comparison of Group Testing Algorithms for Case Identification in the Presence of Testing Error. <em>Biometrics</em>, 63:1152-1163.
</p>
<p>Litvak E, Tu X, and Pagano M. (1994). Screening for the Presence of a Disease by Pooling Sera Samples. <em>Journal of the American Statistical Association</em>, 89:424-434.
</p>
<p>Liu A, Liu C, Zhang Z, and Albert P. (2012). Optimality of Group Testing in the Presence of Misclassification. <em>Biometrika</em>, 99:245-251.
</p>
<p>Louis T. (1982). Finding the Observed Information Matrix when Using the EM algorithm. <em>Journal of the Royal Statistical Society: Series B</em>, 44:226-233.
</p>
<p>Warasi M. (2023). groupTesting: An R Package for Group Testing Estimation. <em>Communications in Statistics-Simulation and Computation</em>, 52:6210-6224.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hier.gt.simulation">hier.gt.simulation</a></code> and <code><a href="#topic+array.gt.simulation">array.gt.simulation</a></code> for group testing data simulation, and <code><a href="#topic+glm.gt">glm.gt</a></code> for group testing regression models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(groupTesting)

## To illustrate 'prop.gt', we use data simulated by 
## the R functions 'hier.gt.simulation' and 'array.gt.simulation'.

## The simulated data-structures are consistent  
## with the data-structure required for 'gtData'.

## Example 1: MLE from 3-stage hierarchical group testing data.
## The data used is simulated by 'hier.gt.simulation'.

N &lt;- 90               # Sample size
S &lt;- 3                # 3-stage hierarchical testing
psz &lt;- c(6,2,1)       # Pool sizes used in stages 1-3
Se &lt;- c(.95,.95,.98)  # Sensitivities in stages 1-3
Sp &lt;- c(.95,.98,.96)  # Specificities in stages 1-3
assayID &lt;- c(1,2,3)   # Assays used in stages 1-3
p.t &lt;- 0.05           # The TRUE parameter to be estimated

# Simulating data:
set.seed(123)
gtOut &lt;- hier.gt.simulation(N,p.t,S,psz,Se,Sp,assayID)$gtData

# Running the EM algorithm:
pStart &lt;- p.t + 0.2   # Initial value
res &lt;- prop.gt(p0=pStart,gtData=gtOut,covariance=TRUE,
               nburn=2000,ngit=5000,maxit=200,tol=1e-03,
               tracing=TRUE,conf.level=0.95)

# Estimation results:
# &gt; res

# $param
# [1] 0.05158

# $covariance
#              [,1]
# [1,] 0.0006374296

# $iterUsed
# [1] 4

# $convergence
# [1] 0

# $summary
#      Estimate StdErr 95%lower 95%upper
# prop    0.052  0.025    0.002    0.101

## Example 2: MLE from two-dimensional array testing data.
## The data used is simulated by 'array.gt.simulation'.

N &lt;- 100             # Sample size
protocol &lt;- "A2"     # 2-stage array without testing the initial master pool
n &lt;- 5               # Row/column size
Se &lt;- c(0.95, 0.95)  # Sensitivities
Sp &lt;- c(0.98, 0.98)  # Specificities
assayID &lt;- c(1, 1)   # The same assay in both stages
p.true &lt;- 0.05       # The TRUE parameter to be estimated

# Simulating data:
set.seed(123)
gtOut &lt;- array.gt.simulation(N,p.true,protocol,n,Se,Sp,assayID)$gtData

# Fitting the model:
pStart &lt;- p.true + 0.2  # Initial value
res &lt;- prop.gt(p0=pStart,gtData=gtOut,covariance=TRUE)
print(res)


## Example 3: MLE from non-overlapping initial pooled responses.
## The data used is simulated by 'hier.gt.simulation'. 

## Note: With initial pooled responses, our MLE is equivalent  
## to the MLE in Litvak et al. (1994) and Liu et al. (2012).

N &lt;- 1000             # Sample size
psz &lt;- 5              # Pool size
S &lt;- 1                # 1-stage testing
Se &lt;- 0.95            # Sensitivity
Sp &lt;- 0.99            # Specificity
assayID &lt;- 1          # Assay used for all pools
p.true &lt;- 0.05        # True parameter

set.seed(123)
gtOut &lt;- hier.gt.simulation(N,p.true,S,psz,Se,Sp,assayID)$gtData

pStart &lt;- p.true + 0.2   # Initial value
res &lt;- prop.gt(p0=pStart,gtData=gtOut,
               covariance=TRUE,nburn=2000,ngit=5000,
               maxit=200,tol=1e-03,tracing=TRUE)
print(res)

## Example 4: MLE from individual (one-by-one) testing data.
## The data used is simulated by 'hier.gt.simulation'.

N &lt;- 1000             # Sample size
psz &lt;- 1              # Pool size 1 (i.e., individual testing)
S &lt;- 1                # 1-stage testing
Se &lt;- 0.95            # Sensitivity
Sp &lt;- 0.99            # Specificity
assayID &lt;- 1          # Assay used for all pools
p.true &lt;- 0.05        # True parameter

set.seed(123)
gtOut &lt;- hier.gt.simulation(N,p.true,S,psz,Se,Sp,assayID)$gtData

pStart &lt;- p.true + 0.2   # Initial value
res &lt;- prop.gt(p0=pStart,gtData=gtOut,
               covariance=TRUE,nburn=2000,
               ngit=5000,maxit=200,
               tol=1e-03,tracing=TRUE)
print(res)

## Example 5: Using pooled testing data.

# Pooled test outcomes:
Z &lt;- c(1, 0, 1, 0, 1, 0, 1, 0, 0)     

# Pool sizes used:
psz &lt;- c(6, 6, 2, 2, 2, 1, 1, 1, 1)

# Pool-specific Se &amp; Sp:
Se &lt;- c(.90, .90, .95, .95, .95, .92, .92, .92, .92)
Sp &lt;- c(.92, .92, .96, .96, .96, .90, .90, .90, .90)

# Assays used:
Assay &lt;- c(1, 1, 2, 2, 2, 3, 3, 3, 3)

# Pool members:
Memb &lt;- rbind( 
   c(1, 2,  3,  4,  5,  6),
   c(7, 8,  9, 10, 11, 12),
   c(1, 2, -9, -9, -9, -9),
   c(3, 4, -9, -9, -9, -9),
   c(5, 6, -9, -9, -9, -9),
   c(1,-9, -9, -9, -9, -9),
   c(2,-9, -9, -9, -9, -9),
   c(5,-9, -9, -9, -9, -9),
   c(6,-9, -9, -9, -9, -9)
)
# The data-structure suited for 'gtData':
gtOut &lt;- cbind(Z, psz, Se, Sp, Assay, Memb)

# Fitting the model:
pStart &lt;- 0.10
res &lt;- prop.gt(p0=pStart,gtData=gtOut,
               covariance=TRUE,nburn=2000,
               ngit=5000,maxit=200,
               tol=1e-03,tracing=TRUE)
print(res)


</code></pre>

<hr>
<h2 id='waldTest'>Wald Chi-Square Test</h2><span id='topic+waldTest'></span>

<h3>Description</h3>

<p>This function implements the Wald <em>chi-square</em> test on a <code class="reqn">K</code>x<code class="reqn">1</code> parameter vector <strong>theta</strong>. The test assumes that <strong>thetaHat</strong>, a consistent estimator of <strong>theta</strong> such as MLE, is asymptotically normal with mean <strong>theta</strong> and covariance matrix <strong>Sigma</strong>. The function can implement 1 test on <strong>theta</strong> as well as multiple, <strong>Q</strong>, tests jointly on <strong>theta</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waldTest(R, thetaHat, Sigma, r = 0, L = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="waldTest_+3A_r">R</code></td>
<td>
<p>A <code class="reqn">Q</code>x<code class="reqn">K</code> matrix of known coefficients depending on how the test is to be carried out.</p>
</td></tr>
<tr><td><code id="waldTest_+3A_thetahat">thetaHat</code></td>
<td>
<p>An estimate of <strong>theta</strong>.</p>
</td></tr>
<tr><td><code id="waldTest_+3A_sigma">Sigma</code></td>
<td>
<p>An estimated covariance matrix for <code>thetaHat</code>.</p>
</td></tr>
<tr><td><code id="waldTest_+3A_r">r</code></td>
<td>
<p>A <code class="reqn">Q</code>x<code class="reqn">1</code> matrix of hypothesized values.</p>
</td></tr>
<tr><td><code id="waldTest_+3A_l">L</code></td>
<td>
<p>A character string to be used as a name of the test. When NULL, &quot;L&quot; will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that Q tests are to be performed jointly on the K by 1 parameter vector <strong>theta</strong>. Let R be a <code class="reqn">Q</code>x<code class="reqn">K</code> matrix of known coefficients such as 0, 1, and -1, and r be a <code class="reqn">Q</code>x<code class="reqn">1</code> matrix of hypothesized values. The hypotheses are <code class="reqn">H0:</code> <code class="reqn">R</code><code class="reqn">\theta</code> = <code class="reqn">r</code> vs. <code class="reqn">H1</code>: <code class="reqn">R</code><code class="reqn">\theta</code> != <code class="reqn">r</code>. The test statistic has a chi-square distribution with Q degrees of freedom (Buse, 1982; Agresti, 2002).
</p>


<h3>Value</h3>

<p>A data.frame object of the Wald test results.
</p>


<h3>References</h3>

<p>Agresti A. (2002). Categorical Data Analysis (2nd ed.). Wiley. ISBN 0471360937.
</p>
<p>Buse A. (1982). The Likelihood Ratio, Wald, and Lagrange Multiplier Tests: An Expository Note. <em>The American Statistician</em>, 36:153-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(groupTesting)

## Example 1
# Parameter: p (proportion)
MLE &lt;- 0.42
Var &lt;- 0.016
# (a) Test  H0: p = 0.50  vs. H1: p != 0.50
R &lt;- matrix(1, nrow=1, ncol=1)
p0 &lt;- 0.50
waldTest( R=R, thetaHat=MLE, r=p0, Sigma=Var ) 

## Example 2
# Parameter: beta = (beta1, beta2), regression coefficients
MLE &lt;- c(1.09, 2.95)
Cov &lt;- rbind(c(0.21, -0.27), 
             c(-0.27, 0.66))
# (a) Test  H0: beta1 = beta2  vs. H1: beta1 != beta2
R &lt;- rbind(c(1,-1))
waldTest( R=R, thetaHat=MLE, r=0, Sigma=Cov, L="1 vs 2" )

# (b) Test  H0: beta1 = 0  vs. H1: beta1 != 0
R &lt;- rbind(c(1,0))
waldTest( R=R, thetaHat=MLE, r=0, Sigma=Cov )

## Example 3
# Parameter: beta = (beta0, beta1, beta2)
MLE &lt;- c(-3.05, 1.99, 0.93)
Cov &lt;- rbind(c( 0.045, -0.022, -0.034),
             c(-0.022,  0.032,  0.008),
             c(-0.034,  0.008,  0.048))

# Performing simultaneous test:
# H0: beta0  = -3, H0: beta1  = 2, H0: beta2  = 1
# H1: beta0 != -3, H1: beta1 != 2, H1: beta2 != 1
R &lt;- rbind(c(1,0,0), 
           c(0,1,0), 
           c(0,0,1))
r &lt;- matrix( c(-3,2,1), nrow=3 )
waldTest( R=R, thetaHat=MLE, r=r, Sigma=Cov)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
