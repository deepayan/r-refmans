<!DOCTYPE html><html><head><title>Help for package unheadr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unheadr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#unheadr-package'><p>unheadr: Handle Data with Messy Header Rows and Broken Values</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>re-export magrittr pipe operator</p></a></li>
<li><a href='#annotate_mf'><p>Annotate meaningful formatting</p></a></li>
<li><a href='#annotate_mf_all'><p>Annotate meaningful formatting for all cells</p></a></li>
<li><a href='#AOEunits'><p>Statistics for game units in Age of Empires II: Definitive Edition</p></a></li>
<li><a href='#AOEunits_raw'><p>Statistics for game units in Age of Empires II: Definitive Edition in a messy presentation</p></a></li>
<li><a href='#boutiques.xlsx'><p>boutiques.xlsx spreadsheet</p></a></li>
<li><a href='#dog_test.xlsx'><p>dog_test.xlsx spreadsheet</p></a></li>
<li><a href='#mash_colnames'><p>Make many header rows into column names</p></a></li>
<li><a href='#primates2017'><p>Comparative data for 54 species of primates</p></a></li>
<li><a href='#primates2017_broken'><p>Comparative data for 16 species of primates with some broken values</p></a></li>
<li><a href='#primates2017_wrapped'><p>Comparative data for two species of primates</p></a></li>
<li><a href='#regex_valign'><p>Vertical character string alignment through regular expressions</p></a></li>
<li><a href='#unbreak_rows'><p>Merge rows up</p></a></li>
<li><a href='#unbreak_vals'><p>Unbreak values using regex to match the lagging half of the broken value</p></a></li>
<li><a href='#untangle2'><p>Rectangling embedded subheaders</p></a></li>
<li><a href='#unwrap_cols'><p>Unwrap values and clean up NAs used as padding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Handle Data with Messy Header Rows and Broken Values</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Verb-like functions to work with messy data, often derived from 
             spreadsheets or parsed PDF tables. Includes functions for unwrapping 
             values broken up across rows, relocating embedded grouping values, 
             and to annotate meaningful formatting in spreadsheet files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.4), rlang (&ge; 0.2.1), forcats, stringr, tidyr,
magrittr, tidyxl, readxl, tibble</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0), covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/luisDVA/unheadr">https://github.com/luisDVA/unheadr</a>, <a href="https://unheadr.liomys.mx/">https://unheadr.liomys.mx/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/luisDVA/unheadr/issues">https://github.com/luisDVA/unheadr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-15 00:08:00 UTC; luisd</td>
</tr>
<tr>
<td>Author:</td>
<td>Luis D. Verde Arregoitia
    <a href="https://orcid.org/0000-0001-9520-6543"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luis D. Verde Arregoitia &lt;luis@liomys.mx&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-15 05:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='unheadr-package'>unheadr: Handle Data with Messy Header Rows and Broken Values</h2><span id='topic+unheadr'></span><span id='topic+unheadr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Verb-like functions to work with messy data, often derived from spreadsheets or parsed PDF tables. Includes functions for unwrapping values broken up across rows, relocating embedded grouping values, and to annotate meaningful formatting in spreadsheet files.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Luis D. Verde Arregoitia <a href="mailto:luis@liomys.mx">luis@liomys.mx</a> (<a href="https://orcid.org/0000-0001-9520-6543">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/luisDVA/unheadr">https://github.com/luisDVA/unheadr</a>
</p>
</li>
<li> <p><a href="https://unheadr.liomys.mx/">https://unheadr.liomys.mx/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/luisDVA/unheadr/issues">https://github.com/luisDVA/unheadr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>re-export magrittr pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>re-export magrittr pipe operator
</p>

<hr>
<h2 id='annotate_mf'>Annotate meaningful formatting</h2><span id='topic+annotate_mf'></span>

<h3>Description</h3>

<p>Turns cell formatting into annotations for values in the target row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_mf(xlfilepath, orig, new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_mf_+3A_xlfilepath">xlfilepath</code></td>
<td>
<p>Path to a single-sheet spreadsheet file (xls or xlsx).</p>
</td></tr>
<tr><td><code id="annotate_mf_+3A_orig">orig</code></td>
<td>
<p>Variable to annotate formatting in.</p>
</td></tr>
<tr><td><code id="annotate_mf_+3A_new">new</code></td>
<td>
<p>Name of new variable with cell formatting pasted as a string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At this point, seven popular approaches for meaningful
formatting (bold, colored text, italic, strikethrough, underline, double underline, and cell highlighting) are hardcoded in
the function. <code>sheets</code>, <code>skip</code>, and <code>range</code> arguments for spreadsheet input
are not supported. The hex8 code of the fill color used for text color and cell
highlighting is also appended in the output. Ensure the data in the
spreadsheet are rectangular before running.
</p>


<h3>Value</h3>

<p>A tibble with a new column with meaningful formatting embedded as
text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_spreadsheet &lt;- system.file("extdata/dog_test.xlsx", package = "unheadr")
annotate_mf(example_spreadsheet, orig = Task, new = Task_annotated)
</code></pre>

<hr>
<h2 id='annotate_mf_all'>Annotate meaningful formatting for all cells</h2><span id='topic+annotate_mf_all'></span>

<h3>Description</h3>

<p>Turns cell formatting into annotations for all values across all variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_mf_all(xlfilepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_mf_all_+3A_xlfilepath">xlfilepath</code></td>
<td>
<p>Path to a single-sheet spreadsheet file (xls or xlsx).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At this point, seven popular approaches for meaningful
formatting (bold, colored text, italic, strikethrough, underline, double underline, and cell highlighting) are hardcoded in
the function. <code>sheets</code>, <code>skip</code>, and <code>range</code> arguments for spreadsheet input
are not supported. The hex8 code of the fill color used for text color and cell
highlighting is also appended in the output. Ensure the data in the
spreadsheet are rectangular before running.
</p>


<h3>Value</h3>

<p>A tibble with meaningful formatting embedded as text for all rows and
columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_spreadsheet &lt;- system.file("extdata/boutiques.xlsx", package = "unheadr")
annotate_mf_all(example_spreadsheet)
</code></pre>

<hr>
<h2 id='AOEunits'>Statistics for game units in Age of Empires II: Definitive Edition</h2><span id='topic+AOEunits'></span>

<h3>Description</h3>

<p>A dataset with the numerical values that determine the behavior and
performance of selected military units available in AoE2:DE (July 2020 Game
Update).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AOEunits
</code></pre>


<h3>Format</h3>

<p>A data frame with 128 observations of 19 variables:
</p>

<dl>
<dt>unit</dt><dd><p>Unit name</p>
</dd>
<dt>building</dt><dd><p>Building in which each unit is trained</p>
</dd>
<dt>type</dt><dd><p>Unit class</p>
</dd>
<dt>age</dt><dd><p>Age at which the unit becomes trainable</p>
</dd>
<dt>cost_wood</dt><dd><p>Unit cost in Wood</p>
</dd>
<dt>cost_food</dt><dd><p>Unit cost in Food</p>
</dd>
<dt>cost_gold</dt><dd><p>Unit cost in Gold</p>
</dd>
<dt>build_time</dt><dd><p>Training time in seconds</p>
</dd>
<dt>rate_of_fire</dt><dd><p>Attack speed</p>
</dd>
<dt>attack_delay</dt><dd><p>Retasking time</p>
</dd>
<dt>movement_speed</dt><dd><p>Travel speed on land</p>
</dd>
<dt>line_of_sight</dt><dd><p>Vision over the surrounding area</p>
</dd>
<dt>hit_points</dt><dd><p>Unit health</p>
</dd>
<dt>min_range</dt><dd><p>Minimum attacking range for ranged units</p>
</dd>
<dt>range</dt><dd><p>Maximum attacking range for ranged units</p>
</dd>
<dt>damage</dt><dd><p>Damage inflicted per attack</p>
</dd>
<dt>accuracy</dt><dd><p>Chance that an attack will be on target</p>
</dd>
<dt>melee_armor</dt><dd><p>Armor against melee attacks</p>
</dd>
<dt>pierce_armor</dt><dd><p>Armor against projectiles</p>
</dd>
</dl>



<h3>Source</h3>

<p>Age of Empires II. Copyright Microsoft Corporation. This dataset was created
under Microsoft's &quot;Game Content Usage Rules&quot;
<a href="https://www.xbox.com/en-us/developers/rules">https://www.xbox.com/en-us/developers/rules</a> using assets from Age of
Empires II, and it is not endorsed by or affiliated with Microsoft. All
information shown is an interpretation of data collected in-game with no
guarantee on the accuracy of any of the data presented.
</p>

<hr>
<h2 id='AOEunits_raw'>Statistics for game units in Age of Empires II: Definitive Edition in a messy presentation</h2><span id='topic+AOEunits_raw'></span>

<h3>Description</h3>

<p>A messy version of the <code><a href="#topic+AOEunits">AOEunits</a></code> dataset, meant for demonstrating data cleaning functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AOEunits_raw
</code></pre>


<h3>Format</h3>

<p>A data frame with 139 observations of 15 variables. See <code>AOEunits</code> for variable descriptions.
</p>


<h3>Source</h3>

<p>Age of Empires II. Copyright Microsoft Corporation. This dataset was created
under Microsoft's &quot;Game Content Usage Rules&quot;
<a href="https://www.xbox.com/en-us/developers/rules">https://www.xbox.com/en-us/developers/rules</a> using assets from Age of
Empires II, and it is not endorsed by or affiliated with Microsoft. All
information shown is an interpretation of data collected in-game with no
guarantee on the accuracy of any of the data presented.
</p>

<hr>
<h2 id='boutiques.xlsx'>boutiques.xlsx spreadsheet</h2><span id='topic+boutiques.xlsx'></span>

<h3>Description</h3>

<p>Open XML Format Spreadsheet with 1 sheet, 6 columns, and 8 rows. Toy dataset
with Q1 profits for different store locations. Additional information
is encoded as meaningful formatting. Bold indicates losses (negative values),
colors indicate continent, and italic indicates a second location in the same
city.
</p>


<h3>Details</h3>

<p>This data is used in the example for <code>annotate_mf_all()</code>.
</p>

<hr>
<h2 id='dog_test.xlsx'>dog_test.xlsx spreadsheet</h2><span id='topic+dog_test.xlsx'></span>

<h3>Description</h3>

<p>Open XML Format Spreadsheet with 1 sheet, 2 columns, and 12 rows. Items
describe various tasks or behaviors that dogs can be evaluated on, assigned
into three categories which appear along with their average scores as
embedded subheaders with meaningful formatting.
</p>


<h3>Details</h3>

<p>This data is used in the example for <code>annotate_mf()</code>.
</p>


<h3>Source</h3>

<p>Items are modified from the checklist written by Junior Watson.
</p>


<h3>References</h3>

<p>http://www.dogtrainingbasics.com/checklist-well-behaved-dog/
</p>

<hr>
<h2 id='mash_colnames'>Make many header rows into column names</h2><span id='topic+mash_colnames'></span>

<h3>Description</h3>

<p>Make many header rows into column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mash_colnames(
  df,
  n_name_rows,
  keep_names = TRUE,
  sliding_headers = FALSE,
  sep = "_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mash_colnames_+3A_df">df</code></td>
<td>
<p>A <code>data.frame</code> or <code>tibble</code> object in which the names are broken up
across the top <em>n</em> rows.</p>
</td></tr>
<tr><td><code id="mash_colnames_+3A_n_name_rows">n_name_rows</code></td>
<td>
<p>Number of rows at the top of the data to be used to create
the new variable (column) names. Must be &gt;= 1.</p>
</td></tr>
<tr><td><code id="mash_colnames_+3A_keep_names">keep_names</code></td>
<td>
<p>If TRUE, existing names will be included in building the
new variable names. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="mash_colnames_+3A_sliding_headers">sliding_headers</code></td>
<td>
<p>If TRUE, empty values in the first (topmost) header
header row be filled column-wise. Defaults to FALSE. See details.</p>
</td></tr>
<tr><td><code id="mash_colnames_+3A_sep">sep</code></td>
<td>
<p>Character string to separate the unified values (default is
underscore).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tables are often shared with the column names broken up across the
first few rows. This function takes the number of rows at the top of a
table that hold the broken up names and whether or not to include the
names, and mashes the values column-wise into a single string for each
column. The <code>keep_names</code> argument can be helpful for tables we
imported using a <code>skip</code> argument. If <code>keep_names</code> is set to <code>FALSE</code>,
adjust the value of <code>n_name_rows</code> accordingly.
</p>
<p>This function will throw a warning when possible <code>NA</code> values end up in the
variable names. <code>sliding_headers</code> can be used for tables with ragged
names in which not every column has a value in the very first row. In these
cases attribution by adjacency is assumed, and when <code>sliding_headers</code>
is set to <code>TRUE</code> the names in the topmost row are filled row-wise. This can
be useful for tables reporting survey data or experimental designs in an
untidy manner.
</p>


<h3>Value</h3>

<p>The original data frame, but with new column names and without the
top n rows that held the broken up names.
</p>


<h3>Author(s)</h3>

<p>This function was originally contributed by Jarrett Byrnes through a
GitHub issue.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>babies &lt;-
  data.frame(
    stringsAsFactors = FALSE,
    Baby = c(NA, NA, "Angie", "Yean", "Pierre"),
    Age = c("in", "months", "11", "9", "7"),
    Weight = c("kg", NA, "2", "3", "4"),
    Ward = c(NA, NA, "A", "B", "C")
  )
# Including the object names
mash_colnames(babies, n_name_rows = 2, keep_names = TRUE)

babies_skip &lt;-
  data.frame(
    stringsAsFactors = FALSE,
    X1 = c("Baby", NA, NA, "Jennie", "Yean", "Pierre"),
    X2 = c("Age", "in", "months", "11", "9", "7"),
    X3 = c("Hospital", NA, NA, "A", "B", "A")
  )
#' # Discarding the automatically-generated names (X1, X2, etc...)
mash_colnames(babies_skip, n_name_rows = 3, keep_names = FALSE)

fish_experiment &lt;-
  data.frame(
    stringsAsFactors = FALSE,
    X1 = c("Sample", NA, "Pacific", "Atlantic", "Freshwater"),
    X2 = c("Larvae", "Control", "12", "11", "10"),
    X3 = c(NA, "Low Dose", "11", "12", "8"),
    X4 = c(NA, "High Dose", "8", "7", "9"),
    X5 = c("Adult", "Control", "13", "13", "8"),
    X6 = c(NA, "Low Dose", "13", "12", "7"),
    X7 = c(NA, "High Dose", "10", "10", "9")
  )
# Ragged names
mash_colnames(fish_experiment,
  n_name_rows = 2,
  keep_names = FALSE, sliding_headers = TRUE
)
</code></pre>

<hr>
<h2 id='primates2017'>Comparative data for 54 species of primates</h2><span id='topic+primates2017'></span>

<h3>Description</h3>

<p>A dataset with embedded subheaders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primates2017
</code></pre>


<h3>Format</h3>

<p>A data frame with 69 rows and 4 variables:
</p>

<dl>
<dt>scientific_name</dt><dd><p>scientific names, with geographic region and
taxonomic family embedded as subheaders.</p>
</dd>
<dt>common_name</dt><dd><p>vernacular name</p>
</dd>
<dt>red_list_status</dt><dd><p>IUCN Red List Status in January 2017</p>
</dd>
<dt>mass_kg</dt><dd><p>mean body mass in kilograms</p>
</dd>
</dl>



<h3>Source</h3>

<p>Estrada, Alejandro, et al. &quot;Impending extinction crisis of the
world's primates: Why primates matter.&quot; Science Advances 3.1 (2017):
e1600946. <a href="https://doi.org/10.1126/sciadv.1600946">doi:10.1126/sciadv.1600946</a>
</p>

<hr>
<h2 id='primates2017_broken'>Comparative data for 16 species of primates with some broken values</h2><span id='topic+primates2017_broken'></span>

<h3>Description</h3>

<p>A dataset with embedded subheaders and some values (T. obscurus, T.
leucocephalus and N. bengalensis) in the scientific_names variable broken up
across two rows (typically done to fit the content in a table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primates2017_broken
</code></pre>


<h3>Format</h3>

<p>A data frame with 19 rows and 4 variables:
</p>

<dl>
<dt>scientific_name</dt><dd><p>scientific names, with embedded subheaders
for geographic region and taxonomic family and broken values</p>
</dd>
<dt>common_name</dt><dd><p>vernacular name</p>
</dd>
<dt>red_list_status</dt><dd><p>IUCN Red List Status in January 2017</p>
</dd>
<dt>mass_kg</dt><dd><p>mean body mass in kilograms</p>
</dd>
</dl>



<h3>Source</h3>

<p>Estrada, Alejandro, et al. &quot;Impending extinction crisis of the
world's primates: Why primates matter.&quot; Science Advances 3.1 (2017):
e1600946. <a href="https://doi.org/10.1126/sciadv.1600946">doi:10.1126/sciadv.1600946</a>
</p>

<hr>
<h2 id='primates2017_wrapped'>Comparative data for two species of primates</h2><span id='topic+primates2017_wrapped'></span>

<h3>Description</h3>

<p>A dataset in which the elements for some of the values are in separate rows'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primates2017_wrapped
</code></pre>


<h3>Format</h3>

<p>A data frame with 9 rows and 6 variables:
</p>

<dl>
<dt>scientific_name</dt><dd><p>scientific names, see reference</p>
</dd>
<dt>common_name</dt><dd><p>vernacular name</p>
</dd>
<dt>habitat</dt><dd><p>habitat types listed in the IUCN Red List assessments</p>
</dd>
<dt>red_list_status</dt><dd><p>IUCN Red List Status in January 2017</p>
</dd>
<dt>mass_kg</dt><dd><p>mean body mass in kilograms</p>
</dd>
<dt>country</dt><dd><p>Countries where the species is present, from IUCN Red
List assessments</p>
</dd>
</dl>



<h3>Source</h3>

<p>Estrada, Alejandro, et al. &quot;Impending extinction crisis of the
world's primates: Why primates matter.&quot; Science Advances 3.1 (2017):
e1600946. <a href="https://doi.org/10.1126/sciadv.1600946">doi:10.1126/sciadv.1600946</a>
</p>

<hr>
<h2 id='regex_valign'>Vertical character string alignment through regular expressions</h2><span id='topic+regex_valign'></span>

<h3>Description</h3>

<p>Aligning strings with regex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regex_valign(stringvec, regex_ai, sep_str = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regex_valign_+3A_stringvec">stringvec</code></td>
<td>
<p>A character vector with one element for each line.</p>
</td></tr>
<tr><td><code id="regex_valign_+3A_regex_ai">regex_ai</code></td>
<td>
<p>A regular expression matching the position for alignment.</p>
</td></tr>
<tr><td><code id="regex_valign_+3A_sep_str">sep_str</code></td>
<td>
<p>Optional character vector that will be inserted at the
positions matched by the regular expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Written mainly for reading fixed width files, text, or tables parsed
from PDFs.
</p>


<h3>Value</h3>

<p>A character vector with one element for each line, with padding
inserted at the matched positions so that elements are vertically aligned
across lines.
</p>


<h3>See Also</h3>

<p>This function is based loosely on
<code>textutils::valign()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guests &lt;-
  unlist(strsplit(c("6       COAHUILA        20/03/2020
7       COAHUILA             20/03/2020
18 BAJA CALIFORNIA     16/03/2020
109       CDMX      12/03/2020
1230   QUERETARO       21/03/2020"), "\n"))

# align at first uppercase word boundary , inserting a separator
regex_valign(guests, "\\b(?=[A-Z])", " - ")
# align dates at end of string
regex_valign(guests, "\\b(?=[0-9]{2}[\\/]{1}[0-9]{2}[\\/]{1}[0-9]{4}$)")
</code></pre>

<hr>
<h2 id='unbreak_rows'>Merge rows up</h2><span id='topic+unbreak_rows'></span>

<h3>Description</h3>

<p>Merge rows up
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbreak_rows(df, regex, ogcol, sep = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbreak_rows_+3A_df">df</code></td>
<td>
<p>A data frame with at least two contiguous rows to be merged.</p>
</td></tr>
<tr><td><code id="unbreak_rows_+3A_regex">regex</code></td>
<td>
<p>A regular expression to identify sets of rows to be merged,
meant for the leading of the two contiguous rows.</p>
</td></tr>
<tr><td><code id="unbreak_rows_+3A_ogcol">ogcol</code></td>
<td>
<p>Variable with the text strings to match.</p>
</td></tr>
<tr><td><code id="unbreak_rows_+3A_sep">sep</code></td>
<td>
<p>Character string to separate the unified values (default is
space).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function recodes empty strings (&quot;&quot;) to <code>NA</code> for smoother pattern matching.
</p>


<h3>Value</h3>

<p>A tibble or data frame with merged rows. Values of the
lagging rows are pasted onto the values in the leading row, whitespace is
squished, and the lagging row is dropped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bball &lt;-
  data.frame(
    stringsAsFactors = FALSE,
    v1 = c(
      "Player", NA, "Sleve McDichael", "Dean Wesrey",
      "Karl Dandleton"
    ),
    v2 = c("Most points", "in a game", "55", "43", "41"),
    v3 = c("Season", "(year ending)", "2001", "2000", "2010")
  )
unbreak_rows(bball, "Most", v2)
</code></pre>

<hr>
<h2 id='unbreak_vals'>Unbreak values using regex to match the lagging half of the broken value</h2><span id='topic+unbreak_vals'></span>

<h3>Description</h3>

<p>Unbreak values using regex to match the lagging half of the broken value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbreak_vals(df, regex, ogcol, newcol, sep = " ", slice_groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbreak_vals_+3A_df">df</code></td>
<td>
<p>A data frame with one or more values within a variable broken up
across two rows.</p>
</td></tr>
<tr><td><code id="unbreak_vals_+3A_regex">regex</code></td>
<td>
<p>Regular expression for matching the trailing (lagging) half of the broken
values.</p>
</td></tr>
<tr><td><code id="unbreak_vals_+3A_ogcol">ogcol</code></td>
<td>
<p>Variable to unbreak.</p>
</td></tr>
<tr><td><code id="unbreak_vals_+3A_newcol">newcol</code></td>
<td>
<p>Name of the new variable with the unified values.</p>
</td></tr>
<tr><td><code id="unbreak_vals_+3A_sep">sep</code></td>
<td>
<p>Character string to separate the unified values (default is
space).</p>
</td></tr>
<tr><td><code id="unbreak_vals_+3A_slice_groups">slice_groups</code></td>
<td>
<p>Deprecated. See details and Package News.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is limited to quite specific cases, but useful when
dealing with tables that contain, for example, scientific names broken across two rows.
For unwrapping values, see <code><a href="#topic+unwrap_cols">unwrap_cols</a></code>.
</p>


<h3>Value</h3>

<p>A tibble with 'unbroken' values. The variable that originally
contained the broken values gets dropped, and the new variable with the
unified values is placed as the first column. The <code>slice_groups</code>
argument is now deprecated; the extra rows and the variable with broken
values will be dropped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates2017_broken)
# regex matches strings starting in lowercase (broken species epithets)
unbreak_vals(primates2017_broken, "^[a-z]", scientific_name, sciname_new)
</code></pre>

<hr>
<h2 id='untangle2'>Rectangling embedded subheaders</h2><span id='topic+untangle2'></span>

<h3>Description</h3>

<p>Rectangling embedded subheaders
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untangle2(df, regex, orig, new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="untangle2_+3A_df">df</code></td>
<td>
<p>A data frame with embedded subheaders.</p>
</td></tr>
<tr><td><code id="untangle2_+3A_regex">regex</code></td>
<td>
<p>Regular expression to match the subheaders.</p>
</td></tr>
<tr><td><code id="untangle2_+3A_orig">orig</code></td>
<td>
<p>Variable containing the extraneous subheaders.</p>
</td></tr>
<tr><td><code id="untangle2_+3A_new">new</code></td>
<td>
<p>Name of variable that will contain the group values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Special thanks to Jenny Bryan for fixing the initial tidyeval code
and overall function structure.
</p>


<h3>Value</h3>

<p>A tibble without the matched subheaders and a new variable containing
the grouping data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates2017)
# put taxonomic family in its own variable (matches the suffix "DAE")
untangle2(primates2017, "DAE$", scientific_name, family)
# put geographic regions in their own variable (matching them all by name)
untangle2(
  primates2017, "Asia|Madagascar|Mainland Africa|Neotropics",
  scientific_name, family
)
# with magrittr pipes (re-exported in this package)
primates2017 %&gt;%
  untangle2("DAE$", scientific_name, family) %&gt;%
  untangle2(
    "Asia|Madagascar|Mainland Africa|Neotropics",
    scientific_name, region
  )
</code></pre>

<hr>
<h2 id='unwrap_cols'>Unwrap values and clean up NAs used as padding</h2><span id='topic+unwrap_cols'></span>

<h3>Description</h3>

<p>Unwrap values and clean up NAs used as padding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwrap_cols(df, groupingVar, separator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwrap_cols_+3A_df">df</code></td>
<td>
<p>A data frame with wrapped values and an inconsistent number of NA
values used to as within-group padding.</p>
</td></tr>
<tr><td><code id="unwrap_cols_+3A_groupingvar">groupingVar</code></td>
<td>
<p>Name of the variable describing the observational units.</p>
</td></tr>
<tr><td><code id="unwrap_cols_+3A_separator">separator</code></td>
<td>
<p>Character string defining the separator that will delimit
the elements of the unwrapped value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is roughly the opposite of <code>tidyr::separate_rows()</code>.
</p>


<h3>Value</h3>

<p>A summarized tibble. Order is preserved in the grouping variable by
making it a factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates2017_wrapped)
# using commas to separate elements
unwrap_cols(primates2017_wrapped, scientific_name, ", ")

# separating with semicolons
df &lt;- data.frame(
  ounits = c("A", NA, "B", "C", "D", NA),
  vals = c(1, 2, 2, 3, 1, 3)
)
unwrap_cols(df, ounits, ";")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
