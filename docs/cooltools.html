<!DOCTYPE html><html lang="en"><head><title>Help for package cooltools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cooltools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cooltools-package'><p>Practical Tools for Scientific Computations and Visualizations</p></a></li>
<li><a href='#.cooltools.env'><p>Package environment</p></a></li>
<li><a href='#alp'><p>Associated Legendre Polynomials</p></a></li>
<li><a href='#approxfun2'><p>Bilinear interpolation function of data on a regular grid</p></a></li>
<li><a href='#bindata'><p>Bin two-dimensional data in one dimension</p></a></li>
<li><a href='#car2pol'><p>Cartesian to polar/cylindrical coordinate conversion</p></a></li>
<li><a href='#car2sph'><p>Cartesian to spherical coordinate conversion</p></a></li>
<li><a href='#cmplx2col'><p>Convert complex numbers to color</p></a></li>
<li><a href='#colorbar'><p>Vertical color bar</p></a></li>
<li><a href='#contourlevel'><p>Find contour levels of a d-dimensional density field</p></a></li>
<li><a href='#cosmofct'><p>Fast cosmology conversion functions</p></a></li>
<li><a href='#cshift'><p>Circularly shift each dimension of an array</p></a></li>
<li><a href='#cst'><p>Scientific constants</p></a></li>
<li><a href='#cubehelix'><p>Cube Helix colour palette</p></a></li>
<li><a href='#dft'><p>Discrete Fourier Transform</p></a></li>
<li><a href='#dftgrid'><p>Produce coordinates for Discrete Fourier Transform</p></a></li>
<li><a href='#dpqr'><p>d/p/q/r-family for a custom distribution</p></a></li>
<li><a href='#entropy'><p>Information entropy</p></a></li>
<li><a href='#errlines'><p>Draw a line with uncertainty regions</p></a></li>
<li><a href='#fibonaccisphere'><p>Evenly distributed n points on a sphere</p></a></li>
<li><a href='#gradient'><p>Compute gradient</p></a></li>
<li><a href='#grf'><p>Gaussian Random Field generator</p></a></li>
<li><a href='#griddata'><p>Distribute a point set onto a regular grid</p></a></li>
<li><a href='#histcoord'><p>Generate histogram coordinates from mid points</p></a></li>
<li><a href='#inertia'><p>Inertia tensor</p></a></li>
<li><a href='#invert'><p>Invert and shift colors of an image</p></a></li>
<li><a href='#is.equal'><p>Numerical equality check</p></a></li>
<li><a href='#jackknife'><p>Jackknife Estimation</p></a></li>
<li><a href='#kde2'><p>Multi-dimensional adaptive kernel density estimation</p></a></li>
<li><a href='#landyszalay'><p>Two-point correlation estimation</p></a></li>
<li><a href='#last'><p>Last element of a vector</p></a></li>
<li><a href='#lightness'><p>Change lightness of a color</p></a></li>
<li><a href='#lim'><p>Crop values to a custom range</p></a></li>
<li><a href='#linuxspaces'><p>Handle spaces in Linux filenames</p></a></li>
<li><a href='#loadbin'><p>Read binary data into array</p></a></li>
<li><a href='#makeframe'><p>Display a single movie frame</p></a></li>
<li><a href='#makemovie'><p>Produce a movie from frame-drawing function</p></a></li>
<li><a href='#mcintegral'><p>Monte Carlo and Quasi-Monte Carlo integration in any dimension</p></a></li>
<li><a href='#midseq'><p>Mid-points of regular grid</p></a></li>
<li><a href='#mollweide'><p>Mollweide projection</p></a></li>
<li><a href='#moments'><p>Second moment tensor</p></a></li>
<li><a href='#mutual'><p>Mutual information of two random variables</p></a></li>
<li><a href='#ndft'><p>Non-uniform Discrete Fourier Transform</p></a></li>
<li><a href='#ngon'><p>Draw a regular n-gon</p></a></li>
<li><a href='#nplot'><p>Make empty plot area</p></a></li>
<li><a href='#paircount'><p>Count the number of point-pairs in distance bins</p></a></li>
<li><a href='#pdf2jpg'><p>Convert pdf to jpg</p></a></li>
<li><a href='#planckcolors'><p>Planck CMB colour palette</p></a></li>
<li><a href='#pol2car'><p>Polar/cylindrical to Cartesian coordinate conversion</p></a></li>
<li><a href='#quadrupole'><p>Quadrupole tensor</p></a></li>
<li><a href='#quiet'><p>Suppress in-routine output</p></a></li>
<li><a href='#rasterflip'><p>Flip array to be displayed with rasterImage()</p></a></li>
<li><a href='#rebindensity'><p>Re-bin density histograms</p></a></li>
<li><a href='#rng'><p>Random number generator for a custom d-dimensional distribution</p></a></li>
<li><a href='#rotation2'><p>2D rotation matrix</p></a></li>
<li><a href='#rotation3'><p>3D rotation matrix</p></a></li>
<li><a href='#runif2'><p>Generate randomly oriented vectors in 2D</p></a></li>
<li><a href='#runif3'><p>Generate randomly oriented vectors in 3D</p></a></li>
<li><a href='#scalarproduct'><p>Scalar product</p></a></li>
<li><a href='#smartround'><p>Round a vector of floating-point values while preserving their sum</p></a></li>
<li><a href='#smoothcontour'><p>Draw smoothed contours</p></a></li>
<li><a href='#smoothfun'><p>Smoothed Function</p></a></li>
<li><a href='#spectrumcolors'><p>Spectrum colour palette</p></a></li>
<li><a href='#sph2car'><p>Spherical to Cartesian coordinate conversion</p></a></li>
<li><a href='#sphereplot'><p>Plot a spherical function or point set</p></a></li>
<li><a href='#sphericalharmonics'><p>Spherical Harmonics</p></a></li>
<li><a href='#stretch'><p>Stretch values to a custom range</p></a></li>
<li><a href='#subplot'><p>Insert a sub-panel into plot</p></a></li>
<li><a href='#tick'><p>Start timer</p></a></li>
<li><a href='#tock'><p>Stop timer</p></a></li>
<li><a href='#transparent'><p>Add transparency to a color</p></a></li>
<li><a href='#transzoom'><p>Zoom, translate and rotate array image</p></a></li>
<li><a href='#uniquedouble'><p>Turn a 64-bit integer into a unique double value</p></a></li>
<li><a href='#unitvector'><p>Normalize vectors to unit length</p></a></li>
<li><a href='#vectornorm'><p>Vector norm</p></a></li>
<li><a href='#vectorproduct'><p>Vector product</p></a></li>
<li><a href='#wavelength2col'><p>Convert wavelength to RGB</p></a></li>
<li><a href='#yinyangyong'><p>Yin-Yang-Yong image</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Practical Tools for Scientific Computations and Visualizations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of routines for efficient scientific computations in physics and astrophysics. These routines include utility functions, numerical computation tools, as well as visualisation tools. They can be used, for example, for generating random numbers from spherical and custom distributions, information and entropy analysis, special Fourier transforms, two-point correlation estimation (e.g. as in Landy &amp; Szalay (1993) &lt;<a href="https://doi.org/10.1086%2F172900">doi:10.1086/172900</a>&gt;), binning &amp; gridding of point sets, 2D interpolation, Monte Carlo integration, vector arithmetic and coordinate transformations. Also included is a non-exhaustive list of important constants and cosmological conversion functions. The graphics routines can be used to produce and export publication-ready scientific plots and movies, e.g. as used in Obreschkow et al. (2020, MNRAS Vol 493, Issue 3, Pages 4551â€“4569). These routines include special color scales, projection functions, and bitmap handling routines.</td>
</tr>
<tr>
<td>Imports:</td>
<td>plotrix, celestial, data.table, pracma, utils, png, jpeg,
MASS, raster, sp, cubature, bit64, randtoolbox, Rcpp, FNN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>EBImage</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-16 08:19:46 UTC; 00077389</td>
</tr>
<tr>
<td>Author:</td>
<td>Danail Obreschkow <a href="https://orcid.org/0000-0002-1527-0762"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Danail Obreschkow &lt;danail.obreschkow@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-18 23:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cooltools-package'>Practical Tools for Scientific Computations and Visualizations</h2><span id='topic+cooltools'></span><span id='topic+cooltools-package'></span>

<h3>Description</h3>

<p>Collection of routines for efficient scientific computations in physics and astrophysics. These routines include utility functions, advanced computation tools, as well as visualisation tools. They can be used, for example, for generating random numbers from spherical and custom distributions, information and entropy analysis, special Fourier transforms, two-point correlation estimation (e.g. as in Landy &amp; Szalay (1993) &lt;doi:10.1086/172900&gt;), binning &amp; gridding of point sets, 2D interpolation, Monte Carlo integration, vector arithmetic and coordinate transformations. Also included are a non-exhaustive list of important constants and cosmological conversion functions. The graphics routines can be used to produce and export publication-ready scientific plots and movies, e.g. as used in Obreschkow et al. (2020) &lt;doi:10.1093/mnras/staa445&gt;. These routines include special color scales, projection functions, and bitmap handling routines.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='.cooltools.env'>Package environment</h2><span id='topic+.cooltools.env'></span>

<h3>Description</h3>

<p>Environment used to store global variables in the package, e.g. used for subplot routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cooltools.env
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 0.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='alp'>Associated Legendre Polynomials</h2><span id='topic+alp'></span>

<h3>Description</h3>

<p>Compute associated Legendre polynomials P_l^m(x), defined as the canonical solutions of the general Legendre equation. These polynomials are used, for instance, to compute the spherical harmonics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alp(x, l = 0, m = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alp_+3A_x">x</code></td>
<td>
<p>real argument between -1 and +1, can be a vector</p>
</td></tr>
<tr><td><code id="alp_+3A_l">l</code></td>
<td>
<p>degree of the polynomial (0,1,2,...); accurate to about 25</p>
</td></tr>
<tr><td><code id="alp_+3A_m">m</code></td>
<td>
<p>order of the polynomial (-l,-l+1,...,l); for negative values the standard convention is used: if m&gt;0, then P(x,l,-m) = P(x,l,m) (-1)^m*factorial(l-m)/factorial(l+m).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with the same number of elements as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sphericalharmonics">sphericalharmonics</a></code>
</p>

<hr>
<h2 id='approxfun2'>Bilinear interpolation function of data on a regular grid</h2><span id='topic+approxfun2'></span>

<h3>Description</h3>

<p>Generates a fast function f(x,y) that interpolates gridded data, based on the analogous subroutine <code><a href="stats.html#topic+approxfun">approxfun</a></code> in 1D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxfun2(x, y, z, outside = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approxfun2_+3A_x">x</code></td>
<td>
<p>n-vector of x-coordinates; must be strictly monotonically increasing, but not necessarily equally spaced</p>
</td></tr>
<tr><td><code id="approxfun2_+3A_y">y</code></td>
<td>
<p>m-vector of y-coordinates; must be strictly monotonically increasing, but not necessarily equally spaced</p>
</td></tr>
<tr><td><code id="approxfun2_+3A_z">z</code></td>
<td>
<p>n-by-m matrix containing the known function values at the (x,y)-coordinates</p>
</td></tr>
<tr><td><code id="approxfun2_+3A_outside">outside</code></td>
<td>
<p>value of the approximation function outside the grid (default is NA)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a fast and vectorized interpolation function f(x,y)
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+approxfun">approxfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(3)
y = seq(4)
z = array(c(x+1,x+2,x+3,x+4),c(3,4))
f = approxfun2(x,y,z)
print(f(1.7,2.4))

</code></pre>

<hr>
<h2 id='bindata'>Bin two-dimensional data in one dimension</h2><span id='topic+bindata'></span>

<h3>Description</h3>

<p>Divides a vector of values x into finite intervals; returns the counts and other statistics in each interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindata(x, y = NULL, bins = 20, method = "regular", xlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bindata_+3A_x">x</code></td>
<td>
<p>N-element vector of x-coordinates</p>
</td></tr>
<tr><td><code id="bindata_+3A_y">y</code></td>
<td>
<p>optional N-element vector of values associated with the different points in x</p>
</td></tr>
<tr><td><code id="bindata_+3A_bins">bins</code></td>
<td>
<p>If method is 'regular' or 'equal', this is a scalar specifying the number of bins. If method is 'custom' this is a vector of (n+1) x-values delimiting the n bins.</p>
</td></tr>
<tr><td><code id="bindata_+3A_method">method</code></td>
<td>
<p>Character string. Choose 'regular' for regularly space bins, 'equal' for bins containing an equal number of points (+-1), or 'custom' for bins with custom edges.</p>
</td></tr>
<tr><td><code id="bindata_+3A_xlim">xlim</code></td>
<td>
<p>optional 2-element vector specifying the data range (data cropped if necessary). If not given, xlim is set to the full range of x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of items
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>number of bins</p>
</td></tr>
<tr><td><code>xlim</code></td>
<td>
<p>considered range of x-coordinates, same as input argument xlim, if given</p>
</td></tr>
<tr><td><code>xleft</code></td>
<td>
<p>n-element vector containing the x-coordinates of the left bin edges</p>
</td></tr>
<tr><td><code>xmid</code></td>
<td>
<p>n-element vector containing the x-coordinates of the bin centres</p>
</td></tr>
<tr><td><code>xright</code></td>
<td>
<p>n-element vector containing the x-coordinates of the right bin edges</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>n-element vector containing the widths of the bins</p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p>n-element vector containing the number of points in each bin</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>n-element vector containg the mean x-values in each bin</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>n-element vector containg the mean y-values in each bin</p>
</td></tr>
<tr><td><code>xmedian</code></td>
<td>
<p>n-element vector containg the median of the x-values in each bin</p>
</td></tr>
<tr><td><code>ymedian</code></td>
<td>
<p>n-element vector containg the median of the y-values in each bin</p>
</td></tr>
<tr><td><code>yerr</code></td>
<td>
<p>n-element vector giving the uncertainty on the mean</p>
</td></tr>
<tr><td><code>ysd</code></td>
<td>
<p>n-element vector giving the standard deviations of the y-values</p>
</td></tr>
<tr><td><code>y16</code></td>
<td>
<p>n-element vector giving the 15.86-percentile of the y-values</p>
</td></tr>
<tr><td><code>y84</code></td>
<td>
<p>n-element vector giving the 84.13-percentile of the y-values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+griddata">griddata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make and plot 100 random (x,y)-points
set.seed(1)
x = runif(200)
y = x+rnorm(200)
plot(x,y,pch=16,cex=0.5)

# bin the data into 10 bins of 20 points each
bin = bindata(x,y,10,'equal')
segments(bin$xleft,bin$y,bin$xright,bin$y,col='red')
segments(bin$x,bin$y16,bin$x,bin$y84,col='red')
segments(bin$x,bin$y-bin$yerr,bin$x,bin$y+bin$yerr,col='red',lwd=3)
points(bin$x,bin$y,pch=16,col='red')

</code></pre>

<hr>
<h2 id='car2pol'>Cartesian to polar/cylindrical coordinate conversion</h2><span id='topic+car2pol'></span>

<h3>Description</h3>

<p>Convert 2D/3D Cartesian to polar/cylindrical coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>car2pol(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="car2pol_+3A_x">x</code></td>
<td>
<p>2/3-vector or n-by-2/3 matrix representing the Cartesian components x,y,(z) of n two/three-dimensional vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 2/3-vector or a n-by-2/3 matrix representing the polar/cylindrical coordinates r,phi,(z), where phi=0...2*pi is the azimuth measured positively from the x-axis.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pol2car">pol2car</a></code>
</p>

<hr>
<h2 id='car2sph'>Cartesian to spherical coordinate conversion</h2><span id='topic+car2sph'></span>

<h3>Description</h3>

<p>Convert 3D Cartesian to spherical coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>car2sph(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="car2sph_+3A_x">x</code></td>
<td>
<p>3-vector or n-by-3 matrix representing the Cartesian components (x,y,z)  of n three-dimensional vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-vector or a n-by-3 element matrix representing the spherical coordinates (r,theta,phi), where theta=0...pi is the polar angle measured from the north pole and phi=0...2*pi is the azimuth measured positively from the x-axis (ISO 80000-2:2019 physics convention).
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sph2car">sph2car</a></code>
</p>

<hr>
<h2 id='cmplx2col'>Convert complex numbers to color</h2><span id='topic+cmplx2col'></span>

<h3>Description</h3>

<p>Converts a complex number (or a vector/array thereof) into a color-string, such that brightness represents the complex amplitude and hue represents the complex phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmplx2col(z, max = NULL, hue = 0, saturation = 1, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cmplx2col_+3A_z">z</code></td>
<td>
<p>complex number or vector/array of complex numbers</p>
</td></tr>
<tr><td><code id="cmplx2col_+3A_max">max</code></td>
<td>
<p>value of the complex module that corresponds to full brightness; if not given, this is set equal to the maximum complex amplitude in z.</p>
</td></tr>
<tr><td><code id="cmplx2col_+3A_hue">hue</code></td>
<td>
<p>hue value of positive reals</p>
</td></tr>
<tr><td><code id="cmplx2col_+3A_saturation">saturation</code></td>
<td>
<p>saturation value of colors</p>
</td></tr>
<tr><td><code id="cmplx2col_+3A_gamma">gamma</code></td>
<td>
<p>positive number to adjust the non-linearity of the color scale (1=linear)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a single color or vector/array of colors
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='colorbar'>Vertical color bar</h2><span id='topic+colorbar'></span>

<h3>Description</h3>

<p>Adds a vertical color bar to a plot with a custom axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorbar(
  xleft,
  ybottom,
  xright,
  ytop,
  col = gray.colors(256, 0, 1),
  clim = c(0, 1),
  show.border = TRUE,
  text = "",
  line = 2,
  show.axis = TRUE,
  side = "right",
  lwd = 1,
  nticks = 5,
  at = NULL,
  srt = 0,
  ticklength = 0.1,
  shift = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorbar_+3A_xleft">xleft</code></td>
<td>
<p>left x-coordinate of the bar</p>
</td></tr>
<tr><td><code id="colorbar_+3A_ybottom">ybottom</code></td>
<td>
<p>bottom y-coordinate of the bar</p>
</td></tr>
<tr><td><code id="colorbar_+3A_xright">xright</code></td>
<td>
<p>right x-coordinate of the bar</p>
</td></tr>
<tr><td><code id="colorbar_+3A_ytop">ytop</code></td>
<td>
<p>top y-coordinate of the bar</p>
</td></tr>
<tr><td><code id="colorbar_+3A_col">col</code></td>
<td>
<p>vector of colors</p>
</td></tr>
<tr><td><code id="colorbar_+3A_clim">clim</code></td>
<td>
<p>2-vector specifying the range of values, linearly represented by the full color scale</p>
</td></tr>
<tr><td><code id="colorbar_+3A_show.border">show.border</code></td>
<td>
<p>logical flag specifying whether to draw a rectangular border around the bar</p>
</td></tr>
<tr><td><code id="colorbar_+3A_text">text</code></td>
<td>
<p>axis label</p>
</td></tr>
<tr><td><code id="colorbar_+3A_line">line</code></td>
<td>
<p>distance between label and color bar</p>
</td></tr>
<tr><td><code id="colorbar_+3A_show.axis">show.axis</code></td>
<td>
<p>logical flag specifying whether to draw an axis</p>
</td></tr>
<tr><td><code id="colorbar_+3A_side">side</code></td>
<td>
<p>character string, which specifies the location of the axis on the bar. This has to be 'left' or 'right' (default).</p>
</td></tr>
<tr><td><code id="colorbar_+3A_lwd">lwd</code></td>
<td>
<p>linewidth of border and ticks</p>
</td></tr>
<tr><td><code id="colorbar_+3A_nticks">nticks</code></td>
<td>
<p>number of ticks on the axis</p>
</td></tr>
<tr><td><code id="colorbar_+3A_at">at</code></td>
<td>
<p>vector of values specifying the tick positions on the axis, this overrides nticks.</p>
</td></tr>
<tr><td><code id="colorbar_+3A_srt">srt</code></td>
<td>
<p>rotation angle of tick text</p>
</td></tr>
<tr><td><code id="colorbar_+3A_ticklength">ticklength</code></td>
<td>
<p>length of ticks</p>
</td></tr>
<tr><td><code id="colorbar_+3A_shift">shift</code></td>
<td>
<p>extra distance between axis numbers and color bar</p>
</td></tr>
<tr><td><code id="colorbar_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed text function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot a spherical function with color bar
nplot(xlim=c(0,1.2), asp=1)
f = function(theta,phi) cos(10*theta+phi)
sp = sphereplot(f, 200, col=planckcolors(200), phi0=0.1, theta0=pi/3,
add=TRUE, center=c(0.5,0.5), radius=0.4, clim=c(-1,1))
colorbar(1,0.1,1.1,0.9,col=sp$col,clim=sp$clim)

</code></pre>

<hr>
<h2 id='contourlevel'>Find contour levels of a d-dimensional density field</h2><span id='topic+contourlevel'></span>

<h3>Description</h3>

<p>Given a vector d-dimensional vector/array <code>f</code> or function <code>f(x)</code> of a d-element vector <code>x</code>, this routine evaluates the value l, such that the sum/integral of f over the domain f&gt;l makes up a fraction p of the total sum/integral of f. The main purpose of this routine is to determine the iso-contour levels of a likelihood or density function, containing a cumulative probability-mass p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourlevel(
  f,
  p = c(0.6826895, 0.9544997),
  xmin = NULL,
  xmax = NULL,
  neval = 10000,
  napprox = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contourlevel_+3A_f">f</code></td>
<td>
<p>either a d-dimensional vector/array or a function <code>f(x)</code> of a d-element vector <code>x</code>. There is no need for <code>f</code> to be normalized.</p>
</td></tr>
<tr><td><code id="contourlevel_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="contourlevel_+3A_xmin">xmin</code>, <code id="contourlevel_+3A_xmax">xmax</code></td>
<td>
<p>(only used if <code>f</code> is a function) vectors with of lower and upper limits of <code>x</code>, defining the domain on which the function <code>f(x)</code> is evaluated. Outside this domain, <code>f</code> is assumed to vanish. These limits should be chosen as narrow as possible for the algorithm to converge quickly.</p>
</td></tr>
<tr><td><code id="contourlevel_+3A_neval">neval</code></td>
<td>
<p>(only used if <code>f</code> is a function) maximum number of function evaluations in numerical integrals</p>
</td></tr>
<tr><td><code id="contourlevel_+3A_napprox">napprox</code></td>
<td>
<p>(only used if <code>f</code> is a function) number of points used interpolate the cumulative probability density. If set to 0, no interpolation is used.</p>
</td></tr>
<tr><td><code id="contourlevel_+3A_...">...</code></td>
<td>
<p>(only used if <code>f</code> is a function) additional parameters to be passed to the function f.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of levels l, which has the same length as p.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpqr">dpqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## f(x) is a 1D PDF
# compute 1-sigma and 2-sigma contour levels of a normal distribution, i.e.
# the values l, such that int_{dnorm(x)&gt;l} dnorm(x) dx = p (=68.3%, 95.4%).
l = contourlevel(dnorm,xmin=-10,xmax=10,napprox=0)
print(l)

# compare these values to the solutions dnorm(1), dnorm(2)
print(dnorm(c(1,2)))


## f(x) is a 2D likelihood function
# Produce 20%, 40%, 60% and 80% iso contours on the 2D likelihood function f(x)
f = function(x) cos(2*x[1]-x[2]-1)^2*exp(-x[1]^2-x[2]^2-x[1]*x[2])
p = c(0.2,0.4,0.6,0.8) # cumulative probability
l = contourlevel(f,p,c(-5,-5),c(5,5)) # values l, such that int_{f&gt;l}(f(x)dx)=p int(f(x)*dx)

# Plot function and contours at the levels l
x = seq(-3,3,length=200)
m = pracma::meshgrid(x)
z = array(Vectorize(function(x,y) f(c(x,y)))(m$Y,m$X),dim(m$X))
image(x,x,z,col=terrain.colors(100))
contour(x,x,z,levels=l,add=TRUE,labels=sprintf('%.0f%%',p*100),labcex=0.7)


## f is a 20-by20 array representing a gridded pointset
# produce a set of 1000 points in 2D, drawn from a 2D normal distribution
set.seed(1)
x = MASS::mvrnorm(n=1000, mu=c(0,0), matrix(c(3,1,1,2),2,2))

# grid these points onto a regular 20-by-20 grid
g = griddata(x, min=-6, max=6)

# find 1-sigma and 2-sigma contour levels and draw contours at these levels
l = contourlevel(g$field)
plot(x, xlim=g$grid[[1]]$lim, ylim=g$grid[[2]]$lim, pch=20, cex=0.5)
contour(g$grid[[1]]$mid,g$grid[[2]]$mid,g$field,
        levels=l,add=TRUE,col='red',lwd=c(2,1),labels=NA)

</code></pre>

<hr>
<h2 id='cosmofct'>Fast cosmology conversion functions</h2><span id='topic+cosmofct'></span>

<h3>Description</h3>

<p>Generates all 20 conversion functions between redshift (z), luminosity distance (dl), comoving distance (dc) and angular diameter distance (da), and lookback time (t = light travel time from specified redshift); based on the *celestial* package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosmofct(zmin = 0, zmax = 1, dz = 0.02, H0 = 70, OmegaM = 0.3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cosmofct_+3A_zmin">zmin</code></td>
<td>
<p>minimum redshift for which the conversion functions are used</p>
</td></tr>
<tr><td><code id="cosmofct_+3A_zmax">zmax</code></td>
<td>
<p>maximum redshift for which the conversion functions are used</p>
</td></tr>
<tr><td><code id="cosmofct_+3A_dz">dz</code></td>
<td>
<p>redshift interval on which the conversion functions are interpolated (default of 0.02 is normally largely sufficient)</p>
</td></tr>
<tr><td><code id="cosmofct_+3A_h0">H0</code></td>
<td>
<p>local Hubble constant in units of km/s/Mpc (default 70).</p>
</td></tr>
<tr><td><code id="cosmofct_+3A_omegam">OmegaM</code></td>
<td>
<p>local normalised matter density (default 0.3).</p>
</td></tr>
<tr><td><code id="cosmofct_+3A_...">...</code></td>
<td>
<p>other cosmological parameters accepted by <code>cosdist</code> of the *celestial* package. Defaults are OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of 20 vectorized functions; e.g. dc2z to convert from comoving distance to redshift. Also contains the <code>age</code> of the universe at z=0. All distances are in units of Mpc and times are in units of Gyr.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow (based on *celestial* package by Aaron Robotham)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## uses a flat LCDM cosmology with h=0.68, OmegaM=0.32 and OmegaL=0.68
cosmo = cosmofct(0,1,H0=68,OmegaM=0.32)
curve(cosmo$z2dl(x),0,1,xlab='z',ylab='distance',col='red')
curve(cosmo$z2dc(x),0,1,col='black',add=TRUE)
curve(cosmo$z2da(x),0,1,col='blue',add=TRUE)
d = seq(500,5000,500)
points(cosmo$dl2z(d),d,pch=16,col='red')
points(cosmo$dc2z(d),d,pch=16,col='black')
points(cosmo$da2z(d),d,pch=16,col='blue')

</code></pre>

<hr>
<h2 id='cshift'>Circularly shift each dimension of an array</h2><span id='topic+cshift'></span>

<h3>Description</h3>

<p>Circulates each dimension of an array. This routine is identical to <code><a href="pracma.html#topic+circshift">circshift</a></code>, but works with arrays up to 5 dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cshift(x, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cshift_+3A_x">x</code></td>
<td>
<p>vector or array (up to rank 5)</p>
</td></tr>
<tr><td><code id="cshift_+3A_s">s</code></td>
<td>
<p>scalar, if x is a vector, or a vector of length matching the rank of x, if x is an array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or array of the same shape as x.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='cst'>Scientific constants</h2><span id='topic+cst'></span>

<h3>Description</h3>

<p>The list <code>cst</code> contains useful scientific constants in SI units, mainly for astrophysics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cst
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 22.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'># print all the constants to console
for (i in seq(length(cst))) cat(sprintf('%6s = %.12e\n',names(cst)[i],cst[i]))

</code></pre>

<hr>
<h2 id='cubehelix'>Cube Helix colour palette</h2><span id='topic+cubehelix'></span>

<h3>Description</h3>

<p>Generate the Cube Helix colour palette, designed to appropriately display of intensity images, as the brightness increases monotonically when displayed in greyscale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubehelix(n, r = 1.5, hue = 1, gamma = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cubehelix_+3A_n">n</code></td>
<td>
<p>integer number of colours in the scale</p>
</td></tr>
<tr><td><code id="cubehelix_+3A_r">r</code></td>
<td>
<p>real number specifying the number of rotations of the helix over the scale</p>
</td></tr>
<tr><td><code id="cubehelix_+3A_hue">hue</code></td>
<td>
<p>non-negative number specifying the colour intensity from grey (0) to normal (1) and over-saturated (&gt;1)</p>
</td></tr>
<tr><td><code id="cubehelix_+3A_gamma">gamma</code></td>
<td>
<p>positive number specifying the relative importance of low vs high values</p>
</td></tr>
<tr><td><code id="cubehelix_+3A_rev">rev</code></td>
<td>
<p>logical flag indicating whether the ordering of the colors should be reversed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This scheme was published by Green, D. A., 2011, &quot;A colour scheme for the display of astronomical intensity images.&quot; Bulletin of the Astronomical Society of India, 39, 289.
</p>


<h3>Value</h3>

<p>Returns an n-vector of RGB colour strings.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='dft'>Discrete Fourier Transform</h2><span id='topic+dft'></span>

<h3>Description</h3>

<p>Discrete Fourier Transform (DFT) with longest modes at the center in Fourier space and normalized such that dft(dft(f),inverse)=f. This is the discretization scheme described in  Appendix D of Obreschkow et al. 2013, ApJ 762. Relies on <code><a href="stats.html#topic+fft">fft</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dft(f, inverse = FALSE, shift = -floor(dim(as.array(f))/2), simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dft_+3A_f">f</code></td>
<td>
<p>real or complex D-dimensional array containing the values to be transformed.</p>
</td></tr>
<tr><td><code id="dft_+3A_inverse">inverse</code></td>
<td>
<p>logical flag; if TRUE the inverse Fourier transform is performed.</p>
</td></tr>
<tr><td><code id="dft_+3A_shift">shift</code></td>
<td>
<p>D-vector specifying the integer shift of the coordinates in Fourier space. Set to <code>shift=rep(0,D)</code> to produced a DFT with the longest mode at the corner in Fourier space.</p>
</td></tr>
<tr><td><code id="dft_+3A_simplify">simplify</code></td>
<td>
<p>logical flag; if TRUE the complex output array will be simplified to a real array, if it is real within the floating point accuracy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array of the same shape as <code>f</code>, containing the (inverse) Fourier Transform.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fft">fft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## DFT of a 2D normal Gaussian function
n = 30
f = array(0,c(n,n))
for (i in seq(n)) {
  for (j in seq(n)) f[i,j] = exp(-(i-6)^2/4-(j-8)^2/2-(i-6)*(j-8)/2)
}
plot(NA,xlim=c(0,2.1),ylim=c(0,1.1),asp=1,bty='n',xaxt='n',yaxt='n',xlab='',ylab='')
rasterImage(f,0,0,1,1,interpolate=FALSE)
g = dft(f)
img = array(hsv((pracma::angle(g)/2/pi)%%1,1,abs(g)/max(abs(g))),c(n,n))
rasterImage(img,1.1,0,2.1,1,interpolate=FALSE)
text(0.5,1,'Input function f',pos=3)
text(1.6,1,'DFT(f)',pos=3)

</code></pre>

<hr>
<h2 id='dftgrid'>Produce coordinates for Discrete Fourier Transform</h2><span id='topic+dftgrid'></span>

<h3>Description</h3>

<p>Produces the direct space coordinates (x) and Fourier space frequencies (f) and angular frequencies (k), corresponding to the Discrete Fourier Transform <code>dft</code> of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dftgrid(N, L, x0 = 0, k0 = -floor(N/2) * 2 * pi/L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dftgrid_+3A_n">N</code></td>
<td>
<p>number of divisions along one dimension used in direct and Fourier space</p>
</td></tr>
<tr><td><code id="dftgrid_+3A_l">L</code></td>
<td>
<p>side-length (=period) of the data long one dimension</p>
</td></tr>
<tr><td><code id="dftgrid_+3A_x0">x0</code></td>
<td>
<p>zero-point of x-coordinates (=0 in most applications)</p>
</td></tr>
<tr><td><code id="dftgrid_+3A_k0">k0</code></td>
<td>
<p>zero-point of k-coordinates (=0 or -floor(N/2)*dk in most applications)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>vector of direct space coordinates</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>vector of Fourier space coordinates (frequencies)</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>vector of Fourier space coordinates (angular frequencies)</p>
</td></tr>
<tr><td><code>dx</code></td>
<td>
<p>spacing of x-values</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>spacing of f-values</p>
</td></tr>
<tr><td><code>dk</code></td>
<td>
<p>spacing of k-values</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>input value of L</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>input value of N</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='dpqr'>d/p/q/r-family for a custom distribution</h2><span id='topic+dpqr'></span>

<h3>Description</h3>

<p>Produces the family of d/p/q/r functions associated with a custom one-dimensional distribution function; similarly to the standard families dnorm/pnorm/qnorm/rnorm, dunif/punif/...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpqr(fun, min, max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpqr_+3A_fun">fun</code></td>
<td>
<p>distribution function of a single variable; does not have to be normalized</p>
</td></tr>
<tr><td><code id="dpqr_+3A_min">min</code>, <code id="dpqr_+3A_max">max</code></td>
<td>
<p>domain of distribution function; outside this domain <code>fun</code> will be considered equal to 0. In practice, this should be the most restrictive domain containing (almost) all the mass of <code>fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of items:
</p>
<table role = "presentation">
<tr><td><code>d(x)</code></td>
<td>
<p>Probability distribution function (PDF), i.e. a normalised version of <code>fun</code>, limited to the domain <code>[xmin,xmax]</code>.</p>
</td></tr>
<tr><td><code>p(x)</code></td>
<td>
<p>Cumulative distributiont function, defined as the integrated PDF up to x.</p>
</td></tr>
<tr><td><code>q(p)</code></td>
<td>
<p>Quantile function, returning the position x, at which the cumulative probability equals <code>p</code>.</p>
</td></tr>
<tr><td><code>r(n)</code></td>
<td>
<p>A vector of <code>n</code> random numbers drawn from the PDF.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rng">rng</a></code>, <code><a href="#topic+contourlevel">contourlevel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f = function(x) sin(x)
rsin = dpqr(f,0,pi)$r
x = rsin(1e3)
hist(x,freq=FALSE)
curve(sin(x)/2,0,pi,add=TRUE)

</code></pre>

<hr>
<h2 id='entropy'>Information entropy</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>Computes the information entropy H=sum(p*log_b(p)), also known as Shannon entropy, of a probability vector p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(p, b = exp(1), normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entropy_+3A_p">p</code></td>
<td>
<p>vector of probabilities; typically normalized, such that sum(p)=1.</p>
</td></tr>
<tr><td><code id="entropy_+3A_b">b</code></td>
<td>
<p>base of the logarithm (default is e)</p>
</td></tr>
<tr><td><code id="entropy_+3A_normalize">normalize</code></td>
<td>
<p>logical flag. If TRUE (default), the vector p is automatically normalized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the information entropy in units that depend on b. If b=2, the units are bits; if b=exp(1), the units are nats; if b=10, the units are dits.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='errlines'>Draw a line with uncertainty regions</h2><span id='topic+errlines'></span>

<h3>Description</h3>

<p>Draw a line with uncertainty regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errlines(
  x,
  y,
  errp,
  errn = errp,
  col = "black",
  alpha = 0.5,
  smooth = FALSE,
  df = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="errlines_+3A_x">x</code></td>
<td>
<p>vector of x-coordinates</p>
</td></tr>
<tr><td><code id="errlines_+3A_y">y</code></td>
<td>
<p>vector of y-coordinates</p>
</td></tr>
<tr><td><code id="errlines_+3A_errp">errp</code></td>
<td>
<p>vector of y-errors in the positive direction (upwards)</p>
</td></tr>
<tr><td><code id="errlines_+3A_errn">errn</code></td>
<td>
<p>vector of y-errors in the negative direction (downwards)</p>
</td></tr>
<tr><td><code id="errlines_+3A_col">col</code></td>
<td>
<p>color of the line</p>
</td></tr>
<tr><td><code id="errlines_+3A_alpha">alpha</code></td>
<td>
<p>transparency of the uncertainty region</p>
</td></tr>
<tr><td><code id="errlines_+3A_smooth">smooth</code></td>
<td>
<p>logical flag indicating whether the line should be smoothed</p>
</td></tr>
<tr><td><code id="errlines_+3A_df">df</code></td>
<td>
<p>df (=degrees of freedom) parameter of <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> function</p>
</td></tr>
<tr><td><code id="errlines_+3A_...">...</code></td>
<td>
<p>additional parameters used by <code><a href="graphics.html#topic+lines">lines</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='fibonaccisphere'>Evenly distributed n points on a sphere</h2><span id='topic+fibonaccisphere'></span>

<h3>Description</h3>

<p>Distributes n points on a sphere in a relatively even fashion following the generalised Fibonacci algorithm, described at http://extremelearning.com.au/evenly-distributing-points-on-a-sphere/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fibonaccisphere(n = 1000, r = 1, out.xyz = TRUE, out.sph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fibonaccisphere_+3A_n">n</code></td>
<td>
<p>number of points to be placed on the sphere</p>
</td></tr>
<tr><td><code id="fibonaccisphere_+3A_r">r</code></td>
<td>
<p>radius</p>
</td></tr>
<tr><td><code id="fibonaccisphere_+3A_out.xyz">out.xyz</code></td>
<td>
<p>logical flag specifying whether to return Cartesian coordinates (default is TRUE)</p>
</td></tr>
<tr><td><code id="fibonaccisphere_+3A_out.sph">out.sph</code></td>
<td>
<p>logical flag specifying whether to return spherical coordinates (default is FALSE); <code>theta</code>=colatitute (=polar angle=angle from z-axis), <code>phi</code>=longitude (=azimuth angle),</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of n points (in n rows), in Cartesian and/or spherical coordinates.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif3">runif3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plot standard projections of a 1000-point Fibonacci sphere
xyz = fibonaccisphere()
plot(xyz, asp=1, pch=16, cex=0.5)

</code></pre>

<hr>
<h2 id='gradient'>Compute gradient</h2><span id='topic+gradient'></span>

<h3>Description</h3>

<p>Evaluates the gradient of a vector of array of rank 2 or 3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(f, circular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gradient_+3A_f">f</code></td>
<td>
<p>vector or array of rank 2 or 3</p>
</td></tr>
<tr><td><code id="gradient_+3A_circular">circular</code></td>
<td>
<p>logical scalar or vector specifying whether periodic boundaries are used along each dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with the different components of the gradient; each component has the same dimension as f.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='grf'>Gaussian Random Field generator</h2><span id='topic+grf'></span>

<h3>Description</h3>

<p>Generates a scalar Gaussian Random Field (GRF) in 1, 2 or 3 dimensions, with a power-law power spectrum of custom slope alpha. The field is normalized such that its mean is zero (up to floating point errors) and its expected standard deviation is one, for alpha=0. The Fourier phases are sampled in order of increasing frequency, such that the random structure is preserved when changing the output size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grf(nside = 100, dim = 2, alpha = 0, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grf_+3A_nside">nside</code></td>
<td>
<p>integer number of elements per dimension in the output matrix</p>
</td></tr>
<tr><td><code id="grf_+3A_dim">dim</code></td>
<td>
<p>integer number of dimensions</p>
</td></tr>
<tr><td><code id="grf_+3A_alpha">alpha</code></td>
<td>
<p>spectral index, such that Fourier amplitudes scale as k^alpha. alpha=0 corresponds to uncorrelated white noise, alpha&lt;0 is red noise, while alpha&gt;1 is blue noise.</p>
</td></tr>
<tr><td><code id="grf_+3A_seed">seed</code></td>
<td>
<p>optional seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector, matrix or 3D-array with <code>nside</code> elements per dimension
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate the same 2D GRF in two different resolutions
nplot(c(0,2.1), asp=1)
lowres = grf(nside=30, alpha=-2, seed=1)
graphics::rasterImage(stretch(lowres),0,0,1,1)
highres = grf(nside=120, alpha=-2, seed=1)
graphics::rasterImage(stretch(highres),1.1,0,2.1,1)

# Check the power spectrum of a general GRF
nside = 50 # change this to any integer &gt;1
alpha = -1.7 # change this to any power
dim = 3 # change this to any positive integer (but keep nside^dim reasonable)
x = grf(nside=nside, dim=dim, alpha=alpha)
fourier.grid = dftgrid(N=nside,L=1)
knorm = vectornorm(expand.grid(rep(list(fourier.grid$k),dim)))
power = abs(dft(x))^2
b = bindata(knorm,power,method='equal')
plot(b$xmedian,b$ymedian,log='xy',pch=16,
     xlab='Fourier mode |k|',ylab='Power p(k)',main='Power spectrum')
graphics::curve(x^alpha/nside^dim,col='blue',add=TRUE) # expected power-law

</code></pre>

<hr>
<h2 id='griddata'>Distribute a point set onto a regular grid</h2><span id='topic+griddata'></span>

<h3>Description</h3>

<p>Distributes a set of points in D dimensions onto a regular, D-dimensional grid, using a fast nearest neighbor algorithm. Weights can be used optionally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>griddata(x, w = NULL, n = 10, min = NULL, max = NULL, type = "counts")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="griddata_+3A_x">x</code></td>
<td>
<p>N-element vector (if D=1) or N-by-D matrix (if D&gt;1), giving the Cartesian coordinates of N points in D dimensions.</p>
</td></tr>
<tr><td><code id="griddata_+3A_w">w</code></td>
<td>
<p>optional N-element vector with weights.</p>
</td></tr>
<tr><td><code id="griddata_+3A_n">n</code></td>
<td>
<p>scalar or D-element vector specifying the number of equally space grid cells along each dimension.</p>
</td></tr>
<tr><td><code id="griddata_+3A_min">min</code></td>
<td>
<p>optional scalar or D-element vector specifying the lower bound of the grid. If not given, min is adjusted to the range of x.</p>
</td></tr>
<tr><td><code id="griddata_+3A_max">max</code></td>
<td>
<p>optional scalar or D-element vector specifying the upper bound of the grid. If not given, max is adjusted to the range of x.</p>
</td></tr>
<tr><td><code id="griddata_+3A_type">type</code></td>
<td>
<p>character string (&quot;counts&quot;, &quot;density&quot;, &quot;probability&quot;) specifying the normalization of the output: &quot;counts&quot; (default) returns the number of points (multiplied by their weights, if given) in each cell; thus the total number of points (or total mass, if weights are given) is <code>sum(field)</code>. &quot;density&quot; returns the density, such that the total number of points (or total mass, if weights are given) is <code>sum(field) dV</code>. &quot;probability&quot; returns a probability density, such that <code>sum(field) dV</code>=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of items
</p>
<table role = "presentation">
<tr><td><code>field</code></td>
<td>
<p>D-dimensional array representing the value in each grid cell. See parameter <code>type</code> for more details.</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>List of D elements with the grid properties along each dimension. n: number of grid cells; mid: n-vector of mid-cell coordinates; breaks: (n+1)-vector of cell edges; lim: 2-vector of considered range; delta: cell width.</p>
</td></tr>
<tr><td><code>dV</code></td>
<td>
<p>Single number representing the volume of the D-dimensional grid cells.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Distribute 1-dimensional data onto a regular grid
npoints = 1e4
x = rnorm(npoints)
g = griddata(x,min=-3,max=3,n=100,type='probability')
curve(dnorm(x),-3,3)
points(g$grid$mid,g$field,pch=16)

# Distribute 2-dimensional data onto a regular grid
x = runif(100,max=2)
y = runif(100)
g = griddata(cbind(x,y),min=c(0,0),max=c(2,1),n=c(20,10))
image(g$grid[[1]]$breaks,g$grid[[2]]$breaks,g$field,
      asp=1,col=grey.colors(100,0,1),xlab='x',ylab='y')
points(x,y,col='red',pch=16)

# ... same with weights
w = runif(100)
g = griddata(cbind(x,y),w,min=c(0,0),max=c(2,1),n=c(20,10))
image(g$grid[[1]]$breaks,g$grid[[2]]$breaks,g$field,
      asp=1,col=grey.colors(100,0,1),xlab='x',ylab='y')
points(x,y,col='red',pch=16,cex=w)

</code></pre>

<hr>
<h2 id='histcoord'>Generate histogram coordinates from mid points</h2><span id='topic+histcoord'></span>

<h3>Description</h3>

<p>Converts the mid-point x-values and mean densities of binned data into (x,y)-coordinates of a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histcoord(x, y, yleft = 0, yright = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="histcoord_+3A_x">x</code></td>
<td>
<p>n-vector giving the bin mid-points</p>
</td></tr>
<tr><td><code id="histcoord_+3A_y">y</code></td>
<td>
<p>n-vector giving bin values</p>
</td></tr>
<tr><td><code id="histcoord_+3A_yleft">yleft</code></td>
<td>
<p>optional value specifying the value at the left edge</p>
</td></tr>
<tr><td><code id="histcoord_+3A_yright">yright</code></td>
<td>
<p>optional value specifying the value at the right edge</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(2n+2)-by-2 matrix of (x,y)-coordinates to draw histogram as a connected line
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = seq(5)
y = sin(x)
plot(x,y,xlim=c(0,6))
lines(histcoord(x,y))

</code></pre>

<hr>
<h2 id='inertia'>Inertia tensor</h2><span id='topic+inertia'></span>

<h3>Description</h3>

<p>Computes the symmetric tensor of moments of inertia
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inertia(x, m = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inertia_+3A_x">x</code></td>
<td>
<p>n-by-3 matrix (x[1:n,1:3]) specifying the 3D Cartesian coordinates of n points</p>
</td></tr>
<tr><td><code id="inertia_+3A_m">m</code></td>
<td>
<p>n-vector with point masses, or single scalar giving a uniform mass for all points (default is unity)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-by-3 symmetric matrix
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadrupole">quadrupole</a></code>, <code><a href="#topic+moments">moments</a></code>
</p>

<hr>
<h2 id='invert'>Invert and shift colors of an image</h2><span id='topic+invert'></span>

<h3>Description</h3>

<p>Invert the brightness of each color channel in an image and/or circularly shifts the hue value. Optionally, a Gaussian blur can be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert(
  img = NULL,
  invert = TRUE,
  colshift = 0,
  blur = 0,
  file.in = "",
  file.out = "",
  format = "png",
  show.image = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invert_+3A_img">img</code></td>
<td>
<p>n-by-m-by-3 array or n-by-m-by-4 array representing an rgb(+alpha) image</p>
</td></tr>
<tr><td><code id="invert_+3A_invert">invert</code></td>
<td>
<p>logical flag indicating whether the channel-brightness should be inverted</p>
</td></tr>
<tr><td><code id="invert_+3A_colshift">colshift</code></td>
<td>
<p>numerical value between 0 and 1 setting the circular shift of the hue value. If <code>invert=TRUE</code>, choosing <code>colshift=0.5</code> preserves the colors, while inverting black and white.</p>
</td></tr>
<tr><td><code id="invert_+3A_blur">blur</code></td>
<td>
<p>numerical value &gt;=0 defining the standard deviation of an optional Gaussian blur.</p>
</td></tr>
<tr><td><code id="invert_+3A_file.in">file.in</code></td>
<td>
<p>optional input filename, which can be used to load an image instead of providing it via <code>img</code>. This filename is ignored if <code>img</code> is specified.</p>
</td></tr>
<tr><td><code id="invert_+3A_file.out">file.out</code></td>
<td>
<p>optional output filename.</p>
</td></tr>
<tr><td><code id="invert_+3A_format">format</code></td>
<td>
<p>one of &quot;png&quot; or &quot;jpg&quot; specifying the file format of the input and output image.</p>
</td></tr>
<tr><td><code id="invert_+3A_show.image">show.image</code></td>
<td>
<p>logical flag specifying whether the image is displayed in the R console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n-by-m-by-3 array or n-by-m-by-4 array of the processed image.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img = yinyangyong # this is an example image included in the package

# invert brightness of all channels
invert(img)

# invert brightness, but preserve hue
invert(img, colshift=0.5)

</code></pre>

<hr>
<h2 id='is.equal'>Numerical equality check</h2><span id='topic+is.equal'></span>

<h3>Description</h3>

<p>Checks if two or more numerical values are identical within a relative numerical tolerance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.equal(x, ..., stoptext = NULL, eps = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.equal_+3A_x">x</code></td>
<td>
<p>vector or array of values to compare</p>
</td></tr>
<tr><td><code id="is.equal_+3A_...">...</code></td>
<td>
<p>optional additional values to compare</p>
</td></tr>
<tr><td><code id="is.equal_+3A_stoptext">stoptext</code></td>
<td>
<p>optional character string; if given, the routine stops if the values are not all equal and adds the character string to the error message</p>
</td></tr>
<tr><td><code id="is.equal_+3A_eps">eps</code></td>
<td>
<p>relative numerical tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical value. TRUE means that all values of <code>x</code> are equal within the specified relative tolerance; also returns TRUE if all values are Inf or NA or NaN.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'># almost identical values
x = c(acos(1/sqrt(2)),pi/4)
print(x)
print(x[1]==x[2])
print(is.equal(x))

# various other examples
print(is.equal(1,2,3))
print(is.equal(1,NA,3))
print(is.equal(Inf,NA))
print(is.equal(NaN,NA))
print(is.equal(NaN,Inf))
print(is.equal(Inf,Inf,Inf))
print(is.equal(NA,NA))
print(is.equal(NaN,NaN))
print(is.equal(1.4,1.4))
print(is.equal(1.4,1.400000001))
print(is.equal(1.4,1.400000001,1.41))
print(is.equal(0,0,0,0))

</code></pre>

<hr>
<h2 id='jackknife'>Jackknife Estimation</h2><span id='topic+jackknife'></span>

<h3>Description</h3>

<p>Computes the &quot;leave-one-out&quot; Jackknife bias and standard error of an estimator <code>f(x)</code> of a data-vector <code>x</code>, or an estimator <code>f(x,y)</code> of vectors <code>x</code> and <code>y</code>. See Efron and Tibshirani (1993) for details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jackknife(x, f, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jackknife_+3A_x">x</code></td>
<td>
<p>data vector</p>
</td></tr>
<tr><td><code id="jackknife_+3A_f">f</code></td>
<td>
<p>estimator function <code>f(x,...)</code> or <code>f(x,y,...)</code></p>
</td></tr>
<tr><td><code id="jackknife_+3A_y">y</code></td>
<td>
<p>optional data vector if <code>f</code> is a function of two vectors, such as the correlation coefficient <code>cor(x,y)</code>.</p>
</td></tr>
<tr><td><code id="jackknife_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>value</code></td>
<td>
<p>Default value of the estimator <code>f</code>.</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>Jackknife bias estimate of <code>f</code>.</p>
</td></tr>
<tr><td><code>unbiased</code></td>
<td>
<p>Bias-corrected value of <code>f</code>.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Jackknife standard error of <code>f</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='kde2'>Multi-dimensional adaptive kernel density estimation</h2><span id='topic+kde2'></span>

<h3>Description</h3>

<p>Produces a 2D kernel density estimation on a 2D grid from a D-dimensional (D&gt;=2) point set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde2(
  x,
  w = NULL,
  nx = 300,
  xlim = NULL,
  ylim = NULL,
  smoothing = 1,
  sigma = NULL,
  sigma.min = 0,
  sigma.max = Inf,
  reflect = "",
  algorithm = "kdenn",
  probability = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kde2_+3A_x">x</code></td>
<td>
<p>N-by-D vector of x-coordinates or N-by-2 matrix of (x,y)-coordinates</p>
</td></tr>
<tr><td><code id="kde2_+3A_w">w</code></td>
<td>
<p>optional N-element vector with weights</p>
</td></tr>
<tr><td><code id="kde2_+3A_nx">nx</code></td>
<td>
<p>integer specifying the number of equally space grid cells along the x-axis; the number ny of pixels along the y-axis is determined automatically from xlim and ylim.</p>
</td></tr>
<tr><td><code id="kde2_+3A_xlim">xlim</code></td>
<td>
<p>2-element vector specifying the x-range</p>
</td></tr>
<tr><td><code id="kde2_+3A_ylim">ylim</code></td>
<td>
<p>2-element vector specifying the y-range; if needed, this range is slightly adjusted to allow for an integer number of pixels.</p>
</td></tr>
<tr><td><code id="kde2_+3A_smoothing">smoothing</code></td>
<td>
<p>positive linear smoothing factor; the larger, the smoother the density field</p>
</td></tr>
<tr><td><code id="kde2_+3A_sigma">sigma</code></td>
<td>
<p>optional N-vector, specifying the blurring of each pixel individually in length units of x; only used if algorithm=4.</p>
</td></tr>
<tr><td><code id="kde2_+3A_sigma.min">sigma.min</code></td>
<td>
<p>optional value, specifying the minimum blurring of any pixel, expressed in standard deviations in length units of x</p>
</td></tr>
<tr><td><code id="kde2_+3A_sigma.max">sigma.max</code></td>
<td>
<p>optional value, specifying the maximum blurring of any pixel, expressed in standard deviations in length units of x</p>
</td></tr>
<tr><td><code id="kde2_+3A_reflect">reflect</code></td>
<td>
<p>vector of strings c('left','right','bottom','top') specifying the edges, where the data should be reflected to avoid probability density leaking outside the window</p>
</td></tr>
<tr><td><code id="kde2_+3A_algorithm">algorithm</code></td>
<td>
<p>integer value or character string specifying the smoothing altorithm:<br />
<code>basic (0):</code> basic nearest-neighbor gridding algorithm without smoothing
<code>blur (1):</code> simple Gaussian blur of gridded density field
<code>kdefast (2):</code> 2D smoothing method that ignores higher dimensional information and applies a smoothing size to each pixel that depends on the number of objects in each pixel
<code>kdennnn  (3):</code> sophisticated Kernel density estimator that uses D-dimensional nearest neighbor separations to smooth each data point individually
<code>manual (4):</code> smooths each data point individually using a Gaussian Kernel with point-dependent standard deviations given in the optional vector <code>sigma</code><br /><br /></p>
</td></tr>
<tr><td><code id="kde2_+3A_probability">probability</code></td>
<td>
<p>logical flag. If TRUE, the output field is normalized such that sum(field)dpixel^2=1. If FALSE (default), the field is such that sum(field)dpixel^2 equals the effective number of particles (or effective mass, if weights are given) in the range specified by xlim and ylim, including particle fractions that have been smoothed into the field and excluding particle fractions that have been smoothed out of it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of items
</p>
<table role = "presentation">
<tr><td><code>field</code></td>
<td>
<p>2D array of smoothed density field.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>nx-element vector of cell-center x-coordinates.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>ny-element vector of cell-center y-coordinates.</p>
</td></tr>
<tr><td><code>xbreak</code></td>
<td>
<p>(nx+1)-element vector of cell-edge x-coordinates.</p>
</td></tr>
<tr><td><code>ybreak</code></td>
<td>
<p>(ny+1)-element vector of cell-edge y-coordinates.</p>
</td></tr>
<tr><td><code>dpixel</code></td>
<td>
<p>grid spacing along x-coordinate and y-coordinate.</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>name of algorithm in use.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+griddata">griddata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a mock sample of n d-dimensional points from
# three different components (1D line, 2D square, d-D normal distr)
d = 3 # number of dimensions of mock point set; try to choose different values 2, 3, 4, ...
n = 1e4 # number of particles per component
set.seed(1)
x = rbind(cbind(array(rep(runif(n,-1,1),2),c(n,2)),array(0,c(n,d-2))),
          cbind(array(runif(2*n),c(n,2)),array(0,c(n,d-2))),
          array(rnorm(d*n),c(n,d)))

# grid total projected probability density
npixels = 500 # number of pixels along a grid side
q = midseq(-3,3,npixels)
f1 = outer(dnorm(q),dnorm(q),'*')/3+outer(dunif(q),dunif(q),'*')/3
q = seq(round(npixels/3),round(npixels*2/3))
f1[q+npixels*(q-1)] = f1[q+npixels*(q-1)]+(npixels/6)^2/length(q)/3

# recover 2D projected pdf from 3D point sample using different methods
f2 = kde2(x, n=npixels, xlim=c(-3,3), ylim=c(-3,3), algorithm='basic', probability=TRUE)$field
f3 = kde2(x, n=npixels, xlim=c(-3,3), ylim=c(-3,3), algorithm='kdefast', probability=TRUE)$field
f4 = kde2(x, n=npixels, xlim=c(-3,3), ylim=c(-3,3), algorithm='kdenn', probability=TRUE)$field

# plot the 2D fields
img = function(f,x,y,title) {
  graphics::rasterImage(rasterflip(lim(f)^0.3),x,y,x+0.99,y+0.99)
  graphics::text(x+0.05,y+0.9,title,col='orange',pos=4)
}
oldpar = graphics::par(mar=rep(0.1,4))
nplot(c(0,2),c(0,2),asp=1)
img(f1,0,1,'Input pdf')
img(f2,1,1,'Random sample ("basic")')
img(f3,0,0,'Recovered pdf ("kdefast")')
img(f4,1,0,'Recovered pdf ("kdenn")')
graphics::par(oldpar)

</code></pre>

<hr>
<h2 id='landyszalay'>Two-point correlation estimation</h2><span id='topic+landyszalay'></span>

<h3>Description</h3>

<p>Evaluates the Landy-Szalay (1993) estimator of the two-point correlation function of a point set D given a random comparison set R. The two point sets D and R can be made of different numbers of points, as the pair-counts are automatically normalized according to the number of points. In fact, it is often preferable to make the R set larger to reduce the R-related shot noise in the two-point estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landyszalay(D, R, dr = 0.1, cpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landyszalay_+3A_d">D</code></td>
<td>
<p>n-element vector or n-by-d matrix of d-dimensional positions of the data points</p>
</td></tr>
<tr><td><code id="landyszalay_+3A_r">R</code></td>
<td>
<p>m-element vector or m-by-d matrix of d-dimensional positions of the random comparison points</p>
</td></tr>
<tr><td><code id="landyszalay_+3A_dr">dr</code></td>
<td>
<p>bin size for the evaluation of the two-point correlation function</p>
</td></tr>
<tr><td><code id="landyszalay_+3A_cpp">cpp</code></td>
<td>
<p>logical flag; if set to TRUE (default) a fast implementation in C++ is used to count the point-pairs in distance bins, otherwise the counting is performed less efficiently in R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the two-point statistics of the data points:
</p>
<table role = "presentation">
<tr><td><code>r</code></td>
<td>
<p>vector with the mid-points of the distance bins for which the two-point correlation function has been evaluated.</p>
</td></tr>
<tr><td><code>xi</code></td>
<td>
<p>values of the two-point correlation function at the distances r.</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>Poisson errors of xi.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+paircount">paircount</a></code>
</p>

<hr>
<h2 id='last'>Last element of a vector</h2><span id='topic+last'></span>

<h3>Description</h3>

<p>Returns the last element of a vector or the n-th element counting from the end of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last(x, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="last_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="last_+3A_n">n</code></td>
<td>
<p>optional integer specifying the n-th element from the end to be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar of the same type as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='lightness'>Change lightness of a color</h2><span id='topic+lightness'></span>

<h3>Description</h3>

<p>Change lightness of a color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lightness(col, light = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lightness_+3A_col">col</code></td>
<td>
<p>is a color or vector/array of colors, specified as text (e.g. 'purple') or 7/9-character (e.g. '#A020F0')</p>
</td></tr>
<tr><td><code id="lightness_+3A_light">light</code></td>
<td>
<p>lightness value, according to a HSL scheme, between 0 and 1 or a vector/array thereof</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 9-character color or vector/array of 9-character colors.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transparent">transparent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate different lightnesses of the same color
plot(runif(50),runif(50),pch=20,cex=10,col=lightness('purple',runif(50)))

</code></pre>

<hr>
<h2 id='lim'>Crop values to a custom range</h2><span id='topic+lim'></span>

<h3>Description</h3>

<p>Limits the values of a vector or array to a desired interval, while keeping the shape of the input argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lim(x, min = 0, max = 1, clip = NULL, na = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lim_+3A_x">x</code></td>
<td>
<p>vector or array</p>
</td></tr>
<tr><td><code id="lim_+3A_min">min</code></td>
<td>
<p>minimum value</p>
</td></tr>
<tr><td><code id="lim_+3A_max">max</code></td>
<td>
<p>maximum value</p>
</td></tr>
<tr><td><code id="lim_+3A_clip">clip</code></td>
<td>
<p>optional value specifying the value assigned to clipped data, e.g. <code>clip=NA</code></p>
</td></tr>
<tr><td><code id="lim_+3A_na">na</code></td>
<td>
<p>optional value specifying the value assigned to non-numbers (NA and NaN)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector/array of the same shape as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code>stretch</code>
</p>

<hr>
<h2 id='linuxspaces'>Handle spaces in Linux filenames</h2><span id='topic+linuxspaces'></span>

<h3>Description</h3>

<p>Convert spaces in filenames (&quot; &quot;) to linux-type spaces &quot;\ &quot;, needed when calling system() on macOS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linuxspaces(txt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linuxspaces_+3A_txt">txt</code></td>
<td>
<p>filename, which may contain ordinary spaces, e.g. &quot;my file 1.txt&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filename with modified spaces, e.g. &quot;my\ file\ 1.txt&quot;
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename = '~/Desktop/my file 1.txt'
command = sprintf('ls -l %s',linuxspaces(filename))
## Not run: 
system(command)

## End(Not run)

</code></pre>

<hr>
<h2 id='loadbin'>Read binary data into array</h2><span id='topic+loadbin'></span>

<h3>Description</h3>

<p>Reads binary data using the base function <code><a href="base.html#topic+readBin">readBin</a></code> and recasts it into an array of custom dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadbin(
  filename,
  dim,
  bytes = 4,
  type = "numeric",
  signed = FALSE,
  endian = "little"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadbin_+3A_filename">filename</code></td>
<td>
<p>path of the file to be loaded</p>
</td></tr>
<tr><td><code id="loadbin_+3A_dim">dim</code></td>
<td>
<p>vector specifying the dimensions of the array</p>
</td></tr>
<tr><td><code id="loadbin_+3A_bytes">bytes</code></td>
<td>
<p>number of bytes per number in the binary file</p>
</td></tr>
<tr><td><code id="loadbin_+3A_type">type</code></td>
<td>
<p>character vector of length describing the data type: &quot;numeric&quot; (default), &quot;double&quot;, &quot;integer&quot;, &quot;int&quot;, &quot;logical&quot;, &quot;complex&quot;, &quot;character&quot;, &quot;raw&quot;</p>
</td></tr>
<tr><td><code id="loadbin_+3A_signed">signed</code></td>
<td>
<p>logical. Only used for integers of sizes 1 and 2, when it determines if the quantity on file should be regarded as a signed or unsigned integer.</p>
</td></tr>
<tr><td><code id="loadbin_+3A_endian">endian</code></td>
<td>
<p>endian-type (&quot;big&quot; or &quot;little&quot;) of the file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array of dimension dim.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='makeframe'>Display a single movie frame</h2><span id='topic+makeframe'></span>

<h3>Description</h3>

<p>Displays a single movie-frame in the R-console, exactly as used in a movie generated with <code><a href="#topic+makemovie">makemovie</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeframe(
  frame.draw,
  frame.index,
  width = 1080,
  height = 720,
  cex = 1,
  oversampling = 1,
  pngfile = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeframe_+3A_frame.draw">frame.draw</code></td>
<td>
<p>function that plots an individual frame. This function must have exactly one  argument 'x', which can be integer (e.g. a simple frame index) or real (e.g. a time).</p>
</td></tr>
<tr><td><code id="makeframe_+3A_frame.index">frame.index</code></td>
<td>
<p>list of frame indices 'x' to be included in the movie</p>
</td></tr>
<tr><td><code id="makeframe_+3A_width">width</code></td>
<td>
<p>integer number of pixels along the horizontal axis</p>
</td></tr>
<tr><td><code id="makeframe_+3A_height">height</code></td>
<td>
<p>integer number of pixels along the vertical axis</p>
</td></tr>
<tr><td><code id="makeframe_+3A_cex">cex</code></td>
<td>
<p>number defining the overall scaling of line widths, font sizes, etc.</p>
</td></tr>
<tr><td><code id="makeframe_+3A_oversampling">oversampling</code></td>
<td>
<p>integer specifying the oversampling factor along both dimensions. If larger than 1, frames are plotted with (width*oversampling)-by-(height*oversampling) pixels and then resized back to width-by-height. This can be used to make line objects and text move more smoothly.</p>
</td></tr>
<tr><td><code id="makeframe_+3A_pngfile">pngfile</code></td>
<td>
<p>optional path+filename of output file to save the image. R must have write access to this file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the displayed image as n-by-my-by 4 array, representing the 4 RGBA channels of height n and width m.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makemovie">makemovie</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example: Movie of a manual clock

# Function to draw a single clock face with two hands
frame = function(time) {
  oldpar = graphics::par(mar=c(0,0,0,0))
  nplot(xlim=c(-1.1,1.1),ylim=c(-1.1,1.1),pty='s')
  plotrix::draw.circle(0,0,1,col='#aaaaff')
  radius = c(0.5,0.9)
  speed = 2*pi/c(720,60)
  lwd = c(4,2)
  graphics::arrows(0,0,radius*sin(speed*time),radius*cos(speed*time),lwd=lwd)
  graphics::par(oldpar)
}

# Produce movie
## Not run: 
makeframe(frame,15,200,200)

## End(Not run)

</code></pre>

<hr>
<h2 id='makemovie'>Produce a movie from frame-drawing function</h2><span id='topic+makemovie'></span>

<h3>Description</h3>

<p>Generates an MP4-movie provided a custom function that plots individual frames. The routine has been developed and tested for MacOS and it requires on a working installation of ffmpeg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makemovie(
  frame.draw,
  frame.index,
  output.path,
  output.filename,
  width = 1080,
  height = 720,
  fps = 60,
  keep.frames = FALSE,
  quiet = FALSE,
  separator = "/",
  ffmpeg.cmd = "ffmpeg",
  ffmpeg.opt = "-vcodec libx264 -crf 18 -pix_fmt yuv420p",
  manual = FALSE,
  cex = 1,
  oversampling = 1,
  first.index = 1,
  last.index = length(frame.index)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makemovie_+3A_frame.draw">frame.draw</code></td>
<td>
<p>function that plots an individual frame. This function must have exactly one  argument 'x', which can be integer (e.g. a simple frame index) or real (e.g. a time).</p>
</td></tr>
<tr><td><code id="makemovie_+3A_frame.index">frame.index</code></td>
<td>
<p>list of frame indices 'x' to be included in the movie</p>
</td></tr>
<tr><td><code id="makemovie_+3A_output.path">output.path</code></td>
<td>
<p>character specifying the directory, where the movie and temporary frames are saved</p>
</td></tr>
<tr><td><code id="makemovie_+3A_output.filename">output.filename</code></td>
<td>
<p>movie filename without path. This filename should end on the extension '.mp4'.</p>
</td></tr>
<tr><td><code id="makemovie_+3A_width">width</code></td>
<td>
<p>integer number of pixels along the horizontal axis</p>
</td></tr>
<tr><td><code id="makemovie_+3A_height">height</code></td>
<td>
<p>integer number of pixels along the vertical axis</p>
</td></tr>
<tr><td><code id="makemovie_+3A_fps">fps</code></td>
<td>
<p>number of frames per second</p>
</td></tr>
<tr><td><code id="makemovie_+3A_keep.frames">keep.frames</code></td>
<td>
<p>logical flag specifying whether the temporary directory with the individual frame files should be kept. If <code>manual</code> is set to <code>TRUE</code>, the frames are always kept.</p>
</td></tr>
<tr><td><code id="makemovie_+3A_quiet">quiet</code></td>
<td>
<p>logical flag; if true, all console outputs produced by 'ffmpeg' are suppressed</p>
</td></tr>
<tr><td><code id="makemovie_+3A_separator">separator</code></td>
<td>
<p>filename separate of the system ('/' for Mac, Linux, Unix; '\' for Windows)</p>
</td></tr>
<tr><td><code id="makemovie_+3A_ffmpeg.cmd">ffmpeg.cmd</code></td>
<td>
<p>command used to call ffmpeg form a terminal. Normally, this is just 'ffmpeg'.</p>
</td></tr>
<tr><td><code id="makemovie_+3A_ffmpeg.opt">ffmpeg.opt</code></td>
<td>
<p>compression and formatting options used with ffmpeg</p>
</td></tr>
<tr><td><code id="makemovie_+3A_manual">manual</code></td>
<td>
<p>logical flag; if true, ffmpeg is not called from within the code and the frames are never deleted. The suggested linux command line is returned as output.</p>
</td></tr>
<tr><td><code id="makemovie_+3A_cex">cex</code></td>
<td>
<p>number defining the overall scaling of line widths, font sizes, etc.</p>
</td></tr>
<tr><td><code id="makemovie_+3A_oversampling">oversampling</code></td>
<td>
<p>integer specifying the oversampling factor along both dimensions. If larger than 1, frames are plotted with (width*oversampling)-by-(height*oversampling) pixels and then resized back to width-by-height. This can be used to make line objects and text move more smoothly.</p>
</td></tr>
<tr><td><code id="makemovie_+3A_first.index">first.index</code></td>
<td>
<p>integer specifying the first index of the vector frame.index to consider. Choosing a value larger than the default (1) can be used to continue a previously interrupted call of makemovie and/or to call makemovie from different R sessions in parallel.</p>
</td></tr>
<tr><td><code id="makemovie_+3A_last.index">last.index</code></td>
<td>
<p>integer specifying the last index of the vector frame.index to consider. Choosing a value smaller than the default (length(frame.index)) can be used to continue a previously interrupted call of makemovie and/or to call makemovie from different R sessions in parallel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Linux command line to convert frames into movie using ffmpeg.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeframe">makeframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example: Movie of a manual clock

# Function to draw a single clock face with two hands
frame = function(time) {
  oldpar = graphics::par(mar=c(0,0,0,0))
  nplot(xlim=c(-1.1,1.1),ylim=c(-1.1,1.1),pty='s')
  plotrix::draw.circle(0,0,1,col='#aaaaff')
  radius = c(0.5,0.9)
  speed = 2*pi/c(720,60)
  lwd = c(4,2)
  graphics::arrows(0,0,radius*sin(speed*time),radius*cos(speed*time),lwd=lwd)
  graphics::par(oldpar)
}

# Produce movie
## Not run: 
makemovie(frame,seq(0,60,0.5),'~/testmovie','movie.mp4',200,200)

## End(Not run)

</code></pre>

<hr>
<h2 id='mcintegral'>Monte Carlo and Quasi-Monte Carlo integration in any dimension</h2><span id='topic+mcintegral'></span>

<h3>Description</h3>

<p>Numerical integration using a Monte Carlo (MC) or Quasi-Monte Carlo (QMC) algorithm, based on a Halton sequence. These algorithms are of low order (1/sqrt(n) for MC, log(n)/n for QMC in one dimension) compared to the typical orders of 1D deterministic integrators, such as those available in the <code>integrate</code> function. The MC and QMC integrators are suitable to compute D-dimensional integrals with D&gt;&gt;1, since the order of most deterministic methods deteriorates exponentially with D, whereas the order of MC remains 1/sqrt(n), irrespective of D, and the order of QMC only deteriorates slowly with D as log(n)^D/n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcintegral(f, a, b, n = 1e+05, qmc = FALSE, seed = NULL, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcintegral_+3A_f">f</code></td>
<td>
<p>scalar function of a D-vector to be integrated numerically; for fast performance, this function should be vectorized, such that it returns an N-element vector if it is given an N-by-D matrix as argument. An automatic warning is produced if the function is not vectorized in this manner.</p>
</td></tr>
<tr><td><code id="mcintegral_+3A_a">a</code></td>
<td>
<p>D-vector with lower limit(s) of the integration</p>
</td></tr>
<tr><td><code id="mcintegral_+3A_b">b</code></td>
<td>
<p>D-vector with upper limit(s) of the integration</p>
</td></tr>
<tr><td><code id="mcintegral_+3A_n">n</code></td>
<td>
<p>approximate number of random evaluations. (The exact number is max(1,round(sqrt(n)))^2.)</p>
</td></tr>
<tr><td><code id="mcintegral_+3A_qmc">qmc</code></td>
<td>
<p>logical flag. If false (default), pseudo-random numbers are used; if true, quasi-random numbers from a D-dimensional Halton sequence are used.</p>
</td></tr>
<tr><td><code id="mcintegral_+3A_seed">seed</code></td>
<td>
<p>optional seed for random number generator. Only used if <code>qmc</code> is false.</p>
</td></tr>
<tr><td><code id="mcintegral_+3A_warn">warn</code></td>
<td>
<p>logical flag. If true (default), a warning is produced if the function f is not vectorized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of items:
</p>
<table role = "presentation">
<tr><td><code>value</code></td>
<td>
<p>the best estimate of the integral.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>an estimate of the statistical 1-sigma uncertainty.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>exact number of evaluations (close to n).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Numerically integrate sin(x)
f = function(x) sin(x)
m = mcintegral(f,0,pi)
cat(sprintf('Integral = %.3f\u00B1%.3f (true value = 2)\n',m$value,m$sigma))

## Numerically compute the volume of a unit sphere
sphere = function(x) as.numeric(rowSums(x^2)&lt;=1) # this is vectorized
vmc = mcintegral(sphere,rep(-1,3),rep(1,3),seed=1)
vqmc = mcintegral(sphere,rep(-1,3),rep(1,3),qmc=TRUE)
cat(sprintf('Volume of unit sphere = %.3f\u00B1%.3f (MC)\n',vmc$value,vmc$error))
cat(sprintf('Volume of unit sphere = %.3f\u00B1%.3f (QMC)\n',vqmc$value,vqmc$error))
cat(sprintf('Volume of unit sphere = %.3f (exact)\n',4*pi/3))

</code></pre>

<hr>
<h2 id='midseq'>Mid-points of regular grid</h2><span id='topic+midseq'></span>

<h3>Description</h3>

<p>Compute the mid-point positions of a one-dimensional regular grid of n equal intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midseq(min, max, n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="midseq_+3A_min">min</code></td>
<td>
<p>left boundary of first bin</p>
</td></tr>
<tr><td><code id="midseq_+3A_max">max</code></td>
<td>
<p>right boundary of last bin</p>
</td></tr>
<tr><td><code id="midseq_+3A_n">n</code></td>
<td>
<p>number of bins</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of mid points
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='mollweide'>Mollweide projection</h2><span id='topic+mollweide'></span>

<h3>Description</h3>

<p>Performs a Mollweide projection (also known as Babinet projection, homalographic projection, homolographic projection, and elliptical projection) of longitude and latitude coordinates. The most important feature of the Mollweide projection is that it preserves surface areas, which makes it a commonly used projection in geography, astronomy and cosmology. The total surface area of the standard projection is equal to the surface area of the unit sphere (4pi); and the shape of the fully projected sphere is an ellipse (with axes lengths 2*sqrt(2) and sqrt(2)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mollweide(lon, lat, lon0 = 0, radius = 1, deg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mollweide_+3A_lon">lon</code></td>
<td>
<p>n-vector of longitudes in radian (unless deg=TRUE)</p>
</td></tr>
<tr><td><code id="mollweide_+3A_lat">lat</code></td>
<td>
<p>n-vector of latitudes in radian (unless deg=TRUE), must lie between -pi/2 and +pi/2</p>
</td></tr>
<tr><td><code id="mollweide_+3A_lon0">lon0</code></td>
<td>
<p>latitude of null meridian, which will be projected on to x=0</p>
</td></tr>
<tr><td><code id="mollweide_+3A_radius">radius</code></td>
<td>
<p>radius of spherical projection, such that the surface area of the projection equals 4*pi*radius^2</p>
</td></tr>
<tr><td><code id="mollweide_+3A_deg">deg</code></td>
<td>
<p>logical flag; if set to TRUE, the input arguments <code>lon</code>, <code>lat</code>, <code>lon0</code> are assumed to be in degrees (otherwise in radians)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n-by-2 matrix of 2D Cartesian coordinates <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon = runif(1e4,0,2*pi)
lat = asin(runif(1e4,-1,1)) # = uniform sampling of the sphere
plot(mollweide(lon,lat),xlim=c(-3,3),ylim=c(-1.5,1.5),pch=16,cex=0.5)
plotrix::draw.ellipse(0,0,2*sqrt(2),sqrt(2),border='orange',lwd=2)

</code></pre>

<hr>
<h2 id='moments'>Second moment tensor</h2><span id='topic+moments'></span>

<h3>Description</h3>

<p>Compute the tensor of second moments of a set of point masses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moments(x, m = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moments_+3A_x">x</code></td>
<td>
<p>n-by-3 matrix (x[1:n,1:3]) specifying the 3D Cartesian coordinates of n points</p>
</td></tr>
<tr><td><code id="moments_+3A_m">m</code></td>
<td>
<p>n-vector with point masses, or single scalar giving a uniform mass for all points (default is unity)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-by-3 symmetric matrix
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inertia">inertia</a></code>, <code><a href="#topic+quadrupole">quadrupole</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a randomly oriented ellipsoid of semi-axes a=2.1, b=1.73, c=0.8
x = t(t(fibonaccisphere(1e4))*c(2.1,1.73,0.8))
x = x%*%rotation3(c(0.3,1.64,2.31))

# Recover lengths of semi-axes from eigenvalues of second moment tensor
M = moments(x,m=1/dim(x)[1])
v = sqrt(3*eigen(M)$values)
print(v)

</code></pre>

<hr>
<h2 id='mutual'>Mutual information of two random variables</h2><span id='topic+mutual'></span>

<h3>Description</h3>

<p>Computes the mutual information of two random variables X and Y, given their 2D density represented in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual(x, y = NULL, b = exp(1), n = NULL, xlim = NULL, ylim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutual_+3A_x">x</code></td>
<td>
<p>either of the following: (1) an m-by-n matrix representing the 2D probability mass function of two random variables X and Y; all elements must be non-negative; the normalization is irrelevant. (2) an n-vector of sampled x-values; in this case y must be specified.</p>
</td></tr>
<tr><td><code id="mutual_+3A_y">y</code></td>
<td>
<p>optional vector of sampled y-values (only used if <code>x</code> is a vector of x-values).</p>
</td></tr>
<tr><td><code id="mutual_+3A_b">b</code></td>
<td>
<p>base of the logarithm in mutual information I(X,Y). Default is e.</p>
</td></tr>
<tr><td><code id="mutual_+3A_n">n</code></td>
<td>
<p>scalar or 2-element vector specifying the number of equally space grid cells. Only used if x and y are vectors. If not provided, the default is n=0.2*sqrt(length(x)), bound between 2 and 1000. Note that n~sqrt(length(x)) keeps the mutual information constant for random data sets of different size.</p>
</td></tr>
<tr><td><code id="mutual_+3A_xlim">xlim</code></td>
<td>
<p>2-element vector specifying the x-range (data cropped if necessary). Only used if x and y are vectors. If not given, xlim is set to the range of x.</p>
</td></tr>
<tr><td><code id="mutual_+3A_ylim">ylim</code></td>
<td>
<p>2-element vector specifying the y-range (data cropped if necessary). Only used if x and y are vectors. If not given, ylim is set to the range of y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of items:
</p>
<table role = "presentation">
<tr><td><code>I</code></td>
<td>
<p>standard mutual information I(X,Y).</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>normalized mutual information I(X,Y)/sqrt(H(X)*H(Y)), where H is the Shannon information entropy.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='ndft'>Non-uniform Discrete Fourier Transform</h2><span id='topic+ndft'></span>

<h3>Description</h3>

<p>Compute the one-dimensional Non-uniform Discrete Fourier Transform (NDFT). This is needed if the data are sampled at irregularly spaced times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndft(
  f,
  x = seq(0, length(f) - 1)/length(f),
  nu = seq(0, length(f) - 1),
  inverse = FALSE,
  weighing = TRUE,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ndft_+3A_f">f</code></td>
<td>
<p>vector of real or complex function values</p>
</td></tr>
<tr><td><code id="ndft_+3A_x">x</code></td>
<td>
<p>vector of points in direct space, typically time or position coordinates. If <code>inverse=FALSE</code>, <code>x</code> must have the same length as <code>f</code>.</p>
</td></tr>
<tr><td><code id="ndft_+3A_nu">nu</code></td>
<td>
<p>vector of frequencies in units of [1/units of x]. If <code>inverse=TRUE</code>, <code>nu</code> must have the same length as <code>f</code>.</p>
</td></tr>
<tr><td><code id="ndft_+3A_inverse">inverse</code></td>
<td>
<p>logical flag; if TRUE, the inverse Fourier transform is performed.</p>
</td></tr>
<tr><td><code id="ndft_+3A_weighing">weighing</code></td>
<td>
<p>logical flag; if TRUE, irregularly spaced evaluations of <code>f</code> will be weighted proportionally to their bin width in <code>x</code> (if <code>inverse=FALSE</code>) or <code>nu</code> (if <code>inverse=FALSE</code>).</p>
</td></tr>
<tr><td><code id="ndft_+3A_simplify">simplify</code></td>
<td>
<p>logical flag; if TRUE, the complex output array will be simplified to a real array, if it is real within the floating point accuracy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The one-dimensional NDFT of a vector <code class="reqn">f=(f_1,...,f_N)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">F_j=\sum_i w_i f_i exp(-2\pi i*x_i*\nu_j)</code>
</p>
<p> where <code class="reqn">w_i</code> are optional weights, proportional to the interval around <code class="reqn">x_i</code>, only used if <code>weighing=TRUE</code>. Likewise, the inverse NDFT is defined as </p>
<p style="text-align: center;"><code class="reqn">f_i=\sum_j w_j F_j exp(+2\pi i*x_i*nu_j)</code>
</p>
<p> where <code class="reqn">w_j</code> are optional weights, proportional to the interval around <code class="reqn">\nu_j</code>. In this implementation NDFTs are computed using a brute force algorithm, scaling as <code class="reqn">O(N*N)</code>, which is considerably worse than the <code class="reqn">O(N)*log(N)</code> scaling of FFT algorithms. It is therefore important to pick the required frequencies wisely to minimise computing times.
</p>


<h3>Value</h3>

<p>Returns a vector of the same length as <code>x</code> (if <code>inverse=FALSE</code>) or <code>nu</code> (if <code>inverse=TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fft">fft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define an example signal
nu1 = 1 # [Hz] first frequency
nu2 = 8 # [Hz] second frequency in the signal
s = function(t) sin(2*pi*nu1*t)+0.7*cos(2*pi*nu2*t+5)

# Discretize signal
N = 50 # number of samples
t.uniform = seq(0,N-1)/N
t.nonuniform = t.uniform^1.3
s.uniform = s(t.uniform)
s.nonuniform = s(t.nonuniform)

# Plot signal
oldpar = par(mfrow = c(1, 2))
curve(s,0,1,500,xaxs='i',main='Time signal',xlab='Time t',ylab='s(t)',col='grey')
points(t.uniform,s.uniform,pch=16,cex=0.8)
points(t.nonuniform,s.nonuniform,pch=4,col='blue')
legend('topright',c('Continuous signal','Uniform sample','Non-uniform sample'),
       lwd=c(1,NA,NA),pch=c(NA,16,4),col=c('grey','black','blue'),pt.cex=c(1,0.8,1))

# Uniform and non-uniform DFT
nu = seq(0,N-1) # discrete frequencies
spectrum.uniform = stats::fft(s.uniform)
spectrum.nonuniform = ndft(s.nonuniform,t.nonuniform,nu)
spectrum.wrong = stats::fft(s.nonuniform)

# Evaluate power
power.uniform = Mod(spectrum.uniform)^2
power.nonuniform = Mod(spectrum.nonuniform)^2
power.wrong = Mod(spectrum.wrong)^2

# Plot DFT and NDFT up to Nyquist frequency
plot(nu,power.uniform,pch=16,cex=0.8,xlim=c(0,N/2),xaxs='i',
               main='Power spectrum',xlab=expression('Frequency'~nu~'[Hz]'),ylab='Power')
points(nu,power.nonuniform,pch=4,col='blue')
points(nu,power.wrong,pch=1,col='red')
abline(v=c(nu1,nu2),col='grey',lty=2)
legend('topright',c('DFT of uniform sample','NDFT of non-uniform sample',
'DFT of non-uniform sample (wrong)','Input frequencies'),
       lwd=c(NA,NA,NA,1),lty=c(NA,NA,NA,2),pch=c(16,4,1,NA),
       col=c('black','blue','red','grey'),pt.cex=c(0.8,1,1,NA))
par(oldpar)

</code></pre>

<hr>
<h2 id='ngon'>Draw a regular n-gon</h2><span id='topic+ngon'></span>

<h3>Description</h3>

<p>Draws a regular polygon with n sides, such as a triangle (n=3) or hexagon (n=6).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngon(x = 0, y = 0, s = 1, n = 6, angle = 0, fix.aspect = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ngon_+3A_x">x</code></td>
<td>
<p>vector of x-coordinates specifying the centres of the n-gons.</p>
</td></tr>
<tr><td><code id="ngon_+3A_y">y</code></td>
<td>
<p>vector of y-coordinates specifying the centres of the n-gons.</p>
</td></tr>
<tr><td><code id="ngon_+3A_s">s</code></td>
<td>
<p>side lengths; either a single number or a vector of the same length as <code>x</code> and <code>y</code>. In log-log plots, the value of s is in units of dex.</p>
</td></tr>
<tr><td><code id="ngon_+3A_n">n</code></td>
<td>
<p>number of sides of the regular n-gons; either a single number or a vector of the same length as <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="ngon_+3A_angle">angle</code></td>
<td>
<p>rotation angle in radians; either a single number or a vector of the same length as <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="ngon_+3A_fix.aspect">fix.aspect</code></td>
<td>
<p>logical flag. If TRUE (default), the aspect ratio of the n-gon on the screen is forced to be unity, even if the this makes it irregular in the coordinates of the plot. If FALSE, the n-gon is regular in plot coordinates, which makes it distorted in screen coordinates if the aspect ratio is not one and/or if logarithmic coordinates are used.</p>
</td></tr>
<tr><td><code id="ngon_+3A_...">...</code></td>
<td>
<p>additional arguments used by <code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plot random points on the unit sphere in Mollweide projection
# hexagon at the center of a plot
nplot(bty='o', asp=0.5)
ngon(x=0.5, y=0.5, s=0.1, n=6, fix.aspect=FALSE)

ngon(x=0.5, y=0.5, s=0.1, n=6, border='red')

plot(NA,xlim=c(1,1e3),ylim=c(1,1e5),log='xy')
ngon(x=10^runif(10,0,3), y=10^runif(10,0,5), s=1, n=6,  border='red',lwd=3)

</code></pre>

<hr>
<h2 id='nplot'>Make empty plot area</h2><span id='topic+nplot'></span>

<h3>Description</h3>

<p>Open an empty plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nplot(
  xlim = c(0, 1),
  ylim = c(0, 1),
  xlab = "",
  ylab = "",
  xaxs = "i",
  yaxs = "i",
  xaxt = "n",
  yaxt = "n",
  bty = "n",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nplot_+3A_xlim">xlim</code>, <code id="nplot_+3A_ylim">ylim</code></td>
<td>
<p>vectors with plotting limits.</p>
</td></tr>
<tr><td><code id="nplot_+3A_xlab">xlab</code>, <code id="nplot_+3A_ylab">ylab</code></td>
<td>
<p>horizontal and vertical labels.</p>
</td></tr>
<tr><td><code id="nplot_+3A_xaxs">xaxs</code>, <code id="nplot_+3A_yaxs">yaxs</code></td>
<td>
<p>style of the axis interval (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="nplot_+3A_xaxt">xaxt</code>, <code id="nplot_+3A_yaxt">yaxt</code></td>
<td>
<p>character which specifies the x axis type (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="nplot_+3A_bty">bty</code></td>
<td>
<p>character specifying the border type (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="nplot_+3A_...">...</code></td>
<td>
<p>additional arguments used by <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='paircount'>Count the number of point-pairs in distance bins</h2><span id='topic+paircount'></span>

<h3>Description</h3>

<p>Count the number of point-pairs in equally spaced distances bins. Code works in any dimension. If only one point set is provided, the distances of this point set with itself are used (counting each pairs only once, i.e. only ij, not ji).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paircount(x, y = NULL, dr, rmax, cpp = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paircount_+3A_x">x</code></td>
<td>
<p>n-element vector or n-by-d matrix of d-dimensional positions of data points</p>
</td></tr>
<tr><td><code id="paircount_+3A_y">y</code></td>
<td>
<p>optional m-element vector or m-by-d matrix of d-dimensional positions of a second point set</p>
</td></tr>
<tr><td><code id="paircount_+3A_dr">dr</code></td>
<td>
<p>distance bin size</p>
</td></tr>
<tr><td><code id="paircount_+3A_rmax">rmax</code></td>
<td>
<p>maximum distance to be considered</p>
</td></tr>
<tr><td><code id="paircount_+3A_cpp">cpp</code></td>
<td>
<p>logical flag; if set to TRUE (default) a fast implementation in C++ is used, otherwise the counting is performed less efficiently in R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of two column vectors:
</p>
<table role = "presentation">
<tr><td><code>r</code></td>
<td>
<p>mid-points of the distance bins.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of pairs in the distance bin.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landyszalay">landyszalay</a></code>
</p>

<hr>
<h2 id='pdf2jpg'>Convert pdf to jpg</h2><span id='topic+pdf2jpg'></span>

<h3>Description</h3>

<p>Calls the console &quot;convert&quot; function to convert a pdf-file into a jpeg-image. Requires &quot;convert&quot; to be installed already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdf2jpg(
  pdf.filename,
  jpg.filename,
  quality = 100,
  background = "white",
  dim = c(1600, 1200),
  remove.pdf = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdf2jpg_+3A_pdf.filename">pdf.filename</code></td>
<td>
<p>filename of pdf input file</p>
</td></tr>
<tr><td><code id="pdf2jpg_+3A_jpg.filename">jpg.filename</code></td>
<td>
<p>filename of jpeg output file</p>
</td></tr>
<tr><td><code id="pdf2jpg_+3A_quality">quality</code></td>
<td>
<p>quality of jpeg compression from 1 (worst) to 100 (best)</p>
</td></tr>
<tr><td><code id="pdf2jpg_+3A_background">background</code></td>
<td>
<p>color of background</p>
</td></tr>
<tr><td><code id="pdf2jpg_+3A_dim">dim</code></td>
<td>
<p>size in pixels of the jpeg-image</p>
</td></tr>
<tr><td><code id="pdf2jpg_+3A_remove.pdf">remove.pdf</code></td>
<td>
<p>logical flag. If TRUE, the pdf file is deleted after the conversion.</p>
</td></tr>
<tr><td><code id="pdf2jpg_+3A_verbose">verbose</code></td>
<td>
<p>logical flag to turn on/off console statements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='planckcolors'>Planck CMB colour palette</h2><span id='topic+planckcolors'></span>

<h3>Description</h3>

<p>Generates color scale matching the one normally used to display the Planck CMB temperature map from -300uK to +300uK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>planckcolors(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="planckcolors_+3A_n">n</code></td>
<td>
<p>integer number of colors in the scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n-vector of RGB colour strings.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>
<p>#' @examples
nplot()
rasterImage(rbind(planck.colors(1e3)),0,0,1,1)
</p>

<hr>
<h2 id='pol2car'>Polar/cylindrical to Cartesian coordinate conversion</h2><span id='topic+pol2car'></span>

<h3>Description</h3>

<p>Convert polar/cylindrical coordinates to 2D/3D Cartesian coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pol2car(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pol2car_+3A_x">x</code></td>
<td>
<p>2/3-element or n-by-2/3 matrix representing the polar/cylindrical coordinates (r,phi)/(r,phi,z), where phi=0...2*pi is the azimuth measured positively from the x-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 2/3-element vector or a n-by-2/3 element matrix representing the Cartesian coordinates (x,y)/(x,y,z).
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+car2pol">car2pol</a></code>
</p>

<hr>
<h2 id='quadrupole'>Quadrupole tensor</h2><span id='topic+quadrupole'></span>

<h3>Description</h3>

<p>Compute the trace-free quadrupole tensor of a set of point masses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadrupole(x, m = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadrupole_+3A_x">x</code></td>
<td>
<p>n-by-3 matrix (x[1:n,1:3]) specifying the 3D Cartesian coordinates of n points</p>
</td></tr>
<tr><td><code id="quadrupole_+3A_m">m</code></td>
<td>
<p>n-vector with point masses, or single scalar giving a uniform mass for all points (default is unity)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-by-3 symmetric matrix
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inertia">inertia</a></code>, <code><a href="#topic+moments">moments</a></code>
</p>

<hr>
<h2 id='quiet'>Suppress in-routine output</h2><span id='topic+quiet'></span>

<h3>Description</h3>

<p>Runs any routine or command while suppressing in-routine console output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quiet(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quiet_+3A_x">x</code></td>
<td>
<p>routine to be called</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns whatever the called routine returns in invisible form.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Test function
test = function(x) {
  cat('This routine is likes to talk a lot!\n')
  return(x^2)
}

# Standard call call:
y = test(5)
print(y)

# Quiet call:
y = quiet(test(6))
print(y)

</code></pre>

<hr>
<h2 id='rasterflip'>Flip array to be displayed with rasterImage()</h2><span id='topic+rasterflip'></span>

<h3>Description</h3>

<p>Flips the array A to be displayed with rasterImage, such that the first index runs from left to right and second index runs from bottom to top, like in standard Cartesian coordinates. In this way <code>rasterImage(rasterflip(A))</code> has the same orientation as <code>image(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterflip(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterflip_+3A_a">A</code></td>
<td>
<p>n-by-m array of a monochromatic image or n-by-m-by-k array of a color image (where k is 3 or 4)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A m-by-n array of a monochromatic image or m-by-n-by-k array of a color image.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>

<hr>
<h2 id='rebindensity'>Re-bin density histograms</h2><span id='topic+rebindensity'></span>

<h3>Description</h3>

<p>Transform density histogram data into histogram data with different bins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebindensity(x, y, xout)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rebindensity_+3A_x">x</code></td>
<td>
<p>n-vector giving the mid-points of the input histogram bins, must be equally spaced</p>
</td></tr>
<tr><td><code id="rebindensity_+3A_y">y</code></td>
<td>
<p>n-vector giving the values of the input histogram values</p>
</td></tr>
<tr><td><code id="rebindensity_+3A_xout">xout</code></td>
<td>
<p>m-vector giving the mid-points of the output histogram bins, must be equally spaced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m-vector of y-values associated with the bins specified by xout.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'># original binning
x = seq(0.5,4.5)
y = seq(5)
plot(x,y,xlim=c(-1,6),ylim=c(0,6),pch=16)
lines(histcoord(x,y),lwd=3)

# rebinning
xout = seq(-0.9,6,0.3)
yout = rebindensity(x,y,xout)
points(xout,yout,col='red',pch=16)
lines(histcoord(xout,yout),col='red')

</code></pre>

<hr>
<h2 id='rng'>Random number generator for a custom d-dimensional distribution</h2><span id='topic+rng'></span>

<h3>Description</h3>

<p>Brute-force algorithm for drawing random numbers from a d-dimensional distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rng(f, n, min, max, fmax = NULL, quasi = FALSE, start = 1, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rng_+3A_f">f</code></td>
<td>
<p>function of a d-vector representing a d-dimensional distribution function. This function must be non-negative on the whole domain. It does not need to be normalized. For fast performance, this function should be vectorized, such that it returns an N-element vector if it is given an N-by-D matrix as argument. An automatic warning is produced if the function is not vectorized in this manner.</p>
</td></tr>
<tr><td><code id="rng_+3A_n">n</code></td>
<td>
<p>number of random numbers to be generated</p>
</td></tr>
<tr><td><code id="rng_+3A_min">min</code>, <code id="rng_+3A_max">max</code></td>
<td>
<p>are d-vectors specifying the domain of distribution function; the domain must be finite and should be as restrictive as possible to keep the number of random trials as low as possible.</p>
</td></tr>
<tr><td><code id="rng_+3A_fmax">fmax</code></td>
<td>
<p>maximum value of <code>f</code> on its domain. If set to <code>NULL</code> (default), this value will be determined automatically, using the <code><a href="stats.html#topic+optimize">optimize</a></code> (if d=1) and <code><a href="stats.html#topic+optim">optim</a></code> (if d&gt;1) function with its default options. A value for <code>fmax</code> should be set, if the automatically determined value (see output list) is incorrect.</p>
</td></tr>
<tr><td><code id="rng_+3A_quasi">quasi</code></td>
<td>
<p>logical flag. If true, quasi-random numbers with low-discrepancy are drawn, based on a Halton sequence. Otherwise, the standard internal pseudo-random generator of <code>runif()</code> is used.</p>
</td></tr>
<tr><td><code id="rng_+3A_start">start</code></td>
<td>
<p>starting index of Halton sequence. Only used if <code>quasi=TRUE</code>.</p>
</td></tr>
<tr><td><code id="rng_+3A_warn">warn</code></td>
<td>
<p>logical flag. If true, a warning is produced if the function f is not vectorized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of items:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>n-by-d matrix of n random d-vectors.</p>
</td></tr>
<tr><td><code>fmax</code></td>
<td>
<p>maximum value of the distribution function <code>f</code> on the domain.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of random vectors (same as argument <code>n</code>).</p>
</td></tr>
<tr><td><code>ntrials</code></td>
<td>
<p>number of trials.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpqr">dpqr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 1D random number generation from a sine-function
f = function(x) sin(x)
out.pseudo = rng(f,1e3,0,pi)
out.quasi = rng(f,1e3,0,pi,quasi=TRUE)
hist(out.pseudo$x,100,freq=FALSE,border=NA,xlab='x',main='sine-distribution')
hist(out.quasi$x,100,freq=FALSE,border=NA,col='#ff000066',add=TRUE)
curve(sin(x)/2,0,pi,add=TRUE)

## 2D quasi-random sampling of a disk with exponentially declining surface density
f = function(x) exp(-sqrt(x[,1]^2+x[,2]^2))
out = rng(f,1e4,min=c(-5,-5),max=c(5,5),quasi=TRUE)
plot(out$x,cex=0.3,pch=16,asp=1,main='Quasi-random exponential disk')

## 5D random number generation (5-dimensional sphere)
f = function(x) as.numeric(sum(x^2)&lt;=1)
out = rng(f,1e4,rep(-1,5),rep(1,5))
cat(sprintf('Number of successes over number of trials : %.4f\n',out$n/out$ntrials))
cat(sprintf('Expected ratio for n=\u221E : %.4f\n',pi^(5/2)/gamma(1+5/2)/2^5))

</code></pre>

<hr>
<h2 id='rotation2'>2D rotation matrix</h2><span id='topic+rotation2'></span>

<h3>Description</h3>

<p>Compute a 2D rotation matrix given a rotation angle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation2(angle)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotation2_+3A_angle">angle</code></td>
<td>
<p>rotation angle in radians (counter-clockwise)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 2-by-2 anti-symmetric rotation matrix
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotation3">rotation3</a></code>
</p>

<hr>
<h2 id='rotation3'>3D rotation matrix</h2><span id='topic+rotation3'></span>

<h3>Description</h3>

<p>Compute a 3D rotation matrix given an axis and an angle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotation3(u, angle = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotation3_+3A_u">u</code></td>
<td>
<p>3-vector specifying the rotation axis</p>
</td></tr>
<tr><td><code id="rotation3_+3A_angle">angle</code></td>
<td>
<p>rotation angle in radians; if not given, the norm of the vector <code>u</code> is interpreted as the angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-by-3 rotation matrix
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotation2">rotation2</a></code>
</p>

<hr>
<h2 id='runif2'>Generate randomly oriented vectors in 2D</h2><span id='topic+runif2'></span>

<h3>Description</h3>

<p>Generate randomly oriented vectors in 2D, following an isotropic distribution (optionally truncated to a region).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif2(n = 1, r = c(0, 1), azimuth = c(0, 2 * pi), quasi = FALSE, start = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif2_+3A_n">n</code></td>
<td>
<p>number of random vectors to be generated</p>
</td></tr>
<tr><td><code id="runif2_+3A_r">r</code></td>
<td>
<p>2-vector specifying the range of radii</p>
</td></tr>
<tr><td><code id="runif2_+3A_azimuth">azimuth</code></td>
<td>
<p>2-vector specifying the range of azimuth angles</p>
</td></tr>
<tr><td><code id="runif2_+3A_quasi">quasi</code></td>
<td>
<p>logical flag. If true, quasi-random numbers with low-discrepancy are drawn, based on a Halton sequence. Otherwise, the standard internal pseudo-random generator of <code>runif()</code> is used.</p>
</td></tr>
<tr><td><code id="runif2_+3A_start">start</code></td>
<td>
<p>starting index of Halton sequence. Only used if <code>quasi=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n-by-2 array of n vectors.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif3">runif3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate 500 unit vectors with radii between 0.5 and 1
x = runif2(500,r=c(0.5,1))
oldpar = par(pty='s')
plot(x,pch=20)
par(oldpar)

</code></pre>

<hr>
<h2 id='runif3'>Generate randomly oriented vectors in 3D</h2><span id='topic+runif3'></span>

<h3>Description</h3>

<p>Generate randomly oriented vectors in 3D, following an isotropic distribution (optionally truncated to a region).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif3(
  n = 1,
  r = c(0, 1),
  azimuth = c(0, 2 * pi),
  polarangle = c(0, pi),
  quasi = FALSE,
  start = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif3_+3A_n">n</code></td>
<td>
<p>number of random vectors to be generated</p>
</td></tr>
<tr><td><code id="runif3_+3A_r">r</code></td>
<td>
<p>2-vector specifying the range of radii</p>
</td></tr>
<tr><td><code id="runif3_+3A_azimuth">azimuth</code></td>
<td>
<p>2-vector specifying the range of azimuth angles (maximum range 0..2*pi)</p>
</td></tr>
<tr><td><code id="runif3_+3A_polarangle">polarangle</code></td>
<td>
<p>2-vector specifying the range of polar angles (maximum range 0..pi)</p>
</td></tr>
<tr><td><code id="runif3_+3A_quasi">quasi</code></td>
<td>
<p>logical flag. If true, quasi-random numbers with low-discrepancy are drawn, based on a Halton sequence. Otherwise, the standard internal pseudo-random generator of <code>runif()</code> is used.</p>
</td></tr>
<tr><td><code id="runif3_+3A_start">start</code></td>
<td>
<p>starting index of Halton sequence. Only used if <code>quasi=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n-by-3 array of n vectors.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runif2">runif2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## draw 20 unit vectors on a sphere
x = runif3(20,r=c(1,1))
print(rowSums(x^2))

</code></pre>

<hr>
<h2 id='scalarproduct'>Scalar product</h2><span id='topic+scalarproduct'></span>

<h3>Description</h3>

<p>Compute scalar product of two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarproduct(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scalarproduct_+3A_x">x</code>, <code id="scalarproduct_+3A_y">y</code></td>
<td>
<p>d-element vectors or n-by-d matrices representing n d-element vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a scalar or a n-element vector with the scalar products.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vectorproduct">vectorproduct</a></code>
</p>

<hr>
<h2 id='smartround'>Round a vector of floating-point values while preserving their sum</h2><span id='topic+smartround'></span>

<h3>Description</h3>

<p>Rounds the values in a vector up and down, preserving the sum of the vector and minimizing the total rounding error under this condition. An example where this is useful is when rounding a vector of percentages, where the total should add up to 100 percent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smartround(x, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smartround_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="smartround_+3A_digits">digits</code></td>
<td>
<p>optional non-negative integer specifying the number of digits of the rounded numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of rounded values of the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = runif(5)
x = x/sum(x)*100
print(x)
print(sum(x))
y = smartround(x)
print(y)
print(sum(y))
y2 = smartround(x,2)
print(y2)
print(sum(y2))

</code></pre>

<hr>
<h2 id='smoothcontour'>Draw smoothed contours</h2><span id='topic+smoothcontour'></span>

<h3>Description</h3>

<p>Draw smoothed iso-countours for a density field. The contours are computed using the <code><a href="grDevices.html#topic+contourLines">contourLines</a></code> routine and smoothed using the <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> function. Both open and closed contour lines are handled correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothcontour(
  x = seq(0, 1, length.out = nrow(z)),
  y = seq(0, 1, length.out = ncol(z)),
  z,
  levels,
  smoothing = 0.5,
  min.radius = 1,
  lwd = 1,
  lty = 1,
  col = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothcontour_+3A_x">x</code>, <code id="smoothcontour_+3A_y">y</code></td>
<td>
<p>vectors containing the locations of grid lines at which the values of z are measured. These must be in ascending order. By default, equally spaced values from 0 to 1 are used.</p>
</td></tr>
<tr><td><code id="smoothcontour_+3A_z">z</code></td>
<td>
<p>matrix representing the density field on which the contours are plotted.</p>
</td></tr>
<tr><td><code id="smoothcontour_+3A_levels">levels</code></td>
<td>
<p>vector of the iso-contour levels.</p>
</td></tr>
<tr><td><code id="smoothcontour_+3A_smoothing">smoothing</code></td>
<td>
<p>value between 0 and 1 specifying the degree of smoothing.</p>
</td></tr>
<tr><td><code id="smoothcontour_+3A_min.radius">min.radius</code></td>
<td>
<p>numerical value. If larger than 0, all contours with a mean radius (in pixels) below <code>min.radius</code> are removed.</p>
</td></tr>
<tr><td><code id="smoothcontour_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="smoothcontour_+3A_lty">lty</code></td>
<td>
<p>vector of line types (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="smoothcontour_+3A_col">col</code></td>
<td>
<p>vector of colors (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="smoothcontour_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to the function <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+contourLines">contourLines</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
f = function(x) cos(2*x[1]-x[2]-1)^2*exp(-x[1]^2-x[2]^2-x[1]*x[2])
x = seq(-3,3,length=100)
m = pracma::meshgrid(x)
z = array(Vectorize(function(x,y) f(c(x,y)))(m$Y,m$X)+rnorm(4e4,sd=0.1),dim(m$X))
image(x,x,z,col=terrain.colors(100))
contour(x,x,z,levels=c(0.2,0.5),add=TRUE)
smoothcontour(x,x,z,levels=c(0.2,0.5),lwd=3,smoothing=0.8,min.radius=2)

</code></pre>

<hr>
<h2 id='smoothfun'>Smoothed Function</h2><span id='topic+smoothfun'></span>

<h3>Description</h3>

<p>Generates a cubic smoothed spline function y=f(x) approximating supplied (x,y)-data with a custom number of degrees of freedom. The routines builds on <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, but directly returns the smoothed function rather than the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothfun(x, y = NULL, w = NULL, df = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoothfun_+3A_x">x</code></td>
<td>
<p>a vector giving the values of the predictor variable, or a list or a two-column matrix specifying x and y.</p>
</td></tr>
<tr><td><code id="smoothfun_+3A_y">y</code></td>
<td>
<p>responses. If y is missing or NULL, the responses are assumed to be specified by x, with x the index vector.</p>
</td></tr>
<tr><td><code id="smoothfun_+3A_w">w</code></td>
<td>
<p>optional vector of weights of the same length as x; defaults to all 1.</p>
</td></tr>
<tr><td><code id="smoothfun_+3A_df">df</code></td>
<td>
<p>the desired equivalent number of degrees of freedom. Must be in [2,nx], where nx is the number of unique x values. If not given, nx is set to the square root of the number of unique x-values.</p>
</td></tr>
<tr><td><code id="smoothfun_+3A_...">...</code></td>
<td>
<p>additional optional arguments used by <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a fast and vectorized smoothed function f(x).
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make random data set
set.seed(1)
x = runif(100)
y = sin(2*pi*x)+rnorm(100, sd=0.5)
plot(x,y,pch=16)

# smoothed spline
f = smoothfun(x, y)
curve(f, add=TRUE, col='red')

# smoothed spline with custom degree of freedom
g = smoothfun(x, y, df=5)
curve(g, add=TRUE, col='blue')

</code></pre>

<hr>
<h2 id='spectrumcolors'>Spectrum colour palette</h2><span id='topic+spectrumcolors'></span>

<h3>Description</h3>

<p>Generates smooth rainbow color scale from red to purple, similar to <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, but with improved smoothness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrumcolors(n, alpha = 1, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectrumcolors_+3A_n">n</code></td>
<td>
<p>integer number of colors in the scale</p>
</td></tr>
<tr><td><code id="spectrumcolors_+3A_alpha">alpha</code></td>
<td>
<p>alpha transparency value (0=fully transparent, 1=fully opaque)</p>
</td></tr>
<tr><td><code id="spectrumcolors_+3A_rev">rev</code></td>
<td>
<p>logical flag indicating whether the ordering of the colors should be reversed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n-vector of RGB colour strings.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>
<p>#' @examples
nplot()
rasterImage(rbind(spectrumcolors(1e3)),0,0,1,0.5)
rasterImage(rbind(rainbow(1e3,end=5/6)),0,0.5,1,1)
text(0.5,0.25,'spectrum')
text(0.5,0.75,'rainbow')
abline(h=0.5)
</p>

<hr>
<h2 id='sph2car'>Spherical to Cartesian coordinate conversion</h2><span id='topic+sph2car'></span>

<h3>Description</h3>

<p>Convert 3D spherical to Cartesian coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph2car(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sph2car_+3A_x">x</code></td>
<td>
<p>3-element or n-by-3 matrix representing the spherical components (r,theta,phi) of n three-dimensional vectors. Here, theta=0...pi is the polar angle measured from the north pole and phi=0...2*pi is the azimuth measured positively from the x-axis (ISO 80000-2:2019 physics convention).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-element vector or a n-by-3 element matrix representing the Cartesian coordinates (x,y,z)
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+car2sph">car2sph</a></code>
</p>

<hr>
<h2 id='sphereplot'>Plot a spherical function or point set</h2><span id='topic+sphereplot'></span>

<h3>Description</h3>

<p>Plots a spherical function or a point set in a 2D projection using only standard R graphics. This avoids compatibility issues of rgl, e.g. knitting markdown documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphereplot(
  f,
  n = 100,
  theta0 = pi/2,
  phi0 = 0,
  angle = 0,
  projection = "globe",
  col = gray.colors(256, 0, 1),
  clim = NULL,
  add = FALSE,
  center = c(0, 0),
  radius = 1,
  nv = 500,
  show.border = TRUE,
  show.grid = TRUE,
  grid.phi = seq(0, 330, 30)/180 * pi,
  grid.theta = seq(30, 150, 30)/180 * pi,
  pch = 16,
  pt.col = "black",
  pt.cex = 0.5,
  lwd = 0.5,
  lty = 1,
  line.col = "black",
  background = "white",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphereplot_+3A_f">f</code></td>
<td>
<p>must be either of:
</p>
<p>(1) NULL to plot just grid without spherical function
</p>
<p>(2) a vectorized real function f(theta,phi) of the polar angle theta [0,pi] and azimuth angle [0,2pi]
</p>
<p>(3) an n-by-2 array of values theta and phi</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_n">n</code></td>
<td>
<p>number of grid cells in each dimension used in the plot</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_theta0">theta0</code></td>
<td>
<p>polar angle in radians at the center of the projection</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_phi0">phi0</code></td>
<td>
<p>azimuth angle in radians at the center of the projection</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_angle">angle</code></td>
<td>
<p>angle in radians between vertical axis and central longitudinal great circle</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_projection">projection</code></td>
<td>
<p>type of projection: &quot;globe&quot; (default), &quot;cylindrical&quot;, &quot;mollweide&quot;</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_col">col</code></td>
<td>
<p>color map</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_clim">clim</code></td>
<td>
<p>2-element vector specifying the values of f corresponding to the first and last color in col</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_add">add</code></td>
<td>
<p>logical flag specifying whether the sphere is to be added to an existing plot</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_center">center</code></td>
<td>
<p>center of the sphere on the plot</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_radius">radius</code></td>
<td>
<p>radius of the sphere on the plot</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_nv">nv</code></td>
<td>
<p>number or vertices used for grid lines and border</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_show.border">show.border</code></td>
<td>
<p>logical flag specifying whether to show a circular border around the sphere</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_show.grid">show.grid</code></td>
<td>
<p>logical flag specifying whether to show grid lines</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_grid.phi">grid.phi</code></td>
<td>
<p>vector of phi-values of the longitudinal grid lines</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_grid.theta">grid.theta</code></td>
<td>
<p>vector of theta-values of the latitudinal grid lines</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_pch">pch</code></td>
<td>
<p>point type</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_pt.col">pt.col</code></td>
<td>
<p>point color</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_pt.cex">pt.cex</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_lwd">lwd</code></td>
<td>
<p>line width of grid lines and border</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_lty">lty</code></td>
<td>
<p>line type of grid lines and border</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_line.col">line.col</code></td>
<td>
<p>color of grid lines and border</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_background">background</code></td>
<td>
<p>background color</p>
</td></tr>
<tr><td><code id="sphereplot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function f</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the vector <code>col</code> of colors and 2-vector <code>clim</code> of values corresponding to the first and last color.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plot random points on the unit sphere in Mollweide projection
set.seed(1)
f = cbind(acos(runif(5000,-1,1)),runif(5000,0,2*pi))
sphereplot(f,theta0=pi/3,projection='mollweide',pt.col='red')

## Plot real spherical harmonics up to third degree
oldpar = par(mar=c(0,0,0,0))
nplot(xlim=c(-4,3.5),ylim=c(0,4),asp=1)
for (l in seq(0,3)) { # degree of spherical harmonic
  for (m in seq(-l,l)) { # order of spherical harmonic

    # make spherical harmonic function in real-valued convention
    f = function(theta,phi) sphericalharmonics(l,m,cbind(theta,phi))

    # plot spherical harmonic
    sphereplot(f, 50, col=planckcolors(100), phi0=0.1, theta0=pi/3, add=TRUE, clim=c(-0.7,0.7),
               center=c(m,3.5-l), radius=0.47)

    if (l==3) text(m,-0.15,sprintf('m=%+d',m))
  }
  text(-l-0.55,3.5-l,sprintf('l=%d',l),pos=2)
}
par(oldpar)

</code></pre>

<hr>
<h2 id='sphericalharmonics'>Spherical Harmonics</h2><span id='topic+sphericalharmonics'></span>

<h3>Description</h3>

<p>Evaluates spherical harmonics Y, either in the real-valued or complex-valued basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphericalharmonics(l, m, x, basis = "real")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sphericalharmonics_+3A_l">l</code></td>
<td>
<p>degree of the spherical harmonic, accurate to about l=500; (0=monopole, 1=dipole, 2=quadrupole, 3=octupole, 4=hexadecapole,...)</p>
</td></tr>
<tr><td><code id="sphericalharmonics_+3A_m">m</code></td>
<td>
<p>order of the spherical harmonic (-l,-l+1,...,+l)</p>
</td></tr>
<tr><td><code id="sphericalharmonics_+3A_x">x</code></td>
<td>
<p>either an n-by-2 matrix specifying the polar angle <code>theta</code> (0...pi) and azimuthal angle <code>phi</code> (0...2*pi); or an n-by-3 matrix specifying the 3D coordinates of n vectors (whose normalization is irrelevant).</p>
</td></tr>
<tr><td><code id="sphericalharmonics_+3A_basis">basis</code></td>
<td>
<p>a string specifying the type of spherical harmonics; this has to be either &quot;complex&quot; for the standard complex-valued harmonics with Condon-Shortley phase convention, or &quot;real&quot; (default) for the standard real-valued harmonics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n-vector of the spherical harmonics; for points x=c(0,0,0), a value of 0 is returned
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Check orthonormalization of all spherical harmonics up to 3rd degree

# make indices l and m up to 3rd degree
l = c(0,rep(1,3),rep(2,5),rep(3,7))
m = c(0,seq(-1,1),seq(-2,2),seq(-3,3))

# check orthonormalization for all pairs
for (i in seq(16)) {
  for (j in seq(16)) {

    # compute scalar product
    f = function(theta,phi) {
      Yi = sphericalharmonics(l[i],m[i],cbind(theta,phi))
      Yj = sphericalharmonics(l[j],m[j],cbind(theta,phi))
      return(Re(Yi*Conj(Yj))*sin(theta))
    }
    g = Vectorize(function(phi) integrate(f,0,pi,phi)$value)
    scalar.product = integrate(g,0,2*pi)$value

    # compare scalar product to expected value
    ok = abs(scalar.product-(i==j))&lt;1e-6
    cat(sprintf('(l=%1d,m=%+1d|l=%1d,m=%+1d)=%5.3f  %s\n',l[i],m[i],l[j],m[j],
                scalar.product+1e-10,ifelse(ok,'ok','wrong')))
  }
}

</code></pre>

<hr>
<h2 id='stretch'>Stretch values to a custom range</h2><span id='topic+stretch'></span>

<h3>Description</h3>

<p>Shifts and stretches the values of a vector or array to a desired interval, while maintaining the shape of the input argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stretch(x, min = 0, max = 1, invert = FALSE, gamma = NULL, na = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stretch_+3A_x">x</code></td>
<td>
<p>vector or array</p>
</td></tr>
<tr><td><code id="stretch_+3A_min">min</code></td>
<td>
<p>minimum value</p>
</td></tr>
<tr><td><code id="stretch_+3A_max">max</code></td>
<td>
<p>maximum value</p>
</td></tr>
<tr><td><code id="stretch_+3A_invert">invert</code></td>
<td>
<p>logical flag specifying whether the data should be inverted, such that the smallest input value maps to max and the largest input value maps to min.</p>
</td></tr>
<tr><td><code id="stretch_+3A_gamma">gamma</code></td>
<td>
<p>optional argument specifying a non-linear transformation x-&gt;x^gamma, if gamma&gt;0, or x-&gt;1-(1-x)^(-gamma), if gamma&lt;0.</p>
</td></tr>
<tr><td><code id="stretch_+3A_na">na</code></td>
<td>
<p>optional value specifying the value assigned to non-numbers (NA and NaN)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector/array of the same shape as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code>lim</code>
</p>

<hr>
<h2 id='subplot'>Insert a sub-panel into plot</h2><span id='topic+subplot'></span>

<h3>Description</h3>

<p>Insert a sub-panel into an existing plotting area. To open a subplot, call <code>par(subplot(...))</code>, to close it, you must call <code>par(subplot('off'))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subplot(xleft = NA, ybottom, xright, ytop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subplot_+3A_xleft">xleft</code></td>
<td>
<p>lower x-coordinate of the sub-panel relative to the current plot.</p>
</td></tr>
<tr><td><code id="subplot_+3A_ybottom">ybottom</code></td>
<td>
<p>lower y-coordinate of the sub-panel relative to the current plot.</p>
</td></tr>
<tr><td><code id="subplot_+3A_xright">xright</code></td>
<td>
<p>upper x-coordinate of the sub-panel relative to the current plot.</p>
</td></tr>
<tr><td><code id="subplot_+3A_ytop">ytop</code></td>
<td>
<p>upper y-coordinate of the sub-panel relative to the current plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical parameters to user with <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'># main plot
f = function(x) x*sin(1/(x+.Machine$double.eps))
curve(f,0,1,n=1000,ylim=c(-1,1),xlab='',ylab='',xaxs='i',yaxs='i')
rect(0.02,-0.1,0.1,0.1,border='blue',col=transparent('blue',0.2))

# subplot
par(subplot(0.55,-0.8,0.93,0))
curve(f,0.02,0.1,n=500,ylim=c(-0.1,0.1),xlab='',ylab='',xaxs='i',yaxs='i')
rect(0.02,-0.1,0.1,0.1,border=NA,col= transparent('blue',0.2))
par(subplot('off'))

</code></pre>

<hr>
<h2 id='tick'>Start timer</h2><span id='topic+tick'></span>

<h3>Description</h3>

<p>Start timer and write a custom text into the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tick(txt = "Start")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tick_+3A_txt">txt</code></td>
<td>
<p>custom text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tock">tock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tick('Sum 10 million random numbers')
x = sum(runif(1e7))
tock()

</code></pre>

<hr>
<h2 id='tock'>Stop timer</h2><span id='topic+tock'></span>

<h3>Description</h3>

<p>Stop timer and write the computation in seconds since the last call of tick().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tock(txt = "", fmt = " (%.2fs). %s\n")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tock_+3A_txt">txt</code></td>
<td>
<p>custom text to be displayed</p>
</td></tr>
<tr><td><code id="tock_+3A_fmt">fmt</code></td>
<td>
<p>character vector of format strings. It must contain exactly one %s as placeholder for <code>txt</code> and one numerical format, such as %f or %e, as placeholder for the time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the elapsed time in seconds since calling tick().
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tick">tick</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tick('Sum 10 million random numbers')
x = sum(runif(1e7))
tock()

</code></pre>

<hr>
<h2 id='transparent'>Add transparency to a color</h2><span id='topic+transparent'></span>

<h3>Description</h3>

<p>Add transparency to a color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transparent(col, alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transparent_+3A_col">col</code></td>
<td>
<p>is a color or vector/array of colors, specified as text (e.g. 'purple') or 7/9-character (e.g. '#A020F0')</p>
</td></tr>
<tr><td><code id="transparent_+3A_alpha">alpha</code></td>
<td>
<p>transparency value between 0 and 1 or a vector/array thereof</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 9-character color or vector/array of 9-character colors.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lightness">lightness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Add different transparencies of the same color
plot(runif(50),runif(50),pch=20,cex=10,col=transparent('purple',runif(50)))

# Add the same transparency to different colors
plot(runif(50),runif(50),pch=20,cex=10,col=transparent(rainbow(50)))

</code></pre>

<hr>
<h2 id='transzoom'>Zoom, translate and rotate array image</h2><span id='topic+transzoom'></span>

<h3>Description</h3>

<p>Zoom/rotate/translate an image relative to its center for images represented as simple arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transzoom(
  img = NULL,
  zoom = 1,
  shift = c(0, 0),
  angle = 0,
  size = NULL,
  col = "black",
  filter = "bilinear",
  file.in = "",
  file.out = "",
  format = "png",
  show.image = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transzoom_+3A_img">img</code></td>
<td>
<p>n-by-m-by-3 array or n-by-m-by-4 array representing an rgb(+alpha) image.</p>
</td></tr>
<tr><td><code id="transzoom_+3A_zoom">zoom</code></td>
<td>
<p>zoom factor (&gt;0).</p>
</td></tr>
<tr><td><code id="transzoom_+3A_shift">shift</code></td>
<td>
<p>2-vector specifying the vertical+horizontal translation in units of output pixels (i.e. after zooming).</p>
</td></tr>
<tr><td><code id="transzoom_+3A_angle">angle</code></td>
<td>
<p>rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="transzoom_+3A_size">size</code></td>
<td>
<p>2-vector specifying the vertical+horizontal dimensions of the output image. If not given, this is taken to be identical to the input image.</p>
</td></tr>
<tr><td><code id="transzoom_+3A_col">col</code></td>
<td>
<p>background color</p>
</td></tr>
<tr><td><code id="transzoom_+3A_filter">filter</code></td>
<td>
<p>affine transformation filter; either 'none' or 'bilinear'</p>
</td></tr>
<tr><td><code id="transzoom_+3A_file.in">file.in</code></td>
<td>
<p>optional input filename, which can be used to load an image instead of providing it via <code>img</code>. This filename is ignored if <code>img</code> is specified.</p>
</td></tr>
<tr><td><code id="transzoom_+3A_file.out">file.out</code></td>
<td>
<p>optional output filename.</p>
</td></tr>
<tr><td><code id="transzoom_+3A_format">format</code></td>
<td>
<p>one of &quot;png&quot; or &quot;jpg&quot; specifying the file format of the input and output image.</p>
</td></tr>
<tr><td><code id="transzoom_+3A_show.image">show.image</code></td>
<td>
<p>logical flag specifying whether the image is displayed in the R console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an n-by-m-by-3 array or n-by-m-by-4 array of the processed image.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img = yinyangyong # this is an example image included in the package
transzoom(img, zoom=2) # zoom by a factor 2

</code></pre>

<hr>
<h2 id='uniquedouble'>Turn a 64-bit integer into a unique double value</h2><span id='topic+uniquedouble'></span>

<h3>Description</h3>

<p>Turns 64-bit integers into unique doubles for faster comparison. The output double values are completely different from the input values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniquedouble(int64)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniquedouble_+3A_int64">int64</code></td>
<td>
<p>integer or vector of integers; normally used with 64-bit integers, but also works with other types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a double floating point value.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The comparison of in-built types is very fast:
int32 = as.integer(0) # (same as int32 = 0)
system.time(for(i in seq(1e4)) comparison=int32==int32)

# The comparison of 64-bit integers is very slow:
int64 = bit64::as.integer64(0)
system.time(for(i in seq(1e4)) comparison=int64==int64)

# The comparison of converted 64-bit integers is again fast:
int64d = uniquedouble(int64)
system.time(for(i in seq(1e4)) comparison=int64d==int64d)

</code></pre>

<hr>
<h2 id='unitvector'>Normalize vectors to unit length</h2><span id='topic+unitvector'></span>

<h3>Description</h3>

<p>Compute the unit vectors for for a matrix of non-normalised vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitvector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unitvector_+3A_x">x</code></td>
<td>
<p>m-element vector or n-by-m matrix <code>x[1:n,1:m]</code> representing n m-element vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data type identical to <code>x</code>, but with normalised vectors. Zero-vectors are returned for vectors of length zero.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vectornorm">vectornorm</a></code>
</p>

<hr>
<h2 id='vectornorm'>Vector norm</h2><span id='topic+vectornorm'></span>

<h3>Description</h3>

<p>Compute the norm of a vector or a matrix of vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectornorm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vectornorm_+3A_x">x</code></td>
<td>
<p>m-element vector or n-by-m matrix (x[1:n,1:m]) representing n m-element vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a scalar or an n-element vector with the vector norms
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vectornorm">vectornorm</a></code>
</p>

<hr>
<h2 id='vectorproduct'>Vector product</h2><span id='topic+vectorproduct'></span>

<h3>Description</h3>

<p>Compute cross product of two 3-element vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorproduct(x, y, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vectorproduct_+3A_x">x</code>, <code id="vectorproduct_+3A_y">y</code></td>
<td>
<p>3-element vectors or n-by-3 matrices representing n 3-element vectors</p>
</td></tr>
<tr><td><code id="vectorproduct_+3A_normalize">normalize</code></td>
<td>
<p>logical flag; if set to TRUE the cross-product(s) is/are automatically normalized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 3-element vector or a n-by-3 element matrix with the cross products
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scalarproduct">scalarproduct</a></code>, <code><a href="#topic+vectornorm">vectornorm</a></code> and <code><a href="#topic+unitvector">unitvector</a></code>
</p>

<hr>
<h2 id='wavelength2col'>Convert wavelength to RGB</h2><span id='topic+wavelength2col'></span>

<h3>Description</h3>

<p>Converts a given wavelength of light to an approximate RGB color value, using black in the invisible range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavelength2col(wavelength)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wavelength2col_+3A_wavelength">wavelength</code></td>
<td>
<p>wavelength value (or vector), in nanometers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a color string or vector of color strings with the same number of elements as <code>wavelength</code>.
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Source</h3>

<p>Smoothed implementation of the original Fortran version by Dan Bruton (http://www.physics.sfasu.edu/astro/color/spectra.html) and the R-function by Michael Friendly (https://gist.github.com/friendly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda = seq(300,800)
col = matrix(wavelength2col(lambda),nrow=1)
plot(NA,xlim=range(lambda),ylim=c(0,1),xaxs='i',xlab='wavelength [nm]',yaxs='i',yaxt='n',ylab='')
rasterImage(col,min(lambda),0,max(lambda),1)

</code></pre>

<hr>
<h2 id='yinyangyong'>Yin-Yang-Yong image</h2><span id='topic+yinyangyong'></span>

<h3>Description</h3>

<p>A data set containing a 500-by-500-by-4 array, representing an image of a Yin-Yang-Yong symbol with transparency. This symbol was 'reinvented' many times. The particular version in this package is the one drawn by the package author Danail Obreschkow in 1999.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yinyangyong
</code></pre>


<h3>Format</h3>

<p>An object of class <code>array</code> of dimension 500 x 500 x 4.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Danail Obreschkow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nplot(asp=1)
rasterImage(yinyangyong,0,0,1,1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
