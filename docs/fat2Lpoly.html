<!DOCTYPE html><html><head><title>Help for package fat2Lpoly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fat2Lpoly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#design.1locus'>
<p>Setting-up design matrices for a polytomous model with a single biallelic marker.</p></a></li>
<li><a href='#design.dichotomous'>
<p>Setting-up the design matrix for a logistic model with two biallelic markers.</p></a></li>
<li><a href='#design.endo2disease'>
<p>Setting-up design matrices for the endophenotype-to-disease model.</p></a></li>
<li><a href='#design.full'>
<p>Setting-up design matrices for a full polytomous model with two biallelic markers.</p></a></li>
<li><a href='#fat2Lpoly'>
<p>Two-locus Family-based Association Test with Polytomous Outcome</p></a></li>
<li><a href='#fat2Lpoly-internal'><p>Internal fat2Lpoly Functions</p></a></li>
<li><a href='#fat2Lpoly.allSNPs'>
<p>Example results output by the function <code>fat2Lpoly.withinR</code></p></a></li>
<li><a href='#fat2Lpoly.withinR'>
<p>Two-locus Family-based Association Test with Polytomous Outcome (all arguments within R)</p></a></li>
<li><a href='#get.scores.pvalues'>
<p>function to compute scores and p-values</p></a></li>
<li><a href='#ped.x.all'>
<p>Example dataset returned by the function <code>read.merlin.files</code></p></a></li>
<li><a href='#read.merlin.files'>
<p>function to read input files in Merlin format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Two-Locus Family-Based Association Test with Polytomous Outcome</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandre BUREAU &lt;alexandre.bureau@msp.ulaval.ca&gt; and Jordie Croteau
        &lt;jorcroteau@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandre BUREAU &lt;alexandre.bureau@msp.ulaval.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>kinship2, multgee</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs family-based association tests with a polytomous outcome under 2-locus and 1-locus models
             defined by some design matrix.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.cervo.ulaval.ca/pages_perso_chercheurs/bureau_a/">https://www.cervo.ulaval.ca/pages_perso_chercheurs/bureau_a/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-23 13:26:15 UTC; alexandrebureau</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-04 14:20:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='design.1locus'>
Setting-up design matrices for a polytomous model with a single biallelic marker.
</h2><span id='topic+design.1locus'></span>

<h3>Description</h3>

<p>This function sets up two identical lists of three design matrices, one for each linear predictor of the logit of the three outcome levels defined by the combination of two dichotomous traits against the reference level (0,0) under a model with the main effect of a single biallelic marker. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design.1locus(x, par.constrained, constraints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design.1locus_+3A_x">x</code></td>
<td>

<p>A numeric vector of values representing genotypes of a biallelic marker. The two homozygous genotypes must 
be coded 0 and 1, and the heterozygous genotype value depends on the genetic model: 0 (recessive), 1/2 (allelic) or 1 (dominant).
</p>
</td></tr>
<tr><td><code id="design.1locus_+3A_par.constrained">par.constrained</code></td>
<td>

<p>Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the parameter (1, 2 or 3) in the linear predictor for each level involved in the nc constraints BETWEEN the logistic models for different levels of the response variable, one constraint per column. 
This functionality is not yet implemented.</p>
</td></tr>
<tr><td><code id="design.1locus_+3A_constraints">constraints</code></td>
<td>

<p>Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the nc linear constraints BETWEEN the logistic models for different levels of the response variable, involving the parameters specified in <code>par.constrained</code>, one constraint per column.  A 0 means that the corresponding parameter is not involved in the constraint.
This functionality is not yet implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Y_{1}</code> and <code class="reqn">Y_{2}</code> be binary variables coding the presence (1) or absence (0) of the two traits (e.g. and endophenotype and a disease trait, respectively).
The linear predictors (without intercept) of the logistic functions between outcome levels and the reference level <code class="reqn">Y_{1} = 0</code> and <code class="reqn">Y_{2} = 0</code> are as follows:
</p>
<p><code class="reqn">Y_{1} = 1 , Y_{2} = 0 : \beta_{11} X</code>
</p>
<p><code class="reqn">Y_{1} = 0 , Y_{2} = 1 : \beta_{21} X</code>
</p>
<p><code class="reqn">Y_{1} = 1 , Y_{2} = 1 : \beta_{31} X</code>
</p>
<p>The vector <code class="reqn">X</code> constitute the design matrix for each linear predictor of the above model.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x.e</code></td>
<td>
<p>List of 3 design matrices containing the vector <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>x.loc.e</code></td>
<td>
<p>list of character strings containing the indices of the variables in <code>x</code> involved in each term of the model, i.e. &quot;1&quot;</p>
</td></tr>
<tr><td><code>x.l</code></td>
<td>
<p>identical to <code>x.e</code></p>
</td></tr>
<tr><td><code>x.loc.l</code></td>
<td>
<p>identical to <code>x.l</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexandre Bureau &lt;alexandre.bureau@msp.ulaval.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fat2Lpoly">fat2Lpoly</a>, <a href="#topic+design.full">design.full</a>, <a href="#topic+design.endo2disease">design.endo2disease</a></code>
</p>

<hr>
<h2 id='design.dichotomous'>
Setting-up the design matrix for a logistic model with two biallelic markers.
</h2><span id='topic+design.dichotomous'></span>

<h3>Description</h3>

<p>This function sets up two identical lists, each containing a design matrix for the linear predictor of the logit of a dichotomous outcome under a full logistic model with main effects and product terms for two biallelic markers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design.dichotomous(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design.dichotomous_+3A_x">x</code></td>
<td>
<p> A 2-column matrix of numeric values representing genotypes of biallelic markers, with one column per marker and one row per subject. The two homozygous genotypes must 
be coded 0 and 1, and the heterozygous genotype value depends on the genetic model: 0 (recessive), 1/2 (allelic) or 1 (dominant).
</p>
</td></tr>
<tr><td><code id="design.dichotomous_+3A_...">...</code></td>
<td>
<p> Additional arguments will be ignored, but must be allowed for compatibility with other design functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear predictors (without intercept) of the logistic function for <code class="reqn">Y = 1</code>  against the reference level <code class="reqn">Y = 0</code> has the form:
</p>
<p><code class="reqn">\eta_{11} X_{1} + \eta_{12} X_{2} + \eta_{13} X_{1} X_{2}</code>
</p>
<p>The design matrix for the above model is constructed by this function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x.e</code></td>
<td>
<p>List containing the single design matrix with all terms forming the full 2-locus logistic model</p>
</td></tr>
<tr><td><code>x.loc.e</code></td>
<td>
<p>list of character strings containing the indices of the variables in <code>x</code> involved in each term of the logistic model</p>
</td></tr>
<tr><td><code>x.l</code></td>
<td>
<p>identical to <code>x.e</code></p>
</td></tr>
<tr><td><code>x.loc.l</code></td>
<td>
<p>identical to <code>x.l</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexandre Bureau &lt;alexandre.bureau@msp.ulaval.ca&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fat2Lpoly">fat2Lpoly</a>, <a href="#topic+design.full">design.full</a></code>
</p>

<hr>
<h2 id='design.endo2disease'>
Setting-up design matrices for the endophenotype-to-disease model.
</h2><span id='topic+design.endo2disease'></span>

<h3>Description</h3>

<p>This function sets up two lists of three design matrices, one for each linear predictor of the logit of the three outcome levels defined by the combination of two dichotomous traits against the reference level (0,0) under the endophenotype-to-disease model of Bureau et al (2014). The design matrices in the first list contain all terms forming the model, and those in the second list contain all main effect and product terms appearing in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design.endo2disease(x, par.constrained, constraints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design.endo2disease_+3A_x">x</code></td>
<td>
<p> A matrix of dimensions 2 x n of numeric values representing genotypes of biallelic markers, with one column per marker and one row per subject. The two homozygous genotypes must 
be coded 0 and 1, and the heterozygous genotype value depends on the genetic model: 0 (recessive), 1/2 (allelic) or 1 (dominant).
</p>
</td></tr>
<tr><td><code id="design.endo2disease_+3A_par.constrained">par.constrained</code></td>
<td>
<p> Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the parameter (1 or 2) in the linear predictor for each level involved in the nc constraints BETWEEN the logistic models for different levels of the response variable, one constraint per column. 
This functionality is not yet implemented.
</p>
</td></tr>
<tr><td><code id="design.endo2disease_+3A_constraints">constraints</code></td>
<td>

<p>Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the nc linear constraints BETWEEN the logistic models for different levels of the response variable, involving the parameters specified in <code>par.constrained</code>, one constraint per column.  A 0 means that the corresponding parameter is not involved in the constraint.
This functionality is not yet implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Y_{1}</code> and <code class="reqn">Y_{2}</code> be binary variables coding the presence (1) or absence (0) of the endophenotype and the disease trait, respectively.
The linear predictors (without intercept) of the logistic functions between outcome levels and the reference level <code class="reqn">Y_{1} = 0</code> and <code class="reqn">Y_{2} = 0</code> specified by the endophenotype-to-disease model are as follows:
</p>
<p><code class="reqn">Y_{1} = 1 , Y_{2} = 0 : \beta_{11} X_{1} + \beta_{e} X_{1} (1 - X_{2})</code>
</p>
<p><code class="reqn">Y_{1} = 0 , Y_{2} = 1 : \beta_{21} X_{1}</code>
</p>
<p><code class="reqn">Y_{1} = 1 , Y_{2} = 1 : \beta_{31} X_{1} + \beta_{33} X_{1} X_{2}</code>
</p>
<p>The design matrices for the above model are constructed by this function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x.e</code></td>
<td>
<p>List of 3 design matrices containing all terms forming the endophenotype-to-disease model</p>
</td></tr>
<tr><td><code>x.loc.e</code></td>
<td>
<p>list of character strings containing the indices of the variables in <code>x</code> involved in each term of the endophenotype-to-disease model</p>
</td></tr>
<tr><td><code>x.l</code></td>
<td>
<p>List of 3 design matrices containing the terms <code class="reqn">X_{1}</code>, <code class="reqn">X_{2}</code> and <code class="reqn">X_{1} X_{2}</code> appearing in the endophenotype-to-disease model.</p>
</td></tr>
<tr><td><code>x.loc.l</code></td>
<td>
<p>list of character strings containing the indices of the variables in <code>x</code> involved in each term in the list <code>x.l</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexandre Bureau &lt;alexandre.bureau@msp.ulaval.ca&gt;
</p>


<h3>References</h3>

<p>Bureau A., Croteau J., Chagnon, Y.C., Roy, M.-A. and Maziade, M. Extension of the Generalized Disequilibrium Test to polytomous phenotypes and two locus models. Frontiers in Genetics, 5: Article 258. </p>


<h3>See Also</h3>

<p><code><a href="#topic+fat2Lpoly">fat2Lpoly</a>, <a href="#topic+design.full">design.full</a></code>
</p>

<hr>
<h2 id='design.full'>
Setting-up design matrices for a full polytomous model with two biallelic markers.
</h2><span id='topic+design.full'></span>

<h3>Description</h3>

<p>This function sets up two identical lists of three design matrices, one for each linear predictor of the logit of the three outcome levels defined by the combination of two dichotomous traits against the reference level (0,0) under a full model with main effects and product terms for two biallelic markers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design.full(x, par.constrained, constraints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design.full_+3A_x">x</code></td>
<td>
<p> A 2-column matrix of numeric values representing genotypes of biallelic markers, with one column per marker and one row per subject. The two homozygous genotypes must 
be coded 0 and 1, and the heterozygous genotype value depends on the genetic model: 0 (recessive), 1/2 (allelic) or 1 (dominant).
</p>
</td></tr>
<tr><td><code id="design.full_+3A_par.constrained">par.constrained</code></td>
<td>
<p> Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the parameter (1, 2 or 3) in the linear predictor for each level involved in the nc constraints BETWEEN the logistic models for different levels of the response variable, one constraint per column. 
This functionality is not yet implemented.
</p>
</td></tr>
<tr><td><code id="design.full_+3A_constraints">constraints</code></td>
<td>

<p>Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the nc linear constraints BETWEEN the logistic models for different levels of the response variable, involving the parameters specified in <code>par.constrained</code>, one constraint per column.  A 0 means that the corresponding parameter is not involved in the constraint.
This functionality is not yet implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Y_{1}</code> and <code class="reqn">Y_{2}</code> be binary variables coding the presence (1) or absence (0) of the two traits (e.g. and endophenotype and a disease trait, respectively).
The linear predictors (without intercept) of the logistic functions between outcome levels and the reference level <code class="reqn">Y_{1} = 0</code> and <code class="reqn">Y_{2} = 0</code> for the full model are as follows:
</p>
<p><code class="reqn">Y_{1} = 1 , Y_{2} = 0 : \beta_{11} X_{1} + \beta_{12} X_{2} + \beta_{13} X_{1} X_{2}</code>
</p>
<p><code class="reqn">Y_{1} = 0 , Y_{2} = 1 : \beta_{21} X_{1} + \beta_{22} X_{2} + \beta_{23} X_{1} X_{2}</code>
</p>
<p><code class="reqn">Y_{1} = 1 , Y_{2} = 1 : \beta_{31} X_{1} + \beta_{32} X_{2} + \beta_{33} X_{1} X_{2}</code>
</p>
<p>The design matrices for the above model are constructed by this function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x.e</code></td>
<td>
<p>List of 3 design matrices containing all terms forming the full model</p>
</td></tr>
<tr><td><code>x.loc.e</code></td>
<td>
<p>list of character strings containing the indices of the variables in <code>x</code> involved in each term of the full model</p>
</td></tr>
<tr><td><code>x.l</code></td>
<td>
<p>identical to <code>x.e</code></p>
</td></tr>
<tr><td><code>x.loc.l</code></td>
<td>
<p>identical to <code>x.l</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexandre Bureau &lt;alexandre.bureau@msp.ulaval.ca&gt;
</p>


<h3>References</h3>

<p>Bureau A., Croteau J., Chagnon, Y.C., Roy, M.-A. and Maziade, M. Extension of the Generalized Disequilibrium Test to polytomous phenotypes and two locus models. Frontiers in Genetics, 5: Article 258. </p>


<h3>See Also</h3>

<p><code><a href="#topic+fat2Lpoly">fat2Lpoly</a>, <a href="#topic+design.endo2disease">design.endo2disease</a></code>
</p>

<hr>
<h2 id='fat2Lpoly'>
Two-locus Family-based Association Test with Polytomous Outcome
</h2><span id='topic+fat2Lpoly'></span>

<h3>Description</h3>

<p>Performs family-based association tests with a polytomous outcome under 2-locus and 1-locus models as described in reference [1]. Various functions <code>design.constraint</code> to create design matrices are provided in this package. When SNP pairs are specified, the tested SNP is the second one of each pair, while the first one is considered the conditioning SNP. The function may also perform one-locus tests if individual SNPs are specified instead of SNP pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fat2Lpoly(pedfilenames, datfilenames, freq.data, ibdfilenames = NULL, 
          snp.names.mat, ibd.loci = NULL, joint.tests = NULL, 
		  contingency.file = FALSE, design.constraint,
		  par.constrained, constraints, pairweights=calcule.poids.alphafixe,
		  lc = NULL, alpha = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fat2Lpoly_+3A_pedfilenames">pedfilenames</code></td>
<td>

<p>vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the pedigree files in Merlin format (see Merlin website [2]). Put the full path of the files if they are not in the current working directory. If the phenotype is polytomous with 4 levels created by all combinations of two dichotomous phenotypic variables <code class="reqn">Y_{1}</code> and <code class="reqn">Y_{2}</code>, then the sixth and seventh columns of each file are respectively for <code class="reqn">Y_{1}</code> (e.g. the endophenotype) and <code class="reqn">Y_{2}</code> (e.g. the disease phenotype).
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_datfilenames">datfilenames</code></td>
<td>

<p>vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the Merlin format data files corresponding to the pedigree files.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_freq.data">freq.data</code></td>
<td>

<p>Either 
(1) a vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the allele frequency files corresponding to the pedigree files. These files must be in Merlin Classic format.
or
(2) a list of length 1 or 2 (the number of loci involved in the <code>design</code> function), each element of which is a numeric vector of length 'number of SNPs in <code>datfilenames</code>' and specifies each SNP's minor allele.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_ibdfilenames">ibdfilenames</code></td>
<td>

<p>vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the Merlin format ibd files corresponding to the pedigree files. If NULL (the default), then we use the kinship coefficients multiplied by two, instead of the expectation of the IBD probabilities, in the computation of the score statistics. The kinship coefficients are obtained using the function <code>kinship</code> from the package <code>kinship2</code>.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_snp.names.mat">snp.names.mat</code></td>
<td>

<p>matrix of one or two columns giving the names of the SNPs (if one column matrix) or pairs of SNPs (if two columns matrix) to be analyzed.  These SNPs represent all or part of the SNPs in the data files <code>datfilenames</code>.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_ibd.loci">ibd.loci</code></td>
<td>

<p>matrix of the same dimensions as <code>snp.names.mat</code>, giving the respective names of the markers (used to obtain the IBD results) closest to the corresponding SNPs. The marker names must be written exactly the same as in the ibd files <code>ibdfilenames</code> for extraction of IBD data. If the IBD data are specified by genetic positions instead of marker names, then for each SNP, specify the genetic position where IBD was inferred which is closest to the corresponding SNP.  If NULL (the default), then we use the kinship coefficients multiplied by two, instead of the expectation of the IBD probabilities, in the computation of the score statistics. The kinship coefficients are obtained using the function <code>kinship</code> from the package <code>kinship2</code>.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_joint.tests">joint.tests</code></td>
<td>

<p>list of vectors of numbers between 1 and the total number of parameters in the <code>design</code> function. Each vector gives parameter indices to test the corresponding parameters jointly.  The default is not to perform any joint test.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_contingency.file">contingency.file</code></td>
<td>

<p>if 'TRUE' (default is 'FALSE'), then a file called descriptive_statistics'date_and_time'.txt is created and contingency tables with the numbers of subjects per level are progressively added to this file.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_design.constraint">design.constraint</code></td>
<td>

<p>function building the design matrices WITHIN each category, for constraints specific to each category.  It also returns the design matrices comprising only the loci main effects that are used for computing the covariances. An attribute <code>n.levels</code> must be added within the function, to the object it returns.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_par.constrained">par.constrained</code></td>
<td>
<p> Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the parameter in the linear predictor for each level involved in the nc constraints BETWEEN the logistic models for different levels of the response variable, one constraint per column. 
This functionality is not yet implemented.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_constraints">constraints</code></td>
<td>

<p>Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the nc linear constraints BETWEEN the logistic models for different levels of the response variable, involving the parameters specified in <code>par.constrained</code>, one constraint per column.  A 0 means that the corresponding parameter is not involved in the constraint.
This functionality is not yet implemented.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_pairweights">pairweights</code></td>
<td>

<p>function calculating the weights of the observation pair differences when conditioning on the first SNP in the test of the second SNP in a SNP pair. Default is calcule.poids.alphafixe, implementing the weighting function of equation (6) of reference [1]. An alternative is calcule.poids.Chen, implementing the weighting function of equation (7) of reference [1].
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_lc">lc</code></td>
<td>

<p>numerical identifier of the SNP (locus) on which to condition when testing model terms. Defaults to NULL, or no conditioning.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly_+3A_alpha">alpha</code></td>
<td>

<p>vector of length <code>n.levels</code>-1 of the coefficients of the polytomous logistic model of association beween the phenotype and the conditionning SNP. Defaults to NULL. If <code>alpha = NULL</code> and <code>lc</code> is not NULL, an <code>alpha</code> is obtained by logistic regression (multinomial logistic regression if <code>n.levels&gt;2</code>) of the phenotype on the genotype at locus <code>lc</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All subjects included in the pedigree files must also be found in the IBD files.
</p>
<p>All fields in the pedigree files must be numeric.  No letters allowed, even for family and subject ID's.
</p>
<p>Families whose genotyped subjects are all in the same category (phenotype combination), are uninformative and will be excluded.
</p>
<p>Conditioning on the first SNP in a SNP pair is implemented by weighting the observation pair differences according to a model of the polytomous outcome as a function of the first SNP genotypes. The function converting the coefficients of this regression model into weights is specified by the argument <code>pairweights</code>. The default function <code>calcule.poids.alphafixe</code> provided satisfactory power in simulations described in reference [1].
</p>
<p>File &quot;descriptive_statistics'date_and_time'.txt&quot; (will be created if contingency.file='TRUE'): For each tested SNP, it shows contingency tables of the subjects in the 2 or 4 different categories, first for all families together and then for each individual family.
</p>
<p>If one or both of the arguments ibd.loci and ibdfilenames are left unspecified (or NULL, their default), then we use the kinship coefficients multiplied by two, instead of the expectation of the IBD probabilities, in the computation of the score statistics. The kinship coefficients are obtained using the function <code>kinship</code> from the package <code>kinship2</code>.
</p>


<h3>Value</h3>

<p>returns a list of five objects:
</p>
<table>
<tr><td><code>scores.covs.all.SNPs</code></td>
<td>

<p>list of length 'nrow(<code>snp.names.mat</code>)', each element of which contains the estimates of the scores and covariances of all the families.
</p>
</td></tr>
<tr><td><code>p.values.scores</code></td>
<td>

<p>data frame of p-values for all the SNPs or SNP pairs in <code>snp.names.mat</code>, for the global test (all parameters tested jointly), the individual tests and other joint tests specified by the argument <code>joint.tests</code>.  The p-values are obtained from scores summed over all families.  These scores of individual tests are also included in this data frame.
</p>
</td></tr>
<tr><td><code>MA.table</code></td>
<td>

<p>data frame giving the minor allele numbers of all the SNPs contained in the allele frequency files.
</p>
</td></tr>
<tr><td><code>y1</code></td>
<td>

<p>affection name extracted from first line of the data file(s)
</p>
</td></tr>
<tr><td><code>y2</code></td>
<td>

<p>affection name extracted from second line of the data file(s)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexandre Bureau and Jordie Croteau
</p>


<h3>References</h3>

<p>1. Bureau A., Croteau J., Chagnon, Y.C., Roy, M.-A. and Maziade, M. Extension of the Generalized Disequilibrium Test to polytomous phenotypes and two locus models. Frontiers in Genetics, 5: Article 258. 
2. http://www.sph.umich.edu/csg/abecasis/Merlin/tour/input_files.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fat2Lpoly.withinR">fat2Lpoly.withinR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path.data=paste(.libPaths()[which(unlist(lapply(.libPaths(),
function(x) length(grep("fat2Lpoly",dir(x)))))&gt;0)],"/fat2Lpoly/extdata/",sep="")
if(length(path.data)&gt;1) path.data=path.data[length(path.data)]

snps.anal=c("snp3.loc2","snp4.loc2")
microsat.names.loc2=c("2_3_mrk:","2_4_mrk:")

############ design.endo2disease with conditioning on locus 1 ################
## Not run: 
joint.tests=list(c(2,5))
snp.names.mat=cbind(rep("snp4.loc1",length(snps.anal)),snps.anal)
microsat.names.mat=cbind(rep("1_4_mrk:",length(snps.anal)),microsat.names.loc2)
test=fat2Lpoly(pedfilenames=paste(path.data,c("loc1.ped","loc2.ped"),sep=""),
               datfilenames=paste(path.data,c("loc1.dat","loc2.dat"),sep=""),
			   freq.data=paste(path.data,c("loc1.freq","loc2.freq"),sep=""),
               ibdfilenames=paste(path.data,c("loc1.ibd","loc2.ibd"),sep=""),
		       snp.names.mat=snp.names.mat,ibd.loci=microsat.names.mat,
		       joint.tests=joint.tests,contingency.file=TRUE,
		       design.constraint=design.endo2disease,lc=1)

test$p.values.scores

## End(Not run)		   
###############################################################################

################### design.endo2disease without conditioning ##################
joint.tests=list(c(2,5))
snp.names.mat=cbind(rep("snp4.loc1",length(snps.anal)),snps.anal)
microsat.names.mat=cbind(rep("1_4_mrk:",length(snps.anal)),microsat.names.loc2)
test=fat2Lpoly(pedfilenames=paste(path.data,c("loc1.ped","loc2.ped"),sep=""),
               datfilenames=paste(path.data,c("loc1.dat","loc2.dat"),sep=""),
			   freq.data=paste(path.data,c("loc1.freq","loc2.freq"),sep=""),
               ibdfilenames=paste(path.data,c("loc1.ibd","loc2.ibd"),sep=""),
		       snp.names.mat=snp.names.mat,ibd.loci=microsat.names.mat,
		       joint.tests=joint.tests,contingency.file=FALSE,
		       design.constraint=design.endo2disease)

test$p.values.scores   
###############################################################################

################# design.full with conditioning on locus 1 ##################
## Not run: 
joint.tests=list(c(2,3),c(5,6),c(8,9),c(2,3,5,6,8,9))
snp.names.mat=cbind(rep("snp4.loc1",length(snps.anal)),snps.anal)
microsat.names.mat=cbind(rep("1_4_mrk:",length(snps.anal)),microsat.names.loc2)
test=fat2Lpoly(pedfilenames=paste(path.data,c("loc1.ped","loc2.ped"),sep=""),
               datfilenames=paste(path.data,c("loc1.dat","loc2.dat"),sep=""),
			   freq.data=paste(path.data,c("loc1.freq","loc2.freq"),sep=""),
               ibdfilenames=paste(path.data,c("loc1.ibd","loc2.ibd"),sep=""),
		       snp.names.mat=snp.names.mat,ibd.loci=microsat.names.mat,
		       joint.tests=joint.tests,
               design.constraint=design.full,lc=1)

test$p.values.scores

## End(Not run)
##############################################################################

############################# design.1locus #################################
snp.names.mat=as.matrix(snps.anal)
microsat.names.mat=as.matrix(microsat.names.loc2)
test=fat2Lpoly(pedfilenames=paste(path.data,"loc2.ped",sep=""),
               datfilenames=paste(path.data,"loc2.dat",sep=""),
               freq.data=paste(path.data,"loc2.freq",sep=""),
			   ibdfilenames=paste(path.data,"loc2.ibd",sep=""),
		       snp.names.mat=snp.names.mat,ibd.loci=microsat.names.mat,
			   design.constraint=design.1locus)

test$p.values.scores			   
##############################################################################

############# design.dichotomous with conditioning on locus 1 ##############
## Not run: 
joint.tests=list(c(2,3))
snp.names.mat=cbind(rep("snp4.loc1",length(snps.anal)),snps.anal)
microsat.names.mat=cbind(rep("1_4_mrk:",length(snps.anal)),microsat.names.loc2)
test=fat2Lpoly(pedfilenames=paste(path.data,c("loc1.ped","loc2.ped"),sep=""),
               datfilenames=paste(path.data,c("loc1.dat","loc2.dat"),sep=""),
			   freq.data=paste(path.data,c("loc1.freq","loc2.freq"),sep=""),
               ibdfilenames=paste(path.data,c("loc1.ibd","loc2.ibd"),sep=""),
		       snp.names.mat=snp.names.mat,ibd.loci=microsat.names.mat,
		       joint.tests=joint.tests,
               design.constraint=design.dichotomous,lc=1)

test$p.values.scores

## End(Not run)			   
##############################################################################
</code></pre>

<hr>
<h2 id='fat2Lpoly-internal'>Internal fat2Lpoly Functions</h2><span id='topic+alleles2sums'></span><span id='topic+cov.score.interfunction'></span><span id='topic+cov.score.poly'></span><span id='topic+scores.covs'></span><span id='topic+design.polytomous'></span><span id='topic+ibd.terms'></span><span id='topic+ibd.terms.w'></span><span id='topic+score.poly'></span><span id='topic+produits.paires'></span><span id='topic+converti.terme'></span><span id='topic+calcule.poids.Chen'></span><span id='topic+calcule.poids.alphafixe'></span>

<h3>Description</h3>

<p>Internal fat2Lpoly functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='fat2Lpoly.allSNPs'>
Example results output by the function <code>fat2Lpoly.withinR</code>
</h2><span id='topic+fat2Lpoly.allSNPs'></span>

<h3>Description</h3>

<p>This list is an example of output from the function <code>fat2Lpoly.withinR</code>. It is provided to test the function <code>get.scores.pvalues</code> by executing the example code in the <code>get.scores.pvalues</code> documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fat2Lpoly.allSNPs)</code></pre>


<h3>Format</h3>

<p>A list of two objects:
</p>

<dl>
<dt>scores.covs.all.SNPs</dt><dd>
<p>list of length 'nrow(<code>snp.names.mat</code>)', each element of which contains the estimates of the scores and covariances of all the families.
</p>
</dd>
<dt>snp.names.mat</dt><dd>
<p>(same matrix as provided as argument) matrix of one or two columns giving the names of the SNPs (if one column matrix) or pairs of SNPs (if two columns matrix) to be analyzed.  These SNPs represent all or part of the SNPs in the data files <code>datfilenames</code>.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(fat2Lpoly.allSNPs)
</code></pre>

<hr>
<h2 id='fat2Lpoly.withinR'>
Two-locus Family-based Association Test with Polytomous Outcome (all arguments within R)
</h2><span id='topic+fat2Lpoly.withinR'></span>

<h3>Description</h3>

<p>Same as <code>fat2Lpoly</code> except that the first four arguments of <code>fat2Lpoly</code> are replaced by one object having the format of the objects returned by <code>read.merlin.files</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fat2Lpoly.withinR(ped.x.all, snp.names.mat, ibd.loci = NULL, contingency.file = FALSE, 
                  design.constraint, par.constrained, constraints, 
                  pairweights=calcule.poids.alphafixe, lc = NULL, alpha = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fat2Lpoly.withinR_+3A_ped.x.all">ped.x.all</code></td>
<td>

<p>object returned by the function <code>read.merlin.files</code> or having the same format.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_snp.names.mat">snp.names.mat</code></td>
<td>

<p>matrix of one or two columns giving the names of the SNPs (if one column matrix) or pairs of SNPs (if two columns matrix) to be analyzed.  These SNPs represent all or part of the SNPs in the data files <code>datfilenames</code>.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_ibd.loci">ibd.loci</code></td>
<td>

<p>matrix of the same dimensions as <code>snp.names.mat</code>, giving the respective names of the markers (used to obtain the IBD results) nearest to the corresponding SNPs. The marker names must be written exactly the same as in the ibd files <code>ibdfilenames</code> for extraction of IBD data.  If the IBD data are specified by genetic positions instead of marker names, this matrix must contain the genetic positions of the markers instead of the marker names. If NULL (the default), then we use the kinship coefficients multiplied by two, instead of the expectation of the IBD probabilities, in the computation of the score statistics. The kinship coefficients are obtained using the function <code>kinship</code> from the package <code>kinship2</code>.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_contingency.file">contingency.file</code></td>
<td>

<p>if 'TRUE' (default is 'FALSE'), then a file called descriptive_statistics'date_and_time'.txt is created and contingency tables with the numbers of subjects per level are progressively added to this file.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_design.constraint">design.constraint</code></td>
<td>

<p>function building the design matrices WITHIN each category, for constraints specific to each category.  It also returns the design matrices comprising only the loci main effects that are used for computing the covariances.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_par.constrained">par.constrained</code></td>
<td>
<p> Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the parameter in the linear predictor for each level involved in the nc constraints BETWEEN the logistic models for different levels of the response variable, one constraint per column. 
This functionality is not yet implemented.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_constraints">constraints</code></td>
<td>

<p>Optional matrix of dimensions (<code>n.levels</code>-1) x nc specifying the nc linear constraints BETWEEN the logistic models for different levels of the response variable, involving the parameters specified in <code>par.constrained</code>, one constraint per column.  A 0 means that the corresponding parameter is not involved in the constraint.
This functionality is not yet implemented.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_pairweights">pairweights</code></td>
<td>

<p>function calculating the weights of the observation pair differences when conditioning on the first SNP in the test of the second SNP in a SNP pair. Default is calcule.poids.alphafixe, implementing the weighting function of equation (6) of reference [1]. An alternative is calcule.poids.Chen, implementing the weighting function of equation (7) of reference [1].
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_lc">lc</code></td>
<td>

<p>numerical identifier of the SNP (locus) on which to condition when testing model terms. Defaults to NULL, or no conditioning.
</p>
</td></tr>
<tr><td><code id="fat2Lpoly.withinR_+3A_alpha">alpha</code></td>
<td>

<p>vector of length <code>n.levels</code>-1 of the coefficients of the polytomous logistic model of association beween the phenotype and the conditionning SNP. Defaults to NULL. If <code>alpha = NULL</code> and <code>lc</code> is not NULL, an <code>alpha</code> is obtained by logistic regression (multinomial logistic regression if <code>n.levels&gt;2</code>) of the phenotype on the genotype at locus <code>lc</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>File &quot;descriptive_statistics'date_and_time'.txt&quot; (will be created if contingency.file='TRUE'): For each tested SNP, it shows contingency tables of the subjects in the 2 or 4 different categories, first for all families together and then for each individual family.
</p>
<p>If the argument ibd.loci is left unspecified (or NULL, its default), then we use the kinship coefficients multiplied by two, instead of the expectation of the IBD probabilities, in the computation of the score statistics. The kinship coefficients are obtained using the function <code>kinship</code> from the package <code>kinship2</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>scores.covs.all.SNPs</code></td>
<td>

<p>list of length 'nrow(<code>snp.names.mat</code>)', each element of which contains the estimates of the scores and covariances of all the families.
</p>
</td></tr>
<tr><td><code>snp.names.mat</code></td>
<td>

<p>(same matrix as provided as argument) matrix of one or two columns giving the names of the SNPs (if one column matrix) or pairs of SNPs (if two columns matrix) to be analyzed.  These SNPs represent all or part of the SNPs in the data files <code>datfilenames</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexandre Bureau and Jordie Croteau
</p>


<h3>References</h3>

<p>Bureau A., Croteau J., Chagnon, Y.C., Roy, M.-A. and Maziade, M. Extension of the Generalized Disequilibrium Test to polytomous phenotypes and two locus models. Frontiers in Genetics, 5: Article 258. </p>


<h3>See Also</h3>

<p><code><a href="#topic+fat2Lpoly">fat2Lpoly</a>, <a href="#topic+read.merlin.files">read.merlin.files</a>, <a href="#topic+get.scores.pvalues">get.scores.pvalues</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ped.x.all)

## Not run: 
snp.names.mat=cbind(rep("snp4.loc1",2),c("snp3.loc2","snp4.loc2"))	
microsat.names.mat=cbind(rep("1_4_mrk:",2),c("2_3_mrk:","2_4_mrk:"))	
fat2Lpoly.allSNPs=fat2Lpoly.withinR(ped.x.all,snp.names.mat,ibd.loci=
                            microsat.names.mat,contingency.file=TRUE,
							design.constraint=design.endo2disease,
							lc=1)

joint.tests=list(c(2,5))   
get.scores.pvalues(fat2Lpoly.allSNPs,joint.tests)

## End(Not run)
</code></pre>

<hr>
<h2 id='get.scores.pvalues'>
function to compute scores and p-values
</h2><span id='topic+get.scores.pvalues'></span>

<h3>Description</h3>

<p>For each tested SNP and each parameter in the model, computes scores by summing family scores over all families and computes the corresponding p-values.  P-values of global and joint tests are also computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.scores.pvalues(test, joint.tests)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.scores.pvalues_+3A_test">test</code></td>
<td>

<p>object returned by <code>fat2Lpoly.withinR</code>.
</p>
</td></tr>
<tr><td><code id="get.scores.pvalues_+3A_joint.tests">joint.tests</code></td>
<td>

<p>list of vectors of numbers between 1 and the total number of parameters in the <code>design</code> function. Each vector gives parameter indices to test the corresponding parameters jointly.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of p-values for all the tested SNPs, for the global test (all parameters tested jointly), the individual tests and other joint tests specified by the argument <code>joint.tests</code>.  The p-values are obtained from scores summed over all families.  These scores of individual tests are also included in this data frame.
</p>


<h3>Author(s)</h3>

<p>Alexandre Bureau and Jordie Croteau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fat2Lpoly">fat2Lpoly</a>, <a href="#topic+fat2Lpoly.withinR">fat2Lpoly.withinR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fat2Lpoly.allSNPs)
			   
joint.tests=list(c(2,5),c(3,4))

get.scores.pvalues(fat2Lpoly.allSNPs, joint.tests)	
			   
#    snp.cond  snp.test global_p params.joint_2-5_p params.joint_3-4_p param_1_score 
# 1 snp4.loc1 snp2.loc2 5.80e-03           7.12e-01           0.000954         0.449 
# 2 snp4.loc1 snp4.loc2 2.14e-07           1.24e-05           0.000954         0.449 
# 3 snp4.loc1 snp5.loc2 1.14e-03           1.44e-01           0.000954         0.449 
# 4 snp4.loc1 snp6.loc2 5.59e-04           3.84e-02           0.000954         0.449 
# 5 snp4.loc1 snp8.loc2 1.15e-03           1.55e-01           0.000954         0.449 
# param_2_score param_3_score param_4_score param_5_score param_1_p param_2_p
#         0.333        -1.427         3.638         0.733     0.653     0.739
#         0.890        -1.427         3.638         4.612     0.653     0.373		
#         0.776        -1.427         3.638         1.785     0.653     0.438
#        -0.082        -1.427         3.638         2.553     0.653     0.934
#         0.869        -1.427         3.638         1.695     0.653     0.385		
#   param_3_p param_4_p param_5_p
# 1     0.154  0.000275  0.464000
# 2     0.154  0.000275  0.000004
# 3     0.154  0.000275  0.074200
# 4     0.154  0.000275  0.010700
# 5     0.154  0.000275  0.090100	
</code></pre>

<hr>
<h2 id='ped.x.all'>
Example dataset returned by the function <code>read.merlin.files</code>
</h2><span id='topic+ped.x.all'></span>

<h3>Description</h3>

<p>This list is an example of output from the function <code>read.merlin.files</code>. It is provided to test the function <code>fat2Lpoly.withinR</code> by executing the example code in the <code>fat2Lpoly.withinR</code> documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ped.x.all)</code></pre>


<h3>Format</h3>

<p>A list of six objects:
</p>

<dl>
<dt>ped</dt><dd>
<p>data frame with columns fam.id, subject.ids, endophenotype and phenotype (in the given order)
</p>
</dd>
<dt>x.all</dt><dd>
<p>data frame of SNP genotypes in the format &quot;(number of minor alleles)/2&quot;, for all SNPs listed in the file(s) in <code>datfilenames</code>.  It contains only the SNP data and it has as column names the SNP names in <code>datfilenames</code>.  The lines come in the same order as in <code>ped</code>.
</p>
</dd>
<dt>MA.table</dt><dd>
<p>data frame giving the minor allele numbers of all the SNPs.  The first column consists of <code>x.all</code>'s column names and the second column the minor allele numbers.
</p>
</dd>
<dt>ibd.dat.list</dt><dd>
<p>list of one or two data frames containing the columns of the IBD data file(s) in <code>ibdfilenames</code>.  
</p>
</dd>
<dt>y1.name</dt><dd>
<p>affection name extracted from first line of the data file(s)
</p>
</dd>
<dt>y2.name</dt><dd>
<p>affection name extracted from second line of the data file(s)
</p>
</dd>
<dt>ibdfilenames</dt><dd>
<p>(same object as provided as argument) vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the Merlin format ibd files corresponding to the pedigree files.
</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(ped.x.all)
</code></pre>

<hr>
<h2 id='read.merlin.files'>
function to read input files in Merlin format
</h2><span id='topic+read.merlin.files'></span>

<h3>Description</h3>

<p>Reads the pedigree, data and allele frequency input files.  The data read is reformatted to be used by the function <code>fat2Lpoly.withinR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.merlin.files(pedfilenames, datfilenames, freq.data, ibdfilenames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.merlin.files_+3A_pedfilenames">pedfilenames</code></td>
<td>

<p>vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the pedigree files in Merlin format (see Merlin website [1]). Put the full path of the files if they are not in the current working directory. If the phenotype is polytomous with 4 levels created by all combinations of two dichotomous phenotypic variables <code class="reqn">Y_{1}</code> and <code class="reqn">Y_{2}</code>, then the sixth and seventh columns of each file contain respectively <code class="reqn">Y_{1}</code> (e.g. the endophenotype) and <code class="reqn">Y_{2}</code> (e.g. the disease phenotype). If the phenotype is dichotomous, then the sixth column of each file contains it.</p>
</td></tr>
<tr><td><code id="read.merlin.files_+3A_datfilenames">datfilenames</code></td>
<td>

<p>vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the Merlin format data files corresponding to the pedigree files.
</p>
</td></tr>
<tr><td><code id="read.merlin.files_+3A_freq.data">freq.data</code></td>
<td>

<p>Either 
(1) a vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the allele frequency files corresponding to the pedigree files. These files must be in Merlin Classic format.
or
(2) a list of length 1 or 2 (the number of loci involved in the <code>design</code> function), each element of which is a numeric vector of length 'number of SNPs in <code>datfilenames</code>' and specifies each SNP's minor allele.
</p>
</td></tr>
<tr><td><code id="read.merlin.files_+3A_ibdfilenames">ibdfilenames</code></td>
<td>

<p>vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the Merlin format ibd files corresponding to the pedigree files. If NULL (the default), the reading of the IBD files is skipped.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All subjects included in the pedigree files must also be found in the IBD files.
</p>
<p>All fields in the pedigree files must be numeric.  No letters allowed, even for family and subject ID's.
</p>


<h3>Value</h3>

<p>returns a list of six objects:
</p>
<table>
<tr><td><code>ped</code></td>
<td>

<p>data frame with columns fam.id, subject.ids, endophenotype and phenotype (in the given order)
</p>
</td></tr>
<tr><td><code>x.all</code></td>
<td>

<p>data frame of SNP genotypes in the format &quot;(number of minor alleles)/2&quot;, for all SNPs listed in the file(s) in <code>datfilenames</code>.  It contains only the SNP data and it has as column names the SNP names in <code>datfilenames</code>.  The lines come in the same order as in <code>ped</code>.
</p>
</td></tr>
<tr><td><code>MA.table</code></td>
<td>

<p>data frame giving the minor allele numbers of all the SNPs.  The first column consists of <code>x.all</code>'s column names and the second column the minor allele numbers.
</p>
</td></tr>
<tr><td><code>ibd.dat.list</code></td>
<td>

<p>list of one or two data frames containing the columns of the IBD data file(s) in <code>ibdfilenames</code>.  
</p>
</td></tr>
<tr><td><code>y1.name</code></td>
<td>

<p>affection name extracted from first line of the data file(s)
</p>
</td></tr>
<tr><td><code>y2.name</code></td>
<td>

<p>affection name extracted from second line of the data file(s)
</p>
</td></tr>
<tr><td><code>ibdfilenames</code></td>
<td>

<p>(same object as provided as argument) vector of 1 or 2 (the number of loci involved in the <code>design</code> function) character strings giving the names of the Merlin format ibd files corresponding to the pedigree files.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexandre Bureau and Jordie Croteau
</p>


<h3>References</h3>

<p>1. http://www.sph.umich.edu/csg/abecasis/Merlin/tour/input_files.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fat2Lpoly.withinR">fat2Lpoly.withinR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path.data=paste(.libPaths()[which(unlist(lapply(.libPaths(),
function(x) length(grep("fat2Lpoly",dir(x)))))&gt;0)],
"/fat2Lpoly/extdata/",sep="")
if(length(path.data)&gt;1) path.data=path.data[length(path.data)]

input.data=read.merlin.files(pedfilenames=
                  paste(path.data,c("loc1.ped","loc2.ped"),sep=""),
                  datfilenames=
				paste(path.data,c("loc1.dat","loc2.dat"),sep=""),
			      freq.data=
			      paste(path.data,c("loc1.freq","loc2.freq"),sep=""),
                       ibdfilenames=
				paste(path.data,c("loc1.ibd","loc2.ibd"),sep=""))

input.data2=read.merlin.files(pedfilenames=
					paste(path.data,"loc2.ped",sep=""),
                            datfilenames=
                            paste(path.data,"loc2.dat",sep=""),
                            freq.data=
                            paste(path.data,"loc2.freq",sep=""),
					ibdfilenames=
					paste(path.data,"loc2.ibd",sep=""))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
