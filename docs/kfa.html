<!DOCTYPE html><html><head><title>Help for package kfa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kfa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agg_cors'><p>Aggregated factor correlations</p></a></li>
<li><a href='#agg_loadings'><p>Aggregated factor loadings</p></a></li>
<li><a href='#agg_model_fit'><p>Summary table of model fit</p></a></li>
<li><a href='#agg_rels'><p>Aggregated scale reliabilities</p></a></li>
<li><a href='#efa_cfa_syntax'><p>Write confirmatory factor analysis syntax</p></a></li>
<li><a href='#example.kfa'><p>kfa results from simulated data example</p></a></li>
<li><a href='#find_k'><p>Find k for k-fold cross-validation</p></a></li>
<li><a href='#get_std_loadings'><p>Standardized factor loadings matrix</p></a></li>
<li><a href='#index_available'><p>Available Fit Indices</p></a></li>
<li><a href='#k_model_fit'><p>Extract model fit</p></a></li>
<li><a href='#kfa'><p>Conducts k-fold cross validation for factor analysis</p></a></li>
<li><a href='#kfa_report'><p>Creates summary report from a k-fold factor analysis</p></a></li>
<li><a href='#model_structure'><p>Unique factor structures</p></a></li>
<li><a href='#run_efa'><p>Conducts exploratory factor analysis</p></a></li>
<li><a href='#write_efa'><p>Write exploratory factor analysis syntax</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>K-Fold Cross Validation for Factor Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyle Nickodem [aut, cre] and Peter Halpin [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyle Nickodem &lt;kyle.nickodem@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to identify plausible and replicable factor
  structures for a set of variables via k-fold cross validation. The process
  combines the exploratory and confirmatory factor analytic approach to scale
  development (Flora &amp; Flake, 2017) &lt;<a href="https://doi.org/10.1037%2Fcbs0000069">doi:10.1037/cbs0000069</a>&gt; with a cross validation
  technique that maximizes the available data (Hastie, Tibshirani, &amp; Friedman, 2009)
  &lt;isbn:978-0-387-21606-5&gt;. Also available are functions to determine k by drawing 
  on power analytic techniques for covariance structures (MacCallum, Browne, &amp;
  Sugawara, 1996) &lt;<a href="https://doi.org/10.1037%2F1082-989X.1.2.130">doi:10.1037/1082-989X.1.2.130</a>&gt;, generate model syntax, and
  summarize results in a report.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, doParallel, flextable (&ge; 0.6.3), foreach, GPArotation,
knitr, lavaan (&ge; 0.6.9), officer, parallel, rmarkdown,
semTools (&ge; 0.5.5), simstandard</td>
</tr>
<tr>
<td>Suggests:</td>
<td>semPlot</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/knickodem/kfa">https://github.com/knickodem/kfa</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/knickodem/kfa/issues">https://github.com/knickodem/kfa/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-08 23:18:57 UTC; kylenick</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-09 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='agg_cors'>Aggregated factor correlations</h2><span id='topic+agg_cors'></span>

<h3>Description</h3>

<p>The factor correlations aggregated over k-folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_cors(models, flag = 0.9, type = "factor")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_cors_+3A_models">models</code></td>
<td>
<p>An object returned from <code><a href="#topic+kfa">kfa</a></code></p>
</td></tr>
<tr><td><code id="agg_cors_+3A_flag">flag</code></td>
<td>
<p>threshold above which a factor correlation will be flagged</p>
</td></tr>
<tr><td><code id="agg_cors_+3A_type">type</code></td>
<td>
<p>currently ignored; <code>"factor"</code> (default) or <code>"observed"</code> variable correlations</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of mean factor correlations for each factor model and <code>vector</code> with count of folds with a flagged correlation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.kfa)
agg_cors(example.kfa)

</code></pre>

<hr>
<h2 id='agg_loadings'>Aggregated factor loadings</h2><span id='topic+agg_loadings'></span>

<h3>Description</h3>

<p>The factor loadings aggregated over k-folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_loadings(models, flag = 0.3, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_loadings_+3A_models">models</code></td>
<td>
<p>An object returned from <code><a href="#topic+kfa">kfa</a></code></p>
</td></tr>
<tr><td><code id="agg_loadings_+3A_flag">flag</code></td>
<td>
<p>threshold below which loading will be flagged</p>
</td></tr>
<tr><td><code id="agg_loadings_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to display in the report.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of mean factor loadings for each factor model and <code>vector</code> with count of folds with a flagged loading
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.kfa)
agg_loadings(example.kfa)

</code></pre>

<hr>
<h2 id='agg_model_fit'>Summary table of model fit</h2><span id='topic+agg_model_fit'></span>

<h3>Description</h3>

<p>Summary table of model fit aggregated over k-folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_model_fit(kfits, index = "all", digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_model_fit_+3A_kfits">kfits</code></td>
<td>
<p>an object returned from <code><a href="#topic+k_model_fit">k_model_fit</a></code> when <code>by.folds = TRUE</code></p>
</td></tr>
<tr><td><code id="agg_model_fit_+3A_index">index</code></td>
<td>
<p>character; one or more fit indices to summarize. Indices
must be present in the <code>kfits</code> object. Default is <code>"all"</code> indices present in <code>kfits</code>.
Chi-square value and degrees of freedom are always reported.</p>
</td></tr>
<tr><td><code id="agg_model_fit_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to display in the report</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of aggregated model fit statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.kfa)
fits &lt;- k_model_fit(example.kfa, by.fold = TRUE)
agg_model_fit(fits)

</code></pre>

<hr>
<h2 id='agg_rels'>Aggregated scale reliabilities</h2><span id='topic+agg_rels'></span>

<h3>Description</h3>

<p>The factor reliabilities aggregated over k-folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_rels(models, flag = 0.6, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_rels_+3A_models">models</code></td>
<td>
<p>An object returned from <code><a href="#topic+kfa">kfa</a></code></p>
</td></tr>
<tr><td><code id="agg_rels_+3A_flag">flag</code></td>
<td>
<p>threshold below which reliability will be flagged</p>
</td></tr>
<tr><td><code id="agg_rels_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to display in the report.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> of mean factor (scale) reliabilities for each factor model and <code>vector</code> with count of folds with a flagged reliability
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.kfa)
agg_rels(example.kfa)

</code></pre>

<hr>
<h2 id='efa_cfa_syntax'>Write confirmatory factor analysis syntax</h2><span id='topic+efa_cfa_syntax'></span>

<h3>Description</h3>

<p>Uses the factor loadings matrix, presumably from an exploratory factor analysis, to generate <code>lavaan</code> compatible confirmatory factory analysis syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efa_cfa_syntax(
  loadings,
  simple = TRUE,
  min.loading = NA,
  single.item = c("keep", "drop", "none"),
  identified = TRUE,
  constrain0 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efa_cfa_syntax_+3A_loadings">loadings</code></td>
<td>
<p>matrix of factor loadings</p>
</td></tr>
<tr><td><code id="efa_cfa_syntax_+3A_simple">simple</code></td>
<td>
<p>logical; Should the perfect simple structure be returned (default) when converting EFA results to CFA syntax?
If <code>FALSE</code>, items can cross-load on multiple factors.</p>
</td></tr>
<tr><td><code id="efa_cfa_syntax_+3A_min.loading">min.loading</code></td>
<td>
<p>numeric between 0 and 1 indicating the minimum (absolute) value of the loading for a variable on a factor
when converting EFA results to CFA syntax. Must be specified when <code>simple = FALSE</code>.</p>
</td></tr>
<tr><td><code id="efa_cfa_syntax_+3A_single.item">single.item</code></td>
<td>
<p>character indicating how single-item factors should be treated.
Use <code>"keep"</code> (default) to keep them in the model when generating the CFA syntax, <code>"drop"</code>
to remove them, or <code>"none"</code> indicating the CFA syntax should not be generated for
this model and <code>""</code> is returned.</p>
</td></tr>
<tr><td><code id="efa_cfa_syntax_+3A_identified">identified</code></td>
<td>
<p>logical; Should identification check for rotational uniqueness a la Millsap (2001) be performed?
If the model is not identified <code>""</code> is returned.</p>
</td></tr>
<tr><td><code id="efa_cfa_syntax_+3A_constrain0">constrain0</code></td>
<td>
<p>logical; Should variable(s) with all loadings below <code>min.loading</code> still be included in model syntax?
If <code>TRUE</code>, variable(s) will load onto first factor with the loading constrained to 0.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Millsap, R. E. (2001). When trivial constraints are not trivial: The choice of uniqueness
constraints in confirmatory factor analysis. *Structural Equation Modeling, 8*(1), 1-17. <a href="https://doi.org/10.1207/S15328007SEM0801_1">doi:10.1207/S15328007SEM0801_1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loadings &lt;- matrix(c(rep(.2, 3), rep(.6, 3), rep(.8, 3), rep(.3, 3)), ncol = 2)
# simple structure
efa_cfa_syntax(loadings)
# allow cross-loadings and check if model is identified
efa_cfa_syntax(loadings, simple = FALSE, min.loading = .25)
# allow cross-loadings and ignore identification check
efa_cfa_syntax(loadings, simple = FALSE, min.loading = .25, identified = FALSE)

</code></pre>

<hr>
<h2 id='example.kfa'>kfa results from simulated data example</h2><span id='topic+example.kfa'></span>

<h3>Description</h3>

<p>Simulated responses for 900 observations on 20 variables loading onto a 3 factor
structure (see example in <code><a href="#topic+kfa">kfa</a></code> documentation for model).
The simulated data was run through <code><a href="#topic+kfa">kfa</a></code> with the call
kfa(sim.data, k = 2, m = 3) which tested 1-, 2-, and 3-factor structures over 2 folds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example.kfa)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"kfa"</code>, which is a four-element <code>list</code>:
</p>

<ul>
<li> <p><strong>cfas</strong> <code>lavaan</code> CFA objects for each <em>k</em> fold
</p>
</li>
<li> <p><strong>cfa.syntax</strong> syntax used to produce CFA objects
</p>
</li>
<li> <p><strong>model.names</strong> vector of names for CFA objects
</p>
</li>
<li> <p><strong>efa.structures</strong> all factor structures identified in the EFA
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(example.kfa)
agg_cors(example.kfa)

</code></pre>

<hr>
<h2 id='find_k'>Find k for k-fold cross-validation</h2><span id='topic+find_k'></span>

<h3>Description</h3>

<p>This function is specifically for determining <em>k</em> in the context of factor analysis using
change in RMSEA as the criterion for identifying the optimal factor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_k(
  variables,
  n,
  p,
  m = NULL,
  max.k = 10,
  min.n = 200,
  rmsea0 = 0.05,
  rmseaA = 0.08,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_k_+3A_variables">variables</code></td>
<td>
<p>a <code>data.frame</code> (or convertible to a <code>data.frame</code>) with variables to factor analyze in columns and observations in rows.
The power analysis assumes all observations have complete data. Use <code>n</code> argument or remove rows manually to account for missingness.</p>
</td></tr>
<tr><td><code id="find_k_+3A_n">n</code></td>
<td>
<p>integer; number of observations. Ignored if <code>variables</code> is provided.</p>
</td></tr>
<tr><td><code id="find_k_+3A_p">p</code></td>
<td>
<p>integer; number of variables to factor analyze. Ignored if<code>variables</code> is provided.</p>
</td></tr>
<tr><td><code id="find_k_+3A_m">m</code></td>
<td>
<p>integer; maximum number of factors expected to be extracted from <code>variables</code>. Default is <code>p</code> / 4 (i.e., 4 variables per factor).</p>
</td></tr>
<tr><td><code id="find_k_+3A_max.k">max.k</code></td>
<td>
<p>integer; maximum number of folds. Default is 10. <code>NULL</code> indicates no maximum.</p>
</td></tr>
<tr><td><code id="find_k_+3A_min.n">min.n</code></td>
<td>
<p>integer; minimum sample size per fold. Default is 200 based on simulations from Curran et al. (2003).</p>
</td></tr>
<tr><td><code id="find_k_+3A_rmsea0">rmsea0</code></td>
<td>
<p>numeric; RMSEA under the null hypothesis.</p>
</td></tr>
<tr><td><code id="find_k_+3A_rmseaa">rmseaA</code></td>
<td>
<p>numeric; RMSEA under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="find_k_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="semTools.html#topic+findRMSEAsamplesize">findRMSEAsamplesize</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector with the number of folds (k), sample size suggested by the power analysis (power.n), and the actual sample size used for determining k (actual.n).
</p>


<h3>References</h3>

<p>Curran, P. J., Bollen, K. A., Chen, F., Paxton, P., &amp; Kirby, J. B. (2003). Finite sampling properties of the point estimates and confidence intervals of the RMSEA. <em>Sociological Methods &amp; Research, 32</em>(2), 208-252. <a href="https://doi.org/10.1177/0049124103256130">doi:10.1177/0049124103256130</a>
</p>
<p>MacCallum, R. C., Browne, M. W., &amp; Sugawara, H. M. (1996). Power analysis and determination of sample size for covariance structure modeling. <em>Psychological Methods, 1</em>(2), 130–149. <a href="https://doi.org/10.1037/1082-989X.1.2.130">doi:10.1037/1082-989X.1.2.130</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_k(n = 900, p = 20, m = 3)

# adjust precision
find_k(n = 900, p = 20, m = 3, rmsea0 = .03, rmseaA = .10)

</code></pre>

<hr>
<h2 id='get_std_loadings'>Standardized factor loadings matrix</h2><span id='topic+get_std_loadings'></span>

<h3>Description</h3>

<p>Extract standardized factor loadings from lavaan object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_std_loadings(object, type = "std.all", df = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_std_loadings_+3A_object">object</code></td>
<td>
<p>a <code>lavaan</code> object</p>
</td></tr>
<tr><td><code id="get_std_loadings_+3A_type">type</code></td>
<td>
<p>standardize on the latent variables (<code>"std.lv"</code>),
latent and observed variables (<code>"std.all"</code>, default), or latent and observed variables
but not exogenous variables (<code>"std.nox"</code>)? See <code><a href="lavaan.html#topic+standardizedSolution">standardizedSolution</a></code>.</p>
</td></tr>
<tr><td><code id="get_std_loadings_+3A_df">df</code></td>
<td>
<p>should loadings be returned as a <code>matrix</code> (default) or <code>data.frame</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> or <code>data.frame</code> of factor loadings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HolzingerSwineford1939, package = "lavaan")
HS.model &lt;- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '

fit &lt;- lavaan::cfa(HS.model, data = HolzingerSwineford1939)
get_std_loadings(fit)

</code></pre>

<hr>
<h2 id='index_available'>Available Fit Indices</h2><span id='topic+index_available'></span>

<h3>Description</h3>

<p>Shows the fit indices available from <code><a href="#topic+kfa">kfa</a></code> object to report in <code><a href="#topic+kfa_report">kfa_report</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_available(models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_available_+3A_models">models</code></td>
<td>
<p>an object returned from <code><a href="#topic+kfa">kfa</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of index names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.kfa)
index_available(example.kfa)

</code></pre>

<hr>
<h2 id='k_model_fit'>Extract model fit</h2><span id='topic+k_model_fit'></span>

<h3>Description</h3>

<p>Model fit indices extracted from k-folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_model_fit(models, index = "default", by.fold = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k_model_fit_+3A_models">models</code></td>
<td>
<p>an object returned from <code><a href="#topic+kfa">kfa</a></code></p>
</td></tr>
<tr><td><code id="k_model_fit_+3A_index">index</code></td>
<td>
<p>character; one or more fit indices to summarize in the report. Use <code><a href="#topic+index_available">index_available</a></code> to see choices.
Chi-square value and degrees of freedom are always reported. Default is CFI and RMSEA (naive, scaled, or robust version depends on estimator used in <code>models</code>).</p>
</td></tr>
<tr><td><code id="k_model_fit_+3A_by.fold">by.fold</code></td>
<td>
<p>Should each element in the returned lists be a fold (default) or a factor model?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> of data.frames with average model fit for each factor model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.kfa)

# customize fit indices to report
k_model_fit(example.kfa, index = c("chisq", "cfi", "rmsea", "srmr"))

# organize results by factor model rather than by fold
k_model_fit(example.kfa, by.fold = FALSE)

</code></pre>

<hr>
<h2 id='kfa'>Conducts k-fold cross validation for factor analysis</h2><span id='topic+kfa'></span>

<h3>Description</h3>

<p>The function splits the data into <em>k</em> folds where each fold contains training data and test data.
For each fold, exploratory factor analyses (EFAs) are run on the training data. The structure for each model
is transformed into <code>lavaan</code>-compatible confirmatory factor analysis (CFA) syntax.
The CFAs are then run on the test data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfa(
  data,
  variables = names(data),
  k = NULL,
  m = floor(length(variables)/4),
  seed = 101,
  cores = NULL,
  custom.cfas = NULL,
  power.args = list(rmsea0 = 0.05, rmseaA = 0.08),
  rotation = "oblimin",
  simple = TRUE,
  min.loading = NA,
  single.item = "none",
  ordered = FALSE,
  estimator = NULL,
  missing = "listwise",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfa_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing the variables (i.e., items) to factor analyze</p>
</td></tr>
<tr><td><code id="kfa_+3A_variables">variables</code></td>
<td>
<p>character vector of column names in <code>data</code> indicating the variables to factor analyze. Default is to use all columns.</p>
</td></tr>
<tr><td><code id="kfa_+3A_k">k</code></td>
<td>
<p>number of folds in which to split the data. Default is <code>NULL</code> which determines k via <code><a href="#topic+find_k">find_k</a></code>.</p>
</td></tr>
<tr><td><code id="kfa_+3A_m">m</code></td>
<td>
<p>integer; maximum number of factors to extract. Default is 4 items per factor.</p>
</td></tr>
<tr><td><code id="kfa_+3A_seed">seed</code></td>
<td>
<p>integer passed to <code>set.seed</code> when randomly selecting cases for each fold.</p>
</td></tr>
<tr><td><code id="kfa_+3A_cores">cores</code></td>
<td>
<p>integer; number of CPU cores to use for parallel processing. Default is <code><a href="parallel.html#topic+detectCores">detectCores</a></code> - 1.</p>
</td></tr>
<tr><td><code id="kfa_+3A_custom.cfas">custom.cfas</code></td>
<td>
<p>a single object or named <code>list</code> of <code>lavaan</code> syntax specifying custom factor model(s).</p>
</td></tr>
<tr><td><code id="kfa_+3A_power.args">power.args</code></td>
<td>
<p>named <code>list</code> of arguments to pass to <code><a href="#topic+find_k">find_k</a></code> and <code><a href="semTools.html#topic+findRMSEAsamplesize">findRMSEAsamplesize</a></code> when conducting power analysis to determine <code>k</code>.</p>
</td></tr>
<tr><td><code id="kfa_+3A_rotation">rotation</code></td>
<td>
<p>character (case-sensitive); any rotation method listed in
<code><a href="GPArotation.html#topic+rotations">rotations</a></code> in the <code>GPArotation</code> package. Default is &quot;oblimin&quot;.</p>
</td></tr>
<tr><td><code id="kfa_+3A_simple">simple</code></td>
<td>
<p>logical; Should the perfect simple structure be returned (default) when converting EFA results to CFA syntax?
If <code>FALSE</code>, items can cross-load on multiple factors.</p>
</td></tr>
<tr><td><code id="kfa_+3A_min.loading">min.loading</code></td>
<td>
<p>numeric between 0 and 1 indicating the minimum (absolute) value of the loading for a variable on a factor
when converting EFA results to CFA syntax. Must be specified when <code>simple = FALSE</code>.</p>
</td></tr>
<tr><td><code id="kfa_+3A_single.item">single.item</code></td>
<td>
<p>character indicating how single-item factors should be treated.
Use <code>"keep"</code> to keep them in the model when generating the CFA syntax or
<code>"none"</code> (default) indicating the CFA syntax should not be generated for
this model and <code>""</code> is returned.</p>
</td></tr>
<tr><td><code id="kfa_+3A_ordered">ordered</code></td>
<td>
<p>logical; Should items be treated as ordinal and the
polychoric correlations used in the factor analysis? When <code>FALSE</code> (default)
the Pearson correlation matrix is used. A character vector of item names is
also accepted to prompt estimation of the polychoric correlation matrix.</p>
</td></tr>
<tr><td><code id="kfa_+3A_estimator">estimator</code></td>
<td>
<p>if <code>ordered = FALSE</code>, the default is &quot;MLMVS&quot;. If
<code>ordered = TRUE</code>, the default is &quot;WLSMV&quot;. See <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code> for other options.</p>
</td></tr>
<tr><td><code id="kfa_+3A_missing">missing</code></td>
<td>
<p>default is &quot;listwise&quot;. See <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code> for other options.</p>
</td></tr>
<tr><td><code id="kfa_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>lavaan</code> functions. See <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order for <code>custom.cfas</code> to be tested along with the EFA identified structures, each model supplied in <code>custom.cfas</code> must
include all <code>variables</code> in <code>lavaan</code>-compatible syntax.
</p>
<p>Deciding an appropriate <em>m</em> can be difficult, but is consequential for the possible factor structures to
examine, the power analysis to determine <em>k</em>, and overall computation time.
The <code>n_factors</code> function in the <code>parameters</code> package can assist with this decision.
</p>
<p>When converting EFA results to CFA syntax (via <code><a href="#topic+efa_cfa_syntax">efa_cfa_syntax</a></code>), the simple structure is
defined as each variable loading onto a single factor. This is determined using the largest factor loading for each variable.
When <code>simple = FALSE</code>, variables are allowed to cross-load on multiple factors. In this case, all pathways with loadings
above the <code>min.loading</code> are retained. However, allowing cross-loading variables can result in model under-identification.
The <code><a href="#topic+efa_cfa_syntax">efa_cfa_syntax</a></code>) function conducts an identification check (i.e., <code>identified = TRUE</code>) and
under-identified models are not run in the CFA portion of the analysis.
</p>


<h3>Value</h3>

<p>An object of class <code>"kfa"</code>, which is a four-element <code>list</code>:
</p>

<ul>
<li> <p><strong>cfas</strong> <code>lavaan</code> CFA objects for each <em>k</em> fold
</p>
</li>
<li> <p><strong>cfa.syntax</strong> syntax used to produce CFA objects
</p>
</li>
<li> <p><strong>model.names</strong> vector of names for CFA objects
</p>
</li>
<li> <p><strong>efa.structures</strong> all factor structures identified in the EFA
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# simulate data based on a 3-factor model with standardized loadings
sim.mod &lt;- "f1 =~ .7*x1 + .8*x2 + .3*x3 + .7*x4 + .6*x5 + .8*x6 + .4*x7
                f2 =~ .8*x8 + .7*x9 + .6*x10 + .5*x11 + .5*x12 + .7*x13 + .6*x14
                f3 =~ .6*x15 + .5*x16 + .9*x17 + .4*x18 + .7*x19 + .5*x20
                f1 ~~ .2*f2
                f2 ~~ .2*f3
                f1 ~~ .2*f3
                x9 ~~ .2*x10"
set.seed(1161)
sim.data &lt;- simstandard::sim_standardized(sim.mod, n = 900,
                                          latent = FALSE,
                                          errors = FALSE)[c(2:9,1,10:20)]

# include a custom 2-factor model
custom2f &lt;- paste0("f1 =~ ", paste(colnames(sim.data)[1:10], collapse = " + "),
                   "\nf2 =~ ",paste(colnames(sim.data)[11:20], collapse = " + "))


mods &lt;- kfa(data = sim.data,
            k = NULL, # prompts power analysis to determine number of folds
            cores = 2,
            custom.cfas = custom2f)
            

</code></pre>

<hr>
<h2 id='kfa_report'>Creates summary report from a k-fold factor analysis</h2><span id='topic+kfa_report'></span>

<h3>Description</h3>

<p>Generates a report summarizing the factor analytic results over k-folds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfa_report(
  models,
  file.name,
  report.title = file.name,
  path = NULL,
  report.format = "html_document",
  word.template = NULL,
  index = "default",
  plots = FALSE,
  load.flag = 0.3,
  cor.flag = 0.9,
  rel.flag = 0.6,
  digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfa_report_+3A_models">models</code></td>
<td>
<p>an object returned from <code><a href="#topic+kfa">kfa</a></code></p>
</td></tr>
<tr><td><code id="kfa_report_+3A_file.name">file.name</code></td>
<td>
<p>character; file name to create on disk.</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_report.title">report.title</code></td>
<td>
<p>character; title of the report</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_path">path</code></td>
<td>
<p>character; path of the directory where summary report will be saved. Default is working directory. <code>path</code> and <code>file.name</code> are combined to create final file path</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_report.format">report.format</code></td>
<td>
<p>character; file format of the report. Default is HTML (&quot;html_document&quot;). See <code><a href="rmarkdown.html#topic+render">render</a></code> for other options.</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_word.template">word.template</code></td>
<td>
<p>character; file path to word document to use as a formatting template when <code>report.format = "word_document"</code>.</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_index">index</code></td>
<td>
<p>character; one or more fit indices to summarize in the report. Use <code><a href="#topic+index_available">index_available</a></code> to see choices.
Chi-square value and degrees of freedom are always reported. Default is CFI and RMSEA (naive, scaled, or robust version depends on estimator used in <code>models</code>).</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_plots">plots</code></td>
<td>
<p>logical; should plots of the factor models be included in the report?</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_load.flag">load.flag</code></td>
<td>
<p>numeric; factor loadings of variables below this value will be flagged. Default is .30</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_cor.flag">cor.flag</code></td>
<td>
<p>numeric; factor correlations above this value will be flagged. Default is .90</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_rel.flag">rel.flag</code></td>
<td>
<p>numeric; factor (scale) reliabilities below this value will be flagged. Default is .60.</p>
</td></tr>
<tr><td><code id="kfa_report_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal places to display in the report.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary report of factor structures and model fit within and between folds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate data based on a 3-factor model with standardized loadings
sim.mod &lt;- "f1 =~ .7*x1 + .8*x2 + .3*x3 + .7*x4 + .6*x5 + .8*x6 + .4*x7
                f2 =~ .8*x8 + .7*x9 + .6*x10 + .5*x11 + .5*x12 + .7*x13 + .6*x14
                f3 =~ .6*x15 + .5*x16 + .9*x17 + .4*x18 + .7*x19 + .5*x20
                f1 ~~ .2*f2
                f2 ~~ .2*f3
                f1 ~~ .2*f3
                x9 ~~ .2*x10"
set.seed(1161)
sim.data &lt;- simstandard::sim_standardized(sim.mod, n = 900,
                                          latent = FALSE,
                                          errors = FALSE)[c(2:9,1,10:20)]

# include a custom 2-factor model
custom2f &lt;- paste0("f1 =~ ", paste(colnames(sim.data)[1:10], collapse = " + "),
                   "\nf2 =~ ",paste(colnames(sim.data)[11:20], collapse = " + "))


mods &lt;- kfa(data = sim.data,
            k = NULL, # prompts power analysis to determine number of folds
            cores = 2,
            custom.cfas = custom2f)
            

## Not run: 
kfa_report(mods, file.name = "example_sim_kfa_report",
           report.format = "html_document",
           report.title = "K-fold Factor Analysis - Example Sim")
           
## End(Not run)

</code></pre>

<hr>
<h2 id='model_structure'>Unique factor structures</h2><span id='topic+model_structure'></span>

<h3>Description</h3>

<p>Extract unique factor structures across the k-folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_structure(models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_structure_+3A_models">models</code></td>
<td>
<p>An object returned from <code><a href="#topic+kfa">kfa</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the number of folds the unique factor structure was tested for each factor model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example.kfa)
model_structure(example.kfa)

</code></pre>

<hr>
<h2 id='run_efa'>Conducts exploratory factor analysis</h2><span id='topic+run_efa'></span>

<h3>Description</h3>

<p>This function is intended for use on independent samples rather than integrated
with k-fold cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_efa(
  data,
  variables = names(data),
  m = floor(ncol(data)/4),
  rotation = "oblimin",
  simple = TRUE,
  min.loading = NA,
  single.item = c("keep", "drop", "none"),
  identified = TRUE,
  constrain0 = FALSE,
  ordered = FALSE,
  estimator = NULL,
  missing = "listwise",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_efa_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> containing the variables (i.e., items) to factor analyze</p>
</td></tr>
<tr><td><code id="run_efa_+3A_variables">variables</code></td>
<td>
<p>character vector of column names in <code>data</code> indicating the variables to factor analyze. Default is to use all columns.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_m">m</code></td>
<td>
<p>integer; maximum number of factors to extract. Default is 4 items per factor.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_rotation">rotation</code></td>
<td>
<p>character (case-sensitive); any rotation method listed in
<code><a href="GPArotation.html#topic+rotations">rotations</a></code> in the <code>GPArotation</code> package. Default is &quot;oblimin&quot;.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_simple">simple</code></td>
<td>
<p>logical; Should the perfect simple structure be returned (default) when converting EFA results to CFA syntax?
If <code>FALSE</code>, items can cross-load on multiple factors.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_min.loading">min.loading</code></td>
<td>
<p>numeric between 0 and 1 indicating the minimum (absolute) value of the loading for a variable on a factor
when converting EFA results to CFA syntax. Must be specified when <code>simple = FALSE</code>.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_single.item">single.item</code></td>
<td>
<p>character indicating how single-item factors should be treated.
Use <code>"keep"</code> (default) to keep them in the model when generating the CFA syntax, <code>"drop"</code>
to remove them, or <code>"none"</code> indicating the CFA syntax should not be generated for
this model and <code>""</code> is returned.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_identified">identified</code></td>
<td>
<p>logical; Should identification check for rotational uniqueness a la Millsap (2001) be performed?
If the model is not identified <code>""</code> is returned.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_constrain0">constrain0</code></td>
<td>
<p>logical; Should variable(s) with all loadings below <code>min.loading</code> still be included in model syntax?
If <code>TRUE</code>, variable(s) will load onto first factor with the loading constrained to 0.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_ordered">ordered</code></td>
<td>
<p>logical; Should items be treated as ordinal and the
polychoric correlations used in the factor analysis? When <code>FALSE</code> (default)
the Pearson correlation matrix is used. A character vector of item names is
also accepted to prompt estimation of the polychoric correlation matrix.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_estimator">estimator</code></td>
<td>
<p>if <code>ordered = FALSE</code>, the default is &quot;MLMVS&quot;. If
<code>ordered = TRUE</code>, the default is &quot;WLSMV&quot;. See <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code> for other options.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_missing">missing</code></td>
<td>
<p>default is &quot;listwise&quot;. See <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code> for other options.</p>
</td></tr>
<tr><td><code id="run_efa_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>lavaan</code> functions. See <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When converting EFA results to CFA syntax (via <code><a href="#topic+efa_cfa_syntax">efa_cfa_syntax</a></code>), the simple structure is
defined as each variable loading onto a single factor. This is determined using the largest factor loading for each variable.
When <code>simple = FALSE</code>, variables are allowed to cross-load on multiple factors. In this case, all pathways with loadings
above the <code>min.loading</code> are retained. However, allowing cross-loading variables can result in model under-identification.
An identification check is run by default, but can be turned off by setting <code>identified = FALSE</code>.
</p>


<h3>Value</h3>

<p>A three-element <code>list</code>:
</p>

<ul>
<li> <p><strong>efas</strong> <code>lavaan</code> object for each <em>m</em> model
</p>
</li>
<li> <p><strong>loadings</strong> (rotated) factor loading matrix for each <em>m</em> model
</p>
</li>
<li> <p><strong>cfa.syntax</strong> CFA syntax generated from loadings
</p>
</li></ul>



<h3>References</h3>

<p>Millsap, R. E. (2001). When trivial constraints are not trivial: The choice of uniqueness constraints in confirmatory factor analysis. <em>Structural Equation Modeling, 8</em>(1), 1-17. <a href="https://doi.org/10.1207/S15328007SEM0801_1">doi:10.1207/S15328007SEM0801_1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate data based on a 3-factor model with standardized loadings
sim.mod &lt;- "f1 =~ .7*x1 + .8*x2 + .3*x3 + .7*x4 + .6*x5 + .8*x6 + .4*x7
                f2 =~ .8*x8 + .7*x9 + .6*x10 + .5*x11 + .5*x12 + .7*x13 + .6*x14
                f3 =~ .6*x15 + .5*x16 + .9*x17 + .4*x18 + .7*x19 + .5*x20
                f1 ~~ .2*f2
                f2 ~~ .2*f3
                f1 ~~ .2*f3
                x9 ~~ .2*x10"
set.seed(1161)
sim.data &lt;- simstandard::sim_standardized(sim.mod, n = 900,
                                          latent = FALSE,
                                          errors = FALSE)[c(2:9,1,10:20)]
# Run 1-, 2-, and 3-factor models
efas &lt;- run_efa(sim.data, m = 3)

</code></pre>

<hr>
<h2 id='write_efa'>Write exploratory factor analysis syntax</h2><span id='topic+write_efa'></span>

<h3>Description</h3>

<p>Converts variable names to lavaan-compatible exploratory factor analysis syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_efa(nf, vnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_efa_+3A_nf">nf</code></td>
<td>
<p>integer; number of factors</p>
</td></tr>
<tr><td><code id="write_efa_+3A_vnames">vnames</code></td>
<td>
<p>character vector; names of variables to include in the efa</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character. Use <code>cat()</code> to best examine the returned syntax.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vnames &lt;- paste("x", 1:10)
syntax &lt;- write_efa(nf = 2, vnames = vnames)
cat(syntax)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
