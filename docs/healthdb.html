<!DOCTYPE html><html><head><title>Help for package healthdb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {healthdb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#healthdb-package'><p>healthdb: Working with Healthcare Databases</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#bind_source'><p>Row-bind a list of data.frames or remote tables with variable selection and renaming</p></a></li>
<li><a href='#build_def'><p>Build case definition function calls</p></a></li>
<li><a href='#collapse_episode'><p>Group records no more than n days apart as episodes</p></a></li>
<li><a href='#compute_comorbidity'><p>Compute Elixhauser Comorbidity Index</p></a></li>
<li><a href='#compute_duration'><p>Compute duration between two dates</p></a></li>
<li><a href='#cut_period'><p>Cut the time period in one row into multiple rows by interval</p></a></li>
<li><a href='#define_case'><p>Identify diseases/events from administrative records</p></a></li>
<li><a href='#exclude'><p>Remove rows based on conditions or another data set</p></a></li>
<li><a href='#execute_def'><p>Execute parameterized case definitions</p></a></li>
<li><a href='#fetch_var'><p>Get variables from multiple tables with common ID columns</p></a></li>
<li><a href='#identify_row'><p>Identify rows with a match</p></a></li>
<li><a href='#if_date'><p>Interpret if any n elements drawn from a date vector could be some days apart within some time span</p></a></li>
<li><a href='#lookup'><p>Find value corresponding to the input vector using a look-up table</p></a></li>
<li><a href='#make_test_dat'><p>Make test data</p></a></li>
<li><a href='#pool_case'><p>Pool qualified clients from results of multiple definitions</p></a></li>
<li><a href='#report_n'><p>Report number of distinct value in a column across data frames</p></a></li>
<li><a href='#restrict_date'><p>Remove or flag groups failed to meet conditions based on dates</p></a></li>
<li><a href='#restrict_n'><p>Remove or flag groups with n less than some number</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Working with Healthcare Databases</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A system for identifying diseases or events from healthcare databases and
    preparing data for epidemiological studies. It includes capabilities not
    supported by 'SQL', such as matching strings by 'stringr' style regular
    expressions, and can compute comorbidity scores (Quan et al. (2005)
    &lt;<a href="https://doi.org/10.1097%2F01.mlr.0000182534.19832.83">doi:10.1097/01.mlr.0000182534.19832.83</a>&gt;) directly on a database server. The
    implementation is based on 'dbplyr' with full 'tidyverse' compatibility.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>clock, data.table, dbplyr (&ge; 2.5.0), dplyr (&ge; 1.1.0), glue,
lubridate, magrittr, purrr, rlang, stringr (&ge; 1.5.0), tidyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/KevinHzq/healthdb">https://github.com/KevinHzq/healthdb</a>,
<a href="https://kevinhzq.github.io/healthdb/">https://kevinhzq.github.io/healthdb/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/KevinHzq/healthdb/issues">https://github.com/KevinHzq/healthdb/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), withr, RSQLite</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-23 01:23:29 UTC; kevin.hu</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin Hu <a href="https://orcid.org/0000-0003-0254-5277"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin Hu &lt;kevin.hu@bccdc.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-23 02:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='healthdb-package'>healthdb: Working with Healthcare Databases</h2><span id='topic+healthdb'></span><span id='topic+healthdb-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A system for identifying diseases or events from healthcare databases and preparing data for epidemiological studies. It includes capabilities not supported by 'SQL', such as matching strings by 'stringr' style regular expressions, and can compute comorbidity scores (Quan et al. (2005) <a href="https://doi.org/10.1097/01.mlr.0000182534.19832.83">doi:10.1097/01.mlr.0000182534.19832.83</a>) directly on a database server. The implementation is based on 'dbplyr' with full 'tidyverse' compatibility.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kevin Hu <a href="mailto:kevin.hu@bccdc.ca">kevin.hu@bccdc.ca</a> (<a href="https://orcid.org/0000-0003-0254-5277">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/KevinHzq/healthdb">https://github.com/KevinHzq/healthdb</a>
</p>
</li>
<li> <p><a href="https://kevinhzq.github.io/healthdb/">https://kevinhzq.github.io/healthdb/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/KevinHzq/healthdb/issues">https://github.com/KevinHzq/healthdb/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='bind_source'>Row-bind a list of data.frames or remote tables with variable selection and renaming</h2><span id='topic+bind_source'></span>

<h3>Description</h3>

<p>Row bind a list of data.frames or remote tables with variable selection and renaming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_source(data, ..., force_proceed = getOption("healthdb.force_proceed"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_source_+3A_data">data</code></td>
<td>
<p>A list of data.frame or remote tables, e.g., output from <code><a href="#topic+execute_def">execute_def()</a></code>.</p>
</td></tr>
<tr><td><code id="bind_source_+3A_...">...</code></td>
<td>
<p>Named arguments for each variable included in the output. The argument name should be the new name in the output, and the right hand side of the argument is a character vector of the original names. The name vector and the list elements in <code>data</code> will be matched by position. if an output variable only came from some of the sources, fill the name vector to a length equal to the number of sources with NA, e.g., <code>var</code> only come from the second out of three sources, then <code>var = c(NA, 'nm_in_src2', NA)</code>.</p>
</td></tr>
<tr><td><code id="bind_source_+3A_force_proceed">force_proceed</code></td>
<td>
<p>A logical for whether to ask for user input in order to proceed when remote tables are needed to be collected for binding. The default is FALSE to let user be aware of that the downloading process may be slow. Use <code>options(healthdb.force_proceed = TRUE)</code> to suppress the prompt once and for all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or remote table containing combined rows of the input list with variables specified by ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- subset(iris, Species == "setosa")
df2 &lt;- subset(iris, Species == "versicolor")
df3 &lt;- subset(iris, Species == "virginica")

bind_source(list(df1, df2, df3),
  s_l = "Sepal.Length",
  s_w = "Sepal.Width",
  p_l_setosa = c("Petal.Length", NA, NA),
  p_l_virginica = c(NA, NA, "Petal.Length")
) %&gt;%
head()
</code></pre>

<hr>
<h2 id='build_def'>Build case definition function calls</h2><span id='topic+build_def'></span>

<h3>Description</h3>

<p>This function assembles function calls from the supplied functions and their required arguments, leaving the data argument empty for easy re-use of the definition calls with different data and batch execution (see <code><a href="#topic+execute_def">execute_def()</a></code> for detail). It is useful for defining multiple diseases/events across multiple sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_def(def_lab, src_labs, def_fn = define_case, fn_args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_def_+3A_def_lab">def_lab</code></td>
<td>
<p>A single character label for the definition, e.g., some disease.</p>
</td></tr>
<tr><td><code id="build_def_+3A_src_labs">src_labs</code></td>
<td>
<p>A character vector of place-holder names for the data sources that will be used to execute the definition.</p>
</td></tr>
<tr><td><code id="build_def_+3A_def_fn">def_fn</code></td>
<td>
<p>A list of functions (default: <code><a href="#topic+define_case">define_case()</a></code>) that will filter the source data sets and keep clients met the case definition. The length of the list should be either 1 or equal to the length of <code>src_labs</code>. If length = 1, the same function will be applied to all sources; otherwise, <code>def_fn</code> should match <code>src_lab</code> by position. User can supply custom functions but must put input data as the first argument and name it <code>data</code>.</p>
</td></tr>
<tr><td><code id="build_def_+3A_fn_args">fn_args</code></td>
<td>
<p>A named list of arguments passing to the <code>def_fn</code>. Each element in the list should have the same name as an argument in the source-specific <code>def_fn</code>, and the element length should also be either 1 or equal to the number of sources. If you have <code>def_fn</code> functions taking different sets of arguments, include the union in one list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with a number of rows equal to the length of <code>src_labs</code>, containing the input arguments and the synthetic function call in the <code>fn_call</code> column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sud_def &lt;- build_def("SUD", # usually a disease name
  src_lab = c("src1", "src2"), # identify from multiple sources, e.g., hospitalization, ED visits.
  # functions that filter the data with some criteria,
  # including mean here for src2 as a trivial example
  # to show only valid arguments will be in the call
  def_fn = list(define_case, mean),
  fn_args = list(
    vars = list(starts_with("diagx"), "diagx_2"),
    match = "start", # "start" will be applied to all sources as length = 1
    vals = list(c("304"), c("305")),
    clnt_id = "clnt_id",
    # c() can be used in place of list
    # if this argument only takes one value for each source
    n_per_clnt = c(2, 3),
    x = list(1:10) # src2 with mean as def_fn will only accept this argument
  )
)

# the result is a tibble
sud_def

# the fn_call column stores the code that can be ran with execute_def
sud_def#fn_call
</code></pre>

<hr>
<h2 id='collapse_episode'>Group records no more than n days apart as episodes</h2><span id='topic+collapse_episode'></span>

<h3>Description</h3>

<p>This function is useful for collapsing, e.g., medication dispensation or hospitalization, records into episodes if the records' dates are no more than n days gap apart. The length of the gap can be relaxed by another grouping variable. This function is implemented for data.frame input only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_episode(
  data,
  clnt_id,
  start_dt,
  end_dt = NULL,
  gap,
  overwrite = NULL,
  gap_overwrite = Inf,
  .dt_trans = data.table::as.IDate,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_episode_+3A_data">data</code></td>
<td>
<p>A data.frame that contains the id and date variables.</p>
</td></tr>
<tr><td><code id="collapse_episode_+3A_clnt_id">clnt_id</code></td>
<td>
<p>Column name of subject/person ID.</p>
</td></tr>
<tr><td><code id="collapse_episode_+3A_start_dt">start_dt</code></td>
<td>
<p>Column name of the starting date of records.</p>
</td></tr>
<tr><td><code id="collapse_episode_+3A_end_dt">end_dt</code></td>
<td>
<p>Column name of the end date of records. The default is NULL assuming the record last one day and only the start date will be used to calculate the gaps between records.</p>
</td></tr>
<tr><td><code id="collapse_episode_+3A_gap">gap</code></td>
<td>
<p>A number in days that will be used to separate episodes. For example, gap = 7 means collapsing records no more than 7 days apart. Note that the number of days apart will be calculated as numeric difference between two days, so that Monday and Sunday is considered as 6 days apart.</p>
</td></tr>
<tr><td><code id="collapse_episode_+3A_overwrite">overwrite</code></td>
<td>
<p>Column name of a grouping variable determining whether the consecutive records are related and should have a different gap value. For example, dispensing records may have the same original prescription number, and a different gap value can be assigned for such situation, e.g., the days between two records is &gt; gap, but these records still belong to the same prescription.</p>
</td></tr>
<tr><td><code id="collapse_episode_+3A_gap_overwrite">gap_overwrite</code></td>
<td>
<p>A different gap value used for related records. The default is Inf, which means all records with the same overwrite variable will be collapsed.</p>
</td></tr>
<tr><td><code id="collapse_episode_+3A_.dt_trans">.dt_trans</code></td>
<td>
<p>Function to transform start_dt/end_dt. Default is <code><a href="data.table.html#topic+IDateTime">data.table::as.IDate()</a></code>.</p>
</td></tr>
<tr><td><code id="collapse_episode_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to the .dt_trans function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data.frame with new columns indicating episode grouping. The new variables include:
</p>

<ul>
<li><p> epi_id: unique identifier of episodes across the whole data set
</p>
</li>
<li><p> epi_no: identifier of episodes within a client/group
</p>
</li>
<li><p> epi_seq: identifier of records within an episode
</p>
</li>
<li><p> epi_start/stop_dt: start and end dates corresponding to epi_id
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># make toy data
df &lt;- make_test_dat() %&gt;%
dplyr::select(clnt_id, dates)

head(df)

# collapse records no more than 90 days apart
# end_dt could be absent then it is assumed to be the same as start_dt
collapse_episode(df, clnt_id, start_dt = dates, gap = 90)
</code></pre>

<hr>
<h2 id='compute_comorbidity'>Compute Elixhauser Comorbidity Index</h2><span id='topic+compute_comorbidity'></span>

<h3>Description</h3>

<p>This function computes unweighted Elixhauser Comorbidity Index for both data.frame and remote table input. The ICD codes used to identify the 31 disease categories is from Quan et al. (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_comorbidity(
  data,
  vars,
  icd_ver = c("ICD-10", "ICD-9-CM-3digits", "ICD-9-CM-5digits"),
  clnt_id,
  uid = NULL,
  sum_by = c("row", "clnt"),
  excl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_comorbidity_+3A_data">data</code></td>
<td>
<p>Data.frames or remote tables (e.g., from <code><a href="dbplyr.html#topic+tbl_sql">dbplyr::tbl_sql()</a></code>)</p>
</td></tr>
<tr><td><code id="compute_comorbidity_+3A_vars">vars</code></td>
<td>
<p>An expression passing to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. It can be quoted/unquoted column names, or helper functions, such as <code><a href="dplyr.html#topic+reexports">dplyr::starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="compute_comorbidity_+3A_icd_ver">icd_ver</code></td>
<td>
<p>One of <code>c("ICD-10", "ICD-9-CM-3digits", "ICD-9-CM-5digits")</code>. Specify the ICD code version used in <code>data</code>. The ICD-10 and ICD-9-CM 5 digits version are from Quan et al. (2005). The ICD-9-CM 3 digits version is adopted from Manitoba Centre for Health Policy. It uses BOTH 3-digit and 5-digit codes in search. See their web page for cautions and limitations of the 3 digit version if your data only has 3-digit codes (<a href="http://mchp-appserv.cpe.umanitoba.ca/viewConcept.php?printer=Y&amp;conceptID=1436#CAUTIONS">http://mchp-appserv.cpe.umanitoba.ca/viewConcept.php?printer=Y&amp;conceptID=1436#CAUTIONS</a>).</p>
</td></tr>
<tr><td><code id="compute_comorbidity_+3A_clnt_id">clnt_id</code></td>
<td>
<p>Grouping variable (quoted/unquoted).</p>
</td></tr>
<tr><td><code id="compute_comorbidity_+3A_uid">uid</code></td>
<td>
<p>Variable name for a unique row identifier. It is necessary for SQL to produce consistent result based on sorting.</p>
</td></tr>
<tr><td><code id="compute_comorbidity_+3A_sum_by">sum_by</code></td>
<td>
<p>One of &quot;row&quot; or &quot;clnt&quot;. The &quot;row&quot; option computes total score for each row (default), and the &quot;clnt&quot; option summarizes total score by <code>clnt_id</code>. Each disease categories will be counted only once in the calculation regardless of multiple records in a category.</p>
</td></tr>
<tr><td><code id="compute_comorbidity_+3A_excl">excl</code></td>
<td>
<p>A character vector of disease categories labels that should be excluded in the total score calculation. This is useful when some of the categories are the exposure/outcome of interest, and the goal is to measure comorbidity excluding these disease. See detail for a list of the categories and labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of disease categories - labels (in quote):
</p>

<ol>
<li><p> Congestive Heart Failure - &quot;chf&quot;
</p>
</li>
<li><p> Cardiac Arrhythmia - &quot;arrhy&quot;
</p>
</li>
<li><p> Valvular Disease - &quot;vd&quot;
</p>
</li>
<li><p> Pulmonary Circulation Disorders - &quot;pcd&quot;
</p>
</li>
<li><p> Peripheral Vascular Disorders - &quot;pvd&quot;
</p>
</li>
<li><p> Hypertension Uncomplicated - &quot;hptn_nc&quot;
</p>
</li>
<li><p> Hypertension complicated - &quot;hptn_C&quot;
</p>
</li>
<li><p> Paralysis - &quot;para&quot;
</p>
</li>
<li><p> Other Neurological Disorders - &quot;Othnd&quot;
</p>
</li>
<li><p> Chronic Pulmonary Disease - &quot;copd&quot;
</p>
</li>
<li><p> Diabetes Uncomplicated - &quot;diab_nc&quot;
</p>
</li>
<li><p> Diabetes Complicated - &quot;diab_c&quot;
</p>
</li>
<li><p> Hypothyroidism - &quot;hptothy&quot;
</p>
</li>
<li><p> Renal Failure - &quot;rf&quot;
</p>
</li>
<li><p> Liver Disease - &quot;ld&quot;
</p>
</li>
<li><p> Peptic Ulcer Disease excluding bleeding - &quot;pud_nb&quot;
</p>
</li>
<li><p> AIDS/HIV - &quot;hiv&quot;
</p>
</li>
<li><p> Lymphoma - &quot;lymp&quot;
</p>
</li>
<li><p> Metastatic Cancer - &quot;mets&quot;
</p>
</li>
<li><p> Solid Tumor without Metastasis - &quot;tumor&quot;
</p>
</li>
<li><p> Rheumatoid Arthritis/collagen - &quot;rheum_a&quot;
</p>
</li>
<li><p> Coagulopathy - &quot;coag&quot;
</p>
</li>
<li><p> Obesity - &quot;obesity&quot;
</p>
</li>
<li><p> Weight Loss - &quot;wl&quot;
</p>
</li>
<li><p> Fluid and Electrolyte Disorders - &quot;fluid&quot;
</p>
</li>
<li><p> Blood Loss Anemia - &quot;bla&quot;
</p>
</li>
<li><p> Deficiency Anemia - &quot;da&quot;
</p>
</li>
<li><p> Alcohol Abuse - &quot;alcohol&quot;
</p>
</li>
<li><p> Drug Abuse - &quot;drug&quot;
</p>
</li>
<li><p> Psychoses - &quot;psycho&quot;
</p>
</li>
<li><p> Depression - &quot;dep&quot;
</p>
</li></ol>



<h3>Value</h3>

<p>A data.frame or remote table with binary indicators for each categories as columns.
</p>


<h3>References</h3>

<p>Quan H, Sundararajan V, Halfon P, Fong A, Burnand B, Luthi JC, Saunders LD, Beck CA, Feasby TE, Ghali WA. Coding algorithms for defining comorbidities in ICD-9-CM and ICD-10 administrative data. Med Care 2005;43(11):1130-1139.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make ICD-9 toy data
df &lt;- data.frame(
  uid = 1:10, clnt_id = sample(1:3, 10, replace = TRUE),
  diagx_1 = c("193", "2780", "396", "4254", "4150", "401", "401", "0932", "5329", "2536"),
  diagx_2 = c(NA, NA, "72930", "V6542", "493", "405", "5880", "2409", "714", NA)
)

# compute Elixhauser Comorbidity Index by row
# uid is needed for by row calculation
# 3 categories were excluded in total_eci
compute_comorbidity(df,
  vars = starts_with("diagx"),
  icd_ver = "ICD-9-CM-5digits",
  clnt_id = clnt_id, uid = uid,
  excl = c("drug", "psycho", "dep")
)

# compute ECI by person
compute_comorbidity(df,
  vars = starts_with("diagx"),
  icd_ver = "ICD-9-CM-5digits",
  clnt_id = clnt_id,
  sum_by = "clnt"
)
</code></pre>

<hr>
<h2 id='compute_duration'>Compute duration between two dates</h2><span id='topic+compute_duration'></span>

<h3>Description</h3>

<p>This function is meant to be for data frame input only and used with <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> to compute age or duration between two character or Date columns. If a vector of breaks is given, the output will be converted to factor with labels generated automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_duration(
  from,
  to,
  lower_brks = NULL,
  unit = c("year", "day", "week", "month"),
  trans = FALSE,
  .transfn = lubridate::ymd,
  verbose = getOption("healthdb.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_duration_+3A_from">from</code></td>
<td>
<p>A character or Date vector for start dates.</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_to">to</code></td>
<td>
<p>A character or Date vector for end dates.</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_lower_brks">lower_brks</code></td>
<td>
<p>A numeric vector for lower breaks passing to the base <code><a href="base.html#topic+cut">base::cut()</a></code> function to convert the numeric result to a factor. The level labels will be auto generated. For example, the level labels are <code>c("&lt;19", "19-24", "25-34", "35-44", "45-54", "55+")</code> for <code>lower_brks = c(0, 19, 25, 35, 45, 55)</code>. Default is NULL (no conversion).</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_unit">unit</code></td>
<td>
<p>A character string specifying the unit of the output. One of &quot;year&quot; (default), &quot;day&quot;, &quot;week&quot;, or &quot;month&quot;.</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_trans">trans</code></td>
<td>
<p>A logical for whether transform both <code>from</code> and <code>to</code> with the <code>.transfn</code> function</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_.transfn">.transfn</code></td>
<td>
<p>A function for transforming the inputs. Default is <code><a href="lubridate.html#topic+ymd">lubridate::ymd()</a></code>.</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_verbose">verbose</code></td>
<td>
<p>A logical for whether print summary of the out and warning for missing values. Default is fetching from options. Use <code>options(healthdb.verbose = FALSE)</code> to suppress once and for all.</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to <code><a href="base.html#topic+cut">base::cut()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or factor vector of the duration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy data
n &lt;- 5
df &lt;- data.frame(id = 1:n,
start_dt = sample(seq(as.Date("1970-01-01"), as.Date("2000-12-31"), by = 1), size = n),
end_dt = sample(seq(as.Date("2001-01-01"), as.Date("2023-12-31"), by = 1), size = n))

# get age group at a cut-off
df %&gt;% dplyr::mutate(
 age_grp = compute_duration(start_dt, "2023-01-01", lower_brks = c(0, 19, 25, 35, 45, 55))
)

# compute gaps between two dates in weeks
df %&gt;% dplyr::mutate(
 gap_wks = compute_duration(start_dt, end_dt, unit = "week")
)
</code></pre>

<hr>
<h2 id='cut_period'>Cut the time period in one row into multiple rows by interval</h2><span id='topic+cut_period'></span>

<h3>Description</h3>

<p>This function is for cutting time periods into segments, which could be useful for subsequent overlap joins. Each original period (per row) will be expanded to multiple rows by weeks, months, etc. Only data.frame input is accepted as the output size is greater than the input. Thus, remote tables should be collected before running this function for optimal performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_period(
  data,
  start,
  end,
  len,
  unit = c("day", "week", "month", "quarter", "year"),
  .dt_trans = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_period_+3A_data">data</code></td>
<td>
<p>Input data.frame that each row has start and end dates</p>
</td></tr>
<tr><td><code id="cut_period_+3A_start">start</code></td>
<td>
<p>Record start date column (unquoted)</p>
</td></tr>
<tr><td><code id="cut_period_+3A_end">end</code></td>
<td>
<p>Record end date column (unquoted)</p>
</td></tr>
<tr><td><code id="cut_period_+3A_len">len</code></td>
<td>
<p>An integer, the interval that would be used to divide the record duration</p>
</td></tr>
<tr><td><code id="cut_period_+3A_unit">unit</code></td>
<td>
<p>One of &quot;day&quot; (default), &quot;week&quot;, &quot;month&quot;, &quot;quarter, or &quot;year&quot; used in combination of <code>len</code> to specify the time length of the interval.</p>
</td></tr>
<tr><td><code id="cut_period_+3A_.dt_trans">.dt_trans</code></td>
<td>
<p>Function to transform start/end, such as <code><a href="lubridate.html#topic+ymd">lubridate::ymd()</a></code>. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame that each row is now a segment of the period defined by <code>c(start, end)</code> in the original row. Original variables are retained and repeated for each segment plus new variables defining the segment interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy data
df &lt;- data.frame(sample_id = 1, period_id = 1, start_date = "2015-01-01", end_date = "2019-12-31")

# divide period into segments (multiple rows per period)
df_seg &lt;- cut_period(
  data = df, start = start_date, end = end_date,
  len = 1,
  unit = "year",
  .dt_trans = lubridate::ymd
)

# categorize segment_id as factor
df_seg$segment &lt;- cut(df_seg$segment_id,
  breaks = c(0, 1, 2, Inf),
  labels = c("&lt; 1 year", "1 - 2 years", "Remainder")
)

head(df_seg)
</code></pre>

<hr>
<h2 id='define_case'>Identify diseases/events from administrative records</h2><span id='topic+define_case'></span>

<h3>Description</h3>

<p>This function is a composite of <code><a href="#topic+identify_row">identify_row()</a></code>, <code><a href="#topic+exclude">exclude()</a></code>, <code><a href="#topic+restrict_n">restrict_n()</a></code>, and <code><a href="#topic+restrict_date">restrict_date()</a></code>. It is aimed to implement common case definitions in epidemiological studies using administrative database as a one-shot big query. The intended use case is for definitions in the form of, e.g., two or more physician visits with some diagnostic code at least 30 days apart within two years. The component functions mentioned above are chained in the following order if all arguments were supplied: <code>identify_row(vals) %&gt;% exclude(identify_row(excl_vals), by = clnt_id) %&gt;% restrict_n() %&gt;% restrict_date()</code>. Only necessary steps in the chain will be ran if some arguments are missing, see the verbose output for what was done. Note that if <code>date_var</code> is supplied, <code>n_per_clnt</code> will be counted by distinct dates instead of number of records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_case(
  data,
  vars,
  match = "in",
  vals,
  clnt_id,
  n_per_clnt = 1,
  date_var = NULL,
  apart = NULL,
  within = NULL,
  uid = NULL,
  excl_vals = NULL,
  excl_args = NULL,
  keep = c("all", "first", "last"),
  if_all = FALSE,
  mode = c("flag", "filter"),
  force_collect = FALSE,
  verbose = getOption("healthdb.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_case_+3A_data">data</code></td>
<td>
<p>Data.frames or remote tables (e.g., from <code><a href="dbplyr.html#topic+tbl_sql">dbplyr::tbl_sql()</a></code>)</p>
</td></tr>
<tr><td><code id="define_case_+3A_vars">vars</code></td>
<td>
<p>An expression passing to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. It can be quoted/unquoted column names, or helper functions, such as <code><a href="dplyr.html#topic+reexports">dplyr::starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="define_case_+3A_match">match</code></td>
<td>
<p>One of &quot;in&quot;, &quot;start&quot;, &quot;regex&quot;, &quot;like&quot;, &quot;between&quot;, and &quot;glue_sql&quot;. It determines how values would be matched. See <code><a href="#topic+identify_row">identify_row()</a></code> for detail.</p>
</td></tr>
<tr><td><code id="define_case_+3A_vals">vals</code></td>
<td>
<p>Depending on <code>match</code>, it takes different input. See <code><a href="#topic+identify_row">identify_row()</a></code>.</p>
</td></tr>
<tr><td><code id="define_case_+3A_clnt_id">clnt_id</code></td>
<td>
<p>Grouping variable (quoted/unquoted).</p>
</td></tr>
<tr><td><code id="define_case_+3A_n_per_clnt">n_per_clnt</code></td>
<td>
<p>A single number specifying the minimum number of group size.</p>
</td></tr>
<tr><td><code id="define_case_+3A_date_var">date_var</code></td>
<td>
<p>Variable name (quoted/unquoted) for the dates to be interpreted.</p>
</td></tr>
<tr><td><code id="define_case_+3A_apart">apart</code></td>
<td>
<p>An integer specifying the minimum gap (in days) between adjacent dates in a draw.</p>
</td></tr>
<tr><td><code id="define_case_+3A_within">within</code></td>
<td>
<p>An integer specifying the maximum time span (in days) of a draw.</p>
</td></tr>
<tr><td><code id="define_case_+3A_uid">uid</code></td>
<td>
<p>Variable name for a unique row identifier. It is necessary for SQL to produce consistent result based on sorting.</p>
</td></tr>
<tr><td><code id="define_case_+3A_excl_vals">excl_vals</code></td>
<td>
<p>Same as <code>vals</code> but clients/groups with these values are going to be removed from the result. This is intended for exclusion criteria of a case definition.</p>
</td></tr>
<tr><td><code id="define_case_+3A_excl_args">excl_args</code></td>
<td>
<p>A named list of arguments passing to the second <code><a href="#topic+identify_row">identify_row()</a></code> call for <code>excl_vals</code>. If not supplied, <code>var</code>, <code>match</code> and <code>if_all</code> of the first call will be re-used.</p>
</td></tr>
<tr><td><code id="define_case_+3A_keep">keep</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> &quot;first&quot; (keeping each client's earliest record),
</p>
</li>
<li><p> &quot;last&quot; (keeping the latest),
</p>
</li>
<li><p> and &quot;all&quot; (keeping all relevant records, default).
</p>
</li>
<li><p> Note that &quot;first&quot;/&quot;last&quot; should not be used with &quot;flag&quot; mode.
</p>
</li></ul>
</td></tr>
<tr><td><code id="define_case_+3A_if_all">if_all</code></td>
<td>
<p>A logical for whether combining the predicates (if multiple columns were selected by vars) with AND instead of OR. Default is FALSE, e.g., var1 in vals OR var2 in vals.</p>
</td></tr>
<tr><td><code id="define_case_+3A_mode">mode</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> &quot;flag&quot; - add new columns starting with &quot;flag_&quot; indicating if the client met the condition,
</p>
</li>
<li><p> or &quot;filter&quot; - remove clients that did not meet the condition from the data.
</p>
</li>
<li><p> This will be passed to both <code><a href="#topic+restrict_n">restrict_n()</a></code> AND <code><a href="#topic+restrict_date">restrict_date()</a></code>. Default is &quot;flag&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="define_case_+3A_force_collect">force_collect</code></td>
<td>
<p>A logical for whether force downloading the result table if it is not a local data.frame. Downloading data could be slow, so the user has to opt in; default is FALSE.</p>
</td></tr>
<tr><td><code id="define_case_+3A_verbose">verbose</code></td>
<td>
<p>A logical for whether printing explanation for the operation. Default is fetching from options. Use <code>options(healthdb.verbose = FALSE)</code> to suppress once and for all.</p>
</td></tr>
<tr><td><code id="define_case_+3A_...">...</code></td>
<td>
<p>Additional arguments, e.g., <code>mode</code>, passing to <code><a href="#topic+restrict_date">restrict_date()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of input data satisfied the specified case definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_size &lt;- 30
df &lt;- data.frame(
  clnt_id = rep(1:3, each = 10),
  service_dt = sample(seq(as.Date("2020-01-01"), as.Date("2020-01-31"), by = 1),
    size = sample_size, replace = TRUE
  ),
  diagx = sample(letters, size = sample_size, replace = TRUE),
  diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),
  diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE)
)

# define from one source
define_case(df,
  vars = starts_with("diagx"), "in", vals = letters[1:4],
  clnt_id = clnt_id, date_var = service_dt,
  excl_args = list(if_all = TRUE),
  # remove non-case
  mode = "filter",
  # keeping the first record
  keep = "first"
)

# multiple sources with purrr::pmap
# arguments with length = 1 will be recycle to match the number of sources
# wrap expressions/unquoted variables with bquote(),
# or rlang:exprs() to prevent immediate evaluation,
# or just use quoted variable names
purrr::pmap(
  list(
    data = list(df, df),
    vars = rlang::exprs(starts_with("diagx")),
    match = c("in", "start"),
    vals = list(letters[1:4], letters[5:10]),
    clnt_id = list(bquote(clnt_id)), n_per_clnt = c(2, 3),
    date_var = "service_dt",
    excl_vals = list(letters[11:13], letters[14:16]),
    excl_args = list(list(if_all = TRUE), list(if_all = FALSE))
  ),
  define_case
)
</code></pre>

<hr>
<h2 id='exclude'>Remove rows based on conditions or another data set</h2><span id='topic+exclude'></span>

<h3>Description</h3>

<p>This function combines <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code>, and negation of <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>. When a second data set is supplied through the <code>excl</code> argument, anti join would be performed; otherwise, <code>data</code> would be filtered with the expression given via the <code>condition</code> argument, and the filter result would in turn be removed using <code><a href="dplyr.html#topic+setops">dplyr::setdiff()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclude(
  data,
  excl = NULL,
  by = NULL,
  condition = NULL,
  verbose = getOption("healthdb.verbose"),
  report_on = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exclude_+3A_data">data</code></td>
<td>
<p>Data.frames or remote tables (e.g., from <code><a href="dbplyr.html#topic+tbl_sql">dbplyr::tbl_sql()</a></code>). A subset will be removed from this data.</p>
</td></tr>
<tr><td><code id="exclude_+3A_excl">excl</code></td>
<td>
<p>Data frames or remote tables (e.g., from 'dbplyr'). Rows/values present in it will be removed from <code>data</code> if there is a match. This will be passed to <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code> as the second argument.</p>
</td></tr>
<tr><td><code id="exclude_+3A_by">by</code></td>
<td>
<p>Column names that should be matched by <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code>, or a expressions with <code><a href="dplyr.html#topic+join_by">dplyr::join_by()</a></code>. See <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code>'s <code>by</code> argument for detail. Default NULL is the same as <code>setdiff(data, excl)</code>.</p>
</td></tr>
<tr><td><code id="exclude_+3A_condition">condition</code></td>
<td>
<p>An expression that will be passed to <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>. The rows that satisfy <code>condition</code> are those to be removed from <code>data</code>.</p>
</td></tr>
<tr><td><code id="exclude_+3A_verbose">verbose</code></td>
<td>
<p>A logical for whether printing explanation for the operation. Default is fetching from options. Use <code>options(healthdb.verbose = FALSE)</code> to suppress once and for all.</p>
</td></tr>
<tr><td><code id="exclude_+3A_report_on">report_on</code></td>
<td>
<p>A quoted/unquoted column name for counting how many of its distinct values were removed from <code>data</code>, e.g., counting how many client IDs were removed. Default is NULL.</p>
</td></tr>
<tr><td><code id="exclude_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>/<code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code> for finer control of matching, e.g., na action, by-group filtering, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame or remote table that is a subset of <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># exclude with condition
cyl_not_4 &lt;- exclude(mtcars, condition = cyl == 4, report_on = cyl)

# exclude with another data
exclude(mtcars, cyl_not_4, dplyr::join_by(cyl), report_on = cyl)
</code></pre>

<hr>
<h2 id='execute_def'>Execute parameterized case definitions</h2><span id='topic+execute_def'></span>

<h3>Description</h3>

<p>This function executes the function calls stored in the output tibble from [build_def()] with data objects supplied through a named list and returns the results as a list. It is intended to facilitate re-use of pre-defined calls with different data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execute_def(
  def,
  with_data,
  bind = FALSE,
  force_proceed = getOption("healthdb.force_proceed")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="execute_def_+3A_def">def</code></td>
<td>
<p>A tibble created by [build_def()].</p>
</td></tr>
<tr><td><code id="execute_def_+3A_with_data">with_data</code></td>
<td>
<p>A named list which the elements are in the form of src_lab = data, where 'src_lab' corresponds to the src_labs argument from [build_def()] and 'data' is the data object that will be passed to calls stored in def. The names (and length) of 'with_data' must match the unique values of src_labs in 'def'.</p>
</td></tr>
<tr><td><code id="execute_def_+3A_bind">bind</code></td>
<td>
<p>A logical for whether row-binding records from multiple sources into one table. Note that the binding may fail in ways that are difficult to anticipate in advance, such as data type conflict (e.g., Date vs. character) between variables in the same name from different sources. The default is FALSE. If TRUE, the behavior is to try and return the unbinded result when failed.</p>
</td></tr>
<tr><td><code id="execute_def_+3A_force_proceed">force_proceed</code></td>
<td>
<p>A logical for whether to ask for user input in order to proceed when remote tables are needed to be collected for binding. The default is FALSE to let user be aware of that the downloading process may be slow. Use options(healthdb.force_proceed = TRUE) to suppress the prompt once and for all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single (if bind = TRUE) or a list of data.frames or remote tables.
</p>


<h3>See Also</h3>

<p>[bind_sources()] for binding the output with convenient renaming features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy data
sample_size &lt;- 30
df &lt;- data.frame(
  clnt_id = rep(1:3, each = 10),
  service_dt = sample(seq(as.Date("2020-01-01"), as.Date("2020-01-31"), by = 1),
    size = sample_size, replace = TRUE
  ),
  diagx = sample(letters, size = sample_size, replace = TRUE),
  diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),
  diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE)
)

# make df a database table
db &lt;- dbplyr::tbl_memdb(df)

# use build_def to make a toy definition
sud_def &lt;- build_def("SUD", # usually a disease name
  src_lab = c("src1", "src2"), # identify from multiple sources, e.g., hospitalization, ED visits.
  # functions that filter the data with some criteria
  def_fn = define_case,
  fn_args = list(
    vars = starts_with("diagx"),
    match = "start", # "start" will be applied to all sources as length = 1
    vals = list(c("304"), c("305")),
    clnt_id = "clnt_id", # list()/c() could be omitted for single element
    # c() can be used in place of list
    # if this argument only takes one value for each source
    n_per_clnt = c(2, 3)
  )
)

# save the definition for re-use
# saveRDS(sud_def, file = some_path)

sud_def %&gt;% execute_def(with_data = list(src1 = df, src2 = db), force_proceed = TRUE)
</code></pre>

<hr>
<h2 id='fetch_var'>Get variables from multiple tables with common ID columns</h2><span id='topic+fetch_var'></span>

<h3>Description</h3>

<p>This function fetches variables from different tables that linked by common IDs. It calls <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code> multiple times with various source tables (y argument of the join) to gather variables. It is not meant to replace left_join() but simplify syntax for the situation that you started off a table of study sample and wanted to gather covariates from different sources linked by common client IDs, which is often the case when working with healthcare databases.
<strong>Caution</strong>: this function is intended for one-to-one joins only because it could be problematic when we do not know which source caused a one-to-many join and changed the number of rows. For data.frame input, an error will be given when one-to-many joins were detected. However, such checking could be an expensive operation on remote source. Therefore, for database input, the result will not be checked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_var(data, keys, linkage, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_var_+3A_data">data</code></td>
<td>
<p>A data.frame or remote table (tbl_sql). It would be used as the x argument in left_join().</p>
</td></tr>
<tr><td><code id="fetch_var_+3A_keys">keys</code></td>
<td>
<p>A vector of quoted/unquoted variable names, or 'tidyselect' expression (see <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>). These variables must be present in <code>data</code> and would be used as the <code>by</code> argument in left_join(). The y tables must have a subset of these if not all.</p>
</td></tr>
<tr><td><code id="fetch_var_+3A_linkage">linkage</code></td>
<td>
<p>A list of formulas in the form of &quot;from_tab ~ get_vars|by_keys&quot;:
</p>

<ul>
<li><p> source table on the left-hand-side
</p>
</li>
<li><p> variables on the right-hand-side
</p>
</li>
<li><p> If a source table does not have all the variables in <code>keys</code>, use &quot;|&quot; on RHS to specify the subset of <code>keys</code> to be used.
</p>
</li></ul>

<p>For example, given <code>keys</code> has 3 variables,
list(
y1 ~ tidyselect_expr1,
y2 ~ tidyselect_expr2|key1 + key2)
</p>
<p>meaning:
</p>

<ol>
<li><p> from table y1 get variables picked by the tidyselect expression matching on all 3 keys;
</p>
</li>
<li><p> from table y2 get variables matching on only key1 and key2.
</p>
</li></ol>
</td></tr>
<tr><td><code id="fetch_var_+3A_...">...</code></td>
<td>
<p>Additional arguments, e.g., <code>copy = TRUE</code>, passing to left_join().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or remote table containing all original columns of x and new variables matched from other tables based on the specified linkage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy data
size &lt;- 30
n &lt;- 10
df1 &lt;- data.frame(
  id = sample(1:n, size = size, replace = TRUE),
  service_dt = sample(seq(as.Date("2020-01-01"), as.Date("2022-01-31"), by = 1),
    size = size
  )
) %&gt;%
  dplyr::mutate(year = lubridate::year(service_dt))
df2 &lt;- data.frame(
  id = rep(1:n, size / n), year = rep(2020:2022, each = n),
  status_1 = sample(0:1, size = size, replace = TRUE),
  status_2 = sample(0:1, size = size, replace = TRUE)
)
df3 &lt;- data.frame(id = 1:n, sex = sample(c("F", "M"), size = n, replace = TRUE))

# simple joins
# note that for left_join(df1, df2), boths keys have to be used,
# otherwise, error as the relation would not be one-to-one
fetch_var(df1,
  keys = c(id, year),
  linkage = list(
    df2 ~ starts_with("s"), # match both keys without '|'
    df3 ~ sex | id
  ) # match by id only; otherwise failed because df3 has no year
)

# example if some y is remote
# make df2 as database table
db2 &lt;- dbplyr::tbl_memdb(df2)

fetch_var(df1,
  keys = c(id, year),
  linkage = list(
    db2 ~ starts_with("s"),
    df3 ~ sex | id
  ),
  copy = TRUE # pass to left_join for forced collection of remote table
)
</code></pre>

<hr>
<h2 id='identify_row'>Identify rows with a match</h2><span id='topic+identify_row'></span>

<h3>Description</h3>

<p>Filter rows which values satisfy the specified conditions. The functionality is identical to <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> combined with <code><a href="dplyr.html#topic+across">dplyr::if_any()</a></code> or <code><a href="dplyr.html#topic+across">dplyr::if_all()</a></code>, but it used the 'data.table' package <code>vignette("datatable-intro", package = "data.table")</code> for data.frame method, and has regular regular expression support for remote database tables. The motivation is to take away some pain when working with databases which often do not support regular expression and 'LIKE' operator with multiple string patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_row(
  data,
  vars,
  match = c("in", "start", "regex", "like", "between", "glue_sql"),
  vals,
  if_all = FALSE,
  verbose = getOption("healthdb.verbose"),
  query_only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_row_+3A_data">data</code></td>
<td>
<p>Data.frames or remote tables (e.g., from <code><a href="dbplyr.html#topic+tbl_sql">dbplyr::tbl_sql()</a></code>)</p>
</td></tr>
<tr><td><code id="identify_row_+3A_vars">vars</code></td>
<td>
<p>An expression passing to <code><a href="dplyr.html#topic+select">dplyr::select()</a></code>. It can be quoted/unquoted column names, or helper functions, such as <code><a href="dplyr.html#topic+reexports">dplyr::starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="identify_row_+3A_match">match</code></td>
<td>
<p>One of &quot;in&quot;, &quot;start&quot;, &quot;regex&quot;, &quot;like&quot;, &quot;between&quot;, and &quot;glue_sql&quot;. It determines how values would be matched. The operations under each type:
</p>

<ul>
<li><p> &quot;in&quot;: var %in% vals (This is default)
</p>
</li>
<li><p> &quot;regex&quot;: stringr::str_detect(var, vals). For remote tables, unique values in vars are collected locally before matching (may be slow).
</p>
</li>
<li><p> &quot;like&quot;: stringr::str_like(var, vals). For remote tables, WHERE var LIKE val.
</p>
</li>
<li><p> &quot;start&quot;: same as regex or LIKE with modified vals, e.g., &quot;^val1|^val2&quot; or &quot;va1%|val2%&quot;
</p>
</li>
<li><p> &quot;between&quot;: dplyr::between(var, val1, val2)
</p>
</li>
<li><p> &quot;glue_sql&quot;: For remote table only, this gives full control of the WHERE clause using dplyr::filter(dbplyr::sql(glue::glue_sql(...)))
</p>
</li></ul>
</td></tr>
<tr><td><code id="identify_row_+3A_vals">vals</code></td>
<td>
<p>Depending on <code>match</code>, it takes different input:
</p>

<ul>
<li><p> &quot;in&quot;: a vector of values (numeric/character/Date)
</p>
</li>
<li><p> &quot;start&quot;: a vector of numeric/character that would be modified into a regex or LIKE pattern string by adding &quot;^&quot; in front or &quot;%&quot; at the end
</p>
</li>
<li><p> &quot;regex&quot;/&quot;like&quot;: a string of the expression
</p>
</li>
<li><p> &quot;between&quot;: a vector of numeric or date with exactly two elements, e.g., c(lower, upper)
</p>
</li>
<li><p> &quot;glue_sql&quot;: a string of a SQL WHERE clause, which will be passed to <code><a href="glue.html#topic+glue_sql">glue::glue_sql()</a></code>. See examples for detail.
</p>
</li></ul>
</td></tr>
<tr><td><code id="identify_row_+3A_if_all">if_all</code></td>
<td>
<p>A logical for whether combining the predicates (if multiple columns were selected by vars) with AND instead of OR. Default is FALSE, e.g., var1 in vals OR var2 in vals.</p>
</td></tr>
<tr><td><code id="identify_row_+3A_verbose">verbose</code></td>
<td>
<p>A logical for whether printing explanation and result overview for the query. Default is fetching from options. Use <code>options(healthdb.verbose = FALSE)</code> to suppress once and for all. Result overview is not for remote tables as the query is not executed immediately, thus no result is available for summary without adding an extra run (may be slow) of the query.</p>
</td></tr>
<tr><td><code id="identify_row_+3A_query_only">query_only</code></td>
<td>
<p>A logical for whether keeping the output as remote table (Default TRUE) or downloading the query result as a tibble (FALSE). The argument is ignored when the input data is a data.frame/tibble.</p>
</td></tr>
<tr><td><code id="identify_row_+3A_...">...</code></td>
<td>
<p>For remote table method only. Additional arguments passing to <code><a href="glue.html#topic+glue_sql">glue::glue_sql()</a></code> for parameterized queries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or tbl_sql object depending on the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#applying to data.frame; both sepal length and width in range 3-5
identify_row(iris, starts_with("Sepal"), "between", c(3, 5), if_all = TRUE)

#applying to remote table; species starts with se or ends with ca
iris_db &lt;- dbplyr::memdb_frame(iris)
identify_row(iris_db, Species, "like", c("se%", "%ca"))

#using glue_sql to write the WHERE clause
#use {`vars`} to refer to the variables selected by vars
#supply additional values required in the query through '...'
#note that if you use LIKE here, you cannot supply multiple patterns in what
identify_row(iris_db, Species, "glue_sql",
 "{`vars`} LIKE {what}",
  what = "se%")

#add * after a vector
identify_row(iris_db, Species, "glue_sql",
 "{`vars`} IN ({what*})",
 what = c("setosa", "virginica"))
</code></pre>

<hr>
<h2 id='if_date'>Interpret if any n elements drawn from a date vector could be some days apart within some time span</h2><span id='topic+if_date'></span>

<h3>Description</h3>

<p>Given a vector of dates x, interpret if there could be at least one set of n elements taken from x satisfy that adjacent elements in the set are at least certain days apart AND the dates in the set are within the specified time span. When identifying events/diseases from administrative data, definitions often require, e.g., n diagnoses that are at least some days apart within some years. This function is intended for such use and optimized to avoid looping through all n-size combinations in x. This function does not work with remote table input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_date(
  x,
  n,
  apart = NULL,
  within = NULL,
  detail = FALSE,
  align = c("left", "right"),
  dup.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_date_+3A_x">x</code></td>
<td>
<p>A character or Date vector</p>
</td></tr>
<tr><td><code id="if_date_+3A_n">n</code></td>
<td>
<p>An integer for the size of a draw</p>
</td></tr>
<tr><td><code id="if_date_+3A_apart">apart</code></td>
<td>
<p>An integer specifying the minimum gap (in days) between adjacent dates in a draw.</p>
</td></tr>
<tr><td><code id="if_date_+3A_within">within</code></td>
<td>
<p>An integer specifying the maximum time span (in days) of a draw.</p>
</td></tr>
<tr><td><code id="if_date_+3A_detail">detail</code></td>
<td>
<p>Logical for whether return result per element of x.The default is FALSE, which returns one logical summarized by any(). Detail is not available if <code>apart</code> was supplied without <code>within</code> because sets that satisfied the condition could overlap, and records within a set may be far apart; thus, no unambiguous way to label by element.</p>
</td></tr>
<tr><td><code id="if_date_+3A_align">align</code></td>
<td>
<p>Character, define if the time span for each record should start (&quot;left&quot;) or end (&quot;right&quot;) at its current date. Defaults to &quot;left&quot;. See 'flag_at' argument in <code><a href="#topic+restrict_date">restrict_date()</a></code> for detail.</p>
</td></tr>
<tr><td><code id="if_date_+3A_dup.rm">dup.rm</code></td>
<td>
<p>Logical for whether multiple records on the same date should be count as one in calculation. Only applicable when <code>within</code> is supplied without <code>apart</code>; duplicated dates have no impact when <code>apart</code> is present as the n dates must be distinct if they were apart. Default is TRUE.</p>
</td></tr>
<tr><td><code id="if_date_+3A_...">...</code></td>
<td>
<p>Additional argument passing to <code><a href="data.table.html#topic+IDateTime">data.table::as.IDate()</a></code> for date conversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single or a vector of logical for whether there is any draw from x satisfied the conditions
</p>


<h3>See Also</h3>

<p><code><a href="#topic+restrict_date">restrict_date()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates_of_records &lt;- sample(seq(as.Date("2015-01-01"), as.Date("2021-12-31"), 7), 10)

# whether there is any 3 records at least 30 days apart within 2 years
if_date(dates_of_records, n = 3, apart = 30, within = 365 * 2)

# specified either apart or within or both
if_date(dates_of_records, n = 2, within = 365)

</code></pre>

<hr>
<h2 id='lookup'>Find value corresponding to the input vector using a look-up table</h2><span id='topic+lookup'></span>

<h3>Description</h3>

<p>Find value corresponding to the input vector using a look-up table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup(x, link, lu, verbose = getOption("healthdb.verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_+3A_x">x</code></td>
<td>
<p>A variable name in a data.frame; this function should be called inside dplyr::mutate().</p>
</td></tr>
<tr><td><code id="lookup_+3A_link">link</code></td>
<td>
<p>A formula in the form: name_of_x_in_lu ~ name_of_target_value. The left-hand-side can be omitted if x's name is also x in the look-up.</p>
</td></tr>
<tr><td><code id="lookup_+3A_lu">lu</code></td>
<td>
<p>Look-up table in data.frame class.</p>
</td></tr>
<tr><td><code id="lookup_+3A_verbose">verbose</code></td>
<td>
<p>A logical for whether warn for missing values in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of matched values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(drug_code = 1:10)
lu &lt;- data.frame(drug_id = 1:20, drug_code = as.character(1:10), drug_name = sample(letters, 20))

df %&gt;% dplyr::mutate(
  drug_nm = lookup(drug_code, drug_id ~ drug_name, lu),
  # this will work as lu also has drug_code column
  drug_nm = lookup(drug_code, ~ drug_name, lu)
)
</code></pre>

<hr>
<h2 id='make_test_dat'>Make test data</h2><span id='topic+make_test_dat'></span>

<h3>Description</h3>

<p>Make a toy data set for testing and demo. This is for internal use purpose and not intended to be called by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_test_dat(
  vals_kept = c("304", "305", 3040:3049, 3050:3059),
  noise_val = "999",
  IDs = 1:50,
  date_range = seq(as.Date("2015-01-01"), as.Date("2020-12-31"), by = 1),
  nrows = 100,
  n_any = 50,
  n_all = 10,
  seed = NULL,
  answer_id = NULL,
  type = c("data.frame", "database")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_test_dat_+3A_vals_kept">vals_kept</code></td>
<td>
<p>A vector of values that suppose to be identified.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_noise_val">noise_val</code></td>
<td>
<p>A vector of values that are not meant to be identified.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_ids">IDs</code></td>
<td>
<p>A vector of client IDs.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_date_range">date_range</code></td>
<td>
<p>A vector of all possible dates in the data.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_nrows">nrows</code></td>
<td>
<p>Number of rows of the output.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_n_any">n_any</code></td>
<td>
<p>Number of rows to be identified if the criteria is that if any target column contains certain values.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_n_all">n_all</code></td>
<td>
<p>Number of rows to be identified if the criteria is that if all target columns contain certain values.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generation.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_answer_id">answer_id</code></td>
<td>
<p>Column name for the indicator of how the row should be identified: any, all, and noise.</p>
</td></tr>
<tr><td><code id="make_test_dat_+3A_type">type</code></td>
<td>
<p>Output type, &quot;data.frame&quot; or &quot;database&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or remote table from 'dbplyr'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_test_dat() %&gt;% head()
</code></pre>

<hr>
<h2 id='pool_case'>Pool qualified clients from results of multiple definitions</h2><span id='topic+pool_case'></span>

<h3>Description</h3>

<p>This function filters and pools, i.e., row bind, qualified clients/groups from different source with an option to summarize by client. Unlike <code><a href="#topic+bind_source">bind_source()</a></code>, no need to supply variable names; the function will guess what should be included and their names from the supplied definition from <code><a href="#topic+build_def">build_def()</a></code>. Whether a client is qualified relies on the flag variables set by <code><a href="#topic+define_case">define_case()</a></code>. Therefore, this function is intended to be use only with the built-in <code><a href="#topic+define_case">define_case()</a></code> as <code>def_fn</code> in <code><a href="#topic+build_def">build_def()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_case(
  data,
  def,
  output_lvl = c("raw", "clnt"),
  include_src = c("all", "has_valid", "n_per_clnt"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_case_+3A_data">data</code></td>
<td>
<p>A list of data.frame or remote table which should be output from <code><a href="#topic+execute_def">execute_def()</a></code>.</p>
</td></tr>
<tr><td><code id="pool_case_+3A_def">def</code></td>
<td>
<p>A tibble of case definition generated by <code><a href="#topic+build_def">build_def()</a></code>.</p>
</td></tr>
<tr><td><code id="pool_case_+3A_output_lvl">output_lvl</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> &quot;raw&quot; - output all records (default),
</p>
</li>
<li><p> or &quot;clnt&quot; - output one record per client with summaries including date of first valid record ('first_valid_date'), date of the latest record ('last_entry_date'), and sources that contain valid records.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pool_case_+3A_include_src">include_src</code></td>
<td>
<p>Character. It determines records from which sources should be included. This matters when clients were identified only from, not all, but some of the sources. This choice will not impact the number of client that would be identified but has impact on the number of records and the latest entry date. The options are one of:
</p>

<ul>
<li><p> &quot;all&quot; - records from all sources are included;
</p>
</li>
<li><p> &quot;has_valid&quot; - for each client, records from sources that contain at least one valid record are included;
</p>
</li>
<li><p> &quot;n_per_clnt&quot; - for each client, if they had fewer than <code>n_per_clnt</code> records in a source (see <code><a href="#topic+restrict_n">restrict_n()</a></code>), then records from that source are removed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pool_case_+3A_...">...</code></td>
<td>
<p>Additional arguments passing to <code><a href="#topic+bind_source">bind_source()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or remote table with clients that satisfied the predefined case definition. Columns started with &quot;raw_in_&quot; are source-specific counts of raw records, and columns started with &quot;valid_in_&quot; are the number of valid entries (or the number of flags) in each source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy data
df1 &lt;- make_test_dat()
df2 &lt;- make_test_dat()

# use build_def to make a toy definition
sud_def &lt;- build_def("SUD", # usually a disease name
  src_lab = c("src1", "src2"), # identify from multiple sources, e.g., hospitalization, ED visits.
  # functions that filter the data with some criteria
  def_fn = define_case,
  fn_args = list(
    vars = starts_with("diagx"),
    match = "start", # "start" will be applied to all sources as length = 1
    vals = list(c("304"), c("305")),
    clnt_id = "clnt_id", # list()/c() could be omitted for single element
    # c() can be used in place of list
    # if this argument only takes one value for each source
    n_per_clnt = c(2, 3)
  )
)

# save the definition for re-use
# saveRDS(sud_def, file = some_path)

# execute definition
sud_by_src &lt;- sud_def %&gt;% execute_def(with_data = list(src1 = df1, src2 = df2))

# pool results from src1 and src2 together at client level
pool_case(sud_by_src, sud_def, output_lvl = "clnt")
</code></pre>

<hr>
<h2 id='report_n'>Report number of distinct value in a column across data frames</h2><span id='topic+report_n'></span>

<h3>Description</h3>

<p>This function is intended to mimic <code><a href="dplyr.html#topic+n_distinct">dplyr::n_distinct()</a></code> for multiple inputs. It is useful to report the number of clients through out a series of inclusion or exclusion steps. An use case could be getting the Ns for the sample definition flowchart in an epidemiological study. It is also useful for inline reporting of Ns in a Rmarkdown document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_n(..., on, force_proceed = getOption("healthdb.force_proceed"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_n_+3A_...">...</code></td>
<td>
<p>Data frames or remote tables (e.g., from 'dbplyr')</p>
</td></tr>
<tr><td><code id="report_n_+3A_on">on</code></td>
<td>
<p>The column to report on. It must be present in all data sources.</p>
</td></tr>
<tr><td><code id="report_n_+3A_force_proceed">force_proceed</code></td>
<td>
<p>A logical for whether to ask for user input in order to proceed when the data is not local data.frames, and a query needs to be executed before reporting. The default is fetching from options (FALSE). Use <code>options(healthdb.force_proceed = TRUE)</code> to suppress the prompt once and for all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence of the number of distinct <code>on</code> for each data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some exclusions
iris_1 &lt;- subset(iris, Petal.Length &gt; 1)
iris_2 &lt;- subset(iris, Petal.Length &gt; 2)

# get n at each operation
n &lt;- report_n(iris, iris_1, iris_2, on = Species)
n

# get the difference at each step
diff(n)
# data in a list
iris_list &lt;- list(iris_1, iris_2)
report_n(rlang::splice(iris_list), on = Species)
# if you loaded tidyverse, this will also work
# report_n(!!!iris_list, on = Species)
</code></pre>

<hr>
<h2 id='restrict_date'>Remove or flag groups failed to meet conditions based on dates</h2><span id='topic+restrict_date'></span>

<h3>Description</h3>

<p>For each client or group, interpret if they have n records that are at least certain days apart AND within a specified time span. When identifying events/diseases from administrative data, definitions often require, e.g., n diagnoses that are at least some days apart within some years. This function is intended for such use and optimized to avoid looping through all n-size combinations of dates per client.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_date(
  data,
  clnt_id,
  date_var,
  n,
  apart = NULL,
  within = NULL,
  uid = NULL,
  mode = c("flag", "filter"),
  flag_at = c("left", "right"),
  dup.rm = TRUE,
  force_collect = FALSE,
  verbose = getOption("healthdb.verbose"),
  check_missing = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_date_+3A_data">data</code></td>
<td>
<p>Data frames or remote tables (e.g., from <code><a href="dbplyr.html#topic+tbl_sql">dbplyr::tbl_sql()</a></code>)</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_clnt_id">clnt_id</code></td>
<td>
<p>Grouping variable (quoted/unquoted).</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_date_var">date_var</code></td>
<td>
<p>Variable name (quoted/unquoted) for the dates to be interpreted.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_n">n</code></td>
<td>
<p>An integer for the size of a draw.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_apart">apart</code></td>
<td>
<p>An integer specifying the minimum gap (in days) between adjacent dates in a draw.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_within">within</code></td>
<td>
<p>An integer specifying the maximum time span (in days) of a draw.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_uid">uid</code></td>
<td>
<p>Variable name for a unique row identifier. It is necessary for SQL to produce consistent result based on sorting.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_mode">mode</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> &quot;flag&quot; - add a new column 'flag_restrict_date' indicating if the condition was met (flag = 1 if the time period starting or ending at the current record satisfied the apart-within condition),
</p>
</li>
<li><p> or &quot;filter&quot; - remove clients without any qualified record from the data. Default is &quot;flag&quot;.
</p>
</li></ul>
</td></tr>
<tr><td><code id="restrict_date_+3A_flag_at">flag_at</code></td>
<td>
<p>Character, define if the flag should be placed at the start (&quot;left&quot;) or end (&quot;right&quot;) of a time period that contains n qualified records. Defaults to &quot;left&quot;. Note that this would impact the first and last qualified/diagnosed dates of a client, e.g., using &quot;right&quot; will have the first flag not at the earliest but the date which the client became qualified. For example, if the condition was 2 records within a year, for <code>c("2023-01-01", "2023-04-01", "2024-05-01")</code>, flag will be <code>c(0, 1, 0)</code> for &quot;right&quot; while <code>c(1,0,0)</code> for &quot;left&quot;.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_dup.rm">dup.rm</code></td>
<td>
<p>Logical for whether multiple records on the same date should be count as one in calculation. Only applicable when <code>within</code> is supplied without <code>apart</code>; duplicated dates have no impact when <code>apart</code> is present as the n dates must be distinct if they were apart. Default is TRUE.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_force_collect">force_collect</code></td>
<td>
<p>A logical for whether force downloading remote table if <code>apart</code> is not NULL. For remote table only, because <code>apart</code> is implemented for local data frame only. Downloading data could be slow, so the user has to opt in; default FALSE will stop with error.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_verbose">verbose</code></td>
<td>
<p>A logical for whether to explain the query and report how many groups were removed. Default is fetching from options. Use <code>options(healthdb.verbose = FALSE)</code> to suppress once and for all. Reporting is not for remote tables as the query is not executed immediately, thus no result is available for summary without adding an extra run (may be slow) of the query.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_check_missing">check_missing</code></td>
<td>
<p>A logical for whether to check and remove missing entries in <code>date_var</code> before applying the conditions. Default is FALSE for faster run time.</p>
</td></tr>
<tr><td><code id="restrict_date_+3A_...">...</code></td>
<td>
<p>Additional argument passing to <code><a href="data.table.html#topic+IDateTime">data.table::as.IDate()</a></code> for date conversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of input data satisfied the dates requirement, or raw input data with an new flag column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+if_date">if_date()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_size &lt;- 30
df &lt;- data.frame(
  clnt_id = sample(1:sample_size, sample_size, replace = TRUE),
  service_dt = sample(seq(as.Date("2020-01-01"), as.Date("2020-01-31"), by = 1),
    size = sample_size, replace = TRUE
  ),
  diagx = sample(letters, size = sample_size, replace = TRUE),
  diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),
  diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE)
)

# Keep clients with 2 records that were 1 week apart within 1 month
restrict_date(df, clnt_id, service_dt, n = 2, apart = 7, within = 30)
</code></pre>

<hr>
<h2 id='restrict_n'>Remove or flag groups with n less than some number</h2><span id='topic+restrict_n'></span>

<h3>Description</h3>

<p>Remove or flags groups or clients that have less than some number of rows or some number of distinct values in a variable. For example, it can be used to remove clients that had less than n visits to some service on different dates from some administrative records. It offers filtering with <code><a href="dplyr.html#topic+n_distinct">dplyr::n_distinct()</a></code> functionality for database input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_n(
  data,
  clnt_id,
  n_per_clnt,
  count_by = NULL,
  mode = c("flag", "filter"),
  verbose = getOption("healthdb.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_n_+3A_data">data</code></td>
<td>
<p>Data.frames or remote tables (e.g., from <code><a href="dbplyr.html#topic+tbl_sql">dbplyr::tbl_sql()</a></code>)</p>
</td></tr>
<tr><td><code id="restrict_n_+3A_clnt_id">clnt_id</code></td>
<td>
<p>Grouping variable (quoted/unquoted).</p>
</td></tr>
<tr><td><code id="restrict_n_+3A_n_per_clnt">n_per_clnt</code></td>
<td>
<p>A single number specifying the minimum number of group size.</p>
</td></tr>
<tr><td><code id="restrict_n_+3A_count_by">count_by</code></td>
<td>
<p>Another variable dictating the counting unit of <code>n_per_clnt.</code> The default is NULL meaning the inclusion criteria is the number of row, i.e., <code>dplyr::n() &gt;= n_per_clnt</code>. If it is not NULL, the criteria becomes equivalent to <code>dplyr::n_distinct(count_by) &gt;= n_per_clnt</code>.</p>
</td></tr>
<tr><td><code id="restrict_n_+3A_mode">mode</code></td>
<td>
<p>Either &quot;flag&quot; - add a new column 'flag_restrict_n' indicating if the client met the condition (all rows from a qualified client would have flag = 1), or &quot;filter&quot; - remove clients that did not meet the condition from the data. Default is &quot;flag&quot;.</p>
</td></tr>
<tr><td><code id="restrict_n_+3A_verbose">verbose</code></td>
<td>
<p>A logical for whether to explain the query and report how many groups were removed. Default is fetching from options. Use <code>options(healthdb.verbose = FALSE)</code> to suppress once and for all. Reporting is not for remote tables as the query is not executed immediately, thus no result is available for summary without adding an extra run (may be slow) of the query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A subset of input data satisfied the group size requirement, or raw input data with an new flag column.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+context">dplyr::n()</a></code>, <code><a href="dplyr.html#topic+n_distinct">dplyr::n_distinct()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># flag cyl groups with less than 8 cars
restrict_n(mtcars, clnt_id = cyl, n_per_clnt = 8, mode = "flag") %&gt;%
head()

#remove cyl groups with less than 2 types of gear boxes
restrict_n(mtcars, clnt_id = cyl, n_per_clnt = 3, count_by = gear, mode = "filter")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
