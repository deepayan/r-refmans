<!DOCTYPE html><html><head><title>Help for package flexmsm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flexmsm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conv.check'><p>Convergence diagnostics on fitted model output.</p></a></li>
<li><a href='#flexmsm-package'><p>flexmsm: Flexible Multi-State Modelling</p></a></li>
<li><a href='#fmsm'><p>Flexible transition intensity based models for univariate multistate processes</p></a></li>
<li><a href='#fmsmObject'><p>Fitted fmsmObject object</p></a></li>
<li><a href='#IDM_cav'><p>Cardiac allograft vasculopathy (CAV) data</p></a></li>
<li><a href='#LikGradHess.general'><p>Likelihood, gradient and Hessian for univariate transition intensity based models</p></a></li>
<li><a href='#logLik.fmsm'><p>Extract the log likelihood for the fitted multistate model</p></a></li>
<li><a href='#P.pred'><p>Predict and plot the transition probabilities</p></a></li>
<li><a href='#plot.fmsm'><p>Function to plot the smooths included in the model specifications.</p></a></li>
<li><a href='#print.fmsm'><p>Print a fmsm object</p></a></li>
<li><a href='#print.summary.fmsm'><p>Flexible transition intensity based models for univariate multistate processes</p></a></li>
<li><a href='#Q.matr.setup.general'><p>Internal function</p></a></li>
<li><a href='#Q.pred'><p>Predict and plot the transition intensities</p></a></li>
<li><a href='#simulateIDM'><p>Function to predict and plot the estimated transition intensities (and confidence intervals).</p></a></li>
<li><a href='#state.pairs.CT'><p>Function to extract state pair counts and observed (right) times.</p></a></li>
<li><a href='#summary.fmsm'><p>Summary for fitted model ouput.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A General Framework for Flexible Multi-State Survival Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A general estimation framework for multi-state Markov processes with flexible specification of the transition intensities.
    The log-transition intensities can be specified through Generalised Additive Models which allow for virtually any type of covariate
    effect. Elementary specifications such as time-homogeneous processes and simple parametric forms are also supported. There are 
    no limitations on the type of process one can assume, with both forward and backward transitions allowed and virtually any number
    of states.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>GJRM, mgcv, stats, trust, msm, matrixStats, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-23 09:36:43 UTC; Alessia</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessia Eletti [aut, cre],
  Giampiero Marra [aut],
  Rosalba Radice [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessia Eletti &lt;alessia.eletti.19@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-23 12:20:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='conv.check'>Convergence diagnostics on fitted model output.</h2><span id='topic+conv.check'></span>

<h3>Description</h3>

<p>Convergence diagnostics on fitted model output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv.check(object, also.unpen = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv.check_+3A_object">object</code></td>
<td>
<p>Fitted model object.</p>
</td></tr>
<tr><td><code id="conv.check_+3A_also.unpen">also.unpen</code></td>
<td>
<p>If <code>TRUE</code>, displays eigenvalues range also for the unpenalised Hessian. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Convergence diagnostics.
</p>

<hr>
<h2 id='flexmsm-package'>flexmsm: Flexible Multi-State Modelling</h2><span id='topic+flexmsm-package'></span><span id='topic+flexmsm'></span>

<h3>Description</h3>

<p>Provides a function for fitting any type of multistate survival model, with flexibly defined transition intensities and any type of observation scheme.
The package also provides a host of tools for straightforward interpretation and visualisation of the fitted model.
</p>
<p>The main fitting function is <code><a href="#topic+fmsm">fmsm</a></code>, which fits the multistate survival model, providing parameter and
as key inference quantities (p-values, estimated degrees of freedom, ...), as well as the elements needed to obtain
predicted transition intensities and probabilities, along with their confidence intervals.
</p>
<p>The main auxiliary functions are <code><a href="#topic+Q.pred">Q.pred</a></code> and <code><a href="#topic+P.pred">P.pred</a></code>.
</p>


<h3>Details</h3>

<p>Provides functions for fitting and interpreting the output of general flexible multistate survival models.
The process is defined by means of a list of model specifications for the transition intensities, each of which follow syntax
similar to that used for GAMs in <code>mgcv</code>.
</p>
<p>The estimation approach is based on a carefully structured, stable penalised likelihood approach, with the smoothers
(representing several types of covariate effects) set up using penalised regression splines.
The numerical routine carries out function minimization using a trust region algorithm in combination with an adaptation of an automatic
multiple smoothing parameter estimation procedure for Generalised Additive Models (see <code>mgcv</code> for more details on this last point). The smooths
supported by this package are those available in <code>mgcv</code>.
</p>
<p>Confidence intervals for smooth components and nonlinear functions of the model parameters are derived using a Bayesian approach.
P-values for testing individual smooth terms for equality to the zero function are also provided and based on the approach
implemented in <code>mgcv</code>. The usual plotting and summary functions are also available.
</p>
<p>Plots of the estimated transition intensities and transition probabilities can be obtained along with their respective confidence intervals.
This includes 3D plots when two-dimensional splines are included in the model specification of one or more transition intensities.
</p>


<h3>Author(s)</h3>

<p>Alessia Eletti (University College London, Department of Statistical Science),
Giampiero Marra (University College London, Department of Statistical Science)
and Rosalba Radice (Cass Business School, City, University of London).
</p>
<p>Maintainer: Alessia Eletti <a href="mailto:alessia.eletti.19@ucl.ac.uk">alessia.eletti.19@ucl.ac.uk</a>
</p>


<h3>References</h3>

<p>Eletti, A., Marra, G., Radice, R., (submitted), A General Estimation Framework for Multi-State Markov Processes with Flexible Specification of the Transition Intensities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmsm">fmsm</a></code>
</p>

<hr>
<h2 id='fmsm'>Flexible transition intensity based models for univariate multistate processes</h2><span id='topic+fmsm'></span>

<h3>Description</h3>

<p>Fits a flexible multistate survival model. Any type of process is supported,
including both forward and backward transitions, and must be specified by providing a list
of equations, one for each transition intensity allowed. Any type of observation scheme is
allowed: the process can be observed in continuous time, intermittently at fixed times, there
can be an absorbing state as well as censored states.
Virtually any type of covariate
effects are supported and can be specified by means of splines, with the same syntax used
to specify Generalised Additive Models (GAMs) in <code>R</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmsm(formula, data, id, state, death, pmethod = 'eigendecomp',
       aggregate = TRUE, params.0 = NULL, sp.0 = NULL,
       constraint = NULL, sp.method = 'perf', iterlimsp = 50,
       Q.diagnostics = TRUE, fit = TRUE, iterlim = 100,
       tolsp = 1e-7, tolsp.EFS = 0.1, parallel = FALSE, no_cores = 2,
       cens.state = NULL, living.exact = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmsm_+3A_formula">formula</code></td>
<td>
<p>Model specification for the transition intensities.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_data">data</code></td>
<td>
<p>Dataset.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_id">id</code></td>
<td>
<p>Name of the variable in the dataset representing the unique code associated with each patient.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_state">state</code></td>
<td>
<p>Name of the variable in the dataset representing the state occupied by the patient at the given time.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_death">death</code></td>
<td>
<p><code>TRUE</code> if the last state is an absorbing state, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_pmethod">pmethod</code></td>
<td>
<p>Which method should be used for the computation of the transition probability matrix. Available options are
</p>

<ul>
<li> <p><code>'eigendecomp'</code> (default): this method is based on the eigendecomposition of the transition intensity matrix (from Kalbfleisch &amp; Lawless 1985);
</p>
</li>
<li> <p><code>'analytic'</code>: uses analytic expressions of the transition probabilities, obtained by solving the Kolmogorov forward differential equation, only implemented for IDMs for now;
</p>
</li>
<li> <p><code>'scaling&amp;squaring'</code>: this is the scaling and squaring method implemented as proposed in Fung (2004).This is inefficient, so its use is not recommended. Can be used to investigate convergence errors.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fmsm_+3A_aggregate">aggregate</code></td>
<td>
<p>Whether or not data should be aggregated (this slightly improves efficiency as redundancies in the data are eliminated). The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_params.0">params.0</code></td>
<td>
<p>Starting values for the model parameters. Defaults to <code>NULL</code>, i.e. they are computed internally.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_sp.0">sp.0</code></td>
<td>
<p>Starting values for the smoothing parameters. Defaults to <code>NULL</code>, i.e. they are computed internally.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_constraint">constraint</code></td>
<td>
<p>A list containing the constraints to be applied to the model parameters. This follows the form <code>list(x1 = (1,1,1), x2 = c())</code></p>
</td></tr>
<tr><td><code id="fmsm_+3A_sp.method">sp.method</code></td>
<td>
<p>Method to be used for smoothing parameter estimation. The default is <code>magic</code>, the automatic multiple smoothing parameter selection algorithm. Alternatively, <code>efs</code> can be used for the Fellner-Schall method.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_iterlimsp">iterlimsp</code></td>
<td>
<p>Maximum allowed iterations for smoothing parameter estimation.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_q.diagnostics">Q.diagnostics</code></td>
<td>
<p>If <code>TRUE</code>, diagnostics information on the Q matrix are saved. The default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_fit">fit</code></td>
<td>
<p>If <code>FALSE</code>, fitting is not carried. May be useful to extract model setup quantities.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_iterlim">iterlim</code></td>
<td>
<p>Maximum allowed iterations for trust region algorithm.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_tolsp">tolsp</code></td>
<td>
<p>Convergence criterion used in <code>magic</code> based smoothing parameter estimation.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_tolsp.efs">tolsp.EFS</code></td>
<td>
<p>Convergence criterion used in <code>efs</code> based smoothing parameter estimation.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code> parallel computing is used during estimation. This can only be used by Windows users for now.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_no_cores">no_cores</code></td>
<td>
<p>Number of cores used if parallel computing chosen. The default is 2. If <code>NULL</code>, all available cores are used.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_cens.state">cens.state</code></td>
<td>
<p>Code used in the dataset to indicate the censored states.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_living.exact">living.exact</code></td>
<td>
<p>Name of the variable in the dataset indicating whether an observation is exactly observed or not.</p>
</td></tr>
<tr><td><code id="fmsm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, prints the convergence criterion obtained at each iteration of the full algorithm. The default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>fmsm</code> as described in <code>fmsmObject</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##################################################
# MULTISTATE SURVIVAL MODELLING with CAV DATA ####
##################################################

library(flexmsm)

# Import data
Data &lt;- IDM_cav

# MODEL SPECIFICATION ####
formula &lt;- list(years ~ s(years, bs = 'cr', k = 10) + dage + pdiag, # 1-2
                years ~ s(years, bs = 'cr', k = 10) + dage + pdiag, # 1-3
                0,                                                  # 2-1
                years ~ s(years, bs = 'cr', k = 10) + dage + pdiag, # 2-3
                0,                                                  # 3-1
                0                                                   # 3-2
)

# Counts of pairs of consecutive states observed (C = counts, T = times)
counts.CT &lt;- state.pairs.CT(formula = formula, data = Data, time = 'years',
                            state = 'state', id = 'PTNUM')
counts.CT$counts


# MODEL FITTING ###

# NOTE ***
# Takes about 18 minutes on a machine with Windows 10,
# Intel 2.20 GHz core, 16 GB of RAM and 8 cores, using all cores.
# The default is to use 2 cores, this takes about 26 minutes.
# To use all available cores on your device input no_cores = NULL.
# ****

fmsm.out &lt;- fmsm(formula = formula, data = Data,
                 id = PTNUM, state = state, death = TRUE,
                 fit = TRUE, parallel = TRUE, no_cores = 2,
                 pmethod = 'analytic')

print(fmsm.out)

AIC(fmsm.out)
BIC(fmsm.out)

# FITTING SUMMARY ####
summary(fmsm.out)
conv.check(fmsm.out)

####################
# VISUALISATION ####
####################

# PLOT THE SMOOTHS OF TIME FOR EACH TRANSITION ####
# par(mfrow = c(1,3))
plot(fmsm.out)


# Consider a patient with:
dage.pred &lt;- 16      # - 16 year old donor
pdiag.pred &lt;- 0      # - IDC as principal diagnosis
start.pred &lt;- 0      # - start observation at time t = 0
stop.pred &lt;- 15      # - t = 15 years for time horizon
n.pred &lt;- 21         # - 21 time points
no.state.pred &lt;- -13 # - (because we don't need this, so anything is fine)

newdata &lt;- data.frame(PTNUM = rep(1, n.pred),
                      years = seq(start.pred, stop.pred, length.out = n.pred),
                      state = rep(no.state.pred, n.pred),
                      dage = rep(dage.pred, n.pred), pdiag = rep(pdiag.pred, n.pred))



# ESTMATED TRANSITION INTENSITIES ####

# Plot of estimated transition intensities
# par(mfrow = c(1,3))
Q.hat &lt;- Q.pred(fmsm.out, newdata = newdata, get.CI = TRUE, plot.Q = TRUE, rug = TRUE,
                ylim = c(0, 1.5))

# Estimated transition intensity matrix at, e.g., t = 0
round(Q.hat$Q.hist[,,1], 3)



# ESTMATED TRANSITION PROBABILITIES ####

# Plot of estimated transition probabilities
# par(mfrow = c(2,3))
P.hat &lt;- P.pred(fmsm.out, newdata = newdata, get.CI = TRUE, plot.P = TRUE, rug = TRUE)

# Estimated 15 year transition probability matrix
round(P.hat$P.pred, 3)
# e.g., there is a 6.2% chance of observing CAV onset 15 years after transplant



## End(Not run)

</code></pre>

<hr>
<h2 id='fmsmObject'>Fitted fmsmObject object</h2><span id='topic+fmsmObject'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+fmsm">fmsm</a></code> function returns the fitted model object <code>fmsmObject</code>. This is of class &quot;fmsm&quot; and includes the components listed below. These are intended for confident users. To extract results
from the fitted model objects, functions such as <code><a href="#topic+summary.fmsm">summary.fmsm</a></code>, <code><a href="#topic+plot.fmsm">plot.fmsm</a></code>, <code><a href="#topic+Q.pred">Q.pred</a></code> and <code><a href="#topic+P.pred">P.pred</a></code> should be used instead.
</p>


<h3>Value</h3>

<table>
<tr><td><code>suStf</code></td>
<td>
<p>A list with all of the quantities used for estimation and post-estimation computations. This includes the full design matrix <code>full.X</code>, the starting parameters used, <code>params.0</code> and <code>sp.0</code>, and more technical quantities such as the positions of the smooths' parameters and of the parametric coefficients.</p>
</td></tr>
<tr><td><code>msm.fit.object</code></td>
<td>
<p>This contains all of the details of the model fitting.</p>
</td></tr>
<tr><td><code>msm.post.object</code></td>
<td>
<p>This contains all of the post-estimation details.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Formula used in the model specification.</p>
</td></tr>
<tr><td><code>short.formula</code></td>
<td>
<p>Short version of the model specification, i.e. only non-zero transition specifications are included.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations in the dataset.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of unique individuals.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The value of the log-likelihood at convergence.</p>
</td></tr>
<tr><td><code>t.edf</code></td>
<td>
<p>Total effective degrees of freedom.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fmsm">fmsm</a></code>, <code><a href="#topic+summary.fmsm">summary.fmsm</a></code>
</p>

<hr>
<h2 id='IDM_cav'>Cardiac allograft vasculopathy (CAV) data</h2><span id='topic+IDM_cav'></span>

<h3>Description</h3>

<p>A series of approximately yearly angiographic examinations of heart transplant recipients. Onset of cardiac allograft vasculopathy, a deterioration of the arterial wall, and death are monitored. This is a subset of data from the <code>cav</code> dataset in <code>R</code> package <code>msm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDM_cav
</code></pre>


<h3>Format</h3>

<p>A data frame with 2,803 observations of 614 patients and 5 variables. These are grouped by patient number and ordered by years after transplant.
</p>

<dl>
<dt>PTNUM</dt><dd><p>Unique number identifying each patient.</p>
</dd>
<dt>years</dt><dd><p>Examination time (years after transplant).</p>
</dd>
<dt>state</dt><dd><p>State of the examination. State 1 represents no CAV, state 2 represents CAV, state 3 represents death.</p>
</dd>
<dt>dage</dt><dd><p>Age of the heart donor (years).</p>
</dd>
<dt>pdiag</dt><dd><p>Primary diagnosis (reason for transplant). IHD = ischaemic heart disease, IDC = idiopathic dilated cardiomyopathy.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Papworth Hospital, U.K.
</p>

<hr>
<h2 id='LikGradHess.general'>Likelihood, gradient and Hessian for univariate transition intensity based models</h2><span id='topic+LikGradHess.general'></span>

<h3>Description</h3>

<p>Likelihood, gradient and Hessian for univariate transition intensity based models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LikGradHess.general(
  params,
  data = NULL,
  full.X = NULL,
  MM,
  pen.matr.S.lambda,
  aggregated.provided = FALSE,
  do.gradient = TRUE,
  do.hessian = TRUE,
  pmethod = "analytic",
  death,
  Qmatr.diagnostics.list = NULL,
  verbose = FALSE,
  parallel = FALSE,
  no_cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LikGradHess.general_+3A_params">params</code></td>
<td>
<p>Parameters vector.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_data">data</code></td>
<td>
<p>Dataset in proper format.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_full.x">full.X</code></td>
<td>
<p>Full design matrix.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_mm">MM</code></td>
<td>
<p>List of necessary setup quantities.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_pen.matr.s.lambda">pen.matr.S.lambda</code></td>
<td>
<p>Penalty matrix multiplied by smoothing parameter lambda.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_aggregated.provided">aggregated.provided</code></td>
<td>
<p>Whether aggregated form was provided (may become obsolete in the future if we see original dataset as special case of aggregated where <code>nrep = 1</code>).</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_do.gradient">do.gradient</code></td>
<td>
<p>Whether or not to compute the gradient.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_do.hessian">do.hessian</code></td>
<td>
<p>Whether or not to compute the Hessian.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_pmethod">pmethod</code></td>
<td>
<p>Method to be used for computation of transition probability matrix. See help of <code>msm()</code> for further details.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_death">death</code></td>
<td>
<p>Whether the last state is an absorbing state.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_qmatr.diagnostics.list">Qmatr.diagnostics.list</code></td>
<td>
<p>List of maximum absolute values of the Q matrices computed during model fitting.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print out the progress being made in computing the likelihood, gradient and Hessian.</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_parallel">parallel</code></td>
<td>
<p>Whether or not to use parallel computing (only for Windows users for now).</p>
</td></tr>
<tr><td><code id="LikGradHess.general_+3A_no_cores">no_cores</code></td>
<td>
<p>Number of cores used if parallel computing chosen. The default is 2. If <code>NULL</code>, all available cores are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Penalized likelihood, gradient and Hessian associated with model at given parameters, for use by trust region algorithm.
</p>

<hr>
<h2 id='logLik.fmsm'>Extract the log likelihood for the fitted multistate model</h2><span id='topic+logLik.fmsm'></span>

<h3>Description</h3>

<p>It extracts the log-likelihood for a fitted <code>fmsm</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmsm'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.fmsm_+3A_object">object</code></td>
<td>
<p>Fitted model object of class <code>fmsm</code> produced by function <code><a href="#topic+fmsm">fmsm</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.fmsm_+3A_...">...</code></td>
<td>
<p>Unused in this case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard logLik object.
</p>

<hr>
<h2 id='P.pred'>Predict and plot the transition probabilities</h2><span id='topic+P.pred'></span>

<h3>Description</h3>

<p>Function to predict and plot the estimated transition probabilities (and confidence intervals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>P.pred(object, newdata, get.CI = TRUE,
       n.sim.CI = 1000, prob.lev = 0.05,
       plot.P = FALSE, which.plots = NULL,
       rug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="P.pred_+3A_object">object</code></td>
<td>
<p>Fitted model object.</p>
</td></tr>
<tr><td><code id="P.pred_+3A_newdata">newdata</code></td>
<td>
<p>Dataframe containing the profile for which one wished to obtain the predicted transition probabilities.</p>
</td></tr>
<tr><td><code id="P.pred_+3A_get.ci">get.CI</code></td>
<td>
<p>Whether to compute the confidence intervals.</p>
</td></tr>
<tr><td><code id="P.pred_+3A_n.sim.ci">n.sim.CI</code></td>
<td>
<p>Number of simulations to be used for confidence intervals computation.</p>
</td></tr>
<tr><td><code id="P.pred_+3A_prob.lev">prob.lev</code></td>
<td>
<p>Probability level of confidence intervals.</p>
</td></tr>
<tr><td><code id="P.pred_+3A_plot.p">plot.P</code></td>
<td>
<p>Whether to output plots of transition probabilities.</p>
</td></tr>
<tr><td><code id="P.pred_+3A_which.plots">which.plots</code></td>
<td>
<p>Number between 1 and the maximum number of non-null transition probabilities. This can be used if only some plots are to be plotted.</p>
</td></tr>
<tr><td><code id="P.pred_+3A_rug">rug</code></td>
<td>
<p>Whether to include a rugplot of the observed transition times.</p>
</td></tr>
<tr><td><code id="P.pred_+3A_...">...</code></td>
<td>
<p>Other graphical arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated transition probabilities (and confidence intervals).
</p>
<table>
<tr><td><code>P.pred</code></td>
<td>
<p>Predicted transition probability matrix corresponding to the time horizon specified in <code>newdata</code>. This is a <code>nstates x nstates</code> matrix.</p>
</td></tr>
<tr><td><code>P.CI.lower</code></td>
<td>
<p>Matrix containing the lower bounds of the confidence intervals for the predicted transition probability matrix.</p>
</td></tr>
<tr><td><code>P.CI.upper</code></td>
<td>
<p>Matrix containing the upper bounds of the confidence intervals for the predicted transition probability matrix.</p>
</td></tr>
<tr><td><code>P.hist</code></td>
<td>
<p>List of predicted transition probability matrices computed at each time point specified in <code>newdata</code>. This is a <code>nstates x nstates x n.pred</code> array, where <code>n.pred</code> is the number of rows in <code>newdata</code>.</p>
</td></tr>
<tr><td><code>P.CI.lower.hist</code></td>
<td>
<p>List of matrices containing the lower bounds of the confidence intervals for each predicted transition probability matrix in <code>P.hist</code>..</p>
</td></tr>
<tr><td><code>P.CI.upper.hist</code></td>
<td>
<p>List of matrices containing the upper bounds of the confidence intervals for each predicted transition probability matrix in <code>P.hist</code>.</p>
</td></tr>
<tr><td><code>full.X</code></td>
<td>
<p>Full design matrix corresponding to the <code>newdata</code> provided.</p>
</td></tr>
<tr><td><code>P.sim.hist</code></td>
<td>
<p>List of transition probability matrices simulated to obtain the confidence intervals at each time point from <code>newdata</code>. May be useful to quickly obtain intervals for a different confidence level.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fmsm">fmsm</a></code>
</p>

<hr>
<h2 id='plot.fmsm'>Function to plot the smooths included in the model specifications.</h2><span id='topic+plot.fmsm'></span>

<h3>Description</h3>

<p>Function to plot the smooths included in the model specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmsm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fmsm_+3A_x">x</code></td>
<td>
<p>Fitted model object.</p>
</td></tr>
<tr><td><code id="plot.fmsm_+3A_...">...</code></td>
<td>
<p>Other graphical arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots the smooths.
</p>

<hr>
<h2 id='print.fmsm'>Print a fmsm object</h2><span id='topic+print.fmsm'></span>

<h3>Description</h3>

<p>The print method for the <code>fmsmObject</code> produced by <code><a href="#topic+fmsm">fmsm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmsm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fmsm_+3A_x">x</code></td>
<td>
<p><code>fmsm</code> object produced by function <code><a href="#topic+fmsm">fmsm</a></code>.</p>
</td></tr>
<tr><td><code id="print.fmsm_+3A_...">...</code></td>
<td>
<p>Unused in this case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print.fmsm</code> prints out a matrix summarising the positions of the transition intensities, the transition intensities formulae, the total number of observations, etc for the fitted multistate survival model.
</p>

<hr>
<h2 id='print.summary.fmsm'>Flexible transition intensity based models for univariate multistate processes</h2><span id='topic+print.summary.fmsm'></span>

<h3>Description</h3>

<p>Flexible transition intensity based models for univariate multistate processes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.fmsm'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.fmsm_+3A_x">x</code></td>
<td>
<p>Fitted model object.</p>
</td></tr>
<tr><td><code id="print.summary.fmsm_+3A_digits">digits</code></td>
<td>
<p>Number of digits printed in the output.</p>
</td></tr>
<tr><td><code id="print.summary.fmsm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>By default significance stars are printed alongside the output.</p>
</td></tr>
<tr><td><code id="print.summary.fmsm_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints model term summaries.
</p>

<hr>
<h2 id='Q.matr.setup.general'>Internal function</h2><span id='topic+Q.matr.setup.general'></span>

<h3>Description</h3>

<p>Internal function needed for setup of Q matrix and its first and second derivative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q.matr.setup.general(
  params,
  nstates,
  full.X,
  start.pos.par,
  l.short.formula,
  whereQ,
  firstD = TRUE,
  secondD = TRUE,
  bound.eta = FALSE,
  pos.optparams,
  pos.optparams2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q.matr.setup.general_+3A_params">params</code></td>
<td>
<p>Parameters vector.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_nstates">nstates</code></td>
<td>
<p>Number of states.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_full.x">full.X</code></td>
<td>
<p>Full design matrix.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_start.pos.par">start.pos.par</code></td>
<td>
<p>Positions within full parameters vector of starting point for each sub-parameters vector corresponding to each transition intensity specification.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_l.short.formula">l.short.formula</code></td>
<td>
<p>Number of transitions.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_whereq">whereQ</code></td>
<td>
<p>Positions within Q matrix of not-null transition intensities.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_firstd">firstD</code></td>
<td>
<p>Whether the first derivative of the Q matrix should be computed.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_secondd">secondD</code></td>
<td>
<p>Whether the second derivative of the Q matrix should be computed.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_bound.eta">bound.eta</code></td>
<td>
<p>Whether to bound the additive predictor, defaults to <code>FALSE</code>. This is only used for debugging purposes, do not change.</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_pos.optparams">pos.optparams</code></td>
<td>
<p>Vector with positions of parameters vector in the form used by the optimization algorithm (i.e. when one or more parameters are constrained to be equal these will only appear once).</p>
</td></tr>
<tr><td><code id="Q.matr.setup.general_+3A_pos.optparams2">pos.optparams2</code></td>
<td>
<p>Like <code>pos.optparams</code> but the count is not stopped at the constrained parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Q matrix and its first and second derivatives with respect to the parameters vector.
</p>

<hr>
<h2 id='Q.pred'>Predict and plot the transition intensities</h2><span id='topic+Q.pred'></span>

<h3>Description</h3>

<p>Function to predict and plot the estimated transition intensities (and confidence intervals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q.pred(object, newdata, get.CI = TRUE,
       n.sim.CI = 1000, prob.lev = 0.05,
       plot.Q = FALSE, which.plots = NULL,
       cond.list.2d = NULL, plot.Q.2d = FALSE,
       rug = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q.pred_+3A_object">object</code></td>
<td>
<p>Fitted model object.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_newdata">newdata</code></td>
<td>
<p>Dataframe containing the profile for which one wished to obtain the predicted transition intensities.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_get.ci">get.CI</code></td>
<td>
<p>Whether to compute the confidence intervals.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_n.sim.ci">n.sim.CI</code></td>
<td>
<p>Number of simulations to be used for confidence intervals computation.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_prob.lev">prob.lev</code></td>
<td>
<p>Probability level of confidence intervals.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_plot.q">plot.Q</code></td>
<td>
<p>Whether to output plots of transition intensities.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_which.plots">which.plots</code></td>
<td>
<p>Number between 1 and the maximum number of non-null transition intensities. This can be used if only some plots are to be plotted.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_cond.list.2d">cond.list.2d</code></td>
<td>
<p>Value of covariate(s) to be kept fixed in the plotting of 3D-transition intensities.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_plot.q.2d">plot.Q.2d</code></td>
<td>
<p>Whether to plot 3D transition intensities (only valid if 2D-smooths are present).</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_rug">rug</code></td>
<td>
<p>Whether to include a rugplot of the observed transition times.</p>
</td></tr>
<tr><td><code id="Q.pred_+3A_...">...</code></td>
<td>
<p>Other graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated transition intensities (and confidence intervals).
</p>
<table>
<tr><td><code>Q.hist</code></td>
<td>
<p>List of predicted transition intensity matrices computed at each time point specified in <code>newdata</code>. This is a <code>nstates x nstates x n.pred</code> array, where <code>n.pred</code> is the number of rows in <code>newdata</code>.</p>
</td></tr>
<tr><td><code>Q.CI.lower</code></td>
<td>
<p>Matrix containing the lower bounds of the confidence intervals for the predicted transition intensity matrix.</p>
</td></tr>
<tr><td><code>Q.CI.upper</code></td>
<td>
<p>Matrix containing the upper bounds of the confidence intervals for the predicted transition intensity matrix.</p>
</td></tr>
<tr><td><code>full.X</code></td>
<td>
<p>Full design matrix corresponding to the <code>newdata</code> provided.</p>
</td></tr>
<tr><td><code>Q.sim.hist</code></td>
<td>
<p>List of transition intensity matrices simulated to obtain the confidence intervals at each time point from <code>newdata</code>. May be useful to quickly obtain intervals for a different confidence level.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fmsm">fmsm</a></code>
</p>

<hr>
<h2 id='simulateIDM'>Function to predict and plot the estimated transition intensities (and confidence intervals).</h2><span id='topic+simulateIDM'></span>

<h3>Description</h3>

<p>Function to predict and plot the estimated transition intensities (and confidence intervals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateIDM(N = N, seed = seed, og.12 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateIDM_+3A_n">N</code></td>
<td>
<p>Total number of individuals.</p>
</td></tr>
<tr><td><code id="simulateIDM_+3A_seed">seed</code></td>
<td>
<p>Seed used for the simulation.</p>
</td></tr>
<tr><td><code id="simulateIDM_+3A_og.12">og.12</code></td>
<td>
<p>If <code>TRUE</code> a common shape for the first transition is used. If <code>FALSE</code> a sinusoid is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated data generated from an Illness-Death model (IDM).
</p>

<hr>
<h2 id='state.pairs.CT'>Function to extract state pair counts and observed (right) times.</h2><span id='topic+state.pairs.CT'></span>

<h3>Description</h3>

<p>Function to extract state pair counts and observed (right) times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state.pairs.CT(
  formula = NULL,
  data = NULL,
  whereQ = NULL,
  nstates = NULL,
  time = NULL,
  state = NULL,
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state.pairs.CT_+3A_formula">formula</code></td>
<td>
<p>Model specification.</p>
</td></tr>
<tr><td><code id="state.pairs.CT_+3A_data">data</code></td>
<td>
<p>Data.</p>
</td></tr>
<tr><td><code id="state.pairs.CT_+3A_whereq">whereQ</code></td>
<td>
<p>Placement of allowed transition intensities. Only for internal use. Defaults to <code>NULL</code> and is obtained automatically when <code>formula</code> is provided.</p>
</td></tr>
<tr><td><code id="state.pairs.CT_+3A_nstates">nstates</code></td>
<td>
<p>Total number of states. Only for internal use. Defaults to <code>NULL</code> and is obtained automatically when <code>formula</code> is provided.</p>
</td></tr>
<tr><td><code id="state.pairs.CT_+3A_time">time</code></td>
<td>
<p>Name of variable containing the time-to-event.</p>
</td></tr>
<tr><td><code id="state.pairs.CT_+3A_state">state</code></td>
<td>
<p>Name of variable containing the states.</p>
</td></tr>
<tr><td><code id="state.pairs.CT_+3A_id">id</code></td>
<td>
<p>Name of variable containing the unique code identifying the individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with the state-pair counts and a list with the observed (right) times for each transition.
</p>

<hr>
<h2 id='summary.fmsm'>Summary for fitted model ouput.</h2><span id='topic+summary.fmsm'></span>

<h3>Description</h3>

<p>Summary for fitted model ouput.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmsm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fmsm_+3A_object">object</code></td>
<td>
<p>Fitted model object.</p>
</td></tr>
<tr><td><code id="summary.fmsm_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary of fitted model object.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
