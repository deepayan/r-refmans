<!DOCTYPE html><html lang="en"><head><title>Help for package ids</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ids}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjective_animal'><p>Ids based on a number of adjectives and an animal</p></a></li>
<li><a href='#ids'><p>Generic id generating function</p></a></li>
<li><a href='#int_to_proquint'><p>Convert to and from proquints</p></a></li>
<li><a href='#proquint'><p>Generate random proquint identifiers</p></a></li>
<li><a href='#random_id'><p>Cryptographically generated random identifiers</p></a></li>
<li><a href='#sentence'><p>Sentence style identifiers</p></a></li>
<li><a href='#uuid'><p>Generate UUIDs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generate Random Identifiers</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate random or human readable and pronounceable identifiers.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/richfitz/ids">https://github.com/richfitz/ids</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/richfitz/ids/issues">https://github.com/richfitz/ids/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>openssl, uuid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rcorpora, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-05-31 08:43:42 UTC; rich</td>
</tr>
<tr>
<td>Author:</td>
<td>Rich FitzJohn [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rich FitzJohn &lt;rich.fitzjohn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-05-31 08:49:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjective_animal'>Ids based on a number of adjectives and an animal</h2><span id='topic+adjective_animal'></span>

<h3>Description</h3>

<p>Ids based on a number of adjectives and an animal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjective_animal(n = 1, n_adjectives = 1, style = "snake",
  max_len = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjective_animal_+3A_n">n</code></td>
<td>
<p>number of ids to return.  If <code>NULL</code>, it instead
returns the generating function</p>
</td></tr>
<tr><td><code id="adjective_animal_+3A_n_adjectives">n_adjectives</code></td>
<td>
<p>Number of adjectives to prefix the anmial with</p>
</td></tr>
<tr><td><code id="adjective_animal_+3A_style">style</code></td>
<td>
<p>Style to join words with.  Can be one of &quot;Pascal&quot;,
&quot;camel&quot;, &quot;snake&quot;, &quot;kebab&quot;, &quot;dot&quot;, &quot;title&quot;, &quot;sentence&quot;, &quot;lower&quot;,
&quot;upper&quot;, and &quot;constant&quot;.</p>
</td></tr>
<tr><td><code id="adjective_animal_+3A_max_len">max_len</code></td>
<td>
<p>The maximum length of a word part to include (this
may be useful because some of the names are rather long.  This
stops you generating a
<code>hexakosioihexekontahexaphobic_queenalexandrasbirdwingbutterfly</code>).
A vector of length 2 can be passed in here in which case the
first element will apply to the adjectives (all of them) and the
second element will apply to the animals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of adjectives and animals comes from
<a href="https://github.com/a-type/adjective-adjective-animal">https://github.com/a-type/adjective-adjective-animal</a>, and in
turn from <a href="gfycat.com">gfycat.com</a>
</p>


<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random identifier:
adjective_animal()

# Generate a bunch all at once:
adjective_animal(5)

# Control the style of punctuation with the style argument:
adjective_animal(style = "lower")
adjective_animal(style = "CONSTANT")
adjective_animal(style = "camel")
adjective_animal(style = "kebab")

# Control the number of adjectives used
adjective_animal(n_adjectives = 3)

# This can get out of hand quickly though:
adjective_animal(n_adjectives = 7)

# Limit the length of adjectives and animals used:
adjective_animal(10, max_len = 6)

# The lengths can be controlled for adjectives and animals
# separately, with Inf meaning no limit:
adjective_animal(10, max_len = c(6, Inf), n_adjectives = 2)

# Pass n = NULL to bind arguments to a function
id &lt;- adjective_animal(NULL, n_adjectives = 2, style = "dot", max_len = 6)
id()
id(10)
</code></pre>

<hr>
<h2 id='ids'>Generic id generating function</h2><span id='topic+ids'></span>

<h3>Description</h3>

<p>Generic id generating function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ids(n, ..., vals = list(...), style = "snake")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ids_+3A_n">n</code></td>
<td>
<p>number of ids to return.  If <code>NULL</code>, it instead
returns the generating function</p>
</td></tr>
<tr><td><code id="ids_+3A_...">...</code></td>
<td>
<p>A number of character vectors</p>
</td></tr>
<tr><td><code id="ids_+3A_vals">vals</code></td>
<td>
<p>A list of character vectors, <em>instead</em> of <code>...</code></p>
</td></tr>
<tr><td><code id="ids_+3A_style">style</code></td>
<td>
<p>Style to join words with.  Can be one of &quot;Pascal&quot;,
&quot;camel&quot;, &quot;snake&quot;, &quot;kebab&quot;, &quot;dot&quot;, &quot;title&quot;, &quot;sentence&quot;, &quot;lower&quot;,
&quot;upper&quot;, and &quot;constant&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a character vector of length <code>n</code>, or a
function of one argument if <code>n</code> is <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For an example, please see the vignette
</code></pre>

<hr>
<h2 id='int_to_proquint'>Convert to and from proquints</h2><span id='topic+int_to_proquint'></span><span id='topic+proquint_to_int'></span><span id='topic+proquint_word_to_int'></span><span id='topic+int_to_proquint_word'></span>

<h3>Description</h3>

<p>Convert to and from proquints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_to_proquint(x, use_cache = TRUE)

proquint_to_int(p, as = "numeric", use_cache = TRUE)

proquint_word_to_int(w, use_cache = TRUE, validate = TRUE)

int_to_proquint_word(i, use_cache = TRUE, validate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int_to_proquint_+3A_x">x</code></td>
<td>
<p>An integer (or integer-like) value to convert to a
proquint</p>
</td></tr>
<tr><td><code id="int_to_proquint_+3A_use_cache">use_cache</code></td>
<td>
<p>Because there are relatively few combinations per
word, and because constructing short strings is relatively
expensive in R, it may be useful to cache all 65536 possible
words.  If <code>TRUE</code> then the first time that this function is
used all words will be cached and the results used - the first
time may take up to ~1/4 of a second and subsequent calls will
be much faster.  The identifiers selected will not change with
this option (i.e., given a particular random seed, changing this
option will not affect the identifiers randomly selected).</p>
</td></tr>
<tr><td><code id="int_to_proquint_+3A_p">p</code></td>
<td>
<p>A character vector representing a proquint</p>
</td></tr>
<tr><td><code id="int_to_proquint_+3A_as">as</code></td>
<td>
<p>The target data type for conversion from proquint.  The
options are <code>integer</code>, <code>numeric</code> and <code>bignum</code>.
The first two will overflow given sufficiently large input -
this will throw an error (overflow is at
<code>.Machine$integer.max</code> and <code>2 / .Machine$double.eps - 1</code>
for <code>integer</code> and <code>numeric</code> respectively).  For
<code>bignum</code> this will return a <em>list</em> of <code>bignum</code>
elements <em>even if <code>p</code> is of length 1</em>.</p>
</td></tr>
<tr><td><code id="int_to_proquint_+3A_w">w</code></td>
<td>
<p>A proquint <em>word</em> (five letter string)</p>
</td></tr>
<tr><td><code id="int_to_proquint_+3A_validate">validate</code></td>
<td>
<p>Validate the range of inputs?  Because these
functions are used internally, they can skip input validation.
You can too if you promise to pass sanitised input in.  If
out-of-range values are passed in and validation is disabled the
behaviour is undefined and subject to change.</p>
</td></tr>
<tr><td><code id="int_to_proquint_+3A_i">i</code></td>
<td>
<p>An integer representing a single proquint word (in the
range 0:65535)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions try to be type safe and predictable about what
they will and will not return.
</p>
<p>For <code>proquint_to_int</code>, because numeric overflow is a
possibility, it is important to consider whether a proquint can be
meaninfully translated into an integer or a numeric and the
functions will throw an error rather than failing in a more
insidious way (promoting the type or returning NA).
</p>
<p><code>proquint_word_to_int</code> always retuns an integer vector of the
same length as the input.
</p>
<p>Missing values are allowed; a missing integer representation of a
proquint will translate as <code>NA_character_</code> and a missing
proquint will translate as <code>NA_integer_</code> (if <code>as =
"integer"</code>), <code>NA_real_</code>, if <code>as = "numeric"</code> or as
<code>NULL</code> (if <code>as = "bignum"</code>).
</p>
<p>Names are always discarded.  Future versions may gain an argument
<code>named</code> with a default of <code>FALSE</code>, but that setting to
<code>TRUE</code> would preseve names.  Let me know if this would be
useful.
</p>

<hr>
<h2 id='proquint'>Generate random proquint identifiers</h2><span id='topic+proquint'></span>

<h3>Description</h3>

<p>Generate random &quot;proquint&quot; identifiers.  &quot;proquint&quot; stands for
PRO-nouncable QUINT-uplets and were described by Daniel Wilkerson
in <a href="https://arxiv.org/html/0901.4016">https://arxiv.org/html/0901.4016</a>.  Each &quot;word&quot; takes one
of <code class="reqn">2^16</code> possibilities.  A four word proquint has a keyspace
of <code class="reqn">10^19</code> possibilities but takes only 23 characters.
Proquint identifiers can be interchanged with integers (though
this is totally optional); see <code><a href="#topic+proquint_to_int">proquint_to_int</a></code> and
the other functions documented on that page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proquint(n = 1, n_words = 2L, use_cache = TRUE, use_openssl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proquint_+3A_n">n</code></td>
<td>
<p>number of ids to return.  If <code>NULL</code>, it instead
returns the generating function</p>
</td></tr>
<tr><td><code id="proquint_+3A_n_words">n_words</code></td>
<td>
<p>The number of words for each identifier; each word
has <code>2^16</code> (65536) possible combinations, a two-word
proquint has <code>2^32</code> possible combinations and an
<code>k</code>-word proquint has <code>2^(k * 16)</code> possible
combinations.</p>
</td></tr>
<tr><td><code id="proquint_+3A_use_cache">use_cache</code></td>
<td>
<p>Because there are relatively few combinations per
word, and because constructing short strings is relatively
expensive in R, it may be useful to cache all 65536 possible
words.  If <code>TRUE</code> then the first time that this function is
used all words will be cached and the results used - the first
time may take up to ~1/4 of a second and subsequent calls will
be much faster.  The identifiers selected will not change with
this option (i.e., given a particular random seed, changing this
option will not affect the identifiers randomly selected).</p>
</td></tr>
<tr><td><code id="proquint_+3A_use_openssl">use_openssl</code></td>
<td>
<p>Use openssl for random number generation, with
the primary effect that the identifiers will not be affected by
R's random seed (at a small speed cost).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the abstract of their paper, Wilkerson introduces proquints:
</p>
<p>&quot;Identifiers (IDs) are pervasive throughout our modern
life. We suggest that these IDs would be easier to manage and
remember if they were easily readable, spellable, and
pronounceable. As a solution to this problem we propose using
PRO-nouncable QUINT-uplets of alternating unambiguous consonants
and vowels: proquints.&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A single, two word, proquint
proquint()

# Longer identifier:
proquint(n_words = 5)

# More identifiers
proquint(10)
</code></pre>

<hr>
<h2 id='random_id'>Cryptographically generated random identifiers</h2><span id='topic+random_id'></span>

<h3>Description</h3>

<p>Random identifiers.  By default this uses the <code>openssl</code>
package to produce a random set of bytes, and expresses that as a
hex character string.  This does not affect R's random number
stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_id(n = 1, bytes = 16, use_openssl = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_id_+3A_n">n</code></td>
<td>
<p>number of ids to return.  If <code>NULL</code>, it instead
returns the generating function</p>
</td></tr>
<tr><td><code id="random_id_+3A_bytes">bytes</code></td>
<td>
<p>The number of bytes to include for each identifier.
The length of the returned identifiers will be twice this long
with each pair of characters representing a single byte.</p>
</td></tr>
<tr><td><code id="random_id_+3A_use_openssl">use_openssl</code></td>
<td>
<p>A logical, indicating if we should use the
openssl for generating the random identifiers.  The openssl
random bytestream is not affected by the state of the R random
number generator (e.g., via <code><a href="base.html#topic+set.seed">set.seed</a></code>) so may not be
suitable for use where reproducibility is important.  The speed
should be very similar for both approaches.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random id:
random_id()

# Generate 10 of them!
random_id(10)

# Different length ids
random_id(bytes = 8)
# (note that the number of characters is twice the number of bytes)

# The ids are not affected by R's RNG state:
set.seed(1)
(id1 &lt;- random_id())
set.seed(1)
(id2 &lt;- random_id())
# The generated identifiers are different, despite the seed being the same:
id1 == id2

# If you need these identifiers to be reproducible, pass use_openssl = FALSE
set.seed(1)
(id1 &lt;- random_id(use_openssl = FALSE))
set.seed(1)
(id2 &lt;- random_id(use_openssl = FALSE))
# This time they are the same:
id1 == id2

# Pass \code{n = NULL} to generate a function that binds your arguments:
id8 &lt;- random_id(NULL, bytes = 8)
id8(10)
</code></pre>

<hr>
<h2 id='sentence'>Sentence style identifiers</h2><span id='topic+sentence'></span>

<h3>Description</h3>

<p>Create a sentence style identifier.  This uses the approach
described by Asana on their blog
<a href="https://blog.asana.com/2011/09/6-sad-squid-snuggle-softly/">https://blog.asana.com/2011/09/6-sad-squid-snuggle-softly/</a>.
This approach encodes 32 bits of information (so 2^32 ~= 4 billion
possibilities) and in theory can be remapped to an integer if you
really wanted to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sentence(n = 1, style = "snake", past = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sentence_+3A_n">n</code></td>
<td>
<p>number of ids to return.  If <code>NULL</code>, it instead
returns the generating function</p>
</td></tr>
<tr><td><code id="sentence_+3A_style">style</code></td>
<td>
<p>Style to join words with.  Can be one of &quot;Pascal&quot;,
&quot;camel&quot;, &quot;snake&quot;, &quot;kebab&quot;, &quot;dot&quot;, &quot;title&quot;, &quot;sentence&quot;, &quot;lower&quot;,
&quot;upper&quot;, and &quot;constant&quot;.</p>
</td></tr>
<tr><td><code id="sentence_+3A_past">past</code></td>
<td>
<p>Use the past tense for verbs (e.g., slurped or jogged
rather than slurping or jogging)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate an identifier
sentence()

# Generate a bunch
sentence(10)

# As with adjective_animal, use "style" to control punctuation
sentence(style = "Camel")
sentence(style = "dot")
sentence(style = "Title")

# Change the tense of the verb:
set.seed(1)
sentence()
set.seed(1)
sentence(past = TRUE)

# Pass n = NULL to bind arguments to a function
id &lt;- sentence(NULL, past = TRUE, style = "dot")
id()
id(10)
</code></pre>

<hr>
<h2 id='uuid'>Generate UUIDs</h2><span id='topic+uuid'></span>

<h3>Description</h3>

<p>Generate UUIDs using the uuid package.  This is simply a thin
wrapper around <code>uuid::UUIDgenerate</code> that matches the interface
in the rest of the ids package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uuid(n = 1, drop_hyphens = FALSE, use_time = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uuid_+3A_n">n</code></td>
<td>
<p>number of ids to return.  If <code>NULL</code>, it instead
returns the generating function</p>
</td></tr>
<tr><td><code id="uuid_+3A_drop_hyphens">drop_hyphens</code></td>
<td>
<p>Drop the hyphens from the UUID?</p>
</td></tr>
<tr><td><code id="uuid_+3A_use_time">use_time</code></td>
<td>
<p>Passed through to <code>UUIDgenerate</code> as <code>use.time</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rich FitzJohn
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate one id
uuid()

# Or a bunch
uuid(10)

# More in the style of random_id()
uuid(drop_hyphens = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
