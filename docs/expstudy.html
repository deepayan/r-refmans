<!DOCTYPE html><html><head><title>Help for package expstudy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {expstudy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_fct_adjs'><p>Calculate adjustment factors for an underlying assumption</p></a></li>
<li><a href='#defunct'><p>Defunct functions</p></a></li>
<li><a href='#expstudy-package'><p>expstudy: Tools for Actuarial Experience Studies</p></a></li>
<li><a href='#guess_measure_sets'><p>Guess a measure set using regexs</p></a></li>
<li><a href='#metrics'><p>Experience study metrics</p></a></li>
<li><a href='#mortexp'><p>Mortality experience study</p></a></li>
<li><a href='#mutate_expecvar'><p>Add new expecteds and variances to an experience study</p></a></li>
<li><a href='#mutate_metrics'><p>Add common metrics to an experience study</p></a></li>
<li><a href='#summarise_measures'><p>Aggregate an experience study</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Actuarial Experience Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Experiences studies are an integral component of the actuarial 
    control cycle. Regardless of the decrement or policyholder behavior of 
    interest, the analyses conducted is often the same. Ultimately, this 
    package aims to reduce time spent writing the same code used for 
    different experience studies, therefore increasing the time for to uncover
    new insights inherit within the relevant experience.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cb12991/expstudy">https://github.com/cb12991/expstudy</a>,
<a href="https://cb12991.github.io/expstudy/">https://cb12991.github.io/expstudy/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cb12991/expstudy/issues">https://github.com/cb12991/expstudy/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, lifecycle, rlang, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, roxygen2, testthat</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 14:00:14 UTC; GRC3B</td>
</tr>
<tr>
<td>Author:</td>
<td>Cody Buehler [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cody Buehler &lt;cb12991@me.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 14:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_fct_adjs'>Calculate adjustment factors for an underlying assumption</h2><span id='topic+compute_fct_adjs'></span>

<h3>Description</h3>

<p>There often are situations where an industry table is used for an assumed
rate due to a company lacking sufficient credibility to write their own
assumption. However, as experience becomes more available, a company would
likely want to incorporate this experience into the industry assumption
because it provides valuable insight into their own policyholders. A common
industry approach is to apply &quot;factor adjustments&quot; developed using company
experience to the industry assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_fct_adjs(
  .data,
  expected_rate,
  measure_sets = guess_measure_sets(.data),
  amount_scalar = NULL,
  method = c("simultaneous", "sequential"),
  cred_wt_adjs = FALSE,
  balance_adjs = FALSE,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_fct_adjs_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> that houses an experience study.</p>
</td></tr>
<tr><td><code id="compute_fct_adjs_+3A_expected_rate">expected_rate</code></td>
<td>
<p>The underlying expected rate in the experience study for which factor
adjustments are being generated for.</p>
</td></tr>
<tr><td><code id="compute_fct_adjs_+3A_measure_sets">measure_sets</code></td>
<td>
<p>A (potentially named) list of measure sets. Only need to specify once if
chaining multiple <code>expstudy</code> functions as the <code>measure_sets</code> will be
passed as an attribute in results.</p>
</td></tr>
<tr><td><code id="compute_fct_adjs_+3A_amount_scalar">amount_scalar</code></td>
<td>
<p>A numeric vector to use when determining amount-weighted expecteds and
variances. The function will determine whether or not the new
expecteds/variances are amount-weighted if the corresponding actuals in
the study have values greater than 1 (actuals that are not
amount-weighted, i.e., counts, should only be 0 or 1).</p>
</td></tr>
<tr><td><code id="compute_fct_adjs_+3A_method">method</code></td>
<td>
<p>String indicating the method of determining factor adjustments:
</p>
<div class="sourceCode"><pre>* `simultaneous` will calculate factor adjustments for all combinations
of group values in one iteration.
* `sequential` will calculate factor adjustments for each grouping
variable individually and applies that factor adjustment to the
underlying expected rate before continuing with the next grouping
variable's factor computation.
</pre></div></td></tr>
<tr><td><code id="compute_fct_adjs_+3A_cred_wt_adjs">cred_wt_adjs</code></td>
<td>
<p>Logical indicating if factor adjustments should be credibility-weighted
using partial credibility scores.</p>
</td></tr>
<tr><td><code id="compute_fct_adjs_+3A_balance_adjs">balance_adjs</code></td>
<td>
<p>Logical indicating if credibility-weighted adjustments should be scaled to
produce a 100% A/E ratio in aggregate (has no effect if
<code>cred_wt_adjs = FALSE</code>).</p>
</td></tr>
<tr><td><code id="compute_fct_adjs_+3A_na.rm">na.rm</code></td>
<td>
<p>logical.  Should missing values (including <code>NaN</code>) be
removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function piggy-backs off of <code>measure_sets</code> defined in other expstudy
functions to quickly produce factor adjustments under a variety of methods.
Providing a <code><a href="dplyr.html#topic+grouped_df">dplyr::grouped_df()</a></code> will generate factors for each group
according to the method specified. If two or more grouping variables are
provided, an additional &quot;composite&quot; factor adjustment will also be generated
which is the product of each individual adjustment.
</p>


<h3>Value</h3>

<p>A list of data frames that house factor adjustments for each measure set
provided in <code>measure_sets</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mortexp |&gt;
  dplyr::group_by(
    GENDER,
    SMOKING_STATUS
  ) |&gt;
  compute_fct_adjs(
    EXPECTED_MORTALITY_RT,
    amount_scalar = FACE_AMOUNT
  )

</code></pre>

<hr>
<h2 id='defunct'>Defunct functions</h2><span id='topic+defunct'></span><span id='topic+add_proportions'></span><span id='topic+add_metrics'></span><span id='topic+add_credibility'></span><span id='topic+compile_results'></span><span id='topic+aggregate'></span><span id='topic+expstudy'></span><span id='topic+format_metrics'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#defunct"><img src="../help/figures/lifecycle-defunct.svg" alt='[Defunct]' /></a>
</p>
<p>These functions were part of the initial release of <code>expstudy</code> but are now
defunct. If there's a known replacement, calling the function
will tell you about it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Deprecated in 2.0.0 -------------------------------------

add_proportions(expstudy, ..., .base_grp_nms = character(0), .min_ungrpd = 0L)

add_metrics(
  expstudy,
  ...,
  .metrics = c("act2expec", "act2expos", "expec2expos"),
  .metric_nms = list(act2expec = "ACTUAL_TO_EXPECTED", act2expos = "ACTUAL_TO_EXPOSED",
    expec2expos = "EXPECTED_TO_EXPOSED")
)

add_credibility(
  expstudy,
  .cred_k = 0.05,
  .cred_p = 0.95,
  .cred_nms = "CREDIBILITY"
)

compile_results(
  expstudy,
  ...,
  output = c("metrics", "proportions"),
  output_args = list(metrics = NULL, proportions = NULL),
  output_format = c("unformatted", "formatted")
)

aggregate(expstudy, ..., .oth_sum_vars = NULL)

expstudy(data, actuals, expecteds, exposures, variances = NULL, keys = NULL)

format_metrics(expstudy)
</code></pre>

<hr>
<h2 id='expstudy-package'>expstudy: Tools for Actuarial Experience Studies</h2><span id='topic+expstudy-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Experiences studies are an integral component of the actuarial control cycle. Regardless of the decrement or policyholder behavior of interest, the analyses conducted is often the same. Ultimately, this package aims to reduce time spent writing the same code used for different experience studies, therefore increasing the time for to uncover new insights inherit within the relevant experience.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Cody Buehler <a href="mailto:cb12991@me.com">cb12991@me.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cb12991/expstudy">https://github.com/cb12991/expstudy</a>
</p>
</li>
<li> <p><a href="https://cb12991.github.io/expstudy/">https://cb12991.github.io/expstudy/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cb12991/expstudy/issues">https://github.com/cb12991/expstudy/issues</a>
</p>
</li></ul>


<hr>
<h2 id='guess_measure_sets'>Guess a measure set using regexs</h2><span id='topic+guess_measure_sets'></span>

<h3>Description</h3>

<p>Attempt to guess the names of a <strong>measure set</strong> using regular expressions
(or regexs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_measure_sets(
  data,
  measure_regexs = getOption("expstudy.default_measure_regexs"),
  measure_set_prefixes = getOption("expstudy.default_measure_set_prefixes"),
  measure_set_suffixes = getOption("expstudy.default_measure_set_suffixes")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_measure_sets_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> that houses an experience study.</p>
</td></tr>
<tr><td><code id="guess_measure_sets_+3A_measure_regexs">measure_regexs</code></td>
<td>
<p>A named list of patterns to use as regexs when guessing columns in the
study dataset to be used for one study measure in each measure set. There
must be one column for each measure in a measure set (actuals, expecteds,
exposures, and variances). Defaults to
<code>getOption('expstudy.default_measure_regexs')</code>.</p>
</td></tr>
<tr><td><code id="guess_measure_sets_+3A_measure_set_prefixes">measure_set_prefixes</code>, <code id="guess_measure_sets_+3A_measure_set_suffixes">measure_set_suffixes</code></td>
<td>
<p>Character vectors that will be use to differentiate the same measure in
one measure set from another measure set. Using <code>NULL</code> indicates that
the study measures do not differ by prefix/suffix and will error if more
than one column is guessed using the measure regex for a single measure.
Defaults to measures sets not differing by prefix
(<code>measure_set_prefixes = NULL</code>) but do differ by count and amount
suffixes (<code>measure_set_prefixes = c('_CNT', '_AMT')</code>).
</p>
<p>If the experience study has columns that follow a consistent naming
structure, this function can seamlessly provide other <code>expstudy</code> functions
information on the study measures to use for various calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of measure sets that identify common variables used for
<code>expstudy</code> analyses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guess_measure_sets(mortexp)

</code></pre>

<hr>
<h2 id='metrics'>Experience study metrics</h2><span id='topic+metrics'></span><span id='topic+avg_observed'></span><span id='topic+avg_observed_vec'></span><span id='topic+avg_expected'></span><span id='topic+avg_expected_vec'></span><span id='topic+ci_fctr'></span><span id='topic+ci_fctr_vec'></span><span id='topic+ae_ratio'></span><span id='topic+ae_ratio_vec'></span><span id='topic+credibility'></span><span id='topic+credibility_vec'></span>

<h3>Description</h3>

<p>A collection of common metrics used in an actuarial environment are provided.
Two versions of each metric functions have been developed: one where it takes
a measure set for an experience study as its primary argument, and one where
vectors can be provided instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_observed(measure_set, ...)

avg_observed_vec(actuals, exposures, ...)

avg_expected(measure_set, ...)

avg_expected_vec(expecteds, exposures, ...)

ci_fctr(measure_set, se_conf = 0.95, two_tailed = TRUE, ...)

ci_fctr_vec(exposures, variances, se_conf = 0.95, two_tailed = TRUE, ...)

ae_ratio(measure_set, ...)

ae_ratio_vec(actuals, expecteds, ...)

credibility(measure_set, distance_from_mean = 0.05, cred_conf = 0.95, ...)

credibility_vec(
  expecteds,
  variances,
  distance_from_mean = 0.05,
  cred_conf = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics_+3A_measure_set">measure_set</code></td>
<td>
<p>A named character vector or list with each element mapping a column in
the experience study to one of the following measures: <code>actuals</code>,
<code>expecteds</code>, <code>exposures</code>, or <code>variances</code>.</p>
</td></tr>
<tr><td><code id="metrics_+3A_...">...</code></td>
<td>
<p>Not used directly and be left blank.</p>
</td></tr>
<tr><td><code id="metrics_+3A_actuals">actuals</code>, <code id="metrics_+3A_expecteds">expecteds</code>, <code id="metrics_+3A_exposures">exposures</code>, <code id="metrics_+3A_variances">variances</code></td>
<td>
<p>Columns in experience study that correspond to individual measures for
vector versions of metric functions.</p>
</td></tr>
<tr><td><code id="metrics_+3A_se_conf">se_conf</code></td>
<td>
<p>A number between 0 and 1 corresponding to the confidence level surrounding
the standard error calculation.</p>
</td></tr>
<tr><td><code id="metrics_+3A_two_tailed">two_tailed</code></td>
<td>
<p>A boolean indicating whether or not a two-tailed hypothesis test should be
utilized.</p>
</td></tr>
<tr><td><code id="metrics_+3A_distance_from_mean">distance_from_mean</code></td>
<td>
<p>A number between 0 and 1 representing the precision of the credibility
estimate.</p>
</td></tr>
<tr><td><code id="metrics_+3A_cred_conf">cred_conf</code></td>
<td>
<p>A number between 0 and 1 corresponding to the confidence level surrounding
the credibility calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Metric functions that use a measure set as its primary argument are intended
to be used with <code><a href="#topic+mutate_metrics">mutate_metrics()</a></code> and return a (<code>quosure</code>)<code><a href="rlang.html#topic+defusing-advanced">rlang::quo()</a></code>.
Use the vector versions (those ending in <code style="white-space: pre;">&#8288;_vec&#8288;</code>) if instead a numeric vector
result is desired.
</p>


<h3>Value</h3>

<p>Measure set versions return a (<code>quosure</code>)<code><a href="rlang.html#topic+defusing-advanced">rlang::quo()</a></code> to be evaluated in
<code><a href="#topic+mutate_metrics">mutate_metrics()</a></code>. Vector versions numeric vector
of the same length of measures used in the calculation per group (if
grouping applied).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>avg_observed()</code>: Calculates the average actual decrements observed per unit of exposure.
</p>
</li>
<li> <p><code>avg_expected()</code>: Calculates the average expected decrements per unit of exposure.
</p>
</li>
<li> <p><code>ci_fctr()</code>: Calculates the additive factor which constructs a confidence interval
around the expected decrement rate for a given level of confidence.
</p>
</li>
<li> <p><code>ae_ratio()</code>: Calculates the ratio of actual decrements to expected decrements, also
referred to as the AE ratio.
</p>
</li>
<li> <p><code>credibility()</code>: Calculates the credibility score according to limited fluctuation
credibility theory.
</p>
</li></ul>

<hr>
<h2 id='mortexp'>Mortality experience study</h2><span id='topic+mortexp'></span>

<h3>Description</h3>

<p>A dataset containing an example of a mortality experience study for 1000
fictional whole life insurance policyholders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mortexp
</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame()</a></code> with over 175,000 rows and 24 columns:
</p>

<dl>
<dt><code>AS_OF_DATE</code></dt><dd>
<p>This indicates which point in time a record encompasses.
</p>
</dd>
<dt><code>POLICY_HOLDER</code></dt><dd>
<p>An index used to distinguish policyholders. In this example the
policyholder is also the (only) insured.
</p>
</dd>
<dt>
<code>GENDER</code>,
<code>SMOKING_STATUS</code>,
<code>UNDERWRITING_CLASS</code>,
<code>INSURED_DOB</code>,
<code>ISSUE_DATE</code>,
<code>ISSUE_AGE</code>
</dt><dd>
<p>Various characteristics of an insured at time of issue.
</p>
</dd>
<dt><code>FACE_AMOUNT</code></dt><dd>
<p>Face amount of insurance for a corresponding policy.
</p>
</dd>
<dt><code>TERMINATION_DATE</code></dt><dd>
<p>If terminated, the effective date of termination. An <code>NA</code> value will be
listed for policies that are still in-force.
</p>
</dd>
<dt><code>ATTAINED_AGE</code></dt><dd>
<p>The age of the insured at the record's <code>AS_OF_DATE</code>
</p>
</dd>
<dt><code>EXPECTED_MORTALITY_RT</code></dt><dd>
<p>An expected mortality rate for an insured. The rate is calculated
according to De Moivre's Law (also known as uniform distribution of
deaths, or <code class="reqn">\text{UDD}</code>) with <code class="reqn">\omega=120</code>.
</p>
</dd>
<dt><code>POLICY_DURATION_MNTH</code>, <code>POLICY_DURATION_YR</code></dt><dd>
<p>Temporal indices describing how long a policy has been in-force at the
<code>AS_OF_DATE</code>. For example, when a policy is first issued (i.e.,
<code class="reqn">t=0</code>), it is in policy duration year one and policy duration month
one.
</p>
</dd>
<dt><code>POLICY_STATUS</code></dt><dd>
<p>The current status of the policy, either in-force, surrendered, or
death. The value will be listed for each policy record even though a
decrement only occurs at the end of the policy's duration (for policies
which are no longer in-force).
</p>
</dd>
<dt><code>MORT_EXPOSURE_CNT</code>,<code>MORT_EXPOSURE_AMT</code></dt><dd>
<p>Measures how many policyholders or how much face amount of insurance is
exposed to the risk of decrement for an associated observations.
</p>
</dd>
<dt><code>MORT_ACTUAL_CNT</code>,<code>MORT_ACTUAL_AMT</code></dt><dd>
<p>Measures the decrement occurrence on a policy count or face amount of
insurance basis.
</p>
</dd>
<dt><code>MORT_EXPECTED_CNT</code>,<code>MORT_EXPECTED_AMT</code></dt><dd>
<p>Measures the expected decrement value for an associated observation on a
policy count or face amount of insurance basis.
</p>
</dd>
<dt><code>MORT_VARIANCE_CNT</code>,<code>MORT_VARIANCE_AMT</code></dt><dd>
<p>Measures the variance of the decrement expectation, also on a policy
count or face amount of insurance basis. Used to calculate credibility
scores and confidence intervals.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>All policy record detail is randomly generated. See
<a href="https://www.soa.org/globalassets/assets/Files/Research/2016-10-experience-study-calculations.pdf">the Society of Actuaries' publication on experience study calculations</a>
for additional information regarding experience study calculations.
</p>

<hr>
<h2 id='mutate_expecvar'>Add new expecteds and variances to an experience study</h2><span id='topic+mutate_expecvar'></span>

<h3>Description</h3>

<p><code>mutate_expecvar()</code> uses a new expected rate for a decrement of interest and
adds a corresponding expected decrements column and corresponding variance
of expected decrements column. If there are already expecteds and variances
measures within the study dataset, either new, prefixed columns will be
added or the current expecteds and variances can be overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_expecvar(
  .data,
  new_expected_rates,
  new_expecvar_prefix = "auto",
  measure_sets = guess_measure_sets(.data),
  amount_scalar = NULL,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_expecvar_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> that houses an experience study.</p>
</td></tr>
<tr><td><code id="mutate_expecvar_+3A_new_expected_rates">new_expected_rates</code></td>
<td>
<p>A numeric vector to use as the expected probability for the study's event
of interest (i.e., policy lapse or insured death). This can be a column
in the dataset or a new numeric vector of length 1 or <code>nrow(.data)</code>.</p>
</td></tr>
<tr><td><code id="mutate_expecvar_+3A_new_expecvar_prefix">new_expecvar_prefix</code></td>
<td>
<p>A string to distinguish the new expecteds and variances columns in the
dataset. To overwrite existing expecteds and variances columns, use an
argument value of <code>NULL</code>, <code>character()</code>, or <code>''</code>. The default <code>'auto'</code> will
add a numeric prefix based on the previous names of expecteds/variances so
that names will remain unique.</p>
</td></tr>
<tr><td><code id="mutate_expecvar_+3A_measure_sets">measure_sets</code></td>
<td>
<p>A (potentially named) list of measure sets. Only need to specify once if
chaining multiple <code>expstudy</code> functions as the <code>measure_sets</code> will be
passed as an attribute in results.</p>
</td></tr>
<tr><td><code id="mutate_expecvar_+3A_amount_scalar">amount_scalar</code></td>
<td>
<p>A numeric vector to use when determining amount-weighted expecteds and
variances. The function will determine whether or not the new
expecteds/variances are amount-weighted if the corresponding actuals in
the study have values greater than 1 (actuals that are not
amount-weighted, i.e., counts, should only be 0 or 1).</p>
</td></tr>
<tr><td><code id="mutate_expecvar_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="mutate_expecvar_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_expecvar_+3A_.before">.before</code>, <code id="mutate_expecvar_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Columns from <code>.data</code> will be preserved according to the <code>.keep</code> argument.
</p>
</li>
<li><p> Existing columns that are modified by <code>...</code> will always be returned in
their original location.
</p>
</li>
<li><p> New columns created through <code>...</code> will be placed according to the
<code>.before</code> and <code>.after</code> arguments.
</p>
</li>
<li><p> The number of rows is not affected.
</p>
</li>
<li><p> Columns given the value <code>NULL</code> will be removed.
</p>
</li>
<li><p> Groups will be recomputed if a grouping variable is mutated.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Underlying Assumptions</h3>

<p>This function was developed according to current industry practice relating
to experience study calculations. Some of the assumptions incorporated are
briefly outlined below.
</p>

<ol>
<li><p> The experience study data is at a seriatim level where repeated
observations of multiple units can exist. For example, the study data can
contain experience for multiple policies over multiple calendar or policy
years.
</p>
</li>
<li><p> Each decrement event can be described as a Bernoulli random variable with
expected rate of decrement equal to $p$. Furthermore, combining multiple
observation units with equal rates of decrement $p$ can be considered a
Binomial random variable with $n$ equal to the number of observation units.
</p>
</li>
<li><p> Decrements are considered to be uniform between observations.
</p>
</li></ol>

<p>With these assumptions, new expecteds that are not amount-weighted are
calculated as the product of exposures and the expected decrement rate, new
variances are calculated as the product of the previously calculated new
expecteds and 1 minus the previously calculated new expecteds.
Amount-weighted expecteds and variances follow the prior calculations and
additionally multiply by the amount scalar and amount scalar squared,
respectively.
</p>
<p>For a more detailed explanation of these methods used, please refer to the
<a href="https://www.soa.org/globalassets/assets/Files/Research/2016-10-experience-study-calculations.pdf">Society of Actuary's publication over experience study calculations</a>.
</p>


<h3>Naming convention</h3>

<p><code>expstudy</code> uses a naming convention where some functions are prefixed by the
underling <code>dplyr</code> verb. The purpose of this is to associate the resulting
structure of the <code>expstudy</code> function with a very similar output as what the
<code>dplyr</code> function would produce. Note that the intention here is not replace
all <code>dplyr</code> use cases but instead add specific functionality to streamline
routine experience study analyses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mortexp |&gt;
  dplyr::mutate(
    NEW_EXPECTED_MORT_RT = runif(n = nrow(mortexp))
  ) |&gt;
  mutate_expecvar(
    new_expected_rates = NEW_EXPECTED_MORT_RT,
    new_expecvar_prefix = 'ADJ_',
    amount_scalar = FACE_AMOUNT
  )

</code></pre>

<hr>
<h2 id='mutate_metrics'>Add common metrics to an experience study</h2><span id='topic+mutate_metrics'></span>

<h3>Description</h3>

<p><code>mutate_metrics()</code> calculates metrics for an experience study using common
measures associated with the data. These measures are identified via the
<code>measure_sets</code> argument which can be provided directly or be guessed using
regular expressions (<code>regexs</code>). See <code><a href="#topic+guess_measure_sets">guess_measure_sets()</a></code> for additional
detail on how this guessing is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_metrics(
  .data,
  measure_sets = guess_measure_sets(.data),
  metrics = list(AVG_OBSRV = avg_observed, AVG_EXPEC = avg_expected, CI_FCTR = ci_fctr,
    AE_RATIO = ae_ratio, CREDIBILITY = credibility),
  ...,
  .by = NULL,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_metrics_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> that houses an experience study.</p>
</td></tr>
<tr><td><code id="mutate_metrics_+3A_measure_sets">measure_sets</code></td>
<td>
<p>A (potentially named) list of measure sets. Only need to specify once if
chaining multiple <code>expstudy</code> functions as the <code>measure_sets</code> will be
passed as an attribute in results.</p>
</td></tr>
<tr><td><code id="mutate_metrics_+3A_metrics">metrics</code></td>
<td>
<p>A named list of functions to calculate <a href="#topic+metrics">metrics</a>. Each function will be
applied to each set identified in <code>measure_sets</code>.</p>
</td></tr>
<tr><td><code id="mutate_metrics_+3A_...">...</code></td>
<td>
<p>Additional (optional) arguments passed along to each
(metric function)<a href="#topic+metrics">metrics</a>.</p>
</td></tr>
<tr><td><code id="mutate_metrics_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
<tr><td><code id="mutate_metrics_+3A_.keep">.keep</code></td>
<td>
<p>Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_metrics_+3A_.before">.before</code>, <code id="mutate_metrics_+3A_.after">.after</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is structured in a way that uses sets of measures within the
study as the first function argument of each metric function. The default
argument uses a set of metric functions, provided by <code>expstudy</code>, which are
commonly requested metrics used in actuarial analyses. For convenience,
a vectorized version of these default metric functions have also been
provided; see <a href="#topic+metrics">metrics</a> for more information.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. The output has the following
properties:
</p>

<ul>
<li><p> Columns from <code>.data</code> will be preserved according to the <code>.keep</code> argument.
</p>
</li>
<li><p> Existing columns that are modified by <code>...</code> will always be returned in
their original location.
</p>
</li>
<li><p> New columns created through <code>...</code> will be placed according to the
<code>.before</code> and <code>.after</code> arguments.
</p>
</li>
<li><p> The number of rows is not affected.
</p>
</li>
<li><p> Columns given the value <code>NULL</code> will be removed.
</p>
</li>
<li><p> Groups will be recomputed if a grouping variable is mutated.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Naming convention</h3>

<p><code>expstudy</code> uses a naming convention where some functions are prefixed by the
underling <code>dplyr</code> verb. The purpose of this is to associate the resulting
structure of the <code>expstudy</code> function with a very similar output as what the
<code>dplyr</code> function would produce. Note that the intention here is not replace
all <code>dplyr</code> use cases but instead add specific functionality to streamline
routine experience study analyses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Metrics can be added at a seriatim level, but often are
# calculated after some aggregation is applied to a cohort:
mortexp |&gt;
  dplyr::group_by(
    GENDER
  ) |&gt;
  summarise_measures() |&gt;
  mutate_metrics()

</code></pre>

<hr>
<h2 id='summarise_measures'>Aggregate an experience study</h2><span id='topic+summarise_measures'></span>

<h3>Description</h3>

<p><code>summarise_measures()</code> functions the same as <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code> and
returns a new data frame per combination of grouping variable. However,
this function is is streamlined to return the sum of an experience study's
measures instead of any arbitrary summary function. These measures are
identified via the <code>measure_sets</code> argument which can be provided directly
or be guessed using regular expressions (<code>regexs</code>). See
<code><a href="#topic+guess_measure_sets">guess_measure_sets()</a></code> for additional detail on how this guessing is
implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_measures(
  .data,
  measure_sets = guess_measure_sets(.data),
  na.rm = TRUE,
  .groups = "drop",
  .by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_measures_+3A_.data">.data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> that houses an experience study.</p>
</td></tr>
<tr><td><code id="summarise_measures_+3A_measure_sets">measure_sets</code></td>
<td>
<p>A (potentially named) list of measure sets. Only need to specify once if
chaining multiple <code>expstudy</code> functions as the <code>measure_sets</code> will be
passed as an attribute in results.</p>
</td></tr>
<tr><td><code id="summarise_measures_+3A_na.rm">na.rm</code></td>
<td>
<p>logical.  Should missing values (including <code>NaN</code>) be
removed?</p>
</td></tr>
<tr><td><code id="summarise_measures_+3A_.groups">.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the
result.
</p>

<ul>
<li><p> &quot;drop_last&quot;: dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li><p> &quot;drop&quot;: All levels of grouping are dropped.
</p>
</li>
<li><p> &quot;keep&quot;: Same grouping structure as <code>.data</code>.
</p>
</li>
<li><p> &quot;rowwise&quot;: Each row is its own group.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it is chosen
based on the number of rows of the results:
</p>

<ul>
<li><p> If all the results have 1 row, you get &quot;drop_last&quot;.
</p>
</li>
<li><p> If the number of rows varies, you get &quot;keep&quot; (note that returning a
variable number of rows was deprecated in favor of <code><a href="dplyr.html#topic+reframe">reframe()</a></code>, which
also unconditionally drops all levels of grouping).
</p>
</li></ul>

<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option &quot;dplyr.summarise.inform&quot; is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</td></tr>
<tr><td><code id="summarise_measures_+3A_.by">.by</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to <code><a href="dplyr.html#topic+group_by">group_by()</a></code>. For
details and examples, see <a href="dplyr.html#topic+dplyr_by">?dplyr_by</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object <em>usually</em> of the same type as <code>.data</code>.
</p>

<ul>
<li><p> The rows come from the underlying <code><a href="dplyr.html#topic+group_keys">group_keys()</a></code>.
</p>
</li>
<li><p> The columns are a combination of the grouping keys and the summary
expressions that you provide.
</p>
</li>
<li><p> The grouping structure is controlled by the <code style="white-space: pre;">&#8288;.groups=&#8288;</code> argument, the
output may be another <a href="dplyr.html#topic+grouped_df">grouped_df</a>, a <a href="dplyr.html#topic+tibble">tibble</a> or a <a href="dplyr.html#topic+rowwise">rowwise</a> data frame.
</p>
</li>
<li><p> Data frame attributes are <strong>not</strong> preserved, because <code>summarise()</code>
fundamentally creates a new data frame.
</p>
</li></ul>



<h3>Naming convention</h3>

<p><code>expstudy</code> uses a naming convention where some functions are prefixed by the
underling <code>dplyr</code> verb. The purpose of this is to associate the resulting
structure of the <code>expstudy</code> function with a very similar output as what the
<code>dplyr</code> function would produce. Note that the intention here is not replace
all <code>dplyr</code> use cases but instead add specific functionality to streamline
routine experience study analyses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mortexp |&gt;
  dplyr::group_by(
    UNDERWRITING_CLASS
  ) |&gt;
  summarise_measures()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
