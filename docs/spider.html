<!DOCTYPE html><html lang="en"><head><title>Help for package spider</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spider}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spider-package'><p>Species Identity and Evolution in R</p></a></li>
<li><a href='#anoteropsis'><p>Cytochrome oxidase I (COI) sequences of New Zealand _Anoteropsis_ species</p></a></li>
<li><a href='#bestCloseMatch'><p>Measures of identification accuracy</p></a></li>
<li><a href='#blockAlignment'><p>Make all sequences the same length</p></a></li>
<li><a href='#cgraph'><p>Complete graph</p></a></li>
<li><a href='#chaoHaplo'><p>Chao estimator of haplotype number</p></a></li>
<li><a href='#checkDNA'><p>Check a DNA alignment for missing data</p></a></li>
<li><a href='#dataStat'><p>Taxa statistics</p></a></li>
<li><a href='#dolomedes'><p>Cytochrome oxidase I (COI) sequences of New Zealand _Dolomedes_ species</p></a></li>
<li><a href='#haploAccum'><p>Haplotype accumulation curves</p></a></li>
<li><a href='#heatmapSpp'><p>Visualise a distance matrix using a heatmap</p></a></li>
<li><a href='#is.ambig'><p>Missing bases in alignments</p></a></li>
<li><a href='#localMinima'><p>Determine thresholds from a density plot</p></a></li>
<li><a href='#maxInDist'><p>Nearest non-conspecific and maximum intra-specific distances</p></a></li>
<li><a href='#minInDist'><p>Nearest non-conspecific and maximum intra-specific distances</p></a></li>
<li><a href='#monophyly'><p>Species monophyly over a tree</p></a></li>
<li><a href='#monophylyBoot'><p>Species monophyly over a tree</p></a></li>
<li><a href='#nearNeighbour'><p>Measures of identification accuracy</p></a></li>
<li><a href='#nonConDist'><p>Nearest non-conspecific and maximum intra-specific distances</p></a></li>
<li><a href='#nucDiag'><p>Nucleotide diagnostics for species alignments</p></a></li>
<li><a href='#ordinDNA'><p>Calculates a Principal Components Ordination of genetic distances</p></a></li>
<li><a href='#paa'><p>Population Aggregate Analysis</p></a></li>
<li><a href='#plot.haploAccum'><p>Plotting haplotype accumulation curves</p></a></li>
<li><a href='#plot.ordinDNA'><p>Plot an 'ordinDNA' object</p></a></li>
<li><a href='#plot.slidWin'><p>Plot a 'slidWin' object</p></a></li>
<li><a href='#polyBalance'><p>Balance of a phylogenetic tree with polytomies</p></a></li>
<li><a href='#rankSlidWin'><p>Rank a 'slidWin' object.</p></a></li>
<li><a href='#read.BOLD'><p>Downloads DNA sequences from the Barcode of Life Database (BOLD)</p></a></li>
<li><a href='#read.GB'><p>Download sequences from Genbank with metadata.</p></a></li>
<li><a href='#rmSingletons'><p>Detect and remove singletons</p></a></li>
<li><a href='#rnucDiag'><p>Nucleotide diagnostics for species alignments</p></a></li>
<li><a href='#rosenberg'><p>Rosenberg's probability of reciprocal monophyly</p></a></li>
<li><a href='#salticidae'><p>Cytochrome oxidase I (COI) sequences of world-wide species of Salticidae</p></a></li>
<li><a href='#sarkar'><p>Dummy sequences illustrating the categories of diagnostic nucleotides</p></a></li>
<li><a href='#search.BOLD'><p>Downloads DNA sequences from the Barcode of Life Database (BOLD)</p></a></li>
<li><a href='#seeBarcode'><p>Create illustrative barcodes</p></a></li>
<li><a href='#seqStat'><p>Sequence statistics</p></a></li>
<li><a href='#slideAnalyses'><p>Sliding window analyses</p></a></li>
<li><a href='#slideBoxplots'><p>Boxplots across windows</p></a></li>
<li><a href='#slideNucDiag'><p>Sliding nucleotide diagnostics</p></a></li>
<li><a href='#slidingWindow'><p>Create windows along an alignment</p></a></li>
<li><a href='#sppDist'><p>Intra and inter-specific distances</p></a></li>
<li><a href='#sppDistMatrix'><p>Mean intra- and inter-specific distance matrix</p></a></li>
<li><a href='#sppVector'>
<p>Species Vectors</p></a></li>
<li><a href='#stats.BOLD'><p>Downloads DNA sequences from the Barcode of Life Database (BOLD)</p></a></li>
<li><a href='#tajima.K'><p>Calculate Tajima's K index of divergence</p></a></li>
<li><a href='#tclust'><p>Clustering by a threshold</p></a></li>
<li><a href='#threshID'><p>Measures of identification accuracy</p></a></li>
<li><a href='#threshOpt'><p>Threshold optimisation</p></a></li>
<li><a href='#tiporder'><p>Orders tip labels by their position on the tree.</p></a></li>
<li><a href='#titv'><p>Number of pairwise transitions and transversions in an alignment.</p></a></li>
<li><a href='#tree.comp'><p>Tree comparisons</p></a></li>
<li><a href='#woodmouse'><p>Cytochrome b Gene Sequences of Woodmice</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Species Identity and Evolution in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-02-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel Brown, Rupert Collins, Stephane Boyer, Marie-Caroline Lefort, Jagoba Malumbres-Olarte, Cor Vink, Rob Cruickshank</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rupert A. Collins &lt;rupertcollins@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of species limits and DNA barcoding data. Included are functions for generating important summary statistics from DNA barcode data, assessing specimen identification efficacy, testing and optimizing divergence threshold limits, assessment of diagnostic nucleotides, and calculation of the probability of reciprocal monophyly. Additionally, a sliding window function offers opportunities to analyse information across a gene, often used for marker design in degraded DNA studies. Further information on the package has been published in Brown et al (2012) &lt;<a href="https://doi.org/10.1111%2Fj.1755-0998.2011.03108.x">doi:10.1111/j.1755-0998.2011.03108.x</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, pegas, graphics, stats, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-02-16 19:05:02 UTC; rc16041</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-02-16 19:33:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='spider-package'>Species Identity and Evolution in R</h2><span id='topic+spider-package'></span><span id='topic+spider'></span>

<h3>Description</h3>

<p>Spider: SPecies IDentity and Evolution in R, is an R package implementing a
number of useful analyses for DNA barcoding studies and associated research
into species delimitation and speciation. Included are functions for
generating summary statistics from DNA barcode data, assessing specimen
identification efficacy, and for testing and optimising divergence threshold
limits. In terms of investigating evolutionary and taxonomic questions,
techniques for sliding window, population aggregate, and nucleotide
diagnostic analyses are also provided.
</p>


<h3>Details</h3>

<p>The complete list of functions can be displayed with
<code>library(help=spider)</code>.
</p>
<p>More information, including a tutorial on the use of spider can be found at
<code>http://spider.r-forge.r-project.org</code>.
</p>

<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> spider</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.4-2</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2017-05-13</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;"> LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>A few of the key functions provided by spider:
</p>
<p>DNA barcoding: <code><a href="#topic+bestCloseMatch">bestCloseMatch</a></code>, <code><a href="#topic+nearNeighbour">nearNeighbour</a></code>,
<code><a href="#topic+threshID">threshID</a></code>, <code><a href="#topic+threshOpt">threshOpt</a></code>, <code><a href="#topic+heatmapSpp">heatmapSpp</a></code>.
</p>
<p>Sliding window: <code><a href="#topic+slidingWindow">slidingWindow</a></code>, <code><a href="#topic+slideAnalyses">slideAnalyses</a></code>,
<code><a href="#topic+slideBoxplots">slideBoxplots</a></code>.
</p>
<p>Nucleotide diagnostics: <code><a href="#topic+nucDiag">nucDiag</a></code>, <code><a href="#topic+rnucDiag">rnucDiag</a></code>.
</p>
<p>Morphological techniques: <code><a href="#topic+paa">paa</a></code>.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown, Rupert Collins, Stephane Boyer, Marie-Caroline Lefort,
Jagoba Malumbres-Olarte, Cor Vink, Rob Cruickshank
</p>
<p>Maintainer: Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Brown S. D. J., Collins R. A., Boyer S., Lefort M.-C.,
Malumbres-Olarte J., Vink C. J., &amp; Cruickshank R. H. 2012. SPIDER: an R
package for the analysis of species identity and evolution, with particular
reference to DNA barcoding. _Molecular Ecology Resources_ 12:562-565. doi:
10.1111/j.1755-0998.2011.03108.x
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+ape-package">ape-package</a></code>, <code><a href="pegas.html#topic+pegas-package">pegas-package</a></code>.
</p>

<hr>
<h2 id='anoteropsis'>Cytochrome oxidase I (COI) sequences of New Zealand _Anoteropsis_ species</h2><span id='topic+anoteropsis'></span>

<h3>Description</h3>

<p>A set of 33 sequences of the mitochondrial protein-coding gene cytochrome
oxidase I from 20 species of the New Zealand wolf spider genus
<em>Anoteropsis</em> (Lycosidae) and two species of <em>Artoria</em> as
outgroups. The sequences are available on GenBank as accession numbers
AY059961 through AY059993.
</p>


<h3>Format</h3>

<p>A DNAbin object containing 33 sequences with a length of 409 base
pairs stored as a matrix.</p>


<h3>Source</h3>

<p>Vink, C. J., and Paterson, A. M. (2003). Combined molecular and
morphological phylogenetic analyses of the New Zealand wolf spider genus
_Anoteropsis_ (Araneae: Lycosidae). _Molecular Phylogenetics and Evolution_
*28* 576-587.
</p>

<hr>
<h2 id='bestCloseMatch'>Measures of identification accuracy</h2><span id='topic+bestCloseMatch'></span>

<h3>Description</h3>

<p>Tests of barcoding efficacy using distance-based methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestCloseMatch(distobj, sppVector, threshold = 0.01, names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestCloseMatch_+3A_distobj">distobj</code></td>
<td>
<p>A distance object (usually from <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>).</p>
</td></tr>
<tr><td><code id="bestCloseMatch_+3A_sppvector">sppVector</code></td>
<td>
<p>Vector of species names. See <code><a href="#topic+sppVector">sppVector</a></code>.</p>
</td></tr>
<tr><td><code id="bestCloseMatch_+3A_threshold">threshold</code></td>
<td>
<p>Distance cutoff for identifications. Default of 0.01 (1%).</p>
</td></tr>
<tr><td><code id="bestCloseMatch_+3A_names">names</code></td>
<td>
<p>Logical. Should the names of the nearest match be shown?
Default of FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions test barcoding efficacy. All sequences must be identified
prior to testing. Each sequence is considered an unknown while the remaining
sequences in the dataset constitute the DNA barcoding database that is used
for identification. If the identification from the test is the same as the
pre-considered identification, a correct result is returned.
</p>
<p><code>bestCloseMatch</code> conducts the &quot;best close match&quot; analysis of Meier et
al. (2006), considering the closest individual unless it is further than the
given threshold, which results in no identification. More than one species
tied for closest match results in an assignment of &quot;ambiguous&quot;. When the
threshold is large, this analysis will return essentially the same result as
<code>nearNeighbour</code>. If <code>names = TRUE</code>, a list is returned containing
the names of all species represented by specimens within the threshold.
</p>
<p><code>nearNeighbour</code> finds the closest individual and returns if their names
are the same (TRUE) or different (FALSE). If <code>names = TRUE</code>, the name
of the closest individual is returned. Ties are decided by majority rule.
</p>
<p><code>threshID</code> conducts a threshold-based analysis, similar to that
conducted by the &quot;Identify Specimen&quot; tool provided by the Barcode of Life
Database (<a href="http://www.boldsystems.org/index.php/IDS_OpenIdEngine">http://www.boldsystems.org/index.php/IDS_OpenIdEngine</a>). It
is more inclusive than <code>bestCloseMatch</code>, considering ALL sequences
within the given threshold. If <code>names = TRUE</code>, a list is returned
containing the names of all species represented by specimens within the
threshold.
</p>
<p>These functions are not recommended as identification tools, though they can
be used as such when <code>names = TRUE</code>.
</p>


<h3>Value</h3>

<p><code>bestCloseMatch</code> and <code>threshID</code> return a character vector
giving the identification status of each individual.  </p>
<table role = "presentation">
<tr><td><code>"correct"</code></td>
<td>
<p>The
name of the closest match is the same</p>
</td></tr> <tr><td><code>"incorrect"</code></td>
<td>
<p>The name of the
closest match is different</p>
</td></tr> <tr><td><code>"ambiguous"</code></td>
<td>
<p>More than one species is the
closest match (<code>bestCloseMatch</code>), or is within the given threshold
(<code>threshID</code>)</p>
</td></tr> <tr><td><code>"no id"</code></td>
<td>
<p>No species are within the threshold
distance</p>
</td></tr>
</table>
<p><code>nearNeighbour</code> returns a logical vector or (if <code>names = TRUE</code>)
the name for the nearest individual.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Meier, R., Shiyang, K., Vaidya, G., &amp; Ng, P. (2006). DNA
barcoding and taxonomy in Diptera: a tale of high intraspecific variability
and low identification success. _Systematic Biology_ *55* (5) 715-728.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nearNeighbour">nearNeighbour</a></code>, <code><a href="#topic+threshID">threshID</a></code>, <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+sppVector">sppVector</a></code> 
Also as <code><a href="utils.html#topic+help">help</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split = "_"), 
    function(x) paste(x[1], x[2], sep = "_"))

bestCloseMatch(anoDist, anoSpp)
bestCloseMatch(anoDist, anoSpp, threshold = 0.005)
nearNeighbour(anoDist, anoSpp)
nearNeighbour(anoDist, anoSpp, names = TRUE)
threshID(anoDist, anoSpp)
threshID(anoDist, anoSpp, threshold = 0.003)

data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

bestCloseMatch(doloDist, doloSpp)
bestCloseMatch(doloDist, doloSpp, threshold = 0.005)
nearNeighbour(doloDist, doloSpp)
nearNeighbour(doloDist, doloSpp, names=TRUE)
threshID(doloDist, doloSpp)
threshID(doloDist, doloSpp, threshold = 0.003)

</code></pre>

<hr>
<h2 id='blockAlignment'>Make all sequences the same length</h2><span id='topic+blockAlignment'></span>

<h3>Description</h3>

<p>Coerces all sequences in a DNAbin object to the same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockAlignment(DNAbin, mode = "shortest", range = NULL, fill = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockAlignment_+3A_dnabin">DNAbin</code></td>
<td>
<p>An object of class <code>DNAbin</code></p>
</td></tr>
<tr><td><code id="blockAlignment_+3A_mode">mode</code></td>
<td>
<p>Character vector. Options of &quot;shortest&quot; or &quot;longest&quot;</p>
</td></tr>
<tr><td><code id="blockAlignment_+3A_range">range</code></td>
<td>
<p>Numeric vector of length 2. Index of the bases where the new
alignment should begin and end</p>
</td></tr>
<tr><td><code id="blockAlignment_+3A_fill">fill</code></td>
<td>
<p>Character to fill the extra bases in short sequences. Default of
&quot;&quot; (blank). Recommend that only &quot;-&quot; (gap) or &quot;?&quot; be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>mode = "shortest"</code>, the alignment is truncated at the length of
the shortest sequence. When <code>mode = "longest"</code>, the alignment is
extended to the end of the longest sequence, with shorter sequences filled
in with <code>"fill"</code>s.
</p>


<h3>Value</h3>

<p>A DNAbin object in matrix format.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(salticidae)
salticidae
blockAlignment(salticidae)
blockAlignment(salticidae, mode = "longest")
blockAlignment(salticidae, mode = NULL, range = c(200, 600))

graphics::image(blockAlignment(salticidae))
graphics::image(blockAlignment(salticidae, mode = "longest"))
graphics::image(blockAlignment(salticidae, mode = NULL, range = c(200, 600)))

</code></pre>

<hr>
<h2 id='cgraph'>Complete graph</h2><span id='topic+cgraph'></span>

<h3>Description</h3>

<p>Creates a complete graph for the given cloud of vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgraph(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgraph_+3A_x">x</code></td>
<td>
<p>X values, or a matrix with two columns containing X and Y values.</p>
</td></tr>
<tr><td><code id="cgraph_+3A_y">y</code></td>
<td>
<p>Y values. Can be left empty if <code>x</code> is a matrix.</p>
</td></tr>
<tr><td><code id="cgraph_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="graphics.html#topic+segments">segments</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>y</code> is not given, <code>x</code> is required to be a matrix containing
both x and y values.
</p>


<h3>Value</h3>

<p>Plots a complete graph between the given vertices.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ordinDNA">plot.ordinDNA</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- runif(15)
y &lt;- runif(15)

graphics::plot(x, y)
cgraph(x, y)

M &lt;- cbind(x, y)
cgraph(M[1:10,], col = "blue")

</code></pre>

<hr>
<h2 id='chaoHaplo'>Chao estimator of haplotype number</h2><span id='topic+chaoHaplo'></span>

<h3>Description</h3>

<p>Calculates the Chao1 estimate of the number of haplotypes in a population
based on the total number of haplotypes present, and the number of
singletons and doubletons in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chaoHaplo(DNAbin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chaoHaplo_+3A_dnabin">DNAbin</code></td>
<td>
<p>An object of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes a large number of specimens have been sampled and that
duplicate haplotypes have not been removed. Interpretation becomes difficult
when more than one species is included in the dataset.
</p>


<h3>Value</h3>

<p>An vector of length three, giving the estimated total number of
haplotypes in the population, and lower and upper 95% confidence limits.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Vink, C. J., McNeill, M. R., Winder, L. M., Kean, J. M., and
Phillips, C. B. (2011). PCR analyses of gut contents of pasture arthropods.
In: Paddock to PCR: Demystifying Molecular Technologies for Practical Plant
Protection (eds. Ridgway, H. J., Glare, T. R., Wakelin, S. A., O'Callaghan,
M.), pp. 125-134. New Zealand Plant Protection Society, Lincoln.
</p>
<p>Chao, A. (1989). Estimating population size for sparse data in
capture-recapture experimnets. _Biometrics_ *45* 427-438.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+haploAccum">haploAccum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
#Create dataset with multiple copies of Dolomedes haplotypes
doloSamp &lt;- dolomedes[sample(16, 100, replace=TRUE, prob=c(0.85, rep(0.01, 15))), ]

chaoHaplo(doloSamp)

</code></pre>

<hr>
<h2 id='checkDNA'>Check a DNA alignment for missing data</h2><span id='topic+checkDNA'></span>

<h3>Description</h3>

<p>This functions counts the number of bases in an alignment that are composed
of missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDNA(DNAbin, gapsAsMissing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDNA_+3A_dnabin">DNAbin</code></td>
<td>
<p>A DNA alignment of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="checkDNA_+3A_gapsasmissing">gapsAsMissing</code></td>
<td>
<p>Logical. Should gaps (coded as '-') be considered
missing bases? Default of TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function considers bases coded as '?' and 'N' as missing data. By
default, gaps (coded as '-') are also considered missing.
</p>


<h3>Value</h3>

<p>A numeric vector giving the number of missing bases in each sequence
of the alignment.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
checkDNA(anoteropsis)
checkDNA(anoteropsis, gapsAsMissing=FALSE)

</code></pre>

<hr>
<h2 id='dataStat'>Taxa statistics</h2><span id='topic+dataStat'></span>

<h3>Description</h3>

<p>Returns the numbers of species, genera and individuals in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataStat(sppVector, genVector, thresh = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataStat_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
<tr><td><code id="dataStat_+3A_genvector">genVector</code></td>
<td>
<p>Genus vector that defines the genera of each individual,
created in a similar manner to the species vector.</p>
</td></tr>
<tr><td><code id="dataStat_+3A_thresh">thresh</code></td>
<td>
<p>Threshold for adequate individual/species number. Default of
5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value <code>NULL</code> can be passed to <code>gen</code> if genera are not of
interest in the dataset.
</p>


<h3>Value</h3>

<p>A table giving the number of genera and species in the dataset;
giving the minimum, maximum, mean and median number of individuals per
species, and the number of species below the given threshold.
</p>


<h3>Author(s)</h3>

<p>Rupert Collins &lt;rupertcollins@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
#Species vector
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))
#Genus vector
anoGen &lt;-  sapply(strsplit(anoSpp, split="_"), function(x) x[1])
dataStat(anoSpp, anoGen)

</code></pre>

<hr>
<h2 id='dolomedes'>Cytochrome oxidase I (COI) sequences of New Zealand _Dolomedes_ species</h2><span id='topic+dolomedes'></span>

<h3>Description</h3>

<p>A set of 37 sequences of the mitochondrial protein-coding gene cytochrome
oxidase I from the 4 New Zealand species of the nursery-web spider genus
<em>Dolomedes</em> (Pisauridae). These sequences are available on GenBank as
accession numbers GQ337328 through GQ337385.
</p>


<h3>Format</h3>

<p>A DNAbin object containing 37 sequences with a length of 850 base
pairs stored as a matrix.</p>


<h3>Source</h3>

<p>Vink, C. J., and Duperre, N. (2010). Pisauridae (Arachnida:
Araneae). _Fauna of New Zealand_ *64* 1-54.
</p>

<hr>
<h2 id='haploAccum'>Haplotype accumulation curves</h2><span id='topic+haploAccum'></span>

<h3>Description</h3>

<p><code>haploAccum</code> identifies the different haplotypes represented in a set
of DNA sequences and performs the calculations for plotting haplotype
accumulations curves (see <code><a href="#topic+plot.haploAccum">plot.haploAccum</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haploAccum(DNAbin, method = "random", permutations = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haploAccum_+3A_dnabin">DNAbin</code></td>
<td>
<p>A set of DNA sequences in an object of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="haploAccum_+3A_method">method</code></td>
<td>
<p>Method for haplotype accumulation. Method <code>"collector"</code>
enters the sequences in the order that they appear in the sequence alignment
and <code>"random"</code> adds the sequences in a random order.</p>
</td></tr>
<tr><td><code id="haploAccum_+3A_permutations">permutations</code></td>
<td>
<p>Number of permutations for method <code>"random"</code>.</p>
</td></tr>
<tr><td><code id="haploAccum_+3A_...">...</code></td>
<td>
<p>Other parameters to functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Haplotype accumulation curves can be used to assess haplotype diversity in
an area or compare different populations, or to evaluate sampling effort.
<code>``random''</code> calculates the mean accumulated number of haplotypes and
its standard deviation through random permutations (subsampling of
sequences), similar to the method to produce rarefaction curves (Gotelli and
Colwell 2001).
</p>


<h3>Value</h3>

<p>An object of class &lsquo;haploAccum&rsquo; with items: </p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>Function
call.</p>
</td></tr> <tr><td><code>method</code></td>
<td>
<p>Method for accumulation.</p>
</td></tr> <tr><td><code>sequences</code></td>
<td>
<p>Number of
analysed sequences.</p>
</td></tr> <tr><td><code>n.haplotypes</code></td>
<td>
<p>Accumulated number of haplotypes
corresponding to each number of sequences.</p>
</td></tr> <tr><td><code>sd</code></td>
<td>
<p>The standard deviation
of the haplotype accumulation curve. Estimated through permutations for
<code>method = "random"</code> and <code>NULL</code> for <code>method = "collector"</code>.</p>
</td></tr>
<tr><td><code>perm</code></td>
<td>
<p>Results of the permutations for <code>method = "random"</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on the functions <code>haplotype</code> (E. Paradis)
from the package 'pegas' and <code>specaccum</code> (R. Kindt) from the
package'vegan'. Missing or ambiguous data will be detected and indicated by
a warning, as they may cause an overestimation of the number of haplotypes.
</p>


<h3>Author(s)</h3>

<p>Jagoba Malumbres-Olarte &lt;j.malumbres.olarte@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Gotellli, N.J. &amp; Colwell, R.K. (2001). Quantifying biodiversity:
procedures and pitfalls in measurement and comparison of species richness.
_Ecology Letters_ *4*, 379&ndash;391.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
#Generate multiple haplotypes
doloHaplo &lt;- dolomedes[sample(37, size = 200, replace = TRUE), ] 
dolocurv &lt;- haploAccum(doloHaplo, method = "random", permutations = 100)
dolocurv
graphics::plot(dolocurv)

</code></pre>

<hr>
<h2 id='heatmapSpp'>Visualise a distance matrix using a heatmap</h2><span id='topic+heatmapSpp'></span>

<h3>Description</h3>

<p>This function plots a heatmap of the distance matrix, with shorter distances
indicated by darker colours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapSpp(distObj, sppVector, col = NULL, axisLabels = NULL,
  triangle = "both", showData = FALSE, dataRound = 3, dataCEX = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmapSpp_+3A_distobj">distObj</code></td>
<td>
<p>A matrix or object of class <code>dist</code>.</p>
</td></tr>
<tr><td><code id="heatmapSpp_+3A_sppvector">sppVector</code></td>
<td>
<p>The species vector. See <code><a href="#topic+sppVector">sppVector</a></code>.</p>
</td></tr>
<tr><td><code id="heatmapSpp_+3A_col">col</code></td>
<td>
<p>A vector giving the colours for the heatmap.</p>
</td></tr>
<tr><td><code id="heatmapSpp_+3A_axislabels">axisLabels</code></td>
<td>
<p>A character vector that provides the axis labels for the
heatmap. By default the species vector is used.</p>
</td></tr>
<tr><td><code id="heatmapSpp_+3A_triangle">triangle</code></td>
<td>
<p>Which triangle of the heatmap should be plotted. Possible
values of &quot;both&quot;, &quot;upper&quot; and &quot;lower&quot;. Default of &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="heatmapSpp_+3A_showdata">showData</code></td>
<td>
<p>Logical. Should the data be shown on the heatmap? Default of
FALSE.</p>
</td></tr>
<tr><td><code id="heatmapSpp_+3A_dataround">dataRound</code></td>
<td>
<p>The number of significant figures the printed data will
show. Default of 3.</p>
</td></tr>
<tr><td><code id="heatmapSpp_+3A_datacex">dataCEX</code></td>
<td>
<p>Size of text for printed data. Default of 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default palette has been taken from the <code>colorspace</code> package.
</p>


<h3>Value</h3>

<p>Plots a heatmap of the distance matrix. Darker colours indicate
shorter distances, lighter colours indicate greater distances.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes, model = "raw")
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)
heatmapSpp(doloDist, doloSpp)
heatmapSpp(doloDist, doloSpp, axisLabels = dimnames(dolomedes)[[1]])

data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis, model = "raw")
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))
heatmapSpp(anoDist, anoSpp)
heatmapSpp(anoDist, anoSpp, showData = TRUE)
heatmapSpp(anoDist, anoSpp, showData = TRUE, dataRound = 1, dataCEX = 0.4)
heatmapSpp(anoDist, anoSpp, triangle = "upper")
heatmapSpp(anoDist, anoSpp, triangle = "lower")
heatmapSpp(anoDist, anoSpp, triangle = "lower", showData = TRUE, dataRound = 1, dataCEX = 0.4)


</code></pre>

<hr>
<h2 id='is.ambig'>Missing bases in alignments</h2><span id='topic+is.ambig'></span>

<h3>Description</h3>

<p>Checks what columns in an alignment have ambiguous bases or missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ambig(DNAbin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.ambig_+3A_dnabin">DNAbin</code></td>
<td>
<p>A DNA alignment of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ambiguous bases are bases that have been coded with any of the Union of Pure
and Applied Chemistry (IUPAC) DNA codes that are not A, C, G, or T. Missing
data are bases that have been coded with &quot;-&quot;, &quot;?&quot; or &quot;N&quot;.
</p>


<h3>Value</h3>

<p>A logical vector containing TRUE if ambiguous bases or missing data
are present, FALSE if not. Does not differentiate between the two classes of
data.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkDNA">checkDNA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(woodmouse)
is.ambig(woodmouse)
#Columns with ambiguous bases
which(is.ambig(woodmouse))

</code></pre>

<hr>
<h2 id='localMinima'>Determine thresholds from a density plot</h2><span id='topic+localMinima'></span>

<h3>Description</h3>

<p>This function determines possible thresholds from the distance matrix for an
alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localMinima(distobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="localMinima_+3A_distobj">distobj</code></td>
<td>
<p>A distance object (usually from <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the concept of the barcoding gap, where a dip in
the density of genetic distances indicates the transition between intra- and
inter-specific distances. Understanding your data is vital to correctly
interpreting the output of this function, but as a start, the first local
minimum is often a good place to start.
</p>
<p>The value of this function is that it does not require prior knowledge of
species identity to get an indication of potential threshold values.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;density&rsquo;, which is a list containing the values
calculated by <code><a href="stats.html#topic+density">density</a></code>. The element <code>localMinima</code> has been
added, which contains the values of the local minima of the density plot.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, <code><a href="stats.html#topic+density">density</a></code>. 
Also as <code><a href="utils.html#topic+help">help</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)

anoThresh &lt;- localMinima(anoDist)
graphics::plot(anoThresh)
anoThresh$localMinima
#Often the first value is the one to go for:
anoThresh$localMinima[1]

</code></pre>

<hr>
<h2 id='maxInDist'>Nearest non-conspecific and maximum intra-specific distances</h2><span id='topic+maxInDist'></span>

<h3>Description</h3>

<p>These functions give the distances to the nearest non-conspecific and
furthest conspecific representatives for each individual in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxInDist(distobj, sppVector = NULL, propZero = FALSE, rmNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxInDist_+3A_distobj">distobj</code></td>
<td>
<p>Distance matrix.</p>
</td></tr>
<tr><td><code id="maxInDist_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector (see <code><a href="#topic+sppVector">sppVector</a></code>). Default of
NULL.</p>
</td></tr>
<tr><td><code id="maxInDist_+3A_propzero">propZero</code></td>
<td>
<p>Logical. TRUE gives the proportion of zero distances.</p>
</td></tr>
<tr><td><code id="maxInDist_+3A_rmna">rmNA</code></td>
<td>
<p>Logical. TRUE ignores missing values in the distance matrix.
Default of FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nonConDist</code> returns the minimum inter-specific distance for each
individual.
</p>
<p><code>maxInDist</code> returns the maximum intra-specific distance for each
individual.
</p>
<p>These two functions can be used to create a version of the barcoding gap.
</p>
<p><code>minInDist</code> returns the minimum intra-specific distance for each
individual.
</p>


<h3>Value</h3>

<p>If <code>propZero=FALSE</code>, a numeric vector giving the distance of
the closest non-conspecific individual (<code>nonConDist</code>) or the most
distant conspecific individual (<code>maxInDist</code>).
</p>
<p>If <code>propZero=TRUE</code>, a single number giving the proportion of zero
distances.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))

nonConDist(anoDist, anoSpp)
nonConDist(anoDist, anoSpp, propZero=TRUE)

maxInDist(anoDist, anoSpp)
maxInDist(anoDist, anoSpp, propZero=TRUE)

#Barcoding gap
inter &lt;- nonConDist(anoDist, anoSpp)
intra &lt;- maxInDist(anoDist, anoSpp)
graphics::hist(inter-intra)

#An alternative way of plotting the gap
bnd &lt;- cbind(data.frame(inter, intra))
ord &lt;- bnd[order(bnd$inter),]
graphics::plot(ord$inter, type="n", ylab="Percent K2P distance", xlab="Individual")
segCol &lt;- rep("gray50", length(ord$inter))
segCol[ord$inter-ord$intra &lt; 0] &lt;- "red"
graphics::segments(x0=1:length(ord$inter), y0=ord$inter, y1=ord$intra, col=segCol, lwd=6)

</code></pre>

<hr>
<h2 id='minInDist'>Nearest non-conspecific and maximum intra-specific distances</h2><span id='topic+minInDist'></span>

<h3>Description</h3>

<p>These functions give the distances to the nearest non-conspecific and
furthest conspecific representatives for each individual in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minInDist(distobj, sppVector = NULL, propZero = FALSE, rmNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minInDist_+3A_distobj">distobj</code></td>
<td>
<p>Distance matrix.</p>
</td></tr>
<tr><td><code id="minInDist_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector (see <code><a href="#topic+sppVector">sppVector</a></code>). Default of
NULL.</p>
</td></tr>
<tr><td><code id="minInDist_+3A_propzero">propZero</code></td>
<td>
<p>Logical. TRUE gives the proportion of zero distances.</p>
</td></tr>
<tr><td><code id="minInDist_+3A_rmna">rmNA</code></td>
<td>
<p>Logical. TRUE ignores missing values in the distance matrix.
Default of FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nonConDist</code> returns the minimum inter-specific distance for each
individual.
</p>
<p><code>maxInDist</code> returns the maximum intra-specific distance for each
individual.
</p>
<p>These two functions can be used to create a version of the barcoding gap.
</p>
<p><code>minInDist</code> returns the minimum intra-specific distance for each
individual.
</p>


<h3>Value</h3>

<p>If <code>propZero=FALSE</code>, a numeric vector giving the distance of
the closest non-conspecific individual (<code>nonConDist</code>) or the most
distant conspecific individual (<code>maxInDist</code>).
</p>
<p>If <code>propZero=TRUE</code>, a single number giving the proportion of zero
distances.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))

nonConDist(anoDist, anoSpp)
nonConDist(anoDist, anoSpp, propZero=TRUE)

maxInDist(anoDist, anoSpp)
maxInDist(anoDist, anoSpp, propZero=TRUE)

#Barcoding gap
inter &lt;- nonConDist(anoDist, anoSpp)
intra &lt;- maxInDist(anoDist, anoSpp)
graphics::hist(inter-intra)

#An alternative way of plotting the gap
bnd &lt;- cbind(data.frame(inter, intra))
ord &lt;- bnd[order(bnd$inter),]
graphics::plot(ord$inter, type="n", ylab="Percent K2P distance", xlab="Individual")
segCol &lt;- rep("gray50", length(ord$inter))
segCol[ord$inter-ord$intra &lt; 0] &lt;- "red"
graphics::segments(x0=1:length(ord$inter), y0=ord$inter, y1=ord$intra, col=segCol, lwd=6)

</code></pre>

<hr>
<h2 id='monophyly'>Species monophyly over a tree</h2><span id='topic+monophyly'></span>

<h3>Description</h3>

<p>Determines if the species given in <code>sppVector</code> form monophyletic groups
on a given tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monophyly(phy, sppVector, pp = NA, singletonsMono = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monophyly_+3A_phy">phy</code></td>
<td>
<p>A tree of class &lsquo;phylo&rsquo;.</p>
</td></tr>
<tr><td><code id="monophyly_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector. See <code><a href="#topic+sppVector">sppVector</a></code></p>
</td></tr>
<tr><td><code id="monophyly_+3A_pp">pp</code></td>
<td>
<p>Object of class &lsquo;prop.part&rsquo;. Assists in speeding up the function,
if it has been called already. Default of NA, calling
<code><a href="ape.html#topic+prop.part">prop.part</a></code> internally.</p>
</td></tr>
<tr><td><code id="monophyly_+3A_singletonsmono">singletonsMono</code></td>
<td>
<p>Logical. Should singletons (i.e. only a single
specimen representing that species) be treated as monophyletic? Default of
TRUE. Possible values of FALSE and NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>monophyly</code> determines if each species is monophyletic.
<code>monophylyBoot</code> incorporates a bootstrap test to determine the support
for this monophyly. Species with a bootstrap support lower than
<code>"thresh"</code> are recorded as FALSE.
</p>
<p>Rerooting is done on the longest internal edge in the tree returned by
<code>nj(dist.dna(DNAbin))</code>.
</p>


<h3>Value</h3>

<p><code>monophyly</code> returns a logical vector, stating if each species
is monophyletic. Values correspond to the species order given by
<code>unique(sppVector)</code>.
</p>
<p><code>monophylyBoot</code> returns a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>results</code></td>
<td>
<p>A logical vector, stating if each species is monophyletic
with a bootstrap support higher than the given threshold.</p>
</td></tr> <tr><td><code>BSvalues</code></td>
<td>
<p>A
numeric vector giving the bootstrap proportions for each node of
<code>phy</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+prop.part">prop.part</a></code>, <code><a href="ape.html#topic+root">root</a></code>,
<code><a href="ape.html#topic+boot.phylo">boot.phylo</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Random trees
set.seed(16)
tr &lt;- ape::rtree(15)
spp &lt;- rep(LETTERS[1:5], rep(3,5))
monophyly(tr, spp)

tr2 &lt;- tr
spp2 &lt;- c(rep(LETTERS[1:4], rep(3,4)), LETTERS[5:7])
monophyly(tr2, spp2)

#Empirical data
## Not run: 
data(anoteropsis)
anoTree &lt;- ape::nj(ape::dist.dna(anoteropsis))
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))

monophyly(anoTree, anoSpp)
monophyly(anoTree, anoSpp, singletonsMono=FALSE)
unique(anoSpp)

#To get score for each individual
anoMono &lt;- monophyly(anoTree, anoSpp)
anoMono[match(anoSpp, unique(anoSpp))]

data(woodmouse)
woodTree &lt;- ape::nj(ape::dist.dna(woodmouse))
woodSpp &lt;- c("D", "C", "C", "A", "A", "E", "A", "F", "C", "F", "E", "D", "A", "A", "E")
unique(woodSpp)
monophyly(woodTree, woodSpp)
woodMono &lt;- monophylyBoot(woodTree, woodSpp, woodmouse)
woodMono$results
woodMono$BSvalues

monophylyBoot(woodTree, woodSpp, woodmouse, reroot = FALSE)
monophylyBoot(woodTree, woodSpp, woodmouse, thresh = 0.9, reroot = FALSE)

## End(Not run)


</code></pre>

<hr>
<h2 id='monophylyBoot'>Species monophyly over a tree</h2><span id='topic+monophylyBoot'></span>

<h3>Description</h3>

<p>Determines if the species given in <code>sppVector</code> form monophyletic groups
on a given tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monophylyBoot(phy, sppVector, DNAbin, thresh = 0.7, reroot = TRUE,
  pp = NA, singletonsMono = TRUE, reps = 1000, block = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monophylyBoot_+3A_phy">phy</code></td>
<td>
<p>A tree of class &lsquo;phylo&rsquo;.</p>
</td></tr>
<tr><td><code id="monophylyBoot_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector. See <code><a href="#topic+sppVector">sppVector</a></code></p>
</td></tr>
<tr><td><code id="monophylyBoot_+3A_dnabin">DNAbin</code></td>
<td>
<p>An object of class 'DNAbin'. Required for calculating
bootstrap values.</p>
</td></tr>
<tr><td><code id="monophylyBoot_+3A_thresh">thresh</code></td>
<td>
<p>Numeric between 0 and 1. Bootstrap threshold under which
potentially monophyletic species are negated. Default of 0.7.</p>
</td></tr>
<tr><td><code id="monophylyBoot_+3A_reroot">reroot</code></td>
<td>
<p>Logical. Should the bootstrap replicates be rerooted on the
longest edge? Default of TRUE.</p>
</td></tr>
<tr><td><code id="monophylyBoot_+3A_pp">pp</code></td>
<td>
<p>Object of class &lsquo;prop.part&rsquo;. Assists in speeding up the function,
if it has been called already. Default of NA, calling
<code><a href="ape.html#topic+prop.part">prop.part</a></code> internally.</p>
</td></tr>
<tr><td><code id="monophylyBoot_+3A_singletonsmono">singletonsMono</code></td>
<td>
<p>Logical. Should singletons (i.e. only a single
specimen representing that species) be treated as monophyletic? Default of
TRUE. Possible values of FALSE and NA.</p>
</td></tr>
<tr><td><code id="monophylyBoot_+3A_reps">reps</code></td>
<td>
<p>Numeric. Number of bootstrap replications. Default of 1000.</p>
</td></tr>
<tr><td><code id="monophylyBoot_+3A_block">block</code></td>
<td>
<p>The number of nucleotides that will be resampled together.
Default of 3 to resample on the codon level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>monophyly</code> determines if each species is monophyletic.
<code>monophylyBoot</code> incorporates a bootstrap test to determine the support
for this monophyly. Species with a bootstrap support lower than
<code>"thresh"</code> are recorded as FALSE.
</p>
<p>Rerooting is done on the longest internal edge in the tree returned by
<code>nj(dist.dna(DNAbin))</code>.
</p>


<h3>Value</h3>

<p><code>monophyly</code> returns a logical vector, stating if each species
is monophyletic. Values correspond to the species order given by
<code>unique(sppVector)</code>.
</p>
<p><code>monophylyBoot</code> returns a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>results</code></td>
<td>
<p>A logical vector, stating if each species is monophyletic
with a bootstrap support higher than the given threshold.</p>
</td></tr> <tr><td><code>BSvalues</code></td>
<td>
<p>A
numeric vector giving the bootstrap proportions for each node of
<code>phy</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+prop.part">prop.part</a></code>, <code><a href="ape.html#topic+root">root</a></code>,
<code><a href="ape.html#topic+boot.phylo">boot.phylo</a></code>, <code><a href="#topic+monophyly">monophyly</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Random trees
set.seed(16)
tr &lt;- ape::rtree(15)
spp &lt;- rep(LETTERS[1:5], rep(3,5))
monophyly(tr, spp)

tr2 &lt;- tr
spp2 &lt;- c(rep(LETTERS[1:4], rep(3,4)), LETTERS[5:7])
monophyly(tr2, spp2)

#Empirical data
## Not run: 
data(anoteropsis)
anoTree &lt;- ape::nj(ape::dist.dna(anoteropsis))
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))

monophyly(anoTree, anoSpp)
monophyly(anoTree, anoSpp, singletonsMono=FALSE)
unique(anoSpp)

#To get score for each individual
anoMono &lt;- monophyly(anoTree, anoSpp)
anoMono[match(anoSpp, unique(anoSpp))]

data(woodmouse)
woodTree &lt;- ape::nj(ape::dist.dna(woodmouse))
woodSpp &lt;- c("D", "C", "C", "A", "A", "E", "A", "F", "C", "F", "E", "D", "A", "A", "E")
unique(woodSpp)
monophyly(woodTree, woodSpp)
woodMono &lt;- monophylyBoot(woodTree, woodSpp, woodmouse)
woodMono$results
woodMono$BSvalues

monophylyBoot(woodTree, woodSpp, woodmouse, reroot = FALSE)
monophylyBoot(woodTree, woodSpp, woodmouse, thresh = 0.9, reroot = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='nearNeighbour'>Measures of identification accuracy</h2><span id='topic+nearNeighbour'></span>

<h3>Description</h3>

<p>Tests of barcoding efficacy using distance-based methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearNeighbour(distobj, sppVector, names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nearNeighbour_+3A_distobj">distobj</code></td>
<td>
<p>A distance object (usually from <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>).</p>
</td></tr>
<tr><td><code id="nearNeighbour_+3A_sppvector">sppVector</code></td>
<td>
<p>Vector of species names. See <code><a href="#topic+sppVector">sppVector</a></code>.</p>
</td></tr>
<tr><td><code id="nearNeighbour_+3A_names">names</code></td>
<td>
<p>Logical. Should the names of the nearest match be shown?
Default of FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions test barcoding efficacy. All sequences must be identified
prior to testing. Each sequence is considered an unknown while the remaining
sequences in the dataset constitute the DNA barcoding database that is used
for identification. If the identification from the test is the same as the
pre-considered identification, a correct result is returned.
</p>
<p><code>bestCloseMatch</code> conducts the &quot;best close match&quot; analysis of Meier et
al. (2006), considering the closest individual unless it is further than the
given threshold, which results in no identification. More than one species
tied for closest match results in an assignment of &quot;ambiguous&quot;. When the
threshold is large, this analysis will return essentially the same result as
<code>nearNeighbour</code>. If <code>names = TRUE</code>, a list is returned containing
the names of all species represented by specimens within the threshold.
</p>
<p><code>nearNeighbour</code> finds the closest individual and returns if their names
are the same (TRUE) or different (FALSE). If <code>names = TRUE</code>, the name
of the closest individual is returned. Ties are decided by majority rule.
</p>
<p><code>threshID</code> conducts a threshold-based analysis, similar to that
conducted by the &quot;Identify Specimen&quot; tool provided by the Barcode of Life
Database (<a href="http://www.boldsystems.org/index.php/IDS_OpenIdEngine">http://www.boldsystems.org/index.php/IDS_OpenIdEngine</a>). It
is more inclusive than <code>bestCloseMatch</code>, considering ALL sequences
within the given threshold. If <code>names = TRUE</code>, a list is returned
containing the names of all species represented by specimens within the
threshold.
</p>
<p>These functions are not recommended as identification tools, though they can
be used as such when <code>names = TRUE</code>.
</p>


<h3>Value</h3>

<p><code>bestCloseMatch</code> and <code>threshID</code> return a character vector
giving the identification status of each individual.  </p>
<table role = "presentation">
<tr><td><code>"correct"</code></td>
<td>
<p>The
name of the closest match is the same</p>
</td></tr> <tr><td><code>"incorrect"</code></td>
<td>
<p>The name of the
closest match is different</p>
</td></tr> <tr><td><code>"ambiguous"</code></td>
<td>
<p>More than one species is the
closest match (<code>bestCloseMatch</code>), or is within the given threshold
(<code>threshID</code>)</p>
</td></tr> <tr><td><code>"no id"</code></td>
<td>
<p>No species are within the threshold
distance</p>
</td></tr>
</table>
<p><code>nearNeighbour</code> returns a logical vector or (if <code>names = TRUE</code>)
the name for the nearest individual.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Meier, R., Shiyang, K., Vaidya, G., &amp; Ng, P. (2006). DNA
barcoding and taxonomy in Diptera: a tale of high intraspecific variability
and low identification success. _Systematic Biology_ *55* (5) 715-728.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nearNeighbour">nearNeighbour</a></code>, <code><a href="#topic+threshID">threshID</a></code>, <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+sppVector">sppVector</a></code> 
Also as <code><a href="utils.html#topic+help">help</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split = "_"), 
    function(x) paste(x[1], x[2], sep = "_"))

bestCloseMatch(anoDist, anoSpp)
bestCloseMatch(anoDist, anoSpp, threshold = 0.005)
nearNeighbour(anoDist, anoSpp)
nearNeighbour(anoDist, anoSpp, names = TRUE)
threshID(anoDist, anoSpp)
threshID(anoDist, anoSpp, threshold = 0.003)

data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

bestCloseMatch(doloDist, doloSpp)
bestCloseMatch(doloDist, doloSpp, threshold = 0.005)
nearNeighbour(doloDist, doloSpp)
nearNeighbour(doloDist, doloSpp, names=TRUE)
threshID(doloDist, doloSpp)
threshID(doloDist, doloSpp, threshold = 0.003)

</code></pre>

<hr>
<h2 id='nonConDist'>Nearest non-conspecific and maximum intra-specific distances</h2><span id='topic+nonConDist'></span>

<h3>Description</h3>

<p>These functions give the distances to the nearest non-conspecific and
furthest conspecific representatives for each individual in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonConDist(distobj, sppVector = NULL, propZero = FALSE, rmNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nonConDist_+3A_distobj">distobj</code></td>
<td>
<p>Distance matrix.</p>
</td></tr>
<tr><td><code id="nonConDist_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector (see <code><a href="#topic+sppVector">sppVector</a></code>). Default of
NULL.</p>
</td></tr>
<tr><td><code id="nonConDist_+3A_propzero">propZero</code></td>
<td>
<p>Logical. TRUE gives the proportion of zero distances.</p>
</td></tr>
<tr><td><code id="nonConDist_+3A_rmna">rmNA</code></td>
<td>
<p>Logical. TRUE ignores missing values in the distance matrix.
Default of FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nonConDist</code> returns the minimum inter-specific distance for each
individual.
</p>
<p><code>maxInDist</code> returns the maximum intra-specific distance for each
individual.
</p>
<p>These two functions can be used to create a version of the barcoding gap.
</p>
<p><code>minInDist</code> returns the minimum intra-specific distance for each
individual.
</p>


<h3>Value</h3>

<p>If <code>propZero=FALSE</code>, a numeric vector giving the distance of
the closest non-conspecific individual (<code>nonConDist</code>) or the most
distant conspecific individual (<code>maxInDist</code>).
</p>
<p>If <code>propZero=TRUE</code>, a single number giving the proportion of zero
distances.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))

nonConDist(anoDist, anoSpp)
nonConDist(anoDist, anoSpp, propZero=TRUE)

maxInDist(anoDist, anoSpp)
maxInDist(anoDist, anoSpp, propZero=TRUE)

#Barcoding gap
inter &lt;- nonConDist(anoDist, anoSpp)
intra &lt;- maxInDist(anoDist, anoSpp)
graphics::hist(inter-intra)

#An alternative way of plotting the gap
bnd &lt;- cbind(data.frame(inter, intra))
ord &lt;- bnd[order(bnd$inter),]
graphics::plot(ord$inter, type="n", ylab="Percent K2P distance", xlab="Individual")
segCol &lt;- rep("gray50", length(ord$inter))
segCol[ord$inter-ord$intra &lt; 0] &lt;- "red"
graphics::segments(x0=1:length(ord$inter), y0=ord$inter, y1=ord$intra, col=segCol, lwd=6)

</code></pre>

<hr>
<h2 id='nucDiag'>Nucleotide diagnostics for species alignments</h2><span id='topic+nucDiag'></span>

<h3>Description</h3>

<p>Determines the diagnostic nucleotides for each species given in
<code>sppVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nucDiag(DNAbin, sppVector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nucDiag_+3A_dnabin">DNAbin</code></td>
<td>
<p>An object of class 'DNAbin'.</p>
</td></tr>
<tr><td><code id="nucDiag_+3A_sppvector">sppVector</code></td>
<td>
<p>The species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide a means for evaluating the presence of diagnostic
nucleotides that distinguish species within an alignment. <code>nucDiag</code>
returns the positions of bases corresponding to the definition of pure,
simple diagnostic nucleotides given by Sarkar et al (2008).
</p>
<p><code>rnucDiag</code> runs a bootstrapping-style resampling test to evaluate the
numbers of diagnostic nucleotides that might be expected by random
assortment of specimens.
</p>


<h3>Value</h3>

<p><code>nucDiag</code> returns a list giving the pure, simple diagnostic
nucleotides (i.e. those nucleotides that are fixed within species and
different from all other species) for each species in the species vector. A
result of <code>integer(0)</code> indicates there are no diagnostic nucleotides
for those species.
</p>
<p><code>rnucDiag</code> returns a list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>min</code></td>
<td>
<p>The minimum number of diagnostic nucleotides in the sample.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The mean number of diagnostic nucleotides in the sample.</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>The median number of diagnostic nucleotides in the sample.</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>The maximum number of diagnostic nucleotides in the sample.</p>
</td></tr>
<tr><td><code>rndFreq</code></td>
<td>
<p>A list of frequency distributions of the number of diagnostic
nucleotides in groups formed by 1 sequence, 2 sequences, etc.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Sarkar, I., Planet, P., &amp; DeSalle, R. (2008). CAOS software for
use in character- based DNA barcoding. _Molecular Ecology Resources_ *8*
1256-1259
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slideNucDiag">slideNucDiag</a></code>, <code><a href="#topic+rnucDiag">rnucDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
	function(x) paste(x[1], x[2], sep="_"))

nucDiag(anoteropsis, anoSpp)


#To view the nucleotide values 
anoNuc &lt;- nucDiag(anoteropsis, anoSpp)
as.character(anoteropsis[ ,anoNuc[[1]][1] ])



data(sarkar)
sarkarSpp &lt;- substr(dimnames(sarkar)[[1]], 1, 3)
nucDiag(sarkar, sarkarSpp)

## Not run: 
rnucDiag(anoteropsis, anoSpp, n = 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='ordinDNA'>Calculates a Principal Components Ordination of genetic distances</h2><span id='topic+ordinDNA'></span>

<h3>Description</h3>

<p>Calculates Principical Coonrdinates Analysis on a matrix of genetic
distances and plots an ordination of the first two major axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinDNA(distobj, sppVector, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinDNA_+3A_distobj">distobj</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
<tr><td><code id="ordinDNA_+3A_sppvector">sppVector</code></td>
<td>
<p>The species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
<tr><td><code id="ordinDNA_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+plot.ordinDNA">plot.ordinDNA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>, which performs a
Principal Coordinates Analysis on the distance matrix given. In addition, it
plots an ordination of the genetic distance matrix given, showing the
relative distance between each of the species in the dataset. It is
presented as an alternative to the neighbour-joining trees which are
frequently used for the visualisation of DNA barcoding data. NJ trees show
hypotheses of relationships, which are inappropriate for the questions
usally asked in DNA barcoding studies.
</p>
<p>The distance between the centroids of the clusters are roughly proportional
to the genetic distances between the species. NOTE: it is important to
remember that the plot shows only one plane of a multi-dimensional space.
Species with overlapping circles are not necessarily conspecific. Further
exploration is required.
</p>


<h3>Value</h3>

<p>Plots an ordination of the first two major axes showing the
positions of each individual (squares), the centroid of each species
(circular bullet and name of species), and the variation in the species
(large circle, the radius of which is the distance to the furthest
individual from the centroid).
</p>
<p>Additionally returns a list of class <code>"ordinDNA"</code> with the following
elements: </p>
<table role = "presentation">
<tr><td><code>pco</code></td>
<td>
<p>Output of the Principal Coordinates Analysis.</p>
</td></tr>
<tr><td><code>sppVector</code></td>
<td>
<p>Character vector giving the species vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cmdscale">cmdscale</a></code>, <code><a href="#topic+plot.ordinDNA">plot.ordinDNA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

doloOrd &lt;- ordinDNA(doloDist, doloSpp)
doloOrd

</code></pre>

<hr>
<h2 id='paa'>Population Aggregate Analysis</h2><span id='topic+paa'></span>

<h3>Description</h3>

<p>Conducts population aggregate analysis over a matrix of characters of
interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paa(data, sppVector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paa_+3A_data">data</code></td>
<td>
<p>A data matrix with columns as characters and rows as
individuals.</p>
</td></tr>
<tr><td><code id="paa_+3A_sppvector">sppVector</code></td>
<td>
<p>The species vector. See <code><a href="#topic+sppVector">sppVector</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used on DNA sequences, the function treats gaps as seperate characters.
</p>


<h3>Value</h3>

<p>A matrix with species as rows and characters as columns. Cells give
the character state of each species if fixed, or &quot;poly&quot; if the character is
polymorphic.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Sites, J. W. J., &amp; Marshall, J. C. (2003). Delimiting species: a
Renaissance issue in systematic biology. _Trends in Ecology and Evolution_
*18* (9), 462-470.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Create some exemplar data
u &lt;- sample(c(0,1), 16, replace=TRUE)
v &lt;- rep(c(0,1), rep(8,2))
x &lt;- rep(c(1,0), rep(8,2))
y &lt;- sample(c(0,1), 16, replace=TRUE)
z &lt;- rep(c(1,0), rep(8,2))

dat &lt;- cbind(u,v,x,y,z)
popn &lt;- rep(c("A","B", "C", "D"), rep(4,4))

paa(dat, popn)

#Use on DNA sequences
data(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
	function(x) paste(x[1], x[2], sep="_"))

paa(as.character(anoteropsis), anoSpp)

</code></pre>

<hr>
<h2 id='plot.haploAccum'>Plotting haplotype accumulation curves</h2><span id='topic+plot.haploAccum'></span>

<h3>Description</h3>

<p>Plots the accumulation curves calculated by <code><a href="#topic+haploAccum">haploAccum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'haploAccum'
plot(x, add = FALSE, ci = 2, ci.type = c("bar",
  "line", "polygon"), col = par("fg"), ci.col = col, ci.lty = 1, xlab,
  ylab = "Haplotypes", ylim, main = paste(x$method,
  "method of haplotype accumulation", sep = " "), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.haploAccum_+3A_x">x</code></td>
<td>
<p>A &lsquo;haploAccum&rsquo; object obtained from <code><a href="#topic+haploAccum">haploAccum</a></code>.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_add">add</code></td>
<td>
<p>Add graph to an existing graph.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_ci">ci</code></td>
<td>
<p>Multiplier for the calculation of confidence intervals from
standard deviation. <code>ci = 0</code> prevents the drawing of confidence
intervals.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_ci.type">ci.type</code></td>
<td>
<p>Type of confidence intervals: <code>"bar"</code> for vertical bars,
<code>"line"</code> for lines, and <code>"polygon"</code> for a shaded area.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_col">col</code></td>
<td>
<p>Colour for curve line.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_ci.col">ci.col</code></td>
<td>
<p>Colour for lines or shaded area when <code>"polygon"</code>.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_ci.lty">ci.lty</code></td>
<td>
<p>Line type for confidence interval lines or border of the
<code>"polygon"</code>.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_xlab">xlab</code></td>
<td>
<p>Label for the X-axis.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_ylab">ylab</code></td>
<td>
<p>Label for the Y-axis.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_ylim">ylim</code></td>
<td>
<p>Y-axis limits.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_main">main</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="plot.haploAccum_+3A_...">...</code></td>
<td>
<p>Other parameters to pass to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots a haplotype accumulation curve and confidence intervals
depending on the options given to <code><a href="#topic+haploAccum">haploAccum</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jagoba Malumbres-Olarte &lt;j.malumbres.olarte@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Gotellli, N.J. &amp; Colwell, R.K. (2001). Quantifying biodiversity:
procedures and pitfalls in measurement and comparison of species richness.
_Ecology Letters_ *4* 379&ndash;391.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
#Generate multiple haplotypes
doloHaplo &lt;- dolomedes[sample(37, size = 200, replace = TRUE), ] 
dolocurv &lt;- haploAccum(doloHaplo, method = "random", permutations = 100)

graphics::plot(dolocurv)
graphics::plot(dolocurv, add = FALSE, ci = 2, ci.type = "polygon", col = "blue", ci.col = "red", 
    ci.lty = 1)

</code></pre>

<hr>
<h2 id='plot.ordinDNA'>Plot an 'ordinDNA' object</h2><span id='topic+plot.ordinDNA'></span>

<h3>Description</h3>

<p>Plots an ordination of the Principal Components Analysis conducted by
<code><a href="#topic+ordinDNA">ordinDNA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ordinDNA'
plot(x, majorAxes = c(1, 2), plotCol = "default",
  trans = "CC", textcex = 0.7, pchCentroid = FALSE, sppBounds = "net",
  sppNames = TRUE, namePos = "top", ptPch = 21, ptCex = 0.5,
  netWd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ordinDNA_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;ordinDNA&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_majoraxes">majorAxes</code></td>
<td>
<p>Numeric. Gives the numbers of the major axes that should be
plotted. Default of the first two major axes (<code>majorAxes = c(1,2)</code>)</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_plotcol">plotCol</code></td>
<td>
<p>A vector of RGB colours giving the colours of the points and
circles. Must be in the form of a character vector with elements &quot;#XXXXXX&quot;
where XXXXXX gives the hexadecimal value for the colours desired. Default of
<code>"default"</code>. Colours are recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_trans">trans</code></td>
<td>
<p>A character vector giving the hexadecimal value for the
transparency of the circles. Default of &quot;CC&quot;.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_textcex">textcex</code></td>
<td>
<p>Numeric. Controls the size of the text giving the species
value of the circles.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_pchcentroid">pchCentroid</code></td>
<td>
<p>Numeric. Controls the shape of the point showing the
centroid of the circle for each species. Default of FALSE, no plotting of
centroid position.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_sppbounds">sppBounds</code></td>
<td>
<p>Option to determine the method of visualising conspecific
points. Options of <code>"net"</code> (the default), <code>"none"</code> or
<code>"circles"</code>.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_sppnames">sppNames</code></td>
<td>
<p>Logical. Should species names be plotted? Default of TRUE.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_namepos">namePos</code></td>
<td>
<p>Character vector of length 1 giving the position where the
species names should be plotted. Possible values are: &quot;top&quot; and &quot;bottom&quot;,
anything else plots the names at the centroid.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_ptpch">ptPch</code></td>
<td>
<p>Numeric. Number of the symbol to be used for plotting. see
<code><a href="graphics.html#topic+points">points</a></code>. Default of 21.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_ptcex">ptCex</code></td>
<td>
<p>Numeric. Number governing the size of the points. Default of
0.5.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_netwd">netWd</code></td>
<td>
<p>Numeric. Number governing the width of the lines in the netowk.
Default of 1.</p>
</td></tr>
<tr><td><code id="plot.ordinDNA_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.ordinDNA</code> calculates the centroid and radius of the most variable
individual for each species in the multivariate space of the Principal
Components Analysis object given.
</p>
<p><code>majorAxes</code> plots the axes in the form <code>c(x, y)</code>. The maximum
number of axes calculated is the number of specimens in the dataset minus
one.
</p>
<p><code>sppBounds</code> has the following options: <code>"net"</code> (the default)
creates a complete graph between all individuals within a species.  If
<code>"circles"</code> is specified, a circle is drawn with a center fixed on the
centroid, and a radius of the length to the maximally distant individual.
Selecting the option of <code>"none"</code> means the individuals are not
connected in any way.
</p>


<h3>Value</h3>

<p>Plots an ordination of the first two major axes showing the
positions of each individual (squares), the centroid of each species
(circular bullet and name of species), and the variation in the species
(large circle, the radius of which is the distance to the furthest
individual from the centroid).
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordinDNA">ordinDNA</a></code>, <code><a href="#topic+cgraph">cgraph</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

doloOrd &lt;- ordinDNA(doloDist, doloSpp)

graphics::plot(doloOrd)
graphics::plot(doloOrd, majorAxes = c(1,3))
graphics::plot(doloOrd, textcex = 0.001)
graphics::plot(doloOrd, plotCol = c("#FF0000", "#00FF00", "#0000FF"))
graphics::plot(doloOrd, namesPos = "bottom")
graphics::plot(doloOrd, namesPos = "centre")

data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))
    
anoOrd &lt;- ordinDNA(anoDist, anoSpp)

plot(anoOrd, sppBounds = "circles")

</code></pre>

<hr>
<h2 id='plot.slidWin'>Plot a 'slidWin' object</h2><span id='topic+plot.slidWin'></span>

<h3>Description</h3>

<p>Graphical representation of the summary statistics derived from
<code><a href="#topic+slideAnalyses">slideAnalyses</a></code> and <code><a href="#topic+slideBoxplots">slideBoxplots</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slidWin'
plot(x, outliers = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.slidWin_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;slidWin&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.slidWin_+3A_outliers">outliers</code></td>
<td>
<p>Logical. When the results of <code><a href="#topic+slideBoxplots">slideBoxplots</a></code> are
being called, should the outliers be plotted? Default of FALSE.</p>
</td></tr>
<tr><td><code id="plot.slidWin_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When boxplots of methods <code>nonCon</code> and <code>interAll</code>, the y-axis
limits are constrained to the midpoint of the range covered by the boxplots,
so that the intra-specific variation can be seen.
</p>


<h3>Value</h3>

<p>Plots graphs depending on the options given to
<code><a href="#topic+slideAnalyses">slideAnalyses</a></code> or <code><a href="#topic+slideBoxplots">slideBoxplots</a></code>.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slideAnalyses">slideAnalyses</a></code>, <code><a href="#topic+slideBoxplots">slideBoxplots</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

doloSlide &lt;- slideAnalyses(dolomedes,  doloSpp, 200, interval=10, treeMeasures=TRUE)

graphics::plot(doloSlide)

doloBox &lt;- slideBoxplots(dolomedes,  doloSpp, 200, interval=10, method="overall")

graphics::plot(doloBox)


data(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))

anoBox &lt;- slideBoxplots(anoteropsis,  anoSpp, 200, interval=10, method="interAll")

graphics::plot(anoBox)
graphics::plot(anoBox, outliers=TRUE)


</code></pre>

<hr>
<h2 id='polyBalance'>Balance of a phylogenetic tree with polytomies</h2><span id='topic+polyBalance'></span>

<h3>Description</h3>

<p>This function computes the numbers of descendants for each dichotomous
branch of a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyBalance(phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polyBalance_+3A_phy">phy</code></td>
<td>
<p>A tree of class &lsquo;phylo&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extends <code><a href="ape.html#topic+balance">balance</a></code> to allow the balance of a tree
with polytomies to be calculated. When the tree is fully dichotomous, the
result is identical to <code><a href="ape.html#topic+balance">balance</a></code>.
</p>


<h3>Value</h3>

<p>A numeric matrix with two columns and one row for each node of the
tree. The columns give the numbers of descendants on each node.
Non-dichotomous nodes are reported as 'NA'.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+balance">balance</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	set.seed(55)
	tr &lt;- ape::rtree(15)
	tr2 &lt;- ape::di2multi(tr, tol=0.02)
	polyBalance(tr)
	polyBalance(tr2)

</code></pre>

<hr>
<h2 id='rankSlidWin'>Rank a 'slidWin' object.</h2><span id='topic+rankSlidWin'></span>

<h3>Description</h3>

<p>Display the highest ranking windows measured by <code><a href="#topic+slideAnalyses">slideAnalyses</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankSlidWin(slidWin, criteria = "mean_distance", num = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankSlidWin_+3A_slidwin">slidWin</code></td>
<td>
<p>An object of class &lsquo;slidWin&rsquo;, made using
<code><a href="#topic+slideAnalyses">slideAnalyses</a></code>.</p>
</td></tr>
<tr><td><code id="rankSlidWin_+3A_criteria">criteria</code></td>
<td>
<p>Name of criteria to sort by. Can be any of the following:
<code>"mean_distance", "monophyly", "clade_comparison",
"clade_comp_shallow", "zero_noncon", "zero_distances", "diag_nuc"</code> or
<code>"all"</code>. Default of <code>"mean_distance"</code> if distance measures have
been calculated, otherwise <code>"monophyly"</code>.</p>
</td></tr>
<tr><td><code id="rankSlidWin_+3A_num">num</code></td>
<td>
<p>Number of windows to return. Default of 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The criteria for <code>rankSlidWin</code> correspond to the variables outputted by
<code><a href="#topic+slideAnalyses">slideAnalyses</a></code> and are sorted in the following manner:
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>rankSlidWin</code> criterion: </td><td style="text-align: left;">
<code><a href="#topic+slideAnalyses">slideAnalyses</a></code> output:</td><td style="text-align: left;"> Sorting method:</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"mean_distance"</code> </td><td style="text-align: left;"> <code>"dist_mean_out"</code> </td><td style="text-align: left;"> Ascending</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"monophyly"</code> </td><td style="text-align: left;"> <code>"win_mono_out"</code> </td><td style="text-align: left;"> Ascending</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"clade_comparison"</code> </td><td style="text-align: left;"> <code>"comp_out"</code> </td><td style="text-align: left;"> Ascending</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"clade_comp_shallow"</code> </td><td style="text-align: left;"> <code>"comp_depth_out"</code> </td><td style="text-align: left;"> Ascending</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"zero_noncon"</code> </td><td style="text-align: left;"> <code>"noncon_out"</code> </td><td style="text-align: left;"> Descending</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"zero_distances"</code> </td><td style="text-align: left;"> <code>"zero_out"</code> </td><td style="text-align: left;"> Descending</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"diag_nuc"</code> </td><td style="text-align: left;"> <code>"nd_out"</code> </td><td style="text-align: left;"> Ascending</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>Given a sequence of 1:10, the ascending method of sorting considers 10 as
high. The descending method considers 1 as high.
</p>
<p>The <code>"all"</code> criterion returns the windows that have the highest
cumulative total score over all criteria.
</p>


<h3>Value</h3>

<p>A data frame giving the values of the measures calculated by
<code><a href="#topic+slideAnalyses">slideAnalyses</a></code>, ranked to show the top 10 positions based on
the criterion given.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slideAnalyses">slideAnalyses</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

doloSlide &lt;- slideAnalyses(dolomedes, doloSpp, 200, interval = 10, treeMeasures = TRUE)

rankSlidWin(doloSlide)
rankSlidWin(doloSlide, criteria = "zero_distances")

doloSlide2 &lt;- slideAnalyses(dolomedes, doloSpp, 200, interval = 10, treeMeasures = FALSE)
rankSlidWin(doloSlide2)

doloSlide3 &lt;- slideAnalyses(dolomedes, doloSpp, 200, interval = 10, distMeasures = FALSE, 
    treeMeasures = TRUE)
rankSlidWin(doloSlide3)

</code></pre>

<hr>
<h2 id='read.BOLD'>Downloads DNA sequences from the Barcode of Life Database (BOLD)</h2><span id='topic+read.BOLD'></span>

<h3>Description</h3>

<p>These functions allow DNA sequences to be downloaded from the Barcode of
Life Database (BOLD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.BOLD(IDs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.BOLD_+3A_ids">IDs</code></td>
<td>
<p>A character vector containing BOLD process ID numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>search.BOLD</code> retrieves BOLD process identification numbers for any
given taxon using the API for BOLD version 3.0. By default, it only returns
the first 500 process IDs for the given taxon. By selecting the option
<code>exhaustive = TRUE</code>, the function can be made to search for more than
500 process IDs, but is much slower.
</p>
<p><code>stats.BOLD</code> retrieves the total number of records for the given taxon.
</p>
<p><code>read.BOLD</code> downloads the sequences associated with the process
identification numbers using a brute force method of downloading the
specimen record, then searching and splitting the HTML code to remove the
relevant information. This process is likely to make the function fairly
unstable if BOLD make any changes to their website.
</p>
<p>Previous versions of <code>read.BOLD</code> used the eFetch web service offered by
BOLD to enable batch retrieval of records, however from October 2012 BOLD
deprecated eFetch without providing a replacement service.
</p>


<h3>Value</h3>

<p><code>search.BOLD</code> returns a character vector giving the process
identification numbers of the specimens found by the search.
</p>
<p><code>read.BOLD</code> returns an object of class &lsquo;DNAbin&rsquo;. This object has the
attributes &quot;species&quot;, &quot;accession_num&quot;, and &quot;gene&quot;.
</p>


<h3>Warning</h3>

<p>On 26 Oct 2011, attempts to access records using the
eFetch system through a web browser resulted in an error, saying that eFetch
and eSearch are offline for maintainance.
</p>
<p>As of 7 March 2012, both functions have been modified to interface with the
new BOLD architecture, and work as expected.
</p>
<p>29 Oct 2012: It appears that BOLD has taken eFetch offline permanently,
rendering <code>read.BOLD</code> as it currently stands useless. While we may be
able to work out something, this will require a complete rewrite of the
function. <code>search.BOLD</code> continues to work as intended.
</p>
<p>17 Dec 2012: A new version of <code>read.BOLD</code> has been released that
appears to work (for the time being).
</p>
<p>15 Feb 2018: 'read.BOLD' is deprecated. Please use the rOpenSci 'bold' package for better functionality.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>BOLD web services: <a href="http://www.boldsystems.org/index.php/resources/api?type=webservices">http://www.boldsystems.org/index.php/resources/api?type=webservices</a>.
</p>
<p>BOLD version 3.0 <a href="http://v3.boldsystems.org/">http://v3.boldsystems.org/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stats.BOLD">stats.BOLD</a></code>, <code><a href="#topic+search.BOLD">search.BOLD</a></code>, <code><a href="#topic+read.GB">read.GB</a></code>. 
<code><a href="utils.html#topic+help">help</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
stats.BOLD("Pisauridae")

search.BOLD(c("Danio kyathit", "Dolomedes", "Sitona discoideus"))

nn &lt;- search.BOLD("Pisauridae")
pisaurid &lt;- read.BOLD(nn)

ape::write.dna(pisaurid, "filename.fas", format="fasta")
## End(Not run)

</code></pre>

<hr>
<h2 id='read.GB'>Download sequences from Genbank with metadata.</h2><span id='topic+read.GB'></span>

<h3>Description</h3>

<p>Downloads sequences associated with the given accession numbers into a
&lsquo;DNAbin&rsquo; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.GB(access.nb, seq.names = access.nb, species.names = TRUE,
  gene = TRUE, access = TRUE, as.character = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.GB_+3A_access.nb">access.nb</code></td>
<td>
<p>A character vector giving the GenBank accession numbers to
download.</p>
</td></tr>
<tr><td><code id="read.GB_+3A_seq.names">seq.names</code></td>
<td>
<p>A character vector giving the names to give to each
sequence. Defaults to &quot;accession number | species name&quot;.</p>
</td></tr>
<tr><td><code id="read.GB_+3A_species.names">species.names</code></td>
<td>
<p>Logical. Should species names be downloaded? Default of
TRUE.</p>
</td></tr>
<tr><td><code id="read.GB_+3A_gene">gene</code></td>
<td>
<p>Logical. Should the name of the gene region be downloaded?
Default of TRUE.</p>
</td></tr>
<tr><td><code id="read.GB_+3A_access">access</code></td>
<td>
<p>Logical. Should the accession number be downloaded? Default of
TRUE.</p>
</td></tr>
<tr><td><code id="read.GB_+3A_as.character">as.character</code></td>
<td>
<p>Logical. Should the sequences be returned as character
vector? Default of FALSE, function returns sequences as a &lsquo;DNAbin&rsquo; object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a modification of
<code><a href="ape.html#topic+ape-package">read.GenBank</a></code> to include metadata with each
sequence. Additional data currently implemented are the species names and
the gene region from which sequences were derived.
</p>


<h3>Value</h3>

<p>A 'DNAbin' object with the following attributes: <code>"species"</code>,
<code>"gene"</code>, and <code>"accession_num"</code>.
</p>


<h3>Warning</h3>

<p>15 Feb 2018: 'read.GB' is deprecated. Please use the rOpenSci packages 'rentrez' and 'traits', or 'ape' for better functionality.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+read.GenBank">read.GenBank</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
read.GB("AY059961")

#Download the sequences making data(anoteropsis) from Genbank
nums &lt;- 59961:59993
seqs &lt;- paste("AY0", nums, sep="")
dat &lt;- read.GB(seqs)

attr(dat, "species")
attr(dat, "gene")
attr(dat, "accession_num")
## End(Not run)

</code></pre>

<hr>
<h2 id='rmSingletons'>Detect and remove singletons</h2><span id='topic+rmSingletons'></span>

<h3>Description</h3>

<p>A utility to detect and remove species represented only by singletons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmSingletons(sppVector, exclude = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmSingletons_+3A_sppvector">sppVector</code></td>
<td>
<p>Vector of species names. (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
<tr><td><code id="rmSingletons_+3A_exclude">exclude</code></td>
<td>
<p>Logical. Should singletons be removed? Default of TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>exclude = TRUE</code> (the default), singletons are excluded and the
vector returns the index of all non-singletons in the dataset. When
<code>exclude = FALSE</code>, the indices of the singletons are presented.
</p>


<h3>Value</h3>

<p>Returns a numeric vector giving the indices of the selected
individuals.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))

rmSingletons(anoSpp)
rmSingletons(anoSpp, exclude=FALSE)

data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

rmSingletons(doloSpp)
rmSingletons(doloSpp, exclude=FALSE)
</code></pre>

<hr>
<h2 id='rnucDiag'>Nucleotide diagnostics for species alignments</h2><span id='topic+rnucDiag'></span>

<h3>Description</h3>

<p>Determines the diagnostic nucleotides for each species given in
<code>sppVector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnucDiag(DNAbin, sppVector, n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rnucDiag_+3A_dnabin">DNAbin</code></td>
<td>
<p>An object of class 'DNAbin'.</p>
</td></tr>
<tr><td><code id="rnucDiag_+3A_sppvector">sppVector</code></td>
<td>
<p>The species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
<tr><td><code id="rnucDiag_+3A_n">n</code></td>
<td>
<p>The number of pseudoreplicates to perform. Default of 100</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide a means for evaluating the presence of diagnostic
nucleotides that distinguish species within an alignment. <code>nucDiag</code>
returns the positions of bases corresponding to the definition of pure,
simple diagnostic nucleotides given by Sarkar et al (2008).
</p>
<p><code>rnucDiag</code> runs a bootstrapping-style resampling test to evaluate the
numbers of diagnostic nucleotides that might be expected by random
assortment of specimens.
</p>


<h3>Value</h3>

<p><code>nucDiag</code> returns a list giving the pure, simple diagnostic
nucleotides (i.e. those nucleotides that are fixed within species and
different from all other species) for each species in the species vector. A
result of <code>integer(0)</code> indicates there are no diagnostic nucleotides
for those species.
</p>
<p><code>rnucDiag</code> returns a list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>min</code></td>
<td>
<p>The minimum number of diagnostic nucleotides in the sample.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The mean number of diagnostic nucleotides in the sample.</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>The median number of diagnostic nucleotides in the sample.</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>The maximum number of diagnostic nucleotides in the sample.</p>
</td></tr>
<tr><td><code>rndFreq</code></td>
<td>
<p>A list of frequency distributions of the number of diagnostic
nucleotides in groups formed by 1 sequence, 2 sequences, etc.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Sarkar, I., Planet, P., &amp; DeSalle, R. (2008). CAOS software for
use in character- based DNA barcoding. _Molecular Ecology Resources_ *8*
1256-1259
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slideNucDiag">slideNucDiag</a></code>, <code><a href="#topic+rnucDiag">rnucDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
	function(x) paste(x[1], x[2], sep="_"))

nucDiag(anoteropsis, anoSpp)


#To view the nucleotide values 
anoNuc &lt;- nucDiag(anoteropsis, anoSpp)
as.character(anoteropsis[ ,anoNuc[[1]][1] ])



data(sarkar)
sarkarSpp &lt;- substr(dimnames(sarkar)[[1]], 1, 3)
nucDiag(sarkar, sarkarSpp)

## Not run: 
rnucDiag(anoteropsis, anoSpp, n = 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='rosenberg'>Rosenberg's probability of reciprocal monophyly</h2><span id='topic+rosenberg'></span>

<h3>Description</h3>

<p>This function computes Rosenberg's probability of reciprocal monophyly for
each dichotomous node of a phylogenetic tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rosenberg(phy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rosenberg_+3A_phy">phy</code></td>
<td>
<p>A tree of class &lsquo;phylo&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because <code>ape</code> plots node labels in a different manner to the method in
which they are stored, when plotting the node labels made by
<code>rosenberg</code>, make sure the <code>node</code> argument is given as shown in
the examples below.
</p>


<h3>Value</h3>

<p>A numeric vector with names giving the node numbers of <code>phy</code>.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Rosenberg, N. A. (2007). Statistical tests for taxonomic
distinctiveness from observations of monophyly. _Evolution_ *61* (2),
317-323.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+nodelabels">nodelabels</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoTr &lt;- ape::nj(ape::dist.dna(anoteropsis))
anoLab &lt;- rosenberg(anoTr)
ape::plot.phylo(anoTr)
ape::nodelabels(round(anoLab,3), node=as.numeric(names(anoLab)))

data(dolomedes)
doloTr &lt;- ape::nj(ape::dist.dna(dolomedes))
doloRose &lt;- rosenberg(doloTr)
ape::plot.phylo(doloTr)
ape::nodelabels(round(doloRose, 3))

#Colour circles for nodes with a probability &lt; 0.005
doloNodes &lt;- doloRose &lt; 0.005
doloLabs &lt;- doloRose
doloLabs[doloNodes] &lt;- "blue"
doloLabs[!doloNodes] &lt;- "red"
ape::plot.phylo(doloTr, cex=0.7)
ape::nodelabels(pch=21, bg=doloLabs, node=as.numeric(names(doloLabs)), cex=2)
graphics::legend(x=0.015, y=16.13, legend=c("significant", "not significant"), pch=21, 
    pt.bg=c("blue", "red"), bty="n", pt.cex=2)

</code></pre>

<hr>
<h2 id='salticidae'>Cytochrome oxidase I (COI) sequences of world-wide species of Salticidae</h2><span id='topic+salticidae'></span>

<h3>Description</h3>

<p>A set of 41 sequences of the mitochondrial protein-coding gene cytochrome
oxidase I from 41 species of the jumping spider family Salticidae.The
sequences are available on GenBank as accession numbers AY297360 through
AY297400.
</p>


<h3>Format</h3>

<p>A DNAbin object containing 41 sequences with a length of 409 base
pairs stored as a list.</p>


<h3>Source</h3>

<p>Maddison, W. P., and Hedin, M. C. (2003). Jumping spider phylogeny
(Araneae: Salticidae). _Invertebrate Systematics_ *17* 529-549.
</p>

<hr>
<h2 id='sarkar'>Dummy sequences illustrating the categories of diagnostic nucleotides</h2><span id='topic+sarkar'></span>

<h3>Description</h3>

<p>A set of 8 dummy sequences published in Sarkar et al 2008 to illustrate the
different categories of diagnostic nucleotides.
</p>


<h3>Format</h3>

<p>A DNAbin object containing 8 sequences with a length of 18 base
pairs stored as a matrix.</p>


<h3>Source</h3>

<p>Sarkar, I., Planet, P., &amp; DeSalle, R. (2008). CAOS software for use
in character- based DNA barcoding. _Molecular Ecology Resources_ *8*
1256-1259
</p>

<hr>
<h2 id='search.BOLD'>Downloads DNA sequences from the Barcode of Life Database (BOLD)</h2><span id='topic+search.BOLD'></span>

<h3>Description</h3>

<p>These functions allow DNA sequences to be downloaded from the Barcode of
Life Database (BOLD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.BOLD(taxon, exhaustive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search.BOLD_+3A_taxon">taxon</code></td>
<td>
<p>A character vector of the names of the taxa of interest.</p>
</td></tr>
<tr><td><code id="search.BOLD_+3A_exhaustive">exhaustive</code></td>
<td>
<p>Logical. Should the function search for more than 500
process IDs? Default of FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>search.BOLD</code> retrieves BOLD process identification numbers for any
given taxon using the API for BOLD version 3.0. By default, it only returns
the first 500 process IDs for the given taxon. By selecting the option
<code>exhaustive = TRUE</code>, the function can be made to search for more than
500 process IDs, but is much slower.
</p>
<p><code>stats.BOLD</code> retrieves the total number of records for the given taxon.
</p>
<p><code>read.BOLD</code> downloads the sequences associated with the process
identification numbers using a brute force method of downloading the
specimen record, then searching and splitting the HTML code to remove the
relevant information. This process is likely to make the function fairly
unstable if BOLD make any changes to their website.
</p>
<p>Previous versions of <code>read.BOLD</code> used the eFetch web service offered by
BOLD to enable batch retrieval of records, however from October 2012 BOLD
deprecated eFetch without providing a replacement service.
</p>


<h3>Value</h3>

<p><code>search.BOLD</code> returns a character vector giving the process
identification numbers of the specimens found by the search.
</p>
<p><code>read.BOLD</code> returns an object of class &lsquo;DNAbin&rsquo;. This object has the
attributes &quot;species&quot;, &quot;accession_num&quot;, and &quot;gene&quot;.
</p>


<h3>Warning</h3>

<p>On 26 Oct 2011, attempts to access records using the
eFetch system through a web browser resulted in an error, saying that eFetch
and eSearch are offline for maintainance.
</p>
<p>As of 7 March 2012, both functions have been modified to interface with the
new BOLD architecture, and work as expected.
</p>
<p>29 Oct 2012: It appears that BOLD has taken eFetch offline permanently,
rendering <code>read.BOLD</code> as it currently stands useless. While we may be
able to work out something, this will require a complete rewrite of the
function. <code>search.BOLD</code> continues to work as intended.
</p>
<p>17 Dec 2012: A new version of <code>read.BOLD</code> has been released that
appears to work (for the time being).
15 Feb 2018: 'search.BOLD' is deprecated. Please use the rOpenSci 'bold' package for better functionality.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>BOLD web services: <a href="http://www.boldsystems.org/index.php/resources/api?type=webservices">http://www.boldsystems.org/index.php/resources/api?type=webservices</a>.
</p>
<p>BOLD version 3.0 <a href="http://v3.boldsystems.org/">http://v3.boldsystems.org/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stats.BOLD">stats.BOLD</a></code>, <code><a href="#topic+search.BOLD">search.BOLD</a></code>, <code><a href="#topic+read.GB">read.GB</a></code>. 
<code><a href="utils.html#topic+help">help</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
stats.BOLD("Pisauridae")

search.BOLD(c("Danio kyathit", "Dolomedes", "Sitona discoideus"))

nn &lt;- search.BOLD("Pisauridae")
pisaurid &lt;- read.BOLD(nn)

ape::write.dna(pisaurid, "filename.fas", format="fasta")
## End(Not run)

</code></pre>

<hr>
<h2 id='seeBarcode'>Create illustrative barcodes</h2><span id='topic+seeBarcode'></span>

<h3>Description</h3>

<p>This function plots an illustrative barcode consisting of vertical bands in
four colours corresponding to the DNA bases adenine (A), cytosine (C),
guanine (G) and thiamine (T).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seeBarcode(seq, col = c("green", "blue", "black", "red"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seeBarcode_+3A_seq">seq</code></td>
<td>
<p>A single sequence of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="seeBarcode_+3A_col">col</code></td>
<td>
<p>A character vector of length 4 giving colours to represent A, G,
C and T respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Green, blue, black and red are the standard colours representing A, G, C and
T respectively.
</p>


<h3>Value</h3>

<p>Plots an illustrative barcode.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
graphics::layout(matrix(1:6, ncol=1))
graphics::par(mar=c(0.5, 0, 0.5, 0))
data(woodmouse)
seeBarcode(woodmouse[1,])
seeBarcode(woodmouse[1,], col=c("pink", "orange", "steelblue", "yellow"))
seeBarcode(woodmouse[1,], col=c("black", "white", "white", "black"))
apply(woodmouse[1:3,], MARGIN=1, FUN=seeBarcode)

</code></pre>

<hr>
<h2 id='seqStat'>Sequence statistics</h2><span id='topic+seqStat'></span>

<h3>Description</h3>

<p>Utility that produces a table giving summary statistics for a &lsquo;DNAbin&rsquo;
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqStat(DNAbin, thresh = 500)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqStat_+3A_dnabin">DNAbin</code></td>
<td>
<p>Alignment of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="seqStat_+3A_thresh">thresh</code></td>
<td>
<p>Threshold sequence length. Default of 500 (minimum length for
official DNA barcodes).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function considers bases coded as '?', 'N' and '-' as missing data.
</p>


<h3>Value</h3>

<p>A table giving the minimum, maximum, mean and median sequence
lengths, and the number of sequences with lengths below the given threshold.
</p>


<h3>Author(s)</h3>

<p>Rupert Collins &lt;rupertcollins@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
seqStat(anoteropsis)

</code></pre>

<hr>
<h2 id='slideAnalyses'>Sliding window analyses</h2><span id='topic+slideAnalyses'></span>

<h3>Description</h3>

<p>Wraps a number of measures used in sliding window analyses into one
easy-to-use function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideAnalyses(DNAbin, sppVector, width, interval = 1, distMeasures = TRUE,
  treeMeasures = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slideAnalyses_+3A_dnabin">DNAbin</code></td>
<td>
<p>A DNA alignment of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="slideAnalyses_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
<tr><td><code id="slideAnalyses_+3A_width">width</code></td>
<td>
<p>Desired width of windows in number of nucleotides.</p>
</td></tr>
<tr><td><code id="slideAnalyses_+3A_interval">interval</code></td>
<td>
<p>Distance between each window in number of nucleotides.
Default of 1. Giving the option of 'codons' sets the size to 3.</p>
</td></tr>
<tr><td><code id="slideAnalyses_+3A_distmeasures">distMeasures</code></td>
<td>
<p>Logical. Should distance measures be calculated? Default
of TRUE.</p>
</td></tr>
<tr><td><code id="slideAnalyses_+3A_treemeasures">treeMeasures</code></td>
<td>
<p>Logical. Should tree-based measures be calculated?
Default of FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distance measures include the following: proportion of zero non-conspecific
distances, number of diagnostic nucleotides, number of zero-length
distances, and overall mean distance.
</p>
<p>Tree-based measures include the following: proportion of species that are
monophyletic, proportion of clades that are identical between the neighbour
joining tree calculated for the window and the tree calculated for the full
dataset, and the latter with <code>method="shallow"</code>.
</p>
<p>Tree-based measures are a lot more time-intensive than distance measures.
When dealing with lots of taxa and short windows, this part of the function
can take hours.
</p>
<p>Both distance and tree measures are calculated from a K2P distance matrix
created from the data with the option <code>pairwise.deletion = TRUE</code>. When
sequences with missing data are compared with other sequences, a <code>NA</code>
distance results. These are ignored in the calculation of
<code>slideAnalyses</code> distance metrics. However, the tree measures cannot
cope with this missing data, and so no result is returned for windows where
some sequences solely contain missing data.
</p>


<h3>Value</h3>

<p>An object of class 'slidWin' which is a list containing the
following elements: </p>
<table role = "presentation">
<tr><td><code>win_mono_out</code></td>
<td>
<p>Proportion of species that are
monophyletic.</p>
</td></tr> <tr><td><code>comp_out</code></td>
<td>
<p>Proportion of clades that are identical
between the NJ tree calculated for the window and the tree calculated for
the full dataset.</p>
</td></tr> <tr><td><code>comp_depth_out</code></td>
<td>
<p>Proportion of shallow clades that
are identical.</p>
</td></tr> <tr><td><code>pos_tr_out</code></td>
<td>
<p>Index of window position for tree-based
analyses.</p>
</td></tr> <tr><td><code>noncon_out</code></td>
<td>
<p>Proportion of zero non-conspecific distances.</p>
</td></tr>
<tr><td><code>nd_out</code></td>
<td>
<p>The sum of diagnostic nucleotides for each species.</p>
</td></tr>
<tr><td><code>zero_out</code></td>
<td>
<p>The number of zero-length distances.</p>
</td></tr>
<tr><td><code>dist_mean_out</code></td>
<td>
<p>Overall mean K2P distance of each window.</p>
</td></tr>
<tr><td><code>pos_out</code></td>
<td>
<p>Index of window position.</p>
</td></tr> <tr><td><code>dat_zero_out</code></td>
<td>
<p>Number of zero
inter-specific distances in the full dataset.</p>
</td></tr> <tr><td><code>boxplot_out</code></td>
<td>
<p>Always
FALSE. Required for <code><a href="#topic+plot.slidWin">plot.slidWin</a></code>.</p>
</td></tr> <tr><td><code>distMeasures</code></td>
<td>
<p>Value
of argument. Required for <code><a href="#topic+plot.slidWin">plot.slidWin</a></code>.</p>
</td></tr>
<tr><td><code>treeMeasures</code></td>
<td>
<p>Value of argument. Required for
<code><a href="#topic+plot.slidWin">plot.slidWin</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+plot.slidWin">plot.slidWin</a></code>,
<code><a href="#topic+rankSlidWin">rankSlidWin</a></code>, <code><a href="#topic+slideNucDiag">slideNucDiag</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

slideAnalyses(dolomedes, doloSpp, 200, interval=10, treeMeasures=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='slideBoxplots'>Boxplots across windows</h2><span id='topic+slideBoxplots'></span>

<h3>Description</h3>

<p>Calculates boxplots of genetic distances using sliding windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideBoxplots(DNAbin, sppVector, width, interval = 1, method = "nonCon")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slideBoxplots_+3A_dnabin">DNAbin</code></td>
<td>
<p>A DNA alignment of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="slideBoxplots_+3A_sppvector">sppVector</code></td>
<td>
<p>A species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
<tr><td><code id="slideBoxplots_+3A_width">width</code></td>
<td>
<p>Width of windows.</p>
</td></tr>
<tr><td><code id="slideBoxplots_+3A_interval">interval</code></td>
<td>
<p>Distance between each window in number of base pairs.
Default of 1. Giving the option of <code>"codons"</code> sets the size to 3.</p>
</td></tr>
<tr><td><code id="slideBoxplots_+3A_method">method</code></td>
<td>
<p>Options of <code>"overall", "interAll"</code> or <code>"nonCon"</code>
(the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Giving <code>method="overall"</code> calculates the boxplot for the distance
matrix of each window.
</p>
<p>Giving <code>method="interAll"</code> calculates boxplots for the inter- and
intra-specific distances of each window, showing the result for ALL
inter-specific distances.
</p>
<p>Giving <code>method="nonCon"</code> calculates boxplots for the inter- and
intra-specific distances of each window, showing the result for only the
nearest-conspecific distances for each individual.
</p>


<h3>Value</h3>

<p>A list with
</p>
<table role = "presentation">
<tr><td><code>treeMeasures</code></td>
<td>
<p>Logical. Tree measures calculated? Always FALSE.</p>
</td></tr>
<tr><td><code>distMeasures</code></td>
<td>
<p>Logical. Distance measures calculated? Always FALSE.</p>
</td></tr>
<tr><td><code>bp_out</code></td>
<td>
<p>If <code>method="overall"</code>, contains the boxplot objects of
each window.</p>
</td></tr> <tr><td><code>bp_InterSpp_out</code></td>
<td>
<p>If <code>method!="overall"</code>, contains
the boxplot objects of the interspecific distances of each window.</p>
</td></tr>
<tr><td><code>bp_IntraSpp_out</code></td>
<td>
<p>If <code>method!="overall"</code>, contains the boxplot
objects of the intraspecific distances of each window.</p>
</td></tr>
<tr><td><code>bp_range_out</code></td>
<td>
<p>range of y-axis values.</p>
</td></tr> <tr><td><code>pos_out</code></td>
<td>
<p>x-axis values.</p>
</td></tr>
<tr><td><code>boxplot_out</code></td>
<td>
<p>Logical. Boxplots calculated? Always TRUE.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method used for calculating boxplots. <code>"overall",
"interAll"</code> or <code>"nonCon"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>, <code><a href="#topic+plot.slidWin">plot.slidWin</a></code>,
<code><a href="#topic+slideAnalyses">slideAnalyses</a></code>, <code><a href="#topic+slidingWindow">slidingWindow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

doloNonCon &lt;- slideBoxplots(dolomedes, doloSpp, 200, interval=10)
graphics::plot(doloNonCon)

doloOverall &lt;- slideBoxplots(dolomedes, doloSpp, 200, interval=10, method="overall")
graphics::plot(doloOverall)

doloInterall &lt;- slideBoxplots(dolomedes, doloSpp, 200, interval=10, method="interAll")
graphics::plot(doloInterall)

</code></pre>

<hr>
<h2 id='slideNucDiag'>Sliding nucleotide diagnostics</h2><span id='topic+slideNucDiag'></span>

<h3>Description</h3>

<p>Calculates the number of diagnostic nucleotides in sliding windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideNucDiag(DNAbin, sppVector, width, interval = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slideNucDiag_+3A_dnabin">DNAbin</code></td>
<td>
<p>A DNA alignment of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="slideNucDiag_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
<tr><td><code id="slideNucDiag_+3A_width">width</code></td>
<td>
<p>Desired width of windows in number of base pairs.</p>
</td></tr>
<tr><td><code id="slideNucDiag_+3A_interval">interval</code></td>
<td>
<p>Distance between each window in number of base pairs.
Default of 1. Giving the option of <code>"codons"</code> sets the size to 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determines the number of diagnostic nucleotides for each species in each
window.
</p>


<h3>Value</h3>

<p>A matrix giving the number of diagnostic nucleotides for each
species (rows) in each window (columns).
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slideAnalyses">slideAnalyses</a></code>, <code><a href="#topic+slideBoxplots">slideBoxplots</a></code>,
<code><a href="#topic+slidingWindow">slidingWindow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

slideNucDiag(dolomedes, doloSpp, 200, interval = 3)

slidND &lt;- slideNucDiag(dolomedes, doloSpp, 200, interval = 3)

#Number of basepairs for each species
graphics::matplot(t(slidND), type = "l")

#Number of basepairs for a single species
graphics::plot(slidND[4, ], type = "l")

#Total number of basepairs per window
graphics::plot(colSums(slidND), type = "l")


</code></pre>

<hr>
<h2 id='slidingWindow'>Create windows along an alignment</h2><span id='topic+slidingWindow'></span>

<h3>Description</h3>

<p>Creates windows of a specified width along a DNA alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slidingWindow(DNAbin, width, interval = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slidingWindow_+3A_dnabin">DNAbin</code></td>
<td>
<p>A DNA alignment of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="slidingWindow_+3A_width">width</code></td>
<td>
<p>Width of each window.</p>
</td></tr>
<tr><td><code id="slidingWindow_+3A_interval">interval</code></td>
<td>
<p>Numeric or option of <code>"codons"</code>. This sets interval
between windows. Default of 1. Setting the option to &quot;codons&quot; gives an
interval of 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sliding window analyses are often used to determine the variability along
sequences. This can be useful for investigating whether there is evidence
for recombination, developing shorter genetic markers, or for determining
variation within a gene.
</p>
<p>Analyses can be conducted on each window using <code><a href="base.html#topic+lapply">lapply</a></code>.
</p>


<h3>Value</h3>

<p>A list of &lsquo;DNAbin&rsquo; objects, with each alignment being <code>width</code>
bases in length. The list has length of the DNA alignment minus the width.
The positions covered by each window can be retreived with <code>attr(x,
"window")</code>.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lapply">lapply</a></code>, <code><a href="#topic+slideAnalyses">slideAnalyses</a></code>,
<code><a href="#topic+slideBoxplots">slideBoxplots</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(woodmouse)
woodmouse &lt;- woodmouse[,1:20]
win1 &lt;- slidingWindow(woodmouse, width = 10)
length(win1)

win2 &lt;- slidingWindow(woodmouse, width = 10, interval = 2)
length(win2)

win3 &lt;- slidingWindow(woodmouse, width = 10, interval = "codons")
length(win3)

win4 &lt;- slidingWindow(woodmouse, width = 15)
length(win4)
attr(win4[[1]], "window")
attr(win4[[2]], "window")

</code></pre>

<hr>
<h2 id='sppDist'>Intra and inter-specific distances</h2><span id='topic+sppDist'></span>

<h3>Description</h3>

<p>Separates a distance matrix into its inter- and intra-specific components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sppDist(distobj, sppVector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sppDist_+3A_distobj">distobj</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
<tr><td><code id="sppDist_+3A_sppvector">sppVector</code></td>
<td>
<p>The species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to produce histograms and other charts exploring
the &lsquo;barcode gap&rsquo;, such as in the examples below.
</p>


<h3>Value</h3>

<p>A list with two elements: </p>
<table role = "presentation">
<tr><td><code>inter</code></td>
<td>
<p>A numeric vector containing
ALL inter-specific pairwise distances.</p>
</td></tr> <tr><td><code>intra</code></td>
<td>
<p>A numeric vector
containing ALL intra-specific pairwise distances.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sppDistMatrix">sppDistMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

doloSpDist &lt;- sppDist(doloDist, doloSpp)

doloSpDist

#Histogram of the barcode gap
transGreen &lt;- rgb(0, 1, 0, 0.5) #Make a slightly transparent colour to see some overlap
graphics::hist(doloSpDist$inter, col="grey")
graphics::hist(doloSpDist$intra, col=transGreen, add=TRUE)

#Boxplot of the same
graphics::boxplot(doloSpDist)

</code></pre>

<hr>
<h2 id='sppDistMatrix'>Mean intra- and inter-specific distance matrix</h2><span id='topic+sppDistMatrix'></span>

<h3>Description</h3>

<p>Creates a matrix giving the mean distances within and between species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sppDistMatrix(distobj, sppVector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sppDistMatrix_+3A_distobj">distobj</code></td>
<td>
<p>A distance matrix.</p>
</td></tr>
<tr><td><code id="sppDistMatrix_+3A_sppvector">sppVector</code></td>
<td>
<p>The species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix with dimensions <code>length(sppVector)</code>. It
contains the mean intra specific distances down the diagonal, and the mean
pairwise distance between the species in the triangles. The two triangles
are identical.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

sppDistMatrix(doloDist, doloSpp)


</code></pre>

<hr>
<h2 id='sppVector'>
Species Vectors
</h2><span id='topic+sppVector'></span>

<h3>Description</h3>

<p>A grouping variable that gives an identity to the individuals in various analyses.
</p>


<h3>Details</h3>

<p>Species vectors are the key concept behind a lot of <code>spider</code>'s functionality. They are the method used to group data from individuals into species. It is important to note that &quot;species&quot; in this context can mean any cluster (real or otherwise) that is of interest. Populations, demes, subspecies and genera could be the taxa segregated by &quot;species vectors&quot;.
</p>
<p>The two characteristics of a species vector are UNIQUENESS between species and CONSISTENCY within them. R recognises differences of a single character between elements, leading to <code>spider</code> considering these elements to represent different species.
</p>
<p>There is an easy way and a hard way to create species vectors. The hard way is to type out each element in the vector, making sure no typos or alignment errors are made.
</p>
<p>The easy way is to add species designations into your data matrix from the beginning in such a way that it is easy to use R's data manipulation tools to create a species vector from the names of your data. See the examples for a few ways to do this.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p>Functions for creating species vectors:
<code><a href="base.html#topic+strsplit">strsplit</a></code>, <code><a href="base.html#topic+substr">substr</a></code>, <code><a href="base.html#topic+sapply">sapply</a></code>.
</p>
<p>Functions that use species vectors:
<code><a href="#topic+nearNeighbour">nearNeighbour</a></code>, <code><a href="#topic+monophyly">monophyly</a></code>, <code><a href="#topic+nonConDist">nonConDist</a></code>, <code><a href="#topic+nucDiag">nucDiag</a></code>, <code><a href="#topic+rmSingletons">rmSingletons</a></code>, <code><a href="#topic+slideAnalyses">slideAnalyses</a></code>, <code><a href="#topic+slideBoxplots">slideBoxplots</a></code>, <code><a href="#topic+sppDist">sppDist</a></code>, <code><a href="#topic+sppDistMatrix">sppDistMatrix</a></code>, <code><a href="#topic+threshOpt">threshOpt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dolomedes)
#Dolomedes species vector
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

data(anoteropsis)
#Anoteropsis species vector
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))


</code></pre>

<hr>
<h2 id='stats.BOLD'>Downloads DNA sequences from the Barcode of Life Database (BOLD)</h2><span id='topic+stats.BOLD'></span>

<h3>Description</h3>

<p>These functions allow DNA sequences to be downloaded from the Barcode of
Life Database (BOLD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats.BOLD(taxon)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stats.BOLD_+3A_taxon">taxon</code></td>
<td>
<p>A character vector of the names of the taxa of interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>search.BOLD</code> retrieves BOLD process identification numbers for any
given taxon using the API for BOLD version 3.0. By default, it only returns
the first 500 process IDs for the given taxon. By selecting the option
<code>exhaustive = TRUE</code>, the function can be made to search for more than
500 process IDs, but is much slower.
</p>
<p><code>stats.BOLD</code> retrieves the total number of records for the given taxon.
</p>
<p><code>read.BOLD</code> downloads the sequences associated with the process
identification numbers using a brute force method of downloading the
specimen record, then searching and splitting the HTML code to remove the
relevant information. This process is likely to make the function fairly
unstable if BOLD make any changes to their website.
</p>
<p>Previous versions of <code>read.BOLD</code> used the eFetch web service offered by
BOLD to enable batch retrieval of records, however from October 2012 BOLD
deprecated eFetch without providing a replacement service.
</p>


<h3>Value</h3>

<p><code>search.BOLD</code> returns a character vector giving the process
identification numbers of the specimens found by the search.
</p>
<p><code>read.BOLD</code> returns an object of class &lsquo;DNAbin&rsquo;. This object has the
attributes &quot;species&quot;, &quot;accession_num&quot;, and &quot;gene&quot;.
</p>


<h3>Warning</h3>

<p>On 26 Oct 2011, attempts to access records using the
eFetch system through a web browser resulted in an error, saying that eFetch
and eSearch are offline for maintainance.
</p>
<p>As of 7 March 2012, both functions have been modified to interface with the
new BOLD architecture, and work as expected.
</p>
<p>29 Oct 2012: It appears that BOLD has taken eFetch offline permanently,
rendering <code>read.BOLD</code> as it currently stands useless. While we may be
able to work out something, this will require a complete rewrite of the
function. <code>search.BOLD</code> continues to work as intended.
</p>
<p>17 Dec 2012: A new version of <code>read.BOLD</code> has been released that
appears to work (for the time being).
15 Feb 2018: 'stats.BOLD' is deprecated. Please use the rOpenSci 'bold' package for better functionality.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>BOLD web services: <a href="http://www.boldsystems.org/index.php/resources/api?type=webservices">http://www.boldsystems.org/index.php/resources/api?type=webservices</a>.
</p>
<p>BOLD version 3.0 <a href="http://v3.boldsystems.org/">http://v3.boldsystems.org/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stats.BOLD">stats.BOLD</a></code>, <code><a href="#topic+search.BOLD">search.BOLD</a></code>, <code><a href="#topic+read.GB">read.GB</a></code>. 
<code><a href="utils.html#topic+help">help</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
stats.BOLD("Pisauridae")

search.BOLD(c("Danio kyathit", "Dolomedes", "Sitona discoideus"))

nn &lt;- search.BOLD("Pisauridae")
pisaurid &lt;- read.BOLD(nn)

ape::write.dna(pisaurid, "filename.fas", format="fasta")
## End(Not run)

</code></pre>

<hr>
<h2 id='tajima.K'>Calculate Tajima's K index of divergence</h2><span id='topic+tajima.K'></span>

<h3>Description</h3>

<p>Calculates Tajima's K index of divergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tajima.K(DNAbin, prop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tajima.K_+3A_dnabin">DNAbin</code></td>
<td>
<p>An object of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
<tr><td><code id="tajima.K_+3A_prop">prop</code></td>
<td>
<p>Logical. Should the function report the number of substitutions
per nucleotide? Default of TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 1. If <code>prop = FALSE</code>, the mean number of
substitutions between any two sequences is returned. If <code>prop = TRUE</code>
(the default), this number is returned as the mean number of substitutions
per nucleotide (i.e. the above divided by the length of the sequences).
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Tajima, F. (1983). Evolutionary relationship of DNA sequences in
finite populations. _Genetics_ *105*, 437-460.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+dist.dna">dist.dna</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
tajima.K(anoteropsis)
tajima.K(anoteropsis, prop = FALSE)

</code></pre>

<hr>
<h2 id='tclust'>Clustering by a threshold</h2><span id='topic+tclust'></span>

<h3>Description</h3>

<p>Identifies clusters, excluding individuals greater than the threshold from
any member.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tclust(distobj, threshold = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tclust_+3A_distobj">distobj</code></td>
<td>
<p>A distance object (usually from <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>).</p>
</td></tr>
<tr><td><code id="tclust_+3A_threshold">threshold</code></td>
<td>
<p>Distance cutoff for clustering. Default of 0.01 (1%).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If two individuals are more distant than <code>threshold</code> from each other,
but both within <code>threshold</code> of a third, all three are contained in a
single cluster.
</p>


<h3>Value</h3>

<p>A list with each element giving the index of the individuals
contained in each cluster.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+localMinima">localMinima</a></code>. 
See Also as <code><a href="utils.html#topic+help">help</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
	function(x) paste(x[1], x[2], sep="_"))
anoDist &lt;- ape::dist.dna(anoteropsis)

tclust(anoDist)

#Names of individuals
anoClust &lt;- tclust(anoDist)
lapply(anoClust, function(x) anoSpp[x])

</code></pre>

<hr>
<h2 id='threshID'>Measures of identification accuracy</h2><span id='topic+threshID'></span>

<h3>Description</h3>

<p>Tests of barcoding efficacy using distance-based methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshID(distobj, sppVector, threshold = 0.01, names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshID_+3A_distobj">distobj</code></td>
<td>
<p>A distance object (usually from <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>).</p>
</td></tr>
<tr><td><code id="threshID_+3A_sppvector">sppVector</code></td>
<td>
<p>Vector of species names. See <code><a href="#topic+sppVector">sppVector</a></code>.</p>
</td></tr>
<tr><td><code id="threshID_+3A_threshold">threshold</code></td>
<td>
<p>Distance cutoff for identifications. Default of 0.01 (1%).</p>
</td></tr>
<tr><td><code id="threshID_+3A_names">names</code></td>
<td>
<p>Logical. Should the names of the nearest match be shown?
Default of FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions test barcoding efficacy. All sequences must be identified
prior to testing. Each sequence is considered an unknown while the remaining
sequences in the dataset constitute the DNA barcoding database that is used
for identification. If the identification from the test is the same as the
pre-considered identification, a correct result is returned.
</p>
<p><code>bestCloseMatch</code> conducts the &quot;best close match&quot; analysis of Meier et
al. (2006), considering the closest individual unless it is further than the
given threshold, which results in no identification. More than one species
tied for closest match results in an assignment of &quot;ambiguous&quot;. When the
threshold is large, this analysis will return essentially the same result as
<code>nearNeighbour</code>. If <code>names = TRUE</code>, a list is returned containing
the names of all species represented by specimens within the threshold.
</p>
<p><code>nearNeighbour</code> finds the closest individual and returns if their names
are the same (TRUE) or different (FALSE). If <code>names = TRUE</code>, the name
of the closest individual is returned. Ties are decided by majority rule.
</p>
<p><code>threshID</code> conducts a threshold-based analysis, similar to that
conducted by the &quot;Identify Specimen&quot; tool provided by the Barcode of Life
Database (<a href="http://www.boldsystems.org/index.php/IDS_OpenIdEngine">http://www.boldsystems.org/index.php/IDS_OpenIdEngine</a>). It
is more inclusive than <code>bestCloseMatch</code>, considering ALL sequences
within the given threshold. If <code>names = TRUE</code>, a list is returned
containing the names of all species represented by specimens within the
threshold.
</p>
<p>These functions are not recommended as identification tools, though they can
be used as such when <code>names = TRUE</code>.
</p>


<h3>Value</h3>

<p><code>bestCloseMatch</code> and <code>threshID</code> return a character vector
giving the identification status of each individual.  </p>
<table role = "presentation">
<tr><td><code>"correct"</code></td>
<td>
<p>The
name of the closest match is the same</p>
</td></tr> <tr><td><code>"incorrect"</code></td>
<td>
<p>The name of the
closest match is different</p>
</td></tr> <tr><td><code>"ambiguous"</code></td>
<td>
<p>More than one species is the
closest match (<code>bestCloseMatch</code>), or is within the given threshold
(<code>threshID</code>)</p>
</td></tr> <tr><td><code>"no id"</code></td>
<td>
<p>No species are within the threshold
distance</p>
</td></tr>
</table>
<p><code>nearNeighbour</code> returns a logical vector or (if <code>names = TRUE</code>)
the name for the nearest individual.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Meier, R., Shiyang, K., Vaidya, G., &amp; Ng, P. (2006). DNA
barcoding and taxonomy in Diptera: a tale of high intraspecific variability
and low identification success. _Systematic Biology_ *55* (5) 715-728.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nearNeighbour">nearNeighbour</a></code>, <code><a href="#topic+threshID">threshID</a></code>, <code><a href="ape.html#topic+dist.dna">dist.dna</a></code>, <code><a href="#topic+sppVector">sppVector</a></code> 
Also as <code><a href="utils.html#topic+help">help</a></code>, ~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split = "_"), 
    function(x) paste(x[1], x[2], sep = "_"))

bestCloseMatch(anoDist, anoSpp)
bestCloseMatch(anoDist, anoSpp, threshold = 0.005)
nearNeighbour(anoDist, anoSpp)
nearNeighbour(anoDist, anoSpp, names = TRUE)
threshID(anoDist, anoSpp)
threshID(anoDist, anoSpp, threshold = 0.003)

data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)

bestCloseMatch(doloDist, doloSpp)
bestCloseMatch(doloDist, doloSpp, threshold = 0.005)
nearNeighbour(doloDist, doloSpp)
nearNeighbour(doloDist, doloSpp, names=TRUE)
threshID(doloDist, doloSpp)
threshID(doloDist, doloSpp, threshold = 0.003)

</code></pre>

<hr>
<h2 id='threshOpt'>Threshold optimisation</h2><span id='topic+threshOpt'></span>

<h3>Description</h3>

<p>Determines the positive, negative, false positive and false negative rates
of identification accuracy for a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshOpt(distobj, sppVector, threshold = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshOpt_+3A_distobj">distobj</code></td>
<td>
<p>Distance matrix.</p>
</td></tr>
<tr><td><code id="threshOpt_+3A_sppvector">sppVector</code></td>
<td>
<p>Species vector (see <code><a href="#topic+sppVector">sppVector</a></code>).</p>
</td></tr>
<tr><td><code id="threshOpt_+3A_threshold">threshold</code></td>
<td>
<p>Threshold distance for delimiting intra- and inter-specific
variation. Default of 0.01.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When run over a range of thresholds, this function allows the optimisation
of threshold values based on minimising the identification error rates. See
the example below for more details.
</p>


<h3>Value</h3>

<p>A table giving the threshold and number of negative and positive
identifications, number of false negative and false positive
identifications, and the cumulative error.
</p>


<h3>Author(s)</h3>

<p>Rupert Collins &lt;rupertcollins@gmail.com&gt;
</p>


<h3>References</h3>

<p>Meyer, C. P., and Paulay, G. (2005). DNA barcoding: error rates
based on comprehensive sampling. _PLoS Biology_ *3* (12), 2229-2238.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+localMinima">localMinima</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoDist &lt;- ape::dist.dna(anoteropsis)
anoSpp &lt;- sapply(strsplit(dimnames(anoteropsis)[[1]], split="_"), 
    function(x) paste(x[1], x[2], sep="_"))
threshOpt(anoDist, anoSpp)

data(dolomedes)
doloDist &lt;- ape::dist.dna(dolomedes)
doloSpp &lt;- substr(dimnames(dolomedes)[[1]], 1, 5)
threshOpt(doloDist, doloSpp)

#Conduct the analysis over a range of values to determine the optimum threshold
threshVal &lt;- seq(0.001,0.02, by = 0.001)
opt &lt;- lapply(threshVal, function(x) threshOpt(doloDist, doloSpp, thresh = x))
optMat &lt;- do.call(rbind, opt)
graphics::barplot(t(optMat)[4:5,], names.arg=optMat[,1], xlab="Threshold values", 
    ylab="Cumulative error")
graphics::legend(x = 2.5, y = 29, legend = c("False positives", "False negatives"), 
    fill = c("grey75", "grey25"))

</code></pre>

<hr>
<h2 id='tiporder'>Orders tip labels by their position on the tree.</h2><span id='topic+tiporder'></span>

<h3>Description</h3>

<p>Provides an ordered vector of tip labels, corresponding to their position on
the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiporder(phy, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tiporder_+3A_phy">phy</code></td>
<td>
<p>A tree of class &lsquo;phylo&rsquo;.</p>
</td></tr>
<tr><td><code id="tiporder_+3A_labels">labels</code></td>
<td>
<p>Logical. Should labels be printed? If FALSE, the indices are
given. Default of TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character or numeric vector giving the names of the tip in the
order of their position on the tree. The order is that from top to bottom
when the tree is plotted with <code>direction = "rightwards"</code>.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(anoteropsis)
anoTree &lt;- ape::nj(ape::dist.dna(anoteropsis))
tiporder(anoTree)
tiporder(anoTree, labels = FALSE)


data(woodmouse)
woodTree &lt;- ape::nj(ape::dist.dna(woodmouse))
tiporder(woodTree)
tiporder(ape::ladderize(woodTree))

</code></pre>

<hr>
<h2 id='titv'>Number of pairwise transitions and transversions in an alignment.</h2><span id='topic+titv'></span>

<h3>Description</h3>

<p>Calculates the number of pairwise transitions and transversions between
sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>titv(DNAbin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="titv_+3A_dnabin">DNAbin</code></td>
<td>
<p>A DNA alignment of class &lsquo;DNAbin&rsquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix with dimensions of <code>length(dat)</code>. The upper
triangle contains the number of transversions. The lower triangle contains
the number of transitions.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dolomedes)

subs &lt;- titv(dolomedes)

#Transversions
subs[upper.tri(subs)]
tv &lt;- t(subs)
tv &lt;- tv[lower.tri(tv)]

#Transitions
ti &lt;- subs[lower.tri(subs)]


#Saturation plot
doloDist &lt;- ape::dist.dna(dolomedes)
graphics::plot(doloDist, ti, type="p", pch=19, col="blue", 
    main="Saturation plot of number of transitions and transversions\n
    against K2P distance. Red: transversions. Blue: transitions")
graphics::points(doloDist, tv, pch=19, col="red")


</code></pre>

<hr>
<h2 id='tree.comp'>Tree comparisons</h2><span id='topic+tree.comp'></span>

<h3>Description</h3>

<p>Compares the clades between two trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.comp(phy1, phy2, method = "prop")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree.comp_+3A_phy1">phy1</code>, <code id="tree.comp_+3A_phy2">phy2</code></td>
<td>
<p>Trees of class &lsquo;phylo&rsquo; to compare.</p>
</td></tr>
<tr><td><code id="tree.comp_+3A_method">method</code></td>
<td>
<p>One of the following options: </p>
 <ul>
<li>
<p><code>"prop"</code>&mdash;returns the proportion of clades that are the same between
the two trees </p>
</li>
<li> <p><code>"shallow"</code>&mdash;returns the proportion of shallow
clades (clades where <code>node.depth</code> &lt; median <code>node.depth</code>) that are
the same between the two trees default of <code>"prop"</code>.  </p>
</li>
<li>
<p><code>"PH85"</code>&mdash;returns the topological distance of Penny and Hendy (1985).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a modification of the <code><a href="ape.html#topic+dist.topo">dist.topo</a></code> function in
<code>ape</code> to give similarity between the two trees as a proportion, and to
account for the unreliable resolution of deeper nodes that affect some
methods of tree construction (such as NJ).
</p>
<p>It is important that the tip labels of the two trees are the same. If the
tip labels are different between the two trees, the method will not
recognise any similarity between them.
</p>
<p>This function does not take into account differences in branch length. The
<code>"score"</code> method in <code><a href="ape.html#topic+dist.topo">dist.topo</a></code> does this if desired.
</p>


<h3>Value</h3>

<p>Numeric vector of length 1.
</p>
<p>If <code>method = "prop"</code>, the number returned is the proportion of nodes in
the first tree for which there is a node in the second that contains the
same tips. Higher number represents greater similarity. If it is 1, the
trees are identical. If 0, the trees have no similarity whatsoever.
</p>
<p>When <code>method = "shallow"</code>, only those nodes tipwards of the median node
depth are taken into account. This will not be useful for small trees, but
may be helpful with larger datasets.
</p>
<p><code>"PH85"</code> is the Penny and Hendy (1985) distance. This measure is the
default of <code><a href="ape.html#topic+dist.topo">dist.topo</a></code>. In this measure, the smaller the number,
the closer the trees are. If the trees are identical, this results in 0.
</p>


<h3>Author(s)</h3>

<p>Samuel Brown &lt;s_d_j_brown@hotmail.com&gt;
</p>


<h3>References</h3>

<p>Penny, D. and Hendy, M. D. (1985) The use of tree comparison
metrics. _Systematic Zoology_ *34* 75-82.
</p>


<h3>See Also</h3>

<p><code><a href="ape.html#topic+node.depth">node.depth</a></code>, <code><a href="ape.html#topic+dist.topo">dist.topo</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
tr &lt;- ape::rtree(15)
set.seed(22)
tr2 &lt;- ape::rtree(15)
tree.comp(tr, tr2)
tree.comp(tr, tr2, method="PH85")
tree.comp(tr, tr2, method="shallow")

</code></pre>

<hr>
<h2 id='woodmouse'>Cytochrome b Gene Sequences of Woodmice</h2><span id='topic+woodmouse'></span>

<h3>Description</h3>

<p>This is a set of 15 sequences of the mitochondrial gene cytochrome
<em>b</em> of the woodmouse (<em>Apodemus sylvaticus</em>) which is a
subset of the data analysed by Michaux et al. (2003). The full data
set is available through GenBank (accession numbers AJ511877 to
AJ511987). Dataset from the ape package.
</p>


<h3>Format</h3>

<p>A DNAbin object containing 8 sequences with a length of 18 base
pairs stored as a matrix.</p>


<h3>Source</h3>

<p>Michaux, J. R., Magnanou, E., Paradis, E., Nieberding, C. and Libois,
R. (2003) Mitochondrial phylogeography of the Woodmouse
(<em>Apodemus sylvaticus</em>) in the Western Palearctic region.
_Molecular Ecology_ *12*, 685-697
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
