<!DOCTYPE html><html><head><title>Help for package rem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rem-package'><p>Fit Relational Event Models (REM)</p></a></li>
<li><a href='#createRemDataset'><p>Create REM data set with dynamic risk sets</p></a></li>
<li><a href='#degreeStat'><p>Calculate (in/out)-degree statistics</p></a></li>
<li><a href='#eventSequence'><p>Create event sequence</p></a></li>
<li><a href='#fourCycleStat'><p>Calculate four cycle statistics</p></a></li>
<li><a href='#inertiaStat'><p>Calculate inertia statistics</p></a></li>
<li><a href='#reciprocityStat'><p>Calculate reciprocity statistics</p></a></li>
<li><a href='#similarityStat'><p>Calculate similarity statistics</p></a></li>
<li><a href='#timeToEvent'><p>Calculate the time-to-next-event or the time-since-date for a REM data set.</p></a></li>
<li><a href='#triadStat'><p>Calculate triad statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Relational Event Models (REM)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-10-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Laurence Brandenberger</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laurence Brandenberger &lt;lbrandenberger@ethz.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate endogenous network effects in event sequences and fit relational event models (REM): Using network event sequences (where each tie between a sender and a target in a network is time-stamped), REMs can measure how networks form and evolve over time. Endogenous patterns such as popularity effects, inertia, similarities, cycles or triads can be calculated and analyzed over time.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, foreach, doParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>texreg, statnet, ggplot2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-10-25 08:28:46 UTC; lenzibrandenberger</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-10-25 13:10:24 UTC</td>
</tr>
</table>
<hr>
<h2 id='rem-package'>Fit Relational Event Models (REM)</h2><span id='topic+rem-package'></span><span id='topic+rem'></span><span id='topic+relational-event-model'></span><span id='topic+relational+20event+20model'></span>

<h3>Description</h3>

<p>The <span class="pkg">rem</span> package uses a combination of event history and network analysis to test network dependencies in event sequences. If events in an event sequence depend on each other, network structures and patterns can be calculated and estimated using relational event models. The <code>rem</code>-package includes functions to calculate endogenous network statistics in (signed) one-, two- and multi-mode network event sequences. The statistics include inertia (<a href="#topic+inertiaStat">inertiaStat</a>), reciprocity (<a href="#topic+reciprocityStat">reciprocityStat</a>), in- or outdegree statistics (<a href="#topic+degreeStat">degreeStat</a>), closing triads (<a href="#topic+triadStat">triadStat</a>), closing four-cycles (<a href="#topic+fourCycleStat">fourCycleStat</a>) or endogenous similarity statistics (<a href="#topic+similarityStat">similarityStat</a>). The rate of event occurrence can then be tested using standard models of event history analysis, such as a stratified Cox model (or a conditional logistic regression). <a href="#topic+createRemDataset">createRemDataset</a> can be used to create counting process data sets with dynamic risk sets.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> rem</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-10-24</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:lbrandenberger@ethz.ch">lbrandenberger@ethz.ch</a>
</p>


<h3>References</h3>

<p>Lerner, Jurgen, Bussmann, Margit, Snijders, Tom. A., &amp; Brandes, Ulrik. 2013. Modeling frequency and type of interaction in event networks. Corvinus Journal of Sociology and Social Policy, (1), 3-32.
</p>
<p>Brandenberger, Laurence. 2018. Trading Favors - Examining the Temporal Dynamics of Reciprocity in Congressional Collaborations Using Relational Event Models. Social Networks, 54: 238-253.
</p>
<p>Malang, Thomas, Laurence Brandeberger and Philip Leifeld. 2018. Networks and Social Influence in European Legislative Politics. British Journal of Political Science. DOI: 10.1017/S0007123417000217.
</p>

<hr>
<h2 id='createRemDataset'>Create REM data set with dynamic risk sets</h2><span id='topic+createRemDataset'></span>

<h3>Description</h3>

<p>The function creates counting process data sets with dynamic risk sets for relational event models. For each event in the event sequence, null-events are generated and represent possible events that could have happened at that time but did not. A data set with true and null-events is returned with an event dummy for whether the event occurred or was simply possible (variable <code>eventdummy</code>). The returned data set also includes a variable <code>eventTime</code> which represents the true time of the reported event.</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRemDataset(data, sender, target, eventSequence, 
	eventAttribute = NULL, time = NULL, 
	start = NULL, startDate = NULL, 
	end = NULL, endDate = NULL, 
	timeformat = NULL,
	atEventTimesOnly = TRUE, untilEventOccurrs = TRUE,
	includeAllPossibleEvents = FALSE, possibleEvents = NULL, 
	returnInputData = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRemDataset_+3A_data">data</code></td>
<td>
<p> A data frame containing all the events.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_sender">sender</code></td>
<td>
<p>  A string (or factor or numeric) variable that represents the sender of the event.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_target">target</code></td>
<td>
<p>  A string (or factor or numeric) variable that represents the target of the event.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_eventsequence">eventSequence</code></td>
<td>
<p> Numeric variable that represents the event sequence. The variable has to be sorted in ascending order.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_eventattribute">eventAttribute</code></td>
<td>
<p> An optional variable that represents an attribute to an event. Repeated events affect the construction of the counting process data set. Use the <code>eventAttribute</code>-variable to specify the uniqueness of an event. If <code>eventAttribute = NULL</code>, events are defines as sender-target nodes only.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_time">time</code></td>
<td>
<p>  An optional date variable that represents the date an event took place. The variable is used if <code>startDate</code> or <code>endDate</code> are specified. <code>timeformat</code> should be used to specify which format the date variable is in, in case it was not yet converted to a Date-variable.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_start">start</code></td>
<td>
<p>  An optional numeric variable that indicates at which point in the event sequence a specific event was at risk. The variable has to be numerical and correspond to the variable <code>eventSequence</code>. If this option is used, each event in the event data set will be considered at risk from the specified value onwards. If it is not specified, <code>start</code> is defined as the first value in the event sequence. In case of repeated events, the start-value for each duplicated event is one event-unit after the last such event.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_startdate">startDate</code></td>
<td>
<p> An optional date variable that represents the date an event started being at risk. <code>timeformat</code> should be used to specify which format the date variable is in, incase it was not yet converted to a Date-variable.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_end">end</code></td>
<td>
<p> An optional numeric variable that indicates at which point in the event sequence a specific event stopped being at risk. The variable has to be numerical and correspond to the variable <code>eventSequence</code>. If this option is used, each event in the event data set will be considered at risk until the specified value.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_enddate">endDate</code></td>
<td>
<p> An optional date variable that represents the date an event stoped being at risk. <code>timeformat</code> should be used to specify which format the date variable is in, incase it was not yet converted to a Date-variable.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_timeformat">timeformat</code></td>
<td>
<p> A character string indicating the format of the <code>datevar</code>. see <code><a href="base.html#topic+as.Date">as.Date</a></code></p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_ateventtimesonly">atEventTimesOnly</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Boolean option for continuous event sequences. If <code>atEventTimesOnly = TRUE</code>, null-events are only created at times, when an event occurred. If <code>atEventTimesOnly = FALSE</code>, null-events are created on each event-unit from <code>min(eventSequence):max(eventSequence)</code>.
For instance: Given an event sequence with three events at <code>c(1, 4, 6)</code>: 
If <code>atEventTimesOnly = TRUE</code> null events are created for events 1, 4 and 6. If <code>atEventTimesOnly = FALSE</code> null-events are also created for days 2, 3 and 5. </p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_untileventoccurrs">untilEventOccurrs</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Boolean option to define whether null events should be an option even after an event takes place. If <code>untilEventOccurrs = TRUE</code> a conditional logisitc logic is applied in that events are only at risk as long as they have not taken place yet. If <code>untilEventOccurrs = FALSE</code> events continue to be at risk after they have occurred. Note that <code>untilEventOccurrs = TRUE</code> overwrites the <code>end</code>-Variable, if specified.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_includeallpossibleevents">includeAllPossibleEvents</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Boolean option to allow a more dynamic and specified creation of the risk set. If <code>includeAllPossibleEvents = TRUE</code>, a data set has to be provided to <code>possibleEvents</code>.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_possibleevents">possibleEvents</code></td>
<td>
<p> An optional data set with the form: column 1 = sender, column 2 = target, 3 = start, 4 = end, 5 = event attribute, 6... . The data set provides all possible events for the entire event sequence and gives each possible event a start and end value to determine when each event could have been possible. This is useful if the risk set follows a complex pattern that cannot be resolved with the above options. E.g., providing a <code>startDate</code>-variable and setting <code>atEventTimesOnly == FALSE</code> will result in an error since in a continuous time setting the start variable will be matched to the closest date, rather than to the exact value of said date in the event sequence. Manually coding the possible events is neccessary.</p>
</td></tr>
<tr><td><code id="createRemDataset_+3A_returninputdata">returnInputData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Boolean option to check the original data set (handed over in <code>data</code>) against the created start and stop variables. If <code>returnInputData = TRUE</code>, a list of two data sets is returned. The first data set is the counting process data set with null-events, the second the modified <code>data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To follow.
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: standard conditional logistic set-up
dt &lt;- data.frame(
  sender = c('a', 'c', 'd', 'a', 'a', 'f', 'c'), 
  target = c('b', 'd', 'd', 'b', 'b', 'a', 'd'), 
  eventSequence = c(1, 2, 2, 3, 3, 4, 6)
)
count.data &lt;- createRemDataset(
  data = dt, sender = dt$sender, 
  target = dt$target, eventSequence = dt$eventSequence, 
  eventAttribute = NULL, time = NULL, 
  start = NULL, startDate = NULL, 
  end = NULL, endDate = NULL, 
  timeformat = NULL,
  atEventTimesOnly = TRUE, untilEventOccurrs = TRUE,
  includeAllPossibleEvents = FALSE, possibleEvents = NULL, 
  returnInputData = FALSE)

## Example 2: add 2 attributes to the event-classification
dt &lt;- data.frame(
  sender = c('a', 'c', 'd', 'a', 'a', 'f', 'c'), 
  target = c('b', 'd', 'd', 'b', 'b', 'a', 'd'), 
  pro.con = c('pro', 'pro', 'con', 'pro', 'con', 'pro', 'pro'),
  attack = c('yes', 'no', 'no', 'yes', 'yes', 'no', 'yes'),
  eventSequence = c(1, 2, 2, 3, 3, 4, 6)
)
count.data &lt;- createRemDataset(
  data = dt, sender = dt$sender, 
  target = dt$target, eventSequence = dt$eventSequence, 
  eventAttribute = paste0(dt$pro.con, dt$attack), time = NULL, 
  start = NULL, startDate = NULL, 
  end = NULL, endDate = NULL, 
  timeformat = NULL,
  atEventTimesOnly = TRUE, untilEventOccurrs = TRUE,
  includeAllPossibleEvents = FALSE, possibleEvents = NULL, 
  returnInputData = FALSE)

## Example 3: adding start and end variables
# Note: the start and end variables will be overwritten 
# if there are duplicate events. If you want to 
# keep the strict start and stop values that you set, use
# includeAllPossibleEvents = TRUE and specify a 
# possibleEvents-data set.
# Note 2: if untilEventOccurrs = TRUE and an end
# variable is provided, this end variable is 
# overwritten. Set untilEventOccurrs 0 FALSE and 
# provide the end variable if you want the events 
# possibilities to stop at these exact event times.
dt &lt;- data.frame(
  sender = c('a', 'c', 'd', 'a', 'a', 'f', 'c'), 
  target = c('b', 'd', 'd', 'b', 'b', 'a', 'd'), 
  eventSequence = c(1, 2, 2, 3, 3, 4, 6),
  start = c(0, 0, 1, 1, 1, 3, 3), 
  end = rep(6, 7)
)
count.data &lt;- createRemDataset(
  data = dt, sender = dt$sender, 
  target = dt$target, eventSequence = dt$eventSequence, 
  eventAttribute = NULL, time = NULL, 
  start = dt$start, startDate = NULL, 
  end = dt$end, endDate = NULL, 
  timeformat = NULL,
  atEventTimesOnly = TRUE, untilEventOccurrs = TRUE,
  includeAllPossibleEvents = FALSE, possibleEvents = NULL, 
  returnInputData = FALSE)

## Example 4: using start (and stop) dates
dt &lt;- data.frame(
  sender = c('a', 'c', 'd', 'a', 'a', 'f', 'c'), 
  target = c('b', 'd', 'd', 'b', 'b', 'a', 'd'), 
  eventSequence = c(1, 2, 2, 3, 3, 4, 6),
  date = c('01.02.1971', rep('02.02.1971', 2), 
rep('03.02.1971', 2), '04.02.1971', '06.02.1971'),
  dateAtRisk = c(rep('21.01.1971', 2), rep('01.02.1971', 5)), 
  dateRiskEnds = rep('01.03.1971', 7)
)
count.data &lt;- createRemDataset(
  data = dt, sender = dt$sender, target = dt$target, 
  eventSequence = dt$eventSequence, 
  eventAttribute = NULL, time = dt$date, 
  start = NULL, startDate = dt$dateAtRisk, 
  end = NULL, endDate = NULL, 
  timeformat = '%d.%m.%Y',
  atEventTimesOnly = TRUE, untilEventOccurrs = TRUE,
  includeAllPossibleEvents = FALSE, possibleEvents = NULL, 
  returnInputData = FALSE)
# if you want to include null-events at times when no event happened, 
# either see Example 5 or create a start-variable by yourself 
# by using the eventSequence()-command with the option 
# 'returnDateSequenceData = TRUE' in this package. With the
# generated sequence, dates from startDate can be matched
# to the event sequence values (using the match()-command).

## Example 5: using start and stop dates and including 
# possible events whenever no event occurred. 
possible.events &lt;- data.frame(
  sender = c('a', 'c', 'd', 'f'), 
  target = c('b', 'd', 'd', 'a'), 
  start = c(0, 0, 1, 1), 
  end = c(rep(8, 4)))
count.data &lt;- createRemDataset(
  data = dt, sender = dt$sender, target = dt$target, 
  eventSequence = dt$eventSequence, 
  eventAttribute = NULL, time = NULL, 
  start = NULL, startDate = NULL, 
  end = NULL, endDate = NULL, 
  timeformat = NULL,
  atEventTimesOnly = TRUE, untilEventOccurrs = TRUE,
  includeAllPossibleEvents = TRUE, possibleEvents = possible.events, 
  returnInputData = FALSE)
# now you can set 'atEventTimesOnly = FALSE' to include 
# null-events where none occurred until the events happened
count.data &lt;- createRemDataset(
  data = dt, sender = dt$sender, target = dt$target, 
  eventSequence = dt$eventSequence, 
  eventAttribute = NULL, time = NULL, 
  start = NULL, startDate = NULL, 
  end = NULL, endDate = NULL, 
  timeformat = NULL,
  atEventTimesOnly = FALSE, untilEventOccurrs = TRUE,
  includeAllPossibleEvents = TRUE, possibleEvents = possible.events, 
  returnInputData = FALSE)
# plus you can set  to get the full range of the events 
# (bounded by max(possible.events$end))
count.data &lt;- createRemDataset(
  data = dt, sender = dt$sender, target = dt$target, 
  eventSequence = dt$eventSequence, 
  eventAttribute = NULL, time = NULL, 
  start = NULL, startDate = NULL, 
  end = NULL, endDate = NULL, 
  timeformat = NULL,
  atEventTimesOnly = FALSE, untilEventOccurrs = FALSE,
  includeAllPossibleEvents = TRUE, possibleEvents = possible.events, 
  returnInputData = FALSE)
</code></pre>

<hr>
<h2 id='degreeStat'>Calculate (in/out)-degree statistics</h2><span id='topic+degreeStat'></span><span id='topic+degree'></span><span id='topic+outdegree'></span><span id='topic+indegree'></span>

<h3>Description</h3>

<p>Calculate the endogenous network statistic <code>indegree/outdegree</code> for relational event models. <code>indegree/outdegree</code> measures the senders' tendency to be involved in events (sender activity, sender out- or indegree) or the tendency of events to surround a specific target (target popularity, target in- or outdegree)</p>


<h3>Usage</h3>

<pre><code class='language-R'>degreeStat(data, time, degreevar, halflife, 
    weight = NULL, 
    eventtypevar = NULL, 
    eventtypevalue = "valuematch", 
    eventfiltervar = NULL,
    eventfiltervalue = NULL, 
    eventvar = NULL,
    degreeOnOtherVar = NULL,
    variablename = "degree", 
    returnData = FALSE, 
    dataPastEvents = NULL,
    showprogressbar = FALSE, 
    inParallel = FALSE, cluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degreeStat_+3A_data">data</code></td>
<td>
<p> A data frame containing all the variables.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_time">time</code></td>
<td>
<p> Numeric variable that represents the event sequence. The variable has to be sorted in ascending order.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_degreevar">degreevar</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the sender or target of the event. The degree statistic will calculate how often in the past, a given sender or target has been active by counting the number of events in the past where the <code>degreevar</code> is repeated. See <code>details</code> for more information on which variable to chose as <code>degreevar</code> for one- and two-mode networks.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_halflife">halflife</code></td>
<td>
<p> A numeric value that is used in the decay function. The vector of past events is weighted by an exponential decay function using the specified halflife. The halflife parameter determines after how long a period the event weight should be halved. E.g. if <code>halflife = 5</code>, the weight of an event that occurred 5 units in the past is halved. Smaller halflife values give more importance to more recent events, while larger halflife values should be used if time does not affect the sequence of events that much.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_weight">weight</code></td>
<td>
<p> An optional numeric variable that represents the weight of each event. If <code>weight = NULL</code> each event is given an event weight of <code>1</code>.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_eventtypevar">eventtypevar</code></td>
<td>
<p> An optional variable that represents the type of the event. Use <code>eventtypevalue</code> to specify how the <code>eventtypevar</code> should be used to filter past events.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_eventtypevalue">eventtypevalue</code></td>
<td>
<p> An optional value (or set of values) used to specify how paste events should be filtered depending on their type. 
<code>eventtypevalue = "valuematch"</code> indicates that only past events that have the same type should be used to calculate the degree statistic.
<code>eventtypevalue = "valuemix"</code> indicates that past and present events of specific types should be used for the degree statistic. All the possible combinations of the eventtypevar-values will be used. E.g. if <code>eventtypevar</code> contains two unique values &quot;a&quot; and &quot;b&quot;, 4 degree statistics will be  calculated. The first variable calculates the degree effect where the present  event is of type &quot;a&quot; and all the past events are of type &quot;b&quot;. The next variable  calculates the degree statistic for present events of type &quot;b&quot; and past events of type &quot;a&quot;. Additionally, a variable is calculated, where present events as well as past  events are of type &quot;a&quot; and a fourth variable calculates the degree statistic for events with type &quot;b&quot; (i.e. valuematch on value &quot;b&quot;).
<code>eventtypevalue = c("..", "..")</code> is similar to the <code>"nodemix"</code>-option, all different combinations of the values specified in <code>eventtypevalue</code> are used to create the degree statistics.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_eventfiltervar">eventfiltervar</code></td>
<td>
<p> An optional numeric/character/or factor variable for each event. If <code>eventfiltervar</code> is specified, <code>eventfiltervalue</code> has to be provided as well.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_eventfiltervalue">eventfiltervalue</code></td>
<td>
<p> An optional character string that represents the value for which past events should be filtered. To filter the current events, use <code>eventtypevar</code>.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_eventvar">eventvar</code></td>
<td>
<p> An (optional) dummy variable with 0 values for null-events and 1 values for true events. If the <code>data</code> is in the form of counting process data, use the <code>eventvar</code>-option to specify which variable contains the 0/1-dummy for event occurrence. If this variable is not specified, all events in the past will be considered for the calulation of the degree statistic, regardless if they occurred or not (= are null-events).</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_degreeonothervar">degreeOnOtherVar</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the sender or target of the event. It can be used to calculate target-outdegree or sender-indegree statistics in one-mode networks. For the sender indegree statistic, fill the sender variable into the <code>degreevar</code> and the target variable into the <code>degree.on.other.var</code>. For the target-outdegree statistic, fill the target variable into the <code>degreevar</code> and the sender variable into the <code>degree.on.other.var</code>.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_variablename">variablename</code></td>
<td>
<p> An optional value (or values) with the name the degree statistic variable should be given. Default &quot;degree&quot; is used. To be used if <code>returnData = TRUE</code> or multiple degree statistics are calculated.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_returndata">returnData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Set to <code>FALSE</code> by default. The new variable(s) are bound directly to the <code>data.frame</code> provided and the data frame is returned in full.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_datapastevents">dataPastEvents</code></td>
<td>
<p> An optional <code>data.frame</code> with the following variables:
column 1 = time variable, 
column 2 = degree variable, 
column 3 = degree on other variable (or all &quot;1&quot;), 
column 4 = event dummy (or all 1), 
column 5 = weight variable (or all &quot;1&quot;), 
column 6 = event type variable (or all &quot;1&quot;), 
column 7 = event filter variable (or all &quot;1&quot;).</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_showprogressbar">showprogressbar</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Can only be set to TRUE if the function is not run in parallel.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_inparallel">inParallel</code></td>
<td>
 <p><code>TRUE/FALSE</code>. An optional boolean to specify if the loop should be run in parallel.</p>
</td></tr>
<tr><td><code id="degreeStat_+3A_cluster">cluster</code></td>
<td>
<p> An optional numeric or character value that defines the cluster. By specifying a single number, the cluster option uses the provided number of nodes to parallellize. By specifying a cluster using the <code>makeCluster</code>-command in the <code>doParallel</code>-package, the loop can be run on multiple nodes/cores. E.g., <code>cluster = makeCluster(12, type="FORK")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>degreeStat()</code>-function calculates an endogenous statistic that measures whether events have a tendency to include either the same sender or the same target over the entire event sequence. 
</p>
<p>The effect is calculated as follows.
</p>
<p style="text-align: center;"><code class="reqn">G_t = G_t(E) = (A, B, w_t), </code>
</p>

<p><code class="reqn">G_t</code> represents the network of past events and includes all events <code class="reqn">E</code>. These events consist
each of  a sender <code class="reqn">a \in A</code> and a target <code class="reqn">b \in B</code> (in one-mode networks <code class="reqn">A = B</code>) and a weight function <code class="reqn">w_t</code>:
</p>
<p style="text-align: center;"><code class="reqn">  w_t(i, j) = \sum_{e:a = i, b = j} | w_e | \cdot e^{-(t-t_e)\cdot\frac{ln(2)}{T_{1/2}}} \cdot \frac{ln(2)}{T_{1/2}}, </code>
</p>

<p>where <code class="reqn">w_e</code> is the event weight (usually a constant set to 1 for each event), <code class="reqn">t</code> is the current event time, <code class="reqn">t_e</code> is the past event time and <code class="reqn">T_{1/2}</code> is a halflife parameter.
</p>
<p>For the degree effect, the past events <code class="reqn">G_t</code> are filtered to include only events
where the senders or targets are identical to the current sender or target.
</p>
<p style="text-align: center;"><code class="reqn">sender-outdegree(G_t , a , b) = \sum_{j \in B}  w_t(a, j)</code>
</p>

<p style="text-align: center;"><code class="reqn">target-indegree(G_t , a , b) = \sum_{i \in A}  w_t(i, b)</code>
</p>

<p style="text-align: center;"><code class="reqn">sender-indegree(G_t , a , b) = \sum_{i \in A}  w_t(i, a)</code>
</p>

<p style="text-align: center;"><code class="reqn">target-outdegree(G_t , a , b) = \sum_{j \in B}  w_t(b, j)</code>
</p>

<p>Depending on whether the degree statistic is measured on the sender variable or the target variable, either activity or popularity effects are calculated. 
</p>
<p>For one-mode networks: Four distinct statistics can be calculated: sender-indegree, sender-outdegree, target-indegree or target-outdegree. The sender-indegree measures how often the current sender was targeted by other senders in the past (i.e. how popular were current senders). The sender-outedegree measures how often the current sender was involved in an event, where they were also marked as sender (i.e. how active the current sender has been in the past). The target-indegree statistic measures how often the current targets were targeted in the past (i.e. how popular were current targets). And the target-outdegree measures how often the current targets were senders in the past (i.e. how active were current targets in the past). 
</p>
<p>For two-mode networks: Two distinct statistics can be calculated: sender-outdegree and target-indegree. Sender-outdegree measures how often the current sender has been involved in an event in the past (i.e. how active the sender has been up until now). The target-indegree statistic measures how often the current target has been involved in an event in the past (i.e. how popular a given target has been before the current event).
</p>
<p>An exponential decay function is used to model the effect of time on the endogenous statistics. Each past event that contains the same sender or the same target (depending on the variable specified in <code>degreevar</code>) and fulfills additional filtering options (specified via event type or event attributes) is weighted with an exponential decay. The further apart the past event is from the present event, the less weight is given to this event. The halflife parameter in the <code>degreeStat()</code>-function determines at which rate the weights of past events should be reduced. 
</p>
<p>The <code>eventtypevar</code>- and <code>eventattributevar</code>-options help filter the past events more specifically. How they are filtered depends on the <code>eventtypevalue</code>- and <code>eventattributevalue</code>-option.
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data with 'sender', 'target' and a 'time'-variable
# (Note: Data used here are random events from the Correlates of War Project)
sender &lt;- c('TUN', 'NIR', 'NIR', 'TUR', 'TUR', 'USA', 'URU', 
            'IRQ', 'MOR', 'BEL', 'EEC', 'USA', 'IRN', 'IRN', 
            'USA', 'AFG', 'ETH', 'USA', 'SAU', 'IRN', 'IRN',
            'ROM', 'USA', 'USA', 'PAN', 'USA', 'USA', 'YEM', 
            'SYR', 'AFG', 'NAT', 'NAT', 'USA')
target &lt;- c('BNG', 'ZAM', 'JAM', 'SAU', 'MOM', 'CHN', 'IRQ', 
            'AFG', 'AFG', 'EEC', 'BEL', 'ITA', 'RUS', 'UNK',
            'IRN', 'RUS', 'AFG', 'ISR', 'ARB', 'USA', 'USA',
            'USA', 'AFG', 'IRN', 'IRN', 'IRN', 'AFG', 'PAL',
            'ARB', 'USA', 'EEC', 'BEL', 'PAK')
time &lt;- c('800107', '800107', '800107', '800109', '800109', 
          '800109', '800111', '800111', '800111', '800113',
          '800113', '800113', '800114', '800114', '800114', 
          '800116', '800116', '800116', '800119', '800119',
          '800119', '800122', '800122', '800122', '800124', 
          '800125', '800125', '800127', '800127', '800127', 
          '800204', '800204', '800204')
type &lt;- sample(c('cooperation', 'conflict'), 33,
               replace = TRUE)

# combine them into a data.frame
dt &lt;- data.frame(sender, target, time, type)

# create event sequence and order the data
dt &lt;- eventSequence(datevar = dt$time, dateformat = "%y%m%d", 
                    data = dt, type = "continuous", 
                    byTime = "daily", returnData = TRUE,
                    sortData = TRUE)

# create counting process data set (with null-events) - conditional logit setting
dts &lt;- createRemDataset(dt, dt$sender, dt$target, dt$event.seq.cont, 
                          eventAttribute = dt$type, 
                          atEventTimesOnly = TRUE, untilEventOccurrs = TRUE, 
						  returnInputData = TRUE)
## divide up the results: counting process data = 1, original data = 2
dtrem &lt;- dts[[1]]
dt &lt;- dts[[2]]
## merge all necessary event attribute variables back in
dtrem$type &lt;- dt$type[match(dtrem$eventID, dt$eventID)]
dtrem$important &lt;- dt$important[match(dtrem$eventID, dt$eventID)]
# manually sort the data set
dtrem &lt;- dtrem[order(dtrem$eventTime), ]

# calculate sender-outdegree statistic
dtrem$sender.outdegree &lt;- degreeStat(data = dtrem,
                                  time = dtrem$eventTime, 
                                  degreevar = dtrem$sender, 
                                  halflife = 2, 
                                  eventvar = dtrem$eventDummy,
                                  returnData = FALSE)

# plot sender-outdegree over time
library("ggplot2")
ggplot(dtrem, aes(eventTime, sender.outdegree, 
                  group = factor(eventDummy), color = factor(eventDummy) ) ) +
  geom_point()+ geom_smooth() 

# calculate sender-indegree statistic
dtrem$sender.indegree &lt;- degreeStat(data = dtrem,
                                    time = dtrem$eventTime, 
                                    degreevar = dtrem$sender, 
                                    halflife = 2, 
                                    eventvar = dtrem$eventDummy,
                                    degreeOnOtherVar = dtrem$target,
                                    returnData = FALSE)

# calculate target-indegree statistic
dtrem$target.indegree &lt;- degreeStat(data = dtrem,
                                     time = dtrem$eventTime, 
                                     degreevar = dtrem$target, 
                                     halflife = 2, 
                                     eventvar = dtrem$eventDummy,
                                     returnData = FALSE)

# calculate target-outdegree statistic
dtrem$target.outdegree &lt;- degreeStat(data = dtrem,
                                    time = dtrem$eventTime, 
                                    degreevar = dtrem$target, 
                                    halflife = 2, 
                                    eventvar = dtrem$eventDummy,
                                    degreeOnOtherVar = dtrem$sender,
                                    returnData = FALSE)

# calculate target-indegree with typematch
dtrem$target.indegree.tm &lt;- degreeStat(data = dtrem,
                                    time = dtrem$eventTime, 
                                    degreevar = dtrem$target, 
                                    halflife = 2, 
                                    eventtypevar = dtrem$type, 
                                    eventtypevalue = "valuematch",
                                    eventvar = dtrem$eventDummy,
                                    returnData = FALSE)
</code></pre>

<hr>
<h2 id='eventSequence'>Create event sequence</h2><span id='topic+eventSequence'></span><span id='topic+event.sequence'></span><span id='topic+event+20sequence'></span>

<h3>Description</h3>

<p> Create the event sequence for relational event models. Continuous or ordinal sequences can be created. Various dates may be excluded from the sequence (e.g. special holidays, specific weekdays or longer time spans).</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventSequence(datevar, 
    dateformat = NULL, data = NULL, 
    type = "continuous", byTime = "daily",
    excludeDate = NULL, excludeTypeOfDay = NULL, 
    excludeYear = NULL, excludeFrom = NULL, 
    excludeTo = NULL, returnData = FALSE, 
    sortData = FALSE, 
    returnDateSequenceData = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventSequence_+3A_datevar">datevar</code></td>
<td>
<p> The variable containing the information on the date and/or time of the event.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_dateformat">dateformat</code></td>
<td>
<p> A character string indicating the format of the <code>datevar</code>. see <code><a href="base.html#topic+as.Date">as.Date</a></code></p>
</td></tr>
<tr><td><code id="eventSequence_+3A_data">data</code></td>
<td>
<p> An optional data frame containing all the variables.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_type">type</code></td>
<td>
<p> &quot;'<code>continuous</code>&quot;' or &quot;'<code>ordinal</code>&quot;'. Specifies whether the event sequence is to be created as a continuous sequence or an ordinal sequence.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_bytime">byTime</code></td>
<td>
<p> String value. Specifies at what interval the event sequence is created. Use &quot;daily&quot;, &quot;monthly&quot; or &quot;yearly&quot;.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_excludedate">excludeDate</code></td>
<td>
<p> An optional string or string vector containing one or more dates that should be excluded from the event.sequence. The dates have to be in the same format as provided in <code>dateformat</code>. Only valid for continuous event sequences.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_excludetypeofday">excludeTypeOfDay</code></td>
<td>
<p> String value or vector naming the day(s) that should be excluded from the event sequence. Depending on the locale the weekdays may be named differently. Use <code>Sys.getlocale("LC_TIME")</code> to find which locale is installed.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_excludeyear">excludeYear</code></td>
<td>
<p> A string value or vector naming the year(s) that should be excluded from the event sequence.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_excludefrom">excludeFrom</code></td>
<td>
<p> A string value (or a vector of strings) with the start value of the date from (from-value included) which the event sequence should not be affected. The value has to be in the same format as specified in <code>dateformat</code>.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_excludeto">excludeTo</code></td>
<td>
<p> A string value (or a vector of strings) with the end value of the date to which time the event sequence should not be affected (to-value included). The value has to be in the same format as specified in <code>dateformat</code>.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_returndata">returnData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Default set to <code>FALSE</code>. The data frame provided is returned in full, together with the new variable for the event sequence. </p>
</td></tr>
<tr><td><code id="eventSequence_+3A_sortdata">sortData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Default set to <code>FALSE</code>. Should only be used if <code>returnData = TRUE</code>. The entire data.frame will be ordered according to the event sequence.</p>
</td></tr>
<tr><td><code id="eventSequence_+3A_returndatesequencedata">returnDateSequenceData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Boolean option to return
the full information on which date matches to which sequence number instead
of the event sequence (and corresponding data frame).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to estimate relational event models, the events have to be ordered, either according to an ordinal or a continuous event sequence. The ordinal event sequence simply orders the events and gives each event a place in the sequence. 
The continuous event sequence creates an artificial sequence ranging from <code>min(datevar)</code> to <code>max(datevar)</code> and matches each event with its place in the artificial event sequence. Dates, years or Weekdays can be excluded from the artificial event sequence. This is useful for excluding specific holidays, weekends etc..
</p>
<p>Where two or more events occur at the same time, they are given the same value in the event sequence. 
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data with 'sender', 'target' and a 'time'-variable
# (Note: Data used here are random events from the Correlates of War Project)
sender &lt;- c('TUN', 'NIR', 'NIR', 'TUR', 'TUR', 'USA', 'URU', 
            'IRQ', 'MOR', 'BEL', 'EEC', 'USA', 'IRN', 'IRN', 
            'USA', 'AFG', 'ETH', 'USA', 'SAU', 'IRN', 'IRN',
            'ROM', 'USA', 'USA', 'PAN', 'USA', 'USA', 'YEM', 
            'SYR', 'AFG', 'NAT', 'NAT', 'USA')
target &lt;- c('BNG', 'ZAM', 'JAM', 'SAU', 'MOM', 'CHN', 'IRQ', 
            'AFG', 'AFG', 'EEC', 'BEL', 'ITA', 'RUS', 'UNK',
            'IRN', 'RUS', 'AFG', 'ISR', 'ARB', 'USA', 'USA',
            'USA', 'AFG', 'IRN', 'IRN', 'IRN', 'AFG', 'PAL',
            'ARB', 'USA', 'EEC', 'BEL', 'PAK')
time &lt;- c('800107', '800107', '800107', '800109', '800109', 
          '800109', '800111', '800111', '800111', '800113',
          '800113', '800113', '800114', '800114', '800114', 
          '800116', '800116', '800116', '800119', '800119',
          '800119', '800122', '800122', '800122', '800124', 
          '800125', '800125', '800127', '800127', '800127', 
          '800204', '800204', '800204')

# combine them into a data.frame
dt &lt;- data.frame(sender, target, time)

# create continuous event sequence: return the data with the 
# event sequence and sort the data according to the event sequence.
dt &lt;- eventSequence(datevar = dt$time, dateformat = '%y%m%d', 
                    data = dt, type = 'continuous', 
                    byTime = 'daily', returnData = TRUE,
                    sortData = TRUE)

# alternative : create variable with the continuous event 
# sequence, unsorted
dt$eventSeq &lt;- eventSequence(datevar = dt$time, 
                             dateformat = '%y%m%d', 
                             data = dt, type = 'continuous',
                             byTime = 'daily', 
                             returnData = FALSE, 
                             sortData = FALSE)
# manually sort the data set
dt &lt;- dt[order(dt$eventSeq), ]

# create the sequence by month
dt$eventSeqMonthly &lt;- eventSequence(datevar = dt$time, 
                                    dateformat = '%y%m%d', 
                                    data = dt, 
                                    type = 'continuous', 
                                    byTime = 'monthly', 
                                    returnData = FALSE, 
                                    sortData = FALSE)

# create the sequence by year
dt$eventSeqYearly &lt;- eventSequence(datevar = dt$time, 
                                   dateformat = '%y%m%d', 
                                   data = dt, 
                                   type = 'continuous', 
                                   byTime = 'yearly', 
                                   returnData = FALSE, 
                                   sortData = FALSE)

# create an ordinal event sequence
dt$eventSeqOrdinal &lt;- eventSequence(datevar = dt$time, 
                                    dateformat = '%y%m%d', 
                                    data = dt, 
                                    type = 'ordinal', 
                                    byTime = 'daily', 
                                    returnData = FALSE, 
                                    sortData = FALSE)

# exclude certain dates
dt$eventSeqEx &lt;- eventSequence(datevar = dt$time,
                               dateformat = '%y%m%d', 
                               data = dt, type = 'continuous',
                               byTime = 'daily', 
                               excludeDate = c('800108', '800112'),
                               returnData = FALSE, 
                               sortData = FALSE)

# return the sequence data set, where all values in the event sequence
# correspond to the date of the events. Useful to calculate
# start-variables for the createRemDataset-command.
seq.data &lt;- eventSequence(datevar = dt$time,
                          dateformat = "%y%m%d", 
                          data = dt, type = "continuous",
                          byTime = "daily", 
                          excludeDate = c("800108", "800112"),
                          returnData = FALSE, 
                          sortData = FALSE, 
                          returnDateSequenceData = TRUE)
</code></pre>

<hr>
<h2 id='fourCycleStat'>Calculate four cycle statistics</h2><span id='topic+fourCycleStat'></span><span id='topic+fourCycle'></span>

<h3>Description</h3>

<p>Calculate the endogenous network statistic <code>fourCycle</code> that 
measures the tendency for events to close four cycles in two-mode event sequences.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourCycleStat(data, time, sender, target, halflife, 
    weight = NULL, 
    eventtypevar = NULL, 
    eventtypevalue = 'standard', 
    eventfiltervar = NULL, 
    eventfilterAB = NULL, eventfilterAJ = NULL, 
    eventfilterIB = NULL, eventfilterIJ = NULL,
    eventvar = NULL,
    variablename = 'fourCycle',
    returnData = FALSE,
    dataPastEvents = NULL,
    showprogressbar = FALSE, 
    inParallel = FALSE, cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourCycleStat_+3A_data">data</code></td>
<td>
<p> A data frame containing all the variables.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_time">time</code></td>
<td>
<p> Numeric variable that represents the event sequence. The variable
has to be sorted in ascending order.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_sender">sender</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the sender of the event.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_target">target</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the target of the event.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_halflife">halflife</code></td>
<td>
<p> A numeric value that is used in the decay function.
The vector of past events is weighted by an exponential decay function using the specified halflife. The halflife parameter determins after how long a period the event weight should be halved. E.g. if <code>halflife = 5</code>, the weight of an event that occured 5 units in the past is halved. Smaller halflife values give more importance to more recent events, while larger halflife values should be  used if time does not affect the sequence of events that much.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_weight">weight</code></td>
<td>
<p> An optional numeric variable that represents the weight of each event. If <code>weight = NULL</code> each event is given an event weight of <code>1</code>.
</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_eventtypevar">eventtypevar</code></td>
<td>
<p> An optional variable that represents the type of the event. Use <code>eventtypevalue</code> to specify how the <code>eventtypevar</code> should be used to filter past events.
</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_eventtypevalue">eventtypevalue</code></td>
<td>
<p> An optional value (or set of values) used to specify how paste events should be filtered depending on their type. <code>'standard'</code>, <code>'positive'</code> or <code>'negative'</code> may be used. Default set to <code>'standard'</code>. <code>'standard'</code> referrs to closing four cylces where the type of the events is irrelevant. <code>'positive'</code> closing four cycles can be classified as reciprocity via the second mode. It indicates whether senders have a tendency to reciprocate or show support by engaging in targets that close a four cycle between two senders. <code>'negative'</code> closing four cycles represent opposition between two senders, where the current event is more likely if the two senders have opposed each other in the past. Support or opposition is represented by the <code>eventtypevar</code> value for each event.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_eventfiltervar">eventfiltervar</code></td>
<td>
<p> An optinoal variable that allows filtering of past events using an event attribute. It can be a sender attribute, a target attribute, time or dyad attribute.
Use <code>eventfilterAB</code>, <code>eventfilterAJ</code>, <code>eventfilterIB</code> or <code>eventfilterIJ</code> to specify how the <code>eventfiltervar</code> should be used.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_eventfilterab">eventfilterAB</code></td>
<td>
<p> An optional value used to specify how 
paste events should be filtered depending on their attribute. Each distinct edge that form a four cycle can be filtered. <code>eventfilterAB</code> refers to the current event. <code>eventfilterAJ</code> refers to the event involving the current sender and target <code>j</code> that has been used by the current as well as the second actor in the past. <code>eventfilterIB</code> refers to the event involving the second sender and the current target. <code>eventfilterIJ</code> filters events that involve the second sender and the second target. See the four cycle formula in the <code>details</code> section for more information.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_eventfilteraj">eventfilterAJ</code></td>
<td>
<p> see <code>eventfilterAB</code>.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_eventfilterib">eventfilterIB</code></td>
<td>
<p>see <code>eventfilterAB</code>.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_eventfilterij">eventfilterIJ</code></td>
<td>
<p>see <code>eventfilterAB</code>.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_eventvar">eventvar</code></td>
<td>
<p> An optional dummy variable with 0 values for null-events and 1 values for true events. If the <code>data</code> is in the form of counting process data, use the <code>eventvar</code>-option to specify which variable contains the 0/1-dummy for event occurrence. If this variable is not specified, all events in the past will be considered for the calulation of the four cycle statistic, regardless if they occurred or not (= are null-events). Misspecification could result in grievous errors in the calculation of the network statistic.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_variablename">variablename</code></td>
<td>
<p> An optional value (or values) with the name the four cycle statistic variable should be given. To be used if <code>returnData = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_returndata">returnData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Set to <code>FALSE</code> by default. The new  variable(s) are bound directly to the <code>data.frame</code> provided and the data frame is returned in full.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_datapastevents">dataPastEvents</code></td>
<td>
<p> An optional <code>data.frame</code> with the following variables:
column 1 = time variable, 
column 2 = sender variable, 
column 3 = target on other variable (or all &quot;1&quot;), 
column 4 = weight variable (or all &quot;1&quot;), 
column 5 = event type variable (or all &quot;1&quot;), 
column 6 = event filter variable (or all &quot;1&quot;). Make sure that the data frame does not contain null events. Filter it out for true events only.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_showprogressbar">showprogressbar</code></td>
<td>
<p><code>TRUE/FALSE</code>. To be implemented.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_inparallel">inParallel</code></td>
<td>
 <p><code>TRUE/FALSE</code>. An optional boolean to specify if the loop should be run in parallel.</p>
</td></tr>
<tr><td><code id="fourCycleStat_+3A_cluster">cluster</code></td>
<td>
<p> An optional numeric or character value that defines the cluster. By specifying a single number, the cluster option uses the provided number of nodes to parallellize. By specifying a cluster using the <code>makeCluster</code>-command in the <code>doParallel</code>-package, the loop can be run on multiple nodes/cores. E.g., <code>cluster = makeCluster(12, type="FORK")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fourCycleStat()</code>-function calculates an endogenous statistic that measures whether events have a tendency to form four cycles.
</p>
<p>The effect is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">G_t = G_t(E) = (A, B, w_t), </code>
</p>

<p><code class="reqn">G_t</code> represents the network of past events and includes all events <code class="reqn">E</code>. These events consist
each of  a sender <code class="reqn">a \in A</code> and a target <code class="reqn">b \in B</code> and a weight function <code class="reqn">w_t</code>:
</p>
<p style="text-align: center;"><code class="reqn">  w_t(i, j) = \sum_{e:a = i, b = j} | w_e | \cdot e^{-(t-t_e)\cdot\frac{ln(2)}{T_{1/2}}} \cdot \frac{ln(2)}{T_{1/2}}, </code>
</p>

<p>where <code class="reqn">w_e</code> is the event weight (usually a constant set to 1 for each event), <code class="reqn">t</code> is the current event time, <code class="reqn">t_e</code> is the past event time and <code class="reqn">T_{1/2}</code> is a halflife parameter.
</p>
<p>For the four-cylce effect, the past events <code class="reqn">G_t</code> are filtered to include only events
where the current event closes an open four-cycle in the past.
</p>
<p style="text-align: center;"><code class="reqn">fourCycle(G_t , a , b) = \sqrt[3]{\sum_{i \in A \&amp; j \in B} w_t(a, j) \cdot w_t(i, b) \cdot w_t(i, j)}</code>
</p>

<p>An exponential decay function is used to model the effect of time on the endogenous statistics. The further apart the past event is from the present event, the less weight is given to this event. The halflife parameter in the <code>fourCycleStat()</code>-function determins at which rate the weights of past events should be reduced. Therefore, if the one (or more) of the three events in the four cycle have ocurred further in the past, less weight is given to this four cycle because it becomes less likely that the two senders reacted to each other in the way the four cycle assumes.
</p>
<p>The <code>eventtypevar</code>- and <code>eventfiltervar</code>-options help filter the past events more specifically. How they are filtered depends on the <code>eventtypevalue</code>- and <code>eventfilter__</code>-option.
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data two-mode network event sequence data with
# a 'sender', 'target' and a 'time'-variable
sender &lt;- c('A', 'B', 'A', 'C', 'A', 'D', 'F', 'G', 'A', 'B',
            'B', 'C', 'D', 'E', 'F', 'B', 'C', 'D', 'E', 'C', 
            'A', 'F', 'E', 'B', 'C', 'E', 'D', 'G', 'A', 'G', 
            'F', 'B', 'C')
target &lt;- c('T1', 'T2', 'T3', 'T2', 'T1', 'T4', 'T6', 'T2', 
            'T4', 'T5', 'T5', 'T5', 'T1', 'T6', 'T7', 'T2', 
            'T3', 'T1', 'T1', 'T4', 'T5', 'T6', 'T8', 'T2',
            'T7', 'T1', 'T6', 'T7', 'T3', 'T4', 'T7', 'T8', 'T2')
time &lt;- c('03.01.15', '04.01.15', '10.02.15', '28.02.15', '01.03.15', 
          '07.03.15', '07.03.15', '12.03.15', '04.04.15', '28.04.15',
          '06.05.15', '11.05.15', '13.05.15', '17.05.15', '22.05.15', 
          '09.08.15', '09.08.15', '14.08.15', '16.08.15', '29.08.15',
          '05.09.15', '25.09.15', '02.10.15', '03.10.15', '11.10.15', 
          '18.10.15', '20.10.15', '28.10.15', '04.11.15', '09.11.15', 
          '10.12.15', '11.12.15', '12.12.15')
type &lt;- sample(c('con', 'pro'), 33, replace = TRUE)
important &lt;- sample(c('important', 'not important'), 33,
                    replace = TRUE)

# combine them into a data.frame
dt &lt;- data.frame(sender, target, time, type, important)

# create event sequence and order the data
dt &lt;- eventSequence(datevar = dt$time, dateformat = '%d.%m.%y', 
                    data = dt, type = 'continuous', 
                    byTime = "daily", returnData = TRUE,
                    sortData = TRUE)

# create counting process data set (with null-events) - conditional logit setting
dts &lt;- createRemDataset(dt, dt$sender, dt$target, dt$event.seq.cont, 
                          eventAttribute = dt$type, 
                          atEventTimesOnly = TRUE, untilEventOccurrs = TRUE, 
						  returnInputData = TRUE)
## divide up the results: counting process data = 1, original data = 2
dtrem &lt;- dts[[1]]
dt &lt;- dts[[2]]
## merge all necessary event attribute variables back in
dtrem$type &lt;- dt$type[match(dtrem$eventID, dt$eventID)]
dtrem$important &lt;- dt$important[match(dtrem$eventID, dt$eventID)]
# manually sort the data set
dtrem &lt;- dtrem[order(dtrem$eventTime), ]

# calculate closing four-cycle statistic
dtrem$fourCycle &lt;- fourCycleStat(data = dtrem, 
                              time = dtrem$eventTime, 
                              sender = dtrem$sender, 
                              target = dtrem$target, 
                              eventvar = dtrem$eventDummy,
                              halflife = 20)

# plot closing four-cycles over time:
library("ggplot2")
ggplot(dtrem, aes (eventTime, fourCycle,
                group = factor(eventDummy), color = factor(eventDummy)) ) +
  geom_point()+ geom_smooth() 

# calculate positive closing four-cycles: general support
dtrem$fourCycle.pos &lt;- fourCycleStat(data = dtrem, 
                                 time = dtrem$eventTime, 
                                 sender = dtrem$sender, 
                                 target = dtrem$target, 
                                 eventvar = dtrem$eventDummy,
                                 eventtypevar = dtrem$type, 
                                 eventtypevalue = 'positive',
                                 halflife = 20)

# calculate negative closing four-cycles: general opposition
dtrem$fourCycle.neg &lt;- fourCycleStat(data = dtrem, 
                                     time = dtrem$eventTime, 
                                     sender = dtrem$sender, 
                                     target = dtrem$target, 
                                     eventvar = dtrem$eventDummy,
                                     eventtypevar = dtrem$type, 
                                     eventtypevalue = 'negative',
                                     halflife = 20)
</code></pre>

<hr>
<h2 id='inertiaStat'>Calculate inertia statistics</h2><span id='topic+inertiaStat'></span><span id='topic+inertia'></span>

<h3>Description</h3>

<p>Calculate the endogenous network statistic <code>inertia</code> for relational event models. <code>inertia</code> measures the tendency for events to consist of the same sender and target (i.e. repeated events).</p>


<h3>Usage</h3>

<pre><code class='language-R'>inertiaStat(data, time, sender, target, halflife,
    weight = NULL, 
    eventtypevar = NULL,
    eventtypevalue = "valuematch", 
    eventfiltervar = NULL,
    eventfiltervalue = NULL, 
    eventvar = NULL,
    variablename = "inertia", 
    returnData = FALSE,
    showprogressbar = FALSE, 
    inParallel = FALSE, cluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inertiaStat_+3A_data">data</code></td>
<td>
<p> A data frame containing all the variables.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_time">time</code></td>
<td>
<p> Numeric variable that represents the event sequence. The variable has to be sorted in ascending order.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_sender">sender</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the sender of the event.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_target">target</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the target of the event.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_halflife">halflife</code></td>
<td>
<p> A numeric value that is used in the decay function. The vector of past events is weighted by an exponential decay function using the specified halflife. The halflife parameter determins after how long a period the event weight should be halved. E.g. if <code>halflife = 5</code>, the weight of an event that occured 5 units in the past is halved. Smaller halflife values give more importance to more recent events, while larger halflife values should be  used if time does not affect the sequence of events that much.</p>
</td></tr> 
<tr><td><code id="inertiaStat_+3A_weight">weight</code></td>
<td>
<p> An optional numeric variable that represents the weight of each event. If <code>weight = NULL</code> each event is given an event weight of <code>1</code>.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_eventtypevar">eventtypevar</code></td>
<td>
<p> An optional variable that represents the type of the event. Use <code>eventtypevalue</code> to specify how the <code>eventtypevar</code> should be used to filter past events.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_eventtypevalue">eventtypevalue</code></td>
<td>
<p> An optional value (or set of values) used to specify how  paste events should be filtered depending on their type. 
<code>eventtypevalue = "valuematch"</code> indicates that only past events that have the same type as the current event should be used to calculate the inertia statistic.
<code>eventtypevalue = "valuemix"</code> indicates that past and present events of specific types should be used for the inertia statistic. All the possible combinations of the eventtypevar-values will be used. E.g. if <code>eventtypevar</code> contains two unique values &quot;a&quot; and &quot;b&quot;, 4 inertia statistics will be  calculated. The first variable calculates the inertia effect where the present  event is of type &quot;a&quot; and all the past events are of type &quot;b&quot;. The next variable  calculates inertia for present events of type &quot;b&quot; and past events of type &quot;a&quot;. Additionally, a variable is calculated, where present events as well as past events are of type &quot;a&quot; and a fourth variable calculates inertia for events with type &quot;b&quot; (i.e. valuematch on value &quot;b&quot;).
<code>eventtypevalue = c(.., ..)</code> is similar to the <code>"nodmix"</code>-option, all different combinations of the values specified in <code>eventtypevalue</code> are used to create inertia statistics.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_eventfiltervar">eventfiltervar</code></td>
<td>
<p> An optional numeric/character/or factor variable for each event. If <code>eventfiltervar</code> is specified, <code>eventfiltervalue</code> has to be provided as well.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_eventfiltervalue">eventfiltervalue</code></td>
<td>
<p> An optional character string that represents the value for which past events should be filtered. To filter the current events, use <code>eventtypevar</code>.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_eventvar">eventvar</code></td>
<td>
<p> An optional dummy variable with 0 values for null-events and 1 values for true events. If the <code>data</code> is in the form of counting process data, use the <code>eventvar</code>-option to specify which variable contains the 0/1-dummy for event occurrence. If this variable is not specified, all events in the past will be considered for the calulation of the inertia statistic, regardless if they occurred or not (= are null-events).</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_variablename">variablename</code></td>
<td>
<p> An optional value (or values) with the name the inertia statistic variable should be given. To be used if <code>returnData = TRUE</code> or multiple inertia statistics are calculated.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_returndata">returnData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Set to <code>FALSE</code> by default. The new variable(s) are bound directly to the <code>data.frame</code> provided and the data frame is returned in full.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_showprogressbar">showprogressbar</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Can only be set to TRUE if the function is not run in parallel.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_inparallel">inParallel</code></td>
<td>
 <p><code>TRUE/FALSE</code>. An optional boolean to specify if the loop should be run in parallel.</p>
</td></tr>
<tr><td><code id="inertiaStat_+3A_cluster">cluster</code></td>
<td>
<p> An optional numeric or character value that defines the cluster. By specifying a single number, the cluster option uses the provided number of nodes to parallellize. By specifying a cluster using the <code>makeCluster</code>-command in the <code>doParallel</code>-package, the loop can be run on multiple nodes/cores. E.g., <code>cluster = makeCluster(12, type="FORK")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>inertiaStat()</code>-function calculates an endogenous statistic that  measures whether events have a tendency to be repeated with the same sender and target over the entire event sequence.
</p>
<p>The effect is calculated as follows.
</p>
<p style="text-align: center;"><code class="reqn">G_t = G_t(E) = (A, B, w_t), </code>
</p>

<p><code class="reqn">G_t</code> represents the network of past events and includes all events <code class="reqn">E</code>. These events consist
each of  a sender <code class="reqn">a \in A</code> and a target <code class="reqn">b \in B</code> and a weight function <code class="reqn">w_t</code>:
</p>
<p style="text-align: center;"><code class="reqn">  w_t(i, j) = \sum_{e:a = i, b = j} | w_e | \cdot e^{-(t-t_e)\cdot\frac{ln(2)}{T_{1/2}}} \cdot \frac{ln(2)}{T_{1/2}}, </code>
</p>

<p>where <code class="reqn">w_e</code> is the event weight (usually a constant set to 1 for each event), <code class="reqn">t</code> is the current event time, <code class="reqn">t_e</code> is the past event time and <code class="reqn">T_{1/2}</code> is a halflife parameter.
</p>
<p>For the inertia effect, the past events <code class="reqn">G_t</code> are filtered to include only events
where the senders and targets are identical to the current sender and target.
</p>
<p style="text-align: center;"><code class="reqn">inertia(G_t , a , b) = w_t(a, b)</code>
</p>

<p>An exponential decay function is used to model the effect of time on the endogenous statistics. Each past event that contains the same sender and target and fulfills additional filtering options specivied via event type or event attributes is weighted with an exponential decay. The further apart the past event is from the present event, the less weight is given to this event. The halflife parameter in the <code>inertiaStat()</code>-function determins at which rate the weights of past events should be reduced. 
</p>
<p>The <code>eventfiltervar</code>- and <code>eventtypevar</code>-options help filter the past events more specifically. How they are filtered depends on the <code>eventfiltervalue</code>- and <code>eventtypevalue</code>-option.
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data with 'sender', 'target' and a 'time'-variable
# (Note: Data used here are random events from the Correlates of War Project)
sender &lt;- c('TUN', 'NIR', 'NIR', 'TUR', 'TUR', 'USA', 'URU', 
            'IRQ', 'MOR', 'BEL', 'EEC', 'USA', 'IRN', 'IRN', 
            'USA', 'AFG', 'ETH', 'USA', 'SAU', 'IRN', 'IRN',
            'ROM', 'USA', 'USA', 'PAN', 'USA', 'USA', 'YEM', 
            'SYR', 'AFG', 'NAT', 'NAT', 'USA')
target &lt;- c('BNG', 'ZAM', 'JAM', 'SAU', 'MOM', 'CHN', 'IRQ', 
            'AFG', 'AFG', 'EEC', 'BEL', 'ITA', 'RUS', 'UNK',
            'IRN', 'RUS', 'AFG', 'ISR', 'ARB', 'USA', 'USA',
            'USA', 'AFG', 'IRN', 'IRN', 'IRN', 'AFG', 'PAL',
            'ARB', 'USA', 'EEC', 'BEL', 'PAK')
time &lt;- c('800107', '800107', '800107', '800109', '800109', 
          '800109', '800111', '800111', '800111', '800113',
          '800113', '800113', '800114', '800114', '800114', 
          '800116', '800116', '800116', '800119', '800119',
          '800119', '800122', '800122', '800122', '800124', 
          '800125', '800125', '800127', '800127', '800127', 
          '800204', '800204', '800204')
type &lt;- sample(c('cooperation', 'conflict'), 33,
               replace = TRUE)

# combine them into a data.frame
dt &lt;- data.frame(sender, target, time, type)

# create event sequence and order the data
dt &lt;- eventSequence(datevar = dt$time, dateformat = "%y%m%d", 
                    data = dt, type = "continuous", 
                    byTime = "daily", returnData = TRUE,
                    sortData = TRUE)

# create counting process data set (with null-events) - conditional logit setting
dts &lt;- createRemDataset(dt, dt$sender, dt$target, 
	dt$event.seq.cont, eventAttribute = dt$type,
	atEventTimesOnly = TRUE, untilEventOccurrs = TRUE, 
	returnInputData = TRUE)
## divide up the results: counting process data = 1, original data = 2
dtrem &lt;- dts[[1]]
dt &lt;- dts[[2]]
## merge all necessary event attribute variables back in
dtrem$type &lt;- dt$type[match(dtrem$eventID, dt$eventID)]
# manually sort the data set
dtrem &lt;- dtrem[order(dtrem$eventTime), ]
	
# manually sort the data set
dtrem &lt;- dtrem[order(dtrem$eventTime), ]

# calculate inertia statistics
dtrem$inertia &lt;- inertiaStat(data = dtrem, time = dtrem$eventTime, 
                          sender = dtrem$sender, target = dtrem$target,
                          eventvar = dtrem$eventDummy,
                          halflife = 2, returnData = FALSE, 
                          showprogressbar = FALSE)

# plot inertia over time
library("ggplot2")
ggplot(dtrem, aes ( eventTime, inertia, 
	group = factor(eventDummy), color = factor(eventDummy)) ) +
	geom_point() + geom_smooth() 

# inertia with typematch (e.g. for 'cooperation' events only count
# past 'cooperation' events) 
dtrem$inertia.tm &lt;- inertiaStat(data = dtrem, time = dtrem$eventTime, 
                             sender = dtrem$sender, target = dtrem$target,
                             eventvar = dtrem$eventDummy,
                             halflife = 2, 
                             eventtypevar = dtrem$type, 
                             eventtypevalue = "valuematch",
                             returnData = FALSE, 
                             showprogressbar = FALSE)

# inertia with valuemix: for each combination of types
# in the eventtypevar, create a variable
dtrem &lt;- inertiaStat(data = dtrem, time = dtrem$eventTime, 
              sender = dtrem$sender, target = dtrem$target,
              eventvar = dtrem$eventDummy,
              halflife = 2, 
              eventtypevar = dtrem$type, 
              eventtypevalue = "valuemix",
              returnData = TRUE, 
              showprogressbar = FALSE)
</code></pre>

<hr>
<h2 id='reciprocityStat'>Calculate reciprocity statistics</h2><span id='topic+reciprocityStat'></span><span id='topic+reciprocity'></span>

<h3>Description</h3>

<p>Calculate the endogenous network statistic <code>reciprocity</code> for relational event models. <code>reciprocity</code> measures the tendency for senders to reciprocate prior events where they were targeted by other senders. One-mode network statistic only.</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocityStat(data, time, sender, target, halflife, 
    weight = NULL, 
    eventtypevar = NULL,
    eventtypevalue = "valuematch", 
    eventfiltervar = NULL,
    eventfiltervalue = NULL, 
    eventvar = NULL,
    variablename = "recip", 
    returnData = FALSE,
    showprogressbar = FALSE, 
    inParallel = FALSE, cluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocityStat_+3A_data">data</code></td>
<td>
<p> A data frame containing all the variables.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_time">time</code></td>
<td>
<p> Numeric variable that represents the event sequence. The variable has to be sorted in ascending order.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_sender">sender</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the sender of the event.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_target">target</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the target of the event.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_halflife">halflife</code></td>
<td>
<p> A numeric value that is used in the decay function.
The vector of past events is weighted by an exponential decay function using the specified halflife. The halflife parameter determines after how long a period the event weight should be halved. E.g. if <code>halflife = 5</code>, the weight of an event that occurred 5 units in the past is halved. Smaller halflife values give more importance to more recent events, while larger halflife values should be  used if time does not affect the time between events that much.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_weight">weight</code></td>
<td>
<p> An optional numeric variable that represents the weight of each event. If <code>weight = NULL</code> each event is given an event weight of <code>1</code>.
</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_eventtypevar">eventtypevar</code></td>
<td>
<p> An optional variable that represents the type of the event. Use <code>eventtypevalue</code> to specify how the <code>eventtypevar</code> should be used  to filter past events.
</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_eventtypevalue">eventtypevalue</code></td>
<td>
<p> An optional value (or set of values) used to specify how 
paste events should be filtered depending on their type. 
<code>eventtypevalue = "valuematch"</code> indicates that only past events that have the same type as the current event should be used to calculate the reciprocity statistic.
<code>eventtypevalue = "valuemix"</code> indicates that past and present events of  specific types should be used for the reciprocity statistic. All the possible combinations of the eventtypevar-values will be used. E.g. if <code>eventtypevar</code> contains three unique values &quot;a&quot; and &quot;b&quot;, 4 reciprocity statistics will be 
calculated. The first variable calculates the reciprocity effect where the present  event is of type &quot;a&quot; and all the past events are of type &quot;b&quot;. The next variable calculates reciprocity for present events of type &quot;b&quot; and past events of type &quot;a&quot;. Additionally, a variable is calculated, where present events as well as past  events are of type &quot;a&quot; and a fourth variable calculates reciprocity for events with type &quot;b&quot; (i.e. valuematch on value &quot;b&quot;).
<code>eventtypevalue = c(.., ..)</code>, similar to the &quot;<code>nodmix</code>&quot;-option, all different combinations of the values specified in <code>eventtypevalue</code> are used to create reciprocity statistics.
</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_eventfiltervar">eventfiltervar</code></td>
<td>
<p> An optional numeric/character/or factor variable for each event. If <code>eventfiltervar</code> is specified, <code>eventfiltervalue</code> has to be provided as well.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_eventfiltervalue">eventfiltervalue</code></td>
<td>
<p> An optional character string that represents the value for which past events should be filtered. To filter the current events, use <code>eventtypevar</code>.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_eventvar">eventvar</code></td>
<td>
<p> An optional dummy variable with 0 values for null-events and 1 values for true events. If the <code>data</code> is in the form of counting process data, use the <code>eventvar</code>-option to specify which variable contains the 0/1-dummy for event occurrence. If this variable is not specified, all events in the past will be considered for the calulation of the reciprocity statistic, regardless if they occurred or not (= are null-events).</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_variablename">variablename</code></td>
<td>
<p> An optional value (or values) with the name the reciprocity
statistic variable should be given. To be used if <code>returnData = TRUE</code> or
multiple reciprocity statistics are calculated.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_returndata">returnData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Set to <code>FALSE</code> by default. The new 
variable(s) are bound directly to the <code>data.frame</code> provided and the
data frame is returned in full.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_showprogressbar">showprogressbar</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Can only be set to TRUE if the function is not run in parallel.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_inparallel">inParallel</code></td>
<td>
 <p><code>TRUE/FALSE</code>. An optional boolean to specify if the loop should be run in parallel.</p>
</td></tr>
<tr><td><code id="reciprocityStat_+3A_cluster">cluster</code></td>
<td>
<p> An optional numeric or character value that defines the cluster. By specifying a single number, the cluster option uses the provided number of nodes to parallellize. By specifying a cluster using the <code>makeCluster</code>-command in the <code>doParallel</code>-package, the loop can be run on multiple nodes/cores. E.g., <code>cluster = makeCluster(12, type="FORK")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>reciprocityStat()</code>-function calculates an endogenous statistic that measures whether senders have a tendency to reciprocate events.
</p>
<p>The effect is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">G_t = G_t(E) = (A, B, w_t), </code>
</p>

<p><code class="reqn">G_t</code> represents the network of past events and includes all events <code class="reqn">E</code>. These events consist each of  a sender <code class="reqn">a \in A</code> and a target <code class="reqn">b \in B</code> and a weight function <code class="reqn">w_t</code>:
</p>
<p style="text-align: center;"><code class="reqn">  w_t(i, j) = \sum_{e:a = i, b = j} | w_e | \cdot e^{-(t-t_e)\cdot\frac{ln(2)}{T_{1/2}}} \cdot \frac{ln(2)}{T_{1/2}}, </code>
</p>

<p>where <code class="reqn">w_e</code> is the event weight (usually a constant set to 1 for each event), <code class="reqn">t</code> is the current event time, <code class="reqn">t_e</code> is the past event time and <code class="reqn">T_{1/2}</code> is a halflife parameter.
</p>
<p>For the reciprocity effect, the past events <code class="reqn">G_t</code> are filtered to include only events where the senders are the present targets and the targets are the present senders:
</p>
<p style="text-align: center;"><code class="reqn">reciprocity(G_t , a , b) = w_t(b, a)</code>
</p>

<p>An exponential decay function is used to model the effect of time on the endogenous statistics. Each past event that involves the sender as target and the target as sender, and fulfills additional filtering options specified via event type or event attributes, is weighted with an exponential decay. The further apart the past event is from the present event, the less weight is given to this event. The halflife parameter in the <code>reciprocityStat()</code>-function determines at which rate the weights of past events should be reduced. 
</p>
<p>The <code>eventtypevar</code>- and <code>eventattributevar</code>-options help filter the past events more specifically. How they are filtered depends on the <code>eventtypevalue</code>- and <code>eventattributevalue</code>-option.
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data with 'sender', 'target' and a 'time'-variable
# (Note: Data used here are random events from the Correlates of War Project)
sender &lt;- c('TUN', 'NIR', 'NIR', 'TUR', 'TUR', 'USA', 'URU', 
            'IRQ', 'MOR', 'BEL', 'EEC', 'USA', 'IRN', 'IRN', 
            'USA', 'AFG', 'ETH', 'USA', 'SAU', 'IRN', 'IRN',
            'ROM', 'USA', 'USA', 'PAN', 'USA', 'USA', 'YEM', 
            'SYR', 'AFG', 'NAT', 'NAT', 'USA')
target &lt;- c('BNG', 'ZAM', 'JAM', 'SAU', 'MOM', 'CHN', 'IRQ', 
            'AFG', 'AFG', 'EEC', 'BEL', 'ITA', 'RUS', 'UNK',
            'IRN', 'RUS', 'AFG', 'ISR', 'ARB', 'USA', 'USA',
            'USA', 'AFG', 'IRN', 'IRN', 'IRN', 'AFG', 'PAL',
            'ARB', 'USA', 'EEC', 'BEL', 'PAK')
time &lt;- c('800107', '800107', '800107', '800109', '800109', 
          '800109', '800111', '800111', '800111', '800113',
          '800113', '800113', '800114', '800114', '800114', 
          '800116', '800116', '800116', '800119', '800119',
          '800119', '800122', '800122', '800122', '800124', 
          '800125', '800125', '800127', '800127', '800127', 
          '800204', '800204', '800204')
type &lt;- sample(c('cooperation', 'conflict'), 33,
               replace = TRUE)
important &lt;- sample(c('important', 'not important'), 33,
                    replace = TRUE)

# combine them into a data.frame
dt &lt;- data.frame(sender, target, time, type, important)

# create event sequence and order the data
dt &lt;- eventSequence(datevar = dt$time, dateformat = "%y%m%d", 
                    data = dt, type = "continuous", 
                    byTime = "daily", returnData = TRUE,
                    sortData = TRUE)

# create counting process data set (with null-events) - conditional logit setting
dts &lt;- createRemDataset(dt, dt$sender, dt$target, dt$event.seq.cont, 
                          eventAttribute = dt$type, 
                          atEventTimesOnly = TRUE, untilEventOccurrs = TRUE, 
						  returnInputData = TRUE)
## divide up the results: counting process data = 1, original data = 2
dtrem &lt;- dts[[1]]
dt &lt;- dts[[2]]
## merge all necessary event attribute variables back in
dtrem$type &lt;- dt$type[match(dtrem$eventID, dt$eventID)]
dtrem$important &lt;- dt$important[match(dtrem$eventID, dt$eventID)]
# manually sort the data set
dtrem &lt;- dtrem[order(dtrem$eventTime), ]

# calculate reciprocity statistic
dtrem$recip &lt;- reciprocityStat(data = dtrem,
                            time = dtrem$eventTime, 
                            sender = dtrem$sender, 
                            target = dtrem$target,
                            eventvar = dtrem$eventDummy,
                            halflife = 2)

# plot sender-outdegree over time
library("ggplot2")
ggplot(dtrem, aes(eventTime, recip, 
               group = factor(eventDummy), color = factor(eventDummy)) ) +
  geom_point()+ geom_smooth() 

# calculate reciprocity statistic with typematch
# if a cooperated with b in the past, does
# b cooperate with a now?
dtrem$recip.typematch &lt;- reciprocityStat(data = dtrem,
                               time = dtrem$eventTime, 
                               sender = dtrem$sender, 
                               target = dtrem$target,
                               eventvar = dtrem$eventDummy,
                               eventtypevar = dtrem$type,
                               eventtypevalue = 'valuematch',
                               halflife = 2)

# calculate reciprocity with valuemix on type
dtrem &lt;- reciprocityStat(data = dtrem,
                         time = dtrem$eventTime, 
                         sender = dtrem$sender, 
                         target = dtrem$target,
                         eventvar = dtrem$eventDummy,
                         eventtypevar = dtrem$type,
                         eventtypevalue = 'valuemix',
                         halflife = 2, 
                         returnData = TRUE)

# calculate reciprocity and count important events only
dtrem$recip.filtered &lt;- reciprocityStat(data = dtrem,
                               time = dtrem$eventTime, 
                               sender = dtrem$sender, 
                               target = dtrem$target,
                               eventvar = dtrem$eventDummy,
                               eventfiltervar = dtrem$important, 
                               eventfiltervalue = 'important',
                               halflife = 2)
</code></pre>

<hr>
<h2 id='similarityStat'>Calculate similarity statistics</h2><span id='topic+similarityStat'></span><span id='topic+similarity'></span>

<h3>Description</h3>

<p>Calculate the endogenous network statistic <code>similarity</code> for relational event models. <code>similarityStat</code> measures the tendency for senders to adapt their behavior to that of their peers.</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarityStat(data, time, sender, target, 
    senderOrTarget = 'sender', 
    whichSimilarity = NULL, 
    halflifeLastEvent = NULL, 
    halflifeTimeBetweenEvents = NULL, 
    eventtypevar = NULL, 
    eventfiltervar = NULL, 
    eventfiltervalue = NULL, 
    eventvar = NULL,
    variablename = 'similarity',
    returnData = FALSE, 
    dataPastEvents = NULL,
    showprogressbar = FALSE, 
    inParallel = FALSE, cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarityStat_+3A_data">data</code></td>
<td>
<p> A data frame containing all the variables.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_time">time</code></td>
<td>
<p> Numeric variable that represents the event sequence. The variable has to be sorted in ascending order.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_sender">sender</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the sender of the event.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_target">target</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the target of the event.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_senderortarget">senderOrTarget</code></td>
<td>
 <p><code>sender</code> or <code>target</code>. Indicates on which variable (sender or target) the similarity should be calculated on. Sender similarity measures how many targets the current sender has in common with other senders who used the same targets in the past. Target similarity measures how many senders have used the current target as well as another target that the current sender used in the past.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_whichsimilarity">whichSimilarity</code></td>
<td>
 <p><code>"total"</code> or <code>"average"</code>. Indicates how the variable should be aggregated. <code>"total"</code> counts the number of similar events there are in the past event history.  <code>"average"</code> divides the count of similar events by the number of senders or the number of  targets, depending on which mode of similarity is chosen.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_halflifelastevent">halflifeLastEvent</code></td>
<td>
<p> A numeric value that is used in the decay function. The vector of past events is weighted by an exponential decay function using the specified halflife. The halflife parameter determines after how long a period the event weight should be halved. For sender similarity: The halflife determines the weight of the count of targets that two actors have in common. The further back the second sender was active, the less weight is given the similarity between this sender and the current sender. For target similarity: The halflife determines the weight of the count of targets that have used both been used by other senders in the past. The longer ago the current sender engaged in an event with the  other target, the less weight is given the count.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_halflifetimebetweenevents">halflifeTimeBetweenEvents</code></td>
<td>
<p> A numeric value that is used in the decay function. Instead of counting each past event for the similarity statistic, each event is reduced depending on the time that passed between the current event and the past event. For sender similarity: Each target that two actors have in common is weighted by the time that passed between the two events. For target similarity: Each sender that two targets have in common is weighted by the time that passed between the two events. </p>
</td></tr>
<tr><td><code id="similarityStat_+3A_eventtypevar">eventtypevar</code></td>
<td>
<p> An optional dummy variable that represents the type of the event. If specified, only past events are considered for the count that reflect the same type as the current event (typematch).</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_eventfiltervar">eventfiltervar</code></td>
<td>
<p> An optional variable that filters past events by the <code>eventfiltervalue</code> specified. </p>
</td></tr>
<tr><td><code id="similarityStat_+3A_eventfiltervalue">eventfiltervalue</code></td>
<td>
<p> A string that represents an event attribute by which all past events have to be filtered by.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_eventvar">eventvar</code></td>
<td>
<p> An optional dummy variable with 0 values for null-events and 1 values for true events. If the <code>data</code> is in the form of counting process data, use the <code>eventvar</code>-option to specify which variable contains the 0/1-dummy for event occurrence. If this variable is not specified, all events in the past will be considered for the calulation of the similarity statistic, regardless if they occurred or not (= are null-events). Misspecification could result in grievous errors in the calculation of the network statistic.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_variablename">variablename</code></td>
<td>
<p> An optional value (or values) with the name the similarity statistic variable should be given. To be used if <code>returnData = TRUE</code>.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_returndata">returnData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Set to <code>FALSE</code> by default. The new  variable(s) are bound directly to the <code>data.frame</code> provided and the data frame is returned in full.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_datapastevents">dataPastEvents</code></td>
<td>
<p> An optional <code>data.frame</code> with the following variables:
column 1 = time variable, 
column 2 = sender variable, 
column 3 = target on other variable (or all &quot;1&quot;), 
column 4 = event type variable (or all &quot;1&quot;), 
column 5 = event filter variable (or all &quot;1&quot;). Make sure that the data frame does not contain null events. Filter it out for true events only.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_showprogressbar">showprogressbar</code></td>
<td>
<p><code>TRUE/FALSE</code>. To be implemented.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_inparallel">inParallel</code></td>
<td>
 <p><code>TRUE/FALSE</code>. An optional boolean to specify if the loop should be run in parallel.</p>
</td></tr>
<tr><td><code id="similarityStat_+3A_cluster">cluster</code></td>
<td>
<p> An optional numeric or character value that defines the cluster. By specifying a single number, the cluster option uses the provided number of nodes to parallellize. By specifying a cluster using the <code>makeCluster</code>-command in the <code>doParallel</code>-package, the loop can be run on multiple nodes/cores. E.g., <code>cluster = makeCluster(12, type="FORK")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>similiarityStat()</code>-function calculates an endogenous statistic that measures whether sender (or targets) have a tendency to cluster together. Tow distinct types of similarity measures can be calculated: sender similarity or target similarity. 
</p>
<p>Sender similarity: How many targets does the current sender have in common with senders who used the current target in the past? How likely is it that two senders are alike?
</p>
<p>The function proceeds as follows: 
</p>

<ol>
<li><p> First it filters out all the targets that the present sender <code class="reqn">a</code> used in the past 
</p>
</li>
<li><p> Next it filters out all the senders that have also used the current target <code class="reqn">b</code>
</p>
</li>
<li><p> For each of the senders found in (2) it compiles a list of targets that this sender has used in the past
</p>
</li>
<li><p> For each of the senders found in (2) it cross-checks the two lists generated in (1) and (3) and count how many targets the two senders have in common. 
</p>
</li></ol>

<p>Target similarity: How many senders have used the same two concepts that the current sender has used (in the past and is currently using)? For each target that the current sender has used in the past, how many senders have also used these past targets as well as the current target? How likely is it that two targets are used together?
</p>
<p>The function proceeds as follows: 
</p>

<ol>
<li><p> First filter out all the targets that the current sender <code class="reqn">a</code> has used in the past
</p>
</li>
<li><p> Next it filters out all the senders that have also used the current target <code class="reqn">b</code>
</p>
</li>
<li><p> For each target found in (1) it compiles a list of senders that have also used this target in the past
</p>
</li>
<li><p> For each target found in (1) it cross-checks the list of senders that have used <code class="reqn">b</code> (found under (2)) and the list of senders that also used one other target that <code class="reqn">a</code> used (found under (3))
</p>
</li></ol>

<p>Two decay functions may be used in the calculation of the similarity score for each event. 
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data with 'sender', 'target' and a 'time'-variable
# (Note: Data used here are random events from the Correlates of War Project)
sender &lt;- c('TUN', 'NIR', 'NIR', 'TUR', 'TUR', 'USA', 'URU', 
            'IRQ', 'MOR', 'BEL', 'EEC', 'USA', 'IRN', 'IRN', 
            'USA', 'AFG', 'ETH', 'USA', 'SAU', 'IRN', 'IRN',
            'ROM', 'USA', 'USA', 'PAN', 'USA', 'USA', 'YEM', 
            'SYR', 'AFG', 'NAT', 'NAT', 'USA')
target &lt;- c('BNG', 'ZAM', 'JAM', 'SAU', 'MOM', 'CHN', 'IRQ', 
            'AFG', 'AFG', 'EEC', 'BEL', 'ITA', 'RUS', 'UNK',
            'IRN', 'RUS', 'AFG', 'ISR', 'ARB', 'USA', 'USA',
            'USA', 'AFG', 'IRN', 'IRN', 'IRN', 'AFG', 'PAL',
            'ARB', 'USA', 'EEC', 'BEL', 'PAK')
time &lt;- c('800107', '800107', '800107', '800109', '800109', 
          '800109', '800111', '800111', '800111', '800113',
          '800113', '800113', '800114', '800114', '800114', 
          '800116', '800116', '800116', '800119', '800119',
          '800119', '800122', '800122', '800122', '800124', 
          '800125', '800125', '800127', '800127', '800127', 
          '800204', '800204', '800204')
type &lt;- sample(c('cooperation', 'conflict'), 33,
               replace = TRUE)
important &lt;- sample(c('important', 'not important'), 33,
                    replace = TRUE)

# combine them into a data.frame
dt &lt;- data.frame(sender, target, time, type, important)

# create event sequence and order the data
dt &lt;- eventSequence(datevar = dt$time, dateformat = "%y%m%d", 
                    data = dt, type = "continuous", 
                    byTime = "daily", returnData = TRUE,
                    sortData = TRUE)

# create counting process data set (with null-events) - conditional logit setting
dts &lt;- createRemDataset(dt, dt$sender, dt$target, dt$event.seq.cont, 
                          eventAttribute = dt$type, 
                          atEventTimesOnly = TRUE, untilEventOccurrs = TRUE, 
						  returnInputData = TRUE)
## divide up the results: counting process data = 1, original data = 2
dtrem &lt;- dts[[1]]
dt &lt;- dts[[2]]
## merge all necessary event attribute variables back in
dtrem$type &lt;- dt$type[match(dtrem$eventID, dt$eventID)]
dtrem$important &lt;- dt$important[match(dtrem$eventID, dt$eventID)]
# manually sort the data set
dtrem &lt;- dtrem[order(dtrem$eventTime), ]

# average sender similarity
dtrem$s.sim.av &lt;- similarityStat(data = dtrem, 
                              time = dtrem$eventTime,
                              sender = dtrem$sender, 
                              target = dtrem$target, 
                              eventvar = dtrem$eventDummy,
                              senderOrTarget = "sender", 
                              whichSimilarity = "average")

# average target similarity
dtrem$t.sim.av &lt;- similarityStat(data = dtrem, 
                                 time = dtrem$eventTime,
                                 sender = dtrem$sender, 
                                 target = dtrem$target, 
                                 eventvar = dtrem$eventDummy,
                                 senderOrTarget = "target", 
                                 whichSimilarity = "average")

# Calculate sender similarity with 1 halflife 
# parameter: This parameter makes sure, that those other  
# senders (with whom you compare your targets) have been 
# active in the past. THe longer they've done nothing, the 
# less weight is given to the number of similar targets.
dtrem$s.sim.hl2 &lt;- similarityStat(data = dtrem, 
                                 time = dtrem$eventTime,
                                 sender = dtrem$sender, 
                                 target = dtrem$target, 
                                 eventvar = dtrem$eventDummy,
                                 senderOrTarget = "sender", 
                                 halflifeLastEvent = 2)

# Calculate sender similarity with 2 halflife parameters: 
# The first parameter makes sure that the actors against
# whom you compare yourself have been active in the 
# recent past. The second halflife parameter makes
# sure that the two events containing the same 
# targets (once by the current actor, once by the other 
# actor) are not that far apart. The longer apart, the 
# less likely it is that the current sender will remember
# how the similar-past sender has acted.
dtrem$s.sim.hl2.hl1 &lt;- similarityStat(data = dtrem, 
                                  time = dtrem$eventTime,
                                  sender = dtrem$sender, 
                                  target = dtrem$target, 
                                  eventvar = dtrem$eventDummy,
                                  senderOrTarget = "sender", 
                                  halflifeLastEvent = 2, 
                                  halflifeTimeBetweenEvents = 1)
</code></pre>

<hr>
<h2 id='timeToEvent'>Calculate the time-to-next-event or the time-since-date for a REM data set.</h2><span id='topic+timeToEvent'></span>

<h3>Description</h3>

<p>Calculate time-to-next-event or time-since-date for a REM data set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeToEvent(time, type = 'time-to-next-event', timeEventPossible = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeToEvent_+3A_time">time</code></td>
<td>
<p> A integer or Date variable reflecting the time of the event. Note: make sure to specify event time not the event sequence in a counting process data set.</p>
</td></tr>
<tr><td><code id="timeToEvent_+3A_type">type</code></td>
<td>
<p> Either 'time-to-next-event' or 'time-since-date'. 
<code>type = 'time-to-next-event'</code> calculates the time between the current event and the event closes to the current in the past. 
<code>type = 'time-since-date'</code> uses the <code>time</code>-variable as well as the <code>timeEventPossible</code>-variable to calculate how much time has passed between the two variables, i.e., how long the event took to come true. </p>
</td></tr>
<tr><td><code id="timeToEvent_+3A_timeeventpossible">timeEventPossible</code></td>
<td>
<p> An optional integer or Date variable to be used if <code>type = 'time-since-date'</code> is specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To come.
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get some random data
dt &lt;- data.frame(
  sender = c('a', 'c', 'd', 'a', 'a', 'f', 'c'), 
  target = c('b', 'd', 'd', 'b', 'b', 'a', 'd'), 
  date = c(rep('10.01.90',2), '11.01.90', '04.01.90',
 '05.01.90', rep('10.01.90',2)),
  start = c(0, 0, 1, 1, 1, 3, 3), 
  end = rep(6, 7), 
  targetAvailableSince = c(rep(-10,6), -2),
  dateTargetAvailable = c(rep('31.12.89',6), '01.01.90')
)

## create event sequence
dt &lt;- eventSequence(dt$date, dateformat = '%d.%m.%y', data = dt,
              type = "continuous", byTime = "daily",
              excludeDate = '07.01.90',
              returnData = TRUE, sortData = TRUE,
              returnDateSequenceData = FALSE)
## also return the sequenceData
dt.seq &lt;- eventSequence(dt$date, dateformat = '%d.%m.%y', data = dt,
                    type = "continuous", byTime = "daily",
                    excludeDate = '07.01.90',
                    returnDateSequenceData = TRUE)

## create counting process data set
dts &lt;- createRemDataset(
	data = dt, sender = dt$sender, target = dt$target, 
	eventSequence = dt$event.seq.cont, 
	eventAttribute = NULL, time = NULL, 
	start = dt$start, startDate = NULL, 
	end = dt$end, endDate = NULL, 
	timeformat = NULL, atEventTimesOnly = TRUE, 
	untilEventOccurrs = TRUE,
	includeAllPossibleEvents = FALSE, 
	possibleEvents = NULL, returnInputData = TRUE)	
## divide up the results: counting process data = 1, original data = 2
dt.rem &lt;- dts[[1]]
dt &lt;- dts[[2]]

## merge all necessary event attribute variables back in
dt.rem$targetAvailableSince &lt;- dt$targetAvailableSince[match(dt.rem$eventID, 
	dt$eventID)]
dt.rem$dateTargetAvailable &lt;- dt$dateTargetAvailable[match(dt.rem$eventID, 
	dt$eventID)]

## add dates to the eventTime
dt.rem$eventDate &lt;- dt.seq$date.sequence[match(dt.rem$eventTime,
	dt.seq$event.sequence)]

## sort the dataframe according to eventTime
dt.rem &lt;- dt.rem[order(dt.rem$eventTime), ]

## 1. numeric, time-to-next-event
dt.rem$timeToNextEvent &lt;- timeToEvent(as.integer(dt.rem$eventTime))

## 2. numeric, time-since
dt.rem$timeSince &lt;- timeToEvent(dt.rem$eventTime, 
                                type = 'time-since-date', 
                                dt.rem$targetAvailableSince)

## 3. Date, time-to-next-event
# since the event sequence excluded 06.01.90 =&gt; time to next event differs
# for the two specification with the integr (1) and the Date-variable (2).
# To be consistent, pick the eventTime instead of the Date-variable.
dt.rem$timeToNextEvent2 &lt;- timeToEvent(as.Date(dt.rem$eventDate, '%d.%m.%y'))


## 4. Date, time-since
dt.rem$timeSince2 &lt;- timeToEvent(
	as.Date(dt.rem$eventDate, '%d.%m.%y'),
	type = 'time-since-date', 
	as.Date(dt.rem$dateTargetAvailable, '%d.%m.%y'))

</code></pre>

<hr>
<h2 id='triadStat'>Calculate triad statistics</h2><span id='topic+triadStat'></span><span id='topic+triad'></span>

<h3>Description</h3>

<p>Calculate the endogenous network statistic <code>triads</code> that measures the tendency for events to close open triads.</p>


<h3>Usage</h3>

<pre><code class='language-R'>triadStat(data, time, sender, target, halflife, 
    weight = NULL, 
    eventtypevar = NULL, 
    eventtypevalues = NULL, 
    eventfiltervar = NULL,
    eventfilterAI = NULL, 
    eventfilterBI = NULL,
    eventfilterAB = NULL, 
    eventvar = NULL,
    variablename = 'triad', 
    returnData = FALSE, 
    showprogressbar = FALSE, 
    inParallel = FALSE, cluster = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triadStat_+3A_data">data</code></td>
<td>
<p> A data frame containing all the variables.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_time">time</code></td>
<td>
<p> Numeric variable that represents the event sequence. The variable has to be sorted in ascending order.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_sender">sender</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the sender of the event.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_target">target</code></td>
<td>
<p> A string (or factor or numeric) variable that represents the target of the event.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_halflife">halflife</code></td>
<td>
<p> A numeric value that is used in the decay function. The vector of past events is weighted by an exponential decay function using the specified halflife. The halflife parameter determins after how long a period the event weight should be halved. E.g. if <code>halflife = 5</code>, the weight of an event that occured 5 units in the past is halved. Smaller halflife values give more importance to more recent events, while larger halflife values should be used if time does not affect the sequence of events that much.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_weight">weight</code></td>
<td>
<p> An optional numeric variable that represents the weight of each event. If <code>weight = NULL</code> each event is given an event weight of <code>1</code>.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_eventtypevar">eventtypevar</code></td>
<td>
<p> An optional dummy variable that represents the type of the event. Use <code>eventtypevalues</code> to specify how the <code>eventtypevar</code> should be used to filter past events. Specifying the <code>eventtypevar</code> is needed to calculate effects of social balance theory, such as 'friend-of-friend' or 'enemy-of-enemy' statistics.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_eventtypevalues">eventtypevalues</code></td>
<td>
<p> Two string values that represent the type of the past events. The first string value represents the eventtype that exists for all past events that include the current sender (either as sender or target) and a third actor. The second value represents the eventtype for all past events that include the target (either as sender or target) as well as the third actor.
An example: Let the <code>eventtypevar</code> indicate whether an event is of cooperative or hostile nature.
To test whether the hypothesis 'the friend of my friend is my friend' holds, both <code>eventtypevalues</code> must be the same and point to the cooperative type (e.g. <code>eventtypevalues = c("cooperation", "cooperation")</code>) depending on
how the <code>eventtypevar</code> is coded.
To test whether the hypothesis 'the friend of my enemy is my enemy' holds, 
the first value in <code>eventtypevalues</code> represents the hostile event between current sender and a third actor and the second value represents the cooperative event between the third actor and the target.
To test the hypothesis 'the enemy of my enemy is my friend', the first value represents the hostile events between current sender and a third actor and the second value represents the hostile event between the current target and the third actor.
For the fourth hypothesis, to test social balance theory 'the enemy of my friend is my enemy', the first value represents a cooperative event between the current sender and a third actor and the second value represents a hostile event between the current target and the third actor.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_eventfiltervar">eventfiltervar</code></td>
<td>
<p> An optional string (or factor or numeric) variable that can be used to filter past and current events. Use <code>eventfilterAI</code>, <code>eventfilterBI</code> or <code>eventfilterAB</code> to specify which past events should be filtered and by what value.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_eventfilterai">eventfilterAI</code></td>
<td>
<p> An optional value used to specify how paste events should be filtered depending on their attribute. Each distinct edge that form a triad can be filtered. <code>eventfilterAI</code> refers to the past event involving the current sender (a) and a third actor (i). <code>eventfilterBI</code>referrs to past events involving target (b) and the third actor (i). <code>eventfilterAB</code> refers to the current event involving sender (a) and target (b).</p>
</td></tr>
<tr><td><code id="triadStat_+3A_eventfilterbi">eventfilterBI</code></td>
<td>
<p> see <code>eventfilterAI</code>.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_eventfilterab">eventfilterAB</code></td>
<td>
<p> see <code>eventfilterAI</code>.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_eventvar">eventvar</code></td>
<td>
<p> An optional dummy variable with 0 values for null-events and 1 values for true events. If the <code>data</code> is in the form of counting process data, use the <code>eventvar</code>-option to specify which variable contains the 0/1-dummy for event occurrence. If this variable is not specified, all events in the past will be considered for the calulation of the triad statistic, regardless if they occurred or not (= are null-events).</p>
</td></tr>
<tr><td><code id="triadStat_+3A_variablename">variablename</code></td>
<td>
<p> An optional value (or values) with the name the triad
statistic variable should be given. To be used if <code>returnData = TRUE</code>.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_returndata">returnData</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Set to <code>FALSE</code> by default. The new 
variable is bound directly to the <code>data.frame</code> provided and the
data frame is returned in full.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_showprogressbar">showprogressbar</code></td>
<td>
 <p><code>TRUE/FALSE</code>. Can only be set to TRUE if the function is not run in parallel.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_inparallel">inParallel</code></td>
<td>
 <p><code>TRUE/FALSE</code>. An optional boolean to specify if the loop should be run in parallel.</p>
</td></tr>
<tr><td><code id="triadStat_+3A_cluster">cluster</code></td>
<td>
<p> An optional numeric or character value that defines the cluster. By specifying a single number, the cluster option uses the provided number of nodes to parallellize. By specifying a cluster using the <code>makeCluster</code>-command in the <code>doParallel</code>-package, the loop can be run on multiple nodes/cores. E.g., <code>cluster = makeCluster(12, type="FORK")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>triadStat()</code>-function calculates an endogenous statistic that measures whether events have a tendency to form closing triads.
</p>
<p>The effect is calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">G_t = G_t(E) = (A, B, w_t), </code>
</p>

<p><code class="reqn">G_t</code> represents the network of past events and includes all events <code class="reqn">E</code>. These events consist
each of  a sender <code class="reqn">a \in A</code> and a target <code class="reqn">b \in B</code> and a weight function <code class="reqn">w_t</code>:
</p>
<p style="text-align: center;"><code class="reqn">  w_t(i, j) = \sum_{e:a = i, b = j} | w_e | \cdot e^{-(t-t_e)\cdot\frac{ln(2)}{T_{1/2}}} \cdot \frac{ln(2)}{T_{1/2}}, </code>
</p>

<p>where <code class="reqn">w_e</code> is the event weight (usually a constant set to 1 for each event), <code class="reqn">t</code> is the current event time, <code class="reqn">t_e</code> is the past event time and <code class="reqn">T_{1/2}</code> is a halflife parameter.
</p>
<p>For the triad effect, the past events <code class="reqn">G_t</code> are filtered to include only events
where the current event closes an open triad in the past.
</p>
<p style="text-align: center;"><code class="reqn">triad(G_t , a , b) = \sqrt{\sum_{i \in A} w_t(a, i) \cdot w_t(i, b)}</code>
</p>

<p>An exponential decay function is used to model the effect of time on the endogenous statistics. The further apart the past event is from the present event, the less weight is given to this event. The halflife parameter in the <code>triadStat()</code>-function determines at which rate the weights of past events should be reduced. Therefore, if the one (or more) of the two events in the triad have occurred further in the past, less weight is given to this triad because it becomes less likely that the sender and target actors reacted to each other in the way the triad assumes.
</p>
<p>The <code>eventtypevar</code>- and <code>eventattributevar</code>-options help filter the past events more specifically. How they are filtered depends on the <code>eventtypevalue</code>- and <code>eventattributevalue</code>-option.
</p>


<h3>Author(s)</h3>

<p>Laurence Brandenberger <a href="mailto:laurence.brandenberger@eawag.ch">laurence.brandenberger@eawag.ch</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+rem-package">rem-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some data with 'sender', 'target' and a 'time'-variable
# (Note: Data used here are random events from the Correlates of War Project)
sender &lt;- c('TUN', 'UNK', 'NIR', 'TUR', 'TUR', 'USA', 'URU', 
            'IRQ', 'MOR', 'BEL', 'EEC', 'USA', 'IRN', 'IRN', 
            'USA', 'AFG', 'ETH', 'USA', 'SAU', 'IRN', 'IRN',
            'ROM', 'USA', 'USA', 'PAN', 'USA', 'USA', 'YEM', 
            'SYR', 'AFG', 'NAT', 'UNK', 'IRN')
target &lt;- c('BNG', 'RUS', 'JAM', 'SAU', 'MOM', 'CHN', 'IRQ', 
            'AFG', 'AFG', 'EEC', 'BEL', 'ITA', 'RUS', 'UNK',
            'IRN', 'RUS', 'AFG', 'ISR', 'ARB', 'USA', 'USA',
            'USA', 'AFG', 'IRN', 'IRN', 'IRN', 'AFG', 'PAL',
            'ARB', 'USA', 'EEC', 'IRN', 'CHN')
time &lt;- c('800107', '800107', '800107', '800109', '800109', 
          '800109', '800111', '800111', '800111', '800113',
          '800113', '800113', '800114', '800114', '800114', 
          '800116', '800116', '800116', '800119', '800119',
          '800119', '800122', '800122', '800122', '800124', 
          '800125', '800125', '800127', '800127', '800127', 
          '800204', '800204', '800204')
type &lt;- sample(c('cooperation', 'conflict'), 33,
               replace = TRUE)
important &lt;- sample(c('important', 'not important'), 33,
                    replace = TRUE)

# combine them into a data.frame
dt &lt;- data.frame(sender, target, time, type, important)

# create event sequence and order the data
dt &lt;- eventSequence(datevar = dt$time, dateformat = "%y%m%d", 
                    data = dt, type = "continuous", 
                    byTime = "daily", returnData = TRUE,
                    sortData = TRUE)

# create counting process data set (with null-events) - conditional logit setting
dts &lt;- createRemDataset(dt, dt$sender, dt$target, dt$event.seq.cont, 
                          eventAttribute = dt$type, 
                          atEventTimesOnly = TRUE, untilEventOccurrs = TRUE, 
						  returnInputData = TRUE)
dtrem &lt;- dts[[1]]
dt &lt;- dts[[2]]
# manually sort the data set
dtrem &lt;- dtrem[order(dtrem$eventTime), ]
# merge type-variable back in
dtrem$type &lt;- dt$type[match(dtrem$eventID, dt$eventID)]

# calculate triad statistic
dtrem$triad &lt;- triadStat(data = dtrem, time = dtrem$eventTime, 
                      sender = dtrem$sender, target = dtrem$target, 
                      eventvar = dtrem$eventDummy,
                      halflife = 2)

# calculate friend-of-friend statistic
dtrem$triad.fof &lt;- triadStat(data = dtrem, time = dtrem$eventTime, 
                          sender = dtrem$sender, target = dtrem$target, 
                          halflife = 2, eventtypevar = dtrem$type, 
                          eventtypevalues = c("cooperation",
                                              "cooperation"), 
                          eventvar = dtrem$eventDummy)

# calculate friend-of-enemy statistic
dtrem$triad.foe &lt;- triadStat(data = dtrem, time = dtrem$eventTime, 
                             sender = dtrem$sender, target = dtrem$target, 
                             halflife = 2, eventtypevar = dtrem$type, 
                             eventtypevalues = c("conflict",
                                                 "cooperation"), 
                             eventvar = dtrem$eventDummy)

# calculate enemy-of-friend statistic
dtrem$triad.eof &lt;- triadStat(data = dtrem, time = dtrem$eventTime, 
                             sender = dtrem$sender, target = dtrem$target, 
                             halflife = 2, eventtypevar = dtrem$type, 
                             eventtypevalues = c("cooperation",
                                                 "conflict"), 
                             eventvar = dtrem$eventDummy)

# calculate enemy-of-enemy statistic
dtrem$triad.eoe &lt;- triadStat(data = dtrem, time = dtrem$eventTime, 
                             sender = dtrem$sender, target = dtrem$target, 
                             halflife = 2, eventtypevar = dtrem$type, 
                             eventtypevalues = c("conflict",
                                                 "conflict"), 
                             eventvar = dtrem$eventDummy)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
