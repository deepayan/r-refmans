<!DOCTYPE html><html><head><title>Help for package reda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#reda-package'><p>Recurrent Event Data Analysis</p></a></li>
<li><a href='#AIC+2CrateReg-method'><p>Akaike Information Criterion (AIC)</p></a></li>
<li><a href='#as.character+2CRecur-method'><p>Convert An Recur Object to A Character Vector</p></a></li>
<li><a href='#baseRate'><p>Estimated Baseline Rate Function</p></a></li>
<li><a href='#baseRate.rateReg-class'><p>An S4 Class Representing Estimated Baseline Rate Function</p></a></li>
<li><a href='#BIC+2CrateReg-method'><p>Bayesian Information Criterion (BIC)</p></a></li>
<li><a href='#check_Recur'><p>Checks for Recurrent Event Data</p></a></li>
<li><a href='#coef+2CrateReg-method'><p>Estimated Coefficients of Covariates</p></a></li>
<li><a href='#confint+2CrateReg-method'><p>Confidence Intervals for Covariate Coefficients</p></a></li>
<li><a href='#is.Recur'><p>Is the xect from the Recur class?</p></a></li>
<li><a href='#mcf'><p>Mean Cumulative Function (MCF)</p></a></li>
<li><a href='#mcf.formula-class'><p>An S4 Class Representing Sample MCF</p></a></li>
<li><a href='#mcf.rateReg-class'><p>An S4 Class Respresenting Estimated MCF from a Fitted Model</p></a></li>
<li><a href='#mcfDiff'><p>Comparing Two-Sample MCFs</p></a></li>
<li><a href='#mcfDiff-class'><p>An S4 Class Representing Sample MCF Difference</p></a></li>
<li><a href='#mcfDiff.test-class'><p>An S4 Class Representing the Two-Sample Pseudo-Score Test Results</p></a></li>
<li><a href='#parametrize'><p>Parametrizations of Covariates and Covariate Coefficients</p></a></li>
<li><a href='#plot-method'><p>Plot Baseline Rate or Mean Cumulative Function (MCF)</p></a></li>
<li><a href='#rateReg'><p>Recurrent Events Regression Based on Counts and Rate Function</p></a></li>
<li><a href='#rateReg-class'><p>An S4 Class Representing a Fitted Model</p></a></li>
<li><a href='#Recur'><p>Formula Response for Recurrent Event Data</p></a></li>
<li><a href='#Recur-class'><p>An S4 Class Representing Formula Response for Recurrent Event Data</p></a></li>
<li><a href='#Recur-to'><p>Recurrent Episodes</p></a></li>
<li><a href='#show-method'><p>Show an object.</p></a></li>
<li><a href='#simEvent'><p>Simulated Survival times or Recurrent Events</p></a></li>
<li><a href='#simEvent-class'><p>An S4 Class for Simulated Recurrent Event or Survival Times</p></a></li>
<li><a href='#simuDat'><p>Simulated Sample Dataset for Demonstration</p></a></li>
<li><a href='#summary+2CrateReg-method'><p>Summarizing a Fitted Model</p></a></li>
<li><a href='#summary+2CRecur-method'><p>Summarize an <code>Recur</code> object</p></a></li>
<li><a href='#summary.rateReg-class'><p>An S4 Class Representing Summary of a Fitted Model</p></a></li>
<li><a href='#summary.Recur-class'><p>An S4 Class for Summarized Recur Object</p></a></li>
<li><a href='#Survr'><p>Formula Response for Recurrent Event Data</p></a></li>
<li><a href='#Survr-class'><p>An S4 Class Representing Formula Response</p></a></li>
<li><a href='#valveSeats'><p>Valve Seats Dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Recurrent Event Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains implementations of recurrent event data analysis routines
    including (1) survival and recurrent event data simulation from
    stochastic process point of view by the thinning method
    proposed by Lewis and Shedler (1979) &lt;<a href="https://doi.org/10.1002%2Fnav.3800260304">doi:10.1002/nav.3800260304</a>&gt;
    and the inversion method introduced in Cinlar (1975, ISBN:978-0486497976),
    (2) the mean cumulative function (MCF) estimation by the
    Nelson-Aalen estimator of the cumulative hazard rate function,
    (3) two-sample recurrent event responses comparison with the pseudo-score
    tests proposed by Lawless and Nadeau (1995) &lt;<a href="https://doi.org/10.2307%2F1269617">doi:10.2307/1269617</a>&gt;,
    (4) gamma frailty model with spline rate function following
    Fu, et al. (2016) &lt;<a href="https://doi.org/10.1080%2F10543406.2014.992524">doi:10.1080/10543406.2014.992524</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, ggplot2, graphics, grDevices, methods, splines2 (&ge;
0.4.3), stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'class.R' 'Recur.R' 'Survr.R' 'aic.R'
'baseline.R' 'coef.R' 'data.R' 'mcf-generic.R' 'mcf-formula.R'
'mcf-rateReg.R' 'mcfDiff.R' 'misc.R' 'plot.R' 'rateReg.R'
'reda.R' 'show.R' 'simEvent.R' 'summary.R' 'zzz.R'</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wwenjie.org/reda">https://wwenjie.org/reda</a>, <a href="https://github.com/wenjie2wang/reda">https://github.com/wenjie2wang/reda</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wenjie2wang/reda/issues">https://github.com/wenjie2wang/reda/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-08 15:47:56 UTC; wenjie</td>
</tr>
<tr>
<td>Author:</td>
<td>Wenjie Wang <a href="https://orcid.org/0000-0003-0363-3180"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Haoda Fu [aut],
  Sy Han (Steven) Chiou [ctb],
  Jun Yan <a href="https://orcid.org/0000-0003-4401-7296"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wenjie Wang &lt;wang@wwenjie.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-08 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='reda-package'>Recurrent Event Data Analysis</h2><span id='topic+reda-package'></span>

<h3>Description</h3>

<p>The R package <span class="pkg">reda</span> provides functions for simulating, exploring and
modeling recurrent event data.
</p>


<h3>Details</h3>

<p>The main functions are summarized as follows:
</p>

<ul>
<li> <p><code>simEventData</code>: Simulating survival, recurrent event, and
multiple event data from stochastic process point of view.
</p>
</li>
<li> <p><code>mcf</code>: Estimating the mean cumulative function (MCF) from a
fitted gamma frailty model, or from a sample recurrent event data by using
the nonparametic MCF estimator (the Nelson-Aelen estimator of the cumulative
hazard function).
</p>
</li>
<li> <p><code>mcfDiff</code>: Comparing two-sample MCFs by the pseudo-score tests
and estimating their difference over time.
</p>
</li>
<li> <p><code>rateReg</code>: Fitting Gamma fraitly model with spline baseline rate
function.
</p>
</li></ul>

<p>See the package vignettes for more introduction and demonstration.
</p>

<hr>
<h2 id='AIC+2CrateReg-method'>Akaike Information Criterion (AIC)</h2><span id='topic+AIC+2CrateReg-method'></span>

<h3>Description</h3>

<p><code>AIC,rateReg-method</code> is an S4 class method calculating Akaike
information criterion (AIC) for one or several <code>rateReg</code> objects,
according to the formula - 2 * log-likelihood + 2 * nPar, where nPar
represents the number of parameters in the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rateReg'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC+2B2CrateReg-method_+3A_object">object</code></td>
<td>
<p>An object used to dispatch a method.</p>
</td></tr>
<tr><td><code id="AIC+2B2CrateReg-method_+3A_...">...</code></td>
<td>
<p>Optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="AIC+2B2CrateReg-method_+3A_k">k</code></td>
<td>
<p>An optional numeric value used as the penalty per parameter.  The
default <code>k = 2</code> is the classic AIC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing models fitted by maximum likelihood to the same data, the
smaller the AIC, the better the fit. A friendly warning will be thrown out
if the numbers of observation were different in the model comparison.
<code>help(AIC, stats)</code> for other details.
</p>


<h3>Value</h3>

<p>If just one object is provided, a numeric value representing
calculated AIC.  If multiple objects are provided, a data frame with
rows corresponding to the objects and columns <code>df</code> and <code>AIC</code>,
where <code>df</code> means degree of freedom, which is the number of
parameters in the fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rateReg">rateReg</a></code> for model fitting;
<code><a href="#topic+summary+2CrateReg-method">summary,rateReg-method</a></code> for summary of a fitted model;
<code><a href="#topic+BIC+2CrateReg-method">BIC,rateReg-method</a></code> for BIC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples given in function rateReg.

</code></pre>

<hr>
<h2 id='as.character+2CRecur-method'>Convert An Recur Object to A Character Vector</h2><span id='topic+as.character+2CRecur-method'></span>

<h3>Description</h3>

<p>Summarize and convert the recurrent episodes for each subjects into
character strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Recur'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character+2B2CRecur-method_+3A_x">x</code></td>
<td>
<p>An Recur object.</p>
</td></tr>
<tr><td><code id="as.character+2B2CRecur-method_+3A_...">...</code></td>
<td>
<p>Other arguments for future usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be a helper function for the 'show()' method of
'Recur' objects.  To be precise, the function set the maximum number of
recurrent episodes for each subject to be 'max(2L,
as.integer(getOption(&quot;reda.Recur.maxPrint&quot;)))'.  By default, at most three
recurrent episodes will be summarized for printing.  When subjects having
more than three recurrent episodes, the first
'getOption(&quot;reda.Recur.maxPrint&quot;) - 1' number of recurrent episodes and the
last one will be summarized.  One may use 'options()' to adjust the setting.
For example, the default value is equivalent to 'options(reda.Recur.maxPrint
= 3)'.
</p>

<hr>
<h2 id='baseRate'>Estimated Baseline Rate Function</h2><span id='topic+baseRate'></span><span id='topic+baseRate+2CrateReg-method'></span>

<h3>Description</h3>

<p>An S4 class generic function that returns the estimated baseline rate
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseRate(object, ...)

## S4 method for signature 'rateReg'
baseRate(object, level = 0.95, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseRate_+3A_object">object</code></td>
<td>
<p>An object used to dispatch a method.</p>
</td></tr>
<tr><td><code id="baseRate_+3A_...">...</code></td>
<td>
<p>Other arguments for future usage.</p>
</td></tr>
<tr><td><code id="baseRate_+3A_level">level</code></td>
<td>
<p>An optional numeric value
indicating the confidence level required. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="baseRate_+3A_control">control</code></td>
<td>
<p>An optional list to specify the time grid
where the baseline rate function is estimated.
The availble elements of the control list include
<code>grid</code>, <code>length.out</code>, <code>from</code> and <code>to</code>.
The time grid can be directly specified via element <code>grid</code>.
A dense time grid is suggested.
Element <code>length.out</code> represents the length of grid points.
The dafault value is 1,000.
Element <code>from</code> means the starting point of grid with default 0.
Element <code>to</code> represnts the endpoint of grid
with the right boundary knot as default.
When <code>grid</code> is missing, the grid will be generated
by <code>seq</code> (from package <span class="pkg">base</span>)
with arguments <code>from</code>, <code>to</code> and <code>length.out</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>baseRate</code> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>baseRate,rateReg-method</code>: Estiamted baseline rate from a fitted model.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+rateReg">rateReg</a></code> for model fitting;
<code><a href="#topic+summary+2CrateReg-method">summary,rateReg-method</a></code> for summary of a fitted model;
<code><a href="#topic+plot+2CbaseRate.rateReg-method">plot,baseRate.rateReg-method</a></code> for ploting method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples given in function rateReg.
</code></pre>

<hr>
<h2 id='baseRate.rateReg-class'>An S4 Class Representing Estimated Baseline Rate Function</h2><span id='topic+baseRate.rateReg-class'></span>

<h3>Description</h3>

<p>An S4 class that represents the estimated baseline rate function from model.
The function <code><a href="#topic+baseRate">baseRate</a></code> produces objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>baseRate</code></dt><dd><p>A data frame.</p>
</dd>
<dt><code>level</code></dt><dd><p>A numeric value.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+baseRate+2CrateReg-method">baseRate,rateReg-method</a></code>
</p>

<hr>
<h2 id='BIC+2CrateReg-method'>Bayesian Information Criterion (BIC)</h2><span id='topic+BIC+2CrateReg-method'></span>

<h3>Description</h3>

<p><code>BIC,rateReg-method</code> is an S4 class method calculating
Bayesian information criterion (BIC) or so-called
Schwarz's Bayesian criterion (SBC)
for one or several <code>rateReg</code> objects,
according to the formula
- 2 * log-likelihood + ln(nObs) * nPar,
where nPar represents the number of parameters in the fitted model
and nObs is the number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rateReg'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC+2B2CrateReg-method_+3A_object">object</code></td>
<td>
<p>An object used to dispatch a method.</p>
</td></tr>
<tr><td><code id="BIC+2B2CrateReg-method_+3A_...">...</code></td>
<td>
<p>More fitted model objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing models fitted by maximum likelihood to the same
data, the smaller the BIC, the better the fit.
<code>help(BIC, stats)</code> for other details.
</p>


<h3>Value</h3>

<p>If just one object is provided, a numeric value representing
calculated BIC.
If multiple objects are provided, a data frame with rows
corresponding to the objects and columns <code>df</code> and <code>BIC</code>,
where <code>df</code> means degree of freedom,
which is the number of parameters in the fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rateReg">rateReg</a></code> for model fitting;
<code><a href="#topic+summary+2CrateReg-method">summary,rateReg-method</a></code> for summary of a fitted model;
<code><a href="#topic+AIC+2CrateReg-method">AIC,rateReg-method</a></code> for AIC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples given in function rateReg.
</code></pre>

<hr>
<h2 id='check_Recur'>Checks for Recurrent Event Data</h2><span id='topic+check_Recur'></span>

<h3>Description</h3>

<p>Perform several checks for recurrent event data and update object
attributions if some rows of the contained data (in the <code>.Data</code> slot)
have been removed by such as <code>na.action</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_Recur(x, check = c("hard", "soft", "none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_Recur_+3A_x">x</code></td>
<td>
<p>An <code>Recur</code> object.</p>
</td></tr>
<tr><td><code id="check_Recur_+3A_check">check</code></td>
<td>
<p>A character value specifying how to perform the checks for
recurrent event data.  Errors or warnings will be thrown, respectively,
if the <code>check</code> is specified to be <code>"hard"</code> (by default) or
<code>"soft"</code>.  If <code>check = "none"</code> is specified, no data checking
procedure will be run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>Recur</code> object invisibly.
</p>

<hr>
<h2 id='coef+2CrateReg-method'>Estimated Coefficients of Covariates</h2><span id='topic+coef+2CrateReg-method'></span>

<h3>Description</h3>

<p><code>coef,rateReg-method</code> is an S4 class method that extracts estimated
coefficients of covariates from <code>rateReg</code> object produced by function
<code><a href="#topic+rateReg">rateReg</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rateReg'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2CrateReg-method_+3A_object">object</code></td>
<td>
<p>A <code>rateReg</code> object.</p>
</td></tr>
<tr><td><code id="coef+2B2CrateReg-method_+3A_...">...</code></td>
<td>
<p>Other arguments for future usage.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rateReg">rateReg</a></code> for model fitting;
<code><a href="#topic+confint+2CrateReg-method">confint,rateReg-method</a></code> for confidence intervals
for covariate coefficients;
<code><a href="#topic+summary+2CrateReg-method">summary,rateReg-method</a></code> for summary of a fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples given in function rateReg.
</code></pre>

<hr>
<h2 id='confint+2CrateReg-method'>Confidence Intervals for Covariate Coefficients</h2><span id='topic+confint+2CrateReg-method'></span>

<h3>Description</h3>

<p><code>confint,rateReg-method</code> is an S4 class method for
<code><a href="#topic+rateReg">rateReg</a></code> object, which returns approximate confidence intervals
for all or specified covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rateReg'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint+2B2CrateReg-method_+3A_object">object</code></td>
<td>
<p>A <code>rateReg</code> object.</p>
</td></tr>
<tr><td><code id="confint+2B2CrateReg-method_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence
intervals, either a vector of numbers or a vector of names.  If missing,
all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint+2B2CrateReg-method_+3A_level">level</code></td>
<td>
<p>An optional numeric value to specify the confidence level
required.  By default, the value is 0.95, which produces 95% confidence
intervals.</p>
</td></tr>
<tr><td><code id="confint+2B2CrateReg-method_+3A_...">...</code></td>
<td>
<p>Other arguments for future usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under regularity condition (Shao 2003, Theorem 4.16 and Theorem 4.17, page
287, 290), the approximate confidence intervals are constructed loosely
based on Fisher information matrix and estimates of coefficients.
</p>


<h3>Value</h3>

<p>A numeric matrix with row names and column names.
</p>


<h3>References</h3>

<p>Shao, J. (2003), <em>Mathematical statistics</em>,
Springer texts in statistics, New York: Springer, 2nd Edition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rateReg">rateReg</a></code> for model fitting;
<code><a href="#topic+coef+2CrateReg-method">coef,rateReg-method</a></code> for point estimates
of covariate coefficients;
<code><a href="#topic+summary+2CrateReg-method">summary,rateReg-method</a></code> for summary of a fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples given in function rateReg.
</code></pre>

<hr>
<h2 id='is.Recur'>Is the xect from the Recur class?</h2><span id='topic+is.Recur'></span>

<h3>Description</h3>

<p>Return <code>TRUE</code> if the specified xect is from the <code><a href="#topic+Recur">Recur</a></code>
class, <code>FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Recur(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.Recur_+3A_x">x</code></td>
<td>
<p>An <code>R</code> xect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>

<hr>
<h2 id='mcf'>Mean Cumulative Function (MCF)</h2><span id='topic+mcf'></span><span id='topic+mcf+2Cformula-method'></span><span id='topic+mcf+2CrateReg-method'></span>

<h3>Description</h3>

<p>An S4 class generic function that returns the mean cumulative function (MCF)
estimates from a fitted model or returns the nonparametric MCF estimates (by
Nelson-Aalen estimator or Cook-Lawless cumulative sample mean estimator)
from the sample data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcf(object, ...)

## S4 method for signature 'formula'
mcf(
  object,
  data,
  subset,
  na.action,
  variance = c("LawlessNadeau", "Poisson", "bootstrap", "CSV", "none"),
  logConfInt = FALSE,
  adjustRiskset = TRUE,
  level = 0.95,
  control = list(),
  ...
)

## S4 method for signature 'rateReg'
mcf(
  object,
  newdata,
  groupName,
  groupLevels,
  level = 0.95,
  na.action,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcf_+3A_object">object</code></td>
<td>
<p>An object used to dispatch a method.</p>
</td></tr>
<tr><td><code id="mcf_+3A_...">...</code></td>
<td>
<p>Other arguments for future usage.</p>
</td></tr>
<tr><td><code id="mcf_+3A_data">data</code></td>
<td>
<p>A data frame, list or environment containing the variables in
the model.  If not found in data, the variables are taken from
<code>environment(formula)</code>, usually the environment from which the
function is called.</p>
</td></tr>
<tr><td><code id="mcf_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="mcf_+3A_na.action">na.action</code></td>
<td>
<p>A function that indicates what should the procedure do if
the data contains <code>NA</code>s.  The default is set by the na.action
setting of <code>options</code>.  The &quot;factory-fresh&quot; default is
<code>na.omit</code>.  Other possible values inlcude
<code>na.fail</code>, <code>na.exclude</code>, and <code>na.pass</code>.
<code>help(na.fail)</code> for details.</p>
</td></tr>
<tr><td><code id="mcf_+3A_variance">variance</code></td>
<td>
<p>A character specifying the method for variance estimates.
The available options are <code>"LawlessNadeau"</code> (the default) for
Lawless and Nadeau (1995) method, <code>"Poisson"</code> for Poisson process
method, <code>"bootstrap"</code> for bootstrap method, <code>"CSV"</code> for
variance estimates of the corresponding cumulative sample mean function
(CSM) by the cumulative sample variance method (Cook and Lawless, 2007),
and <code>"none"</code> for no variance estimates.  Partial matching on the
names is allowed.</p>
</td></tr>
<tr><td><code id="mcf_+3A_logconfint">logConfInt</code></td>
<td>
<p>A logical value. If <code>FALSE</code> (the default), the
confidence interval are constructed based on the normality of the MCF
estimates. Otherwise, the confidence intervals of given level are
constucted based on the normality of logarithm of the MCF estimates.</p>
</td></tr>
<tr><td><code id="mcf_+3A_adjustriskset">adjustRiskset</code></td>
<td>
<p>A logical value indicating whether to adjust the size
of risk-set.  If <code>TRUE</code> by default, the size of risk-set will be
adjusted based on at-risk indicators and Nelson-Aalen estimator will be
returned.  Otherwise, the cumulative sample mean (CSM) function given by
Cook and Lawless (2007) will be returned without adjustment on size of
risk-set.</p>
</td></tr>
<tr><td><code id="mcf_+3A_level">level</code></td>
<td>
<p>An optional numeric value indicating the confidence level
required. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="mcf_+3A_control">control</code></td>
<td>
<p>An optional named list specifying other options.  For
<code>rateReg</code> object, it can be used to specify the time grid where the
MCF is estimated. The available named elements are given as follows:
</p>

<ul>
<li> <p><code>grid</code>: The time grid where MCF is estimated. A dense
grid is suggested for further using the plot method.
</p>
</li>
<li> <p><code>length.out</code>: The length of grid points. The dafault
value is 1,000.
</p>
</li>
<li> <p><code>from</code>: The starting point of grid. The default value is
the left boundary knots (for <code>rateReg</code> object).
</p>
</li>
<li> <p><code>to</code>: The endpoint of grid. The default value is the
right boundary knots (for <code>rateReg</code> object).
</p>
</li></ul>

<p>The option <code>length.out</code>, <code>from</code>, <code>to</code> will be ignored if
<code>grid</code> is specified directly. Otherwise, the grid will be generated
by function <code>seq.int</code> with specified <code>from</code>,
<code>to</code> and <code>length.out</code>.
</p>
<p>For formula method, the available named elements are given as follows:
</p>

<ul>
<li> <p><code>B</code>: The number of bootstrap replicates for using
bootstrap method for variance estimates of sample MCF estimates.
The default value is 200.
</p>
</li>
<li> <p><code>se.method</code>: The method used for SE estimates for
bootstrap. The available methods include <code>"sample.se"</code>
(the default) and <code>"normality"</code>. The former takes the
sample SE of point estimates from bootstrap samples; The latter
estimates SE based on interquantile and normality assumption.
</p>
</li>
<li> <p><code>ci.method</code>: The method used for confidence interval (CI)
for bootstrap. The available options include <code>"normality"</code>
(the default) and <code>"percentile"</code>. The former estimates the
CI based on SE estimates and normality assumption; The latter
takes percentiles of the bootstrap estimates.
</p>
</li>
<li> <p><code>keep.data</code>: A logical value specifying whether to keep the
processed data in the output object. If <code>TRUE</code>
(the default), the processed data will be kept in the output and
available for later usage. Otherwise, an empty data
frame object will be returned in the <code>data</code> slot.
<code>FALSE</code> may be set when the memory consumption is
of concern and we only need MCF estimates. For example, the
function <code>mcfDiff</code> and <code>mcfDiff.test</code> will not be
applicable for the <code>mcf.formula</code> object with an empty
<code>data</code> slot.
</p>
</li>
<li> <p><code>verbose</code>: A logical value. The default value is
<code>TRUE</code>. If <code>FALSE</code>, possible data checking messages
(not including warnings or errors) will be suppressed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcf_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame. If specified, the data frame should
have the same column names as the covariate names appearing in the
formula of original fitting.</p>
</td></tr>
<tr><td><code id="mcf_+3A_groupname">groupName</code></td>
<td>
<p>An optional length-one charactor vector to specify the name
for grouping each unique row in <code>newdata</code>, such as &quot;gender&quot; for
&quot;male&quot; and &quot;female&quot;. The default value is &quot;Group&quot;.</p>
</td></tr>
<tr><td><code id="mcf_+3A_grouplevels">groupLevels</code></td>
<td>
<p>An optional charactor vector to specify the levels for
each unique row in <code>newdata</code>, such as &quot;treatment&quot; and &quot;control&quot;.
The default values are <code>"Level"</code> followed by a numeric sequence
with length of number of levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>formula</code> object with <code><a href="#topic+Recur">Recur</a></code> object as response, the
covariate specified at the right hand side of the formula should be either
<code>1</code> or any &quot;linear&quot; conbination of categorical variable in the data.
The former computes the overall sample MCF.  The latter computes the sample
MCF for each level of the combination of the categorical variable(s)
specified, respectively.
</p>
<p>The MCF estimates are computed on each unique time point of the sample data.
By default, the size of risk set is adjusted over time based on the at-risk
indicators, which results in the Nelson-Aalen nonparametric estimator
(Nelson 2003).  If the size of risk set remains a constant (total number of
processes) over time (specified by <code>adjustRiskset = FALSE</code>), the
cumulative sample mean (CSM) function introduced in Chapter 1 of Cook and
Lawless (2007) will be computed instead.  The point estimate of sample MCF
at each time point does not assume any particular underlying model. The
variance estimates at each time point is computed following the Lawless and
Nadeau method (LawLess and Nadeau 1995), the Poisson process method, or the
bootstrap methods.  The approximate confidence intervals are provided as
well, which are constructed based on the asymptotic normality of the MCF
itself (by default) or the logarithm of MCF.
</p>
<p>For <code>rateReg</code> object, <code>mcf</code> estimates the baseline MCF and its
confidence interval at each time grid if argument <code>newdata</code> is not
specified.  Otherwise, <code>mcf</code> estimates MCF and its confidence interval
for the given <code>newdata</code> based on Delta-method.
</p>


<h3>Value</h3>

<p>A <code>mcf.formula</code> or <code>mcf.rateReg</code> object.
</p>
<p>A brief description of the slots of a <code>mcf.formula</code> object is given as
follows:
</p>

<ul>
<li> <p><code>formula</code>: Model Formula.
</p>
</li>
<li> <p><code>data</code>: Processed data based on the model formula or an
empty data frame if <code>keep.data</code> is set to be <code>FALSE</code>.
</p>
</li>
<li> <p><code>MCF</code>: A data frame containing estimates for sample MCF.
</p>
</li>
<li> <p><code>origin</code>: Time origins.
</p>
</li>
<li> <p><code>multiGroup</code>: A logical value indicating whether MCF
is estimated for different groups respectively.
</p>
</li>
<li> <p><code>logConfInt</code>: A logical value indicating whether the
variance estimates are based on the normality of logarithm of
the MCF estimates.
</p>
</li>
<li> <p><code>level</code>: Confidence level specified.
</p>
</li></ul>

<p>Most slots of a <code>mcf.rateReg</code> object are inherited from the input
<code>rateReg</code> object. A brief description of other slots is given as
follows:
</p>

<ul>
<li> <p><code>newdata</code>: Given dataset used to estimate MCF.
</p>
</li>
<li> <p><code>MCF</code>: A data frame containing MCF estimates.
</p>
</li>
<li> <p><code>level</code>: Confidence level specified.
</p>
</li>
<li> <p><code>na.action</code>: The way handling missing values.
</p>
</li>
<li> <p><code>control</code>: The control list.
</p>
</li>
<li> <p><code>multiGroup</code>: A logical value indicating whether MCF
is estimated for different groups respectively.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>mcf,formula-method</code>: Sample MCF from data.
</p>
</li>
<li> <p><code>mcf,rateReg-method</code>: Estimated MCF from a fitted model.
</p>
</li></ul>


<h3>References</h3>

<p>Cook, R. J., and Lawless, J. (2007). <em>The statistical analysis of
recurrent events</em>, Springer Science &amp; Business Media.
</p>
<p>Lawless, J. F. and Nadeau, C. (1995). Some Simple Robust Methods for the
Analysis of Recurrent Events. <em>Technometrics</em>, 37, 158&ndash;168.
</p>
<p>Nelson, W. B. (2003). <em>Recurrent Events Data Analysis for Product
Repairs, Disease Recurrences, and Other Applications</em> (Vol. 10). SIAM.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rateReg">rateReg</a></code> for model fitting;
<code><a href="#topic+mcfDiff">mcfDiff</a></code> for comparing two-sample MCFs.
<code><a href="#topic+plot-method">plot-method</a></code> for plotting MCF.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(reda)

### sample MCF
## Example 1. valve-seat data
## the default variance estimates by Lawless and Nadeau (1995) method
valveMcf0 &lt;- mcf(Recur(Days, ID, No.) ~ 1, data = valveSeats)
plot(valveMcf0, conf.int = TRUE, mark.time = TRUE, addOrigin = TRUE) +
    ggplot2::xlab("Days") + ggplot2::theme_bw()

## variance estimates following Poisson process model
valveMcf1 &lt;- mcf(Recur(Days, ID, No.) ~ 1,
                 data = valveSeats, variance = "Poisson")
## variance estimates by bootstrap method (with 1,000 bootstrap samples)
set.seed(123)
valveMcf2 &lt;- mcf(Recur(Days, ID, No.) ~ 1,
                 data = valveSeats, variance = "bootstrap",
                 control = list(B = 200))

## comparing the variance estimates from different methods
library(ggplot2)
ciDat &lt;- rbind(cbind(valveMcf0@MCF, Method = "Lawless &amp; Nadeau"),
               cbind(valveMcf1@MCF, Method = "Poisson"),
               cbind(valveMcf2@MCF, Method = "Bootstrap"))
ggplot(ciDat, aes(x = time, y = se)) +
    geom_step(aes(color = Method, linetype = Method)) +
    xlab("Days") + ylab("SE estimates") + theme_bw()

## comparing the confidence interval estimates from different methods
ggplot(ciDat, aes(x = time)) +
    geom_step(aes(y = MCF)) +
    geom_step(aes(y = lower, color = Method, linetype = Method)) +
    geom_step(aes(y = upper, color = Method, linetype = Method)) +
    xlab("Days") + ylab("Confidence intervals") + theme_bw()


## Example 2. the simulated data
simuMcf &lt;- mcf(Recur(time, ID, event) ~ group + gender,
               data = simuDat, ID %in% 1 : 50)
plot(simuMcf, conf.int = TRUE, lty = 1 : 4,
     legendName = "Treatment &amp; Gender")

### estimate MCF difference between two groups
## one sample MCF object of two groups
mcf0 &lt;- mcf(Recur(time, ID, event) ~ group, data = simuDat)
## two-sample pseudo-score tests
mcfDiff.test(mcf0)
## difference estimates over time
mcf0_diff &lt;- mcfDiff(mcf0, testVariance = "none")
plot(mcf0_diff)

## or explicitly ask for the difference of two sample MCF
mcf1 &lt;- mcf(Recur(time, ID, event) ~ 1, data = simuDat,
            subset = group %in% "Contr")
mcf2 &lt;- mcf(Recur(time, ID, event) ~ 1, data = simuDat,
            subset = group %in% "Treat")
## perform two-sample tests and estimate difference at the same time
mcf12_diff1 &lt;- mcfDiff(mcf1, mcf2)
mcf12_diff2 &lt;- mcf1 - mcf2   # or equivalently using the `-` method
stopifnot(all.equal(mcf12_diff1, mcf12_diff2))
mcf12_diff1
plot(mcf12_diff1)

### For estimated MCF from a fitted model,
### see examples given in function rateReg.
</code></pre>

<hr>
<h2 id='mcf.formula-class'>An S4 Class Representing Sample MCF</h2><span id='topic+mcf.formula-class'></span>

<h3>Description</h3>

<p>An S4 class that represents sample mean cumulative function (MCF) from data.
The function <code><a href="#topic+mcf">mcf</a></code> produces objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>formula</code></dt><dd><p>Formula.</p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame.</p>
</dd>
<dt><code>MCF</code></dt><dd><p>A data frame.</p>
</dd>
<dt><code>origin</code></dt><dd><p>A named numeric vector.</p>
</dd>
<dt><code>multiGroup</code></dt><dd><p>A logical value.</p>
</dd>
<dt><code>variance</code></dt><dd><p>A character vector.</p>
</dd>
<dt><code>logConfInt</code></dt><dd><p>A logical value.</p>
</dd>
<dt><code>level</code></dt><dd><p>A numeric value.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mcf+2Cformula-method">mcf,formula-method</a></code>.
</p>

<hr>
<h2 id='mcf.rateReg-class'>An S4 Class Respresenting Estimated MCF from a Fitted Model</h2><span id='topic+mcf.rateReg-class'></span>

<h3>Description</h3>

<p>An S4 class that represents estimated mean cumulative function (MCF) from
Models. The function <code><a href="#topic+mcf">mcf</a></code> produces objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>Function call.</p>
</dd>
<dt><code>formula</code></dt><dd><p>Formula.</p>
</dd>
<dt><code>spline</code></dt><dd><p>A character.</p>
</dd>
<dt><code>knots</code></dt><dd><p>A numeric vector.</p>
</dd>
<dt><code>degree</code></dt><dd><p>A nonnegative integer.</p>
</dd>
<dt><code>Boundary.knots</code></dt><dd><p>A numeric vector.</p>
</dd>
<dt><code>newdata</code></dt><dd><p>A numeric matrix.</p>
</dd>
<dt><code>MCF</code></dt><dd><p>A data frame.</p>
</dd>
<dt><code>level</code></dt><dd><p>A numeric value between 0 and 1.</p>
</dd>
<dt><code>na.action</code></dt><dd><p>A length-one character vector.</p>
</dd>
<dt><code>control</code></dt><dd><p>A list.</p>
</dd>
<dt><code>multiGroup</code></dt><dd><p>A logical value.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mcf+2CrateReg-method">mcf,rateReg-method</a></code>
</p>

<hr>
<h2 id='mcfDiff'>Comparing Two-Sample MCFs</h2><span id='topic+mcfDiff'></span><span id='topic+-+2Cmcf.formula+2Cmcf.formula-method'></span><span id='topic+mcfDiff.test'></span>

<h3>Description</h3>

<p>This function estimates the sample MCF difference between two groups. Both
the point estimates and the confidence intervals are computed (Lawless and
Nadeau 1995). The two-sample pseudo-score test proposed by Cook, Lawless,
and Nadeau (1996) is also performed by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcfDiff(mcf1, mcf2 = NULL, level = 0.95, ...)

mcfDiff.test(
  mcf1,
  mcf2 = NULL,
  testVariance = c("robust", "Poisson", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcfDiff_+3A_mcf1">mcf1</code></td>
<td>
<p>A <code>mcf.formula</code> object representing the MCF for one or two
groups.</p>
</td></tr>
<tr><td><code id="mcfDiff_+3A_mcf2">mcf2</code></td>
<td>
<p>An optional second <code>mcf.formula</code> object or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mcfDiff_+3A_level">level</code></td>
<td>
<p>A numeric value indicating the confidence level required. The
default value is 0.95.</p>
</td></tr>
<tr><td><code id="mcfDiff_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>mcfDiff.test</code>.</p>
</td></tr>
<tr><td><code id="mcfDiff_+3A_testvariance">testVariance</code></td>
<td>
<p>A character string specifying the method for computing
the variance estimate for the pseudo-score test statistic proposed by
Cook, Lawless, and Nadeau (1996). The applicable options include
<code>"robust"</code> (default) for an estimate robust to departures from
Poisson assumptions, <code>"Poisson"</code> for an estimate for Poisson
process, and <code>"none"</code> for not performing any test (if only the
difference estimates are of interest in <code>mcfDiff</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mcfDiff</code> estimates the two-sample MCFs' difference and
internally calls function <code>mcfDiff.test</code> to perform the pseudo-score
tests by default. A <code>-</code> method is available as a simple wrapper for the
function <code>mcfDiff</code> for comparing two-sample MCFs from two
<code>mcf.formula</code> objects. For instance, suppose <code>mcf1</code> and
<code>mcf2</code> are <code>mcf.formula</code> objects, each of which represents the
sample MCF estimates for one group. The function call <code>mcf1 - mcf2</code> is
equivalent to <code>mcfDiff(mcf1, mcf2)</code>.
</p>
<p>The null hypothesis of the two-sample pseudo-score test is that there is no
difference between the two sample MCFs, while the alternative hypothesis
suggests a difference.  The test is based on a family of test statistics
proposed by Lawless and Nadeau (1995). The argument <code>testVariance</code>
specifies the method for computing the variance estimates of the test
statistics under different model assumption. See the document of argument
<code>testVariance</code> for all applicable options.  For the variance estimates
robust to departures from Poisson process assumption, both constant weight
and the linear weight function (with scaling) suggested in Cook, Lawless,
and Nadeau (1996) are implemented. The constant weight is powerful in cases
where the two MCFs are approximately proportional to each other. The linear
weight function is originally <code>a(u) = t - u</code>, where <code>u</code> represents
the time variable and <code>t</code> is the first time point when the risk set of
either group becomes empty. It is further scaled by <code>1 / t</code> for test
statistics invariant to the unit of measurement of the time variable.  The
linear weight function puts more emphasis on the difference at earily times
than later times and is more powerful for cases where the MCFs are no longer
proportional to each other, but not crossing. Also see Cook and Lawless
(2007, Section 3.7.5) for more details.
</p>


<h3>Value</h3>

<p>The function <code>mcfDiff</code> returns a <code>mcfDiff</code> object (of S4 class)
that contains the following slots:
</p>

<ul>
<li> <p><code>call</code>: Function call.
</p>
</li>
<li> <p><code>MCF</code>: Estimated Mean cumulative function Difference at each time
point.
</p>
</li>
<li> <p><code>origin</code>: Time origins of the two groups.
</p>
</li>
<li> <p><code>variance</code>: The method used for variance estimates.
</p>
</li>
<li> <p><code>logConfInt</code>: A logical value indicating whether normality is
assumed for <code>log(MCF)</code> instead of MCF itself.  For <code>mcfDiff</code>
object, it is always <code>FALSE</code>.
</p>
</li>
<li> <p><code>level</code>: Confidence level specified.
</p>
</li>
<li> <p><code>test</code>: A <code>mcfDiff.test</code> object for the hypothesis test
results.
</p>
</li></ul>

<p>The function <code>mcfDiff.test</code> returns a <code>mcfDiff.test</code> object (of S4
class) that contains the following slots:
</p>

<ul>
<li> <p><code>.Data</code>: A numeric matrix (of two rows and five columns) for
hypothesis testing results.
</p>
</li>
<li> <p><code>testVariance</code>: A character string (or vector of length one)
indicating the method used for the variance estimates of the test statistic.
</p>
</li></ul>



<h3>References</h3>

<p>Lawless, J. F., &amp; Nadeau, C. (1995). Some Simple Robust Methods for the
Analysis of Recurrent Events. <em>Technometrics</em>, 37(2), 158&ndash;168.
</p>
<p>Cook, R. J., Lawless, J. F., &amp; Nadeau, C. (1996). Robust Tests for Treatment
Comparisons Based on Recurrent Event Responses. <em>Biometrics</em>, 52(2),
557&ndash;571.
</p>
<p>Cook, R. J., &amp; Lawless, J. (2007). <em>The Statistical Analysis of
Recurrent Events</em>.  Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples given for function mcf.
</code></pre>

<hr>
<h2 id='mcfDiff-class'>An S4 Class Representing Sample MCF Difference</h2><span id='topic+mcfDiff-class'></span>

<h3>Description</h3>

<p>An S4 class that represents the difference between two sample mean
cumulative functions from data.  The function <code><a href="#topic+mcfDiff">mcfDiff</a></code>
produces objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>A function call.</p>
</dd>
<dt><code>MCF</code></dt><dd><p>A data frame.</p>
</dd>
<dt><code>origin</code></dt><dd><p>A named numeric vector.</p>
</dd>
<dt><code>variance</code></dt><dd><p>A character vector.</p>
</dd>
<dt><code>logConfInt</code></dt><dd><p>A logical value.</p>
</dd>
<dt><code>level</code></dt><dd><p>A numeric value.</p>
</dd>
<dt><code>test</code></dt><dd><p>A <code>mcfDiff.test</code> class object.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mcfDiff">mcfDiff</a></code>
</p>

<hr>
<h2 id='mcfDiff.test-class'>An S4 Class Representing the Two-Sample Pseudo-Score Test Results</h2><span id='topic+mcfDiff.test-class'></span>

<h3>Description</h3>

<p>An S4 class that represents the results of the two-sample pseudo-score tests
between two sample mean cumulative functions.  The function
<code><a href="#topic+mcfDiff.test">mcfDiff.test</a></code> produces objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>A numeric matrix.</p>
</dd>
<dt><code>testVariance</code></dt><dd><p>A character vector.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+mcfDiff.test">mcfDiff.test</a></code>
</p>

<hr>
<h2 id='parametrize'>Parametrizations of Covariates and Covariate Coefficients</h2><span id='topic+parametrize'></span>

<h3>Description</h3>

<p>This function helps the parametrizations of covariates and covariate
coeffcients when users specify a general hazard rate function in function
<code>simEvent</code> and <code>simEventData</code>. It applies the specified function
(or the built-in option) <code>FUN</code> to the <code class="reqn">i_{th}</code> row of the covariate
matrix <code>z</code> and the <code class="reqn">i_{th}</code> row of the coefficient matrix,
iteratively, for <code class="reqn">i</code> from one to the number of rows of the covariate
matrix <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametrize(z, zCoef, FUN = c("exponential", "linear", "excess"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parametrize_+3A_z">z</code></td>
<td>
<p>A numeric matrix, each row of which represents the covariate vector
at one perticular time point.</p>
</td></tr>
<tr><td><code id="parametrize_+3A_zcoef">zCoef</code></td>
<td>
<p>A numeric matrix, each row of which represents the covariate
coeffcient vector at one perticular time point.</p>
</td></tr>
<tr><td><code id="parametrize_+3A_fun">FUN</code></td>
<td>
<p>The parametrization of the model parameter(s) with covariates and
covariate coefficients. The built-in options include
<code>"exponential"</code>, <code>"linear"</code>, <code>"excess"</code> for
parametrization in the exponential, linear, excess relative risk model
form, respectively. It can also be a function that at least has argument
<code>z</code> and <code>zCoef</code> for incorporating the covariates and covariate
coefficients into the model. The user-specified function should expect
that both the input <code>z</code> and <code>zCoef</code> are numeric vectors and
return a numeric value (or can be convected to a numeric value by
<code>as.numeric</code>).</p>
</td></tr>
<tr><td><code id="parametrize_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to the function <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>See Also</h3>

<p><code>simEvent</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## time points
timeVec &lt;- c(0.5, 2)
## time-variant covariates
zMat &lt;- cbind(0.5, ifelse(timeVec &gt; 1, 1, 0))
## time-varying coefficients
zCoefMat &lt;- cbind(sin(timeVec), timeVec)

## the following three ways are equivalent for the exponential form,
## where the first one (using the built-in option) has the best performance
parametrize(zMat, zCoefMat, FUN = "exponential")
parametrize(zMat, zCoefMat, function(z, zCoef) exp(z %*% zCoef))
sapply(1 : 2, function(i) as.numeric(exp(zMat[i, ] %*% zCoefMat[i, ])))

</code></pre>

<hr>
<h2 id='plot-method'>Plot Baseline Rate or Mean Cumulative Function (MCF)</h2><span id='topic+plot-method'></span><span id='topic+plot+2Cmcf.formula+2Cmissing-method'></span><span id='topic+plot+2Cmcf.formula-method'></span><span id='topic+plot+2Cmcf.rateReg+2Cmissing-method'></span><span id='topic+plot+2Cmcf.rateReg-method'></span><span id='topic+plot+2CbaseRate.rateReg+2Cmissing-method'></span><span id='topic+plot+2CbaseRate.rateReg-method'></span><span id='topic+plot+2CmcfDiff+2Cmissing-method'></span><span id='topic+plot+2CmcfDiff-method'></span>

<h3>Description</h3>

<p>S4 class methods plotting sample MCF from data, estimated MCF, or estimated
baseline hazard rate function from a fitted model by using <code>ggplot2</code>
plotting system.  The plots generated are thus able to be further customized
properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mcf.formula,missing'
plot(
  x,
  y,
  lty,
  col,
  legendName,
  legendLevels,
  conf.int = FALSE,
  mark.time = FALSE,
  addOrigin = FALSE,
  ...
)

## S4 method for signature 'mcf.rateReg,missing'
plot(x, y, conf.int = FALSE, lty, col, ...)

## S4 method for signature 'baseRate.rateReg,missing'
plot(x, y, conf.int = FALSE, lty, col, ...)

## S4 method for signature 'mcfDiff,missing'
plot(
  x,
  y,
  lty,
  col,
  legendName,
  legendLevels,
  conf.int = TRUE,
  addOrigin = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-method_+3A_x">x</code></td>
<td>
<p>An object used to dispatch a method.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_y">y</code></td>
<td>
<p>An argument that should be missing and ignored now.  Its existence
is just for satisfying the definition of generaic function <code>plot</code>
in package <code>graphics</code> for methods' dispatching.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_lty">lty</code></td>
<td>
<p>An optional numeric vector indicating line types specified to
different groups: 0 = blank, 1 = solid, 2 = dashed, 3 = dotted, 4 =
dotdash, 5 = longdash, 6 = twodash.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_col">col</code></td>
<td>
<p>An optional character vector indicating line colors specified to
different groups.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_legendname">legendName</code></td>
<td>
<p>An optional length-one charactor vector to specify the
name for grouping each unique row in <code>newdata</code>, such as &quot;gender&quot;
for &quot;male&quot; and &quot;female&quot;. The default value is generated from the
<code>object</code>.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_legendlevels">legendLevels</code></td>
<td>
<p>An optional charactor vector to specify the levels for
each unique row in <code>newdata</code>, such as &quot;treatment&quot; and &quot;control&quot;.
The default values are generated from the <code>object</code>.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_conf.int">conf.int</code></td>
<td>
<p>A logical value indicating whether to plot confidence
interval.  The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_mark.time">mark.time</code></td>
<td>
<p>A logical value with default value <code>FALSE</code>.  If
<code>TRUE</code>, each censoring time is marked by &quot;+&quot; on the MCF curves.
Otherwise, the censoring time would not be marked.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_addorigin">addOrigin</code></td>
<td>
<p>A logical value indicating whether the MCF curves start
from origin time. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot-method_+3A_...">...</code></td>
<td>
<p>Other arguments for further usage.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcf">mcf</a></code> for estimation of MCF;
<code><a href="#topic+rateReg">rateReg</a></code> for model fitting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples given in function mcf and rateReg.

</code></pre>

<hr>
<h2 id='rateReg'>Recurrent Events Regression Based on Counts and Rate Function</h2><span id='topic+rateReg'></span><span id='topic+rateReg.control'></span>

<h3>Description</h3>

<p>This function fits recurrent event data (event counts) by gamma frailty
model with spline rate function. The default model is the gamma frailty
model with one piece constant baseline rate function, which is equivalent to
negative binomial regression with the same shape and rate parameter in the
gamma prior. Spline (including piecewise constant) baseline hazard rate
function can be specified for the model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rateReg(
  formula,
  data,
  subset,
  na.action,
  start = list(),
  control = list(),
  contrasts = NULL,
  ...
)

rateReg.control(
  df = NULL,
  degree = 0L,
  knots = NULL,
  Boundary.knots = NULL,
  periodic = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rateReg_+3A_formula">formula</code></td>
<td>
<p><code>Recur</code> object produced by function <code><a href="#topic+Recur">Recur</a></code>.
The terminal events and risk-free episodes specified in <code>Recur</code>
will be ignored since the model does not support them.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment containing the
variables in the model.  If not found in data, the variables are taken
from <code>environment(formula)</code>, usually the environment from which
function <code><a href="#topic+rateReg">rateReg</a></code> is called.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_na.action">na.action</code></td>
<td>
<p>A function that indicates what should the procedure do if
the data contains <code>NA</code>s.  The default is set by the na.action
setting of <code>options</code>.  The &quot;factory-fresh&quot; default is
<code>na.omit</code>.  Other possible values inlcude <code>na.fail</code>,
<code>na.exclude</code>, and <code>na.pass</code>. See <code>help(na.fail)</code> for
details.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_start">start</code></td>
<td>
<p>An optional list of starting values for the parameters to be
estimated in the model.  See more in Section details.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_control">control</code></td>
<td>
<p>An optional list of parameters to control the maximization
process of negative log likelihood function and adjust the baseline rate
function.  See more in Section details.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list, whose entries are values (numeric
matrices or character strings naming functions) to be used as
replacement values for the contrasts replacement function and whose
names are the names of columns of data containing factors.  See
<code>contrasts.arg</code> of <code>model.matrix.default</code> for details.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>rateReg.control()</code> and
<code>stats::constrOptim()</code>.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_df">df</code></td>
<td>
<p>A nonnegative integer to specify the degree of freedom of baseline
rate function. If argument <code>knots</code> or <code>degree</code> are specified,
<code>df</code> will be neglected whether it is specified or not.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_degree">degree</code></td>
<td>
<p>A nonnegative integer to specify the degree of spline bases.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_knots">knots</code></td>
<td>
<p>A numeric vector that represents all the internal knots of
baseline rate function.  The default is <code>NULL</code>, representing no any
internal knots.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>A length-two numeric vector to specify the boundary
knots for baseline rate funtion. By default, the left boundary knot is
the smallest origin time and the right one takes the largest censoring
time from data.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_periodic">periodic</code></td>
<td>
<p>A logical value indicating if periodic splines should be
used.</p>
</td></tr>
<tr><td><code id="rateReg_+3A_verbose">verbose</code></td>
<td>
<p>A logical value with default <code>TRUE</code>.  Set it to
<code>FALSE</code> to supress messages from this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+Recur">Recur</a></code> in the formula response by default first checks
the dataset and will report an error if the dataset does not fall into
recurrent event data framework.  Subject's ID will be pinpointed if its
observation violates any checking rule. See <code><a href="#topic+Recur">Recur</a></code> for all the
checking rules.
</p>
<p>Function <code>rateReg</code> first constructs the design matrix from
the specified arguments: <code>formula</code>, <code>data</code>, <code>subset</code>,
<code>na.action</code> and <code>constrasts</code> before model fitting.
The constructed design matrix will be checked again to
fit the recurrent event data framework
if any observation with missing covariates is removed.
</p>
<p>The model fitting process involves minimization of negative log
likelihood function, which calls function <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>
internally. <code>help(constrOptim)</code> for more details.
</p>
<p>The argument <code>start</code> is an optional list
that allows users to specify the initial guess for
the parameter values for the minimization of
negative log likelihood function.
The available numeric vector elements in the list include
</p>

<ul>
<li> <p><code>beta</code>: Coefficient(s) of covariates,
set to be all 0.1 by default.
</p>
</li>
<li> <p><code>theta</code>: Parameter in Gamma(theta, 1 / theta) for
frailty random effect, set to be 0.5 by default.
</p>
</li>
<li> <p><code>alpha</code>: Coefficient(s) of baseline rate function,
set to be all 0.05 by default.
</p>
</li></ul>

<p>The argument <code>control</code> allows users to control the process of
minimization of negative log likelihood function passed to
<code>constrOptim</code> and specify the boundary knots of baseline rate function.
</p>


<h3>Value</h3>

<p>A <code>rateReg</code> object, whose slots include
</p>

<ul>
<li> <p><code>call</code>: Function call of <code>rateReg</code>.
</p>
</li>
<li> <p><code>formula</code>: Formula used in the model fitting.
</p>
</li>
<li> <p><code>nObs</code>: Number of observations.
</p>
</li>
<li> <p><code>spline</code>: A list contains
</p>

<ul>
<li> <p><code>spline</code>: The name of splines used.
</p>
</li>
<li> <p><code>knots</code>: Internal knots specified for the baseline
rate function.
</p>
</li>
<li> <p><code>Boundary.knots</code>: Boundary knots specified for the
baseline rate function.
</p>
</li>
<li> <p><code>degree</code>: Degree of spline bases specified in
baseline rate function.
</p>
</li>
<li> <p><code>df</code>: Degree of freedom of the model specified.
</p>
</li></ul>

</li>
<li> <p><code>estimates</code>: Estimated coefficients of covariates and
baseline rate function, and estimated rate parameter of
gamma frailty variable.
</p>
</li>
<li> <p><code>control</code>: The control list specified for model fitting.
</p>
</li>
<li> <p><code>start</code>: The initial guess specified for the parameters
to be estimated.
</p>
</li>
<li> <p><code>na.action</code>: The procedure specified to deal with
missing values in the covariate.
</p>
</li>
<li> <p><code>xlevels</code>: A list that records the levels in
each factor variable.
</p>
</li>
<li> <p><code>contrasts</code>: Contrasts specified and used for each
factor variable.
</p>
</li>
<li> <p><code>convergCode</code>: <code>code</code> returned by function
<code><a href="stats.html#topic+optim">optim</a></code>, which is an integer indicating why the
optimization process terminated. <code>help(optim)</code> for details.
</p>
</li>
<li> <p><code>logL</code>: Log likelihood of the fitted model.
</p>
</li>
<li> <p><code>fisher</code>: Observed Fisher information matrix.
</p>
</li></ul>



<h3>References</h3>

<p>Fu, H., Luo, J., &amp; Qu, Y. (2016).
Hypoglycemic events analysis via recurrent time-to-event (HEART) models.
<em>Journal Of Biopharmaceutical Statistics</em>, 26(2), 280&ndash;298.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary+2CrateReg-method">summary,rateReg-method</a></code> for summary of fitted model;
<code><a href="#topic+coef+2CrateReg-method">coef,rateReg-method</a></code> for estimated covariate coefficients;
<code><a href="#topic+confint+2CrateReg-method">confint,rateReg-method</a></code> for confidence interval of
covariate coefficients;
<code><a href="#topic+baseRate+2CrateReg-method">baseRate,rateReg-method</a></code> for estimated coefficients of baseline
rate function;
<code><a href="#topic+mcf+2CrateReg-method">mcf,rateReg-method</a></code> for estimated MCF from a fitted model;
<code><a href="#topic+plot+2Cmcf.rateReg-method">plot,mcf.rateReg-method</a></code> for plotting estimated MCF.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(reda)

## constant rate function
(constFit &lt;- rateReg(Recur(time, ID, event) ~ group + x1, data = simuDat))

## six pieces' piecewise constant rate function
(piecesFit &lt;- rateReg(Recur(time, ID, event) ~ group + x1,
                      data = simuDat, subset = ID %in% 1:50,
                      knots = seq.int(28, 140, by = 28)))

## fit rate function with cubic spline
(splineFit &lt;- rateReg(Recur(time, ID, event) ~ group + x1, data = simuDat,
                      knots = c(56, 84, 112), degree = 3))

## more specific summary
summary(constFit)
summary(piecesFit)
summary(splineFit)

## model selection based on AIC or BIC
AIC(constFit, piecesFit, splineFit)
BIC(constFit, piecesFit, splineFit)

## estimated covariate coefficients
coef(piecesFit)
coef(splineFit)

## confidence intervals for covariate coefficients
confint(piecesFit)
confint(splineFit, "x1", 0.9)
confint(splineFit, 1, 0.975)

## estimated baseline rate function
splinesBase &lt;- baseRate(splineFit)
plot(splinesBase, conf.int = TRUE)

## estimated baseline mean cumulative function (MCF) from a fitted model
piecesMcf &lt;- mcf(piecesFit)
plot(piecesMcf, conf.int = TRUE, col = "blueviolet")

## estimated MCF for given new data
newDat &lt;- data.frame(x1 = rep(0, 2), group = c("Treat", "Contr"))
splineMcf &lt;- mcf(splineFit, newdata = newDat, groupName = "Group",
                 groupLevels = c("Treatment", "Control"))
plot(splineMcf, conf.int = TRUE, lty = c(1, 5))

## example of further customization by ggplot2
library(ggplot2)
plot(splineMcf) +
    geom_ribbon(aes(x = time, ymin = lower,
                    ymax = upper, fill = Group),
                data = splineMcf@MCF, alpha = 0.2) +
    xlab("Days")
</code></pre>

<hr>
<h2 id='rateReg-class'>An S4 Class Representing a Fitted Model</h2><span id='topic+rateReg-class'></span>

<h3>Description</h3>

<p>The class <code>rateReg</code> is an S4 class that represents a fitted model.  The
function <code><a href="#topic+rateReg">rateReg</a></code> produces objects of this class.  See
&ldquo;Slots&rdquo; for details.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>Function call.</p>
</dd>
<dt><code>formula</code></dt><dd><p>Formula.</p>
</dd>
<dt><code>nObs</code></dt><dd><p>A positive integer</p>
</dd>
<dt><code>spline</code></dt><dd><p>A list.</p>
</dd>
<dt><code>estimates</code></dt><dd><p>A list.</p>
</dd>
<dt><code>control</code></dt><dd><p>A list.</p>
</dd>
<dt><code>start</code></dt><dd><p>A list.</p>
</dd>
<dt><code>na.action</code></dt><dd><p>A character vector (of length one).</p>
</dd>
<dt><code>xlevels</code></dt><dd><p>A list.</p>
</dd>
<dt><code>contrasts</code></dt><dd><p>A list.</p>
</dd>
<dt><code>convergCode</code></dt><dd><p>A nonnegative integer.</p>
</dd>
<dt><code>logL</code></dt><dd><p>A numeric value.</p>
</dd>
<dt><code>fisher</code></dt><dd><p>A numeric matrix.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+rateReg">rateReg</a></code>
</p>

<hr>
<h2 id='Recur'>Formula Response for Recurrent Event Data</h2><span id='topic+Recur'></span>

<h3>Description</h3>

<p>Create an S4 class object that represents formula response for recurrent
event data with optional checking procedures embedded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Recur(
  time,
  id,
  event,
  terminal,
  origin,
  check = c("hard", "soft", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Recur_+3A_time">time</code></td>
<td>
<p>A numerical vector representing the time of reccurence event or
censoring, or a list with elements named <code>"time1"</code> and
<code>"time2"</code> for specifying the follow-up of recurrent events.  In the
latter case, function <code>%to%</code> (or <code>%2%</code>) can be used for
ease of typing.  In addition to numeric values, <code>Date</code> and
<code>difftime</code> are allowed and converted to numeric values.  An error
will be thrown if this argument is not specified.</p>
</td></tr>
<tr><td><code id="Recur_+3A_id">id</code></td>
<td>
<p>Subject identificators. It can be numeric vector, character
vector, or a factor vector.  If it is left unspecified, <code>Recur</code>
will assume that each row represents a subject.</p>
</td></tr>
<tr><td><code id="Recur_+3A_event">event</code></td>
<td>
<p>A numeric vector that may represent the status, costs, or types
of the recurrent events. Logical vector is allowed and converted to
numeric vector. Non-positive values are internally converted to zero
indicating censoring status.</p>
</td></tr>
<tr><td><code id="Recur_+3A_terminal">terminal</code></td>
<td>
<p>A numeric vector that may represent the status, costs, or
types of the terminal events.  Logival vector is allowed and converted
to numeric vector.  Non-positive values are internally converted to zero
indicating censoring status.  If a scalar value is specified, all
subjects will have the same status of terminal events at their last
recurrent episodes.  The length of the specified <code>terminal</code> should
be equal to the number of subjects, or number of data rows.  In the
latter case, each subject may have at most one positive entry of
<code>terminal</code> at the last recurrent episode.</p>
</td></tr>
<tr><td><code id="Recur_+3A_origin">origin</code></td>
<td>
<p>The time origin of each subject.  If a scalar value is
specified, all subjects will have the same origin at the specified
value.  The length of the specified <code>origin</code> should be equal to the
number of subjects, or number of data rows.  In the latter case,
different subjects may have different origins.  However, one subject
must have the same origin.  In addition to numeric values, <code>Date</code>
and <code>difftime</code> are also supported and converted to numeric values.</p>
</td></tr>
<tr><td><code id="Recur_+3A_check">check</code></td>
<td>
<p>A character value specifying how to perform the checks for
recurrent event data.  Errors or warnings will be thrown, respectively,
if the <code>check</code> is specified to be <code>"hard"</code> (by default) or
<code>"soft"</code>.  If <code>check = "none"</code> is specified, no data checking
procedure will be run.</p>
</td></tr>
<tr><td><code id="Recur_+3A_...">...</code></td>
<td>
<p>Other arguments for future usage.  A warning will be thrown if
any invalid argument is specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a successor function of the deprecated function <code>Survr</code>.  See
the vignette by 'vignette(&quot;reda-Recur&quot;)' for details.
</p>


<h3>Value</h3>

<p>An <code>Recur</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(reda)
with(valveSeats, Recur(Days, ID))
with(valveSeats, Recur(Days, ID, No.))
with(valveSeats, Recur(Days, ID, No., terminal = 1))
with(valveSeats, Recur(Days, ID, No., origin = 10))
</code></pre>

<hr>
<h2 id='Recur-class'>An S4 Class Representing Formula Response for Recurrent Event Data</h2><span id='topic+Recur-class'></span>

<h3>Description</h3>

<p>The class <code>Recur</code> is an S4 that represents a formula response for
recurrent event data model.  The function <code><a href="#topic+Recur">Recur</a></code> produces
objects of this class.  See &ldquo;Slots&rdquo; for details.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>A numeric matrix that consists of the following columns:
</p>
 <ul>
<li> <p><code>time1</code>: the beginning of time segements; </p>
</li>
<li>
<p><code>time2</code>: the end of time segements; </p>
</li>
<li> <p><code>id</code>: Identificators
of subjects; </p>
</li>
<li> <p><code>event</code>: Event indicators; </p>
</li>
<li><p>:
<code>terminal</code>: Indicators of terminal events.</p>
</li></ul>
</dd>
<dt><code>call</code></dt><dd><p>A function call producing the object.</p>
</dd>
<dt><code>ID</code></dt><dd><p>A character vector for unique original identificators of subjects.</p>
</dd>
<dt><code>ord</code></dt><dd><p>An integer vector for increasingly ordering data by <code>id</code>,
<code>time2</code>, and <code>- event</code>.  Sorting is often done in the
model-fitting steps, where the indices stored in this slot can be used
directly.</p>
</dd>
<dt><code>rev_ord</code></dt><dd><p>An integer vector for reverting the ordering of the sorted
data (by <code>ord</code>) to its original ordering.  This slot is provided to
easily revert the sorting.</p>
</dd>
<dt><code>first_idx</code></dt><dd><p>An integer vector indicating the first record of each
subject in the sorted matrix.  It helps in the data checking produce and
may be helpful in model-fitting step, such as getting the origin time.</p>
</dd>
<dt><code>last_idx</code></dt><dd><p>An integer vector indicating the last record of each subject
in the sorted data.  Similar to <code>first_idx</code>, it helps in the data
checking produce and may be helpful in the model-fitting step, such as
locating the terminal events.</p>
</dd>
<dt><code>check</code></dt><dd><p>A character string indicating how the data checking is
performed.  It just records the option that users specified on data
checking.</p>
</dd>
<dt><code>time_class</code></dt><dd><p>A character vector preserving the class(es) of input times.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Recur">Recur</a></code>
</p>

<hr>
<h2 id='Recur-to'>Recurrent Episodes</h2><span id='topic+Recur-to'></span><span id='topic++25to+25'></span><span id='topic++252+25'></span>

<h3>Description</h3>

<p>Specify time segements or recurrent episodes by endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time1 %to% time2

time1 %2% time2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Recur-to_+3A_time1">time1</code></td>
<td>
<p>The left end-points of the recurrent episodes.</p>
</td></tr>
<tr><td><code id="Recur-to_+3A_time2">time2</code></td>
<td>
<p>The right end-points of the recurrent episodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be used for specifying the argument <code>time</code>
in function <code><a href="#topic+Recur">Recur</a></code>.
</p>


<h3>Value</h3>

<p>A list that consists of two elements named
<code>"time1"</code> and <code>"time2"</code>.
</p>

<hr>
<h2 id='show-method'>Show an object.</h2><span id='topic+show-method'></span><span id='topic+show+2CRecur-method'></span><span id='topic+show+2CrateReg-method'></span><span id='topic+show+2Csummary.rateReg-method'></span><span id='topic+show+2CsummaryRateReg-method'></span><span id='topic+show+2Csummary.Recur-method'></span><span id='topic+show+2Cmcf.formula-method'></span><span id='topic+show+2Cmcf.rateReg-method'></span><span id='topic+show+2CsimEvent-method'></span><span id='topic+show+2CmcfDiff-method'></span><span id='topic+show+2CmcfDiff.test-method'></span>

<h3>Description</h3>

<p>S4 class methods that display objects produced from this package (similar to
S3 class <code>print</code> methods).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Recur'
show(object)

## S4 method for signature 'rateReg'
show(object)

## S4 method for signature 'summary.rateReg'
show(object)

## S4 method for signature 'summary.Recur'
show(object)

## S4 method for signature 'mcf.formula'
show(object)

## S4 method for signature 'mcf.rateReg'
show(object)

## S4 method for signature 'simEvent'
show(object)

## S4 method for signature 'mcfDiff'
show(object)

## S4 method for signature 'mcfDiff.test'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show-method_+3A_object">object</code></td>
<td>
<p>An object used to dispatch a method.</p>
</td></tr>
</table>

<hr>
<h2 id='simEvent'>Simulated Survival times or Recurrent Events</h2><span id='topic+simEvent'></span><span id='topic+simEventData'></span>

<h3>Description</h3>

<p>The function <code>simEvent</code> generates simulated recurrent events or
survival time (the first event time) from one stochastic process. The
function <code>simEventData</code> provides a simple wrapper that calls
<code>simEvent</code> internally and collects the generated survival data or
recurrent events into a data frame. More examples are available in one of
the package vignettes in addition to the function documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simEvent(
  z = 0,
  zCoef = 1,
  rho = 1,
  rhoCoef = 1,
  rhoMax = NULL,
  origin = 0,
  endTime = 3,
  frailty = 1,
  recurrent = TRUE,
  interarrival = "rexp",
  relativeRisk = c("exponential", "linear", "excess", "none"),
  method = c("thinning", "inversion"),
  arguments = list(),
  ...
)

simEventData(nProcess = 1, z = 0, origin = 0, endTime = 3, frailty = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simEvent_+3A_z">z</code></td>
<td>
<p>Time-invariant or time-varying covariates. The default value is
<code>0</code> for no covariate effect.  This argument should be a numeric
vector for time-invariant covariates or a function of times that returns
a numeric matrix for time-varying covariates, where each row represents
the covariate vector at one perticular time point.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_zcoef">zCoef</code></td>
<td>
<p>Time-invariant or time-varying coefficients of covariates. The
default value is <code>1</code>. Similar to the argument <code>z</code>, this
argument should be a numeric vector for time-invariant coefficients or a
function of times that returns a numeric matrix for time-varying
coefficients, where each row represents the coefficient vector at one
perticular time point. The dimension of the <code>z</code> and <code>zCoef</code>
(either specified or generated) has to match with each other.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_rho">rho</code></td>
<td>
<p>Baseline rate (or intensity) function for the Poisson process.
The default is <code>1</code> for a homogenous process of unit intensity. This
argument can be either a non-negative numeric value for a homogenous
process or a function of times for a non-homogenous process. In the
latter case, the function should be able to take a vector of time points
and return a numerical matrix (or vector) with each row representing the
baseline hazard rate vector (or scalar value) at each time point.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_rhocoef">rhoCoef</code></td>
<td>
<p>Coefficients of baseline rate function. The default value is
<code>1</code>. It can be useful when <code>rho</code> is a function generating
spline bases.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_rhomax">rhoMax</code></td>
<td>
<p>A positive number representing an upper bound of the
underlying rate function (excluding the frailty term but including the
covariate effect) for the thinning method.  If this argument is left
unspecified, the function will try to determine an upper bound
internally.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_origin">origin</code></td>
<td>
<p>The time origin set to be <code>0</code> by default. It should be
either a numeric value less than <code>endTime</code> or a function that
returns such a numeric value.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_endtime">endTime</code></td>
<td>
<p>The end of follow-up time set to be <code>3</code> by default.
Similar to <code>origin</code>, <code>endTime</code> should be either a numeric
value greater than <code>origin</code> or a function that returns such a
numeric value.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_frailty">frailty</code></td>
<td>
<p>A positive number or a function for frailty effect. The
default value is <code>1</code> for no frailty effect.  Other positive value
can be specified directly for a shared frailty effect within a cluster.
Similar to <code>z</code>, <code>zCoef</code>, and <code>rho</code>, a function can be
specified for other distribution of the frailty effect. The specified
function should randomly return a positive numeric value. The functions
that generate random numbers following a certain distribution from
<code>stats</code> package can be directly used. The arguments of the function
can be specified through a list named <code>frailty</code> in
<code>arguments</code>. For example, if we consider Gamma distribution with
mean one as the distribution of frailty effect, we may specify
<code>frailty = "rgamma"</code>. The shape and scale parameter needs to be
specified through a list named <code>frailty</code> in <code>arguments</code>, such
as <code>arguments = list(frailty = list(shape = 2, scale = 0.5))</code>.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_recurrent">recurrent</code></td>
<td>
<p>A logical value with default value <code>TRUE</code> indicating
whether to generate recurrent event data or survival data.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_interarrival">interarrival</code></td>
<td>
<p>A function object for randomly generating (positive)
interarrival time between two successive arrivals/events.  The default
value is <code>"rexp"</code> (i.e., function <code>stats::rexp</code>) for
generating interarrival times following exponential distribution, which
leads to a Poisson process. If the assumption of exponential
interarrival times cannot be justified, we may consider a renewal
process, (a generalization of Poisson process), in which interarrival
times between events independently follows an identical distribution. A
customized function can be specified in this case. It must have at least
one argument named <code>rate</code> for the expected number of
arrivals/events in unit time and returns one positive numerical
value. If the function contains an argument named <code>n</code>, it is
assumed that the function returns <code>n</code> interarrival times in one
function call to possibly speed up the random number generation
procedure.  Other arguments can be specified through a named list inside
<code>arguments</code>.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_relativerisk">relativeRisk</code></td>
<td>
<p>Relateive risk function for incorporating the covariates
and the covariate coefficients into the intensity function. The
applicable choices include <code>exponential</code> (the default) for the
regular Cox model or Andersen-Gill model, <code>linear</code> for linear model
(including an intercept term), <code>excess</code> for excess model, and
<code>none</code> for not incorporating the covariates through a relative risk
function. A customized function can be specified. The specified function
must have at least one argument named <code>z</code> for the covariate vector
and another argument named zCoef for covariate coefficient vector.
The function should return a numeric value for given <code>z</code> vector and
<code>zCoef</code> vector.  Other arguments can be specified through a named
list inside <code>arguments</code>.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_method">method</code></td>
<td>
<p>A character string specifying the method for generating
simulated recurrent or survival data. The default method is thinning
method (Lewis and Shedler 1979). Another available option is the
inversion method (Cinlar 1975). When the rate function may go to
infinite, the inversion method is used and a warning will be thrown out
if the thinning method is initially specified.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_arguments">arguments</code></td>
<td>
<p>A list that consists of named lists for specifying other
arguments in the corresponding functions. For example, if a function of
time named <code>foo</code> with two arguments, <code>x</code> (for time) and
<code>y</code>, is specified for the time-varying covariates, the value of its
second argument, <code>y</code>, can be specified by <code>arguments = list(z
= list(y = 1)</code>.  A partial matching on names is not allowed to avoid
possible misspecification. The input arguments will be evaluated within
function <code>simEvent</code>, which can be useful for randomly setting
function parameters for each process in function
<code>simEventData</code>. See examples and vignettes for details.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_...">...</code></td>
<td>
<p>Additional arguements passed from function <code>simEventData</code> to
fucntion <code>simEvent</code>. For function <code>simEvent</code>, <code>...</code> is
not used.</p>
</td></tr>
<tr><td><code id="simEvent_+3A_nprocess">nProcess</code></td>
<td>
<p>Number of stochastic processes. If missing, the value will
be the number of row of the specified matrix <code>z</code>. Otherwise, a
positive number should be speicified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each process, a time-invariant or time-varying baseline hazard rate
(intensity) function of failure can be specified.  Covariates and their
coefficients can be specified and incorporated by the specified relative
risk functions. The default is the exponential relative risk function, which
corresponds to the Cox proportional hazard model (Cox 1972) for survival
data or Andersen-Gill model (Andersen and Gill 1982) for recurrent
events. Other relative risk function can be specified through the argument
<code>relativeRisk</code>. In addition, a frailty effect can be considered.
Conditional on predictors (or covariates) and the unobserved frailty effect,
the process is by default a Poisson process, where the interarrival times
between two successive arrivals/events follow exponential distribution. A
general renewal process can be specified through <code>interarrival</code> for
other distributions of the interarrival times in addition to the exponential
distribution.
</p>
<p>The thinning method (Lewis and Shedler 1979) is applied for bounded hazard
rate function by default. The inversion method (Cinlar 1975) is also
available for possibly unbounded but integrable rate function over the given
time period. The inversion method will be used when the rate function may go
to infinite and a warning will be thrown out if the thinning method is
specified originally.
</p>
<p>For the covariates <code>z</code>, the covariate coefficients <code>zCoef</code>, and
the baseline hazard rate function <code>rho</code>, a function of time can be
specified for time-varying effect.  The first argument of the input function
has to be the time variable (not need to be named as &quot;time&quot; though). Other
arguments of the function can be specified through a named list in
<code>arguments</code>, while the first argument should not be specified.
</p>
<p>For the frailty effect <code>frailty</code>, the starting point <code>origin</code>, and
the end point of the process <code>endTime</code>, functions that generate random
numbers can be specified. An argument <code>n = 1</code> will be implicitly
specified if the function has an argument named <code>n</code>, which is designed
for those common functions generating random numbers from <span class="pkg">stats</span>
package. Similar to <code>z</code>, <code>zCoef</code>, and <code>rho</code>, other arguments
of the function can be specified through a named list in <code>arguments</code>.
</p>
<p>For time-varying covariates, the function <code>simEventData</code> assumes
covariates can be observed only at event times and censoring times. Thus,
covariate values are returned only at these time points. If we want other
observed covariate values to be recorded, we may write a simple wrapper
function for <code>simEvent</code> similar to <code>simEventData</code>.
</p>


<h3>Value</h3>

<p>The function <code>simEvent</code> returns a <code>simEvent</code> S4 class object and
the function <code>simEventData</code> returns a <code>data.frame</code>.
</p>


<h3>References</h3>

<p>Andersen, P. K., &amp; Gill, R. D. (1982). Cox's regression model for counting
processes: A large sample study. <em>The annals of statistics</em>, 10(4),
1100&ndash;1120.
</p>
<p>Cinlar, Erhan (1975). <em>Introduction to stochastic processes</em>. Englewood
Cliffs, NJ: Printice-Hall.
</p>
<p>Cox, D. R. (1972). Regression models and life-tables.
<em>Journal of the Royal Statistical Society. Series B
(Methodological)</em>, 34(2), 187&ndash;220.
</p>
<p>Lewis, P. A., &amp; G. S. Shedler. (1979). Simulation of
Nonhomogeneous Poisson Processes by Thinning.
<em>Naval Research Logistics Quarterly</em>,
26(3), Wiley Online Library: 403&ndash;13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(reda)
set.seed(123)

### time-invariant covariates and coefficients
## one process
simEvent(z = c(0.5, 1), zCoef = c(1, 0))
simEvent(z = 1, zCoef = 0.5, recurrent = FALSE)

## simulated data
simEventData(z = c(0.5, 1), zCoef = c(1, 0), endTime = 2)
simEventData(z = cbind(rnorm(3), 1), zCoef = c(1, 0))
simEventData(z = matrix(rnorm(5)), zCoef = 0.5, recurrent = FALSE)


### time-varying covariates and time-varying coefficients
zFun &lt;- function(time, intercept) {
    cbind(time / 10 + intercept, as.numeric(time &gt; 1))
}
zCoefFun &lt;- function(x, shift) {
    cbind(sqrt(x + shift), 1)
}
simEvent(z = zFun, zCoef = zCoefFun,
         arguments = list(z = list(intercept = 0.1),
                          zCoef = list(shift = 0.1)))

## same function of time for all processes
simEventData(3, z = zFun, zCoef = zCoefFun,
             arguments = list(z = list(intercept = 0.1),
                              zCoef = list(shift = 0.1)))

## same function within one process but different between processes
## use quote function in the arguments
simDat &lt;- simEventData(3, z = zFun, zCoef = zCoefFun,
                       arguments = list(
                           z = list(intercept = quote(rnorm(1) / 10)),
                           zCoef = list(shift = 0.1)
                       ))
## check the intercept randomly generated,
## which should be the same within each ID but different between IDs.
unique(with(simDat, cbind(ID, intercept = round(X.1 - time / 10, 6))))


### non-negative time-varying baseline hazard rate function
simEvent(rho = function(timeVec) { sin(timeVec) + 1 })
simEventData(3, origin = rnorm(3), endTime = rnorm(3, 5),
             rho = function(timeVec) { sin(timeVec) + 1 })
## specify other arguments
simEvent(z = c(rnorm(1), rbinom(1, 1, 0.5)) / 10,
         rho = function(a, b) { sin(a + b) + 1 },
         arguments = list(rho = list(b = 0.5)))
simEventData(z = cbind(rnorm(3), rbinom(3, 1, 0.5)) / 10,
             rho = function(a, b) { sin(a + b) + 1 },
             arguments = list(rho = list(b = 0.5)))

## quadratic B-splines with one internal knot at "time = 1"
## (using function 'bSpline' from splines2 package)
simEvent(rho = splines2::bSpline, rhoCoef = c(0.8, 0.5, 1, 0.6),
         arguments = list(rho = list(degree = 2, knots = 1,
                                     intercept = TRUE,
                                     Boundary.knots = c(0, 3))))


### frailty effect
## Gamma distribution with mean one
simEvent(z = c(0.5, 1), zCoef = c(1, 0), frailty = rgamma,
         arguments = list(frailty = list(shape = 2, scale = 0.5)))

## lognormal with mean zero (on the log scale)
set.seed(123)
simEvent(z = c(0.5, 1), zCoef = c(1, 0), frailty = "rlnorm",
         arguments = list(frailty = list(sdlog = 1)))
## or equivalently
set.seed(123)
logNorm &lt;- function(a) exp(rnorm(n = 1, mean = 0, sd = a))
simEvent(z = c(0.5, 1), zCoef = c(1, 0), frailty = logNorm,
         arguments = list(frailty = list(a = 1)))


### renewal process
## interarrival times following uniform distribution
rUnif &lt;- function(n, rate, min) runif(n, min, max = 2 / rate)
simEvent(interarrival = rUnif,
         arguments = list(interarrival = list(min = 0)))

## interarrival times following Gamma distribution with scale one
set.seed(123)
simEvent(interarrival = function(n, rate) rgamma(n, shape = 1 / rate))
## or equivalently
set.seed(123)
simEvent(interarrival = function(rate) rgamma(n = 1, shape = 1 / rate))


### relative risk functioin
set.seed(123)
simEvent(relativeRisk = "linear")
## or equivalently
rriskFun &lt;- function(z, zCoef, intercept) {
    as.numeric(z %*% zCoef) + intercept
}
set.seed(123)
simEvent(relativeRisk = rriskFun,
         arguments = list(relativeRisk = list(intercept = 1)))
</code></pre>

<hr>
<h2 id='simEvent-class'>An S4 Class for Simulated Recurrent Event or Survival Times</h2><span id='topic+simEvent-class'></span>

<h3>Description</h3>

<p>An S4 class that represents the simulated recurrent event or survival time
from one stochastic process. The function <code><a href="#topic+simEvent">simEvent</a></code> produces
objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>A numerical vector of possibly length zero.</p>
</dd>
<dt><code>call</code></dt><dd><p>A function call.</p>
</dd>
<dt><code>z</code></dt><dd><p>A list.</p>
</dd>
<dt><code>zCoef</code></dt><dd><p>A list.</p>
</dd>
<dt><code>rho</code></dt><dd><p>A list.</p>
</dd>
<dt><code>rhoCoef</code></dt><dd><p>A numerical vector.</p>
</dd>
<dt><code>frailty</code></dt><dd><p>A list.</p>
</dd>
<dt><code>origin</code></dt><dd><p>A list.</p>
</dd>
<dt><code>endTime</code></dt><dd><p>A list.</p>
</dd>
<dt><code>censoring</code></dt><dd><p>A list.</p>
</dd>
<dt><code>recurrent</code></dt><dd><p>A logical vector.</p>
</dd>
<dt><code>interarrival</code></dt><dd><p>A list.</p>
</dd>
<dt><code>relativeRisk</code></dt><dd><p>A list.</p>
</dd>
<dt><code>method</code></dt><dd><p>A character vector.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+simEvent">simEvent</a></code>
</p>

<hr>
<h2 id='simuDat'>Simulated Sample Dataset for Demonstration</h2><span id='topic+simuDat'></span>

<h3>Description</h3>

<p>A simulated data frame with covariates named
<code>ID</code>, <code>time</code>, <code>event</code>, <code>group</code>, <code>x1</code>,
and <code>gender</code>, where
</p>

<ul>
<li> <p><code>ID</code>: Subjects identification;
</p>
</li>
<li> <p><code>time</code>: Event or censoring time;
</p>
</li>
<li> <p><code>event</code>: Event indicator, 1 = event, 0 = censored;
</p>
</li>
<li> <p><code>group</code>: Treatment group indicator;
</p>
</li>
<li> <p><code>x1</code>: Continuous variable.
</p>
</li>
<li> <p><code>gender</code>: Gender of subjects.
</p>
</li></ul>



<h3>Format</h3>

<p>A data frame with 500 rows and 6 variables.
</p>


<h3>Details</h3>

<p>The sample dataset is originally simulated by the thinning
method developed by Lewis and Shedler (1979) and
further processed for a better demonstration purpose.
See Fu et al. (2016) for details also.
</p>


<h3>References</h3>

<p>Lewis, P. A., &amp; Shedler, G. S. (1979).
Simulation of nonhomogeneous Poisson processes by thinning.
<em>Naval Research Logistics Quarterly</em>, 26(3), 403&ndash;413.
</p>
<p>Fu, H., Luo, J., &amp; Qu, Y. (2016).
Hypoglycemic events analysis via recurrent time-to-event (HEART) models.
<em>Journal Of Biopharmaceutical Statistics</em>, 26(2), 280&ndash;298.
</p>

<hr>
<h2 id='summary+2CrateReg-method'>Summarizing a Fitted Model</h2><span id='topic+summary+2CrateReg-method'></span>

<h3>Description</h3>

<p>Summary of estimated coefficients of covariates, rate function bases,
and estimated rate parameter of frailty random variable, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rateReg'
summary(object, showCall = TRUE, showKnots = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CrateReg-method_+3A_object">object</code></td>
<td>
<p>A <code>rateReg</code> object.</p>
</td></tr>
<tr><td><code id="summary+2B2CrateReg-method_+3A_showcall">showCall</code></td>
<td>
<p>A logic value with dafault <code>TRUE</code>,
indicating whether function <code>show</code>
prints out the original call information of <code>rateReg</code>.
It may be helpful for a more concise printout.</p>
</td></tr>
<tr><td><code id="summary+2B2CrateReg-method_+3A_showknots">showKnots</code></td>
<td>
<p>A logic value with default <code>TRUE</code>,
indicating whether function <code>show</code>
prints out the internal and boundary knots.
Similar to argument <code>showCall</code>, It may be helpful
for a more concise printout.</p>
</td></tr>
<tr><td><code id="summary+2B2CrateReg-method_+3A_...">...</code></td>
<td>
<p>Other arguments for future usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary,rateReg-method</code> returns a
<code>summary.rateReg</code> object,
whose slots include
</p>

<ul>
<li> <p><code>covarCoef</code>: Estimated covariate coefficients.
</p>
</li>
<li> <p><code>frailtyPar</code>: Estimated rate parameter of gamma frailty.
</p>
</li>
<li> <p><code>baseRateCoef</code>: Estimated coeffcients of baseline
rate function.
</p>
</li></ul>

<p>For the meaning of other slots, see <code><a href="#topic+rateReg">rateReg</a></code>.
</p>


<h3>Value</h3>

<p><code>summary.rateReg</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rateReg">rateReg</a></code> for model fitting;
<code><a href="#topic+coef+2CrateReg-method">coef,rateReg-method</a></code> for point estimates of
covariate coefficients;
<code><a href="#topic+confint+2CrateReg-method">confint,rateReg-method</a></code> for confidence intervals
of covariate coeffcients;
<code><a href="#topic+baseRate+2CrateReg-method">baseRate,rateReg-method</a></code> for coefficients of baseline
rate function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples given in function rateReg.

</code></pre>

<hr>
<h2 id='summary+2CRecur-method'>Summarize an <code>Recur</code> object</h2><span id='topic+summary+2CRecur-method'></span>

<h3>Description</h3>

<p>Summarize an <code>Recur</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Recur'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2CRecur-method_+3A_object">object</code></td>
<td>
<p>An <code>Recur</code> object.</p>
</td></tr>
<tr><td><code id="summary+2B2CRecur-method_+3A_...">...</code></td>
<td>
<p>Other arguments not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.Recur</code> object.
</p>

<hr>
<h2 id='summary.rateReg-class'>An S4 Class Representing Summary of a Fitted Model</h2><span id='topic+summary.rateReg-class'></span>

<h3>Description</h3>

<p>The class <code>summary.rateReg</code> is an S4 class with selective slots of
<code>rateReg</code> object.  See &ldquo;Slots&rdquo; for details.  The function
<code><a href="#topic+summary+2CrateReg-method">summary,rateReg-method</a></code> produces objects of this class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>Function call.</p>
</dd>
<dt><code>spline</code></dt><dd><p>A character.</p>
</dd>
<dt><code>knots</code></dt><dd><p>A numeric vector.</p>
</dd>
<dt><code>Boundary.knots</code></dt><dd><p>A numeric vector.</p>
</dd>
<dt><code>covarCoef</code></dt><dd><p>A numeric matrix.</p>
</dd>
<dt><code>frailtyPar</code></dt><dd><p>A numeric matrix.</p>
</dd>
<dt><code>degree</code></dt><dd><p>A nonnegative integer.</p>
</dd>
<dt><code>baseRateCoef</code></dt><dd><p>A numeric matrix.</p>
</dd>
<dt><code>logL</code></dt><dd><p>A numeric value.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+summary+2CrateReg-method">summary,rateReg-method</a></code>
</p>

<hr>
<h2 id='summary.Recur-class'>An S4 Class for Summarized Recur Object</h2><span id='topic+summary.Recur-class'></span>

<h3>Description</h3>

<p>An S4 Class for Summarized Recur Object
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>A function call.</p>
</dd>
<dt><code>sampleSize</code></dt><dd><p>An integer representing the sample size (number of
subjects).</p>
</dd>
<dt><code>reSize</code></dt><dd><p>An integer representing the number of recurrent events.</p>
</dd>
<dt><code>avgReSize</code></dt><dd><p>A numeric value representing the average number of recurrent
events per subject.</p>
</dd>
<dt><code>propTem</code></dt><dd><p>A numeric value representing the proportion of subjects having
terminal event.</p>
</dd>
<dt><code>medFU</code></dt><dd><p>A numeric value for median follow-up time.</p>
</dd>
<dt><code>medTem</code></dt><dd><p>A numeric value for median survival time of the terminal
events.</p>
</dd>
</dl>

<hr>
<h2 id='Survr'>Formula Response for Recurrent Event Data</h2><span id='topic+Survr'></span>

<h3>Description</h3>

<p>Create an S4 class that represents formula response for recurrent event data
modeled by methods based on counts and rate function.  Note that the
function is deprecated since version 0.5.0 and will be removed in future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Survr(ID, time, event, origin = 0, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Survr_+3A_id">ID</code></td>
<td>
<p>Subject identificators. It can be numeric vector, character
vector, or a factor vector.</p>
</td></tr>
<tr><td><code id="Survr_+3A_time">time</code></td>
<td>
<p>Time of reccurence event or censoring. In addition to numeric
values, <code>Date</code> and <code>difftime</code> are supported and converted to
numeric values.</p>
</td></tr>
<tr><td><code id="Survr_+3A_event">event</code></td>
<td>
<p>A numeric vector indicating failure cost or event indicator
taking positive values as costs (<code>1</code> as events), and non-positive
values as censoring.  Logical vector is allowed and will be converted to
numeric vector.</p>
</td></tr>
<tr><td><code id="Survr_+3A_origin">origin</code></td>
<td>
<p>The time origin of each subject or process. In addition to
numeric values, <code>Date</code> and <code>difftime</code> are also supported and
converted to numeric values.  Different subjects may have different
origins. However, one subject must have the same origin.</p>
</td></tr>
<tr><td><code id="Survr_+3A_check">check</code></td>
<td>
<p>A logical value suggesting whether to perform data checking
procedure. The default value is <code>TRUE</code>. <code>FALSE</code> should be set
with caution and only for processed data already in recerruent event
data framework.</p>
</td></tr>
<tr><td><code id="Survr_+3A_...">...</code></td>
<td>
<p>Other arguments for future usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a similar function to <code>Survr</code> in package
<span class="pkg">survrec</span> but with a more considerate checking procedure embedded for
recurrent event data modeled by methods based on counts and rate function.
The checking rules apply to each subject respectively and include that
</p>

<ul>
<li><p> Subject identification, event times, censoring time, and event
indicator cannot be missing or contain missing values.
</p>
</li>
<li><p> There has to be only one censoring time not earlier than
any event time.
</p>
</li>
<li><p> The time origin has to be the same and not later than any event
time.
</p>
</li></ul>


<hr>
<h2 id='Survr-class'>An S4 Class Representing Formula Response</h2><span id='topic+Survr-class'></span>

<h3>Description</h3>

<p>The class <code>Survr</code> is an S4 that represents a formula response for
recurrent event data model.  The function <code><a href="#topic+Survr">Survr</a></code> produces
objects of this class.  See &ldquo;Slots&rdquo; for details.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>A numeric matrix object.</p>
</dd>
<dt><code>ID</code></dt><dd><p>A charactrer vector for original subject identificator.</p>
</dd>
<dt><code>check</code></dt><dd><p>A logical value indicating whether to performance data checking.</p>
</dd>
<dt><code>ord</code></dt><dd><p>An integer vector for increasingly ordering data by <code>ID</code>,
<code>time</code>, and <code>1 - event</code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Survr">Survr</a></code>
</p>

<hr>
<h2 id='valveSeats'>Valve Seats Dataset</h2><span id='topic+valveSeats'></span>

<h3>Description</h3>

<p>Valve seats wear out in certain diesel engines, each with 16 valve seats.
The dataset served as an example of recurrence data in Nelson (1995),
which consists of valve-seat replacements on 41 engines in a fleet.
The covariates are named
<code>ID</code>, <code>Days</code>, and <code>No.</code>, where
</p>

<ul>
<li> <p><code>ID</code>: The engine number;
</p>
</li>
<li> <p><code>Days</code>: Engine age in days;
</p>
</li>
<li> <p><code>No.</code>: Event indicator, '1' for a valve-seat replacement
and, '0' for the censoring age of an engine.
</p>
</li></ul>



<h3>Format</h3>

<p>A data frame with 89 rows and 3 variables.
</p>


<h3>References</h3>

<p>Nelson, W. (1995), Confidence Limits for Recurrence
Data-Applied to Cost or Number of Product Repairs, <em>Technometrics</em>,
37, 147&ndash;157.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
