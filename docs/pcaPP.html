<!DOCTYPE html><html lang="en"><head><title>Help for package pcaPP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcaPP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cor.fk'><p> Fast estimation of Kendall's tau rank correlation coefficient</p></a></li>
<li><a href='#covPC'><p> Covariance Matrix Estimation from princomp Object</p></a></li>
<li><a href='#covPCA'><p> Robust Covariance Matrix Estimation</p></a></li>
<li><a href='#data.Zou'><p> Test Data Generation for Sparse PCA examples</p></a></li>
<li><a href='#l1median'><p> Multivariate L1 Median</p></a></li>
<li><a href='#l1median_NLM'><p> Multivariate L1 Median</p></a></li>
<li><a href='#objplot'><p> Objective Function Plot for Sparse PCs</p></a></li>
<li><a href='#opt.TPO'><p> Model Selection for Sparse (Robust) Principal Components</p></a></li>
<li><a href='#PCAgrid'><p> (Sparse) Robust Principal Components using the Grid search algorithm</p></a></li>
<li><a href='#PCAproj'><p> Robust Principal Components using the algorithm of Croux and Ruiz-Gazen (2005)</p></a></li>
<li><a href='#PCdiagplot'><p>Diagnostic plot for principal components</p></a></li>
<li><a href='#plot.opt.TPO'><p> Tradeoff Curves for Sparse PCs</p></a></li>
<li><a href='#plotcov'><p> Compare two Covariance Matrices in Plots</p></a></li>
<li><a href='#qn'><p> scale estimation using the robust Qn estimator</p></a></li>
<li><a href='#ScaleAdv'><p> centers and rescales data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.0-5</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Released 2.0-4-1 on 2024-08-09 on CRAN</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust PCA by Projection Pursuit</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valentin Todorov &lt;valentin.todorov@chello.at&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.6.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>robustbase</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for robust PCA by projection pursuit.
    The methods are described in Croux et al. (2006) &lt;<a href="https://doi.org/10.2139%2Fssrn.968376">doi:10.2139/ssrn.968376</a>&gt;,
    Croux et al. (2013) &lt;<a href="https://doi.org/10.1080%2F00401706.2012.727746">doi:10.1080/00401706.2012.727746</a>&gt;,
    Todorov and Filzmoser (2013) &lt;<a href="https://doi.org/10.1007%2F978-3-642-33042-1_31">doi:10.1007/978-3-642-33042-1_31</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/valentint/pcaPP">https://github.com/valentint/pcaPP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/valentint/pcaPP/issues">https://github.com/valentint/pcaPP/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-19 10:48:56 UTC; valen</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Filzmoser [aut],
  Heinrich Fritz [aut],
  Klaudius Kalcher [aut],
  Valentin Todorov [cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cor.fk'> Fast estimation of Kendall's tau rank correlation coefficient</h2><span id='topic+cor.fk'></span>

<h3>Description</h3>

<p>Calculates Kendall's tau rank correlation coefficient in O (n log (n)) 
rather than O (n^2) as in the current R implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.fk (x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor.fk_+3A_x">x</code></td>
<td>
<p> A vector, a matrix or a data frame of data. </p>
</td></tr>
<tr><td><code id="cor.fk_+3A_y">y</code></td>
<td>
<p> A vector of data. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code of this implementation of the fast Kendall's tau correlation algorithm has 
originally been published by David Simcha. 
Due to it's runtime (<code>O(n log n)</code>) it's essentially faster than the 
current R implementation (<code>O (n\^2)</code>), especially for large numbers of 
observations.
The algorithm goes back to Knight (1966) and has been described more detailed 
by Abrevaya (1999) and Christensen (2005).
</p>


<h3>Value</h3>

<p>The estimated correlation coefficient.
</p>


<h3>Author(s)</h3>

<p> David Simcha, Heinrich Fritz, Christophe Croux, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

 
<p>Knight, W. R. (1966). A Computer Method for Calculating Kendall's Tau with Ungrouped Data.
Journal of the American Statistical Association, <strong>314</strong>(61) Part 1, 436-439.<br />
Christensen D. (2005). Fast algorithms for the calculation of Kendall's Tau.
Journal of Computational Statistics <strong>20</strong>, 51-62.<br />
Abrevaya J. (1999). Computation of the Maximum Rank Correlation Estimator.
Economic Letters <strong>62</strong>, 279-285.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+cor">cor</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  set.seed (100)		## creating test data
  n &lt;- 1000
  x &lt;- rnorm (n)
  y &lt;- x+  rnorm (n)

  tim &lt;- proc.time ()[1]	## applying cor.fk
  cor.fk (x, y)
  cat ("cor.fk runtime [s]:", proc.time ()[1] - tim, "(n =", length (x), ")\n")

  tim &lt;- proc.time ()[1]	## applying cor (standard R implementation)
  cor (x, y, method = "kendall")
  cat ("cor runtime [s]:", proc.time ()[1] - tim, "(n =", length (x), ")\n")

		##	applying cor and cor.fk on data containing				

  Xt &lt;- cbind (c (x, as.integer (x)), c (y, as.integer (y)))

  tim &lt;- proc.time ()[1]	## applying cor.fk
  cor.fk (Xt)
  cat ("cor.fk runtime [s]:", proc.time ()[1] - tim, "(n =", nrow (Xt), ")\n")

  tim &lt;- proc.time ()[1]	## applying cor (standard R implementation)
  cor (Xt, method = "kendall")
  cat ("cor runtime [s]:", proc.time ()[1] - tim, "(n =", nrow (Xt), ")\n")
</code></pre>

<hr>
<h2 id='covPC'> Covariance Matrix Estimation from princomp Object</h2><span id='topic+covPC'></span>

<h3>Description</h3>

<p>computes the covariance matrix from a princomp object. 
The number of components k can be given as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covPC(x, k, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covPC_+3A_x">x</code></td>
<td>
<p> an object of class princomp. </p>
</td></tr>
<tr><td><code id="covPC_+3A_k">k</code></td>
<td>
<p> number of PCs to use for covariance estimation (optional). </p>
</td></tr>
<tr><td><code id="covPC_+3A_method">method</code></td>
<td>
<p> method how the PCs have been estimated (optional). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several possibilities to estimate the principal components (PCs)
from an input data matrix, including the functions <code><a href="#topic+PCAproj">PCAproj</a></code> and 
<code><a href="#topic+PCAgrid">PCAgrid</a></code>. This function uses the estimated PCs to reconstruct
the covariance matrix. Not all PCs have to be used, the number k of
PCs (first k PCs) can be given as input to the function.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cov</code></td>
<td>
<p> the estimated covariance matrix</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p> the center of the data, as provided from the princomp object.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> a string describing the method that was used to calculate the
PCs.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt; </p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+PCAgrid">PCAgrid</a></code>, <code><a href="#topic+PCAproj">PCAproj</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
             rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
  pc &lt;- princomp(x)
  covPC(pc, k=2)
</code></pre>

<hr>
<h2 id='covPCA'> Robust Covariance Matrix Estimation </h2><span id='topic+covPCAproj'></span><span id='topic+covPCAgrid'></span>

<h3>Description</h3>

<p>computes the robust covariance matrix using the <code>PCAgrid</code> and 
<code>PCAproj</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covPCAproj(x, control)
covPCAgrid(x, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covPCA_+3A_x">x</code></td>
<td>
<p> a numeric matrix or data frame which provides the data. </p>
</td></tr>
<tr><td><code id="covPCA_+3A_control">control</code></td>
<td>
<p> a list whose elements must be the same as (or a subset of) 
the parameters of the appropriate PCA function (<code><a href="#topic+PCAgrid">PCAgrid</a></code> or 
<code><a href="#topic+PCAproj">PCAproj</a></code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>covPCAproj</code> and <code>covPCAgrid</code> use the functions
<code><a href="#topic+PCAproj">PCAproj</a></code> and <code><a href="#topic+PCAgrid">PCAgrid</a></code> respectively to estimate 
the covariance matrix of the data matrix <code>x</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cov</code></td>
<td>
<p> the actual covariance matrix estimated from <code>x</code></p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p> the center of the data <code>x</code> that was substracted from them
before the PCA algorithms were run.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> a string describing the method that was used to calculate the
covariance matrix estimation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt; </p>


<h3>References</h3>

 
<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis, 
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+PCAgrid">PCAgrid</a></code>, <code><a href="#topic+ScaleAdv">ScaleAdv</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
             rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
  covPCAproj(x)
  # compare with classical covariance matrix:
  cov(x)
</code></pre>

<hr>
<h2 id='data.Zou'> Test Data Generation for Sparse PCA examples </h2><span id='topic+data.Zou'></span>

<h3>Description</h3>

<p>Draws a sample data set, as introduced by Zou et al. (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.Zou (n = 250, p =  c(4, 4, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.Zou_+3A_n">n</code></td>
<td>
<p> The required number of observations. </p>
</td></tr>
<tr><td><code id="data.Zou_+3A_p">p</code></td>
<td>
<p> A vector of length 3, specifying how many variables shall be 
constructed using the three factors V1, V2 and V3. </p>
</td></tr>
<tr><td><code id="data.Zou_+3A_...">...</code></td>
<td>
<p> Further arguments passed to or from other functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This data set has been introduced by Zou et al. (2006), and then been referred 
to several times, e.g. by Farcomeni (2009), Guo et al. (2010) and 
Croux et al. (2011).
</p>
<p>The data set contains two latent factors V1 ~ N(0, 290) and V2 ~ N(0, 300) and 
a third mixed component V3 = -0.3 V1 + 0.925V2 + e; e ~ N(0, 1).<br />
The ten variables Xi of the original data set are constructed the following 
way:<br />
Xi = V1 + ei; i = 1, 2, 3, 4<br />
Xi = V2 + ei; i = 5, 6, 7, 8<br />
Xi = V3 + ei; i = 9, 10<br />
whereas ei ~ N(0, 1) is indepependent for i = 1 , ..., 10
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>n x sum (p)</code> containing the generated sample data 
set.
</p>


<h3>Author(s)</h3>

<p>Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, H. Fritz (2011).
Robust Sparse Principal Component Analysis Based on Projection-Pursuit,
<em>??</em> To appear.
</p>
<p>A. Farcomeni (2009).
An exact approach to sparse principal component analysis,
<em>Computational Statistics</em>, Vol. 24(4), pp. 583-604.
</p>
<p>J. Guo, G.  James, E. Levina, F. Michailidis, and J. Zhu (2010).
Principal component analysis with sparse fused loadings,
<em>Journal of Computational and Graphical Statistics.</em> To appear.
</p>
<p>H. Zou, T. Hastie, R. Tibshirani (2006). 
Sparse principal component analysis,
<em>Journal of Computational and Graphical Statistics</em>, Vol. 15(2), pp. 265-286.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sPCAgrid">sPCAgrid</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>                   ##  data generation
  set.seed (0)
  x &lt;- data.Zou ()

                   ##  applying PCA
  pc &lt;-  princomp (x)
                   ##  the corresponding non-sparse loadings
  unclass (pc$load[,1:3])
  pc$sdev[1:3]

                   ##  lambda as calculated in the opt.TPO - example
  lambda &lt;- c (0.23, 0.34, 0.005)
                   ##  applying sparse PCA
  spc &lt;- sPCAgrid (x, k = 3, lambda = lambda, method = "sd")
  unclass (spc$load)
  spc$sdev[1:3]

                   ## comparing the non-sparse and sparse biplot
  par (mfrow = 1:2)
  biplot (pc, main = "non-sparse PCs")
  biplot (spc, main = "sparse PCs")
</code></pre>

<hr>
<h2 id='l1median'> Multivariate L1 Median </h2><span id='topic+l1median'></span>

<h3>Description</h3>

<p>Computes the multivariate L1 median (also called spatial median) of a data matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l1median(X, MaxStep = 200, ItTol = 10^-8, trace = 0, m.init = .colMedians (X))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l1median_+3A_x">X</code></td>
<td>
<p> A matrix containing the values whose multivariate L1 median is to be computed. </p>
</td></tr>
<tr><td><code id="l1median_+3A_maxstep">MaxStep</code></td>
<td>
<p> The maximum number of iterations. </p>
</td></tr>
<tr><td><code id="l1median_+3A_ittol">ItTol</code></td>
<td>
<p> Tolerance for convergence of the algorithm.</p>
</td></tr>
<tr><td><code id="l1median_+3A_trace">trace</code></td>
<td>
<p> The tracing level. </p>
</td></tr>
<tr><td><code id="l1median_+3A_m.init">m.init</code></td>
<td>
<p> An initial estimate. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the vector of the coordinates of the L1 median.
</p>


<h3>Author(s)</h3>

<p>Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+median">median</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  l1median(rnorm(100), trace = -1) # this returns the median of the sample

  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 4), diag(c(1, 1, 2, 2))), 
             rmvnorm( 50, rep(3, 4), diag(rep(2, 4))))
  l1median(x, trace = -1)
  # compare with coordinate-wise median:
  apply(x,2,median)
</code></pre>

<hr>
<h2 id='l1median_NLM'> Multivariate L1 Median </h2><span id='topic+l1median_NM'></span><span id='topic+l1median_CG'></span><span id='topic+l1median_BFGS'></span><span id='topic+l1median_NLM'></span><span id='topic+l1median_HoCr'></span><span id='topic+l1median_VaZh'></span>

<h3>Description</h3>

<p>Computes the multivariate L1 median (also called spatial median) of a data matrix <code>X</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l1median_NM (X, maxit = 200, tol = 10^-8, trace = 0,
             m.init = .colMedians (X), ...)
l1median_CG (X, maxit = 200, tol = 10^-8, trace = 0,
             m.init = .colMedians (X), ...)
l1median_BFGS (X, maxit = 200, tol = 10^-8, trace = 0,
               m.init = .colMedians (X), REPORT = 10, ...)
l1median_NLM (X, maxit = 200, tol = 10^-8, trace = 0,
              m.init = .colMedians (X), ...)
l1median_HoCr (X, maxit = 200, tol = 10^-8, zero.tol = 1e-15, trace = 0,
               m.init = .colMedians (X), ...)
l1median_VaZh (X, maxit = 200, tol = 10^-8, zero.tol = 1e-15, trace = 0,
	       m.init = .colMedians (X), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="l1median_NLM_+3A_x">X</code></td>
<td>
<p> a matrix of dimension <code>n</code> x <code>p</code>.</p>
</td></tr>
<tr><td><code id="l1median_NLM_+3A_maxit">maxit</code></td>
<td>
<p> The maximum number of iterations to be performed. </p>
</td></tr>
<tr><td><code id="l1median_NLM_+3A_tol">tol</code></td>
<td>
<p> The convergence tolerance. </p>
</td></tr>
<tr><td><code id="l1median_NLM_+3A_trace">trace</code></td>
<td>
<p> The tracing level. Set <code>trace &gt; 0</code> to retrieve additional information on the single iterations. </p>
</td></tr>
<tr><td><code id="l1median_NLM_+3A_m.init">m.init</code></td>
<td>
<p> A vector of length <code>p</code> containing the initial value of the L1-median. </p>
</td></tr>
<tr><td><code id="l1median_NLM_+3A_report">REPORT</code></td>
<td>
<p> A parameter internally passed to <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</td></tr>
<tr><td><code id="l1median_NLM_+3A_zero.tol">zero.tol</code></td>
<td>
<p> The zero-tolerance level used in <code>l1median_VaZh</code> and <code>l1median_HoCr</code> for determining the equality of two observations (i.e. an observation and a current center estimate). </p>
</td></tr>
<tr><td><code id="l1median_NLM_+3A_...">...</code></td>
<td>
<p> Further parameters passed from other functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The L1-median is computed using the built-in functions 
<code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+nlm">nlm</a></code>. 
These functions are a transcript of the <code>L1median</code> 
method of package <code>robustX</code>, porting as much code as possible into C++.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p> A vector of length <code>p</code> containing the L1-median. </p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p> The value of the objective function <code>||X - l1median||</code> which is minimized for finding the L1-median. </p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p> The return code of the optimization algorithm. See <code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+nlm">nlm</a></code> for further information. </p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p> The number of iterations performed. </p>
</td></tr>
<tr><td><code>iterations_gr</code></td>
<td>
<p> When using a gradient function this value holds the number of times the gradient had to be computed. </p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>The algorithms runtime in milliseconds.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See the vignette &quot;Compiling pcaPP for Matlab&quot; which comes with this package to compile and use some of these functions in Matlab.</p>


<h3>Author(s)</h3>

<p>Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+median">median</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 4), diag(c(1, 1, 2, 2))), 
             rmvnorm( 50, rep(3, 4), diag(rep(2, 4))))

  l1median_NM (x)$par
  l1median_CG (x)$par
  l1median_BFGS (x)$par
  l1median_NLM (x)$par
  l1median_HoCr (x)$par
  l1median_VaZh (x)$par

  # compare with coordinate-wise median:
  apply(x,2,median)
</code></pre>

<hr>
<h2 id='objplot'> Objective Function Plot for Sparse PCs </h2><span id='topic+objplot'></span>

<h3>Description</h3>

<p>Plots an objective function (TPO or BIC) of one or more sparse PCs for a 
series of lambdas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  objplot (x, k, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="objplot_+3A_x">x</code></td>
<td>
<p> An <code><a href="#topic+opt.TPO">opt.TPO</a></code> or <code><a href="#topic+opt.BIC">opt.BIC</a></code> object. </p>
</td></tr>
<tr><td><code id="objplot_+3A_k">k</code></td>
<td>
<p> This function displays the objective function's values of the 
<code>k</code>-th component for <code>opt.TPO</code>-objects, or the first 
<code>k</code> components for <code>opt.BIC</code>-objects.
</p>
</td></tr>
<tr><td><code id="objplot_+3A_...">...</code></td>
<td>
<p> Further arguments passed to or from other functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function operates on the return object of function
<code><a href="#topic+opt.TPO">opt.TPO</a></code> or <code><a href="#topic+opt.BIC">opt.BIC</a></code>.
The model (<code>lambda</code>) selected by the minimization of the corresponding 
criterion is highlighted by a dashed vertical line.
</p>
<p>The component the argument <code>k</code> refers to, corresponds to the 
<code>$pc.noord</code> item of argument <code>x</code>.
For more info on the order of sparse PCs see the details section of 
<code><a href="#topic+opt.TPO">opt.TPO</a></code>.
</p>


<h3>Author(s)</h3>

<p>Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, H. Fritz (2011).
Robust Sparse Principal Component Analysis Based on Projection-Pursuit,
<em>??</em> To appear.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sPCAgrid">sPCAgrid</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  set.seed (0)
                      ##  generate test data
  x &lt;- data.Zou (n = 250)

  k.max &lt;- 3          ##  max number of considered sparse PCs

                      ##  arguments for the sPCAgrid algorithm
  maxiter &lt;- 25       ##    the maximum number of iterations
  method &lt;- "sd"      ##    using classical estimations

                      ##  Optimizing the TPO criterion
  oTPO &lt;- opt.TPO (x, k.max = k.max, method = method, maxiter = maxiter)

                      ##  Optimizing the BIC criterion
  oBIC &lt;- opt.BIC (x, k.max = k.max, method = method, maxiter = maxiter)

          ##  Objective function vs. lambda
  par (mfrow = c (2, k.max))
  for (i in 1:k.max)        objplot (oTPO, k = i)
  for (i in 1:k.max)        objplot (oBIC, k = i)
</code></pre>

<hr>
<h2 id='opt.TPO'> Model Selection for Sparse (Robust) Principal Components </h2><span id='topic+opt.TPO'></span><span id='topic+opt.BIC'></span>

<h3>Description</h3>

<p>These functions compute a suggestion for the sparseness parameter 
<code>lambda</code> which is required by function <code><a href="#topic+sPCAgrid">sPCAgrid</a></code>.
A range of different values for lambda is tested and 
according to an objective function, the best solution is selected.
Two different approaches (TPO and BIC) are available, which is further 
discussed in the details section.
A graphical summary of the optimization can be obtained by plotting 
the function's return value (<code><a href="#topic+plot.opt.TPO">plot.opt.TPO</a></code>, 
<code><a href="#topic+plot.opt.BIC">plot.opt.BIC</a></code> for tradeoff curves or <code><a href="#topic+objplot">objplot</a></code>
for an objective function plot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  opt.TPO (x, k.max = ncol (x), n.lambda = 30, lambda.max, ...)
  opt.BIC (x, k.max = ncol (x), n.lambda = 30, lambda.max, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.TPO_+3A_x">x</code></td>
<td>
<p> a numerical matrix or data frame of dimension (<code>n x p</code>), 
which provides the data for the principal components analysis. </p>
</td></tr>
<tr><td><code id="opt.TPO_+3A_k.max">k.max</code></td>
<td>
<p> the maximum number of components which shall be considered
for optimizing an objective function (optional). </p>
</td></tr>
<tr><td><code id="opt.TPO_+3A_n.lambda">n.lambda</code></td>
<td>
<p> the number of lambdas to be checked for each component 
(optional). </p>
</td></tr>
<tr><td><code id="opt.TPO_+3A_lambda.max">lambda.max</code></td>
<td>
<p> the maximum value of lambda to be checked (optional).
If omitted, the lambda which yields &quot;full sparseness&quot; (i.e. loadings of 
only zeros and ones) is computed and used as default value. </p>
</td></tr>
<tr><td><code id="opt.TPO_+3A_...">...</code></td>
<td>
<p> further arguments passed to <code><a href="#topic+sPCAgrid">sPCAgrid</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The choice for a particular lambda is done by optimizing an objective function, 
which is calculated for a set of <code>n.lambda</code> models with different 
lambdas, ranging from 0 to <code>lambda.max</code>. If <code>lambda.max</code> is not 
specified, the minimum lambda yielding &quot;full sparseness&quot; is used.
&quot;Full sparseness&quot; refers to a model with minimum possible absolute sum of 
loadings, which in general implies only zeros and ones in the loadings matrix.
</p>
<p>The user can choose between two optimization methods: 
TPO (Tradeoff Product Optimization; see below), or the 
BIC (see Guo et al., 2011; Croux et al., 2011).
The main difference is, that optimization based on the BIC always chooses the 
same lambda for all PCs, and refers to a particular choice of <code>k</code>, 
the number of considered components.
TPO however is optimized separately for each component, and so delivers 
different lambdas within a model and does not depend on a decision on <code>k</code>.
<br />
This characteristic can be noticed in the return value of the function:
<code><a href="#topic+opt.TPO">opt.TPO</a></code> returns a single model with <code>k.max</code> PCs and 
different values of <code>lambda</code> for each PC. 
On the contrary <code><a href="#topic+opt.BIC">opt.BIC</a></code> returns <code>k.max</code> distinct models 
with <code>k.max</code> different lambdas, whereas for each model a different
number of components <code>k</code> has been considered for the optimization.
Applying the latter method, the user finally has to select one of these 
<code>k.max</code> models manually, 
e.g. by considering the cumulated explained variance,
whereas the TPO method does not require any further decisions.
</p>
<p>The tradeoff made in the context of sparse PCA refers to the loss of explained
variance vs. the gain of sparseness. TPO (Tradeoff Product Optimization) 
maximizes the area under the tradeoff curve (see <code><a href="#topic+plot.opt.TPO">plot.opt.TPO</a></code>),
in particular it maximizes the explained variance multiplied by the number of 
zero loadings of a particular component. As in this context the according 
criterion is minimized, the negative product is considered.
</p>
<p>Note that in the context of sparse PCA, there are two sorting orders of PCs, 
which must be considered: Either according to the objective function's value, 
(item <code>$pc.noord</code>)or the variance of each PC(item <code>$pc</code>).
As in none-sparse PCA the objective function is identical to the PCs' 
variance, this is not an issue there.<br />
The sPCAgrid algorithm delivers the components in decreasing order, according 
to the objective function (which apart from the variance also includes sparseness
terms), whereas the method <code><a href="#topic+sPCAgrid">sPCAgrid</a></code> subsequently re-orders the 
components according to their explained variance.
</p>


<h3>Value</h3>

<p>The functions return an S3 object of type &quot;opt.TPO&quot; or &quot;opt.BIC&quot; respectively, 
containing the following items:
</p>
<table role = "presentation">
<tr><td><code>pc</code></td>
<td>

<p>An S3 object of type <code>princomp</code> (<code><a href="#topic+opt.TPO">opt.TPO</a></code>), or a list of 
such objects of length <code>k.max</code> (<code><a href="#topic+opt.BIC">opt.BIC</a></code>), 
as returned by <code><a href="#topic+sPCAgrid">sPCAgrid</a></code>.</p>
</td></tr>
<tr><td><code>pc.noord</code></td>
<td>
<p>An S3 object of type <code>princomp</code> (<code><a href="#topic+opt.TPO">opt.TPO</a></code>), 
or a list of such objects of length <code>k.max</code> (<code><a href="#topic+opt.BIC">opt.BIC</a></code>), 
as returned by <code><a href="#topic+sPCAgrid">sPCAgrid</a></code>.<br />
Here the PCs have not been re-ordered according 
to their variance, but are still ordered according to their objective 
function's value
as returned by the <code><a href="#topic+sPCAgrid">sPCAgrid</a></code> - algorithm.
This information is used for according tradeoff curves and the objective 
function plot.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> The input data matrix as provided by the user. </p>
</td></tr>
<tr><td><code>k.ini</code>, <code>opt</code></td>
<td>
<p> These items contain optimization information, as used in 
functions <code><a href="#topic+plot.opt.TPO">plot.opt.TPO</a></code>, <code><a href="#topic+plot.opt.BIC">plot.opt.BIC</a></code> and 
<code><a href="#topic+objplot">objplot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, H. Fritz (2011).
Robust Sparse Principal Component Analysis Based on Projection-Pursuit,
<em>??</em> To appear.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sPCAgrid">sPCAgrid</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  set.seed (0)
                      ##  generate test data
  x &lt;- data.Zou (n = 250)

  k.max &lt;- 3          ##  max number of considered sparse PCs

                      ##  arguments for the sPCAgrid algorithm
  maxiter &lt;- 25       ##    the maximum number of iterations
  method &lt;- "sd"      ##    using classical estimations

                      ##  Optimizing the TPO criterion
  oTPO &lt;- opt.TPO (x, k.max = k.max, method = method, maxiter = maxiter)

  oTPO$pc             ##  the model selected by opt.TPO
  oTPO$pc$load        ##  and the according sparse loadings.

                      ##  Optimizing the BIC criterion
  oBIC &lt;- opt.BIC (x, k.max = k.max, method = method, maxiter = maxiter)

  oBIC$pc[[1]]        ##  the first model selected by opt.BIC (k = 1)

          ##  Tradeoff Curves: Explained Variance vs. sparseness
  par (mfrow = c (2, k.max))
  for (i in 1:k.max)        plot (oTPO, k = i)
  for (i in 1:k.max)        plot (oBIC, k = i)

          ##  Tradeoff Curves: Explained Variance vs. lambda
  par (mfrow = c (2, k.max))
  for (i in 1:k.max)        plot (oTPO, k = i, f.x = "lambda")
  for (i in 1:k.max)        plot (oBIC, k = i, f.x = "lambda")

          ##  Objective function vs. lambda
  par (mfrow = c (2, k.max))
  for (i in 1:k.max)        objplot (oTPO, k = i)
  for (i in 1:k.max)        objplot (oBIC, k = i)
</code></pre>

<hr>
<h2 id='PCAgrid'> (Sparse) Robust Principal Components using the Grid search algorithm </h2><span id='topic+PCAgrid'></span><span id='topic+sPCAgrid'></span>

<h3>Description</h3>

<p>Computes a desired number of (sparse) (robust) principal components using 
the grid search algorithm in the plane.
The global optimum of the objective function is searched in planes, not in
the p-dimensional space, using regular grids in these planes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCAgrid (x, k = 2, method = c ("mad", "sd", "qn"),
         maxiter = 10, splitcircle = 25, scores = TRUE, zero.tol = 1e-16, 
	 center = l1median, scale, trace = 0, store.call = TRUE, control, ...)

sPCAgrid (x, k = 2, method = c ("mad", "sd", "qn"), lambda = 1,
          maxiter = 10, splitcircle = 25, scores = TRUE, zero.tol = 1e-16, 
	  center = l1median, scale, trace = 0, store.call = TRUE, control, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCAgrid_+3A_x">x</code></td>
<td>
<p> a numerical matrix or data frame of dimension (<code>n x p</code>)which 
provides the data for the principal components analysis. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_k">k</code></td>
<td>
<p> the desired number of components to compute </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_method">method</code></td>
<td>
<p> the scale estimator used to detect the direction with the 
largest variance. Possible values are <code>"sd"</code>, <code>"mad"</code> and 
<code>"qn"</code>, the  latter can be called <code>"Qn"</code> too. <code>"mad"</code> is the 
default value.</p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_lambda">lambda</code></td>
<td>
<p> the sparseness constraint's strength(<code>sPCAgrid</code> only).
A single value for all components, or a vector of length <code>k</code> with 
different values for each component can be specified.
See <code><a href="#topic+opt.TPO">opt.TPO</a></code> for the choice of this argument. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_splitcircle">splitcircle</code></td>
<td>
<p> the number of directions in which the algorithm should
search for the largest variance. The direction with the largest variance
is searched for in the directions defined by a number of equally spaced points
on the unit circle. This argument determines, how many such points are used to
split the unit circle. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_scores">scores</code></td>
<td>
<p> A logical value indicating whether the scores of the
principal component should be calculated. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_zero.tol">zero.tol</code></td>
<td>
<p> the zero tolerance used internally for checking 
convergence, etc. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_center">center</code></td>
<td>
<p> this argument indicates how the data is to be centered. It
can be a function like <code><a href="base.html#topic+mean">mean</a></code> or <code><a href="stats.html#topic+median">median</a></code> or a vector
of length <code>ncol(x)</code> containing the center value of each column. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_scale">scale</code></td>
<td>
<p> this argument indicates how the data is to be rescaled. It
can be a function like <code><a href="stats.html#topic+sd">sd</a></code> or <code><a href="stats.html#topic+mad">mad</a></code> or a vector
of length <code>ncol(x)</code> containing the scale value of each column. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_trace">trace</code></td>
<td>
<p> an integer value &gt;= 0, specifying the tracing level. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_store.call">store.call</code></td>
<td>
<p> a logical variable, specifying whether the function call
shall be stored in the result structure. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_control">control</code></td>
<td>
<p> a list which elements must be the same as (or a subset of) 
the parameters above. If the control object is supplied, the parameters from 
it will be used and any other given parameters are overridden. </p>
</td></tr>
<tr><td><code id="PCAgrid_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to <code>PCAgrid</code>, the function <code>sPCAgrid</code> computes sparse
principal components. The strength of the applied sparseness constraint is
specified by argument <code>lambda</code>.


</p>
<p>Similar to the function <code><a href="stats.html#topic+princomp">princomp</a></code>, there is a <code>print</code> method 
for the these objects that prints the results in a nice format and the 
<code>plot</code> method produces a scree plot (<code><a href="stats.html#topic+screeplot">screeplot</a></code>). There is 
also a <code>biplot</code> method.
</p>
<p>Angle halving is an extension of the original algorithm. In the original 
algorithm, the search directions are determined by a number of points on the
unit circle in the interval [-pi/2 ; pi/2). Angle halving means this angle is
halved in each iteration, eg. for the first approximation, the above mentioned
angle is used, for the second approximation, the angle is halved to 
[-pi/4 ; pi/4) and so on. This usually gives better results with less 
iterations needed. <br />
NOTE: in previous implementations angle halving could be suppressed by the 
former argument &quot;<code>anglehalving</code>&quot;. This still can be done by setting 
argument <code>maxiter = 0</code>.
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>"princomp"</code>, i.e. a list 
similar to the output of the function <code><a href="stats.html#topic+princomp">princomp</a></code>.
</p>
<table role = "presentation">
<tr><td><code>sdev</code></td>
<td>
<p>the (robust) standard deviations of the principal components.</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>the matrix of variable loadings (i.e., a matrix whose columns
contain the eigenvectors).  This is of class <code>"loadings"</code>:
see <code><a href="stats.html#topic+loadings">loadings</a></code> for its <code><a href="base.html#topic+print">print</a></code> method.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>the means that were subtracted.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scalings applied to each variable.</p>
</td></tr>
<tr><td><code>n.obs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>if <code>scores = TRUE</code>, the scores of the supplied data on the
principal components.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>A vector containing the objective functions values. For function
<code>PCAgrid</code> this is the same as <code>sdev</code>. </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The lambda each component has been calculated with 
(<code><a href="#topic+sPCAgrid">sPCAgrid</a></code> only).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>See the vignette &quot;Compiling pcaPP for Matlab&quot; which comes with this package to compile and use these functions in Matlab.</p>


<h3>Author(s)</h3>

<p>Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>
<p>C. Croux, P. Filzmoser, H. Fritz (2011).
Robust Sparse Principal Component Analysis Based on Projection-Pursuit,
<em>??</em> To appear.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+PCAproj">PCAproj</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
             rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
  # Here we calculate the principal components with PCAgrid
  pc &lt;- PCAgrid(x)
  # we could draw a biplot too:
  biplot(pc)
  # now we want to compare the results with the non-robust principal components
  pc &lt;- princomp(x)
  # again, a biplot for comparison:
  biplot(pc)

  ##  Sparse loadings
  set.seed (0)
  x &lt;- data.Zou ()

                   ##  applying PCA
  pc &lt;-  princomp (x)
                   ##  the corresponding non-sparse loadings
  unclass (pc$load[,1:3])
  pc$sdev[1:3]

                   ##  lambda as calculated in the opt.TPO - example
  lambda &lt;- c (0.23, 0.34, 0.005)
                   ##  applying sparse PCA
  spc &lt;- sPCAgrid (x, k = 3, lambda = lambda, method = "sd")
  unclass (spc$load)
  spc$sdev[1:3]

                   ## comparing the non-sparse and sparse biplot
  par (mfrow = 1:2)
  biplot (pc, main = "non-sparse PCs")
  biplot (spc, main = "sparse PCs")
</code></pre>

<hr>
<h2 id='PCAproj'> Robust Principal Components using the algorithm of Croux and Ruiz-Gazen (2005) </h2><span id='topic+PCAproj'></span>

<h3>Description</h3>

<p>Computes a desired number of (robust) principal components using the algorithm of 
Croux and Ruiz-Gazen (JMVA, 2005). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCAproj(x, k = 2, method = c("mad", "sd", "qn"), CalcMethod = c("eachobs",
"lincomb", "sphere"), nmax = 1000, update = TRUE, scores = TRUE, maxit = 5, 
maxhalf = 5, scale = NULL, center = l1median_NLM, zero.tol = 1e-16, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCAproj_+3A_x">x</code></td>
<td>
<p> a numeric matrix or data frame which provides the data for the 
principal components analysis. </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_k">k</code></td>
<td>
<p> desired number of components to compute </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_method">method</code></td>
<td>
<p> scale estimator used to detect the direction with the largest 
variance. Possible values are <code>"sd"</code>, <code>"mad"</code> and <code>"qn"</code>, the 
latter can be called <code>"Qn"</code> too. <code>"mad"</code> is the default value.</p>
</td></tr>
<tr><td><code id="PCAproj_+3A_calcmethod">CalcMethod</code></td>
<td>
<p> the variant of the algorithm to be used. Possible values are
<code>"eachobs"</code>, <code>"lincomb"</code> and <code>"sphere"</code>, with <code>"eachobs"</code> being 
the default. </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_nmax">nmax</code></td>
<td>
<p> maximum number of directions to search in each step (only when
using <code>"sphere"</code> or <code>"lincomb"</code> as the <code>CalcMethod</code>). </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_update">update</code></td>
<td>
<p> a logical value indicating whether an update algorithm should be 
used.</p>
</td></tr>
<tr><td><code id="PCAproj_+3A_scores">scores</code></td>
<td>
<p> a logical value indicating whether the scores of the
principal component should be calculated. </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_maxit">maxit</code></td>
<td>
<p> maximim number of iterations. </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_maxhalf">maxhalf</code></td>
<td>
<p> maximum number of steps for angle halving. </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_scale">scale</code></td>
<td>
<p> this argument indicates how the data is to be rescaled. It
can be a function like <code><a href="stats.html#topic+sd">sd</a></code> or <code><a href="stats.html#topic+mad">mad</a></code> or a vector
of length <code>ncol(x)</code> containing the scale value of each column. </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_center">center</code></td>
<td>
<p> this argument indicates how the data is to be centered. It
can be a function like <code><a href="base.html#topic+mean">mean</a></code> or <code><a href="stats.html#topic+median">median</a></code> or a vector
of length <code>ncol(x)</code> containing the center value of each column. </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_zero.tol">zero.tol</code></td>
<td>
<p> the zero tolerance used internally for checking 
convergence, etc. </p>
</td></tr>
<tr><td><code id="PCAproj_+3A_control">control</code></td>
<td>
<p> a list which elements must be the same as (or a subset of) 
the parameters above. If the control object is supplied, the parameters from 
it will be used and any other given parameters are overridden. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, this algrithm considers the directions of each observation 
through the origin of the centered data as possible projection directions.
As this algorithm has some drawbacks, especially if <code>ncol(x) &gt; nrow(x)</code>
in the data matrix, there are several improvements that can be used with this
algorithm.
</p>

<ul>
<li><p> update - An updating step basing on the algorithm for finding the
eigenvectors is added to the algorithm. This can be used with any 
<code>CalcMethod</code>
</p>
</li>
<li><p> sphere - Additional search directions are added using random directions.
The random directions are determined using random data points generated from 
a p-dimensional multivariate standard normal distribution. These new data 
points are projected to the unit sphere, giving the new search directions.
</p>
</li>
<li><p> lincomb - Additional search directions are added using linear 
combinations of the observations. It is similar to the 
<code>"sphere"</code> - algorithm, but the new data points are generated using linear 
combinations of the original data <code>b_1*x_1 + ... + b_n*x_n</code> where the 
coefficients <code>b_i</code> come from a uniform distribution in the interval 
<code>[0, 1]</code>.
</p>
</li></ul>

<p>Similar to the function <code><a href="stats.html#topic+princomp">princomp</a></code>, there is a <code>print</code> method 
for the these objects that prints the results in a nice format and the <code>plot</code> 
method produces a scree plot (<code><a href="stats.html#topic+screeplot">screeplot</a></code>). There is also a 
<code><a href="stats.html#topic+biplot">biplot</a></code> method.
</p>


<h3>Value</h3>

<p>The function returns a list of class <code>"princomp"</code>, i.e. a list similar to the 
output of the function <code><a href="stats.html#topic+princomp">princomp</a></code>.
</p>
<table role = "presentation">
<tr><td><code>sdev</code></td>
<td>
<p>the (robust) standard deviations of the principal components.</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>the matrix of variable loadings (i.e., a matrix whose columns
contain the eigenvectors).  This is of class <code>"loadings"</code>:
see <code><a href="stats.html#topic+loadings">loadings</a></code> for its <code><a href="base.html#topic+print">print</a></code> method.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>the means that were subtracted.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scalings applied to each variable.</p>
</td></tr>
<tr><td><code>n.obs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>if <code>scores = TRUE</code>, the scores of the supplied data on the
principal components.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+PCAgrid">PCAgrid</a></code>, <code><a href="#topic+ScaleAdv">ScaleAdv</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
             rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
  # Here we calculate the principal components with PCAgrid
  pc &lt;- PCAproj(x, 6)
  # we could draw a biplot too:
  biplot(pc)

  # we could use another calculation method and another objective function, and 
  # maybe only calculate the first three principal components:
  pc &lt;- PCAproj(x, 3, "qn", "sphere")
  biplot(pc)

  # now we want to compare the results with the non-robust principal components
  pc &lt;- princomp(x)
  # again, a biplot for comparision:
  biplot(pc)
</code></pre>

<hr>
<h2 id='PCdiagplot'>Diagnostic plot for principal components</h2><span id='topic+PCdiagplot'></span>

<h3>Description</h3>

<p>Computes Orthogonal Distances (OD) and Score Distances (SD) for already computed principal components
using the projection pursuit technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCdiagplot(x, PCobj, crit = c(0.975, 0.99, 0.999), ksel = NULL, plot = TRUE,
           plotbw = TRUE, raw = FALSE, colgrid = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCdiagplot_+3A_x">x</code></td>
<td>
<p> a numeric matrix or data frame which provides the data for the
principal components analysis. </p>
</td></tr>
<tr><td><code id="PCdiagplot_+3A_pcobj">PCobj</code></td>
<td>
<p> a PCA object resulting from <code><a href="#topic+PCAproj">PCAproj</a></code> or <code><a href="#topic+PCAgrid">PCAgrid</a></code> </p>
</td></tr>
<tr><td><code id="PCdiagplot_+3A_crit">crit</code></td>
<td>
<p> quantile(s) used for the critical value(s) for OD and SD </p>
</td></tr>
<tr><td><code id="PCdiagplot_+3A_ksel">ksel</code></td>
<td>
<p> range for the number of PCs to be used in the plot; if NULL all PCs provided are used </p>
</td></tr>
<tr><td><code id="PCdiagplot_+3A_plot">plot</code></td>
<td>
<p> if TRUE a plot is generated, otherwise only the values are returned </p>
</td></tr>
<tr><td><code id="PCdiagplot_+3A_plotbw">plotbw</code></td>
<td>
<p> if TRUE the plot uses gray, otherwise color representation </p>
</td></tr>
<tr><td><code id="PCdiagplot_+3A_raw">raw</code></td>
<td>
<p> if FALSE, the distribution of the SD will be transformed to approach chisquare 
distribution, otherwise the raw values are reported and used for plotting </p>
</td></tr>
<tr><td><code id="PCdiagplot_+3A_colgrid">colgrid</code></td>
<td>
<p> the color used for the grid lines in the plot </p>
</td></tr>
<tr><td><code id="PCdiagplot_+3A_...">...</code></td>
<td>
<p> additional graphics parameters as used in <code><a href="graphics.html#topic+par">par</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on (robust) principal components, a diagnostics plot is made using Orthogonal Distance (OD)
and Score Distance (SD). This plot can provide important information about the multivariate
data structure.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ODist</code></td>
<td>
<p>matrix with OD for each observation (rows) and each selected PC (cols) </p>
</td></tr>
<tr><td><code>SDist</code></td>
<td>
<p>matrix with SD for each observation (rows) and each selected PC (cols) </p>
</td></tr>
<tr><td><code>critOD</code></td>
<td>
<p>matrix with critical values for OD for each selected PC (rows) and each
critical value (cols) </p>
</td></tr>
<tr><td><code>critSD</code></td>
<td>
<p>matrix with critical values for SD for each selected PC (rows) and each
critical value (cols) </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

 
<p>P. Filzmoser and H. Fritz (2007).
Exploring high-dimensional data with robust principal components.
In  S. Aivazian, P. Filzmoser, and Yu. Kharin, editors, Proceedings of the Eighth 
International Conference on Computer Data Analysis and Modeling, volume 1, pp. 43-50, 
Belarusian State University, Minsk.
</p>
<p>M. Hubert, P.J. Rousseeuwm, K. Vanden Branden (2005).
ROBCA: a new approach to robust principal component analysis
Technometrics 47, pp. 64-79.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCAproj">PCAproj</a></code>, <code><a href="#topic+PCAgrid">PCAgrid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(85, rep(0, 6), diag(c(5, rep(1,5)))),
             rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
  # Here we calculate the principal components with PCAgrid
  pcrob &lt;- PCAgrid(x, k=6)
  resrob &lt;- PCdiagplot(x,pcrob,plotbw=FALSE)

  # compare with classical method:
  pcclass &lt;- PCAgrid(x, k=6, method="sd")
  resclass &lt;- PCdiagplot(x,pcclass,plotbw=FALSE)
</code></pre>

<hr>
<h2 id='plot.opt.TPO'> Tradeoff Curves for Sparse PCs </h2><span id='topic+plot.opt.TPO'></span><span id='topic+plot.opt.BIC'></span>

<h3>Description</h3>

<p>Tradeoff curves of one or more sparse PCs for a series of lambdas, which 
contrast the loss of explained variance and the gain of sparseness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'opt.TPO'
 plot(x, k, f.x = c ("l0", "pl0", "l1", "pl1", "lambda"),
                        f.y = c ("var", "pvar"), ...)
## S3 method for class 'opt.BIC'
 plot(x, k, f.x = c ("l0", "pl0", "l1", "pl1", "lambda"),
                        f.y = c ("var", "pvar"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.opt.TPO_+3A_x">x</code></td>
<td>
<p> An <code><a href="#topic+opt.TPO">opt.TPO</a></code> or <code><a href="#topic+opt.BIC">opt.BIC</a></code> object. </p>
</td></tr>
<tr><td><code id="plot.opt.TPO_+3A_k">k</code></td>
<td>
<p> This function plots the tradeoff curve of the 
<code>k</code>-th component for <code>opt.TPO</code>-objects, or the first 
<code>k</code> components for <code>opt.BIC</code>-objects.
</p>
</td></tr>
<tr><td><code id="plot.opt.TPO_+3A_f.x">f.x</code>, <code id="plot.opt.TPO_+3A_f.y">f.y</code></td>
<td>
<p> A string, specifying which information shall be plotted on the 
x and y - axis. See the details section for more information.</p>
</td></tr>
<tr><td><code id="plot.opt.TPO_+3A_...">...</code></td>
<td>
<p> Further arguments passed to or from other functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>f.x</code> can obtain the following values:
</p>

<ul>
<li> <p><code>"l0"</code>: l0 - sparseness, which corresponds to the number of 
zero loadings of the considered component(s).
</p>
</li>
<li> <p><code>"pl0"</code>: l0 - sparseness in percent (l0 - sparseness 
ranges from <code>0</code> to <code>p-1</code> for each component).
</p>
</li>
<li> <p><code>"l1"</code>: l1 - sparseness, which corresponds to 
the negative sum of absolute 
loadings of the considered component(s).<br />
(The exact value displayed for a single component is
<code>sqrt (p) - S</code>, with <code>S</code> as the the absolute sum of loadings.)
<br />
As this value is a part of the objective function which selects 
the candidate directions within the <code><a href="#topic+sPCAgrid">sPCAgrid</a></code> function,
this option is provided here.
</p>
</li>
<li> <p><code>"pl1"</code> The &quot;l1 - sparseness&quot; in percent (l1 - sparseness 
ranges from <code>0</code> to <code>sqrt (p-1)</code> for each component).
</p>
</li>
<li> <p><code>"lambda"</code>: The lambda used for computing a particular model.
</p>
</li></ul>

<p>The argument <code>f.y</code> can obtain the following values:
</p>

<ul>
<li> <p><code>"var"</code>: The (cumulated) explained variance of the considered
component(s). The value shown here is calculated using the variance 
estimator specified via the <code>method</code> argument of function 
<code><a href="#topic+sPCAgrid">sPCAgrid</a></code>.
</p>
</li>
<li> <p><code>"pvar"</code>: The (cumulated) explained variance of the considered
component(s) in percent. The 100%-level is assumed as the sum of variances 
of all columns of argument <code>x</code>.<br />
Again the same variance estimator is 
used as specified via the <code>method</code> argument of function 
<code><a href="#topic+sPCAgrid">sPCAgrid</a></code>.<br />
</p>
</li></ul>

<p>The subtitle summarizes the result of the applied criterion for selecting a
value of lambda:
</p>

<ul>
<li><p> The name of the applied method (TPO/BIC).
</p>
</li>
<li><p> The selected value of <code>lambda</code> for the <code>k</code>-th component 
(<code><a href="#topic+opt.TPO">opt.TPO</a></code>) or all computed components (<code><a href="#topic+opt.BIC">opt.BIC</a></code>).
</p>
</li>
<li><p> The empirical cumulated variance (ECV) of the first <code>k</code> components 
in percent.
</p>
</li>
<li><p> The obtained l0-sparseness of the first <code>k</code> components.
</p>
</li></ul>

<p>This function operates on the return object of function
<code><a href="#topic+opt.TPO">opt.TPO</a></code> or <code><a href="#topic+opt.BIC">opt.BIC</a></code>.
The model (<code>lambda</code>) selected by the minimization of the corresponding 
criterion is highlighted by a dashed vertical line.
</p>
<p>The component the argument <code>k</code> refers to, corresponds to the 
<code>$pc.noord</code> item of argument <code>x</code>.
For more info on the order of sparse PCs see the details section of 
<code><a href="#topic+opt.TPO">opt.TPO</a></code>.
</p>


<h3>Author(s)</h3>

<p>Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, H. Fritz (2011).
Robust Sparse Principal Component Analysis Based on Projection-Pursuit,
<em>??</em> To appear.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sPCAgrid">sPCAgrid</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  set.seed (0)
                      ##  generate test data
  x &lt;- data.Zou (n = 250)

  k.max &lt;- 3          ##  max number of considered sparse PCs

                      ##  arguments for the sPCAgrid algorithm
  maxiter &lt;- 25       ##    the maximum number of iterations
  method &lt;- "sd"      ##    using classical estimations

                      ##  Optimizing the TPO criterion
  oTPO &lt;- opt.TPO (x, k.max = k.max, method = method, maxiter = maxiter)

                      ##  Optimizing the BIC criterion
  oBIC &lt;- opt.BIC (x, k.max = k.max, method = method, maxiter = maxiter)

          ##  Tradeoff Curves: Explained Variance vs. sparseness
  par (mfrow = c (2, k.max))
  for (i in 1:k.max)        plot (oTPO, k = i)
  for (i in 1:k.max)        plot (oBIC, k = i)

          ##  Explained Variance vs. lambda
  par (mfrow = c (2, k.max))
  for (i in 1:k.max)        plot (oTPO, k = i, f.x = "lambda")
  for (i in 1:k.max)        plot (oBIC, k = i, f.x = "lambda")
</code></pre>

<hr>
<h2 id='plotcov'> Compare two Covariance Matrices in Plots</h2><span id='topic+plotcov'></span>

<h3>Description</h3>

<p>allows a direct comparison of two estimations of the covariance 
matrix (e.g. resulting from covPC) in a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotcov(cov1, cov2, method1, labels1, method2, labels2, ndigits, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotcov_+3A_cov1">cov1</code></td>
<td>
<p> a covariance matrix (from cov, covMcd, covPC, 
covPCAgrid, covPCAproj, etc. </p>
</td></tr>
<tr><td><code id="plotcov_+3A_cov2">cov2</code></td>
<td>
<p> a covariance matrix (from cov, covMcd, covPC, 
covPCAgrid, covPCAproj, etc. </p>
</td></tr>
<tr><td><code id="plotcov_+3A_method1">method1</code></td>
<td>
<p> legend for ellipses of estimation method1</p>
</td></tr>
<tr><td><code id="plotcov_+3A_method2">method2</code></td>
<td>
<p> legend for ellipses of estimation method2</p>
</td></tr>
<tr><td><code id="plotcov_+3A_labels1">labels1</code></td>
<td>
<p> legend for numbers of estimation method1</p>
</td></tr>
<tr><td><code id="plotcov_+3A_labels2">labels2</code></td>
<td>
<p> legend for numbers of estimation method2</p>
</td></tr>
<tr><td><code id="plotcov_+3A_ndigits">ndigits</code></td>
<td>
<p> number of digits to use for printing covariances, by default 
ndigits=4</p>
</td></tr>
<tr><td><code id="plotcov_+3A_...">...</code></td>
<td>
<p> additional arguments for text or plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since (robust) PCA can be used to re-compute the (robust) covariance matrix,
one might be interested to compare two different methods of covariance
estimation visually. This routine takes as input objects for the covariances
to compare the output of <code><a href="stats.html#topic+cov">cov</a></code>, but also the return objects 
from <code><a href="#topic+covPCAgrid">covPCAgrid</a></code>, <code><a href="#topic+covPCAproj">covPCAproj</a></code>, <code><a href="#topic+covPC">covPC</a></code>,
and <code><a href="robustbase.html#topic+covMcd">covMcd</a></code>. The comparison of the two covariance matrices
is done by numbers (the covariances) and by ellipses.
</p>


<h3>Value</h3>

<p>only the plot is generated
</p>


<h3>Author(s)</h3>

<p> Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt; </p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+PCAgrid">PCAgrid</a></code>, <code><a href="#topic+PCAproj">PCAproj</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # multivariate data with outliers
  library(mvtnorm)
  x &lt;- rbind(rmvnorm(200, rep(0, 6), diag(c(5, rep(1,5)))),
             rmvnorm( 15, c(0, rep(20, 5)), diag(rep(1, 6))))
  plotcov(covPCAproj(x),covPCAgrid(x))

</code></pre>

<hr>
<h2 id='qn'> scale estimation using the robust Qn estimator </h2><span id='topic+qn'></span>

<h3>Description</h3>

<p>Returns a scale estimation as calculated by the (robust) Qn estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qn(x, corrFact)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qn_+3A_x">x</code></td>
<td>
<p> a vector of data </p>
</td></tr>
<tr><td><code id="qn_+3A_corrfact">corrFact</code></td>
<td>
<p> the finite sample bias correction factor. By default a value of ~ 2.219144 is used (assuming normality). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Qn estimator computes the first quartile of the pairwise absolute 
differences of all data values.
</p>


<h3>Value</h3>

<p>The estimated scale of the data.
</p>


<h3>Warning </h3>

<p>Earlier implementations used a wrong correction factor for the final result. Thus qn estimations computed with package pcaPP version &gt; 1.8-1 differ about 0.12% from earlier estimations (version &lt;= 1.8-1).
</p>


<h3>Note</h3>

<p>See the vignette &quot;Compiling pcaPP for Matlab&quot; which comes with this package to compile and use this function in Matlab.</p>


<h3>Author(s)</h3>

<p> Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

 
<p>P.J. Rousseeuw, C. Croux (1993)
Alternatives to the Median Absolute Deviation,
<em>JASA</em>, <strong>88</strong>, 1273-1283.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+mad">mad</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # data with outliers
  x &lt;- c(rnorm(100), rnorm(10, 10))
  qn(x)
</code></pre>

<hr>
<h2 id='ScaleAdv'> centers and rescales data </h2><span id='topic+ScaleAdv'></span>

<h3>Description</h3>

<p>Data is centered and rescaled (to have mean 0 and a standard deviation of 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScaleAdv(x, center = mean, scale = sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScaleAdv_+3A_x">x</code></td>
<td>
<p> matrix containing the observations. If this is not a matrix, but
a data frame, it is automatically converted into a matrix using the function
<code><a href="base.html#topic+as.matrix">as.matrix</a></code>. In any other case, (eg. a vector) it is converted 
into a matrix with one single column. </p>
</td></tr>
<tr><td><code id="ScaleAdv_+3A_center">center</code></td>
<td>
<p> this argument indicates how the data is to be centered. It 
can be a function like <code><a href="base.html#topic+mean">mean</a></code> or <code><a href="stats.html#topic+median">median</a></code> or a vector
of length <code>ncol(x)</code> containing the center value of each column. </p>
</td></tr>
<tr><td><code id="ScaleAdv_+3A_scale">scale</code></td>
<td>
<p> this argument indicates how the data is to be rescaled. It 
can be a function like <code><a href="stats.html#topic+sd">sd</a></code> or <code><a href="stats.html#topic+mad">mad</a></code> or a vector
of length <code>ncol(x)</code> containing the scale value of each column. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <code>scale</code> being <code>NULL</code> means that no rescaling is done.
</p>


<h3>Value</h3>

<p>The function returns a list containing
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>centered and rescaled data matrix.</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p> a vector of the centers of each column x. If you add to 
each column of <code>x</code> the appropriate value from <code>center</code>, you will obtain
the data with the original location of the observations. </p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p> a vector of the scale factors of each column x. If you multiply 
each column of <code>x</code> by the appropriate value from <code>scale</code>, you will obtain
the data with the original scales. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Heinrich Fritz, Peter Filzmoser &lt;<a href="mailto:P.Filzmoser@tuwien.ac.at">P.Filzmoser@tuwien.ac.at</a>&gt;</p>


<h3>References</h3>

<p>C. Croux, P. Filzmoser, M. Oliveira, (2007).
Algorithms for Projection-Pursuit Robust Principal Component Analysis,
<em>Chemometrics and Intelligent Laboratory Systems</em>, Vol. 87, pp. 218-225.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(100, 10, 5)
  x &lt;- ScaleAdv(x)$x

  # can be used with multivariate data too
  library(mvtnorm)
  x &lt;- rmvnorm(100, 3:7, diag((7:3)^2))
  res &lt;- ScaleAdv(x, center = l1median, scale = mad)
  res

  # instead of using an estimator, you could specify the center and scale yourself too
  x &lt;- rmvnorm(100, 3:7, diag((7:3)^2))
  res &lt;- ScaleAdv(x, 3:7, 7:3)
  res
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
