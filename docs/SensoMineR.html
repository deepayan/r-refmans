<!DOCTYPE html><html><head><title>Help for package SensoMineR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SensoMineR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyse_holos'><p>Analyse Holos data</p></a></li>
<li><a href='#ardi'><p>Automatic Research of DIvergences between scores</p></a></li>
<li><a href='#averagetable'><p>Computes a (products,descriptors) matrix</p></a></li>
<li><a href='#barrow'><p>Barplot per row with respect to a set of quantitative variables</p></a></li>
<li><a href='#boot'><p>Simulate virtual panels for several functions</p></a></li>
<li><a href='#boxprod'><p>Boxplot per category with respect to a categorical variable and a set of quantitative variables</p></a></li>
<li><a href='#CA_JAR'><p>Make a correspondence analysis on the JAR data</p></a></li>
<li><a href='#calculate.average'><p>Calcul de moyenne</p></a></li>
<li><a href='#cards'><p>Cards</p></a></li>
<li><a href='#carto'><p>Preference Mapping Techniques</p></a></li>
<li><a href='#cartoconsumer'><p>Preference Mapping Techniques and segmentation of consumers</p></a></li>
<li><a href='#chocolates'><p>Chocolates data</p></a></li>
<li><a href='#cocktail'><p>Cocktail data</p></a></li>
<li><a href='#coltable'><p>Color the cells of a data frame according to 4 threshold levels</p></a></li>
<li><a href='#compo.cocktail'><p>Composition of the cocktails data</p></a></li>
<li><a href='#ConsensualWords'><p>Consensual words for Sorting Task data</p></a></li>
<li><a href='#ConsistencyIdeal'><p>Sensory and Hedonic consistency of the ideal data</p></a></li>
<li><a href='#construct.axes'><p>Coordinates of individuals and illustrative individuals for PCA or MFA</p></a></li>
<li><a href='#cpa'><p>Consumers' Preferences Analysis</p></a></li>
<li><a href='#cream_id'><p>Cream Ideal Data</p></a></li>
<li><a href='#cream_signa'><p>Data description of the consumers who made the Ideal for the cream</p></a></li>
<li><a href='#decat'><p>DEscription of CATegories</p></a></li>
<li><a href='#fahst'><p>Factorial Approach for Hierarchical Sorting Task data</p></a></li>
<li><a href='#fasnt'><p>Factorial Approach for Sorting Napping Task data</p></a></li>
<li><a href='#fast'><p>Factorial Approach for Sorting Task data</p></a></li>
<li><a href='#fcp'><p>Free choice profiling</p></a></li>
<li><a href='#format_holos'><p>Format Holos data</p></a></li>
<li><a href='#graphinter'><p>Graphical display of the interaction between two qualitative variables</p></a></li>
<li><a href='#hedo.cocktail'><p>Cocktails hedonic scores</p></a></li>
<li><a href='#hedochoc'><p>Chocolates hedonic scores</p></a></li>
<li><a href='#histprod'><p>Histogram for each descriptor</p></a></li>
<li><a href='#hsortplot'><p>Plot consumers' hierarchical sorting</p></a></li>
<li><a href='#IdMap'><p>Ideal Mapping (IdMap)</p></a></li>
<li><a href='#IdMapConsumer'><p>Ideal Mapping by categories (IdMapConsumer)</p></a></li>
<li><a href='#indscal'><p>Construct the Indscal model for Napping data type</p></a></li>
<li><a href='#interact'><p>Estimation of interaction coefficients</p></a></li>
<li><a href='#JAR'><p>JAR</p></a></li>
<li><a href='#magicsort'><p>Returns a sorted data matrix</p></a></li>
<li><a href='#MultiIdeal'><p>Single vs. Multiple Ideal</p></a></li>
<li><a href='#nappeplot'><p>Plot panelists' tableclothe</p></a></li>
<li><a href='#nappesortplot'><p>Plot consumers' sorted tablecloth</p></a></li>
<li><a href='#napping'><p>Napping data</p></a></li>
<li><a href='#napping.don'><p>An example of Napping data</p></a></li>
<li><a href='#napping.words'><p>An example of &quot;illustrative&quot; variables to enhance results from Napping data</p></a></li>
<li><a href='#optimaldesign'><p> Construction of an optimal design</p></a></li>
<li><a href='#paneliperf'><p>Panelists' performance according to their capabilities to dicriminate between products</p></a></li>
<li><a href='#panellipse'><p>Confidence ellipses around products based on panelists descriptions</p></a></li>
<li><a href='#panellipse.session'><p>Repetability of panelists descriptions studied by confidence ellipses around products per session</p></a></li>
<li><a href='#panelmatch'><p>Confidence ellipses around products based on panel descriptions</p></a></li>
<li><a href='#panelperf'><p>Panel's performance according to its capabilities to dicriminate between products</p></a></li>
<li><a href='#perfume'><p>Perfume</p></a></li>
<li><a href='#perfume_fcp'><p>Perfume data obtained by free choice profiling</p></a></li>
<li><a href='#perfume_ideal'><p>Perfume Ideal Data</p></a></li>
<li><a href='#plot.fahst'><p>Make Factorial Approach for Hierarchical Sorting Task data (FAHST) graphs</p></a></li>
<li><a href='#plot.fasnt'><p>Make Factorial Approach for Sorting Napping Task data (FASNT) graphs</p></a></li>
<li><a href='#plot.fast'><p>Make Factorial Approach for Sorting Task data (FAST) graphs</p></a></li>
<li><a href='#plot.IdMap'><p>Plot for the Ideal Mapping</p></a></li>
<li><a href='#plot.JAR'><p>Make penalty graph</p></a></li>
<li><a href='#plot.WordCountAna'><p>Word-Count based methods Analysis (WordCountAna) graphs</p></a></li>
<li><a href='#plotellipse'><p>Plot confidence ellipses</p></a></li>
<li><a href='#plotellipseinter'><p>Plotellipseinter</p></a></li>
<li><a href='#plotellipseinterhmfa'><p>Plotellipseinterhmfa</p></a></li>
<li><a href='#plotpanelist'><p>Plotpanelist</p></a></li>
<li><a href='#pmfa'><p>Procrustean Multiple Factor Analysis (PMFA)</p></a></li>
<li><a href='#print.fahst'><p>Print Factorial Approach for Hierarchical Sorting Task data (FAHST) results</p></a></li>
<li><a href='#print.fasnt'><p>Print Factorial Approach for Sorting Napping Task data (FASNT) results</p></a></li>
<li><a href='#print.fast'><p>Print Factorial Approach for Sorting Task data (FAST) results</p></a></li>
<li><a href='#scalebypanelist'><p>Scale by panelist</p></a></li>
<li><a href='#search.desc'><p>Search for discriminating descriptors</p></a></li>
<li><a href='#senso.cocktail'><p>Sensory data for 16 cocktails</p></a></li>
<li><a href='#sensochoc'><p>Sensory data for 6 chocolates</p></a></li>
<li><a href='#sensopanels'><p>Sensory profiles given by 7 panels</p></a></li>
<li><a href='#simulation'><p>Simulate virtual panels</p></a></li>
<li><a href='#smoothies'><p>Smoothies</p></a></li>
<li><a href='#triangle.design'><p>Construct a design for triangle tests</p></a></li>
<li><a href='#triangle.pair.test'><p>Make a Triangle test for two products</p></a></li>
<li><a href='#triangle.test'><p>Make a Triangle test for a set of products</p></a></li>
<li><a href='#videos'>
<p>Videos data obtained with Holos</p></a></li>
<li><a href='#WilliamsDesign'><p>Construct a Williams design</p></a></li>
<li><a href='#WordCountAna'><p>Word-Count based methods Analysis  (WordCountAna)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.27</td>
</tr>
<tr>
<td>Title:</td>
<td>Sensory Data Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Francois Husson, Sebastien Le, Marine Cadoret</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francois Husson &lt;francois.husson@institut-agro.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), FactoMineR (&ge; 2.7)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster,KernSmooth,ggplot2,reshape2,AlgDesign,gtools,ggrepel</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical Methods to Analyse Sensory Data. SensoMineR: A package for sensory data analysis. S. Le and F. Husson (2008).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://sensominer.free.fr">http://sensominer.free.fr</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 09:00:11 UTC; husson</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyse_holos'>Analyse Holos data</h2><span id='topic+analyse_holos'></span>

<h3>Description</h3>

<p>Provide numeric tools and graphical tools to analyse Holos data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_holos(data, method, axes = c(1, 2), graph = TRUE, export.res = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyse_holos_+3A_data">data</code></td>
<td>
<p>A list of object, as returned by the <code><a href="#topic+format_holos">format_holos</a></code> function.</p>
</td></tr>
<tr><td><code id="analyse_holos_+3A_method">method</code></td>
<td>
<p>A string corresponding to the holistic task realized by the subjects during the experiment: &quot;N&quot; for Napping task, &quot;S&quot; for Sorting task, or &quot;SN&quot; for Sorted Napping task.</p>
</td></tr>
<tr><td><code id="analyse_holos_+3A_axes">axes</code></td>
<td>
<p>A length 2 vector specifying the components of the factorial analysis to plot. By default, the first two components are plotted.</p>
</td></tr>
<tr><td><code id="analyse_holos_+3A_graph">graph</code></td>
<td>
<p>A boolean specifying if the graphical outputs of the factorial analysis should be plotted or not. By default, graph = TRUE.</p>
</td></tr>
<tr><td><code id="analyse_holos_+3A_export.res">export.res</code></td>
<td>
<p>A boolean specifying if all the graphical outputs should be exported in the working directory or not. By default, export.res = FALSE. NB: If method = &quot;N&quot;, setting this argument to TRUE is the only way to access the individual cognitive processes.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>IDsubjects</code></td>
<td>
<p>A dataframe containing the concordance between the names of the subjects as given in the Holos experiment and their ID.</p>
</td></tr>
<tr><td><code>summary.task</code></td>
<td>
<p>The summary of the task realized by the subjects with pieces of information such as the number of steps performed by each subject, the duration of the task, etc.</p>
</td></tr>
<tr><td><code>res.FA</code></td>
<td>
<p>The results of the factorial analysis as returned by the <code>MFA</code> function of the <code>FactoMineR</code> package for Napping data, by the <code>MCA</code> function for Sorting data, and by the <code>HMFA</code> function for Sorted Napping data.</p>
</td></tr>
<tr><td><code>datasets</code></td>
<td>
<p>All the individuals data sets (digit-tracking data of each subject) and panel data sets (merged final configurations and verbalization).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Le, M.T., Brard, M. &amp; Le, S. (2016). Holos: A collaborative environment for similarity-based holistic approaches. Behavior Research Methods.<br />
Le, M.T., Husson, F. &amp; Le, S. (2014). Digit-tracking: Interpreting the evolution over time of sensory dimensions of an individual product space issued from Napping and sorted Napping. Food Quality and Preference.</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_holos">format_holos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(videos)

# Example with Napping data
res.N &lt;- analyse_holos(videos, method = "N", export.res = TRUE)
res.N$summary.task$nbstep.time # number of steps and duration of the task for each subject
res.N$summary.task$freq[[1]] # number of times the first subject moved each stimulus during the task
res.N$res.FA # MFA results that can be customized with the plot.MFA function of FactoMineR
res.N$datasets$digitdata[[1]] # digit-tracking data of the first subject
res.N$datasets$finaldata # Napping data (panel level)

# Example with Sorting data
res.S &lt;- analyse_holos(videos, method = "S")
res.S$res.FA # MCA results that can be customized with the plot.MCA function of FactoMineR
res.S$datasets # Sorting data (panel level)
sorting.data &lt;- apply(res.S$datasets, 2, as.factor) ?
res.fast &lt;- fast(sorting.data)
ConsensualWords(res.fast)

## End(Not run)
</code></pre>

<hr>
<h2 id='ardi'>Automatic Research of DIvergences between scores</h2><span id='topic+ardi'></span>

<h3>Description</h3>

<p>Spot the most singular or particular data with respect to all descriptors and to two
qualitative variables and all their possible categories combinations.<br />
Computes the highest differences between all the 
categories of the variables <em>product</em>, <em>panelist</em> and all their possible combinations,
with respect to a set of quantitative variables (the sensory descriptors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ardi(donnee, col.p, col.j, firstvar, lastvar = ncol(donnee), 
      nbval = 10, center = TRUE, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ardi_+3A_donnee">donnee</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>
<tr><td><code id="ardi_+3A_col.p">col.p</code></td>
<td>
<p>the position of the <em>product</em> variable</p>
</td></tr>
<tr><td><code id="ardi_+3A_col.j">col.j</code></td>
<td>
<p>the position of the <em>panelist</em> variable</p>
</td></tr>
<tr><td><code id="ardi_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first sensory descriptor</p>
</td></tr>
<tr><td><code id="ardi_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last sensory descriptor (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="ardi_+3A_nbval">nbval</code></td>
<td>
<p>the number of highest divergences to be displayed</p>
</td></tr>
<tr><td><code id="ardi_+3A_center">center</code></td>
<td>
<p>by default, data are mean centered by panelist</p>
</td></tr>
<tr><td><code id="ardi_+3A_scale">scale</code></td>
<td>
<p>by default, data are not scaled by panelist</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Step 1 For each quantitative variable, means by all the possible combinations (panelist,product) are computed. <br />
Step 2 Then, data are mean centered and scaled to unit variance by descriptor and the divergence
corresponds to the absolute value of the entries. <br />
Step 3 Means on divergences are computed by products or by panelists and then sorted.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>a data frame (descriptors are mean centered per panelist and scaled to unit variance)</p>
</td></tr>
<tr><td><code>panelist</code></td>
<td>
<p>a data frame, by default the 10 highest divergences between panelists according to the sensory
descriptors</p>
</td></tr>
<tr><td><code>product</code></td>
<td>
<p>a data frame, by default the 10 highest divergences between products according to the sensory
descriptors</p>
</td></tr>
<tr><td><code>combination</code></td>
<td>
<p>a data frame, by default the 10 highest divergences between panelists and products according to the sensory
descriptors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>F Husson, S Le
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decat">decat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(chocolates)
ardi(sensochoc, col.p = 4, col.j = 1, firstvar = 5)

## End(Not run)
  </code></pre>

<hr>
<h2 id='averagetable'>Computes a (products,descriptors) matrix</h2><span id='topic+averagetable'></span>

<h3>Description</h3>

<p>Returns the (products,descriptors) matrix with entries the means over panelists and sessions. <br />
Computes analyses of variance automatically for a given model and a set of quantitative variables.
Returns a data matrix where each row is associated with each
category of a given categorical variable (in most cases, the categorical variable is the 
<em>product</em> variable), each column is associated with a quantitative variable, and each cell is
the corresponding adjusted mean or mean.<br />
Computes the average data table with respect to a categorical variable and a set 
of quantitative variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>averagetable(donnee, formul, subset = NULL, method = "coeff", 
    firstvar, lastvar = ncol(donnee), file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="averagetable_+3A_donnee">donnee</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>
<tr><td><code id="averagetable_+3A_formul">formul</code></td>
<td>
<p>the model with respect to which the factor levels of the categorical variable of interest are calculated</p>
</td></tr>  
<tr><td><code id="averagetable_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process</p>
</td></tr>
<tr><td><code id="averagetable_+3A_method">method</code></td>
<td>
<p>two possibilities, &quot;coeff&quot; (by default) or &quot;mean&quot;</p>
</td></tr>
<tr><td><code id="averagetable_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="averagetable_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="averagetable_+3A_file">file</code></td>
<td>
<p>the name of the output file (by default, NULL and results are not in a file)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formul</code> parameter can be filled in for a given analysis of variance model.
The <code>formul</code> parameter must begin with the categorical variable of interest (generally the <em>product</em> variable)
followed by the different other factors (and eventually their interactions) of interest. Classicially, one can used 
<code>formul = "~Product+Panelist+Product:Panelist"</code>.
In practise and in our type of applications, this function is very useful to obtain a data matrix 
in which rows represent products and columns represent sensory descriptors. <br />
If &quot;mean&quot; is assigned to the <code>method</code> parameter, then the <code>formul</code> parameter
can be restricted to the sole variable of interest (generally the <em>product</em> variable). <br />
If data are balanced, the two options &quot;mean&quot; and &quot;coeff&quot; give the same results.
</p>


<h3>Value</h3>

<p>Return a matrix of dimension (<em>p,q</em>), where <em>p</em> is the number of categories of the qualitative variable 
of interest (in most cases, <em>p</em> is the number of products)
and <em>q</em> is the number of (sensory) descriptors. If &quot;coeff&quot; is assigned to the 
<code>method</code> parameter then the function <em>averagetable</em> returns the matrix
of the adjusted means; if &quot;mean&quot; is assigned to the <code>method</code> parameter 
then the function averagetable returns the matrix of the means per category.
</p>


<h3>Author(s)</h3>

<p>Francois Husson <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a></p>


<h3>References</h3>

<p>P. Lea, T. Naes, M. Rodbotten. <em>Analysis of variance for sensory data</em>. <br />
H. Sahai, M. I. Ageel. <em>The analysis of variance</em>.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+aov">aov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
resaverage&lt;-averagetable(sensochoc, formul = "~Product+Panelist",
    firstvar = 5)
coltable(magicsort(resaverage), level.upper = 6,level.lower = 4,
    main.title = "Average by chocolate")

res.pca = PCA(resaverage, scale.unit = TRUE)
</code></pre>

<hr>
<h2 id='barrow'>Barplot per row with respect to a set of quantitative variables</h2><span id='topic+barrow'></span>

<h3>Description</h3>

<p>Returns as many barplots as there are rows in a matrix. The barplots are automatically generated 
for all the quantitative variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barrow(donnee, numr = 2, numc = 2, numchar = 8, color = "lightblue",
      title = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barrow_+3A_donnee">donnee</code></td>
<td>
<p>a data frame of dimension (<em>p,q</em>), where p is the number of products
and <em>q</em> is the number of sensory descriptors for instance</p>
</td></tr>
<tr><td><code id="barrow_+3A_numr">numr</code></td>
<td>
<p>the number of barplots to be displayed per row (by default 2)</p>
</td></tr>
<tr><td><code id="barrow_+3A_numc">numc</code></td>
<td>
<p>the number of barplots to be displayed per column (by default 2)</p>
</td></tr>
<tr><td><code id="barrow_+3A_numchar">numchar</code></td>
<td>
<p>the number of character used to write the boxplot labels (by default 8)</p>
</td></tr>
<tr><td><code id="barrow_+3A_color">color</code></td>
<td>
<p>the color of the barplots (by default &quot;lightblue&quot;)</p>
</td></tr>
<tr><td><code id="barrow_+3A_title">title</code></td>
<td>
<p>the title used in the graphs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are ignored when forming barplots. 
</p>


<h3>Author(s)</h3>

 
<p>S Le <a href="mailto:Sebastien.Le@agrocampus-rennes.fr">Sebastien.Le@agrocampus-rennes.fr</a>
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) <em>The New S Language</em>. Wadsworth &amp; Brooks/Cole.<br />
Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A. (1983) <em>Graphical Methods for Data Analysis</em>. Wadsworth &amp; Brooks/Cole. 
</p>


<h3>See Also</h3>

 
<p><code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
resdecat&lt;-decat(sensochoc, formul = "~Product+Panelist", firstvar = 5, 
    graph = FALSE)
## Not run: 
barrow(resdecat$tabT)
barrow(resdecat$coeff, color = "orange")

## End(Not run)
</code></pre>

<hr>
<h2 id='boot'>Simulate virtual panels for several functions</h2><span id='topic+boot'></span>

<h3>Description</h3>

<p>Simulate virtual panels for the sorting task, the napping, the sorting napping, 
the free choice profiling, the hierarchical sorting task</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot(X, method = "sorting", axes = 1:2, scale = TRUE, ncp = NULL, group = NULL,
    nbsim = 200,level.conf = 0.95,nbchoix = NULL,color = NULL,cex = 0.8, 
    title = NULL, new.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot_+3A_x">X</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="boot_+3A_method">method</code></td>
<td>
<p>String with the method to use. The argument can be &quot;sorting&quot; (the default for sorting task data), 
&quot;napping&quot; (for napping data), &quot;sortnapping&quot; (for sorted napping), 
&quot;freechoice&quot; (for free choice profiling), &quot;hsort&quot; (for hierarchical sorting task data).</p>
</td></tr>  
<tr><td><code id="boot_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="boot_+3A_scale">scale</code></td>
<td>
<p>boolean, used when method=&quot;freechoice&quot;; if TRUE, the variables are scaled</p>
</td></tr>
<tr><td><code id="boot_+3A_ncp">ncp</code></td>
<td>
<p>number of components used to procrustes the virtual subspaces on the true subspace; by default NULL and the number of components is estimated</p>
</td></tr>
<tr><td><code id="boot_+3A_group">group</code></td>
<td>
<p>a list indicating the number of variables in each group; used when method=&quot;freechoice&quot; or method=&quot;hsort&quot;</p>
</td></tr>
<tr><td><code id="boot_+3A_nbsim">nbsim</code></td>
<td>
<p>the number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="boot_+3A_level.conf">level.conf</code></td>
<td>
<p>confidence level used to construct the ellipses. By default, 0.95</p>
</td></tr>
<tr><td><code id="boot_+3A_nbchoix">nbchoix</code></td>
<td>
<p>the number of panelists forming a virtual panel, by default the number of panelists in the original panel</p>
</td></tr>
<tr><td><code id="boot_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="boot_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="boot_+3A_title">title</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="boot_+3A_new.plot">new.plot</code></td>
<td>
<p>boolean, if TRUE, a new graphical device is created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate virtual panels by bootstrap of the panelists. For each virtual panel, calculate the mean 
configuration and procrustes this configuration on the true configuration obtained from the true panel.
</p>


<h3>Value</h3>

<p>Returns a list with estim.ncp which corresponds to the output of the estim_ncp function (function which estimates the number of components) and the simul object which can be used with the plotellipse function.
</p>


<h3>Author(s)</h3>

<p>Marine Cadoret and Francois Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
######## Napping example
data(napping)
res &lt;- boot(napping.don,method="napping")

######## Sorting task example
data(perfume)
res &lt;- boot(perfume,method="sorting")

######## Sorted task napping example
data(smoothies)
res &lt;- boot(smoothies,method="sortnapping")

######## Hierarchical sorting task example
data(cards)
group.cards&lt;-c(2,3,3,2,2,4,2,3,2,1,3,2,3,3,3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3)
res &lt;- boot(cards,method="hsort", group=group.cards)

######## Free choice profiling example
data(perfume_fcp)
res &lt;- boot(perfume_fcp, method="freechoice", group = c(12,7,7,7,6,8))

## End(Not run)
</code></pre>

<hr>
<h2 id='boxprod'>Boxplot per category with respect to a categorical variable and a set of quantitative variables</h2><span id='topic+boxprod'></span>

<h3>Description</h3>

<p>Returns as many boxplots as there are categories for a given categorical variable of interest (in most cases, the
<em>product</em> variable). The boxplots are automatically generated for all the quantitative variables 
(in our type of applications, variables are often sensory descriptors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxprod(donnee, col.p, firstvar, lastvar = ncol(donnee), 
    numr = 2, numc = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxprod_+3A_donnee">donnee</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="boxprod_+3A_col.p">col.p</code></td>
<td>
<p>the position of the categorical variable of interest</p>
</td></tr>
<tr><td><code id="boxprod_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="boxprod_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="boxprod_+3A_numr">numr</code></td>
<td>
<p>the number of boxplots per row (by default 2)</p>
</td></tr>
<tr><td><code id="boxprod_+3A_numc">numc</code></td>
<td>
<p>the number of boxplots per column (by default 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are ignored when forming boxplots. 
</p>


<h3>Author(s)</h3>

 
<p>F Husson <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> <br />
S Le <a href="mailto:Sebastien.Le@agrocampus-ouest.fr">Sebastien.Le@agrocampus-ouest.fr</a>
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) <em>The New S Language</em>. Wadsworth &amp; Brooks/Cole.<br />
Chambers, J. M., Cleveland, W. S., Kleiner, B. and Tukey, P. A. (1983) <em>Graphical Methods for Data Analysis</em>. Wadsworth &amp; Brooks/Cole. 
</p>


<h3>See Also</h3>

 
<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code> which does the computation,
<code><a href="graphics.html#topic+bxp">bxp</a></code> for the plotting and more examples; and <code><a href="graphics.html#topic+stripchart">stripchart</a></code> 
for an alternative (with small data sets).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
boxprod(sensochoc, col.p = 4, firstvar = 5, numr = 2, numc = 2)
</code></pre>

<hr>
<h2 id='CA_JAR'>Make a correspondence analysis on the JAR data</h2><span id='topic+CA_JAR'></span>

<h3>Description</h3>

<p>Plot the CA graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CA_JAR(x, col.p, col.j, col.pref, jarlevel="jar")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CA_JAR_+3A_x">x</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="CA_JAR_+3A_col.p">col.p</code></td>
<td>
<p>the position of the <em>product</em> variable</p>
</td></tr>
<tr><td><code id="CA_JAR_+3A_col.j">col.j</code></td>
<td>
<p>the position of the <em>panelist</em> variable</p>
</td></tr>
<tr><td><code id="CA_JAR_+3A_col.pref">col.pref</code></td>
<td>
<p>the position of the <em>preference</em> variable</p>
</td></tr>
<tr><td><code id="CA_JAR_+3A_jarlevel">jarlevel</code></td>
<td>
<p>a string corresponding to the jar level (the level must be the same for all the jar variables)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw a CA graph with the preference data as supplementary qualitative variables, the products as rows, and the categories of the jar variables as columns
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(JAR)
res &lt;- CA_JAR(x = JAR, col.p = 13, col.j = 1, col.pref = 2, jarlevel = "jar")
plot.CA(res$res.CA, invisible = "row", cex = 0.8)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='calculate.average'>Calcul de moyenne</h2><span id='topic+calculate.average'></span>

<h3>Description</h3>

<p>Fonction intermediaire</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.average(axeACP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.average_+3A_axeacp">axeACP</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>axeACP: 1st col: identificateur, colonne suivante: coord sur axe, produit, juge (avec 0 pour moyenne)
les premieres lignes correspondent aux moyennes tous juges confondus
les suivantes aux notes individuelles, classees par juge
cree tab: tableau avec en ligne les juges, 
en colonne les produits (ou si c'est une AFM les individus moyens ou partiels ou les 2)
en profondeur les coord sur les differents axes
</p>


<h3>Author(s)</h3>

<p>F Husson</p>

<hr>
<h2 id='cards'>Cards</h2><span id='topic+cards'></span>

<h3>Description</h3>

<p>The data used here refer to 16 cards (images) on which 30 children performed a hierarchical sorting task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cards)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows (the number of cards) and 81 columns (the total number of levels provided by all children).
For each child, we have several qualitative variables corresponding to nested partitions: a partition corresponds to a level provided by the child.
The columns are grouped by child.
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cards)
## Example of FAHST
group.cards&lt;-c(2,3,3,2,2,4,2,3,2,1,3,2,3,3,3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3)
res.fahst&lt;-fahst(cards,group=group.cards)

## End(Not run)
</code></pre>

<hr>
<h2 id='carto'>Preference Mapping Techniques</h2><span id='topic+carto'></span>

<h3>Description</h3>

<p>Performs preference mapping techniques based on multidimensional exploratory data analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carto(Mat, MatH, 
      level = 0, regmod = 1, coord = c(1, 2), asp = 1, 
      cex = 1.3, col = "steelblue4", font = 2, clabel = 0.8,
      label.j = FALSE, resolution = 200, nb.clusters = 0,
	    graph.tree=TRUE,graph.corr=TRUE,graph.carto=TRUE,
	    main=NULL,col.min=7.5,col.max=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carto_+3A_mat">Mat</code></td>
<td>
<p>a data frame corresponding to the axes of the map</p>
</td></tr>
<tr><td><code id="carto_+3A_math">MatH</code></td>
<td>
<p>a data frame in which each row represent a product and each column represent the hedonic scores of a given 
consumer for the products</p>
</td></tr>
<tr><td><code id="carto_+3A_level">level</code></td>
<td>
<p>the number of standard deviations used in the calculation of the preference response surface for all
the consumers</p>
</td></tr>
<tr><td><code id="carto_+3A_regmod">regmod</code></td>
<td>
<p>the type of regression model used in the calculation of the preference response surface for all
the consumers. <code>regmod</code> = 1: quadratic model, 
<code>regmod</code> = 2: vector model, <code>regmod</code> = 3: circular model, <code>regmod</code> = 4: elliptical model</p>
</td></tr>
<tr><td><code id="carto_+3A_coord">coord</code></td>
<td>
<p>a vector of length 2, the rank of the axis used to display the results if <code>"manual"</code>
is not assigned to the <code>option</code> parameter</p>
</td></tr>
<tr><td><code id="carto_+3A_asp">asp</code></td>
<td>
<p>if 1 is assigned to that parameter, the graphic displays are output in an orthonormal coordinate system</p>
</td></tr>
<tr><td><code id="carto_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="carto_+3A_col">col</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="carto_+3A_font">font</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="carto_+3A_clabel">clabel</code></td>
<td>
<p>cf. the <span class="pkg">ade4</span> package</p>
</td></tr>
<tr><td><code id="carto_+3A_label.j">label.j</code></td>
<td>
<p>boolean, if T then the labels of the panelists who gave the hedonic scores are displayed</p>
</td></tr>
<tr><td><code id="carto_+3A_resolution">resolution</code></td>
<td>
<p>resolution of the map</p>
</td></tr>
<tr><td><code id="carto_+3A_nb.clusters">nb.clusters</code></td>
<td>
<p>number of clusters to use (by default, 0 and the optimal numer of clusters is calculated</p>
</td></tr>
<tr><td><code id="carto_+3A_graph.tree">graph.tree</code></td>
<td>
<p>boolean, if TRUE plots the tree in 2 dimensions</p>
</td></tr>
<tr><td><code id="carto_+3A_graph.corr">graph.corr</code></td>
<td>
<p>boolean, if TRUE plots the variables factor map</p>
</td></tr>
<tr><td><code id="carto_+3A_graph.carto">graph.carto</code></td>
<td>
<p>boolean, if TRUE plots the preference map</p>
</td></tr>
<tr><td><code id="carto_+3A_main">main</code></td>
<td>
<p>an overall title for the plot</p>
</td></tr>
<tr><td><code id="carto_+3A_col.min">col.min</code></td>
<td>
<p>define the color which match to the low levels of preference</p>
</td></tr>
<tr><td><code id="carto_+3A_col.max">col.max</code></td>
<td>
<p>define the color which match to the high levels of preference</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The preference mapping methods are commonly used in the fields of market research 
and research and development to explore and understand the structure and tendencies of consumer preferences, 
to link consumer preference information to other data and to predict the behavior of consumers 
in terms of acceptance of a given product.<br />
This function refers to the method introduced by M. Danzart. A response surface is computed per consumer; then
according to certain threshold preference zones are delimited and finally superimposed.
</p>


<h3>Author(s)</h3>

<p>Francois Husson <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> <br />
Sebastien Le <a href="mailto:Sebastien.Le@agrocampus-ouest.fr">Sebastien.Le@agrocampus-ouest.fr</a>
</p>


<h3>References</h3>

<p>Danzart M., Sieffermann J.M., Delarue J. (2004). New developments in preference mapping techniques: 
finding out a consumer optimal product, its sensory profile and the key sensory attributes. 
<em>7th Sensometrics Conference, July 27-30, 2004, Davis, CA.</em><br />
</p>


<h3>See Also</h3>

<p><code><a href="FactoMineR.html#topic+MFA">MFA</a></code>, <code><a href="FactoMineR.html#topic+GPA">GPA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1: carto for the sensory descriptors
data(cocktail)
res.pca &lt;- PCA(senso.cocktail)
res.carto &lt;- carto(res.pca$ind$coord[,1:2], hedo.cocktail)

## Example 2
data(cocktail)
res.mfa &lt;- MFA(cbind.data.frame(senso.cocktail,compo.cocktail),
    group=c(ncol(senso.cocktail),ncol(compo.cocktail)),
    name.group=c("senso","compo"))
res.carto &lt;- carto(res.mfa$ind$coord[,1:2], hedo.cocktail)

## End(Not run)
</code></pre>

<hr>
<h2 id='cartoconsumer'>Preference Mapping Techniques and segmentation of consumers</h2><span id='topic+cartoconsumer'></span>

<h3>Description</h3>

<p>Performs preference mapping techniques based on multidimensional exploratory data analysis and segmentation of consumers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartoconsumer(res, data.pref, nb.clust=0, seuil=0.8, consol=TRUE, ncp=5,
		 scale.conso=TRUE,graph.carto=TRUE,graph.hcpc=FALSE, graph.group=FALSE,
		col.min=7.5, col.max=0, contrast=0.2, level=0, asp=0,lwd=2)
				</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cartoconsumer_+3A_res">res</code></td>
<td>
<p>the result of a factor analysis</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_data.pref">data.pref</code></td>
<td>
<p>a data frame in which each row represent a product and each column represent the hedonic scores of a given 
consumer for the products</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_nb.clust">nb.clust</code></td>
<td>
<p>	an integer. If 0, the tree is cut at the level the user clicks on. If -1, the tree is automatically cut at the suggested level (see details). If a (positive) integer, the tree is cut with nb.cluters clusters</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_seuil">seuil</code></td>
<td>
<p>the size of the area kept for each group of consumers</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_consol">consol</code></td>
<td>
<p>a boolean. If TRUE, a k-means consolidation is performed</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_ncp">ncp</code></td>
<td>
<p>number of dimensions kept in the results (by default 5)</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_scale.conso">scale.conso</code></td>
<td>
<p>scale data by consumer</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_graph.carto">graph.carto</code></td>
<td>
<p>if TRUE, the preference map is displayed. If FALSE, no graph is displayed</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_graph.hcpc">graph.hcpc</code></td>
<td>
<p>if TRUE, graphics of segmentation (trees and indivuals map) are displayed. If FALSE, no graph are displayed</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_graph.group">graph.group</code></td>
<td>
<p>if TRUE, preference maps for each group are displayed. If FALSE, no map are displayed</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_col.min">col.min</code></td>
<td>
<p>define the color which match to the low levels of preference</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_col.max">col.max</code></td>
<td>
<p>define the color which match to the high levels of preference</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_contrast">contrast</code></td>
<td>
<p>define the color contrast between groups' areas and the rest of the map</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_level">level</code></td>
<td>
<p>the number of standard deviations used in the calculation of the preference response surface for all
the consumers</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_asp">asp</code></td>
<td>
<p>if 1 is assigned to that parameter, the graphic displays are output in an orthonormal coordinate system</p>
</td></tr>
<tr><td><code id="cartoconsumer_+3A_lwd">lwd</code></td>
<td>
<p>control the line width for the outlines defining groups' areas</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The preference mapping methods are commonly used in the fields of market research 
and research and development to explore and understand the structure and tendencies of consumer preferences, 
to link consumer preference information to other data and to predict the behavior of consumers 
in terms of acceptance of a given product.<br />
This function refers to the method introduced by M. Danzart. A segmentation of consumers is performed, and a 
preference map is displayed for each group of consumers. The original preference map is built, the areas of 
each group are underlined thanks to a contrast, and the number of consumers is shown.
</p>


<h3>Author(s)</h3>

<p>Francois Husson <a href="mailto:husson@agrocampus-rennes.fr">husson@agrocampus-rennes.fr</a> <br />
Sophie Birot and Celia Pontet
</p>


<h3>References</h3>

<p>Danzart M., Sieffermann J.M., Delarue J. (2004). New developments in preference mapping techniques: 
finding out a consumer optimal product, its sensory profile and the key sensory attributes. 
<em>7th Sensometrics Conference, July 27-30, 2004, Davis, CA.</em><br />
</p>


<h3>See Also</h3>

<p><code><a href="FactoMineR.html#topic+MFA">MFA</a></code>, <code><a href="FactoMineR.html#topic+GPA">GPA</a></code>, <code><a href="#topic+carto">carto</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1: carto on the sensory descriptors
data(cocktail)
res.pca &lt;- PCA(senso.cocktail)
results1 &lt;- cartoconsumer(res.pca, hedo.cocktail)
results2 &lt;- cartoconsumer(res.pca, hedo.cocktail,
      graph.hcpc=TRUE,graph.group=TRUE)

## End(Not run)

## Example 2
## Not run: 
data(cocktail)
res.mfa &lt;- MFA(cbind.data.frame(senso.cocktail,compo.cocktail),
    group=c(ncol(senso.cocktail),ncol(compo.cocktail)),
    name.group=c("senso","compo"))
results3 &lt;- cartoconsumer(res.mfa, hedo.cocktail)

## End(Not run)
</code></pre>

<hr>
<h2 id='chocolates'>Chocolates data</h2><span id='topic+chocolates'></span>

<h3>Description</h3>

<p>The data used here refer to six varieties of chocolates sold in France.<br />
</p>
<p>- For the sensory description: each chocolate was evaluated twice by 29 panelists according to 14
sensory descriptors;<br />
- For the hedonic data: each chocolate was evaluated on a structured scale from 0 to 10, 
by 222 consumers, according to their liking (0) or disliking (10);<br />
- For the sensory panels description: each chocolate was evaluated by 7 panels according to 14
sensory descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chocolates)</code></pre>


<h3>Format</h3>

<p>There are three data frames:
- sensochoc: a data frame with 348 rows and 19 columns: 5 qualitative variables
(Panelist, Session, Form, Rank, Product) and 14 sensory descriptors;<br />
- hedochoc: a data frame with 6 rows and 222 columns: each row corresponds to a chocolate
and each column to the hedonic scores given by one of the 222 consumers participating in the study;<br />
- sensopanels: a data frame with 6 rows and 98 columns: each row corresponds to a chocolate
and each column to the mean over the panelists of a given panel 
according to a sensory descriptor.
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
decat(sensochoc, formul = "~Product+Panelist", firstvar = 5, graph = FALSE)
</code></pre>

<hr>
<h2 id='cocktail'>Cocktail data</h2><span id='topic+cocktail'></span>

<h3>Description</h3>

<p>The data used here refer to 16 cocktails.
</p>
<p>There are 3 files corresponding to the composition of the cocktails; the sensory description of the cocktails; the hedonic scores.
</p>
<p>- For the composition of the cocktails: The mango, banana, orange and lemon concentration are known;<br />
- For the sensory description: each cocktail was evaluated by 12 panelists according to 13
sensory descriptors (only the average of each cocktail are given).
- For the hedonic data: each cocktail was evaluated on a structured scale from 0 to 10, 
by 100 consumers, according to their disliking (0) or liking (10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cocktail)</code></pre>


<h3>Format</h3>

<p>There are three data frames:
- compo.cocktail: a data frame with 16 rows and 4 columns: the composition of each cocktail is given for the 4 ingredients;<br />
- senso.cocktail: a data frame with 16 rows and 13 columns: each cocktail was evaluated by 12 panelists according to 13
sensory descriptors;<br />
hedo.cocktail: a data frame with 16 rows and 100 columns: each cocktail was evaluated on a structured scale from 0 to 10, 
by 100 consumers, according to their disliking (0) or liking (10).
</p>


<h3>Source</h3>

<p>Applied Mathematics Department, Agrocampus Rennes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cocktail)
</code></pre>

<hr>
<h2 id='coltable'>Color the cells of a data frame according to 4 threshold levels</h2><span id='topic+coltable'></span>

<h3>Description</h3>

<p>Return a colored display of a data frame according to 4 threshold levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coltable(matrice, col.mat = matrice,
    nbrow = nrow(matrice), nbcol = ncol(matrice), 
    level.lower = 0.05, col.lower = "mistyrose", 
    level.upper = 1.96, col.upper = "lightblue",
    cex = 0,nbdec = 4, main.title = NULL, level.lower2 = -1e10,
    col.lower2 = "red", level.upper2 = 1e10, 
    col.upper2 = "blue", novalue = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coltable_+3A_matrice">matrice</code></td>
<td>
<p>a data frame (or a matrix) with only quantitative variables</p>
</td></tr>
<tr><td><code id="coltable_+3A_col.mat">col.mat</code></td>
<td>
<p>a data frame (or a matrix) from which the cells of the <code>matrice</code> data frame are colored;
by default, <code>col.mat</code>=<code>matrice</code></p>
</td></tr>
<tr><td><code id="coltable_+3A_nbrow">nbrow</code></td>
<td>
<p>the number of rows to be displayed (by default, <code>nrow(matrice)</code>)</p>
</td></tr>
<tr><td><code id="coltable_+3A_nbcol">nbcol</code></td>
<td>
<p>the number of columns to be displayed (by default, <code>ncol(matrice)</code>)</p>
</td></tr>
<tr><td><code id="coltable_+3A_level.lower">level.lower</code></td>
<td>
<p>the threshold below which cells are colored in <code>col.lower</code></p>
</td></tr>
<tr><td><code id="coltable_+3A_col.lower">col.lower</code></td>
<td>
<p>the color used for <code>level.lower</code></p>
</td></tr>
<tr><td><code id="coltable_+3A_level.upper">level.upper</code></td>
<td>
<p>the threshold above which cells are colored in <code>col.upper</code></p>
</td></tr>
<tr><td><code id="coltable_+3A_col.upper">col.upper</code></td>
<td>
<p>the color used for <code>level.upper</code></p>
</td></tr>
<tr><td><code id="coltable_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="coltable_+3A_nbdec">nbdec</code></td>
<td>
<p>the number of decimal places displayed</p>
</td></tr>
<tr><td><code id="coltable_+3A_main.title">main.title</code></td>
<td>
<p>title of the graph(s)</p>
</td></tr>
<tr><td><code id="coltable_+3A_level.lower2">level.lower2</code></td>
<td>
<p>the threshold below which cells are colored in <code>col.lower2</code>; this level should be less than level.lower</p>
</td></tr>
<tr><td><code id="coltable_+3A_col.lower2">col.lower2</code></td>
<td>
<p>the color used for <code>level.lower2</code></p>
</td></tr>
<tr><td><code id="coltable_+3A_level.upper2">level.upper2</code></td>
<td>
<p>the threshold above which cells are colored in <code>col.upper2</code>; this level should be greater than level.upper</p>
</td></tr>
<tr><td><code id="coltable_+3A_col.upper2">col.upper2</code></td>
<td>
<p>the color used for <code>level.upper2</code></p>
</td></tr>
<tr><td><code id="coltable_+3A_novalue">novalue</code></td>
<td>
<p>boolean, if TRUE the values are not written</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very useful especially when there are a lot of values to check.
</p>


<h3>Author(s)</h3>

<p>F Husson, S Le
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
data(chocolates)
resdecat&lt;-decat(sensochoc, formul = "~Product+Panelist", firstvar = 5,
    graph = FALSE)
resaverage&lt;-averagetable(sensochoc, formul = "~Product+Panelist", 
    firstvar = 5)
resaverage.sort = resaverage[rownames(magicsort(resdecat$tabT)),
    colnames(magicsort(resdecat$tabT))]
coltable(resaverage.sort, magicsort(resdecat$tabT), 
    level.lower = -1.96, level.upper = 1.96,
    main.title = "Average by chocolate")

## Example 3
## Not run: 
data(chocolates)
resperf&lt;-paneliperf(sensochoc, 
    formul = "~Product+Panelist+Product:Panelist", 
    formul.j = "~Product", col.j = 1, firstvar = 5, lastvar = 12, 
    synthesis = FALSE, graph = FALSE)
resperfprob&lt;-magicsort(resperf$prob.ind, method = "median")
coltable(resperfprob, level.lower = 0.05, level.upper = 1, 
    main.title = "P-value of the F-test (by panelist)")

resperfr2&lt;-magicsort(resperf$r2.ind, method = "median", 
    ascending = FALSE)
coltable(resperfr2, level.lower = 0.00, level.upper = 0.85, 
    main.title = "Adjusted R-square (by panelist)")

## End(Not run)
</code></pre>

<hr>
<h2 id='compo.cocktail'>Composition of the cocktails data</h2><span id='topic+compo.cocktail'></span>

<h3>Description</h3>

<p>The data used here refer to the composition of 16 cocktails, i.e. the mango, banana, orange and lemon concentration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cocktail)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows and 4 columns: the composition of each cocktail is given for the 4 ingredients.
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cocktail)
</code></pre>

<hr>
<h2 id='ConsensualWords'>Consensual words for Sorting Task data</h2><span id='topic+ConsensualWords'></span>

<h3>Description</h3>

<p>This function is designed to point out the words that are used in a consensual way by consumers from a sorting task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConsensualWords(res.fast, nbtimes = 3, nbsimul = 500, proba = 0.05, 
    graph = TRUE, axes = c(1,2))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConsensualWords_+3A_res.fast">res.fast</code></td>
<td>
<p>an object of class fast</p>
</td></tr>  
<tr><td><code id="ConsensualWords_+3A_nbtimes">nbtimes</code></td>
<td>
<p>minimum sample size for the word selection</p>
</td></tr>
<tr><td><code id="ConsensualWords_+3A_nbsimul">nbsimul</code></td>
<td>
<p>the number of simulations used to compute Bootstrap</p>
</td></tr>
<tr><td><code id="ConsensualWords_+3A_proba">proba</code></td>
<td>
<p>the significance threshold considered to consider a word as consensual 
(by default 0.05)</p>
</td></tr>
<tr><td><code id="ConsensualWords_+3A_graph">graph</code></td>
<td>
<p>boolean, if TRUE a graph is displayed</p>
</td></tr>
<tr><td><code id="ConsensualWords_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>Centroids</code></td>
<td>
<p>coordinates of the consensual words on the dimensions of the fast result</p>
</td></tr>
<tr><td><code>Within.inertia</code></td>
<td>
<p>frequency of use of each word and within inertia associated</p>
</td></tr>
<tr><td><code>Results.Bootstrap</code></td>
<td>
<p>frequency of use of each word, within inertia associated and 
p-value calculated according to the Bootstrap technique</p>
</td></tr>
<tr><td><code>Consensual.words</code></td>
<td>
<p>a list of significant consensual words sorted from the most 
consensual to the less consensual</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume)
## Example of FAST results
res.fast&lt;-fast(perfume,sep.words=";")
res.consensual&lt;-ConsensualWords(res.fast)

## End(Not run)
</code></pre>

<hr>
<h2 id='ConsistencyIdeal'>Sensory and Hedonic consistency of the ideal data</h2><span id='topic+ConsistencyIdeal'></span>

<h3>Description</h3>

<p>Evaluate the sensory and hedonic consistency of the ideal data, both at the consumer and panel level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ConsistencyIdeal(dataset, col.p, col.j, col.lik, id.recogn, type="both", scale.unit=TRUE,
                  ncp=NULL, axes=c(1,2), nbsim=0, replace.na=FALSE, graph=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConsistencyIdeal_+3A_dataset">dataset</code></td>
<td>
<p>A matrix with at least two qualitative variables (<em>consumer</em> and <em>products</em>)
and a set of quantitative variables containing at least 2*A variables (for both <em>perceived</em> and <em>ideal</em> intensities)</p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_col.p">col.p</code></td>
<td>
<p>The position of the <em>product</em> variable </p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_col.j">col.j</code></td>
<td>
<p>The position of the <em>consumer</em> variable </p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_col.lik">col.lik</code></td>
<td>
<p>The position of the <em>liking</em> variable </p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_id.recogn">id.recogn</code></td>
<td>
<p>The sequence in the variable names which distinguish the ideal
variables from the sensory variables. This sequence should be fixed and unique. <br />
Each ideal variable should be preceeded by the corresponding perceived intensity variable. </p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_type">type</code></td>
<td>
<p>Define whether you want the sensory consistency only (&quot;sensory&quot;), the hedonic consistency only (&quot;hedonic&quot;), or both (&quot;both&quot;)</p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_scale.unit">scale.unit</code></td>
<td>
<p>Boolean, if TRUE the descriptors are scaled to unit variance</p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_ncp">ncp</code></td>
<td>
<p>Number of dimensions kept in the results</p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_axes">axes</code></td>
<td>
<p>A length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_nbsim">nbsim</code></td>
<td>
<p>The number of simulations performed. By default (=0), no simulations are performed and only the results for the real data are given</p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_replace.na">replace.na</code></td>
<td>
<p>Boolean, define whether the missing values (in the correlation matrix calculated for the consistency at the consumer level) should be ignored or replaced by 0</p>
</td></tr>
<tr><td><code id="ConsistencyIdeal_+3A_graph">graph</code></td>
<td>
<p>Boolean, define whether the distribution of the correlation coefficient should be plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SENSORY CONSISTENCY<br />
A the panel level:<br />
A PCA is performed on the table crossing the J consumers in rows and the A ideal variables
in columns (the averaged or corrected averaged is then considered).<br />
On this space, the sensory description of the P products (P rows) on the A attributes
is projected as supplementary entities while the hedonic table crossing
the J consumers (in rows) and the P products (in columns) is projected as supplementary variables.<br />
The sensory consistency is measured by the correspondence between the same products seen
through the sensory and through the hedonic descriptions.<br />
At the consumer level:<br />
For each consumer, the correlation between the (corrected) ideal ratings and
the correlation between the hedonic scores and the perceived intensity of each attribute is calculated.<br />
A test on this correlation coefficient is performed for each consumer.<br />
The distribution of these correlations coefficients are also given graphically.
<br />
<br />
HEDONIC CONSISTENCY <br />
For each consumer, a PCR-model expressing the liking scores in function of the perceived intensity is created.<br />
Once the model is created, the model is applied to the ideal ratings provided by the consumer
considered and the hedonic score of the ideal product is estimated.<br />
This hedonic score is then compared to the hedonic scores provided to the products tested.<br />
If simulations are asked, the same procedure is estimated after re-sampling the vector of hedonic scores.<br />
In that case, the distribution of the estimated ideal hedonic score can be estimated
under H0 and the significance of the estimated ideal hedonic score can be done.<br />
</p>


<h3>Value</h3>

<p>A list containing the results for the sensory and hedonic consistency:<br />
</p>
<table>
<tr><td><code>Senso</code></td>
<td>
<p>contains the results of the sensory consistency</p>
</td></tr>
<tr><td><code>Senso$panel</code></td>
<td>
<p>results for the consistency at the panel level including:</p>
</td></tr>
<tr><td><code>Senso$panel$dataset</code></td>
<td>
<p>the datasets used for the different PCA</p>
</td></tr>
<tr><td><code>Senso$panel$PCA.ideal</code></td>
<td>
<p>the results of the PCA for the creation of the ideal space</p>
</td></tr>
<tr><td><code>Senso$panel$PCA.ideal_hedo</code></td>
<td>
<p>the results of the PCA with projection of the hedonic scores</p>
</td></tr>
<tr><td><code>Senso$panel$PCA.ideal_senso</code></td>
<td>
<p>the results of the PCA with the proojection of the sensory descriptions</p>
</td></tr>
<tr><td><code>Senso$panel$correlation</code></td>
<td>
<p>the correlation between the <em>product</em> projected from the <em>sensory</em> and <em>hedonic</em> points of view</p>
</td></tr>
<tr><td><code>Senso$conso</code></td>
<td>
<p>results of the consistency at the consumer level including: </p>
</td></tr>
<tr><td><code>Senso$conso$driver.lik</code></td>
<td>
<p>the linear drivers of liking (correlation between perceived intensity and liking score for each attribute)</p>
</td></tr>
<tr><td><code>Senso$conso$correlations</code></td>
<td>
<p>the correlations between drivers of liking and the difference (ideal-perceived) intensity</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code>Hedo$R2</code></td>
<td>
<p>the R2 coefficients of the indivvidual models</p>
</td></tr>
<tr><td><code>Hedo$hedo</code></td>
<td>
<p>a list containing the hedonic scores for the <em>product</em>, <em>ideal products</em>, <em>average ideal product</em>
and the <em>standardized ideal product</em> for each consumer</p>
</td></tr>
<tr><td><code>Hedo$simulation</code></td>
<td>
<p>a list including the estimated hedonic score for each simulation, the p-value and the matrix of simulations used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thierry Worch (thierry@qistatistics.co.uk)</p>


<h3>References</h3>

<p>Worch, T., Le, S., Punter, P., &amp; Pages, J. (2012).
Assessment of the consistency of ideal profiles according to non-ideal data for IPM.
<em>Food Quality and Preference</em>, 24, 99-110.,
Worch, T., Le, S., Punter, P., &amp; Pages, J. (2012).
Extension of the consistency of the data obtained with the Ideal Profile Method:
Would the ideal products be more liked than the tested products?
<em>Food Quality and Preference</em>, 26, 74-80.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+panelperf">panelperf</a></code>, <code><a href="#topic+paneliperf">paneliperf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume_ideal)
res &lt;- ConsistencyIdeal(perfume_ideal, col.p=2, col.j=1, 
   col.lik=ncol(perfume_ideal), id.recogn="id_", 
   type="both", nbsim=100)

## End(Not run)
</code></pre>

<hr>
<h2 id='construct.axes'>Coordinates of individuals and illustrative individuals for PCA or MFA</h2><span id='topic+construct.axes'></span>

<h3>Description</h3>

<p>This function is especially designed to be used in a sensory data analysis context.
Returns the coordinates of the products when performing either PCA or MFA and 
the coordinates of the &quot;partial&quot; products when performing MFA.
Returns also the panelists' coordinates when projected as illustrative rows onto the products' space.
Produces graphs of products and descriptors from the output of PCA or MFA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct.axes(matrice, coord = c(1,2), scale.unit = TRUE, group = NULL,
      name.group = NULL, centerbypanelist = FALSE, scalebypanelist = FALSE,
      method = "coeff", graph.type = c("ggplot","classic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct.axes_+3A_matrice">matrice</code></td>
<td>
<p>a data.frame made up of at least two qualitative variables (the <em>panelist</em> and 
the <em>product</em> variables), the others are sensory descriptors used to perform an MFA or a PCA if group = NULL</p>
</td></tr>
<tr><td><code id="construct.axes_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="construct.axes_+3A_scale.unit">scale.unit</code></td>
<td>
<p>boolean, if <code>TRUE</code> the descriptors are scaled to unit variance</p>
</td></tr>
<tr><td><code id="construct.axes_+3A_group">group</code></td>
<td>
<p>the number of variables in each group of variables when multiple factor analysis is performed (by default this parameter equals NULL and a PCA is performed)</p>
</td></tr>  
<tr><td><code id="construct.axes_+3A_name.group">name.group</code></td>
<td>
<p>the names of the groups of variables when mfa is performed (if <code>group</code> differs from NULL)</p>
</td></tr>  
<tr><td><code id="construct.axes_+3A_centerbypanelist">centerbypanelist</code></td>
<td>
<p>center the data by panelist before the construction of the axes</p>
</td></tr>
<tr><td><code id="construct.axes_+3A_scalebypanelist">scalebypanelist</code></td>
<td>
<p>scale the data by panelist before the construction of the axes</p>
</td></tr>
<tr><td><code id="construct.axes_+3A_method">method</code></td>
<td>
<p>the method to replace the missing values: &quot;average&quot; or &quot;coeff&quot; 
(coefficients of the <em>product</em> variable in the anova model)</p>
</td></tr>
<tr><td><code id="construct.axes_+3A_graph.type">graph.type</code></td>
<td>
<p>a character that gives the type of graph used: &quot;ggplot&quot; or &quot;classic&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data set is an object of class <code>data.frame</code>, 
for which the two first columns are qualitative variables (the first variable refers to the <em>panelist</em> variable 
and the second to the <em>product</em> variable) and the others are quantitative. <br />
</p>
<p>The ouptut of this function is a list with one element when performing PCA and two elements 
when performing MFA. The first element is the data frame of the coordinates of the products according to 
the whole panel (Panelist=0) and to the panelists. 
The second element is the data frame of the coordinates of the &quot;partial products&quot;
according to the whole panel (Panelist=0) and to the panelists. <br />
</p>
<p>This function is necessary when calculating confidence ellipses for products.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>eig</code></td>
<td>
<p>a matrix with the component of the factor analysis (in row) and the eigenvalues, the inertia and the cumulative inertia for each component</p>
</td></tr>
<tr><td><code>moyen</code></td>
<td>
<p>the coordinates of the products with respect to the panel and to each panelists</p>
</td></tr>
<tr><td><code>partiel</code></td>
<td>
<p>the coordinates of the <em>partial</em> products with respect to the panel and to each panelists</p>
</td></tr>
</table>
<p>Returns also a correlation circle as well as a graph of individuals
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>References</h3>

<p>Escofier, B. and Pages, J. (1990) 
<em>Analyses factorielles simples et multiples: objectifs, methodes et interpretation</em> 
Dunod, Paris. 1&ndash;267. <br />
</p>
<p>Escofier, B. and Pages, J. (1994) 
Multiple factor analysis (AFMULT package). 
<em>Computational Statistics and Data Analysis</em>, <b>18</b>, 121&ndash;140.
</p>


<h3>See Also</h3>

 <p><code><a href="FactoMineR.html#topic+MFA">MFA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example1: PCA 
data(chocolates)
donnee &lt;- cbind.data.frame(sensochoc[,c(1,4,5:18)])
axe &lt;- construct.axes(donnee, scale.unit = TRUE)
 
## Example2: MFA (two groups of variables)
data(chocolates) 
donnee &lt;- cbind.data.frame(sensochoc[,c(1,4,5:18)])
axe &lt;- construct.axes(donnee, group = c(6,8), 
    name.group = c("A-F","T-S"),scale.unit = TRUE)
</code></pre>

<hr>
<h2 id='cpa'>Consumers' Preferences Analysis</h2><span id='topic+cpa'></span>

<h3>Description</h3>

<p>Performs preference mapping techniques based on multidimensional exploratory data analysis. This methodology is
oriented towards consumers' preferences; here consumers are pictured according only to their preferences. 
In this manner, the distance between two consumers is very natural and easy to interpret, and a clustering of 
the consumers is also very easy to obtain. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpa(senso, hedo, coord=c(1,2), center = TRUE, scale = TRUE, 
    nb.clusters = 0, scale.unit = FALSE, 
    col = terrain.colors(45)[1:41])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpa_+3A_senso">senso</code></td>
<td>
<p>a data frame of dimension (<em>p,k</em>), where <em>p</em> is the number of products and <em>k</em> the
number of sensory descriptors</p>
</td></tr>
<tr><td><code id="cpa_+3A_hedo">hedo</code></td>
<td>
<p>a data frame of dimension (<em>p,j</em>), where <em>p</em> is the number of products and <em>j</em> the
number of consumers or panelists</p>
</td></tr>
<tr><td><code id="cpa_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="cpa_+3A_center">center</code></td>
<td>
<p>boolean, if TRUE then data are mean centered</p>
</td></tr>
<tr><td><code id="cpa_+3A_scale">scale</code></td>
<td>
<p>boolean, if TRUE then data are scaled to unit variance</p>
</td></tr>
<tr><td><code id="cpa_+3A_nb.clusters">nb.clusters</code></td>
<td>
<p>number of clusters to use (by default, 0 and the optimal numer of clusters is calculated</p>
</td></tr>
<tr><td><code id="cpa_+3A_scale.unit">scale.unit</code></td>
<td>
<p>boolean, if TRUE then PCA is made on scaled data</p>
</td></tr>
<tr><td><code id="cpa_+3A_col">col</code></td>
<td>
<p>color palette</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This methodology is oriented towards consumers' preferences; here, consumers are pictured according only to their preferences. 
In this manner, the distance between two consumers is very natural and easy to interpret, 
and a clustering of the consumers is also very easy to obtain using a classic hierarchical 
clustering procedure performed on Euclidian distances with the Ward's minimum variance criterion. 
The originality of the representation is that the characteristics of the products 
are also superimposed to the former picture.
</p>


<h3>Value</h3>

<p>Return the following results:
</p>
<table>
<tr><td><code>clusters</code></td>
<td>
<p>the cluster number allocated to each consumer</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>the coordinates of the panelists, of the clusters, of the archetypes</p>
</td></tr>
<tr><td><code>prod.clusters</code></td>
<td>
<p>a list with as many elements as there are clusters; each element of the list gathers
the specific products for its corresponding cluster</p>
</td></tr>
<tr><td><code>desc.clusters</code></td>
<td>
<p>the correlation coefficients between the average hedonic scores per cluster and the sensory descriptors</p>
</td></tr>
</table>
<p>A dendogram which highlight the clustering, a correlation circle that displays the hedonic scores, a graph of the consumers such as two consumers are all 
the more close that they do like the same products, as many graphs as there are variables: for a given variable, 
each consumer is colored according to the coefficient of correlation based on his hedonic scores and the variable.
</p>


<h3>Author(s)</h3>

<p>F Husson <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a> <br />
S Le 
</p>


<h3>References</h3>

<p>S. Le, F. Husson, J. Pages (2005). Another look at sensory data: how to &quot;have your salmon and eat it, too!&quot;. 
<em>6th Pangborn sensory science symposium, August 7-11, 2005, Harrogate, UK.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cocktail)
res.cpa = cpa(cbind(compo.cocktail, senso.cocktail), hedo.cocktail)
## If you prefer a graph in black and white and with 3 clusters
res.cpa = cpa(cbind(compo.cocktail, senso.cocktail), hedo.cocktail, 
    col = gray((50:1)/50), nb.clusters = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='cream_id'>Cream Ideal Data</h2><span id='topic+cream_id'></span>

<h3>Description</h3>

<p>The data used here refer to the sensory description of 9 dessert chocolate creams.<br />
</p>
<p>Each cream was evaluated once by 86 French consumers and described on 13 attributes according to the Ideal Profile Method.<br />
Both perceived and ideal intensities were asked. In addition, the overall liking is asked.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cream_id)</code></pre>


<h3>Format</h3>

<p>A data frame made of 86*9=774 rows and 2 qualitative variables (panelist and product),
13*2 attributes (perceived and ideal intensities) and overall liking.
</p>


<h3>Source</h3>

<p>Institut Agro, Melodie Sanchez, Sarah Sanchez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cream_id)
decat(cream_id, formul = "~product+user", firstvar = 3, graph = FALSE)

###IdMapConsumer function
data(cream_signa)
res.idmap &lt;- IdMapConsumer(craem_id, cream_signa, col.p=2, col.j=1, col.lik=29, 
num.col.var.signa=c(1:12), conf.level=0.90, id.recogn="id_", color = FALSE, simusigni = 500) 


## End(Not run)
</code></pre>

<hr>
<h2 id='cream_signa'>Data description of the consumers who made the Ideal for the cream</h2><span id='topic+cream_signa'></span>

<h3>Description</h3>

<p>The data used here refer to the sensory description of 9 dessert chocolate creams.<br />
</p>
<p>Each cream was evaluated once by 86 French consumers and described on 13 attributes according to the Ideal Profile Method.<br />
Both perceived and ideal intensities were asked. In addition, the overall liking is asked.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cream_signa)</code></pre>


<h3>Format</h3>

<p>A data frame made of 86*9=774 rows and 2 qualitative variables (panelist and product),
13*2 attributes (perceived and ideal intensities) and overall liking.
</p>


<h3>Source</h3>

<p>Institut Agro, Melodie Sanchez, Sarah Sanchez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cream_signa)
data(cream_signa)
res.idmap &lt;- IdMapConsumer(cream_id, cream_signa, col.p=2, col.j=1, col.lik=29, 
num.col.var.signa=c(1:12), conf.level=0.90, id.recogn="id_", color = FALSE, simusigni = 500) 


## End(Not run)
</code></pre>

<hr>
<h2 id='decat'>DEscription of CATegories</h2><span id='topic+decat'></span>

<h3>Description</h3>

<p>This function is designed to point out the variables that are the most characteristic according 
to the set of products in its whole, and to each of the products in particular. <br />
</p>
<p>This function is designed to test the main effect of a categorical variable (F-test) 
and the significance of its coefficients (T-test) for a set of endogenous variables 
and a given analysis of variance model.
In most cases, the main effect is the product effect and the endogenous variables are
the sensory descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decat(donnee, formul, firstvar, lastvar = length(colnames(donnee)), 
    proba = 0.05, graph = TRUE, col.lower = "mistyrose", 
    col.upper = "lightblue", nbrow = NULL, nbcol = NULL, random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decat_+3A_donnee">donnee</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>
<tr><td><code id="decat_+3A_formul">formul</code></td>
<td>
<p>the model that is to be tested</p>
</td></tr>
<tr><td><code id="decat_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="decat_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="decat_+3A_proba">proba</code></td>
<td>
<p>the significance threshold considered for the analyses of variance (by default 0.05)</p>
</td></tr>
<tr><td><code id="decat_+3A_graph">graph</code></td>
<td>
<p>a boolean, if TRUE a barplot of the P-values associated with the F-test of the product effet is displayed</p>
</td></tr>
<tr><td><code id="decat_+3A_col.lower">col.lower</code></td>
<td>
<p>the color used for 'level.lower'. Only useful if <code>graph</code> is TRUE</p>
</td></tr>
<tr><td><code id="decat_+3A_col.upper">col.upper</code></td>
<td>
<p>the color used for 'upper.lower'. Only useful if <code>graph</code> is TRUE</p>
</td></tr>
<tr><td><code id="decat_+3A_nbrow">nbrow</code></td>
<td>
<p>the number of rows to be displayed (by default, all the values are displayed). Only useful if <code>graph</code> is TRUE</p>
</td></tr>
<tr><td><code id="decat_+3A_nbcol">nbcol</code></td>
<td>
<p>the number of columns to be displayed (by default, all the values are displayed). Only useful if <code>graph</code> is TRUE</p>
</td></tr>
<tr><td><code id="decat_+3A_random">random</code></td>
<td>
<p>boolean, effect should be possible as fixed or random (default as random)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formul</code> parameter must be filled in by an analysis of variance model and must 
begin with the categorical variable of interest (e.g. the product effect)
followed by the different other factors of interest (and their combinations).
E.g.:<code>formul = "~Product+Panelist+Session"</code>.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>tabF</code></td>
<td>
<p>the V-test and the P-value of the F-test for each descriptor resulting from the analysis of variance model</p>
</td></tr>
<tr><td><code>tabT</code></td>
<td>
<p>a (products,descriptors) data frame, in which each cell is the Vtest for a given product and
a given descriptor</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>a (products,descriptors) data frame, in which each cell is the coefficient resulting
from the analysis of variance model for a given product and a given descriptor</p>
</td></tr>
<tr><td><code>resF</code></td>
<td>
<p>the V-test and the P-value for each descriptor resulting from the analysis of variance model, sorted in ascending order</p>
</td></tr>
<tr><td><code>resT</code></td>
<td>
<p>a list which elements are data frames, one data frame per product: 
the coefficient, the P-value and the Vtest for each significant descriptor resulting from the analysis of variance model, sorted in descending order</p>
</td></tr>
<tr><td><code>adjmean</code></td>
<td>
<p>a (products,descriptors) data frame, in which each cell is the adjusted mean resulting
from the analysis of variance model for a given product and a given descriptor</p>
</td></tr>
</table>
<p>A barplot of the P-values associated with the F-test of the product effet.<br />
A colored table with the adjusted means of the categorical variable: the values significantly different from the general mean are colored (significantly
different with the <code>proba</code> level); the significantly less are colored in red (by default) and the significantly great are colored in blue. 
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>References</h3>

<p>P. Lea, T. Naes, M. Rodbotten. <em>Analysis of variance for sensory data</em>.<br />
H. Sahai, M. I. Ageel. <em>The analysis of variance</em>.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+aov">aov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example 1
data(chocolates)
## model (AOV): " descriptor = product + panelist "
resdecat&lt;-decat(sensochoc, formul="~Product+Panelist", firstvar = 5)
barrow(resdecat$tabT)
barrow(t(resdecat$tabT), numr = 3, numc = 3)
barrow(resdecat$coeff, color = "orange") 

### Example 2
data(chocolates)
## model (AOV): " descriptor = product + panelist "
res2 &lt;-decat(sensochoc, formul="~Product+Panelist", firstvar = 5,
    proba=1, graph = FALSE)
</code></pre>

<hr>
<h2 id='fahst'>Factorial Approach for Hierarchical Sorting Task data</h2><span id='topic+fahst'></span>

<h3>Description</h3>

<p>Perform Factorial Approach for Hierarchical Sorting Task data (FAHST) on a table where the rows (i) are products and the columns (j) are for each consumer the partitionning variables associated with nested sorting. The columns are grouped by consumer.
For the partitionning variables, the label associated with a group can be an arbirary label (for example G1 for group 1, <em>etc.</em>) or the words associated with the group in the case of qualified hierarchical sorting.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fahst(don,group,alpha=0.05,graph=TRUE,axes=c(1,2),name.group=NULL,ncp=5,B=200,ncp.boot=2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fahst_+3A_don">don</code></td>
<td>
<p>a data frame with n rows (products) and p columns (nested partitions for all consumers)</p>
</td></tr>
<tr><td><code id="fahst_+3A_group">group</code></td>
<td>
<p>a list indicating the number of levels (nested partitions) for each consumer</p>
</td></tr>
<tr><td><code id="fahst_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="fahst_+3A_graph">graph</code></td>
<td>
<p>boolean, if TRUE a graph is displayed</p>
</td></tr>
<tr><td><code id="fahst_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="fahst_+3A_name.group">name.group</code></td>
<td>
<p>a vector containing the name of the consumers (by default, NULL and the consumers are named J1, J2 and so on)</p>
</td></tr>
<tr><td><code id="fahst_+3A_ncp">ncp</code></td>
<td>
<p>number of dimensions kept in the results (by default 5)</p>
</td></tr>
<tr><td><code id="fahst_+3A_b">B</code></td>
<td>
<p>the number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="fahst_+3A_ncp.boot">ncp.boot</code></td>
<td>
<p>number of dimensions used for the Procrustean rotations to build confidence ellipses (by default 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>eig</code></td>
<td>
<p>a matrix containing all the eigenvalues, the percentage of variance and the cumulative percentage of variance</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>a list of matrices containing all the results for the products (coordinates, square cosine, contributions)</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>a list of matrices containing all the results for the categories of the different nested partitions (coordinates, square cosine, contributions, v.test)</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>a list of matrices containing all the results for consumers (coordinates, square cosine, contributions)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list with some statistics</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>References</h3>

<p>Cadoret, M., Le, S., Pages, J. (2010) <em>A new approach for analyzing hierarchical sorting task data</em>. Sensometrics conference. Rotterdam, the Netherlands<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cards)
## Example of FAHST results
group.cards&lt;-c(2,3,3,2,2,4,2,3,2,1,3,2,3,3,3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3)
res.fahst&lt;-fahst(cards,group=group.cards)

## End(Not run)
</code></pre>

<hr>
<h2 id='fasnt'>Factorial Approach for Sorting Napping Task data</h2><span id='topic+fasnt'></span>

<h3>Description</h3>

<p>Perform Factorial Approach for Sorting Napping Task data (FASNT) on a table where the rows (i) are products and the columns (j) are for each consumer the coordinates of the products on the tablecloth associated with napping on the one hand and the partitionning variable associated with categorization on the other hand. The columns are grouped by consumer.
For the partitionning variable, the label associated with a group can be an arbirary label (for example G1 for group 1, <em>etc.</em>) or the words associated with the group in the case of qualified sorted napping.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fasnt(don,first="nappe",B=100,axes=c(1,2),alpha=0.05,ncp=5,
     graph=TRUE,name.group=NULL,sep.word=" ",word.min=5,ncp.boot=2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fasnt_+3A_don">don</code></td>
<td>
<p>a data frame with n rows (products) and p columns (assesor : categorical variables)</p>
</td></tr>
<tr><td><code id="fasnt_+3A_first">first</code></td>
<td>
<p>2 possibilities: &quot;nappe&quot; if the napping variables first appear for each consumer or &quot;catego&quot; if it is the categorization variable</p>
</td></tr>
<tr><td><code id="fasnt_+3A_b">B</code></td>
<td>
<p>the number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="fasnt_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="fasnt_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="fasnt_+3A_ncp">ncp</code></td>
<td>
<p>number of dimensions kept in the results (by default 5)</p>
</td></tr>
<tr><td><code id="fasnt_+3A_graph">graph</code></td>
<td>
<p>boolean, if TRUE a graph is displayed</p>
</td></tr>
<tr><td><code id="fasnt_+3A_name.group">name.group</code></td>
<td>
<p>a vector containing the name of the consumers (by default, NULL and the group are named J1, J2 and so on)</p>
</td></tr>
<tr><td><code id="fasnt_+3A_sep.word">sep.word</code></td>
<td>
<p>the word separator character in the case of qualified sorted napping</p>
</td></tr>
<tr><td><code id="fasnt_+3A_word.min">word.min</code></td>
<td>
<p>minimum sample size for the word selection in textual analysis</p>
</td></tr>
<tr><td><code id="fasnt_+3A_ncp.boot">ncp.boot</code></td>
<td>
<p>number of dimensions used for the Procrustean rotations to build confidence ellipses (by default 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>eig</code></td>
<td>
<p>a matrix containing all the eigenvalues, the percentage of variance and the cumulative percentage of variance</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>a list of matrices containing all the results for the products (coordinates, square cosine, contributions)</p>
</td></tr>
<tr><td><code>quali.var</code></td>
<td>
<p>a list of matrices containing all the results for the categories of categorization (coordinates, square cosine, contributions, v.test)</p>
</td></tr>
<tr><td><code>quanti.var</code></td>
<td>
<p>a list of matrices containing all the results for the napping (coordinates, square cosine, contributions, v.test)</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>a list of matrices containing all the results for consumers (coordinates, square cosine, contributions)</p>
</td></tr>
<tr><td><code>indicator</code></td>
<td>
<p>a list of matrices containing different indicators for napping and categorization</p>
</td></tr>
<tr><td><code>textual</code></td>
<td>
<p>the results of the textual analysis for the products</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list with some statistics</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>References</h3>

<p>Pag\'es, J., Le, S., Cadoret, M. (2010) <em>The Sorted Napping: a new holistic approach in sensory evaluation</em>. Journal of Sensory Studies<br />
Cadoret, M., Le, S., Pages, J. (2009) <em>Combining the best of two worlds, the &quot;sorted napping&quot;</em>. SPISE. Ho Chi Minh City, Vietnam<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(smoothies)
## Example of FASNT results
res.fasnt&lt;-fasnt(smoothies,first="nappe",sep.word=";")

## End(Not run)
</code></pre>

<hr>
<h2 id='fast'>Factorial Approach for Sorting Task data</h2><span id='topic+fast'></span>

<h3>Description</h3>

<p>Perform Factorial Approach for Sorting Task data (FAST) on a table where the rows (i) are products and the columns (j) are consumers.
A cell (i,j) corresponds either to the number of the group to which the product i belongs for the consumer j, or, in the case of &quot;qualified&quot; categorization, to the sequence of words associted with the group to which the product i belongs for the consumer j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast(don,alpha=0.05,sep.words=" ",word.min=5,graph=TRUE,axes=c(1,2),
     ncp=5,B=200,label.miss=NULL,ncp.boot=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_+3A_don">don</code></td>
<td>
<p>a data frame with n rows (products) and p columns (assesor : categorical variables)</p>
</td></tr>  
<tr><td><code id="fast_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="fast_+3A_sep.words">sep.words</code></td>
<td>
<p>the word separator character in the case of qualified categorization</p>
</td></tr>
<tr><td><code id="fast_+3A_word.min">word.min</code></td>
<td>
<p>minimum sample size for the word selection in textual analysis</p>
</td></tr>
<tr><td><code id="fast_+3A_graph">graph</code></td>
<td>
<p>boolean, if TRUE a graph is displayed</p>
</td></tr>
<tr><td><code id="fast_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="fast_+3A_ncp">ncp</code></td>
<td>
<p>number of dimensions kept in the results (by default 5)</p>
</td></tr>
<tr><td><code id="fast_+3A_b">B</code></td>
<td>
<p>the number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="fast_+3A_label.miss">label.miss</code></td>
<td>
<p>label associated with missing groups in the case of incomplete data set</p>
</td></tr>
<tr><td><code id="fast_+3A_ncp.boot">ncp.boot</code></td>
<td>
<p>number of dimensions used for the Procrustean rotations to build confidence ellipses (by default NULL and the number of components is estimated)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>eig</code></td>
<td>
<p>a matrix containing all the eigenvalues, the percentage of variance and the cumulative percentage of variance</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>a list of matrices containing all the results for the categories (coordinates, square cosine, contributions, v.test)</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>a list of matrices containing all the results for the products (coordinates, square cosine, contributions)</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>a list of matrices containing all the results for consumers (coordinates, square cosine, contributions)</p>
</td></tr>
<tr><td><code>acm</code></td>
<td>
<p>all the results of the MCA</p>
</td></tr>
<tr><td><code>cooccur</code></td>
<td>
<p>the reordered co-occurrence matrix among products</p>
</td></tr>
<tr><td><code>reord</code></td>
<td>
<p>the reordered matrix products*consumers</p>
</td></tr>
<tr><td><code>cramer</code></td>
<td>
<p>the Cramer's V matrix between all the consumers</p>
</td></tr>
<tr><td><code>textual</code></td>
<td>
<p>the results of the textual analysis for the products</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list with some statistics</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>References</h3>

<p>Cadoret, M., Le, S., Pages, J. (2008) <em>A novel Factorial Approach for analysing Sorting Task data</em>. 9th Sensometrics meeting. St Catharines, Canada<br />
Cadoret, M., Le, S., Pages, J. (2009) <em>A Factorial Approach for Sorting Task data (FAST)</em>. Food Quality and Preference.  20. pp. 410-417<br />
Cadoret, M., Le, S., Pages, J. (2009) <em>Missing values in categorization</em>. Applied Stochastic Models and Data Analysis (ASMDA). Vilnius, Lithuania<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume)
## Example of FAST results
res.fast&lt;-fast(perfume,sep.words=";")
res.consensual&lt;-ConsensualWords(res.fast)

## End(Not run)
</code></pre>

<hr>
<h2 id='fcp'>Free choice profiling</h2><span id='topic+fcp'></span>

<h3>Description</h3>

<p>Free choice profiling with confidence ellipses</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcp(X,group,scale=TRUE, ncp = NULL, axes=c(1,2), name.group = NULL, level.conf = 0.95, 
    nbsim=500, nbchoix=NULL, cex=1, color=NULL, title=NULL, new.plot=TRUE, 
	graph=c("ind","var","ellipse"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcp_+3A_x">X</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="fcp_+3A_group">group</code></td>
<td>
<p>a list indicating the number of variables in each group; used when method=&quot;freechoice&quot; or method=&quot;hsort&quot;</p>
</td></tr>
<tr><td><code id="fcp_+3A_scale">scale</code></td>
<td>
<p>boolean, used when method=&quot;freechoice&quot;; if TRUE, the variables are scaled</p>
</td></tr>
<tr><td><code id="fcp_+3A_ncp">ncp</code></td>
<td>
<p>number of components used to procrustes the virtual subspaces on the true subspace; NULL by default and the number of components is estimated</p>
</td></tr>
<tr><td><code id="fcp_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="fcp_+3A_name.group">name.group</code></td>
<td>
<p>the names of each group of variables</p>
</td></tr>
<tr><td><code id="fcp_+3A_level.conf">level.conf</code></td>
<td>
<p>confidence level used to construct the ellipses. By default, 0.95</p>
</td></tr>
<tr><td><code id="fcp_+3A_nbsim">nbsim</code></td>
<td>
<p>the number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="fcp_+3A_nbchoix">nbchoix</code></td>
<td>
<p>the number of panelists forming a virtual panel, by default the number of panelists in the original panel</p>
</td></tr>
<tr><td><code id="fcp_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="fcp_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="fcp_+3A_title">title</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="fcp_+3A_new.plot">new.plot</code></td>
<td>
<p>boolean, if TRUE, a new graphical device is created</p>
</td></tr>
<tr><td><code id="fcp_+3A_graph">graph</code></td>
<td>
<p>list with the graphs to draw; &quot;ind&quot;, &quot;var&quot; and &quot;ellipse&quot; by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform MFA on the data frame and calculate confidence ellipses around the products
</p>


<h3>Value</h3>

<p>Returns a list with the result of the MFA and the bootstraped results that can be used with the plotellipse function.
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume_fcp)
res &lt;- fcp(perfume_fcp, group = c(12,7,7,7,6,8))

## End(Not run)
</code></pre>

<hr>
<h2 id='format_holos'>Format Holos data</h2><span id='topic+format_holos'></span>

<h3>Description</h3>

<p>Format the data exported from the Holos platform.</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_holos(path.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_holos_+3A_path.data">path.data</code></td>
<td>
<p>The path corresponding to the folder containing all Holos data (i.e. one folder per subject with different files: &quot;X_comment.txt&quot;, &quot;X_data.txt&quot;, &quot;X_last.txt&quot;, &quot;X_txt&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 4 objects: <code>IDsubjects</code>, a dataframe containing the concordance between the names of the subjects as given in the Holos experiment and their ID; <code>datadigit</code>, a list of S (S = number of subjects) dataframes corresponding to the digit-tracking data; <code>datafinal_coord</code>, a list of S (S = number of subjects) dataframes corresponding to the final configurations data; and <code>datafinal_verb</code>, a list of S (S = number of subjects) dataframes corresponding to the final verbalization data.</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyse_holos">analyse_holos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- format_holos(path.data = "C:/MyDirectory/")
## End(Not run)
</code></pre>

<hr>
<h2 id='graphinter'>Graphical display of the interaction between two qualitative variables</h2><span id='topic+graphinter'></span>

<h3>Description</h3>

<p>This function is designed to display the interaction between two qualitative variables, in most cases
the <em>product</em> and the <em>session</em> variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphinter(donnee, col.p, col.j, firstvar, lastvar=ncol(donnee), 
    numr = 2,numc = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphinter_+3A_donnee">donnee</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>  
<tr><td><code id="graphinter_+3A_col.p">col.p</code></td>
<td>
<p>the position of one categorical variables of interest (the <em>product</em> variable)</p>
</td></tr>
<tr><td><code id="graphinter_+3A_col.j">col.j</code></td>
<td>
<p>the position of one categorical variables of interest (the <em>session</em> variable)</p>
</td></tr>
<tr><td><code id="graphinter_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="graphinter_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="graphinter_+3A_numr">numr</code></td>
<td>
<p>the number of graphs per row (by default 2)</p>
</td></tr>
<tr><td><code id="graphinter_+3A_numc">numc</code></td>
<td>
<p>the number of graphs per column (by default 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data set must be balanced (or not unbalanced too much).
</p>


<h3>Value</h3>

<p>If the variables of interest are the <em>product</em> and the <em>session</em> variables, 
a list containing the following components:
</p>
<table>
<tr><td><code>prod</code></td>
<td>
<p>a data frame of dimension (<em>p,q</em>), the means over the panelists and the sessions for the
<em>p</em> products and the <em>q</em> sensory descriptors</p>
</td></tr>
<tr><td><code>seance</code></td>
<td>
<p>as many matrices of dimension (<em>p,q</em>) as there are sessions, 
the means over the panelists for the <em>p</em> products, the <em>q</em> sensory descriptors and for each session</p>
</td></tr>
</table>
<p>The graphical display of the interaction for each sensory descriptor.
</p>


<h3>Author(s)</h3>

<p>F Husson, S Le</p>


<h3>References</h3>

<p>P. Lea, T. Naes, M. Rodbotten. <em>Analysis of variance for sensory data</em>. <br />
H. Sahai, M. I. Ageel. <em>The analysis of variance</em>.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+aov">aov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(chocolates)
graphinter(sensochoc, col.p = 4, col.j = 2, firstvar = 5, lastvar = 12,
    numr = 1, numc = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='hedo.cocktail'>Cocktails hedonic scores</h2><span id='topic+hedo.cocktail'></span>

<h3>Description</h3>

<p>The data used here refer to 16 cocktails.
Each cocktail was evaluated on a structured scale from 0 to 10, 
by 100 consumers, according to their liking (0) or disliking (10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cocktail)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows and 100 columns: each row corresponds to a cocktail
and each column to the hedonic scores given by one of the 100 consumers participating in the study.
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cocktail)
</code></pre>

<hr>
<h2 id='hedochoc'>Chocolates hedonic scores</h2><span id='topic+hedochoc'></span>

<h3>Description</h3>

<p>The data used here refer to six varieties of chocolates sold in France.
Each chocolate was evaluated on a structured scale from 0 to 10, 
by 222 consumers, according to their liking (0) or disliking (10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chocolates)</code></pre>


<h3>Format</h3>

<p>A data frame with 6 rows and 222 columns: each row corresponds to a chocolate
and each column to the hedonic scores given by one of the 222 consumers participating in the study.
</p>


<h3>Source</h3>

<p>Agrocampus Rennes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
</code></pre>

<hr>
<h2 id='histprod'>Histogram for each descriptor</h2><span id='topic+histprod'></span>

<h3>Description</h3>

<p>Computes automatically histograms for a set of quantitative variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histprod(donnee, firstvar, lastvar = ncol(donnee), numr = 2, 
    numc = 2, adjust = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histprod_+3A_donnee">donnee</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="histprod_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="histprod_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="histprod_+3A_numr">numr</code></td>
<td>
<p>the number of histograms per row (by default 2)</p>
</td></tr>
<tr><td><code id="histprod_+3A_numc">numc</code></td>
<td>
<p>the number of histograms per column (by default 2)</p>
</td></tr>
<tr><td><code id="histprod_+3A_adjust">adjust</code></td>
<td>
<p>the bandwidth used is actually 'adjust*bw'. This makes it easy to specify values like &quot;half the default&quot; bandwidth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Displays histograms with a common Y-axis as well as the local estimator of the density for each descriptor, hence the
<code>adjust</code> parameter to fill in. Displays also the normal distribution with mean and variance the respective values
estimated for each descriptor.
</p>


<h3>Author(s)</h3>

<p>S Le
</p>


<h3>See Also</h3>

 
<p><code><a href="stats.html#topic+density">density</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
histprod(sensochoc, firstvar = 5, lastvar = 10)
</code></pre>

<hr>
<h2 id='hsortplot'>Plot consumers' hierarchical sorting</h2><span id='topic+hsortplot'></span>

<h3>Description</h3>

<p>Plot consumers' hierarchical sorting</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsortplot(don, group, numr = 2, numc = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsortplot_+3A_don">don</code></td>
<td>
<p>a data frame with n rows (products) and p columns (nested partitions for all consumers)</p>
</td></tr>
<tr><td><code id="hsortplot_+3A_group">group</code></td>
<td>
<p>a list indicating the number of levels (nested partitions) for each consumer</p>
</td></tr>
<tr><td><code id="hsortplot_+3A_numr">numr</code></td>
<td>
<p>the number of hierarchical sorting per row (by default 2)</p>
</td></tr>
<tr><td><code id="hsortplot_+3A_numc">numc</code></td>
<td>
<p>the number of hierarchical sorting per column (by default 2)</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The data used here refer to a specific experiment, where children were asked to provide hierarchical sorting (several nested partitions) from 16 cards.
</p>


<h3>Value</h3>

<p>Returns as many graphs as there are consumers, each graph represents hierarchical sorting provided by a consumer</p>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+fahst">fahst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cards)
group.cards&lt;-c(2,3,3,2,2,4,2,3,2,1,3,2,3,3,3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3)
hsortplot(cards,group.cards)

## End(Not run)
</code></pre>

<hr>
<h2 id='IdMap'>Ideal Mapping (IdMap)</h2><span id='topic+IdMap'></span>

<h3>Description</h3>

<p>Create the ideal map, a map based on the ideal profiles provided by the consumers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IdMap(dataset, col.p, col.j, col.lik, id.recogn, nbsimul=500, nbchoix=NULL,
      alpha=0.05, coord=c(1,2), precision=0.1, levels.contour=NULL, 
	  color=FALSE, cons.eq=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IdMap_+3A_dataset">dataset</code></td>
<td>
<p>A matrix with at least two qualitative variables (<em>consumer</em> and <em>products</em>)
and a set of quantitative variables containing at least 2*A variables (for both <em>perceived</em> and <em>ideal</em> intensities)</p>
</td></tr>
<tr><td><code id="IdMap_+3A_col.p">col.p</code></td>
<td>
<p>The position of the <em>product</em> variable </p>
</td></tr>
<tr><td><code id="IdMap_+3A_col.j">col.j</code></td>
<td>
<p>The position of the <em>consumer</em> variable </p>
</td></tr>
<tr><td><code id="IdMap_+3A_col.lik">col.lik</code></td>
<td>
<p>The position of the <em>liking</em> variable </p>
</td></tr>
<tr><td><code id="IdMap_+3A_id.recogn">id.recogn</code></td>
<td>
<p>The sequence in the variable names which distinguish the ideal
variables from the sensory variables. This sequence should be fixed and unique. <br />
Each ideal variable should be preceded by the corresponding perceived intensity variable. </p>
</td></tr>
<tr><td><code id="IdMap_+3A_nbchoix">nbchoix</code></td>
<td>
<p>The number of consumers forming a virtual panel, by default the number of panelists in the original panel</p>
</td></tr>
<tr><td><code id="IdMap_+3A_nbsimul">nbsimul</code></td>
<td>
<p>The number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="IdMap_+3A_alpha">alpha</code></td>
<td>
<p>The confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="IdMap_+3A_coord">coord</code></td>
<td>
<p>A length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="IdMap_+3A_precision">precision</code></td>
<td>
<p>The value defining the step when gridding the space</p>
</td></tr>
<tr><td><code id="IdMap_+3A_levels.contour">levels.contour</code></td>
<td>
<p>The levels (between 0 and 1) to consider for the colors on the surface plot.
By default, they are set automatically based on the results</p>
</td></tr>
<tr><td><code id="IdMap_+3A_color">color</code></td>
<td>
<p>Boolean, define whether the map is in color or in black and white</p>
</td></tr>
<tr><td><code id="IdMap_+3A_cons.eq">cons.eq</code></td>
<td>
<p>Boolean, define whether the IdMap (by default) or the wIdMap is performed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IdMap, step by step:<br />
Step 1: the sensory and ideal variables are separated into two tables.<br />
Step 2: the product space is created by PCA on the averaged sensory table (averaged by product).<br />
Step 3: the averaged ideal product of each consumer is projected as supplementary entities in this space.<br />
Step 4: confidence ellipses are created around each individual averaged ideal product using truncated total bootstrap.<br />
Step 5: for each consumer, the space is grid and the position where the ideal area
is defined is marked: individual surfaces of response are created.<br />
Step 6: (optional) the ellipses can be balanced by applying individual weight
(all the ellipses have a weigth of 1, however the size of the ellipse). wIdMap is then performed.<br />
Step 7: all the individual surface plots are added together and a surface plot is created.<br />
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>PCA</code></td>
<td>
<p>the results from the PCA used to create the sensory space</p>
</td></tr>
<tr><td><code>idmap</code></td>
<td>
<p>a list containing the results of the IdMap (<em>data</em>), the weight for each consumer (<em>j.weight</em>)
and the precision used.</p>
</td></tr>
<tr><td><code>ideal</code></td>
<td>
<p>a list containing the estimated profile of the ideal of reference (not available for the wIdMap) 
as well as the percentage of consumers concerned</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Worch Thierry (thierry@qistatistics.co.uk)</p>


<h3>References</h3>

<p>Worch, T., Le, S., Punter, P., Pages, J. (2012).
Construction of an Ideal Map (IdMap) based on the ideal profiles obtained directly from consumers.
<em>Food Quality and Preference</em>, 26, 93-104.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.IdMap">plot.IdMap</a></code>, <code><a href="#topic+carto">carto</a></code>, <code><a href="#topic+boot">boot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume_ideal)

#! For the IdMap
res.IdMap &lt;- IdMap(perfume_ideal, col.p=2, col.j=1, 
   col.lik=ncol(perfume_ideal), id.recogn="id_")
plot.IdMap(res.IdMap, xlim=c(-7,10), ylim=c(-5,7), levels.contour=NULL, color=TRUE)

#! For the wIdMap
res.wIdMap &lt;- IdMap(perfume_ideal, col.p=2, col.j=1, col.lik=ncol(perfume_ideal), 
   id.recogn="id_", cons.eq=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='IdMapConsumer'>Ideal Mapping by categories (IdMapConsumer)</h2><span id='topic+IdMapConsumer'></span>

<h3>Description</h3>

<p>Create the ideal map and plot the ideal areas of the categories of qualitative variables. 
And perform 2 tests: a global test in order to highlight the significance of the difference between ideals of all the categories of the same variable; 
a pair comparison test to highlight the significance between 2 categories of the same variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>IdMapConsumer(dataset.id, dataset.signa, col.p, col.j, col.lik, 
	num.col.var.signa, conf.level=0.95, id.recogn, nbchoix = NULL,
    nbsimul = 500, alpha = 0.05, coord = c(1, 2), precision = 0.1,
    levels.contour = NULL, color = FALSE, simusigni = 500) 
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IdMapConsumer_+3A_dataset.id">dataset.id</code></td>
<td>
<p>A matrix with at least two qualitative variables (<em>consumer</em> and <em>products</em>)
and a set of quantitative variables containing at least 2*A variables (for both <em>perceived</em> and <em>ideal</em> intensities)</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_dataset.signa">dataset.signa</code></td>
<td>
<p>a data frame with n rows (individuals) and p columns (categorical variables)</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_col.p">col.p</code></td>
<td>
<p>The position of the <em>product</em> variable in the dataframe <em>dataset.id</em></p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_col.j">col.j</code></td>
<td>
<p>The position of the <em>consumer</em> variable  in the dataframe <em>dataset.id</em></p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_col.lik">col.lik</code></td>
<td>
<p>The position of the <em>liking</em> variable  in the dataframe <em>dataset.id</em></p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_id.recogn">id.recogn</code></td>
<td>
<p>The sequence in the variable names which distinguish the ideal
variables from the sensory variables. This sequence should be fixed and unique. <br />
Each ideal variable should be preceeded by the corresponding perceived intensity variable.</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_num.col.var.signa">num.col.var.signa</code></td>
<td>
<p>The position of the categorical variables in the dataframe <em>dataset.signa</em> you want to plot the ideal area 
of the different modalities/you want to know if the ideal product of the different modalities is significantly different</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_conf.level">conf.level</code></td>
<td>
<p>Threshold used for the tests</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_nbchoix">nbchoix</code></td>
<td>
<p>The number of consumers forming a virtual panel, by default the number of panelists in the original panel</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_nbsimul">nbsimul</code></td>
<td>
<p>The number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_alpha">alpha</code></td>
<td>
<p>The confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_coord">coord</code></td>
<td>
<p>A length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_precision">precision</code></td>
<td>
<p>The value defining the step when gridding the space</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_levels.contour">levels.contour</code></td>
<td>
<p>The levels (between 0 and 1) to consider for the colors on the surface plot.
By default, they are set automatically based on the results</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_color">color</code></td>
<td>
<p>Boolean, define whether the map is in color or in black and white</p>
</td></tr>
<tr><td><code id="IdMapConsumer_+3A_simusigni">simusigni</code></td>
<td>
<p>The number of simulations used to perform the global and the pair comparison test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IdMapConsumer, step by step:
Step 1: the classical IdMap is plotted with the method &quot;ellipses&quot;<br />
Step 2: for each modality of the categorical variable, the optimum of the ideal area is calculated with the method &quot;density&quot;<br />
Step 3: for each categorical variable given in <em>num.col.var.signa</em>, simulations are performed giving the p-value 
for the global ant the pair comparison test. <br />
Step 4: if the global test is significant for a variable, the ideal areas of its modalities are plotted on the IdMap
</p>
<p>This function needs the KernSmooth package.</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>PCA</code></td>
<td>
<p>the results from the PCA used to create the sensory space</p>
</td></tr>
<tr><td><code>idmap</code></td>
<td>
<p>a list containing the results of the IdMap (<em>data</em>), the weight for each consumer (<em>j.weight</em>)
and the precision used.</p>
</td></tr>
<tr><td><code>ideal</code></td>
<td>
<p>a list containing the estimated profile of the ideal of reference (not available for the wIdMap) 
as well as the percentage of consumers concerned</p>
</td></tr>
<tr><td><code>coordobs</code></td>
<td>
<p>The coordinates of all the ideals of all the categories on the sensory space</p>
</td></tr>
<tr><td><code>test.global</code></td>
<td>
<p>The results for the global test for each variables (observed inertia, critical inertia, P-value)</p>
</td></tr>
<tr><td><code>test.paires</code></td>
<td>
<p>The results for the pair comparison test  for each variables, between its ideal's categories(observed distance between two categories, critical distance, P-value)</p>
</td></tr>
</table>
<p>The three last components are provided only if the user choose &quot;color = FALSE&quot;, else no test and no ideal map with categories' ideal are performed.
</p>


<h3>Author(s)</h3>

<p>Melodie Sanchez, Sarah Sanchez, francois.husson@institut-agro.fr</p>


<h3>References</h3>

<p>Worch, T., Le, S., Punter, P., &amp; Pages, J. (2012).
Construction of an Ideal Map (IdMap) based on the ideal profiles obtained directly from consumers.
<em>Food Quality and Preference</em>, 26, 93-104.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+IdMap">IdMap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###Load the two datasets
data(cream_id)
data(cream_signa)

###Run the analysis and test the ideals of the variables from 1 to 12 
## for example with a confidence level of 90
res.idmap &lt;- IdMapConsumer(cream_id, cream_signa, col.p=2, col.j=1, col.lik=29, 
   num.col.var.signa=c(1:12),conf.level=0.90,id.recogn="id_") 

## End(Not run)
</code></pre>

<hr>
<h2 id='indscal'>Construct the Indscal model for Napping data type</h2><span id='topic+indscal'></span>

<h3>Description</h3>

<p>This version of the Indscal model is specially adapted to Napping data type, i.e. products (stimuli)
are positioned on a tableclothe by panelists, then their coordinates are used as input for the Indscal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indscal(matrice, matrice.illu = NULL, maxit = 200, coord = c(1,2), 
    eps = 1/10^5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indscal_+3A_matrice">matrice</code></td>
<td>
<p>a data frame of dimension (<em>p,2j</em>),
where <em>p</em> represents the number of products and <em>j</em> the number 
of panelists (two coordinates per panelist)</p>
</td></tr>
<tr><td><code id="indscal_+3A_matrice.illu">matrice.illu</code></td>
<td>
<p>a data frame with illustrative variables (with the same row.names in common as in <code>matrice</code>)</p>
</td></tr>  
<tr><td><code id="indscal_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations until the algorithm stops</p>
</td></tr>  
<tr><td><code id="indscal_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="indscal_+3A_eps">eps</code></td>
<td>
<p>a threshold with respect to which the algorithm stops, i.e. when the difference between 
the criterion function at step <em>n</em> and <em>n+1</em> is less than <code>eps</code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Returns a list including:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>a matrix with the subject coordinates</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>a matrix with the stimuli (individuals) coordinates</p>
</td></tr>
<tr><td><code>subvar</code></td>
<td>
<p>a vector with the strain between each configuration and the stimuli configuration</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>the strain criterion</p>
</td></tr>
</table>
<p>The functions returns the three following graphs: <br />
A stimuli representation, ie. a representation of the products<br />
A representation of the weights computed by the Indscal model.<br />
A correlation circle of the variables enhanced by illustrative variables (supplementary columns)
</p>


<h3>Author(s)</h3>

<p>Peter Ellis <br />
Francois Husson</p>


<h3>References</h3>

<p>Carroll, J.D. &amp; J.J. Chang (1970). Analysis of individual differences in multidimensional scaling via an N-way generalization of &quot;Eckart-Young&quot; decomposition. <em>Psychometrika</em>, 35, 283-319.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nappeplot">nappeplot</a></code>, <code><a href="#topic+pmfa">pmfa</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(napping)
nappeplot(napping.don)
resindscal&lt;- indscal(napping.don, napping.words)
prefpls(cbind(resindscal$points, napping.words))
pmfa(napping.don, napping.words, mean.conf = resindscal$points)

## End(Not run)
</code></pre>

<hr>
<h2 id='interact'>Estimation of interaction coefficients</h2><span id='topic+interact'></span>

<h3>Description</h3>

<p>Computes automatically the interaction coefficients between two quantitative variables
<code>col.p</code> and <code>col.j</code> for the following model:
<code>"~col.p+col.j+col.p:col.j"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interact(donnee, col.p, col.j, firstvar, lastvar = ncol(donnee))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interact_+3A_donnee">donnee</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>
<tr><td><code id="interact_+3A_col.p">col.p</code></td>
<td>
<p>the position of the <em>product</em> effect for instance</p>
</td></tr>
<tr><td><code id="interact_+3A_col.j">col.j</code></td>
<td>
<p>the position of the <em>panelist</em> effect for instance</p>
</td></tr>
<tr><td><code id="interact_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="interact_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases <code>col.p</code> represents the <em>product</em> effect, <code>col.j</code> represents the <em>panelist</em> effect,
and the variables of interest are the sensory descriptors. The model considered is the following one:
<code>"~Product+Panelist+Product:Panelist"</code>.<br />
Data must be complete (but not necessarily balanced).
</p>


<h3>Value</h3>

<p>Returns an array of dimension (<em>p,j,k</em>), where <em>p</em> is the number of products, <em>j</em> the number of panelists
and <em>k</em> the number of sensory descriptors.
The entries of this array are the interaction coefficients between a panelist and a product for a given descriptor. <br />
For each sensory descriptor, returns a graph where each (panelist,product) interaction coefficient is displayed,
a graph where the contribution to the (panelist,product) interaction coefficient by product is displayed,
a graph where the contribution to the (panelist,product) interaction coefficient by panelist is displayed.
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aov">aov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(chocolates)
resinteract=interact(sensochoc, col.p = 4, col.j = 1, firstvar = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='JAR'>JAR</h2><span id='topic+JAR'></span>

<h3>Description</h3>

<p>Just About Right</p>


<h3>Usage</h3>

<pre><code class='language-R'>JAR(x, col.p, col.j, col.pref, jarlevel="jar")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JAR_+3A_x">x</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="JAR_+3A_col.p">col.p</code></td>
<td>
<p>the position of the <em>product</em> variable</p>
</td></tr>
<tr><td><code id="JAR_+3A_col.j">col.j</code></td>
<td>
<p>the position of the <em>panelist</em> variable</p>
</td></tr>
<tr><td><code id="JAR_+3A_col.pref">col.pref</code></td>
<td>
<p>the position of the <em>preference</em> variable</p>
</td></tr>
<tr><td><code id="JAR_+3A_jarlevel">jarlevel</code></td>
<td>
<p>a string corresponding to the jar level (the level must be the same for all the jar variables)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform the penalty analysis. Two models are constructed.<br />
The one-dimensional model is constructed descriptor by descriptor. For descriptor_j the model is:<br />
Hedonic score = Descriptor_j_Not enough+ Descriptor_j_Too much <br />
The multi-dimensional model is constructed with all descriptors simultaneously:<br />
Hedonic score = Descriptor_1_Not enough+ Descriptor_1_Too much +...+ Descriptor_p_Not enough+ Descriptor_p_Too much+ Product + Judge<br />
</p>


<h3>Value</h3>

<p>Returns a list of 3 objects. <br />
The penalty1 object corresponds to the one-dimensional penalty results: a data-frame with the penalty coefficient in the first column, the standard deviation and the p-value for the test that the penalty is significantly different from 0.<br />
The penalty2 object corresponds to the mutli-dimensional penalty results: a data-frame with the penalty coefficient in the first column, the standard deviation and the p-value for the test that the penalty is significantly different from 0.
The Frequency object gives the percentage of times the non-jar categories are given for each product: a matrix with the non-jar categories in rows and the products in columns</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.JAR">plot.JAR</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(JAR)
res.jar &lt;- JAR(JAR,col.p=13,col.j=1,col.pref=2)
plot(res.jar,name.prod="284", model=1)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='magicsort'>Returns a sorted data matrix</h2><span id='topic+magicsort'></span>

<h3>Description</h3>

<p>Sort the rows and columns of a matrix in a &quot;magic&quot; order or by ascending (or descending) mean or median or geometrical mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magicsort(matrice, sort.mat = matrice, method = "magic",
    byrow = TRUE, bycol = TRUE, ascending = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magicsort_+3A_matrice">matrice</code></td>
<td>
<p>a data matrix to sort</p>
</td></tr>
<tr><td><code id="magicsort_+3A_sort.mat">sort.mat</code></td>
<td>
<p>sort the rows and columns according to the result of the PCA made on this matrix (by default the <code>matrice</code>)</p>
</td></tr>
<tr><td><code id="magicsort_+3A_method">method</code></td>
<td>
<p>four types of calculations, magic (<code>"magic"</code>), (<code>"median"</code>), arithmetical (<code>"mean"</code>) or geometrical (<code>"geo"</code>) mean (by default magic)</p>
</td></tr>
<tr><td><code id="magicsort_+3A_byrow">byrow</code></td>
<td>
<p>boolean, if TRUE then data are sorted over the rows</p>
</td></tr>
<tr><td><code id="magicsort_+3A_bycol">bycol</code></td>
<td>
<p>boolean, if TRUE then data are sorted over the columns</p>
</td></tr>
<tr><td><code id="magicsort_+3A_ascending">ascending</code></td>
<td>
<p>boolean, if TRUE then data are sorted in ascending order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Very useful function to compare results.
</p>


<h3>Author(s)</h3>

<p>F Husson, S Le</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
data(chocolates)
resdecat&lt;-decat(sensochoc, formul = "~Product", firstvar = 5, 
    graph = FALSE)
coltable(magicsort(resdecat$tabT), level.lower = -1.96, 
    level.upper = 1.96, main.title = "Products' description")

## Example 2
data(chocolates)
resperf&lt;-paneliperf(sensochoc, 
    formul = "~Product+Panelist+Product:Panelist",
    formul.j = "~Product", col.j = 1, firstvar = 5, lastvar = 12,
    synthesis = FALSE, graph = FALSE)
res.sort=magicsort(resperf$prob.ind, method = "median")
coltable(res.sort, main.title = "P-values of the F-test by panelist")
</code></pre>

<hr>
<h2 id='MultiIdeal'>Single vs. Multiple Ideal</h2><span id='topic+MultiIdeal'></span>

<h3>Description</h3>

<p>By the use of confidence ellipses, this procedure checks whether consumers
associate the different products tested to a single or to multiple ideals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiIdeal(dataset, col.p, col.j, id.recogn, level.search.desc=0.2, correct=FALSE,
            nbchoix=NULL, nbsimul=500, coord=c(1,2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiIdeal_+3A_dataset">dataset</code></td>
<td>
<p>A matrix with at least two qualitative variables (<em>consumer</em> and <em>products</em>)
and a set of quantitative variables containing at least 2*A variables (for both <em>perceived</em> and <em>ideal</em> intensities)</p>
</td></tr>
<tr><td><code id="MultiIdeal_+3A_col.p">col.p</code></td>
<td>
<p>The position of the <em>product</em> variable </p>
</td></tr>
<tr><td><code id="MultiIdeal_+3A_col.j">col.j</code></td>
<td>
<p>The position of the <em>consumer</em> variable </p>
</td></tr>
<tr><td><code id="MultiIdeal_+3A_id.recogn">id.recogn</code></td>
<td>
<p>The sequence in the variable names which distinguish the ideal
variables from the sensory variables. This sequence should be fixed and unique. <br />
Each ideal variable should be preceeded by the corresponding perceived intensity variable. </p>
</td></tr>
<tr><td><code id="MultiIdeal_+3A_level.search.desc">level.search.desc</code></td>
<td>
<p>the threshold above which a descriptor is not considered as discriminant according to AOV model &quot;descriptor=Product+Panelist&quot;.</p>
</td></tr>
<tr><td><code id="MultiIdeal_+3A_correct">correct</code></td>
<td>
<p>Boolean, define whether the ideal products should be corrected from the difference in the use of the scale or not</p>
</td></tr>
<tr><td><code id="MultiIdeal_+3A_nbchoix">nbchoix</code></td>
<td>
<p>The number of consumers forming a virtual panel, by default the number of panelists in the original panel</p>
</td></tr>
<tr><td><code id="MultiIdeal_+3A_nbsimul">nbsimul</code></td>
<td>
<p>The number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="MultiIdeal_+3A_coord">coord</code></td>
<td>
<p>A length 2 vector specifying the components to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure of MultiIdeal, step by step:<br />
Step 1: the sensory and ideal variables are separated into two tables.<br />
Step 2: the product space is created by PCA on the averaged sensory table (averaged by product).<br />
Step 3: the ideal information (Product x Consumer) is projected as supplementary entities in this space.<br />
Step 4: confidence ellipses are created around the averaged ideal points associated to each product (using the consumer variability).<br />
</p>


<h3>Value</h3>

<p>Returns a matrix with the P-values of the Hotelling's T2 tests for each pair of products.
</p>


<h3>Author(s)</h3>

<p>Worch Thierry (thierry@qistatistics.co.uk)</p>


<h3>References</h3>

<p>Worch, T., &amp; Ennis, J.M. (2013).
Investigating the single ideal assumption using Ideal Profile Method. 
<em>Food Quality and Preference</em>.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+panellipse">panellipse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume_ideal)
res &lt;- MultiIdeal(perfume_ideal, col.p=2, col.j=1, id.recogn="id_", 
    level.search.desc=0.2, nbsimul=500, coord=c(1,2))

# To run the analysis with all the attributes
res &lt;- MultiIdeal(perfume_ideal, col.p=2, col.j=1, id.recogn="id_", 
    level.search.desc=1, nbsimul=500, coord=c(1,2))

## End(Not run)
</code></pre>

<hr>
<h2 id='nappeplot'>Plot panelists' tableclothe</h2><span id='topic+nappeplot'></span>

<h3>Description</h3>

<p>Plot panelists' tableclothe.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nappeplot(donnee, numr = 2, numc = 2, color = "blue", lim = c(60,40))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nappeplot_+3A_donnee">donnee</code></td>
<td>
<p>a data frame of dimension (<em>p,2j</em>),
where <em>p</em> represents the number of products and <em>j</em> the number 
of panelists</p>
</td></tr>
<tr><td><code id="nappeplot_+3A_numr">numr</code></td>
<td>
<p>the number of tableclothe per row (by default 2)</p>
</td></tr>
<tr><td><code id="nappeplot_+3A_numc">numc</code></td>
<td>
<p>the number of tableclothe per column (by default 2)</p>
</td></tr>
<tr><td><code id="nappeplot_+3A_color">color</code></td>
<td>
<p>the color used to display the products</p>
</td></tr>
<tr><td><code id="nappeplot_+3A_lim">lim</code></td>
<td>
<p>the size of the tableclothe</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The data used here refer to a specific experiment, where panelists are 
asked to position products on a tableclothe of dimension <code>lim</code>, by default (60,40).
</p>


<h3>Value</h3>

<p>Returns as many graphs as there are panelists, each graph represents products 
positioned by a given panelist on a tablecloth
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>References</h3>

<p>Pages J. (2005). Collection and analysis of perceived product inter-distances using multiple factor analysis; 
application to the study of ten white wines from the Loire Valley. <em>Food Quality and Preference</em>. 16 (7) pp. 642-649.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+napping">napping</a></code>, <code><a href="#topic+pmfa">pmfa</a></code>, <code><a href="#topic+indscal">indscal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(napping)
nappeplot(napping.don)

## End(Not run)
</code></pre>

<hr>
<h2 id='nappesortplot'>Plot consumers' sorted tablecloth</h2><span id='topic+nappesortplot'></span>

<h3>Description</h3>

<p>Plot consumers' sorted tablecloth.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nappesortplot(donnee,first="nappe", numr = 2, numc = 2, lim = c(60,40))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nappesortplot_+3A_donnee">donnee</code></td>
<td>
<p>a data frame of dimension (<em>p,3j</em>),
where <em>p</em> represents the number of products and <em>j</em> the number 
of consumers</p>
</td></tr>
<tr><td><code id="nappesortplot_+3A_first">first</code></td>
<td>
<p>2 possibilities: &quot;nappe&quot; if the napping variables first appear for each consumer or &quot;catego&quot; if it is the categorization variable</p>
</td></tr>
<tr><td><code id="nappesortplot_+3A_numr">numr</code></td>
<td>
<p>the number of tablecloth per row (by default 2)</p>
</td></tr>
<tr><td><code id="nappesortplot_+3A_numc">numc</code></td>
<td>
<p>the number of tablecloth per column (by default 2)</p>
</td></tr>
<tr><td><code id="nappesortplot_+3A_lim">lim</code></td>
<td>
<p>the size of the tablecloth</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The data used here refer to a specific experiment, where consumers are 
asked to position products on a tablecloth of dimension <code>lim</code>, by default (60,40) and to categorize them.
</p>


<h3>Value</h3>

<p>Returns as many graphs as there are consumers, each graph represents products 
positioned by a given consumer on a tablecloth and colored according to the categorization
</p>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>References</h3>

<p>Pages, J., Le, S., Cadoret, M. (2010) <em>The Sorted Napping: a new holistic approach in sensory evaluation</em>. Journal of Sensory Studies<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fasnt">fasnt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(smoothies)
nappesortplot(smoothies,first="nappe")

## End(Not run)
</code></pre>

<hr>
<h2 id='napping'>Napping data</h2><span id='topic+napping'></span>

<h3>Description</h3>

<p>The data used here refer to 10 different French wines evaluated by 11 panelists.<br />
They were asked to position the wines on a tableclothe of dimension (60,40).
They were asked to describe each wine using their own word list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(napping)</code></pre>


<h3>Format</h3>

<p>There are two data frames:
- napping.don: A data frame of dimension (10,22): each row represents
a French wine, each couple (Xi,Yi) represents the 
coordinates of the wines positioned on a tableclothe for a given panelist;<br />
- napping.words: A data frame of dimension (10,14): each row represents
a French wine, each column an attribute, each cell the number of times
a given attribute was quoted for a given wine.
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(napping)
nappeplot(napping.don)
dev.new()
pmfa(napping.don, napping.words)

## End(Not run)
</code></pre>

<hr>
<h2 id='napping.don'>An example of Napping data</h2><span id='topic+napping.don'></span>

<h3>Description</h3>

<p>The data used here refer to 10 different French wines evaluated by 11 panelists.
They were asked to position the wines on a tableclothe of dimension (60,40).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(napping)</code></pre>


<h3>Format</h3>

<p>A data frame of dimension (10,22): each row represents
a French wine, each couple (Xi,Yi) represents the 
coordinates of the wines positioned on a tableclothe for a given panelist.
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(napping)
nappeplot(napping.don)
res &lt;- pmfa(napping.don, napping.words)
res2 &lt;- boot(napping.don,method="napping")

## End(Not run)
</code></pre>

<hr>
<h2 id='napping.words'>An example of &quot;illustrative&quot; variables to enhance results from Napping data</h2><span id='topic+napping.words'></span>

<h3>Description</h3>

<p>The data used here refer to 10 different French wines evaluated by 11 panelists.
They were asked to describe each wine using their own word list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(napping)</code></pre>


<h3>Format</h3>

<p>A data frame of dimension (10,14): each row represents
a French wine, each column an attribute, each cell the number of times
a given attribute was quoted for a given wine
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(napping)
nappeplot(napping.don)
dev.new()
pmfa(napping.don, napping.words)

## End(Not run)
</code></pre>

<hr>
<h2 id='optimaldesign'> Construction of an optimal design </h2><span id='topic+optimaldesign'></span>

<h3>Description</h3>

<p>Construction of an optimal design balanced for first order of carry-over effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimaldesign(nbPanelist, nbProd, nbProdByPanelist=nbProd, seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimaldesign_+3A_nbpanelist">nbPanelist</code></td>
<td>
<p> Maximum number of panelists </p>
</td></tr>
<tr><td><code id="optimaldesign_+3A_nbprod">nbProd</code></td>
<td>
<p> Number of products </p>
</td></tr>
<tr><td><code id="optimaldesign_+3A_nbprodbypanelist">nbProdByPanelist</code></td>
<td>
<p> Number of products that each panelist will evaluate</p>
</td></tr>
<tr><td><code id="optimaldesign_+3A_seed">seed</code></td>
<td>
<p> initialization of the algorithm </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with
</p>
<table>
<tr><td><code>design</code></td>
<td>
<p>design with the products evaluated by each panelist</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>contingency table with the number of times each product is seen at each rank</p>
</td></tr>
<tr><td><code>succ</code></td>
<td>
<p>contingency table with the number of times each product follow each product</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>F. Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
optimaldesign(nbPanelist=10,nbProd=5,nbProdByPanelist=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='paneliperf'>Panelists' performance according to their capabilities to dicriminate between products</h2><span id='topic+paneliperf'></span>

<h3>Description</h3>

<p>Computes automatically P-values, Vtests, residuals, r-square for 
each category of a given qualitative variable (e.g. the <em>panelist</em> variable);<br />
Computes he agreement between each panelist and the panel results;<br />
Gives the panel results (optional).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paneliperf(donnee, formul, formul.j = "~Product", col.j, firstvar,
      lastvar = ncol(donnee), synthesis = FALSE, random = TRUE, 
      graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paneliperf_+3A_donnee">donnee</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>
<tr><td><code id="paneliperf_+3A_formul">formul</code></td>
<td>
<p>the aov model used for the panel</p>
</td></tr>
<tr><td><code id="paneliperf_+3A_formul.j">formul.j</code></td>
<td>
<p>the aov model used for each panelist (no <em>panelist</em> effect allowed)</p>
</td></tr>
<tr><td><code id="paneliperf_+3A_col.j">col.j</code></td>
<td>
<p>the position of the <em>panelist</em> variable</p>
</td></tr>
<tr><td><code id="paneliperf_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="paneliperf_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code></p>
</td></tr>
<tr><td><code id="paneliperf_+3A_synthesis">synthesis</code></td>
<td>
<p>boolean, the possibility to have the anova results for the panel model</p>
</td></tr>
<tr><td><code id="paneliperf_+3A_random">random</code></td>
<td>
<p>boolean, the status of the Panelist variable in the anova model for the panel</p>
</td></tr>
<tr><td><code id="paneliperf_+3A_graph">graph</code></td>
<td>
<p>boolean, draws the PCA and MFA graphs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formul</code> parameter must be filled in by an analysis of variance model and must 
begin with the categorical variable of interest (e.g. the product effect)
followed by the different other factors of interest (and their combinations).
E.g.:<code>formul = "~Product+Session"</code>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>prob.ind</code></td>
<td>
<p>a matrix which rows are the panelist, which columns are the endogenous variables (in most cases the sensory descriptors) and
which entries are the P-values associated to the AOV model</p>
</td></tr>
<tr><td><code>vtest.ind</code></td>
<td>
<p>a matrix which rows are the panelist, which columns are the endogenous variables (in most cases the sensory descriptors) and
which entries are the Vtests associated to the AOV model</p>
</td></tr>
<tr><td><code>res.ind</code></td>
<td>
<p>a matrix which rows are the panelist, which columns are the endogenous variables (in most cases the sensory descriptors) and
which entries are the residuals associated to the AOV model</p>
</td></tr>
<tr><td><code>r2.ind</code></td>
<td>
<p>a matrix which rows are the panelist, which columns are the endogenous variables (in most cases the sensory descriptors) and
which entries are the R-square associated to the AOV model</p>
</td></tr>
<tr><td><code>signif.ind</code></td>
<td>
<p>a vector with the number of significant descriptors per panelist</p>
</td></tr>
<tr><td><code>agree.ind</code></td>
<td>
<p>a matrix with as many rows as there are panelists and as many columns as there are descriptors and 
the entries of this matrix are the correlation coefficients between the product coefficients for the panel 
and for the panelists</p>
</td></tr>
</table>
<p><br />
</p>
<table>
<tr><td><code>complete</code></td>
<td>
<p>a matrix with the v-test corresponding to the p.value (see <code>p.values</code> below), the median of the agreement (see <code>agree</code> upper), the standard deviation of the panel anova model (see <code>res</code> below)</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>a matrix of dimension (<em>k,m</em>) of <em>P-values</em> associated with the F-test for the 
<em>k</em> descriptors and the <em>m</em> factors and their combinations considered in the analysis
of variance model of interest</p>
</td></tr>
<tr><td><code>variability</code></td>
<td>
<p>a matrix of dimension (<em>k,m</em>) where the entries correspond to the percentages of variability
due to the effects introduced in the analysis of variance model of interest</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>a vector of dimension <em>k</em> of residual terms for the analysis
of variance model of interest</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>a vector of dimension <em>k</em> of r-squared for the analysis of variance model of interest</p>
</td></tr>
</table>
<p>The usual graphs when MFA is performed on the data.frame
resulting from vtest.ind and agree.ind. <br />
The PCA graphs for the complete output.<br />
</p>


<h3>Author(s)</h3>

<p>F Husson, S Le</p>


<h3>References</h3>

<p>P. Lea, T. Naes, M. Rodbotten. <em>Analysis of variance for sensory data</em>.
H. Sahai, M. I. Ageel. <em>The analysis of variance</em>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+panelperf">panelperf</a></code>, <code><a href="stats.html#topic+aov">aov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(chocolates)
res&lt;-paneliperf(sensochoc, formul = "~Product+Panelist+Session+
  Product:Panelist+Product:Session+Panelist:Session",
  formul.j = "~Product", col.j = 1, firstvar = 5, synthesis = TRUE)
resprob&lt;-magicsort(res$prob.ind, method = "median")
coltable(resprob, level.lower = 0.05, level.upper = 1,
    main.title = "P-value of the F-test (by panelist)")
hist(resprob,main="Histogram of the P-values",xlab="P-values")

resr2&lt;-magicsort(res$r2.ind, method = "median", ascending = FALSE)
coltable(resr2, level.lower = 0.00, level.upper = 0.85,
    main.title = "Adjusted R-square (by panelist)")

resagree&lt;-magicsort(res$agree, sort.mat = res$r2.ind, method = "median")
coltable(resagree, level.lower = 0.00, level.upper = 0.85,
    main.title = "Agreement between panelists")
hist(resagree,main="Histogram of the agreement between panelist and panel",
    xlab="Correlation coefficient between the product effect for 
    panelist and panel")

coltable(magicsort(res$p.value, sort.mat = res$p.value[,1], bycol = FALSE,
    method = "median"),
    main.title = "Panel performance (sorted by product P-value)")

## End(Not run)
</code></pre>

<hr>
<h2 id='panellipse'>Confidence ellipses around products based on panelists descriptions</h2><span id='topic+panellipse'></span>

<h3>Description</h3>

<p>Virtual panels are generated using Boostrap techniques in order to display
confidence ellipses around products.</p>


<h3>Usage</h3>

<pre><code class='language-R'>panellipse(donnee, col.p, col.j, firstvar, lastvar = ncol(donnee),
    alpha = 0.05, coord = c(1,2), scale.unit = TRUE, nbsimul = 300,
    nbchoix = NULL, group = NULL, name.group = NULL,
    level.search.desc = 0.2, centerbypanelist = TRUE,
    scalebypanelist = FALSE, name.panelist = FALSE,
    variability.variable = TRUE, cex = 1, color = NULL,
	graph.type = c("ggplot","classic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panellipse_+3A_donnee">donnee</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>  
<tr><td><code id="panellipse_+3A_col.p">col.p</code></td>
<td>
<p>the position of the <em>product</em> variable</p>
</td></tr>
<tr><td><code id="panellipse_+3A_col.j">col.j</code></td>
<td>
<p>the position of the <em>panelist</em> variable</p>
</td></tr>
<tr><td><code id="panellipse_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first sensory descriptor</p>
</td></tr>
<tr><td><code id="panellipse_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last sensory descriptor (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="panellipse_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="panellipse_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="panellipse_+3A_scale.unit">scale.unit</code></td>
<td>
<p>boolean, if T the descriptors are scaled to unit variance</p>
</td></tr>
<tr><td><code id="panellipse_+3A_nbsimul">nbsimul</code></td>
<td>
<p>the number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="panellipse_+3A_nbchoix">nbchoix</code></td>
<td>
<p>the number of panelists forming a virtual panel, by default the number of panelists in the original panel</p>
</td></tr>
<tr><td><code id="panellipse_+3A_group">group</code></td>
<td>
<p>the number of variables in each group of variables when multiple factor analysis is performed (by default this parameter equals NULL and a PCA is performed)</p>
</td></tr>
<tr><td><code id="panellipse_+3A_name.group">name.group</code></td>
<td>
<p>the names of the groups of variables when mfa is performed (if <code>group</code> differs from NULL)</p>
</td></tr>  
<tr><td><code id="panellipse_+3A_level.search.desc">level.search.desc</code></td>
<td>
<p>the threshold above which a descriptor is not considered as discriminant according to AOV model <code>"descriptor=Product+Panelist"</code></p>
</td></tr>
<tr><td><code id="panellipse_+3A_centerbypanelist">centerbypanelist</code></td>
<td>
<p>boolean, if T center the data by panelist before the construction of the axes</p>
</td></tr>
<tr><td><code id="panellipse_+3A_scalebypanelist">scalebypanelist</code></td>
<td>
<p>boolean, if T scale the data by panelist before the construction of the axes (by default, FALSE
is assigned to that parameter)</p>
</td></tr>
<tr><td><code id="panellipse_+3A_name.panelist">name.panelist</code></td>
<td>
<p>boolean, if T then the name of each panelist is displayed on the <code>plotpanelist</code> graph (by default, FALSE
is assigned to that parameter)</p>
</td></tr>
<tr><td><code id="panellipse_+3A_variability.variable">variability.variable</code></td>
<td>
<p>boolean, if T a plot with the variability of the variable is drawn and a confidence intervals of the correlations
between descriptors are calculated</p>
</td></tr>
<tr><td><code id="panellipse_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="panellipse_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="panellipse_+3A_graph.type">graph.type</code></td>
<td>
<p>a character that gives the type of graph used: &quot;ggplot&quot; or &quot;classic&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Panellipse, step by step:<br />
Step 1 Performs a selection of discriminating descriptors with respect to a threshold set by users <br />
Step 2 Virtual panels are generated using Boostrap techniques; the number of panels as well as their size
are set by users with the <em>nbsimul</em> and <em>nbchoix</em> parameters <br />
Step 3 Coordinates of the products with respect to each virtual panels are computed <br />
Step 4 Each product is then circled by its confidence ellipse generated by virtual panels and
comprising (1-alpha)*100 percent of the virtual products <br />
Step 5 Variability of the variables is drawn and confidence interval of the correlation coefficient between descriptors are calculated by bootstrap <br />
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>eig</code></td>
<td>
<p>a matrix with the component of the factor analysis (in row) and the eigenvalues, the inertia and the cumulative inertia for each component</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>
<p>a list with: the coordinates of the products with respect to the panel and to each panelists
and the coordinates of the <em>partial</em> products with respect to the panel and to each panelists</p>
</td></tr>
<tr><td><code>hotelling</code></td>
<td>
<p>Returns a matrix with the P-values of the Hotelling's T2 tests for each pair of products: this matrix allows to find the
product which are significantly different for the 2-components sensory description; if an MFA is done, <em>hotelling</em> returns as many matrices 
as there are group, these matrices allows to find the product which are significantly different for the 2-components sensory description of the
group, and it returns also a <em>global</em> matrix corresponding to the P-values for the tests corresponding to the mean product.</p>
</td></tr>
<tr><td><code>correl</code></td>
<td>
<p>a list with: the matrix of the estimated correlation coefficients and two matrices corresponding to the confidence intervals, min and max, of the correlation coefficients calculated by bootstrap.</p>
</td></tr>
</table>
<p>Returns a graph of the products as well as a correlation circle of the descriptors.<br />
</p>
<p>Returns a graph where each product is displayed with respect to a panel and to each panelist composing
the panel; products described by the panel are displayed as square, they are displayed as circle when
they are described by each panelist.<br />
</p>
<p>Returns a graph where each product is circled by its confidence ellipse generated by virtual panels.
When a Multiple Factor Analysis is performed, returns a graph where each partial product is circled by its confidence ellipse generated by virtual panels.<br />
</p>
<p>Returns a graph where the variability of each variable is drawn on the correlation circle graph. <br />
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>References</h3>

<p>Husson F., Le Dien S. &amp; Pages J.  (2005). Confidence ellipse for the sensory profiles obtained by Principal Components Analysis. <em>Food Quality and Preference</em>.  16 (3), 245-250. <br />
Pages J. &amp; Husson F. (2005). Multiple Factor Analysis with confidence ellipses: a methodology to study the relationships between sensory and instrumental data. To be published in <em>Journal of Chemometrics</em>. <br />
Husson F., Le S. &amp; Pages J.  Variability of the representation of the variables resulting from PCA in the case of a conventional sensory profile. <em>Food Quality and Preference</em>.  16 (3), 245-250. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+panellipse.session">panellipse.session</a></code>, <code><a href="#topic+panelmatch">panelmatch</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1: PCA
data(chocolates)
res &lt;- panellipse(sensochoc, col.p = 4, col.j = 1, firstvar = 5)
coltable(res$hotelling, main.title = "P-values for the Hotelling's T2 tests")

## If we consider only 12 panelists in a virtual panel, 
## what would be the size of the ellipses
res2 &lt;- panellipse(sensochoc, col.p = 4, col.j = 1, nbchoix = 12, firstvar = 5)
coltable(res2$hotelling, main.title = "P-values for the Hotelling's T2 tests")

## If we want the confidence ellipses around the individual descriptions
panellipse(sensochoc, col.p = 4, col.j = 1, nbchoix = 1, firstvar = 5)


## Example 2: MFA
data(chocolates)
res &lt;- panellipse(sensochoc, col.p = 4, col.j = 1, firstvar = 5, 
    group = c(6,8), name.group = c("G1","G2"))
for (i in 1:dim(res$hotelling$bygroup)[3]) coltable(res$hotelling$bygroup[,,i], 
    main.title = paste("P-values for the Hotelling's T2 tests (",
    dimnames(res$hotelling$bygroup)[3][[1]][i],")",sep=""))

## End(Not run)
</code></pre>

<hr>
<h2 id='panellipse.session'>Repetability of panelists descriptions studied by confidence ellipses around products per session</h2><span id='topic+panellipse.session'></span>

<h3>Description</h3>

<p>Virtual panels are generated using Boostrap techniques in order to display
confidence ellipses around products.</p>


<h3>Usage</h3>

<pre><code class='language-R'>panellipse.session(donnee, col.p, col.j, col.s, firstvar, 
    lastvar = ncol(donnee), alpha = 0.05, coord = c(1,2), 
    scale.unit = TRUE, nbsimul = 500, nbchoix = NULL, 
    level.search.desc = 0.2,  centerbypanelist = TRUE, 
    scalebypanelist = FALSE, name.panelist = FALSE,
    variability.variable = FALSE, cex = 1, color= NULL,
	graph.type = c("ggplot","classic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panellipse.session_+3A_donnee">donnee</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>  
<tr><td><code id="panellipse.session_+3A_col.p">col.p</code></td>
<td>
<p>the position of the <em>product</em> variable</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_col.j">col.j</code></td>
<td>
<p>the position of the <em>panelist</em> variable</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_col.s">col.s</code></td>
<td>
<p>the position of the <em>session</em> variable</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first sensory descriptor</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last sensory descriptor (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_scale.unit">scale.unit</code></td>
<td>
<p>boolean, if T the descriptors are scaled to unit variance</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_nbsimul">nbsimul</code></td>
<td>
<p>the number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_nbchoix">nbchoix</code></td>
<td>
<p>the number of panelists forming a virtual panel, by default the number of panelists in the original panel</p>
</td></tr>  
<tr><td><code id="panellipse.session_+3A_level.search.desc">level.search.desc</code></td>
<td>
<p>the threshold above which a descriptor is not considered as discriminant according to AOV model <code>"descriptor=Product+Panelist"</code></p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_centerbypanelist">centerbypanelist</code></td>
<td>
<p>boolean, if T center the data by panelist before the construction of the axes</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_scalebypanelist">scalebypanelist</code></td>
<td>
<p>boolean, if T scale the data by panelist before the construction of the axes (by default, FALSE
is assigned to that parameter)</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_name.panelist">name.panelist</code></td>
<td>
<p>boolean, if T then the name of each panelist is displayed on the <code>plotpanelist</code> graph (by default, FALSE
is assigned to that parameter)</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_variability.variable">variability.variable</code></td>
<td>
<p>boolean, if T a plot with the variability of the variable is drawn and a confidence intervals of the correlations
between descriptors are calculated</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="panellipse.session_+3A_graph.type">graph.type</code></td>
<td>
<p>a character that gives the type of graph used: &quot;ggplot&quot; or &quot;classic&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>panellipse.session, step by step:<br />
Step 1 Construct a data frame by session <br />
Step 2 Performs a selection of discriminating descriptors with respect to a threshold set by users <br />
Step 3 MFA is computed with one group for one session <br />
Step 4 Virtual panels are generated using Boostrap techniques; the number of panels as well as their size
are set by users with the <em>nbsimul</em> and <em>nbchoix</em> parameters <br />
Step 5 Coordinates of the products with respect to each virtual panels are computed <br />
Step 6 Each product is then circled by its confidence ellipse generated by virtual panels and
comprising (1-alpha)*100 percent of the virtual products
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>bysession</code></td>
<td>
<p>the data by session</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a matrix with the component of the factor analysis (in row) and the eigenvalues, the inertia and the cumulative inertia for each component</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>
<p>a list with: the coordinates of the products with respect to the panel and to each panelists
and the coordinates of the <em>partial</em> products with respect to the panel and to each panelists</p>
</td></tr>
<tr><td><code>hotelling</code></td>
<td>
<p>returns a matrix with the P-values of the Hotelling's T2 tests for each pair of products: this matrix allows to find the
product which are significatnly different for the 2-components sensory description</p>
</td></tr>
<tr><td><code>variability</code></td>
<td>
<p>returns an index of the sessions' reproductibility: the first eigenvalue of the separate PCA performed on homologous descriptors</p>
</td></tr>
</table>
<p>Returns a graph of the products as well as a correlation circle of the descriptors.<br />
</p>
<p>Returns a graph where each product is displayed with respect to a panel and to each panelist composing
the panel; products described by the panel are displayed as square, they are displayed as circle when
they are described by each panelist.<br />
</p>
<p>Returns a graph where each product is circled by its confidence ellipse generated by virtual panels.<br />
</p>
<p>Returns a graph where each partial product is circled by its confidence ellipse generated by virtual panels.<br />
</p>
<p>Returns a graph where the variability of each variable is drawn on the correlation circle graph. <br />
</p>


<h3>Author(s)</h3>

<p>F Husson, S Le</p>


<h3>References</h3>

<p>Husson F., Le Dien S. &amp; Pages J.  (2005). Confidence ellipse for the sensory profiles obtained by Principal Components Analysis. <em>Food Quality and Preference</em>.  16 (3), 245-250. <br />
Pages J. &amp; Husson F. (2005). Multiple Factor Analysis with confidence ellipses: a methodology to study the relationships between sensory and instrumental data. To be published in <em>Journal of Chemometrics</em>. <br />
Husson F., Le S. &amp; Pages J.  Variability of the representation of the variables resulting from PCA in the case of a conventional sensory profile. <em>Food Quality and Preference</em>.  16 (3), 245-250. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panellipse">panellipse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(chocolates)
res &lt;- panellipse.session(sensochoc, col.p = 4, col.j = 1, col.s = 2, 
    firstvar = 5)
magicsort(res$variability)
for (i in 1:dim(res$hotelling$bysession)[3]) coltable(res$hotelling$bysession[,,i], 
    main.title = paste("P-values for the Hotelling's T2 tests (",
    dimnames(res$hotelling$bysession)[3][[1]][i],")",sep=""))

## End(Not run)
</code></pre>

<hr>
<h2 id='panelmatch'>Confidence ellipses around products based on panel descriptions</h2><span id='topic+panelmatch'></span>

<h3>Description</h3>

<p>Comparison of panels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>panelmatch(donnee, col.p, col.j, firstvar, 
    alpha = 0.05, coord = c(1,2), scale.unit = TRUE, nbsimul = 500, 
    nbchoix = NULL, centerbypanelist = TRUE, 
    scalebypanelist = FALSE, name.panelist = FALSE, cex = 1, 
    color = NULL, hierar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelmatch_+3A_donnee">donnee</code></td>
<td>
<p>a list of data frames, each one made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>  
<tr><td><code id="panelmatch_+3A_col.p">col.p</code></td>
<td>
<p>the position of the <em>product</em> variable (in each data frame, the same position)</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_col.j">col.j</code></td>
<td>
<p>the position of the <em>panelist</em> variable (in each data frame, the same position)</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first sensory descriptor (in each data frame, the same position)</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_scale.unit">scale.unit</code></td>
<td>
<p>boolean, if T the descriptors are scaled to unit variance</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_nbsimul">nbsimul</code></td>
<td>
<p>the number of simulations (corresponding to the number of virtual panels) used to compute the ellipses</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_nbchoix">nbchoix</code></td>
<td>
<p>the number of panelists forming a virtual panel, by default the number of panelists in the original panel</p>
</td></tr>  
<tr><td><code id="panelmatch_+3A_centerbypanelist">centerbypanelist</code></td>
<td>
<p>boolean, if T center the data by panelist before the construction of the axes</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_scalebypanelist">scalebypanelist</code></td>
<td>
<p>boolean, if T scale the data by panelist before the construction of the axes (by default, FALSE
is assigned to that parameter)</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_name.panelist">name.panelist</code></td>
<td>
<p>boolean, if T then the name of each panelist is displayed on the <code>plotpanelist</code> graph (by default, FALSE
is assigned to that parameter)</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="panelmatch_+3A_hierar">hierar</code></td>
<td>
<p>hierarchy in the variable (see <code>hmfa</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>eig</code></td>
<td>
<p>a matrix with the component of the factor analysis (in row) and the eigenvalues, the inertia and the cumulative inertia for each component</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>
<p>a list with: the coordinates of the products with respect to the panel and to each panelists
and the coordinates of the <em>partial</em> products with respect to the panel and to each panelists</p>
</td></tr>
<tr><td><code>hotelling</code></td>
<td>
<p>Returns a matrix with the P-values of the Hotelling's T2 tests for each pair of products: this matrix allows to find the
product which are significatnly different for the 2-components sensory description</p>
</td></tr>
</table>
<p>Returns a graph of the products as well as a correlation circle of the descriptors.<br />
</p>
<p>Returns a graph where each product is displayed with respect to a panel and to each panelist composing
the panel; products described by the panel are displayed as square, they are displayed as circle when
they are described by each panelist.<br />
</p>
<p>Returns a graph where each product is circled by its confidence ellipse generated by virtual panels.
When a Multiple Factor Analysis is performed, returns a graph where each partial product is circled by its confidence ellipse generated by virtual panels.<br />
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>References</h3>

<p>Husson F., Le Dien S. &amp; Pages J.  (2005). Confidence ellipse for the sensory profiles obtained by Principal Components Analysis. <em>Food Quality and Preference</em>.  16 (3), 245-250. <br />
Pages J. &amp; Husson F. (2005). Multiple Factor Analysis with confidence ellipses: a methodology to study the relationships between sensory and instrumental data. To be published in <em>Journal of Chemometrics</em>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+panellipse">panellipse</a></code>, <code><a href="#topic+panellipse.session">panellipse.session</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(chocolates)
Panel1=sensochoc[as.numeric(sensochoc[,1])&lt;11,]
Panel2=sensochoc[as.numeric(sensochoc[,1])&lt;21 &amp; as.numeric(sensochoc[,1])&gt;10,]
Panel3=sensochoc[as.numeric(sensochoc[,1])&gt;20,]
res &lt;- panelmatch(list(P1=Panel1,P2=Panel2,P3=Panel3), col.p = 4, col.j = 1, firstvar = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='panelperf'>Panel's performance according to its capabilities to dicriminate between products</h2><span id='topic+panelperf'></span>

<h3>Description</h3>

<p>Computes automatically P-values associated with the F-test as well as the residual term for a given analysis of variance model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panelperf(donnee, formul, subset = NULL, firstvar, 
    lastvar = ncol(donnee), random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelperf_+3A_donnee">donnee</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="panelperf_+3A_formul">formul</code></td>
<td>
<p>the model that is to be tested</p>
</td></tr>
<tr><td><code id="panelperf_+3A_subset">subset</code></td>
<td>
<p>cf. function <code><a href="stats.html#topic+lm">lm</a></code> in the <span class="pkg">stats</span> package</p>
</td></tr>
<tr><td><code id="panelperf_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="panelperf_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code></p>
</td></tr>
<tr><td><code id="panelperf_+3A_random">random</code></td>
<td>
<p>boolean, effect should be possible as fixed or random (default as random)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formul</code> parameter must be filled in by an analysis of variance model and must 
begin with the categorical variable of interest (e.g. the product effect)
followed by the different other factors of interest (and their combinations).
E.g.:<code>formul = "~Product+Session"</code>.
</p>


<h3>Value</h3>

 
<p>A list containing the following components:
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>a matrix of dimension (<em>k,m</em>) of <em>P-values</em> associated with the F-test for the 
<em>k</em> descriptors and the <em>m</em> factors and their combinations considered in the analysis
of variance model of interest</p>
</td></tr>
<tr><td><code>variability</code></td>
<td>
<p>a matrix of dimension (<em>k,m</em>) where the entries correspond to the percentages of variability
due to the effects introduced in the analysis of variance model of interest</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>a vector of dimension <em>k</em> of residual terms for the analysis
of variance model of interest</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p>a vector of dimension <em>k</em> of r-squared for the analysis of variance model of interest</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>F Husson, S Le</p>


<h3>References</h3>

<p>P. Lea, T. Naes, M. Rodbotten. <em>Analysis of variance for sensory data</em>.<br />
H. Sahai, M. I. Ageel. <em>The analysis of variance</em>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+paneliperf">paneliperf</a></code>, <code><a href="stats.html#topic+aov">aov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
res=panelperf(sensochoc, firstvar = 5, formul = "~Product+Panelist+
    Session+Product:Panelist+Session:Product+Panelist:Session")
## Sort results by product p.values.
coltable(magicsort(res$p.value, sort.mat = res$p.value[,1], bycol = FALSE,
    method = "median"), main.title = "Panel performance (sorted by product P-value)")
</code></pre>

<hr>
<h2 id='perfume'>Perfume</h2><span id='topic+perfume'></span>

<h3>Description</h3>

<p>The data used here refer to 12 luxury perfumes categorized by 30 consumers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(perfume)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows (the number of perfumes) and 30 columns (the number of consumers): a cell corresponds either to the number of the group to which the product belongs for the consumer, or, in the case of &quot;qualified&quot; categorization, to the sequence of words associted with the group to which the product belongs for the consumer.
</p>


<h3>Source</h3>

<p>Applied Mathematics Department, Institut Agro Centre de Rennes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume)
## Example of FAST
res.fast &lt;- fast(perfume)

## End(Not run)
</code></pre>

<hr>
<h2 id='perfume_fcp'>Perfume data obtained by free choice profiling</h2><span id='topic+perfume_fcp'></span>

<h3>Description</h3>

<p>The data used here refer to 12 luxury perfumes described by 6 experts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(perfume_fcp)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 rows (the number of perfumes) and 47 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume_fcp)
res &lt;- fcp(perfume_fcp, group = c(12,7,7,7,6,8))

## End(Not run)
</code></pre>

<hr>
<h2 id='perfume_ideal'>Perfume Ideal Data</h2><span id='topic+perfume_ideal'></span>

<h3>Description</h3>

<p>The data used here refer to the sensory description of twelve perfumes (2 were duplicated).<br />
</p>
<p>Each perfume was evaluated once by 103 Dutch consumers and described on 21 attributes according to the Ideal Profile Method.<br />
Both perceived and ideal intensities were asked. In addition, the overall liking is asked.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(perfume_ideal)</code></pre>


<h3>Format</h3>

<p>A data frame made of 103*14=1442 rows and 2 qualitative variables (set and product),
21*2 attributes (perceived and ideal intensities) and overall liking.
</p>


<h3>Source</h3>

<p>OP&amp;P Product Research, Utrecht, The Netherlands
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume_ideal)
decat(perfume_ideal, formul = "~product+user", firstvar = 3, graph = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fahst'>Make Factorial Approach for Hierarchical Sorting Task data (FAHST) graphs</h2><span id='topic+plot.fahst'></span>

<h3>Description</h3>

<p>Plot the graphs for Factorial Approach for Hierarchical Sorting Task data (FAHST).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fahst'
plot(x,choix="ind", axes = c(1, 2), xlim = NULL, ylim = NULL, 
    invisible = NULL, col.ind = "blue", col.var = "red", lab.ind=TRUE,lab.var=TRUE, 
	cex = 1, lab.lev=TRUE,lab.grpe = TRUE, title = NULL, habillage = "none", 
	habillage.lev = "none", traj = FALSE, palette = NULL, new.plot = TRUE, ...)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fahst_+3A_x">x</code></td>
<td>
<p>an object of class fahst</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_choix">choix</code></td>
<td>
<p>the graph to plot (&quot;ind&quot; for the products and the categories, &quot;group&quot; for the consumers and &quot;level&quot; for the levels)</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_xlim">xlim</code></td>
<td>
<p>range for the plotted 'x' values, defaulting to the range of the finite values of 'x'</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_ylim">ylim</code></td>
<td>
<p>range for the plotted 'y' values, defaulting to the range of the finite values of 'y'</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_invisible">invisible</code></td>
<td>
<p>string indicating if some points should not be drawn (&quot;ind&quot; or &quot;var&quot;)</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_col.ind">col.ind</code></td>
<td>
<p>a color for the products</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_col.var">col.var</code></td>
<td>
<p>a color for the categories</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_lab.ind">lab.ind</code></td>
<td>
<p>boolean, if TRUE, the products are labelled</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_lab.var">lab.var</code></td>
<td>
<p>boolean, if TRUE, the categories associated with categorization are labelled</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_lab.lev">lab.lev</code></td>
<td>
<p>boolean, if TRUE, the levels are labelled</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_lab.grpe">lab.grpe</code></td>
<td>
<p>boolean, if TRUE, the consumers are labelled</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_title">title</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_habillage">habillage</code></td>
<td>
<p>give no color for the individuals (&quot;none&quot;), or color the products according to one of the levels of a consumer (give the number of the colomn corresponding to the level)</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_habillage.lev">habillage.lev</code></td>
<td>
<p>give no color for the levels (&quot;none&quot;), color the levels according to consumer (&quot;subject&quot;) or color the levels according to the number of the level (&quot;level&quot;)</p>
</td></tr>  
<tr><td><code id="plot.fahst_+3A_traj">traj</code></td>
<td>
<p>boolean, if TRUE, trajectories are drawn between levels of the same consumer</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_palette">palette</code></td>
<td>
<p>the color palette used to draw the points. By default colors are chosen. If you want to define the colors : palette=palette(c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;)); or you can use: palette=palette(rainbow(30)), or in black and white for example: palette=palette(gray(seq(0,.9,len=25)))</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_new.plot">new.plot</code></td>
<td>
<p>boolean, if TRUE, a new graphical device is created</p>
</td></tr>
<tr><td><code id="plot.fahst_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the products factor map, the categories factor map, the levels factor map and the consumers factor map.
</p>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+fahst">fahst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cards)
group&lt;-c(2,3,3,2,2,4,2,3,2,1,3,2,3,3,3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3)
res.fahst &lt;- fahst(cards,group,graph=FALSE)
plot.fahst(res.fahst,choix="ind",invisible="var",habillage=2,
    title="Cards colored according to level 2 of subject 1")
plot.fahst(res.fahst,choix="level",traj=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fasnt'>Make Factorial Approach for Sorting Napping Task data (FASNT) graphs</h2><span id='topic+plot.fasnt'></span>

<h3>Description</h3>

<p>Plot the graphs for Factorial Approach for Sorting Napping Task data (FASNT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fasnt'
plot(x,choix="ind", axes = c(1, 2), xlim = NULL, ylim = NULL, 
    invisible = NULL, col.ind = "blue", col.var = "red", lab.ind=TRUE,lab.var=TRUE, 
	lab.coord=TRUE, lab.partial=TRUE, cex = 1,lab.grpe = TRUE, title = NULL, 
	habillage = "none", palette = NULL, new.plot = TRUE, ...)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fasnt_+3A_x">x</code></td>
<td>
<p>an object of class fast</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_choix">choix</code></td>
<td>
<p>the graph to plot (&quot;ind&quot; for the products and the categories, &quot;group&quot; for the consumers and &quot;partial&quot; for the partial products)</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_xlim">xlim</code></td>
<td>
<p>range for the plotted 'x' values, defaulting to the range of the finite values of 'x'</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_ylim">ylim</code></td>
<td>
<p>range for the plotted 'y' values, defaulting to the range of the finite values of 'y'</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_habillage">habillage</code></td>
<td>
<p>give no color for the individuals (&quot;none&quot;), or color the products among a consumer (give the number of the consumer)</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_col.ind">col.ind</code></td>
<td>
<p>a color for the products</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_col.var">col.var</code></td>
<td>
<p>a color for the categories</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_lab.ind">lab.ind</code></td>
<td>
<p>boolean, if TRUE, the products are labelled</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_lab.var">lab.var</code></td>
<td>
<p>boolean, if TRUE, the categories associated with categorization are labelled</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_lab.coord">lab.coord</code></td>
<td>
<p>boolean, if TRUE, the napping variables are labelled</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_lab.partial">lab.partial</code></td>
<td>
<p>boolean, if TRUE, the partial products are labelled</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_invisible">invisible</code></td>
<td>
<p>string indicating if some points should not be drawn (&quot;ind&quot; or &quot;var&quot;)</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_lab.grpe">lab.grpe</code></td>
<td>
<p>boolean, if TRUE, the consumers are labelled</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_title">title</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_palette">palette</code></td>
<td>
<p>the color palette used to draw the points. By default colors are chosen. If you want to define the colors : palette=palette(c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;)); or you can use: palette=palette(rainbow(30)), or in black and white for example: palette=palette(gray(seq(0,.9,len=25)))</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_new.plot">new.plot</code></td>
<td>
<p>boolean, if TRUE, a new graphical device is created</p>
</td></tr>
<tr><td><code id="plot.fasnt_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the products factor map, the categories factor map, the coordinates factor map and the consumers factor map.
</p>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+fasnt">fasnt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(smoothies)
res.fasnt &lt;- fasnt(smoothies, first="nappe",graph=FALSE)
plot.fasnt(res.fasnt,choix="ind",invisible="var",habillage=15,
  title="Objects colored according to the groups provided by consumer 5")
plot.fasnt(res.fasnt,choix="partial",lab.partial=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fast'>Make Factorial Approach for Sorting Task data (FAST) graphs</h2><span id='topic+plot.fast'></span>

<h3>Description</h3>

<p>Plot the graphs for Factorial Approach for Sorting Task data (FAST).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fast'
plot(x,choix="ind", axes = c(1, 2), xlim = NULL, ylim = NULL, invisible = NULL,
    col.ind = "blue", col.var = "red", col.quali.sup = "darkred", 
    col.ind.sup ="darkblue", col.quanti.sup = "black",label = "all",
    cex = 1,lab.grpe = TRUE, title = NULL, habillage = "none", palette = NULL,
    new.plot = TRUE, ...)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fast_+3A_x">x</code></td>
<td>
<p>an object of class fast</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_choix">choix</code></td>
<td>
<p>the graph to plot (&quot;ind&quot; for the products, &quot;var&quot; for the vcategories, &quot;group&quot; for the consumers)</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_xlim">xlim</code></td>
<td>
<p>range for the plotted 'x' values, defaulting to the range of the finite values of 'x'</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_ylim">ylim</code></td>
<td>
<p>range for the plotted 'y' values, defaulting to the range of the finite values of 'y'</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_habillage">habillage</code></td>
<td>
<p>give no color for the individuals (&quot;none&quot;), or color the products among a consumer (give the number of the consumer)</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_col.ind">col.ind</code></td>
<td>
<p>a color for the products</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_col.var">col.var</code></td>
<td>
<p>a color for the categories</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_col.quali.sup">col.quali.sup</code></td>
<td>
<p>a color for the supplementary categories</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_col.ind.sup">col.ind.sup</code></td>
<td>
<p>a color for the supplementary individuals</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_col.quanti.sup">col.quanti.sup</code></td>
<td>
<p>a color for the quantitative supplementary variables</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_label">label</code></td>
<td>
<p>a list of character for the elements which are labelled (by default, all the elements are labelled (&quot;ind&quot;, &quot;var&quot;))</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_invisible">invisible</code></td>
<td>
<p>string indicating if some points should not be drawn (&quot;ind&quot; or &quot;var&quot;)</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_lab.grpe">lab.grpe</code></td>
<td>
<p>boolean, if TRUE, the consumers are labelled</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_title">title</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_palette">palette</code></td>
<td>
<p>the color palette used to draw the points. By default colors are chosen. If you want to define the colors : palette=palette(c(&quot;black&quot;,&quot;red&quot;,&quot;blue&quot;)); or you can use: palette=palette(rainbow(30)), or in black and white for example: palette=palette(gray(seq(0,.9,len=25)))</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_new.plot">new.plot</code></td>
<td>
<p>boolean, if TRUE, a new graphical device is created</p>
</td></tr>
<tr><td><code id="plot.fast_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the products factor map, the categories factor map and the consumers factor map.
</p>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+fast">fast</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume)
res.fast &lt;- fast(perfume,graph=FALSE)
plot.fast(res.fast,choix="ind",invisible="var",habillage=5)
plot.fast(res.fast,choix="group")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.IdMap'>Plot for the Ideal Mapping</h2><span id='topic+plot.IdMap'></span>

<h3>Description</h3>

<p>Option to replot by zooming on the ideal map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IdMap'
plot(x, xlim, ylim, levels.contour=NULL, color=FALSE, inverse=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.IdMap_+3A_x">x</code></td>
<td>
<p>An object of class <em>IdMap</em></p>
</td></tr>
<tr><td><code id="plot.IdMap_+3A_xlim">xlim</code></td>
<td>
<p>The lower and upper limits of interest on the X-axis </p>
</td></tr>
<tr><td><code id="plot.IdMap_+3A_ylim">ylim</code></td>
<td>
<p>The lower and upper limits of interest on the Y-axis</p>
</td></tr>
<tr><td><code id="plot.IdMap_+3A_levels.contour">levels.contour</code></td>
<td>
<p>The levels (between 0 and 1) to consider for the colors on the surface plot.
By default, they are set automatically based on the results </p>
</td></tr>
<tr><td><code id="plot.IdMap_+3A_color">color</code></td>
<td>
<p>Boolean, define whether the map is in color or in black and white</p>
</td></tr>
<tr><td><code id="plot.IdMap_+3A_inverse">inverse</code></td>
<td>
<p>Boolean, define whether the Black/While code should be inversed in the graph</p>
</td></tr>
<tr><td><code id="plot.IdMap_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replot the Ideal Map by zooming on the area of interest
</p>


<h3>Value</h3>

<p>Return the IdMap zoomed on the area of interest.
</p>


<h3>Author(s)</h3>

<p>Worch Thierry (thierry@qistatistics.co.uk)</p>


<h3>See Also</h3>

 <p><code><a href="#topic+IdMap">IdMap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume_ideal)
res &lt;- IdMap(perfume_ideal, col.p=2, col.j=1, col.lik=ncol(perfume_ideal), id.recogn="id_")
plot.IdMap(res, xlim=c(-7,10), ylim=c(-5,7), levels.contour=NULL, color=TRUE)
plot.IdMap(res, xlim=c(-7,10), ylim=c(-5,7), levels.contour=NULL, color=FALSE, inverse=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.JAR'>Make penalty graph</h2><span id='topic+plot.JAR'></span>

<h3>Description</h3>

<p>Plot the graphs for the penalty analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JAR'
plot(x, name.prod, model=1, confidence=TRUE, level=0.05, ...)
    </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.JAR_+3A_x">x</code></td>
<td>
<p>an object of class fast</p>
</td></tr>
<tr><td><code id="plot.JAR_+3A_name.prod">name.prod</code></td>
<td>
<p>a string corresonding to the name of the product for which penalty is drawn</p>
</td></tr>
<tr><td><code id="plot.JAR_+3A_model">model</code></td>
<td>
<p>an integer: 1 means that the one-dimensional penalties are drawn, 2 means that the multidimensional penalties are drawn</p>
</td></tr>
<tr><td><code id="plot.JAR_+3A_confidence">confidence</code></td>
<td>
<p>A boolean: if true, the confidence interval is drawn for each penalty</p>
</td></tr>
<tr><td><code id="plot.JAR_+3A_level">level</code></td>
<td>
<p>threshold for the selection of the categories that are plotted</p>
</td></tr>
<tr><td><code id="plot.JAR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods, such as cex, cex.main, ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draw a plot of the penalty against the ferquency of the categories.
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>See Also</h3>

 <p><code><a href="#topic+JAR">JAR</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(JAR)
res.jar &lt;- JAR(JAR,col.p=13,col.j=1,col.pref=2)
plot.JAR(res.jar,name.prod="284", model=1)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.WordCountAna'>Word-Count based methods Analysis (WordCountAna) graphs</h2><span id='topic+plot.WordCountAna'></span>

<h3>Description</h3>

<p>Draw the Word-Count based methods Analysis (WordCountAna) graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WordCountAna'
plot(x,axes=c(1,2),choix="prod",lab=TRUE,color=NULL,pch=NULL,
    proba=0.05,xlim=NULL,ylim=NULL,cex=1,title=NULL,new.plot=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.WordCountAna_+3A_x">x</code></td>
<td>
<p>an object of class VerbAna</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_choix">choix</code></td>
<td>
<p>a string corresponding to the graph that you want to do (&quot;prod&quot; for the products graph, &quot;panel&quot; for the panellists graph, &quot;dist&quot; for the distinct-words graph, &quot;cons&quot; for the consensual words graph)</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_lab">lab</code></td>
<td>
<p>boolean, if TRUE, the labels are drawn</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_color">color</code></td>
<td>
<p>the color to use to draw the graph</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_pch">pch</code></td>
<td>
<p>either an integer specifying a symbol or a single character to be used as the default in plotting points. See points for possible values and their interpretation</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_proba">proba</code></td>
<td>
<p>significance threshold considered to define consensual words (by default 0.05)</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_xlim">xlim</code></td>
<td>
<p>range for the plotted 'x' values, defaulting to the range of the finite values of 'x'</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_ylim">ylim</code></td>
<td>
<p>range for the plotted 'y' values, defaulting to the range of the finite values of 'y'</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_cex">cex</code></td>
<td>
<p>numerical value giving the amount by which plotting text and symbols should be magnified relative to the default (by default 1)</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_title">title</code></td>
<td>
<p>string corresponding to the title of the graph you draw</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_new.plot">new.plot</code></td>
<td>
<p>boolean, if TRUE, a new graphical device is created</p>
</td></tr>
<tr><td><code id="plot.WordCountAna_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods, such as cex, cex.main, ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns one of the four following factor maps depending on the choice: products, panellists, distinct-words and consensual words.
</p>


<h3>Author(s)</h3>

<p>Belchin Kostov <a href="mailto:badriyan@clinic.ub.es">badriyan@clinic.ub.es</a>, Francois Husson <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a>, Monica Becue-Bertaut</p>


<h3>References</h3>

<p>Kostov, B., Becue-Bertaut, M., Husson, F., Pages, J., Cadoret, M., Torrens, J. and Urpi, P. (2012). A tool for detecting words with consensual meaning in verbalization tasks. 11th Sensometrics Conference, July 10-13, 2012, Rennes, France.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+WordCountAna">WordCountAna</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(perfume)
res&lt;-WordCountAna(base=perfume,sep.word=";",graph=FALSE)
plot.WordCountAna(res,choix="prod")
plot.WordCountAna(res,choix="panel")
plot.WordCountAna(res,choix="dist")
plot.WordCountAna(res,choix="cons")
plot.WordCountAna(res,choix="cons",proba=0.1)
</code></pre>

<hr>
<h2 id='plotellipse'>Plot confidence ellipses</h2><span id='topic+plotellipse'></span>

<h3>Description</h3>

<p>Plot confidence ellipses.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotellipse(mat, alpha = 0.05, coord = c(1,2), eig, cex = 1, 
    color = NULL, title = NULL, graph.type = c("ggplot","classic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotellipse_+3A_mat">mat</code></td>
<td>
<p>Matrix with all the points</p>
</td></tr>
<tr><td><code id="plotellipse_+3A_alpha">alpha</code></td>
<td>
<p>the confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="plotellipse_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plotellipse_+3A_eig">eig</code></td>
<td>
<p>a matrix with the component of the factor analysis (in row) and the eigenvalues, the inertia and the cumulative inertia for each component. Typically, the <code>eig</code> output of the <code>construct.axes</code> function</p>
</td></tr>
<tr><td><code id="plotellipse_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="plotellipse_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="plotellipse_+3A_title">title</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="plotellipse_+3A_graph.type">graph.type</code></td>
<td>
<p>a character that gives the type of graph used: &quot;ggplot&quot; or &quot;classic&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(chocolates)
donnee &lt;- cbind.data.frame(sensochoc[,c(1,4,5:18)])
axe &lt;- construct.axes(donnee, scale.unit = TRUE)
simul &lt;- simulation(axe)
plotellipse (simul, alpha = 0.05, eig = signif(axe$eig,4))
#######################################
donnee &lt;- cbind.data.frame(sensochoc[,c(1,4,5:18)])
axe &lt;- construct.axes(donnee, group = c(6,8), 
    name.group = c("A-F","T-S"),scale.unit = TRUE)
simul &lt;- simulation(axe, nbgroup = (ncol(axe$partiel)-2)/(ncol(axe$moyen)-2))
plotellipse (simul, alpha = 0.05, eig = signif(axe$eig,4))

## End(Not run)</code></pre>

<hr>
<h2 id='plotellipseinter'>Plotellipseinter</h2><span id='topic+plotellipseinter'></span>

<h3>Description</h3>

<p>Construit l'ensemble des ellipses de confiance</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotellipseinter(mat, alpha = 0.05, coord = c(1,2), nbgroup = 1,
    moy = TRUE, eig, cex = 1, color = NULL, title = NULL,
	graph.type = c("ggplot","classic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotellipseinter_+3A_mat">mat</code></td>
<td>
<p>Matrix with all the points</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_alpha">alpha</code></td>
<td>
<p>Confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_nbgroup">nbgroup</code></td>
<td>
<p>Confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_moy">moy</code></td>
<td>
<p>Confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_eig">eig</code></td>
<td>
<p>a matrix with the component of the factor analysis (in row) and the eigenvalues, the inertia and the cumulative inertia for each component. Typically, the <code>eig</code> output of the <code>construct.axes</code> function</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_title">title</code></td>
<td>
<p>string corresponding to the title of the graph you draw (by default NULL and a title is chosen)</p>
</td></tr>
<tr><td><code id="plotellipseinter_+3A_graph.type">graph.type</code></td>
<td>
<p>a character that gives the type of graph used: &quot;ggplot&quot; or &quot;classic&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson</p>

<hr>
<h2 id='plotellipseinterhmfa'>Plotellipseinterhmfa</h2><span id='topic+plotellipseinterhmfa'></span>

<h3>Description</h3>

<p>Construit l'ensemble des ellipses de confiance</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotellipseinterhmfa(mat, alpha = 0.05, coord = c(1,2), nbgroup = 1,
    eig, cex = 1, color = NULL, hmfa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotellipseinterhmfa_+3A_mat">mat</code></td>
<td>
<p>Matrix with all the points</p>
</td></tr>
<tr><td><code id="plotellipseinterhmfa_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plotellipseinterhmfa_+3A_alpha">alpha</code></td>
<td>
<p>Confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="plotellipseinterhmfa_+3A_nbgroup">nbgroup</code></td>
<td>
<p>Confidence level of the ellipses</p>
</td></tr>
<tr><td><code id="plotellipseinterhmfa_+3A_eig">eig</code></td>
<td>
<p>a matrix with the component of the factor analysis (in row) and the eigenvalues, the inertia and the cumulative inertia for each component. Typically, the <code>eig</code> output of the <code>construct.axes</code> function</p>
</td></tr>
<tr><td><code id="plotellipseinterhmfa_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="plotellipseinterhmfa_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="plotellipseinterhmfa_+3A_hmfa">hmfa</code></td>
<td>
<p>a list with the hierarchy and the partial coordinates of the HMFA</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson</p>

<hr>
<h2 id='plotpanelist'>Plotpanelist</h2><span id='topic+plotpanelist'></span>

<h3>Description</h3>

<p>Displays panelists' sensory profiles onto the products' space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotpanelist(mat, coord = c(1,2), name = FALSE, eig, cex = 1, color = NULL, 
  graph.type = c("ggplot","classic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotpanelist_+3A_mat">mat</code></td>
<td>
<p>a data frame structured as the first element of the list resulting from the function construct.axes,
i.e. the coordinates of the products with respect to the panel and to each panelists</p>
</td></tr>
<tr><td><code id="plotpanelist_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="plotpanelist_+3A_name">name</code></td>
<td>
<p>boolean, if T then the name of each panelist is displayed on the graph (by default, FALSE
is assigned to that parameter)</p>
</td></tr>
<tr><td><code id="plotpanelist_+3A_eig">eig</code></td>
<td>
<p>a matrix with the component of the factor analysis (in row) and the eigenvalues, the inertia and the cumulative inertia for each component. Typically, the <code>eig</code> output of the <code>construct.axes</code> function</p>
</td></tr>
<tr><td><code id="plotpanelist_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
<tr><td><code id="plotpanelist_+3A_color">color</code></td>
<td>
<p>a vector with the colors used; by default there are 35 colors defined</p>
</td></tr>
<tr><td><code id="plotpanelist_+3A_graph.type">graph.type</code></td>
<td>
<p>a character that gives the type of graph used: &quot;ggplot&quot; or &quot;classic&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a graph where each product is displayed with respect to a panel and to each panelist composing
the panel. Products described by the panel are displayed as square, they are displayed as circle when
they are described by each panelist.
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
donnee &lt;- cbind.data.frame(sensochoc[,c(1,4,5:18)])
axe &lt;- construct.axes(donnee, scale.unit = TRUE)
plotpanelist(axe$moyen, eig = signif(axe$eig,4))
</code></pre>

<hr>
<h2 id='pmfa'>Procrustean Multiple Factor Analysis (PMFA)</h2><span id='topic+pmfa'></span>

<h3>Description</h3>

<p>Performs Multiple Factor Analysis combined with Procrustean Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmfa(matrice, matrice.illu = NULL, mean.conf = NULL, dilat = TRUE,
      graph.ind = TRUE, graph.mfa = TRUE, lim = c(60,40), coord = c(1,2), cex = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmfa_+3A_matrice">matrice</code></td>
<td>
<p>a data frame of dimension (<em>p,2j</em>), where <em>p</em> represents the number 
of products and <em>j</em> the number of panelists</p>
</td></tr>
<tr><td><code id="pmfa_+3A_matrice.illu">matrice.illu</code></td>
<td>
<p>a data frame with illustrative variables (with the same row.names in common as in <code>matrice</code>)</p>
</td></tr>  
<tr><td><code id="pmfa_+3A_mean.conf">mean.conf</code></td>
<td>
<p>coordinates of the average configuration (by default NULL, the average configuration is generated by MFA)</p>
</td></tr>  
<tr><td><code id="pmfa_+3A_dilat">dilat</code></td>
<td>
<p>boolean, if TRUE (which is the default value) the Morand's dilatation is used</p>
</td></tr>  
<tr><td><code id="pmfa_+3A_graph.ind">graph.ind</code></td>
<td>
<p>boolean, if TRUE (which is the default value) superimposes each panelist's configuration on the average configuration</p>
</td></tr>  
<tr><td><code id="pmfa_+3A_graph.mfa">graph.mfa</code></td>
<td>
<p>boolean, if TRUE (which is the default value) and if <code>mean.conf</code> = NULL the graphs of the MFA are drawn</p>
</td></tr>  
<tr><td><code id="pmfa_+3A_lim">lim</code></td>
<td>
<p>size of the tablecothe</p>
</td></tr>  
<tr><td><code id="pmfa_+3A_coord">coord</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="pmfa_+3A_cex">cex</code></td>
<td>
<p>cf. function <code><a href="graphics.html#topic+par">par</a></code> in the <span class="pkg">graphics</span> package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs first Multiple Factor Analysis on the tableclothes, then GPA in order to superimpose as well
as possible panelist's configuration on the average configuration obtained by MFA (in the case where <code>mean.conf</code> is NULL).
If <code>mean.conf</code> is not NULL the configuration used is the one input by the user.
</p>


<h3>Value</h3>

<p>Returns the RV coefficient between each individual configuration and the consensus. <br />
If <code>mean.conf</code> is NULL (and <code>graph.mfa</code> is TRUE), returns the usual graphs resulting from the MFA function: the graph of the individuals and their partial representations,
the graph of the variables (i.e. the coordinates of the products given by each panelist). <br />
If <code>mean.conf</code> is not NULL returns the configuration input by the user. <br />
When <code>matrice.illu</code> is not NULL, returns a graph of illustrative variables. <br />
Returns as many superimposed representations of individual configurations as there are panelists.
</p>


<h3>Author(s)</h3>

<p>Francois Husson, Sebastien Le</p>


<h3>References</h3>

<p>Morand, E., Pages, J. Procrustes multiple factor analysis to analyze the overall perception of food products.
<em>Food Quality and Preference</em> 14, 182-188.
</p>


<h3>See Also</h3>

<p><code><a href="FactoMineR.html#topic+MFA">MFA</a></code>, <code><a href="#topic+nappeplot">nappeplot</a></code>, <code><a href="#topic+indscal">indscal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(napping)
nappeplot(napping.don)
dev.new()
pmfa(napping.don, napping.words)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.fahst'>Print Factorial Approach for Hierarchical Sorting Task data (FAHST) results</h2><span id='topic+print.fahst'></span>

<h3>Description</h3>

<p>Print Factorial Approach for Hierarchical Sorting Task data (FAHST) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fahst'
print(x, file = NULL, sep = ";", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fahst_+3A_x">x</code></td>
<td>
<p>an object of class fahst</p>
</td></tr>
<tr><td><code id="print.fahst_+3A_file">file</code></td>
<td>
<p>A connection, or a character string naming the file to print to.  If NULL (the default), the results are not printed in a file</p>
</td></tr>
<tr><td><code id="print.fahst_+3A_sep">sep</code></td>
<td>
<p>character string to insert between the objects to print (if the argument file is not NULL</p>
</td></tr>
<tr><td><code id="print.fahst_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+fahst">fahst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cards)
group&lt;-c(2,3,3,2,2,4,2,3,2,1,3,2,3,3,3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3)
res.fast &lt;- fahst(cards,group,graph=F)
print.fahst(res.fahst, file="c:/fahst.csv", sep = ";")

## End(Not run)
</code></pre>

<hr>
<h2 id='print.fasnt'>Print Factorial Approach for Sorting Napping Task data (FASNT) results</h2><span id='topic+print.fasnt'></span>

<h3>Description</h3>

<p>Print Factorial Approach for Sorting Napping Task data (FASNT) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fasnt'
print(x, file = NULL, sep = ";", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fasnt_+3A_x">x</code></td>
<td>
<p>an object of class fasnt</p>
</td></tr>
<tr><td><code id="print.fasnt_+3A_file">file</code></td>
<td>
<p>A connection, or a character string naming the file to print to.  If NULL (the default), the results are not printed in a file</p>
</td></tr>
<tr><td><code id="print.fasnt_+3A_sep">sep</code></td>
<td>
<p>character string to insert between the objects to print (if the argument file is not NULL</p>
</td></tr>
<tr><td><code id="print.fasnt_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+fasnt">fasnt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(smoothies)
res.fasnt &lt;- fasnt(smoothies, first="nappe",graph=F)
print.fasnt(res.fasnt, file="c:/fasnt.csv", sep = ";")

## End(Not run)
</code></pre>

<hr>
<h2 id='print.fast'>Print Factorial Approach for Sorting Task data (FAST) results</h2><span id='topic+print.fast'></span>

<h3>Description</h3>

<p>Print Factorial Approach for Sorting Task data (FAST) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fast'
print(x, file = NULL, sep = ";", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fast_+3A_x">x</code></td>
<td>
<p>an object of class fast</p>
</td></tr>
<tr><td><code id="print.fast_+3A_file">file</code></td>
<td>
<p>A connection, or a character string naming the file to print to.  If NULL (the default), the results are not printed in a file</p>
</td></tr>
<tr><td><code id="print.fast_+3A_sep">sep</code></td>
<td>
<p>character string to insert between the objects to print (if the argument file is not NULL</p>
</td></tr>
<tr><td><code id="print.fast_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marine Cadoret, Sebastien Le <a href="mailto:sebastien.le@institut-agro.fr">sebastien.le@institut-agro.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+fast">fast</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(perfume)
res.fast &lt;- fast(perfume,graph=FALSE)
print.fast(res.fast, file="c:/essai.csv", sep = ";")

## End(Not run)
</code></pre>

<hr>
<h2 id='scalebypanelist'>Scale by panelist</h2><span id='topic+scalebypanelist'></span>

<h3>Description</h3>

<p>Returns a data frame with entries the means of the products over the sessions for 
the whole panel and for each panelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalebypanelist(matrice, center = TRUE, scale = FALSE, col.p, 
    col.j, firstvar, lastvar = ncol(matrice), method = "coeff")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalebypanelist_+3A_matrice">matrice</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>
<tr><td><code id="scalebypanelist_+3A_center">center</code></td>
<td>
<p>boolean, if T scores given by panelists are centered</p>
</td></tr>  
<tr><td><code id="scalebypanelist_+3A_scale">scale</code></td>
<td>
<p>boolean, if T scores given by panelists are scaled to unit varaince</p>
</td></tr>  
<tr><td><code id="scalebypanelist_+3A_col.p">col.p</code></td>
<td>
<p>the position of one categorical variables of interest (the <em>product</em> variable)</p>
</td></tr>
<tr><td><code id="scalebypanelist_+3A_col.j">col.j</code></td>
<td>
<p>the position of one categorical variables of interest (the <em>panelist</em> variable)</p>
</td></tr>
<tr><td><code id="scalebypanelist_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="scalebypanelist_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code>)</p>
</td></tr>
<tr><td><code id="scalebypanelist_+3A_method">method</code></td>
<td>
<p>the method to replace the missing values: &quot;average&quot; or &quot;coeff&quot; 
(coefficients of the <em>product</em> variable in the anova model)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame of dimension (<em>p*(1+j),k+2</em>), where <em>p</em> is the number
of products, <em>j</em> the number of panelists, and <em>k</em> the number of sensory 
descriptors (the first two variables correspond to the <em>panelist</em> and the <em>product</em> variables). 
This data frame contains the means of the products over the sessions for 
the whole panel and for each panelist (data may be scaled to unit variance or not, this 
parameter is set by users).
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
res=scalebypanelist(sensochoc, col.p = 4, col.j = 1, firstvar = 5)
res
</code></pre>

<hr>
<h2 id='search.desc'>Search for discriminating descriptors</h2><span id='topic+search.desc'></span>

<h3>Description</h3>

<p>This function is designed to select the significant descriptors in a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search.desc(matrice, col.j, col.p, firstvar, 
      lastvar = ncol(matrice), level = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search.desc_+3A_matrice">matrice</code></td>
<td>
<p>a data frame made up of at least two qualitative variables 
(<em>product</em>, <em>panelist</em>) and a set of quantitative variables (sensory descriptors)</p>
</td></tr>
<tr><td><code id="search.desc_+3A_col.j">col.j</code></td>
<td>
<p>the position of the categorical variable which make the variability, panelist for sensory studies. The value of <code>col.j</code> can also be NULL if no categorical variables make the variability.</p>
</td></tr>
<tr><td><code id="search.desc_+3A_col.p">col.p</code></td>
<td>
<p>the position of the categorical variable of interest, product for sensory studies</p>
</td></tr>
<tr><td><code id="search.desc_+3A_firstvar">firstvar</code></td>
<td>
<p>the position of the first endogenous variable</p>
</td></tr>
<tr><td><code id="search.desc_+3A_lastvar">lastvar</code></td>
<td>
<p>the position of the last endogenous variable (by default the last column of <code>donnee</code></p>
</td></tr>
<tr><td><code id="search.desc_+3A_level">level</code></td>
<td>
<p>the threshold (P-value) below which variables are considered as discriminating for
the following analysis of variance model: <code>descriptor=col.p+col.j</code> </p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Returns a data frame with all the qualitative variables and only discriminating variables
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
## In this example, all the descriptos are discriminated
interesting.desc &lt;- search.desc(sensochoc, col.j = 1, col.p = 4, 
    firstvar = 5, level = 0.5)
</code></pre>

<hr>
<h2 id='senso.cocktail'>Sensory data for 16 cocktails</h2><span id='topic+senso.cocktail'></span>

<h3>Description</h3>

<p>The data used here refer to the sensory description of 16 cocktails. Each cocktail was evaluated by 12 panelists according to 13
sensory descriptors (only the average of each cocktail are given).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cocktail)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows and 13 columns: each cocktail was evaluated by 12 panelists according to 13
sensory descriptors.
</p>


<h3>Source</h3>

<p>Agrocampus Rennes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cocktail)
</code></pre>

<hr>
<h2 id='sensochoc'>Sensory data for 6 chocolates</h2><span id='topic+sensochoc'></span>

<h3>Description</h3>

<p>The data used here refer to the sensory description of six varieties of chocolates sold in France: 
each chocolate was evaluated twice by 29 panelists according to 14
sensory descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chocolates)</code></pre>


<h3>Format</h3>

<p>A data frame with 348 rows and 19 columns: 5 qualitative variables
(Panelist, Session, Form, Rank, Product) and 14 sensory descriptors.
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
decat(sensochoc, formul = "~Product+Panelist", firstvar = 5, graph = FALSE)
</code></pre>

<hr>
<h2 id='sensopanels'>Sensory profiles given by 7 panels</h2><span id='topic+sensopanels'></span>

<h3>Description</h3>

<p>The data used here refer to six varieties of chocolates sold in France.
Each chocolate was evaluated by 7 panels according to 14
sensory descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chocolates)</code></pre>


<h3>Format</h3>

<p>A data frame with 6 rows and 98 columns: each row corresponds to a chocolate
and each column to the mean over the panelists of a given panel 
according to a sensory descriptor.
</p>


<h3>Source</h3>

<p>Agrocampus Rennes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
</code></pre>

<hr>
<h2 id='simulation'>Simulate virtual panels</h2><span id='topic+simulation'></span>

<h3>Description</h3>

<p>Simulate virtual panels</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation(axeAFM, nbchoix = NULL, nbgroup = 1, nbsimul = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulation_+3A_axeafm">axeAFM</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="simulation_+3A_nbchoix">nbchoix</code></td>
<td>
<p>Number of panelists in a virtual Panel</p>
</td></tr>  
<tr><td><code id="simulation_+3A_nbgroup">nbgroup</code></td>
<td>
<p>Number of groups (by default 1 for a PCA)</p>
</td></tr>  
<tr><td><code id="simulation_+3A_nbsimul">nbsimul</code></td>
<td>
<p>number of simulations</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Called by the simulation procedure
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>References</h3>

<p>Husson, F., Le Dien, S. &amp; Pages, J.  (2005). Confidence ellipse for the sensory profiles obtained by Principal Components Analysis. Food Quality and Preference.  16 (3). pp. 245-250.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chocolates)
donnee &lt;- cbind.data.frame(sensochoc[,c(1,4,5:18)])
axe &lt;- construct.axes(donnee, scale.unit = TRUE)
simul &lt;- simulation(axe)
plotellipse (simul, alpha = 0.05, eig = signif(axe$eig,4))
</code></pre>

<hr>
<h2 id='smoothies'>Smoothies</h2><span id='topic+smoothies'></span>

<h3>Description</h3>

<p>The data used here refer to 8 smoothies on which 24 consumers performed a sorted napping task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(smoothies)</code></pre>


<h3>Format</h3>

<p>A data frame with 8 rows (the number of smoothies) and 72 columns (the number of consumers * 3).
For each consumer, we have the coordinates of the products on the tablecloth associated with napping on the one hand and the partitionning variable associated with categorization on the other hand.
The columns are grouped by consumer.
</p>


<h3>Source</h3>

<p>Applied mathematics department, Institut Agro
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(smoothies)
## Example of FASNT
res.fasnt&lt;-fasnt(smoothies,first="nappe")

## End(Not run)
</code></pre>

<hr>
<h2 id='triangle.design'>Construct a design for triangle tests</h2><span id='topic+triangle.design'></span>

<h3>Description</h3>

<p>Construct a design to make triangle tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle.design (nbprod , nbpanelist, bypanelist = nbprod*(nbprod-1)/2,
   labprod=1:nbprod, labpanelist=1:nbpanelist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle.design_+3A_nbprod">nbprod</code></td>
<td>
<p>number of products to compare</p>
</td></tr>
<tr><td><code id="triangle.design_+3A_nbpanelist">nbpanelist</code></td>
<td>
<p>number of panelists who make the triangle test</p>
</td></tr>
<tr><td><code id="triangle.design_+3A_bypanelist">bypanelist</code></td>
<td>
<p>number of expermient that each panelist can done (by default each panelist make all the comparisons between the products</p>
</td></tr>
<tr><td><code id="triangle.design_+3A_labprod">labprod</code></td>
<td>
<p>name of the products (by default, the product are coded from 1 to the number of products</p>
</td></tr>
<tr><td><code id="triangle.design_+3A_labpanelist">labpanelist</code></td>
<td>
<p>name of the panelists (by default, the panelists are coded from 1 to the number of panelists</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Triangle test: panelists receive three coded samples. They are told that two of the sample are the same and one is different.
Panelists are asked to identify the odd sample.</p>


<h3>Value</h3>

<p>Returns an data.frame of dimension (<em>t,3</em>), where <em>t</em> is the number of experiments.
In column 1, 2 and 3 the product to test are given.
The product in column 1 is by coded &quot;X&quot;, in column 2 is coded by &quot;Y&quot; and in column 3 is coded by &quot;Z&quot;.
Panelist should start by product &quot;X&quot;, then &quot;Y&quot; and then by &quot;Z&quot;.
</p>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>See Also</h3>

<p><code><a href="#topic+triangle.test">triangle.test</a></code>, <code><a href="#topic+triangle.pair.test">triangle.pair.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Example 1
design1 = triangle.design (nbprod = 4, nbpanelist = 8)

##Example 2
design2 = triangle.design(nbprod = 4, nbpanelist = 6, bypanelist = 3,
  labprod=c("prod1","prod2","prod3","prod4"),
  labpanelist=c("John","Audrey","Peter","Martina","James","Lisa"))
  
</code></pre>

<hr>
<h2 id='triangle.pair.test'>Make a Triangle test for two products</h2><span id='topic+triangle.pair.test'></span>

<h3>Description</h3>

<p>Make a Triangle test for two products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle.pair.test (nb.good, nb.answer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle.pair.test_+3A_nb.good">nb.good</code></td>
<td>
<p>number of panelists who identify the odd sample</p>
</td></tr>
<tr><td><code id="triangle.pair.test_+3A_nb.answer">nb.answer</code></td>
<td>
<p>number of panelists who make the triangle test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Triangle test: panelists receive three coded samples. They are told that two of the sample are the same and one is different.
Panelists are asked to identify the odd sample. 
</p>


<h3>Value</h3>

<p>Returns 
</p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the Triangle test;</p>
</td></tr>
<tr><td><code>Estimation</code></td>
<td>
<p>estimation by Maximum Likelihood of the number of panelists who really perceive the difference between the products;</p>
</td></tr>
<tr><td><code>ML</code></td>
<td>
<p>Maximum Likelihood of the estimation of the number of panelists who really perceive the difference between the products;</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>
<p>minimum of panelists who should detect the odd product to can say that panelists perceive the difference between the products.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>See Also</h3>

<p><code><a href="#topic+triangle.test">triangle.test</a></code>, <code><a href="#topic+triangle.design">triangle.design</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>triangle.pair.test (11, 20)  
</code></pre>

<hr>
<h2 id='triangle.test'>Make a Triangle test for a set of products</h2><span id='topic+triangle.test'></span>

<h3>Description</h3>

<p>Make a Triangle test for a set of products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle.test (design, answer, preference = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle.test_+3A_design">design</code></td>
<td>
<p>a data.frame corresponding to the design use to make the Triangle test (typically the ouput of the function <code>triangle.design</code></p>
</td></tr>
<tr><td><code id="triangle.test_+3A_answer">answer</code></td>
<td>
<p>a vector of the answers of all the panelists; all the answer should be &quot;X&quot;, &quot;Y&quot; or &quot;Z&quot;</p>
</td></tr>
<tr><td><code id="triangle.test_+3A_preference">preference</code></td>
<td>
<p>a vector of the preference of the panelists; all the answer should be &quot;X&quot;, &quot;Y&quot; or &quot;Z&quot; (by default, there preference are not taken into account)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Triangle test: panelists receive three coded samples. They are told that two of the sample are the same and one is different.
Panelists are asked to identify the odd sample. 
</p>


<h3>Value</h3>

<p>Returns a list of matrices. Each matrix give the reult for all the pair of products:
</p>
<table>
<tr><td><code>nb.comp</code></td>
<td>
<p>a matrix with the number of comparisons done for each pair of products;</p>
</td></tr>
<tr><td><code>nb.ident</code></td>
<td>
<p>a matrix with the number of panelists who indicate the odd product for each pair of products;</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>a matrix with the p-value of the Triangle tests for each pair of products;</p>
</td></tr>
<tr><td><code>nb.recognition</code></td>
<td>
<p>estimation of the panelists who really perceived the difference between two product, for each pair of product;</p>
</td></tr>
<tr><td><code>maxML</code></td>
<td>
<p>Maximum Likelihood of the estimation of the number of panelists who really perceive the difference between the products;</p>
</td></tr>
<tr><td><code>confusion</code></td>
<td>
<p>estimation of the percentage of panelists who do not perceived the difference between two product, for each pair of product;</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>
<p>minimum of panelists who should detect the odd product to can say that panelists perceive the difference between the products, for each pair of products;</p>
</td></tr>
<tr><td><code>preference</code></td>
<td>
<p>number of times that product of row i is prefered that product in column j for the panelists who find the odd product.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francois Husson</p>


<h3>See Also</h3>

<p><code><a href="#topic+triangle.pair.test">triangle.pair.test</a></code>, <code><a href="#topic+triangle.design">triangle.design</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>design = triangle.design(nbprod = 4, nbpanelist = 6, bypanelist = 3)
answer = c("X","Y","Y","X","Z","X","Y","X","Z",
    "X","X","Z","X","Y","X","Z","X","Y")
triangle.test (design, answer)  
</code></pre>

<hr>
<h2 id='videos'>
Videos data obtained with Holos
</h2><span id='topic+videos'></span>

<h3>Description</h3>

<p>Example of Holos data, as obtained with the <code><a href="#topic+format_holos">format_holos</a></code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(videos)</code></pre>


<h3>Format</h3>

<p>A list of 4 objects: <code>name.subjects</code>, a dataframe containing the concordance between the names of the subjects as given in the Holos experiment and their ID; <code>datadigit</code>, a list of S (S = number of subjects) dataframes corresponding to the digit-tracking data; <code>datafinal_coord</code>, a list of S (S = number of subjects) dataframes corresponding to the final configurations data; and <code>datafinal_verb</code>, a list of S (S = number of subjects) dataframes corresponding to the final verbalization data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_holos">format_holos</a> <a href="#topic+analyse_holos">analyse_holos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(videos)
</code></pre>

<hr>
<h2 id='WilliamsDesign'>Construct a Williams design</h2><span id='topic+WilliamsDesign'></span>

<h3>Description</h3>

<p>Construct a Williams design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WilliamsDesign(nbprod,seed=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WilliamsDesign_+3A_nbprod">nbprod</code></td>
<td>
<p>nombre de produits</p>
</td></tr>
<tr><td><code id="WilliamsDesign_+3A_seed">seed</code></td>
<td>
<p>a number to intialize the generator of the random number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Retrun the design<br />
</p>


<h3>Author(s)</h3>

<p>Francois Husson <a href="mailto:husson@agrocampus-rennes.fr">husson@agrocampus-rennes.fr</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> exemple1 &lt;- WilliamsDesign(12)
</code></pre>

<hr>
<h2 id='WordCountAna'>Word-Count based methods Analysis  (WordCountAna)</h2><span id='topic+WordCountAna'></span>

<h3>Description</h3>

<p>Sensory methods as labelled sorting task, check-all-that-apply (CATA), ultra-flash profiling (UFP) and open-ended questions can be used to collect free-text descriptions of products through word-count based methods. A data frame with rows-products and columns-panellists is considered for the analysis. WordCountAna performs a multiple factor analysis for contingency tables keeping all the information in the comparison of the products. The identification of the consensual words which have the same meaning for most of the panellists eases the interpretation of the word-count based methods and solves the problems arising from the large diversity of vocabulary as the different meanings possibly associated to a same word. A test, based on resampling techniques, allows for assessing the significance of the consensus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WordCountAna (base, sep.word = NULL, ncp = Inf, nb.panel = 3, nb.simul = 500, 
    proba = 0.05, graph = TRUE, axes = c(1,2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WordCountAna_+3A_base">base</code></td>
<td>
<p>a data frame with n rows (products) and p columns (panellists). Each cell corresponds to a free-text description used to describe a product by a panellist</p>
</td></tr>
<tr><td><code id="WordCountAna_+3A_sep.word">sep.word</code></td>
<td>
<p>a string with all the characters which correspond to separator of words (by default, NULL and is considered equal to &quot;; (),?./:'!$=+;&lt;&gt;[]@-&quot;)</p>
</td></tr>
<tr><td><code id="WordCountAna_+3A_ncp">ncp</code></td>
<td>
<p>number of dimensions kept in the results and to compute the within-inertia</p>
</td></tr>
<tr><td><code id="WordCountAna_+3A_nb.panel">nb.panel</code></td>
<td>
<p>minimum number of panellists who used the same word in order to define consensual words (by default 3)</p>
</td></tr>
<tr><td><code id="WordCountAna_+3A_nb.simul">nb.simul</code></td>
<td>
<p>number of bootstrap simulations (by default 500)</p>
</td></tr>
<tr><td><code id="WordCountAna_+3A_proba">proba</code></td>
<td>
<p>significance threshold considered to define consensual words (by default 0.05)</p>
</td></tr>
<tr><td><code id="WordCountAna_+3A_graph">graph</code></td>
<td>
<p>boolean, if TRUE a graph is displayed</p>
</td></tr>
<tr><td><code id="WordCountAna_+3A_axes">axes</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mfact</code></td>
<td>
<p>a list of matrices containing all the results for multiple factor analysis for contingency tables</p>
</td></tr>
<tr><td><code>dist.words</code></td>
<td>
<p>a matrix containing the results for distinct words (number of times that used and number of panellists that pronounced)</p>
</td></tr>
<tr><td><code>centroids</code></td>
<td>
<p>a matrix containing the coordinates of the centroids of distinct-words</p>
</td></tr>
<tr><td><code>cons</code></td>
<td>
<p>a matrix containing the results of bootstrap resampling for distinct-words pronounced by at least &quot;nb.panel&quot; panellists (number of times that used, number of panellists that pronounced and the significance of the consensus)</p>
</td></tr>
<tr><td><code>cons.words</code></td>
<td>
<p>a vector of consensual words assessed by bootstrap resampling</p>
</td></tr>
</table>
<p>Returns the products factor map, panellists factor map, distinct-words factor map and consensual words factor map.
</p>


<h3>Author(s)</h3>

<p>Belchin Kostov <a href="mailto:badriyan@clinic.ub.es">badriyan@clinic.ub.es</a>, Francois Husson <a href="mailto:francois.husson@institut-agro.fr">francois.husson@institut-agro.fr</a>, Monica Becue-Bertaut</p>


<h3>References</h3>

<p>Becue-Bertaut, M. and Pages, J. (2008). Multiple factor analysis and clustering of a mixture of quantitative, categorical and frequency data. <em>Computational Statistice and Data Analysis</em>, 52, 3255-3268.
Kostov, B., Becue-Bertaut, M. and Husson, F. (2012). Multiple Factor Analysis for Contingency Tables in FactoMineR Package. <em>The R journal</em>
Kostov, B., Becue-Bertaut, M., Husson, F., Pages, J., Cadoret, M., Torrens, J. and Urpi, P. (2012). A tool for detecting words with consensual meaning in verbalization tasks. 11th Sensometrics Conference, July 10-13, 2012, Rennes, France.
</p>


<h3>See Also</h3>

 <p><code>textual</code>, <code>MFA</code>, <code><a href="#topic+plot.WordCountAna">plot.WordCountAna</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(perfume)
res&lt;-WordCountAna(base=perfume,sep.word=";")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
