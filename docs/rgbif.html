<!DOCTYPE html><html lang="en-US"><head><title>Help for package rgbif</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgbif}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rgbif-package'><p>Interface to the Global Biodiversity Information Facility API.</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#blanktheme'><p>Custom ggplot2 theme</p></a></li>
<li><a href='#check_wkt'><p>Check input WKT</p></a></li>
<li><a href='#count_facet'><p>Facetted count occurrence search.</p></a></li>
<li><a href='#create_gist'><p>Function that takes a list of files and creates payload for API</p></a></li>
<li><a href='#dataset'><p>Search for more obscure dataset metadata.</p></a></li>
<li><a href='#dataset_doi'><p>Get a GBIF dataset from a doi</p></a></li>
<li><a href='#dataset_gridded'><p>Check if a dataset is gridded</p></a></li>
<li><a href='#dataset_list_funs'><p>List datasets that are deleted or have no endpoint.</p></a></li>
<li><a href='#dataset_search'><p>Search for dataset metadata.</p></a></li>
<li><a href='#dataset_uuid_funs'><p>Get dataset metadata using a datasetkey</p></a></li>
<li><a href='#datasets'><p>Search for datasets and dataset metadata.</p></a></li>
<li><a href='#density_spplist'><p>The density web service provides access to records showing the density</p>
of occurrence records from the GBIF Network by one-degree cell.</a></li>
<li><a href='#densitylist'><p>The density web service provides access to records showing the density</p>
of occurrence records from the GBIF Network by one-degree cell.</a></li>
<li><a href='#derived_dataset'><p>Register a derived dataset for citation.</p></a></li>
<li><a href='#download_predicate_dsl'><p>Download predicate DSL (domain specific language)</p></a></li>
<li><a href='#downloads'><p>Downloads interface</p></a></li>
<li><a href='#DownReq'><p>DownReq</p></a></li>
<li><a href='#elevation'><p>Get elevation for lat/long points from a data.frame or list of points.</p></a></li>
<li><a href='#enumeration'><p>Enumerations.</p></a></li>
<li><a href='#gbif_bbox2wkt'><p>Convert a bounding box to a Well Known Text polygon, and a WKT to a</p>
bounding box</a></li>
<li><a href='#gbif_citation'><p>Get citation for datasets used</p></a></li>
<li><a href='#gbif_geocode'><p>Geocode lat-lon point(s) with GBIF's set of geo-polygons (experimental)</p></a></li>
<li><a href='#gbif_issues'><p>List all GBIF issues and their codes.</p></a></li>
<li><a href='#gbif_issues_lookup'><p>Lookup issue definitions and short codes</p></a></li>
<li><a href='#gbif_names'><p>View highlighted terms in name results from GBIF.</p></a></li>
<li><a href='#gbif_oai'><p>GBIF registry data via OAI-PMH</p></a></li>
<li><a href='#gbif_photos'><p>View photos from GBIF.</p></a></li>
<li><a href='#gbifdata'><p>Get data.frame from occurrencelist, occurrencelist_many, or densitylist.</p></a></li>
<li><a href='#gbifmap'><p>Get Github credentials from use in console</p></a></li>
<li><a href='#gbifmap_dens'><p>Make a simple map to visualize GBIF data density data</p></a></li>
<li><a href='#gbifmap_list'><p>Make a simple map to visualize GBIF point data.</p></a></li>
<li><a href='#GbifQueue'><p>GbifQueue</p></a></li>
<li><a href='#get_credentials'><p>Get Github credentials from use in console</p></a></li>
<li><a href='#gist'><p>Post a file as a Github gist</p></a></li>
<li><a href='#installations'><p>Installations metadata.</p></a></li>
<li><a href='#lit_search'><p>Search for literature that cites GBIF mediated data</p></a></li>
<li><a href='#map_fetch'><p>Fetch maps of GBIF occurrences</p></a></li>
<li><a href='#mvt_fetch'><p>Fetch Map Vector Tiles (MVT)</p></a></li>
<li><a href='#name_backbone'><p>Lookup names in the GBIF backbone taxonomy.</p></a></li>
<li><a href='#name_backbone_checklist'><p>Lookup names in the GBIF backbone taxonomy in a checklist.</p></a></li>
<li><a href='#name_issues'><p>Parse and examine further GBIF name issues on a dataset.</p></a></li>
<li><a href='#name_lookup'><p>Lookup names in all taxonomies in GBIF.</p></a></li>
<li><a href='#name_parse'><p>Parse taxon names using the GBIF name parser.</p></a></li>
<li><a href='#name_suggest'><p>Suggest up to 20 name usages.</p></a></li>
<li><a href='#name_usage'><p>Lookup details for specific names in all taxonomies in GBIF.</p></a></li>
<li><a href='#network'><p>Get data about GBIF networks</p></a></li>
<li><a href='#networks'><p>Networks metadata.</p></a></li>
<li><a href='#nodes'><p>Nodes metadata.</p></a></li>
<li><a href='#occ_count'><p>Get number of occurrence records.</p></a></li>
<li><a href='#occ_count_'><p>Get quick pre-computed occurrence counts of a limited number of dimensions.</p></a></li>
<li><a href='#occ_data'><p>Legacy alternative to occ_search</p></a></li>
<li><a href='#occ_download'><p>Spin up a download request for GBIF occurrence data.</p></a></li>
<li><a href='#occ_download_cached'><p>Check for downloads already in your GBIF account</p></a></li>
<li><a href='#occ_download_cancel'><p>Cancel a download creation process.</p></a></li>
<li><a href='#occ_download_dataset_activity'><p>Lists the downloads activity of a dataset</p></a></li>
<li><a href='#occ_download_datasets'><p>List datasets for a download</p></a></li>
<li><a href='#occ_download_describe'><p>Describes the fields available in GBIF downloads</p></a></li>
<li><a href='#occ_download_get'><p>Get a download from GBIF.</p></a></li>
<li><a href='#occ_download_import'><p>Import a downloaded file from GBIF.</p></a></li>
<li><a href='#occ_download_list'><p>Lists the downloads created by a user.</p></a></li>
<li><a href='#occ_download_meta'><p>Retrieves the occurrence download metadata by its unique key.</p></a></li>
<li><a href='#occ_download_queue'><p>Download requests in a queue</p></a></li>
<li><a href='#occ_download_sql'><p>Download occurrence data using a SQL query</p></a></li>
<li><a href='#occ_download_wait'><p>Wait for an occurrence download to be done</p></a></li>
<li><a href='#occ_facet'><p>Facet GBIF occurrences</p></a></li>
<li><a href='#occ_get'><p>Get data for GBIF occurrences by occurrence key</p></a></li>
<li><a href='#occ_issues'><p>Parse and examine further GBIF occurrence issues on a dataset.</p></a></li>
<li><a href='#occ_metadata'><p>Search for catalog numbers, collection codes, collector names, and</p>
institution codes.</a></li>
<li><a href='#occ_search'><p>Search for GBIF occurrences</p></a></li>
<li><a href='#occ_spellcheck'><p>Spell check search term for occurrence searches</p></a></li>
<li><a href='#occurrencecount'><p>Counts taxon concept records matching a range of filters.</p></a></li>
<li><a href='#occurrencedensity'><p>Returns summary counts of occurrence records by one-degree cell for a single</p>
taxon, country, dataset, data publisher or data network.</a></li>
<li><a href='#occurrenceget'><p>Get individual records for a given occurrence record.</p></a></li>
<li><a href='#occurrencelist'><p>Occurrencelist searches for taxon concept records matching a range of filters.</p></a></li>
<li><a href='#occurrencelist_all'><p>Occurrencelist_all carries out an occurrencelist query for a single name and</p>
all its name variants according to GBIF's name matching.</a></li>
<li><a href='#occurrencelist_many'><p>occurrencelist_many is the same as occurrencelist, but takes in a vector</p>
of species names.</a></li>
<li><a href='#organizations'><p>Organizations metadata.</p></a></li>
<li><a href='#parsenames'><p>Parse taxon names using the GBIF name parser.</p></a></li>
<li><a href='#providers'><p>Get data providers and their unique keys.</p></a></li>
<li><a href='#resources'><p>Get data resources and their unique keys.</p></a></li>
<li><a href='#rgb_country_codes'><p>Look up 2 character ISO country codes</p></a></li>
<li><a href='#rgbif-defunct'><p>Defunct functions in rgbif</p></a></li>
<li><a href='#stylegeojson'><p>Style a data.frame prior to converting to geojson.</p></a></li>
<li><a href='#suggestfields'><p>Fields available in gbif_suggest function</p></a></li>
<li><a href='#taxoncount'><p>Search by taxon to retrieve number of records in GBIF.</p></a></li>
<li><a href='#taxonget'><p>Get taxonomic information on a specific taxon or taxa in GBIF by their taxon</p>
concept keys.</a></li>
<li><a href='#taxonsearch'><p>Search for taxa in GBIF.</p></a></li>
<li><a href='#taxrank'><p>Get the possible values to be used for (taxonomic) rank arguments in GBIF</p>
API methods.</a></li>
<li><a href='#togeojson'><p>Convert spatial data files to GeoJSON from various formats.</p></a></li>
<li><a href='#wkt_parse'><p>parse wkt into smaller bits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Interface to the Global Biodiversity Information Facility API</td>
</tr>
<tr>
<td>Description:</td>
<td>A programmatic interface to the Web Service methods
    provided by the Global Biodiversity Information Facility (GBIF;
    <a href="https://www.gbif.org/developer/summary">https://www.gbif.org/developer/summary</a>). GBIF is a database
    of species occurrence records from sources all over the globe.
    rgbif includes functions for searching for taxonomic names,
    retrieving information on data providers, getting species occurrence
    records, getting counts of occurrence records, and using the GBIF
    tile map service to make rasters summarizing huge amounts of data.</td>
</tr>
<tr>
<td>Version:</td>
<td>3.8.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/rgbif">https://github.com/ropensci/rgbif</a> (devel),
<a href="https://docs.ropensci.org/rgbif/">https://docs.ropensci.org/rgbif/</a> (documentation)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/rgbif/issues">https://github.com/ropensci/rgbif/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>xml2, ggplot2, crul (&ge; 0.7.4), data.table, whisker, magrittr,
jsonlite (&ge; 1.6), oai (&ge; 0.2.2), tibble, lazyeval, R6, stats,
wk</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, png, terra, magick, protolite (&ge; 2.0), sf, vcr (&ge;
1.2.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Biodiversity</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>GBIF, specimens, API, web-services, occurrences,
species, taxonomy</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-26 15:08:27 UTC; ftw712</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Damiano Oldoni <a href="https://orcid.org/0000-0003-3445-7562"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Vijay Barve <a href="https://orcid.org/0000-0002-4852-2567"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Peter Desmet <a href="https://orcid.org/0000-0002-8442-8025"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Laurens Geffert [ctb],
  Dan Mcglinn <a href="https://orcid.org/0000-0003-2359-3526"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Karthik Ram <a href="https://orcid.org/0000-0002-0233-1757"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  rOpenSci [fnd] (https://ropensci.org/),
  John Waller <a href="https://orcid.org/0000-0002-7302-5976"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Waller &lt;jwaller@gbif.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-27 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rgbif-package'>Interface to the Global Biodiversity Information Facility API.</h2><span id='topic+rgbif-package'></span><span id='topic+rgbif'></span>

<h3>Description</h3>

<p>rgbif: A programmatic interface to the Web Service methods
provided by the Global Biodiversity Information Facility.
</p>


<h3>About</h3>

<p>This package gives you access to data from GBIF <a href="https://www.gbif.org/">https://www.gbif.org/</a>
via their API.
</p>


<h3>Documentation for the GBIF API</h3>


<ul>
<li><p> summary <a href="https://www.gbif.org/developer/summary">https://www.gbif.org/developer/summary</a> - Summary of
the GBIF API
</p>
</li>
<li><p> registry <a href="https://www.gbif.org/developer/registry">https://www.gbif.org/developer/registry</a> - Metadata
on datasets, and contributing organizations
</p>
</li>
<li><p> species names <a href="https://www.gbif.org/developer/species">https://www.gbif.org/developer/species</a> - Species
names and metadata
</p>
</li>
<li><p> occurrences <a href="https://www.gbif.org/developer/occurrence">https://www.gbif.org/developer/occurrence</a> -
Occurrences
</p>
</li>
<li><p> maps <a href="https://www.gbif.org/developer/maps">https://www.gbif.org/developer/maps</a> - Maps - these APIs
are not implemented in <span class="pkg">rgbif</span>, and are meant more for integration
with web based maps.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Scott Chamberlain
</p>
<p>Karthik Ram
</p>
<p>Dan Mcglinn
</p>
<p>Vijay Barve
</p>
<p>John Waller
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='blanktheme'>Custom ggplot2 theme</h2><span id='topic+blanktheme'></span>

<h3>Description</h3>

<p>Custom ggplot2 theme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blanktheme()
</code></pre>

<hr>
<h2 id='check_wkt'>Check input WKT</h2><span id='topic+check_wkt'></span>

<h3>Description</h3>

<p>Check input WKT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_wkt(wkt = NULL, skip_validate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_wkt_+3A_wkt">wkt</code></td>
<td>
<p>(character) one or more Well Known Text objects</p>
</td></tr>
<tr><td><code id="check_wkt_+3A_skip_validate">skip_validate</code></td>
<td>
<p>(logical) whether to skip <code>wk::wk_problems</code>
call or not. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
check_wkt('POLYGON((30.1 10.1, 10 20, 20 60, 60 60, 30.1 10.1))')
check_wkt('POINT(30.1 10.1)')
check_wkt('LINESTRING(3 4,10 50,20 25)')

# check many passed in at once
check_wkt(c('POLYGON((30.1 10.1, 10 20, 20 60, 60 60, 30.1 10.1))',
  'POINT(30.1 10.1)'))

# bad WKT
# wkt &lt;- 'POLYGON((30.1 10.1, 10 20, 20 60, 60 60, 30.1 a))'
# check_wkt(wkt)

# many wkt's, semi-colon separated, for many repeated "geometry" args
wkt &lt;- "POLYGON((-102.2 46.0,-93.9 46.0,-93.9 43.7,-102.2 43.7,-102.2 46.0))
;POLYGON((30.1 10.1, 10 20, 20 40, 40 40, 30.1 10.1))"
check_wkt(gsub("\n", '', wkt))

## End(Not run)
</code></pre>

<hr>
<h2 id='count_facet'>Facetted count occurrence search.</h2><span id='topic+count_facet'></span>

<h3>Description</h3>

<p>Facetted count occurrence search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_facet(keys = NULL, by = "country", countries = 10, removezeros = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_facet_+3A_keys">keys</code></td>
<td>
<p>(numeric) GBIF keys, a vector. optional</p>
</td></tr>
<tr><td><code id="count_facet_+3A_by">by</code></td>
<td>
<p>(character) One of georeferenced, basisOfRecord, country, or
publishingCountry. default: country</p>
</td></tr>
<tr><td><code id="count_facet_+3A_countries">countries</code></td>
<td>
<p>(numeric) Number of countries to facet on, or a vector of
country names. default: 10</p>
</td></tr>
<tr><td><code id="count_facet_+3A_removezeros">removezeros</code></td>
<td>
<p>(logical) remove zeros or not? default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Select number of countries to facet on
count_facet(by='country', countries=3, removezeros = TRUE)
# Or, pass in country names
count_facet(by='country', countries='AR', removezeros = TRUE)

spplist &lt;- c('Geothlypis trichas','Tiaris olivacea','Pterodroma axillaris',
             'Calidris ferruginea','Pterodroma macroptera',
             'Gallirallus australis',
             'Falco cenchroides','Telespiza cantans','Oreomystis bairdi',
             'Cistothorus palustris')
keys &lt;- sapply(spplist,
  function(x) name_backbone(x, rank="species")$usageKey)
count_facet(keys, by='country', countries=3, removezeros = TRUE)
count_facet(keys, by='country', countries=3, removezeros = FALSE)
count_facet(by='country', countries=20, removezeros = TRUE)
count_facet(keys, by='basisOfRecord', countries=5, removezeros = TRUE)

# get occurrences by georeferenced state
## across all records
count_facet(by='georeferenced')

## by keys
count_facet(keys, by='georeferenced')

# by basisOfRecord
count_facet(by="basisOfRecord")

## End(Not run)
</code></pre>

<hr>
<h2 id='create_gist'>Function that takes a list of files and creates payload for API</h2><span id='topic+create_gist'></span>

<h3>Description</h3>

<p>This function is defunct.  See the package gistr for similar functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_gist(...)
</code></pre>

<hr>
<h2 id='dataset'>Search for more obscure dataset metadata.</h2><span id='topic+dataset'></span>

<h3>Description</h3>

<p>Search for more obscure dataset metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset(
  country = NULL,
  type = NULL,
  identifierType = NULL,
  identifier = NULL,
  machineTagNamespace = NULL,
  machineTagName = NULL,
  machineTagValue = NULL,
  modified = NULL,
  query = NULL,
  deleted = FALSE,
  limit = NULL,
  start = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataset_+3A_country">country</code></td>
<td>
<p>The 2-letter country code (as per ISO-3166-1) of the country
publishing the dataset.</p>
</td></tr>
<tr><td><code id="dataset_+3A_type">type</code></td>
<td>
<p>The primary type of the dataset.
Available values : OCCURRENCE, CHECKLIST, METADATA, SAMPLING_EVENT,
MATERIAL_ENTITY.</p>
</td></tr>
<tr><td><code id="dataset_+3A_identifiertype">identifierType</code></td>
<td>
<p>An identifier type for the identifier parameter.
Available values : URL, LSID, HANDLER, DOI, UUID, FTP, URI, UNKNOWN,
GBIF_PORTAL, GBIF_NODE, GBIF_PARTICIPANT, GRSCICOLL_ID, GRSCICOLL_URI,
IH_IRN, ROR, GRID, CITES, SYMBIOTA_UUID, WIKIDATA, NCBI_BIOCOLLECTION.</p>
</td></tr>
<tr><td><code id="dataset_+3A_identifier">identifier</code></td>
<td>
<p>An identifier of the type given by the identifierType
parameter.</p>
</td></tr>
<tr><td><code id="dataset_+3A_machinetagnamespace">machineTagNamespace</code></td>
<td>
<p>Filters for entities with a machine tag in the
specified namespace.</p>
</td></tr>
<tr><td><code id="dataset_+3A_machinetagname">machineTagName</code></td>
<td>
<p>Filters for entities with a machine tag with the
specified name (use in combination with the machineTagNamespace parameter).</p>
</td></tr>
<tr><td><code id="dataset_+3A_machinetagvalue">machineTagValue</code></td>
<td>
<p>Filters for entities with a machine tag with the
specified value (use in combination with the machineTagNamespace and machineTagName parameters).</p>
</td></tr>
<tr><td><code id="dataset_+3A_modified">modified</code></td>
<td>
<p>The modified date of the dataset. Accepts ranges and a &rdquo;
can be used as a wildcard, e.g.:modified=2023-04-01,</p>
</td></tr>
<tr><td><code id="dataset_+3A_query">query</code></td>
<td>
<p>Simple full text search parameter. The value for this parameter
can be a simple word or a phrase. Wildcards are not supported.</p>
</td></tr>
<tr><td><code id="dataset_+3A_deleted">deleted</code></td>
<td>
<p>Logical specifying whether to return only deleted datasets.</p>
</td></tr>
<tr><td><code id="dataset_+3A_limit">limit</code></td>
<td>
<p>Controls the number of results in the page.</p>
</td></tr>
<tr><td><code id="dataset_+3A_start">start</code></td>
<td>
<p>Determines the start for the search results.</p>
</td></tr>
<tr><td><code id="dataset_+3A_curlopts">curlopts</code></td>
<td>
<p>options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows you to search for some more obscure dataset metadata
that might not be possible with <code>dataset_search()</code>. For example, searching
through registry machinetags.
</p>


<h3>Value</h3>

<p>A <code>list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset(limit=3)
dataset(country="US",limit=3)
dataset(type="CHECKLIST",limit=3)
dataset(identifierType = "URL",limit=3)
dataset(identifier = 168,limit=3)
dataset(machineTagNamespace = "metasync.gbif.org",limit=3)
dataset(machineTagName = "datasetTitle",limit=3)
dataset(machineTagValue = "Borkhart",limit=3)
dataset(modified = "2023-04-01", limit=3) 
dataset(q = "dog", limit=3) 
dataset(deleted=TRUE,limit=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='dataset_doi'>Get a GBIF dataset from a doi</h2><span id='topic+dataset_doi'></span>

<h3>Description</h3>

<p>Get a GBIF dataset from a doi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_doi(doi = NULL, limit = 20, start = NULL, curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataset_doi_+3A_doi">doi</code></td>
<td>
<p>the doi of the dataset you wish to lookup.</p>
</td></tr>
<tr><td><code id="dataset_doi_+3A_limit">limit</code></td>
<td>
<p>Controls the number of results in the page.</p>
</td></tr>
<tr><td><code id="dataset_doi_+3A_start">start</code></td>
<td>
<p>Determines the offset for the search results.</p>
</td></tr>
<tr><td><code id="dataset_doi_+3A_curlopts">curlopts</code></td>
<td>
<p>options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for dataset lookup using a doi. Be aware that
some doi have more than one dataset associated with them.
</p>


<h3>Value</h3>

<p>A <code>list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset_doi('10.15468/igasai')

## End(Not run)
</code></pre>

<hr>
<h2 id='dataset_gridded'>Check if a dataset is gridded</h2><span id='topic+dataset_gridded'></span>

<h3>Description</h3>

<p>Check if a dataset is gridded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_gridded(
  uuid = NULL,
  min_dis = 0.05,
  min_per = 50,
  min_dis_count = 30,
  return = "logical",
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataset_gridded_+3A_uuid">uuid</code></td>
<td>
<p>(vector) A character vector of GBIF datasetkey uuids.</p>
</td></tr>
<tr><td><code id="dataset_gridded_+3A_min_dis">min_dis</code></td>
<td>
<p>(numeric) (default 0.02) Minimum distance in degrees to accept
as gridded.</p>
</td></tr>
<tr><td><code id="dataset_gridded_+3A_min_per">min_per</code></td>
<td>
<p>(integer)(default 50%) Minimum percentage of points having same nearest
neighbor distance to be considered gridded.</p>
</td></tr>
<tr><td><code id="dataset_gridded_+3A_min_dis_count">min_dis_count</code></td>
<td>
<p>(default 30) Minimum number of unique points to accept
an assessment of 'griddyness'.</p>
</td></tr>
<tr><td><code id="dataset_gridded_+3A_return">return</code></td>
<td>
<p>(character) (default &quot;logical&quot;). Choice of &quot;data&quot; will return
a data.frame of more information or &quot;logical&quot; will return just TRUE or FALSE
indicating whether a dataset is considered 'gridded&quot;.</p>
</td></tr>
<tr><td><code id="dataset_gridded_+3A_warn">warn</code></td>
<td>
<p>(logical) indicates whether to warn about missing values or bad
values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gridded datasets are a known problem at GBIF. Many datasets have
equally-spaced points in a regular pattern. These datasets are usually
systematic national surveys or data taken from some atlas
(“so-called rasterized collection designs”). This function uses the
percentage of unique lat-long points with the most common nearest
neighbor distance to identify gridded datasets.
</p>
<p><a href="https://data-blog.gbif.org/post/finding-gridded-datasets/">https://data-blog.gbif.org/post/finding-gridded-datasets/</a>
</p>
<p>I recommend keeping the default values for the parameters.
</p>


<h3>Value</h3>

<p>A logical <code>vector</code> indicating whether a dataset is considered gridded.
Or if <code>return="data"</code>, a <code>data.frame</code> of more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

dataset_gridded("9070a460-0c6e-11dd-84d2-b8a03c50a862")
dataset_gridded(c("9070a460-0c6e-11dd-84d2-b8a03c50a862",
               "13b70480-bd69-11dd-b15f-b8a03c50a862"))



## End(Not run)

</code></pre>

<hr>
<h2 id='dataset_list_funs'>List datasets that are deleted or have no endpoint.</h2><span id='topic+dataset_list_funs'></span><span id='topic+dataset_duplicate'></span><span id='topic+dataset_noendpoint'></span>

<h3>Description</h3>

<p>List datasets that are deleted or have no endpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_duplicate(limit = 20, start = NULL, curlopts = list())

dataset_noendpoint(limit = 20, start = NULL, curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataset_list_funs_+3A_limit">limit</code></td>
<td>
<p>Controls the number of results in the page.</p>
</td></tr>
<tr><td><code id="dataset_list_funs_+3A_start">start</code></td>
<td>
<p>Determines the start for the search results.</p>
</td></tr>
<tr><td><code id="dataset_list_funs_+3A_curlopts">curlopts</code></td>
<td>
<p>options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get a list of deleted datasets or datasets with no endpoint. You get the full
and no parameters aside from <code>limit</code> and <code>start</code> are accepted.
</p>


<h3>Value</h3>

<p>A <code>list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset_noendpoint(limit=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='dataset_search'>Search for dataset metadata.</h2><span id='topic+dataset_search'></span><span id='topic+dataset_export'></span><span id='topic+dataset_suggest'></span>

<h3>Description</h3>

<p>Search for dataset metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_export(
  query = NULL,
  type = NULL,
  publishingCountry = NULL,
  subtype = NULL,
  license = NULL,
  keyword = NULL,
  publishingOrg = NULL,
  hostingOrg = NULL,
  endorsingNodeKey = NULL,
  decade = NULL,
  projectId = NULL,
  hostingCountry = NULL,
  networkKey = NULL,
  doi = NULL
)

dataset_search(
  query = NULL,
  type = NULL,
  publishingCountry = NULL,
  subtype = NULL,
  license = NULL,
  keyword = NULL,
  publishingOrg = NULL,
  hostingOrg = NULL,
  endorsingNodeKey = NULL,
  decade = NULL,
  projectId = NULL,
  hostingCountry = NULL,
  networkKey = NULL,
  doi = NULL,
  facet = NULL,
  facetLimit = NULL,
  facetOffset = NULL,
  facetMincount = NULL,
  facetMultiselect = NULL,
  limit = 100,
  start = NULL,
  description = FALSE,
  curlopts = list()
)

dataset_suggest(
  query = NULL,
  type = NULL,
  publishingCountry = NULL,
  subtype = NULL,
  license = NULL,
  keyword = NULL,
  publishingOrg = NULL,
  hostingOrg = NULL,
  endorsingNodeKey = NULL,
  decade = NULL,
  projectId = NULL,
  hostingCountry = NULL,
  networkKey = NULL,
  doi = NULL,
  limit = 100,
  start = NULL,
  description = FALSE,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataset_search_+3A_query">query</code></td>
<td>
<p>Simple full text search parameter. The value for this parameter
can be a simple word or a phrase. Wildcards are not supported.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_type">type</code></td>
<td>
<p>The primary type of the dataset. Available values: &quot;OCCURRENCE&quot;,
&quot;CHECKLIST&quot;, &quot;METADATA&quot;, &quot;SAMPLING_EVENT&quot;, &quot;MATERIAL_ENTITY&quot;.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_publishingcountry">publishingCountry</code></td>
<td>
<p>Filters datasets by their owning organization's
country given as a ISO 639-1 (2 letter) country code.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_subtype">subtype</code></td>
<td>
<p>The sub-type of the dataset.The sub-type of the dataset.
Available values: &quot;TAXONOMIC_AUTHORITY&quot;, &quot;NOMENCLATOR_AUTHORITY&quot;,
&quot;INVENTORY_THEMATIC&quot;, &quot;INVENTORY_REGIONAL&quot;, &quot;GLOBAL_SPECIES_DATASET&quot;,
&quot;DERIVED_FROM_OCCURRENCE&quot;, &quot;SPECIMEN&quot;, &quot;OBSERVATION&quot;.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_license">license</code></td>
<td>
<p>The dataset's licence. Available values: &quot;CC0_1_0&quot;,
&quot;CC_BY_4_0&quot;, &quot;CC_BY_NC_4_0&quot;, &quot;UNSPECIFIED&quot;, &quot;UNSUPPORTED&quot;.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_keyword">keyword</code></td>
<td>
<p>Filters datasets by a case insensitive plain text keyword.
The search is done on the merged collection of tags, the dataset
keywordCollections and temporalCoverages.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_publishingorg">publishingOrg</code></td>
<td>
<p>Filters datasets by their publishing organization
UUID key.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_hostingorg">hostingOrg</code></td>
<td>
<p>Filters datasets by their hosting organization UUID key</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_endorsingnodekey">endorsingNodeKey</code></td>
<td>
<p>Node UUID key that endorsed this dataset's publisher.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_decade">decade</code></td>
<td>
<p>Filters datasets by their temporal coverage broken down to
decades. Decades are given as a full year, e.g. 1880, 1960, 2000, etc, and
will return datasets wholly contained in the decade as well as those that
cover the entire decade or more. Ranges can be used like this &quot;1800,1900&quot;.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_projectid">projectId</code></td>
<td>
<p>Filter or facet based on the project ID of a given dataset.
A dataset can have a project id if it is the result of a project.
Multiple datasets can have the same project id.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_hostingcountry">hostingCountry</code></td>
<td>
<p>Filters datasets by their hosting organization's
country given as a ISO 639-1 (2 letter) country code.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_networkkey">networkKey</code></td>
<td>
<p>Filters network UUID associated to a dataset.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_doi">doi</code></td>
<td>
<p>DOI of the dataset.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_facet">facet</code></td>
<td>
<p>A facet name used to retrieve the most frequent values for a field.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_facetlimit">facetLimit</code></td>
<td>
<p>Facet parameters allow paging requests using the parameters
facetOffset and facetLimit.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_facetoffset">facetOffset</code></td>
<td>
<p>Facet parameters allow paging requests using the
parameters facetOffset and facetLimit</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_facetmincount">facetMincount</code></td>
<td>
<p>Used in combination with the facet parameter.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_facetmultiselect">facetMultiselect</code></td>
<td>
<p>Used in combination with the facet parameter.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_limit">limit</code></td>
<td>
<p>Controls the number of results in the page. Using too high a
value will be overwritten with the default maximum threshold, depending on
the service. Sensible defaults are used so this may be omitted.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_start">start</code></td>
<td>
<p>Determines the offset for the search results. A limit of 20
and offset of 40 will get the third page of 20 results. Some services have
a maximum offset.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_description">description</code></td>
<td>
<p>Logical whether to return descriptions.</p>
</td></tr>
<tr><td><code id="dataset_search_+3A_curlopts">curlopts</code></td>
<td>
<p>options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dataset_search()</code> searches and returns metadata on GBIF datasets from the
registry. This function does not search occurrence data, only metadata on
the datasets that contain may contain occurrence data. It also searches over
other dataset types, such checklist and metadata datasets. Only a sample of
results is returned.
</p>
<p><code>dataset_export()</code>  function will download a <code>tibble</code> of the results of a
<code>dataset_search()</code>. This function is primarily useful if you want the full results of a
<code>dataset_search()</code>.
</p>
<p>Use <code>dataset_search(facet="x",limit=0)$facets</code> to get simple group by counts
for different parameters.
</p>


<h3>Value</h3>

<p>A <code>list</code> for <code>dataset_search()</code>. A <code>tibble</code> for <code>dataset_export()</code>.
</p>


<h3>References</h3>

<p>https://techdocs.gbif.org/en/openapi/v1/registry#/Datasets/searchDatasets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# search metadata on all datasets and return a sample
dataset_search()
# dataset_export() # download info on all +90K datasets 

dataset_search(publishingCountry = "US")
dataset_search(type = "OCCURRENCE") 
dataset_search(keyword = "bird")
dataset_search(subtype = "TAXONOMIC_AUTHORITY") 
dataset_search(license = "CC0_1_0") 
dataset_search(query = "frog") 
dataset_search(publishingCountry = "UA") 
dataset_search(publishingOrg = "e2e717bf-551a-4917-bdc9-4fa0f342c530") 
dataset_search(hostingOrg = "7ce8aef0-9e92-11dc-8738-b8a03c50a862") 
dataset_search(decade="1890,1990",limit=5)
dataset_search(projectId = "GRIIS") 
dataset_search(hostingCountry = "NO") 
dataset_search(networkKey = "99d66b6c-9087-452f-a9d4-f15f2c2d0e7e") 
dataset_search(doi='10.15468/aomfnb') 

# search multiple values 
dataset_search(projectId = "GRIIS;BID-AF2020-140-REG") 
dataset_search(hostingCountry = "NO;SE")
dataset_search(doi="10.15468/aomfnb;10.15468/igasai")

# multiple filters
dataset_search(license = "CC0_1_0",subtype = "TAXONOMIC_AUTHORITY")
# dataset_export(license = "CC0_1_0",subtype = "TAXONOMIC_AUTHORITY")

# using dataset export to get all datasets 
dataset_export(decade="1800,1900")
dataset_export(projectId="GRIIS")

# get simple group by counts 
dataset_search(facet="type",limit=0,facetLimit=5)$facets 
dataset_search(facet="publishingCountry",limit=0,facetLimit=5)$facets
dataset_search(facet="license",limit=0,facetLimit=5, facetMincount=10000)


## End(Not run)
</code></pre>

<hr>
<h2 id='dataset_uuid_funs'>Get dataset metadata using a datasetkey</h2><span id='topic+dataset_uuid_funs'></span><span id='topic+dataset_get'></span><span id='topic+dataset_process'></span><span id='topic+dataset_networks'></span><span id='topic+dataset_constituents'></span><span id='topic+dataset_comment'></span><span id='topic+dataset_contact'></span><span id='topic+dataset_endpoint'></span><span id='topic+dataset_identifier'></span><span id='topic+dataset_machinetag'></span><span id='topic+dataset_tag'></span><span id='topic+dataset_metrics'></span>

<h3>Description</h3>

<p>Get dataset metadata using a datasetkey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_get(uuid = NULL, curlopts = list())

dataset_process(uuid = NULL, limit = 20, start = NULL, curlopts = list())

dataset_networks(uuid = NULL, limit = 20, start = NULL, curlopts = list())

dataset_constituents(uuid = NULL, limit = 20, start = NULL, curlopts = list())

dataset_comment(uuid = NULL, curlopts = list())

dataset_contact(uuid = NULL, curlopts = list())

dataset_endpoint(uuid = NULL, curlopts = list())

dataset_identifier(uuid = NULL, curlopts = list())

dataset_machinetag(uuid = NULL, curlopts = list())

dataset_tag(uuid = NULL, curlopts = list())

dataset_metrics(uuid = NULL, curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dataset_uuid_funs_+3A_uuid">uuid</code></td>
<td>
<p>A GBIF datasetkey uuid.</p>
</td></tr>
<tr><td><code id="dataset_uuid_funs_+3A_curlopts">curlopts</code></td>
<td>
<p>options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a>.</p>
</td></tr>
<tr><td><code id="dataset_uuid_funs_+3A_limit">limit</code></td>
<td>
<p>Number of records to return.</p>
</td></tr>
<tr><td><code id="dataset_uuid_funs_+3A_start">start</code></td>
<td>
<p>Record number to start at.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dataset_metrics()</code> can only be used with checklist type datasets.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> or a <code>list</code>.
</p>


<h3>References</h3>

<p><a href="https://techdocs.gbif.org/en/openapi/v1/registry">https://techdocs.gbif.org/en/openapi/v1/registry</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dataset_get("38b4c89f-584c-41bb-bd8f-cd1def33e92f")
dataset_process("38b4c89f-584c-41bb-bd8f-cd1def33e92f",limit=3)
dataset_networks("3dab037f-a520-4bc3-b888-508755c2eb52")
dataset_constituents("7ddf754f-d193-4cc9-b351-99906754a03b",limit=3)
dataset_comment("2e4cc37b-302e-4f1b-bbbb-1f674ff90e14")
dataset_contact("7ddf754f-d193-4cc9-b351-99906754a03b")
dataset_endpoint("7ddf754f-d193-4cc9-b351-99906754a03b")
dataset_identifier("7ddf754f-d193-4cc9-b351-99906754a03b")
dataset_machinetag("7ddf754f-d193-4cc9-b351-99906754a03b")
dataset_tag("c47f13c1-7427-45a0-9f12-237aad351040")
dataset_metrics("7ddf754f-d193-4cc9-b351-99906754a03b")

## End(Not run)
</code></pre>

<hr>
<h2 id='datasets'>Search for datasets and dataset metadata.</h2><span id='topic+datasets'></span>

<h3>Description</h3>

<p>Search for datasets and dataset metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasets(
  data = "all",
  type = NULL,
  uuid = NULL,
  query = NULL,
  id = NULL,
  limit = 100,
  start = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="datasets_+3A_data">data</code></td>
<td>
<p>The type of data to get. One or more of: 'organization',
'contact', 'endpoint', 'identifier', 'tag', 'machinetag', 'comment',
'constituents', 'document', 'metadata', 'deleted', 'duplicate',
'subDataset', 'withNoEndpoint', or the special 'all'. Default: <code>all</code></p>
</td></tr>
<tr><td><code id="datasets_+3A_type">type</code></td>
<td>
<p>Type of dataset. Options: include occurrence, checklist,
metadata, or sampling_event.</p>
</td></tr>
<tr><td><code id="datasets_+3A_uuid">uuid</code></td>
<td>
<p>UUID of the data node provider. This must be specified if data
is anything other than <code>all</code></p>
</td></tr>
<tr><td><code id="datasets_+3A_query">query</code></td>
<td>
<p>Query term(s). Only used when <code>data=all</code></p>
</td></tr>
<tr><td><code id="datasets_+3A_id">id</code></td>
<td>
<p>A metadata document id.</p>
</td></tr>
<tr><td><code id="datasets_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100. Maximum: 1000.</p>
</td></tr>
<tr><td><code id="datasets_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0. Use in combination
with <code>limit</code> to page through results.</p>
</td></tr>
<tr><td><code id="datasets_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>References</h3>

<p><a href="https://www.gbif.org/developer/registry#datasets">https://www.gbif.org/developer/registry#datasets</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
datasets(limit=5)
datasets(type="occurrence", limit=10)
datasets(uuid="a6998220-7e3a-485d-9cd6-73076bd85657")
datasets(data='contact', uuid="a6998220-7e3a-485d-9cd6-73076bd85657")
datasets(data='metadata', uuid="a6998220-7e3a-485d-9cd6-73076bd85657")
datasets(data='metadata', uuid="a6998220-7e3a-485d-9cd6-73076bd85657",
  id=598)
datasets(data=c('deleted','duplicate'))
datasets(data=c('deleted','duplicate'), limit=1)

# curl options
datasets(data=c('deleted','duplicate'), curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='density_spplist'>The density web service provides access to records showing the density
of occurrence records from the GBIF Network by one-degree cell.</h2><span id='topic+density_spplist'></span>

<h3>Description</h3>

<p>This function is defunct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_spplist(...)
</code></pre>

<hr>
<h2 id='densitylist'>The density web service provides access to records showing the density
of occurrence records from the GBIF Network by one-degree cell.</h2><span id='topic+densitylist'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densitylist(...)
</code></pre>

<hr>
<h2 id='derived_dataset'>Register a derived dataset for citation.</h2><span id='topic+derived_dataset'></span><span id='topic+derived_dataset_prep'></span>

<h3>Description</h3>

<p>Register a derived dataset for citation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derived_dataset(
  citation_data = NULL,
  title = NULL,
  description = NULL,
  source_url = NULL,
  gbif_download_doi = NULL,
  user = NULL,
  pwd = NULL,
  curlopts = list()
)

derived_dataset_prep(
  citation_data = NULL,
  title = NULL,
  description = NULL,
  source_url = NULL,
  gbif_download_doi = NULL,
  user = NULL,
  pwd = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derived_dataset_+3A_citation_data">citation_data</code></td>
<td>
<p>(required) A data.frame with <strong>two columns</strong>. The first
column should be GBIF <strong>datasetkey uuids</strong> and the second column should be
<strong>occurrence counts</strong> from each of your datasets, representing the
contribution of each dataset to your final derived dataset.</p>
</td></tr>
<tr><td><code id="derived_dataset_+3A_title">title</code></td>
<td>
<p>(required) The title for your derived dataset.</p>
</td></tr>
<tr><td><code id="derived_dataset_+3A_description">description</code></td>
<td>
<p>(required) A description of the dataset. Perhaps
describing how it was created.</p>
</td></tr>
<tr><td><code id="derived_dataset_+3A_source_url">source_url</code></td>
<td>
<p>(required) A link to where the dataset is stored.</p>
</td></tr>
<tr><td><code id="derived_dataset_+3A_gbif_download_doi">gbif_download_doi</code></td>
<td>
<p>(optional) A DOI from an original GBIF download.</p>
</td></tr>
<tr><td><code id="derived_dataset_+3A_user">user</code></td>
<td>
<p>(required) Your GBIF username.</p>
</td></tr>
<tr><td><code id="derived_dataset_+3A_pwd">pwd</code></td>
<td>
<p>(required) Your GBIF password.</p>
</td></tr>
<tr><td><code id="derived_dataset_+3A_curlopts">curlopts</code></td>
<td>
<p>a list of arguments to pass to curl.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Usage</h3>

<p>Create a <strong>citable DOI</strong> for a dataset derived from GBIF mediated
occurrences.
</p>
<p><strong>Use-case (1)</strong> your dataset was obtained with <code>occ_search()</code> and
never returned a <strong>citable DOI</strong>, but you want to cite the data in a
research paper.
</p>
<p><strong>Use-case (2)</strong> your dataset was obtained using <code>occ_download()</code> and you
got a DOI, but the data underwent extensive filtering using
<code>CoordinateCleaner</code> or some other cleaning pipeline. In this case be sure
to fill in your original <code>gbif_download_doi</code>.
</p>
<p><strong>Use-case (3)</strong> your dataset was generated using a GBIF cloud export but
you want a DOI to cite in your research paper.
</p>
<p>Use <code>derived_dataset</code> to create a custom citable meta-data description and
most importantly a DOI link between an external archive (e.g. Zenodo) and the
datasets involved in your research or analysis.
</p>
<p>All fields (except <code>gbif_download_doi</code>) are required for the registration to
work.
</p>
<p>We recommend that you run <code>derived_dataset_prep()</code> to check registration
details before making it final with <code>derived_dataset()</code>.
</p>


<h3>Authentication</h3>

<p>Some <code>rgbif</code> functions require your <strong>GBIF credentials</strong>.
</p>
<p>For the <code>user</code> and <code>pwd</code> parameters, you can set them in one of
three ways:
</p>

<ol>
<li><p> Set them in your <code>.Renviron</code>/<code>.bash_profile</code> (or similar) file with the
names <code>GBIF_USER</code>, <code>GBIF_PWD</code>, and <code>GBIF_EMAIL</code>
</p>
</li>
<li><p> Set them in your <code>.Rprofile</code> file with the names <code>gbif_user</code> and
<code>gbif_pwd</code>.
</p>
</li>
<li><p> Simply pass strings to each of the parameters in the function
call.
</p>
</li></ol>

<p>We strongly recommend the <strong>first option</strong> - storing your details as
environment variables - as it's the most widely used way to store secrets.
</p>
<p>You can edit your <code>.Renviron</code> with <code>usethis::edit_r_environ()</code>.
</p>
<p>After editing, your <code>.Renviron</code> file should look something like this...
</p>
<p>GBIF_USER=&quot;jwaller&quot;<br />
GBIF_PWD=&quot;fakepassword123&quot;<br />
GBIF_EMAIL=&quot;jwaller@gbif.org&quot;<br />
</p>
<p>See <code>?Startup</code> for help.
</p>


<h3>References</h3>

<p><a href="https://data-blog.gbif.org/post/derived-datasets/">https://data-blog.gbif.org/post/derived-datasets/</a>
<a href="https://www.gbif.org/derived-dataset/about">https://www.gbif.org/derived-dataset/about</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- data.frame(
 datasetKey = c(
 "3ea36590-9b79-46a8-9300-c9ef0bfed7b8",
 "630eb55d-5169-4473-99d6-a93396aeae38",
 "806bf7d4-f762-11e1-a439-00145eb45e9a"),
 count = c(3, 1, 2781)
 )

## If output looks ok, run derived_dataset to register the dataset
 derived_dataset_prep(
 citation_data = data,
 title = "Test for derived dataset",
 description = "This data was filtered using a fake protocol",
 source_url = "https://zenodo.org/record/4246090#.YPGS2OgzZPY"
 )

#  derived_dataset(
#  citation_data = data,
#  title = "Test for derived dataset",
#  description = "This data was filtered using a fake protocol",
#  source_url = "https://zenodo.org/record/4246090#.YPGS2OgzZPY"
#  )

## Example with occ_search and dplyr
# library(dplyr)

# citation_data &lt;- occ_search(taxonKey=212, limit=20)$data %&gt;%
#   group_by(datasetKey) %&gt;% 
#   count()

# # You would still need to upload your data to Zenodo or something similar 
# derived_dataset_prep(
#   citation_data = citation_data,
#   title="Bird data downloaded for test",
#   description="This data was downloaded using rgbif::occ_search and was 
#   later uploaded to Zenodo.",
#   source_url="https://zenodo.org/record/4246090#.YPGS2OgzZPY",
#   gbif_download_doi = NULL,
# )

## End(Not run)

</code></pre>

<hr>
<h2 id='download_predicate_dsl'>Download predicate DSL (domain specific language)</h2><span id='topic+download_predicate_dsl'></span><span id='topic+pred'></span><span id='topic+pred_gt'></span><span id='topic+pred_gte'></span><span id='topic+pred_lt'></span><span id='topic+pred_lte'></span><span id='topic+pred_not'></span><span id='topic+pred_like'></span><span id='topic+pred_within'></span><span id='topic+pred_isnull'></span><span id='topic+pred_notnull'></span><span id='topic+pred_or'></span><span id='topic+pred_and'></span><span id='topic+pred_in'></span><span id='topic+pred_default'></span>

<h3>Description</h3>

<p>Download predicate DSL (domain specific language)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred(key, value)

pred_gt(key, value)

pred_gte(key, value)

pred_lt(key, value)

pred_lte(key, value)

pred_not(...)

pred_like(key, value)

pred_within(value)

pred_isnull(key)

pred_notnull(key)

pred_or(..., .list = list())

pred_and(..., .list = list())

pred_in(key, value)

pred_default()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="download_predicate_dsl_+3A_key">key</code></td>
<td>
<p>(character) the key for the predicate. See &quot;Keys&quot; below</p>
</td></tr>
<tr><td><code id="download_predicate_dsl_+3A_value">value</code></td>
<td>
<p>(various) the value for the predicate</p>
</td></tr>
<tr><td><code id="download_predicate_dsl_+3A_...">...</code>, <code id="download_predicate_dsl_+3A_.list">.list</code></td>
<td>
<p>For <code>pred_or()</code> or <code>pred_and()</code>, one or more objects of
class <code>occ_predicate</code>, created by any <code style="white-space: pre;">&#8288;pred*&#8288;</code> function</p>
</td></tr>
</table>


<h3>predicate methods and their equivalent types</h3>

<p><code style="white-space: pre;">&#8288;pred*&#8288;</code> functions are named for the 'type' of operation they do, following
the terminology used by GBIF, see
https://www.gbif.org/developer/occurrence#predicates
</p>
<p>Function names are given, with the equivalent GBIF type value (e.g.,
<code>pred_gt</code> and <code>greaterThan</code>)
</p>
<p>The following functions take one key and one value:
</p>

<ul>
<li> <p><code>pred</code>: equals
</p>
</li>
<li> <p><code>pred_lt</code>: lessThan
</p>
</li>
<li> <p><code>pred_lte</code>: lessThanOrEquals
</p>
</li>
<li> <p><code>pred_gt</code>: greaterThan
</p>
</li>
<li> <p><code>pred_gte</code>: greaterThanOrEquals
</p>
</li>
<li> <p><code>pred_like</code>: like
</p>
</li></ul>

<p>The following function is only for geospatial queries, and only
accepts a WKT string:
</p>

<ul>
<li> <p><code>pred_within</code>: within
</p>
</li></ul>

<p>The following function is only for stating the you don't want
a key to be null, so only accepts one key:
</p>

<ul>
<li> <p><code>pred_notnull</code>: isNotNull
</p>
</li></ul>

<p>The following function is only for stating that you want a key to be null.
</p>

<ul>
<li> <p><code>pred_isnull</code> : isNull
</p>
</li></ul>

<p>The following two functions accept multiple individual predicates,
separating them by either &quot;and&quot; or &quot;or&quot;:
</p>

<ul>
<li> <p><code>pred_and</code>: and
</p>
</li>
<li> <p><code>pred_or</code>: or
</p>
</li></ul>

<p>The not predicate accepts one predicate; that is, this negates whatever
predicate is passed in, e.g., not the taxonKey of 12345:
</p>

<ul>
<li> <p><code>pred_not</code>: not
</p>
</li></ul>

<p>The following function is special in that it accepts a single key
but many values; stating that you want to search for all the values:
</p>

<ul>
<li> <p><code>pred_in</code>: in
</p>
</li></ul>

<p>The following function will apply commonly used <strong>defaults</strong>.
</p>

<ul>
<li> <p><code>pred_default</code>
</p>
</li></ul>

<p>Using <code>pred_default()</code> is equivalent to running:
</p>
<div class="sourceCode"><pre>  pred_and(
   pred("HAS_GEOSPATIAL_ISSUE",FALSE),
   pred("HAS_COORDINATE",TRUE),
   pred("OCCURRENCE_STATUS","PRESENT"),
   pred_not(pred_in("BASIS_OF_RECORD",
    c("FOSSIL_SPECIMEN","LIVING_SPECIMEN")))
  )
</pre></div>


<h3>What happens internally</h3>

<p>Internally, the input to <code style="white-space: pre;">&#8288;pred*&#8288;</code> functions turns into JSON to be sent to
GBIF. For example ...
</p>
<p><code>pred_in("taxonKey", c(2480946, 5229208))</code> gives:
</p>
<div class="sourceCode"><pre>{
   "type": "in",
   "key": "TAXON_KEY",
   "values": ["2480946", "5229208"]
 }
</pre></div>
<p><code>pred_gt("elevation", 5000)</code> gives:
</p>
<div class="sourceCode"><pre>{
   "type": "greaterThan",
   "key": "ELEVATION",
   "value": "5000"
}
</pre></div>
<p><code>pred_or(pred("taxonKey", 2977832), pred("taxonKey", 2977901))</code> gives:
</p>
<div class="sourceCode"><pre>{
  "type": "or",
  "predicates": [
     {
       "type": "equals",
       "key": "TAXON_KEY",
       "value": "2977832"
     },
     {
       "type": "equals",
       "key": "TAXON_KEY",
       "value": "2977901"
     }
  ]
}
</pre></div>


<h3>Keys</h3>

<p>Acceptable arguments to the <code>key</code> parameter are (with the version of
the key in parens that must be sent if you pass the query via the <code>body</code>
parameter; see below for examples). You can also use the 'ALL_CAPS' version
of a key if you prefer. Open an issue in the GitHub
repository for this package if you know of a key that should
be supported that is not yet.
</p>

<ul>
<li><p> taxonKey (TAXON_KEY)
</p>
</li>
<li><p> acceptedTaxonKey (ACCEPTED_TAXON_KEY)
</p>
</li>
<li><p> kingdomKey (KINGDOM_KEY)
</p>
</li>
<li><p> phylumKey (PHYLUM_KEY)
</p>
</li>
<li><p> classKey (CLASS_KEY)
</p>
</li>
<li><p> orderKey (ORDER_KEY)
</p>
</li>
<li><p> familyKey (FAMILY_KEY)
</p>
</li>
<li><p> genusKey (GENUS_KEY)
</p>
</li>
<li><p> subgenusKey (SUBGENUS_KEY)
</p>
</li>
<li><p> speciesKey (SPECIES_KEY)
</p>
</li>
<li><p> scientificName (SCIENTIFIC_NAME)
</p>
</li>
<li><p> country (COUNTRY)
</p>
</li>
<li><p> publishingCountry (PUBLISHING_COUNTRY)
</p>
</li>
<li><p> hasCoordinate (HAS_COORDINATE)
</p>
</li>
<li><p> hasGeospatialIssue (HAS_GEOSPATIAL_ISSUE)
</p>
</li>
<li><p> typeStatus (TYPE_STATUS)
</p>
</li>
<li><p> recordNumber (RECORD_NUMBER)
</p>
</li>
<li><p> lastInterpreted (LAST_INTERPRETED)
</p>
</li>
<li><p> modified (MODIFIED)
</p>
</li>
<li><p> continent (CONTINENT)
</p>
</li>
<li><p> geometry (GEOMETRY)
</p>
</li>
<li><p> basisOfRecord (BASIS_OF_RECORD)
</p>
</li>
<li><p> datasetKey (DATASET_KEY)
</p>
</li>
<li><p> datasetID/datasetId (DATASET_ID)
</p>
</li>
<li><p> eventDate (EVENT_DATE)
</p>
</li>
<li><p> catalogNumber (CATALOG_NUMBER)
</p>
</li>
<li><p> otherCatalogNumbers (OTHER_CATALOG_NUMBERS)
</p>
</li>
<li><p> year (YEAR)
</p>
</li>
<li><p> month (MONTH)
</p>
</li>
<li><p> decimalLatitude (DECIMAL_LATITUDE)
</p>
</li>
<li><p> decimalLongitude (DECIMAL_LONGITUDE)
</p>
</li>
<li><p> elevation (ELEVATION)
</p>
</li>
<li><p> depth (DEPTH)
</p>
</li>
<li><p> institutionCode (INSTITUTION_CODE)
</p>
</li>
<li><p> collectionCode (COLLECTION_CODE)
</p>
</li>
<li><p> issue (ISSUE)
</p>
</li>
<li><p> mediatype (MEDIA_TYPE)
</p>
</li>
<li><p> recordedBy (RECORDED_BY)
</p>
</li>
<li><p> recordedById/recordedByID (RECORDED_BY_ID)
</p>
</li>
<li><p> establishmentMeans (ESTABLISHMENT_MEANS)
</p>
</li>
<li><p> coordinateUncertaintyInMeters (COORDINATE_UNCERTAINTY_IN_METERS)
</p>
</li>
<li><p> gadm (GADM_GID) (for the Database of Global Administrative Areas)
</p>
</li>
<li><p> level0Gid (GADM_LEVEL_0_GID)
</p>
</li>
<li><p> level1Gid (GADM_LEVEL_1_GID)
</p>
</li>
<li><p> level2Gid (GADM_LEVEL_2_GID)
</p>
</li>
<li><p> level3Gid (GADM_LEVEL_3_GID)
</p>
</li>
<li><p> stateProvince (STATE_PROVINCE)
</p>
</li>
<li><p> occurrenceStatus (OCCURRENCE_STATUS)
</p>
</li>
<li><p> publishingOrg (PUBLISHING_ORG)
</p>
</li>
<li><p> occurrenceId/occurrenceID (OCCURRENCE_ID)
</p>
</li>
<li><p> eventId/eventID (EVENT_ID)
</p>
</li>
<li><p> parentEventId/parentEventID (PARENT_EVENT_ID)
</p>
</li>
<li><p> identifiedBy (IDENTIFIED_BY)
</p>
</li>
<li><p> identifiedById/identifiedByID (IDENTIFIED_BY_ID)
</p>
</li>
<li><p> license (LICENSE)
</p>
</li>
<li><p> locality(LOCALITY)
</p>
</li>
<li><p> pathway (PATHWAY)
</p>
</li>
<li><p> preparations (PREPARATIONS)
</p>
</li>
<li><p> networkKey (NETWORK_KEY)
</p>
</li>
<li><p> organismId/organismID (ORGANISM_ID)
</p>
</li>
<li><p> organismQuantity (ORGANISM_QUANTITY)
</p>
</li>
<li><p> organismQuantityType (ORGANISM_QUANTITY_TYPE)
</p>
</li>
<li><p> protocol (PROTOCOL)
</p>
</li>
<li><p> relativeOrganismQuantity (RELATIVE_ORGANISM_QUANTITY)
</p>
</li>
<li><p> repatriated (REPATRIATED)
</p>
</li>
<li><p> sampleSizeUnit (SAMPLE_SIZE_UNIT)
</p>
</li>
<li><p> sampleSizeValue (SAMPLE_SIZE_VALUE)
</p>
</li>
<li><p> samplingProtocol (SAMPLING_PROTOCOL)
</p>
</li>
<li><p> verbatimScientificName (VERBATIM_SCIENTIFIC_NAME)
</p>
</li>
<li><p> taxonID/taxonId (TAXON_ID)
</p>
</li>
<li><p> taxonomicStatus (TAXONOMIC_STATUS)
</p>
</li>
<li><p> waterBody (WATER_BODY)
</p>
</li>
<li><p> iucnRedListCategory (IUCN_RED_LIST_CATEGORY)
</p>
</li>
<li><p> degreeOfEstablishment (DEGREE_OF_ESTABLISHMENT)
</p>
</li>
<li><p> isInCluster (IS_IN_CLUSTER)
</p>
</li>
<li><p> lifeStage (LIFE_STAGE)
</p>
</li>
<li><p> distanceFromCentroidInMeters (DISTANCE_FROM_CENTROID_IN_METERS)
</p>
</li>
<li><p> gbifId (GBIF_ID)
</p>
</li></ul>



<h3>References</h3>

<p>Download predicates docs:
<a href="https://www.gbif.org/developer/occurrence#predicates">https://www.gbif.org/developer/occurrence#predicates</a>
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pred("taxonKey", 3119195)
pred_gt("elevation", 5000)
pred_gte("elevation", 5000)
pred_lt("elevation", 1000)
pred_lte("elevation", 1000)
pred_within("POLYGON((-14 42, 9 38, -7 26, -14 42))")
pred_and(pred_within("POLYGON((-14 42, 9 38, -7 26, -14 42))"),
  pred_gte("elevation", 5000))
pred_or(pred_lte("year", 1989), pred("year", 2000))
pred_and(pred_lte("year", 1989), pred("year", 2000))
pred_in("taxonKey", c(2977832, 2977901, 2977966, 2977835))
pred_in("basisOfRecord", c("MACHINE_OBSERVATION", "HUMAN_OBSERVATION"))
pred_not(pred("taxonKey", 729))
pred_like("catalogNumber", "PAPS5-560%")
pred_notnull("issue")
pred("basisOfRecord", "LITERATURE")
pred("hasCoordinate", TRUE)
pred("stateProvince", "California")
pred("hasGeospatialIssue", FALSE)
pred_within("POLYGON((-14 42, 9 38, -7 26, -14 42))")
pred_or(pred("taxonKey", 2977832), pred("taxonKey", 2977901),
  pred("taxonKey", 2977966))
pred_in("taxonKey", c(2977832, 2977901, 2977966, 2977835))
</code></pre>

<hr>
<h2 id='downloads'>Downloads interface</h2><span id='topic+downloads'></span>

<h3>Description</h3>

<p>GBIF provides two ways to get occurrence data: through the
<code style="white-space: pre;">&#8288;/occurrence/search&#8288;</code> route (see <code><a href="#topic+occ_search">occ_search()</a></code>),
or via the <code style="white-space: pre;">&#8288;/occurrence/download&#8288;</code> route (many functions, see below).
<code><a href="#topic+occ_search">occ_search()</a></code> is more appropriate for smaller data, while
<code style="white-space: pre;">&#8288;occ_download*()&#8288;</code> functions are more appropriate for larger data requests.
</p>


<h3>Settings</h3>

<p>You'll use <code><a href="#topic+occ_download">occ_download()</a></code> to kick off a download. You'll need to
give that function settings from your GBIF profile: your user name, your
password, and your email. These three settings are required to use the
function. You can specify them in one of three ways:
</p>

<ul>
<li><p> Pass them to <code>occ_download</code> as parameters
</p>
</li>
<li><p> Use R options: As options either in the current R session using
the <code><a href="base.html#topic+options">options()</a></code> function, or by setting them in your <code>.Rprofile</code> file, after
which point they'll be read in automatically
</p>
</li>
<li><p> Use environment variables: As env vars either in the current R session using
the <code><a href="base.html#topic+Sys.setenv">Sys.setenv()</a></code> function, or by setting them in your
<code>.Renviron</code>/<code>.bash_profile</code> or similar files, after which point they'll be read
in automatically
</p>
</li></ul>



<h3>BEWARE</h3>

<p>You can not perform that many downloads, so plan wisely.
See <em>Rate limiting</em> below.
</p>


<h3>Rate limiting</h3>

<p>If you try to launch too many downloads, you will receive an 420
&quot;Enhance Your Calm&quot; response. If there is less then 100 in total
across all GBIF users, then you can have 3 running at a time. If
there are more than that, then each user is limited to 1 only.
These numbers are subject to change.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code><a href="#topic+occ_download">occ_download()</a></code> - Start a download
</p>
</li>
<li> <p><code><a href="#topic+occ_download_prep">occ_download_prep()</a></code> - Prepare a download request
</p>
</li>
<li> <p><code><a href="#topic+occ_download_queue">occ_download_queue()</a></code> - Start many downloads in a queue
</p>
</li>
<li> <p><code><a href="#topic+occ_download_cached">occ_download_cached()</a></code> - Check for downloads already in your GBIF account
</p>
</li>
<li> <p><code><a href="#topic+occ_download_wait">occ_download_wait()</a></code> - Re-run <code>occ_download_meta()</code> until ready
</p>
</li>
<li> <p><code><a href="#topic+occ_download_meta">occ_download_meta()</a></code> - Get metadata progress on a single download
</p>
</li>
<li> <p><code><a href="#topic+occ_download_list">occ_download_list()</a></code> - List your downloads
</p>
</li>
<li> <p><code><a href="#topic+occ_download_cancel">occ_download_cancel()</a></code> - Cancel a download
</p>
</li>
<li> <p><code><a href="#topic+occ_download_cancel_staged">occ_download_cancel_staged()</a></code> - Cancels any jobs with status <code>RUNNING</code>
or <code>PREPARING</code>
</p>
</li>
<li> <p><code><a href="#topic+occ_download_get">occ_download_get()</a></code> - Retrieve a download
</p>
</li>
<li> <p><code><a href="#topic+occ_download_import">occ_download_import()</a></code> - Import a download from local file system
</p>
</li>
<li> <p><code><a href="#topic+occ_download_datasets">occ_download_datasets()</a></code> - List datasets for a download
</p>
</li>
<li> <p><code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity()</a></code> - Lists the downloads activity
of a dataset
</p>
</li></ul>

<p>Download query composer methods:
</p>
<p>See <a href="#topic+download_predicate_dsl">download_predicate_dsl</a>
</p>


<h3>Query length</h3>

<p>GBIF has a limit of 12,000 characters for a download query. This means
that you can have a pretty long query, but at some point it may lead to an
error on GBIF's side and you'll have to split your query into a few.
</p>


<h3>Download status</h3>

<p>The following statuses can be found with any download:
</p>

<ul>
<li><p> PREPARING: just submitted by user and awaiting processing (typically only
a few seconds)
</p>
</li>
<li><p> RUNNING: being created (takes typically 1-15 minutes)
</p>
</li>
<li><p> FAILED: something unexpected went wrong
</p>
</li>
<li><p> KILLED: user decided to abort the job while it was in PREPARING or RUNNING
phase
</p>
</li>
<li><p> SUCCEEDED: The download was created and the user was informed
</p>
</li>
<li><p> FILE_ERASED: The download was deleted according to the retention policy,
see https://www.gbif.org/faq?question=for-how-long-will-does-gbif-store-downloads
</p>
</li></ul>


<hr>
<h2 id='DownReq'>DownReq</h2><span id='topic+DownReq'></span>

<h3>Description</h3>

<p>handles single requests for <a href="#topic+GbifQueue">GbifQueue</a>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>req</code></dt><dd><p>(list) internal holder for the request</p>
</dd>
<dt><code>type</code></dt><dd><p>(list) type, one of &quot;lazy&quot; (to be lazy evaluated) or &quot;pre&quot;
(run with <code>occ_download_exec</code> internal fxn)</p>
</dd>
<dt><code>result</code></dt><dd><p>(list) holds the result of the http request</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DownReq-new"><code>DownReq$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DownReq-print"><code>DownReq$print()</code></a>
</p>
</li>
<li> <p><a href="#method-DownReq-run"><code>DownReq$run()</code></a>
</p>
</li>
<li> <p><a href="#method-DownReq-status"><code>DownReq$status()</code></a>
</p>
</li>
<li> <p><a href="#method-DownReq-clone"><code>DownReq$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DownReq-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>DownReq</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>DownReq$new(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>either a lazy object with an object of class <code>occ_download</code>, or an
object of class <code>occ_download_prep</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>DownReq</code> object
</p>


<hr>
<a id="method-DownReq-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>DownReq</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>DownReq$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DownReq-run"></a>



<h4>Method <code>run()</code></h4>

<p>execute http request
</p>


<h5>Usage</h5>

<div class="r"><pre>DownReq$run()</pre></div>



<h5>Returns</h5>

<p>nothing, puts the http response in <code style="white-space: pre;">&#8288;$result&#8288;</code>
</p>


<hr>
<a id="method-DownReq-status"></a>



<h4>Method <code>status()</code></h4>

<p>check http request status
</p>


<h5>Usage</h5>

<div class="r"><pre>DownReq$status()</pre></div>



<h5>Returns</h5>

<p>output of <code><a href="#topic+occ_download_meta">occ_download_meta()</a></code>
</p>


<hr>
<a id="method-DownReq-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DownReq$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- DownReq$new(occ_download_prep(pred("basisOfRecord", "LITERATURE"), 
  pred("year", "1956")
))
res
# res$run()
# res
# res$status()
# res$result

## End(Not run)
</code></pre>

<hr>
<h2 id='elevation'>Get elevation for lat/long points from a data.frame or list of points.</h2><span id='topic+elevation'></span>

<h3>Description</h3>

<p>Uses the GeoNames web service
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elevation(
  input = NULL,
  latitude = NULL,
  longitude = NULL,
  latlong = NULL,
  elevation_model = "srtm3",
  username = Sys.getenv("GEONAMES_USER"),
  key,
  curlopts,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elevation_+3A_input">input</code></td>
<td>
<p>A data.frame of lat/long data. There must be columns
decimalLatitude and decimalLongitude.</p>
</td></tr>
<tr><td><code id="elevation_+3A_latitude">latitude</code></td>
<td>
<p>A vector of latitude's. Must be the same length as the
longitude vector.</p>
</td></tr>
<tr><td><code id="elevation_+3A_longitude">longitude</code></td>
<td>
<p>A vector of longitude's. Must be the same length as
the latitude vector.</p>
</td></tr>
<tr><td><code id="elevation_+3A_latlong">latlong</code></td>
<td>
<p>A vector of lat/long pairs. See examples.</p>
</td></tr>
<tr><td><code id="elevation_+3A_elevation_model">elevation_model</code></td>
<td>
<p>(character) one of srtm3 (default), srtm1, astergdem,
or gtopo30. See &quot;Elevation models&quot; below for more</p>
</td></tr>
<tr><td><code id="elevation_+3A_username">username</code></td>
<td>
<p>(character) Required. An GeoNames user name. See Details.</p>
</td></tr>
<tr><td><code id="elevation_+3A_key">key</code>, <code id="elevation_+3A_curlopts">curlopts</code></td>
<td>
<p>defunct. see docs</p>
</td></tr>
<tr><td><code id="elevation_+3A_...">...</code></td>
<td>
<p>curl options passed on to <a href="crul.html#topic+verb-GET">crul::verb-GET</a>
see <code>curl::curl_options()</code> for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new column named <code>elevation_geonames</code> in the supplied data.frame
or a vector with elevation of each location in meters. Note that data from
GBIF can already have a column named <code>elevation</code>, thus the column we
add is named differently.
</p>


<h3>GeoNames user name</h3>

<p>To get a GeoNames user name, register for an account at
http://www.geonames.org/login - then you can enable your account for the
GeoNames webservice on your account page
(http://www.geonames.org/manageaccount). Once you are enabled to use
the webservice, you can pass in your username to the <code>username</code>
parameter. Better yet, store your username in your <code>.Renviron</code> file, or
similar (e.g., .zshrc or .bash_profile files) and read it in via
<code>Sys.getenv()</code> as in the examples below. By default we do
<code>Sys.getenv("GEONAMES_USER")</code> for the <code>username</code> parameter.
</p>


<h3>Elevation models</h3>


<ul>
<li><p> srtm3:
</p>

<ul>
<li><p> sample area: ca 90m x 90m
</p>
</li>
<li><p> result: a single number giving the elevation in meters according to
srtm3, ocean areas have been masked as &quot;no data&quot; and have been assigned
a value of -32768
</p>
</li></ul>

</li>
<li><p> srtm1:
</p>

<ul>
<li><p> sample area: ca 30m x 30m
</p>
</li>
<li><p> result: a single number giving the elevation in meters according to
srtm1, ocean areas have been masked as &quot;no data&quot; and have been assigned
a value of -32768
</p>
</li></ul>

</li>
<li><p> astergdem (Aster Global Digital Elevation Model V2 2011):
</p>

<ul>
<li><p> sample area: ca 30m x 30m, between 83N and 65S latitude
</p>
</li>
<li><p> result: a single number giving the elevation in meters according to
aster gdem, ocean areas have been masked as &quot;no data&quot; and have been
assigned a value of -32768
</p>
</li></ul>

</li>
<li><p> gtopo30:
</p>

<ul>
<li><p> sample area: ca 1km x 1km
</p>
</li>
<li><p> result: a single number giving the elevation in meters according to
gtopo30, ocean areas have been masked as &quot;no data&quot; and have been
assigned a value of -9999
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>GeoNames http://www.geonames.org/export/web-services.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
user &lt;- Sys.getenv("GEONAMES_USER")

occ_key &lt;- name_suggest('Puma concolor')$key[1]
dat &lt;- occ_search(taxonKey = occ_key, limit = 300, hasCoordinate = TRUE)
head( elevation(dat$data, username = user) )

# Pass in a vector of lat's and a vector of long's
elevation(latitude = dat$data$decimalLatitude[1:10],
  longitude = dat$data$decimalLongitude[1:10],
  username = user, verbose = TRUE)

# Pass in lat/long pairs in a single vector
pairs &lt;- list(c(31.8496,-110.576060), c(29.15503,-103.59828))
elevation(latlong=pairs, username = user)

# Pass on curl options
pairs &lt;- list(c(31.8496,-110.576060), c(29.15503,-103.59828))
elevation(latlong=pairs, username = user, verbose = TRUE)

# different elevation models
lats &lt;- dat$data$decimalLatitude[1:5]
lons &lt;- dat$data$decimalLongitude[1:5]
elevation(latitude = lats, longitude = lons, elevation_model = "srtm3")
elevation(latitude = lats, longitude = lons, elevation_model = "srtm1")
elevation(latitude = lats, longitude = lons, elevation_model = "astergdem")
elevation(latitude = lats, longitude = lons, elevation_model = "gtopo30")

## End(Not run)
</code></pre>

<hr>
<h2 id='enumeration'>Enumerations.</h2><span id='topic+enumeration'></span><span id='topic+enumeration_country'></span>

<h3>Description</h3>

<p>Many parts of the GBIF API make use of enumerations, i.e. controlled
vocabularies for specific topics - and are available via these functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumeration(x = NULL, curlopts = list())

enumeration_country(curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enumeration_+3A_x">x</code></td>
<td>
<p>A given enumeration.</p>
</td></tr>
<tr><td><code id="enumeration_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>enumeration</code> returns a character vector, while
<code>enumeration_country</code> returns a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# basic enumeration
enumeration()
enumeration("NameType")
enumeration("MetadataType")
enumeration("TypeStatus")

# country enumeration
enumeration_country()

# curl options
enumeration(curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='gbif_bbox2wkt'>Convert a bounding box to a Well Known Text polygon, and a WKT to a
bounding box</h2><span id='topic+gbif_bbox2wkt'></span><span id='topic+gbif_wkt2bbox'></span>

<h3>Description</h3>

<p>Convert a bounding box to a Well Known Text polygon, and a WKT to a
bounding box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbif_bbox2wkt(minx = NA, miny = NA, maxx = NA, maxy = NA, bbox = NULL)

gbif_wkt2bbox(wkt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbif_bbox2wkt_+3A_minx">minx</code></td>
<td>
<p>(numeric) Minimum x value, or the most western longitude</p>
</td></tr>
<tr><td><code id="gbif_bbox2wkt_+3A_miny">miny</code></td>
<td>
<p>(numeric) Minimum y value, or the most southern latitude</p>
</td></tr>
<tr><td><code id="gbif_bbox2wkt_+3A_maxx">maxx</code></td>
<td>
<p>(numeric) Maximum x value, or the most eastern longitude</p>
</td></tr>
<tr><td><code id="gbif_bbox2wkt_+3A_maxy">maxy</code></td>
<td>
<p>(numeric) Maximum y value, or the most northern latitude</p>
</td></tr>
<tr><td><code id="gbif_bbox2wkt_+3A_bbox">bbox</code></td>
<td>
<p>(numeric) A vector of length 4, with the elements: minx, miny,
maxx, maxy</p>
</td></tr>
<tr><td><code id="gbif_bbox2wkt_+3A_wkt">wkt</code></td>
<td>
<p>(character) A Well Known Text object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gbif_bbox2wkt returns an object of class charactere, a Well
Known Text string of the form
'POLYGON((minx miny, maxx miny, maxx maxy, minx maxy, minx miny))'.
</p>
<p>gbif_wkt2bbox returns a numeric vector of length 4, like
c(minx, miny, maxx, maxy)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Convert a bounding box to a WKT
## Pass in a vector of length 4 with all values
gbif_bbox2wkt(bbox=c(-125.0,38.4,-121.8,40.9))

## Or pass in each value separately
gbif_bbox2wkt(minx=-125.0, miny=38.4, maxx=-121.8, maxy=40.9)

# Convert a WKT object to a bounding box
wkt &lt;- "POLYGON((-125 38.4,-125 40.9,-121.8 40.9,-121.8 38.4,-125 38.4))"
gbif_wkt2bbox(wkt)

## End(Not run)
</code></pre>

<hr>
<h2 id='gbif_citation'>Get citation for datasets used</h2><span id='topic+gbif_citation'></span>

<h3>Description</h3>

<p>Get citation for datasets used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbif_citation(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbif_citation_+3A_x">x</code></td>
<td>
<p>(character) Result of call to <code><a href="#topic+occ_download_get">occ_download_get()</a></code>, <code><a href="#topic+occ_download_meta">occ_download_meta()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is deprecated for use with <code><a href="#topic+occ_search">occ_search()</a></code> and <code><a href="#topic+occ_data">occ_data()</a></code>
results, and is deprecated for use with datasetKeys and gbifids. Instead,
we encourage you to use <code><a href="#topic+derived_dataset">derived_dataset()</a></code> instead.
</p>
<p><code><a href="#topic+occ_download_get">occ_download_get()</a></code> and <code><a href="#topic+occ_download_meta">occ_download_meta()</a></code> results are still supported.
</p>


<h3>Value</h3>

<p>list with S3 class assigned, used by a print method to pretty print
citation information. Though you can unclass the output or just index to the
named items as needed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Downloads
## occ_download_get()
# d1 &lt;- occ_download(pred("country", "BG"), pred_gte("year", 2020))
# occ_download_meta(d1) # wait until status = succeeded
# d1 &lt;- occ_download_get(d1, overwrite = TRUE)
# gbif_citation(d1)

## occ_download_meta()
# key &lt;- "0000122-171020152545675"
# res &lt;- occ_download_meta(key)
# gbif_citation(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='gbif_geocode'>Geocode lat-lon point(s) with GBIF's set of geo-polygons (experimental)</h2><span id='topic+gbif_geocode'></span>

<h3>Description</h3>

<p>Geocode lat-lon point(s) with GBIF's set of geo-polygons (experimental)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbif_geocode(latitude = NULL, longitude = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbif_geocode_+3A_latitude">latitude</code></td>
<td>
<p>a vector of numeric latitude values between -90 and 90.</p>
</td></tr>
<tr><td><code id="gbif_geocode_+3A_longitude">longitude</code></td>
<td>
<p>a vector of numeric longitude values between -180 and 180.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of results from the GBIF gecoding service.
</p>

<ul>
<li> <p><strong>latitude</strong> : The input latitude
</p>
</li>
<li> <p><strong>longitude</strong> : The input longitude
</p>
</li>
<li> <p><strong>index</strong> : The original input rownumber
</p>
</li>
<li> <p><strong>id</strong> : The polygon id from which the geocode comes from
</p>
</li>
<li> <p><strong>type</strong> : One of the following : &quot;Political&quot; (county codes),
&quot;IHO&quot; (marine regions), &quot;SeaVox&quot; (marine regions), &quot;WGSRPD&quot; (tdwg regions),
&quot;EEZ&quot;, (in national waters) or &quot;GADM0&quot;,&quot;GADM1&quot;,&quot;GADM2&quot;,&quot;GADM2&quot;(http://gadm.org/)
</p>
</li>
<li> <p><strong>title</strong> : The name of the source polygon
</p>
</li>
<li> <p><strong>distance</strong> : distance to the polygon boarder
</p>
</li></ul>

<p>This function uses the GBIF geocoder API which is not guaranteed to be
stable and is undocumented. As such, this may return different data over
time, may be rate-limited or may stop working if GBIF change the service.
Use this function with caution.
</p>


<h3>References</h3>

<p>http://gadm.org/
http://marineregions.org/
http://www.tdwg.org/standards/
<a href="http://api.gbif.org/v1/geocode/reverse?lat=0&amp;lng=0">http://api.gbif.org/v1/geocode/reverse?lat=0&amp;lng=0</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# one pair 
gbif_geocode(0,0)
# or multiple pairs of points
gbif_geocode(c(0,50),c(0,20))


## End(Not run)

</code></pre>

<hr>
<h2 id='gbif_issues'>List all GBIF issues and their codes.</h2><span id='topic+gbif_issues'></span>

<h3>Description</h3>

<p>Returns a data.frame of all GBIF issues with the following columns:
</p>

<ul>
<li> <p><code>code</code>: issue short code, e.g. <code>gass84</code>
</p>
</li>
<li> <p><code>code</code>: issue full name, e.g. <code>GEODETIC_DATUM_ASSUMED_WGS84</code>
</p>
</li>
<li> <p><code>description</code>: issue description
</p>
</li>
<li> <p><code>type</code>: issue type, either related to <code>occurrence</code> or <code>name</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>gbif_issues()
</code></pre>


<h3>Source</h3>

<p>https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/OccurrenceIssue.html
https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/NameUsageIssue.html
</p>

<hr>
<h2 id='gbif_issues_lookup'>Lookup issue definitions and short codes</h2><span id='topic+gbif_issues_lookup'></span>

<h3>Description</h3>

<p>Lookup issue definitions and short codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbif_issues_lookup(issue = NULL, code = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbif_issues_lookup_+3A_issue">issue</code></td>
<td>
<p>Full name of issue, e.g, CONTINENT_COUNTRY_MISMATCH</p>
</td></tr>
<tr><td><code id="gbif_issues_lookup_+3A_code">code</code></td>
<td>
<p>An issue short code, e.g. 'ccm'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gbif_issues_lookup(issue = 'CONTINENT_COUNTRY_MISMATCH')
gbif_issues_lookup(code = 'ccm')
gbif_issues_lookup(issue = 'COORDINATE_INVALID')
gbif_issues_lookup(code = 'cdiv')
</code></pre>

<hr>
<h2 id='gbif_names'>View highlighted terms in name results from GBIF.</h2><span id='topic+gbif_names'></span>

<h3>Description</h3>

<p>View highlighted terms in name results from GBIF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbif_names(input, output = NULL, browse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbif_names_+3A_input">input</code></td>
<td>
<p>Input output from occ_search</p>
</td></tr>
<tr><td><code id="gbif_names_+3A_output">output</code></td>
<td>
<p>Output folder path. If not given uses temporary folder.</p>
</td></tr>
<tr><td><code id="gbif_names_+3A_browse">browse</code></td>
<td>
<p>(logical) Browse output (default: <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# browse=FALSE returns path to file
gbif_names(name_lookup(query='snake', hl=TRUE), browse=FALSE)

(out &lt;- name_lookup(query='canada', hl=TRUE, limit=5))
gbif_names(out)
gbif_names(name_lookup(query='snake', hl=TRUE))
gbif_names(name_lookup(query='bird', hl=TRUE))

# or not highlight
gbif_names(name_lookup(query='bird', limit=200))

## End(Not run)
</code></pre>

<hr>
<h2 id='gbif_oai'>GBIF registry data via OAI-PMH</h2><span id='topic+gbif_oai'></span><span id='topic+gbif_oai_identify'></span><span id='topic+gbif_oai_list_identifiers'></span><span id='topic+gbif_oai_list_records'></span><span id='topic+gbif_oai_list_metadataformats'></span><span id='topic+gbif_oai_list_sets'></span><span id='topic+gbif_oai_get_records'></span>

<h3>Description</h3>

<p>GBIF registry data via OAI-PMH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbif_oai_identify(...)

gbif_oai_list_identifiers(
  prefix = "oai_dc",
  from = NULL,
  until = NULL,
  set = NULL,
  token = NULL,
  as = "df",
  ...
)

gbif_oai_list_records(
  prefix = "oai_dc",
  from = NULL,
  until = NULL,
  set = NULL,
  token = NULL,
  as = "df",
  ...
)

gbif_oai_list_metadataformats(id = NULL, ...)

gbif_oai_list_sets(token = NULL, as = "df", ...)

gbif_oai_get_records(ids, prefix = "oai_dc", as = "parsed", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbif_oai_+3A_...">...</code></td>
<td>
<p>Curl options passed on to <code>httr::GET</code></p>
</td></tr>
<tr><td><code id="gbif_oai_+3A_prefix">prefix</code></td>
<td>
<p>(character) A string to specify the metadata format in OAI-PMH
requests issued to the repository. The default (<code>"oai_dc"</code>) corresponds
to the mandatory OAI unqualified Dublin Core metadata schema.</p>
</td></tr>
<tr><td><code id="gbif_oai_+3A_from">from</code></td>
<td>
<p>(character) string giving datestamp to be used as lower bound
for datestamp-based selective harvesting (i.e., only harvest records with
datestamps in the given range). Dates and times must be encoded using ISO
8601. The trailing Z must be used when including time. OAI-PMH implies
UTC for data/time specifications.</p>
</td></tr>
<tr><td><code id="gbif_oai_+3A_until">until</code></td>
<td>
<p>(character) Datestamp to be used as an upper bound, for
datestamp-based selective harvesting (i.e., only harvest records with
datestamps in the given range).</p>
</td></tr>
<tr><td><code id="gbif_oai_+3A_set">set</code></td>
<td>
<p>(character) A set to be used for selective harvesting (i.e., only
harvest records in the given set).</p>
</td></tr>
<tr><td><code id="gbif_oai_+3A_token">token</code></td>
<td>
<p>(character) a token previously provided by the server to resume
a request where it last left off. 50 is max number of records returned.
We will loop for you internally to get all the records you asked for.</p>
</td></tr>
<tr><td><code id="gbif_oai_+3A_as">as</code></td>
<td>
<p>(character) What to return. One of &quot;df&quot; (for data.frame;
default), &quot;list&quot; (get a list), or &quot;raw&quot; (raw text). For
<code>gbif_oai_get_records</code>, one of &quot;parsed&quot; or &quot;raw&quot;</p>
</td></tr>
<tr><td><code id="gbif_oai_+3A_id">id</code>, <code id="gbif_oai_+3A_ids">ids</code></td>
<td>
<p>(character) The OAI-PMH identifier for the record. Optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions only work with GBIF registry data, and do so
via the OAI-PMH protocol
(https://www.openarchives.org/OAI/openarchivesprotocol.html)
</p>


<h3>Value</h3>

<p>raw text, list or data.frame, depending on requested output via
<code>as</code> parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gbif_oai_identify()

today &lt;- format(Sys.Date(), "%Y-%m-%d")
gbif_oai_list_identifiers(from = today)
gbif_oai_list_identifiers(set = "country:NL")

gbif_oai_list_records(from = today)
gbif_oai_list_records(set = "country:NL")

gbif_oai_list_metadataformats()
gbif_oai_list_metadataformats(id = "9c4e36c1-d3f9-49ce-8ec1-8c434fa9e6eb")

gbif_oai_list_sets()
gbif_oai_list_sets(as = "list")

gbif_oai_get_records("9c4e36c1-d3f9-49ce-8ec1-8c434fa9e6eb")
ids &lt;- c("9c4e36c1-d3f9-49ce-8ec1-8c434fa9e6eb",
         "e0f1bb8a-2d81-4b2a-9194-d92848d3b82e")
gbif_oai_get_records(ids)

## End(Not run)
</code></pre>

<hr>
<h2 id='gbif_photos'>View photos from GBIF.</h2><span id='topic+gbif_photos'></span>

<h3>Description</h3>

<p>View photos from GBIF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbif_photos(input, output = NULL, which = "table", browse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gbif_photos_+3A_input">input</code></td>
<td>
<p>Input output from occ_search</p>
</td></tr>
<tr><td><code id="gbif_photos_+3A_output">output</code></td>
<td>
<p>Output folder path. If not given uses temporary folder.</p>
</td></tr>
<tr><td><code id="gbif_photos_+3A_which">which</code></td>
<td>
<p>One of map or table (default).</p>
</td></tr>
<tr><td><code id="gbif_photos_+3A_browse">browse</code></td>
<td>
<p>(logical) Browse output (default: <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The max number of photos you can see when which=&quot;map&quot; is ~160,
so cycle through if you have more than that.
</p>


<h3>BEWARE</h3>

<p>The maps in the table view may not show up correctly if
you are using RStudio
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- occ_search(mediaType = 'StillImage', limit = 100)
gbif_photos(res)
gbif_photos(res, which='map')

res &lt;- occ_search(scientificName = "Aves", mediaType = 'StillImage',
  limit=150)
gbif_photos(res)
gbif_photos(res, output = '~/barfoo')

## End(Not run)
</code></pre>

<hr>
<h2 id='gbifdata'>Get data.frame from occurrencelist, occurrencelist_many, or densitylist.</h2><span id='topic+gbifdata'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbifdata(...)
</code></pre>

<hr>
<h2 id='gbifmap'>Get Github credentials from use in console</h2><span id='topic+gbifmap'></span>

<h3>Description</h3>

<p>This function is defunct.  See the package gistr for similar functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbifmap(...)
</code></pre>

<hr>
<h2 id='gbifmap_dens'>Make a simple map to visualize GBIF data density data</h2><span id='topic+gbifmap_dens'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbifmap_dens(...)
</code></pre>


<h3>See Also</h3>

<p>gbifmap
</p>

<hr>
<h2 id='gbifmap_list'>Make a simple map to visualize GBIF point data.</h2><span id='topic+gbifmap_list'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbifmap_list(...)
</code></pre>


<h3>See Also</h3>

<p>gbifmap
</p>

<hr>
<h2 id='GbifQueue'>GbifQueue</h2><span id='topic+GbifQueue'></span>

<h3>Description</h3>

<p>GBIF download queue
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>reqs</code></dt><dd><p>(list) a named list of objects of class <code><a href="#topic+occ_download">occ_download()</a></code></p>
</dd>
<dt><code>queue</code></dt><dd><p>(list) holds the queued jobs</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GbifQueue-print"><code>GbifQueue$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GbifQueue-new"><code>GbifQueue$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GbifQueue-add"><code>GbifQueue$add()</code></a>
</p>
</li>
<li> <p><a href="#method-GbifQueue-add_all"><code>GbifQueue$add_all()</code></a>
</p>
</li>
<li> <p><a href="#method-GbifQueue-remove"><code>GbifQueue$remove()</code></a>
</p>
</li>
<li> <p><a href="#method-GbifQueue-next_"><code>GbifQueue$next_()</code></a>
</p>
</li>
<li> <p><a href="#method-GbifQueue-last_"><code>GbifQueue$last_()</code></a>
</p>
</li>
<li> <p><a href="#method-GbifQueue-jobs"><code>GbifQueue$jobs()</code></a>
</p>
</li>
<li> <p><a href="#method-GbifQueue-clone"><code>GbifQueue$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GbifQueue-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>GbifQueue</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GbifQueue-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>GbifQueue</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$new(..., .list = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>any number of <code><a href="#topic+occ_download">occ_download()</a></code> requests</p>
</dd>
<dt><code>.list</code></dt><dd><p>any number of <code><a href="#topic+occ_download">occ_download()</a></code> requests as <code>lazy</code>
objects, called with e.g., <code>lazyeval::lazy()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>GbifQueue</code> object
</p>


<hr>
<a id="method-GbifQueue-add"></a>



<h4>Method <code>add()</code></h4>

<p>Add single jobs to the queue
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$add(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>an <code><a href="#topic+occ_download">occ_download()</a></code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; adds job (<code>x</code>) to the queue
</p>


<hr>
<a id="method-GbifQueue-add_all"></a>



<h4>Method <code>add_all()</code></h4>

<p>Add all jobs to the queue
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$add_all()</pre></div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-GbifQueue-remove"></a>



<h4>Method <code>remove()</code></h4>

<p>Remove a job from the queue
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$remove(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>an <code><a href="#topic+occ_download">occ_download()</a></code> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-GbifQueue-next_"></a>



<h4>Method <code>next_()</code></h4>

<p>Get the next job in the <code>queue</code>. if no more jobs,
returns empty list
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$next_()</pre></div>



<h5>Returns</h5>

<p>next job or empty list
</p>


<hr>
<a id="method-GbifQueue-last_"></a>



<h4>Method <code>last_()</code></h4>

<p>Get the last job in the <code>queue</code>. if no more jobs,
returns empty list
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$last_()</pre></div>



<h5>Returns</h5>

<p>last job or empty list
</p>


<hr>
<a id="method-GbifQueue-jobs"></a>



<h4>Method <code>jobs()</code></h4>

<p>Get number of jobs in the <code>queue</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$jobs()</pre></div>



<h5>Returns</h5>

<p>(integer) number of jobs
</p>


<hr>
<a id="method-GbifQueue-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GbifQueue$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (interactive()) { # dont run in automated example runs, too costly
x &lt;- GbifQueue$new(
  occ_download(pred('taxonKey', 3119195), pred("year", 1976)),
  occ_download(pred('taxonKey', 3119195), pred("year", 2001)),
  occ_download(pred('taxonKey', 3119195), pred("year", 2001), pred_lte("month", 8)),
  occ_download(pred('taxonKey', 3119195), pred("year", 2004)),
  occ_download(pred('taxonKey', 3119195), pred("year", 2005))
)
x
x$reqs
x$add_all()
x
x$jobs()
x
x$remove(x$reqs[[1]])
x
x$reqs[[1]]$run()
x$reqs[[1]]$result

# pre-prepared download request
z &lt;- occ_download_prep(
  pred_in("basisOfRecord", c("HUMAN_OBSERVATION","OBSERVATION")),
  pred("hasCoordinate", TRUE),
  pred("hasGeospatialIssue", FALSE),
  pred("year", 1993),
  user = "foo", pwd = "bar", email = "foo@bar.com"
)
out &lt;- GbifQueue$new(.list = list(z))
out
out$reqs
}
## End(Not run)
</code></pre>

<hr>
<h2 id='get_credentials'>Get Github credentials from use in console</h2><span id='topic+get_credentials'></span>

<h3>Description</h3>

<p>This function is defunct.  See the package gistr for similar functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_credentials(...)
</code></pre>

<hr>
<h2 id='gist'>Post a file as a Github gist</h2><span id='topic+gist'></span>

<h3>Description</h3>

<p>This function is defunct.  See the package gistr for similar functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gist(...)
</code></pre>

<hr>
<h2 id='installations'>Installations metadata.</h2><span id='topic+installations'></span>

<h3>Description</h3>

<p>Installations metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installations(
  data = "all",
  uuid = NULL,
  query = NULL,
  identifier = NULL,
  identifierType = NULL,
  limit = 100,
  start = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="installations_+3A_data">data</code></td>
<td>
<p>The type of data to get. One or more of: 'contact', 'endpoint',
'dataset', 'comment', 'deleted', 'nonPublishing', or the special 'all'.
Default: <code>'all'</code></p>
</td></tr>
<tr><td><code id="installations_+3A_uuid">uuid</code></td>
<td>
<p>UUID of the data node provider. This must be specified if data
is anything other than 'all'.</p>
</td></tr>
<tr><td><code id="installations_+3A_query">query</code></td>
<td>
<p>Query nodes. Only used when <code>data='all'</code>. Ignored
otherwise.</p>
</td></tr>
<tr><td><code id="installations_+3A_identifier">identifier</code></td>
<td>
<p>The value for this parameter can be a simple string or
integer, e.g. <code>identifier=120</code>. This parameter doesn't seem to work right
now.</p>
</td></tr>
<tr><td><code id="installations_+3A_identifiertype">identifierType</code></td>
<td>
<p>Used in combination with the identifier parameter to
filter identifiers by identifier type. See details. This parameter doesn't
seem to work right now.</p>
</td></tr>
<tr><td><code id="installations_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100. Maximum: 1000.</p>
</td></tr>
<tr><td><code id="installations_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0. Use in combination
with <code>limit</code> to page through results.</p>
</td></tr>
<tr><td><code id="installations_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>identifierType options:
</p>

<ul>
<li> <p>DOI No description.
</p>
</li>
<li> <p>FTP No description.
</p>
</li>
<li> <p>GBIF_NODE Identifies the node (e.g: <code>DK</code> for Denmark, <code>sp2000</code>
for Species 2000).
</p>
</li>
<li> <p>GBIF_PARTICIPANT Participant identifier from the GBIF IMS
Filemaker system.
</p>
</li>
<li> <p>GBIF_PORTAL Indicates the identifier originated from an
auto_increment column in the portal.data_provider or portal.data_resource
table respectively.
</p>
</li>
<li> <p>HANDLER No description.
</p>
</li>
<li> <p>LSID Reference controlled by a separate system, used for example
by DOI.
</p>
</li>
<li> <p>SOURCE_ID No description.
</p>
</li>
<li> <p>UNKNOWN No description.
</p>
</li>
<li> <p>URI No description.
</p>
</li>
<li> <p>URL No description.
</p>
</li>
<li> <p>UUID No description.
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.gbif.org/developer/registry#installations">https://www.gbif.org/developer/registry#installations</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
installations(limit=5)
installations(query="france", limit = 25)
installations(uuid="b77901f9-d9b0-47fa-94e0-dd96450aa2b4")
installations(data='contact', uuid="2e029a0c-87af-42e6-87d7-f38a50b78201")
installations(data='endpoint', uuid="b77901f9-d9b0-47fa-94e0-dd96450aa2b4")
installations(data='dataset', uuid="b77901f9-d9b0-47fa-94e0-dd96450aa2b4")
installations(data='deleted', limit = 25)
installations(data='deleted', limit=2)
installations(data=c('deleted','nonPublishing'), limit=2)
installations(identifierType='DOI', limit=2)

# Pass on curl options
installations(data='deleted', curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='lit_search'>Search for literature that cites GBIF mediated data</h2><span id='topic+lit_search'></span><span id='topic+lit_count'></span>

<h3>Description</h3>

<p>Search for literature that cites GBIF mediated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lit_search(
  q = NULL,
  countriesOfResearcher = NULL,
  countriesOfCoverage = NULL,
  literatureType = NULL,
  relevance = NULL,
  year = NULL,
  topics = NULL,
  datasetKey = NULL,
  publishingOrg = NULL,
  peerReview = NULL,
  openAccess = NULL,
  downloadKey = NULL,
  doi = NULL,
  journalSource = NULL,
  journalPublisher = NULL,
  flatten = TRUE,
  limit = NULL,
  curlopts = list()
)

lit_count(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lit_search_+3A_q">q</code></td>
<td>
<p>(character) Simple full text search parameter. The value for this
parameter can be a simple word or a phrase. Wildcards are not supported.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_countriesofresearcher">countriesOfResearcher</code></td>
<td>
<p>(character) Country of institution with which
author is affiliated, e.g. DK (for Denmark). Country codes are
listed in enumeration_country().</p>
</td></tr>
<tr><td><code id="lit_search_+3A_countriesofcoverage">countriesOfCoverage</code></td>
<td>
<p>(character) Country of focus of study,
e.g. BR (for Brazil). Country codes are listed in enumeration_country().</p>
</td></tr>
<tr><td><code id="lit_search_+3A_literaturetype">literatureType</code></td>
<td>
<p>(character) Type of literature (&quot;JOURNAL&quot;,
&quot;BOOK_SECTION&quot;, &quot;WORKING_PAPER&quot;, &quot;REPORT&quot;, &quot;GENERIC&quot;, &quot;THESIS&quot;, &quot;CONFERENCE_PROCEEDINGS&quot;,
&quot;WEB_PAGE&quot;).</p>
</td></tr>
<tr><td><code id="lit_search_+3A_relevance">relevance</code></td>
<td>
<p>(character) How is the publication relate to GBIF. See details
(&quot;GBIF_USED&quot;, &quot;GBIF_MENTIONED&quot;, &quot;GBIF_PUBLISHED&quot;, &quot;GBIF_CITED&quot;, &quot;GBIF_CITED&quot;,
&quot;GBIF_PUBLISHED&quot;, &quot;GBIF_ACKNOWLEDGED&quot;, &quot;GBIF_AUTHOR&quot;).</p>
</td></tr>
<tr><td><code id="lit_search_+3A_year">year</code></td>
<td>
<p>(integer) Year of publication.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_topics">topics</code></td>
<td>
<p>(character) Topic of publication.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_datasetkey">datasetKey</code></td>
<td>
<p>(character) GBIF dataset uuid referenced in publication.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_publishingorg">publishingOrg</code></td>
<td>
<p>(character) Publisher uuid whose dataset is
referenced in publication.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_peerreview">peerReview</code></td>
<td>
<p>(logical) Has publication undergone peer-review?</p>
</td></tr>
<tr><td><code id="lit_search_+3A_openaccess">openAccess</code></td>
<td>
<p>(logical) Is publication Open Access?</p>
</td></tr>
<tr><td><code id="lit_search_+3A_downloadkey">downloadKey</code></td>
<td>
<p>(character) Download referenced in publication.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_doi">doi</code></td>
<td>
<p>(character) Digital Object Identifier (DOI).</p>
</td></tr>
<tr><td><code id="lit_search_+3A_journalsource">journalSource</code></td>
<td>
<p>(character) Journal of publication.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_journalpublisher">journalPublisher</code></td>
<td>
<p>(character) Publisher of journal.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_flatten">flatten</code></td>
<td>
<p>(logical) should any lists in the resulting data be flattened
into comma-seperated strings?</p>
</td></tr>
<tr><td><code id="lit_search_+3A_limit">limit</code></td>
<td>
<p>how many records to return. limit=NULL will fetch up to 10,000.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to HttpClient.
see curl::curl_options for curl options.</p>
</td></tr>
<tr><td><code id="lit_search_+3A_...">...</code></td>
<td>
<p>additional parameters passed to lit_search</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables you to search for literature indexed by GBIF,
including peer-reviewed papers, citing GBIF datasets and downloads.
The literature API powers the
<a href="https://www.gbif.org/resource/search?contentType=literature">literature search</a>
on GBIF.
</p>
<p>The GBIF Secretariat maintains an ongoing
<a href="https://www.gbif.org/literature-tracking">literature tracking programme</a>,
which identifies research uses and citations of biodiversity information
accessed through GBIF’s global infrastructure.
</p>
<p>In the literature database, <strong>relevance</strong> refers to how publications relate
to GBIF following these definitions:
</p>

<ul>
<li><p> GBIF_USED : makes substantive use of data in a quantitative analysis (e.g. ecological niche modelling)
</p>
</li>
<li><p> GBIF_CITED : cites a qualitative fact derived in data (e.g. a given species is found in a given country)
</p>
</li>
<li><p> GBIF_DISCUSSED : discusses GBIF as an infrastructure or the use of data
</p>
</li>
<li><p> GBIF_PRIMARY : GBIF is the primary source of data (no longer applied)
</p>
</li>
<li><p> GBIF_ACKNOWLEDGED : acknowledges GBIF (but doesn't use or cite data)
</p>
</li>
<li><p> GBIF_PUBLISHED : describes or talks about data published to GBIF
</p>
</li>
<li><p> GBIF_AUTHOR : authored by GBIF staff
</p>
</li>
<li><p> GBIF_MENTIONED : unspecifically mentions GBIF or the GBIF portal
</p>
</li>
<li><p> GBIF_FUNDED : funded by GBIF or a GBIF-managed funding programme
</p>
</li></ul>

<p>The following arguments can take multiple values:
</p>

<ul>
<li><p> relevance
</p>
</li>
<li><p> countriesOfResearcher
</p>
</li>
<li><p> countriesOfCoverage
</p>
</li>
<li><p> literatureType
</p>
</li>
<li><p> topics
</p>
</li>
<li><p> datasetKey
</p>
</li>
<li><p> publishingOrg
</p>
</li>
<li><p> downloadKey
</p>
</li>
<li><p> doi
</p>
</li>
<li><p> journalSource
</p>
</li>
<li><p> journalPublisher
</p>
</li></ul>

<p>If <code>flatten=TRUE</code>, then <strong>data</strong> will be returned as flat
data.frame with no complex column types (i.e. no lists or data.frames).
</p>
<p><code>limit=NULL</code> will return up to 10,000 records. The maximum value for
<code>limit</code> is 10,000. If no filters are used, only the first 1,000 records
will be returned, limit must be explicitly set to <code>limit=10000</code>, to get
the first 10,000 records in this case.
</p>
<p><code>lit_count()</code> is a convenience wrapper, which will return the number of
literature references for a certain <code>lit_search()</code> query. This is the
same as running <code>lit_search()$meta$count</code>.
</p>


<h3>Value</h3>

<p>A named list with two values: <code>$data</code> and <code>$meta</code>. <code>$data</code> is
a <code>data.frame</code> of literature references.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lit_search(q="bats")$data 
lit_search(datasetKey="50c9509d-22c7-4a22-a47d-8c48425ef4a7")
lit_search(year=2020)
lit_search(year="2011,2020") # year ranges
lit_search(relevance=c("GBIF_CITED","GBIF_USED")) # multiple values
lit_search(relevance=c("GBIF_USED","GBIF_CITED"), 
topics=c("EVOLUTION","PHYLOGENETICS"))
lit_count() # total number of literature referencing GBIF
lit_count(peerReview=TRUE)
# number of citations of iNaturalist 
lit_count(datasetKey="50c9509d-22c7-4a22-a47d-8c48425ef4a7")
# number of peer-reviewed articles used GBIF mediated data
lit_count(peerReview=TRUE,literatureType="JOURNAL",relevance="GBIF_USED")
 
# Typically what is meant by "literature that uses GBIF" 
lit_search(peerReview=TRUE,literatureType="JOURNAL",relevance="GBIF_USED")
lit_count(peerReview=TRUE,literatureType="JOURNAL",relevance="GBIF_USED")

## End(Not run)
</code></pre>

<hr>
<h2 id='map_fetch'>Fetch maps of GBIF occurrences</h2><span id='topic+map_fetch'></span>

<h3>Description</h3>

<p>This function is a wrapper for the GBIF mapping api version 2.0.
The mapping API is a web map tile service making it straightforward to
visualize GBIF content on interactive maps, and overlay content from other
sources. It returns tile maps with number of
GBIF records per area unit that can be used in a variety of ways, for example
in interactive leaflet web maps. Map details are specified by a number of
query parameters, some of them optional. Full documentation of the GBIF
mapping api can be found at https://www.gbif.org/developer/maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_fetch(
  source = "density",
  x = 0:1,
  y = 0,
  z = 0,
  format = "@1x.png",
  srs = "EPSG:4326",
  bin = NULL,
  hexPerTile = NULL,
  squareSize = NULL,
  style = NULL,
  taxonKey = NULL,
  datasetKey = NULL,
  country = NULL,
  publishingOrg = NULL,
  publishingCountry = NULL,
  year = NULL,
  basisOfRecord = NULL,
  return = "png",
  base_style = NULL,
  plot_terra = TRUE,
  curlopts = list(http_version = 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_fetch_+3A_source">source</code></td>
<td>
<p>(character) Either <code>density</code> for fast, precalculated tiles,
or <code>adhoc</code> for any search. Default: <code>density</code></p>
</td></tr>
<tr><td><code id="map_fetch_+3A_x">x</code></td>
<td>
<p>(integer sequence) the column. Default: 0:1</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_y">y</code></td>
<td>
<p>(integer sequence) the row. Default: 0</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_z">z</code></td>
<td>
<p>(integer) the zoom. Default: 0</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_format">format</code></td>
<td>
<p>(character) The data format, one of:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;@Hx.png&#8288;</code> for a 256px raster tile
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;@1x.png&#8288;</code> for a 512px raster tile (the default)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;@2x.png&#8288;</code> for a 1024px raster tile
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;@3x.png&#8288;</code> for a 2048px raster tile
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;@4x.png&#8288;</code> for a 4096px raster tile
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_fetch_+3A_srs">srs</code></td>
<td>
<p>(character) Spatial reference system. One of:
</p>

<ul>
<li> <p><code>EPSG:3857</code> (Web Mercator)
</p>
</li>
<li> <p><code>EPSG:4326</code> (WGS84 plate care?)
</p>
</li>
<li> <p><code>EPSG:3575</code> (Arctic LAEA on 10 degrees E)
</p>
</li>
<li> <p><code>EPSG:3031</code> (Antarctic stereographic)
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_fetch_+3A_bin">bin</code></td>
<td>
<p>(character) <code>square</code> or <code>hex</code> to aggregate occurrence counts into
squares or hexagons. Points by default.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_hexpertile">hexPerTile</code></td>
<td>
<p>(integer) sets the size of the hexagons
(the number horizontally across a tile).</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_squaresize">squareSize</code></td>
<td>
<p>(integer) sets the size of the squares. Choose a factor
of 4096 so they tessalate correctly: probably from 8, 16, 32, 64, 128,
256, 512.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_style">style</code></td>
<td>
<p>(character) for raster tiles, choose from the available styles.
Defaults to classic.point for source=&quot;density&quot; and &quot;scaled.circle&quot; for source=&quot;adhoc&quot;.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_taxonkey">taxonKey</code></td>
<td>
<p>(integer/numeric/character) search by taxon key, can only
supply 1.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_datasetkey">datasetKey</code></td>
<td>
<p>(character) search by taxon key, can only supply 1.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_country">country</code></td>
<td>
<p>(character) search by taxon key, can only supply 1.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_publishingorg">publishingOrg</code></td>
<td>
<p>(character) search by taxon key, can only supply 1.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_publishingcountry">publishingCountry</code></td>
<td>
<p>(character) search by taxon key, can only
supply 1.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_year">year</code></td>
<td>
<p>(integer) integer that limits the search to a certain year or,
if passing a vector of integers, multiple years, for example
<code>1984</code> or <code>c(2016, 2017, 2018)</code> or <code>2010:2015</code> (years 2010 to 2015). optional</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_basisofrecord">basisOfRecord</code></td>
<td>
<p>(character) one or more basis of record states to
include records with that basis of record. The full list is: <code>c("OBSERVATION", "HUMAN_OBSERVATION", "MACHINE_OBSERVATION", "MATERIAL_SAMPLE", "PRESERVED_SPECIMEN", "FOSSIL_SPECIMEN", "LIVING_SPECIMEN", "LITERATURE", "UNKNOWN")</code>.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_return">return</code></td>
<td>
<p>(character) Either &quot;png&quot; or &quot;terra&quot;.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_base_style">base_style</code></td>
<td>
<p>(character)  The style of the base map.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_plot_terra">plot_terra</code></td>
<td>
<p>(logical) Set whether the terra map be default plotted.</p>
</td></tr>
<tr><td><code id="map_fetch_+3A_curlopts">curlopts</code></td>
<td>
<p>options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
<tr><td><code id="map_fetch_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the adhoc interface.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default settings, <code>return='png'</code>, will return a <code>magick-image</code>
png. This image will be a composite image of the the occurrence tiles fetched
and a base map. This map is primarily useful as a high quality image of
occurrence records.
</p>
<p>The args <code>x</code> and <code>y</code> can both be integer sequences. For example, <code>x=0:3</code> or
<code>y=0:1</code>. Note that the tile index starts at 0. Higher values of <code>z</code>, will
will produce more tiles that can be fetched and stitched together. Selecting
a too high value for <code>x</code> or <code>y</code> will produce a blank image.
</p>
<p>Setting <code>return='terra'</code> will return a <code>terra::SpatRaster </code> object. This
is primarily useful if you were interested in the underlying aggregated
occurrence density data.
</p>
<p>See the article
</p>


<h3>Value</h3>

<p>a <code>magick-image</code> or <code>terra::SpatRaster </code> object.
</p>


<h3>Author(s)</h3>

<p>John Waller and Laurens Geffert <a href="mailto:laurensgeffert@gmail.com">laurensgeffert@gmail.com</a>
</p>


<h3>References</h3>

<p>https://www.gbif.org/developer/maps
</p>
<p>https://api.gbif.org/v2/map/demo.html
</p>
<p>https://api.gbif.org/v2/map/demo13.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvt_fetch">mvt_fetch()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# all occurrences
map_fetch()
# get artic map
map_fetch(srs='EPSG:3031') 
# only preserved specimens
map_fetch(basisOfRecord="PRESERVED_SPECIMEN")

# Map of occ in Great Britain
map_fetch(z=3,y=1,x=7:8,country="GB")
# Peguins with artic projection
map_fetch(srs='EPSG:3031',taxonKey=2481660,style='glacier.point', 
base_style="gbif-dark")

# occ from a long time ago
map_fetch(year=1600) 
# polygon style 
map_fetch(style="iNaturalist.poly",bin="hex")
# iNaturalist dataset plotted 
map_fetch(datasetKey="50c9509d-22c7-4a22-a47d-8c48425ef4a7",
  style="iNaturalist.poly")
 
# use source="adhoc" for more filters
map_fetch(z=1,
  source="adhoc",
  iucn_red_list_category="CR",
  style="scaled.circles",
  base_style='gbif-light')

# cropped map of Hawaii
map_fetch(z=5,x=3:4,y=12,source="adhoc",gadmGid="USA.12_1")



## End(Not run)
</code></pre>

<hr>
<h2 id='mvt_fetch'>Fetch Map Vector Tiles (MVT)</h2><span id='topic+mvt_fetch'></span>

<h3>Description</h3>

<p>This function is a wrapper for the GBIF mapping api version 2.0.
The mapping API is a web map tile service making it straightforward to
visualize GBIF content on interactive maps, and overlay content from other
sources. It returns maps vector tiles with number of
GBIF records per area unit that can be used in a variety of ways, for example
in interactive leaflet web maps. Map details are specified by a number of
query parameters, some of them optional. Full documentation of the GBIF
mapping api can be found at https://www.gbif.org/developer/maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvt_fetch(
  source = "density",
  x = 0,
  y = 0,
  z = 0,
  srs = "EPSG:4326",
  bin = NULL,
  hexPerTile = NULL,
  squareSize = NULL,
  style = "classic.point",
  taxonKey = NULL,
  datasetKey = NULL,
  country = NULL,
  publishingOrg = NULL,
  publishingCountry = NULL,
  year = NULL,
  basisOfRecord = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvt_fetch_+3A_source">source</code></td>
<td>
<p>(character) Either <code>density</code> for fast, precalculated tiles,
or <code>adhoc</code> for any search. Default: <code>density</code></p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_x">x</code></td>
<td>
<p>(integer) the column. Default: 0</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_y">y</code></td>
<td>
<p>(integer) the row. Default: 0</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_z">z</code></td>
<td>
<p>(integer) the zoom. Default: 0</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_srs">srs</code></td>
<td>
<p>(character) Spatial reference system for the output (input srs for mvt
from GBIF is always <code>EPSG:3857</code>). One of:
</p>

<ul>
<li> <p><code>EPSG:3857</code> (Web Mercator)
</p>
</li>
<li> <p><code>EPSG:4326</code> (WGS84 plate care?)
</p>
</li>
<li> <p><code>EPSG:3575</code> (Arctic LAEA on 10 degrees E)
</p>
</li>
<li> <p><code>EPSG:3031</code> (Antarctic stereographic)
</p>
</li></ul>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_bin">bin</code></td>
<td>
<p>(character) <code>square</code> or <code>hex</code> to aggregate occurrence counts into
squares or hexagons. Points by default. optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_hexpertile">hexPerTile</code></td>
<td>
<p>(integer) sets the size of the hexagons
(the number horizontally across a tile). optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_squaresize">squareSize</code></td>
<td>
<p>(integer) sets the size of the squares. Choose a factor
of 4096 so they tessalate correctly: probably from 8, 16, 32, 64, 128,
256, 512. optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_style">style</code></td>
<td>
<p>(character) for raster tiles, choose from the available styles.
Defaults to classic.point. optional. THESE DON'T WORK YET.</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_taxonkey">taxonKey</code></td>
<td>
<p>(integer/numeric/character) search by taxon key, can only
supply 1. optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_datasetkey">datasetKey</code></td>
<td>
<p>(character) search by taxon key, can only supply 1.
optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_country">country</code></td>
<td>
<p>(character) search by taxon key, can only supply 1.
optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_publishingorg">publishingOrg</code></td>
<td>
<p>(character) search by taxon key, can only supply 1.
optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_publishingcountry">publishingCountry</code></td>
<td>
<p>(character) search by taxon key, can only
supply 1. optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_year">year</code></td>
<td>
<p>(integer) integer that limits the search to a certain year or,
if passing a vector of integers, multiple years, for example
<code>1984</code> or <code>c(2016, 2017, 2018)</code> or <code>2010:2015</code> (years 2010 to 2015). optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_basisofrecord">basisOfRecord</code></td>
<td>
<p>(character) one or more basis of record states to
include records with that basis of record. The full list is: <code>c("OBSERVATION", "HUMAN_OBSERVATION", "MACHINE_OBSERVATION", "MATERIAL_SAMPLE", "PRESERVED_SPECIMEN", "FOSSIL_SPECIMEN", "LIVING_SPECIMEN", "LITERATURE", "UNKNOWN")</code>. optional</p>
</td></tr>
<tr><td><code id="mvt_fetch_+3A_...">...</code></td>
<td>
<p>curl options passed on to <a href="crul.html#topic+HttpClient">crul::HttpClient</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the arguments passed on to generate a query
to the GBIF web map API. The API returns a web tile object as png that is
read and converted into an R raster object. The break values or nbreaks
generate a custom colour palette for the web tile, with each bin
corresponding to one grey value. After retrieval, the raster is reclassified
to the actual break values. This is a somewhat hacky but nonetheless
functional solution in the absence of a GBIF raster API implementation.
</p>
<p>We add extent and set the projection for the output. You can reproject
after retrieving the output.
</p>


<h3>Value</h3>

<p>an sf object
</p>


<h3>References</h3>

<p>https://www.gbif.org/developer/maps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+map_fetch">map_fetch()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (
 requireNamespace("sf", quietly = TRUE) &amp;&amp;
 requireNamespace("protolite", quietly = TRUE)
) {
  x &lt;- mvt_fetch(taxonKey = 2480498, year = 2007:2011)
  x
  
  # gives an sf object
  class(x)
  
  # different srs
  ## 3857
  y &lt;- mvt_fetch(taxonKey = 2480498, year = 2010, srs = "EPSG:3857")
  y
  ## 3031
  z &lt;- mvt_fetch(taxonKey = 2480498, year = 2010, srs = "EPSG:3031", verbose = TRUE)
  z
  # 3575
  z &lt;- mvt_fetch(taxonKey = 2480498, year = 2010, srs = "EPSG:3575")
  z

  # bin
  x &lt;- mvt_fetch(taxonKey = 212, year = 1998, bin = "hex",
     hexPerTile = 30, style = "classic-noborder.poly")
  x

  # query with basisOfRecord
  mvt_fetch(taxonKey = 2480498, year = 2010,
    basisOfRecord = "HUMAN_OBSERVATION")
  mvt_fetch(taxonKey = 2480498, year = 2010,
    basisOfRecord = c("HUMAN_OBSERVATION", "LIVING_SPECIMEN"))
 }

## End(Not run)
</code></pre>

<hr>
<h2 id='name_backbone'>Lookup names in the GBIF backbone taxonomy.</h2><span id='topic+name_backbone'></span><span id='topic+name_backbone_verbose'></span>

<h3>Description</h3>

<p>Lookup names in the GBIF backbone taxonomy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_backbone(
  name,
  rank = NULL,
  kingdom = NULL,
  phylum = NULL,
  class = NULL,
  order = NULL,
  family = NULL,
  genus = NULL,
  strict = FALSE,
  verbose = FALSE,
  start = NULL,
  limit = 100,
  curlopts = list()
)

name_backbone_verbose(
  name,
  rank = NULL,
  kingdom = NULL,
  phylum = NULL,
  class = NULL,
  order = NULL,
  family = NULL,
  genus = NULL,
  strict = FALSE,
  start = NULL,
  limit = 100,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_backbone_+3A_name">name</code></td>
<td>
<p>(character) Full scientific name potentially with authorship
(required)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_rank">rank</code></td>
<td>
<p>(character) The rank given as our rank enum. (optional)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_kingdom">kingdom</code></td>
<td>
<p>(character) If provided default matching will also try to
match against this if no direct match is found for the name alone.
(optional)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_phylum">phylum</code></td>
<td>
<p>(character) If provided default matching will also try to
match against this if no direct match is found for the name alone.
(optional)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_class">class</code></td>
<td>
<p>(character) If provided default matching will also try to
match against this if no direct match is found for the name alone.
(optional)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_order">order</code></td>
<td>
<p>(character) If provided default matching will also try to
match against this if no direct match is found for the name alone.
(optional)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_family">family</code></td>
<td>
<p>(character) If provided default matching will also try to
match against this if no direct match is found for the name alone.
(optional)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_genus">genus</code></td>
<td>
<p>(character) If provided default matching will also try to
match against this if no direct match is found for the name alone.
(optional)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_strict">strict</code></td>
<td>
<p>(logical) If <code>TRUE</code> it (fuzzy) matches only the given name,
but never a taxon in the upper classification (optional)</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_verbose">verbose</code></td>
<td>
<p>(logical) should the function give back more (less reliable)
results. See function <code>name_backbone_verbose()</code></p>
</td></tr>
<tr><td><code id="name_backbone_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0. Use in combination
with <code>limit</code> to page through results.</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100. Maximum: 1000.</p>
</td></tr>
<tr><td><code id="name_backbone_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you don't get a match, GBIF gives back a data.frame with columns
<code>synonym</code>, <code>confidence</code>, and <code>matchType='NONE'</code>.
</p>


<h3>Value</h3>

<p>For <code>name_backbone</code>, a data.frame for a single taxon with many
columns. For <code>name_backbone_verbose</code>, a larger number of results in a
data.frame the results of resulting from fuzzy matching.
You will also get back your input name, rank, kingdom, phylum ect. as
columns input_name, input_rank, input_kingdom ect. so you can check the
results.
</p>


<h3>References</h3>

<p><a href="https://www.gbif.org/developer/species#searching">https://www.gbif.org/developer/species#searching</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
name_backbone(name='Helianthus annuus', kingdom='plants')
name_backbone(name='Helianthus', rank='genus', kingdom='plants')
name_backbone(name='Poa', rank='genus', family='Poaceae')

# Verbose - gives back alternatives
## Strictness
name_backbone_verbose(name='Poa', kingdom='plants',
  strict=FALSE)
name_backbone_verbose(name='Helianthus annuus', kingdom='plants',
  strict=TRUE)

# Non-existent name - returns list of lenght 3 stating no match
name_backbone(name='Aso')
name_backbone(name='Oenante')

# Pass on curl options
name_backbone(name='Oenante', curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='name_backbone_checklist'>Lookup names in the GBIF backbone taxonomy in a checklist.</h2><span id='topic+name_backbone_checklist'></span>

<h3>Description</h3>

<p>Lookup names in the GBIF backbone taxonomy in a checklist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_backbone_checklist(
  name_data = NULL,
  rank = NULL,
  kingdom = NULL,
  phylum = NULL,
  class = NULL,
  order = NULL,
  family = NULL,
  genus = NULL,
  strict = FALSE,
  verbose = FALSE,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_backbone_checklist_+3A_name_data">name_data</code></td>
<td>
<p>(data.frame or vector) see details.</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_rank">rank</code></td>
<td>
<p>(character) default value (optional).</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_kingdom">kingdom</code></td>
<td>
<p>(character) default value (optional).</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_phylum">phylum</code></td>
<td>
<p>(character) default value (optional).</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_class">class</code></td>
<td>
<p>(character) default value (optional).</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_order">order</code></td>
<td>
<p>(character) default value (optional).</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_family">family</code></td>
<td>
<p>(character) default value (optional).</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_genus">genus</code></td>
<td>
<p>(character) default value (optional).</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_strict">strict</code></td>
<td>
<p>(logical) strict=TRUE will not attempt to fuzzy match or
return higherrankmatches.</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_verbose">verbose</code></td>
<td>
<p>(logical) If true it shows alternative matches which were
considered but then rejected.</p>
</td></tr>
<tr><td><code id="name_backbone_checklist_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an alternative for  <code>name_backbone()</code>, which will work with
a list of names (a vector or a data.frame). The data.frame should have the
following column names, but <strong>only the 'name' column is required</strong>. If only
one column is present, then that column is assumed to be the 'name' column.
</p>

<ul>
<li> <p><strong>name</strong> : (required)
</p>
</li>
<li> <p><strong>rank</strong> : (optional)
</p>
</li>
<li> <p><strong>kingdom</strong> : (optional)
</p>
</li>
<li> <p><strong>phylum</strong> : (optional)
</p>
</li>
<li> <p><strong>class</strong> : (optional)
</p>
</li>
<li> <p><strong>order</strong> : (optional)
</p>
</li>
<li> <p><strong>family</strong> : (optional)
</p>
</li>
<li> <p><strong>genus</strong> : (optional)
</p>
</li></ul>

<p>The input columns will be returned as &quot;verbatim_name&quot;,&quot;verbatim_rank&quot;,
&quot;verbatim_phylum&quot; ect. A column of &quot;verbatim_index&quot; will also be returned
giving the index of the input.
</p>
<p>The following aliases for the 'name' column will work (any case or with '_'
will work) :
</p>

<ul>
<li><p> &quot;scientificName&quot;, &quot;ScientificName&quot;, &quot;scientific_name&quot; ...
</p>
</li>
<li><p> &quot;sci_name&quot;, &quot;sciname&quot;, &quot;SCI_NAME&quot; ...
</p>
</li>
<li><p> &quot;names&quot;, &quot;NAMES&quot; ...
</p>
</li>
<li><p> &quot;species&quot;, &quot;SPECIES&quot; ...
</p>
</li>
<li><p> &quot;species_name&quot;, &quot;speciesname&quot; ...
</p>
</li>
<li><p> &quot;sp_name&quot;, &quot;SP_NAME&quot;, &quot;spname&quot; ...
</p>
</li>
<li><p> &quot;taxon_name&quot;, &quot;taxonname&quot;, &quot;TAXON NAME&quot; ...
</p>
</li></ul>

<p>If more than one aliases is present and no column is named 'name', then the
left-most column with an acceptable aliased name above is used.
</p>
<p>If <code>verbose=TRUE</code>, a column called <code>is_alternative</code> will be returned,
which species if a name was originally a first choice or not.
<code>is_alternative=TRUE</code> means the name was not is not considered to be
the best match by GBIF.
</p>
<p>Default values for rank, kingdom, phylum, class, order, family, and genus can
can be supplied. If a default value is supplied, the values for these fields
are ignored in name_data, and the default value is used instead. This is most
useful if you have a list of names and you know they are all plants, insects,
birds, ect. You can also input multiple values, if they are the same length as
list of names you are trying to match.
</p>
<p>This function can also be used with a character vector of names. In that case
no column names are needed of course.
</p>
<p>This function is very similar to the GBIF species-lookup tool.
<a href="https://www.gbif.org/tools/species-lookup">https://www.gbif.org/tools/species-lookup</a>.
</p>
<p>If you have 1000s of names to match, it can take some minutes to get back all
of the matches. I have tested it with 60K names. Scientific names with author details
usually get better matches.
</p>
<p>See also article <a href="https://docs.ropensci.org/rgbif/articles/taxonomic_names.html">Working With Taxonomic Names</a>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of matched names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(rgbif)

name_data &lt;- data.frame(
 scientificName = c(
   "Cirsium arvense (L.) Scop.", # a plant
   "Calopteryx splendens (Harris, 1780)", # an insect
   "Puma concolor (Linnaeus, 1771)", # a big cat
   "Ceylonosticta alwisi (Priyadarshana &amp; Wijewardhane, 2016)", # newly discovered insect 
   "Puma concuolor (Linnaeus, 1771)", # a mis-spelled big cat
   "Fake species (John Waller 2021)", # a fake species
   "Calopteryx" # Just a Genus   
 ), description = c(
   "a plant",
   "an insect",
   "a big cat",
   "newly discovered insect",
   "a mis-spelled big cat",
   "a fake species",
   "just a GENUS"
 ), 
 kingdom = c(
   "Plantae",
   "Animalia",
   "Animalia",
   "Animalia",
   "Animalia",
   "Johnlia",
   "Animalia"
 ))

name_backbone_checklist(name_data)

# return more than 1 result per name
name_backbone_checklist(name_data,verbose=TRUE) 

# works with just vectors too 
name_list &lt;- c(
"Cirsium arvense (L.) Scop.", 
"Calopteryx splendens (Harris, 1780)", 
"Puma concolor (Linnaeus, 1771)", 
"Ceylonosticta alwisi (Priyadarshana &amp; Wijewardhane, 2016)", 
"Puma concuolor", 
"Fake species (John Waller 2021)", 
"Calopteryx")

name_backbone_checklist(name_list)
name_backbone_checklist(name_list,verbose=TRUE)
name_backbone_checklist(name_list,strict=TRUE) 

# default values
name_backbone_checklist(c("Aloe arborecens Mill.",
"Cirsium arvense (L.) Scop."),kingdom="Plantae")
name_backbone_checklist(c("Aloe arborecens Mill.",
"Calopteryx splendens (Harris, 1780)"),kingdom=c("Plantae","Animalia"))


## End(Not run)

</code></pre>

<hr>
<h2 id='name_issues'>Parse and examine further GBIF name issues on a dataset.</h2><span id='topic+name_issues'></span>

<h3>Description</h3>

<p>Parse and examine further GBIF name issues on a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_issues(.data, ..., mutate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_issues_+3A_.data">.data</code></td>
<td>
<p>Output from a call to <code><a href="#topic+name_usage">name_usage()</a></code></p>
</td></tr>
<tr><td><code id="name_issues_+3A_...">...</code></td>
<td>
<p>Named parameters to only get back (e.g. bbmn), or to
remove (e.g. -bbmn).</p>
</td></tr>
<tr><td><code id="name_issues_+3A_mutate">mutate</code></td>
<td>
<p>(character) One of:
</p>

<ul>
<li> <p><code>split</code> Split issues into new columns.
</p>
</li>
<li> <p><code>expand</code> Expand issue abbreviated codes into descriptive names.
for downloads datasets, this is not super useful since the
issues come to you as expanded already.
</p>
</li>
<li> <p><code>split_expand</code> Split into new columns, and expand issue names.
</p>
</li></ul>

<p>For split and split_expand, values in cells become y (&quot;yes&quot;) or n (&quot;no&quot;)</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/NameUsageIssue.html">https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/NameUsageIssue.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# what do issues mean, can print whole table
head(gbif_issues())
# or just name related issues
gbif_issues()[which(gbif_issues()$type %in% c("name")),]
# or search for matches
gbif_issues()[gbif_issues()$code %in% c('bbmn','clasna','scina'),]
# compare out data to after name_issues use
(aa &lt;- name_usage(name = "Lupus"))
aa %&gt;% name_issues("clasna")

## or parse issues in various ways
### remove data rows with certain issue classes
aa %&gt;% name_issues(-clasna, -scina)

### expand issues to more descriptive names
aa %&gt;% name_issues(mutate = "expand")

### split and expand
aa %&gt;% name_issues(mutate = "split_expand")

### split, expand, and remove an issue class
aa %&gt;% name_issues(-bbmn, mutate = "split_expand")

## Or you can use name_issues without %&gt;%
name_issues(aa, -bbmn, mutate = "split_expand")

## End(Not run)
</code></pre>

<hr>
<h2 id='name_lookup'>Lookup names in all taxonomies in GBIF.</h2><span id='topic+name_lookup'></span>

<h3>Description</h3>

<p>This service uses fuzzy lookup so that you can put in partial names and
you should get back those things that match. See examples below.
</p>
<p>Faceting: If <code>facet=FALSE</code> or left to the default (NULL), no faceting
is done. And therefore, all parameters with facet in their name are
ignored (facetOnly, facetMincount, facetMultiselect).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_lookup(
  query = NULL,
  rank = NULL,
  higherTaxonKey = NULL,
  status = NULL,
  isExtinct = NULL,
  habitat = NULL,
  nameType = NULL,
  datasetKey = NULL,
  origin = NULL,
  nomenclaturalStatus = NULL,
  limit = 100,
  start = 0,
  facet = NULL,
  facetMincount = NULL,
  facetMultiselect = NULL,
  type = NULL,
  hl = NULL,
  issue = NULL,
  constituentKey = NULL,
  verbose = FALSE,
  return = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_lookup_+3A_query">query</code></td>
<td>
<p>Query term(s) for full text search.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_rank">rank</code></td>
<td>
<p>CLASS, CULTIVAR, CULTIVAR_GROUP, DOMAIN, FAMILY, FORM, GENUS,
INFORMAL, INFRAGENERIC_NAME, INFRAORDER, INFRASPECIFIC_NAME,
INFRASUBSPECIFIC_NAME, KINGDOM, ORDER, PHYLUM, SECTION, SERIES, SPECIES,
STRAIN, SUBCLASS, SUBFAMILY, SUBFORM, SUBGENUS, SUBKINGDOM, SUBORDER,
SUBPHYLUM, SUBSECTION, SUBSERIES, SUBSPECIES, SUBTRIBE, SUBVARIETY,
SUPERCLASS, SUPERFAMILY, SUPERORDER, SUPERPHYLUM, SUPRAGENERIC_NAME,
TRIBE, UNRANKED, VARIETY</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_highertaxonkey">higherTaxonKey</code></td>
<td>
<p>Filters by any of the higher Linnean rank keys. Note
this is within the respective checklist and not searching nub keys
across all checklists. This parameter accepts many inputs in a vector (
passed in the same request).</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_status">status</code></td>
<td>
<p>Filters by the taxonomic status as one of:
</p>

<ul>
<li><p> ACCEPTED
</p>
</li>
<li><p> DETERMINATION_SYNONYM Used for unknown child taxa referred to via
spec, ssp, ...
</p>
</li>
<li><p> DOUBTFUL Treated as accepted, but doubtful whether this is correct.
</p>
</li>
<li><p> HETEROTYPIC_SYNONYM More specific subclass of SYNONYM.
</p>
</li>
<li><p> HOMOTYPIC_SYNONYM More specific subclass of SYNONYM.
</p>
</li>
<li><p> INTERMEDIATE_RANK_SYNONYM Used in nub only.
</p>
</li>
<li><p> MISAPPLIED More specific subclass of SYNONYM.
</p>
</li>
<li><p> PROPARTE_SYNONYM More specific subclass of SYNONYM.
</p>
</li>
<li><p> SYNONYM A general synonym, the exact type is unknown.
</p>
</li></ul>
</td></tr>
<tr><td><code id="name_lookup_+3A_isextinct">isExtinct</code></td>
<td>
<p>(logical) Filters by extinction status (e.g.
<code>isExtinct=TRUE</code>)</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_habitat">habitat</code></td>
<td>
<p>(character) Filters by habitat. One of: marine, freshwater,
or terrestrial</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_nametype">nameType</code></td>
<td>
<p>Filters by the name type as one of:
</p>

<ul>
<li><p> BLACKLISTED surely not a scientific name.
</p>
</li>
<li><p> CANDIDATUS Candidatus is a component of the taxonomic name for a
bacterium that cannot be maintained in a Bacteriology Culture Collection.
</p>
</li>
<li><p> CULTIVAR a cultivated plant name.
</p>
</li>
<li><p> DOUBTFUL doubtful whether this is a scientific name at all.
</p>
</li>
<li><p> HYBRID a hybrid formula (not a hybrid name).
</p>
</li>
<li><p> INFORMAL a scientific name with some informal addition like &quot;cf.&quot; or
indetermined like Abies spec.
</p>
</li>
<li><p> SCINAME a scientific name which is not well formed.
</p>
</li>
<li><p> VIRUS a virus name.
</p>
</li>
<li><p> WELLFORMED a well formed scientific name according to present
nomenclatural rules.
</p>
</li></ul>
</td></tr>
<tr><td><code id="name_lookup_+3A_datasetkey">datasetKey</code></td>
<td>
<p>Filters by the dataset's key (a uuid)</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_origin">origin</code></td>
<td>
<p>(character) Filters by origin. One of:
</p>

<ul>
<li><p> SOURCE
</p>
</li>
<li><p> DENORMED_CLASSIFICATION
</p>
</li>
<li><p> VERBATIM_ACCEPTED
</p>
</li>
<li><p> EX_AUTHOR_SYNONYM
</p>
</li>
<li><p> AUTONYM
</p>
</li>
<li><p> BASIONYM_PLACEHOLDER
</p>
</li>
<li><p> MISSING_ACCEPTED
</p>
</li>
<li><p> IMPLICIT_NAME
</p>
</li>
<li><p> PROPARTE
</p>
</li>
<li><p> VERBATIM_BASIONYM
</p>
</li></ul>
</td></tr>
<tr><td><code id="name_lookup_+3A_nomenclaturalstatus">nomenclaturalStatus</code></td>
<td>
<p>Not yet implemented, but will eventually allow
for filtering by a nomenclatural status enum.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_limit">limit</code></td>
<td>
<p>Number of records to return.
Hard maximum limit set by GBIF API: 99999.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_facet">facet</code></td>
<td>
<p>A vector/list of facet names used to retrieve the 100 most
frequent values for a field. Allowed facets are: datasetKey, higherTaxonKey,
rank, status, isExtinct, habitat, and nameType. Additionally threat and
nomenclaturalStatus are legal values but not yet implemented, so data will
not yet be returned for them.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_facetmincount">facetMincount</code></td>
<td>
<p>Used in combination with the facet parameter. Set
facetMincount to exclude facets with a count less than x, e.g.
http://bit.ly/2osAUQB only shows the type values 'CHECKLIST' and 'OCCURRENCE'
because the other types have counts less than 10000</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_facetmultiselect">facetMultiselect</code></td>
<td>
<p>(logical) Used in combination with the facet
parameter. Set <code>facetMultiselect=TRUE</code> to still return counts for
values that are not currently filtered, e.g. http://bit.ly/2JAymaC still
shows all type values even though type is being filtered
by <code>type=CHECKLIST</code>.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_type">type</code></td>
<td>
<p>Type of name. One of occurrence, checklist, or metadata.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_hl">hl</code></td>
<td>
<p>(logical) Set <code>hl=TRUE</code> to highlight terms matching the query
when in fulltext search fields. The highlight will be an emphasis tag of
class <code>gbifH1</code> e.g. <code>query='plant', hl=TRUE</code>. Fulltext search
fields include: title, keyword, country, publishing country, publishing
organization title, hosting organization title, and description. One
additional full text field is searched which includes information from
metadata documents, but the text of this field is not returned in the
response.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_issue">issue</code></td>
<td>
<p>Filters by issue. Issue has to be related to names. Type
<code>gbif_issues()</code> to get complete list of issues.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_constituentkey">constituentKey</code></td>
<td>
<p>Filters by the dataset's constituent key (a uuid).</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_verbose">verbose</code></td>
<td>
<p>(logical) If <code>TRUE</code>, all data is returned as a list for each
element. If <code>FALSE</code> (default) a subset of the data that is thought to be most
essential is organized into a data.frame.</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_return">return</code></td>
<td>
<p>Defunct. All components are returned; index to the
one(s) you want</p>
</td></tr>
<tr><td><code id="name_lookup_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class gbif, which is a S3 class list, with slots for
metadata (<code>meta</code>), the data itself (<code>data</code>), the taxonomic
hierarchy data (<code>hierarchies</code>), and vernacular names (<code>names</code>).
In addition, the object has attributes listing the user supplied arguments
and type of search, which is, differently from occurrence data, always
equals to 'single' even if multiple values for some parameters are given.
<code>meta</code> is a list of length four with offset, limit, endOfRecords and
count fields. <code>data</code> is a tibble (aka data.frame) containing all
information about the found taxa. <code>hierarchies</code> is a list of
data.frame's, one per GBIF key (taxon), containing its taxonomic
classification. Each data.frame contains two columns: <code>rankkey</code> and
<code>name</code>. <code>names</code> returns a list of data.frame's, one per GBIF key
(taxon), containing all vernacular names. Each data.frame contains two
columns: <code>vernacularName</code> and <code>language</code>.
</p>
<p>A list of length five:
</p>

<ul>
<li> <p><strong>metadata</strong>
</p>
</li>
<li> <p><strong>data</strong>: either a data.frame (<code>verbose=FALSE</code>, default) or a list (<code>verbose=TRUE</code>).
</p>
</li>
<li> <p><strong>facets</strong>
</p>
</li>
<li> <p><strong>hierarchies</strong>
</p>
</li>
<li> <p><strong>names</strong>
</p>
</li></ul>



<h3>Repeat parameter inputs</h3>

<p>Some parameters can take many inputs, and treated as 'OR' (e.g., a or b or
c). The following take many inputs:
</p>

<ul>
<li> <p><strong>rank</strong>
</p>
</li>
<li> <p><strong>higherTaxonKey</strong>
</p>
</li>
<li> <p><strong>status</strong>
</p>
</li>
<li> <p><strong>habitat</strong>
</p>
</li>
<li> <p><strong>nameType</strong>
</p>
</li>
<li> <p><strong>datasetKey</strong>
</p>
</li>
<li> <p><strong>origin</strong>
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.gbif.org/developer/species#searching">https://www.gbif.org/developer/species#searching</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Look up names like mammalia
name_lookup(query='mammalia', limit = 20)

# Start with an offset
name_lookup(query='mammalia', limit=1)
name_lookup(query='mammalia', limit=1, start=2)

# large requests (paging is internally implemented).
# hard maximum limit set by GBIF API: 99999
# name_lookup(query = "Carnivora", limit = 10000)

# Get all data and parse it, removing descriptions which can be quite long
out &lt;- name_lookup('Helianthus annuus', rank="species", verbose=TRUE)
lapply(out$data, function(x) {
  x[!names(x) %in% c("descriptions","descriptionsSerialized")]
})

# Search for a genus
name_lookup(query="Cnaemidophorus", rank="genus")
# Limit records to certain number
name_lookup('Helianthus annuus', rank="species", limit=2)

# Query by habitat
name_lookup(habitat = "terrestrial", limit=2)
name_lookup(habitat = "marine", limit=2)
name_lookup(habitat = "freshwater", limit=2)

# Using faceting
name_lookup(facet='status', limit=0, facetMincount='70000')
name_lookup(facet=c('status','higherTaxonKey'), limit=0,
  facetMincount='700000')

name_lookup(facet='nameType', limit=0)
name_lookup(facet='habitat', limit=0)
name_lookup(facet='datasetKey', limit=0)
name_lookup(facet='rank', limit=0)
name_lookup(facet='isExtinct', limit=0)

name_lookup(isExtinct=TRUE, limit=0)

# text highlighting
## turn on highlighting
res &lt;- name_lookup(query='canada', hl=TRUE, limit=5)
res$data
name_lookup(query='canada', hl=TRUE, limit=45)
## and you can pass the output to gbif_names() function
res &lt;- name_lookup(query='canada', hl=TRUE, limit=5)
gbif_names(res)

# Lookup by datasetKey (set up sufficient high limit, API maximum: 99999)
# name_lookup(datasetKey='3f8a1297-3259-4700-91fc-acc4170b27ce',
#   limit = 50000)

# Some parameters accept many inputs, treated as OR
name_lookup(rank = c("family", "genus"))
name_lookup(higherTaxonKey = c("119", "120", "121", "204"))
name_lookup(status = c("misapplied", "synonym"))$data
name_lookup(habitat = c("marine", "terrestrial"))
name_lookup(nameType = c("cultivar", "doubtful"))
name_lookup(datasetKey = c("73605f3a-af85-4ade-bbc5-522bfb90d847",
  "d7c60346-44b6-400d-ba27-8d3fbeffc8a5"))
name_lookup(datasetKey = "289244ee-e1c1-49aa-b2d7-d379391ce265",
  origin = c("SOURCE", "DENORMED_CLASSIFICATION"))

# Pass on curl options
name_lookup(query='Cnaemidophorus', rank="genus",
  curlopts = list(verbose = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='name_parse'>Parse taxon names using the GBIF name parser.</h2><span id='topic+name_parse'></span>

<h3>Description</h3>

<p>Parse taxon names using the GBIF name parser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_parse(scientificname, curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_parse_+3A_scientificname">scientificname</code></td>
<td>
<p>A character vector of scientific names.</p>
</td></tr>
<tr><td><code id="name_parse_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing fields extracted from parsed
taxon names. Fields returned are the union of fields extracted from
all species names in <code>scientificname</code>.
</p>


<h3>Author(s)</h3>

<p>John Baumgartner (johnbb@student.unimelb.edu.au)
</p>


<h3>References</h3>

<p><a href="https://www.gbif.org/developer/species#parser">https://www.gbif.org/developer/species#parser</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
name_parse(scientificname='x Agropogon littoralis')
name_parse(c('Arrhenatherum elatius var. elatius',
             'Secale cereale subsp. cereale', 'Secale cereale ssp. cereale',
             'Vanessa atalanta (Linnaeus, 1758)'))
name_parse("Ajuga pyramidata")
name_parse("Ajuga pyramidata x reptans")

# Pass on curl options
# res &lt;- name_parse(c('Arrhenatherum elatius var. elatius',
#          'Secale cereale subsp. cereale', 'Secale cereale ssp. cereale',
#          'Vanessa atalanta (Linnaeus, 1758)'), curlopts=list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='name_suggest'>Suggest up to 20 name usages.</h2><span id='topic+name_suggest'></span>

<h3>Description</h3>

<p>A quick and simple autocomplete service that returns up to 20 name
usages by doing prefix matching against the scientific name. Results
are ordered by relevance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_suggest(
  q = NULL,
  datasetKey = NULL,
  rank = NULL,
  fields = NULL,
  start = NULL,
  limit = 100,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_suggest_+3A_q">q</code></td>
<td>
<p>(character, required) Simple search parameter. The value for
this parameter can be a simple word or a phrase. Wildcards can be added to
the simple word parameters only, e.g. q=<em>puma</em></p>
</td></tr>
<tr><td><code id="name_suggest_+3A_datasetkey">datasetKey</code></td>
<td>
<p>(character) Filters by the checklist dataset key (a uuid,
see examples)</p>
</td></tr>
<tr><td><code id="name_suggest_+3A_rank">rank</code></td>
<td>
<p>(character) A taxonomic rank. One of class, cultivar,
cultivar_group, domain, family, form, genus, informal, infrageneric_name,
infraorder, infraspecific_name, infrasubspecific_name, kingdom, order,
phylum, section, series, species, strain, subclass, subfamily, subform,
subgenus, subkingdom, suborder, subphylum, subsection, subseries,
subspecies, subtribe, subvariety, superclass, superfamily, superorder,
superphylum, suprageneric_name, tribe, unranked, or variety.</p>
</td></tr>
<tr><td><code id="name_suggest_+3A_fields">fields</code></td>
<td>
<p>(character) Fields to return in output data.frame (simply
prunes columns off)</p>
</td></tr>
<tr><td><code id="name_suggest_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0. Use in combination
with <code>limit</code> to page through results.</p>
</td></tr>
<tr><td><code id="name_suggest_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100. Maximum: 1000.</p>
</td></tr>
<tr><td><code id="name_suggest_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with two elements <code>data</code> (tibble) and <code>hierarchy</code> (list of
data.frame's). If 'higherClassificationMap' is one of the <code>fields</code> requested,
then <code>hierarchy</code> is a list of data.frame's; if not included, <code>hierarchy</code>
is an empty list.
</p>


<h3>Repeat parmeter inputs</h3>

<p>Some parameters can take many inputs, and treated as 'OR' (e.g., a or b or
c). The following take many inputs:
</p>

<ul>
<li> <p><strong>rank</strong>
</p>
</li>
<li> <p><strong>datasetKey</strong>
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.gbif.org/developer/species#searching">https://www.gbif.org/developer/species#searching</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
name_suggest(q='Puma concolor')
name_suggest(q='Puma')
name_suggest(q='Puma', rank="genus")
name_suggest(q='Puma', rank="subspecies")
name_suggest(q='Puma', rank="species")
name_suggest(q='Puma', rank="infraspecific_name")

name_suggest(q='Puma', limit=2)
name_suggest(q='Puma', fields=c('key','canonicalName'))
name_suggest(q='Puma', fields=c('key','canonicalName',
  'higherClassificationMap'))

# Some parameters accept many inputs, treated as OR
name_suggest(rank = c("family", "genus"))
name_suggest(datasetKey = c("73605f3a-af85-4ade-bbc5-522bfb90d847",
  "d7c60346-44b6-400d-ba27-8d3fbeffc8a5"))

# If 'higherClassificationMap' in fields, a list is returned
name_suggest(q='Puma', fields=c('key','higherClassificationMap'))

# Pass on curl options
name_suggest(q='Puma', limit=200, curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='name_usage'>Lookup details for specific names in all taxonomies in GBIF.</h2><span id='topic+name_usage'></span>

<h3>Description</h3>

<p>Lookup details for specific names in all taxonomies in GBIF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_usage(
  key = NULL,
  name = NULL,
  data = "all",
  language = NULL,
  datasetKey = NULL,
  uuid = NULL,
  rank = NULL,
  shortname = NULL,
  start = 0,
  limit = 100,
  return = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_usage_+3A_key">key</code></td>
<td>
<p>(numeric or character) A GBIF key for a taxon</p>
</td></tr>
<tr><td><code id="name_usage_+3A_name">name</code></td>
<td>
<p>(character) Filters by a case insensitive, canonical namestring,
e.g. 'Puma concolor'</p>
</td></tr>
<tr><td><code id="name_usage_+3A_data">data</code></td>
<td>
<p>(character) Specify an option to select what data is returned.
See Description below.</p>
</td></tr>
<tr><td><code id="name_usage_+3A_language">language</code></td>
<td>
<p>(character) Language, default is english</p>
</td></tr>
<tr><td><code id="name_usage_+3A_datasetkey">datasetKey</code></td>
<td>
<p>(character) Filters by the dataset's key (a uuid). Must
be length=1</p>
</td></tr>
<tr><td><code id="name_usage_+3A_uuid">uuid</code></td>
<td>
<p>(character) A dataset key</p>
</td></tr>
<tr><td><code id="name_usage_+3A_rank">rank</code></td>
<td>
<p>(character) Taxonomic rank. Filters by taxonomic rank as
one of: CLASS, CULTIVAR, CULTIVAR_GROUP, DOMAIN, FAMILY, FORM, GENUS,
INFORMAL, INFRAGENERIC_NAME, INFRAORDER, INFRASPECIFIC_NAME,
INFRASUBSPECIFIC_NAME, KINGDOM, ORDER, PHYLUM, SECTION, SERIES, SPECIES,
STRAIN, SUBCLASS, SUBFAMILY, SUBFORM, SUBGENUS, SUBKINGDOM, SUBORDER,
SUBPHYLUM, SUBSECTION, SUBSERIES, SUBSPECIES, SUBTRIBE, SUBVARIETY,
SUPERCLASS, SUPERFAMILY, SUPERORDER, SUPERPHYLUM, SUPRAGENERIC_NAME,
TRIBE, UNRANKED, VARIETY</p>
</td></tr>
<tr><td><code id="name_usage_+3A_shortname">shortname</code></td>
<td>
<p>(character) A short name for a dataset - it may
not do anything</p>
</td></tr>
<tr><td><code id="name_usage_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0.</p>
</td></tr>
<tr><td><code id="name_usage_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100.</p>
</td></tr>
<tr><td><code id="name_usage_+3A_return">return</code></td>
<td>
<p>Defunct. All components are returned; index to the
one(s) you want</p>
</td></tr>
<tr><td><code id="name_usage_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This service uses fuzzy lookup so that you can put in partial names and
you should get back those things that match. See examples below.
</p>
<p>This function is different from <code><a href="#topic+name_lookup">name_lookup()</a></code> in that that function
searches for names. This function encompasses a bunch of API endpoints,
most of which require that you already have a taxon key, but there is one
endpoint that allows name searches (see examples below).
</p>
<p>Note that <code>data="verbatim"</code> hasn't been working.
</p>
<p>Options for the data parameter are: 'all', 'verbatim', 'name', 'parents',
'children', 'related', 'synonyms', 'descriptions','distributions', 'media',
'references', 'speciesProfiles', 'vernacularNames', 'typeSpecimens', 'root',
'iucnRedListCategory'
</p>
<p>This function used to be vectorized with respect to the <code>data</code>
parameter, where you could pass in multiple values and the function
internally loops over each option making separate requests. This has been
removed. You can still loop over many options for the <code>data</code> parameter,
just use an <code>lapply</code> family function, or a for loop, etc.
</p>
<p>See <code><a href="#topic+name_issues">name_issues()</a></code> for more information about issues in <code>issues</code> column.
</p>


<h3>Value</h3>

<p>An object of class gbif, which is a S3 class list, with slots for
metadata (<code>meta</code>) and the data itself (<code>data</code>). In addition, the
object has attributes listing the user supplied arguments and type of
search, which is, differently from occurrence data, always equals to
'single' even if multiple values for some parameters are given. <code>meta</code>
is a list of length four with offset, limit, endOfRecords and count fields.
<code>data</code> is a tibble (aka data.frame) containing all information about
the found taxa.
</p>


<h3>Repeat parameter inputs</h3>

<p>These parameters used to accept many inputs, but no longer do:
</p>

<ul>
<li> <p><strong>rank</strong>
</p>
</li>
<li> <p><strong>name</strong>
</p>
</li>
<li> <p><strong>langugae</strong>
</p>
</li>
<li> <p><strong>datasetKey</strong>
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.gbif.org/developer/species#nameUsages">https://www.gbif.org/developer/species#nameUsages</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A single name usage
name_usage(key=1)

# Name usage for a taxonomic name
name_usage(name='Puma', rank="GENUS")

# Name usage for all taxa in a dataset
# (set sufficient high limit, but less than 100000)
# name_usage(datasetKey = "9ff7d317-609b-4c08-bd86-3bc404b77c42", 
#  limit = 10000)
# All name usages
name_usage()

# References for a name usage
name_usage(key=2435099, data='references')

# Species profiles, descriptions
name_usage(key=3119195, data='speciesProfiles')
name_usage(key=3119195, data='descriptions')
name_usage(key=2435099, data='children')

# Vernacular names for a name usage
name_usage(key=3119195, data='vernacularNames')

# Limit number of results returned
name_usage(key=3119195, data='vernacularNames', limit=3)

# Search for names by dataset with datasetKey parameter
name_usage(datasetKey="d7dddbf4-2cf0-4f39-9b2a-bb099caae36c")

# Search for a particular language
name_usage(key=3119195, language="FRENCH", data='vernacularNames')

# get root usage with a uuid
name_usage(data = "root", uuid = "73605f3a-af85-4ade-bbc5-522bfb90d847")

# search by language
name_usage(language = "spanish")

# Pass on curl options
name_usage(name='Puma concolor', limit=300, curlopts = list(verbose=TRUE))

# look up iucn red list category 
name_usage(key = 7707728, data = 'iucnRedListCategory') 

## End(Not run)
</code></pre>

<hr>
<h2 id='network'>Get data about GBIF networks</h2><span id='topic+network'></span><span id='topic+network_constituents'></span>

<h3>Description</h3>

<p>Get data about GBIF networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network(
  data = "all",
  uuid = NULL,
  query = NULL,
  identifier = NULL,
  identifierType = NULL,
  limit = 100,
  start = NULL,
  curlopts = list()
)

network_constituents(uuid = NULL, limit = 100, start = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="network_+3A_data">data</code></td>
<td>
<p>The type of data to get. One or more of: 'contact', 'endpoint',
'identifier', 'tag', 'machineTag', 'comment', 'constituents', or the
special 'all'. Default: <code>'all'</code></p>
</td></tr>
<tr><td><code id="network_+3A_uuid">uuid</code></td>
<td>
<p>UUID of the data network provider. This must be specified if
data is anything other than 'all'. Only 1 can be passed in</p>
</td></tr>
<tr><td><code id="network_+3A_query">query</code></td>
<td>
<p>Query nodes. Only used when <code>data='all'</code>. Ignored
otherwise.</p>
</td></tr>
<tr><td><code id="network_+3A_identifier">identifier</code></td>
<td>
<p>The value for this parameter can be a simple string or
integer, e.g. <code>identifier=120</code>. This parameter doesn't seem to work right
now.</p>
</td></tr>
<tr><td><code id="network_+3A_identifiertype">identifierType</code></td>
<td>
<p>Used in combination with the identifier parameter to
filter identifiers by identifier type. See details. This parameter doesn't
seem to work right now.</p>
</td></tr>
<tr><td><code id="network_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100. Maximum: 1000.</p>
</td></tr>
<tr><td><code id="network_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0. Use in combination
with <code>limit</code> to page through results.</p>
</td></tr>
<tr><td><code id="network_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>identifierType options:
</p>

<ul>
<li> <p>DOI No description.
</p>
</li>
<li> <p>FTP No description.
</p>
</li>
<li> <p>GBIF_NODE Identifies the node (e.g: <code>DK</code> for Denmark, <code>sp2000</code>
for Species 2000).
</p>
</li>
<li> <p>GBIF_PARTICIPANT Participant identifier from the GBIF IMS
Filemaker system.
</p>
</li>
<li> <p>GBIF_PORTAL Indicates the identifier originated from an
auto_increment column in the portal.data_provider or portal.data_resource
table respectively.
</p>
</li>
<li> <p>HANDLER No description.
</p>
</li>
<li> <p>LSID Reference controlled by a separate system, used for example
by DOI.
</p>
</li>
<li> <p>SOURCE_ID No description.
</p>
</li>
<li> <p>UNKNOWN No description.
</p>
</li>
<li> <p>URI No description.
</p>
</li>
<li> <p>URL No description.
</p>
</li>
<li> <p>UUID No description.
</p>
</li></ul>

<p>Get various information about GBIF networks. <code>network_constituents()</code> is a
convenience function that allows you to get all the datasets in a network.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>network()</code> returns a list
</p>
</li>
<li> <p><code>network_constituents()</code> returns a data.frame of datasets in the network
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.gbif.org/developer/registry#networks">https://www.gbif.org/developer/registry#networks</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
network()
network(uuid='2b7c7b4f-4d4f-40d3-94de-c28b6fa054a6')

network_constituents('2b7c7b4f-4d4f-40d3-94de-c28b6fa054a6')

# curl options
network(curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='networks'>Networks metadata.</h2><span id='topic+networks'></span>

<h3>Description</h3>

<p>Networks metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>networks(
  data = "all",
  uuid = NULL,
  query = NULL,
  identifier = NULL,
  identifierType = NULL,
  limit = 100,
  start = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="networks_+3A_data">data</code></td>
<td>
<p>The type of data to get. One or more of: 'contact', 'endpoint',
'identifier', 'tag', 'machineTag', 'comment', 'constituents', or the
special 'all'. Default: <code>'all'</code></p>
</td></tr>
<tr><td><code id="networks_+3A_uuid">uuid</code></td>
<td>
<p>UUID of the data network provider. This must be specified if
data is anything other than 'all'. Only 1 can be passed in</p>
</td></tr>
<tr><td><code id="networks_+3A_query">query</code></td>
<td>
<p>Query nodes. Only used when <code>data='all'</code>. Ignored
otherwise.</p>
</td></tr>
<tr><td><code id="networks_+3A_identifier">identifier</code></td>
<td>
<p>The value for this parameter can be a simple string or
integer, e.g. <code>identifier=120</code>. This parameter doesn't seem to work right
now.</p>
</td></tr>
<tr><td><code id="networks_+3A_identifiertype">identifierType</code></td>
<td>
<p>Used in combination with the identifier parameter to
filter identifiers by identifier type. See details. This parameter doesn't
seem to work right now.</p>
</td></tr>
<tr><td><code id="networks_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100. Maximum: 1000.</p>
</td></tr>
<tr><td><code id="networks_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0. Use in combination
with <code>limit</code> to page through results.</p>
</td></tr>
<tr><td><code id="networks_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>identifierType options:
</p>

<ul>
<li> <p>DOI No description.
</p>
</li>
<li> <p>FTP No description.
</p>
</li>
<li> <p>GBIF_NODE Identifies the node (e.g: <code>DK</code> for Denmark, <code>sp2000</code>
for Species 2000).
</p>
</li>
<li> <p>GBIF_PARTICIPANT Participant identifier from the GBIF IMS
Filemaker system.
</p>
</li>
<li> <p>GBIF_PORTAL Indicates the identifier originated from an
auto_increment column in the portal.data_provider or portal.data_resource
table respectively.
</p>
</li>
<li> <p>HANDLER No description.
</p>
</li>
<li> <p>LSID Reference controlled by a separate system, used for example
by DOI.
</p>
</li>
<li> <p>SOURCE_ID No description.
</p>
</li>
<li> <p>UNKNOWN No description.
</p>
</li>
<li> <p>URI No description.
</p>
</li>
<li> <p>URL No description.
</p>
</li>
<li> <p>UUID No description.
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.gbif.org/developer/registry#networks">https://www.gbif.org/developer/registry#networks</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
networks()
networks(uuid='2b7c7b4f-4d4f-40d3-94de-c28b6fa054a6')

# curl options
networks(curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='nodes'>Nodes metadata.</h2><span id='topic+nodes'></span>

<h3>Description</h3>

<p>Nodes metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes(
  data = "all",
  uuid = NULL,
  query = NULL,
  identifier = NULL,
  identifierType = NULL,
  limit = 100,
  start = NULL,
  isocode = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nodes_+3A_data">data</code></td>
<td>
<p>The type of data to get. One or more of: 'organization',
'endpoint', 'identifier', 'tag', 'machineTag', 'comment',
'pendingEndorsement', 'country', 'dataset', 'installation', or the
special 'all'. Default: <code>'all'</code></p>
</td></tr>
<tr><td><code id="nodes_+3A_uuid">uuid</code></td>
<td>
<p>UUID of the data node provider. This must be specified if data
is anything other than 'all'.</p>
</td></tr>
<tr><td><code id="nodes_+3A_query">query</code></td>
<td>
<p>Query nodes. Only used when <code>data='all'</code></p>
</td></tr>
<tr><td><code id="nodes_+3A_identifier">identifier</code></td>
<td>
<p>The value for this parameter can be a simple string or
integer, e.g. <code>identifier=120</code>. This parameter doesn't seem to work right
now.</p>
</td></tr>
<tr><td><code id="nodes_+3A_identifiertype">identifierType</code></td>
<td>
<p>Used in combination with the identifier parameter to
filter identifiers by identifier type. See details. This parameter doesn't
seem to work right now.</p>
</td></tr>
<tr><td><code id="nodes_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100. Maximum: 1000.</p>
</td></tr>
<tr><td><code id="nodes_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0. Use in combination
with <code>limit</code> to page through results.</p>
</td></tr>
<tr><td><code id="nodes_+3A_isocode">isocode</code></td>
<td>
<p>A 2 letter country code. Only used if data='country'.</p>
</td></tr>
<tr><td><code id="nodes_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>identifierType options:
</p>

<ul>
<li> <p>DOI No description.
</p>
</li>
<li> <p>FTP No description.
</p>
</li>
<li> <p>GBIF_NODE Identifies the node (e.g: <code>DK</code> for Denmark, <code>sp2000</code>
for Species 2000).
</p>
</li>
<li> <p>GBIF_PARTICIPANT Participant identifier from the GBIF IMS
Filemaker system.
</p>
</li>
<li> <p>GBIF_PORTAL Indicates the identifier originated from an
auto_increment column in the portal.data_provider or portal.data_resource
table respectively.
</p>
</li>
<li> <p>HANDLER No description.
</p>
</li>
<li> <p>LSID Reference controlled by a separate system, used for example
by DOI.
</p>
</li>
<li> <p>SOURCE_ID No description.
</p>
</li>
<li> <p>UNKNOWN No description.
</p>
</li>
<li> <p>URI No description.
</p>
</li>
<li> <p>URL No description.
</p>
</li>
<li> <p>UUID No description.
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.gbif.org/developer/registry#nodes">https://www.gbif.org/developer/registry#nodes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nodes(limit=5)
nodes(uuid="1193638d-32d1-43f0-a855-8727c94299d8")
nodes(data='identifier', uuid="03e816b3-8f58-49ae-bc12-4e18b358d6d9")
nodes(data=c('identifier','organization','comment'),
  uuid="03e816b3-8f58-49ae-bc12-4e18b358d6d9")

uuids = c("8cb55387-7802-40e8-86d6-d357a583c596",
  "02c40d2a-1cba-4633-90b7-e36e5e97aba8",
  "7a17efec-0a6a-424c-b743-f715852c3c1f",
  "b797ce0f-47e6-4231-b048-6b62ca3b0f55",
  "1193638d-32d1-43f0-a855-8727c94299d8",
  "d3499f89-5bc0-4454-8cdb-60bead228a6d",
  "cdc9736d-5ff7-4ece-9959-3c744360cdb3",
  "a8b16421-d80b-4ef3-8f22-098b01a89255",
  "8df8d012-8e64-4c8a-886e-521a3bdfa623",
  "b35cf8f1-748d-467a-adca-4f9170f20a4e",
  "03e816b3-8f58-49ae-bc12-4e18b358d6d9",
  "073d1223-70b1-4433-bb21-dd70afe3053b",
  "07dfe2f9-5116-4922-9a8a-3e0912276a72",
  "086f5148-c0a8-469b-84cc-cce5342f9242",
  "0909d601-bda2-42df-9e63-a6d51847ebce",
  "0e0181bf-9c78-4676-bdc3-54765e661bb8",
  "109aea14-c252-4a85-96e2-f5f4d5d088f4",
  "169eb292-376b-4cc6-8e31-9c2c432de0ad",
  "1e789bc9-79fc-4e60-a49e-89dfc45a7188",
  "1f94b3ca-9345-4d65-afe2-4bace93aa0fe")

res &lt;- lapply(uuids, function(x) nodes(x, data='identifier')$data)
res &lt;- res[!sapply(res, NROW)==0]
res[1]

# Pass on curl options
nodes(limit=20, curlopts=list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_count'>Get number of occurrence records.</h2><span id='topic+occ_count'></span>

<h3>Description</h3>

<p>Get number of occurrence records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_count(..., occurrenceStatus = "PRESENT", curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_count_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>occ_search()</code>.</p>
</td></tr>
<tr><td><code id="occ_count_+3A_occurrencestatus">occurrenceStatus</code></td>
<td>
<p>(character) Default is &quot;PRESENT&quot;. Specify whether
search should return &quot;PRESENT&quot; or &quot;ABSENT&quot; data.</p>
</td></tr>
<tr><td><code id="occ_count_+3A_curlopts">curlopts</code></td>
<td>
<p>(list) curl options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>occ_count()</code> is a short convenience wrapper for
<code>occ_search(limit=0)$meta$count</code>.
</p>
<p>The current version (since rgbif 3.7.6) of <code>occ_count()</code> uses a different
GBIF API endpoint from previous versions. This change greatly improves
the usability of <code>occ_count()</code>. Legacy parameters <code>georeferenced</code>, <code>type</code>,
<code>date</code>, <code>to</code>, <code>from</code> are no longer supported and not guaranteed to work
correctly.
</p>
<p>Multiple values of the type <code>c("a","b")</code> will give an error,
but <code>"a;b"</code> will work.
</p>


<h3>Value</h3>

<p>The occurrence count of the <code>occ_search()</code> query.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+occ_count_year">occ_count_year()</a></code>, <code><a href="#topic+occ_count_country">occ_count_country()</a></code>, <code><a href="#topic+occ_count_pub_country">occ_count_pub_country()</a></code>,
<code><a href="#topic+occ_count_basis_of_record">occ_count_basis_of_record()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# total occurrences mediated by GBIF
occ_count() # should be &gt; 2 billion! 

# number of plant occurrences
occ_count(kingdomKey=name_backbone("Plantea")$usageKey) 
occ_count(scientificName = 'Ursus americanus')

occ_count(country="DK") # found in Denmark 
occ_count(country="DK;US") # found in Denmark and United States
occ_count(publishingCountry="US") # published by the United States
# number of repatriated eBird records in India
occ_count(repatriated = TRUE,country="IN") 
 
occ_count(taxonKey=212) # number of bird occurrences
# between years 1800-1900
occ_count(basisOfRecord="PRESERVED_SPECIMEN", year="1800,1900") 
occ_count(recordedBy="John Waller") # recorded by John Waller
occ_count(decimalLatitude=0, decimalLongitude=0) # exactly on 0,0

# close to a known iso2 centroid
occ_count(distanceFromCentroidInMeters="0,2000") 
# close to a known iso2 centroid in Sweden
occ_count(distanceFromCentroidInMeters="0,2000",country="SE") 

occ_count(hasCoordinate=TRUE) # with coordinates
occ_count(protocol = "DIGIR") # published using DIGIR format
occ_count(mediaType = 'StillImage') # with images

# number of occurrences iucn status "critically endangered"
occ_count(iucnRedListCategory="CR") 
occ_count(verbatimScientificName="Calopteryx splendens;Calopteryx virgo")
occ_count(
geometry="POLYGON((24.70938 48.9221,24.71056 48.92175,24.71107
 48.92296,24.71002 48.92318,24.70938 48.9221))")

# getting a table of counts using the facets interface
# occurrence counts by year
occ_count(facet="year")
occ_count(facet="year",facetLimit=400)

# top scientificNames from Japan
occ_count(facet="scientificName",country="JP")
# top countries publishing specimen bird records between 1850 and 1880
occ_count(facet="scientificName",taxonKey=212,basisOfRecord="PRESERVED_SPECIMEN"
,year="1850,1880")

# Number of present or absence records of Elephants
occ_count(facet="occurrenceStatus",scientificName="Elephantidae")

# top 100 datasets publshing occurrences to GBIF
occ_count(facet="datasetKey",facetLimit=100)
# top datasets publishing country centroids on GBIF
occ_count(facet="datasetKey",distanceFromCentroidInMeters="0")

# common values for coordinateUncertaintyInMeters for museum specimens
occ_count(facet="coordinateUncertaintyInMeters",basisOfRecord="PRESERVED_SPECIMEN")

# number of iucn listed bird and insect occurrences in Mexico
occ_count(facet="iucnRedListCategory",taxonKey="212;216",country="MX")

# most common latitude values mediated by GBIF
occ_count(facet="decimalLatitude")

# top iNaturalist users publishing research-grade obs to GBIF
occ_count(facet="recordedBy",datasetKey="50c9509d-22c7-4a22-a47d-8c48425ef4a7")
# top 100 iNaturalist users from Ukraine
occ_count(facet="recordedBy",datasetKey="50c9509d-22c7-4a22-a47d-8c48425ef4a7"
,country="UA",facetLimit=100)

# top institutions publishing specimen occurrences to GBIF
occ_count(facet="institutionCode",basisOfRecord="PRESERVED_SPECIMEN")


## End(Not run)
</code></pre>

<hr>
<h2 id='occ_count_'>Get quick pre-computed occurrence counts of a limited number of dimensions.</h2><span id='topic+occ_count_'></span><span id='topic+occ_count_country'></span><span id='topic+occ_count_pub_country'></span><span id='topic+occ_count_year'></span><span id='topic+occ_count_basis_of_record'></span>

<h3>Description</h3>

<p>Get quick pre-computed occurrence counts of a limited number of dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_count_country(publishingCountry = NULL)

occ_count_pub_country(country = NULL)

occ_count_year(year = NULL)

occ_count_basis_of_record(curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_count__+3A_publishingcountry">publishingCountry</code></td>
<td>
<p>The 2-letter country code (as per ISO-3166-1)
the country from which the occurrence was published.</p>
</td></tr>
<tr><td><code id="occ_count__+3A_country">country</code></td>
<td>
<p>(character) The 2-letter country code (ISO-3166-1)
in which the occurrence was recorded.</p>
</td></tr>
<tr><td><code id="occ_count__+3A_year">year</code></td>
<td>
<p>The 4 digit year. Supports range queries, 'smaller,larger'
(e.g., '1990,1991', whereas 1991, 1990' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_count__+3A_curlopts">curlopts</code></td>
<td>
<p>(list) curl options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get quick pre-computed counts of a limited number of dimensions.
</p>
<p><code>occ_count_country()</code> will return a data.frame with occurrence counts by
country. By using <code>occ_count_country(publishingCountry="DK")</code> will
return the occurrence contributions Denmark has made to each country.
</p>
<p><code>occ_count_pub_country()</code> will return a data.frame with occurrence counts by
publishing country. Using <code>occ_count_pub_country(country="DK")</code>, will return
the occurrence contributions each country has made to that focal <code>country=DK</code>.
</p>
<p><code>occ_count_year()</code> will return a data.frame with the total occurrences
mediated by GBIF for each year. By using <code>occ_counts_year(year="1800,1900")</code>
will only return counts for that range.
</p>
<p><code>occ_count_basis_of_record()</code> will return a data.frame with total occurrences
mediated by GBIF for each basis of record.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of counts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+occ_count">occ_count()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# total occurrence counts for all countries and iso2 places
occ_count_country()  
# the occurrences Mexico has published in other countries 
occ_count_country("MX") 
# the occurrences Denmark has published in other countries 
occ_count_country("DK")

# the occurrences other countries have published in Denmark
occ_count_pub_country("DK")
# the occurrences other countries have published in Mexico
occ_count_pub_country("MX")

# total occurrence counts for each year that an occurrence was 
# recorded or collected.
occ_count_year()
# supports ranges
occ_count_year("1800,1900")

# table of occurrence counts by basis of record
occ_count_basis_of_record()


## End(Not run)
</code></pre>

<hr>
<h2 id='occ_data'>Legacy alternative to occ_search</h2><span id='topic+occ_data'></span>

<h3>Description</h3>

<p>Legacy alternative to occ_search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_data(
  taxonKey = NULL,
  scientificName = NULL,
  country = NULL,
  publishingCountry = NULL,
  hasCoordinate = NULL,
  typeStatus = NULL,
  recordNumber = NULL,
  lastInterpreted = NULL,
  continent = NULL,
  geometry = NULL,
  geom_big = "asis",
  geom_size = 40,
  geom_n = 10,
  recordedBy = NULL,
  recordedByID = NULL,
  identifiedByID = NULL,
  basisOfRecord = NULL,
  datasetKey = NULL,
  eventDate = NULL,
  catalogNumber = NULL,
  year = NULL,
  month = NULL,
  decimalLatitude = NULL,
  decimalLongitude = NULL,
  elevation = NULL,
  depth = NULL,
  institutionCode = NULL,
  collectionCode = NULL,
  hasGeospatialIssue = NULL,
  issue = NULL,
  search = NULL,
  mediaType = NULL,
  subgenusKey = NULL,
  repatriated = NULL,
  phylumKey = NULL,
  kingdomKey = NULL,
  classKey = NULL,
  orderKey = NULL,
  familyKey = NULL,
  genusKey = NULL,
  speciesKey = NULL,
  establishmentMeans = NULL,
  degreeOfEstablishment = NULL,
  protocol = NULL,
  license = NULL,
  organismId = NULL,
  publishingOrg = NULL,
  stateProvince = NULL,
  waterBody = NULL,
  locality = NULL,
  occurrenceStatus = "PRESENT",
  gadmGid = NULL,
  coordinateUncertaintyInMeters = NULL,
  verbatimScientificName = NULL,
  eventId = NULL,
  identifiedBy = NULL,
  networkKey = NULL,
  verbatimTaxonId = NULL,
  occurrenceId = NULL,
  organismQuantity = NULL,
  organismQuantityType = NULL,
  relativeOrganismQuantity = NULL,
  iucnRedListCategory = NULL,
  lifeStage = NULL,
  isInCluster = NULL,
  distanceFromCentroidInMeters = NULL,
  skip_validate = TRUE,
  limit = 500,
  start = 0,
  curlopts = list(http_version = 2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_data_+3A_taxonkey">taxonKey</code></td>
<td>
<p>(numeric) A taxon key from the GBIF backbone. All included
and synonym taxa are included in the search, so a search for aves with
taxononKey=212 will match all birds, no matter which species. You can pass
many keys to <code>occ_search(taxonKey=c(1,212))</code>.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_scientificname">scientificName</code></td>
<td>
<p>A scientific name from the GBIF backbone. All included
and synonym taxa are included in the search.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_country">country</code></td>
<td>
<p>(character) The 2-letter country code (ISO-3166-1)
in which the occurrence was recorded. <code>enumeration_country()</code>.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_publishingcountry">publishingCountry</code></td>
<td>
<p>The 2-letter country code (as per ISO-3166-1) of
the country in which the occurrence was recorded. See
<code>enumeration_country()</code>.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_hascoordinate">hasCoordinate</code></td>
<td>
<p>(logical) Return only occurrence records with lat/long
data (<code>TRUE</code>) or all records (<code>FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_typestatus">typeStatus</code></td>
<td>
<p>Type status of the specimen. One of many
<a href="https://www.gbif.org/occurrence/search?type_status=PARATYPE">options</a>.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_recordnumber">recordNumber</code></td>
<td>
<p>Number recorded by collector of the data, different from
GBIF record number.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_lastinterpreted">lastInterpreted</code></td>
<td>
<p>Date the record was last modified in GBIF, in ISO
8601 format: yyyy, yyyy-MM, yyyy-MM-dd, or MM-dd.  Supports range queries,
'smaller,larger' (e.g., '1990,1991', whereas '1991,1990' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_continent">continent</code></td>
<td>
<p>The source supplied continent.
</p>

<ul>
<li><p> &quot;africa&quot;
</p>
</li>
<li><p> &quot;antarctica&quot;
</p>
</li>
<li><p> &quot;asia&quot;
</p>
</li>
<li><p> &quot;europe&quot;
</p>
</li>
<li><p> &quot;north_america&quot;
</p>
</li>
<li><p> &quot;oceania&quot;
</p>
</li>
<li><p> &quot;south_america&quot;
</p>
</li></ul>

<p>Continent is not inferred but only populated if provided by the
dataset publisher. Applying this filter may exclude many relevant records.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_geometry">geometry</code></td>
<td>
<p>(character) Searches for occurrences inside a polygon in
Well Known Text (WKT) format. A WKT shape written as either
</p>

<ul>
<li><p> &quot;POINT&quot;
</p>
</li>
<li><p> &quot;LINESTRING&quot;
</p>
</li>
<li><p> &quot;LINEARRING&quot;
</p>
</li>
<li><p> &quot;POLYGON&quot;
</p>
</li>
<li><p> &quot;MULTIPOLYGON&quot;
</p>
</li></ul>

<p>For Example, &quot;POLYGON((37.08 46.86,38.06 46.86,38.06 47.28,37.08 47.28,
37.0 46.8))&quot;. See also the section <strong>WKT</strong> below.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_geom_big">geom_big</code></td>
<td>
<p>(character) One&quot;bbox&quot; or &quot;asis&quot; (default).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_geom_size">geom_size</code></td>
<td>
<p>(integer) An integer indicating size of the cell. Default:
40.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_geom_n">geom_n</code></td>
<td>
<p>(integer) An integer indicating number of cells in each
dimension. Default: 10.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_recordedby">recordedBy</code></td>
<td>
<p>(character) The person who recorded the occurrence.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_recordedbyid">recordedByID</code></td>
<td>
<p>(character) Identifier (e.g. ORCID) for the person who
recorded the occurrence</p>
</td></tr>
<tr><td><code id="occ_data_+3A_identifiedbyid">identifiedByID</code></td>
<td>
<p>(character) Identifier (e.g. ORCID) for the person who
provided the taxonomic identification of the occurrence.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_basisofrecord">basisOfRecord</code></td>
<td>
<p>(character) The specific nature of the data record. See
<a href="https://gbif.github.io/parsers/apidocs/org/gbif/api/vocabulary/BasisOfRecord.html">here</a>.
</p>

<ul>
<li><p> &quot;FOSSIL_SPECIMEN&quot;
</p>
</li>
<li><p> &quot;HUMAN_OBSERVATION&quot;
</p>
</li>
<li><p> &quot;MATERIAL_CITATION&quot;
</p>
</li>
<li><p> &quot;MATERIAL_SAMPLE&quot;
</p>
</li>
<li><p> &quot;LIVING_SPECIMEN&quot;
</p>
</li>
<li><p> &quot;MACHINE_OBSERVATION&quot;
</p>
</li>
<li><p> &quot;OBSERVATION&quot;
</p>
</li>
<li><p> &quot;PRESERVED_SPECIMEN&quot;
</p>
</li>
<li><p> &quot;OCCURRENCE&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="occ_data_+3A_datasetkey">datasetKey</code></td>
<td>
<p>(character) The occurrence dataset uuid key. That can be
found in the dataset page url. For example, &quot;7e380070-f762-11e1-a439-00145
eb45e9a&quot; is the key for <a href="https://www.gbif.org/dataset/7e380070-f762-11e1-a439-00145eb45e9a">Natural History Museum (London) Collection Specimens</a>.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_eventdate">eventDate</code></td>
<td>
<p>(character) Occurrence date in ISO 8601 format: yyyy,
yyyy-MM, yyyy-MM-dd, or MM-dd. Supports range queries, 'smaller,larger'
('1990,1991', whereas '1991,1990' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_catalognumber">catalogNumber</code></td>
<td>
<p>(character) An identifier of any form assigned by the
source within a physical collection or digital dataset for the record which
may not unique, but should be fairly unique in combination with the
institution and collection code.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_year">year</code></td>
<td>
<p>The 4 digit year. A year of 98 will be interpreted as AD 98.
Supports range queries, 'smaller,larger' (e.g., '1990,1991', whereas 1991,
1990' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_month">month</code></td>
<td>
<p>The month of the year, starting with 1 for January. Supports
range queries, 'smaller,larger' (e.g., '1,2', whereas '2,1' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_decimallatitude">decimalLatitude</code></td>
<td>
<p>Latitude in decimals between -90 and 90 based on
WGS84. Supports range queries, 'smaller,larger' (e.g., '25,30', whereas
'30,25' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_decimallongitude">decimalLongitude</code></td>
<td>
<p>Longitude in decimals between -180 and 180 based on
WGS84. Supports range queries (e.g., '-0.4,-0.2', whereas '-0.2,-0.4'
wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_elevation">elevation</code></td>
<td>
<p>Elevation in meters above sea level. Supports range
queries, 'smaller,larger' (e.g., '5,30', whereas '30,5' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_depth">depth</code></td>
<td>
<p>Depth in meters relative to elevation. For example 10 meters
below a lake surface with given elevation. Supports range queries,
'smaller,larger' (e.g., '5,30', whereas '30,5' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_institutioncode">institutionCode</code></td>
<td>
<p>An identifier of any form assigned by the source to
identify the institution the record belongs to.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_collectioncode">collectionCode</code></td>
<td>
<p>(character) An identifier of any form assigned by the
source to identify the physical collection or digital dataset uniquely within
the text of an institution.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_hasgeospatialissue">hasGeospatialIssue</code></td>
<td>
<p>(logical) Includes/excludes occurrence records
which contain spatial issues (as determined in our record interpretation),
i.e. <code>hasGeospatialIssue=TRUE</code> returns only those records with spatial
issues while <code>hasGeospatialIssue=FALSE</code> includes only records without
spatial issues. The absence of this parameter returns any record with or
without spatial issues.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_issue">issue</code></td>
<td>
<p>(character) One or more of many possible issues with each
occurrence record. Issues passed to this parameter filter results by
the issue. One of many <a href="https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/OccurrenceIssue.html">options</a>.
See <a href="https://data-blog.gbif.org/post/issues-and-flags/">here</a> for definitions.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_search">search</code></td>
<td>
<p>(character) Query terms. The value for this parameter can be a
simple word or a phrase. For example, <a href="https://www.gbif.org/occurrence/search?q=puma">search=&quot;puma&quot;</a></p>
</td></tr>
<tr><td><code id="occ_data_+3A_mediatype">mediaType</code></td>
<td>
<p>(character) Media type of &quot;MovingImage&quot;, &quot;Sound&quot;, or
&quot;StillImage&quot;.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_subgenuskey">subgenusKey</code></td>
<td>
<p>(numeric) Subgenus classification key.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_repatriated">repatriated</code></td>
<td>
<p>(character) Searches for records whose publishing country
is different to the country where the record was recorded in.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_phylumkey">phylumKey</code></td>
<td>
<p>(numeric) Phylum classification key.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_kingdomkey">kingdomKey</code></td>
<td>
<p>(numeric) Kingdom classification key.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_classkey">classKey</code></td>
<td>
<p>(numeric) Class classification key.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_orderkey">orderKey</code></td>
<td>
<p>(numeric) Order classification key.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_familykey">familyKey</code></td>
<td>
<p>(numeric) Family classification key.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_genuskey">genusKey</code></td>
<td>
<p>(numeric) Genus classification key.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_specieskey">speciesKey</code></td>
<td>
<p>(numeric) Species classification key.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_establishmentmeans">establishmentMeans</code></td>
<td>
<p>(character) provides information about whether an
organism or organisms have been introduced to a given place and time through
the direct or indirect activity of modern humans.
</p>

<ul>
<li><p> &quot;Introduced&quot;
</p>
</li>
<li><p> &quot;Native&quot;
</p>
</li>
<li><p> &quot;NativeReintroduced&quot;
</p>
</li>
<li><p> &quot;Vagrant&quot;
</p>
</li>
<li><p> &quot;Uncertain&quot;
</p>
</li>
<li><p> &quot;IntroducedAssistedColonisation&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="occ_data_+3A_degreeofestablishment">degreeOfEstablishment</code></td>
<td>
<p>(character) Provides information about degree to
which an Organism survives, reproduces, and expands its range at the given
place and time. One of many <a href="https://www.gbif.org/occurrence/search?advanced=1&amp;degree_of_establishment=Managed">options</a>.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_protocol">protocol</code></td>
<td>
<p>(character) Protocol or mechanism used to provide the
occurrence record. One of many <a href="https://www.gbif.org/occurrence/search?protocol=DWC_ARCHIVE&amp;advanced=1">options</a>.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_license">license</code></td>
<td>
<p>(character) The type license applied to the dataset or record.
</p>

<ul>
<li><p> &quot;CC0_1_0&quot;
</p>
</li>
<li><p> &quot;CC_BY_4_0&quot;
</p>
</li>
<li><p> &quot;CC_BY_NC_4_0&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="occ_data_+3A_organismid">organismId</code></td>
<td>
<p>(numeric) An identifier for the Organism instance (as
opposed to a particular digital record of the Organism). May be a globally
unique identifier or an identifier specific to the data set.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_publishingorg">publishingOrg</code></td>
<td>
<p>(character) The publishing organization key (a UUID).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_stateprovince">stateProvince</code></td>
<td>
<p>(character) The name of the next smaller administrative
region than country (state, province, canton, department, region, etc.) in
which the Location occurs.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_waterbody">waterBody</code></td>
<td>
<p>(character) The name of the water body in which the
locations occur</p>
</td></tr>
<tr><td><code id="occ_data_+3A_locality">locality</code></td>
<td>
<p>(character) The specific description of the place.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_occurrencestatus">occurrenceStatus</code></td>
<td>
<p>(character)  Default is &quot;PRESENT&quot;. Specify whether
search should return &quot;PRESENT&quot; or &quot;ABSENT&quot; data.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_gadmgid">gadmGid</code></td>
<td>
<p>(character) The gadm id of the area occurrences are desired
from. https://gadm.org/.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_coordinateuncertaintyinmeters">coordinateUncertaintyInMeters</code></td>
<td>
<p>A number or range between 0-1,000,000
which specifies the desired coordinate uncertainty. A coordinateUncertainty
InMeters=1000 will be interpreted all records with exactly 1000m. Supports
range queries, 'smaller,larger' (e.g., '1000,10000', whereas '10000,1000'
wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_verbatimscientificname">verbatimScientificName</code></td>
<td>
<p>(character) Scientific name as provided by the
source.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_eventid">eventId</code></td>
<td>
<p>(character) identifier(s) for a sampling event.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_identifiedby">identifiedBy</code></td>
<td>
<p>(character)  names of people, groups, or organizations.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_networkkey">networkKey</code></td>
<td>
<p>(character) The occurrence network key (a uuid)
who assigned the Taxon to the subject.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_verbatimtaxonid">verbatimTaxonId</code></td>
<td>
<p>(character) The taxon identifier provided to GBIF by
the data publisher.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_occurrenceid">occurrenceId</code></td>
<td>
<p>(character) occurrence id from source.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_organismquantity">organismQuantity</code></td>
<td>
<p>A number or range which
specifies the desired organism quantity. An organismQuantity=5
will be interpreted all records with exactly 5. Supports range queries,
smaller,larger (e.g., '5,20', whereas '20,5' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_organismquantitytype">organismQuantityType</code></td>
<td>
<p>(character) The type of quantification system
used for the quantity of organisms. For example, &quot;individuals&quot; or &quot;biomass&quot;.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_relativeorganismquantity">relativeOrganismQuantity</code></td>
<td>
<p>(numeric) A relativeOrganismQuantity=0.1 will
be interpreted all records with exactly 0.1 The relative measurement of the
quantity of the organism (a number between 0-1). Supports range queries,
&quot;smaller,larger&quot; (e.g., '0.1,0.5', whereas '0.5,0.1' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_data_+3A_iucnredlistcategory">iucnRedListCategory</code></td>
<td>
<p>(character) The IUCN threat status category.
</p>

<ul>
<li><p> &quot;NE&quot; (Not Evaluated)
</p>
</li>
<li><p> &quot;DD&quot; (Data Deficient)
</p>
</li>
<li><p> &quot;LC&quot; (Least Concern)
</p>
</li>
<li><p> &quot;NT&quot; (Near Threatened)
</p>
</li>
<li><p> &quot;VU&quot; (Vulnerable)
</p>
</li>
<li><p> &quot;EN&quot; (Endangered)
</p>
</li>
<li><p> &quot;CR&quot; (Critically Endangered)
</p>
</li>
<li><p> &quot;EX&quot; (Extinct)
</p>
</li>
<li><p> &quot;EW&quot; (Extinct in the Wild)
</p>
</li></ul>
</td></tr>
<tr><td><code id="occ_data_+3A_lifestage">lifeStage</code></td>
<td>
<p>(character) the life stage of the occurrence. One of many
<a href="https://www.gbif.org/occurrence/search?advanced=1&amp;life_stage=Tadpole">options</a>.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_isincluster">isInCluster</code></td>
<td>
<p>(logical) identify potentially related records on GBIF.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_distancefromcentroidinmeters">distanceFromCentroidInMeters</code></td>
<td>
<p>A number or range. A value of &quot;2000,*&quot;
means at least 2km from known centroids. A value of &quot;0&quot; would mean occurrences
exactly on known centroids. A value of &quot;0,2000&quot; would mean within 2km of
centroids. Max value is 5000.</p>
</td></tr>
<tr><td><code id="occ_data_+3A_skip_validate">skip_validate</code></td>
<td>
<p>(logical) whether to skip wellknown::validate_wkt call
or not. passed down to check_wkt(). Default: TRUE</p>
</td></tr>
<tr><td><code id="occ_data_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 500. Note that the per
request maximum is 300, but since we set it at 500 for the function, we
do two requests to get you the 500 records (if there are that many).
Note that there is a hard maximum of 100,000, which is calculated as the
<code>limit+start</code>, so <code>start=99,000</code> and <code>limit=2000</code> won't work</p>
</td></tr>
<tr><td><code id="occ_data_+3A_start">start</code></td>
<td>
<p>Record number to start at. Use in combination with limit to
page through results. Note that we do the paging internally for you, but
you can manually set the <code>start</code> parameter</p>
</td></tr>
<tr><td><code id="occ_data_+3A_curlopts">curlopts</code></td>
<td>
<p>(list)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a legacy alternative to <code>occ_search()</code>. It is not
recommended to use <code>occ_data()</code> as it is not as flexible as <code>occ_search()</code>.
New search terms will not be added to this function and it is only supported
for legacy reasons.
</p>


<h3>Value</h3>

<p>An object of class <code>gbif_data</code>, which is a S3 class list, with
slots for metadata (<code>meta</code>) and the occurrence data itself
(<code>data</code>), and with attributes listing the user supplied arguments
and whether it was a &quot;single&quot; or &quot;many&quot; search; that is, if you supply
two values of the <code>datasetKey</code> parameter to searches are done, and
it's a &quot;many&quot;. <code>meta</code> is a list of length four with offset, limit,
endOfRecords and count fields. <code>data</code> is a tibble (aka data.frame)
</p>

<hr>
<h2 id='occ_download'>Spin up a download request for GBIF occurrence data.</h2><span id='topic+occ_download'></span><span id='topic+occ_download_prep'></span>

<h3>Description</h3>

<p>Spin up a download request for GBIF occurrence data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download(
  ...,
  body = NULL,
  type = "and",
  format = "DWCA",
  user = NULL,
  pwd = NULL,
  email = NULL,
  curlopts = list()
)

occ_download_prep(
  ...,
  body = NULL,
  type = "and",
  format = "DWCA",
  user = NULL,
  pwd = NULL,
  email = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_+3A_...">...</code></td>
<td>
<p>For <code>occ_download()</code> and <code>occ_download_prep()</code>, one or more
objects of class <code>occ_predicate</code> or <code>occ_predicate_list</code>, created by
<code style="white-space: pre;">&#8288;pred*&#8288;</code> functions (see <a href="#topic+download_predicate_dsl">download_predicate_dsl</a>). If you use this, don't
use <code>body</code> parameter.</p>
</td></tr>
<tr><td><code id="occ_download_+3A_body">body</code></td>
<td>
<p>if you prefer to pass in the payload yourself, use this
parameter. If you use this, don't pass anything to the dots. Accepts
either an R list, or JSON. JSON is likely easier, since the JSON
library <span class="pkg">jsonlite</span> requires that you unbox strings that shouldn't
be auto-converted to arrays, which is a bit tedious for large queries.
optional</p>
</td></tr>
<tr><td><code id="occ_download_+3A_type">type</code></td>
<td>
<p>(character) One of equals (=), and (&amp;), or (|), lessThan (&lt;),
lessThanOrEquals (&lt;=), greaterThan (&gt;), greaterThanOrEquals (&gt;=), in,
within, not (!), like, isNotNull</p>
</td></tr>
<tr><td><code id="occ_download_+3A_format">format</code></td>
<td>
<p>(character) The download format. One of 'DWCA' (default),
'SIMPLE_CSV', or 'SPECIES_LIST'</p>
</td></tr>
<tr><td><code id="occ_download_+3A_user">user</code></td>
<td>
<p>(character) User name within GBIF's website. Required. See
&quot;Authentication&quot; below</p>
</td></tr>
<tr><td><code id="occ_download_+3A_pwd">pwd</code></td>
<td>
<p>(character) User password within GBIF's website. Required. See
&quot;Authentication&quot; below</p>
</td></tr>
<tr><td><code id="occ_download_+3A_email">email</code></td>
<td>
<p>(character) Email address to receive download notice done
email. Required. See &quot;Authentication&quot; below</p>
</td></tr>
<tr><td><code id="occ_download_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>geometry</h3>

<p>When using the geometry parameter, make sure that your well known text
(WKT) is formatted as GBIF expects it. They expect WKT to have a
counter-clockwise winding order. For example, the following is clockwise
<code style="white-space: pre;">&#8288;POLYGON((-19.5 34.1, -25.3 68.1, 35.9 68.1, 27.8 34.1, -19.5 34.1))&#8288;</code>,
whereas they expect the other order:
<code style="white-space: pre;">&#8288;POLYGON((-19.5 34.1, 27.8 34.1, 35.9 68.1, -25.3 68.1, -19.5 34.1))&#8288;</code>
</p>
<p>note that coordinate pairs are <code style="white-space: pre;">&#8288;longitude latitude&#8288;</code>, longitude first, then
latitude
</p>
<p>you should not get any results if you supply WKT that has clockwise
winding order.
</p>
<p>also note that <code><a href="#topic+occ_search">occ_search()</a></code>/<code><a href="#topic+occ_data">occ_data()</a></code> behave differently with
respect to WKT in that you can supply clockwise WKT to those
functions but they treat it as an exclusion, so get all data not
inside the WKT area.
</p>


<h3>Methods</h3>


<ul>
<li> <p><code>occ_download_prep</code>: prepares a download request, but DOES NOT execute it.
meant for use with <code><a href="#topic+occ_download_queue">occ_download_queue()</a></code>
</p>
</li>
<li> <p><code>occ_download</code>: prepares a download request and DOES execute it
</p>
</li></ul>



<h3>Authentication</h3>

<p>For <code>user</code>, <code>pwd</code>, and <code>email</code> parameters, you can set them in one of
three ways:
</p>

<ul>
<li><p> Set them in your <code>.Rprofile</code> file with the names <code>gbif_user</code>,
<code>gbif_pwd</code>, and <code>gbif_email</code>
</p>
</li>
<li><p> Set them in your <code>.Renviron</code>/<code>.bash_profile</code> (or similar) file with the
names <code>GBIF_USER</code>, <code>GBIF_PWD</code>, and <code>GBIF_EMAIL</code>
</p>
</li>
<li><p> Simply pass strings to each of the parameters in the function
call
</p>
</li></ul>

<p>We strongly recommend the second option - storing your details as
environment variables as it's the most widely used way to store secrets.
</p>
<p>See <code>?Startup</code> for help.
</p>


<h3>Query length</h3>

<p>GBIF has a limit of 12,000 characters for a download query. This means
that you can have a pretty long query, but at some point it may lead to an
error on GBIF's side and you'll have to split your query into a few.
</p>


<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>References</h3>

<p>See the API docs
<a href="https://www.gbif.org/developer/occurrence#download">https://www.gbif.org/developer/occurrence#download</a> for more info,
and the predicates docs
<a href="https://www.gbif.org/developer/occurrence#predicates">https://www.gbif.org/developer/occurrence#predicates</a>
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# occ_download(pred("basisOfRecord", "LITERATURE"))
# occ_download(pred("taxonKey", 3119195), pred_gt("elevation", 5000))
# occ_download(pred_gt("decimalLatitude", 50))
# occ_download(pred_gte("elevation", 9000))
# occ_download(pred_gte('decimalLatitude", 65))
# occ_download(pred("country", "US"))
# occ_download(pred("institutionCode", "TLMF"))
# occ_download(pred("catalogNumber", 217880))
# occ_download(pred("gbifId", 142317604)) 

# download format
# z &lt;- occ_download(pred_gte("decimalLatitude", 75),
#  format = "SPECIES_LIST")

# res &lt;- occ_download(pred("taxonKey", 7264332), pred("hasCoordinate", TRUE))

# pass output directly, or later, to occ_download_meta for more information
# occ_download(pred_gt('decimalLatitude', 75)) %&gt;% occ_download_meta

# Multiple queries
# occ_download(pred_gte("decimalLatitude", 65),
#  pred_lte("decimalLatitude", -65), type="or")
# gg &lt;- occ_download(pred("depth", 80), pred("taxonKey", 2343454),
#  type="or")
# x &lt;- occ_download(pred_and(pred_within("POLYGON((-14 42, 9 38, -7 26, -14 42))"),
#  pred_gte("elevation", 5000)))

# complex example with many predicates
# shows example of how to do date ranges for both year and month
# res &lt;- occ_download(
#  pred_gt("elevation", 5000),
#  pred_in("basisOfRecord", c('HUMAN_OBSERVATION','OBSERVATION','MACHINE_OBSERVATION')),
#  pred("country", "US"),
#  pred("hasCoordinate", TRUE),
#  pred("hasGeospatialIssue", FALSE),
#  pred_gte("year", 1999),
#  pred_lte("year", 2011),
#  pred_gte("month", 3),
#  pred_lte("month", 8)
# )

# Using body parameter - pass in your own complete query
## as JSON
query1 &lt;- '{"creator":"sckott",
  "notification_address":["stuff1@gmail.com"],
  "predicate":{"type":"and","predicates":[
    {"type":"equals","key":"TAXON_KEY","value":"7264332"},
    {"type":"equals","key":"HAS_COORDINATE","value":"TRUE"}]}
 }'
# res &lt;- occ_download(body = query1, curlopts=list(verbose=TRUE))

## as a list
library(jsonlite)
query &lt;- list(
  creator = unbox("sckott"),
  notification_address = "stuff1@gmail.com",
  predicate = list(
    type = unbox("and"),
    predicates = list(
      list(type = unbox("equals"), key = unbox("TAXON_KEY"),
        value = unbox("7264332")),
      list(type = unbox("equals"), key = unbox("HAS_COORDINATE"),
        value = unbox("TRUE"))
    )
  )
)
# res &lt;- occ_download(body = query, curlopts = list(verbose = TRUE))

# Prepared query
occ_download_prep(pred("basisOfRecord", "LITERATURE"))
occ_download_prep(pred("basisOfRecord", "LITERATURE"), format = "SIMPLE_CSV")
occ_download_prep(pred("basisOfRecord", "LITERATURE"), format = "SPECIES_LIST")
occ_download_prep(pred_in("taxonKey", c(2977832, 2977901, 2977966, 2977835)))
occ_download_prep(pred_within("POLYGON((-14 42, 9 38, -7 26, -14 42))"))

## a complicated example
occ_download_prep(
  pred_in("basisOfRecord", c("MACHINE_OBSERVATION", "HUMAN_OBSERVATION")),
  pred_in("taxonKey", c(2498343, 2481776, 2481890)),
  pred_in("country", c("GB", "IE")),
  pred_or(pred_lte("year", 1989), pred("year", 2000))
)

# x = occ_download(
#   pred_in("basisOfRecord", c("MACHINE_OBSERVATION", "HUMAN_OBSERVATION")),
#   pred_in("taxonKey", c(9206251, 3112648)),
#   pred_in("country", c("US", "MX")),
#   pred_and(pred_gte("year", 1989), pred_lte("year", 1991))
# )
# occ_download_meta(x)
# z &lt;- occ_download_get(x)
# df &lt;- occ_download_import(z)
# str(df)
# library(dplyr)
# unique(df$basisOfRecord)
# unique(df$taxonKey)
# unique(df$countryCode)
# sort(unique(df$year))

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_cached'>Check for downloads already in your GBIF account</h2><span id='topic+occ_download_cached'></span>

<h3>Description</h3>

<p>Check for downloads already in your GBIF account
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_cached(
  ...,
  body = NULL,
  type = "and",
  format = "DWCA",
  user = NULL,
  pwd = NULL,
  email = NULL,
  refresh = FALSE,
  age = 30,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_cached_+3A_...">...</code></td>
<td>
<p>For <code>occ_download()</code> and <code>occ_download_prep()</code>, one or more
objects of class <code>occ_predicate</code> or <code>occ_predicate_list</code>, created by
<code style="white-space: pre;">&#8288;pred*&#8288;</code> functions (see <a href="#topic+download_predicate_dsl">download_predicate_dsl</a>). If you use this, don't
use <code>body</code> parameter.</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_body">body</code></td>
<td>
<p>if you prefer to pass in the payload yourself, use this
parameter. If you use this, don't pass anything to the dots. Accepts
either an R list, or JSON. JSON is likely easier, since the JSON
library <span class="pkg">jsonlite</span> requires that you unbox strings that shouldn't
be auto-converted to arrays, which is a bit tedious for large queries.
optional</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_type">type</code></td>
<td>
<p>(character) One of equals (=), and (&amp;), or (|), lessThan (&lt;),
lessThanOrEquals (&lt;=), greaterThan (&gt;), greaterThanOrEquals (&gt;=), in,
within, not (!), like, isNotNull</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_format">format</code></td>
<td>
<p>(character) The download format. One of 'DWCA' (default),
'SIMPLE_CSV', or 'SPECIES_LIST'</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_user">user</code></td>
<td>
<p>(character) User name within GBIF's website. Required. See
&quot;Authentication&quot; below</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_pwd">pwd</code></td>
<td>
<p>(character) User password within GBIF's website. Required. See
&quot;Authentication&quot; below</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_email">email</code></td>
<td>
<p>(character) Email address to receive download notice done
email. Required. See &quot;Authentication&quot; below</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_refresh">refresh</code></td>
<td>
<p>(logical) refresh your list of downloads. on the first
request of each R session we'll cache your stored GBIF occurrence
downloads locally. you can refresh this list by setting <code>refresh=TRUE</code>;
if you're in the same R session, and you've done many download requests,
then refreshing may be a good idea if you're using this function</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_age">age</code></td>
<td>
<p>(integer) number of days after which you want a new
download. default: 30</p>
</td></tr>
<tr><td><code id="occ_download_cached_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# these are examples from the package maintainer's account;
# outcomes will vary by user
occ_download_cached(pred_gte("elevation", 12000L))
occ_download_cached(pred("catalogNumber", 217880))
occ_download_cached(pred_gte("decimalLatitude", 65),
  pred_lte("decimalLatitude", -65), type="or")
occ_download_cached(pred_gte("elevation", 12000L))
occ_download_cached(pred_gte("elevation", 12000L), refresh = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_cancel'>Cancel a download creation process.</h2><span id='topic+occ_download_cancel'></span><span id='topic+occ_download_cancel_staged'></span>

<h3>Description</h3>

<p>Cancel a download creation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_cancel(key, user = NULL, pwd = NULL, curlopts = list())

occ_download_cancel_staged(
  user = NULL,
  pwd = NULL,
  limit = 20,
  start = 0,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_cancel_+3A_key">key</code></td>
<td>
<p>(character) A key generated from a request, like that from
<code>occ_download</code>. Required.</p>
</td></tr>
<tr><td><code id="occ_download_cancel_+3A_user">user</code></td>
<td>
<p>(character) User name within GBIF's website. Required. See
Details.</p>
</td></tr>
<tr><td><code id="occ_download_cancel_+3A_pwd">pwd</code></td>
<td>
<p>(character) User password within GBIF's website. Required. See
Details.</p>
</td></tr>
<tr><td><code id="occ_download_cancel_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
<tr><td><code id="occ_download_cancel_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 20</p>
</td></tr>
<tr><td><code id="occ_download_cancel_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note, these functions only cancel a job in progress. If your
download is already prepared for you, this won't do anything to change
that.
</p>
<p><code>occ_download_cancel</code> cancels a specific job by download key - returns
success message
</p>
<p><code>occ_download_cancel_staged</code> cancels all jobs with status <code>RUNNING</code>
or <code>PREPARING</code> - if none are found, returns a message saying so -
if some found, they are cancelled, returning message saying so
</p>


<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# occ_download_cancel(key="0003984-140910143529206")
# occ_download_cancel_staged()

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_dataset_activity'>Lists the downloads activity of a dataset</h2><span id='topic+occ_download_dataset_activity'></span>

<h3>Description</h3>

<p>Lists the downloads activity of a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_dataset_activity(
  dataset,
  limit = 20,
  start = 0,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_dataset_activity_+3A_dataset">dataset</code></td>
<td>
<p>(character) A dataset key</p>
</td></tr>
<tr><td><code id="occ_download_dataset_activity_+3A_limit">limit</code></td>
<td>
<p>(integer/numeric) Number of records to return. Default: 20,
Max: 1000</p>
</td></tr>
<tr><td><code id="occ_download_dataset_activity_+3A_start">start</code></td>
<td>
<p>(integer/numeric) Record number to start at. Default: 0</p>
</td></tr>
<tr><td><code id="occ_download_dataset_activity_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two slots:
</p>

<ul>
<li><p> meta: a single row data.frame with columns: <code>offset</code>, <code>limit</code>,
<code>endofrecords</code>, <code>count</code>
</p>
</li>
<li><p> results: a tibble with the nested data flattened, with many
columns with the same <code>download.</code> or <code>download.request.</code> prefixes
</p>
</li></ul>



<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- occ_download_dataset_activity("7f2edc10-f762-11e1-a439-00145eb45e9a")
res
res$meta
res$meta$count

# pagination
occ_download_dataset_activity("7f2edc10-f762-11e1-a439-00145eb45e9a",
limit = 3000)
occ_download_dataset_activity("7f2edc10-f762-11e1-a439-00145eb45e9a",
limit = 3, start = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_datasets'>List datasets for a download</h2><span id='topic+occ_download_datasets'></span>

<h3>Description</h3>

<p>List datasets for a download
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_datasets(key, limit = 20, start = 0, curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_datasets_+3A_key">key</code></td>
<td>
<p>A key generated from a request, like that from <code><a href="#topic+occ_download">occ_download()</a></code></p>
</td></tr>
<tr><td><code id="occ_download_datasets_+3A_limit">limit</code></td>
<td>
<p>(integer/numeric) Number of records to return. Default: 20,
Max: 1000</p>
</td></tr>
<tr><td><code id="occ_download_datasets_+3A_start">start</code></td>
<td>
<p>(integer/numeric) Record number to start at. Default: 0</p>
</td></tr>
<tr><td><code id="occ_download_datasets_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two slots:
</p>

<ul>
<li><p> meta: a single row data.frame with columns: <code>offset</code>, <code>limit</code>,
<code>endofrecords</code>, <code>count</code>
</p>
</li>
<li><p> results: a tibble with the results, of three columns: <code>downloadKey</code>,
<code>datasetKey</code>, <code>numberRecords</code>
</p>
</li></ul>



<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occ_download_datasets(key="0003983-140910143529206")
occ_download_datasets(key="0003983-140910143529206", limit = 3)
occ_download_datasets(key="0003983-140910143529206", limit = 3, start = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_describe'>Describes the fields available in GBIF downloads</h2><span id='topic+occ_download_describe'></span>

<h3>Description</h3>

<p>Describes the fields available in GBIF downloads
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_describe(x = "dwca")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_describe_+3A_x">x</code></td>
<td>
<p>a character string (default: &quot;dwca&quot;). Accepted values:
&quot;simpleCsv&quot;, &quot;simpleAvro&quot;, &quot;simpleParquet&quot;,&quot;speciesList&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a list with the fields available in GBIF downloads. It
is considered experimental by GBIF, so the output might change in the future.
</p>


<h3>Value</h3>

<p>a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occ_download_describe("dwca")$verbatimFields
occ_download_describe("dwca")$verbatimExtensions
occ_download_describe("simpleCsv")$fields

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_get'>Get a download from GBIF.</h2><span id='topic+occ_download_get'></span>

<h3>Description</h3>

<p>Get a download from GBIF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_get(key, path = ".", overwrite = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_get_+3A_key">key</code></td>
<td>
<p>A key generated from a request, like that from <code>occ_download</code></p>
</td></tr>
<tr><td><code id="occ_download_get_+3A_path">path</code></td>
<td>
<p>Path to write zip file to. Default: <code>"."</code>, with a
<code>.zip</code> appended to the end.</p>
</td></tr>
<tr><td><code id="occ_download_get_+3A_overwrite">overwrite</code></td>
<td>
<p>Will only overwrite existing path if TRUE.</p>
</td></tr>
<tr><td><code id="occ_download_get_+3A_...">...</code></td>
<td>
<p>named curl options passed on to
<a href="crul.html#topic+verb-GET">crul::verb-GET</a>. see <code>curl::curl_options()</code> for curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Downloads the zip file to a directory you specify on your machine.
<code><a href="crul.html#topic+HttpClient">crul::HttpClient()</a></code> is used internally to write the zip file to
disk. See <a href="crul.html#topic+writing-options">crul::writing-options</a>. This function only downloads the file.
See <code>occ_download_import</code> to open a downloaded file in your R session.
The speed of this function is of course proportional to the size of the
file to download. For example, a 58 MB file on my machine took about
26 seconds.
</p>


<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>
<p>This function used to check for HTTP response content type, but
it has changed enough that we no longer check it. If you run into issues
with this function, open an issue in the GitHub repository.
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occ_download_get("0000066-140928181241064")
occ_download_get("0003983-140910143529206", overwrite = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_import'>Import a downloaded file from GBIF.</h2><span id='topic+occ_download_import'></span><span id='topic+as.download'></span><span id='topic+as.download.character'></span><span id='topic+as.download.download'></span>

<h3>Description</h3>

<p>Import a downloaded file from GBIF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_import(
  x = NULL,
  key = NULL,
  path = ".",
  fill = FALSE,
  encoding = "UTF-8",
  ...
)

as.download(path = ".", key = NULL)

## S3 method for class 'character'
as.download(path = ".", key = NULL)

## S3 method for class 'download'
as.download(path = ".", key = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_import_+3A_x">x</code></td>
<td>
<p>The output of a call to <code>occ_download_get</code></p>
</td></tr>
<tr><td><code id="occ_download_import_+3A_key">key</code></td>
<td>
<p>A key generated from a request, like that from
<code>occ_download</code></p>
</td></tr>
<tr><td><code id="occ_download_import_+3A_path">path</code></td>
<td>
<p>Path to unzip file to. Default: <code>"."</code> Writes to
folder matching zip file name</p>
</td></tr>
<tr><td><code id="occ_download_import_+3A_fill">fill</code></td>
<td>
<p>(logical) (default: <code>FALSE</code>). If <code>TRUE</code> then in case
the rows have unequal length, blank fields are implicitly filled.
passed on to <code>fill</code> parameter in <a href="data.table.html#topic+fread">data.table::fread</a>.</p>
</td></tr>
<tr><td><code id="occ_download_import_+3A_encoding">encoding</code></td>
<td>
<p>(character) encoding to read in data; passed to
<code><a href="data.table.html#topic+fread">data.table::fread()</a></code>. default: &quot;UTF-8&quot;. other allowed options:
&quot;Latin-1&quot; and &quot;unknown&quot;. see <code>?data.table::fread</code> docs</p>
</td></tr>
<tr><td><code id="occ_download_import_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="data.table.html#topic+fread">data.table::fread()</a></code>. See <code>fread</code>
docs for details. Some <code>fread</code> parameters that may be particular useful
here are: <code>select</code> (select which columns to read in; others are dropped),
<code>nrows</code> (only read in a certain number of rows)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can provide either x as input, or both key and path. We use
<code><a href="data.table.html#topic+fread">data.table::fread()</a></code> internally to read data.
</p>


<h3>Value</h3>

<p>a tibble (data.frame)
</p>


<h3>Problems reading data</h3>

<p>You may run into errors when using <code>occ_download_import()</code>; most often
these are due to <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> not being able to parse the
<code>occurrence.txt</code> file correctly. The <code>fill</code> parameter passes down to
<code><a href="data.table.html#topic+fread">data.table::fread()</a></code> and the <code>...</code> allows you to pass on any other
parameters that <code><a href="data.table.html#topic+fread">data.table::fread()</a></code> accepts. Read the docs for <code>fread</code>
for help.
</p>


<h3>countryCode result column and Namibia</h3>

<p>The country code for Namibia is <code>"NA"</code>. Unfortunately in R an <code>"NA"</code> string
will be read in to R as an NA/missing. To avoid this, in this function
we read in the data, then convert an NA/missing values to the character
string <code>"NA"</code>. When a country code is truly missing it will be an empty
string.
</p>


<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First, kick off at least 1 download, then wait for the job to be complete
# Then use your download keys
res &lt;- occ_download_get(key="0000066-140928181241064", overwrite=TRUE)
occ_download_import(res)

occ_download_get(key="0000066-140928181241064", overwrite = TRUE) %&gt;%
  occ_download_import

# coerce a file path to the right class to feed to occ_download_import
# as.download("0000066-140928181241064.zip")
# as.download(key = "0000066-140928181241064")
# occ_download_import(as.download("0000066-140928181241064.zip"))

# download a dump that has a CSV file
# res &lt;- occ_download_get(key = "0001369-160509122628363", overwrite=TRUE)
# occ_download_import(res)
# occ_download_import(key = "0001369-160509122628363")

# download and import a species list (in csv format)
# x &lt;- occ_download_get("0000172-190415153152247")
# occ_download_import(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_list'>Lists the downloads created by a user.</h2><span id='topic+occ_download_list'></span>

<h3>Description</h3>

<p>Lists the downloads created by a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_list(
  user = NULL,
  pwd = NULL,
  limit = 20,
  start = 0,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_list_+3A_user">user</code></td>
<td>
<p>(character) User name within GBIF's website. Required. See
Details.</p>
</td></tr>
<tr><td><code id="occ_download_list_+3A_pwd">pwd</code></td>
<td>
<p>(character) User password within GBIF's website. Required. See
Details.</p>
</td></tr>
<tr><td><code id="occ_download_list_+3A_limit">limit</code></td>
<td>
<p>(integer/numeric) Number of records to return. Default: 20,
Max: 1000</p>
</td></tr>
<tr><td><code id="occ_download_list_+3A_start">start</code></td>
<td>
<p>(integer/numeric) Record number to start at. Default: 0</p>
</td></tr>
<tr><td><code id="occ_download_list_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two slots:
</p>

<ul>
<li><p> meta: a single row data.frame with columns: <code>offset</code>, <code>limit</code>,
<code>endofrecords</code>, <code>count</code>
</p>
</li>
<li><p> results: a tibble with the nested data flattened, with many
columns with the same <code>request.</code> prefix
</p>
</li></ul>



<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occ_download_list(user="sckott")
occ_download_list(user="sckott", limit = 5)
occ_download_list(user="sckott", start = 21)

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_meta'>Retrieves the occurrence download metadata by its unique key.</h2><span id='topic+occ_download_meta'></span>

<h3>Description</h3>

<p>Retrieves the occurrence download metadata by its unique key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_meta(key, curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_meta_+3A_key">key</code></td>
<td>
<p>A key generated from a request, like that from
<code>occ_download</code></p>
</td></tr>
<tr><td><code id="occ_download_meta_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>occ_download_meta</code>, a list with slots for
the download key, the DOI assigned to the download, license link,
the request details you sent in the <code>occ_download()</code> request,
and metadata about the size and date/time of the request
</p>


<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occ_download_meta(key="0003983-140910143529206")
occ_download_meta("0000066-140928181241064")

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_queue'>Download requests in a queue</h2><span id='topic+occ_download_queue'></span>

<h3>Description</h3>

<p>Download requests in a queue
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_queue(..., .list = list(), status_ping = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_queue_+3A_...">...</code></td>
<td>
<p>any number of <code><a href="#topic+occ_download">occ_download()</a></code> requests</p>
</td></tr>
<tr><td><code id="occ_download_queue_+3A_.list">.list</code></td>
<td>
<p>any number of <code><a href="#topic+occ_download_prep">occ_download_prep()</a></code> requests</p>
</td></tr>
<tr><td><code id="occ_download_queue_+3A_status_ping">status_ping</code></td>
<td>
<p>(integer) seconds between pings checking status of
the download request. generally larger numbers for larger requests.
default: 10 (i.e., 10 seconds). must be 10 or greater</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around <code><a href="#topic+occ_download">occ_download()</a></code>,
allowing the user to kick off any number of requests, while abiding by
GBIF rules of 3 concurrent requests per user.
</p>


<h3>Value</h3>

<p>a list of <code>occ_download</code> class objects, see <code><a href="#topic+occ_download_get">occ_download_get()</a></code>
to fetch data
</p>


<h3>How it works</h3>

<p>It works by using lazy evaluation to collect your requests into a queue
(but does not use lazy evaluation if use the <code>.list</code> parameter).
Then it kicks of the first 3 requests. Then in a while loop, we check
status of those requests, and when any request finishes (see
<code style="white-space: pre;">&#8288;When is a job done?&#8288;</code> below), we kick off the
next, and so on. So in theory, there may not always strictly be 3 running
concurrently, but the function will usually provide for 3 running
concurrently.
</p>


<h3>When is a job done?</h3>

<p>We mark a job as done by checking the <code style="white-space: pre;">&#8288;/occurrence/download/&#8288;</code> API route
with our <code><a href="#topic+occ_download_meta">occ_download_meta()</a></code> function. If the status of the job is
any of &quot;succeeded&quot;, &quot;killed&quot;, or &quot;cancelled&quot;, then we mark the job as done
and move on to other jobs in the queue.
</p>


<h3>Beware</h3>

<p>This function is still in development. There's a lot of complexity
to this problem. We'll be rolling out fixes and improvements in future
versions of the package, so expect to have to adjust your code
with new versions.
</p>


<h3>Note</h3>

<p>see <a href="#topic+downloads">downloads</a> for an overview of GBIF downloads methods
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_wait">occ_download_wait</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (interactive()) { # dont run in automated example runs, too costly
# passing occ_download() requests via ...
out &lt;- occ_download_queue(
  occ_download(pred('taxonKey', 3119195), pred("year", 1976)),
  occ_download(pred('taxonKey', 3119195), pred("year", 2001)),
  occ_download(pred('taxonKey', 3119195), pred("year", 2001),
    pred_lte("month", 8)),
  occ_download(pred('taxonKey', 5229208), pred("year", 2011)),
  occ_download(pred('taxonKey', 2480946), pred("year", 2015)),
  occ_download(pred("country", "NZ"), pred("year", 1999),
    pred("month", 3)),
  occ_download(pred("catalogNumber", "Bird.27847588"),
    pred("year", 1998), pred("month", 2))
)

# supports &lt;= 3 requests too
out &lt;- occ_download_queue(
  occ_download(pred("country", "NZ"), pred("year", 1999), pred("month", 3)),
  occ_download(pred("catalogNumber", "Bird.27847588"), pred("year", 1998),
    pred("month", 2))
)

# using pre-prepared requests via .list
keys &lt;- c(7905507, 5384395, 8911082)
queries &lt;- list()
for (i in seq_along(keys)) {
  queries[[i]] &lt;- occ_download_prep(
    pred("taxonKey", keys[i]),
    pred_in("basisOfRecord", c("HUMAN_OBSERVATION","OBSERVATION")),
    pred("hasCoordinate", TRUE),
    pred("hasGeospatialIssue", FALSE),
    pred("year", 1993)
  )
}
out &lt;- occ_download_queue(.list = queries)
out

# another pre-prepared example
yrs &lt;- 1930:1934
queries &lt;- list()
for (i in seq_along(yrs)) {
  queries[[i]] &lt;- occ_download_prep(
    pred("taxonKey", 2877951),
    pred_in("basisOfRecord", c("HUMAN_OBSERVATION","OBSERVATION")),
    pred("hasCoordinate", TRUE),
    pred("hasGeospatialIssue", FALSE),
    pred("year", yrs[i])
  )
}
out &lt;- occ_download_queue(.list = queries)
out
}
## End(Not run)
</code></pre>

<hr>
<h2 id='occ_download_sql'>Download occurrence data using a SQL query</h2><span id='topic+occ_download_sql'></span><span id='topic+occ_download_sql_validate'></span><span id='topic+occ_download_sql_prep'></span>

<h3>Description</h3>

<p>Download occurrence data using a SQL query
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_sql(
  q = NULL,
  format = "SQL_TSV_ZIP",
  user = NULL,
  pwd = NULL,
  email = NULL,
  validate = TRUE,
  curlopts = list()
)

occ_download_sql_validate(q = NULL, user = NULL, pwd = NULL)

occ_download_sql_prep(
  q = NULL,
  format = "SQL_TSV_ZIP",
  user = NULL,
  pwd = NULL,
  email = NULL,
  validate = TRUE,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_sql_+3A_q">q</code></td>
<td>
<p>sql query</p>
</td></tr>
<tr><td><code id="occ_download_sql_+3A_format">format</code></td>
<td>
<p>only &quot;SQL_TSV_ZIP&quot; is supported right now</p>
</td></tr>
<tr><td><code id="occ_download_sql_+3A_user">user</code></td>
<td>
<p>your GBIF user name</p>
</td></tr>
<tr><td><code id="occ_download_sql_+3A_pwd">pwd</code></td>
<td>
<p>your GBIF password</p>
</td></tr>
<tr><td><code id="occ_download_sql_+3A_email">email</code></td>
<td>
<p>your email address</p>
</td></tr>
<tr><td><code id="occ_download_sql_+3A_validate">validate</code></td>
<td>
<p>should the query be validated before submission. Default is
TRUE.</p>
</td></tr>
<tr><td><code id="occ_download_sql_+3A_curlopts">curlopts</code></td>
<td>
<p>list of curl options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an experimental feature, and the implementation may change throughout
2024. The feature is currently only available for preview by invited users.
Contact <code>helpdesk@gbif.org</code> to request access.
</p>
<p>Please see the article here for more information:
<a href="https://docs.ropensci.org/rgbif/articles/getting_occurrence_data.html">https://docs.ropensci.org/rgbif/articles/getting_occurrence_data.html</a>
</p>


<h3>Value</h3>

<p>an object of class 'occ_download_sql'
</p>


<h3>References</h3>

<p><a href="https://techdocs.gbif.org/en/data-use/api-sql-downloads">https://techdocs.gbif.org/en/data-use/api-sql-downloads</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occ_download_sql("SELECT gbifid,countryCode FROM occurrence 
                  WHERE genusKey = 2435098")

## End(Not run)

</code></pre>

<hr>
<h2 id='occ_download_wait'>Wait for an occurrence download to be done</h2><span id='topic+occ_download_wait'></span>

<h3>Description</h3>

<p>Wait for an occurrence download to be done
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_download_wait(
  x,
  status_ping = 5,
  curlopts = list(http_version = 2),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_download_wait_+3A_x">x</code></td>
<td>
<p>and object of class <code>occ_download</code> or downloadkey</p>
</td></tr>
<tr><td><code id="occ_download_wait_+3A_status_ping">status_ping</code></td>
<td>
<p>(integer) seconds between each <code><a href="#topic+occ_download_meta">occ_download_meta()</a></code>
request. default is 5, and cannot be &lt; 3</p>
</td></tr>
<tr><td><code id="occ_download_wait_+3A_curlopts">curlopts</code></td>
<td>
<p>(list) curl options, as named list, passed on to
<code><a href="#topic+occ_download_meta">occ_download_meta()</a></code></p>
</td></tr>
<tr><td><code id="occ_download_wait_+3A_quiet">quiet</code></td>
<td>
<p>(logical) suppress messages. default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>occ_download_meta</code>, see <code><a href="#topic+occ_download_meta">occ_download_meta()</a></code>
for details
</p>


<h3>Note</h3>

<p><code><a href="#topic+occ_download_queue">occ_download_queue()</a></code> is similar, but handles many requests
at once; <code>occ_download_wait</code> handles one request at a time
</p>


<h3>See Also</h3>

<p>Other downloads: 
<code><a href="#topic+download_predicate_dsl">download_predicate_dsl</a></code>,
<code><a href="#topic+occ_download_cached">occ_download_cached</a>()</code>,
<code><a href="#topic+occ_download_cancel">occ_download_cancel</a>()</code>,
<code><a href="#topic+occ_download_dataset_activity">occ_download_dataset_activity</a>()</code>,
<code><a href="#topic+occ_download_datasets">occ_download_datasets</a>()</code>,
<code><a href="#topic+occ_download_get">occ_download_get</a>()</code>,
<code><a href="#topic+occ_download_import">occ_download_import</a>()</code>,
<code><a href="#topic+occ_download_list">occ_download_list</a>()</code>,
<code><a href="#topic+occ_download_meta">occ_download_meta</a>()</code>,
<code><a href="#topic+occ_download_queue">occ_download_queue</a>()</code>,
<code><a href="#topic+occ_download">occ_download</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- occ_download(
  pred("taxonKey", 9206251),
  pred_in("country", c("US", "MX")),
  pred_gte("year", 1971)
)
res &lt;- occ_download_wait(x)
occ_download_meta(x)

# works also with a downloadkey
occ_download_wait("0000066-140928181241064") 


## End(Not run)
</code></pre>

<hr>
<h2 id='occ_facet'>Facet GBIF occurrences</h2><span id='topic+occ_facet'></span>

<h3>Description</h3>

<p>Facet GBIF occurrences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_facet(facet, facetMincount = NULL, curlopts = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_facet_+3A_facet">facet</code></td>
<td>
<p>(character) a character vector of length 1 or greater. Required.</p>
</td></tr>
<tr><td><code id="occ_facet_+3A_facetmincount">facetMincount</code></td>
<td>
<p>(numeric) minimum number of records to be included
in the faceting results</p>
</td></tr>
<tr><td><code id="occ_facet_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
<tr><td><code id="occ_facet_+3A_...">...</code></td>
<td>
<p>Facet parameters, such as for paging based on each facet
variable, e.g., <code>country.facetLimit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All fields can be faceted on except for last &quot;lastInterpreted&quot;,
&quot;eventDate&quot;, and &quot;geometry&quot;
</p>
<p>If a faceted variable is not found, it is silently dropped, returning
nothing for that query
</p>


<h3>Value</h3>

<p>A list of tibbles (data.frame's) for each facet (each element of
the facet parameter).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+occ_search">occ_search()</a></code> also has faceting ability, but
can include occurrence data in addition to facets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occ_facet(facet = "country")

# facetMincount - minimum number of records to be included
#   in the faceting results
occ_facet(facet = "country", facetMincount = 30000000L)
occ_facet(facet = c("country", "basisOfRecord"))

# paging with many facets
occ_facet(
  facet = c("country", "basisOfRecord", "hasCoordinate"),
  country.facetLimit = 3,
  basisOfRecord.facetLimit = 6
)

# paging
## limit
occ_facet(facet = "country", country.facetLimit = 3)
## offset
occ_facet(facet = "country", country.facetLimit = 3,
  country.facetOffset = 3)

# Pass on curl options
occ_facet(facet = "country", country.facetLimit = 3,
  curlopts = list(verbose = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_get'>Get data for GBIF occurrences by occurrence key</h2><span id='topic+occ_get'></span><span id='topic+occ_get_verbatim'></span>

<h3>Description</h3>

<p>Get data for GBIF occurrences by occurrence key
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_get(
  key,
  fields = "minimal",
  curlopts = list(),
  return = NULL,
  verbatim = NULL
)

occ_get_verbatim(key, fields = "minimal", curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_get_+3A_key">key</code></td>
<td>
<p>(numeric/integer) one or more occurrence keys. required</p>
</td></tr>
<tr><td><code id="occ_get_+3A_fields">fields</code></td>
<td>
<p>(character) Default (&quot;minimal&quot;) will return just taxon name,
key, latitude, and longitude. 'all' returns all fields. Or specify each
field you want returned by name, e.g. fields = c('name',
'decimalLatitude','altitude').</p>
</td></tr>
<tr><td><code id="occ_get_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
<tr><td><code id="occ_get_+3A_return">return</code></td>
<td>
<p>Defunct. All components are returned now; index to the
one(s) you want</p>
</td></tr>
<tr><td><code id="occ_get_+3A_verbatim">verbatim</code></td>
<td>
<p>Defunct. verbatim records can now be retrieved using
<code>occ_get_verbatim()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>occ_get</code> a list of lists. For <code>occ_get_verbatim</code> a data.frame
</p>


<h3>References</h3>

<p><a href="https://www.gbif.org/developer/occurrence#occurrence">https://www.gbif.org/developer/occurrence#occurrence</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
occ_get(key=855998194)

# many occurrences
occ_get(key=c(101010, 240713150, 855998194))

# Verbatim data
occ_get_verbatim(key=855998194)
occ_get_verbatim(key=855998194, fields='all')
occ_get_verbatim(key=855998194,
 fields=c('scientificName', 'lastCrawled', 'county'))
occ_get_verbatim(key=c(855998194, 620594291))
occ_get_verbatim(key=c(855998194, 620594291), fields='all')
occ_get_verbatim(key=c(855998194, 620594291),
   fields=c('scientificName', 'decimalLatitude', 'basisOfRecord'))

# curl options, pass in a named list
occ_get(key=855998194, curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_issues'>Parse and examine further GBIF occurrence issues on a dataset.</h2><span id='topic+occ_issues'></span>

<h3>Description</h3>

<p>Parse and examine further GBIF occurrence issues on a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_issues(.data, ..., mutate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_issues_+3A_.data">.data</code></td>
<td>
<p>Output from a call to <code><a href="#topic+occ_search">occ_search()</a></code>, <code><a href="#topic+occ_data">occ_data()</a></code>, or
<code><a href="#topic+occ_download_import">occ_download_import()</a></code>. The data from <code>occ_download_import</code>
is just a regular data.frame so you can pass in a data.frame to this
function, but if it doesn't have certain columns it will fail.</p>
</td></tr>
<tr><td><code id="occ_issues_+3A_...">...</code></td>
<td>
<p>Named parameters to only get back (e.g. cdround), or to
remove (e.g. -cdround).</p>
</td></tr>
<tr><td><code id="occ_issues_+3A_mutate">mutate</code></td>
<td>
<p>(character) One of:
</p>

<ul>
<li> <p><code>split</code> Split issues into new columns.
</p>
</li>
<li> <p><code>expand</code> Expand issue abbreviated codes into descriptive names.
for downloads datasets, this is not super useful since the
issues come to you as expanded already.
</p>
</li>
<li> <p><code>split_expand</code> Split into new columns, and expand issue names.
</p>
</li></ul>

<p>For split and split_expand, values in cells become y (&quot;yes&quot;) or n (&quot;no&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also the vignette <strong>Cleaning data using GBIF issues</strong>
</p>
<p>Note that you can also query based on issues, e.g.,
<code>occ_search(taxonKey=1, issue='DEPTH_UNLIKELY')</code>. However, I imagine
it's more likely that you want to search for occurrences based on a
taxonomic name, or geographic area, not based on issues, so it makes sense
to pull data down, then clean as needed using this function.
</p>
<p>This function only affects the <code>data</code> element in the <code>gbif</code> class that is
returned from a call to <code><a href="#topic+occ_search">occ_search()</a></code>. Maybe in a future version
we will remove the associated records from the <code>hierarchy</code> and <code>media</code>
elements as they are removed from the <code>data</code> element.
</p>
<p>You'll notice that we sort columns to make it easier to glimpse the important
parts of your data, namely taxonomic name, taxon key, latitude and longitude,
and the issues. The columns are unchanged otherwise.
</p>


<h3>References</h3>

<p>https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/OccurrenceIssue.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# what do issues mean, can print whole table
head(gbif_issues())
# or just occurrence related issues
gbif_issues()[which(gbif_issues()$type %in% c("occurrence")),]
# or search for matches
iss &lt;- c('cdround','cudc','gass84','txmathi')
gbif_issues()[ gbif_issues()$code %in% iss, ]

# compare out data to after occ_issues use
(out &lt;- occ_search(limit=100))
out %&gt;% occ_issues(cdround)

# occ_data
(out &lt;- occ_data(limit=100))
out %&gt;% occ_issues(cdround)

# Parsing output by issue
(res &lt;- occ_data(
  geometry='POLYGON((30.1 10.1,40 40,20 40,10 20,30.1 10.1))',
  limit = 600))

## or parse issues in various ways
### include only rows with cdround issue
gg &lt;- res %&gt;% occ_issues(cdround)
NROW(res$data)
NROW(gg$data)
head(res$data)[,c(1:5)]
head(gg$data)[,c(1:5)]

### remove data rows with certain issue classes
res %&gt;% occ_issues(-cdround, -cudc)

### split issues into separate columns
res %&gt;% occ_issues(mutate = "split")
res %&gt;% occ_issues(-cudc, -mdatunl, mutate = "split")
res %&gt;% occ_issues(gass84, mutate = "split")

### expand issues to more descriptive names
res %&gt;% occ_issues(mutate = "expand")

### split and expand
res %&gt;% occ_issues(mutate = "split_expand")

### split, expand, and remove an issue class
res %&gt;% occ_issues(-cdround, mutate = "split_expand")

## Or you can use occ_issues without %&gt;%
occ_issues(res, -cdround, mutate = "split_expand")

# from GBIF downloaded data via occ_download_* functions
res &lt;- occ_download_get(key="0000066-140928181241064", overwrite=TRUE)
x &lt;- occ_download_import(res)
occ_issues(x, -txmathi)
occ_issues(x, txmathi)
occ_issues(x, gass84)
occ_issues(x, zerocd)
occ_issues(x, gass84, txmathi)
occ_issues(x, mutate = "split")
occ_issues(x, -gass84, mutate = "split")
occ_issues(x, mutate = "expand")
occ_issues(x, mutate = "split_expand")

# occ_search/occ_data with many inputs - give slightly different output
# format than normal 2482598, 2498387
xyz &lt;- occ_data(taxonKey = c(9362842, 2492483, 2435099), limit = 300)
xyz
length(xyz) # length 3
names(xyz) # matches taxonKey values passed in
occ_issues(xyz, -gass84)
occ_issues(xyz, -cdround)
occ_issues(xyz, -cdround, -gass84)

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_metadata'>Search for catalog numbers, collection codes, collector names, and
institution codes.</h2><span id='topic+occ_metadata'></span>

<h3>Description</h3>

<p>Search for catalog numbers, collection codes, collector names, and
institution codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_metadata(
  type = "catalogNumber",
  q = NULL,
  limit = 5,
  pretty = TRUE,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_metadata_+3A_type">type</code></td>
<td>
<p>Type of data, one of catalogNumber, collectionCode, recordedBy,
or institutionCode. Unique partial strings work too, like 'cat' for
catalogNumber</p>
</td></tr>
<tr><td><code id="occ_metadata_+3A_q">q</code></td>
<td>
<p>Search term</p>
</td></tr>
<tr><td><code id="occ_metadata_+3A_limit">limit</code></td>
<td>
<p>Number of results, default=5</p>
</td></tr>
<tr><td><code id="occ_metadata_+3A_pretty">pretty</code></td>
<td>
<p>Pretty as true (Default) uses cat to print data, <code>FALSE</code> gives
character strings.</p>
</td></tr>
<tr><td><code id="occ_metadata_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://www.gbif.org/developer/occurrence#search">https://www.gbif.org/developer/occurrence#search</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# catalog number
occ_metadata(type = "catalogNumber", q=122)

# collection code
occ_metadata(type = "collectionCode", q=12)

# institution code
occ_metadata(type = "institutionCode", q='GB')

# recorded by
occ_metadata(type = "recordedBy", q='scott')

# data as character strings
occ_metadata(type = "catalogNumber", q=122, pretty=FALSE)

# Change number of results returned
occ_metadata(type = "catalogNumber", q=122, limit=10)

# Partial unique type strings work too
occ_metadata(type = "cat", q=122)

# Pass on curl options
occ_metadata(type = "cat", q=122, curlopts = list(verbose = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_search'>Search for GBIF occurrences</h2><span id='topic+occ_search'></span>

<h3>Description</h3>

<p>Search for GBIF occurrences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_search(
  taxonKey = NULL,
  scientificName = NULL,
  country = NULL,
  publishingCountry = NULL,
  hasCoordinate = NULL,
  typeStatus = NULL,
  recordNumber = NULL,
  lastInterpreted = NULL,
  continent = NULL,
  geometry = NULL,
  geom_big = "asis",
  geom_size = 40,
  geom_n = 10,
  recordedBy = NULL,
  recordedByID = NULL,
  identifiedByID = NULL,
  basisOfRecord = NULL,
  datasetKey = NULL,
  eventDate = NULL,
  catalogNumber = NULL,
  year = NULL,
  month = NULL,
  decimalLatitude = NULL,
  decimalLongitude = NULL,
  elevation = NULL,
  depth = NULL,
  institutionCode = NULL,
  collectionCode = NULL,
  hasGeospatialIssue = NULL,
  issue = NULL,
  search = NULL,
  mediaType = NULL,
  subgenusKey = NULL,
  repatriated = NULL,
  phylumKey = NULL,
  kingdomKey = NULL,
  classKey = NULL,
  orderKey = NULL,
  familyKey = NULL,
  genusKey = NULL,
  speciesKey = NULL,
  establishmentMeans = NULL,
  degreeOfEstablishment = NULL,
  protocol = NULL,
  license = NULL,
  organismId = NULL,
  publishingOrg = NULL,
  stateProvince = NULL,
  waterBody = NULL,
  locality = NULL,
  occurrenceStatus = "PRESENT",
  gadmGid = NULL,
  coordinateUncertaintyInMeters = NULL,
  verbatimScientificName = NULL,
  eventId = NULL,
  identifiedBy = NULL,
  networkKey = NULL,
  verbatimTaxonId = NULL,
  occurrenceId = NULL,
  organismQuantity = NULL,
  organismQuantityType = NULL,
  relativeOrganismQuantity = NULL,
  iucnRedListCategory = NULL,
  lifeStage = NULL,
  isInCluster = NULL,
  distanceFromCentroidInMeters = NULL,
  geoDistance = NULL,
  sex = NULL,
  dwcaExtension = NULL,
  gbifId = NULL,
  gbifRegion = NULL,
  projectId = NULL,
  programme = NULL,
  preparations = NULL,
  datasetId = NULL,
  datasetName = NULL,
  publishedByGbifRegion = NULL,
  island = NULL,
  islandGroup = NULL,
  taxonId = NULL,
  taxonConceptId = NULL,
  taxonomicStatus = NULL,
  acceptedTaxonKey = NULL,
  collectionKey = NULL,
  institutionKey = NULL,
  otherCatalogNumbers = NULL,
  georeferencedBy = NULL,
  installationKey = NULL,
  hostingOrganizationKey = NULL,
  crawlId = NULL,
  modified = NULL,
  higherGeography = NULL,
  fieldNumber = NULL,
  parentEventId = NULL,
  samplingProtocol = NULL,
  sampleSizeUnit = NULL,
  pathway = NULL,
  gadmLevel0Gid = NULL,
  gadmLevel1Gid = NULL,
  gadmLevel2Gid = NULL,
  gadmLevel3Gid = NULL,
  earliestEonOrLowestEonothem = NULL,
  latestEonOrHighestEonothem = NULL,
  earliestEraOrLowestErathem = NULL,
  latestEraOrHighestErathem = NULL,
  earliestPeriodOrLowestSystem = NULL,
  latestPeriodOrHighestSystem = NULL,
  earliestEpochOrLowestSeries = NULL,
  latestEpochOrHighestSeries = NULL,
  earliestAgeOrLowestStage = NULL,
  latestAgeOrHighestStage = NULL,
  lowestBiostratigraphicZone = NULL,
  highestBiostratigraphicZone = NULL,
  group = NULL,
  formation = NULL,
  member = NULL,
  bed = NULL,
  associatedSequences = NULL,
  isSequenced = NULL,
  startDayOfYear = NULL,
  endDayOfYear = NULL,
  limit = 500,
  start = 0,
  fields = "all",
  return = NULL,
  facet = NULL,
  facetMincount = NULL,
  facetMultiselect = NULL,
  skip_validate = TRUE,
  curlopts = list(http_version = 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_search_+3A_taxonkey">taxonKey</code></td>
<td>
<p>(numeric) A taxon key from the GBIF backbone. All included
and synonym taxa are included in the search, so a search for aves with
taxononKey=212 will match all birds, no matter which species. You can pass
many keys to <code>occ_search(taxonKey=c(1,212))</code>.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_scientificname">scientificName</code></td>
<td>
<p>A scientific name from the GBIF backbone. All included
and synonym taxa are included in the search.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_country">country</code></td>
<td>
<p>(character) The 2-letter country code (ISO-3166-1)
in which the occurrence was recorded. <code>enumeration_country()</code>.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_publishingcountry">publishingCountry</code></td>
<td>
<p>The 2-letter country code (as per ISO-3166-1) of
the country in which the occurrence was recorded. See
<code>enumeration_country()</code>.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_hascoordinate">hasCoordinate</code></td>
<td>
<p>(logical) Return only occurrence records with lat/long
data (<code>TRUE</code>) or all records (<code>FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_typestatus">typeStatus</code></td>
<td>
<p>Type status of the specimen. One of many
<a href="https://www.gbif.org/occurrence/search?type_status=PARATYPE">options</a>.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_recordnumber">recordNumber</code></td>
<td>
<p>Number recorded by collector of the data, different from
GBIF record number.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_lastinterpreted">lastInterpreted</code></td>
<td>
<p>Date the record was last modified in GBIF, in ISO
8601 format: yyyy, yyyy-MM, yyyy-MM-dd, or MM-dd.  Supports range queries,
'smaller,larger' (e.g., '1990,1991', whereas '1991,1990' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_continent">continent</code></td>
<td>
<p>The source supplied continent.
</p>

<ul>
<li><p> &quot;africa&quot;
</p>
</li>
<li><p> &quot;antarctica&quot;
</p>
</li>
<li><p> &quot;asia&quot;
</p>
</li>
<li><p> &quot;europe&quot;
</p>
</li>
<li><p> &quot;north_america&quot;
</p>
</li>
<li><p> &quot;oceania&quot;
</p>
</li>
<li><p> &quot;south_america&quot;
</p>
</li></ul>

<p>Continent is not inferred but only populated if provided by the
dataset publisher. Applying this filter may exclude many relevant records.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_geometry">geometry</code></td>
<td>
<p>(character) Searches for occurrences inside a polygon in
Well Known Text (WKT) format. A WKT shape written as either
</p>

<ul>
<li><p> &quot;POINT&quot;
</p>
</li>
<li><p> &quot;LINESTRING&quot;
</p>
</li>
<li><p> &quot;LINEARRING&quot;
</p>
</li>
<li><p> &quot;POLYGON&quot;
</p>
</li>
<li><p> &quot;MULTIPOLYGON&quot;
</p>
</li></ul>

<p>For Example, &quot;POLYGON((37.08 46.86,38.06 46.86,38.06 47.28,37.08 47.28,
37.0 46.8))&quot;. See also the section <strong>WKT</strong> below.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_geom_big">geom_big</code></td>
<td>
<p>(character) One&quot;bbox&quot; or &quot;asis&quot; (default).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_geom_size">geom_size</code></td>
<td>
<p>(integer) An integer indicating size of the cell. Default:
40.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_geom_n">geom_n</code></td>
<td>
<p>(integer) An integer indicating number of cells in each
dimension. Default: 10.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_recordedby">recordedBy</code></td>
<td>
<p>(character) The person who recorded the occurrence.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_recordedbyid">recordedByID</code></td>
<td>
<p>(character) Identifier (e.g. ORCID) for the person who
recorded the occurrence</p>
</td></tr>
<tr><td><code id="occ_search_+3A_identifiedbyid">identifiedByID</code></td>
<td>
<p>(character) Identifier (e.g. ORCID) for the person who
provided the taxonomic identification of the occurrence.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_basisofrecord">basisOfRecord</code></td>
<td>
<p>(character) The specific nature of the data record. See
<a href="https://gbif.github.io/parsers/apidocs/org/gbif/api/vocabulary/BasisOfRecord.html">here</a>.
</p>

<ul>
<li><p> &quot;FOSSIL_SPECIMEN&quot;
</p>
</li>
<li><p> &quot;HUMAN_OBSERVATION&quot;
</p>
</li>
<li><p> &quot;MATERIAL_CITATION&quot;
</p>
</li>
<li><p> &quot;MATERIAL_SAMPLE&quot;
</p>
</li>
<li><p> &quot;LIVING_SPECIMEN&quot;
</p>
</li>
<li><p> &quot;MACHINE_OBSERVATION&quot;
</p>
</li>
<li><p> &quot;OBSERVATION&quot;
</p>
</li>
<li><p> &quot;PRESERVED_SPECIMEN&quot;
</p>
</li>
<li><p> &quot;OCCURRENCE&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="occ_search_+3A_datasetkey">datasetKey</code></td>
<td>
<p>(character) The occurrence dataset uuid key. That can be
found in the dataset page url. For example, &quot;7e380070-f762-11e1-a439-00145
eb45e9a&quot; is the key for <a href="https://www.gbif.org/dataset/7e380070-f762-11e1-a439-00145eb45e9a">Natural History Museum (London) Collection Specimens</a>.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_eventdate">eventDate</code></td>
<td>
<p>(character) Occurrence date in ISO 8601 format: yyyy,
yyyy-MM, yyyy-MM-dd, or MM-dd. Supports range queries, 'smaller,larger'
('1990,1991', whereas '1991,1990' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_catalognumber">catalogNumber</code></td>
<td>
<p>(character) An identifier of any form assigned by the
source within a physical collection or digital dataset for the record which
may not unique, but should be fairly unique in combination with the
institution and collection code.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_year">year</code></td>
<td>
<p>The 4 digit year. A year of 98 will be interpreted as AD 98.
Supports range queries, 'smaller,larger' (e.g., '1990,1991', whereas 1991,
1990' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_month">month</code></td>
<td>
<p>The month of the year, starting with 1 for January. Supports
range queries, 'smaller,larger' (e.g., '1,2', whereas '2,1' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_decimallatitude">decimalLatitude</code></td>
<td>
<p>Latitude in decimals between -90 and 90 based on
WGS84. Supports range queries, 'smaller,larger' (e.g., '25,30', whereas
'30,25' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_decimallongitude">decimalLongitude</code></td>
<td>
<p>Longitude in decimals between -180 and 180 based on
WGS84. Supports range queries (e.g., '-0.4,-0.2', whereas '-0.2,-0.4'
wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_elevation">elevation</code></td>
<td>
<p>Elevation in meters above sea level. Supports range
queries, 'smaller,larger' (e.g., '5,30', whereas '30,5' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_depth">depth</code></td>
<td>
<p>Depth in meters relative to elevation. For example 10 meters
below a lake surface with given elevation. Supports range queries,
'smaller,larger' (e.g., '5,30', whereas '30,5' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_institutioncode">institutionCode</code></td>
<td>
<p>An identifier of any form assigned by the source to
identify the institution the record belongs to.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_collectioncode">collectionCode</code></td>
<td>
<p>(character) An identifier of any form assigned by the
source to identify the physical collection or digital dataset uniquely within
the text of an institution.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_hasgeospatialissue">hasGeospatialIssue</code></td>
<td>
<p>(logical) Includes/excludes occurrence records
which contain spatial issues (as determined in our record interpretation),
i.e. <code>hasGeospatialIssue=TRUE</code> returns only those records with spatial
issues while <code>hasGeospatialIssue=FALSE</code> includes only records without
spatial issues. The absence of this parameter returns any record with or
without spatial issues.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_issue">issue</code></td>
<td>
<p>(character) One or more of many possible issues with each
occurrence record. Issues passed to this parameter filter results by
the issue. One of many <a href="https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/OccurrenceIssue.html">options</a>.
See <a href="https://data-blog.gbif.org/post/issues-and-flags/">here</a> for definitions.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_search">search</code></td>
<td>
<p>(character) Query terms. The value for this parameter can be a
simple word or a phrase. For example, <a href="https://www.gbif.org/occurrence/search?q=puma">search=&quot;puma&quot;</a></p>
</td></tr>
<tr><td><code id="occ_search_+3A_mediatype">mediaType</code></td>
<td>
<p>(character) Media type of &quot;MovingImage&quot;, &quot;Sound&quot;, or
&quot;StillImage&quot;.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_subgenuskey">subgenusKey</code></td>
<td>
<p>(numeric) Subgenus classification key.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_repatriated">repatriated</code></td>
<td>
<p>(character) Searches for records whose publishing country
is different to the country where the record was recorded in.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_phylumkey">phylumKey</code></td>
<td>
<p>(numeric) Phylum classification key.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_kingdomkey">kingdomKey</code></td>
<td>
<p>(numeric) Kingdom classification key.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_classkey">classKey</code></td>
<td>
<p>(numeric) Class classification key.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_orderkey">orderKey</code></td>
<td>
<p>(numeric) Order classification key.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_familykey">familyKey</code></td>
<td>
<p>(numeric) Family classification key.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_genuskey">genusKey</code></td>
<td>
<p>(numeric) Genus classification key.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_specieskey">speciesKey</code></td>
<td>
<p>(numeric) Species classification key.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_establishmentmeans">establishmentMeans</code></td>
<td>
<p>(character) provides information about whether an
organism or organisms have been introduced to a given place and time through
the direct or indirect activity of modern humans.
</p>

<ul>
<li><p> &quot;Introduced&quot;
</p>
</li>
<li><p> &quot;Native&quot;
</p>
</li>
<li><p> &quot;NativeReintroduced&quot;
</p>
</li>
<li><p> &quot;Vagrant&quot;
</p>
</li>
<li><p> &quot;Uncertain&quot;
</p>
</li>
<li><p> &quot;IntroducedAssistedColonisation&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="occ_search_+3A_degreeofestablishment">degreeOfEstablishment</code></td>
<td>
<p>(character) Provides information about degree to
which an Organism survives, reproduces, and expands its range at the given
place and time. One of many <a href="https://www.gbif.org/occurrence/search?advanced=1&amp;degree_of_establishment=Managed">options</a>.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_protocol">protocol</code></td>
<td>
<p>(character) Protocol or mechanism used to provide the
occurrence record. One of many <a href="https://www.gbif.org/occurrence/search?protocol=DWC_ARCHIVE&amp;advanced=1">options</a>.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_license">license</code></td>
<td>
<p>(character) The type license applied to the dataset or record.
</p>

<ul>
<li><p> &quot;CC0_1_0&quot;
</p>
</li>
<li><p> &quot;CC_BY_4_0&quot;
</p>
</li>
<li><p> &quot;CC_BY_NC_4_0&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="occ_search_+3A_organismid">organismId</code></td>
<td>
<p>(numeric) An identifier for the Organism instance (as
opposed to a particular digital record of the Organism). May be a globally
unique identifier or an identifier specific to the data set.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_publishingorg">publishingOrg</code></td>
<td>
<p>(character) The publishing organization key (a UUID).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_stateprovince">stateProvince</code></td>
<td>
<p>(character) The name of the next smaller administrative
region than country (state, province, canton, department, region, etc.) in
which the Location occurs.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_waterbody">waterBody</code></td>
<td>
<p>(character) The name of the water body in which the
locations occur</p>
</td></tr>
<tr><td><code id="occ_search_+3A_locality">locality</code></td>
<td>
<p>(character) The specific description of the place.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_occurrencestatus">occurrenceStatus</code></td>
<td>
<p>(character)  Default is &quot;PRESENT&quot;. Specify whether
search should return &quot;PRESENT&quot; or &quot;ABSENT&quot; data.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_gadmgid">gadmGid</code></td>
<td>
<p>(character) The gadm id of the area occurrences are desired
from. https://gadm.org/.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_coordinateuncertaintyinmeters">coordinateUncertaintyInMeters</code></td>
<td>
<p>A number or range between 0-1,000,000
which specifies the desired coordinate uncertainty. A coordinateUncertainty
InMeters=1000 will be interpreted all records with exactly 1000m. Supports
range queries, 'smaller,larger' (e.g., '1000,10000', whereas '10000,1000'
wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_verbatimscientificname">verbatimScientificName</code></td>
<td>
<p>(character) Scientific name as provided by the
source.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_eventid">eventId</code></td>
<td>
<p>(character) identifier(s) for a sampling event.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_identifiedby">identifiedBy</code></td>
<td>
<p>(character)  names of people, groups, or organizations.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_networkkey">networkKey</code></td>
<td>
<p>(character) The occurrence network key (a uuid)
who assigned the Taxon to the subject.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_verbatimtaxonid">verbatimTaxonId</code></td>
<td>
<p>(character) The taxon identifier provided to GBIF by
the data publisher.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_occurrenceid">occurrenceId</code></td>
<td>
<p>(character) occurrence id from source.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_organismquantity">organismQuantity</code></td>
<td>
<p>A number or range which
specifies the desired organism quantity. An organismQuantity=5
will be interpreted all records with exactly 5. Supports range queries,
smaller,larger (e.g., '5,20', whereas '20,5' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_organismquantitytype">organismQuantityType</code></td>
<td>
<p>(character) The type of quantification system
used for the quantity of organisms. For example, &quot;individuals&quot; or &quot;biomass&quot;.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_relativeorganismquantity">relativeOrganismQuantity</code></td>
<td>
<p>(numeric) A relativeOrganismQuantity=0.1 will
be interpreted all records with exactly 0.1 The relative measurement of the
quantity of the organism (a number between 0-1). Supports range queries,
&quot;smaller,larger&quot; (e.g., '0.1,0.5', whereas '0.5,0.1' wouldn't work).</p>
</td></tr>
<tr><td><code id="occ_search_+3A_iucnredlistcategory">iucnRedListCategory</code></td>
<td>
<p>(character) The IUCN threat status category.
</p>

<ul>
<li><p> &quot;NE&quot; (Not Evaluated)
</p>
</li>
<li><p> &quot;DD&quot; (Data Deficient)
</p>
</li>
<li><p> &quot;LC&quot; (Least Concern)
</p>
</li>
<li><p> &quot;NT&quot; (Near Threatened)
</p>
</li>
<li><p> &quot;VU&quot; (Vulnerable)
</p>
</li>
<li><p> &quot;EN&quot; (Endangered)
</p>
</li>
<li><p> &quot;CR&quot; (Critically Endangered)
</p>
</li>
<li><p> &quot;EX&quot; (Extinct)
</p>
</li>
<li><p> &quot;EW&quot; (Extinct in the Wild)
</p>
</li></ul>
</td></tr>
<tr><td><code id="occ_search_+3A_lifestage">lifeStage</code></td>
<td>
<p>(character) the life stage of the occurrence. One of many
<a href="https://www.gbif.org/occurrence/search?advanced=1&amp;life_stage=Tadpole">options</a>.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_isincluster">isInCluster</code></td>
<td>
<p>(logical) identify potentially related records on GBIF.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_distancefromcentroidinmeters">distanceFromCentroidInMeters</code></td>
<td>
<p>A number or range. A value of &quot;2000,*&quot;
means at least 2km from known centroids. A value of &quot;0&quot; would mean occurrences
exactly on known centroids. A value of &quot;0,2000&quot; would mean within 2km of
centroids. Max value is 5000.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_geodistance">geoDistance</code></td>
<td>
<p>(character) Filters to match occurrence records with coordinate values
within a specified distance of a coordinate. Distance may be specified in
kilometres (km) or metres (m). Example : &quot;90,100,5km&quot;</p>
</td></tr>
<tr><td><code id="occ_search_+3A_sex">sex</code></td>
<td>
<p>(character) The sex of the biological individual(s) represented in the occurrence.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_dwcaextension">dwcaExtension</code></td>
<td>
<p>(character) A known Darwin Core Archive extension RowType.
Limits the search to occurrences which have this extension, although they will
not necessarily have any useful data recorded using the extension.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_gbifid">gbifId</code></td>
<td>
<p>(numeric) The unique GBIF key for a single occurrence.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_gbifregion">gbifRegion</code></td>
<td>
<p>(character) Gbif region based on country code.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_projectid">projectId</code></td>
<td>
<p>(character) The identifier for a project, which is often
assigned by a funded programme.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_programme">programme</code></td>
<td>
<p>(character) A group of activities, often associated with a
specific funding stream, such as the GBIF BID programme.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_preparations">preparations</code></td>
<td>
<p>(character) Preparation or preservation method for
a specimen.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_datasetid">datasetId</code></td>
<td>
<p>(character) The ID of the dataset. Parameter may be
repeated. Example : https://doi.org/10.1594/PANGAEA.315492</p>
</td></tr>
<tr><td><code id="occ_search_+3A_datasetname">datasetName</code></td>
<td>
<p>(character) The exact name of the dataset. Not the same as
dataset title.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_publishedbygbifregion">publishedByGbifRegion</code></td>
<td>
<p>(character) GBIF region based on the owning
organization's country.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_island">island</code></td>
<td>
<p>(character) The name of the island on or near which the
location occurs.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_islandgroup">islandGroup</code></td>
<td>
<p>(character) The name of the island group in which the
location occurs.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_taxonid">taxonId</code></td>
<td>
<p>(character) The taxon identifier provided to GBIF by the data
publisher. Example : urn:lsid:dyntaxa.se:Taxon:103026</p>
</td></tr>
<tr><td><code id="occ_search_+3A_taxonconceptid">taxonConceptId</code></td>
<td>
<p>(character) An identifier for the taxonomic concept to
which the record refers - not for the nomenclatural details of a taxon.
Example : 8fa58e08-08de-4ac1-b69c-1235340b7001</p>
</td></tr>
<tr><td><code id="occ_search_+3A_taxonomicstatus">taxonomicStatus</code></td>
<td>
<p>(character) A taxonomic status. Example : SYNONYM</p>
</td></tr>
<tr><td><code id="occ_search_+3A_acceptedtaxonkey">acceptedTaxonKey</code></td>
<td>
<p>(numeric) A taxon key from the GBIF backbone. Only
synonym taxa are included in the search, so a search for Aves with
acceptedTaxonKey=212 will match occurrences identified as birds, but not
any known family, genus or species of bird.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_collectionkey">collectionKey</code></td>
<td>
<p>(character) A key (UUID) for a collection registered in
the Global Registry of Scientific Collections.
Example : dceb8d52-094c-4c2c-8960-75e0097c6861</p>
</td></tr>
<tr><td><code id="occ_search_+3A_institutionkey">institutionKey</code></td>
<td>
<p>(character) A key (UUID) for an institution registered
in the Global Registry of Scientific Collections.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_othercatalognumbers">otherCatalogNumbers</code></td>
<td>
<p>(character) Previous or alternate fully qualified
catalog numbers.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_georeferencedby">georeferencedBy</code></td>
<td>
<p>(character) Name of a person, group, or organization
who determined the georeference (spatial representation) for the location.
Example : Brad Millen</p>
</td></tr>
<tr><td><code id="occ_search_+3A_installationkey">installationKey</code></td>
<td>
<p>(character) The occurrence installation key (a UUID).
Example : 17a83780-3060-4851-9d6f-029d5fcb81c9</p>
</td></tr>
<tr><td><code id="occ_search_+3A_hostingorganizationkey">hostingOrganizationKey</code></td>
<td>
<p>(character) The key (UUID) of the publishing
organization whose installation (server) hosts the original dataset.
Example : fbca90e3-8aed-48b1-84e3-369afbd000ce</p>
</td></tr>
<tr><td><code id="occ_search_+3A_crawlid">crawlId</code></td>
<td>
<p>(numeric) Crawl attempt that harvested this record.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_modified">modified</code></td>
<td>
<p>(character) The most recent date-time on which the
occurrence was changed, according to the publisher. Can be a range.
Example : 2023-02-20</p>
</td></tr>
<tr><td><code id="occ_search_+3A_highergeography">higherGeography</code></td>
<td>
<p>(character) Geographic name less specific than the
information captured in the locality term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_fieldnumber">fieldNumber</code></td>
<td>
<p>(character) An identifier given to the event in the field.
Often serves as a link between field notes and the event.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_parenteventid">parentEventId</code></td>
<td>
<p>(character) An identifier for the information associated
with a sampling event.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_samplingprotocol">samplingProtocol</code></td>
<td>
<p>(character) The name of, reference to, or description
of the method or protocol used during a sampling event.
Example : malaise trap</p>
</td></tr>
<tr><td><code id="occ_search_+3A_samplesizeunit">sampleSizeUnit</code></td>
<td>
<p>(character) The unit of measurement of the size
(time duration, length, area, or volume) of a sample in a sampling event.
Example : hectares</p>
</td></tr>
<tr><td><code id="occ_search_+3A_pathway">pathway</code></td>
<td>
<p>(character) The process by which an organism came to be in a
given place at a given time, as defined in the GBIF Pathway vocabulary.
Example : Agriculture</p>
</td></tr>
<tr><td><code id="occ_search_+3A_gadmlevel0gid">gadmLevel0Gid</code></td>
<td>
<p>(character) A GADM geographic identifier at the zero
level, for example AGO.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_gadmlevel1gid">gadmLevel1Gid</code></td>
<td>
<p>(character) A GADM geographic identifier at the first
level, for example AGO.1_1.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_gadmlevel2gid">gadmLevel2Gid</code></td>
<td>
<p>(character) A GADM geographic identifier at the second
level, for example AFG.1.1_1.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_gadmlevel3gid">gadmLevel3Gid</code></td>
<td>
<p>(character) A GADM geographic identifier at the third
level, for example AFG.1.1.1_1.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_earliesteonorlowesteonothem">earliestEonOrLowestEonothem</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_latesteonorhighesteonothem">latestEonOrHighestEonothem</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_earliesteraorlowesterathem">earliestEraOrLowestErathem</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_latesteraorhighesterathem">latestEraOrHighestErathem</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_earliestperiodorlowestsystem">earliestPeriodOrLowestSystem</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_latestperiodorhighestsystem">latestPeriodOrHighestSystem</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_earliestepochorlowestseries">earliestEpochOrLowestSeries</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_latestepochorhighestseries">latestEpochOrHighestSeries</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_earliestageorloweststage">earliestAgeOrLowestStage</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_latestageorhigheststage">latestAgeOrHighestStage</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_lowestbiostratigraphiczone">lowestBiostratigraphicZone</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_highestbiostratigraphiczone">highestBiostratigraphicZone</code></td>
<td>
<p>(character) geochronologic era term.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_group">group</code></td>
<td>
<p>(character) The full name of the lithostratigraphic group from
which the material entity was collected.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_formation">formation</code></td>
<td>
<p>(character) The full name of the lithostratigraphic
formation from which the material entity was collected.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_member">member</code></td>
<td>
<p>(character) The full name of the lithostratigraphic member
from which the material entity was collected.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_bed">bed</code></td>
<td>
<p>(character) The full name of the lithostratigraphic bed from
which the material entity was collected.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_associatedsequences">associatedSequences</code></td>
<td>
<p>(character) Identifier (publication, global unique
identifier, URI) of genetic sequence information associated with the
material entity. Example : http://www.ncbi.nlm.nih.gov/nuccore/U34853.1</p>
</td></tr>
<tr><td><code id="occ_search_+3A_issequenced">isSequenced</code></td>
<td>
<p>(logical) Indicates whether <code>associatedSequences</code> genetic
sequence information exists.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_startdayofyear">startDayOfYear</code></td>
<td>
<p>(numeric) The earliest integer day of the year on
which the event occurred.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_enddayofyear">endDayOfYear</code></td>
<td>
<p>(numeric) The latest integer day of the year on
which the event occurred.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 500. Note that the per
request maximum is 300, but since we set it at 500 for the function, we
do two requests to get you the 500 records (if there are that many).
Note that there is a hard maximum of 100,000, which is calculated as the
<code>limit+start</code>, so <code>start=99,000</code> and <code>limit=2000</code> won't work</p>
</td></tr>
<tr><td><code id="occ_search_+3A_start">start</code></td>
<td>
<p>Record number to start at. Use in combination with limit to
page through results. Note that we do the paging internally for you, but
you can manually set the <code>start</code> parameter</p>
</td></tr>
<tr><td><code id="occ_search_+3A_fields">fields</code></td>
<td>
<p>(character) Default ('all') returns all fields. 'minimal'
returns just taxon name, key, datasetKey, latitude, and longitute. Or specify each field
you want returned by name, e.g. fields = c('name','latitude','elevation').</p>
</td></tr>
<tr><td><code id="occ_search_+3A_return">return</code></td>
<td>
<p>Defunct. All components (meta, hierarchy, data, media,
facets) are returned now; index to the one(s) you want. See <code><a href="#topic+occ_data">occ_data()</a></code>
if you just want the data component</p>
</td></tr>
<tr><td><code id="occ_search_+3A_facet">facet</code></td>
<td>
<p>(character) a character vector of length 1 or greater.
Required.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_facetmincount">facetMincount</code></td>
<td>
<p>(numeric) minimum number of records to be included
in the faceting results</p>
</td></tr>
<tr><td><code id="occ_search_+3A_facetmultiselect">facetMultiselect</code></td>
<td>
<p>(logical) Set to <code>TRUE</code> to still return counts
for values that are not currently filtered. See examples.
Default: <code>FALSE</code>
</p>
<p><strong>Faceting</strong>:
All fields can be faceted on except for last &quot;lastInterpreted&quot;,
&quot;eventDate&quot;, and &quot;geometry&quot;
</p>
<p>You can do facet searches alongside searching occurrence data, and
return both, or only return facets, or only occurrence data, etc.</p>
</td></tr>
<tr><td><code id="occ_search_+3A_skip_validate">skip_validate</code></td>
<td>
<p>(logical) whether to skip <code>wellknown::validate_wkt</code>
call or not. passed down to <code><a href="#topic+check_wkt">check_wkt()</a></code>. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="occ_search_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
<tr><td><code id="occ_search_+3A_...">...</code></td>
<td>
<p>additional facet parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gbif</code>, which is a S3 class list, with
slots for metadata (<code>meta</code>), the occurrence data itself (<code>data</code>),
the taxonomic hierarchy data (<code>hier</code>), and media metadata
(<code>media</code>).
In addition, the object has attributes listing the user supplied arguments
and whether it was a 'single' or 'many' search; that is, if you supply two
values of the <code>datasetKey</code> parameter to searches are done, and it's a
'many'. <code>meta</code> is a list of length four with offset, limit,
endOfRecords and count fields. <code>data</code> is a tibble (aka data.frame). <code>hier</code>
is a list of data.frames of the unique set of taxa found, where each
data.frame is its taxonomic classification. <code>media</code> is a list of media
objects, where each element holds a set of metadata about the media object.
</p>


<h3>Multiple values passed to a parameter</h3>

<p>There are some parameters you can pass multiple values to in a vector,
each value of which produces a different request (multiple different
requests = c(&quot;a&quot;,&quot;b&quot;)). Some parameters allow multiple values to be passed
in the same request (multiple same request = &quot;a;b&quot;) in a semicolon separated
string (e.g., 'a;b'); if given we'll do a single request with that parameter
repeated for each value given (e.g., <code>foo=a&amp;foo=b</code> if the parameter
is <code>foo</code>).
</p>
<p>See article <a href="https://docs.ropensci.org/rgbif/articles/multiple_values.html">Multiple Values</a>.
</p>


<h3>Hierarchies</h3>

<p>Hierarchies are returned with each occurrence object. There is no
option to return them from the API. However, within the <code>occ_search</code>
function you can select whether to return just hierarchies, just data, all
of data and hierarchies and metadata, or just metadata. If all hierarchies
are the same we just return one for you.
</p>


<h3>curl debugging</h3>

<p>You can pass parameters not defined in this function into the call to
the GBIF API to control things about the call itself using <code>curlopts</code>.
See an example below that passes in the <code>verbose</code> function to get
details on the http call.
</p>


<h3>WKT</h3>

<p>Examples of valid WKT objects:
</p>

<ul>
<li><p> 'POLYGON((-19.5 34.1, 27.8 34.1, 35.9 68.1, -25.3 68.1, -19.5 34.1))'
</p>
</li>
<li><p> 'MULTIPOLYGON(((-123 38,-116 38,-116 43,-123 43,-123 38)),((-97 41,-93 41,-93 45,-97 45,-97 41)))'
</p>
</li>
<li><p> 'POINT(-120 40)'
</p>
</li>
<li><p> 'LINESTRING(3 4,10 50,20 25)'
</p>
</li></ul>

<p>Note that GBIF expects counter-clockwise winding order for WKT. You can
supply clockwise WKT, but GBIF treats it as an exclusion, so you get all
data not inside the WKT area. <code><a href="#topic+occ_download">occ_download()</a></code> behaves differently
in that you should simply get no data back at all with clockwise WKT.
</p>


<h3>Long WKT</h3>

<p>Options for handling long WKT strings:
Note that long WKT strings are specially handled when using <code><a href="#topic+occ_search">occ_search</a></code> or
<code><a href="#topic+occ_data">occ_data</a></code>. Here are the three options for long WKT strings (&gt; 1500 characters),
set one of these three via the parameter <code>geom_big</code>:
</p>

<ul>
<li><p> asis - the default setting. This means we don't do anything internally. That is,
we just pass on your WKT string just as we've done before in this package.
</p>
</li>
<li><p> axe - this option is deprecated since rgbif v3.8.0. Might return error,
since the GBIF's polygon interpretation has changed.
</p>
<p>This method uses <code>sf::st_make_grid</code> and <code>sf::st_intersection</code>, which has
two parameters <code>cellsize</code> and <code>n</code>. You can tweak those parameters here by
tweaking <code>geom_size</code> and <code>geom_n</code>. <code>geom_size</code> seems to be more useful in
toggling the number of WKT strings you get back.
</p>
<p>See <code><a href="#topic+wkt_parse">wkt_parse</a></code> to manually break make WKT bounding box from a larger WKT
string, or break a larger WKT string into many smaller ones.
</p>
</li>
<li><p> bbox - this option checks whether your WKT string is longer than 1500 characters,
and if it is we create a bounding box from the WKT, do the GBIF search with that
bounding box, then prune the resulting data to only those occurrences in your original
WKT string. There is a big caveat however. Because we create a bounding box from the WKT,
and the <code>limit</code> parameter determines some subset of records to get, then when we
prune the resulting data to the WKT, the number of records you get could be less than
what you set with your <code>limit</code> parameter. However, you could set the limit to be
high enough so that you get all records back found in that bounding box, then you'll
get all the records available within the WKT.
</p>
</li></ul>



<h3>Counts</h3>

<p>There is a slight difference in the way records are counted here vs.
results from <code><a href="#topic+occ_count">occ_count</a></code>. For equivalent outcomes, in this
function use <code>hasCoordinate=TRUE</code>, and <code>hasGeospatialIssue=FALSE</code>
to have the same outcome using <code><a href="#topic+occ_count">occ_count</a></code> with
<code>isGeoreferenced=TRUE</code>
</p>


<h3>Note</h3>

<p>Maximum number of records you can get with this function is 100,000.
See https://www.gbif.org/developer/occurrence
</p>


<h3>References</h3>

<p>https://www.gbif.org/developer/occurrence#search
</p>


<h3>See Also</h3>

<p><code><a href="#topic+downloads">downloads()</a></code>, <code><a href="#topic+occ_data">occ_data()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Search by species name, using \code{\link{name_backbone}} first to get key
(key &lt;- name_suggest(q='Helianthus annuus', rank='species')$data$key[1])
occ_search(taxonKey=key, limit=2)

# Return 20 results, this is the default by the way
occ_search(taxonKey=key, limit=20)

# Get just metadata
occ_search(taxonKey=key, limit=0)$meta

# Instead of getting a taxon key first, you can search for a name directly
## However, note that using this approach (with \code{scientificName="..."})
## you are getting synonyms too. The results for using \code{scientifcName} and
## \code{taxonKey} parameters are the same in this case, but I wouldn't be surprised if for some
## names they return different results
occ_search(scientificName = 'Ursus americanus')
key &lt;- name_backbone(name = 'Ursus americanus', rank='species')$usageKey
occ_search(taxonKey = key)

# Search by dataset key
occ_search(datasetKey='7b5d6a48-f762-11e1-a439-00145eb45e9a', limit=20)$data

# Search by catalog number
occ_search(catalogNumber="49366", limit=20)
## separate requests: use a vector of strings
occ_search(catalogNumber=c("49366","Bird.27847588"), limit=10)
## one request, many instances of same parameter: use semi-colon sep. string
occ_search(catalogNumber="49366;Bird.27847588", limit=10)

# Get all data, not just lat/long and name
occ_search(taxonKey=key, fields='all', limit=20)

# Or get specific fields. Note that this isn't done on GBIF's side of things. This
# is done in R, but before you get the return object, so other fields are garbage
# collected
occ_search(taxonKey=key, fields=c('name','basisOfRecord','protocol'), limit=20)

# Use paging parameters (limit and start) to page. Note the different results
# for the two queries below.
occ_search(datasetKey='7b5d6a48-f762-11e1-a439-00145eb45e9a',start=10,limit=5)$data
occ_search(datasetKey='7b5d6a48-f762-11e1-a439-00145eb45e9a',start=20,limit=5)$data

# Many dataset keys
## separate requests: use a vector of strings
occ_search(datasetKey=c("50c9509d-22c7-4a22-a47d-8c48425ef4a7",
   "7b5d6a48-f762-11e1-a439-00145eb45e9a"), limit=20)
## one request, many instances of same parameter: use semi-colon sep. string
v="50c9509d-22c7-4a22-a47d-8c48425ef4a7;7b5d6a48-f762-11e1-a439-00145eb45e9a"
occ_search(datasetKey = v, limit=20)

# Occurrence data: lat/long data, and associated metadata with occurrences
## The `data` slot has a data.frame of all data together
## for easy manipulation
occ_search(taxonKey=key, limit=20)$data

# Taxonomic hierarchy data
## In the `hier` slot
occ_search(taxonKey=key, limit=10)$hier

# Search by recorder
occ_search(recordedBy="smith", limit=20)

# Many collector names
occ_search(recordedBy=c("smith","BJ Stacey"), limit=20)

# recordedByID
occ_search(recordedByID="https://orcid.org/0000-0003-1691-239X", limit=20)

# identifiedByID
occ_search(identifiedByID="https://orcid.org/0000-0003-4710-2648", limit=20)

# Pass in curl options for extra fun
occ_search(taxonKey=2433407, limit=20, curlopts=list(verbose=TRUE))$hier
occ_search(taxonKey=2433407, limit=20,
  curlopts = list(
    noprogress = FALSE,
    progressfunction = function(down, up) {
      cat(sprintf("up: %d | down %d\n", up, down))
      return(TRUE)
    }
  )
)$hier
# occ_search(taxonKey=2433407, limit=20,
#   curlopts = list(timeout_ms = 1))

# Search for many species
splist &lt;- c('Cyanocitta stelleri', 'Junco hyemalis', 'Aix sponsa')
keys &lt;- sapply(splist, function(x) name_suggest(x)$data$key[1], USE.NAMES=FALSE)
## separate requests: use a vector of strings
occ_search(taxonKey = keys, limit=5)
## one request, many instances of same parameter: use semi-colon sep. string
occ_search(taxonKey = paste0(keys, collapse = ";"), limit=5)

# Search using a synonym name
#  Note that you'll see a message printing out that the accepted name will be used
occ_search(scientificName = 'Pulsatilla patens', fields = c('name','scientificName'), limit=5)

# Search on latitidue and longitude
occ_search(decimalLatitude=48, decimalLongitude=10)

# Search on a bounding box
## in well known text format
### polygon
occ_search(geometry='POLYGON((30.1 10.1,40 40,20 40,10 20,30.1 10.1))', limit=20)
### multipolygon
wkt &lt;- 'MULTIPOLYGON(((-123 38,-116 38,-116 43,-123 43,-123 38)),
   ((-97 41,-93 41,-93 45,-97 45,-97 41)))'
occ_search(geometry = gsub("\n\\s+", "", wkt), limit = 20)

## taxonKey + WKT
key &lt;- name_suggest(q='Aesculus hippocastanum')$data$key[1]
occ_search(taxonKey=key, geometry='POLYGON((30.1 10.1,40 40,20 40,10 20,30.1 10.1))',
   limit=20)
## or using bounding box, converted to WKT internally
occ_search(geometry=c(-125.0,38.4,-121.8,40.9), limit=20)

# Search on a long WKT string - too long for a GBIF search API request
## We internally convert your WKT string to a bounding box
##  then do the query
##  then clip the results down to just those in the original polygon
##  - Alternatively, you can set the parameter `geom_big="bbox"`
##  - An additional alternative is to use the GBIF download API, see ?downloads
wkt &lt;- "POLYGON((-9.178796777343678 53.22769021556159,
-12.167078027343678 51.56540789297837,
-12.958093652343678 49.78333685689162,-11.024499902343678 49.21251756301334,
-12.079187402343678 46.68179685941719,-15.067468652343678 45.83103608186854,
-15.770593652343678 43.58271629699817,-15.067468652343678 41.57676278827219,
-11.815515527343678 40.44938999172728,-12.958093652343678 37.72112962230871,
-11.639734277343678 36.52987439429357,-8.299890527343678 34.96062625095747,
-8.739343652343678 32.62357394385735,-5.223718652343678 30.90497915232165,
1.1044063476563224 31.80562077746643,1.1044063476563224 30.754036557416256,
6.905187597656322 32.02942785462211,5.147375097656322 32.99292810780193,
9.629796972656322 34.164474406524725,10.860265722656322 32.91918014319603,
14.551671972656322 33.72700959356651,13.409093847656322 34.888564192275204,
16.748937597656322 35.104560368110114,19.561437597656322 34.81643887792552,
18.594640722656322 36.38849705969625,22.989171972656322 37.162874858929854,
19.825109472656322 39.50651757842751,13.760656347656322 38.89353140585116,
14.112218847656322 42.36091601976124,10.596593847656322 41.11488736647705,
9.366125097656322 43.70991402658437,5.059484472656322 42.62015372417812,
2.3348750976563224 45.21526500321446,-0.7412967773436776 46.80225692528942,
6.114171972656322 47.102229890207894,8.047765722656322 45.52399303437107,
12.881750097656322 48.22681126957933,9.190343847656322 48.693079457106684,
8.750890722656322 50.68283120621287,5.059484472656322 50.40356146487845,
4.268468847656322 52.377558897655156,1.4559688476563224 53.28027243658647,
0.8407344726563224 51.62000971578333,0.5770625976563224 49.32721423860726,
-2.5869999023436776 49.49875947592088,-2.4991092773436776 51.18135535408638,
-2.0596561523436776 52.53822562473851,-4.696374902343678 51.67454591918756,
-5.311609277343678 50.009802108095776,-6.629968652343678 48.75106196817059,
-7.684656152343678 50.12263634382465,-6.190515527343678 51.83776110910459,
-5.047937402343678 54.267098895684235,-6.893640527343678 53.69860705549198,
-8.915124902343678 54.77719740243195,-12.079187402343678 54.52294465763567,
-13.573328027343678 53.437631551347174,
-11.288171777343678 53.48995552517918,
-9.178796777343678 53.22769021556159))"
wkt &lt;- gsub("\n", " ", wkt)

#### Default option with large WKT string fails
# res &lt;- occ_search(geometry = wkt)

#### if WKT too long, with 'geom_big=bbox': makes into bounding box
res &lt;- occ_search(geometry = wkt, geom_big = "bbox")$data

# Search on country
occ_search(country='US', fields=c('name','country'), limit=20)
occ_search(country='FR', fields=c('name','country'), limit=20)
occ_search(country='DE', fields=c('name','country'), limit=20)
### separate requests: use a vector of strings
occ_search(country=c('US','DE'), limit=20)
### one request, many instances of same parameter: use semi-colon sep. string
occ_search(country = 'US;DE', limit=20)

# Get only occurrences with lat/long data
occ_search(taxonKey=key, hasCoordinate=TRUE, limit=20)

# Get only occurrences that were recorded as living specimens
occ_search(taxonKey=key, basisOfRecord="LIVING_SPECIMEN", hasCoordinate=TRUE, limit=20)
## multiple values in a vector = a separate request for each value
occ_search(taxonKey=key,
  basisOfRecord=c("LIVING_SPECIMEN", "HUMAN_OBSERVATION"), limit=20)
## mutiple values in a single string, ";" separated = one request including all values
occ_search(taxonKey=key,
  basisOfRecord="LIVING_SPECIMEN;HUMAN_OBSERVATION", limit=20)

# Get occurrences for a particular eventDate
occ_search(taxonKey=key, eventDate="2013", limit=20)
occ_search(taxonKey=key, year="2013", limit=20)
occ_search(taxonKey=key, month="6", limit=20)

# Get occurrences based on depth
key &lt;- name_backbone(name='Salmo salar', kingdom='animals')$speciesKey
occ_search(taxonKey=key, depth="5", limit=20)

# Get occurrences based on elevation
key &lt;- name_backbone(name='Puma concolor', kingdom='animals')$speciesKey
occ_search(taxonKey=key, elevation=50, hasCoordinate=TRUE, limit=20)

# Get occurrences based on institutionCode
occ_search(institutionCode="TLMF", limit=20)
### separate requests: use a vector of strings
occ_search(institutionCode=c("TLMF","ArtDatabanken"), limit=20)
### one request, many instances of same parameter: use semi-colon sep. string
occ_search(institutionCode = "TLMF;ArtDatabanken", limit=20)

# Get occurrences based on collectionCode
occ_search(collectionCode="Floristic Databases MV - Higher Plants", limit=20)
occ_search(collectionCode=c("Floristic Databases MV - Higher Plants","Artport"))

# Get only those occurrences with spatial issues
occ_search(taxonKey=key, hasGeospatialIssue=TRUE, limit=20)

# Search using a query string
occ_search(search = "kingfisher", limit=20)

# search on repatriated - doesn't work right now
# occ_search(repatriated = "")

# search on phylumKey
occ_search(phylumKey = 7707728, limit = 5)

# search on kingdomKey
occ_search(kingdomKey = 1, limit = 5)

# search on classKey
occ_search(classKey = 216, limit = 5)

# search on orderKey
occ_search(orderKey = 7192402, limit = 5)

# search on familyKey
occ_search(familyKey = 3925, limit = 5)

# search on genusKey
occ_search(genusKey = 1935496, limit = 5)

# search on establishmentMeans
occ_search(establishmentMeans = "INVASIVE", limit = 5)
occ_search(establishmentMeans = "NATIVE", limit = 5)
occ_search(establishmentMeans = "UNCERTAIN", limit = 5)

# search on protocol
occ_search(protocol = "DIGIR", limit = 5)

# search on license
occ_search(license = "CC_BY_4_0", limit = 5)

# search on organismId
occ_search(organismId = "100", limit = 5)

# search on publishingOrg
occ_search(publishingOrg = "28eb1a3f-1c15-4a95-931a-4af90ecb574d", limit = 5)

# search on stateProvince
occ_search(stateProvince = "California", limit = 5)

# search on waterBody
occ_search(waterBody = "AMAZONAS BASIN, RIO JURUA", limit = 5)

# search on locality
res &lt;- occ_search(locality = c("Trondheim", "Hovekilen"), limit = 5)
res$Trondheim$data
res$Hovekilen$data



# Range queries
## See Detail for parameters that support range queries
occ_search(depth='50,100') # this is a range depth, with lower/upper limits in character string
occ_search(depth=c(50,100)) # this is not a range search, but does two searches for each depth

## Range search with year
occ_search(year='1999,2000', limit=20)

## Range search with latitude
occ_search(decimalLatitude='29.59,29.6')

## Range search with distanceFromCentroidInMeters 
occ_search(distanceFromCentroidInMeters = "2000,*") # at least 2km from centroids
occ_search(distanceFromCentroidInMeters = "0,2000") # close to centroids within 2km 
occ_search(distanceFromCentroidInMeters = 0) # exactly on centroids

# Search by specimen type status
## Look for possible values of the typeStatus parameter looking at the typestatus dataset
occ_search(typeStatus = 'allotype', fields = c('name','typeStatus'))

# Search by specimen record number
## This is the record number of the person/group that submitted the data, not GBIF's numbers
## You can see that many different groups have record number 1, so not super helpful
occ_search(recordNumber = 1, fields = c('name','recordNumber','recordedBy'))

# Search by last time interpreted: Date the record was last modified in GBIF
## The lastInterpreted parameter accepts ISO 8601 format dates, including
## yyyy, yyyy-MM, yyyy-MM-dd, or MM-dd. Range queries are accepted for lastInterpreted
occ_search(lastInterpreted = '2014-04-02', fields = c('name','lastInterpreted'))

# Search by continent
## One of africa, antarctica, asia, europe, north_america, oceania, or south_america
occ_search(continent = 'south_america')$meta
occ_search(continent = 'africa')$meta
occ_search(continent = 'oceania')$meta
occ_search(continent = 'antarctica')$meta

# Search for occurrences with images
occ_search(mediaType = 'StillImage')$media
occ_search(mediaType = 'MovingImage')$media
occ_search(mediaType = 'Sound')$media

# Query based on issues - see Details for options
## one issue
occ_search(taxonKey=1, issue='DEPTH_UNLIKELY', fields =
   c('name','key','decimalLatitude','decimalLongitude','depth'))
## two issues
occ_search(taxonKey=1, issue=c('DEPTH_UNLIKELY','COORDINATE_ROUNDED'))
# Show all records in the Arizona State Lichen Collection that cant be matched to the GBIF
# backbone properly:
occ_search(datasetKey='84c0e1a0-f762-11e1-a439-00145eb45e9a',
   issue=c('TAXON_MATCH_NONE','TAXON_MATCH_HIGHERRANK'))

# Parsing output by issue
(res &lt;- occ_search(geometry='POLYGON((30.1 10.1,40 40,20 40,10 20,30.1 10.1))', limit = 50))
## what do issues mean, can print whole table, or search for matches
head(gbif_issues())
gbif_issues()[ gbif_issues()$code %in% c('cdround','cudc','gass84','txmathi'), ]
## or parse issues in various ways
### remove data rows with certain issue classes
library('magrittr')
res %&gt;% occ_issues(gass84)
### split issues into separate columns
res %&gt;% occ_issues(mutate = "split")
### expand issues to more descriptive names
res %&gt;% occ_issues(mutate = "expand")
### split and expand
res %&gt;% occ_issues(mutate = "split_expand")
### split, expand, and remove an issue class
res %&gt;% occ_issues(-cudc, mutate = "split_expand")

# If you try multiple values for two different parameters you are wacked on the hand
# occ_search(taxonKey=c(2482598,2492010), recordedBy=c("smith","BJ Stacey"))

# Get a lot of data, here 1500 records for Helianthus annuus
# out &lt;- occ_search(taxonKey=key, limit=1500)
# nrow(out$data)

# If you pass in an invalid polygon you get hopefully informative errors

### the WKT string is fine, but GBIF says bad polygon
wkt &lt;- 'POLYGON((-178.59375 64.83258989321493,-165.9375 59.24622380205539,
-147.3046875 59.065977905449806,-130.78125 51.04484764446178,-125.859375 36.70806354647625,
-112.1484375 23.367471303759686,-105.1171875 16.093320185359257,-86.8359375 9.23767076398516,
-82.96875 2.9485268155066175,-82.6171875 -14.812060061226388,-74.8828125 -18.849111862023985,
-77.34375 -47.661687803329166,-84.375 -49.975955187343295,174.7265625 -50.649460483096114,
179.296875 -42.19189902447192,-176.8359375 -35.634976650677295,176.8359375 -31.835565983656227,
163.4765625 -6.528187613695323,152.578125 1.894796132058301,135.703125 4.702353722559447,
127.96875 15.077427674847987,127.96875 23.689804541429606,139.921875 32.06861069132688,
149.4140625 42.65416193033991,159.2578125 48.3160811030533,168.3984375 57.019804336633165,
178.2421875 59.95776046458139,-179.6484375 61.16708631440347,-178.59375 64.83258989321493))'

# occ_search(geometry = gsub("\n", '', wkt))

### unable to parse due to last number pair needing two numbers, not one
# wkt &lt;- 'POLYGON((-178.5 64.8,-165.9 59.2,-147.3 59.0,-130.7 51.0,-125.8))'
# occ_search(geometry = wkt)

### unable to parse due to unclosed string
# wkt &lt;- 'POLYGON((-178.5 64.8,-165.9 59.2,-147.3 59.0,-130.7 51.0))'
# occ_search(geometry = wkt)
### another of the same
# wkt &lt;- 'POLYGON((-178.5 64.8,-165.9 59.2,-147.3 59.0,-130.7 51.0,-125.8 36.7))'
# occ_search(geometry = wkt)

### returns no results
# wkt &lt;- 'LINESTRING(3 4,10 50,20 25)'
# occ_search(geometry = wkt)

### Apparently a point is allowed, but errors
# wkt &lt;- 'POINT(45 -122)'
# occ_search(geometry = wkt)

## Faceting
x &lt;- occ_search(facet = "country", limit = 0)
x$facets
x &lt;- occ_search(facet = "establishmentMeans", limit = 10)
x$facets
x$data
x &lt;- occ_search(facet = c("country", "basisOfRecord"), limit = 10)
x$data
x$facets
x$facets$country
x$facets$basisOfRecord
x$facets$basisOfRecord$count
x &lt;- occ_search(facet = "country", facetMincount = 30000000L, limit = 10)
x$facets
x$data
# paging per each faceted variable
(x &lt;- occ_search(
  facet = c("country", "basisOfRecord", "hasCoordinate"),
  country.facetLimit = 3,
  basisOfRecord.facetLimit = 6,
  limit = 0
))
x$facets


# You can set limit=0 to get number of results found
occ_search(datasetKey = '7b5d6a48-f762-11e1-a439-00145eb45e9a', limit = 0)$meta
occ_search(scientificName = 'Ursus americanus', limit = 0)$meta
occ_search(scientificName = 'Ursus americanus', limit = 0)$meta

## End(Not run)
</code></pre>

<hr>
<h2 id='occ_spellcheck'>Spell check search term for occurrence searches</h2><span id='topic+occ_spellcheck'></span>

<h3>Description</h3>

<p>Spell check search term for occurrence searches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occ_spellcheck(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occ_spellcheck_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='occurrencecount'>Counts taxon concept records matching a range of filters.</h2><span id='topic+occurrencecount'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occurrencecount(...)
</code></pre>


<h3>See Also</h3>

<p>occ_count
</p>

<hr>
<h2 id='occurrencedensity'>Returns summary counts of occurrence records by one-degree cell for a single
taxon, country, dataset, data publisher or data network.</h2><span id='topic+occurrencedensity'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occurrencedensity()
</code></pre>

<hr>
<h2 id='occurrenceget'>Get individual records for a given occurrence record.</h2><span id='topic+occurrenceget'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occurrenceget(...)
</code></pre>


<h3>See Also</h3>

<p>occ_get
</p>

<hr>
<h2 id='occurrencelist'>Occurrencelist searches for taxon concept records matching a range of filters.</h2><span id='topic+occurrencelist'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occurrencelist(...)
</code></pre>


<h3>See Also</h3>

<p>occ_search
</p>

<hr>
<h2 id='occurrencelist_all'>Occurrencelist_all carries out an occurrencelist query for a single name and
all its name variants according to GBIF's name matching.</h2><span id='topic+occurrencelist_all'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occurrencelist_all(...)
</code></pre>


<h3>See Also</h3>

<p>occ_search
</p>

<hr>
<h2 id='occurrencelist_many'>occurrencelist_many is the same as occurrencelist, but takes in a vector
of species names.</h2><span id='topic+occurrencelist_many'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occurrencelist_many(...)
</code></pre>


<h3>See Also</h3>

<p>occ_search
</p>

<hr>
<h2 id='organizations'>Organizations metadata.</h2><span id='topic+organizations'></span>

<h3>Description</h3>

<p>Organizations metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>organizations(
  data = "all",
  country = NULL,
  uuid = NULL,
  query = NULL,
  limit = 100,
  start = NULL,
  curlopts = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="organizations_+3A_data">data</code></td>
<td>
<p>(character) The type of data to get. One or more of:
'organization', 'contact', 'endpoint', 'identifier', 'tag', 'machineTag',
'comment', 'hostedDataset', 'ownedDataset', 'deleted', 'pending',
'nonPublishing', or the special 'all'. Default: <code>'all'</code></p>
</td></tr>
<tr><td><code id="organizations_+3A_country">country</code></td>
<td>
<p>(character) Filters by country.</p>
</td></tr>
<tr><td><code id="organizations_+3A_uuid">uuid</code></td>
<td>
<p>(character) UUID of the data node provider. This must be
specified if data is anything other than 'all', 'deleted', 'pending', or
'nonPublishing'.</p>
</td></tr>
<tr><td><code id="organizations_+3A_query">query</code></td>
<td>
<p>(character) Query nodes. Only used when <code>data='all'</code></p>
</td></tr>
<tr><td><code id="organizations_+3A_limit">limit</code></td>
<td>
<p>Number of records to return. Default: 100. Maximum: 1000.</p>
</td></tr>
<tr><td><code id="organizations_+3A_start">start</code></td>
<td>
<p>Record number to start at. Default: 0. Use in combination
with <code>limit</code> to page through results.</p>
</td></tr>
<tr><td><code id="organizations_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length of two, consisting of a data.frame <code>meta</code> when
uuid is NULL, and <code>data</code> which can either be a list or a data.frame
depending on the requested type of data.
</p>


<h3>References</h3>

<p><a href="https://www.gbif.org/developer/registry#organizations">https://www.gbif.org/developer/registry#organizations</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
organizations(limit=5)
organizations(query="france", limit=5)
organizations(country = "SPAIN")
organizations(uuid="4b4b2111-ee51-45f5-bf5e-f535f4a1c9dc")
organizations(data='contact', uuid="4b4b2111-ee51-45f5-bf5e-f535f4a1c9dc")
organizations(data='pending')
organizations(data=c('contact','endpoint'),
  uuid="4b4b2111-ee51-45f5-bf5e-f535f4a1c9dc")

# Pass on curl options
organizations(query="spain", curlopts = list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='parsenames'>Parse taxon names using the GBIF name parser.</h2><span id='topic+parsenames'></span>

<h3>Description</h3>

<p>Parse taxon names using the GBIF name parser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parsenames(scientificname, curlopts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parsenames_+3A_scientificname">scientificname</code></td>
<td>
<p>A character vector of scientific names.</p>
</td></tr>
<tr><td><code id="parsenames_+3A_curlopts">curlopts</code></td>
<td>
<p>list of named curl options passed on to
<code><a href="crul.html#topic+HttpClient">HttpClient</a></code>. see <code>curl::curl_options</code>
for curl options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing fields extracted from parsed
taxon names. Fields returned are the union of fields extracted from
all species names in <code>scientificname</code>.
</p>


<h3>Author(s)</h3>

<p>John Baumgartner (johnbb@student.unimelb.edu.au)
</p>


<h3>References</h3>

<p><a href="https://www.gbif.org/developer/species#parser">https://www.gbif.org/developer/species#parser</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
parsenames(scientificname='x Agropogon littoralis')
parsenames(c('Arrhenatherum elatius var. elatius',
             'Secale cereale subsp. cereale', 'Secale cereale ssp. cereale',
             'Vanessa atalanta (Linnaeus, 1758)'))
parsenames("Ajuga pyramidata")
parsenames("Ajuga pyramidata x reptans")

# Pass on curl options
# res &lt;- parsenames(c('Arrhenatherum elatius var. elatius',
#          'Secale cereale subsp. cereale', 'Secale cereale ssp. cereale',
#          'Vanessa atalanta (Linnaeus, 1758)'), curlopts=list(verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='providers'>Get data providers and their unique keys.</h2><span id='topic+providers'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>providers(...)
</code></pre>


<h3>See Also</h3>

<p>networks organizations datasets
</p>

<hr>
<h2 id='resources'>Get data resources and their unique keys.</h2><span id='topic+resources'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resources(...)
</code></pre>


<h3>See Also</h3>

<p>networks organizations datasets
</p>

<hr>
<h2 id='rgb_country_codes'>Look up 2 character ISO country codes</h2><span id='topic+rgb_country_codes'></span>

<h3>Description</h3>

<p>Look up 2 character ISO country codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb_country_codes(country_name, fuzzy = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgb_country_codes_+3A_country_name">country_name</code></td>
<td>
<p>Name of country to look up</p>
</td></tr>
<tr><td><code id="rgb_country_codes_+3A_fuzzy">fuzzy</code></td>
<td>
<p>If TRUE, uses agrep to do fuzzy search on names.</p>
</td></tr>
<tr><td><code id="rgb_country_codes_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to agrep or grep</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rgb_country_codes(country_name="United")

## End(Not run)
</code></pre>

<hr>
<h2 id='rgbif-defunct'>Defunct functions in rgbif</h2><span id='topic+rgbif-defunct'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+density_spplist">density_spplist()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+densitylist">densitylist()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+gbifdata">gbifdata()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+gbifmap_dens">gbifmap_dens()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+gbifmap_list">gbifmap_list()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+occurrencedensity">occurrencedensity()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+providers">providers()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+resources">resources()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+taxoncount">taxoncount()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+taxonget">taxonget()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+taxonsearch">taxonsearch()</a></code>: service no longer provided
</p>
</li>
<li> <p><code><a href="#topic+stylegeojson">stylegeojson()</a></code>: moving this functionality to spocc package, will be
removed soon
</p>
</li>
<li> <p><code><a href="#topic+togeojson">togeojson()</a></code>: moving this functionality to spocc package, will be
removed soon
</p>
</li>
<li> <p><code><a href="#topic+gist">gist()</a></code>: moving this functionality to spocc package, will be
removed soon
</p>
</li>
<li> <p><code><a href="#topic+occ_spellcheck">occ_spellcheck()</a></code>: GBIF has removed the <code>spellCheck</code> parameter
from their API
</p>
</li></ul>



<h3>Details</h3>

<p>The above functions have been removed. See
<a href="https://github.com/ropensci/rgbif">https://github.com/ropensci/rgbif</a> and poke around the code if you
want to find the old functions in previous versions of the package
</p>

<hr>
<h2 id='stylegeojson'>Style a data.frame prior to converting to geojson.</h2><span id='topic+stylegeojson'></span>

<h3>Description</h3>

<p>This function is defunct.  See the package spocc for similar functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stylegeojson(...)
</code></pre>

<hr>
<h2 id='suggestfields'>Fields available in gbif_suggest function</h2><span id='topic+suggestfields'></span>

<h3>Description</h3>

<p>Fields available in gbif_suggest function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suggestfields()
</code></pre>

<hr>
<h2 id='taxoncount'>Search by taxon to retrieve number of records in GBIF.</h2><span id='topic+taxoncount'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxoncount(...)
</code></pre>


<h3>See Also</h3>

<p>occ_count
</p>

<hr>
<h2 id='taxonget'>Get taxonomic information on a specific taxon or taxa in GBIF by their taxon
concept keys.</h2><span id='topic+taxonget'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxonget(...)
</code></pre>


<h3>See Also</h3>

<p>name_usage
</p>

<hr>
<h2 id='taxonsearch'>Search for taxa in GBIF.</h2><span id='topic+taxonsearch'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxonsearch(...)
</code></pre>


<h3>See Also</h3>

<p>occ_search
</p>

<hr>
<h2 id='taxrank'>Get the possible values to be used for (taxonomic) rank arguments in GBIF
API methods.</h2><span id='topic+taxrank'></span>

<h3>Description</h3>

<p>Get the possible values to be used for (taxonomic) rank arguments in GBIF
API methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxrank()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
taxrank()

## End(Not run)
</code></pre>

<hr>
<h2 id='togeojson'>Convert spatial data files to GeoJSON from various formats.</h2><span id='topic+togeojson'></span>

<h3>Description</h3>

<p>This function is defunct.  See the package togeojson for similar functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>togeojson(...)
</code></pre>

<hr>
<h2 id='wkt_parse'>parse wkt into smaller bits</h2><span id='topic+wkt_parse'></span>

<h3>Description</h3>

<p>parse wkt into smaller bits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkt_parse(wkt, geom_big = "bbox", geom_size = 40, geom_n = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wkt_parse_+3A_wkt">wkt</code></td>
<td>
<p>(character) A WKT string. Required.</p>
</td></tr>
<tr><td><code id="wkt_parse_+3A_geom_big">geom_big</code></td>
<td>
<p>(character) Only &quot;bbox&quot; works since rgbif 3.8.0.</p>
</td></tr>
<tr><td><code id="wkt_parse_+3A_geom_size">geom_size</code></td>
<td>
<p>(integer) An integer indicating size of the cell.
Default: 40.</p>
</td></tr>
<tr><td><code id="wkt_parse_+3A_geom_n">geom_n</code></td>
<td>
<p>(integer) An integer indicating number of cells in
each dimension. Default: 10.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>wkt &lt;- "POLYGON((13.26349675655365 52.53991761181831,18.36115300655365 54.11445544219924,
21.87677800655365 53.80418956368524,24.68927800655365 54.217364774722455,28.20490300655365
54.320018299365124,30.49005925655365 52.85948216284084,34.70880925655365 52.753220564427814,
35.93927800655365 50.46131871049754,39.63068425655365 49.55761261299145,40.86115300655365
46.381388009130845,34.00568425655365 45.279102926537,33.30255925655365 48.636868465271846,
30.13849675655365 49.78513301801265,28.38068425655365 47.2236377039631,29.78693425655365
44.6572866068524,27.67755925655365 42.62220075124676,23.10724675655365 43.77542058000212,
24.51349675655365 47.10412345120368,26.79865300655365 49.55761261299145,23.98615300655365
52.00209943876426,23.63459050655365 49.44345313705238,19.41584050655365 47.580567827212114,
19.59162175655365 44.90682206053508,20.11896550655365 42.36297154876359,22.93146550655365
40.651849782081555,25.56818425655365 39.98171166226459,29.61115300655365 40.78507856230178,
32.95099675655365 40.38459278067577,32.95099675655365 37.37491910393631,26.27130925655365
33.65619609886799,22.05255925655365 36.814081996401605,18.71271550655365 36.1072176729021,
18.53693425655365 39.16878677351903,15.37287175655365 38.346355762190846,15.19709050655365
41.578843777436326,12.56037175655365 41.050735748143424,12.56037175655365 44.02872991212046,
15.19709050655365 45.52594200494078,16.42755925655365 48.05271546733352,17.48224675655365
48.86865641518059,10.62677800655365 47.817178329053135,9.57209050655365 44.154980365192,
8.16584050655365 40.51835445724746,6.05646550655365 36.53210972067291,0.9588092565536499
31.583640057148145,-5.54509699344635 35.68001485298146,-6.77556574344635 40.51835445724746,
-9.41228449344635 38.346355762190846,-12.40056574344635 35.10683619158607,-15.74040949344635
38.07010978950028,-14.68572199344635 41.31532459432774,-11.69744074344635 43.64836179231387,
-8.88494074344635 42.88035509418534,-4.31462824344635 43.52103366008421,-8.35759699344635
47.2236377039631,-8.18181574344635 50.12441989397795,-5.01775324344635 49.55761261299145,
-2.73259699344635 46.25998980446569,-1.67790949344635 44.154980365192,-1.32634699344635
39.30493590580802,2.18927800655365 41.44721797271696,4.47443425655365 43.26556960420879,
2.18927800655365 46.7439668697322,1.83771550655365 50.3492841273576,6.93537175655365
49.671505849335254,5.00177800655365 52.32557322466785,7.81427800655365 51.67627099802223,
7.81427800655365 54.5245591562317,10.97834050655365 51.89375191441792,10.97834050655365
55.43241335888528,13.26349675655365 52.53991761181831))"
wkt &lt;- gsub("\n", " ", wkt)

if (requireNamespace("sf", quietly=TRUE)) {
# to a bounding box in wkt format
wkt_parse(wkt, geom_big = "bbox")

}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
