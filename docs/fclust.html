<!DOCTYPE html><html lang="en"><head><title>Help for package fclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARI.F'>
<p>Fuzzy adjusted Rand index</p></a></li>
<li><a href='#butterfly'><p>Butterfly data</p></a></li>
<li><a href='#cl.memb'><p>Cluster membership</p></a></li>
<li><a href='#cl.memb.H'><p>Cluster membership</p></a></li>
<li><a href='#cl.memb.t'><p>Cluster membership</p></a></li>
<li><a href='#cl.size'><p>Cluster size</p></a></li>
<li><a href='#cl.size.H'><p>Cluster size</p></a></li>
<li><a href='#Fclust'><p>Fuzzy clustering</p></a></li>
<li><a href='#Fclust.compare'>
<p>Similarity between partitions</p></a></li>
<li><a href='#Fclust.index'><p>Cluster validity indexes</p></a></li>
<li><a href='#FKM'><p>Fuzzy k-means</p></a></li>
<li><a href='#FKM.ent'><p>Fuzzy k-means with entropy regularization</p></a></li>
<li><a href='#FKM.ent.noise'><p>Fuzzy k-means with entropy regularization and noise cluster</p></a></li>
<li><a href='#FKM.gk'><p>Gustafson and Kessel - like fuzzy k-means</p></a></li>
<li><a href='#FKM.gk.ent'><p>Gustafson and Kessel - like fuzzy k-means with entropy regularization</p></a></li>
<li><a href='#FKM.gk.ent.noise'><p>Gustafson and Kessel - like fuzzy k-means with entropy regularization and noise cluster</p></a></li>
<li><a href='#FKM.gk.noise'><p>Gustafson and Kessel - like fuzzy k-means with noise cluster</p></a></li>
<li><a href='#FKM.gkb'><p>Gustafson, Kessel and Babuska - like fuzzy k-means</p></a></li>
<li><a href='#FKM.gkb.ent'><p>Gustafson, Kessel and Babuska - like fuzzy k-means with entropy regularization</p></a></li>
<li><a href='#FKM.gkb.ent.noise'><p>Gustafson, Kessel and Babuska - like fuzzy k-means with entropy regularization and noise cluster</p></a></li>
<li><a href='#FKM.gkb.noise'><p>Gustafson, Kessel and Babuska - like fuzzy k-means with noise cluster</p></a></li>
<li><a href='#FKM.med'><p>Fuzzy k-medoids</p></a></li>
<li><a href='#FKM.med.noise'><p>Fuzzy k-medoids with noise cluster</p></a></li>
<li><a href='#FKM.noise'><p>Fuzzy k-means with noise cluster</p></a></li>
<li><a href='#FKM.pf'><p>Fuzzy k-means with polynomial fuzzifier</p></a></li>
<li><a href='#FKM.pf.noise'><p>Fuzzy k-means with polynomial fuzzifier and noise cluster</p></a></li>
<li><a href='#houseVotes'>
<p>Congressional Voting Records Data</p></a></li>
<li><a href='#Hraw'><p>Raw prototypes</p></a></li>
<li><a href='#JACCARD.F'>
<p>Fuzzy Jaccard index</p></a></li>
<li><a href='#Mc'><p>McDonald's data</p></a></li>
<li><a href='#MPC'><p>Modified partition coefficient</p></a></li>
<li><a href='#NBA'>
<p>NBA teams data</p></a></li>
<li><a href='#NEFRC'>
<p>Non-Euclidean Fuzzy Relational Clustering</p></a></li>
<li><a href='#NEFRC.noise'><p>Non-Euclidean Fuzzy Relational Clustering with noise cluster</p></a></li>
<li><a href='#PC'><p>Partition coefficient</p></a></li>
<li><a href='#PE'><p>Partition entropy</p></a></li>
<li><a href='#plot.fclust'><p>Plotting fuzzy clustering output</p></a></li>
<li><a href='#print.fclust'><p>Printing fuzzy clustering output</p></a></li>
<li><a href='#RI.F'>
<p>Fuzzy Rand index</p></a></li>
<li><a href='#SIL'><p>Silhouette index</p></a></li>
<li><a href='#SIL.F'><p>Fuzzy silhouette index</p></a></li>
<li><a href='#summary.fclust'><p>Summarizing fuzzy clustering output</p></a></li>
<li><a href='#synt.data'><p>Synthetic data</p></a></li>
<li><a href='#synt.data2'><p>Synthetic data</p></a></li>
<li><a href='#unemployment'><p>Unemployment data</p></a></li>
<li><a href='#VAT'><p>Visual Assessment of (Cluster) Tendency</p></a></li>
<li><a href='#VCV'><p>Visual Cluster Validity</p></a></li>
<li><a href='#VCV2'><p>(New) Visual Cluster Validity</p></a></li>
<li><a href='#VIFCR'><p>Visual inspection of fuzzy clustering results</p></a></li>
<li><a href='#XB'><p>Xie and Beni index</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fuzzy Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-09-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paolo Giordani &lt;paolo.giordani@uniroma1.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for fuzzy clustering, cluster validity indices and plots for cluster validity and visualizing fuzzy clustering results.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3), base, stats, graphics, grDevices, utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5), MASS (&ge; 7.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.7)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-16 15:59:35 UTC; hornik</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-16 16:34:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARI.F'>
Fuzzy adjusted Rand index</h2><span id='topic+ARI.F'></span>

<h3>Description</h3>

<p>Produces the fuzzy version of the adjusted Rand index between a hard (reference) partition and a fuzzy partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARI.F(VC, U, t_norm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARI.F_+3A_vc">VC</code></td>
<td>
<p>Vector of class labels</p>
</td></tr>
<tr><td><code id="ARI.F_+3A_u">U</code></td>
<td>
<p>Fuzzy membership degree matrix or data.frame</p>
</td></tr>
<tr><td><code id="ARI.F_+3A_t_norm">t_norm</code></td>
<td>
<p>Type of the triangular norm: &quot;minimum&quot; (minimum triangular norm), &quot;triangular product&quot; (product norm) (default: &quot;minimum&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ari.f</code>Value of the fuzzy adjusted Rand index
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Campello, R.J., 2007. A fuzzy extension of the Rand index and other related indexes for clustering and classification assessment. Pattern Recognition Letters, 28, 833-841.
<br /> Hubert, L., Arabie, P., 1985. Comparing partitions. Journal of Classification, 2, 193-218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RI.F">RI.F</a></code>, <code><a href="#topic+JACCARD.F">JACCARD.F</a></code>, <code><a href="#topic+Fclust.compare">Fclust.compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## fuzzy adjusted Rand index
ari.f=ARI.F(VC=Mc$Type,U=clust$U)

## End(Not run)
</code></pre>

<hr>
<h2 id='butterfly'>Butterfly data</h2><span id='topic+butterfly'></span>

<h3>Description</h3>

<p>Synthetic dataset with 2 clusters and some outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(butterfly)</code></pre>


<h3>Format</h3>

<p>A matrix with 17 rows and 2 columns.
</p>


<h3>Details</h3>

<p>The butterfly data motivate the need for the fuzzy approach to clustering.
<br /> The presence of outliers can be handled using fuzzy <em>k</em>-means with noise cluster. In fact, differently from fuzzy <em>k</em>-means, the membership degrees of the outliers are low for all the clusters.</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+FKM">FKM</a></code>, <code><a href="#topic+FKM.noise">FKM.noise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## butterfly data
data(butterfly)
plot(butterfly,type='n')
text(butterfly[,1],butterfly[,2],labels=rownames(butterfly),cex=0.7,lwd=2)
## membership degree matrix using fuzzy k-means (rounded)
round(FKM(butterfly)$U,2)
## membership degree matrix using fuzzy k-means with noise cluster (rounded)
round(FKM.noise(butterfly,delta=3)$U,2)
</code></pre>

<hr>
<h2 id='cl.memb'>Cluster membership</h2><span id='topic+cl.memb'></span>

<h3>Description</h3>

<p>Produces a summary of the membership degree information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cl.memb (U)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cl.memb_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object is assigned to a cluster according to the maximal membership degree. Therefore, it produces the closest hard clustering partition
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>info.U</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (row 1) and the associated membership degrees (row 2)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl.memb.H">cl.memb.H</a></code>, <code><a href="#topic+cl.memb.t">cl.memb.t</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n=20
k=3
## randomly generated membership degree matrix
U=matrix(runif(n*k,0,1), nrow=n, ncol=k)
U=U/apply(U,1,sum)
info.U=cl.memb(U)
## objects assigned to cluster 2
rownames(info.U[info.U[,1]==2,])
</code></pre>

<hr>
<h2 id='cl.memb.H'>Cluster membership</h2><span id='topic+cl.memb.H'></span>

<h3>Description</h3>

<p>Produces a summary of the membership degree information in the hard clustering sense (objects are considered to be assigned to clusters only if the corresponding membership degree are &gt;=0.5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cl.memb.H (U)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cl.memb.H_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object is assigned to a cluster according to the maximal membership degree provided that such a maximal membership degree is &gt;=0.5, otherwise it is assumed that an object is not assigned to any cluster (denoted by cluster index = 0 in row 1).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>info.U</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (row 1) and the associated membership degrees (row 2)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl.memb">cl.memb</a></code>, <code><a href="#topic+cl.memb.t">cl.memb.t</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n=20
k=3
## randomly generated membership degree matrix
U=matrix(runif(n*k,0,1), nrow=n, ncol=k)
U=U/apply(U,1,sum)
info.U=cl.memb.H(U)
## objects assigned to clusters in the hard clustering sense
rownames(info.U[info.U[,1]!=0,])
</code></pre>

<hr>
<h2 id='cl.memb.t'>Cluster membership</h2><span id='topic+cl.memb.t'></span>

<h3>Description</h3>

<p>Produces a summary of the membership degree information according to a threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cl.memb.t (U, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cl.memb.t_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code id="cl.memb.t_+3A_t">t</code></td>
<td>
<p>Threshold in [0,1] (default: 0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object is assigned to a cluster according to the maximal membership degree provided that such a maximal membership degree is &gt;= <code>t</code>, otherwise it is assumed that an object is not assigned to any cluster (denoted by cluster index = 0 in row 1).
The function can be useful to select the subset of objects clearly assigned to clusters (objects with maximal membership degrees &gt;= <code>t</code>).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>info.U</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (row 1) and the associated membership degrees (row 2)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl.memb">cl.memb</a></code>, <code><a href="#topic+cl.memb.H">cl.memb.H</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n=20
k=3
## randomly generated membership degree matrix
U=matrix(runif(n*k,0,1), nrow=n, ncol=k)
U=U/apply(U,1,sum)
## threshold t=0.6
info.U=cl.memb.t(U,0.6)
## objects clearly assigned to clusters
rownames(info.U[info.U[,1]!=0,])
</code></pre>

<hr>
<h2 id='cl.size'>Cluster size</h2><span id='topic+cl.size'></span>

<h3>Description</h3>

<p>Produces the sizes of the clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cl.size (U)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cl.size_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object is assigned to a cluster according to the maximal membership degree.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clus.size</code></td>
<td>
<p>Vector containing the sizes of the clusters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl.size.H">cl.size.H</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n=20
k=3
## randomly generated membership degree matrix
U=matrix(runif(n*k,0,1), nrow=n, ncol=k)
U=U/apply(U,1,sum)
clus.size=cl.size(U)
</code></pre>

<hr>
<h2 id='cl.size.H'>Cluster size</h2><span id='topic+cl.size.H'></span>

<h3>Description</h3>

<p>Produces the sizes of the clusters in the hard clustering sense (objects are considered to be assigned to clusters only if the corresponding membership degree are &gt;=0.5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cl.size.H (U)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cl.size.H_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object is assigned to a cluster according to the maximal membership degree provided that such a maximal membership degree is &gt;=0.5, otherwise it is assumed that an object is not assigned to any cluster.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clus.size</code></td>
<td>
<p>Vector containing the sizes of the clusters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+cl.size">cl.size</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n=20
k=3
## randomly generated membership degree matrix
U=matrix(runif(n*k,0,1), nrow=n, ncol=k)
U=U/apply(U,1,sum)
## cluster size in the hard clustering sense
clus.size=cl.size.H(U)
</code></pre>

<hr>
<h2 id='Fclust'>Fuzzy clustering</h2><span id='topic+Fclust'></span>

<h3>Description</h3>

<p>Performs fuzzy clustering by using the algorithms available in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> Fclust (X, k, type, ent, noise, stand, distance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fclust_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="Fclust_+3A_k">k</code></td>
<td>
<p>An integer value specifying the number of clusters (default: 2)</p>
</td></tr>
<tr><td><code id="Fclust_+3A_type">type</code></td>
<td>
<p>Fuzzy clustering algorithm: <code>"standard"</code> (standard algorithms: FKM - type if <code>distance=TRUE</code>, NEFRC - type if if <code>distance=FALSE</code>), <code>"polynomial"</code> (algorithms with the polynomial fuzzifier), <code>"gk"</code> (Gustafson and Kessel - like algorithms), <code>"gkb"</code> (Gustafson, Kessel and Babuska - like algorithms), <code>"medoids"</code> (Medoid - based algorithms) (default: &quot;standard&quot;)</p>
</td></tr>
<tr><td><code id="Fclust_+3A_ent">ent</code></td>
<td>
<p>If <code>ent=TRUE</code>, the entropy regularization variant of the algorithm is run (default: FALSE)</p>
</td></tr>
<tr><td><code id="Fclust_+3A_noise">noise</code></td>
<td>
<p>If <code>noise=TRUE</code>, the noise cluster variant of the algorithm is run (default: FALSE)</p>
</td></tr>
<tr><td><code id="Fclust_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="Fclust_+3A_distance">distance</code></td>
<td>
<p>If <code>distance=TRUE</code>, <code>X</code> is assumed to be a distance/dissimilarity matrix (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The clustering algorithms are run by using default options.
<br /> To specify different options, use the corresponding function.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clust</code></td>
<td>
<p>Object of class <code>fclust</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+FKM">FKM</a></code>, <code><a href="#topic+FKM.ent">FKM.ent</a></code>, <code><a href="#topic+FKM.gk">FKM.gk</a></code>, <code><a href="#topic+FKM.gk.ent">FKM.gk.ent</a></code>, <code><a href="#topic+FKM.gkb">FKM.gkb</a></code>, <code><a href="#topic+FKM.gkb.ent">FKM.gkb.ent</a></code>, <code><a href="#topic+FKM.med">FKM.med</a></code>, <code><a href="#topic+FKM.pf">FKM.pf</a></code>, <code><a href="#topic+FKM.noise">FKM.noise</a></code>, <code><a href="#topic+FKM.ent.noise">FKM.ent.noise</a></code>, <code><a href="#topic+FKM.gk.noise">FKM.gk.noise</a></code>, <code><a href="#topic+FKM.gkb.ent.noise">FKM.gkb.ent.noise</a></code>,  <code><a href="#topic+FKM.gkb.noise">FKM.gkb.noise</a></code>, <code><a href="#topic+FKM.gk.ent.noise">FKM.gk.ent.noise</a></code>,<code><a href="#topic+FKM.med.noise">FKM.med.noise</a></code>, <code><a href="#topic+FKM.pf.noise">FKM.pf.noise</a></code>, <code><a href="#topic+NEFRC">NEFRC</a></code>, <code><a href="#topic+NEFRC.noise">NEFRC.noise</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+Fclust.compare">Fclust.compare</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=Fclust(Mc[,1:(ncol(Mc)-1)],k=6,type="standard",ent=FALSE,noise=FALSE,stand=1,distance=FALSE)
## fuzzy k-means with polynomial fuzzifier 
## (excluded the factor column Type (last column))
clust=Fclust(Mc[,1:(ncol(Mc)-1)],k=6,type="polynomial",ent=FALSE,noise=FALSE,stand=1,distance=FALSE)
## fuzzy k-means with entropy regularization
## (excluded the factor column Type (last column))
clust=Fclust(Mc[,1:(ncol(Mc)-1)],k=6,type="standard",ent=TRUE,noise=FALSE,stand=1,distance=FALSE)
## fuzzy k-means with noise cluster
## (excluded the factor column Type (last column))
clust=Fclust(Mc[,1:(ncol(Mc)-1)],k=6,type="standard",ent=FALSE,noise=TRUE,stand=1,distance=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Fclust.compare'>
Similarity between partitions</h2><span id='topic+Fclust.compare'></span>

<h3>Description</h3>

<p>Performs some measures of similarity between a hard (reference) partition and a fuzzy partition.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fclust.compare(VC, U, index, tnorm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fclust.compare_+3A_vc">VC</code></td>
<td>
<p>Vector of class labels</p>
</td></tr>
<tr><td><code id="Fclust.compare_+3A_u">U</code></td>
<td>
<p>Fuzzy membership degree matrix or data.frame</p>
</td></tr>
<tr><td><code id="Fclust.compare_+3A_index">index</code></td>
<td>
<p>Measures of similarity: &quot;ARI.F&quot; (fuzzy version of the adjuster Rand index), &quot;RI.F&quot; (fuzzy version of the Rand index), &quot;JACCARD.F&quot; (fuzzy version of the Jaccard index), &quot;ALL&quot; for all the indexes (default: &quot;ALL&quot;)</p>
</td></tr>
<tr><td><code id="Fclust.compare_+3A_tnorm">tnorm</code></td>
<td>
<p>Type of the triangular norm: &quot;minimum&quot; (minimum triangular norm), &quot;triangular product&quot; (product norm) (default: &quot;minimum&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>index</code> is not case-sensitive. All the measures of similarity share the same properties of their non-fuzzy counterpart.
</p>


<h3>Value</h3>

<p><code>out.index</code>Vector containing the similarity measures
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Campello, R.J., 2007. A fuzzy extension of the Rand index and other related indexes for clustering and classification assessment. Pattern Recognition Letters, 28, 833-841.
<br /> Hubert, L., Arabie, P., 1985. Comparing partitions. Journal of Classification, 2, 193-218.
<br /> Jaccard, P., 1901. Étude comparative de la distribution florale dans une portion des Alpes et des Jura. Bulletin de la Société Vaudoise des Sciences Naturelles, 37, 547-579.
<br /> Rand, W.M., 1971. Objective criteria for the evaluation of clustering methods. Journal of the American Statistical Association, 66, 846-850.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RI.F">RI.F</a></code>, <code><a href="#topic+ARI.F">ARI.F</a></code>, <code><a href="#topic+JACCARD.F">JACCARD.F</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## all measures of similarity
all.indexes=Fclust.compare(VC=Mc$Type,U=clust$U)
## fuzzy adjusted Rand index
Fari.index=Fclust.compare(VC=Mc$Type,U=clust$U,index="ARI.F")

## End(Not run)
</code></pre>

<hr>
<h2 id='Fclust.index'>Cluster validity indexes</h2><span id='topic+Fclust.index'></span>

<h3>Description</h3>

<p>Performs some cluster validity indexes for choosing the optimal number of clusters <em>k</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> Fclust.index (fclust.obj, index, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fclust.index_+3A_fclust.obj">fclust.obj</code></td>
<td>
<p>Object of class <code>fclust</code></p>
</td></tr>
<tr><td><code id="Fclust.index_+3A_index">index</code></td>
<td>
<p>Cluster validity indexes to select the number of clusters: <code>PC</code> (partition coefficient), <code>PE</code> (partition entropy), <code>MPC</code> (modified partition coefficient), <code>SIL</code> (silhouette), <code>SIL.F</code> (fuzzy silhouette), <code>XB</code> (Xie and Beni),<code>ALL</code> for all the indexes (default: &quot;ALL&quot;)</p>
</td></tr>
<tr><td><code id="Fclust.index_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>index</code> is not case-sensitive.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>out.index</code></td>
<td>
<p>Vector containing the index values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+PC">PC</a></code>, <code><a href="#topic+PE">PE</a></code>, <code><a href="#topic+MPC">MPC</a></code>, <code><a href="#topic+SIL">SIL</a></code>, <code><a href="#topic+SIL.F">SIL.F</a></code>, <code><a href="#topic+XB">XB</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## cluster validity indexes
all.indexes=Fclust.index(clust)
## Xie and Beni cluster validity index
XB.index=Fclust.index(clust,'XB')
</code></pre>

<hr>
<h2 id='FKM'>Fuzzy k-means</h2><span id='topic+FKM'></span>

<h3>Description</h3>

<p>Performs the fuzzy <em>k</em>-means clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 FKM (X, k, m, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
<tr><td><code id="FKM_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Bezdek J.C., 1981. Pattern Recognition with Fuzzy Objective Function Algorithms. Plenum Press, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.noise">FKM.noise</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means (excluded the factor column Type (last column)), fixing the number of clusters
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## fuzzy k-means (excluded the factor column Type (last column)), selecting the number of clusters
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=2:6,m=1.5,stand=1)
</code></pre>

<hr>
<h2 id='FKM.ent'>Fuzzy k-means with entropy regularization</h2><span id='topic+FKM.ent'></span>

<h3>Description</h3>

<p>Performs the fuzzy <em>k</em>-means clustering algorithm with entropy regularization.
<br /> The entropy regularization allows us to avoid using the artificial fuzziness parameter <em>m</em>. This is replaced by the degree of fuzzy entropy <em>ent</em>, related to the concept of temperature in statistical physics.
An interesting property of the fuzzy <em>k</em>-means with entropy regularization is that the prototypes are obtained as weighted means with weights equal to the membership degrees (rather than to the membership degrees at
the power of <em>m</em> as is for the fuzzy k-means).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 FKM.ent (X, k, ent, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.ent_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_ent">ent</code></td>
<td>
<p>Degree of fuzzy entropy (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.ent_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> The default value for <code>ent</code> is in general not reasonable if <code>FKM.ent</code> is run using raw data. 
<br /> The update of the membership degrees requires the computation of exponential functions. In some cases, this may produce <code>NaN</code> values and the algorithm stops. Such a problem is usually solved by running <code>FKM.ent</code> using standardized data (<code>stand=1</code>).
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.ent</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Li R., Mukaidono M., 1995. A maximum entropy approach to fuzzy clustering. Proceedings of the Fourth IEEE Conference on Fuzzy Systems (FUZZ-IEEE/IFES '95), pp. 2227-2232.
<br /> Li R., Mukaidono M., 1999. Gaussian clustering method based on maximum-fuzzy-entropy interpretation. Fuzzy Sets and Systems, 102, 253-258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.ent.noise">FKM.ent.noise</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means with entropy regularization, fixing the number of clusters
## (excluded the factor column Type (last column))
clust=FKM.ent(Mc[,1:(ncol(Mc)-1)],k=6,ent=3,RS=10,stand=1)
## fuzzy k-means with entropy regularization, selecting the number of clusters
## (excluded the factor column Type (last column))
clust=FKM.ent(Mc[,1:(ncol(Mc)-1)],k=2:6,ent=3,RS=10,stand=1)
</code></pre>

<hr>
<h2 id='FKM.ent.noise'>Fuzzy k-means with entropy regularization and noise cluster</h2><span id='topic+FKM.ent.noise'></span>

<h3>Description</h3>

<p>Performs the fuzzy <em>k</em>-means clustering algorithm with entropy regularization and noise cluster.
<br /> The entropy regularization allows us to avoid using the artificial fuzziness parameter <em>m</em>. This is replaced by the degree of fuzzy entropy <em>ent</em>, related to the concept of temperature in statistical physics.
An interesting property of the fuzzy <em>k</em>-means with entropy regularization is that the prototypes are obtained as weighted means with weights equal to the membership degrees (rather than to the membership degrees at
the power of <em>m</em> as is for the fuzzy k-means).
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 FKM.ent.noise (X, k, ent, delta, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.ent.noise_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_ent">ent</code></td>
<td>
<p>Degree of fuzzy entropy (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average Euclidean distance between objects and prototypes from <code>FKM.ent</code> using the same values of <code>k</code> and <code>m</code>)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.ent.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> The default value for <code>ent</code> is in general not reasonable if <code>FKM.ent</code> is run using raw data. 
<br /> The update of the membership degrees requires the computation of exponential functions. In some cases, this may produce <code>NaN</code> values and the algorithm stops. Such a problem is usually solved by running <code>FKM.ent</code> using standardized data (<code>stand=1</code>).
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p>Noise distance</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Dave' R.N., 1991. Characterization and detection of noise in clustering. Pattern Recognition Letters, 12, 657-664.
<br /> Li R., Mukaidono M., 1995. A maximum entropy approach to fuzzy clustering. Proceedings of the Fourth IEEE Conference on Fuzzy Systems (FUZZ-IEEE/IFES '95), pp. 2227-2232.
<br /> Li R., Mukaidono M., 1999. Gaussian clustering method based on maximum-fuzzy-entropy interpretation. Fuzzy Sets and Systems, 102, 253-258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.ent">FKM.ent</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+butterfly">butterfly</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## butterfly data
data(butterfly)
## fuzzy k-means with entropy regularization and noise cluster, fixing the number of clusters
clust=FKM.ent.noise(butterfly,k = 2, RS=5,delta=3)
## fuzzy k-means with entropy regularization and noise cluster, selecting the number of clusters
clust=FKM.ent.noise(butterfly,RS=5,delta=3)
</code></pre>

<hr>
<h2 id='FKM.gk'>Gustafson and Kessel - like fuzzy k-means</h2><span id='topic+FKM.gk'></span>

<h3>Description</h3>

<p>Performs the Gustafson and Kessel - like fuzzy <em>k</em>-means clustering algorithm.
<br /> Differently from fuzzy <em>k</em>-means, it is able to discover non-spherical clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FKM.gk (X, k, m, vp, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.gk_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_vp">vp</code></td>
<td>
<p>Volume parameter (default: rep(1,k))</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.gk_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> If a cluster covariance matrix becomes singular, then the algorithm stops and the element of <code>value</code> is NaN.
<br /> The Babuska et al. variant in <code>FKM.gkb</code> is recommended.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.gk</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.gk</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.gk</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (default: <code>rep(1,max(k)</code>). If <code>k</code> is a vector, for each group the first <code>k</code> element of <code>vp</code>are considered.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>FKM.gk</code>)</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.gk</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.gk</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.gk</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Gustafson E.E., Kessel W.C., 1978. Fuzzy clustering with a fuzzy covariance matrix. Proceedings of the IEEE Conference on Decision and Control, pp. 761-766.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.gkb">FKM.gkb</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## unemployment data
data(unemployment)
## Gustafson and Kessel-like fuzzy k-means, fixing the number of clusters
clust=FKM.gk(unemployment,k=3,RS=10)
## Gustafson and Kessel-like fuzzy k-means, selecting the number of clusters
clust=FKM.gk(unemployment,k=2:6,RS=10)

## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.gk.ent'>Gustafson and Kessel - like fuzzy k-means with entropy regularization</h2><span id='topic+FKM.gk.ent'></span>

<h3>Description</h3>

<p>Performs the Gustafson and Kessel - like fuzzy <em>k</em>-means clustering algorithm with entropy regularization. 
<br /> Differently from fuzzy <em>k</em>-means, it is able to discover non-spherical clusters.
<br /> The entropy regularization allows us to avoid using the artificial fuzziness parameter <em>m</em>. This is replaced by the degree of fuzzy entropy <em>ent</em>, related to the concept of temperature in statistical physics.
An interesting property of the fuzzy <em>k</em>-means with entropy regularization is that the prototypes are obtained as weighted means with weights equal to the membership degrees (rather than to the membership degrees at
the power of <em>m</em> as is for the fuzzy k-means).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 FKM.gk.ent (X, k, ent, vp, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.gk.ent_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_ent">ent</code></td>
<td>
<p>Degree of fuzzy entropy (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_vp">vp</code></td>
<td>
<p>Volume parameter (default: rep(1,k))</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> If a cluster covariance matrix becomes singular, the algorithm stops and the element of <code>value</code> is NaN.
<br /> The default value for <code>ent</code> is in general not reasonable if <code>FKM.gk.ent</code> is run using raw data. 
<br /> The update of the membership degrees requires the computation of exponential functions. In some cases, this may produce <code>NaN</code> values and the algorithm stops. Such a problem is usually solved by running <code>FKM.gk.ent</code> using standardized data (<code>stand=1</code>).
<br /> The Babuska et al. variant in <code>FKM.gkb.ent</code> is recommended.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.gk.ent</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness (<code>NULL</code> for <code>FKM.gk.ent</code>)</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.gk.ent</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (default: <code>rep(1,max(k)</code>). If <code>k</code> is a vector, for each group the first <code>k</code> element of <code>vp</code>are considered.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>FKM.gk.ent</code>)</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.gk.ent</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.gk.ent</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.gk.ent</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Ferraro M.B., Giordani P., 2013. A new fuzzy clustering algorithm with entropy regularization. Proceedings of the meeting on Classification and Data Analysis (CLADAG).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.gkb.ent">FKM.gkb.ent</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## unemployment data
data(unemployment)
## Gustafson and Kessel-like fuzzy k-means with entropy regularization, 
##fixing the number of clusters
clust=FKM.gk.ent(unemployment,k=3,ent=0.2,RS=10,stand=1)
## Not run: 
## Gustafson and Kessel-like fuzzy k-means with entropy regularization,
##selecting the number of clusters
clust=FKM.gk.ent(unemployment,k=2:6,ent=0.2,RS=10,stand=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.gk.ent.noise'>Gustafson and Kessel - like fuzzy k-means with entropy regularization and noise cluster</h2><span id='topic+FKM.gk.ent.noise'></span>

<h3>Description</h3>

<p>Performs the Gustafson and Kessel - like fuzzy <em>k</em>-means clustering algorithm with entropy regularization and noise cluster.
<br /> Differently from fuzzy <em>k</em>-means, it is able to discover non-spherical clusters.
<br /> The entropy regularization allows us to avoid using the artificial fuzziness parameter <em>m</em>. This is replaced by the degree of fuzzy entropy <em>ent</em>, related to the concept of temperature in statistical physics.
An interesting property of the fuzzy <em>k</em>-means with entropy regularization is that the prototypes are obtained as weighted means with weights equal to the membership degrees (rather than to the membership degrees at
the power of <em>m</em> as is for the fuzzy k-means).
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FKM.gk.ent.noise (X,k,ent,vp,delta,RS,stand,startU,index,alpha,conv,maxit,seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.gk.ent.noise_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_ent">ent</code></td>
<td>
<p>Degree of fuzzy entropy (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_vp">vp</code></td>
<td>
<p>Volume parameter (default: rep(1,k))</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average Euclidean distance between objects and prototypes from <code>FKM.gk.ent</code> using the same values of <code>k</code> and <code>m</code>)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.gk.ent.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> If a cluster covariance matrix becomes singular, the algorithm stops and the element of <code>value</code> is NaN.
<br /> The default value for <code>ent</code> is in general not reasonable if <code>FKM.gk.ent</code> is run using raw data.
<br /> The update of the membership degrees requires the computation of exponential functions. In some cases, this may produce <code>NaN</code> values and the algorithm stops. Such a problem is usually solved by running <code>FKM.gk.ent.noise</code> using standardized data (<code>stand=1</code>).
<br /> The Babuska et al. variant in <code>FKM.gkb.ent.noise</code> is recommended.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.gk.ent.noise</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness (<code>NULL</code> for <code>FKM.gk.ent.noise</code>)</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.gk.ent.noise</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (default: <code>rep(1,max(k)</code>). If <code>k</code> is a vector, for each group the first <code>k</code> element of <code>vp</code>are considered.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.ent.noise</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Dave' R.N., 1991. Characterization and detection of noise in clustering. Pattern Recognition Letters, 12, 657-664.
<br /> Ferraro M.B., Giordani P., 2013. A new fuzzy clustering algorithm with entropy regularization. Proceedings of the meeting on Classification and Data Analysis (CLADAG).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.gkb.ent.noise">FKM.gkb.ent.noise</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## unemployment data
data(unemployment)
## Gustafson and Kessel-like fuzzy k-means with entropy regularization and noise cluster,
##fixing the number of clusters
clust=FKM.gk.ent.noise(unemployment,k=3,ent=0.2,delta=1,RS=10,stand=1)
## Gustafson and Kessel-like fuzzy k-means with entropy regularization and noise cluster,
##selecting the number of clusters
clust=FKM.gk.ent.noise(unemployment,k=2:6,ent=0.2,delta=1,RS=10,stand=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.gk.noise'>Gustafson and Kessel - like fuzzy k-means with noise cluster</h2><span id='topic+FKM.gk.noise'></span>

<h3>Description</h3>

<p>Performs the Gustafson and Kessel - like fuzzy <em>k</em>-means clustering algorithm with noise cluster.
<br /> Differently from fuzzy <em>k</em>-means, it is able to discover non-spherical clusters.
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FKM.gk.noise (X, k, m, vp, delta, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.gk.noise_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_vp">vp</code></td>
<td>
<p>Volume parameter (default: <code>rep(1,max(k)</code>). If <code>k</code> is a vector, for each group the first <code>k</code> element of <code>vp</code>are considered.</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average Euclidean distance between objects and prototypes from <code>FKM.gk</code> using the same values of <code>k</code> and <code>m</code>)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.gk.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> If a cluster covariance matrix becomes singular, then the algorithm stops and the element of <code>value</code> is NaN.
<br /> The Babuska et al. variant in <code>FKM.gkb.noise</code> is recommended.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.gk.noise</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.gk.noise</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.gk.noise</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.gk.noise</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.gk.noise</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.gk.noise</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Dave' R.N., 1991. Characterization and detection of noise in clustering. Pattern Recognition Letters, 12, 657-664.
<br /> Gustafson E.E., Kessel W.C., 1978. Fuzzy clustering with a fuzzy covariance matrix. Proceedings of the IEEE Conference on Decision and Control, pp. 761-766.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.gkb.noise">FKM.gkb.noise</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## unemployment data
data(unemployment)
## Gustafson and Kessel-like fuzzy k-means with noise cluster, fixing the number of clusters
clust=FKM.gk.noise(unemployment,k=3,delta=20,RS=10)
## Gustafson and Kessel-like fuzzy k-means with noise cluster, selecting the number of clusters
clust=FKM.gk.noise(unemployment,k=2:6,delta=20,RS=10)

## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.gkb'>Gustafson, Kessel and Babuska - like fuzzy k-means</h2><span id='topic+FKM.gkb'></span>

<h3>Description</h3>

<p>Performs the Gustafson, Kessel and Babuska - like fuzzy <em>k</em>-means clustering algorithm.
<br /> Differently from fuzzy <em>k</em>-means, it is able to discover non-spherical clusters.
<br /> The Babuska et al. variant improves the computation of the fuzzy covariance matrices in the standard Gustafson and Kessel clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FKM.gkb (X, k, m, vp, gam, mcn, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.gkb_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_vp">vp</code></td>
<td>
<p>Volume parameter (default: rep(1,k))</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_gam">gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (default: 0)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_mcn">mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (default: 1e+15)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>PC</code> (partition coefficient), <code>PE</code> (partition entropy), <code>MPC</code> (modified partition coefficient), <code>SIL</code> (silhouette), <code>SIL.F</code> (fuzzy silhouette), <code>XB</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+2)</p>
</td></tr>
<tr><td><code id="FKM.gkb_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> If a cluster covariance matrix becomes singular, then the algorithm stops and the element of <code>value</code> is NaN.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.gkb</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of clustering index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.gkb</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.gkb</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>FKM.gkb</code>)</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.gkb</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Babuska R., van der Veen P.J., Kaymak U., 2002.  Improved covariance estimation for Gustafson-Kessel clustering. Proceedings of the IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), 1081-1085.
<br /> Gustafson E.E., Kessel W.C., 1978. Fuzzy clustering with a fuzzy covariance matrix. Proceedings of the IEEE Conference on Decision and Control, pp. 761-766.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.gk">FKM.gk</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## unemployment data
data(unemployment)
## Gustafson, Kessel and Babuska-like fuzzy k-means, fixing the number of clusters
clust=FKM.gkb(unemployment,k=3,RS=10)
## Gustafson, Kessel and Babuska-like fuzzy k-means, selecting the number of clusters
clust=FKM.gkb(unemployment,k=2:6,RS=10)
## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.gkb.ent'>Gustafson, Kessel and Babuska - like fuzzy k-means with entropy regularization</h2><span id='topic+FKM.gkb.ent'></span>

<h3>Description</h3>

<p>Performs the Gustafson, Kessel and Babuska - like fuzzy <em>k</em>-means clustering algorithm with entropy regularization.
<br /> Differently from fuzzy <em>k</em>-means, it is able to discover non-spherical clusters.
<br /> The Babuska et al. variant improves the computation of the fuzzy covariance matrices in the standard Gustafson and Kessel clustering algorithm.
<br /> The entropy regularization allows us to avoid using the artificial fuzziness parameter <em>m</em>. This is replaced by the degree of fuzzy entropy <em>ent</em>, related to the concept of temperature in statistical physics.
An interesting property of the fuzzy <em>k</em>-means with entropy regularization is that the prototypes are obtained as weighted means with weights equal to the membership degrees (rather than to the membership degrees at
the power of <em>m</em> as is for the fuzzy k-means).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FKM.gkb.ent (X, k, ent, vp, gam, mcn, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.gkb.ent_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_ent">ent</code></td>
<td>
<p>Degree of fuzzy entropy (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_vp">vp</code></td>
<td>
<p>Volume parameter (default: rep(1,k))</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_gam">gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (default: 0)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_mcn">mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (default: 1e+15)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+2)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> If a cluster covariance matrix becomes singular, the algorithm stops and the element of <code>value</code> is NaN.
<br /> The default value for <code>ent</code> is in general not reasonable if <code>FKM.gk.ent</code> is run using raw data.
<br /> The update of the membership degrees requires the computation of exponential functions. In some cases, this may produce <code>NaN</code> values and the algorithm stops. Such a problem is usually solved by running <code>FKM.gk.ent</code> using standardized data (<code>stand=1</code>).
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.gkb.ent</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>A integer value or vector indicating the number of clusters. (default: 2:6)</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness (<code>NULL</code> for <code>FKM.gkb.ent</code>)</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.gkb.ent</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (default: <code>rep(1,max(k)</code>). If <code>k</code> is a vector, for each group the first <code>k</code> element of <code>vp</code>are considered.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>FKM.gkb.ent</code>)</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.gkb.ent</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Babuska R., van der Veen P.J., Kaymak U., 2002.  Improved covariance estimation for Gustafson-Kessel clustering. Proceedings of the IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), 1081-1085.
<br /> Ferraro M.B., Giordani P., 2013. A new fuzzy clustering algorithm with entropy regularization. Proceedings of the meeting on Classification and Data Analysis (CLADAG).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.gk.ent">FKM.gk.ent</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## unemployment data
data(unemployment)
## Gustafson, Kessel and Babuska-like fuzzy k-means with entropy regularization,
##fixing the number of clusters
clust=FKM.gkb.ent(unemployment,k=3,ent=0.2,RS=10,stand=1)
## Gustafson, Kessel and Babuska-like fuzzy k-means with entropy regularization,
##selecting the number of clusters
clust=FKM.gkb.ent(unemployment,k=2:6,ent=0.2,RS=10,stand=1)
## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.gkb.ent.noise'>Gustafson, Kessel and Babuska - like fuzzy k-means with entropy regularization and noise cluster</h2><span id='topic+FKM.gkb.ent.noise'></span>

<h3>Description</h3>

<p>Performs the Gustafson, Kessel and Babuska - like fuzzy <em>k</em>-means clustering algorithm with entropy regularization and noise cluster.
<br /> Differently from fuzzy <em>k</em>-means, it is able to discover non-spherical clusters.
<br /> The Babuska et al. variant improves the computation of the fuzzy covariance matrices in the standard Gustafson and Kessel clustering algorithm.
<br /> The entropy regularization allows us to avoid using the artificial fuzziness parameter <em>m</em>. This is replaced by the degree of fuzzy entropy <em>ent</em>, related to the concept of temperature in statistical physics.
An interesting property of the fuzzy <em>k</em>-means with entropy regularization is that the prototypes are obtained as weighted means with weights equal to the membership degrees (rather than to the membership degrees at
the power of <em>m</em> as is for the fuzzy k-means).
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FKM.gkb.ent.noise (X,k,ent,vp,delta,gam,mcn,RS,stand,startU,index,alpha,conv,maxit,seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.gkb.ent.noise_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_ent">ent</code></td>
<td>
<p>Degree of fuzzy entropy (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_vp">vp</code></td>
<td>
<p>Volume parameter (default: <code>rep(1,max(k)</code>). If <code>k</code> is a vector, for each group the first <code>k</code> element of <code>vp</code>are considered.</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average Euclidean distance between objects and prototypes from <code>FKM.gk.ent</code> using the same values of <code>k</code> and <code>m</code>)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_gam">gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (default: 0)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_mcn">mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (default: 1e+15)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+2)</p>
</td></tr>
<tr><td><code id="FKM.gkb.ent.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> If a cluster covariance matrix becomes singular, the algorithm stops and the element of <code>value</code> is NaN.
<br /> The default value for <code>ent</code> is in general not reasonable if <code>FKM.gk.ent</code> is run using raw data.
<br /> The update of the membership degrees requires the computation of exponential functions. In some cases, this may produce <code>NaN</code> values and the algorithm stops. Such a problem is usually solved by running <code>FKM.gk.ent.noise</code> using standardized data (<code>stand=1</code>).
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.gkb.ent.noise</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness (<code>NULL</code> for <code>FKM.gkb.ent.noise</code>)</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.gkb.ent.noise</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.gkb.ent.noise</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Babuska R., van der Veen P.J., Kaymak U., 2002.  Improved covariance estimation for Gustafson-Kessel clustering. Proceedings of the IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), 1081-1085.
<br /> Dave' R.N., 1991. Characterization and detection of noise in clustering. Pattern Recognition Letters, 12, 657-664.
<br /> Ferraro M.B., Giordani P., 2013. A new fuzzy clustering algorithm with entropy regularization. Proceedings of the meeting on Classification and Data Analysis (CLADAG).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.gk.ent.noise">FKM.gk.ent.noise</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## unemployment data
data(unemployment)
## Gustafson, Kessel and Babuska-like fuzzy k-means with entropy regularization and noise cluster,
##fixing the number of clusters
clust=FKM.gkb.ent.noise(unemployment,k=3,ent=0.2,delta=1,RS=10,stand=1)
## Gustafson, Kessel and Babuska-like fuzzy k-means with entropy regularization and noise cluster,
##selecting the number of clusters
clust=FKM.gkb.ent.noise(unemployment,k=2:6,ent=0.2,delta=1,RS=10,stand=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.gkb.noise'>Gustafson, Kessel and Babuska - like fuzzy k-means with noise cluster</h2><span id='topic+FKM.gkb.noise'></span>

<h3>Description</h3>

<p>Performs the Gustafson, Kessel and Babuska - like fuzzy <em>k</em>-means clustering algorithm with noise cluster.
<br /> Differently from fuzzy <em>k</em>-means, it is able to discover non-spherical clusters.
<br /> The Babuska et al. variant improves the computation of the fuzzy covariance matrices in the standard Gustafson and Kessel clustering algorithm.
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FKM.gkb.noise (X,k,m,vp,delta,gam,mcn,RS,stand,startU,index,alpha,conv,maxit,seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.gkb.noise_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_vp">vp</code></td>
<td>
<p>Volume parameter (default: rep(1,k))</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average Euclidean distance between objects and prototypes from <code>FKM.gk</code> using the same values of <code>k</code> and <code>m</code>)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_gam">gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (default: 0)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_mcn">mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (default: 1e+15)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+2)</p>
</td></tr>
<tr><td><code id="FKM.gkb.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> If a cluster covariance matrix becomes singular, then the algorithm stops and the element of <code>value</code> is NaN.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.gkb.noise</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.gkb.noise</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.gkb.noise</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (default: <code>rep(1,max(k)</code>). If <code>k</code> is a vector, for each group the first <code>k</code> element of <code>vp</code>are considered.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.gkb.noise</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Babuska R., van der Veen P.J., Kaymak U., 2002.  Improved covariance estimation for Gustafson-Kessel clustering. Proceedings of the IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), 1081-1085.
<br /> Dave' R.N., 1991. Characterization and detection of noise in clustering. Pattern Recognition Letters, 12, 657-664.
<br /> Gustafson E.E., Kessel W.C., 1978. Fuzzy clustering with a fuzzy covariance matrix. Proceedings of the IEEE Conference on Decision and Control, pp. 761-766.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.gk.noise">FKM.gk.noise</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## unemployment data
data(unemployment)
## Gustafson, Kessel and Babuska-like fuzzy k-means with noise cluster,
##fixing the number of clusters
clust=FKM.gkb.noise(unemployment,k=3,delta=20,RS=10)
## Gustafson, Kessel and Babuska-like fuzzy k-means with noise cluster,
##selecting the number of clusters
clust=FKM.gkb.noise(unemployment,k=2:6,delta=20,RS=10)
## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.med'>Fuzzy k-medoids</h2><span id='topic+FKM.med'></span>

<h3>Description</h3>

<p>Performs the fuzzy <em>k</em>-medoids clustering algorithm.
<br /> Differently from fuzzy <em>k</em>-means where the cluster prototypes (centroids) are artificial objects computed as weighted means, in the fuzzy <em>k</em>-medoids the cluster prototypes (medoids) are a subset of the observed objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FKM.med (X, k, m, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.med_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_k">k</code></td>
<td>
<p>An integer value or vector indicating the number of clusters (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 1.5)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>PC</code> (partition coefficient), <code>PE</code> (partition entropy), <code>MPC</code> (modified partition coefficient), <code>SIL</code> (silhouette), <code>SIL.F</code> (fuzzy silhouette), <code>XB</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.med_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> In <code>FKM.med</code> the parameter of fuzziness is usually lower than the one used in <code>FKM</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>FKM.med</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.med</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.med</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>FKM.med</code>)</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>FKM.med</code>)</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.med</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.med</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.med</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Krishnapuram R., Joshi A., Nasraoui O., Yi L., 2001. Low-complexity fuzzy relational clustering algorithms for web mining. IEEE Transactions on Fuzzy Systems, 9, 595-607.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.med.noise">FKM.med.noise</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-medoids, fixing the number of clusters
## (excluded the factor column Type (last column))
clust=FKM.med(Mc[,1:(ncol(Mc)-1)],k=6,m=1.1,RS=10,stand=1)
## fuzzy k-medoids, selecting the number of clusters
## (excluded the factor column Type (last column))
clust=FKM.med(Mc[,1:(ncol(Mc)-1)],k=2:6,m=1.1,RS=10,stand=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='FKM.med.noise'>Fuzzy k-medoids with noise cluster</h2><span id='topic+FKM.med.noise'></span>

<h3>Description</h3>

<p>Performs the fuzzy <em>k</em>-medoids clustering algorithm with noise cluster.
<br /> Differently from fuzzy <em>k</em>-means where the cluster prototypes (centroids) are artificial objects computed as weighted means, in the fuzzy <em>k</em>-medoids the cluster prototypes (medoids) are a subset of the observed objects.
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 FKM.med.noise (X, k, m, delta, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.med.noise_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 1.5)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average Euclidean distance between objects and prototypes from <code>FKM.med</code> using the same values of <code>k</code> and <code>m</code>)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>PC</code> (partition coefficient), <code>PE</code> (partition entropy), <code>MPC</code> (modified partition coefficient), <code>SIL</code> (silhouette), <code>SIL.F</code> (fuzzy silhouette), <code>XB</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.med.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
<br /> As for <code>FKM.med</code>, in <code>FKM.med.noise</code> the parameter of fuzziness is usually lower than the one used in <code>FKM</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>FKM.med.noise</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of clustering index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.med.noise</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.med.noise</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>FKM.med.noise</code>)</p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p>Noise distance</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.med.noise</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.med.noise</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.med.noise</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Dave' R.N., 1991. Characterization and detection of noise in clustering. Pattern Recognition Letters, 12, 657-664.
<br /> Krishnapuram R., Joshi A., Nasraoui O., Yi L., 2001. Low-complexity fuzzy relational clustering algorithms for web mining. IEEE Transactions on Fuzzy Systems, 9, 595-607.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.med">FKM.med</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+butterfly">butterfly</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## butterfly data
data(butterfly)
## fuzzy k-medoids with noise cluster, fixing the number of clusters
clust=FKM.med.noise(butterfly,k=2,RS=5,delta=3)
## fuzzy k-medoids with noise cluster, selecting the number of clusters
clust=FKM.med.noise(butterfly,RS=5,delta=3)
</code></pre>

<hr>
<h2 id='FKM.noise'>Fuzzy k-means with noise cluster</h2><span id='topic+FKM.noise'></span>

<h3>Description</h3>

<p>Performs the fuzzy <em>k</em>-means clustering algorithm with noise cluster. 
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 FKM.noise (X, k, m, delta, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.noise_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average Euclidean distance between objects and prototypes from <code>FKM</code> using the same values of <code>k</code> and <code>m</code>)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>PC</code> (partition coefficient), <code>PE</code> (partition entropy), <code>MPC</code> (modified partition coefficient), <code>SIL</code> (silhouette), <code>SIL.F</code> (fuzzy silhouette), <code>XB</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>FKM.noise</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.noise</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.noise</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>FKM.noise</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>FKM.noise</code>)</p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p>Noise distance</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.noise</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.noise</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.noise</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Dave' R.N., 1991. Characterization and detection of noise in clustering. Pattern Recognition Letters, 12, 657-664.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM">FKM</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+butterfly">butterfly</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## butterfly data
data(butterfly)
## fuzzy k-means with noise cluster, fixing the number of clusters
clust=FKM.noise(butterfly, k = 2, RS=5,delta=3)
## fuzzy k-means with noise cluster, selecting the number of clusters
clust=FKM.noise(butterfly,RS=5,delta=3)
</code></pre>

<hr>
<h2 id='FKM.pf'>Fuzzy k-means with polynomial fuzzifier</h2><span id='topic+FKM.pf'></span>

<h3>Description</h3>

<p>Performs the fuzzy <em>k</em>-means clustering algorithm with polynomial fuzzifier function. 
<br /> The polynomial fuzzifier creates areas of crisp membership degrees around the prototypes while, outside of these areas of crisp membership degrees, fuzzy membership degrees are given. Therefore, the polynomial fuzzifier produces membership degrees equal to one for objects clearly assigned to clusters, that is, very close to the cluster prototypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 FKM.pf (X, k, b, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.pf_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_b">b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (default: 0.5)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette), <code>"XB"</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.pf_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.pf</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Winkler R., Klawonn F., Hoeppner F., Kruse R., 2010. Fuzzy Cluster Analysis of Larger Data Sets. In: Scalable Fuzzy Algorithms for Data Management and Analysis: Methods and Design IGI Global, pp. 302-331. IGI Global, Hershey.
<br /> Winkler R., Klawonn F., Kruse R., 2011. Fuzzy clustering with polynomial fuzzifier function in connection with M-estimators. Applied and Computational Mathematics, 10, 146-163.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.pf.noise">FKM.pf.noise</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means with polynomial fuzzifier, fixing the number of clusters 
## (excluded the factor column Type (last column))
clust=FKM.pf(Mc[,1:(ncol(Mc)-1)],k=6,stand=1)
## fuzzy k-means with polynomial fuzzifier, selecting the number of clusters  
## (excluded the factor column Type (last column))
clust=FKM.pf(Mc[,1:(ncol(Mc)-1)],k=2:6,stand=1)
</code></pre>

<hr>
<h2 id='FKM.pf.noise'>Fuzzy k-means with polynomial fuzzifier and noise cluster</h2><span id='topic+FKM.pf.noise'></span>

<h3>Description</h3>

<p>Performs the fuzzy <em>k</em>-means clustering algorithm with polynomial fuzzifier function and noise cluster.
<br /> The polynomial fuzzifier creates areas of crisp membership degrees around the prototypes while, outside of these areas of crisp membership degrees, fuzzy membership degrees are given. Therefore, the polynomial fuzzifier produces membership degrees equal to one for objects clearly assigned to clusters, that is, very close to the cluster prototypes.
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 FKM.pf.noise (X, k, b, delta, RS, stand, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FKM.pf.noise_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_b">b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (default: 0.5)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average Euclidean distance between objects and prototypes from <code>FKM.pf</code> using the same values of <code>k</code> and <code>m</code>)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_stand">stand</code></td>
<td>
<p>Standardization: if <code>stand=1</code>, the clustering algorithm is run using standardized data (default: no standardization)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>PC</code> (partition coefficient), <code>PE</code> (partition entropy), <code>MPC</code> (modified partition coefficient), <code>SIL</code> (silhouette), <code>SIL.F</code> (fuzzy   silhouette), <code>XB</code> (Xie and Beni) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="FKM.pf.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>FKM.pf.noise</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>FKM.pf.noise</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness (<code>NULL</code> for <code>FKM.pf.noise</code>)</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>FKM.pf.noise</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>FKM.pf.noise</code>)</p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p>Noise distance</p>
</td></tr>
<tr><td><code>gam</code></td>
<td>
<p>Weighting parameter for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.pf.noise</code>)</p>
</td></tr>
<tr><td><code>mcn</code></td>
<td>
<p>Maximum condition number for the fuzzy covariance matrices (<code>NULL</code> for <code>FKM.pf.noise</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (standardized data if <code>stand=1</code>)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix (<code>NULL</code> for <code>FKM.pf.noise</code>)</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Dave' R.N., 1991. Characterization and detection of noise in clustering. Pattern Recognition Letters, 12, 657-664.
<br /> Winkler R., Klawonn F., Hoeppner F., Kruse R., 2010. Fuzzy cluster analysis of larger data sets. In: Scalable Fuzzy Algorithms for Data Management and Analysis: Methods and Design IGI Global, pp. 302-331. IGI Global, Hershey.
<br /> Winkler R., Klawonn F., Kruse R., 2011. Fuzzy clustering with polynomial fuzzifier function in connection with M-estimators. Applied and Computational Mathematics, 10, 146-163.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM.pf">FKM.pf</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Fclust.index">Fclust.index</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means with polynomial fuzzifier and noise cluster, fixing the number of clusters 
## (excluded the factor column Type (last column))
clust=FKM.pf.noise(Mc[,1:(ncol(Mc)-1)],k=6,stand=1)
## fuzzy k-means with polynomial fuzzifier and noise cluster, selecting the number of clusters 
## (excluded the factor column Type (last column))
clust=FKM.pf.noise(Mc[,1:(ncol(Mc)-1)],k=2:6,stand=1)
</code></pre>

<hr>
<h2 id='houseVotes'>
Congressional Voting Records Data</h2><span id='topic+houseVotes'></span>

<h3>Description</h3>

<p>1984 United Stated Congressional Voting Records for each of the U.S. House of
Representatives Congressmen on the 16 key votes identified by the
Congressional Quarterly Almanac.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(houseVotes)</code></pre>


<h3>Format</h3>

<p>A data.frame with 435 rows on 17 columns (16 qualitative variables and 1 classification variable).
</p>


<h3>Details</h3>

<p>The data collect 1984 United Stated Congressional Voting Records for each of the 435 U.S. House of Representatives Congressmen on the 16 key votes identified by the Congressional Quarterly Almanac (CQA). The variable <code>class</code> splits the observations in <code>democrat</code> and <code>republican</code>. The qualitative variables refer to the votes on <code>handicapped-infants</code>, <code>water-project-cost-sharing</code>, <code>adoption-of-the-budget-resolution</code>, <code>physician-fee-freeze</code>, <code>el-salvador-aid</code>, <code>religious-groups-in-schools</code>, <code>anti-satellite-test-ban</code>, <code>aid-to-nicaraguan-contras</code>, <code>mx-missile</code>, <code>immigration</code>, <code>synfuels-corporation-cutback</code>, <code>education-spending</code>, <code>superfund-right-to-sue</code>, <code>crime</code>, <code>duty-free-exports</code>, and <code>export-administration-act-south-africa</code>. All these 16 variables are objects of class <code>factor</code> with three levels according to the CQA scheme: <code>y</code> refers to the types of votes &rdquo;voted for&rdquo;, &rdquo;paired for&rdquo; and &rdquo;announced for&rdquo;; <code>n</code> to &rdquo;voted against&rdquo;, &rdquo;paired against&rdquo; and &rdquo;announced against&rdquo;; codeyn to &rdquo;voted present&rdquo;, &rdquo;voted present to avoid conflict of interest&rdquo; and &rdquo;did not vote or otherwise make a position known&rdquo;.</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>Source</h3>

<p>https://archive.ics.uci.edu/ml/datasets/congressional+voting+records
</p>


<h3>References</h3>

<p>Schlimmer, J.C., 1987. Concept acquisition through representational adjustment. Doctoral dissertation, Department of Information and Computer Science, University of California, Irvine, CA. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NEFRC">NEFRC</a></code>, <code><a href="#topic+NEFRC.noise">NEFRC.noise</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(houseVotes)
X=houseVotes[,-1]
class=houseVotes[,1]

</code></pre>

<hr>
<h2 id='Hraw'>Raw prototypes</h2><span id='topic+Hraw'></span>

<h3>Description</h3>

<p>Produces prototypes using the original units of measurement of <em>X</em> (useful if the clustering algorithm is run using standardized data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> Hraw (X, H)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Hraw_+3A_x">X</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="Hraw_+3A_h">H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Hraw</code></td>
<td>
<p>Prototypes matrix using the original units of measurement of <code>X</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## example n.1 (k-means case)
## unemployment data
data(unemployment)
## fuzzy k-means
unempFKM=FKM(unemployment,k=3,stand=1)
## standardized prototypes
unempFKM$H
## prototypes using the original units of measurement
unempFKM$Hraw=Hraw(unempFKM$X,unempFKM$H)
## example n.2  (k-medoids case)
## unemployment data
data(unemployment)
## fuzzy k-medoids
## Not run: 
## It may take more than a few seconds
unempFKM.med=FKM.med(unemployment,k=3,RS=10,stand=1)
## prototypes using the original units of measurement:
## in fuzzy k-medoids one can equivalently use
unempFKM.med$Hraw1=Hraw(unempFKM.med$X,unempFKM.med$H)
unempFKM.med$Hraw2=unempFKM.med$X[unempFKM.med$medoid,]
## End(Not run)
</code></pre>

<hr>
<h2 id='JACCARD.F'>
Fuzzy Jaccard index</h2><span id='topic+JACCARD.F'></span>

<h3>Description</h3>

<p>Produces the fuzzy version of the Jaccard index between a hard (reference) partition and a fuzzy partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JACCARD.F(VC, U, t_norm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JACCARD.F_+3A_vc">VC</code></td>
<td>
<p>Vector of class labels</p>
</td></tr>
<tr><td><code id="JACCARD.F_+3A_u">U</code></td>
<td>
<p>Fuzzy membership degree matrix or data.frame</p>
</td></tr>
<tr><td><code id="JACCARD.F_+3A_t_norm">t_norm</code></td>
<td>
<p>Type of the triangular norm: &quot;minimum&quot; (minimum triangular norm), &quot;triangular product&quot; (product norm) (default: &quot;minimum&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>jaccard.f</code>Value of the fuzzy Jaccard index
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Campello, R.J., 2007. A fuzzy extension of the Rand index and other related indexes for clustering and classification assessment. Pattern Recognition Letters, 28, 833-841.
<br /> Jaccard, P., 1901. Étude comparative de la distribution florale dans une portion des Alpes et des Jura. Bulletin de la Société Vaudoise des Sciences Naturelles, 37, 547-579.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARI.F">ARI.F</a></code>, <code><a href="#topic+RI.F">RI.F</a></code>, <code><a href="#topic+Fclust.compare">Fclust.compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## fuzzy Jaccard index
jaccard.f=JACCARD.F(VC=Mc$Type,U=clust$U)

## End(Not run)
</code></pre>

<hr>
<h2 id='Mc'>McDonald's data</h2><span id='topic+Mc'></span>

<h3>Description</h3>

<p>Nutrition analysis of McDonald's menu items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mc)</code></pre>


<h3>Format</h3>

<p>A data.frame with 81 rows and 16 columns.
</p>


<h3>Details</h3>

<p>Data are from McDonald's USA Nutrition Facts for Popular Menu Items. A subset of menu items is reported. Beverages are excluded.
In case of duplications, regular size or medium size information is reported. The variable Type is a factor the levels of which specify the kind of the menu items.
Although some menu items could be well described by more than one level, only one level of the variable Type specifies each menu item.
Percent Daily Values (%DV) are based on a 2,000 calorie diet. Some menu items are registered trademarks.
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+FKM">FKM</a></code>, <code><a href="#topic+FKM.ent">FKM.ent</a></code>, <code><a href="#topic+FKM.med">FKM.med</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
p=(ncol(Mc)-1)
## fuzzy k-means (excluded the factor column Type (last column))
clust.FKM=FKM(Mc[,1:p],k=6,m=1.5,stand=1)
## new factor column Cluster.FKM containing the cluster assignment information
## using fuzzy k-means
Mc[,ncol(Mc)+1]=factor(clust.FKM$clus[,1])
colnames(Mc)[ncol(Mc)]=("Cluster.FKM")
levels(Mc$Cluster.FKM)=paste("Clus FKM",1:clust.FKM$k,sep=" ")
## contingency table (Cluster.FKM vs Type)
## to assess whether clusters can be interpreted in terms of the levels of Type
table(Mc$Type,Mc$Cluster.FKM)
## prototypes using the original units of measurement
clust.FKM$Hraw=Hraw(clust.FKM$X,clust.FKM$H)
clust.FKM$Hraw
## fuzzy k-means with entropy regularization
## (excluded the factor column Type (last column))
## Not run: 
## It may take more than a few seconds
clust.FKM.ent=FKM.ent(Mc[,1:p],k=6,ent=3,RS=10,stand=1)
## new factor column Cluster.FKM.ent containing the cluster assignment information
## using fuzzy k-medoids with entropy regularization
Mc[,ncol(Mc)+1]=factor(clust.FKM.ent$clus[,1])
colnames(Mc)[ncol(Mc)]=("Cluster.FKM.ent")
levels(Mc$Cluster.FKM.ent)=paste("Clus FKM.ent",1:clust.FKM.ent$k,sep=" ")
## contingency table (Cluster.FKM.ent vs Type)
## to assess whether clusters can be interpreted in terms of the levels of Type
table(Mc$Type,Mc$Cluster.FKM.ent)
## prototypes using the original units of measurement
clust.FKM.ent$Hraw=Hraw(clust.FKM.ent$X,clust.FKM.ent$H)
clust.FKM.ent$Hraw
## End(Not run)
## fuzzy k-medoids
## (excluded the factor column Type (last column))
clust.FKM.med=FKM.med(Mc[,1:p],k=6,m=1.1,RS=10,stand=1)
## new factor column Cluster.FKM.med containing the cluster assignment information
## using fuzzy k-medoids with entropy regularization
Mc[,ncol(Mc)+1]=factor(clust.FKM.med$clus[,1])
colnames(Mc)[ncol(Mc)]=("Cluster.FKM.med")
levels(Mc$Cluster.FKM.med)=paste("Clus FKM.med",1:clust.FKM.med$k,sep=" ")
## contingency table (Cluster.FKM.med vs Type)
## to assess whether clusters can be interpreted in terms of the levels of Type
table(Mc$Type,Mc$Cluster.FKM.med)
## prototypes using the original units of measurement
clust.FKM.med$Hraw=Hraw(clust.FKM.med$X,clust.FKM.med$H)
clust.FKM.med$Hraw
## or, equivalently,
Mc[clust.FKM.med$medoid,1:p]</code></pre>

<hr>
<h2 id='MPC'>Modified partition coefficient</h2><span id='topic+MPC'></span>

<h3>Description</h3>

<p>Produces the modified partition coefficient index. The optimal number of clusters <em>k</em> is such that the index takes the maximum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> MPC (U)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MPC_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>mpc</code></td>
<td>
<p>Value of the modified partition coefficient index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Dave' R.N., 1996. Validating fuzzy partitions obtained through <em>c</em>-shells clustering. Pattern Recognition Letters, 17, 613-623.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PC">PC</a></code>, <code><a href="#topic+PE">PE</a></code>, <code><a href="#topic+SIL">SIL</a></code>, <code><a href="#topic+SIL.F">SIL.F</a></code>, <code><a href="#topic+XB">XB</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## modified partition coefficient
mpc=MPC(clust$U)
</code></pre>

<hr>
<h2 id='NBA'>
NBA teams data </h2><span id='topic+NBA'></span>

<h3>Description</h3>

<p>NBA team statistics from the 2017-2018 regular season.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NBA)</code></pre>


<h3>Format</h3>

<p>A data.frame with 30 rows and 22 columns.
</p>


<h3>Details</h3>

<p>Data refer to some statistics of the NBA teams for the regular season 2017-2018. The teams are distinguished according to two classification variables.
</p>
<p>The statistics are: number of wins (<code>W</code>), field goals made (<code>FGM</code>), field goals attempted (<code>FGA</code>), field goals percentage (<code>FGP</code>), 3 point field goals made (<code>3PM</code>), 3 point field goals attempted (<code>3PA</code>), 3 point field goals percentage (<code>3PP</code>), free throws made (<code>FTM</code>), free throws attempted (<code>FTA</code>), free throws percentage (<code>FTP</code>), offensive rebounds (<code>OREB</code>), defensive rebounds (<code>DREB</code>), assists (<code>AST</code>), turnovers (<code>TOV</code>), steals (<code>STL</code>), blocks (<code>BLK</code>), blocked field goal attempts (<code>BLKA</code>), personal fouls (<code>PF</code>), personal fouls drawn (<code>PFD</code>) and points (<code>PTS</code>). Moreover, reported are the conference (<code>Conference</code>) and the playoff appearance (<code>Playoff</code>).
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>Source</h3>

<p>https://stats.nba.com/teams/traditional/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FKM">FKM</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(NBA)
## A subset of variables is considered
X &lt;- NBA[,c(4,7,10,11,12,13,14,15,16,17,20)]
clust.FKM=FKM(X=X,k=2:6,m=1.5,RS=50,stand=1,index="SIL.F",alpha=1)
summary(clust.FKM)

## End(Not run)
</code></pre>

<hr>
<h2 id='NEFRC'>
Non-Euclidean Fuzzy Relational Clustering</h2><span id='topic+NEFRC'></span>

<h3>Description</h3>

<p>Performs the Non-Euclidean Fuzzy Relational data Clustering algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NEFRC(D, k, m, RS, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NEFRC_+3A_d">D</code></td>
<td>
<p>Matrix or data.frame containing distances/dissimilarities</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="NEFRC_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix (<code>NULL</code> for <code>NEFRC</code>)</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>NEFRC</code>).</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>NEFRC</code>).</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>NEFRC</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>NEFRC</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>NEFRC</code>)</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>NEFRC</code>)</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>) (<code>NULL</code> for <code>NEFRC</code>)</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (<code>NULL</code> for <code>NEFRC</code>, <code>D</code> is used)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data (<code>NULL</code> for <code>NEFRC</code>)</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Davé, R. N., &amp; Sen, S. 2002. Robust fuzzy clustering of relational data. IEEE Transactions on Fuzzy Systems, 10(6), 713-727.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NEFRC.noise">NEFRC.noise</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(cluster)
data("houseVotes")
X &lt;- houseVotes[,-1]
D &lt;- daisy(x = X, metric = "gower")
clust.NEFRC &lt;- NEFRC(D = D, k = 2:6, m = 2, index = "SIL.F")
summary(clust.NEFRC)
plot(clust.NEFRC)

## End(Not run)
</code></pre>

<hr>
<h2 id='NEFRC.noise'>Non-Euclidean Fuzzy Relational Clustering with noise cluster</h2><span id='topic+NEFRC.noise'></span>

<h3>Description</h3>

<p>Performs the Non-Euclidean Fuzzy Relational data Clustering algorithm.
<br /> The noise cluster is an additional cluster (with respect to the <em>k</em> standard clusters) such that objects recognized to be outliers are assigned to it with high membership degrees.</p>


<h3>Usage</h3>

<pre><code class='language-R'>NEFRC.noise(D, k, m, delta, RS, startU, index, alpha, conv, maxit, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NEFRC.noise_+3A_d">D</code></td>
<td>
<p>Matrix or data.frame containing distances/dissimilarities</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_k">k</code></td>
<td>
<p>An integer value or vector specifying the number of clusters for which the <code>index</code> is to be calculated (default: 2:6)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_delta">delta</code></td>
<td>
<p>Noise distance (default: average observed distance)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_rs">RS</code></td>
<td>
<p>Number of (random) starts (default: 1)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_startu">startU</code></td>
<td>
<p>Rational start for the membership degree matrix <code>U</code> (default: no rational start)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_index">index</code></td>
<td>
<p>Cluster validity index to select the number of clusters: <code>"PC"</code> (partition coefficient), <code>"PE"</code> (partition entropy), <code>"MPC"</code> (modified partition coefficient), <code>"SIL"</code> (silhouette), <code>"SIL.F"</code> (fuzzy silhouette) (default: &quot;SIL.F&quot;)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient for the fuzzy silhouette index <code>SIL.F</code> (default: 1)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion (default: 1e-9)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations (default: 1e+6)</p>
</td></tr>
<tr><td><code id="NEFRC.noise_+3A_seed">seed</code></td>
<td>
<p>Seed value for random number generation (default: NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>startU</code> is given, the argument <code>k</code> is ignored (the number of clusters is <code>ncol(startU)</code>).
<br /> If <code>startU</code> is given, the first element of <code>value</code>, <code>cput</code> and <code>iter</code> refer to the rational start.
</p>


<h3>Value</h3>

<p>Object of class <code>fclust</code>, which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>Prototype matrix (<code>NULL</code> for <code>NEFRC.noise</code>)</p>
</td></tr>
<tr><td><code>F</code></td>
<td>
<p>Array containing the covariance matrices of all the clusters (<code>NULL</code> for <code>NEFRC.noise</code>)</p>
</td></tr>
<tr><td><code>clus</code></td>
<td>
<p>Matrix containing the indexes of the clusters where the objects are assigned (column 1) and the associated membership degrees (column 2)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>Vector containing the indexes of the medoid objects (<code>NULL</code> for <code>NEFRC.noise</code>)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Vector containing the loss function values for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Vector containing the values of the cluster validity index</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Vector containing the numbers of iterations for the <code>RS</code> starts</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Parameter of fuzziness</p>
</td></tr>
<tr><td><code>ent</code></td>
<td>
<p>Degree of fuzzy entropy (<code>NULL</code> for <code>NEFRC.noise</code>)</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Parameter of the polynomial fuzzifier (<code>NULL</code> for <code>NEFRC.noise</code>)</p>
</td></tr>
<tr><td><code>vp</code></td>
<td>
<p>Volume parameter (<code>NULL</code> for <code>NEFRC.noise</code>)</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Noise distance (<code>NULL</code> for <code>NEFRC.noise</code>).</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>Standardization (Yes if <code>stand=1</code>, No if <code>stand=0</code>) (<code>NULL</code> for <code>NEFRC.noise</code>).</p>
</td></tr>
<tr><td><code>Xca</code></td>
<td>
<p>Data used in the clustering algorithm (<code>NULL</code> for <code>NEFRC.noise</code>), <code>D</code> is used)</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Raw data (<code>NULL</code> for <code>NEFRC.noise</code>)</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Dissimilarity matrix</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Matched call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Davé, R. N., &amp; Sen, S. 2002. Robust fuzzy clustering of relational data. IEEE Transactions on Fuzzy Systems, 10(6), 713-727.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NEFRC">NEFRC</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(cluster)
data("houseVotes")
X &lt;- houseVotes[,-1]
D &lt;- daisy(x = X, metric = "gower")
clust.NEFRC.noise &lt;- NEFRC.noise(D = D, k = 2:6, m = 2, index = "SIL.F")
summary(clust.NEFRC.noise)
plot(clust.NEFRC.noise)

## End(Not run)
</code></pre>

<hr>
<h2 id='PC'>Partition coefficient</h2><span id='topic+PC'></span>

<h3>Description</h3>

<p>Produces the partition coefficient index. The optimal number of clusters <em>k</em> is  is such that the index takes the maximum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> PC (U)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PC_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pc</code></td>
<td>
<p>Value of the partition coefficient index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Bezdek J.C., 1974. Cluster validity with fuzzy sets. Journal of Cybernetics, 3, 58-73.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PE">PE</a></code>, <code><a href="#topic+MPC">MPC</a></code>, <code><a href="#topic+SIL">SIL</a></code>, <code><a href="#topic+SIL.F">SIL.F</a></code>, <code><a href="#topic+XB">XB</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## partition coefficient
pc=PC(clust$U)
</code></pre>

<hr>
<h2 id='PE'>Partition entropy</h2><span id='topic+PE'></span>

<h3>Description</h3>

<p>Produces the partition entropy index. The optimal number of clusters <em>k</em> is  is such that the index takes the minimum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> PE (U, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PE_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code id="PE_+3A_b">b</code></td>
<td>
<p>Logarithmic base (default: exp(1))</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pe</code></td>
<td>
<p>Value of the partition entropy index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Bezdek J.C., 1981. Pattern Recognition with Fuzzy Objective Function Algorithms. Plenum Press, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PC">PC</a></code>, <code><a href="#topic+MPC">MPC</a></code>, <code><a href="#topic+SIL">SIL</a></code>, <code><a href="#topic+SIL.F">SIL.F</a></code>, <code><a href="#topic+XB">XB</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## partition entropy index
pe=PE(clust$U)
</code></pre>

<hr>
<h2 id='plot.fclust'>Plotting fuzzy clustering output</h2><span id='topic+plot.fclust'></span>

<h3>Description</h3>

<p>Plot method for class <code>fclust</code>. The function creates a scatter plot visualizing the cluster structure. The objects are represented by points in the plot using observed variables or principal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class fclust
 ## S3 method for class 'fclust'
 plot(x, v1v2, colclus, umin, ucex, pca, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fclust_+3A_x">x</code></td>
<td>
<p>Object of class <code>fclust</code></p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_v1v2">v1v2</code></td>
<td>
<p>Vector with two elements specifying the numbers of the variables (or of the principal components) to be plotted (default: <code>1:2</code>); in case of relational data, the argument is ignored</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_colclus">colclus</code></td>
<td>
<p>Vector specifying the color palette for the clusters (default: <code>palette(rainbow(k))</code>)</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_umin">umin</code></td>
<td>
<p>Lowest maximal membership degree such that an object is assigned to a cluster (default: 0)</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_ucex">ucex</code></td>
<td>
<p>Logical value specifying if the points are magnified according to the maximal membership degree (if <code>ucex=TRUE</code>) (default: <code>ucex=FALSE</code>)</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_pca">pca</code></td>
<td>
<p>Logical value specifying if the objects are represented using principal components (if <code>pca=TRUE</code>) (default: <code>pca=FALSE</code>); in case of relational data, the argument is ignored</p>
</td></tr>
<tr><td><code id="plot.fclust_+3A_...">...</code></td>
<td>
<p>Additional arguments arguments for <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the scatter plot the objects are represented by circles (<code>pch=16</code>) and the prototypes by stars (<code>pch=8</code>) using observed variables (if <code>pca=FALSE</code>) or principal components (if <code>pca=TRUE</code>), the numbers of which are specified in <code>v1v2</code>. Their colors differ for every cluster according to <code>colclus</code>. Objects such that their maximal membership degrees are lower than <code>umin</code> are in black. The sizes of the circles depends on the maximal membership degrees of the corresponding objects if <code>ucex=TRUE</code>. Also note that principal components are extracted using standardized data.
<br /> In case of relational data, the first two components resulting from Non-metric Multidimensional Scaling performed using the package <span class="pkg">MASS</span> are used.
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+VIFCR">VIFCR</a></code>, <code><a href="#topic+VAT">VAT</a></code>, <code><a href="#topic+VCV">VCV</a></code>, <code><a href="#topic+VCV2">VCV2</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## Scatter plot of Calories vs Cholesterol (mg)
names(Mc)
plot(clust,v1v2=c(1,5))
## Scatter plot of Calories vs Cholesterol (mg) using gray levels for the clusters
plot(clust,v1v2=c(1,5),colclus=gray.colors(6))
## Scatter plot of Calories vs Cholesterol (mg)
## coloring in black objects with maximal membership degree lower than 0.5
plot(clust,v1v2=c(1,5),umin=0.5)
## Scatter plot of Calories vs Cholesterol (mg)
## coloring in black objects with maximal membership degree lower than 0.5
## and magnifying the points according to the maximal membership degree
plot(clust,v1v2=c(1,5),umin=0.5,ucex=TRUE)
## Scatter plot using the first two principal components and
## coloring in black objects with maximal membership degree lower than 0.3
plot(clust,v1v2=1:2,umin=0.3,pca=TRUE)
</code></pre>

<hr>
<h2 id='print.fclust'>Printing fuzzy clustering output</h2><span id='topic+print.fclust'></span>

<h3>Description</h3>

<p>Print method for class <code>fclust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class fclust
 ## S3 method for class 'fclust'
 print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.fclust_+3A_x">x</code></td>
<td>
<p>Object of class <code>fclust</code></p>
</td></tr>
<tr><td><code id="print.fclust_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="base.html#topic+print">print</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function displays the number of objects, the number of clusters, the closest hard clustering partition (objects assigned to the clusters with the highest membership degree) and the membership degree matrix (rounded).
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+summary.fclust">summary.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## unemployment data
data(unemployment)
## fuzzy k-means
unempFKM=FKM(unemployment,k=3,stand=1)
unempFKM
</code></pre>

<hr>
<h2 id='RI.F'>
Fuzzy Rand index</h2><span id='topic+RI.F'></span>

<h3>Description</h3>

<p>Produces the fuzzy version of the Rand index between a hard (reference) partition and a fuzzy partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RI.F(VC, U, t_norm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RI.F_+3A_vc">VC</code></td>
<td>
<p>Vector of class labels</p>
</td></tr>
<tr><td><code id="RI.F_+3A_u">U</code></td>
<td>
<p>Fuzzy membership degree matrix or data.frame</p>
</td></tr>
<tr><td><code id="RI.F_+3A_t_norm">t_norm</code></td>
<td>
<p>Type of the triangular norm: &quot;minimum&quot; (minimum triangular norm), &quot;triangular product&quot; (product norm) (default: &quot;minimum&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ri.f</code>Value of the fuzzy adjusted Rand index
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Campello, R.J., 2007. A fuzzy extension of the Rand index and other related indexes for clustering and classification assessment. Pattern Recognition Letters, 28, 833-841.
<br /> Rand, W.M., 1971. Objective criteria for the evaluation of clustering methods. Journal of the American Statistical Association, 66, 846-850.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARI.F">ARI.F</a></code>, <code><a href="#topic+JACCARD.F">JACCARD.F</a></code>, <code><a href="#topic+Fclust.compare">Fclust.compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## fuzzy Rand index
ri.f=RI.F(VC=Mc$Type,U=clust$U)

## End(Not run)
</code></pre>

<hr>
<h2 id='SIL'>Silhouette index</h2><span id='topic+SIL'></span>

<h3>Description</h3>

<p>Produces the silhouette index. The optimal number of clusters <em>k</em> is  is such that the index takes the maximum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> SIL (Xca, U, distance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SIL_+3A_xca">Xca</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="SIL_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code id="SIL_+3A_distance">distance</code></td>
<td>
<p>If <code>distance=TRUE</code>, <code>Xca</code> is assumed to contain distances/dissimilarities (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Xca</code> should contain the same dataset used in the clustering algorithm, i.e., if the clustering algorithm is run using standardized data, then <code>SIL</code> should be computed using the same standardized data.
<br /> Set <code>distance=TRUE</code> if <code>Xca</code> is a distance/dissimilarity matrix.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sil.obj</code></td>
<td>
<p>Vector containing the silhouette indexes for all the objects</p>
</td></tr>
<tr><td><code>sil</code></td>
<td>
<p>Value of the silhouette index (mean of <code>sil.obj</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Kaufman L., Rousseeuw P.J., 1990. Finding Groups in Data: An Introduction to Cluster Analysis. Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PC">PC</a></code>, <code><a href="#topic+PE">PE</a></code>, <code><a href="#topic+MPC">MPC</a></code>, <code><a href="#topic+SIL.F">SIL.F</a></code>, <code><a href="#topic+XB">XB</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## silhouette index
sil=SIL(clust$Xca,clust$U)
</code></pre>

<hr>
<h2 id='SIL.F'>Fuzzy silhouette index</h2><span id='topic+SIL.F'></span>

<h3>Description</h3>

<p>Produces the fuzzy silhouette index. The optimal number of clusters <em>k</em> is  is such that the index takes the maximum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> SIL.F (Xca, U, alpha, distance)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SIL.F_+3A_xca">Xca</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="SIL.F_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code id="SIL.F_+3A_alpha">alpha</code></td>
<td>
<p>Weighting coefficient (default: 1)</p>
</td></tr>
<tr><td><code id="SIL.F_+3A_distance">distance</code></td>
<td>
<p>If <code>distance=TRUE</code>, <code>Xca</code> is assumed to contain distances/dissimilarities (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Xca</code> should contain the same dataset used in the clustering algorithm, i.e., if the clustering algorithm is run using standardized data, then <code>SIL.F</code> should be computed using the same standardized data.
<br /> Set <code>distance=TRUE</code> if <code>Xca</code> is a distance/dissimilarity matrix.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sil.f</code></td>
<td>
<p>Value of the fuzzy silhouette index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Campello R.J.G.B., Hruschka E.R., 2006. A fuzzy extension of the silhouette width criterion for cluster analysis. Fuzzy Sets and Systems, 157, 2858-2875.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PC">PC</a></code>, <code><a href="#topic+PE">PE</a></code>, <code><a href="#topic+MPC">MPC</a></code>, <code><a href="#topic+SIL">SIL</a></code>, <code><a href="#topic+XB">XB</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## fuzzy silhouette index
sil.f=SIL.F(clust$Xca,clust$U)
</code></pre>

<hr>
<h2 id='summary.fclust'>Summarizing fuzzy clustering output</h2><span id='topic+summary.fclust'></span>

<h3>Description</h3>

<p>Summary method for class <code>fclust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class fclust
 ## S3 method for class 'fclust'
 summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fclust_+3A_object">object</code></td>
<td>
<p>Object of class <code>fclust</code></p>
</td></tr>
<tr><td><code id="summary.fclust_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="base.html#topic+summary">summary</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function displays the number of objects, the number of clusters, the cluster sizes, the closest hard clustering partition (objects assigned to the clusters with the highest membership degree), the cluster memberships (using the closest hard clustering partition), the number of objects with unclear assignment (when the maximal membership degree is lower than 0.5), the objects with unclear assignment and the cluster sizes without unclear assignments (only if objects with unclear assignment are present), the cluster summary (for every cluster: size, minimal membership degree, maximal membership degree, average membership degree, number of objects with unclear assignment) and the Euclidean distance matrix for the cluster prototypes.</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+print.fclust">print.fclust</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## unemployment data
data(unemployment)
## fuzzy k-means
unempFKM=FKM(unemployment,k=3,stand=1)
summary(unempFKM)
</code></pre>

<hr>
<h2 id='synt.data'>Synthetic data</h2><span id='topic+synt.data'></span>

<h3>Description</h3>

<p>Synthetic dataset with 2 non-spherical clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(synt.data)</code></pre>


<h3>Format</h3>

<p>A matrix with 302 rows and 2 columns.
</p>


<h3>Details</h3>

<p>Although two clusters are clearly visible, fuzzy k-means fails to discover them.
The Gustafson and Kessel-like fuzzy k-means should be used for finding the known-in-advance clusters.</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+FKM">FKM</a></code>, <code><a href="#topic+FKM.gk">FKM.gk</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## synthetic data
data(synt.data)
plot(synt.data)
## fuzzy k-means
syntFKM=FKM(synt.data)
## Gustafson and Kessel-like fuzzy k-means
syntFKM.gk=FKM.gk(synt.data)
## plot of cluster structures from fuzzy k-means and Gustafson and Kessel-like fuzzy k-means
par(mfcol = c(2,1))
plot(syntFKM)
plot(syntFKM.gk)

## End(Not run)
</code></pre>

<hr>
<h2 id='synt.data2'>Synthetic data</h2><span id='topic+synt.data2'></span>

<h3>Description</h3>

<p>Synthetic dataset with 2 non-spherical clusters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(synt.data2)</code></pre>


<h3>Format</h3>

<p>A matrix with 240 rows and 2 columns.
</p>


<h3>Details</h3>

<p>Although three clusters are clearly visible, Gustafson and Kessel - like fuzzy <em>k</em>-means clustering algorithm <code>FKM.gk</code> fails due to singularity of some covariance matrix.
The Gustafson, Kessel and Babuska - like fuzzy <em>k</em>-means clustering algorithm <code>FKM.gkb</code> should be used to avoid singularity problem.
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Gustafson E.E., Kessel W.C., 1978. Fuzzy clustering with a fuzzy covariance matrix. Proceedings of the IEEE Conference on Decision and Control, pp. 761-766.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+FKM.gk">FKM.gk</a></code>, <code><a href="#topic+FKM.gkb">FKM.gkb</a></code>, <code><a href="#topic+plot.fclust">plot.fclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(synt.data2)
plot(synt.data2)

## Gustafson and Kessel-like fuzzy k-means
syntFKM.gk=FKM.gk(synt.data2, k = 3, RS = 1, seed = 123)
## Gustafson, Kessel and Babuska-like fuzzy k-means
syntFKM.gkb=FKM.gkb(synt.data2, k = 3, RS = 1, seed = 123)

</code></pre>

<hr>
<h2 id='unemployment'>Unemployment data</h2><span id='topic+unemployment'></span>

<h3>Description</h3>

<p>Unemployment data about some European countries in 2011.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(unemployment)</code></pre>


<h3>Format</h3>

<p>A data.frame with 32 rows and 3 columns.
</p>


<h3>Details</h3>

<p>The source is  Eurostat news-release 104/2012 - 4 July 2012.
The 32 observations are European countries: BELGIUM, BULGARIA, CZECHREPUBLIC, DENMARK, GERMANY, ESTONIA, IRELAND, GREECE, SPAIN, FRANCE, ITALY, CYPRUS, LATVIA, LITHUANIA, LUXEMBOURG, HUNGARY, MALTA, NETHERLANDS, AUSTRIA, POLAND, PORTUGAL, ROMANIA, SLOVENIA, SLOVAKIA, FINLAND, SWEDEN, UNITEDKINGDOM, ICELAND, NORWAY, SWITZERLAND, CROATIA, TURKEY.
The 3 variables are: the total unemployment rate, defined as the percentage of unemployed persons aged 15-74 in the economically active population (Variable 1); the youth unemployment rate, defined as the unemployment rate for young people aged between 15 and 24 (Variable 2); the long-term unemployment share, defined as the Percentage of unemployed persons who have been unemployed for 12 months or more (Variable 3).
Non-spherical clusters seem to be present in the data. The Gustafson and Kessel-like fuzzy k-means should be used for finding them.</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+FKM">FKM</a></code>, <code><a href="#topic+FKM.gk">FKM.gk</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## unemployment data
data(unemployment)
## fuzzy k-means (only spherical clusters)
unempFKM=FKM(unemployment,k=3)
## Gustafson and Kessel-like fuzzy k-means (non-spherical clusters)
unempFKM.gk=FKM.gk(unemployment,k=3,RS=10)</code></pre>

<hr>
<h2 id='VAT'>Visual Assessment of (Cluster) Tendency</h2><span id='topic+VAT'></span>

<h3>Description</h3>

<p>Digital intensity image to inspect the number of clusters</p>


<h3>Usage</h3>

<pre><code class='language-R'> VAT (Xca)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VAT_+3A_xca">Xca</code></td>
<td>
<p>Matrix or data.frame (usually data to be used in the clustering algorithm)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each cell refers to a dissimilarity between a pair of objects. Small dissimilarities are represented by dark shades and large dissimilarities are represented by light shades. In the plot the dissimilarities are reorganized in such a way that, roughly speaking, (darkly shaded) diagonal blocks correspond to clusters in the data. Therefore, <em>k</em> dark blocks along its main diagonal suggest that the data contain <em>k</em> (as yet unfound) clusters and the size of each block represents the approximate size of the cluster.
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Bezdek J.C., Hathaway, R.J., 2002. VAT: a tool for visual assessment of (cluster) tendency. Proceedings of the IEEE International Joint Conference on Neural Networks, , pp. 2225?2230.
<br /> Hathaway R.J., Bezdek J.C., 2003. Visual cluster validity for prototype generator clustering models. Pattern Recognition Letters, 24, 1563?1569.
<br /> Huband J.M., Bezdek J.C., 2008. VCV2 ? Visual Cluster Validity. In Zurada J.M., Yen G.G., Wang J. (Eds.): Lecture Notes in Computer Science, 5050, pp. 293?308. Springer-Verlag, Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+VIFCR">VIFCR</a></code>, <code><a href="#topic+VCV">VCV</a></code>, <code><a href="#topic+VCV2">VCV2</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## data standardization (after removing the column Serving Size)
Mc=scale(Mc[,1:(ncol(Mc)-1)],center=TRUE,scale=TRUE)[,]
## plot of VAT
VAT(Mc)
</code></pre>

<hr>
<h2 id='VCV'>Visual Cluster Validity</h2><span id='topic+VCV'></span>

<h3>Description</h3>

<p>Digital intensity image generated using the prototype matrix (and the membership degree matrix) to do cluster validation. The function also plots the VAT image.</p>


<h3>Usage</h3>

<pre><code class='language-R'> VCV (Xca, U, H, which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCV_+3A_xca">Xca</code></td>
<td>
<p>Matrix or data.frame (usually data used in the clustering algorithm)</p>
</td></tr>
<tr><td><code id="VCV_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code id="VCV_+3A_h">H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code id="VCV_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a subset of the numbers <code>1:2</code> (default: <code>1:2</code>)</p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>Plot 1 (<code>which=1</code>): VAT. Each cell refers to a dissimilarity between a pair of objects. Small dissimilarities are represented by dark shades and large dissimilarities are represented by light shades. In the plot the dissimilarities are reorganized in such a way that, roughly speaking, (darkly shaded) diagonal blocks correspond to clusters in the data. Therefore, <em>k</em> dark blocks along its main diagonal suggest that the data contain <em>k</em> (as yet unfound) clusters and the size of each block represents the approximate size of the cluster.
<br /> Plot 2 (<code>which=2</code>): VCV. Each cell refers to a dissimilarity between a pair of objects computed with respect to the cluster prototypes. Small dissimilarities are represented by dark shades and large dissimilarities are represented by light shades. In the plot the dissimilarities are organized by reordering the clusters (the original first cluster is the first reordered cluster and the remaining clusters are reordered so that (new) cluster <em>c</em>+1 is the nearest of the remaining clusters to (newly indexed) cluster <em>c</em>) and the objects (in accordance with decreasing membership degrees). If <em>k</em> dark blocks along its main diagonal are visible, then a <em>k</em>-cluster structure is revealed. Note that the actual number of clusters can be revealed even when a larger number of clusters is used. This suggests that the correct value of <em>k</em> can sometimes be found by running the algorithm with a large value of <em>k</em>, and then ascertaining its correct value from the visual evidence in the VCV image.
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Bezdek J.C., Hathaway, R.J., 2002. VAT: a tool for visual assessment of (cluster) tendency. Proceedings of the IEEE International Joint Conference on Neural Networks, , pp. 2225?2230.
<br /> Hathaway R.J., Bezdek J.C., 2003. Visual cluster validity for prototype generator clustering models. Pattern Recognition Letters, 24, 1563?1569.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+VIFCR">VIFCR</a></code>, <code><a href="#topic+VAT">VAT</a></code>, <code><a href="#topic+VCV2">VCV2</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## plots of VAT and VCV
VCV(clust$Xca,clust$U,clust$H)
## plot of VCV
VCV(clust$Xca,clust$U,clust$H, 2)
</code></pre>

<hr>
<h2 id='VCV2'>(New) Visual Cluster Validity</h2><span id='topic+VCV2'></span>

<h3>Description</h3>

<p>Digital intensity image generated using the membership degree matrix to do cluster validation. The function also plots the VAT image.</p>


<h3>Usage</h3>

<pre><code class='language-R'> VCV2 (Xca, U, which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VCV2_+3A_xca">Xca</code></td>
<td>
<p>Matrix or data.frame (usually data used in the clustering algorithm)</p>
</td></tr>
<tr><td><code id="VCV2_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code id="VCV2_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a subset of the numbers <code>1:2</code> (default: <code>1:2</code>)</p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>Plot 1 (<code>which=1</code>): VAT. Each cell refers to a dissimilarity between a pair of objects. Small dissimilarities are represented by dark shades and large dissimilarities are represented by light shades. In the plot the dissimilarities are reorganized in such a way that, roughly speaking, (darkly shaded) diagonal blocks correspond to clusters in the data. Therefore, <em>k</em> dark blocks along its main diagonal suggest that the data contain <em>k</em> (as yet unfound) clusters and the size of each block represents the approximate size of the cluster.
<br /> Plot 2 (<code>which=2</code>): VCV2. Each cell refers to a dissimilarity between a pair of objects computed with respect to the cluster membership degrees. Small dissimilarities are represented by dark shades and large dissimilarities are represented by light shades. In the plot the dissimilarities are reorganized by using the VAT reordering. If <em>k</em> dark blocks along its main diagonal are visible, then a <em>k</em>-cluster structure is revealed. Note that the actual number of clusters can be revealed even when a larger number of clusters is used. This suggests that the correct value of <em>k</em> can sometimes be found by running the algorithm with a large value of <em>k</em>, and then ascertaining its correct value from the visual evidence in the VCV2 image.
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Bezdek J.C., Hathaway, R.J., 2002. VAT: a tool for visual assessment of (cluster) tendency. Proceedings of the IEEE International Joint Conference on Neural Networks, , pp. 2225?2230.
<br /> Huband J.M., Bezdek J.C., 2008. VCV2 ? Visual Cluster Validity. In Zurada J.M., Yen G.G., Wang J. (Eds.): Lecture Notes in Computer Science, 5050, pp. 293?308. Springer-Verlag, Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+VIFCR">VIFCR</a></code>, <code><a href="#topic+VAT">VAT</a></code>, <code><a href="#topic+VCV">VCV</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## plots of VAT and VCV2
VCV2(clust$Xca,clust$U)
## plot of VCV2
VCV2(clust$Xca,clust$U, 2)
</code></pre>

<hr>
<h2 id='VIFCR'>Visual inspection of fuzzy clustering results</h2><span id='topic+VIFCR'></span>

<h3>Description</h3>

<p>Plots for validation of fuzzy clustering results. Three plots (selected by <code>which</code>) are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> VIFCR (fclust.obj, which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VIFCR_+3A_fclust.obj">fclust.obj</code></td>
<td>
<p>Object of class <code>fclust</code></p>
</td></tr>
<tr><td><code id="VIFCR_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a subset of the numbers <code>1:3</code> (default: <code>1:3</code>)</p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>Plot 1 (<code>which=1</code>). Histogram of the membership degrees setting <code>breaks=seq(from=0,to=1,by=0.1)</code>. The frequencies are scaled so that the heights of the first and the latter rectangles are the same in the ideal case of crisp (non-fuzzy) memberships. The fuzzy clustering solution should be such that the heights of the first and the latter rectangles are high and those of the rectangles in the middle are low. High heights of rectangles in the middle denote the presence of ambiguous membership degrees. This is an indicator for a non-optimal clustering result.
<br /> Plot 2 (<code>which=2</code>). Scatter plot of the objects at the co-ordinates (u1,u2). For each object, u1 and u2 denote, respectively, the highest and the second highest membership degrees. All points lie within the triangle with vertices (0,0), (0.5,0.5) and (1,0). In the ideal case of (almost) crisp membership degrees all points are near the vertex (1,0). Points near the vertex (0.5,0.5) highlight ambiguous objects shared by two clusters. Points near the vertex (0,0) are usually outliers characterized by low membership degrees to all clusters (provided that the noise approach is considered).
<br /> Plot 3 (<code>which=3</code>). For each cluster, scatter plot of the of the objects at the co-ordinates (dc,uc). For each object, dc is the squared Euclidean distance between the object and the cluster prototype and uc is the membership degree of the object to the cluster. The ideal case is such that points are in the upper left area or in the lower right area. In fact, this highlights high membership degrees for small distances and low membership degrees for large distances.
</p>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Klawonn F., Chekhtman V., Janz E., 2003. Visual inspection of fuzzy clustering results. In Benitez J.M., Cordon O., Hoffmann, F., Roy R. (Eds.):  Advances in Soft Computing - Engineering Design and Manufacturing, pp. 65-76. Springer, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fclust">plot.fclust</a></code>, <code><a href="#topic+VAT">VAT</a></code>, <code><a href="#topic+VCV">VCV</a></code>, <code><a href="#topic+VCV2">VCV2</a></code>, <code><a href="#topic+unemployment">unemployment</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## unemployment data
data(unemployment)
## fuzzy k-means
unempFKM=FKM(unemployment,k=3,stand=1)
## all plots
VIFCR(unempFKM)
## plots 1 and 3
VIFCR(unempFKM,c(1,3))
</code></pre>

<hr>
<h2 id='XB'>Xie and Beni index</h2><span id='topic+XB'></span>

<h3>Description</h3>

<p>Produces the Xie and Beni index. The optimal number of clusters <em>k</em> is  is such that the index takes the minimum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> XB (Xca, U, H, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="XB_+3A_xca">Xca</code></td>
<td>
<p>Matrix or data.frame</p>
</td></tr>
<tr><td><code id="XB_+3A_u">U</code></td>
<td>
<p>Membership degree matrix</p>
</td></tr>
<tr><td><code id="XB_+3A_h">H</code></td>
<td>
<p>Prototype matrix</p>
</td></tr>
<tr><td><code id="XB_+3A_m">m</code></td>
<td>
<p>Parameter of fuzziness (default: 2)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Xca</code> should contain the same dataset used in the clustering algorithm, i.e., if the clustering algorithm is run using standardized data, then <code>XB</code> should be computed using the same standardized data.
<br /> <code>m</code> should be the same parameter of fuzziness used in the clustering algorithm.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>xb</code></td>
<td>
<p>Value of the Xie and Beni index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paolo Giordani, Maria Brigida Ferraro, Alessio Serafini</p>


<h3>References</h3>

<p>Xie X.L., Beni G. (1991). A validity measure for fuzzy clustering, IEEE Transactions on Pattern Analysis and Machine Intelligence, 13, 841-847.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PC">PC</a></code>, <code><a href="#topic+PE">PE</a></code>, <code><a href="#topic+MPC">MPC</a></code>, <code><a href="#topic+SIL">SIL</a></code>, <code><a href="#topic+SIL.F">SIL.F</a></code>, <code><a href="#topic+Fclust">Fclust</a></code>, <code><a href="#topic+Mc">Mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## McDonald's data
data(Mc)
names(Mc)
## data normalization by dividing the nutrition facts by the Serving Size (column 1)
for (j in 2:(ncol(Mc)-1))
Mc[,j]=Mc[,j]/Mc[,1]
## removing the column Serving Size
Mc=Mc[,-1]
## fuzzy k-means
## (excluded the factor column Type (last column))
clust=FKM(Mc[,1:(ncol(Mc)-1)],k=6,m=1.5,stand=1)
## Xie and Beni index
xb=XB(clust$Xca,clust$U,clust$H,clust$m)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
