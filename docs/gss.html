<!DOCTYPE html><html><head><title>Help for package gss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aids'><p>AIDS Incubation</p></a></li>
<li><a href='#bacteriuria'><p>Treatment of Bacteriuria</p></a></li>
<li><a href='#buffalo'><p>Buffalo Annual Snowfall</p></a></li>
<li><a href='#cdsscden'><p>Evaluating Conditional PDF, CDF, and Quantiles of Smoothing</p>
Spline Conditional Density Estimates</a></li>
<li><a href='#cdsscopu'><p>Evaluating 1-D Conditional PDF, CDF, and Quantiles of Copula</p>
Density Estimates</a></li>
<li><a href='#cdssden'><p>Evaluating Conditional PDF, CDF, and Quantiles of Smoothing</p>
Spline Density Estimates</a></li>
<li><a href='#clim'><p>Average Temperatures During December 1980 Through February 1981</p></a></li>
<li><a href='#ColoCan'><p>Colorectal Cancer Mortality Rate in Indiana Counties</p></a></li>
<li><a href='#DiaRet'><p>Diabetic Retinopathy</p></a></li>
<li><a href='#drkpk'><p>Numerical Engine for ssden, sshzd, and sshzd1</p></a></li>
<li><a href='#dsscden'><p>Evaluating PDF, CDF, and Quantiles of Smoothing Spline</p>
Conditional Density Estimates</a></li>
<li><a href='#dsscopu'><p>Evaluating Copula Density Estimates</p></a></li>
<li><a href='#dssden'><p>Evaluating PDF, CDF, and Quantiles of Smoothing Spline Density Estimates</p></a></li>
<li><a href='#esc'><p>Embryonic Stem Cell from Mouse</p></a></li>
<li><a href='#eyetrack'><p>Eyesight Fixation in Eyetracking Experiments</p></a></li>
<li><a href='#family'><p>Utility Functions for Error Families</p></a></li>
<li><a href='#fitted.ssanova'><p>Fitted Values and Residuals from Smoothing Spline ANOVA Fits</p></a></li>
<li><a href='#gastric'><p>Gastric Cancer Data</p></a></li>
<li><a href='#gauss.quad'><p>Generating Gauss-Legendre Quadrature</p></a></li>
<li><a href='#gssanova'><p>Fitting Smoothing Spline ANOVA Models with Non-Gaussian Responses</p></a></li>
<li><a href='#gssanova0'><p>Fitting Smoothing Spline ANOVA Models with Non-Gaussian Responses</p></a></li>
<li><a href='#hzdrate.sshzd'><p>Evaluating Smoothing Spline Hazard Estimates</p></a></li>
<li><a href='#hzdrate.sshzd2d'><p>Evaluating 2-D Smoothing Spline Hazard Estimates</p></a></li>
<li><a href='#LakeAcidity'><p>Water Acidity in Lakes</p></a></li>
<li><a href='#mkcov'>
<p>Generating Covariance for Correlated Data</p></a></li>
<li><a href='#mkfun.poly'>
<p>Crafting Building Blocks for Polynomial Splines</p></a></li>
<li><a href='#mkfun.tp'>
<p>Crafting Building Blocks for Thin-Plate and Spherical Splines</p></a></li>
<li><a href='#mkint'>
<p>Generating Integrals of Basis Terms</p></a></li>
<li><a href='#mkran'>
<p>Generating Random Effects in Mixed-Effect Models</p></a></li>
<li><a href='#mkrk.nominal'>
<p>Crafting Building Blocks for Discrete Splines</p></a></li>
<li><a href='#mkterm'>
<p>Assembling Model Terms for Smoothing Spline ANOVA Models</p></a></li>
<li><a href='#mkterm.copu'>
<p>Assembling Model Terms for Copula Density Estimation</p></a></li>
<li><a href='#nlm0'><p>Minimizing Univariate Functions on Finite Intervals</p></a></li>
<li><a href='#NO2'><p>Air Pollution and Road Traffic</p></a></li>
<li><a href='#nox'><p>NOx in Engine Exhaust</p></a></li>
<li><a href='#ozone'><p>Ozone Concentration in Los Angeles Basin</p></a></li>
<li><a href='#penny'><p>Thickness of US Lincoln Pennies</p></a></li>
<li><a href='#predict.ssanova'><p>Predicting from Smoothing Spline ANOVA Fits</p></a></li>
<li><a href='#predict.sscox'><p>Evaluating Smoothing Spline ANOVA Estimate of Relative Risk</p></a></li>
<li><a href='#predict.ssllrm'><p>Evaluating Log-Linear Regression Model Fits</p></a></li>
<li><a href='#predict9.gssanova'><p>Predicting from Smoothing Spline ANOVA Fits with Non-Gaussian Responses</p></a></li>
<li><a href='#print'><p>Print Functions for Smoothing Spline ANOVA Models</p></a></li>
<li><a href='#project'><p>Projecting Smoothing Spline ANOVA Fits for Model Diagnostics</p></a></li>
<li><a href='#rkpk'><p>Numerical Engine for ssanova and gssanova</p></a></li>
<li><a href='#rkpk0'><p>Interface to RKPACK</p></a></li>
<li><a href='#Sachs'><p>Protein Expression in Human Immune System Cells</p></a></li>
<li><a href='#smolyak'><p>Generating Smolyak Cubature</p></a></li>
<li><a href='#ssanova'><p>Fitting Smoothing Spline ANOVA Models</p></a></li>
<li><a href='#ssanova0'><p>Fitting Smoothing Spline ANOVA Models</p></a></li>
<li><a href='#ssanova9'><p>Fitting Smoothing Spline ANOVA Models with Correlated Data</p></a></li>
<li><a href='#sscden'><p>Estimating Conditional Probability Density Using Smoothing</p>
Splines</a></li>
<li><a href='#sscomp'><p>Composition Estimation</p></a></li>
<li><a href='#sscopu'><p>Estimating Copula Density Using Smoothing Splines</p></a></li>
<li><a href='#sscox'><p>Estimating Relative Risk Using Smoothing Splines</p></a></li>
<li><a href='#ssden'><p>Estimating Probability Density Using Smoothing Splines</p></a></li>
<li><a href='#sshzd'><p>Estimating Hazard Function Using Smoothing Splines</p></a></li>
<li><a href='#sshzd2d'><p>Estimating 2-D Hazard Function Using Smoothing Splines</p></a></li>
<li><a href='#ssllrm'><p>Fitting Smoothing Spline Log-Linear Regression Models</p></a></li>
<li><a href='#stan'><p>Stanford Heart Transplant Data</p></a></li>
<li><a href='#summary.gssanova'><p>Assessing Smoothing Spline ANOVA Fits with Non-Gaussian Responses</p></a></li>
<li><a href='#summary.gssanova0'><p>Assessing Smoothing Spline ANOVA Fits with Non-Gaussian Responses</p></a></li>
<li><a href='#summary.ssanova'><p>Assessing Smoothing Spline ANOVA Fits</p></a></li>
<li><a href='#summary.sscopu'><p>Calculating Kendall's Tau and Spearman's Rho for 2-D Copula</p>
Density Estimates</a></li>
<li><a href='#wesdr'><p>Progression of Diabetic Retinopathy</p></a></li>
<li><a href='#wesdr1'><p>Stages of Diabetic Retinopathy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.2-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-15</td>
</tr>
<tr>
<td>Title:</td>
<td>General Smoothing Splines</td>
</tr>
<tr>
<td>Author:</td>
<td>Chong Gu &lt;chong@purdue.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chong Gu &lt;chong@purdue.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive package for structural multivariate
        function estimation using smoothing splines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-16 00:49:46 UTC; chong</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-16 04:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aids'>AIDS Incubation</h2><span id='topic+aids'></span>

<h3>Description</h3>

<p>A data set collected by Centers for Disease Control and Prevention
concerning AIDS patients who were infected with the HIV virus
through blood transfusion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aids)</code></pre>


<h3>Format</h3>

<p>A data frame containing 295 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>incu</code> </td><td style="text-align: left;"> Time from HIV infection to AIDS diagnosis.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>infe</code> </td><td style="text-align: left;"> Time from HIV infection to end of data
	collection (July 1986).</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>age</code> </td><td style="text-align: left;"> Age at time of blood transfusion.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Wang, M.-C. (1989), A semiparametric model for randomly truncated
data.  <em>Journal of the American Statistical Association</em>,
<b>84</b>, 742&ndash;748. 
</p>

<hr>
<h2 id='bacteriuria'>Treatment of Bacteriuria</h2><span id='topic+bacteriuria'></span>

<h3>Description</h3>

<p>Bacteriuria patients were randomly assigned to two treatment
groups.  Weekly binary indicator of bacteriuria was recorded for
every patient over 4 to 16 weeks.  A total of 72 patients were
represented in the data, with 36 each in the two treatment groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bacteriuria)</code></pre>


<h3>Format</h3>

<p>A data frame containing 820 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>id</code> </td><td style="text-align: left;"> Identification of patients, a factor.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>trt</code> </td><td style="text-align: left;"> Treatments 1 or 2, a factor.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>time</code> </td><td style="text-align: left;"> Weeks after randomization.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>infect</code> </td><td style="text-align: left;"> Binary indicator of bacteriuria (bacteria in
	urine).
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Joe, H. (1997), <em>Multivariate Models and Dependence Concepts</em>.
London: Chapman and Hall.
</p>


<h3>References</h3>

<p>Gu, C. and Ma, P. (2005), Generalized nonparametric mixed-effect
models: computation and smoothing parameter selection.
<em>Journal of Computational and Graphical Statistics</em>, <b>14</b>,
485&ndash;504.
</p>

<hr>
<h2 id='buffalo'>Buffalo Annual Snowfall</h2><span id='topic+buffalo'></span>

<h3>Description</h3>

<p>Annual snowfall accumulations in Buffalo, NY from 1910 to 1973.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(buffalo)</code></pre>


<h3>Format</h3>

<p>A vector of 63 numerical values.
</p>


<h3>Source</h3>

<p>Scott, D. W. (1985), Average shifted histograms: Effective
nonparametric density estimators in several dimensions.  <em>The
Annals of Statistics</em>, <b>13</b>, 1024&ndash;1040.
</p>

<hr>
<h2 id='cdsscden'>Evaluating Conditional PDF, CDF, and Quantiles of Smoothing
Spline Conditional Density Estimates</h2><span id='topic+cdsscden'></span><span id='topic+cpsscden'></span><span id='topic+cqsscden'></span>

<h3>Description</h3>

<p>Evaluate conditional pdf, cdf, and quantiles of f(y1|x,y2) for
smoothing spline conditional density estimates f(y|x).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdsscden(object, y, x, cond, int=NULL)
cpsscden(object, q, x, cond)
cqsscden(object, p, x, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdsscden_+3A_object">object</code></td>
<td>
<p>Object of class <code>"sscden"</code> or <code>"sscden1"</code>.</p>
</td></tr>
<tr><td><code id="cdsscden_+3A_x">x</code></td>
<td>
<p>Data frame of x values on which conditional density
f(y1|x,y2) is to be evaluated.</p>
</td></tr>
<tr><td><code id="cdsscden_+3A_y">y</code></td>
<td>
<p>Data frame or vector of y1 points on which conditional
density f(y1|x,y2) is to be evaluated.</p>
</td></tr>
<tr><td><code id="cdsscden_+3A_cond">cond</code></td>
<td>
<p>One row data frame of conditioning variables y2.</p>
</td></tr>
<tr><td><code id="cdsscden_+3A_q">q</code></td>
<td>
<p>Vector of points on which cdf is to be evaluated.</p>
</td></tr>
<tr><td><code id="cdsscden_+3A_p">p</code></td>
<td>
<p>Vector of probabilities for which quantiles are to be
calculated.</p>
</td></tr>
<tr><td><code id="cdsscden_+3A_int">int</code></td>
<td>
<p>Vector of normalizing constants.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>x</code> and <code>y</code> are of the same form as the
argument <code>newdata</code> in <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, but <code>y</code> in
<code>cdsscden</code> can take a vector for 1-D y1.
</p>
<p><code>cpsscden</code> and <code>cqsscden</code> naturally only work for 1-D y1.
</p>


<h3>Value</h3>

<p><code>cdsscden</code> returns a list object with the following
elements.
</p>
<table>
<tr><td><code>pdf</code></td>
<td>
<p>Matrix or vector of conditional pdf f(y1|x,y2), with each
column corresponding to a distinct x value.</p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>Vector of normalizing constants.</p>
</td></tr>
</table>
<p><code>cpsscden</code> and <code>cqsscden</code> return a matrix or vector of
conditional cdf or quantiles of f(y1|x,y2).
</p>


<h3>Note</h3>

<p>If variables other than factors or numerical vectors are involved in
<code>y1</code>, the normalizing constants can not be computed.
</p>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+sscden">sscden</a></code> and <code><a href="#topic+dsscden">dsscden</a></code>.
</p>

<hr>
<h2 id='cdsscopu'>Evaluating 1-D Conditional PDF, CDF, and Quantiles of Copula
Density Estimates</h2><span id='topic+cdsscopu'></span><span id='topic+cpsscopu'></span><span id='topic+cqsscopu'></span>

<h3>Description</h3>

<p>Evaluate conditional pdf, cdf, and quantiles of copula density
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdsscopu(object, x, cond, pos=1, int=NULL)
cpsscopu(object, q, cond, pos=1)
cqsscopu(object, p, cond, pos=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdsscopu_+3A_object">object</code></td>
<td>
<p>Object of class <code>"sscopu"</code>.</p>
</td></tr>
<tr><td><code id="cdsscopu_+3A_x">x</code></td>
<td>
<p>Vector of points on which conditional pdf is to be
evaluated.</p>
</td></tr>
<tr><td><code id="cdsscopu_+3A_cond">cond</code></td>
<td>
<p>Value of conditioning variables.</p>
</td></tr>
<tr><td><code id="cdsscopu_+3A_pos">pos</code></td>
<td>
<p>Position of variable of interest.</p>
</td></tr>
<tr><td><code id="cdsscopu_+3A_int">int</code></td>
<td>
<p>Normalizing constant.</p>
</td></tr>
<tr><td><code id="cdsscopu_+3A_q">q</code></td>
<td>
<p>Vector of points on which conditional cdf is to be
evaluated.</p>
</td></tr>
<tr><td><code id="cdsscopu_+3A_p">p</code></td>
<td>
<p>Vector of probabilities for which conditional quantiles are
to be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of conditional pdf, cdf, or quantiles.
</p>


<h3>See Also</h3>

<p>Fitting functions <code><a href="#topic+sscopu">sscopu</a></code> and <code><a href="#topic+sscopu2">sscopu2</a></code>,
and <code><a href="#topic+dsscopu">dsscopu</a></code>.
</p>

<hr>
<h2 id='cdssden'>Evaluating Conditional PDF, CDF, and Quantiles of Smoothing
Spline Density Estimates</h2><span id='topic+cdssden'></span><span id='topic+cpssden'></span><span id='topic+cqssden'></span>

<h3>Description</h3>

<p>Evaluate conditional pdf, cdf, and quantiles for smoothing spline
density estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdssden(object, x, cond, int=NULL)
cpssden(object, q, cond)
cqssden(object, p, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdssden_+3A_object">object</code></td>
<td>
<p>Object of class <code>"ssden"</code>.</p>
</td></tr>
<tr><td><code id="cdssden_+3A_x">x</code></td>
<td>
<p>Data frame or vector of points on which conditional density
is to be evaluated.</p>
</td></tr>
<tr><td><code id="cdssden_+3A_cond">cond</code></td>
<td>
<p>One row data frame of conditioning variables.</p>
</td></tr>
<tr><td><code id="cdssden_+3A_int">int</code></td>
<td>
<p>Normalizing constant.</p>
</td></tr>
<tr><td><code id="cdssden_+3A_q">q</code></td>
<td>
<p>Vector of points on which conditional cdf is to be
evaluated.</p>
</td></tr>
<tr><td><code id="cdssden_+3A_p">p</code></td>
<td>
<p>Vector of probabilities for which conditional quantiles are
to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> in <code>cdssden</code> is of the same form as the
argument <code>newdata</code> in <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, but can take a
vector for 1-D conditional densities.
</p>
<p><code>cpssden</code> and <code>cqssden</code> naturally only work for 1-D
conditional densities of a numerical variable.
</p>


<h3>Value</h3>

<p><code>cdssden</code> returns a list object with the following elements.
</p>
<table>
<tr><td><code>pdf</code></td>
<td>
<p>Vector of conditional pdf.</p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>Normalizing constant.</p>
</td></tr>
</table>
<p><code>cpssden</code> and <code>cqssden</code> return a vector of conditional cdf
or quantiles.
</p>


<h3>Note</h3>

<p>If variables other than factors or numerical vectors are involved in
<code>x</code>, the normalizing constant can not be computed.
</p>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+ssden">ssden</a></code> and <code><a href="#topic+dssden">dssden</a></code>.
</p>

<hr>
<h2 id='clim'>Average Temperatures During December 1980 Through February 1981</h2><span id='topic+clim'></span>

<h3>Description</h3>

<p>Average temperatures at 690 weather stations during December 1980
through February 1981.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(clim)</code></pre>


<h3>Format</h3>

<p>A data frame containing 690 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>temp</code> </td><td style="text-align: left;"> Average temperature, in Celsius.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>geog</code> </td><td style="text-align: left;"> Geographic location (latitude,longitude), in
	degrees, as a matrix.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>This is reformulated from the data frame <code>climate</code> in the R
package <code>assist</code> by Yuedong Wang and Chunlei Ke.
</p>

<hr>
<h2 id='ColoCan'>Colorectal Cancer Mortality Rate in Indiana Counties</h2><span id='topic+ColoCan'></span>

<h3>Description</h3>

<p>County-wise death counts of colorectal cancer patients in Indiana
during years 2000 through 2004.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ColoCan)</code></pre>


<h3>Format</h3>

<p>A data frame containing 184 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>event</code> </td><td style="text-align: left;"> Death counts.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>pop</code> </td><td style="text-align: left;"> Population from Census 2000.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>sex</code> </td><td style="text-align: left;"> Gender of population.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>wrt</code> </td><td style="text-align: left;"> Proportion of Whites.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>brt</code> </td><td style="text-align: left;"> Proportion of Blacks.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ort</code> </td><td style="text-align: left;"> Proportion of other minorities.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>lat</code> </td><td style="text-align: left;"> Latitude.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>lon</code> </td><td style="text-align: left;"> Longitude.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>geog</code> </td><td style="text-align: left;"> Geographic location, derived from <code>lat</code>
	and <code>lon</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>scrn</code> </td><td style="text-align: left;"> Colorectal cancer screening rate.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>name</code> </td><td style="text-align: left;"> County name.
    </td>
</tr>

</table>



<h3>Details</h3>

<p><code>geog</code> was generated from <code>lat</code> and <code>lon</code> using the
code given in the example section.
</p>


<h3>Source</h3>

<p>Dr. Tonglin Zhang.
</p>


<h3>References</h3>

<p>Zhang, T. and Lin, G. (2009), Cluster detection based on spatial
associations and iterated residuals in generalized linear mixed
models.  <em>Biometrics</em>, <b>65</b>, 353&ndash;360.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Converting latitude and longitude to x-y coordinates
## The 49th county is Marion, where Indianapolis is located.
## Not run: ltln2xy &lt;- function(latlon,latlon0) {
  lat &lt;- latlon[,1]*pi/180; lon &lt;- latlon[,2]*pi/180
  lt0 &lt;- latlon0[1]*pi/180; ln0 &lt;- latlon0[2]*pi/180
  x &lt;- cos(lt0)*sin(lon-ln0); y &lt;- sin(lat-lt0)
  cbind(x,y)
}
data(ColoCan)
latlon &lt;- as.matrix(ColoCan[,c("lat","lon")])
ltln2xy(latlon,latlon[49,])
## Clean up
rm(ltln2xy,ColoCan,latlon)
## End(Not run)
</code></pre>

<hr>
<h2 id='DiaRet'>Diabetic Retinopathy</h2><span id='topic+DiaRet'></span>

<h3>Description</h3>

<p>Time to blindness of 197 diabetic retinopathy patients who received
a laser treatment in one eye.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DiaRet)</code></pre>


<h3>Format</h3>

<p>A data frame containing 197 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
        <code>id</code> </td><td style="text-align: left;"> Patient ID.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>time1</code> </td><td style="text-align: left;"> Follow-up time of left eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>time2</code> </td><td style="text-align: left;"> Follow-up time of right eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>status1</code> </td><td style="text-align: left;"> Censoring indicator of left eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>status2</code> </td><td style="text-align: left;"> Censoring indicator of right eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>trt1</code> </td><td style="text-align: left;"> Treatment indicator of left eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>trt2</code> </td><td style="text-align: left;"> Treatment indicator of right eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>type</code> </td><td style="text-align: left;"> Type of diabetes.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>age</code> </td><td style="text-align: left;"> Age of patient at diagnosis.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>time.t</code> </td><td style="text-align: left;"> Follow-up time of treated eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>time.u</code> </td><td style="text-align: left;"> Follow-up time of untreated eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>status.t</code> </td><td style="text-align: left;"> Censoring indicator of treated eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>status.u</code> </td><td style="text-align: left;"> Censoring indicator of untreated eye.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>This is reformatted from the data frame <code>diabetes</code> in the R
package <code>timereg</code> by Thomas H. Scheike.
</p>


<h3>References</h3>

<p>Huster, W.J., Brookmeyer, R., and Self, S.G. (1989), Modelling
paired survival data with covariates.  <em>Biometrics</em>, <b>45</b>,
145&ndash;56.
</p>

<hr>
<h2 id='drkpk'>Numerical Engine for ssden, sshzd, and sshzd1</h2><span id='topic+sspdsty'></span><span id='topic+mspdsty'></span><span id='topic+sspdsty1'></span><span id='topic+mspdsty1'></span><span id='topic+mspcdsty'></span><span id='topic+mspcdsty1'></span><span id='topic+msphzd'></span><span id='topic+msphzd1'></span><span id='topic+sspcox'></span><span id='topic+mspcox'></span><span id='topic+mspllrm'></span>

<h3>Description</h3>

<p>Perform numerical calculations for the <code><a href="#topic+ssden">ssden</a></code> and
<code><a href="#topic+sshzd">sshzd</a></code> suites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sspdsty(s, r, q, cnt, qd.s, qd.r, qd.wt, prec, maxiter, alpha, bias)
mspdsty(s, r, id.basis, cnt, qd.s, qd.r, qd.wt, prec, maxiter, alpha,
bias, skip.iter)

sspdsty1(s, r, q, cnt, int, prec, maxiter, alpha)
mspdsty1(s, r, id.basis, cnt, int, prec, maxiter, alpha)

mspcdsty(s, r, id.basis, cnt, qd.s, qd.r, xx.wt, qd.wt, prec, maxiter, alpha, skip.iter)

mspcdsty1(s, r, id.basis, cnt, int.s, int.r, prec, maxiter, alpha, skip.iter)

msphzd(s, r, id.wk, Nobs, cnt, qd.s, qd.r, qd.wt, random, prec, maxiter, alpha, skip.iter)

msphzd1(s, r, id.wk, Nobs, cnt, int.s, int.r, rho, random, prec, maxiter, alpha,
        skip.iter)

sspcox(s, r, q, cnt, qd.s, qd.r, qd.wt, prec, maxiter, alpha, random, bias)
mspcox(s, r, id.basis, cnt, qd.s, qd.r, qd.wt, prec, maxiter, alpha, random, bias,
       skip.iter)

mspllrm(s, r, id.basis, cnt, qd.s, qd.r, xx.wt, qd.wt, random, prec, maxiter, alpha,
        skip.iter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drkpk_+3A_s">s</code></td>
<td>
<p>Unpenalized terms evaluated at data points.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_r">r</code></td>
<td>
<p>Basis of penalized terms evaluated at data points.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_q">q</code></td>
<td>
<p>Penalty matrix.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="drkpk_+3A_id.wk">id.wk</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="drkpk_+3A_nobs">Nobs</code></td>
<td>
<p>Total number of lifetime observations.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_cnt">cnt</code></td>
<td>
<p>Bin-counts for histogram data.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_qd.s">qd.s</code></td>
<td>
<p>Unpenalized terms evaluated at quadrature nodes.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_qd.r">qd.r</code></td>
<td>
<p>Basis of penalized terms evaluated at quadrature nodes.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_qd.wt">qd.wt</code></td>
<td>
<p>Quadrature weights.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_alpha">alpha</code></td>
<td>
<p>Parameter defining cross-validation score for smoothing
parameter selection.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_bias">bias</code></td>
<td>
<p>List of arrays incorporating possible sampling bias.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_int">int</code></td>
<td>
<p>Integrals of basis terms.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_int.s">int.s</code></td>
<td>
<p>Integrals of unpenalized terms.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_int.r">int.r</code></td>
<td>
<p>Integrals of basis of penalized terms.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_rho">rho</code></td>
<td>
<p>rho function value on failure times.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_xx.wt">xx.wt</code></td>
<td>
<p>Weights at unique x.</p>
</td></tr>
<tr><td><code id="drkpk_+3A_random">random</code></td>
<td>
<p>Input for parametric random effects in nonparametric
mixed-effect models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sspdsty</code> is used by <code><a href="#topic+ssden">ssden</a></code> to compute
cross-validated density estimate with a single smoothing
parameter. <code>mspdsty</code> is used by <code><a href="#topic+ssden">ssden</a></code> to compute
cross-validated density estimate with multiple smoothing
parameters.
</p>
<p><code>msphzd</code> is used by <code><a href="#topic+sshzd">sshzd</a></code> to compute
cross-validated hazard estimate with single or multiple smoothing
parameters.
</p>


<h3>References</h3>

<p>Du, P. and Gu, C. (2006), Penalized likelihood hazard estimation:
efficient approximation and Bayesian confidence intervals.
<em>Statistics and Probability Letters</em>, <b>76</b>, 244&ndash;254.
</p>
<p>Du, P. and Gu, C. (2009), Penalized Pseudo-Likelihood Hazard
Estimation: A Fast Alternative to Penalized Likelihood.
<em>Journal of Statistical Planning and Inference</em>, <b>139</b>,
891&ndash;899.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. and Wang, J. (2003), Penalized likelihood density
estimation: Direct cross-validation and scalable approximation.
<em>Statistica Sinica</em>, <b>13</b>, 811&ndash;826.
</p>

<hr>
<h2 id='dsscden'>Evaluating PDF, CDF, and Quantiles of Smoothing Spline
Conditional Density Estimates</h2><span id='topic+dsscden'></span><span id='topic+psscden'></span><span id='topic+qsscden'></span><span id='topic+d.sscden'></span><span id='topic+d.sscden1'></span>

<h3>Description</h3>

<p>Evaluate pdf, cdf, and quantiles for smoothing spline conditional
density estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsscden(object, y, x)
psscden(object, q, x)
qsscden(object, p, x)
d.sscden(object, x, y)
d.sscden1(object, x, y, scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsscden_+3A_object">object</code></td>
<td>
<p>Object of class <code>"sscden"</code> or <code>"sscden1"</code>.</p>
</td></tr>
<tr><td><code id="dsscden_+3A_x">x</code></td>
<td>
<p>Data frame of x values on which conditional density f(y|x)
is to be evaluated.</p>
</td></tr>
<tr><td><code id="dsscden_+3A_y">y</code></td>
<td>
<p>Data frame or vector of points on which conditional density
f(y|x) is to be evaluated.</p>
</td></tr>
<tr><td><code id="dsscden_+3A_q">q</code></td>
<td>
<p>Vector of points on which cdf is to be evaluated.</p>
</td></tr>
<tr><td><code id="dsscden_+3A_p">p</code></td>
<td>
<p>Vector of probabilities for which quantiles are to be
calculated.</p>
</td></tr>
<tr><td><code id="dsscden_+3A_scale">scale</code></td>
<td>
<p>Flag indicating whether to use approximate scaling
without quadrature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>x</code> and <code>y</code> are of the same form as the
argument <code>newdata</code> in <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, but <code>y</code> in
<code>dsscden</code> can take a vector for 1-D responses.
</p>
<p><code>psscden</code> and <code>qsscden</code> naturally only work for 1-D
responses.
</p>


<h3>Value</h3>

<p>A matrix or vector of pdf, cdf, or quantiles of f(y|x), with each
column corresponding to a distinct x value.
</p>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+sscden">sscden</a></code> and <code><a href="#topic+cdsscden">cdsscden</a></code>.
</p>

<hr>
<h2 id='dsscopu'>Evaluating Copula Density Estimates</h2><span id='topic+dsscopu'></span>

<h3>Description</h3>

<p>Evaluate copula density estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsscopu(object, x, copu=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsscopu_+3A_object">object</code></td>
<td>
<p>Object of class <code>"sscopu"</code>.</p>
</td></tr>
<tr><td><code id="dsscopu_+3A_x">x</code></td>
<td>
<p>Vector or matrix of point(s) on which copula density is to
be evaluated.</p>
</td></tr>
<tr><td><code id="dsscopu_+3A_copu">copu</code></td>
<td>
<p>Flag indicating whether to apply copularization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of copula density values.
</p>


<h3>See Also</h3>

<p>Fitting functions <code><a href="#topic+sscopu">sscopu</a></code> and <code><a href="#topic+sscopu2">sscopu2</a></code>.
</p>

<hr>
<h2 id='dssden'>Evaluating PDF, CDF, and Quantiles of Smoothing Spline Density Estimates</h2><span id='topic+dssden'></span><span id='topic+pssden'></span><span id='topic+qssden'></span><span id='topic+d.ssden'></span><span id='topic+d.ssden1'></span>

<h3>Description</h3>

<p>Evaluate pdf, cdf, and quantiles for smoothing spline density
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dssden(object, x)
pssden(object, q)
qssden(object, p)
d.ssden(object, x)
d.ssden1(object, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dssden_+3A_object">object</code></td>
<td>
<p>Object of class <code>"ssden"</code>.</p>
</td></tr>
<tr><td><code id="dssden_+3A_x">x</code></td>
<td>
<p>Data frame or vector of points on which density is to be
evaluated.</p>
</td></tr>
<tr><td><code id="dssden_+3A_q">q</code></td>
<td>
<p>Vector of points on which cdf is to be evaluated.</p>
</td></tr>
<tr><td><code id="dssden_+3A_p">p</code></td>
<td>
<p>Vector of probabilities for which quantiles are to be
calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> in <code>dssden</code> is of the same form as the
argument <code>newdata</code> in <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, but can take a
vector for 1-D densities.
</p>
<p><code>pssden</code> and <code>qssden</code> naturally only work for 1-D
densities.
</p>


<h3>Value</h3>

<p>A vector of pdf, cdf, or quantiles.
</p>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+ssden">ssden</a></code> and <code><a href="#topic+cdssden">cdssden</a></code>.
</p>

<hr>
<h2 id='esc'>Embryonic Stem Cell from Mouse</h2><span id='topic+esc'></span>

<h3>Description</h3>

<p>Data concerning mouse embryonic stem cell gene expression and
transcription factor association strength.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(esc)</code></pre>


<h3>Format</h3>

<p>A data frame containing 1027 genes with the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
        <code>y1</code> </td><td style="text-align: left;"> Gene expression after 4 days.</td>
</tr>
<tr>
 <td style="text-align: left;">
        <code>y2</code> </td><td style="text-align: left;"> Gene expression after 8 days.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>y3</code> </td><td style="text-align: left;"> Gene expression after 14 days.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>klf4</code> </td><td style="text-align: left;"> Score of TFAS with KLF4.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>nanog</code> </td><td style="text-align: left;"> Score of TFAS with NANOG.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>oct4</code> </td><td style="text-align: left;"> Score of TFAS with OCT4.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>sox2</code> </td><td style="text-align: left;"> Score of TFAS with SOX2.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>clusterID</code> </td><td style="text-align: left;"> Cluster identification.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>References</h3>

<p>Cai, J., Xie, D., Fan, Z., Chipperfield, H., Marden, J., Wong,
W. H., and Zhong, S. (2010), Modeling co-expression across species
for complex traits: insights to the difference of human and mouse
embryonic stem cells.  <em>PLoS Computational Biology</em>, <b>6</b>,
e1000707.
</p>
<p>Ouyang, Z., Zhou, Q., and Wong, W. H. (2009), chip-seq of
transcription factors predicts absolute and differential gene
expression in embryonic stem cells.  <em>Proceedings of the
National Academy of Sciences of USA</em>, <b>106</b>, 21521&ndash;21526.
</p>

<hr>
<h2 id='eyetrack'>Eyesight Fixation in Eyetracking Experiments</h2><span id='topic+eyetrack'></span>

<h3>Description</h3>

<p>Eyesight Fixation during some eyetracking experiments in liguistic
studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eyetrack)</code></pre>


<h3>Format</h3>

<p>A data frame containing 13891 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>time</code> </td><td style="text-align: left;"> Time, in ms.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>color</code> </td><td style="text-align: left;"> Binary indicator, 1 if eyesight fixed on target
	or color competitor, a factor.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>object</code> </td><td style="text-align: left;"> Binary indicator, 1 if eyesight fixed on target
	or object competitor, a factor.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>id</code> </td><td style="text-align: left;"> Identification of homogeneous sessions, a factor.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>cnt</code> </td><td style="text-align: left;"> Multiplicity count.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Dr. Anouschka Foltz.
</p>


<h3>References</h3>

<p>Gu, C. and Ma, P. (2011), Nonparametric regression with
cross-classified responses.  Manuscript.
</p>

<hr>
<h2 id='family'>Utility Functions for Error Families</h2><span id='topic+mkdata.binomial'></span><span id='topic+dev.resid.binomial'></span><span id='topic+dev.null.binomial'></span><span id='topic+cv.binomial'></span><span id='topic+y0.binomial'></span><span id='topic+proj0.binomial'></span><span id='topic+kl.binomial'></span><span id='topic+cfit.binomial'></span><span id='topic+mkdata.poisson'></span><span id='topic+dev.resid.poisson'></span><span id='topic+dev.null.poisson'></span><span id='topic+cv.poisson'></span><span id='topic+y0.poisson'></span><span id='topic+proj0.poisson'></span><span id='topic+kl.poisson'></span><span id='topic+cfit.poisson'></span><span id='topic+mkdata.Gamma'></span><span id='topic+dev.resid.Gamma'></span><span id='topic+dev.null.Gamma'></span><span id='topic+cv.Gamma'></span><span id='topic+y0.Gamma'></span><span id='topic+proj0.Gamma'></span><span id='topic+kl.Gamma'></span><span id='topic+cfit.Gamma'></span><span id='topic+mkdata.inverse.gaussian'></span><span id='topic+dev.resid.inverse.gaussian'></span><span id='topic+dev.null.inverse.gaussian'></span><span id='topic+cv.inverse.gaussian'></span><span id='topic+y0.inverse.gaussian'></span><span id='topic+proj0.inverse.gaussian'></span><span id='topic+kl.inverse.gaussian'></span><span id='topic+cfit.inverse.gaussian'></span><span id='topic+mkdata.nbinomial'></span><span id='topic+dev.resid.nbinomial'></span><span id='topic+dev.null.nbinomial'></span><span id='topic+cv.nbinomial'></span><span id='topic+y0.nbinomial'></span><span id='topic+proj0.nbinomial'></span><span id='topic+kl.nbinomial'></span><span id='topic+cfit.nbinomial'></span><span id='topic+mkdata.polr'></span><span id='topic+dev.resid.polr'></span><span id='topic+dev.null.polr'></span><span id='topic+cv.polr'></span><span id='topic+y0.polr'></span><span id='topic+proj0.polr'></span><span id='topic+kl.polr'></span><span id='topic+cfit.polr'></span><span id='topic+mkdata.weibull'></span><span id='topic+dev.resid.weibull'></span><span id='topic+dev.null.weibull'></span><span id='topic+cv.weibull'></span><span id='topic+y0.weibull'></span><span id='topic+proj0.weibull'></span><span id='topic+kl.weibull'></span><span id='topic+cfit.weibull'></span><span id='topic+mkdata.lognorm'></span><span id='topic+dev.resid.lognorm'></span><span id='topic+dev0.resid.lognorm'></span><span id='topic+dev.null.lognorm'></span><span id='topic+cv.lognorm'></span><span id='topic+y0.lognorm'></span><span id='topic+proj0.lognorm'></span><span id='topic+kl.lognorm'></span><span id='topic+cfit.lognorm'></span><span id='topic+mkdata.loglogis'></span><span id='topic+dev.resid.loglogis'></span><span id='topic+dev0.resid.loglogis'></span><span id='topic+dev.null.loglogis'></span><span id='topic+cv.loglogis'></span><span id='topic+y0.loglogis'></span><span id='topic+proj0.loglogis'></span><span id='topic+kl.loglogis'></span><span id='topic+cfit.loglogis'></span>

<h3>Description</h3>

<p>Utility functions for fitting Smoothing Spline ANOVA models with
non-Gaussian responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkdata.binomial(y, eta, wt, offset)
dev.resid.binomial(y, eta, wt)
dev.null.binomial(y, wt, offset)
cv.binomial(y, eta, wt, hat, alpha)
y0.binomial(y, eta0, wt)
proj0.binomial(y0, eta, offset)
kl.binomial(eta0, eta1, wt)
cfit.binomial(y, wt, offset)

mkdata.poisson(y, eta, wt, offset)
dev.resid.poisson(y, eta, wt)
dev.null.poisson(y, wt, offset)
cv.poisson(y, eta, wt, hat, alpha, sr, q)
y0.poisson(eta0)
proj0.poisson(y0, eta, wt, offset)
kl.poisson(eta0, eta1, wt)
cfit.poisson(y, wt, offset)

mkdata.Gamma(y, eta, wt, offset)
dev.resid.Gamma(y, eta, wt)
dev.null.Gamma(y, wt, offset)
cv.Gamma(y, eta, wt, hat, rss, alpha)
y0.Gamma(eta0)
proj0.Gamma(y0, eta, wt, offset)
kl.Gamma(eta0, eta1, wt)
cfit.Gamma(y, wt, offset)

mkdata.inverse.gaussian(y, eta, wt, offset)
dev.resid.inverse.gaussian(y, eta, wt)
dev.null.inverse.gaussian(y, wt, offset)
cv.inverse.gaussian(y, eta, wt, hat, rss, alpha)
y0.inverse.gaussian(eta0)
proj0.inverse.gaussian(y0, eta, wt, offset)
kl.inverse.gaussian(eta0, eta1, wt)
cfit.inverse.gaussian(y, wt, offset)

mkdata.nbinomial(y, eta, wt, offset, nu)
dev.resid.nbinomial(y, eta, wt)
dev.null.nbinomial(y, wt, offset)
cv.nbinomial(y, eta, wt, hat, alpha)
y0.nbinomial(y,eta0,nu)
proj0.nbinomial(y0, eta, wt, offset)
kl.nbinomial(eta0, eta1, wt, nu)
cfit.nbinomial(y, wt, offset, nu)

mkdata.polr(y, eta, wt, offset, nu)
dev.resid.polr(y, eta, wt, nu)
dev.null.polr(y, wt, offset)
cv.polr(y, eta, wt, hat, nu, alpha)
y0.polr(eta0)
proj0.polr(y0, eta, wt, offset, nu)
kl.polr(eta0, eta1, wt)
cfit.polr(y, wt, offset)

mkdata.weibull(y, eta, wt, offset, nu)
dev.resid.weibull(y, eta, wt, nu)
dev.null.weibull(y, wt, offset, nu)
cv.weibull(y, eta, wt, hat, nu, alpha)
y0.weibull(y, eta0, nu)
proj0.weibull(y0, eta, wt, offset, nu)
kl.weibull(eta0, eta1, wt, nu, int)
cfit.weibull(y, wt, offset, nu)

mkdata.lognorm(y, eta, wt, offset, nu)
dev.resid.lognorm(y, eta, wt, nu)
dev0.resid.lognorm(y, eta, wt, nu)
dev.null.lognorm(y, wt, offset, nu)
cv.lognorm(y, eta, wt, hat, nu, alpha)
y0.lognorm(y, eta0, nu)
proj0.lognorm(y0, eta, wt, offset, nu)
kl.lognorm(eta0, eta1, wt, nu, y0)
cfit.lognorm(y, wt, offset, nu)

mkdata.loglogis(y, eta, wt, offset, nu)
dev.resid.loglogis(y, eta, wt, nu)
dev0.resid.loglogis(y, eta, wt, nu)
dev.null.loglogis(y, wt, offset, nu)
cv.loglogis(y, eta, wt, hat, nu, alpha)
y0.loglogis(y, eta0, nu)
proj0.loglogis(y0, eta, wt, offset, nu)
kl.loglogis(eta0, eta1, wt, nu, y0)
cfit.loglogis(y, wt, offset, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family_+3A_y">y</code></td>
<td>
<p>Model response.</p>
</td></tr>
<tr><td><code id="family_+3A_eta">eta</code></td>
<td>
<p>Fitted values on link scale.</p>
</td></tr>
<tr><td><code id="family_+3A_wt">wt</code></td>
<td>
<p>Model weights.</p>
</td></tr>
<tr><td><code id="family_+3A_offset">offset</code></td>
<td>
<p>Model offset.</p>
</td></tr>
<tr><td><code id="family_+3A_nu">nu</code></td>
<td>
<p>Size for nbinomial.  Inverse scale for log life time.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code><a href="#topic+gssanova0">gssanova0</a></code> uses <code>mkdata.x</code>, <code>dev.resid.x</code>,
and <code>dev.null.x</code>.  <code><a href="#topic+gssanova">gssanova</a></code> uses the above plus
<code>dev0.resid.x</code> and <code>cv.x</code>.
</p>
<p><code>y0.x</code>, <code>proj0.x</code>, <code>kl.x</code>, and <code>cfit.x</code> are used
by <code><a href="#topic+project.gssanova">project.gssanova</a></code>.
</p>

<hr>
<h2 id='fitted.ssanova'>Fitted Values and Residuals from Smoothing Spline ANOVA Fits</h2><span id='topic+fitted.ssanova'></span><span id='topic+residuals.ssanova'></span><span id='topic+fitted.gssanova'></span><span id='topic+residuals.gssanova'></span>

<h3>Description</h3>

<p>Methods for extracting fitted values and residuals from smoothing
spline ANOVA fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssanova'
fitted(object, ...)
## S3 method for class 'ssanova'
residuals(object, ...)

## S3 method for class 'gssanova'
fitted(object, ...)
## S3 method for class 'gssanova'
residuals(object, type="working", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.ssanova_+3A_object">object</code></td>
<td>
<p>Object of class <code>"ssanova"</code> or <code>"gssanova"</code>.</p>
</td></tr>
<tr><td><code id="fitted.ssanova_+3A_type">type</code></td>
<td>
<p>Type of residuals desired, with two alternatives
<code>"working"</code> (default) or <code>"deviance"</code>.</p>
</td></tr>
<tr><td><code id="fitted.ssanova_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted values for <code>"gssanova"</code> objects are on the link
scale, so are the <code>"working"</code> residuals.
</p>

<hr>
<h2 id='gastric'>Gastric Cancer Data</h2><span id='topic+gastric'></span>

<h3>Description</h3>

<p>Survival of gastric cancer patients under chemotherapy and
chemotherapy-radiotherapy combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gastric)</code></pre>


<h3>Format</h3>

<p>A data frame containing 90 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>futime</code> </td><td style="text-align: left;"> Follow-up time, in days.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>status</code> </td><td style="text-align: left;"> Censoring status.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>trt</code> </td><td style="text-align: left;"> Factor indicating the treatments: 1 --
	chemothrapy, 2 -- combination.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Moreau, T., O'Quigley, J., and Mesbah, M. (1985), A global
goodness-of-fit statistic for the proportional hazards model.
<em>Applied Statistics</em>, <b>34</b>, 212-218.
</p>

<hr>
<h2 id='gauss.quad'>Generating Gauss-Legendre Quadrature</h2><span id='topic+gauss.quad'></span>

<h3>Description</h3>

<p>Generate Gauss-Legendre quadratures using the FORTRAN routine
<code>gaussq.f</code> found on NETLIB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauss.quad(size, interval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauss.quad_+3A_size">size</code></td>
<td>
<p>Size of quadrature.</p>
</td></tr>
<tr><td><code id="gauss.quad_+3A_interval">interval</code></td>
<td>
<p>Interval to be covered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gauss.quad</code> returns a list object with the following elements.
</p>
<table>
<tr><td><code>pt</code></td>
<td>
<p>Quadrature nodes.</p>
</td></tr>
<tr><td><code>wt</code></td>
<td>
<p>Quadrature weights.</p>
</td></tr>
</table>

<hr>
<h2 id='gssanova'>Fitting Smoothing Spline ANOVA Models with Non-Gaussian Responses</h2><span id='topic+gssanova'></span>

<h3>Description</h3>

<p>Fit smoothing spline ANOVA models in non-Gaussian regression.  The
symbolic model specification via <code>formula</code> follows the same
rules as in <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gssanova(formula, family, type=NULL, data=list(), weights, subset,
         offset, na.action=na.omit, partial=NULL, alpha=NULL, nu=NULL,
         id.basis=NULL, nbasis=NULL, seed=NULL, random=NULL,
         skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gssanova_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_family">family</code></td>
<td>
<p>Description of the error distribution.  Supported
are exponential families <code>"binomial"</code>, <code>"poisson"</code>,
<code>"Gamma"</code>, <code>"inverse.gaussian"</code>, and
<code>"nbinomial"</code>.  Also supported are accelerated life model
families <code>"weibull"</code>, <code>"lognorm"</code>, and
<code>"loglogis"</code>.  Further more, proportional odds logistic
regression <code>"polr"</code> for ordinal response is also
supported.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to be used in the
fitting process.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_offset">offset</code></td>
<td>
<p>Optional offset term with known parameter 1.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_partial">partial</code></td>
<td>
<p>Optional symbolic description of parametric terms in
partial spline models.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter defining cross-validation; larger
values yield smoother fits.  Defaults are <code>alpha=1</code> for
<code>family="binomial"</code> and <code>alpha=1.4</code> otherwise.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_nu">nu</code></td>
<td>
<p>Inverse scale parameter in accelerated life model
families.  Ignored for exponential families.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_id.basis">id.basis</code></td>
<td>
<p>Index designating selected &quot;knots&quot;.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be selected.  Ignored when
<code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_seed">seed</code></td>
<td>
<p>Seed for reproducible random selection of &quot;knots&quot;.
Ignored when <code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_random">random</code></td>
<td>
<p>Input for parametric random effects in nonparametric
mixed-effect models.  See <code><a href="#topic+mkran">mkran</a></code> for details.</p>
</td></tr>
<tr><td><code id="gssanova_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code><a href="#topic+ssanova">ssanova</a></code> for
notes on skipping theta iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model specification via <code>formula</code> is intuitive.  For
example, <code>y~x1*x2</code> yields a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	y = C + f_{1}(x1) + f_{2}(x2) + f_{12}(x1,x2) + e
    </code>
</p>

<p>with the terms denoted by <code>"1"</code>, <code>"x1"</code>, <code>"x2"</code>, and
<code>"x1:x2"</code>.
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p>Only one link is implemented for each <code>family</code>.  It is the
logit link for <code>"binomial"</code>, and the log link for
<code>"poisson"</code>, and <code>"Gamma"</code>.  For <code>"nbinomial"</code>, the
working parameter is the logit of the probability <code class="reqn">p</code>; see
<code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code>.  For <code>"weibull"</code>, <code>"lognorm"</code>,
and <code>"loglogis"</code>, it is the location parameter for the log
lifetime.
</p>
<p>The selection of smoothing parameters is through direct
cross-validation.  The cross-validation score used for
<code>family="poisson"</code> is taken from density estimation as in Gu
and Wang (2003), and those used for other families are derived
following the lines of Gu and Xiang (2001).
</p>
<p>A subset of the observations are selected as &quot;knots.&quot;  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
&quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>


<h3>Value</h3>

<p><code>gssanova</code> returns a list object of class
<code>c("gssanova","ssanova")</code>.
</p>
<p>The method <code><a href="#topic+summary.gssanova">summary.gssanova</a></code> can be used to obtain
summaries of the fits.  The method <code><a href="#topic+predict.ssanova">predict.ssanova</a></code> can
be used to evaluate the fits at arbitrary points along with standard
errors, on the link scale.  The method
<code><a href="#topic+project.gssanova">project.gssanova</a></code> can be used to calculate the
Kullback-Leibler projection for model selection.  The methods
<code><a href="#topic+residuals.gssanova">residuals.gssanova</a></code> and <code><a href="#topic+fitted.gssanova">fitted.gssanova</a></code>
extract the respective traits from the fits.
</p>


<h3>Responses</h3>

<p>For <code>family="binomial"</code>, the response can be specified either
as two columns of counts or as a column of sample proportions plus a
column of total counts entered through the argument <code>weights</code>,
as in <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
<p>For <code>family="nbinomial"</code>, the response may be specified as two
columns with the second being the known sizes, or simply as a single
column with the common unknown size to be estimated through the
maximum likelihood.
</p>
<p>For <code>family="weibull"</code>, <code>"lognorm"</code>, or <code>"loglogis"</code>,
the response consists of three columns, with the first giving the
follow-up time, the second the censoring status, and the third the
left-truncation time.  For data with no truncation, the third column
can be omitted.
</p>
<p>For <code>family="polr"</code>, the response should be an ordered factor.
</p>


<h3>Note</h3>

<p>For simpler models and moderate sample sizes, the exact solution of
<code><a href="#topic+gssanova0">gssanova0</a></code> can be faster.
</p>
<p>The results may vary from run to run. For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>
<p>In <em>gss</em> versions earlier than 1.0, <code>gssanova</code> was under
the name <code>gssanova1</code>.
</p>


<h3>References</h3>

<p>Gu, C. and Xiang, D. (2001), Cross validating non Gaussian data:
generalized approximate cross validation revisited.  <em>Journal
of Computational and Graphical Statistics</em>, <b>10</b>, 581&ndash;591.
</p>
<p>Gu, C. and Wang, J. (2003), Penalized likelihood density
estimation: Direct cross-validation and scalable approximation.
<em>Statistica Sinica</em>, <b>13</b>, 811&ndash;826.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit a cubic smoothing spline logistic regression model
test &lt;- function(x)
        {.3*(1e6*(x^11*(1-x)^6)+1e4*(x^3*(1-x)^10))-2}
x &lt;- (0:100)/100
p &lt;- 1-1/(1+exp(test(x)))
y &lt;- rbinom(x,3,p)
logit.fit &lt;- gssanova(cbind(y,3-y)~x,family="binomial")
## The same fit
logit.fit1 &lt;- gssanova(y/3~x,"binomial",weights=rep(3,101),
                       id.basis=logit.fit$id.basis)
## Obtain estimates and standard errors on a grid
est &lt;- predict(logit.fit,data.frame(x=x),se=TRUE)
## Plot the fit and the Bayesian confidence intervals
plot(x,y/3,ylab="p")
lines(x,p,col=1)
lines(x,1-1/(1+exp(est$fit)),col=2)
lines(x,1-1/(1+exp(est$fit+1.96*est$se)),col=3)
lines(x,1-1/(1+exp(est$fit-1.96*est$se)),col=3)

## Fit a mixed-effect logistic model
data(bacteriuria)
bact.fit &lt;- gssanova(infect~trt+time,family="binomial",data=bacteriuria,
                     id.basis=(1:820)[bacteriuria$id%in%c(3,38)],random=~1|id)
## Predict fixed effects
predict(bact.fit,data.frame(time=2:16,trt=as.factor(rep(1,15))),se=TRUE)
## Estimated random effects
bact.fit$b

## Clean up
## Not run: rm(test,x,p,y,logit.fit,logit.fit1,est,bacteriuria,bact.fit)
dev.off()
## End(Not run)
</code></pre>

<hr>
<h2 id='gssanova0'>Fitting Smoothing Spline ANOVA Models with Non-Gaussian Responses</h2><span id='topic+gssanova0'></span><span id='topic+gssanova1'></span>

<h3>Description</h3>

<p>Fit smoothing spline ANOVA models in non-Gaussian regression.  The
symbolic model specification via <code>formula</code> follows the same
rules as in <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gssanova0(formula, family, type=NULL, data=list(), weights, subset,
          offset, na.action=na.omit, partial=NULL, method=NULL,
          varht=1, nu=NULL, prec=1e-7, maxiter=30)

gssanova1(formula, family, type=NULL, data=list(), weights, subset,
          offset, na.action=na.omit, partial=NULL, method=NULL,
          varht=1, alpha=1.4, nu=NULL, id.basis=NULL, nbasis=NULL,
          seed=NULL, random=NULL, skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gssanova0_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_family">family</code></td>
<td>
<p>Description of the error distribution.  Supported
are exponential families <code>"binomial"</code>, <code>"poisson"</code>,
<code>"Gamma"</code>, <code>"inverse.gaussian"</code>, and
<code>"nbinomial"</code>.  Also supported are accelerated life model
families <code>"weibull"</code>, <code>"lognorm"</code>, and
<code>"loglogis"</code>.  Further more, proportional odds logistic
regression <code>"polr"</code> for ordinal response is also
supported.</p>
</td></tr> 
<tr><td><code id="gssanova0_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to be used in the
fitting process.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_offset">offset</code></td>
<td>
<p>Optional offset term with known parameter 1.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_partial">partial</code></td>
<td>
<p>Optional symbolic description of parametric terms in
partial spline models.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_method">method</code></td>
<td>
<p>Score used to drive the performance-oriented
iteration.  Supported are <code>method="v"</code> for GCV,
<code>method="m"</code> for GML, and <code>method="u"</code> for Mallows' CL.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_varht">varht</code></td>
<td>
<p>Dispersion parameter needed for <code>method="u"</code>.
Ignored when <code>method="v"</code> or <code>method="m"</code> are
specified.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_nu">nu</code></td>
<td>
<p>Inverse scale parameter in accelerated life model
families.  Ignored for exponential families.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for the iterations.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
performance-oriented iteration, and for inner-loop multiple
smoothing parameter selection when applicable.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter modifying GCV or Mallows' CL.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_id.basis">id.basis</code></td>
<td>
<p>Index designating selected &quot;knots&quot;.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be selected.  Ignored when
<code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_seed">seed</code></td>
<td>
<p>Seed for reproducible random selection of &quot;knots&quot;.
Ignored when <code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_random">random</code></td>
<td>
<p>Input for parametric random effects in nonparametric
mixed-effect models.  See <code><a href="#topic+mkran">mkran</a></code> for details.</p>
</td></tr>
<tr><td><code id="gssanova0_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code><a href="#topic+ssanova">ssanova</a></code> for
notes on skipping theta iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model specification via <code>formula</code> is intuitive.  For
example, <code>y~x1*x2</code> yields a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	y = C + f_{1}(x1) + f_{2}(x2) + f_{12}(x1,x2) + e
    </code>
</p>

<p>with the terms denoted by <code>"1"</code>, <code>"x1"</code>, <code>"x2"</code>, and
<code>"x1:x2"</code>.
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p>Only one link is implemented for each <code>family</code>.  It is the
logit link for <code>"binomial"</code>, and the log link for
<code>"poisson"</code>, <code>"Gamma"</code>, and <code>"inverse.gaussian"</code>.
For <code>"nbinomial"</code>, the working parameter is the logit of the
probability <code class="reqn">p</code>; see <code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code>.  For
<code>"weibull"</code>, <code>"lognorm"</code>, and <code>"loglogis"</code>, it is the
location parameter for the log lifetime.
</p>
<p>The models are fitted by penalized likelihood method through the
performance-oriented iteration as described in the reference.  For
<code>family="binomial"</code>, <code>"poisson"</code>, <code>"nbinomial"</code>,
<code>"weibull"</code>, <code>"lognorm"</code>, and <code>"loglogis"</code>, the score
driving the performance-oriented iteration defaults to
<code>method="u"</code> with <code>varht=1</code>.  For <code>family="Gamma"</code>
and <code>"inverse.gaussian"</code>, the default is <code>method="v"</code>.
</p>
<p><code>gssanova0</code> uses the algorithm of <code><a href="#topic+ssanova0">ssanova0</a></code> for
the iterated penalized least squares problems, whereas
<code>gssanova1</code> uses the algorithm of <code><a href="#topic+ssanova">ssanova</a></code>.
</p>
<p>In <code>gssanova1</code>, a subset of the observations are selected as
&quot;knots.&quot;  Unless specified via <code>id.basis</code> or <code>nbasis</code>, the
number of &quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>,
which is appropriate for the default cubic splines for numerical
vectors.
</p>


<h3>Value</h3>

<p><code>gssanova0</code> returns a list object of class
<code>c("gssanova0","ssanova0","gssanova")</code>.
</p>
<p><code>gssanova1</code> returns a list object of class
<code>c("gssanova","ssanova")</code>.
</p>
<p>The method <code><a href="#topic+summary.gssanova0">summary.gssanova0</a></code> or
<code><a href="#topic+summary.gssanova">summary.gssanova</a></code> can be used to obtain summaries of
the fits.  The method <code><a href="#topic+predict.ssanova0">predict.ssanova0</a></code> or
<code><a href="#topic+predict.ssanova">predict.ssanova</a></code> can be used to evaluate the fits at
arbitrary points along with standard errors, on the link scale.  The
methods <code><a href="#topic+residuals.gssanova">residuals.gssanova</a></code> and
<code><a href="#topic+fitted.gssanova">fitted.gssanova</a></code> extract the respective traits from the
fits.
</p>


<h3>Responses</h3>

<p>For <code>family="binomial"</code>, the response can be specified either
as two columns of counts or as a column of sample proportions plus a
column of total counts entered through the argument <code>weights</code>,
as in <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
<p>For <code>family="nbinomial"</code>, the response may be specified as two
columns with the second being the known sizes, or simply as a single
column with the common unknown size to be estimated through the
maximum likelihood.
</p>
<p>For <code>family="weibull"</code>, <code>"lognorm"</code>, or <code>"loglogis"</code>,
the response consists of three columns, with the first giving the
follow-up time, the second the censoring status, and the third the
left-truncation time.  For data with no truncation, the third column
can be omitted.
</p>
<p>For <code>family="polr"</code>, the response should be an ordered factor.
</p>


<h3>Note</h3>

<p>The direct cross-validation of <code><a href="#topic+gssanova">gssanova</a></code> can be more
effective, and more stable for complex models.
</p>
<p>For large sample sizes, the approximate solutions of
<code><a href="#topic+gssanova1">gssanova1</a></code> and <code><a href="#topic+gssanova">gssanova</a></code> can be faster than
<code><a href="#topic+gssanova0">gssanova0</a></code>.
</p>
<p>The results from <code>gssanova1</code> may vary from run to run. For
consistency, specify <code>id.basis</code> or set <code>seed</code>.
</p>
<p>The method <code><a href="#topic+project">project</a></code> is not implemented for
<code>gssanova0</code>, nor is the mixed-effect model support through
<code><a href="#topic+mkran">mkran</a></code>.
</p>
<p>In <em>gss</em> versions earlier than 1.0, <code>gssanova0</code> was under
the name <code>gssanova</code>.
</p>


<h3>References</h3>

<p>Gu, C. (1992), Cross-validating non Gaussian data. <em>Journal
of Computational and Graphical Statistics</em>, <b>1</b>, 169-179.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>GU, C. (2014), Smoothing Spline ANOVA Models: R Package
gss. <em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit a cubic smoothing spline logistic regression model
test &lt;- function(x)
        {.3*(1e6*(x^11*(1-x)^6)+1e4*(x^3*(1-x)^10))-2}
x &lt;- (0:100)/100
p &lt;- 1-1/(1+exp(test(x)))
y &lt;- rbinom(x,3,p)
logit.fit &lt;- gssanova0(cbind(y,3-y)~x,family="binomial")
## The same fit
logit.fit1 &lt;- gssanova0(y/3~x,"binomial",weights=rep(3,101))
## Obtain estimates and standard errors on a grid
est &lt;- predict(logit.fit,data.frame(x=x),se=TRUE)
## Plot the fit and the Bayesian confidence intervals
plot(x,y/3,ylab="p")
lines(x,p,col=1)
lines(x,1-1/(1+exp(est$fit)),col=2)
lines(x,1-1/(1+exp(est$fit+1.96*est$se)),col=3)
lines(x,1-1/(1+exp(est$fit-1.96*est$se)),col=3)
## Clean up
## Not run: rm(test,x,p,y,logit.fit,logit.fit1,est)
dev.off()
## End(Not run)
</code></pre>

<hr>
<h2 id='hzdrate.sshzd'>Evaluating Smoothing Spline Hazard Estimates</h2><span id='topic+hzdrate.sshzd'></span><span id='topic+hzdcurve.sshzd'></span><span id='topic+survexp.sshzd'></span>

<h3>Description</h3>

<p>Evaluate smoothing spline hazard estimates by <code>sshzd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hzdrate.sshzd(object, x, se=FALSE, include=c(object$terms$labels,object$lab.p))
hzdcurve.sshzd(object, time, covariates=NULL, se=FALSE)
survexp.sshzd(object, time, covariates=NULL, start=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzdrate.sshzd_+3A_object">object</code></td>
<td>
<p>Object of class <code>"sshzd"</code>.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd_+3A_x">x</code></td>
<td>
<p>Data frame or vector of points on which hazard is to be
evaluated.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd_+3A_se">se</code></td>
<td>
<p>Flag indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd_+3A_include">include</code></td>
<td>
<p>List of model terms to be included in the
evaluation.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd_+3A_time">time</code></td>
<td>
<p>Vector of time points.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd_+3A_covariates">covariates</code></td>
<td>
<p>Vector of covariate values.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd_+3A_start">start</code></td>
<td>
<p>Optional starting times of the intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>se=FALSE</code>, <code>hzdrate.sshzd</code> returns a vector of hazard
evaluations, and <code>hzdcurve.sshzd</code> returns a vector or columns of
hazard curve(s) evaluated on <code>time</code> points at the
<code>covariates</code> values.  For <code>se=TRUE</code>, <code>hzdrate.sshzd</code>
and <code>hzdcurve.sshzd</code> return a list consisting of the following
elements.
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Vector or columns of hazard.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Vector or columns of standard errors for log hazard.</p>
</td></tr>
</table>
<p><code>survexp.sshzd</code> returns a vector or columns of expected
survivals based on the cumulative hazards over (<code>start</code>,
<code>time</code>) at the <code>covariates</code> values, which in fact are the
(conditional) survival probabilities <code class="reqn">S(time)/S(start)</code>.
</p>


<h3>Note</h3>

<p>For left-truncated data, <code>start</code> must be at or after the
earliest truncation point.
</p>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+sshzd">sshzd</a></code>.
</p>

<hr>
<h2 id='hzdrate.sshzd2d'>Evaluating 2-D Smoothing Spline Hazard Estimates</h2><span id='topic+hzdrate.sshzd2d'></span><span id='topic+survexp.sshzd2d'></span>

<h3>Description</h3>

<p>Evaluate 2-D smoothing spline hazard estimates by <code>sshzd2d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hzdrate.sshzd2d(object, time, covariates=NULL)
survexp.sshzd2d(object, time, covariates=NULL, job=3) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzdrate.sshzd2d_+3A_object">object</code></td>
<td>
<p>Object of class <code>"sshzd2d"</code>.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd2d_+3A_time">time</code></td>
<td>
<p>Matrix or vector of time points on which hazard or
survival function is to be evaluated.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd2d_+3A_covariates">covariates</code></td>
<td>
<p>Data frame of covariate values.</p>
</td></tr>
<tr><td><code id="hzdrate.sshzd2d_+3A_job">job</code></td>
<td>
<p>Flag indicating which survival function to evaluate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of hazard or survival values.
</p>


<h3>Note</h3>

<p>For <code>job=1,2</code>, <code>survexp.sshzd2d</code> returns marginal survival
<code class="reqn">S1(t)</code> or <code class="reqn">S2(t)</code>.  For <code>job=3</code>,
<code>survexp.sshzd2d</code> returns the 2-D survival <code class="reqn">S(t1,t2)</code>.
</p>
<p>For <code>hzdrate.sshzd2d</code> and <code>survexp.sshzd2d</code> with
<code>job=3</code>, <code>time</code> should be a matrix of two columns.  For
<code>survexp.sshzd2d</code> with <code>job=1,2</code>, <code>time</code> should be a
vector.
</p>
<p>When <code>covariates</code> is present, its length should be either 1 or
that of <code>time</code>.
</p>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+sshzd2d">sshzd2d</a></code>.
</p>

<hr>
<h2 id='LakeAcidity'>Water Acidity in Lakes</h2><span id='topic+LakeAcidity'></span>

<h3>Description</h3>

<p>Data extracted from the Eastern Lake Survey of 1984 conducted by the
United States Environmental Protection Agency, concerning 112 lakes
in the Blue Ridge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LakeAcidity)</code></pre>


<h3>Format</h3>

<p>A data frame containing 112 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>ph</code> </td><td style="text-align: left;"> Surface ph.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>cal</code> </td><td style="text-align: left;"> Calcium concentration.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>lat</code> </td><td style="text-align: left;"> Latitude.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>lon</code> </td><td style="text-align: left;"> Longitude.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>geog</code> </td><td style="text-align: left;"> Geographic location, derived from <code>lat</code>
	and <code>lon</code>
    </td>
</tr>

</table>



<h3>Details</h3>

<p><code>geog</code> was generated from <code>lat</code> and <code>lon</code> using the
code given in the Example section.
</p>


<h3>Source</h3>

<p>Douglas, A. and Delampady, M. (1990), <em>Eastern Lake Survey &ndash;
Phase I: Documentation for the Data Base and the Derived Data
sets.</em> Tech Report 160 (SIMS), Dept. Statistics, University of
British Columbia.
</p>


<h3>References</h3>

<p>Gu, C. and Wahba, G. (1993), Semiparametric analysis of variance
with tensor product thin plate splines.  <em>Journal of the Royal
Statistical Society Ser. B</em>, <b>55</b>, 353&ndash;368.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Converting latitude and longitude to x-y coordinates
## Not run: ltln2xy &lt;- function(latlon,latlon0) {
  lat &lt;- latlon[,1]*pi/180; lon &lt;- latlon[,2]*pi/180
  lt0 &lt;- latlon0[1]*pi/180; ln0 &lt;- latlon0[2]*pi/180
  x &lt;- cos(lt0)*sin(lon-ln0); y &lt;- sin(lat-lt0)
  cbind(x,y)
}
data(LakeAcidity)
latlon &lt;- as.matrix(LakeAcidity[,c("lat","lon")])
m.lat &lt;- (min(latlon[,1])+max(latlon[,1]))/2
m.lon &lt;- (min(latlon[,2])+max(latlon[,2]))/2
ltln2xy(latlon,c(m.lat,m.lon))
## Clean up
rm(ltln2xy,LakeAcidity,latlon,m.lat,m.lon)
## End(Not run)
</code></pre>

<hr>
<h2 id='mkcov'>
Generating Covariance for Correlated Data
</h2><span id='topic+mkcov'></span><span id='topic+mkcov.arma'></span><span id='topic+mkcov.long'></span><span id='topic+mkcov.known'></span>

<h3>Description</h3>

<p>Generate entries of covariance functions for correlated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkcov.arma(p, q, n)
mkcov.long(id)
mkcov.known(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkcov_+3A_p">p</code></td>
<td>
<p>Order of AR terms.</p>
</td></tr>
<tr><td><code id="mkcov_+3A_q">q</code></td>
<td>
<p>Order of MA terms.</p>
</td></tr>
<tr><td><code id="mkcov_+3A_n">n</code></td>
<td>
<p>Dimension of covariance matrix.</p>
</td></tr>
<tr><td><code id="mkcov_+3A_id">id</code></td>
<td>
<p>Factor of subject ID.</p>
</td></tr>
<tr><td><code id="mkcov_+3A_w">w</code></td>
<td>
<p>Covariance matrix; only the upper triangular part is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mkcov.arma</code> generates covariance functions for ARMA(p,q)
model.
</p>
<p><code>mkcov.long</code> generates covariance functions for longitudinal
data.
</p>
<p><code>mkcov.known</code> allows one to use a known covariance matrix in
<code>ssanova9</code>.
</p>


<h3>Value</h3>

<p>A list of three elements.
</p>
<table>
<tr><td><code>fun</code></td>
<td>
<p>Covariance matrix to be evaluated through
<code>fun(gamma,env)</code> or <code>fun(env)</code>.</p>
</td></tr>
<tr><td><code>env</code></td>
<td>
<p>Constants in covariance function.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>Initial values for correlation parameters.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>One may pass <code>list(fun=...,env=...,init=...)</code> directly to the
argument <code>cov</code> in calls to <code><a href="#topic+ssanova9">ssanova9</a></code>, or make use
of the <code>mkcov.x</code> functions through
<code>cov=list("arma",c(p,q))</code>, <code>cov=list("long",id)</code>, or
<code>cov=list("known",w)</code>.
</p>

<hr>
<h2 id='mkfun.poly'>
Crafting Building Blocks for Polynomial Splines
</h2><span id='topic+mkfun.poly'></span><span id='topic+mkrk.cubic'></span><span id='topic+mkphi.cubic'></span><span id='topic+mkrk.cubic.per'></span><span id='topic+mkrk.linear'></span><span id='topic+mkrk.linear.per'></span><span id='topic+mkrk.trig'></span><span id='topic+mkphi.trig'></span>

<h3>Description</h3>

<p>Craft numerical functions to be used by <code><a href="#topic+mkterm">mkterm</a></code> to
assemble model terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkrk.cubic(range)
mkphi.cubic(range)
mkrk.trig(range)
mkphi.trig(range)
mkrk.cubic.per(range)
mkrk.linear(range)
mkrk.linear.per(range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkfun.poly_+3A_range">range</code></td>
<td>
<p>Numerical vector whose minimum and maximum specify the
range on which the function to be crafted is defined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mkrk.cubic</code>, <code>mkphi.cubic</code>, and <code>mkrk.linear</code>
implement the polynomial spline construction in Gu (2002,
Sec. 2.3.3) for <code class="reqn">m=2,1</code>.
</p>
<p><code>mkrk.cubic.per</code> and <code>mkrk.linear.per</code> implement the
periodic polynomial spline construction in Gu (2002, Sec. 4.2.1) for
<code class="reqn">m=2,1</code>.
</p>


<h3>Value</h3>

<p>A list of two elements.
</p>
<table>
<tr><td><code>fun</code></td>
<td>
<p>Function definition.</p>
</td></tr>
<tr><td><code>env</code></td>
<td>
<p>Portable local constants derived from the argument.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>mkrk.x</code> create a bivariate function
<code>fun(x,y,env,outer=FALSE)</code>, where <code>x</code>, <code>y</code> are real
arguments and local constants can be passed in through <code>env</code>.
</p>
<p><code>mkphi.cubic</code> creates a univariate function
<code>fun(x,nu,env)</code>.
</p>


<h3>References</h3>

<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkterm">mkterm</a></code>, <code><a href="#topic+mkfun.tp">mkfun.tp</a></code>, and
<code><a href="#topic+mkrk.nominal">mkrk.nominal</a></code>.
</p>

<hr>
<h2 id='mkfun.tp'>
Crafting Building Blocks for Thin-Plate and Spherical Splines
</h2><span id='topic+mkfun.tp'></span><span id='topic+mkrk.tp'></span><span id='topic+mkrk.tp.p'></span><span id='topic+mkphi.tp'></span><span id='topic+mkphi.tp.p'></span><span id='topic+mkrk.sphere'></span>

<h3>Description</h3>

<p>Craft numerical functions to be used by <code><a href="#topic+mkterm">mkterm</a></code> to
assemble model terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkrk.tp(dm, order, mesh, weight)
mkphi.tp(dm, order, mesh, weight)
mkrk.tp.p(dm, order)
mkphi.tp.p(dm, order)

mkrk.sphere(order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkfun.tp_+3A_dm">dm</code></td>
<td>
<p>Dimension of the variable <code class="reqn">d</code>.</p>
</td></tr>
<tr><td><code id="mkfun.tp_+3A_order">order</code></td>
<td>
<p>Order of the differential operator <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="mkfun.tp_+3A_mesh">mesh</code></td>
<td>
<p>Normalizing mesh.</p>
</td></tr>
<tr><td><code id="mkfun.tp_+3A_weight">weight</code></td>
<td>
<p>Normalizing weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mkrk.tp</code>, <code>mkphi.tp</code>, <code>mkrk.tp.p</code>, and
<code>mkphi.tp.p</code> implement the construction in Gu (2002,
Sec. 4.4).  Thin-plate splines are defined for <code class="reqn">2m&gt;d</code>.
</p>
<p><code>mkrk.tp.p</code> generates the pseudo kernel, and <code>mkphi.tp.p</code>
generates the <code class="reqn">(m+d-1)!/d!/(m-1)!</code> lower order polynomials with
total order less than <code class="reqn">m</code>.
</p>
<p><code>mkphi.tp</code> generates normalized lower order polynomials
orthonormal w.r.t. a norm specified by <code>mesh</code> and
<code>weight</code>, and <code>mkrk.tp</code> conditions the pseudo kernel to
generate the reproducing kernel orthogonal to the lower order
polynomials w.r.t. the norm.
</p>
<p><code>mkrk.sphere</code> implements the reproducing kernel construction of
Wahba (1981) for <code class="reqn">m=2,3,4</code>.
</p>


<h3>Value</h3>

<p>A list of two elements.
</p>
<table>
<tr><td><code>fun</code></td>
<td>
<p>Function definition.</p>
</td></tr>
<tr><td><code>env</code></td>
<td>
<p>Portable local constants derived from the arguments.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>mkrk.tp</code> and <code>mkrk.sphere</code> create a bivariate function
<code>fun(x,y,env,outer=FALSE)</code>, where <code>x</code>, <code>y</code> are real
arguments and local constants can be passed in through <code>env</code>.
</p>
<p><code>mkphi.tp</code> creates a collection of univariate functions
<code>fun(x,nu,env)</code>, where <code>x</code> is the argument and <code>nu</code>
is the index.
</p>


<h3>References</h3>

<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Wahba, G. (1981), Spline interpolation and smoothing on the sphere.
<em>SIAM Journal on Scientific and Statistical Computing</em>,
<b>2</b>, 5&ndash;16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkterm">mkterm</a></code>, <code><a href="#topic+mkfun.poly">mkfun.poly</a></code>, and
<code><a href="#topic+mkrk.nominal">mkrk.nominal</a></code>.
</p>

<hr>
<h2 id='mkint'>
Generating Integrals of Basis Terms
</h2><span id='topic+mkint'></span><span id='topic+mkint2'></span>

<h3>Description</h3>

<p>Generate integrals of basis terms for use in the ssden1 suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkint(mf, type, id.basis, quad, term, rho, rho.int)
mkint2(mf, type, id.basis, quad, term)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkint_+3A_mf">mf</code></td>
<td>
<p>Model frame of the model formula.</p>
</td></tr>
<tr><td><code id="mkint_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.</p>
</td></tr>
<tr><td><code id="mkint_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="mkint_+3A_quad">quad</code></td>
<td>
<p>Quadratures on marginal domains, weighted by rho.</p>
</td></tr>
<tr><td><code id="mkint_+3A_term">term</code></td>
<td>
<p>Model terms generated by <code>mkterm</code>.</p>
</td></tr>
<tr><td><code id="mkint_+3A_rho">rho</code></td>
<td>
<p>Marginal log(rho) on quadrature points.</p>
</td></tr>
<tr><td><code id="mkint_+3A_rho.int">rho.int</code></td>
<td>
<p>Marginal integrals of log(rho).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mkint</code> calculates the first moments of basis functions with
respect to the indepent joint density rho; <code>mkint2</code> calculates
the second moments for use in <code>project.ssden1</code>.
</p>


<h3>Value</h3>

<p><code>mkint</code> returns a list of five elements.
</p>
<table>
<tr><td><code>s</code></td>
<td>
<p>First moments of phi's.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>First moments of rk's.</p>
</td></tr>
<tr><td><code>s.rho</code></td>
<td>
<p>Cross moments of phi*log(rho).</p>
</td></tr>
<tr><td><code>r.rho</code></td>
<td>
<p>Cross moments of rk*log(rho).</p>
</td></tr>
<tr><td><code>var.type</code></td>
<td>
<p>Types for variables.</p>
</td></tr>
</table>
<p><code>mkint2</code> returns a list of three elements.
</p>
<table>
<tr><td><code>ss</code></td>
<td>
<p>Second moments of phi's.</p>
</td></tr>
<tr><td><code>sr</code></td>
<td>
<p>Cross moments of phi's and rk's.</p>
</td></tr>
<tr><td><code>rr</code></td>
<td>
<p>Second moments of rk.</p>
</td></tr>
</table>

<hr>
<h2 id='mkran'>
Generating Random Effects in Mixed-Effect Models
</h2><span id='topic+mkran'></span><span id='topic+mkran1'></span>

<h3>Description</h3>

<p>Generate entries representing random effects in mixed-effect models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkran(formula, data)
mkran1(ran1, ran2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkran_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the random effects.</p>
</td></tr>
<tr><td><code id="mkran_+3A_data">data</code></td>
<td>
<p>Data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="mkran_+3A_ran1">ran1</code></td>
<td>
<p>Random effects in the form of the value of <code>mkran</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="mkran_+3A_ran2">ran2</code></td>
<td>
<p>Random effects in the form of the value of <code>mkran</code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p><code>mkran</code> generates random effect terms from simple grouping
variables, for use in nonparametric mixed-effect models as described
in Gu and Ma (2005a, b).  The syntax of the formula resembles that
of similar utilities for linear and nonlinear mixed-effect models,
as described in Pinheiro and Bates (2000).
</p>
<p>Currently, <code>mkran</code> takes only two kinds of basic formulas,
<code>~1|grp2</code> or <code>~grp1|grp2</code>.  Both <code>grp1</code> and
<code>grp2</code> should be factors, and for the second formula, the
levels of <code>grp2</code> should be nested under those of <code>grp1</code>.
</p>
<p>The Z matrix is determined by <code>grp2</code>.  When observations are
ordered according to the levels of <code>grp2</code>, the Z matrix is
block diagonal of 1 vectors.
</p>
<p>The Sigma matrix is diagonal.  For <code>~1|grp2</code>, it has one tuning
parameter.  For <code>~grp1|grp2</code>, the number of parameters equals
the number of levels of <code>grp1</code>, with each parameter shared by
the <code>grp2</code> levels nested under the same <code>grp1</code> level.
</p>
<p><code>mkran1</code> adds together two independent random effects, and can
be used recursively to add more than two terms.  The arguments are
of the form of the value of <code>mkran</code> or <code>mkran1</code>, which may
or may not be created by <code>mkran</code> or <code>mkran1</code>.
</p>
<p>Multiple terms of random effects can also be specified via the likes
of <code>mkran(~1|grp1+1|grp2,data)</code>, which is equivalent to
<code>mkran1(mkran(~1|grp1,data),mkran(~1|grp2,data))</code>.
</p>


<h3>Value</h3>

<p>A list of three elements.
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>Z matrix.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Sigma matrix to be evaluated through
<code>sigma$fun(para,sigma$env)</code>.</p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p>Initial parameter values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>One may pass a formula or a list to the argument <code>random</code> in
calls to <code><a href="#topic+ssanova">ssanova</a></code> or<code><a href="#topic+gssanova">gssanova</a></code> to fit
nonparametric mixed-effect models.  A formula will be converted to a
list using <code>mkran</code>.  A list should be of the same form as the
value of <code>mkran</code>.
</p>


<h3>References</h3>

<p>Gu, C. and Ma, P. (2005), Optimal smoothing in nonparametric
mixed-effect models.  <em>The Annals of Statistics</em>, <b>33</b>,
1357&ndash;1379.
</p>
<p>Gu, C. and Ma, P. (2005), Generalized nonparametric mixed-effect
models: computation and smoothing parameter selection.
<em>Journal of Computational and Graphical Statistics</em>, <b>14</b>,
485&ndash;504.
</p>
<p>Pinheiro and Bates (2000), <em>Mixed-Effects Models in S and
S-PLUS</em>.  New York: Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Toy data
test &lt;- data.frame(grp=as.factor(rep(1:2,c(2,3))))
## First formula
ran.test &lt;- mkran(~1|grp,test)
ran.test$z
ran.test$sigma$fun(2,ran.test$sigma$env) # diag(10^(-2),2)
## Second formula
ran.test &lt;- mkran(~grp|grp,test)
ran.test$z
ran.test$sigma$fun(c(1,2),ran.test$sigma$env) # diag(10^(-1),10^(-2))
## Clean up
## Not run: rm(test,ran.test)
</code></pre>

<hr>
<h2 id='mkrk.nominal'>
Crafting Building Blocks for Discrete Splines
</h2><span id='topic+mkrk.nominal'></span><span id='topic+mkrk.ordinal'></span>

<h3>Description</h3>

<p>Craft numerical functions to be used by <code>mkterm</code> to assemble
model terms involving factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkrk.nominal(levels)
mkrk.ordinal(levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkrk.nominal_+3A_levels">levels</code></td>
<td>
<p>Levels of the factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a nominal factor with levels <code class="reqn">1,2,\dots,k</code>, the level means
<code class="reqn">f(i)</code> will be shrunk towards each other through a penalty
proportional to
</p>
<p style="text-align: center;"><code class="reqn">(f(1)-f(.))^2+\dots+(f(k)-f(.))^2</code>
</p>

<p>where <code class="reqn">f(.)=(f(1)+\dots+f(k))/k</code>.
</p>
<p>For a ordinal factor with levels <code class="reqn">1&lt;2&lt;\dots&lt;k</code>, the level means
<code class="reqn">f(i)</code> will be shrunk towards each other through a penalty
proportional to
</p>
<p style="text-align: center;"><code class="reqn">(f(1)-f(2))^2+\dots+(f(k-1)-f(k))^2</code>
</p>



<h3>Value</h3>

<p>A list of two elements.
</p>
<table>
<tr><td><code>fun</code></td>
<td>
<p>Function definition.</p>
</td></tr>
<tr><td><code>env</code></td>
<td>
<p>Portable local constants derived from the arguments.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>mkrk.x</code> create a bivariate function
<code>fun(x,y,env,outer=FALSE)</code>, where <code>x</code>, <code>y</code> are real
arguments and local constants can be passed in through <code>env</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkterm">mkterm</a></code>, <code><a href="#topic+mkrk.cubic">mkrk.cubic</a></code>, and
<code><a href="#topic+mkrk.tp">mkrk.tp</a></code>.
</p>

<hr>
<h2 id='mkterm'>
Assembling Model Terms for Smoothing Spline ANOVA Models
</h2><span id='topic+mkterm'></span>

<h3>Description</h3>

<p>Assemble numerical functions for calculating model terms in a
smoothing spline ANOVA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkterm(mf, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkterm_+3A_mf">mf</code></td>
<td>
<p>Model frame of the model formula.</p>
</td></tr>
<tr><td><code id="mkterm_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <b>factor</b> <code>x</code>, <code>type$x</code> is ignored;
<code><a href="#topic+mkrk.ordinal">mkrk.ordinal</a></code> is used if <code>is.ordered(x)==TRUE</code> and
<code><a href="#topic+mkrk.nominal">mkrk.nominal</a></code> is used otherwise.  Factors with 3 or
more levels are penalized.
</p>
<p>For a <b>numerical vector</b> <code>x</code>, <code>type$x</code> is of the form
<code>type.x</code> for <code>type.x</code>=<code>"cubic"</code>, <code>"linear"</code>,
or of the form <code>list(type.x, range)</code> for
<code>type.x</code>=<code>"per"</code>, <code>"cubic.per"</code>, <code>"linear.per"</code>,
<code>"cubic"</code>, <code>"linear"</code>; <code>"per"</code> is short for
<code>"cubic.per"</code>.  See <code><a href="#topic+mkfun.poly">mkfun.poly</a></code> for the functions
used.  For <code>type.x</code> missing, the <b>default</b> is <code>"cubic"</code>.
For <code>range</code> missing with <code>type.x</code>=<code>"cubic"</code>,
<code>"linear"</code>, the <b>default</b> is
<code>c(min(x),max(x))+c(-1,1)*(max(x)-mimn(x))*.05</code>.
</p>
<p>For a <b>numerical matrix</b> <code>x</code>, <code>type$x</code> is of the form
<code>type.x</code> or <code>list(type.x, order)</code> for
<code>type.x</code>=<code>"tp"</code>, <code>"sphere"</code>, or of the form
<code>list("tp",list(order=order,mesh=mesh,weight=weight))</code>.  See
<code><a href="#topic+mkfun.tp">mkfun.tp</a></code> for the functions used.  For <code>type.x</code>
missing, the <b>default</b> is <code>"tp"</code>.  For <code>order</code>
missing, the <b>default</b> is <code>2</code>.  For <code>mesh</code> and
<code>weight</code> missing with <code>type.x</code>=<code>"tp"</code> and
<code>order</code> given, the <b>defaults</b> are <code>mesh</code>=<code>x</code> and
<code>weight</code>=<code>1</code>.
</p>
<p>For a <b>numerical vector</b> or <b>numerical matrix</b> <code>x</code>,
one may also use <code>type$x</code> of the form
<code>list("custom",list(nphi=nphi,mkphi=mkphi,mkrk=mkrk,env=env))</code>;
<code>nphi</code> is the null space dimension <em>excluding the
constant</em>, and <code>mkphi</code> is ignored if <code>nphi</code>=0.  See
examples below.  This feature allows the use of other marginal
constructions; one may modify <code><a href="#topic+mkphi.cubic">mkphi.cubic</a></code> or
<code><a href="#topic+mkphi.tp.p">mkphi.tp.p</a></code> for <code>mkphi</code> and modify
<code><a href="#topic+mkrk.cubic">mkrk.cubic</a></code> or <code><a href="#topic+mkrk.sphere">mkrk.sphere</a></code> for
<code>mkrk</code>.
</p>


<h3>Value</h3>

<p>A list object with an element <code>labels</code> containing the labels
of all model terms.  For each of the model terms, there is an
element holding the numerical functions for calculating the
unpenalized and penalized parts within the term.
</p>


<h3>Background</h3>

<p>Tensor-product splines are constructed based on the model formula
and the marginal reproducing kernels, as described in Gu (2002,
Sec. 2.4).  The marginal variables can be factors, numerical
vectors, and numerical matrices, as specified in the details
section.
</p>
<p>One-way ANOVA decompositions are built in the supported marginal
constructions, in which one has the constant, a &quot;nonparametric
contrast,&quot; and possibly also a &quot;parametric contrast.&quot;  To the
&quot;nonparametric contrast&quot; there corresponds a reproducing kernal
<code>rk</code>, and to a &quot;parametric contrast&quot; there corresponds a set
of null space basis <code>phi</code>.  The reproducing kernels and null
space basis on the product domain can be constructed from the
marginal <code>rk</code> and <code>phi</code> in a systematic manner.
</p>
<p>The marginal one-way ANOVA structures induce a multi-way ANOVA
structure on the product domain, with model terms consisting of
unpenalized &quot;parametric contrasts&quot; and/or penalized &quot;nonparametric
contrasts.&quot;  One only needs to construct <code>rk</code>'s and
<code>phi</code>'s associated with the model terms implied by the model
formula.
</p>


<h3>Note</h3>

<p>For a <b>numerical vector</b> <code>x</code> in <code><a href="#topic+ssden">ssden</a></code>,
the default <code>range</code> is <code>domain$x</code>.
</p>
<p>For a <b>numerical matrix</b> <code>x</code> with
<code>type.x</code>=<code>"sphere"</code>, it is assumed that
<code>dim(x)[2]==2</code>, <code>x[,1]</code> between [-90,90] the latitude in
degrees, and <code>x[,2]</code> between [-180,180] the longitude in
degrees.
</p>
<p>For <b>backward compatibility</b>, one may set <code>type="cubic"</code>,
<code>"linear"</code>, or <code>"tp"</code>, but then the default parameters can
not be overridden; the type is simply duplicated for each variable.
</p>


<h3>References</h3>

<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## cubic marginals
x1 &lt;- rnorm(100); x2 &lt;- rnorm(100); y &lt;- 3+5*sin(x1-2*x2)+rnorm(x1)
fit &lt;- ssanova0(y~x1*x2)
## the same fit
fit1 &lt;- ssanova0(y~x1*x2,type=list(x1="cubic"))
## the same fit one more time
par &lt;- list(nphi=1,mkphi=mkphi.cubic,mkrk=mkrk.cubic,
            env=c(min(x2),max(x2))+c(-1,1)*(max(x2)-min(x2))*.05)
fit2 &lt;- ssanova0(y~x1*x2,type=list(x2=list("custom",par)))
## Clean up
## Not run: rm(x1,x2,y,fit,fit1,par,fit2)

## cubic and thin-plate marginals
x1 &lt;- rnorm(100); x2 &lt;- matrix(rnorm(200),100,2)
y &lt;- 3+5*sin(x1-2*x2[,1]*x2[,2])+rnorm(x1)
fit &lt;- ssanova0(y~x1*x2)
## the same fit
fit1 &lt;- ssanova0(y~x1*x2,type=list(x2="tp"))
## the same fit one more time
mkphi.tp1 &lt;- function(x) mkphi.tp(x$dm,x$ord,x$mesh,x$wt)
mkrk.tp1 &lt;- function(x) mkrk.tp(x$dm,x$ord,x$mesh,x$wt)
env &lt;- list(dm=2,ord=2,mesh=x2,wt=1)
par &lt;- list(nphi=2,mkphi=mkphi.tp1,mkrk=mkrk.tp1,env=env)
fit2 &lt;- ssanova0(y~x1*x2,type=list(x2=list("custom",par)))
## Clean up
## Not run: rm(x1,x2,y,fit,fit1,mkphi.tp1,mkrk.tp1,env,par,fit2)
</code></pre>

<hr>
<h2 id='mkterm.copu'>
Assembling Model Terms for Copula Density Estimation
</h2><span id='topic+mkterm.copu'></span>

<h3>Description</h3>

<p>Assemble numerical functions for calculating model terms in copula
density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkterm.copu(dm, order, symmetry, exclude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkterm.copu_+3A_dm">dm</code></td>
<td>
<p>Dimension of the domain.</p>
</td></tr>
<tr><td><code id="mkterm.copu_+3A_order">order</code></td>
<td>
<p>Highest order of interactions allowed in log density.</p>
</td></tr>
<tr><td><code id="mkterm.copu_+3A_symmetry">symmetry</code></td>
<td>
<p>Flag indicating whether to enforce symmetry, or
invariance under coordinate permutation.</p>
</td></tr>
<tr><td><code id="mkterm.copu_+3A_exclude">exclude</code></td>
<td>
<p>Pair(s) of marginals whose interactions to be
excluded in log density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chong Gu, <a href="mailto:chong@stat.purdue.edu">chong@stat.purdue.edu</a></p>

<hr>
<h2 id='nlm0'>Minimizing Univariate Functions on Finite Intervals</h2><span id='topic+nlm0'></span>

<h3>Description</h3>

<p>Minimize univariate functions on finite intervals using 3-point
quadratic fit, with golden-section safe-guard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlm0(fun, range, prec=1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlm0_+3A_fun">fun</code></td>
<td>
<p>Function to be minimized.</p>
</td></tr>
<tr><td><code id="nlm0_+3A_range">range</code></td>
<td>
<p>Interval on which the function to be minimized.</p>
</td></tr>
<tr><td><code id="nlm0_+3A_prec">prec</code></td>
<td>
<p>Desired precision of the solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nlm0</code> returns a list object with the following elements.
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>Minimizer.</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>
<p>Minimum.</p>
</td></tr>
<tr><td><code>evaluations</code></td>
<td>
<p>Number of function evaluations.</p>
</td></tr>
</table>

<hr>
<h2 id='NO2'>Air Pollution and Road Traffic</h2><span id='topic+NO2'></span>

<h3>Description</h3>

<p>A subset of 500 hourly observations collected by the Norwegian
Public Roads Administration at Alnabru in Oslo, Norway, between
October 2001 and August 2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NO2)</code></pre>


<h3>Format</h3>

<p>A data frame containing 500 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>no2</code> </td><td style="text-align: left;"> Concentration of NO2, on log scale.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>cars</code> </td><td style="text-align: left;"> Traffic volume of the hour, on log scale.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>temp</code> </td><td style="text-align: left;"> Temperature 2 meters above ground, in Celsius.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>wind</code> </td><td style="text-align: left;"> wind speed, meters/second.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>temp2</code> </td><td style="text-align: left;"> Temperature difference between 25 and 2 meters
	above ground, in Celsius.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>wind2</code> </td><td style="text-align: left;"> Wind direction, in degrees between 0 and 360.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Statlib Datasets Archive at <code>http://lib.stat.cmu.edu/datasets</code>,
contributed by Magne Aldrin.
</p>

<hr>
<h2 id='nox'>NOx in Engine Exhaust</h2><span id='topic+nox'></span>

<h3>Description</h3>

<p>Data from an experiment in which a single-cylinder engine was run
with ethanol to see how the NOx concentration in the exhaust
depended on the compression ratio and the equivalence ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nox)</code></pre>


<h3>Format</h3>

<p>A data frame containing 88 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>nox</code> </td><td style="text-align: left;"> NOx concentration in exhaust.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>comp</code> </td><td style="text-align: left;"> Compression ratio.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>equi</code> </td><td style="text-align: left;"> Equivalence ratio.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Brinkman, N. D. (1981), Ethanol fuel &ndash; a single-cylinder engine
study of efficiency and exhaust emissions.  <em>SAE Transactions</em>,
<b>90</b>, 1410&ndash;1424.
</p>


<h3>References</h3>

<p>Cleveland, W. S. and Devlin, S. J. (1988), Locally weighted
regression: An approach to regression analysis by local fitting.
<em>Journal of the American Statistical Association</em>, <b>83</b>,
596&ndash;610.
</p>
<p>Breiman, L. (1991), The pi method for estimating multivariate
functions from noisy data.  <em>Technometrics</em>, <b>33</b>,
125&ndash;160. 
</p>

<hr>
<h2 id='ozone'>Ozone Concentration in Los Angeles Basin</h2><span id='topic+ozone'></span>

<h3>Description</h3>

<p>Daily measurements of ozone concentration and eight meteorological
quantities in the Los Angeles basin for 330 days of 1976.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ozone)</code></pre>


<h3>Format</h3>

<p>A data frame containing 330 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>upo3</code> </td><td style="text-align: left;"> Upland ozone concentration, in ppm.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>vdht</code> </td><td style="text-align: left;"> Vandenberg 500 millibar height, in meters.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>wdsp</code> </td><td style="text-align: left;"> Wind speed, in miles per hour.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>hmdt</code> </td><td style="text-align: left;"> Humidity.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>sbtp</code> </td><td style="text-align: left;"> Sandburg Air Base temperature, in Celsius.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ibht</code> </td><td style="text-align: left;"> Inversion base height, in foot.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>dgpg</code> </td><td style="text-align: left;"> Dagget pressure gradient, in mmHg.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ibtp</code> </td><td style="text-align: left;"> Inversion base temperature, in Fahrenheit.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>vsty</code> </td><td style="text-align: left;"> Visibility, in miles.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>day</code> </td><td style="text-align: left;"> Calendar day, between 1 and 366.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Unknown.
</p>


<h3>References</h3>

<p>Breiman, L. and Friedman, J. H. (1985), Estimating optimal
transformations for multiple regression and correlation.
<em>Journal of the American Statistical Association</em>, <b>80</b>,
580&ndash;598.
</p>
<p>Hastie, T. and Tibshirani, R. (1990), <em>Generalized Additive
Models</em>. Chapman and Hall.
</p>

<hr>
<h2 id='penny'>Thickness of US Lincoln Pennies</h2><span id='topic+penny'></span>

<h3>Description</h3>

<p>Thickness of US Lincoln pennies minted during years 1945 through
1989.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nox)</code></pre>


<h3>Format</h3>

<p>A data frame containing 90 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>year</code> </td><td style="text-align: left;"> Year minted.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>mil</code> </td><td style="text-align: left;"> Thickness in mils.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Scott, D. W. (1992), <em>Multivariate Density Estimation: Theory,
Practice and Visualization</em>.  New York: Wiley.
</p>


<h3>References</h3>

<p>Gu, C. (1995), Smoothing spline density estimation: Conditional
distribution, <em>Statistica Sinica</em>, <b>5</b>, 709&ndash;726.
</p>
<p>Scott, D. W. (1992), <em>Multivariate Density Estimation: Theory,
Practice and Visualization</em>.  New York: Wiley.
</p>

<hr>
<h2 id='predict.ssanova'>Predicting from Smoothing Spline ANOVA Fits</h2><span id='topic+predict.ssanova'></span><span id='topic+predict.ssanova0'></span><span id='topic+predict1'></span><span id='topic+predict1.ssanova'></span>

<h3>Description</h3>

<p>Evaluate terms in a smoothing spline ANOVA fit at arbitrary points.
Standard errors of the terms can be requested for use in
constructing Bayesian confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssanova'
predict(object, newdata, se.fit=FALSE,
                          include=c(object$terms$labels,object$lab.p), ...)
## S3 method for class 'ssanova0'
predict(object, newdata, se.fit=FALSE,
                           include=c(object$terms$labels,object$lab.p), ...)
## S3 method for class 'ssanova'
predict1(object, contr=c(1,-1), newdata, se.fit=TRUE,
                           include=c(object$terms$labels,object$lab.p), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ssanova_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from <code>"ssanova"</code>.</p>
</td></tr>
<tr><td><code id="predict.ssanova_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or model frame in which to predict.</p>
</td></tr>
<tr><td><code id="predict.ssanova_+3A_se.fit">se.fit</code></td>
<td>
<p>Flag indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="predict.ssanova_+3A_include">include</code></td>
<td>
<p>List of model terms to be included in the
prediction.  The <code>offset</code> term, if present, is to be
specified by <code>"offset"</code>.</p>
</td></tr>
<tr><td><code id="predict.ssanova_+3A_contr">contr</code></td>
<td>
<p>Contrast coefficients.</p>
</td></tr>
<tr><td><code id="predict.ssanova_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>se.fit=FALSE</code>, <code>predict.ssanova</code> returns a vector of
the evaluated fit.
</p>
<p>For <code>se.fit=TRUE</code>, <code>predict.ssanova</code> returns a list
consisting of the following elements.
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Vector of evaluated fit.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Vector of standard errors.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For mixed-effect models through <code><a href="#topic+ssanova">ssanova</a></code> or
<code><a href="#topic+gssanova">gssanova</a></code>, the Z matrix is set to 0 if not supplied.
To supply the Z matrix, add an element <code>random=I(...)</code> in
<code>newdata</code>, where the as-is function <code>I(...)</code> preserves the
integrity of the Z matrix in data frame.
</p>
<p><code>predict1.ssanova</code> takes a list of data frames in
<code>newdata</code> representing x1, x2, etc.  By default, it calculates
f(x1)-f(x2) along with standard errors.  While pairwise contrast is
the targeted application, all linear combinations can be computed.
</p>
<p>For <code>"gssanova"</code> objects, the results are on the link scale.
See also <code><a href="#topic+predict9.gssanova">predict9.gssanova</a></code>.
</p>


<h3>References</h3>

<p>Gu, C. (1992), Penalized likelihood regression: a Bayesian
analysis.  <em>Statistica Sinica</em>, <b>2</b>, 255&ndash;264.
</p>
<p>Gu, C. and Wahba, G. (1993), Smoothing spline ANOVA with
component-wise Bayesian &quot;confidence intervals.&quot;  <em>Journal of
Computational and Graphical Statistics</em>, <b>2</b>, 97&ndash;117.
</p>
<p>Kim, Y.-J. and Gu, C. (2004), Smoothing spline Gaussian regression:
more scalable computation via efficient approximation.
<em>Journal of the Royal Statistical Society, Ser. B</em>, <b>66</b>,
337&ndash;356.
</p>


<h3>See Also</h3>

<p>Fitting functions <code><a href="#topic+ssanova">ssanova</a></code>, <code><a href="#topic+ssanova0">ssanova0</a></code>,
<code><a href="#topic+gssanova">gssanova</a></code>, <code><a href="#topic+gssanova0">gssanova0</a></code> and
methods <code><a href="#topic+summary.ssanova">summary.ssanova</a></code>,
<code><a href="#topic+summary.gssanova">summary.gssanova</a></code>, <code><a href="#topic+summary.gssanova0">summary.gssanova0</a></code>,
<code><a href="#topic+project.ssanova">project.ssanova</a></code>, <code><a href="#topic+fitted.ssanova">fitted.ssanova</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## THE FOLLOWING EXAMPLE IS TIME-CONSUMING
## Not run: 
## Fit a model with cubic and thin-plate marginals, where geog is 2-D
data(LakeAcidity)
fit &lt;- ssanova(ph~log(cal)*geog,,LakeAcidity)
## Obtain estimates and standard errors on a grid
new &lt;- data.frame(cal=1,geog=I(matrix(0,1,2)))
new &lt;- model.frame(~log(cal)+geog,new)
predict(fit,new,se=TRUE)
## Evaluate the geog main effect
predict(fit,new,se=TRUE,inc="geog")
## Evaluate the sum of the geog main effect and the interaction
predict(fit,new,se=TRUE,inc=c("geog","log(cal):geog"))
## Evaluate the geog main effect on a grid
grid &lt;- seq(-.04,.04,len=21)
new &lt;- model.frame(~geog,list(geog=cbind(rep(grid,21),rep(grid,rep(21,21)))))
est &lt;- predict(fit,new,se=TRUE,inc="geog")
## Plot the fit and standard error
par(pty="s")
contour(grid,grid,matrix(est$fit,21,21),col=1)
contour(grid,grid,matrix(est$se,21,21),add=TRUE,col=2)
## Clean up
rm(LakeAcidity,fit,new,grid,est)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.sscox'>Evaluating Smoothing Spline ANOVA Estimate of Relative Risk</h2><span id='topic+predict.sscox'></span>

<h3>Description</h3>

<p>Evaluate terms in a smoothing spline ANOVA estimate of relative risk
at arbitrary points.  Standard errors of the terms can be requested
for use in constructing Bayesian confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sscox'
predict(object, newdata, se.fit=FALSE,
                        include=c(object$terms$labels,object$lab.p), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sscox_+3A_object">object</code></td>
<td>
<p>Object of class <code>"sscox"</code>.</p>
</td></tr>
<tr><td><code id="predict.sscox_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or model frame in which to predict.</p>
</td></tr>
<tr><td><code id="predict.sscox_+3A_se.fit">se.fit</code></td>
<td>
<p>Flag indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="predict.sscox_+3A_include">include</code></td>
<td>
<p>List of model terms to be included in the
prediction.</p>
</td></tr>
<tr><td><code id="predict.sscox_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>se.fit=FALSE</code>, <code>predict.sscox</code> returns a vector of
the evaluated relative risk.
</p>
<p>For <code>se.fit=TRUE</code>, <code>predict.sscox</code> returns a list
consisting of the following elements.
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Vector of evaluated relative risk.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Vector of standard errors for log relative risk.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For mixed-effect models through <code><a href="#topic+sscox">sscox</a></code>, the Z matrix is
set to 0 if not supplied.  To supply the Z matrix, add an element
<code>random=I(...)</code> in <code>newdata</code>, where the as-is function
<code>I(...)</code> preserves the integrity of the Z matrix in data
frame.
</p>


<h3>See Also</h3>

<p>Fitting functions <code><a href="#topic+sscox">sscox</a></code> and method
<code><a href="#topic+project.sscox">project.sscox</a></code>.
</p>

<hr>
<h2 id='predict.ssllrm'>Evaluating Log-Linear Regression Model Fits</h2><span id='topic+predict.ssllrm'></span>

<h3>Description</h3>

<p>Evaluate conditional density in a log-linear regression model fit at
arbitrary x, or contrast of log conditional density possibly with
standard errors for constructing Bayesian confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssllrm'
predict(object, x, y=object$qd.pt, odds=NULL, se.odds=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ssllrm_+3A_object">object</code></td>
<td>
<p>Object of class <code>"ssllrm"</code>.</p>
</td></tr>
<tr><td><code id="predict.ssllrm_+3A_x">x</code></td>
<td>
<p>Data frame of x values.</p>
</td></tr>
<tr><td><code id="predict.ssllrm_+3A_y">y</code></td>
<td>
<p>Data frame of y values; y-variables must be factors.</p>
</td></tr>
<tr><td><code id="predict.ssllrm_+3A_odds">odds</code></td>
<td>
<p>Optional coefficients of contrast.</p>
</td></tr>
<tr><td><code id="predict.ssllrm_+3A_se.odds">se.odds</code></td>
<td>
<p>Flag indicating if standard errors are required.
Ignored when <code>odds=NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.ssllrm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>odds=NULL</code>, <code>predict.ssanova</code> returns a vector/matrix
of the estimated <code>f(y|x)</code>.
</p>
<p>When <code>odds</code> is given, it should match <code>y</code> in length and
the coefficients must add to zero; <code>predict.ssanova</code> then
returns a vector of estimated &quot;odds ratios&quot; if <code>se.odds=FALSE</code>
or a list consisting of the following elements if
<code>se.odds=TRUE</code>.
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Vector of evaluated fit.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>Vector of standard errors.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+ssllrm">ssllrm</a></code>.
</p>

<hr>
<h2 id='predict9.gssanova'>Predicting from Smoothing Spline ANOVA Fits with Non-Gaussian Responses</h2><span id='topic+predict9.gssanova'></span><span id='topic+predict9'></span>

<h3>Description</h3>

<p>Evaluate smoothing spline ANOVA fits with non-Gaussian responses at arbitrary
points, with results on the response scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gssanova'
predict9(object, newdata, ci=FALSE, level=.95, nu=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict9.gssanova_+3A_object">object</code></td>
<td>
<p>Object of class inheriting from <code>"gssanova"</code>.</p>
</td></tr>
<tr><td><code id="predict9.gssanova_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or model frame in which to predict.</p>
</td></tr>
<tr><td><code id="predict9.gssanova_+3A_ci">ci</code></td>
<td>
<p>Flag indicating if Bayesian confidence intervals are required.
Ignored for <code>family="polr"</code>.</p>
</td></tr> 
<tr><td><code id="predict9.gssanova_+3A_level">level</code></td>
<td>
<p>Confidence level.  Ignored when <code>ci=FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict9.gssanova_+3A_nu">nu</code></td>
<td>
<p>Sizes for <code>"nbinomial"</code> fits with known sizes.  Ignored
otherwise.</p>
</td></tr>
<tr><td><code id="predict9.gssanova_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>ci=FALSE</code>, <code>predict9.gssanova</code> returns a vector of the
evaluated fit,
</p>
<p>For <code>ci=TRUE</code>, <code>predict9.gssanova</code> returns a list of three
elements.
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Vector of evaluated fit on response scale.</p>
</td></tr>
<tr><td><code>lcl</code></td>
<td>
<p>Vector of lower confidence limit on response scale.</p>
</td></tr>
<tr><td><code>ucl</code></td>
<td>
<p>Vector of upper confidence limit on response scale.</p>
</td></tr>
</table>
<p>For <code>family="polr"</code>, <code>predict9.gssanova</code> returns a matrix of
probabilities with each row adding up to 1.
</p>


<h3>Note</h3>

<p>For mixed-effect models through <code><a href="#topic+gssanova">gssanova</a></code> or
<code><a href="#topic+gssanova1">gssanova1</a></code>, the Z matrix is set to 0 if not supplied.
To supply the Z matrix, add an element <code>random=I(...)</code> in
<code>newdata</code>, where the as-is function <code>I(...)</code> preserves the
integrity of the Z matrix in data frame.
</p>
<p>Unlike on the link scale, partial sums make no sense on the response
scale, so all terms are forced in here.
</p>


<h3>References</h3>

<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>


<h3>See Also</h3>

<p>Fitting functions <code><a href="#topic+gssanova">gssanova</a></code>, <code><a href="#topic+gssanova1">gssanova1</a></code> and
methods <code><a href="#topic+predict.ssanova">predict.ssanova</a></code>, <code><a href="#topic+summary.gssanova">summary.gssanova</a></code>,
<code><a href="#topic+project.gssanova">project.gssanova</a></code>, <code><a href="#topic+fitted.gssanova">fitted.gssanova</a></code>.
</p>

<hr>
<h2 id='print'>Print Functions for Smoothing Spline ANOVA Models</h2><span id='topic+print.ssanova'></span><span id='topic+print.ssanova0'></span><span id='topic+print.gssanova'></span><span id='topic+print.ssden'></span><span id='topic+print.sscden'></span><span id='topic+print.sshzd'></span><span id='topic+print.sscox'></span><span id='topic+print.ssllrm'></span><span id='topic+print.summary.ssanova'></span><span id='topic+print.summary.gssanova'></span><span id='topic+print.summary.gssanova0'></span>

<h3>Description</h3>

<p>Print functions for Smoothing Spline ANOVA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssanova'
print(x, ...)
## S3 method for class 'ssanova0'
print(x, ...)
## S3 method for class 'gssanova'
print(x, ...)
## S3 method for class 'ssden'
print(x, ...)
## S3 method for class 'sscden'
print(x, ...)
## S3 method for class 'sshzd'
print(x, ...)
## S3 method for class 'sscox'
print(x, ...)
## S3 method for class 'ssllrm'
print(x, ...)
## S3 method for class 'summary.ssanova'
print(x, digits=6, ...)
## S3 method for class 'summary.gssanova'
print(x, digits=6, ...)
## S3 method for class 'summary.gssanova0'
print(x, digits=6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Object of class <code>ssanova</code>, <code>summary.ssanova</code>,
<code>summary.gssanova</code>, or <code>ssden</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to be printed in
values.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ssanova">ssanova</a></code>, <code><a href="#topic+ssanova0">ssanova0</a></code>,
<code><a href="#topic+gssanova">gssanova</a></code>, <code><a href="#topic+gssanova0">gssanova0</a></code>,
<code><a href="#topic+ssden">ssden</a></code>, <code><a href="#topic+ssllrm">ssllrm</a></code>, <code><a href="#topic+sshzd">sshzd</a></code>,
<code><a href="#topic+summary.ssanova">summary.ssanova</a></code>, <code><a href="#topic+summary.gssanova">summary.gssanova</a></code>,
<code><a href="#topic+summary.gssanova0">summary.gssanova0</a></code>.
</p>

<hr>
<h2 id='project'>Projecting Smoothing Spline ANOVA Fits for Model Diagnostics</h2><span id='topic+project'></span><span id='topic+project.ssanova'></span><span id='topic+project.ssanova9'></span><span id='topic+project.gssanova'></span><span id='topic+project.ssden'></span><span id='topic+project.ssden1'></span><span id='topic+project.sscden'></span><span id='topic+project.sscden1'></span><span id='topic+project.sshzd'></span><span id='topic+project.sscox'></span><span id='topic+project.sshzd1'></span><span id='topic+project.ssllrm'></span>

<h3>Description</h3>

<p>Calculate Kullback-Leibler projection of smoothing spline ANOVA fits
for model diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(object, ...)
## S3 method for class 'ssanova'
project(object, include, ...)
## S3 method for class 'ssanova9'
project(object, include, ...)
## S3 method for class 'gssanova'
project(object, include, ...)
## S3 method for class 'ssden'
project(object, include, mesh=FALSE, ...)
## S3 method for class 'ssden1'
project(object, include, drop1=FALSE, ...)
## S3 method for class 'sscden'
project(object, include, ...)
## S3 method for class 'sscden1'
project(object, include, ...)
## S3 method for class 'sshzd'
project(object, include, mesh=FALSE, ...)
## S3 method for class 'sscox'
project(object, include, ...)
## S3 method for class 'sshzd1'
project(object, include, ...)
## S3 method for class 'ssllrm'
project(object, include, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_object">object</code></td>
<td>
<p>Object of class <code>"ssanova"</code>, <code>"gssanova"</code>,
<code>"ssden"</code>, <code>"ssden1"</code>, <code>"sscden"</code>,
<code>"sscden1"</code>, <code>"sshzd"</code>, <code>"sshzd1"</code>, or
<code>"ssllrm"</code>.</p>
</td></tr>
<tr><td><code id="project_+3A_...">...</code></td>
<td>
<p>Additional arguments.  Ignored in <code>project.x</code>.</p>
</td></tr>
<tr><td><code id="project_+3A_include">include</code></td>
<td>
<p>List of model terms to be included in the reduced
model space.  The <code>partial</code> and <code>offset</code> terms, if
present, are to be specified by <code>"partial"</code> and
<code>"offset"</code>, respectively.</p>
</td></tr>
<tr><td><code id="project_+3A_mesh">mesh</code></td>
<td>
<p>Flag indicating whether to return evaluations of the
projection.</p>
</td></tr>
<tr><td><code id="project_+3A_drop1">drop1</code></td>
<td>
<p>If TRUE, calculate <code>p&lt;-length(include)</code> projections
with <code>include[-i]</code>, <code>i=1,...,p</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The entropy KL(fit0,null) can be decomposed as the sum of
KL(fit0,fit1) and KL(fit1,null), where fit0 is the fit to be
projected, fit1 is the projection in the reduced model space, and
null is the constant fit.  The ratio KL(fit0,fit1)/KL(fit0,null)
serves as a diagnostic of the feasibility of the reduced model.
</p>
<p>For regression fits, smoothness safe-guard is used to prevent
interpolation, and KL(fit0,fit1)+KL(fit1,null) may not match
KL(fit0,null) perfectly.
</p>
<p>For mixed-effect models from <code>ssanova</code> and <code>gssanova</code>,
the estimated random effects are treated as offset.
</p>


<h3>Value</h3>

<p>The functions return a list consisting of the following elements.
</p>
<table>
<tr><td><code>ratio</code></td>
<td>
<p>KL(fit0,fit1)/KL(fit0,null); the smaller the value, the
more feasible the reduced model is.</p>
</td></tr>
<tr><td><code>kl</code></td>
<td>
<p>KL(fit0,fit1).</p>
</td></tr>
</table>
<p>For regression fits, the list also contains the following element.
</p>
<table>
<tr><td><code>check</code></td>
<td>
<p>KL(fit0,fit1)/KL(fit0,null)+KL(fit1,null)/KL(fit0,null);
a value closer to 1 is preferred.</p>
</td></tr>
</table>
<p>For density and hazard fits, the list may contain the following
optional element.
</p>
<table>
<tr><td><code>mesh</code></td>
<td>
<p>The evaluations of the projection.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>project.ssden1</code>, <code>project.sscden1</code>, and
<code>project.sshzd1</code> calculates square error projections.
</p>


<h3>References</h3>

<p>Gu, C. (2004), Model diagnostics for smoothing spline ANOVA models.
<em>The Canadian Journal of Statistics</em>, <b>32</b>, 347&ndash;358.
</p>


<h3>See Also</h3>

<p>Fitting functions <code><a href="#topic+ssanova">ssanova</a></code>, <code><a href="#topic+gssanova">gssanova</a></code>,
<code><a href="#topic+ssden">ssden</a></code>, <code><a href="#topic+sshzd">sshzd</a></code>, and <code><a href="#topic+sshzd1">sshzd1</a></code>.
</p>

<hr>
<h2 id='rkpk'>Numerical Engine for ssanova and gssanova</h2><span id='topic+sspreg1'></span><span id='topic+mspreg1'></span><span id='topic+sspreg91'></span><span id='topic+mspreg91'></span><span id='topic+sspngreg'></span><span id='topic+mspngreg'></span><span id='topic+ngreg'></span><span id='topic+ngreg1'></span><span id='topic+regaux'></span><span id='topic+ngreg.proj'></span>

<h3>Description</h3>

<p>Perform numerical calculations for the <code><a href="#topic+ssanova">ssanova</a></code> and
<code><a href="#topic+gssanova">gssanova</a></code> suites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sspreg1(s, r, q, y, wt, method, alpha, varht, random)
mspreg1(s, r, id.basis, y, wt, method, alpha, varht, random, skip.iter)
ngreg1(family, s, r, id.basis, y, wt, offset, method, varht, alpha, nu, random, skip.iter)

sspreg91(s, r, q, y, cov, method, alpha, varht)
mspreg91(s, r, id.basis, y, cov, method, alpha, varht, skip.iter)

sspngreg(family, s, r, q, y, wt, offset, alpha, nu, random)
mspngreg(family, s, r, id.basis, y, wt, offset, alpha, nu, random, skip.iter)
ngreg(dc, family, sr, q, y, wt, offset, nu, alpha)

regaux(s, r, q, nlambda, fit)

ngreg.proj(dc, family, sr, q, y0, wt, offset, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rkpk_+3A_family">family</code></td>
<td>
<p>Description of the error distribution.  Supported
are exponential families <code>"binomial"</code>, <code>"poisson"</code>,
<code>"Gamma"</code>, and <code>"nbinomial"</code>.  Also supported are
accelerated life model families <code>"weibull"</code>,
<code>"lognorm"</code>, and <code>"loglogis"</code>.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_s">s</code></td>
<td>
<p>Unpenalized terms evaluated at data points.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_r">r</code></td>
<td>
<p>Basis of penalized terms evaluated at data points.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_q">q</code></td>
<td>
<p>Penalty matrix.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="rkpk_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_wt">wt</code></td>
<td>
<p>Model weights.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_cov">cov</code></td>
<td>
<p>Input for covariance function for correlated data.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_offset">offset</code></td>
<td>
<p>Model offset.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_method">method</code></td>
<td>
<p><code>"v"</code> for GCV, <code>"m"</code> for GML, or <code>"u"</code>
for Mallows' CL.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_alpha">alpha</code></td>
<td>
<p>Parameter modifying GCV or Mallows' CL scores for
smoothing parameter selection.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_nu">nu</code></td>
<td>
<p>Optional argument for future support of nbinomial,
weibull, lognorm, and loglogis families.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_varht">varht</code></td>
<td>
<p>External variance estimate needed for <code>method="u"</code>.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_random">random</code></td>
<td>
<p>Input for parametric random effects in nonparametric
mixed-effect models.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_nlambda">nlambda</code></td>
<td>
<p>Smoothing parameter in effect.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_fit">fit</code></td>
<td>
<p>Fitted model.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_dc">dc</code></td>
<td>
<p>Coefficients of fits.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_sr">sr</code></td>
<td>
<p><code>cbind(s,r)</code>.</p>
</td></tr>
<tr><td><code id="rkpk_+3A_y0">y0</code></td>
<td>
<p>Components of the fit to be projected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sspreg1</code> is used by <code><a href="#topic+ssanova">ssanova</a></code> to compute
regression estimates with a single smoothing parameter.
<code>mspreg1</code> is used by <code><a href="#topic+ssanova">ssanova</a></code> to compute
regression estimates with multiple smoothing parameters.
</p>
<p><code>ssngpreg</code> is used by <code><a href="#topic+gssanova">gssanova</a></code> to compute
non-Gaussian regression estimates with a single smoothing
parameter.  <code>mspngreg</code> is used by <code><a href="#topic+gssanova">gssanova</a></code> to
compute non-Gaussian regression estimates with multiple smoothing
parameters.  <code>ngreg</code> is used by <code>ssngpreg</code> and
<code>mspngreg</code> to perform Newton iteration with fixed smoothing
parameters and to calculate cross-validation scores on return.
</p>
<p><code>regaux</code> is used by <code>sspreg1</code>, <code>mspreg1</code>,
<code>ssngpreg</code>, and <code>mspngreg</code> to obtain auxiliary information
needed by <code>predict.ssanova</code> for standard error calculation.
</p>
<p><code>ngreg.proj</code> is used by <code><a href="#topic+project.gssanova">project.gssanova</a></code> to
calculate the Kullback-Leibler projection for non-Gaussian
regression.
</p>


<h3>References</h3>

<p>Gu, C. (1992), Cross validating non Gaussian data.  <em>Journal of
Computational and Graphical Statistics</em>, <b>1</b>, 169&ndash;179. 
</p>
<p>Kim, Y.-J. and Gu, C. (2004), Smoothing spline Gaussian regression:
more scalable computation via efficient approximation.
<em>Journal of the Royal Statistical Society, Ser. B</em>, <b>66</b>,
337&ndash;356.
</p>

<hr>
<h2 id='rkpk0'>Interface to RKPACK</h2><span id='topic+sspreg0'></span><span id='topic+mspreg0'></span><span id='topic+getcrdr'></span><span id='topic+getsms'></span><span id='topic+sspregpoi'></span><span id='topic+mspregpoi'></span>

<h3>Description</h3>

<p>Call RKPACK routines for numerical calculations concerning the
<code><a href="#topic+ssanova0">ssanova0</a></code> and <code><a href="#topic+gssanova0">gssanova0</a></code> suites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sspreg0(s, q, y, method="v", varht=1)
mspreg0(s, q, y, method="v", varht=1, prec=1e-7, maxiter=30)
sspregpoi(family, s, q, y, wt, offset, method="u", varht=1, nu, prec=1e-7, maxiter=30)
mspregpoi(family, s, q, y, wt, offset, method="u", varht=1, nu, prec=1e-7, maxiter=30)
getcrdr(obj, r)
getsms(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rkpk0_+3A_s">s</code></td>
<td>
<p>Design matrix of unpenalized terms.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_q">q</code></td>
<td>
<p>Penalty matrices of penalized terms.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_y">y</code></td>
<td>
<p>Model response.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_method">method</code></td>
<td>
<p>Method for smoothing parameter selection.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_varht">varht</code></td>
<td>
<p>Assumed dispersion parameter, needed only for
<code>method="u"</code>.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for iterations.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_family">family</code></td>
<td>
<p>Error family.</p>
</td></tr>	
<tr><td><code id="rkpk0_+3A_wt">wt</code></td>
<td>
<p>Model weights.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_offset">offset</code></td>
<td>
<p>Model offset.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_obj">obj</code></td>
<td>
<p>Object returned from a call to <code>sspreg</code>,
<code>mspreg</code>, <code>sspregpoi</code>, or <code>mspregpoi</code>.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_nu">nu</code></td>
<td>
<p>Optional argument for nbinomial, weibull, lognorm, and
loglogis families.</p>
</td></tr>
<tr><td><code id="rkpk0_+3A_r">r</code></td>
<td>
<p>Inputs for standard error calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sspreg0</code> is used by <code><a href="#topic+ssanova0">ssanova0</a></code> to fit Gaussian
models with a single smoothing parameter.  <code>mspreg0</code> is used to
fit Gaussian models with multiple smoothing parameters.
</p>
<p><code>sspregpoi</code> is used by <code><a href="#topic+gssanova0">gssanova0</a></code> to fit non
Gaussian models with a single smoothing parameter.  <code>mspregpoi</code>
is used to fit non Gaussian models with multiple smoothing
parameters.
</p>
<p><code>getcrdr</code> and <code>getsms</code> are used by
<code><a href="#topic+predict.ssanova0">predict.ssanova0</a></code> to calculate standard errors of the
fitted terms.
</p>


<h3>References</h3>

<p>Gu, C. (1989), RKPACK and its applications: Fitting smoothing spline
models.  In <em>ASA Proceedings of Statistical Computing Section</em>,
pp. 42&ndash;51.
</p>
<p>Gu, C. (1992), Cross validating non Gaussian data.  <em>Journal of
Computational and Graphical Statistics</em>, <b>1</b>, 169&ndash;179. 
</p>

<hr>
<h2 id='Sachs'>Protein Expression in Human Immune System Cells</h2><span id='topic+Sachs'></span>

<h3>Description</h3>

<p>Data concerning protein expression levels in human immune system
cells under stimulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Sachs)</code></pre>


<h3>Format</h3>

<p>A data frame containing 7466 cells, with flow cytometry measurements
of 11 phosphorylated proteins and phospholipids, on the <code>log10</code>
scale of the original.
</p>

<table>
<tr>
 <td style="text-align: left;">
        <code>praf</code> </td><td style="text-align: left;"> Raf phosphorylated at S259.</td>
</tr>
<tr>
 <td style="text-align: left;">
        <code>pmek</code> </td><td style="text-align: left;"> Mek1/mek2 phosphorylated at S217/S221.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>plcg</code> </td><td style="text-align: left;"> Phosphorylation of phospholipase <code class="reqn">C-\gamma</code>
	on Y783.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>pip2</code> </td><td style="text-align: left;"> Phophatidylinositol 4,5-biphosphate.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>pip3</code> </td><td style="text-align: left;"> Phophatidylinositol 3,4,5-triphosphate.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>p44.42</code> </td><td style="text-align: left;"> Erk1/erk2 phosphorylated at T202/Y204.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>pakts473</code> </td><td style="text-align: left;"> AKT phosphorylated at S473.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>pka</code> </td><td style="text-align: left;"> Phosphorylation of of protein kinase A
	substrates on 3 sites.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>pkc</code> </td><td style="text-align: left;"> Phosphorylation of of protein kinase C
	substrates on S660.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>p38</code> </td><td style="text-align: left;"> Erk1/erk2 phosphorylated at T180/Y182.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>pjnk</code> </td><td style="text-align: left;"> Erk1/erk2 phosphorylated at T183/Y185.</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Sachs, K., Perez, O., Pe'er, D., Lauffenburger, D. A., and Nolan,
G. P. (2005), Causal protein-signaling networks derived from
multiparameter single-cell data. <em>Science</em>, <b>308 (5732)</b>,
523&ndash;529.
</p>

<hr>
<h2 id='smolyak'>Generating Smolyak Cubature</h2><span id='topic+smolyak.quad'></span><span id='topic+smolyak.size'></span>

<h3>Description</h3>

<p>Generate delayed Smolyak cubatures using C routines modified from
<code>smolyak.c</code> found in Knut Petras' SMOLPACK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smolyak.quad(d, k)

smolyak.size(d, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smolyak_+3A_d">d</code></td>
<td>
<p>Dimension of unit cube.</p>
</td></tr>
<tr><td><code id="smolyak_+3A_k">k</code></td>
<td>
<p>Depth of algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>smolyak.quad</code> returns a list object with the following
elements.
</p>
<table>
<tr><td><code>pt</code></td>
<td>
<p>Quadrature nodes in rows of matrix.</p>
</td></tr>
<tr><td><code>wt</code></td>
<td>
<p>Quadrature weights.</p>
</td></tr>
</table>
<p><code>smolyak.size</code> returns an integer.
</p>

<hr>
<h2 id='ssanova'>Fitting Smoothing Spline ANOVA Models</h2><span id='topic+ssanova'></span>

<h3>Description</h3>

<p>Fit smoothing spline ANOVA models in Gaussian regression.  The
symbolic model specification via <code>formula</code> follows the same
rules as in <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssanova(formula, type=NULL, data=list(), weights, subset, offset,
        na.action=na.omit, partial=NULL, method="v", alpha=1.4,
        varht=1, id.basis=NULL, nbasis=NULL, seed=NULL, random=NULL,
        skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssanova_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to be used in the
fitting process.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_offset">offset</code></td>
<td>
<p>Optional offset term with known parameter 1.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_partial">partial</code></td>
<td>
<p>Optional symbolic description of parametric terms in
partial spline models.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_method">method</code></td>
<td>
<p>Method for smoothing parameter selection.  Supported
are <code>method="v"</code> for GCV, <code>method="m"</code> for GML (REML),
and <code>method="u"</code> for Mallows' CL.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_alpha">alpha</code></td>
<td>
<p>Parameter modifying GCV or Mallows' CL; larger absolute
values yield smoother fits; negative value invokes a stable and
more accurate GCV/CL evaluation algorithm but may take two to
five times as long.  Ignored when <code>method="m"</code> are
specified.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_varht">varht</code></td>
<td>
<p>External variance estimate needed for
<code>method="u"</code>.  Ignored when <code>method="v"</code> or
<code>method="m"</code> are specified.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_id.basis">id.basis</code></td>
<td>
<p>Index designating selected &quot;knots&quot;.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be selected.  Ignored when
<code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots&quot;.
Ignored when <code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_random">random</code></td>
<td>
<p>Input for parametric random effects in nonparametric
mixed-effect models.  See <code><a href="#topic+mkran">mkran</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssanova_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See notes on skipping theta
iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model specification via <code>formula</code> is intuitive.  For
example, <code>y~x1*x2</code> yields a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	y = C + f_{1}(x1) + f_{2}(x2) + f_{12}(x1,x2) + e
    </code>
</p>

<p>with the terms denoted by <code>"1"</code>, <code>"x1"</code>, <code>"x2"</code>, and
<code>"x1:x2"</code>.
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p>A subset of the observations are selected as &quot;knots.&quot;  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
&quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>
<p>Using <code class="reqn">q</code> &quot;knots,&quot; <code>ssanova</code> calculates an approximate
solution to the penalized least squares problem using algorithms of
the order <code class="reqn">O(nq^{2})</code>, which for <code class="reqn">q&lt;&lt;n</code> scale better than
the <code class="reqn">O(n^{3})</code> algorithms of <code><a href="#topic+ssanova0">ssanova0</a></code>.  For the
exact solution, one may set <code class="reqn">q=n</code> in <code>ssanova</code>, but
<code><a href="#topic+ssanova0">ssanova0</a></code> would be much faster.
</p>


<h3>Value</h3>

<p><code>ssanova</code> returns a list object of class <code>"ssanova"</code>.
</p>
<p>The method <code><a href="#topic+summary.ssanova">summary.ssanova</a></code> can be used to obtain
summaries of the fits.  The method <code><a href="#topic+predict.ssanova">predict.ssanova</a></code> can
be used to evaluate the fits at arbitrary points along with standard
errors.  The method <code><a href="#topic+project.ssanova">project.ssanova</a></code> can be used to
calculate the Kullback-Leibler projection for model selection.  The
methods <code><a href="#topic+residuals.ssanova">residuals.ssanova</a></code> and
<code><a href="#topic+fitted.ssanova">fitted.ssanova</a></code> extract the respective traits
from the fits.
</p>


<h3>Skipping Theta Iteration</h3>

<p>For the selection of multiple smoothing parameters,
<code><a href="stats.html#topic+nlm">nlm</a></code> is used to minimize the selection criterion such
as the GCV score.  When the number of smoothing parameters is large,
the process can be time-consuming due to the great amount of
function evaluations involved.
</p>
<p>The starting values for the <code>nlm</code> iteration are obtained using
Algorith 3.2 in Gu and Wahba (1991).  These starting values usually
yield good estimates themselves, leaving the subsequent quasi-Newton
iteration to pick up the &quot;last 10%&quot; performance with extra effort
many times of the initial one.  Thus, it is often a good idea to
skip the iteration by specifying <code>skip.iter=TRUE</code>, especially
in high-dimensions and/or with multi-way interactions.
</p>
<p><code>skip.iter=TRUE</code> could be made the default in future releases.
</p>


<h3>Note</h3>

<p>To use GCV and Mallows' CL unmodified, set <code>alpha=1</code>.
</p>
<p>For simpler models and moderate sample sizes, the exact solution of
<code><a href="#topic+ssanova0">ssanova0</a></code> can be faster.
</p>
<p>The results may vary from run to run. For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>
<p>In <em>gss</em> versions earlier than 1.0, <code>ssanova</code> was under
the name <code>ssanova1</code>.
</p>


<h3>References</h3>

<p>Wahba, G. (1990), <em>Spline Models for Observational Data</em>.
Philadelphia: SIAM.
</p>
<p>Gu, C. and Wahba, G. (1991), Minimizing GCV/GML scores with multiple
smoothing parameters via the Newton method.  <em>SIAM Journal on
Scientific and Statistical Computing</em>, <b>12</b>, 383&ndash;398.
</p>
<p>Kim, Y.-J. and Gu, C. (2004), Smoothing spline Gaussian regression:
more scalable computation via efficient approximation.
<em>Journal of the Royal Statistical Society, Ser. B</em>, <b>66</b>,
337&ndash;356.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit a cubic spline
x &lt;- runif(100); y &lt;- 5 + 3*sin(2*pi*x) + rnorm(x)
cubic.fit &lt;- ssanova(y~x)
## Obtain estimates and standard errors on a grid
new &lt;- data.frame(x=seq(min(x),max(x),len=50))
est &lt;- predict(cubic.fit,new,se=TRUE)
## Plot the fit and the Bayesian confidence intervals
plot(x,y,col=1); lines(new$x,est$fit,col=2)
lines(new$x,est$fit+1.96*est$se,col=3)
lines(new$x,est$fit-1.96*est$se,col=3)
## Clean up
## Not run: rm(x,y,cubic.fit,new,est)
dev.off()
## End(Not run)

## Fit a tensor product cubic spline
data(nox)
nox.fit &lt;- ssanova(log10(nox)~comp*equi,data=nox)
## Fit a spline with cubic and nominal marginals
nox$comp&lt;-as.factor(nox$comp)
nox.fit.n &lt;- ssanova(log10(nox)~comp*equi,data=nox)
## Fit a spline with cubic and ordinal marginals
nox$comp&lt;-as.ordered(nox$comp)
nox.fit.o &lt;- ssanova(log10(nox)~comp*equi,data=nox)
## Clean up
## Not run: rm(nox,nox.fit,nox.fit.n,nox.fit.o)
</code></pre>

<hr>
<h2 id='ssanova0'>Fitting Smoothing Spline ANOVA Models</h2><span id='topic+ssanova0'></span>

<h3>Description</h3>

<p>Fit smoothing spline ANOVA models in Gaussian regression.  The
symbolic model specification via <code>formula</code> follows the same
rules as in <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssanova0(formula, type=NULL, data=list(), weights, subset,
         offset, na.action=na.omit, partial=NULL, method="v",
         varht=1, prec=1e-7, maxiter=30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssanova0_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to be used in the
fitting process.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_offset">offset</code></td>
<td>
<p>Optional offset term with known parameter 1.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_partial">partial</code></td>
<td>
<p>Optional symbolic description of parametric terms in
partial spline models.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_method">method</code></td>
<td>
<p>Method for smoothing parameter selection.  Supported
are <code>method="v"</code> for GCV, <code>method="m"</code> for GML (REML),
and <code>method="u"</code> for Mallow's CL.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_varht">varht</code></td>
<td>
<p>External variance estimate needed for
<code>method="u"</code>.  Ignored when <code>method="v"</code> or
<code>method="m"</code> are specified.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_prec">prec</code></td>
<td>
<p>Precision requirement in the iteration for multiple
smoothing parameter selection.  Ignored when only one smoothing
parameter is involved.</p>
</td></tr>
<tr><td><code id="ssanova0_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for multiple
smoothing parameter selection.  Ignored when only one smoothing
parameter is involved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model specification via <code>formula</code> is intuitive.  For
example, <code>y~x1*x2</code> yields a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	y = C + f_{1}(x1) + f_{2}(x2) + f_{12}(x1,x2) + e
    </code>
</p>

<p>with the terms denoted by <code>"1"</code>, <code>"x1"</code>, <code>"x2"</code>, and
<code>"x1:x2"</code>.
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p><code>ssanova0</code> and the affiliated methods provide a front end to
RKPACK, a collection of RATFOR routines for nonparametric regression
via the penalized least squares.  The algorithms implemented in
RKPACK are of the order <code class="reqn">O(n^{3})</code>.
</p>


<h3>Value</h3>

<p><code>ssanova0</code> returns a list object of class
<code>c("ssanova0","ssanova")</code>.
</p>
<p>The method <code><a href="#topic+summary.ssanova0">summary.ssanova0</a></code> can be used to obtain
summaries of the fits.  The method <code><a href="#topic+predict.ssanova0">predict.ssanova0</a></code>
can be used to evaluate the fits at arbitrary points along with
standard errors.  The methods <code><a href="#topic+residuals.ssanova">residuals.ssanova</a></code> and
<code><a href="#topic+fitted.ssanova">fitted.ssanova</a></code> extract the respective traits from the
fits.
</p>


<h3>Note</h3>

<p>For complex models and large sample sizes, the approximate solution
of <code><a href="#topic+ssanova">ssanova</a></code> can be faster.
</p>
<p>The method <code><a href="#topic+project">project</a></code> is not implemented for
<code>ssanova0</code>, nor is the mixed-effect model support through
<code><a href="#topic+mkran">mkran</a></code>.
</p>
<p>In <em>gss</em> versions earlier than 1.0, <code>ssanova0</code> was under
the name <code>ssanova</code>.
</p>


<h3>References</h3>

<p>Wahba, G. (1990), <em>Spline Models for Observational Data</em>.
Philadelphia: SIAM.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit a cubic spline
x &lt;- runif(100); y &lt;- 5 + 3*sin(2*pi*x) + rnorm(x)
cubic.fit &lt;- ssanova0(y~x,method="m")
## Obtain estimates and standard errors on a grid
new &lt;- data.frame(x=seq(min(x),max(x),len=50))
est &lt;- predict(cubic.fit,new,se=TRUE)
## Plot the fit and the Bayesian confidence intervals
plot(x,y,col=1); lines(new$x,est$fit,col=2)
lines(new$x,est$fit+1.96*est$se,col=3)
lines(new$x,est$fit-1.96*est$se,col=3)
## Clean up
## Not run: rm(x,y,cubic.fit,new,est)
dev.off()
## End(Not run)

## Fit a tensor product cubic spline
data(nox)
nox.fit &lt;- ssanova0(log10(nox)~comp*equi,data=nox)
## Fit a spline with cubic and nominal marginals
nox$comp&lt;-as.factor(nox$comp)
nox.fit.n &lt;- ssanova0(log10(nox)~comp*equi,data=nox)
## Fit a spline with cubic and ordinal marginals
nox$comp&lt;-as.ordered(nox$comp)
nox.fit.o &lt;- ssanova0(log10(nox)~comp*equi,data=nox)
## Clean up
## Not run: rm(nox,nox.fit,nox.fit.n,nox.fit.o)
</code></pre>

<hr>
<h2 id='ssanova9'>Fitting Smoothing Spline ANOVA Models with Correlated Data</h2><span id='topic+ssanova9'></span><span id='topic+para.arma'></span>

<h3>Description</h3>

<p>Fit smoothing spline ANOVA models with correlated Gaussian data.
The symbolic model specification via <code>formula</code> follows the same
rules as in <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssanova9(formula, type=NULL, data=list(), subset, offset,
         na.action=na.omit, partial=NULL, method="v", alpha=1.4,
         varht=1, id.basis=NULL, nbasis=NULL, seed=NULL, cov,
         skip.iter=FALSE)

para.arma(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssanova9_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_offset">offset</code></td>
<td>
<p>Optional offset term with known parameter 1.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_partial">partial</code></td>
<td>
<p>Optional symbolic description of parametric terms in
partial spline models.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_method">method</code></td>
<td>
<p>Method for smoothing parameter selection.  Supported
are <code>method="v"</code> for V, <code>method="m"</code> for M, and
<code>method="u"</code> for U; see the reference for definitions of U,
V, and M.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_alpha">alpha</code></td>
<td>
<p>Parameter modifying V or U; larger absolute values
yield smoother fits.  Ignored when <code>method="m"</code> are
specified.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_varht">varht</code></td>
<td>
<p>External variance estimate needed for
<code>method="u"</code>.  Ignored when <code>method="v"</code> or
<code>method="m"</code> are specified.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_id.basis">id.basis</code></td>
<td>
<p>Index designating selected &quot;knots&quot;.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be selected.  Ignored when
<code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots&quot;.
Ignored when <code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_cov">cov</code></td>
<td>
<p>Input for covariance functions.  See <code><a href="#topic+mkcov">mkcov</a></code>
for details.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See notes on skipping theta
iteration.</p>
</td></tr>
<tr><td><code id="ssanova9_+3A_fit">fit</code></td>
<td>
<p><code>ssanova9</code> fit with ARMA error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model specification via <code>formula</code> is intuitive.  For
example, <code>y~x1*x2</code> yields a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	y = C + f_{1}(x1) + f_{2}(x2) + f_{12}(x1,x2) + e
    </code>
</p>

<p>with the terms denoted by <code>"1"</code>, <code>"x1"</code>, <code>"x2"</code>, and
<code>"x1:x2"</code>.
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p>A subset of the observations are selected as &quot;knots.&quot;  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
&quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>
<p>Using <code class="reqn">q</code> &quot;knots,&quot; <code>ssanova</code> calculates an approximate
solution to the penalized least squares problem using algorithms of
the order <code class="reqn">O(nq^{2})</code>, which for <code class="reqn">q&lt;&lt;n</code> scale better than
the <code class="reqn">O(n^{3})</code> algorithms of <code><a href="#topic+ssanova0">ssanova0</a></code>.  For the
exact solution, one may set <code class="reqn">q=n</code> in <code>ssanova</code>, but
<code><a href="#topic+ssanova0">ssanova0</a></code> would be much faster.
</p>


<h3>Value</h3>

<p><code>ssanova9</code> returns a list object of class
<code>c("ssanova9","ssanova")</code>.
</p>
<p>The method <code><a href="#topic+summary.ssanova9">summary.ssanova9</a></code> can be used to obtain
summaries of the fits.  The method <code><a href="#topic+predict.ssanova">predict.ssanova</a></code> can
be used to evaluate the fits at arbitrary points along with standard
errors.  The method <code><a href="#topic+project.ssanova9">project.ssanova9</a></code> can be used to
calculate the Kullback-Leibler projection for model selection.  The
methods <code><a href="#topic+residuals.ssanova">residuals.ssanova</a></code> and
<code><a href="#topic+fitted.ssanova">fitted.ssanova</a></code> extract the respective traits from the
fits.
</p>
<p><code>para.arma</code> returns the fitted ARMA coefficients for
<code>cov=list("arma",c(p,q))</code> in the call to <code>ssanova9</code>.
</p>


<h3>Skipping Theta Iteration</h3>

<p>For the selection of multiple smoothing parameters,
<code><a href="stats.html#topic+nlm">nlm</a></code> is used to minimize the selection criterion such
as the GCV score.  When the number of smoothing parameters is large,
the process can be time-consuming due to the great amount of
function evaluations involved.
</p>
<p>The starting values for the <code>nlm</code> iteration are obtained using
Algorith 3.2 in Gu and Wahba (1991).  These starting values usually
yield good estimates themselves, leaving the subsequent quasi-Newton
iteration to pick up the &quot;last 10%&quot; performance with extra effort
many times of the initial one.  Thus, it is often a good idea to
skip the iteration by specifying <code>skip.iter=TRUE</code>, especially
in high-dimensions and/or with multi-way interactions.
</p>
<p><code>skip.iter=TRUE</code> could be made the default in future releases.
</p>


<h3>Note</h3>

<p>The results may vary from run to run. For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>References</h3>

<p>Han, C. and Gu, C. (2008), Optimal smoothing with correlated data,
<em>Sankhya</em>, <b>70-A</b>, 38&ndash;72.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(100); y &lt;- 5 + 3*sin(2*pi*x) + rnorm(x)
## independent fit
fit &lt;- ssanova9(y~x,cov=list("known",diag(1,100)))
## AR(1) fit
fit &lt;- ssanova9(y~x,cov=list("arma",c(1,0)))
para.arma(fit)
## MA(1) fit
e &lt;- rnorm(101); e &lt;- e[-1]-.5*e[-101]
x &lt;- runif(100); y &lt;- 5 + 3*sin(2*pi*x) + e
fit &lt;- ssanova9(y~x,cov=list("arma",c(0,1)))
para.arma(fit)
## Clean up
## Not run: rm(x,y,e,fit)
</code></pre>

<hr>
<h2 id='sscden'>Estimating Conditional Probability Density Using Smoothing
Splines</h2><span id='topic+sscden'></span><span id='topic+sscden1'></span>

<h3>Description</h3>

<p>Estimate conditional probability densities using smoothing spline
ANOVA models.  The symbolic model specification via <code>formula</code>
follows the same rules as in <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sscden(formula, response, type=NULL, data=list(), weights, subset,
       na.action=na.omit, alpha=1.4, id.basis=NULL, nbasis=NULL,
       seed=NULL, ydomain=as.list(NULL), yquad=NULL, prec=1e-7,
       maxiter=30, skip.iter=FALSE)

sscden1(formula, response, type=NULL, data=list(), weights, subset,
        na.action=na.omit, alpha=1.4, id.basis=NULL, nbasis=NULL,
        seed=NULL, rho=list("xy"), ydomain=as.list(NULL), yquad=NULL,
        prec=1e-7, maxiter=30, skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sscden_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="sscden_+3A_response">response</code></td>
<td>
<p>Formula listing response variables.</p>
</td></tr>
<tr><td><code id="sscden_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="sscden_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="sscden_+3A_weights">weights</code></td>
<td>
<p>Optional vector of counts for duplicated data.</p>
</td></tr>
<tr><td><code id="sscden_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="sscden_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="sscden_+3A_alpha">alpha</code></td>
<td>
<p>Parameter defining cross-validation scores for
smoothing parameter selection.</p>
</td></tr>
<tr><td><code id="sscden_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="sscden_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be used.  Ignored when
<code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sscden_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots.&quot;
Ignored when <code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sscden_+3A_ydomain">ydomain</code></td>
<td>
<p>Data frame specifying marginal support of conditional
density.</p>
</td></tr>
<tr><td><code id="sscden_+3A_yquad">yquad</code></td>
<td>
<p>Quadrature for calculating integral on Y domain.
Mandatory if response variables other than factors or numerical
vectors are involved.</p>
</td></tr>
<tr><td><code id="sscden_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td></tr>
<tr><td><code id="sscden_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td></tr>
<tr><td><code id="sscden_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code><a href="#topic+ssanova">ssanova</a></code> for
notes on skipping theta iteration.</p>
</td></tr>
<tr><td><code id="sscden_+3A_rho">rho</code></td>
<td>
<p>rho function needed for sscden1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is specified via <code>formula</code> and <code>response</code>, where
<code>response</code> lists the response variables.  For example,
<code>sscden(~y*x,~y)</code> prescribe a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
        log f(y|x) = g_{y}(y) + g_{xy}(x,y) + C(x)
    </code>
</p>

<p>with the terms denoted by <code>"y"</code>, <code>"y:x"</code>; the term(s) not
involving response(s) are removed and the constant <code>C(x)</code> is
determined by the fact that a conditional density integrates to one
on the <code>y</code> axis.  <code>sscden1</code> does keep terms not involving
response(s) during estimation, although those terms cancel out when
one evaluates the estimated conditional density.    
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p>A subset of the observations are selected as &quot;knots.&quot;  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
&quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>


<h3>Value</h3>

<p><code>sscden</code> returns a list object of class <code>"sscden"</code>.
<code>sscden1</code> returns a list object of class
<code>c("sscden1","sscden")</code>.
</p>
<p><code><a href="#topic+dsscden">dsscden</a></code> and <code><a href="#topic+cdsscden">cdsscden</a></code> can be used to
evaluate the estimated conditional density <code class="reqn">f(y|x)</code> and
<code class="reqn">f(y1|x,y2)</code>; <code><a href="#topic+psscden">psscden</a></code>, <code><a href="#topic+qsscden">qsscden</a></code>,
<code><a href="#topic+cpsscden">cpsscden</a></code>, and <code><a href="#topic+cqsscden">cqsscden</a></code> can be used to
evaluate conditional cdf and quantiles.  The methods
<code><a href="#topic+project.sscden">project.sscden</a></code> or <code><a href="#topic+project.sscden1">project.sscden1</a></code> can
be used to calculate the Kullback-Leibler or square-error
projections for model selection.
</p>


<h3>Note</h3>

<p>Default quadrature on the Y domain will be constructed for numerical
vectors on a hyper cube, then outer product with factor levels will
be taken if factors are involved.  The sides of the hyper cube are
specified by <code>ydomain</code>; for <code>ydomain$y</code> missing, the default
is <code>c(min(y),max(y))+c(-1,1)*(max(y)-mimn(y))*.05</code>.
</p>
<p>On a 1-D interval, the quadrature is the 200-point Gauss-Legendre
formula returned from <code><a href="#topic+gauss.quad">gauss.quad</a></code>.  For multiple
numerical vectors, delayed Smolyak cubatures from
<code><a href="#topic+smolyak.quad">smolyak.quad</a></code> are used on cubes with the marginals
properly transformed; see Gu and Wang (2003) for the marginal
transformations.
</p>
<p>The results may vary from run to run.  For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>
<p>For reasonable execution time in high dimensions, set
<code>skip.iter=TRUE</code>.
</p>


<h3>References</h3>

<p>Gu, C. (1995), Smoothing spline density estimation: Conditional
distribution.  <em>Statistica Sinica</em>, <b>5</b>, 709&ndash;726.
Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(penny); set.seed(5732)
fit &lt;- sscden1(~year*mil,~mil,data=penny,
              ydomain=data.frame(mil=c(49,61)))
yy &lt;- 1944+(0:92)/2
quan &lt;- qsscden(fit,c(.05,.25,.5,.75,.95),
                data.frame(year=yy))
plot(penny$year+.1*rnorm(90),penny$mil,ylim=c(49,61))
for (i in 1:5) lines(yy,quan[i,])
## Clean up
## Not run: rm(penny,yy,quan)
</code></pre>

<hr>
<h2 id='sscomp'>Composition Estimation</h2><span id='topic+sscomp'></span><span id='topic+sscomp2'></span>

<h3>Description</h3>

<p>Estimate composition using multinomial counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sscomp(x,wt=rep(1,length(x)),alpha=1.4)

sscomp2(x,alpha=1.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sscomp_+3A_x">x</code></td>
<td>
<p>Numerical vector or matrix of multinomial counts.</p>
</td></tr>
<tr><td><code id="sscomp_+3A_wt">wt</code></td>
<td>
<p>Numerical vector of integration weights.</p>
</td></tr>
<tr><td><code id="sscomp_+3A_alpha">alpha</code></td>
<td>
<p>Parameter defining cross-validation score for smoothing
parameter selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sscomp</code> takes a vector <code>x</code> to estimate composition using
density estimation on a nominal discrete domain; zero counts must be
included in <code>x</code> to specify the domain.  <code>wt</code> mimicking the
shape of the unknown density could improve performance.
</p>
<p><code>sscomp2</code> takes a matrix <code>x</code>, collapses columns to
estimate a density using <code>sscomp</code>, then using that as <code>wt</code>
in further <code>sscomp</code> calls to estimate composition for each
column.
</p>


<h3>Value</h3>

<p><code>sscomp</code> returns a column of estimated probabilities.
</p>
<p><code>sscomp2</code> returns a matrix of estimated probabilities, matching
the input <code>x</code> in dimensions.
</p>


<h3>References</h3>

<p>Gu, C. (2020), Composition estimation via shrinkage.
<em>manuscript</em>.
</p>

<hr>
<h2 id='sscopu'>Estimating Copula Density Using Smoothing Splines</h2><span id='topic+sscopu'></span><span id='topic+sscopu2'></span>

<h3>Description</h3>

<p>Estimate copula densities using tensor-product cubic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sscopu(x, symmetry=FALSE, alpha=1.4, order=NULL, exclude=NULL,
       weights=NULL, id.basis=NULL, nbasis=NULL, seed=NULL,
       qdsz.depth=NULL, prec=1e-7, maxiter=30, skip.iter=dim(x)[2]!=2)

sscopu2(x, censoring=NULL, truncation=NULL, symmetry=FALSE, alpha=1.4,
        weights=NULL, id.basis=NULL, nbasis=NULL, seed=NULL, prec=1e-7,
        maxiter=30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sscopu_+3A_x">x</code></td>
<td>
<p>Matrix of observations on unit cubes.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_symmetry">symmetry</code></td>
<td>
<p>Flag indicating whether to enforce symmetry, or
invariance under coordinate permutation.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_order">order</code></td>
<td>
<p>Highest order of interaction terms in log density.
When <code>NULL</code>, it is set to <code>dim(x)[2]</code> internally.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_exclude">exclude</code></td>
<td>
<p>Pair(s) of marginals whose interactions to be
excluded in log density.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_alpha">alpha</code></td>
<td>
<p>Parameter defining cross-validation score for smoothing
parameter selection.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_weights">weights</code></td>
<td>
<p>Optional vector of bin-counts for histogram data.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="sscopu_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be used.  Ignored when
<code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots.&quot;
Ignored when <code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_qdsz.depth">qdsz.depth</code></td>
<td>
<p>Depth to be used in <code><a href="#topic+smolyak.quad">smolyak.quad</a></code> for
the generation of quadrature.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code><a href="#topic+ssanova">ssanova</a></code> for
notes on skipping theta iteration.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_censoring">censoring</code></td>
<td>
<p>Optional censoring indicator.</p>
</td></tr>
<tr><td><code id="sscopu_+3A_truncation">truncation</code></td>
<td>
<p>Optional truncation points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sscopu</code> is essentially <code><a href="#topic+ssden">ssden</a></code> applied to
observations on unit cubes.  Instead of variables in data frames,
the data are entered as a numerical matrix, and model complexity is
globally controlled by the highest order of interactions allowed in    log density.
</p>
<p><code>sscopu2</code> further restricts the domain to the unit square, but
allows for possible censoring and truncation.  With
<code>censoring==0,1,2,3</code>, a data point <code class="reqn">(x1,x2)</code> represents
exact observation, <code class="reqn">[0,x1]x{x2}</code>, <code class="reqn">{x1}x[0,x2]</code>, or
<code class="reqn">[0,x1]x[0,x2]</code>.  With <code>truncation</code> point <code class="reqn">(t1,t2)</code>,
the sample is taken from <code class="reqn">[0,t1]x[0,t2]</code> instead of the unit
square.
</p>
<p>With <code>symmetriy=TRUE</code>, one may enforce the interchangeability
of coordinates so that <code class="reqn">f(x1,x2)=f(x2,x1)</code>, say.
</p>
<p>When <code>(1,2)</code> is a row in <code>exclude</code>, interaction terms
involving coordinates <code>1</code> and <code>2</code> are excluded.
</p>


<h3>Value</h3>

<p><code>sscopu</code> and <code>sscopu2</code> return a list object of class
<code>"sscopu"</code>.  <code><a href="#topic+dsscopu">dsscopu</a></code> can be used to evaluate the
estimated copula density.  A &quot;copularization&quot; process is applied to
the estimated density by default so the resulting marginal densities
are guaranteed to be uniform.
</p>
<p><code><a href="#topic+cdsscopu">cdsscopu</a></code>, <code><a href="#topic+cpsscopu">cpsscopu</a></code>, and
<code><a href="#topic+cqsscopu">cqsscopu</a></code> can be used to evaluate 1-D conditional pdf,
cdf, and quantiles.
</p>


<h3>Note</h3>

<p>For reasonable execution time in higher dimensions, set
<code>skip.iter=TRUE</code> in calls to <code>sscopu</code>.
</p>
<p>When <code>"Newton iteration diverges"</code> in <code>sscopu</code>, try to use
a larger <code>qdsz.depth</code>; the default values for dimensions 2, 3,
4, 5, 6+ are 24, 14, 12, 11, 10.  To be sure a larger
<code>qdsz.depth</code> indeed makes difference, verify the cubature size
using <code><a href="#topic+smolyak.size">smolyak.size</a></code>.
</p>
<p>The results may vary from run to run.  For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>Author(s)</h3>

<p>Chong Gu, <a href="mailto:chong@stat.purdue.edu">chong@stat.purdue.edu</a></p>


<h3>References</h3>

<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2015), Hazard estimation with bivariate survival data and
copula density estimation. <em>Journal of Computational and
Graphical Statistics</em>, <b>24</b>, 1053-1073.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate 2-D data
x &lt;- matrix(runif(200),100,2)
## fit copula density
fit &lt;- sscopu(x)
## "same fit"
fit2 &lt;- sscopu2(x,id=fit$id)
## symmetric fit
fit.s &lt;- sscopu(x,sym=TRUE,id=fit$id)
## Not run: 
## Kendall's tau and Spearman's rho
summary(fit); summary(fit2); summary(fit.s)
## clean up
rm(x,fit,fit2,fit.s)

## End(Not run)
</code></pre>

<hr>
<h2 id='sscox'>Estimating Relative Risk Using Smoothing Splines</h2><span id='topic+sscox'></span>

<h3>Description</h3>

<p>Estimate relative risk using smoothing spline ANOVA models.  The
symbolic model specification via <code>formula</code> follows the same
rules as in <code><a href="stats.html#topic+lm">lm</a></code>, but with the response of a special
form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sscox(formula, type=NULL, data=list(), weights=NULL, subset,
      na.action=na.omit, partial=NULL, alpha=1.4, id.basis=NULL,
      nbasis=NULL, seed=NULL, random=NULL, prec=1e-7, maxiter=30,
      skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sscox_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit, where
the response is of the form <code>Surv(futime,status,start=0)</code>.</p>
</td></tr>
<tr><td><code id="sscox_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="sscox_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="sscox_+3A_weights">weights</code></td>
<td>
<p>Optional vector of counts for duplicated data.</p>
</td></tr>
<tr><td><code id="sscox_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="sscox_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="sscox_+3A_partial">partial</code></td>
<td>
<p>Optional symbolic description of parametric terms in
partial spline models.</p>
</td></tr>
<tr><td><code id="sscox_+3A_alpha">alpha</code></td>
<td>
<p>Parameter defining cross-validation score for smoothing
parameter selection.</p>
</td></tr>
<tr><td><code id="sscox_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="sscox_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be used.  Ignored when
<code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sscox_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots.&quot;
Ignored when <code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sscox_+3A_random">random</code></td>
<td>
<p>Input for parametric random effects (frailty) in
nonparametric mixed-effect models.  See <code><a href="#topic+mkran">mkran</a></code> for
details.</p>
</td></tr>
<tr><td><code id="sscox_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td></tr>
<tr><td><code id="sscox_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td></tr>
<tr><td><code id="sscox_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code><a href="#topic+ssanova">ssanova</a></code> for
notes on skipping theta iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A proportional hazard model is assumed, and the relative risk is
estimated via penalized partial likelihood.  The model specification
via <code>formula</code> is for the log relative risk.  For example,
<code>Suve(t,d)~u*v</code> prescribes a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	log f(u,v) = g_{u}(u) + g_{v}(v) + g_{u,v}(u,v)
    </code>
</p>

<p>with the terms denoted by <code>"u"</code>, <code>"v"</code>, and <code>"u:v"</code>;
relative risk is defined only up to a multiplicative constant, so
the constant term is not included in the model.
</p>
<p><code>sscox</code> takes standard right-censored lifetime data, with
possible left-truncation and covariates; in
<code>Surv(futime,status,start=0)~...</code>, <code>futime</code> is the  
follow-up time, <code>status</code> is the censoring indicator, and
<code>start</code> is the optional left-truncation time.
</p>
<p>Parallel to those in a <code><a href="#topic+ssanova">ssanova</a></code> object, the model terms
are sums of unpenalized and penalized terms.  Attached to every
penalized term there is a smoothing parameter, and the model
complexity is largely determined by the number of smoothing
parameters.
</p>
<p>The selection of smoothing parameters is through a cross-validation
mechanism designed for density estimation under biased sampling,
with a fudge factor <code>alpha</code>; <code>alpha=1</code> is &quot;unbiased&quot; for
the minimization of Kullback-Leibler loss but may yield severe
undersmoothing, whereas larger <code>alpha</code> yields smoother
estimates.
</p>
<p>A subset of the observations are selected as &quot;knots.&quot;  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
&quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>


<h3>Value</h3>

<p><code>sscox</code> returns a list object of class <code>"sscox"</code>.
</p>
<p>The method <code><a href="#topic+predict.sscox">predict.sscox</a></code> can be used to evaluate the
fits at arbitrary points along with standard errors.  The method
<code><a href="#topic+project.sscox">project.sscox</a></code> can be used to calculate the
Kullback-Leibler projection for model selection.
</p>


<h3>Note</h3>

<p>The function <code>Surv(futime,status,start=0)</code> is defined and
parsed inside <code>sscox</code>, not quite the same as the one in the
<code>survival</code> package.  The estimation is invariant of monotone
transformations of time.
</p>
<p>The results may vary from run to run.  For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>References</h3>

<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Relative Risk
data(stan)
fit.rr &lt;- sscox(Surv(futime,status)~age,data=stan)
est.rr &lt;- predict(fit.rr,data.frame(age=c(35,40)),se=TRUE)
## Base Hazard
risk &lt;- predict(fit.rr,stan)
fit.bh &lt;- sshzd(Surv(futime,status)~futime,data=stan,offset=log(risk))
tt &lt;- seq(0,max(stan$futime),length=51)
est.bh &lt;- hzdcurve.sshzd(fit.bh,tt,se=TRUE)
## Clean up
## Not run: rm(stan,fit.rr,est.rr,risk,fit.bh,tt,est.bh)
</code></pre>

<hr>
<h2 id='ssden'>Estimating Probability Density Using Smoothing Splines</h2><span id='topic+ssden'></span><span id='topic+ssden1'></span>

<h3>Description</h3>

<p>Estimate probability densities using smoothing spline ANOVA models.
The symbolic model specification via <code>formula</code> follows the same
rules as in <code><a href="stats.html#topic+lm">lm</a></code>, but with the response missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssden(formula, type=NULL, data=list(), alpha=1.4, weights=NULL,
      subset, na.action=na.omit, id.basis=NULL, nbasis=NULL, seed=NULL,
      domain=as.list(NULL), quad=NULL, qdsz.depth=NULL, bias=NULL,
      prec=1e-7, maxiter=30, skip.iter=FALSE)

ssden1(formula, type=NULL, data=list(), alpha=1.4, weights=NULL,
       subset, na.action=na.omit, id.basis=NULL, nbasis=NULL, seed=NULL,
       domain=as.list(NULL), quad=NULL, prec=1e-7, maxiter=30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssden_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="ssden_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssden_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="ssden_+3A_alpha">alpha</code></td>
<td>
<p>Parameter defining cross-validation score for smoothing
parameter selection.</p>
</td></tr>
<tr><td><code id="ssden_+3A_weights">weights</code></td>
<td>
<p>Optional vector of bin-counts for histogram data.</p>
</td></tr>
<tr><td><code id="ssden_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="ssden_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="ssden_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="ssden_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be used.  Ignored when
<code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="ssden_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots.&quot;
Ignored when <code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="ssden_+3A_domain">domain</code></td>
<td>
<p>Data frame specifying marginal support of density.</p>
</td></tr>
<tr><td><code id="ssden_+3A_quad">quad</code></td>
<td>
<p>Quadrature for calculating integral.  Mandatory if
variables other than factors or numerical vectors are involved.</p>
</td></tr>
<tr><td><code id="ssden_+3A_qdsz.depth">qdsz.depth</code></td>
<td>
<p>Depth to be used in <code><a href="#topic+smolyak.quad">smolyak.quad</a></code> for
the generation of quadrature.</p>
</td></tr>
<tr><td><code id="ssden_+3A_bias">bias</code></td>
<td>
<p>Input for sampling bias.</p>
</td></tr>
<tr><td><code id="ssden_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td></tr>
<tr><td><code id="ssden_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td></tr>
<tr><td><code id="ssden_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code><a href="#topic+ssanova">ssanova</a></code> for
notes on skipping theta iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model specification via <code>formula</code> is for the log density.
For example, <code>~x1*x2</code> prescribes a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	log f(x1,x2) = g_{1}(x1) + g_{2}(x2) + g_{12}(x1,x2) + C
    </code>
</p>

<p>with the terms denoted by <code>"x1"</code>, <code>"x2"</code>, and
<code>"x1:x2"</code>; the constant is determined by the fact that a
density integrates to one.
</p>
<p>The selective term elimination may characterize (conditional)
independence structures between variables.  For example,
<code>~x1*x2+x1*x3</code> yields the conditional independence of x2 and x3
given x1.
</p>
<p>Parallel to those in a <code><a href="#topic+ssanova">ssanova</a></code> object, the model terms
are sums of unpenalized and penalized terms.  Attached to every
penalized term there is a smoothing parameter, and the model
complexity is largely determined by the number of smoothing
parameters.
</p>
<p>The selection of smoothing parameters is through a cross-validation
mechanism described in the references, with a parameter
<code>alpha</code>; <code>alpha=1</code> is &quot;unbiased&quot; for the minimization of
Kullback-Leibler loss but may yield severe undersmoothing, whereas
larger <code>alpha</code> yields smoother estimates.
</p>
<p>A subset of the observations are selected as &quot;knots.&quot;  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
&quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>


<h3>Value</h3>

<p><code>ssden</code> returns a list object of class <code>"ssden"</code>.
<code>ssden1</code> returns a list object of class
<code>c("ssden1","ssden")</code>.
</p>
<p><code><a href="#topic+dssden">dssden</a></code> and <code><a href="#topic+cdssden">cdssden</a></code> can be used to
evaluate the estimated joint density and conditional density;
<code><a href="#topic+pssden">pssden</a></code>, <code><a href="#topic+qssden">qssden</a></code>, <code><a href="#topic+cpssden">cpssden</a></code>,
and <code><a href="#topic+cqssden">cqssden</a></code> can be used to evaluate (conditional) cdf
and quantiles.
</p>
<p>The method <code><a href="#topic+project.ssden">project.ssden</a></code> can be used to calculate the
Kullback-Leibler projection of <code>"ssden"</code> objects for model
selection; <code><a href="#topic+project.ssden1">project.ssden1</a></code> can be used to calculate the
square error projection of <code>"ssden1"</code> objects.
</p>


<h3>Note</h3>

<p>In <code>ssden</code>, default quadrature will be constructed for
numerical vectors on a hyper cube, then outer product with factor
levels will be taken if factors are involved.  The sides of the
hyper cube are specified by <code>domain</code>; for <code>domain$x</code>
missing, the default is
<code>c(min(x),max(x))+c(-1,1)*(max(x)-mimn(x))*.05</code>.  In 1-D, the
quadrature is the 200-point Gauss-Legendre formula returned from
<code><a href="#topic+gauss.quad">gauss.quad</a></code>.  In multi-D, delayed Smolyak cubatures
from <code><a href="#topic+smolyak.quad">smolyak.quad</a></code> are used on cubes with the marginals
properly transformed; see Gu and Wang (2003) for the marginal
transformations.
</p>
<p>For reasonable execution time in higher dimensions, set
<code>skip.iter=TRUE</code> in call to <code>ssden</code>.
</p>
<p>If you get an error message from <code>ssden</code> stating <code>"Newton
    iteration diverges"</code>, try to use a larger <code>qdsz.depth</code> which
will execute slower, or switch to <code>ssden1</code>.  The default values
of <code>qdsz.depth</code> for dimensions 4, 5, 6+ are 12, 11, 10.
</p>
<p><code>ssden1</code> does not involve multi-D quadrature but does not
perform as well as <code>ssden</code>.  It can be used in very high
dimensions where <code>ssden</code> is infeasible.
</p>
<p>The results may vary from run to run.  For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>Author(s)</h3>

<p>Chong Gu, <a href="mailto:chong@stat.purdue.edu">chong@stat.purdue.edu</a></p>


<h3>References</h3>

<p>Gu, C. and Wang, J. (2003), Penalized likelihood density
estimation: Direct cross-validation and scalable approximation.
<em>Statistica Sinica</em>, <b>13</b>, 811&ndash;826.
</p>
<p>Gu, C., Jeon, Y., and Lin, Y. (2013), Nonparametric density
estimation in high dimensions.  <em>Statistica Sinica</em>,
<b>23</b>, 1131&ndash;1153.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1-D estimate: Buffalo snowfall
data(buffalo)
buff.fit &lt;- ssden(~buffalo,domain=data.frame(buffalo=c(0,150)))
plot(xx&lt;-seq(0,150,len=101),dssden(buff.fit,xx),type="l")
plot(xx,pssden(buff.fit,xx),type="l")
plot(qq&lt;-seq(0,1,len=51),qssden(buff.fit,qq),type="l")
## Clean up
## Not run: rm(buffalo,buff.fit,xx,qq)
dev.off()
## End(Not run)

## 2-D with triangular domain: AIDS incubation
data(aids)
## rectangular quadrature
quad.pt &lt;- expand.grid(incu=((1:40)-.5)/40*100,infe=((1:40)-.5)/40*100)
quad.pt &lt;- quad.pt[quad.pt$incu&lt;=quad.pt$infe,]
quad.wt &lt;- rep(1,nrow(quad.pt))
quad.wt[quad.pt$incu==quad.pt$infe] &lt;- .5
quad.wt &lt;- quad.wt/sum(quad.wt)*5e3
## additive model (pre-truncation independence)
aids.fit &lt;- ssden(~incu+infe,data=aids,subset=age&gt;=60,
                  domain=data.frame(incu=c(0,100),infe=c(0,100)),
                  quad=list(pt=quad.pt,wt=quad.wt))
## conditional (marginal) density of infe
jk &lt;- cdssden(aids.fit,xx&lt;-seq(0,100,len=51),data.frame(incu=50))
plot(xx,jk$pdf,type="l")
## conditional (marginal) quantiles of infe (TIME-CONSUMING)
## Not run: 
cqssden(aids.fit,c(.05,.25,.5,.75,.95),data.frame(incu=50))

## End(Not run)
## Clean up
## Not run: rm(aids,quad.pt,quad.wt,aids.fit,jk,xx)
dev.off()
## End(Not run)

## One factor plus one vector
data(gastric)
gastric$trt
fit &lt;- ssden(~futime*trt,data=gastric)
## conditional density
cdssden(fit,c("1","2"),cond=data.frame(futime=150))
## conditional quantiles
cqssden(fit,c(.05,.25,.5,.75,.95),data.frame(trt=as.factor("1")))
## Clean up
## Not run: rm(gastric,fit)

## Sampling bias
## (X,T) is truncated to T&lt;X&lt;1 for T~U(0,1), so X is length-biased
rbias &lt;- function(n) {
  t &lt;- runif(n)
  x &lt;- rnorm(n,.5,.15)
  ok &lt;- (x&gt;t)&amp;(x&lt;1)
  while(m&lt;-sum(!ok)) {
    t[!ok] &lt;- runif(m)
    x[!ok] &lt;- rnorm(m,.5,.15)
    ok &lt;- (x&gt;t)&amp;(x&lt;1)
  }
  cbind(x,t)
}
xt &lt;- rbias(100)
x &lt;- xt[,1]; t &lt;- xt[,2]
## length-biased
bias1 &lt;- list(t=1,wt=1,fun=function(t,x){x[,]})
fit1 &lt;- ssden(~x,domain=list(x=c(0,1)),bias=bias1)
plot(xx&lt;-seq(0,1,len=101),dssden(fit1,xx),type="l")
## truncated
bias2 &lt;- list(t=t,wt=rep(1/100,100),fun=function(t,x){x[,]&gt;t})
fit2 &lt;- ssden(~x,domain=list(x=c(0,1)),bias=bias2)
plot(xx,dssden(fit2,xx),type="l")
## Clean up
## Not run: rm(rbias,xt,x,t,bias1,fit1,bias2,fit2)
</code></pre>

<hr>
<h2 id='sshzd'>Estimating Hazard Function Using Smoothing Splines</h2><span id='topic+sshzd'></span><span id='topic+sshzd1'></span>

<h3>Description</h3>

<p>Estimate hazard function using smoothing spline ANOVA models.  The
symbolic model specification via <code>formula</code> follows the same
rules as in <code><a href="stats.html#topic+lm">lm</a></code>, but with the response of a special
form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sshzd(formula, type=NULL, data=list(), alpha=1.4, weights=NULL,
      subset, offset, na.action=na.omit, partial=NULL, id.basis=NULL,
      nbasis=NULL, seed=NULL, random=NULL, prec=1e-7, maxiter=30,
      skip.iter=FALSE)

sshzd1(formula, type=NULL, data=list(), alpha=1.4, weights=NULL,
       subset, na.action=na.omit, rho="marginal", partial=NULL,
       id.basis=NULL, nbasis=NULL, seed=NULL, random=NULL, prec=1e-7,
       maxiter=30, skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sshzd_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit, where
the response is of the form <code>Surv(futime,status,start=0)</code>.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_alpha">alpha</code></td>
<td>
<p>Parameter defining cross-validation score for smoothing
parameter selection.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_weights">weights</code></td>
<td>
<p>Optional vector of counts for duplicated data.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_offset">offset</code></td>
<td>
<p>Optional offset term with known parameter 1.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_partial">partial</code></td>
<td>
<p>Optional symbolic description of parametric terms in
partial spline models.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="sshzd_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be used.  Ignored when
<code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots.&quot;
Ignored when <code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_random">random</code></td>
<td>
<p>Input for parametric random effects (frailty) in
nonparametric mixed-effect models.  See <code><a href="#topic+mkran">mkran</a></code> for
details.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code><a href="#topic+ssanova">ssanova</a></code> for
notes on skipping theta iteration.</p>
</td></tr>
<tr><td><code id="sshzd_+3A_rho">rho</code></td>
<td>
<p>Choice of rho function for sshzd1: <code>"marginal"</code> or
<code>"weibull"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model specification via <code>formula</code> is for the log hazard.
For example, <code>Suve(t,d)~t*u</code> prescribes a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
	log f(t,u) = C + g_{t}(t) + g_{u}(u) + g_{t,u}(t,u)
    </code>
</p>

<p>with the terms denoted by <code>"1"</code>, <code>"t"</code>, <code>"u"</code>, and
<code>"t:u"</code>.  Replacing <code>t*u</code> by <code>t+u</code> in the
<code>formula</code>, one gets a proportional hazard model with
<code class="reqn">g_{t,u}=0</code>.
</p>
<p><code>sshzd</code> takes standard right-censored lifetime data, with
possible left-truncation and covariates; in
<code>Surv(futime,status,start=0)~...</code>, <code>futime</code> is the  
follow-up time, <code>status</code> is the censoring indicator, and
<code>start</code> is the optional left-truncation time.  The main effect
of <code>futime</code> must appear in the model terms specified via
<code>...</code>.
</p>
<p>Parallel to those in a <code><a href="#topic+ssanova">ssanova</a></code> object, the model terms
are sums of unpenalized and penalized terms.  Attached to every
penalized term there is a smoothing parameter, and the model
complexity is largely determined by the number of smoothing
parameters.
</p>
<p>The selection of smoothing parameters is through a cross-validation
mechanism described in Gu (2002, Sec. 7.2), with a parameter
<code>alpha</code>; <code>alpha=1</code> is &quot;unbiased&quot; for the minimization of
Kullback-Leibler loss but may yield severe undersmoothing, whereas
larger <code>alpha</code> yields smoother estimates.
</p>
<p>A subset of the observations are selected as &quot;knots.&quot;  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
&quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>


<h3>Value</h3>

<p><code>sshzd</code> returns a list object of class <code>"sshzd"</code>.
<code>sshzd1</code> returns a list object of class
<code>c("sshzd1","sshzd")</code>.
</p>
<p><code><a href="#topic+hzdrate.sshzd">hzdrate.sshzd</a></code> can be used to evaluate the estimated
hazard function.  <code><a href="#topic+hzdcurve.sshzd">hzdcurve.sshzd</a></code> can be used to
evaluate hazard curves with fixed covariates.
<code><a href="#topic+survexp.sshzd">survexp.sshzd</a></code> can be used to calculated estimated
expected survival.
</p>
<p>The method <code><a href="#topic+project.sshzd">project.sshzd</a></code> can be used to calculate the
Kullback-Leibler projection of <code>"sshzd"</code> objects for model
selection; <code><a href="#topic+project.sshzd1">project.sshzd1</a></code> can be used to calculate the
square error projection of <code>"sshzd1"</code> objects.
</p>


<h3>Note</h3>

<p>The function <code>Surv(futime,status,start=0)</code> is defined and
parsed inside <code>sshzd</code>, not quite the same as the one in the
<code>survival</code> package.
</p>
<p>Integration on the time axis is done by the 200-point Gauss-Legendre
formula on <code>c(min(start),max(futime))</code>, returned from
<code><a href="#topic+gauss.quad">gauss.quad</a></code>.
</p>
<p><code>sshzd1</code> can be up to 50 times faster than <code>sshzd</code>, at the
cost of performance degradation.
</p>
<p>The results may vary from run to run.  For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>References</h3>

<p>Du, P. and Gu, C. (2006), Penalized likelihood hazard estimation:
efficient approximation and Bayesian confidence intervals.
<em>Statistics and Probability Letters</em>, <b>76</b>, 244&ndash;254.
</p>
<p>Du, P. and Gu, C. (2009), Penalized Pseudo-Likelihood Hazard
Estimation: A Fast Alternative to Penalized Likelihood.
<em>Journal of Statistical Planning and Inference</em>, <b>139</b>,
891&ndash;899.
</p>
<p>Du, P. and Ma, S. (2010), Frailty Model with Spline Estimated
Nonparametric Hazard Function, <em>Statistica Sinica</em>, <b>20</b>,
561&ndash;580.
</p>
<p>Gu, C. (2013), <em>Smoothing Spline ANOVA Models (2nd Ed)</em>.  New
York: Springer-Verlag.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Model with interaction
data(gastric)
gastric.fit &lt;- sshzd(Surv(futime,status)~futime*trt,data=gastric)
## exp(-Lambda(600)), exp(-(Lambda(1200)-Lambda(600))), and exp(-Lambda(1200))
survexp.sshzd(gastric.fit,c(600,1200,1200),data.frame(trt=as.factor(1)),c(0,600,0))
## Clean up
## Not run: rm(gastric,gastric.fit)
dev.off()
## End(Not run)

## THE FOLLOWING EXAMPLE IS TIME-CONSUMING
## Proportional hazard model
## Not run: 
data(stan)
stan.fit &lt;- sshzd(Surv(futime,status)~futime+age,data=stan)
## Evaluate fitted hazard
hzdrate.sshzd(stan.fit,data.frame(futime=c(10,20),age=c(20,30)))
## Plot lambda(t,age=20)
tt &lt;- seq(0,60,leng=101)
hh &lt;- hzdcurve.sshzd(stan.fit,tt,data.frame(age=20))
plot(tt,hh,type="l")
## Clean up
rm(stan,stan.fit,tt,hh)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='sshzd2d'>Estimating 2-D Hazard Function Using Smoothing Splines</h2><span id='topic+sshzd2d'></span><span id='topic+sshzd2d1'></span>

<h3>Description</h3>

<p>Estimate 2-D hazard function using smoothing spline ANOVA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sshzd2d(formula1, formula2, symmetry=FALSE, data, alpha=1.4,
        weights=NULL, subset=NULL, id.basis=NULL, nbasis=NULL, seed=NULL,
        prec=1e-7, maxiter=30, skip.iter=FALSE)

sshzd2d1(formula1, formula2, symmetry=FALSE, data, alpha=1.4,
         weights=NULL, subset=NULL, rho="marginal",
         id.basis=NULL, nbasis=NULL, seed=NULL, prec=1e-7, maxiter=30,
         skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sshzd2d_+3A_formula1">formula1</code></td>
<td>
<p>Description of the hazard model to be fit on the
first axis.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_formula2">formula2</code></td>
<td>
<p>Description of the hazard model to be fit on the
second axis.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_symmetry">symmetry</code></td>
<td>
<p>Flag indicating whether to enforce symmetry of the
two axes.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_data">data</code></td>
<td>
<p>Data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_alpha">alpha</code></td>
<td>
<p>Parameter defining cross-validation scores for smoothing
parameter selection.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_weights">weights</code></td>
<td>
<p>Optional vector of counts for duplicated data.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_id.basis">id.basis</code></td>
<td>
<p>Index of observations to be used as &quot;knots.&quot;</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be used.  Ignored when
<code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots.&quot;
Ignored when <code>id.basis</code> is specified.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration in marginal hazard estimation.</p>
</td></tr>
<tr><td><code id="sshzd2d_+3A_rho">rho</code></td>
<td>
<p>Choice of rho function for sshzd2d1: <code>"marginal"</code> or
<code>"weibull"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 2-D survival function is expressed as
<code class="reqn">S(t1,t2)=C(S1(t1),S2(t2))</code>, where <code class="reqn">S1(t1)</code>, <code class="reqn">S2(t2)</code>
are marginal survival functions and <code class="reqn">C(u1,u2)</code> is a 2-D copula.
The marginal survival functions are estimated via the marginal
hazards as in <code><a href="#topic+sshzd">sshzd</a></code>, and the copula is estimated
nonparametrically by calling <code><a href="#topic+sscopu2">sscopu2</a></code>.
</p>
<p>When <code>symmetry=TRUE</code>, a common marginal survial function
S1(t)=S2(t) is estimated, and a symmetric copula is estimated such
that <code class="reqn">C(u1,u2)=C(u2,u1)</code>.
</p>
<p>Covariates can be incorporated in the marginal hazard models as in
<code><a href="#topic+sshzd">sshzd</a></code>, including parametric terms via <code>partial</code>
and frailty terms via <code>random</code>.  Arguments <code>formula1</code> and
<code>formula2</code> are typically model formulas of the same form as the
argument <code>formula</code> in <code><a href="#topic+sshzd">sshzd</a></code>, but when
<code>partial</code> or <code>random</code> are needed, <code>formula1</code> and
<code>formula2</code> should be lists with model formulas as the first
elements and <code>partial</code>/<code>random</code> as named elements; when
necessary, variable configurations (that are done via argument
<code>type</code> in <code><a href="#topic+sshzd">sshzd</a></code>) should also be entered as named
elements of lists <code>formula1</code>/<code>formula2</code>.
</p>
<p>When <code>symmetry=TRUE</code>, parallel model formulas must be
consistent of each other, such as
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>formula1=list(Surv(t1,d1)~t1*u1,partial=~z1,random=~1|id1)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>formula2=list(Surv(t2,d2)~t2*u2,partial=~z2,random=~1|id2)</code>
    </td>
</tr>

</table>

<p>where pairs <code>t1</code>-<code>t2</code>, <code>d2</code>-<code>d2</code> respectively
are different elements in <code>data</code>, pairs <code>u1</code>-<code>u2</code>,
<code>z1</code>-<code>z2</code> respectively may or may not be different
elements in <code>data</code>, and factors <code>id1</code> and <code>id2</code>
are typically the same but at least should have the same levels.
</p>


<h3>Value</h3>

<p><code>sshzd2d</code> and <code>sshzd2d1</code> return a list object of class
<code>"sshzd2d"</code>.
</p>
<p><code><a href="#topic+hzdrate.sshzd2d">hzdrate.sshzd2d</a></code> can be used to evaluate the estimated
2-D hazard function.  <code><a href="#topic+survexp.sshzd2d">survexp.sshzd2d</a></code> can be used to
calculate estimated survival functions.
</p>


<h3>Note</h3>

<p><code>sshzd2d1</code> executes faster than <code>sshzd2d</code>, but often at
the cost of performance degradation.
</p>
<p>The results may vary from run to run.  For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>Author(s)</h3>

<p>Chong Gu, <a href="mailto:chong@stat.purdue.edu">chong@stat.purdue.edu</a></p>


<h3>References</h3>

<p>Gu, C. (2015), Hazard estimation with bivariate survival data and
copula density estimation. <em>Journal of Computational and
Graphical Statistics</em>, <b>24</b>, 1053-1073.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## THE FOLLOWING EXAMPLE IS TIME-CONSUMING
## Not run: 
data(DiaRet)
## Common proportional hazard model on the margins
fit &lt;- sshzd2d(Surv(time1,status1)~time1+trt1*type,
               Surv(time2,status2)~time2+trt2*type,
               data=DiaRet,symmetry=TRUE)
## Evaluate fitted survival and hazard functions
time &lt;- cbind(c(50,70),c(70,70))
cova &lt;- data.frame(trt1=as.factor(c(1,1)),trt2=as.factor(c(1,0)),
                   type=as.factor(c("juvenile","adult")))
survexp.sshzd2d(fit,time,cov=cova)
hzdrate.sshzd2d(fit,time,cov=cova)
## Association between margins: Kendall's tau and Spearman's rho
summary(fit$copu)
## Clean up
rm(DiaRet,fit,time,cova)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='ssllrm'>Fitting Smoothing Spline Log-Linear Regression Models</h2><span id='topic+ssllrm'></span>

<h3>Description</h3>

<p>Fit smoothing spline log-linear regression models.  The symbolic
model specification via <code>formula</code> follows the same rules as in
<code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssllrm(formula, response, type=NULL, data=list(), weights, subset,
       na.action=na.omit, alpha=1, id.basis=NULL, nbasis=NULL,
       seed=NULL, random=NULL, prec=1e-7, maxiter=30, skip.iter=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssllrm_+3A_formula">formula</code></td>
<td>
<p>Symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_response">response</code></td>
<td>
<p>Formula listing response variables.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_type">type</code></td>
<td>
<p>List specifying the type of spline for each variable.
See <code><a href="#topic+mkterm">mkterm</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the
model.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to be used in the
fitting process.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_subset">subset</code></td>
<td>
<p>Optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_na.action">na.action</code></td>
<td>
<p>Function which indicates what should happen when
the data contain NAs.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_alpha">alpha</code></td>
<td>
<p>Parameter modifying GCV or Mallows' CL; larger absolute
values yield smoother fits; negative value invokes a stable and
more accurate GCV/CL evaluation algorithm but may take two to
five times as long.  Ignored when <code>method="m"</code> are
specified.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_id.basis">id.basis</code></td>
<td>
<p>Index designating selected &quot;knots&quot;.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of &quot;knots&quot; to be selected.  Ignored when
<code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the random generation of &quot;knots&quot;.
Ignored when <code>id.basis</code> is supplied.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_random">random</code></td>
<td>
<p>Input for parametric random effects in nonparametric
mixed-effect models.  See <code><a href="#topic+mkran">mkran</a></code> for details.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_prec">prec</code></td>
<td>
<p>Precision requirement for internal iterations.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations allowed for
internal iterations.</p>
</td></tr>
<tr><td><code id="ssllrm_+3A_skip.iter">skip.iter</code></td>
<td>
<p>Flag indicating whether to use initial values of
theta and skip theta iteration.  See <code><a href="#topic+ssanova">ssanova</a></code> for
notes on skipping theta iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is specified via <code>formula</code> and <code>response</code>, where
<code>response</code> lists the response variables.  For example,
<code>ssllrm(~y1*y2*x,~y1+y2)</code> prescribe a model of the form
</p>
<p style="text-align: center;"><code class="reqn">
      log f(y1,y2|x) = g_{1}(y1) + g_{2}(y2) + g_{12}(y1,y2)
              + g_{x1}(x,y1) + g_{x2}(x,y2) + g_{x12}(x,y1,y2) + C(x)
    </code>
</p>

<p>with the terms denoted by <code>"y1"</code>, <code>"y2"</code>, <code>"y1:y2"</code>,
<code>"y1:x"</code>, <code>"y2:x"</code>, and <code>"y1:y2:x"</code>; the term(s) not
involving response(s) are removed and the constant <code>C(x)</code> is
determined by the fact that a conditional density integrates (adds)
to one on the <code>y</code> axis.
</p>
<p>The model terms are sums of unpenalized and penalized
terms. Attached to every penalized term there is a smoothing
parameter, and the model complexity is largely determined by the
number of smoothing parameters.
</p>
<p>A subset of the observations are selected as &quot;knots.&quot;  Unless
specified via <code>id.basis</code> or <code>nbasis</code>, the number of
&quot;knots&quot; <code class="reqn">q</code> is determined by <code class="reqn">max(30,10n^{2/9})</code>, which is
appropriate for the default cubic splines for numerical vectors.
</p>


<h3>Value</h3>

<p><code>ssllrm</code> returns a list object of class <code>"ssllrm"</code>.
</p>
<p>The method <code><a href="#topic+predict.ssllrm">predict.ssllrm</a></code> can be used to evaluate
<code>f(y|x)</code> at arbitrary x, or contrasts of <code>log{f(y|x)}</code>
such as the odds ratio along with standard errors.  The method
<code><a href="#topic+project.ssllrm">project.ssllrm</a></code> can be used to calculate the
Kullback-Leibler projection for model selection.
</p>


<h3>Note</h3>

<p>The responses, or y-variables, must be factors, and there must be at
least one numerical x's.  For <code>response</code>, there is no difference
between <code>~y1+y2</code> and <code>~y1*y2</code>.
</p>
<p>The results may vary from run to run. For consistency, specify
<code>id.basis</code> or set <code>seed</code>.
</p>


<h3>References</h3>

<p>Gu, C. and Ma, P. (2011), Nonparametric regression with
cross-classified responses.  <em>The Canadian Journal of
Statistics</em>, <b>39</b>, 591&ndash;609.
</p>
<p>Gu, C. (2014), Smoothing Spline ANOVA Models: R Package gss.
<em>Journal of Statistical Software</em>, 58(5), 1-25. URL
http://www.jstatsoft.org/v58/i05/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data
test &lt;- function(x)
        {.3*(1e6*(x^11*(1-x)^6)+1e4*(x^3*(1-x)^10))-2}
x &lt;- (0:100)/100
p &lt;- 1-1/(1+exp(test(x)))
y &lt;- rbinom(x,3,p)
y1 &lt;- as.ordered(y)
y2 &lt;- as.factor(rbinom(x,1,p))
## Fit model
fit &lt;- ssllrm(~y1*y2*x,~y1+y2)

## Evaluate f(y|x)
est &lt;- predict(fit,data.frame(x=x),
               data.frame(y1=as.factor(0:3),y2=as.factor(rep(0,4))))
## f(y|x) at all y values (fit$qd.pt)
est &lt;- predict(fit,data.frame(x=x))

## Evaluate contrast of log f(y|x)
est &lt;- predict(fit,data.frame(x=x),odds=c(-1,.5,.5,0),
               data.frame(y1=as.factor(0:3),y2=as.factor(rep(0,4))),se=TRUE)
## Odds ratio log{f(0,0|x)/f(3,0|x)}
est &lt;- predict(fit,data.frame(x=x),odds=c(1,-1),
               data.frame(y1=as.factor(c(0,3)),y2=as.factor(c(0,1))),se=TRUE)

## KL projection
kl &lt;- project(fit,include=c("y2:x","y1:y2","y1:x","y2:x"))

## Clean up
## Not run: rm(test,x,p,y,y1,y2,fit,est,kl)
dev.off()
## End(Not run)
</code></pre>

<hr>
<h2 id='stan'>Stanford Heart Transplant Data</h2><span id='topic+stan'></span>

<h3>Description</h3>

<p>Survival of patients from the Stanford heart transplant program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stan)</code></pre>


<h3>Format</h3>

<p>A data frame containing 184 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>time</code> </td><td style="text-align: left;"> Follow-up time after transplant, in days.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>status</code> </td><td style="text-align: left;"> Censoring status.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>age</code> </td><td style="text-align: left;"> Age at transplant.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>futime</code> </td><td style="text-align: left;"> Square root of <code>time</code>.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Miller, R. G. and Halpern, J. (1982), Regression with censored data.
<em>Biometrika</em>, <b>69</b>, 521&ndash;531.
</p>

<hr>
<h2 id='summary.gssanova'>Assessing Smoothing Spline ANOVA Fits with Non-Gaussian Responses</h2><span id='topic+summary.gssanova'></span>

<h3>Description</h3>

<p>Calculate various summaries of smoothing spline ANOVA fits with
non-Gaussian responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gssanova'
summary(object, diagnostics=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gssanova_+3A_object">object</code></td>
<td>
<p>Object of class <code>"gssanova"</code>.</p>
</td></tr>
<tr><td><code id="summary.gssanova_+3A_diagnostics">diagnostics</code></td>
<td>
<p>Flag indicating if diagnostics are required.</p>
</td></tr>
<tr><td><code id="summary.gssanova_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to the iterated weighted least squares fitting of
<code><a href="stats.html#topic+glm">glm</a></code>, penalized likelihood regression fit can be calculated
through iterated penalized weighted least squares.
</p>
<p>The diagnostics are based on the &quot;pseudo&quot; Gaussian response model
behind the weighted least squares problem at convergence.
</p>


<h3>Value</h3>

<p><code>summary.gssanova</code> returns a list object of <code><a href="base.html#topic+class">class</a></code>
<code>"summary.gssanova"</code> consisting of the following elements.
The entries <code>pi</code>, <code>kappa</code>, <code>cosines</code>, and
<code>roughness</code> are only calculated if <code>diagnostics=TRUE</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>Fitting call.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Error distribution.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Parameter used to define cross-validation in model
fitting.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values on the link scale.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>Assumed or estimated dispersion parameter.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Working residuals on the link scale.</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum of squares.</p>
</td></tr>
<tr><td><code>dev.resid</code></td>
<td>
<p>Deviance residuals.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the fit.</p>
</td></tr>
<tr><td><code>dev.null</code></td>
<td>
<p>Deviance of the null model.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>Roughness penalty associated with the fit.</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>&quot;Percentage decomposition&quot; of &quot;explained variance&quot; into
model terms.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Concurvity diagnostics for model terms.  Virtually the
square roots of variance inflation factors of a retrospective
linear model.</p>
</td></tr>
<tr><td><code>cosines</code></td>
<td>
<p>Cosine diagnostics for practical significance of
model terms.</p>
</td></tr>
<tr><td><code>roughness</code></td>
<td>
<p>Percentage decomposition of the roughness penalty
<code>penalty</code> into model terms.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gu, C. (1992), Diagnostics for nonparametric regression models with
additive terms.  <em>Journal of the American Statistical
Association</em>, <b>87</b>, 1051&ndash;1058.
</p>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+gssanova">gssanova</a></code> and methods
<code><a href="#topic+predict.ssanova">predict.ssanova</a></code>, <code><a href="#topic+project.gssanova">project.gssanova</a></code>,
<code><a href="#topic+fitted.gssanova">fitted.gssanova</a></code>. 
</p>

<hr>
<h2 id='summary.gssanova0'>Assessing Smoothing Spline ANOVA Fits with Non-Gaussian Responses</h2><span id='topic+summary.gssanova0'></span>

<h3>Description</h3>

<p>Calculate various summaries of smoothing spline ANOVA fits with
non-Gaussian responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gssanova0'
summary(object, diagnostics=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gssanova0_+3A_object">object</code></td>
<td>
<p>Object of class <code>"gssanova"</code>.</p>
</td></tr>
<tr><td><code id="summary.gssanova0_+3A_diagnostics">diagnostics</code></td>
<td>
<p>Flag indicating if diagnostics are required.</p>
</td></tr>
<tr><td><code id="summary.gssanova0_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to the iterated weighted least squares fitting of
<code><a href="stats.html#topic+glm">glm</a></code>, penalized likelihood regression fit can be calculated
through iterated penalized weighted least squares.
</p>
<p>The diagnostics are based on the &quot;pseudo&quot; Gaussian response model
behind the weighted least squares problem at convergence.
</p>


<h3>Value</h3>

<p><code>summary.gssanova0</code> returns a list object of <code><a href="base.html#topic+class">class</a></code>
<code>"summary.gssanova0"</code> consisting of the following elements.
The entries <code>pi</code>, <code>kappa</code>, <code>cosines</code>, and
<code>roughness</code> are only calculated if <code>diagnostics=TRUE</code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>Fitting call.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Error distribution.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method for smoothing parameter selection.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>Assumed or estimated dispersion parameter.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of performance-oriented iterations performed.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values on the link scale.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Working residuals on the link scale.</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum of squares.</p>
</td></tr>
<tr><td><code>dev.resid</code></td>
<td>
<p>Deviance residuals.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the fit.</p>
</td></tr>
<tr><td><code>dev.null</code></td>
<td>
<p>Deviance of the null model.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Estimated size for <code>family="nbinomial"</code> with one
column responses.  Estimated inverse scale of log life time for
<code>family="nbinomial"</code>, <code>"lognorm"</code>, or
<code>"loglogis"</code>.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>Roughness penalty associated with the fit.</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>&quot;Percentage decomposition&quot; of &quot;explained variance&quot; into
model terms.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Concurvity diagnostics for model terms.  Virtually the
square roots of variance inflation factors of a retrospective
linear model.</p>
</td></tr>
<tr><td><code>cosines</code></td>
<td>
<p>Cosine diagnostics for practical significance of
model terms.</p>
</td></tr>
<tr><td><code>roughness</code></td>
<td>
<p>Percentage decomposition of the roughness penalty
<code>penalty</code> into model terms.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gu, C. (1992), Diagnostics for nonparametric regression models with
additive terms.  <em>Journal of the American Statistical
Association</em>, <b>87</b>, 1051&ndash;1058.
</p>


<h3>See Also</h3>

<p>Fitting function <code><a href="#topic+gssanova0">gssanova0</a></code> and methods
<code><a href="#topic+predict.ssanova0">predict.ssanova0</a></code>, <code><a href="#topic+fitted.gssanova">fitted.gssanova</a></code>.
</p>

<hr>
<h2 id='summary.ssanova'>Assessing Smoothing Spline ANOVA Fits</h2><span id='topic+summary.ssanova'></span><span id='topic+summary.ssanova0'></span><span id='topic+summary.ssanova9'></span>

<h3>Description</h3>

<p>Calculate various summaries of smoothing spline ANOVA fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssanova'
summary(object, diagnostics=FALSE, ...)
## S3 method for class 'ssanova0'
summary(object, diagnostics=FALSE, ...)
## S3 method for class 'ssanova9'
summary(object, diagnostics=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ssanova_+3A_object">object</code></td>
<td>
<p>Object of class <code>"ssanova"</code>.</p>
</td></tr>
<tr><td><code id="summary.ssanova_+3A_diagnostics">diagnostics</code></td>
<td>
<p>Flag indicating if diagnostics are required.</p>
</td></tr>
<tr><td><code id="summary.ssanova_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.ssanova</code> returns a list object of <code><a href="base.html#topic+class">class</a></code>
<code>"summary.ssanova"</code> consisting of the following elements.
The entries <code>pi</code>, <code>kappa</code>, <code>cosines</code>, and
<code>roughness</code> are only calculated if <code>diagnostics=TRUE</code>; see
the reference below for details concerning the diagnostics.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>Fitting call.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method for smoothing parameter selection.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Fitted values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residuals.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Assumed or estimated error standard deviation.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>Fraction of &quot;explained variance&quot; by the fitted model.</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>Residual sum of squares.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>Roughness penalty associated with the fit.</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>&quot;Percentage decomposition&quot; of &quot;explained variance&quot; into
model terms.</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>Concurvity diagnostics for model terms.  Virtually the
square roots of variance inflation factors of a retrospective
linear model.</p>
</td></tr>
<tr><td><code>cosines</code></td>
<td>
<p>Cosine diagnostics for practical significance of
model terms.</p>
</td></tr>
<tr><td><code>roughness</code></td>
<td>
<p>Percentage decomposition of the roughness penalty
<code>penalty</code> into model terms.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gu, C. (1992), Diagnostics for nonparametric regression models with
additive terms.  <em>Journal of the American Statistical
Association</em>, <b>87</b>, 1051&ndash;1058.
</p>


<h3>See Also</h3>

<p>Fitting functions <code><a href="#topic+ssanova">ssanova</a></code>, <code><a href="#topic+ssanova0">ssanova0</a></code> and
methods <code><a href="#topic+predict.ssanova">predict.ssanova</a></code>,
<code><a href="#topic+project.ssanova">project.ssanova</a></code>, <code><a href="#topic+fitted.ssanova">fitted.ssanova</a></code>.
</p>

<hr>
<h2 id='summary.sscopu'>Calculating Kendall's Tau and Spearman's Rho for 2-D Copula
Density Estimates</h2><span id='topic+summary.sscopu'></span>

<h3>Description</h3>

<p>Calculate Kendall's tau and Spearman's rho for 2-D copula density
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sscopu'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sscopu_+3A_object">object</code></td>
<td>
<p>Object of class <code>"sscopu"</code>.</p>
</td></tr>
<tr><td><code id="summary.sscopu_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing Kendall's tau and Spearman's rho.
</p>


<h3>See Also</h3>

<p>Fitting functions <code><a href="#topic+sscopu">sscopu</a></code> and <code><a href="#topic+sscopu2">sscopu2</a></code>.
</p>

<hr>
<h2 id='wesdr'>Progression of Diabetic Retinopathy</h2><span id='topic+wesdr'></span>

<h3>Description</h3>

<p>Data derived from the Wisconsin Epidemiological Study of Diabetic
Retinopathy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wesdr)</code></pre>


<h3>Format</h3>

<p>A data frame containing 669 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>dur</code> </td><td style="text-align: left;"> Duration of diabetes at baseline, in years.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>gly</code> </td><td style="text-align: left;"> Percent of glycosylated hemoglobin at baseline.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>bmi</code> </td><td style="text-align: left;"> Body mass index at baseline.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ret</code> </td><td style="text-align: left;"> Binary indicator of retinopathy progression at
	first follow-up.
    </td>
</tr>

</table>



<h3>Source</h3>

<p>Wang, Y. (1997), GRKPACK: Fitting smoothing spline ANOVA models for
exponential families.  <em>Communications in Statistics &ndash;
Simulations and Computation</em>, <b>26</b>, 765&ndash;782.
</p>


<h3>References</h3>

<p>Klein, R., Klein, B. E. K., Moss, S. E., Davis, M. D., and DeMets,
D. L. (1988), Glycosylated hemoglobin predicts the incidence and
progression of diabetic retinopathy.  <em>Journal of the American
Medical Association</em>, <b>260</b>, 2864&ndash;2871.
</p>
<p>Klein, R., Klein, B. E. K., Moss, S. E., Davis, M. D., and DeMets,
D. L. (1989), The Wisconsin Epidemiologic Study of Diabetic
Retinopathy. X. Four incidence and progression of diabetic
retinopathy when age at diagnosis is 30 or more years.
<em>Archive Ophthalmology</em>, <b>107</b>, 244&ndash;249.
</p>
<p>Wahba, G., Wang, Y., Gu, C., Klein, R., and Klein, B. E. K. (1995),
Smoothing spline ANOVA for exponential families, with application to
the Wisconsin Epidemiological Study of Diabetic
Retinopathy. <em>The Annals of Statistics</em>, <b>23</b>, 1865&ndash;1895.
</p>

<hr>
<h2 id='wesdr1'>Stages of Diabetic Retinopathy</h2><span id='topic+wesdr1'></span>

<h3>Description</h3>

<p>Data derived from the Wisconsin Epidemiological Study of Diabetic
Retinopathy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wesdr1)</code></pre>


<h3>Format</h3>

<p>A data frame containing 2049 observations on the following variables.
</p>

<table>
<tr>
 <td style="text-align: left;">
	<code>age</code> </td><td style="text-align: left;"> Age of patient.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>dur</code> </td><td style="text-align: left;"> Duration of diabetes, in years.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>gly</code> </td><td style="text-align: left;"> Percent of glycosylated hemoglobin.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>upro</code> </td><td style="text-align: left;"> Ordinal urine protein level.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>insl</code> </td><td style="text-align: left;"> Binary indicator of insulin usage.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ret1</code> </td><td style="text-align: left;"> Ordinal retinopathy stage, right eye.</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>ret2</code> </td><td style="text-align: left;"> Ordinal retinopathy stage, left eye.
    </td>
</tr>

</table>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
