<!DOCTYPE html><html lang="en"><head><title>Help for package litedown</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {litedown}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#litedown-package'><p>A lightweight version of R Markdown</p></a></li>
<li><a href='#crack'><p>Parse R Markdown or R scripts</p></a></li>
<li><a href='#engines'><p>Language engines</p></a></li>
<li><a href='#fuse'><p>Render Markdown, R Markdown, and R scripts</p></a></li>
<li><a href='#fuse_book'><p>Fuse multiple R Markdown documents to a single output file</p></a></li>
<li><a href='#fuse_env'><p>The <code>fuse()</code> environment</p></a></li>
<li><a href='#fuse_site'><p>Fuse R Markdown documents individually under a directory</p></a></li>
<li><a href='#get_context'><p>Get the <code>fuse()</code> context</p></a></li>
<li><a href='#html_format'><p>Output formats in YAML metadata</p></a></li>
<li><a href='#markdown_options'><p>Markdown rendering options</p></a></li>
<li><a href='#pkg_desc'><p>Print the package description, news, citation, manual pages, and source code</p></a></li>
<li><a href='#raw_text'><p>Mark a character vector as raw output</p></a></li>
<li><a href='#reactor'><p>Get and set chunk options</p></a></li>
<li><a href='#roam'><p>Preview Markdown and R Markdown files</p></a></li>
<li><a href='#smartypants'><p>Convert some ASCII strings to HTML entities</p></a></li>
<li><a href='#timing_data'><p>Get the timing data of code chunks and text blocks in a document</p></a></li>
<li><a href='#vest'><p>Add CSS/JS assets to HTML output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Lightweight Version of R Markdown</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Render R Markdown to Markdown (without using 'knitr'), and Markdown
    to lightweight HTML or 'LaTeX' documents with the 'commonmark' package (instead
    of 'Pandoc'). Some missing Markdown features in 'commonmark' are also
    supported, such as raw HTML or 'LaTeX' blocks, 'LaTeX' math, superscripts,
    subscripts, footnotes, element attributes, and appendices,
    but not all 'Pandoc' Markdown features are (or will be) supported. With
    additional JavaScript and CSS, you can also create HTML slides and articles.
    This package can be viewed as a trimmed-down version of R Markdown and
    'knitr'. It does not aim at rich Markdown features or a large variety of
    output formats (the primary formats are HTML and 'LaTeX'). Book and website
    projects of multiple input documents are also supported.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, commonmark (&ge; 1.9.1), xfun (&ge; 0.51)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rbibutils, rstudioapi, tinytex</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yihui/litedown">https://github.com/yihui/litedown</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yihui/litedown/issues">https://github.com/yihui/litedown/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>litedown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-27 04:08:46 UTC; runner</td>
</tr>
<tr>
<td>Author:</td>
<td>Yihui Xie <a href="https://orcid.org/0000-0003-0645-5666"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre] (URL: https://yihui.org),
  Tim Taylor <a href="https://orcid.org/0000-0002-8587-7113"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yihui Xie &lt;xie@yihui.name&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-27 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='litedown-package'>A lightweight version of R Markdown</h2><span id='topic+litedown'></span><span id='topic+litedown-package'></span>

<h3>Description</h3>

<p>Markdown is a plain-text format that can be converted to HTML and other
formats. This package can render R Markdown to Markdown, and then to an
output document format. The main differences between this package and
<span class="pkg">rmarkdown</span> are that it does not use Pandoc or <span class="pkg">knitr</span> (i.e., fewer
dependencies), and it also has fewer Markdown features.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yihui Xie <a href="mailto:xie@yihui.name">xie@yihui.name</a> (<a href="https://orcid.org/0000-0003-0645-5666">ORCID</a>) (https://yihui.org)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Tim Taylor (<a href="https://orcid.org/0000-0002-8587-7113">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/yihui/litedown">https://github.com/yihui/litedown</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/yihui/litedown/issues">https://github.com/yihui/litedown/issues</a>
</p>
</li></ul>


<hr>
<h2 id='crack'>Parse R Markdown or R scripts</h2><span id='topic+crack'></span><span id='topic+sieve'></span>

<h3>Description</h3>

<p>Parse input into code chunks, inline code expressions, and text fragments:
<code><a href="#topic+crack">crack()</a></code> is for parsing R Markdown, and <code><a href="#topic+sieve">sieve()</a></code> is for R scripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crack(input, text = NULL)

sieve(input, text = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crack_+3A_input">input</code></td>
<td>
<p>A character vector to provide the input file path or text. If
not provided, the <code>text</code> argument must be provided instead. The <code>input</code>
vector will be treated as a file path if it is a single string, and points
to an existing file or has a filename extension. In other cases, the vector
will be treated as the <code>text</code> argument input. To avoid ambiguity, if a
string should be treated as <code>text</code> input when it happens to be an existing
file path or has an extension, wrap it in <code><a href="base.html#topic+I">I()</a></code>, or simply use the <code>text</code>
argument instead.</p>
</td></tr>
<tr><td><code id="crack_+3A_text">text</code></td>
<td>
<p>A character vector as the text input. By default, it is read from
the <code>input</code> file if provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For R Markdown, a code chunk must start with a fence of the form <code style="white-space: pre;">&#8288;```{lang}&#8288;</code>, where <code>lang</code> is the language name, e.g., <code>r</code> or <code>python</code>. The
body of a code chunk can start with chunk options written in &quot;pipe comments&quot;,
e.g., <code style="white-space: pre;">&#8288;#| eval = TRUE, echo = FALSE&#8288;</code> (the CSV syntax) or <code style="white-space: pre;">&#8288;#| eval: true&#8288;</code> (the
YAML syntax). An inline code fragment is of the form <code>`{lang} source`</code>
embedded in Markdown text.
</p>
<p>For R scripts, text blocks are extracted by removing the leading
<code style="white-space: pre;">&#8288;#'&#8288;</code> tokens. All other lines are treated as R code, which can optionally be
separated into chunks by consecutive lines of <code style="white-space: pre;">&#8288;#|&#8288;</code> comments (chunk options
are written in these comments). If no <code style="white-space: pre;">&#8288;#'&#8288;</code> or <code style="white-space: pre;">&#8288;#|&#8288;</code> tokens are found in the
script, the script will be divided into chunks that contain smallest
possible complete R expressions.
</p>


<h3>Value</h3>

<p>A list of code chunks and text blocks:
</p>

<ul>
<li><p> Code chunks are of the form <code>list(source, type = "code_chunk", options,   comments, ...)</code>: <code>source</code> is a character vector of the source code of a
code chunk, <code>options</code> is a list of chunk options, and <code>comments</code> is a
vector of pipe comments.
</p>
</li>
<li><p> Text blocks are of the form <code>list(source, type = "text_block", ...)</code>. If
the text block does not contain any inline code, <code>source</code> will be a
character string (lines of text concatenated by line breaks), otherwise it
will be a list with members that are either character strings (normal text
fragments) or lists of the form <code>list(source, options, ...)</code> (<code>source</code> is
the inline code, and <code>options</code> contains its options specified inside <code>  `{lang, ...}`</code>).
</p>
</li></ul>

<p>Both code chunks and text blocks have a list member named <code>lines</code> that
stores their starting and ending line numbers in the input.
</p>


<h3>Note</h3>

<p>For simplicity, <code><a href="#topic+sieve">sieve()</a></code> does not support inline code expressions.
Text after <code style="white-space: pre;">&#8288;#'&#8288;</code> is treated as pure Markdown.
</p>
<p>It is a pure coincidence that the function names <code>crack()</code> and <code>sieve()</code>
weakly resemble Carson Sievert's name, but I will consider adding a class
name <code>sievert</code> to the returned value of <code>sieve()</code> if Carson becomes the
president of the United States someday, which may make the value
radioactive and introduce a new programming paradigm named <em>Radioactive
Programming</em> (in case <em>Reactive Programming</em> is no longer fun or cool).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(litedown)
# parse R Markdown
res = crack(c("```{r}\n1+1\n```", "Hello, `pi` = `{r} pi` and `e` = `{r} exp(1)`!"))
str(res)
# evaluate inline code and combine results with text fragments
txt = lapply(res[[2]]$source, function(x) {
    if (is.character(x))
        x else eval(parse(text = x$source))
})
paste(unlist(txt), collapse = "")

# parse R code
res = sieve(c("#' This is _doc_.", "", "#| eval=TRUE", "# this is code", "1 + 1"))
str(res)
</code></pre>

<hr>
<h2 id='engines'>Language engines</h2><span id='topic+engines'></span>

<h3>Description</h3>

<p>Get or set language engines for evaluating code chunks and inline code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engines(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="engines_+3A_...">...</code></td>
<td>
<p>Named values (for setting) or unnamed values (for getting).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An engine function should have three arguments:
</p>

<ul>
<li> <p><code>x</code>: An element in the <code><a href="#topic+crack">crack()</a></code> list (a code chunk or a text block).
</p>
</li>
<li> <p><code>inline</code>: It indicates if <code>x</code> is from a code chunk or inline code.
</p>
</li>
<li> <p><code>...</code>: Currently unused but recommended for future compatibility (more
arguments might be passed to the function).
</p>
</li></ul>

<p>The function should return a character value.
</p>


<h3>Value</h3>

<p>The usage is similar to <code><a href="#topic+reactor">reactor()</a></code>: <code>engines('LANG')</code> returns an
engine function for the language <code>LANG</code>, and <code>engines(LANG = function(x, inline = FALSE, ...) {})</code> sets the engine for a language.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>litedown::engines()  # built-in engines
</code></pre>

<hr>
<h2 id='fuse'>Render Markdown, R Markdown, and R scripts</h2><span id='topic+fuse'></span><span id='topic+fiss'></span><span id='topic+mark'></span>

<h3>Description</h3>

<p>The function <code>fuse()</code> extracts and runs code from code chunks
and inline code expressions in R Markdown, and interweaves the results with
the rest of text in the input, which is similar to what <code>knitr::knit()</code> and
<code>rmarkdown::render()</code> do. It also works on R scripts in a way similar to
<code>knitr::spin()</code>. The function <code>fiss()</code> extracts code from the input, and is
similar to <code>knitr::purl()</code>.
</p>
<p>The function <code>mark()</code> renders Markdown to an output format via the
<span class="pkg">commonmark</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuse(input, output = NULL, text = NULL, envir = parent.frame(), quiet = FALSE)

fiss(input, output = ".R", text = NULL)

mark(input, output = NULL, text = NULL, options = NULL, meta = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuse_+3A_input">input</code></td>
<td>
<p>A character vector to provide the input file path or text. If
not provided, the <code>text</code> argument must be provided instead. The <code>input</code>
vector will be treated as a file path if it is a single string, and points
to an existing file or has a filename extension. In other cases, the vector
will be treated as the <code>text</code> argument input. To avoid ambiguity, if a
string should be treated as <code>text</code> input when it happens to be an existing
file path or has an extension, wrap it in <code><a href="base.html#topic+I">I()</a></code>, or simply use the <code>text</code>
argument instead.</p>
</td></tr>
<tr><td><code id="fuse_+3A_output">output</code></td>
<td>
<p>An output file path or a filename extension (e.g., <code>.html</code>,
<code>.tex</code>, <code>.xml</code>, <code>.man</code>, <code>.markdown</code>, or <code>.txt</code>). In the latter case, the
output file path will use the extension on the same base filename as the
input file if the <code>input</code> is a file. If <code>output</code> is not character (e.g.,
<code>NA</code>), the results will be returned as a character vector instead of being
written to a file. If <code>output</code> is <code>NULL</code> or an extension, and the input is
a file path, the output file path will have the same base name as the input
file, with an extension corresponding to the output format. The output
format is retrieved from the first value in the <code>output</code> field of the YAML
metadata of the <code>input</code> (e.g., <code>html</code> will generate HTML
output). The <code>output</code> argument can also take an output format name
(possible values are <code>html</code>, <code>latex</code>, <code>xml</code>, <code>man</code>, <code>commonmark</code>, and
<code>text</code>). If no output format is detected or provided, the default is HTML.</p>
</td></tr>
<tr><td><code id="fuse_+3A_text">text</code></td>
<td>
<p>A character vector as the text input. By default, it is read from
the <code>input</code> file if provided.</p>
</td></tr>
<tr><td><code id="fuse_+3A_envir">envir</code></td>
<td>
<p>An environment in which the code is to be evaluated. It can be
accessed via <code><a href="#topic+fuse_env">fuse_env()</a></code> inside <code><a href="#topic+fuse">fuse()</a></code>.</p>
</td></tr>
<tr><td><code id="fuse_+3A_quiet">quiet</code></td>
<td>
<p>If <code>TRUE</code>, do not show the progress bar. If <code>FALSE</code>, the
progress bar will be shown after a number of seconds, which can be set via
a global <a href="base.html#topic+options">option</a> <code>litedown.progress.delay</code> (the default is <code>2</code>).
THe progress bar output can be set via a global option
<code>litedown.progress.output</code> (the default is <code><a href="base.html#topic+stderr">stderr()</a></code>).</p>
</td></tr>
<tr><td><code id="fuse_+3A_options">options</code></td>
<td>
<p>Options to be passed to the renderer. See <code><a href="#topic+markdown_options">markdown_options()</a></code>
for details. This argument can take either a character vector of the form
<code>"+option1 option2-option3"</code> (use <code>+</code> or a space to enable an option, and
<code>-</code> to disable an option), or a list of the form <code>list(option1 = value1, option2 = value2, ...)</code>. A string <code>"+option1"</code> is equivalent to
<code>list(option1 = TRUE)</code>, and <code>"-option2"</code> means <code>list(option2 = FALSE)</code>.
Options that do not take logical values must be specified via a list, e.g.,
<code>list(width = 30)</code>.</p>
</td></tr>
<tr><td><code id="fuse_+3A_meta">meta</code></td>
<td>
<p>A named list of metadata. Elements in the metadata will be used
to fill out the template by their names and values, e.g., <code>list(title = ...)</code> will replace the <code style="white-space: pre;">&#8288;$title$&#8288;</code> variable in the template. See the Section
&ldquo;YAML metadata&rdquo; <a href="https://yihui.org/litedown/#sec:yaml-metadata">in the documentation</a> for supported
variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output file path if output is written to a file, otherwise a
character vector of the rendered output (wrapped in <code><a href="xfun.html#topic+raw_string">xfun::raw_string()</a></code>
for clearer printing).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sieve">sieve()</a></code>, for the syntax of R scripts to be passed to <code><a href="#topic+fuse">fuse()</a></code>.
</p>
<p>The spec of GitHub Flavored Markdown:
<a href="https://github.github.com/gfm/">https://github.github.com/gfm/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(litedown)
doc = c("```{r}", "1 + 1", "```", "", "$\\pi$ = `{r} pi`.")
fuse(doc)
fuse(doc, ".tex")
fiss(doc)

mark(c("Hello _World_!", "", "Welcome to **litedown**."))
# if input appears to be a file path but should be treated as text, use I()
mark(I("This is *not* a file.md"))
# that's equivalent to
mark(text = "This is *not* a file.md")

# output to a file
(mark("_Hello_, **World**!", output = tempfile()))

# convert to other formats
mark("Hello _World_!", ".tex")
mark("Hello _**`World`**_!", "xml")
mark("Hello _**`World`**_!", "text")
</code></pre>

<hr>
<h2 id='fuse_book'>Fuse multiple R Markdown documents to a single output file</h2><span id='topic+fuse_book'></span>

<h3>Description</h3>

<p>This is a helper function to <code><a href="#topic+fuse">fuse()</a></code> <code>.Rmd</code> files and convert all their
Markdown output to a single output file, which is similar to
<code>bookdown::render_book()</code>, but one major differences is that all HTML output
is written to one file, instead of one HTML file per chapter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuse_book(input = ".", output = NULL, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuse_book_+3A_input">input</code></td>
<td>
<p>A directory or a vector of file paths. By default, all
<code>.Rmd</code>/<code>.md</code> files under the current working directory are used as the
input, except for filenames that start with <code>.</code> or <code style="white-space: pre;">&#8288;_&#8288;</code> (e.g., <code style="white-space: pre;">&#8288;_foo.Rmd&#8288;</code>),
or <code>.md</code> files with the same base names as <code>.Rmd</code> files (e.g., <code>bar.md</code>
will not be used if <code>bar.Rmd</code> exists). For a directory <code>input</code>, the file
search will be recursive if <code>input</code> ends with a slash (i.e.,
sub-directories will also be searched). If a file named <code>index.Rmd</code> or
<code>index.md</code> exists, it will always be treated as the first input file. Input
files can also be specified in the config file <code style="white-space: pre;">&#8288;_litedown.yml&#8288;</code> (in the
<code>input</code> field under <code>book</code>).</p>
</td></tr>
<tr><td><code id="fuse_book_+3A_output">output</code></td>
<td>
<p>An output file path or a filename extension (e.g., <code>.html</code>,
<code>.tex</code>, <code>.xml</code>, <code>.man</code>, <code>.markdown</code>, or <code>.txt</code>). In the latter case, the
output file path will use the extension on the same base filename as the
input file if the <code>input</code> is a file. If <code>output</code> is not character (e.g.,
<code>NA</code>), the results will be returned as a character vector instead of being
written to a file. If <code>output</code> is <code>NULL</code> or an extension, and the input is
a file path, the output file path will have the same base name as the input
file, with an extension corresponding to the output format. The output
format is retrieved from the first value in the <code>output</code> field of the YAML
metadata of the <code>input</code> (e.g., <code>html</code> will generate HTML
output). The <code>output</code> argument can also take an output format name
(possible values are <code>html</code>, <code>latex</code>, <code>xml</code>, <code>man</code>, <code>commonmark</code>, and
<code>text</code>). If no output format is detected or provided, the default is HTML.</p>
</td></tr>
<tr><td><code id="fuse_book_+3A_envir">envir</code></td>
<td>
<p>An environment in which the code is to be evaluated. It can be
accessed via <code><a href="#topic+fuse_env">fuse_env()</a></code> inside <code><a href="#topic+fuse">fuse()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the output format needs to be customized, the settings should be written
in the config file <code style="white-space: pre;">&#8288;_litedown.yml&#8288;</code>, e.g.,
</p>
<div class="sourceCode yaml"><pre>---
output:
  html:
    options:
      toc:
        depth: 4
  latex:
    meta:
      documentclass: "book"
</pre></div>
<p>In addition, you can configure the book via the <code>book</code> field, e.g.,
</p>
<div class="sourceCode yaml"><pre>---
book:
  new_session: true
  subdir: false
  pattern: "[.]R?md$"
  chapter_before: "Information before a chapter."
  chapter_after: "This chapter was generated from `$input$`."
---
</pre></div>
<p>The option <code>new_session</code> specifies whether to render each input file in the
current R session or a separate new R session; <code>chapter_before</code> and
<code>chapter_after</code> specify text to be added to the beginning and end of each
file, respectively, which accepts some variables (e.g., <code style="white-space: pre;">&#8288;$input$&#8288;</code> is the
current input file path).
</p>


<h3>Value</h3>

<p>An output file path or the output content, depending on the <code>output</code>
argument.
</p>

<hr>
<h2 id='fuse_env'>The <code>fuse()</code> environment</h2><span id='topic+fuse_env'></span>

<h3>Description</h3>

<p>Get the environment passed to the <code>envir</code> argument of <code><a href="#topic+fuse">fuse()</a></code>, i.e., the
environment in which code chunks and inline code are evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuse_env()
</code></pre>


<h3>Value</h3>

<p>When called during <code>fuse()</code>, it returns the <code>envir</code> argument value of
<code>fuse()</code>. When called outside <code>fuse()</code>, it returns the global environment.
</p>

<hr>
<h2 id='fuse_site'>Fuse R Markdown documents individually under a directory</h2><span id='topic+fuse_site'></span>

<h3>Description</h3>

<p>Run <code><a href="#topic+fuse">fuse()</a></code> on R Markdown documents individually to generate a website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fuse_site(input = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fuse_site_+3A_input">input</code></td>
<td>
<p>The root directory of the site, or a vector of input file paths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a directory contains a config file <code style="white-space: pre;">&#8288;_litedown.yml&#8288;</code>, which has a YAML field
<code>site</code>, the directory will be recognized as a site root directory. The YAML
field <code>output</code> will be applied to all R Markdown files (an individual R
Markdown file can provide its own <code>output</code> field in YAML to override the
global config). For example:
</p>
<div class="sourceCode yaml"><pre>---
site:
  rebuild: "outdated"
  pattern: "[.]R?md$"
output:
  html:
    meta:
      css: ["@default"]
      include_before: "[Home](/) [About](/about.html)"
      include_after: "&amp;copy; 2024 | [Edit]($input$)"
---
</pre></div>
<p>The option <code>rebuild</code> determines whether to rebuild <code>.Rmd</code> files. Possible
values are:
</p>

<ul>
<li> <p><code>newfile</code>: Build an input file if it does not have a <code>.html</code> output file.
</p>
</li>
<li> <p><code>outdated</code>: Rebuild an input file if the modification time of its <code>.html</code>
output file is older than the input.
</p>
</li></ul>



<h3>Value</h3>

<p>Output file paths (invisibly).
</p>

<hr>
<h2 id='get_context'>Get the <code>fuse()</code> context</h2><span id='topic+get_context'></span>

<h3>Description</h3>

<p>A helper function to query the <code><a href="#topic+fuse">fuse()</a></code> context (such as the input file path
or the output format name) when called inside a code chunk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_context(item = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_context_+3A_item">item</code></td>
<td>
<p>The name of the context item.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the <code>item</code> is provided, return its value in the context. If
<code>NULL</code>, the whole context (an environment) is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>litedown::get_context("input")
litedown::get_context("format")
names(litedown::get_context())  # all available items
</code></pre>

<hr>
<h2 id='html_format'>Output formats in YAML metadata</h2><span id='topic+html_format'></span><span id='topic+latex_format'></span>

<h3>Description</h3>

<p>These functions exist only for historical reasons, and should never be called
directly. They can be used to configure output formats in YAML, but you are
recommended to use the file format names instead of these function names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_format(options = NULL, meta = NULL, template = NULL, keep_md = FALSE)

latex_format(
  options = NULL,
  meta = NULL,
  template = NULL,
  keep_md = FALSE,
  keep_tex = FALSE,
  latex_engine = "xelatex",
  citation_package = "natbib"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="html_format_+3A_meta">meta</code>, <code id="html_format_+3A_options">options</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+mark">mark()</a></code>.</p>
</td></tr>
<tr><td><code id="html_format_+3A_template">template</code></td>
<td>
<p>A template file path.</p>
</td></tr>
<tr><td><code id="html_format_+3A_keep_md">keep_md</code>, <code id="html_format_+3A_keep_tex">keep_tex</code></td>
<td>
<p>Whether to keep the intermediate &lsquo;<span class="file">.md</span>&rsquo; and
&lsquo;<span class="file">.tex</span>&rsquo; files generated from &lsquo;<span class="file">.Rmd</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="html_format_+3A_latex_engine">latex_engine</code></td>
<td>
<p>The LaTeX engine to compile &lsquo;<span class="file">.tex</span>&rsquo; to &lsquo;<span class="file">.pdf</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="html_format_+3A_citation_package">citation_package</code></td>
<td>
<p>The LaTeX package for processing citations. Possible
values are <code>none</code>, <code>natbib</code>, and <code>biblatex</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To configure output formats in the YAML metadata of the Markdown document,
simply use the output format names such as <code>html</code> or <code>latex</code> in the <code>output</code>
field in YAML, e.g.,
</p>
<div class="sourceCode yaml"><pre>---
output:
  html:
    options:
      toc: true
    keep_md: true
  latex:
    latex_engine: pdflatex
---
</pre></div>
<p>You can also use <code>litedown::html_format</code> instead of <code>html</code> (or
<code>litedown::latex_format</code> instead of <code>latex</code>) if you like.
</p>


<h3>Note</h3>

<p>If you want to use the <code>Knit</code> button in RStudio, you must add a
top-level field <code>knit: litedown:::knit</code> to the YAML metadata. See
<a href="https://yihui.org/litedown/#sec:knit-button">https://yihui.org/litedown/#sec:knit-button</a> for more information.
</p>

<hr>
<h2 id='markdown_options'>Markdown rendering options</h2><span id='topic+markdown_options'></span>

<h3>Description</h3>

<p>A list of all options to control Markdown rendering. Options that are enabled
by default are marked by a <code>+</code> prefix, and those disabled by default are
marked by <code>-</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markdown_options()
</code></pre>


<h3>Details</h3>

<p>See <a href="https://yihui.org/litedown/#sec:markdown-options">https://yihui.org/litedown/#sec:markdown-options</a> for the full list of
options and their documentation.
</p>


<h3>Value</h3>

<p>A character vector of all available options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all available options
litedown::markdown_options()

library(litedown)

# toc example
mkd &lt;- c("# Header 1", "p1", "## Header 2", "p2")

mark(mkd, options = "+number_sections")
mark(mkd, options = "+number_sections+toc")

# hard_wrap example
mark("foo\nbar\n")
mark("foo\nbar\n", options = "+hardbreaks")

# latex math example
mkd &lt;- c(
  "`$x$` is inline math $x$!", "", "Display style:", "", "$$x + y$$", "",
  "\\begin{align}
a^{2}+b^{2} &amp; = c^{2}\\\\
\\sin^{2}(x)+\\cos^{2}(x) &amp; = 1
\\end{align}"
)

mark(mkd)
mark(mkd, options = "-latex_math")

# table example
mark("
First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell
")

# caption
mark("
| a | b |
|---|--:|
| A | 9 |

Table: A table _caption_.
")

# no table
mark("
First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell
", options = '-table')

# autolink example
mark("https://www.r-project.org/")
mark("https://www.r-project.org/", options = "-autolink")

# links and spans
mark('[a b](#){.red}')
mark('[a\nb](){.red}')

# strikethrough example
mark("~~awesome~~")
mark("~~awesome~~", options = "-strikethrough")

# superscript and subscript examples
mark("2^10^")
mark("2^10^", options = "-superscript")
mark("H~2~O")
mark("H~2~O", options = "-subscript")

# code blocks
mark('```r\n1 + 1;\n```')
mark('```{.r}\n1 + 1;\n```')
mark('```{.r .js}\n1 + 1;\n```')
mark('```{.r .js #foo}\n1 + 1;\n```')
mark('```{.r .js #foo style="background:lime;"}\n1 + 1;\n```')
mark('````\nA _code chunk_:\n\n```{r, echo=TRUE}\n1 + 1;\n```\n````')

# raw blocks
mark('```{=html}\n&lt;p&gt;raw HTML&lt;/p&gt;\n```')
mark('```{=latex}\n\\textbf{raw LaTeX}\n```')

# filter out HTML tags
mkd = '&lt;style&gt;a {}&lt;/style&gt;&lt;script type="text/javascript"&gt;console.log("No!");&lt;/script&gt;\n[Hello](#)'
mark(mkd)
# tagfiler doesn't work: https://github.com/r-lib/commonmark/issues/15
# mark(mkd, options = "tagfilter")
</code></pre>

<hr>
<h2 id='pkg_desc'>Print the package description, news, citation, manual pages, and source code</h2><span id='topic+pkg_desc'></span><span id='topic+pkg_news'></span><span id='topic+pkg_code'></span><span id='topic+pkg_citation'></span><span id='topic+pkg_manual'></span>

<h3>Description</h3>

<p>Helper functions to retrieve various types of package information that can be
put together as the full package documentation like a <span class="pkg">pkgdown</span> website.
These functions can be called inside any R Markdown document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg_desc(name = detect_pkg())

pkg_news(
  name = detect_pkg(),
  path = detect_news(name),
  recent = 1,
  toc = TRUE,
  number_sections = TRUE,
  ...
)

pkg_code(
  path = attr(detect_pkg(), "path"),
  pattern = "[.](R|c|h|f|cpp)$",
  toc = TRUE,
  number_sections = TRUE,
  link = TRUE
)

pkg_citation(name = detect_pkg())

pkg_manual(
  name = detect_pkg(),
  toc = TRUE,
  number_sections = TRUE,
  overview = TRUE,
  examples = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkg_desc_+3A_name">name</code></td>
<td>
<p>The package name (by default, it is automatically detected from
the <code>DESCRIPTION</code> file if it exists in the current working directory or
upper-level directories).</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_path">path</code></td>
<td>
<p>For <code><a href="#topic+pkg_news">pkg_news()</a></code>, path to the <code>NEWS.md</code> file. If empty, <code><a href="utils.html#topic+news">news()</a></code>
will be called to retrieve the news entries. For <code><a href="#topic+pkg_code">pkg_code()</a></code>, path to the
package root directory that contains <code style="white-space: pre;">&#8288;R/&#8288;</code> and/or <code style="white-space: pre;">&#8288;src/&#8288;</code> subdirectories.</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_recent">recent</code></td>
<td>
<p>The number of recent versions to show. By default, only the
latest version's news entries are retrieved. To show the full news, set
<code>recent = 0</code>.</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_toc">toc</code></td>
<td>
<p>Whether to add section headings to the document TOC (when TOC has
been enabled for the document).</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_number_sections">number_sections</code></td>
<td>
<p>Whether to number section headings (when sections are
numbered in the document).</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="utils.html#topic+news">news()</a></code>.</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression to match filenames that should be treated
as source code.</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_link">link</code></td>
<td>
<p>Whether to add links on the file paths of source code. By
default, if a GitHub repo link is detected from the <code>BugReports</code> field of
the package <code>DESCRIPTION</code>, GitHub links will be added to file paths. You
can also provide a string template containing the placeholder <code style="white-space: pre;">&#8288;%s&#8288;</code> (which
will be filled out with the file paths via <code>sprintf()</code>), e.g.,
<code style="white-space: pre;">&#8288;https://github.com/yihui/litedown/blob/main/%s&#8288;</code>.</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_overview">overview</code></td>
<td>
<p>Whether to include the package overview page, i.e., the
<code>{name}-package.Rd</code> page.</p>
</td></tr>
<tr><td><code id="pkg_desc_+3A_examples">examples</code></td>
<td>
<p>A list of arguments to be passed to <code><a href="xfun.html#topic+record">xfun::record()</a></code> to run
examples each help page, e.g., <code>list(dev = 'svg', dev.args = list(height = 6))</code>. If not a list (e.g., <code>FALSE</code>), examples will not be run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector (HTML or Markdown) that will be printed as is
inside a code chunk of an R Markdown document.
</p>
<p><code>pkg_desc()</code> returns an HTML table containing the package metadata.
</p>
<p><code>pkg_news()</code> returns the news entries.
</p>
<p><code>pkg_code()</code> returns the package source code under the <code style="white-space: pre;">&#8288;R/&#8288;</code> and
<code style="white-space: pre;">&#8288;src/&#8288;</code> directories.
</p>
<p><code>pkg_citation()</code> returns the package citation in both the plain-text
and BibTeX formats.
</p>
<p><code>pkg_manual()</code> returns all manual pages of the package in HTML.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
litedown::pkg_desc()
litedown::pkg_news()
litedown::pkg_citation()

## End(Not run)
</code></pre>

<hr>
<h2 id='raw_text'>Mark a character vector as raw output</h2><span id='topic+raw_text'></span>

<h3>Description</h3>

<p>This function should be called inside a code chunk, and its effect is the
same as the chunk option <code>results = "asis"</code>. The input character vector will
be written verbatim to the output (and interpreted as Markdown).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_text(x, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_text_+3A_x">x</code></td>
<td>
<p>A character vector (each element will be treated as a line).</p>
</td></tr>
<tr><td><code id="raw_text_+3A_format">format</code></td>
<td>
<p>An output format name, e.g., <code>html</code> or <code>latex</code>. If provided,
<code>x</code> will be wrapped in a fenced code block, e.g., <code style="white-space: pre;">&#8288; ```{=html}&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with a special class to indicate that it should be
treated as raw output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>litedown::raw_text(c("**This**", "_is_", "[Markdown](#)."))
litedown::raw_text("&lt;b&gt;Bold&lt;/b&gt;", "html")
litedown::raw_text("\\textbf{Bold}", "latex")
</code></pre>

<hr>
<h2 id='reactor'>Get and set chunk options</h2><span id='topic+reactor'></span>

<h3>Description</h3>

<p>Chunk options are stored in an environment returned by <code>reactor()</code>. Option
values can be queried by passing their names to <code>reactor()</code>, and set by
passing named values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reactor(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reactor_+3A_...">...</code></td>
<td>
<p>Named values (for setting) or unnamed values (for getting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>With no arguments, <code>reactor()</code> returns an environment that stores the
options, which can also be used to get or set options. For example, with
<code>opts = reactor()</code>, <code>opts$name</code> returns an option value, and <code>opts$name = value</code> sets an option to a value.
</p>
<p>With named arguments, <code>reactor()</code> sets options and returns a list of their
old values (e.g., <code>reactor(echo = FALSE, fig.width = 8)</code>). The returned
list can be passed to <code>reactor()</code> later to restore the options.
</p>
<p>With unnamed arguments, <code>reactor()</code> returns option values after received
option names as input. If one name is received, its value is returned
(e.g., <code>reactor('echo')</code>). If multiple names are received, a named list of
values is returned (e.g., <code>reactor(c('echo', 'fig.width'))</code>). A special
case is that if only one unnamed argument is received and it takes a list
of named values, the list will be used to set options, e.g.,
<code>reactor(list(echo = FALSE, fig.width = 8))</code>, which is equivalent to
<code>reactor(echo = FALSE, fig.width = 8)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get options
litedown::reactor("echo")
litedown::reactor(c("echo", "fig.width"))

# set options
old = litedown::reactor(echo = FALSE, fig.width = 8)
litedown::reactor(c("echo", "fig.width"))
litedown::reactor(old)  # restore options

# use the environment directly
opts = litedown::reactor()
opts$echo
mget(c("echo", "fig.width"), opts)
ls(opts)  # built-in options
</code></pre>

<hr>
<h2 id='roam'>Preview Markdown and R Markdown files</h2><span id='topic+roam'></span>

<h3>Description</h3>

<p>Launch a web page to list and preview files under a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roam(dir = ".", live = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roam_+3A_dir">dir</code></td>
<td>
<p>A directory path.</p>
</td></tr>
<tr><td><code id="roam_+3A_live">live</code></td>
<td>
<p>Whether to enable live preview. If enabled, the browser page will
be automatically updated upon modification of local files used by the page
(e.g., the Markdown file or external CSS/JS/image files). If disabled, you
can manually refresh the page to fully re-render it.</p>
</td></tr>
<tr><td><code id="roam_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="xfun.html#topic+new_app">xfun::new_app()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Markdown files will be converted to HTML and returned to the web browser
directly without writing to HTML files, to keep the directory clean during
the preview. Clicking on a filename will bring up an HTML preview. To see its
raw content, click on the link on its file size instead.
</p>


<h3>Value</h3>

<p>A URL (invisibly) for the preview.
</p>

<hr>
<h2 id='smartypants'>Convert some ASCII strings to HTML entities</h2><span id='topic+smartypants'></span>

<h3>Description</h3>

<p>Transform ASCII strings <code>(c)</code> (copyright), <code>(r)</code> (registered trademark),
<code>(tm)</code> (trademark), and fractions <code>n/m</code> into <em>smart</em> typographic HTML
entities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smartypants(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smartypants_+3A_text">text</code></td>
<td>
<p>A character vector of the Markdown text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the transformed text.
</p>

<hr>
<h2 id='timing_data'>Get the timing data of code chunks and text blocks in a document</h2><span id='topic+timing_data'></span>

<h3>Description</h3>

<p>Timing can be enabled via the chunk option <code>time = TRUE</code> (e.g., set
<a href="#topic+reactor">reactor</a><code>(time = TRUE)</code> in the first code chunk). After it is
enabled, the execution time for code chunks and text blocks will be recorded.
This function can be called to retrieve the timing data later in the document
(e.g., in the last code chunk).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timing_data(threshold = 0, sort = TRUE, total = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timing_data_+3A_threshold">threshold</code></td>
<td>
<p>A number (time in seconds) to subset data with. Only rows
with time above this threshold are returned.</p>
</td></tr>
<tr><td><code id="timing_data_+3A_sort">sort</code></td>
<td>
<p>Whether to sort the data by time in the decreasing order.</p>
</td></tr>
<tr><td><code id="timing_data_+3A_total">total</code></td>
<td>
<p>Whether to append the total time to the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing input file paths, line numbers, chunk labels,
and time. If no timing data is available, <code>NULL</code> is returned.
</p>


<h3>Note</h3>

<p>By default, the data will be cleared after each call of <code><a href="#topic+fuse">fuse()</a></code> and
will not be available outside <code><a href="#topic+fuse">fuse()</a></code>. To store the data persistently, you
can set the <code>time</code> option to a file path. This is necessary if you want to
get the timing data for multiple input documents (such as all chapters of a
book). Each document needs to point the <code>time</code> option to the same path.
When you do not need timing any more, you will need to delete this file by
yourself.
</p>

<hr>
<h2 id='vest'>Add CSS/JS assets to HTML output</h2><span id='topic+vest'></span>

<h3>Description</h3>

<p>While CSS/JS assets can be set via the <code>css</code>/<code>js</code> keys under the <code>meta</code> field
of the <code>html</code> output format in YAML, this function provides another way to
add them, which can be called in a code chunk to dynamically add assets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vest(feature = NULL, css = NULL, js = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vest_+3A_feature">feature</code></td>
<td>
<p>A character vector of features supported by CSS/JS, e.g.,
<code>c('article', 'callout')</code>. See the row names of <code>litedown:::assets</code> for all
available features. Each feature will be mapped to CSS/JS.</p>
</td></tr>
<tr><td><code id="vest_+3A_css">css</code>, <code id="vest_+3A_js">js</code></td>
<td>
<p>Character vectors of CSS/JS assets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code style="white-space: pre;">&#8288;&lt;link&gt;&#8288;</code> (CSS) or <code style="white-space: pre;">&#8288;&lt;script&gt;&#8288;</code> (JS) tags.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>litedown:::assets[, -1]
# add features
litedown::vest(c("copy-button", "tabsets"))
# add css/js directly
litedown::vest(css = "@tabsets", js = c("@tabsets", "@fold-details"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
