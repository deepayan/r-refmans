<!DOCTYPE html><html><head><title>Help for package RPEGLMEN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RPEGLMEN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fit.glmGammaNet'><p>Elastic Net Penalized Gamma or Exponentially Distributed Response Variables</p></a></li>
<li><a href='#glmnet_exp'><p>Elastic Net Penalized Exponentially Distributed Response Variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gamma and Exponential Generalized Linear Models with Elastic Net
Penalty</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Christidis &lt;anthony.christidis@stat.ubc.ca&gt;, 
  Xin Chen &lt;chenx26@uw.edu&gt;, 
  Daniel Hanson &lt;hansondj@uw.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Christidis &lt;anthony.christidis@stat.ubc.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the fast iterative shrinkage-thresholding algorithm
             (FISTA) algorithm to fit a Gamma distribution with an elastic net 
             penalty as described in Chen, Arakvin and Martin (2018) 
             &lt;<a href="https://arxiv.org/abs/1804.07780">arXiv:1804.07780</a>&gt;. An implementation for the case of the 
             exponential distribution is also available, with details available 
             in Chen and Martin (2018) <a href="https://papers.ssrn.com/abstract_id=3085672">https://papers.ssrn.com/abstract_id=3085672</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.3), RPEIF</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, testthat, PerformanceAnalytics</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-29 00:49:33 UTC; antho</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-29 03:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fit.glmGammaNet'>Elastic Net Penalized Gamma or Exponentially Distributed Response Variables</h2><span id='topic+fit.glmGammaNet'></span>

<h3>Description</h3>

<p><code>git.glmGammaNet</code> Fit glmnet model for Gamma distributed response data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.glmGammaNet(
  A,
  b,
  exponential.dist = FALSE,
  alpha.EN = 0.5,
  num_lambda = 100L,
  glm_type = 1L,
  max_iter = 100L,
  abs_tol = 1e-04,
  rel_tol = 0.01,
  normalize_grad = FALSE,
  k_fold = 5L,
  has_intercept = TRUE,
  k_fold_iter = 5L,
  min.lambda.ratio = 1e-04,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.glmGammaNet_+3A_a">A</code></td>
<td>
<p>The matrix of independent variables.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_b">b</code></td>
<td>
<p>The vector of response variables.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_exponential.dist">exponential.dist</code></td>
<td>
<p>Parameter to determine whether we use the Exponential distribution (TRUE) or the Gamma distribution (FALSE).</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_alpha.en">alpha.EN</code></td>
<td>
<p>The coefficient of elastic net regularizer (1 means lasso).</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_num_lambda">num_lambda</code></td>
<td>
<p>Size of the lambda grid.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_glm_type">glm_type</code></td>
<td>
<p>Type of glm model, 1 is exponential, 2 is gamma (not implemented yet).</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_max_iter">max_iter</code></td>
<td>
<p>Max number of iteration for the prox grad descent optimizer.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_abs_tol">abs_tol</code></td>
<td>
<p>Absolute error threshold for the pgd optimizer.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_rel_tol">rel_tol</code></td>
<td>
<p>Relative error threshold for the pgd optimizer (not used for vanilla PGD).</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_normalize_grad">normalize_grad</code></td>
<td>
<p>Swtich for whether to normalize the gradient or not.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_k_fold">k_fold</code></td>
<td>
<p>The number of folds for cross validation.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_has_intercept">has_intercept</code></td>
<td>
<p>Parameter to determine if there is an intercept (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_k_fold_iter">k_fold_iter</code></td>
<td>
<p>The number of iterations for the cross-validation.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_min.lambda.ratio">min.lambda.ratio</code></td>
<td>
<p>Minimum lambda ratio for cross-validation.</p>
</td></tr>
<tr><td><code id="fit.glmGammaNet_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of optimal coefficient for the glm model.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Function to return the periodogram of data series
myperiodogram &lt;- function (data, max.freq = 0.5, 
                           twosided = FALSE, keep = 1){
  data.fft &lt;- fft(data)
  N &lt;- length(data)
  tmp &lt;- Mod(data.fft[2:floor(N/2)])^2/N
  freq &lt;- ((1:(floor(N/2) - 1))/N)
  tmp &lt;- tmp[1:floor(length(tmp) * keep)]
  freq &lt;- freq[1:floor(length(freq) * keep)]
  if (twosided) {
    tmp &lt;- c(rev(tmp), tmp)
    freq &lt;- c(-rev(freq), freq)
  }
  return(list(spec = tmp, freq = freq))
}

# Function to compute the standard error based the periodogram of 
# the influence functions time series
SE.Gamma &lt;- function(data, d = 7, alpha = 0.5, keep = 1){
  N &lt;- length(data)
  # Compute the periodograms
  my.periodogram &lt;- myperiodogram(data)
  my.freq &lt;- my.periodogram$freq
  my.periodogram &lt;- my.periodogram$spec
  # Remove values of frequency 0 as it does not contain information 
  # about the variance
  my.freq &lt;- my.freq[-1]
  my.periodogram &lt;- my.periodogram[-1]
  # Implement cut-off
  nfreq &lt;- length(my.freq)
  my.freq &lt;- my.freq[1:floor(nfreq*keep)]
  my.periodogram &lt;- my.periodogram[1:floor(nfreq*keep)]
  # GLM with BFGS optimization
  # Create 1, x, x^2, ..., x^d
  x.mat &lt;- rep(1,length(my.freq))
  for(col.iter in 1:d){
    x.mat &lt;- cbind(x.mat,my.freq^col.iter)
  }
  # Fit the Exponential or Gamma model
  res &lt;- fit.glmGammaNet(x.mat, my.periodogram, alpha.EN = alpha)
  # Return the estimated variance
  return(sqrt(exp(res[1])/N))
}

# Loading hedge fund data from PA
data(edhec, package = "PerformanceAnalytics")
colnames(edhec)

# Computing the expected shortfall for the time series of returns
# library(RPEIF)
# test.mat &lt;- apply(edhec, 2, IF.ES)
# test.mat &lt;- apply(test.mat, 2, as.numeric)

# Returning the standard errors from the Gamma distribution fit
# apply(test.mat, 2, SE.Gamma)

</code></pre>

<hr>
<h2 id='glmnet_exp'>Elastic Net Penalized Exponentially Distributed Response Variables</h2><span id='topic+glmnet_exp'></span>

<h3>Description</h3>

<p><code>git.glmGammaNet</code> Fit glmnet model for exponentiall distributed response data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmnet_exp(
  A,
  b,
  alpha.EN = 0.5,
  num_lambda = 100L,
  glm_type = 1L,
  max_iter = 100L,
  abs_tol = 1e-04,
  rel_tol = 0.01,
  normalize_grad = FALSE,
  k_fold = 5L,
  has_intercept = TRUE,
  k_fold_iter = 5L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmnet_exp_+3A_a">A</code></td>
<td>
<p>The matrix of independent variables.</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_b">b</code></td>
<td>
<p>The vector of response variables.</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_alpha.en">alpha.EN</code></td>
<td>
<p>The coefficient of elastic net regularizer (1 means lasso).</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_num_lambda">num_lambda</code></td>
<td>
<p>Size of the lambda grid.</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_glm_type">glm_type</code></td>
<td>
<p>Type of glm model, 1 is exponential, 2 is gamma (not implemented yet).</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_max_iter">max_iter</code></td>
<td>
<p>Max number of iteration for the prox grad descent optimizer.</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_abs_tol">abs_tol</code></td>
<td>
<p>Absolute error threshold for the pgd optimizer.</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_rel_tol">rel_tol</code></td>
<td>
<p>Relative error threshold for the pgd optimizer (not used for vanilla PGD).</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_normalize_grad">normalize_grad</code></td>
<td>
<p>Swtich for whether to normalize the gradient or not.</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_k_fold">k_fold</code></td>
<td>
<p>The number of folds for cross validation.</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_has_intercept">has_intercept</code></td>
<td>
<p>Parameter to determine if there is an intercept (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_k_fold_iter">k_fold_iter</code></td>
<td>
<p>The number of iterations for the cross-validation.</p>
</td></tr>
<tr><td><code id="glmnet_exp_+3A_...">...</code></td>
<td>
<p>Additional Parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of optimal coefficient for the glm model.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Function to return the periodogram of data series
myperiodogram &lt;- function (data, max.freq = 0.5, 
                           twosided = FALSE, keep = 1){
  data.fft &lt;- fft(data)
  N &lt;- length(data)
  tmp &lt;- Mod(data.fft[2:floor(N/2)])^2/N
  freq &lt;- ((1:(floor(N/2) - 1))/N)
  tmp &lt;- tmp[1:floor(length(tmp) * keep)]
  freq &lt;- freq[1:floor(length(freq) * keep)]
  if (twosided) {
    tmp &lt;- c(rev(tmp), tmp)
    freq &lt;- c(-rev(freq), freq)
  }
  return(list(spec = tmp, freq = freq))
}

# Function to compute the standard error based the periodogram of 
# the influence functions time series
SE.Exponential &lt;- function(data, d = 7, alpha = 0.5, keep = 1){
  N &lt;- length(data)
  # Compute the periodograms
  my.periodogram &lt;- myperiodogram(data)
  my.freq &lt;- my.periodogram$freq
  my.periodogram &lt;- my.periodogram$spec
  # Remove values of frequency 0 as it does not contain information 
  # about the variance
  my.freq &lt;- my.freq[-1]
  my.periodogram &lt;- my.periodogram[-1]
  # Implement cut-off
  nfreq &lt;- length(my.freq)
  my.freq &lt;- my.freq[1:floor(nfreq*keep)]
  my.periodogram &lt;- my.periodogram[1:floor(nfreq*keep)]
  # GLM with BFGS optimization
  # Create 1, x, x^2, ..., x^d
  x.mat &lt;- rep(1,length(my.freq))
  for(col.iter in 1:d){
    x.mat &lt;- cbind(x.mat,my.freq^col.iter)
  }
  # Fit the Exponential model
  res &lt;- glmnet_exp(x.mat, my.periodogram, alpha.EN = alpha)
  # Return the estimated variance
  return(sqrt(exp(res[1])/N))
}

# Loading hedge fund data from PA
data(edhec, package = "PerformanceAnalytics")
colnames(edhec)

# Computing the expected shortfall for the time series of returns
# library(RPEIF)
# test.mat &lt;- apply(edhec, 2, IF.ES)
# test.mat &lt;- apply(test.mat, 2, as.numeric)

# Returning the standard errors from the Exponential distribution fit
# apply(test.mat, 2, SE.Exponential)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
