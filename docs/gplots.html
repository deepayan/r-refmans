<!DOCTYPE html><html lang="en"><head><title>Help for package gplots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gplots}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust_hsv'><p>Adjust Color in HSV Space</p></a></li>
<li><a href='#angleAxis'><p>Add a Axis to a Plot with Rotated Labels</p></a></li>
<li><a href='#balloonplot'><p>Plot a graphical matrix where each cell contains a dot whose size</p>
reflects the relative magnitude of the corresponding component.</a></li>
<li><a href='#bandplot'><p>Plot x-y Points with Locally Smoothed Mean and Standard Deviation</p></a></li>
<li><a href='#barplot2'><p>Enhanced Bar Plots</p></a></li>
<li><a href='#boxplot2'><p>Produce a Boxplot Annotated with the Number of Observations</p></a></li>
<li><a href='#bubbleplot'><p>Bubble Plot</p></a></li>
<li><a href='#catch.d'><p>Catch at Age and Residuals</p></a></li>
<li><a href='#ci2d'>
<p>Create 2-dimensional empirical confidence regions</p></a></li>
<li><a href='#col2hex'><p>Convert color names to hex RGB strings</p></a></li>
<li><a href='#colorpanel'><p>Generate a smoothly varying set of colors</p></a></li>
<li><a href='#gplots-defunct'><p>Defunct functions</p></a></li>
<li><a href='#gplots-deprecated'><p>Deprecated functions</p></a></li>
<li><a href='#heatmap.2'><p> Enhanced Heat Map</p></a></li>
<li><a href='#hist2d'><p> Compute and Plot a 2-Dimensional Histogram</p></a></li>
<li><a href='#lmplot2'>
<p>Plots to assess the goodness of fit for the linear model objects</p></a></li>
<li><a href='#lowess'><p>Scatter Plot Smoothing</p></a></li>
<li><a href='#ooplot.default'><p>Create an OpenOffice style plot</p></a></li>
<li><a href='#overplot'><p>Plot multiple variables on the same region, with appropriate axes</p></a></li>
<li><a href='#plotCI'><p>Plot Error Bars and Confidence Intervals</p></a></li>
<li><a href='#plotmeans'><p>Plot Group Means and Confidence Intervals</p></a></li>
<li><a href='#qqnorm.aov'><p> Makes a half or full normal plot for the effects from an aov model</p></a></li>
<li><a href='#reorder.factor'><p>Reorder the Levels of a Factor</p></a></li>
<li><a href='#residplot'><p>Undocumented functions</p></a></li>
<li><a href='#rich.colors'><p>Rich Color Palettes</p></a></li>
<li><a href='#rtPCR'><p>Teratogenesis rtPCR data</p></a></li>
<li><a href='#sinkplot'><p>Send textual R output to a graphics device</p></a></li>
<li><a href='#space'><p>Space points in an x-y plot so they don't overlap.</p></a></li>
<li><a href='#textplot'><p>Display text information in a graphics plot.</p></a></li>
<li><a href='#venn'><p>Plot a Venn diagram</p></a></li>
<li><a href='#wapply'><p>Compute the Value of a Function Over a Local Region Of An X-Y Plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Various R Programming Tools for Plotting Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Various R programming tools for plotting data, including:
  - calculating and plotting locally smoothed summary function as
    ('bandplot', 'wapply'),
  - enhanced versions of standard plots ('barplot2', 'boxplot2',
    'heatmap.2', 'smartlegend'),
  - manipulating colors ('col2hex', 'colorpanel', 'redgreen',
    'greenred', 'bluered', 'redblue', 'rich.colors'),
  - calculating and plotting two-dimensional data summaries ('ci2d',
    'hist2d'),
  - enhanced regression diagnostic plots ('lmplot2', 'residplot'),
  - formula-enabled interface to 'stats::lowess' function ('lowess'),
  - displaying textual data in plots ('textplot', 'sinkplot'),
  - plotting dots whose size reflects the relative magnitude of the
    elements ('balloonplot', 'bubbleplot'),
  - plotting "Venn" diagrams ('venn'),
  - displaying Open-Office style plots ('ooplot'),
  - plotting multiple data on same region, with separate axes
    ('overplot'),
  - plotting means and confidence intervals ('plotCI', 'plotmeans'),
  - spacing points in an x-y plot so they don't overlap ('space').</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools, stats, caTools, KernSmooth, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grid, MASS, knitr, rmarkdown, r2d2, nlme</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-05</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/talgalili/gplots">https://github.com/talgalili/gplots</a>,
<a href="https://talgalili.github.io/gplots/">https://talgalili.github.io/gplots/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/talgalili/gplots/issues">https://github.com/talgalili/gplots/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-05 07:44:32 UTC; talgalili</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory R. Warnes [aut],
  Ben Bolker [aut],
  Lodewijk Bonebakker [aut],
  Robert Gentleman [aut],
  Wolfgang Huber [aut],
  Andy Liaw [aut],
  Thomas Lumley [aut],
  Martin Maechler [aut],
  Arni Magnusson [aut],
  Steffen Moeller [aut],
  Marc Schwartz [aut],
  Bill Venables [aut],
  Tal Galili [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tal Galili &lt;tal.galili@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-05 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust_hsv'>Adjust Color in HSV Space</h2><span id='topic+adjust_hsv'></span>

<h3>Description</h3>

<p>Adjust color hue, saturation, and/or alpha value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_hsv(col, h=NULL, s=NULL, v=NULL, alpha=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_hsv_+3A_col">col</code></td>
<td>
<p>a color or vector of colors.</p>
</td></tr>
<tr><td><code id="adjust_hsv_+3A_h">h</code></td>
<td>
<p>the desired hue.</p>
</td></tr>
<tr><td><code id="adjust_hsv_+3A_s">s</code></td>
<td>
<p>the desired saturation.</p>
</td></tr>
<tr><td><code id="adjust_hsv_+3A_v">v</code></td>
<td>
<p>the desired value.</p>
</td></tr>
<tr><td><code id="adjust_hsv_+3A_alpha">alpha</code></td>
<td>
<p>the desired transparency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colors can be specified as a color name, a hexadecimal string, or an integer.
</p>
<p>Hue, saturation, value, and transparency are specified as values from 0 to 1,
or <code>NULL</code> to leave unchanged.
</p>


<h3>Value</h3>

<p>Adjusted colors in hexadecimal string format.</p>


<h3>Author(s)</h3>

<p>Arni Magnusson.</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>, <code><a href="grDevices.html#topic+rgb2hsv">rgb2hsv</a></code>, and <code><a href="grDevices.html#topic+hsv">hsv</a></code> are the
underlying functions used to convert and adjust the colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col &lt;- "#123456"
col2 &lt;- adjust_hsv(col, h=0.1)
col3 &lt;- adjust_hsv(col, s=0.1)
col4 &lt;- adjust_hsv(col, v=0.7)

barplot(rep(1, 4), col=c(col, col2, col3, col4))
</code></pre>

<hr>
<h2 id='angleAxis'>Add a Axis to a Plot with Rotated Labels</h2><span id='topic+angleAxis'></span>

<h3>Description</h3>

<p>Add a labeled axis to the current plot with rotated text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angleAxis(side, labels, at = 1:length(labels), srt = 45, adj, xpd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="angleAxis_+3A_side">side</code></td>
<td>

<p>an integer specifying which side of the plot the axis is to be
drawn on. The axis is placed as follows: 1=below, 2=left, 3=above and 
4=right.
</p>
</td></tr>
<tr><td><code id="angleAxis_+3A_labels">labels</code></td>
<td>
<p>character or expression vector of labels to be placed at the
tickpoints.
</p>
</td></tr>
<tr><td><code id="angleAxis_+3A_at">at</code></td>
<td>
<p>the points at which tick-marks are to be drawn. Non-finite
(infinite, NaN or NA) values are omitted.
</p>
</td></tr>
<tr><td><code id="angleAxis_+3A_srt">srt</code></td>
<td>

<p>The string rotation in degrees. Defaults to 45 degrees (clockwise).
</p>
</td></tr>
<tr><td><code id="angleAxis_+3A_adj">adj</code></td>
<td>
<p>Text justification.  
A value of 0 produces left-justified text, 0.5 centered text and 1 
right-justified text. For <code>side=1</code> and <code>side=2</code>, the 
default value is <code>adj=1</code>.  For <code>side=3</code> and <code>side=4</code> 
the default value is <code>adj=0</code>.
</p>
</td></tr>
<tr><td><code id="angleAxis_+3A_xpd">xpd</code></td>
<td>
<p>A logical value or NA. If FALSE, labels are clipped to the 
plot region, if TRUE, labels are clipped to the figure region, and
if NA, labels are clipped to the device region.
</p>
</td></tr>
<tr><td><code id="angleAxis_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>text</code>.  Common examples are <code>col</code>, <code>cex</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function augments the feature of the <code>axis</code> functon by allowing the axis labels to be rotated.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+axis">axis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a vector with some values and long labels
values &lt;- sample(1:10)
names(values) &lt;- sapply(letters[1:10], 
                        function(x) paste(rep(x, 10), sep="",collapse="") 
                        ) 

# barplot labels are too long for the available space, hence some are not plotted
barplot(values)

# to add angled labels, tell barplot not to label the x axis, and store the bar location
at &lt;- barplot(values, xaxt="n")
# then use angleAxs
angleAxis(1, at=at, labels = names(values))

# angle counter-clockwise instead
at &lt;- barplot(values, xaxt="n")
angleAxis(1, at=at, labels = names(values), srt=-45, adj=0)

# put labels at the top
oldpar &lt;- par()$mar
par(mar=c(1,4,5,2)+0.1)
at &lt;- barplot(values, xaxt="n")
angleAxis(3, at=at, labels = names(values))
par(oldpar)

# put labels on the left
oldpar &lt;- par()$mar
par(mar=c(5,5,3,2)+0.1)
at &lt;- barplot(values, yaxt="n", horiz=TRUE)
angleAxis(2, at=at, labels = names(values))
par(oldpar)

# put labels on the right
oldpar &lt;- par()$mar
par(mar=c(2,5,3,5)+0.1)
at &lt;- barplot(values, yaxt="n", horiz=TRUE)
angleAxis(4, at=at, labels = names(values))
par(oldpar)

# specify colors for bars and labels
at &lt;- barplot(values, xaxt="n", col=1:10)
angleAxis(1, at=at, labels = names(values), col=1:10)
</code></pre>

<hr>
<h2 id='balloonplot'>Plot a graphical matrix where each cell contains a dot whose size
reflects the relative magnitude of the corresponding component.</h2><span id='topic+balloonplot'></span><span id='topic+balloonplot.default'></span><span id='topic+balloonplot.table'></span>

<h3>Description</h3>

<p>Plot a graphical matrix where each cell contains a dot whose size
reflects the relative magnitude of the corresponding component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balloonplot(x, ...)
## S3 method for class 'table'
balloonplot(x, xlab, ylab, zlab, show.zeros=FALSE,show.margins=TRUE,...)
## Default S3 method:
balloonplot(x,y,z,
                                xlab,
                                ylab,
                                zlab=deparse(substitute(z)),
                                dotsize=2/max(strwidth(19),strheight(19)),
                                dotchar=19,
                                dotcolor="skyblue",
                                text.size=1,
                                text.color=par("fg"),
                                main,
                                label=TRUE,
                                label.digits=2,
                                label.size=1,
                                label.color=par("fg"),
                                scale.method=c("volume","diameter"),
                                scale.range=c("absolute","relative"),
                                colsrt=par("srt"),
                                rowsrt=par("srt"),
                                colmar=1,
                                rowmar=2,
                                show.zeros=FALSE,
                                show.margins=TRUE,
                                cum.margins=TRUE,
                                sorted=TRUE,
                                label.lines=TRUE,
                                fun=function(x)sum(x,na.rm=T),
                                hide.duplicates=TRUE,
                                ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balloonplot_+3A_x">x</code></td>
<td>
<p>A table object, or either a vector or a list of several
categorical vectors containing grouping variables for the first 
(x) margin of the plotted matrix.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_y">y</code></td>
<td>
<p>Vector or list of vectors for grouping variables for the
second (y) dimension of the plotted matrix.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_z">z</code></td>
<td>
<p>Vector of values for the size of the dots in the plotted matrix.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_xlab">xlab</code></td>
<td>
<p>Text label for the x dimension. This will be displayed on the
x axis and in the plot title.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_ylab">ylab</code></td>
<td>
<p>Text label for the y dimension. This will be displayed on the
y axis and in the plot title.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_zlab">zlab</code></td>
<td>
<p>Text label for the dot size. This will be included in the
plot title.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_dotsize">dotsize</code></td>
<td>
<p>Maximum dot size.  You may need to adjust this value
for different plot devices and layouts.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_dotchar">dotchar</code></td>
<td>
<p>Plotting symbol or character used for dots.  See the help
page for the points function for symbol codes.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_dotcolor">dotcolor</code></td>
<td>
<p>Scalar or vector specifying the color(s) of the dots in
the plot.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_text.size">text.size</code>, <code id="balloonplot_+3A_text.color">text.color</code></td>
<td>
<p>Character size and color for row and
column headers</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_main">main</code></td>
<td>
<p>Plot title text.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_label">label</code></td>
<td>
<p>Boolean flag indicating whether the actual value of the
elements should be shown on the plot.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_label.digits">label.digits</code></td>
<td>
<p>Number of digits used in formatting value labels.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_label.size">label.size</code>, <code id="balloonplot_+3A_label.color">label.color</code></td>
<td>
<p> Character size and color for value labels.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_scale.method">scale.method</code></td>
<td>
<p>Method of scaling the sizes of the dot, either
&quot;volume&quot; or &quot;diameter&quot;. See below.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_scale.range">scale.range</code></td>
<td>
<p>Method for scaling original data to compute
circle diameter.  <code>scale.range="absolute"</code> scales the data
relative to 0 (i.e, maps [0,max(z)] &ndash;&gt; [0,1]), while
<code>scale.range="relative"</code> scales the data relative to min(z)
(i.e. maps [min(z), max(z)] &ndash;&gt; [0,1]).</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_rowsrt">rowsrt</code>, <code id="balloonplot_+3A_colsrt">colsrt</code></td>
<td>
<p>Angle of rotation for row and column labels.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_rowmar">rowmar</code>, <code id="balloonplot_+3A_colmar">colmar</code></td>
<td>
<p>Space allocated for row and column labels. Each
unit is the width/height of one cell in the table.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_show.zeros">show.zeros</code></td>
<td>
<p>boolean. If <code>FALSE</code>, entries containing zero will be left
blank in the plotted matrix.  If <code>TRUE</code>, zeros will be
displayed.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_show.margins">show.margins</code></td>
<td>
<p>boolean. If <code>TRUE</code>, row and column sums are
printed in the bottom and right margins, respectively.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_cum.margins">cum.margins</code></td>
<td>
<p>boolean. If <code>TRUE</code>, marginal fractions are
graphically presented in grey behind the row/column label area.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_sorted">sorted</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the rows will be
arranged in sorted order by using the levels of the first y factor,
then the second y factor, etc. The same process is used for the
columns, based on the x factors</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_label.lines">label.lines</code></td>
<td>
<p>boolean. If <code>TRUE</code>, borders will be drawn for
row and column level headers.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_hide.duplicates">hide.duplicates</code></td>
<td>
<p>boolean. If <code>TRUE</code>, column and row headers
will omit duplicates within row/column to reduce clutter.  Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="balloonplot_+3A_fun">fun</code></td>
<td>
<p>function to be used to combine data elements with the same
levels of the grouping variables <code>x</code> and <code>y</code>. Defaults to <code>sum</code></p>
</td></tr>
<tr><td><code id="balloonplot_+3A_...">...</code></td>
<td>
<p> Additional arguments passed to <code>balloonplot.default</code>
or <code>plot</code>, as appropriate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots a visual matrix.  In each <code>x</code>,<code>y</code> cell a
dot is plotted which reflects the relative size of the corresponding
value of <code>z</code>.  When <code>scale.method="volume"</code> the volume of
the dot is proportional to the relative size of <code>z</code>.  When
<code>scale.method="diameter"</code>, the diameter of the dot is proportional to
the the relative size of <code>z</code>.  The &quot;volume&quot; method is default
because the &quot;diameter&quot; method visually exaggerates differences.
</p>


<h3>Value</h3>

<p>Nothing of interest.
</p>


<h3>Note</h3>

<p><code>z</code> is expected to be non-negative.  The function will still
operate correctly if there are negative values of <code>z</code>, but the
corresponding dots will have 0 size and a warning will be generated.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>References</h3>

<p>Function inspired by question posed on R-help by Ramon
Alonso-Allende <a href="mailto:allende@cnb.uam.es">allende@cnb.uam.es</a>.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.table">plot.table</a></code>.
</p>
<p><code><a href="#topic+bubbleplot">bubbleplot</a></code> provides an alternative interface and visual
style based on scatterplots instead of tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Create an Example Data Frame Containing Car x Color data
carnames &lt;- c("bmw","renault","mercedes","seat")
carcolors &lt;- c("red","white","silver","green")
datavals &lt;- round(rnorm(16, mean=100, sd=60),1)
data &lt;- data.frame(Car=rep(carnames,4),
                   Color=rep(carcolors, c(4,4,4,4) ),
                   Value=datavals )
# show the data
data

# generate balloon plot with default scaling
balloonplot( data$Car, data$Color, data$Value)


# show margin label rotation &amp; space expansion, using some long labels
levels(data$Car) &lt;- c("BMW: High End, German","Renault: Medium End, French",
 "Mercedes: High End, German", "Seat: Imaginary, Unknown Producer")

# generate balloon plot with default scaling
balloonplot( data$Car, data$Color, data$Value, colmar=3, colsrt=90)

# Create an example using table
xnames &lt;- sample( letters[1:3], 50, replace=2)
ynames &lt;- sample( 1:5, 50, replace=2)

tab &lt;- table(xnames, ynames)

balloonplot(tab)

# Example of multiple classification variabls using the Titanic data
library(datasets)
data(Titanic)

dframe &lt;- as.data.frame(Titanic) # convert to 1 entry per row format
attach(dframe)
balloonplot(x=Class, y=list(Survived, Age, Sex), z=Freq, sort=TRUE)

# colorize: surviors lightblue, non-survivors: grey
Colors &lt;- Titanic
Colors[,,,"Yes"] &lt;- "skyblue"
Colors[,,,"No"] &lt;- "grey"
colors &lt;- as.character(as.data.frame(Colors)$Freq)

balloonplot(x=list(Age,Sex),
            y=list(Class=Class,
                   Survived=reorder.factor(Survived,new.order=c(2,1))
                   ),
            z=Freq,
            zlab="Number of Passengers",
            sort=TRUE,
            dotcol = colors,
            show.zeros=TRUE,
            show.margins=TRUE)


</code></pre>

<hr>
<h2 id='bandplot'>Plot x-y Points with Locally Smoothed Mean and Standard Deviation</h2><span id='topic+bandplot'></span><span id='topic+bandplot.formula'></span><span id='topic+bandplot.default'></span>

<h3>Description</h3>

<p>Plot x-y points with curves for locally smoothed mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandplot(x,...)
## S3 method for class 'formula'
bandplot(x, data, subset, na.action, ...,
           xlab=NULL, ylab=NULL, add = FALSE, sd = c(-2:2),
           sd.col=c("magenta", "blue", "red", "blue", "magenta"),
           sd.lwd=c(2, 2, 3, 2, 2),  sd.lty=c(2, 1, 1, 1, 2),
           method = "frac", width = 1/5, n=50)
## Default S3 method:
bandplot(x, y, ..., add = FALSE, sd = c(-2:2),
           sd.col=c("magenta", "blue", "red", "blue", "magenta"),
           sd.lwd=c(2, 2, 3, 2, 2),  sd.lty=c(2, 1, 1, 1, 2),
           method = "frac", width = 1/5, n=50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bandplot_+3A_x">x</code></td>
<td>
<p>either formula providing a single dependent variable (y) and
an single independent variable (x) to use as coordinates in the
scatter plot  or a numeric vector of x locations</p>
</td></tr>
<tr><td><code id="bandplot_+3A_y">y</code></td>
<td>
<p>numeric vector of y locations</p>
</td></tr>
<tr><td><code id="bandplot_+3A_data">data</code></td>
<td>
<p>an optional data.frame, list, or environment contianing
the variables used in the model (and in <code>subset</code>).  If not found in
data, the variables are taken from environment(formula),
typically the environment from which lm is called.</p>
</td></tr>
<tr><td><code id="bandplot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="bandplot_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain NAs.  The default is set by the na.action
setting of options, and is na.fail if that is unset.  The
factory-fresh default is na.omit.  Another possible value is
NULL, no action.  Value na.exclude can be useful.  </p>
</td></tr>
<tr><td><code id="bandplot_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters</p>
</td></tr>
<tr><td><code id="bandplot_+3A_xlab">xlab</code>, <code id="bandplot_+3A_ylab">ylab</code></td>
<td>
<p>x and y axis labels</p>
</td></tr>
<tr><td><code id="bandplot_+3A_add">add</code></td>
<td>
<p> Boolean indicating whether the local mean and standard
deviation lines should be added to an existing plot.  Defaults to
FALSE.</p>
</td></tr>
<tr><td><code id="bandplot_+3A_sd">sd</code></td>
<td>
<p>Vector of multiples of the standard devation that should be
plotted.  <code>0</code> gives the mean, <code>-1</code> gives the mean minus
one standard deviation, etc.  Defaults to -2:2.</p>
</td></tr>
<tr><td><code id="bandplot_+3A_sd.col">sd.col</code>, <code id="bandplot_+3A_sd.lwd">sd.lwd</code>, <code id="bandplot_+3A_sd.lty">sd.lty</code></td>
<td>
<p>Color, line width, and line type of each plotted line.</p>
</td></tr>
<tr><td><code id="bandplot_+3A_method">method</code>, <code id="bandplot_+3A_width">width</code>, <code id="bandplot_+3A_n">n</code></td>
<td>
<p> Parameters controlling the smoothing. See the
help page for <code><a href="#topic+wapply">wapply</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bandplot</code> was created to look for changes in the mean or
variance of scatter plots, particularly plots of regression residuals.
</p>
<p>The local mean and standard deviation are calculated by calling
'wapply'.  By default, bandplot asks wapply to smooth using intervals
that include the nearest 1/5 of the data.  See the documentation of
that function for details on the algorithm.
</p>


<h3>Value</h3>

<p>Invisibly returns a list containing the x,y points plotted for each line.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+wapply">wapply</a></code>, <code><a href="#topic+lowess">lowess</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fixed mean, changing variance
x &lt;- 1:1000
y &lt;- rnorm(1000, mean=1, sd=1 + x/1000 )
bandplot(x,y)
bandplot(y~x)

# fixed varance, changing mean
x &lt;- 1:1000
y &lt;- rnorm(1000, mean=x/1000, sd=1)
bandplot(x,y)

#
# changing mean and variance
#
x &lt;- abs(rnorm(500))
y &lt;- rnorm(500, mean=2*x, sd=2+2*x)

# the changing mean and dispersion are hard to see whith the points alone:
plot(x,y )

# regression picks up the mean trend, but not the change in variance
reg &lt;- lm(y~x)
summary(reg)
abline(reg=reg, col="blue", lwd=2)

# using bandplot on the original data helps to show the mean and
# variance trend
bandplot(y ~ x)

# using bandplot on the residuals helps to see that regression removes
# the mean trend but leaves the trend in variability
bandplot(predict(reg),resid(reg))

</code></pre>

<hr>
<h2 id='barplot2'>Enhanced Bar Plots</h2><span id='topic+barplot2'></span><span id='topic+barplot2.default'></span>

<h3>Description</h3>

<p>An enhancement of the standard barplot() function. Creates a bar plot
with vertical or horizontal bars. Can plot confidence intervals for each
bar, a lined grid behind the bars, change plot area color and
logarithmic axes may be used. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
barplot2(height, width = 1, space = NULL,
        names.arg = NULL, legend.text = NULL, beside = FALSE,
        horiz = FALSE, density = NULL, angle = 45,
        col = NULL, prcol = NULL, border = par("fg"),
        main = NULL, sub = NULL, xlab = NULL, ylab = NULL,
        xlim = NULL, ylim = NULL, xpd = TRUE, log = "",
        axes = TRUE, axisnames = TRUE,
        cex.axis = par("cex.axis"), cex.names = par("cex.axis"),
        inside = TRUE, plot = TRUE, axis.lty = 0, offset = 0,
        plot.ci = FALSE, ci.l = NULL, ci.u = NULL,
        ci.color = "black", ci.lty = "solid", ci.lwd = 1, ci.width = 0.5,
        plot.grid = FALSE, grid.inc = NULL,
        grid.lty = "dotted", grid.lwd = 1, grid.col = "black",
        add = FALSE, panel.first = NULL, panel.last = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barplot2_+3A_height">height</code></td>
<td>
<p>either a vector or matrix of values describing the
bars which make up the plot.  If <code>height</code> is a vector, the
plot consists of a sequence of rectangular bars with heights
given by the values in the vector.  If <code>height</code> is a matrix
and <code>beside</code> is <code>FALSE</code> then each bar of the plot
corresponds to a column of <code>height</code>, with the values in the
column giving the heights of stacked &ldquo;sub-bars&rdquo; making up the
bar.  If <code>height</code> is a matrix and <code>beside</code> is
<code>TRUE</code>, then the values in each column are juxtaposed
rather than stacked.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_width">width</code></td>
<td>
<p>optional vector of bar widths. Re-cycled to length the
number of bars drawn.  Specifying a single value will no visible
effect unless <code>xlim</code> is specified.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_space">space</code></td>
<td>
<p>the amount of space (as a fraction of the average bar
width) left before each bar.  May be given as a single number or
one number per bar.  If <code>height</code> is a matrix and
<code>beside</code> is <code>TRUE</code>, <code>space</code> may be specified by
two numbers, where the first is the space between bars in the
same group, and the second the space between the groups.  If not
given explicitly, it defaults to <code>c(0,1)</code> if <code>height</code>
is a matrix and <code>beside</code> is <code>TRUE</code>, and to 0.2
otherwise.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_names.arg">names.arg</code></td>
<td>
<p>a vector of names to be plotted below each bar or
group of bars.  If this argument is omitted, then the names are
taken from the <code>names</code> attribute of <code>height</code> if this
is a vector, or the column names if it is a matrix.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_legend.text">legend.text</code></td>
<td>
<p>a vector of text used to construct a legend for
the plot, or a logical indicating whether a legend should be
included.  This is only useful when <code>height</code> is a matrix.
In that case given legend labels should correspond to the rows of
<code>height</code>; if <code>legend.text</code> is true, the row names of
<code>height</code> will be used as labels if they are non-null.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_beside">beside</code></td>
<td>
<p>a logical value.  If <code>FALSE</code>, the columns of
<code>height</code> are portrayed as stacked bars, and if <code>TRUE</code>
the columns are portrayed as juxtaposed bars.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_horiz">horiz</code></td>
<td>
<p>a logical value.  If <code>FALSE</code>, the bars are drawn
vertically with the first bar to the left.  If <code>TRUE</code>, the
bars are drawn horizontally with the first at the bottom.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_density">density</code></td>
<td>
<p>a vector giving the the density of shading lines, in
lines per inch, for the bars or bar components.
The default value of <code>NULL</code> means that no shading lines
are drawn. Non-positive values of <code>density</code> also inhibit the
drawing of shading lines.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in
degrees (counter-clockwise), for the bars or bar components.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_col">col</code></td>
<td>
<p>a vector of colors for the bars or bar components.
By default, grey is used if <code>height</code> is a vector, and
<code>heat.colors(nrow(height))</code> if <code>height</code> is a matrix.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_prcol">prcol</code></td>
<td>
<p>the color to be used for the plot region.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_border">border</code></td>
<td>
<p>the color to be used for the border of the bars.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_main">main</code>, <code id="barplot2_+3A_sub">sub</code></td>
<td>
<p>overall and sub titles for the plot.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_xlim">xlim</code></td>
<td>
<p>limits for the x axis.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_xpd">xpd</code></td>
<td>
<p>logical. Should bars be allowed to go outside region?</p>
</td></tr>
<tr><td><code id="barplot2_+3A_log">log</code></td>
<td>
<p>a character string which contains &lsquo;&quot;x&quot;&rsquo; if the x axis is
to be logarithmic, &lsquo;&quot;y&quot;&rsquo; if the y axis is to be logarithmic and
&lsquo;&quot;xy&quot;&rsquo; or &lsquo;&quot;yx&quot;&rsquo; if both axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_axes">axes</code></td>
<td>
<p>logical.  If <code>TRUE</code>, a vertical (or horizontal, if
<code>horiz</code> is true) axis is drawn.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_axisnames">axisnames</code></td>
<td>
<p>logical.  If <code>TRUE</code>, and if there are
<code>names.arg</code> (see above), the
other axis is drawn (with <code>lty = 0</code>) and labeled.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_cex.axis">cex.axis</code></td>
<td>
<p>expansion factor for numeric axis labels.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_cex.names">cex.names</code></td>
<td>
<p>expansion factor for names.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_inside">inside</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the lines which divide
adjacent (non-stacked!) bars will be drawn.  Only applies when
<code>space = 0</code> (which it partly is when <code>beside = TRUE</code>).</p>
</td></tr>
<tr><td><code id="barplot2_+3A_plot">plot</code></td>
<td>
<p>logical.  If <code>FALSE</code>, nothing is plotted.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_axis.lty">axis.lty</code></td>
<td>
<p>the graphics parameter <code>lty</code> applied to the axis
and tick marks of the categorical (default horzontal) axis.  Note
that by default the axis is suppressed.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_offset">offset</code></td>
<td>
<p>a vector indicating how much the bars should be shifted
relative to the x axis.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_plot.ci">plot.ci</code></td>
<td>
<p>logical. If <code>TRUE</code>, confidence intervals are plotted
over the bars. Note that if a stacked bar plot is generated, confidence
intervals will not be plotted even if <code>plot.ci = TRUE</code></p>
</td></tr>
<tr><td><code id="barplot2_+3A_ci.l">ci.l</code>, <code id="barplot2_+3A_ci.u">ci.u</code></td>
<td>
<p>The confidence intervals (ci.l = lower bound, ci.u =
upper bound) to be plotted if <code>plot.ci</code> = <code>TRUE</code>. Values must have
the same dim structure as <code>height</code>.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_ci.color">ci.color</code></td>
<td>
<p>the color for the confidence interval line segments</p>
</td></tr>
<tr><td><code id="barplot2_+3A_ci.lty">ci.lty</code></td>
<td>
<p>the line type for the confidence interval line segments</p>
</td></tr>
<tr><td><code id="barplot2_+3A_ci.lwd">ci.lwd</code></td>
<td>
<p>the line width for the confidence interval line
segments</p>
</td></tr>
<tr><td><code id="barplot2_+3A_ci.width">ci.width</code></td>
<td>
<p>length of lines used for the &quot;t&quot; at the end of confidence
interval line segments, as a multple of <code>width</code>.  Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_plot.grid">plot.grid</code></td>
<td>
<p>if <code>TRUE</code> a lined grid will be plotted behind the bars</p>
</td></tr>
<tr><td><code id="barplot2_+3A_grid.inc">grid.inc</code></td>
<td>
<p>the number of grid increments to be plotted</p>
</td></tr>
<tr><td><code id="barplot2_+3A_grid.lty">grid.lty</code></td>
<td>
<p>the line type for the grid</p>
</td></tr>
<tr><td><code id="barplot2_+3A_grid.lwd">grid.lwd</code></td>
<td>
<p>the line width for the grid</p>
</td></tr>
<tr><td><code id="barplot2_+3A_grid.col">grid.col</code></td>
<td>
<p>the line color for the grid</p>
</td></tr>
<tr><td><code id="barplot2_+3A_add">add</code></td>
<td>
<p>logical, if <code>TRUE</code> add barplot to current plot.</p>
</td></tr>
<tr><td><code id="barplot2_+3A_panel.first">panel.first</code></td>
<td>
<p>An expression to be evaluated after the plot region
coordinates have been set up, but prior to the drawing of the bars
and other plot region contents. This can be useful to add additional
plot region content behind the bars. This will also work if
<code>add</code> = <code>TRUE</code></p>
</td></tr>
<tr><td><code id="barplot2_+3A_panel.last">panel.last</code></td>
<td>
<p>An expression to be evaluated after the bars have
been drawn, but prior to the addition of confidence intervals, a
legend and the axis annotation</p>
</td></tr>
<tr><td><code id="barplot2_+3A_...">...</code></td>
<td>
<p>further graphical parameters (<code><a href="graphics.html#topic+par">par</a></code>) are
passed to <code><a href="graphics.html#topic+plot.window">plot.window</a>()</code>, <code><a href="graphics.html#topic+title">title</a>()</code> and
<code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function, it currently only has a default method.
A formula interface may be added eventually.
</p>


<h3>Value</h3>

<p>A numeric vector (or matrix, when <code>beside = TRUE</code>), say
<code>mp</code>, giving the coordinates of <em>all</em> the bar midpoints
drawn, useful for adding to the graph.
</p>
<p>If <code>beside</code> is true, use <code>colMeans(mp)</code> for the
midpoints of each <em>group</em> of bars, see example.
</p>


<h3>Note</h3>

<p>Prior to <span class="rlang"><b>R</b></span> 1.6.0, <code>barplot</code> behaved as if <code>axis.lty = 1</code>,
unintentionally.
0 (zero) and NA values in <code>height</code> will not be plotted if
using logarithmic scales.
If there are NA values in <code>height</code> and <code>beside = FALSE</code>,
values after the NA will not be plotted in stacked bars.
</p>


<h3>Author(s)</h3>

<p>Original barplot() by R-Core. Enhancements by Marc
Schwartz.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a>(..., type = "h")</code>, <code><a href="graphics.html#topic+dotchart">dotchart</a></code>,
<code><a href="graphics.html#topic+hist">hist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tN &lt;- table(Ni &lt;- rpois(100, lambda = 5))
r &lt;- barplot2(tN, col = 'gray')

#- type = "h" plotting *is* `bar'plot
lines(r, tN, type = 'h', col = 'red', lwd = 2)

barplot2(tN, space = 1.5, axisnames = FALSE,
        sub = "barplot2(..., space = 1.5, axisnames = FALSE)")

data(VADeaths, package = "datasets")
barplot2(VADeaths, plot = FALSE)
barplot2(VADeaths, plot = FALSE, beside = TRUE)

mp &lt;- barplot2(VADeaths) # default
tot &lt;- colMeans(VADeaths)
text(mp, tot + 3, format(tot), xpd = TRUE, col = "blue")
barplot2(VADeaths, beside = TRUE,
        col = c("lightblue", "mistyrose", "lightcyan",
                "lavender", "cornsilk"),
        legend = rownames(VADeaths), ylim = c(0, 100))
title(main = "Death Rates in Virginia", font.main = 4)

# Example with confidence intervals and grid
hh &lt;- t(VADeaths)[, 5:1]
mybarcol &lt;- "gray20"
ci.l &lt;- hh * 0.85
ci.u &lt;- hh * 1.15
mp &lt;- barplot2(hh, beside = TRUE,
        col = c("lightblue", "mistyrose",
                "lightcyan", "lavender"),
        legend = colnames(VADeaths), ylim = c(0, 100),
        main = "Death Rates in Virginia", font.main = 4,
        sub = "Faked 95 percent error bars", col.sub = mybarcol,
        cex.names = 1.5, plot.ci = TRUE, ci.l = ci.l, ci.u = ci.u,
        plot.grid = TRUE)
mtext(side = 1, at = colMeans(mp), line = -2,
      text = paste("Mean", formatC(colMeans(hh))), col = "red")
box()

# Example with horizontal bars, grid and logarithmic x axis
barplot2(1:10 , log = "x", plot.grid = TRUE, grid.inc = 10,
        xlim = c(0.5, 20), horiz = TRUE, cex.axis = 0.9,
        prcol = "gray95")
box()

# Bar shading example
barplot2(VADeaths, angle = 15 + 10 * 1:5, density = 20, col = "black",
        legend = rownames(VADeaths))
title(main = list("Death Rates in Virginia", font = 4))

# border :
barplot2(VADeaths, border = "dark blue") 
</code></pre>

<hr>
<h2 id='boxplot2'>Produce a Boxplot Annotated with the Number of Observations</h2><span id='topic+boxplot2'></span>

<h3>Description</h3>

<p>This funcntion uses <code>boxplot</code> to produce a boxplot which is then 
annotated with the number of observations in each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxplot2(..., top=FALSE, shrink=1, textcolor=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxplot2_+3A_...">...</code></td>
<td>
<p> parameters passed to <code>boxplot</code>. </p>
</td></tr>
<tr><td><code id="boxplot2_+3A_top">top</code></td>
<td>
<p> logical indicating whether the number of observations
should be added to the top or the bottom of the plotting
region. Defaults to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="boxplot2_+3A_shrink">shrink</code></td>
<td>
<p> value to shrink character size (cex) when annotating.</p>
</td></tr>
<tr><td><code id="boxplot2_+3A_textcolor">textcolor</code></td>
<td>
<p> text color. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function replaces <code>boxplot.n</code>, which has been deprecated
avoid potential problems with S3 method dispatching.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>,
<code><a href="graphics.html#topic+text">text</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state)

# n's at bottom
boxplot2( state.area ~ state.region)

# n's at top
boxplot2( state.area ~ state.region, top=TRUE)

# small red text
boxplot2( state.area ~ state.region, shrink=0.8, textcolor="red") 
</code></pre>

<hr>
<h2 id='bubbleplot'>Bubble Plot</h2><span id='topic+bubbleplot'></span><span id='topic+bubbleplot.default'></span><span id='topic+bubbleplot.formula'></span>

<h3>Description</h3>

<p>Draw a bubble plot, a scatterplot with varying symbol sizes and
colors, or add points to existing plots. A variety of input formats
are supported, including vectors, matrices, data frames, formulas,
etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bubbleplot(x, ...)

## Default S3 method:
bubbleplot(x, y, z, std=TRUE, pow=0.5, add=FALSE,
           rev=FALSE, type="p", ylim=NULL, xlab=NULL, ylab=NULL,
           pch=c(16,1), cex.points=1, col="black", bg=par("bg"), ...)

## S3 method for class 'formula'
bubbleplot(formula, data, subset, na.action=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bubbleplot_+3A_x">x</code></td>
<td>
<p>a vector of values for the horizontal axis. Can also be a
2-dimensional matrix or table (x values in column names and y values
in row names), or a data frame containing <code>x</code>, <code>y</code>, and
<code>z</code> in that order. If the data frame contains column names
<code>x</code>, <code>y</code>, and <code>z</code> then they will be used for
plotting.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_...">...</code></td>
<td>
<p>passed to <code>plot</code> and <code>points</code>.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_y">y</code></td>
<td>
<p>a vector of values for the vertical axis.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_z">z</code></td>
<td>
<p>a vector of values determining the bubble sizes.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_std">std</code></td>
<td>
<p>whether to standardize the <code>z</code> values.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_pow">pow</code></td>
<td>
<p>a power coefficient for the bubble sizes.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_add">add</code></td>
<td>
<p>whether to add bubbles to an existing plot.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_rev">rev</code></td>
<td>
<p>whether to reverse the y axis.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_type">type</code></td>
<td>
<p>passed to <code>points</code>.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_ylim">ylim</code></td>
<td>
<p>passed to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_xlab">xlab</code>, <code id="bubbleplot_+3A_ylab">ylab</code></td>
<td>
<p>passed to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_pch">pch</code></td>
<td>
<p>passed to <code>points</code>.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_cex.points">cex.points</code></td>
<td>
<p>scales all bubble sizes.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_col">col</code>, <code id="bubbleplot_+3A_bg">bg</code></td>
<td>
<p>passed to <code>points</code>.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_formula">formula</code></td>
<td>
<p>has the form <code>z ~ x + y</code>, where <code>z</code>
determines the bubble sizes and <code>x</code> and <code>y</code> determine
bubble locations.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_data">data</code></td>
<td>
<p>where formula terms are stored, e.g. data frame or list.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_subset">subset</code></td>
<td>
<p>a logical vector specifying which data to plot.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_na.action">na.action</code></td>
<td>
<p>how <code>NA</code> values are handled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>std</code> standardization sets <code>z = abs(z) / mean(abs(z))</code>.
</p>
<p>The <code>pow = 0.5</code> (square root) is a good default, where a <code>z</code>
value of 2 has twice the area of 1. See example #2 below for an
exception, where the <code>z</code> value is tree circumference and
therefore proportional to the tree diameter.
</p>
<p>The <code>pch</code>, <code>col</code>, and <code>bg</code> arguments can be be vectors
of length 2, where positive <code>z</code> values are drawn with
<code>pch[1]</code>, <code>col[1]</code>, <code>bg[1]</code> and negative <code>z</code>
values are drawn with <code>pch[2]</code>, <code>col[2]</code>, and <code>bg[2]</code>.
</p>


<h3>Author(s)</h3>

<p>Arni Magnusson.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+points">points</a></code> is the underlying function used to draw the
bubbles.
</p>
<p><code><a href="graphics.html#topic+symbols">symbols</a></code> can also draw bubbles, but does not handle
negative <code>z</code> values or have convenience features such as
<code>pow</code> and <code>rev</code>.
</p>
<p><code><a href="#topic+balloonplot">balloonplot</a></code> provides an alternative interface and visual
style based on tables instead of scatterplots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>catch.t &lt;- xtabs(Catch~Year+Age, catch.d)              # example table
catch.m &lt;- as.matrix(as.data.frame(unclass(catch.t)))  # example matrix

# 1  Formula
bubbleplot(Catch~Age+Year, data=catch.d)
# Use rev=TRUE to get same layout as crosstab matrix:
print(catch.m)
bubbleplot(Catch~Age+Year, data=catch.d, rev=TRUE, las=1)

# 2  Data frame
bubbleplot(catch.d)
bubbleplot(Orange)
# Visualize tree transverse section at breast height
bubbleplot(Orange, pow=1, cex=2, pch=21,
           col="darkred", bg="peru", lwd=1.5)

# 3  Matrix or table
bubbleplot(catch.m)
bubbleplot(catch.t)

# 4  Positive and negative values
bubbleplot(catch.r)
bubbleplot(Resid~Age+Year, catch.r, subset=Age %in% 4:9,
           rev=TRUE, xlim=c(3.5,9.5), cex=1.3)
# Residuals from orange tree model
library(nlme)
fm &lt;- nlme(circumference~phi1/(1+exp(-(age-phi2)/phi3)),
           fixed=phi1+phi2+phi3~1, random=phi1~1|Tree,
           data=Orange, start=c(phi1=200,phi2=800,phi3=400))
bubbleplot(residuals(fm)~Tree+age, Orange)
bubbleplot(residuals(fm)~Tree+age, Orange, cex=2.5, pch=16,
           col=c("dodgerblue","orange"))

# 5  Richter magnitude, amplitude, and energy release
bubbleplot(mag~long+lat, quakes, pch=1)
bubbleplot(10^mag~long+lat, quakes, cex=1.2, col=gray(0, 0.3))
bubbleplot(sqrt(1000)^mag~long+lat, quakes, cex=1.2, col=gray(0, 0.3))
bubbleplot(sqrt(1000)^mag~long+lat, quakes, cex=1.2, col="#FF00004D")
</code></pre>

<hr>
<h2 id='catch.d'>Catch at Age and Residuals</h2><span id='topic+catch.d'></span><span id='topic+catch.r'></span>

<h3>Description</h3>

<p>Catch-at-age observed data and model residuals from Icelandic saithe
assessment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catch.d
catch.r
</code></pre>


<h3>Format</h3>

<p>Data frame containing three columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>Year</code>  </td><td style="text-align: left;"> year</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Age</code>   </td><td style="text-align: left;"> age</td>
</tr>
<tr>
 <td style="text-align: left;">
    and</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Catch</code> </td><td style="text-align: left;"> catch (thousands of individuals)</td>
</tr>
<tr>
 <td style="text-align: left;">
    or</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Resid</code> </td><td style="text-align: left;"> standardized residual
  </td>
</tr>

</table>



<h3>Details</h3>

<p>The data are from Tables 8.2 and 8.6 in the ICES (2015) fish stock
assessment of Icelandic saithe.
</p>


<h3>Source</h3>

<p>ICES (2015) Report of the North-Western Working Group (NWWG).
<em>ICES CM 2015/ACOM:07</em>, pp. 240&ndash;246.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bubbleplot">bubbleplot</a></code> is an effective way to visualize these data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>catch.t &lt;- xtabs(Catch~Year+Age, catch.d)
catch.m &lt;- as.matrix(as.data.frame(unclass(catch.t)))

# 1  Formula
bubbleplot(Catch~Age+Year, data=catch.d)
# Use rev=TRUE to get same layout as crosstab matrix:
print(catch.m)
bubbleplot(Catch~Age+Year, data=catch.d, rev=TRUE, las=1)

# 2  Data frame
bubbleplot(catch.d)

# 3  Matrix or table
bubbleplot(catch.m)
bubbleplot(catch.t)

# 4  Positive and negative values
bubbleplot(catch.r)
bubbleplot(Resid~Age+Year, catch.r, subset=Age %in% 4:9,
           rev=TRUE, xlim=c(3.5,9.5), cex=1.3)
</code></pre>

<hr>
<h2 id='ci2d'>
Create 2-dimensional empirical confidence regions
</h2><span id='topic+ci2d'></span><span id='topic+print.ci2d'></span>

<h3>Description</h3>

<p>Create 2-dimensional empirical confidence regions from provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci2d(x, y = NULL,
     nbins=51, method=c("bkde2D","hist2d"),
     bandwidth, factor=1.0,
     ci.levels=c(0.50,0.75,0.90,0.95,0.975),
     show=c("filled.contour","contour","image","none"),
     col=topo.colors(length(breaks)-1),
     show.points=FALSE,
     pch=par("pch"),
     points.col="red",
     xlab, ylab, 
     ...)
## S3 method for class 'ci2d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci2d_+3A_x">x</code></td>
<td>
<p>either a vector containing the x coordinates
or a matrix with 2 columns. </p>
</td></tr>
<tr><td><code id="ci2d_+3A_y">y</code></td>
<td>
<p>a vector contianing the y coordinates, not required if &lsquo;x&rsquo;
is matrix</p>
</td></tr>
<tr><td><code id="ci2d_+3A_nbins">nbins</code></td>
<td>
<p>number of bins in each dimension. May be a scalar or a
2 element vector.  Defaults to 51.</p>
</td></tr>
<tr><td><code id="ci2d_+3A_method">method</code></td>
<td>
<p>One of &quot;bkde2D&quot; (for KernSmooth::bdke2d) or &quot;hist2d&quot;
(for gplots::hist2d) specifyting the name of the method to create
the 2-d density summarizing the data.  Defaults to &quot;bkde2D&quot;.</p>
</td></tr>
<tr><td><code id="ci2d_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Bandwidth to use for <code>KernSmooth::bkde2D</code>.
See below for default value. </p>
</td></tr>
<tr><td><code id="ci2d_+3A_factor">factor</code></td>
<td>
<p>Numeric scaling factor for bandwidth.  Useful for
exploring effect of changing the bandwidth.  Defaults to 1.0.</p>
</td></tr>
<tr><td><code id="ci2d_+3A_ci.levels">ci.levels</code></td>
<td>
<p>Confidence level(s) to use for plotting
data. Defaults to <code>c(0.5, 0.75, 0.9, 0.95, 0.975)</code> </p>
</td></tr>
<tr><td><code id="ci2d_+3A_show">show</code></td>
<td>
<p>Plot type to be displaed.  One of &quot;filled.contour&quot;,
&quot;contour&quot;, &quot;image&quot;, or &quot;none&quot;.  Defaults to &quot;filled.contour&quot;.</p>
</td></tr>
<tr><td><code id="ci2d_+3A_show.points">show.points</code></td>
<td>
<p>Boolean indicating whether original data values
should be plotted.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ci2d_+3A_pch">pch</code></td>
<td>
<p>Point type for plots.  See <code>points</code> for details.</p>
</td></tr>
<tr><td><code id="ci2d_+3A_points.col">points.col</code></td>
<td>
<p>Point color for plotting original data. Defaiults to
&quot;red&quot;.</p>
</td></tr>
<tr><td><code id="ci2d_+3A_col">col</code></td>
<td>
<p>Colors to use for plots.</p>
</td></tr>
<tr><td><code id="ci2d_+3A_xlab">xlab</code>, <code id="ci2d_+3A_ylab">ylab</code></td>
<td>
<p>Axis labels</p>
</td></tr>
<tr><td><code id="ci2d_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>KernSmooth::bkde2D</code>
or <code>gplots::hist2d</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes either <code>KernSmooth::bkde2D</code> or
<code>gplots::hist2d</code> to estmate a 2-dimensional density of the data
passed as an argument.  This density is then used to create and
(optionally) display confidence regions.
</p>
<p>When <code>bandwidth</code> is ommited and <code>method="bkde2d"</code>,
<code>KernSmooth::dpik</code> is appled in x and y dimensions to select the
bandwidth.
</p>


<h3>Value</h3>

<p>A <code>ci2d</code> object consisting of a list containing (at least) the
following elements:
</p>
<table role = "presentation">
<tr><td><code>nobs</code></td>
<td>
<p>number of original data points</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x position of each density estimate bin</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y position of each density estimate bin</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>Matrix containing the probability density of each bin
(count in bin/total count)</p>
</td></tr>
<tr><td><code>cumDensity</code></td>
<td>
<p>Matrix where each element contains the cumulative
probability density of all elements with the same density (used to
create the confidence region plots) </p>
</td></tr>
<tr><td><code>contours</code></td>
<td>
<p>List of contours of each confidence region.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call used to create this object</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Confidence intervals generated by ci2d are <em>approximate</em>, and
are subject to biases and/or artifacts induced by the binning or
kernel smoothing method, bin locations, bin sizes, and kernel bandwidth.
</p>
<p>The <code><a href="r2d2.html#topic+conf2d">conf2d</a></code> function in the <span class="pkg">r2d2</span> package may create a more
accurate confidence region, and reports the actual proportion of
points inside the region.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

<p><code><a href="KernSmooth.html#topic+bkde2D">bkde2D</a></code>, <code><a href="r2d2.html#topic+conf2d">conf2d</a></code>,
<code><a href="KernSmooth.html#topic+dpik">dpik</a></code>, <code><a href="#topic+hist2d">hist2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ####
   ## Basic usage 
   ####
   data(geyser, package="MASS")

   x &lt;- geyser$duration
   y &lt;- geyser$waiting

   # 2-d confidence intervals based on binned kernel density estimate
   ci2d(x,y)                   # filled contour plot
   ci2d(x,y, show.points=TRUE) # show original data


   # image plot
   ci2d(x,y, show="image")
   ci2d(x,y, show="image", show.points=TRUE)

   # contour plot
   ci2d(x,y, show="contour", col="black")
   ci2d(x,y, show="contour", col="black", show.points=TRUE)

   ####
   ## Control Axis scales
   ####
   x &lt;- rnorm(2000, sd=4)
   y &lt;- rnorm(2000, sd=1)

   # 2-d confidence intervals based on binned kernel density estimate
   ci2d(x,y)

   # 2-d confidence intervals based on 2d histogram
   ci2d(x,y, method="hist2d", nbins=25)
 
   # Require same scale for each axis, this looks oval
   ci2d(x,y, range.x=list(c(-20,20), c(-20,20)))
   ci2d(x,y, method="hist2d", same.scale=TRUE, nbins=25) # hist2d 

   ####
   ## Control smoothing and binning 
   ####
   x &lt;- rnorm(2000, sd=4)
   y &lt;- rnorm(2000, mean=x, sd=2)

   # Default 2-d confidence intervals based on binned kernel density estimate
   ci2d(x,y)

   # change the smoother bandwidth
   ci2d(x,y,
        bandwidth=c(sd(x)/8, sd(y)/8)
       )

   # change the smoother number of bins
   ci2d(x,y, nbins=10)
   ci2d(x,y)
   ci2d(x,y, nbins=100)

   # Default 2-d confidence intervals based on 2d histogram
   ci2d(x,y, method="hist2d", show.points=TRUE)

   # change the number of histogram bins
   ci2d(x,y, nbin=10, method="hist2d", show.points=TRUE )
   ci2d(x,y, nbin=25, method="hist2d", show.points=TRUE )

   ####
   ## Perform plotting manually
   ####
   data(geyser, package="MASS")

   # let ci2d handle plotting contours...
   ci2d(geyser$duration, geyser$waiting, show="contour", col="black")

   # call contour() directly, show the 90 percent CI, and the mean point 
   est &lt;- ci2d(geyser$duration, geyser$waiting, show="none")
   contour(est$x, est$y, est$cumDensity,
           xlab="duration", ylab="waiting",
           levels=0.90, lwd=4, lty=2)
   points(mean(geyser$duration), mean(geyser$waiting),
         col="red", pch="X")


   ####
   ## Extract confidence region values
   ###
   data(geyser, package="MASS")

   ## Empirical 90 percent confidence limits
   quantile( geyser$duration, c(0.05, 0.95) )
   quantile( geyser$waiting, c(0.05, 0.95) )

   ## Bivariate 90 percent confidence region
   est &lt;- ci2d(geyser$duration, geyser$waiting, show="none")
   names(est$contours) ## show available contours

   ci.90 &lt;- est$contours[names(est$contours)=="0.9"]  # get region(s)
   ci.90 &lt;- rbind(ci.90[[1]],NA, ci.90[[2]], NA, ci.90[[3]]) # join them

   print(ci.90)                  # show full contour
   range(ci.90$x, na.rm=TRUE)    # range for duration
   range(ci.90$y, na.rm=TRUE)    # range for waiting

   ####
   ## Visually compare confidence regions 
   ####
   data(geyser, package="MASS")

   ## Bivariate smoothed 90 percent confidence region
   est &lt;- ci2d(geyser$duration, geyser$waiting, show="none")
   names(est$contours) ## show available contours

   ci.90 &lt;- est$contours[names(est$contours)=="0.9"]  # get region(s)
   ci.90 &lt;- rbind(ci.90[[1]],NA, ci.90[[2]], NA, ci.90[[3]]) # join them

   plot( waiting ~ duration, data=geyser,
         main="Comparison of 90 percent confidence regions" )
   polygon( ci.90, col="green", border="green", density=10)

   ## Univariate Normal-Theory 90 percent confidence region
   mean.x &lt;- mean(geyser$duration)
   mean.y &lt;- mean(geyser$waiting)
   sd.x &lt;- sd(geyser$duration)
   sd.y &lt;- sd(geyser$waiting)

   t.value &lt;- qt(c(0.05,0.95), df=length(geyser$duration), lower=TRUE)
   ci.x &lt;- mean.x +  t.value* sd.x
   ci.y &lt;- mean.y +  t.value* sd.y

   plotCI(mean.x, mean.y,
          li=ci.x[1],
          ui=ci.x[2],
          barcol="blue", col="blue",
          err="x",
          pch="X",
          add=TRUE )

   plotCI(mean.x, mean.y,
          li=ci.y[1],
          ui=ci.y[2],
          barcol="blue", col="blue",
          err="y",
          pch=NA,
          add=TRUE )

#   rect(ci.x[1], ci.y[1], ci.x[2], ci.y[2], border="blue",
#        density=5,
#        angle=45,
#        col="blue" )


   ## Empirical univariate 90 percent confidence region
   box &lt;- cbind( x=quantile( geyser$duration, c(0.05, 0.95 )), 
                 y=quantile( geyser$waiting, c(0.05, 0.95 )) )

   rect(box[1,1], box[1,2], box[2,1], box[2,2], border="red",
        density=5,
        angle=-45,
        col="red" )

   ## now a nice legend
   legend( "topright", legend=c("       Region type",
                                "Univariate Normal Theory",
                                "Univarite Empirical",
                                "Smoothed Bivariate"),
           lwd=c(NA,1,1,1),
           col=c("black","blue","red","green"),
           lty=c(NA,1,1,1)
         )

   ####
   ## Test with a large number of points
   ####
   ## Not run: 
   x &lt;- rnorm(60000, sd=1)
   y &lt;- c( rnorm(40000, mean=x, sd=1),
           rnorm(20000, mean=x+4, sd=1) )

   hist2d(x,y)
   ci &lt;- ci2d(x,y)
   ci
   
## End(Not run)
</code></pre>

<hr>
<h2 id='col2hex'>Convert color names to hex RGB strings</h2><span id='topic+col2hex'></span>

<h3>Description</h3>

<p>Convert color names to hex RGB strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2hex(cname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col2hex_+3A_cname">cname</code></td>
<td>
<p>Color name(s)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector giving the hex color code translation of the provided
color names.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>, <code><a href="grDevices.html#topic+colors">colors</a></code>, <code><a href="grDevices.html#topic+rgb">rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col2hex(c("red","yellow","lightgrey"))
</code></pre>

<hr>
<h2 id='colorpanel'>Generate a smoothly varying set of colors</h2><span id='topic+colorpanel'></span><span id='topic+redgreen'></span><span id='topic+greenred'></span><span id='topic+bluered'></span><span id='topic+redblue'></span>

<h3>Description</h3>

<p><code>colorpanel</code> generate a set of colors that varies
smoothly. <code>redgreen</code>, <code>greenred</code>, <code>bluered</code>, and 
<code>redblue</code> generate red-black-green, green-black-red,
red-white-blue, and blue-white-red colorbars, respectively.
colors 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorpanel(n, low, mid, high)
redgreen(n)
greenred(n)
bluered(n)
redblue(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorpanel_+3A_n">n</code></td>
<td>
<p>Desired number of color elements in the panel.</p>
</td></tr>
<tr><td><code id="colorpanel_+3A_low">low</code>, <code id="colorpanel_+3A_mid">mid</code>, <code id="colorpanel_+3A_high">high</code></td>
<td>
<p>Colors to use for the Lowest, middle,
and highest values. <code>mid</code> may be ommited.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values for <code>low, mid, high</code> can be given as
color names (<code>"red"</code>), plot color index (<code>2</code>), and
HTML-style RGB, (<code>"#FF0000"</code>).
</p>
<p>If <code>mid</code> is supplied, then the returned color panel will consist
of <code>n - floor(n/2)</code> HTML-style RGB elements which vary smoothly
between <code>low</code> and <code>mid</code>, then between <code>mid</code> and
<code>high</code>. Note that if <code>n</code> is even, the color <code>mid</code> will
occur twice at the center of the sequence.
</p>
<p>If <code>mid</code> is omitted, the color panel will vary
smoothly beween <code>low</code> and <code>high</code>. 
</p>


<h3>Value</h3>

<p>Vector of HTML-style RGB colors.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

 <p><code><a href="grDevices.html#topic+colors">colors</a> </code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
showpanel &lt;- function(col)
{
  image(z=matrix(1:100, ncol=1), col=col, xaxt="n", yaxt="n" )
}

par(mfrow=c(3,3))

# two colors only:
showpanel(colorpanel(8,low="red",high="green"))

# three colors
showpanel(colorpanel(8,"red","black","green"))
# note the duplicatation of black at the center, using an odd
# number of elements resolves this:
showpanel(colorpanel(9,"red","black","green"))

showpanel(greenred(64))
showpanel(redgreen(64))
showpanel(bluered(64))
showpanel(redblue(64))

</code></pre>

<hr>
<h2 id='gplots-defunct'>Defunct functions</h2><span id='topic+boxplot.n'></span><span id='topic+plot.lm2'></span><span id='topic+smartlegend'></span>

<h3>Description</h3>

<p>These functions are defunct and have been removed from the gplots package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   boxplot.n(..., top=FALSE, shrink=1, textcolor=NULL)
   plot.lm2(
            x,
            which = 1:5,
            caption = c("Residuals vs Fitted", "Normal Q-Q plot",
              "Scale-Location plot", "Cook's distance plot"),
            panel = panel.smooth,
            sub.caption = deparse(x$call),
            main = "",
            ask,
            ...,
            id.n = 3,
            labels.id = names(residuals(x)),
            cex.id = 0.75,
            band=TRUE,
            rug=TRUE,
            width=1/10,
            max.n=5000
            )
  smartlegend(x = c("left", "center", "right"),
             y = c("top", "center", "bottom"),
             ...,
             inset = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gplots-defunct_+3A_ask">ask</code>, <code id="gplots-defunct_+3A_band">band</code>, <code id="gplots-defunct_+3A_caption">caption</code>, <code id="gplots-defunct_+3A_cex.id">cex.id</code>, <code id="gplots-defunct_+3A_id.n">id.n</code>, <code id="gplots-defunct_+3A_inset">inset</code>, <code id="gplots-defunct_+3A_labels.id">labels.id</code>, <code id="gplots-defunct_+3A_main">main</code>, <code id="gplots-defunct_+3A_max.n">max.n</code>, <code id="gplots-defunct_+3A_panel">panel</code>, <code id="gplots-defunct_+3A_rug">rug</code>, <code id="gplots-defunct_+3A_shrink">shrink</code>, <code id="gplots-defunct_+3A_sub.caption">sub.caption</code>, <code id="gplots-defunct_+3A_textcolor">textcolor</code>, <code id="gplots-defunct_+3A_top">top</code>, <code id="gplots-defunct_+3A_which">which</code>, <code id="gplots-defunct_+3A_width">width</code>, <code id="gplots-defunct_+3A_x">x</code>, <code id="gplots-defunct_+3A_y">y</code>, <code id="gplots-defunct_+3A_...">...</code></td>
<td>
<p>see man page for the corresponding replacement function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are no longer available.  Please refer to the manual page
for the replacement function:
</p>

<ul>
<li> <p><code>boxplot.n</code> has been replaced by <code><a href="#topic+boxplot2">boxplot2</a></code>
</p>
</li>
<li> <p><code>plot.lm2</code> has been replaced by <code><a href="#topic+lmplot2">lmplot2</a></code>
</p>
</li>
<li> <p><code>smartlegend</code> is no longer needed because relative
positioning has been implemented in <code><a href="graphics.html#topic+legend">legend</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+boxplot2">boxplot2</a></code>,
<code><a href="#topic+lmplot2">lmplot2</a></code>,
<code><a href="graphics.html#topic+legend">legend</a></code>,
<code><a href="base.html#topic+Defunct">Defunct</a></code>
</p>

<hr>
<h2 id='gplots-deprecated'>Deprecated functions</h2><span id='topic+deprecated'></span>

<h3>Description</h3>

<p>These functions have been deprecated and will be removed in future
releases of gplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## No deprecated functions at this time ##
</code></pre>


<h3>Details</h3>

<p>These functions have been deprecated.  Please refer to the manual page
for the replacement function:
</p>

<ul>
<li><p> (No deprecated functions at this time)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Deprecated">Deprecated</a></code>
</p>

<hr>
<h2 id='heatmap.2'> Enhanced Heat Map </h2><span id='topic+heatmap.2'></span>

<h3>Description</h3>

<p>A heat map is a false color image (basically
<code><a href="graphics.html#topic+image">image</a>(t(x))</code>) with a dendrogram added to the left side
and/or to the top.  Typically, reordering of the rows and columns
according to some set of values (row or column means) within the
restrictions imposed by the dendrogram is carried out.
</p>
<p>This heatmap provides a number of extensions to the standard R
<code><a href="stats.html#topic+heatmap">heatmap</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmap.2 (x,

           # dendrogram control
           Rowv = TRUE,
           Colv=if(symm)"Rowv" else TRUE,
           distfun = dist,
           hclustfun = hclust,
           dendrogram = c("both","row","column","none"),
           reorderfun = function(d, w) reorder(d, w),
           symm = FALSE,

           # data scaling
           scale = c("none","row", "column"),
           na.rm=TRUE,

           # image plot
           revC = identical(Colv, "Rowv"),
           add.expr,

           # mapping data to colors
           breaks,
           symbreaks=any(x &lt; 0, na.rm=TRUE) || scale!="none",

           # colors
           col="heat.colors",

           # block sepration
           colsep,
           rowsep,
           sepcolor="white",
           sepwidth=c(0.05,0.05),

           # cell labeling
           cellnote,
           notecex=1.0,
           notecol="cyan",
           na.color=par("bg"),

           # level trace
           trace=c("column","row","both","none"),
           tracecol="cyan",
           hline=median(breaks),
           vline=median(breaks),
           linecol=tracecol,

           # Row/Column Labeling
           margins = c(5, 5),
           ColSideColors,
           RowSideColors,
           cexRow = 0.2 + 1/log10(nr),
           cexCol = 0.2 + 1/log10(nc),
           labRow = NULL,
           labCol = NULL,
           srtRow = NULL,
           srtCol = NULL,
           adjRow = c(0,NA),
           adjCol = c(NA,0),
           offsetRow = 0.5,
           offsetCol = 0.5,
           colRow = NULL,
           colCol = NULL,

           # color key + density info
           key = TRUE,
           keysize = 1.5,
           density.info=c("histogram","density","none"),
           denscol=tracecol,
           symkey = any(x &lt; 0, na.rm=TRUE) || symbreaks,
           densadj = 0.25,
           key.title = NULL,
           key.xlab = NULL,
           key.ylab = NULL,
           key.xtickfun = NULL,
           key.ytickfun = NULL,
           key.par=list(),

           # plot labels
           main = NULL,
           xlab = NULL,
           ylab = NULL,

           # plot layout
           lmat = NULL,
           lhei = NULL,
           lwid = NULL,

           # extras
           extrafun=NULL,
           ...
           )
           </code></pre>


<h3>Arguments</h3>


<table role = "presentation">
<tr><td><code id="heatmap.2_+3A_x">x</code></td>
<td>
<p>numeric matrix of the values to be plotted. </p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_rowv">Rowv</code></td>
<td>
<p>determines if and how the <em>row</em> dendrogram should be
reordered.	By default, it is TRUE, which implies dendrogram is
computed and reordered based on row means. If NULL or FALSE, then no
dendrogram is computed and no reordering is done. If a
<code><a href="stats.html#topic+dendrogram">dendrogram</a></code>, then it is used &quot;as-is&quot;, ie
without any reordering. If a vector of integers, then dendrogram is
computed and reordered based on the order of the vector.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_colv">Colv</code></td>
<td>
<p>determines if and how the <em>column</em> dendrogram should
be reordered.	Has the options as the <code>Rowv</code> argument above and
<em>additionally</em> when <code>x</code> is a square matrix,
<code>Colv="Rowv"</code> means that columns should be treated identically
to the rows.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_distfun">distfun</code></td>
<td>
<p>function used to compute the distance (dissimilarity)
between both rows and columns.  Defaults to <code><a href="stats.html#topic+dist">dist</a></code>.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_hclustfun">hclustfun</code></td>
<td>
<p>function used to compute the hierarchical clustering
when <code>Rowv</code> or <code>Colv</code> are not dendrograms.  Defaults to
<code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_dendrogram">dendrogram</code></td>
<td>
<p>character string indicating whether to draw 'none',
'row', 'column' or 'both' dendrograms.  Defaults to 'both'. However,
if Rowv (or Colv) is FALSE or NULL and dendrogram is 'both', then a
warning is issued and Rowv (or Colv) arguments are honoured.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_reorderfun">reorderfun</code></td>
<td>
<p><code>function(d, w)</code> of dendrogram and weights for
reordering the row and column dendrograms.  The default uses
<code><a href="stats.html#topic+stats">stats</a>{reorder.dendrogram}</code> </p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="heatmap.2_+3A_symm">symm</code></td>
<td>
<p>logical indicating if <code>x</code> should be treated
<b>symm</b>etrically; can only be true when <code>x</code> is a
square matrix.</p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_scale">scale</code></td>
<td>
<p>character indicating if the values should be centered and
scaled in either the row direction or the column direction, or
none.  The default is <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code>'s should be removed.</p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_revc">revC</code></td>
<td>
<p>logical indicating if the column order should be
<code><a href="base.html#topic+rev">rev</a></code>ersed for plotting, such that e.g., for the
symmetric case, the symmetry axis is as usual.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_add.expr">add.expr</code></td>
<td>
<p>expression that will be evaluated after the call to
<code>image</code>.  Can be used to add components to the plot.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_breaks">breaks</code></td>
<td>
<p>(optional) Either a numeric vector indicating the
splitting points for binning <code>x</code> into colors, or a integer
number of break points to be used, in which case the break points
will be spaced equally between <code>min(x)</code> and <code>max(x)</code>.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_symbreaks">symbreaks</code></td>
<td>
<p>Boolean indicating whether breaks should be
made symmetric about 0. Defaults to <code>TRUE</code> if the data includes
negative values, and to <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_col">col</code></td>
<td>
<p>colors used for the image. Defaults to heat colors
(<code>heat.colors</code>).</p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_colsep">colsep</code>, <code id="heatmap.2_+3A_rowsep">rowsep</code>, <code id="heatmap.2_+3A_sepcolor">sepcolor</code></td>
<td>
<p>(optional) vector of integers
indicating which columns or rows should be separated from the
preceding columns or rows by a narrow space of color
<code>sepcolor</code>.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_sepwidth">sepwidth</code></td>
<td>
<p>(optional) Vector of length 2 giving the width
(colsep) or height (rowsep) the separator box drawn by colsep and
rowsep as a function of the width (colsep) or height (rowsep) of a
cell. Defaults to <code>c(0.05, 0.05)</code></p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_cellnote">cellnote</code></td>
<td>
<p>(optional) matrix of character strings which will be
placed within each color cell, e.g. p-value symbols.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_notecex">notecex</code></td>
<td>
<p>(optional) numeric scaling factor for <code>cellnote</code>
items.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_notecol">notecol</code></td>
<td>
<p>(optional) character string specifying the color for
<code>cellnote</code> text.  Defaults to &quot;cyan&quot;.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_na.color">na.color</code></td>
<td>
<p>Color to use for missing value (<code>NA</code>). Defaults
to the plot background color.</p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_trace">trace</code></td>
<td>
<p>character string indicating whether a solid &quot;trace&quot; line
should be drawn across 'row's or down 'column's, 'both' or 'none'.
The distance of the line from the center of each color-cell is
proportional to the size of the measurement. Defaults to 'column'.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_tracecol">tracecol</code></td>
<td>
<p>character string giving the color for &quot;trace&quot;
line. Defaults to &quot;cyan&quot;.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_hline">hline</code>, <code id="heatmap.2_+3A_vline">vline</code>, <code id="heatmap.2_+3A_linecol">linecol</code></td>
<td>
<p>Vector of values within cells where a
horizontal or vertical dotted line should be drawn.  The color of
the line is controlled by <code>linecol</code>.  Horizontal  lines are only
plotted if <code>trace</code> is 'row' or 'both'.  Vertical lines are only
drawn if <code>trace</code> 'column' or 'both'.   <code>hline</code> and
<code>vline</code> default to the median of the breaks, <code>linecol</code>
defaults to the value of <code>tracecol</code>.</p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_margins">margins</code></td>
<td>
<p>numeric vector of length 2 containing the margins
(see <code><a href="graphics.html#topic+par">par</a>(mar= *)</code>) for column and row names,
respectively.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_colsidecolors">ColSideColors</code></td>
<td>
<p>(optional) character vector of length
<code>ncol(x)</code> containing the color names for a horizontal side bar
that may be used to annotate the columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_rowsidecolors">RowSideColors</code></td>
<td>
<p>(optional) character vector of length
<code>nrow(x)</code> containing the color names for a vertical side bar
that may be used to annotate the rows of <code>x</code>.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_cexrow">cexRow</code>, <code id="heatmap.2_+3A_cexcol">cexCol</code></td>
<td>
<p>positive numbers, used as <code>cex.axis</code> in
for the row or column axis labeling.  The defaults currently only
use number of rows or columns, respectively.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_labrow">labRow</code>, <code id="heatmap.2_+3A_labcol">labCol</code></td>
<td>
<p>character vectors with row and column labels to
use; these default to <code>rownames(x)</code> or <code>colnames(x)</code>,
respectively.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_srtrow">srtRow</code>, <code id="heatmap.2_+3A_srtcol">srtCol</code></td>
<td>
<p>angle of row/column labels, in degrees from
horizontal</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_adjrow">adjRow</code>, <code id="heatmap.2_+3A_adjcol">adjCol</code></td>
<td>
<p>2-element vector giving the (left-right,
top-bottom) justification of row/column labels (relative to the text
orientation).</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_offsetrow">offsetRow</code>, <code id="heatmap.2_+3A_offsetcol">offsetCol</code></td>
<td>
<p>Number of character-width spaces to
place between row/column labels and the edge of the plotting
region.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_colrow">colRow</code>, <code id="heatmap.2_+3A_colcol">colCol</code></td>
<td>
<p>color of row/column labels, either a scalar to
set the color of all labels the same, or a vector providing the
colors of each label item</p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_key">key</code></td>
<td>
<p>logical indicating whether a color-key should be shown.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_keysize">keysize</code></td>
<td>
<p>numeric value indicating the size of the key</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_density.info">density.info</code></td>
<td>
<p>character string indicating whether to superimpose
a 'histogram', a 'density' plot, or no plot ('none') on the
color-key.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_denscol">denscol</code></td>
<td>
<p>character string giving the color for the density
display specified by <code>density.info</code>, defaults to the same value
as <code>tracecol</code>.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_symkey">symkey</code></td>
<td>
<p>Boolean indicating whether the color key should be
made symmetric about 0. Defaults to <code>TRUE</code> if the data includes
negative values, and to <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_densadj">densadj</code></td>
<td>
<p>Numeric scaling value for tuning the kernel width when
a density plot is drawn on the color key.  (See the <code>adjust</code>
parameter for the <code>density</code> function for details.)  Defaults to
0.25.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_key.title">key.title</code></td>
<td>
<p>main title of the color key. If set to NA no title
will be plotted.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_key.xlab">key.xlab</code></td>
<td>
<p>x axis label of the color key. If set to NA no label
will be plotted.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_key.ylab">key.ylab</code></td>
<td>
<p>y axis label of the color key. If set to NA no label
will be plotted.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_key.xtickfun">key.xtickfun</code></td>
<td>
<p>function computing tick location and labels for
the xaxis of the color key. Returns a named list containing
parameters that can be passed to <code>axis</code>. See examples.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_key.ytickfun">key.ytickfun</code></td>
<td>
<p>function computing tick location and labels for
the y axis of the color key. Returns a named list containing
parameters that can be passed to <code>axis</code>.  See examples.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_key.par">key.par</code></td>
<td>
<p>graphical parameters for the color key. Named list that
can be passed to <code>par</code>.</p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_main">main</code>, <code id="heatmap.2_+3A_xlab">xlab</code>, <code id="heatmap.2_+3A_ylab">ylab</code></td>
<td>
<p>main, x- and y-axis titles; defaults to none.</p>
</td></tr>

<tr><td><code id="heatmap.2_+3A_lmat">lmat</code>, <code id="heatmap.2_+3A_lhei">lhei</code>, <code id="heatmap.2_+3A_lwid">lwid</code></td>
<td>
<p>visual layout: position matrix, column height,
column width.  See below for details</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_extrafun">extrafun</code></td>
<td>
<p>A function to be called after all other work. See
examples.</p>
</td></tr>
<tr><td><code id="heatmap.2_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="graphics.html#topic+image">image</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code>Rowv</code> or <code>Colv</code> are dendrograms they are honored
(and not reordered).	Otherwise, dendrograms are computed as
<code>dd &lt;- as.dendrogram(hclustfun(distfun(X)))</code> where <code>X</code> is
either <code>x</code> or <code>t(x)</code>.<br />
</p>
<p>If either is a vector (of &ldquo;weights&rdquo;) then the appropriate
dendrogram is reordered according to the supplied values subject to
the constraints imposed by the dendrogram, by <code><a href="stats.html#topic+reorder">reorder</a>(dd,
    Rowv)</code>, in the row case.

If either is missing, as by default, then the ordering of the
corresponding dendrogram is by the mean value of the rows/columns,
i.e., in the case of rows, <code>Rowv &lt;- rowMeans(x, na.rm=na.rm)</code>.

If either is <code><a href="base.html#topic+NULL">NULL</a></code>, <em>no reordering</em> will be done for
the corresponding side.
</p>
<p>If <code>scale="row"</code> (or <code>scale="col"</code>) the rows (columns) are
scaled to have mean zero and standard deviation one.  There is some
empirical evidence from genomic plotting that this is useful.
</p>
<p>The default colors range from red to white (<code>heat.colors</code>) and
are not pretty.  Consider using enhancements such as the
<span class="pkg">RColorBrewer</span> package,
<a href="https://cran.r-project.org/package=RColorBrewer">https://cran.r-project.org/package=RColorBrewer</a>
to select better colors.
</p>
<p>By default four components will be displayed in the plot.  At the top
left is the color key, top right is the column dendrogram, bottom left
is the row dendrogram, bottom right is the image plot.  When
RowSideColor or ColSideColor are provided, an additional row or column
is inserted in the appropriate location.   This layout can be
overriden by specifiying appropriate values for <code>lmat</code>,
<code>lwid</code>, and <code>lhei</code>.  <code>lmat</code> controls the relative
postition of each element, while <code>lwid</code> controls the column
width, and <code>lhei</code> controls the row height. See the help page for
<code><a href="graphics.html#topic+layout">layout</a></code> for details on how to use these
arguments.
</p>


<h3>Value</h3>

<p>Invisibly, a list with components
</p>
<table role = "presentation">
<tr><td><code>rowInd</code></td>
<td>
<p>row index permutation vector as returned by
<code><a href="stats.html#topic+order.dendrogram">order.dendrogram</a></code>.</p>
</td></tr>
<tr><td><code>colInd</code></td>
<td>
<p>column index permutation vector.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>rowMeans</code>, <code>rowSDs</code></td>
<td>
<p>mean and standard deviation of each row: only
present if <code>scale="row"</code></p>
</td></tr>
<tr><td><code>colMeans</code>, <code>colSDs</code></td>
<td>
<p>mean and standard deviation of each column: only
present if <code>scale="column"</code></p>
</td></tr>
<tr><td><code>carpet</code></td>
<td>
<p>reordered and scaled 'x' values used generate the main
'carpet'</p>
</td></tr>
<tr><td><code>rowDendrogram</code></td>
<td>
<p>row dendrogram, if present</p>
</td></tr>
<tr><td><code>colDendrogram</code></td>
<td>
<p>column dendrogram, if present</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>values used for color break points</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>colors used</p>
</td></tr>
<tr><td><code>vline</code></td>
<td>
<p>center-line value used for column trace, present only if
<code>trace="both"</code> or <code>trace="column"</code> </p>
</td></tr>
<tr><td><code>hline</code></td>
<td>
<p>center-line value used for row trace, present only if
<code>trace="both"</code> or <code>trace="row"</code> </p>
</td></tr>
<tr><td><code>colorTable</code></td>
<td>
<p>A three-column data frame providing the lower and upper
bound and color for each bin</p>
</td></tr>
<tr><td><code>layout</code></td>
<td>
<p>A named list containing the values used for
<code>lmat</code>, <code>lhei</code>, and <code>lwid</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The original rows and columns are reordered to match the dendrograms
<code>Rowv</code> and <code>Colv</code> (if present).
</p>
<p><code>heatmap.2()</code> uses <code><a href="graphics.html#topic+layout">layout</a></code> to arragent the plot
elements. Consequentially, it can <b>not</b> be used in a multi
column/row layout using <code><a href="graphics.html#topic+layout">layout</a>(...)</code>,
<code><a href="graphics.html#topic+par">par</a>(mfrow=...)</code> or <code>(mfcol=...)</code>.
</p>


<h3>Author(s)</h3>

<p>Andy Liaw, original; R. Gentleman, M. Maechler, W. Huber,
G. Warnes, revisions.</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> data(mtcars)
 x  &lt;- as.matrix(mtcars)
 rc &lt;- rainbow(nrow(x), start=0, end=.3)
 cc &lt;- rainbow(ncol(x), start=0, end=.3)

 ##
 ## demonstrate the effect of row and column dendrogram options
 ##
 heatmap.2(x)                    ## default - dendrogram plotted and reordering done.
 heatmap.2(x, dendrogram="none") ##  no dendrogram plotted, but reordering done.
 heatmap.2(x, dendrogram="row")  ## row dendrogram plotted and row reordering done.
 heatmap.2(x, dendrogram="col")  ## col dendrogram plotted and col reordering done.

 heatmap.2(x, keysize=2)         ## default - dendrogram plotted and reordering done.

 heatmap.2(x, Rowv=FALSE, dendrogram="both") ## generates a warning!
 heatmap.2(x, Rowv=NULL, dendrogram="both")  ## generates a warning!
 heatmap.2(x, Colv=FALSE, dendrogram="both") ## generates a warning!

 ## Reorder dendrogram by branch means rather than sums
 heatmap.2(x, reorderfun=function(d, w) reorder(d, w, agglo.FUN = mean) )

 ## plot a sub-cluster using the same color coding as for the full heatmap
 full &lt;- heatmap.2(x)
 heatmap.2(x, Colv=full$colDendrogram[[2]], breaks=full$breaks)  # column subset
 heatmap.2(x, Rowv=full$rowDendrogram[[1]], breaks=full$breaks)  # row subset
 heatmap.2(x, Colv=full$colDendrogram[[2]],
              Rowv=full$rowDendrogram[[1]], breaks=full$breaks)  # both

 ## Show effect of row and column label rotation
 heatmap.2(x, srtCol=NULL)
 heatmap.2(x, srtCol=0,   adjCol = c(0.5,1) )
 heatmap.2(x, srtCol=45,  adjCol = c(1,1)   )
 heatmap.2(x, srtCol=135, adjCol = c(1,0)   )
 heatmap.2(x, srtCol=180, adjCol = c(0.5,0) )
 heatmap.2(x, srtCol=225, adjCol = c(0,0)   ) ## not very useful
 heatmap.2(x, srtCol=270, adjCol = c(0,0.5) )
 heatmap.2(x, srtCol=315, adjCol = c(0,1)   )
 heatmap.2(x, srtCol=360, adjCol = c(0.5,1) )

 heatmap.2(x, srtRow=45, adjRow=c(0, 1) )
 heatmap.2(x, srtRow=45, adjRow=c(0, 1), srtCol=45, adjCol=c(1,1) )
 heatmap.2(x, srtRow=45, adjRow=c(0, 1), srtCol=270, adjCol=c(0,0.5) )


 ## Show effect of offsetRow/offsetCol (only works when srtRow/srtCol is
 ## not also present)
 heatmap.2(x, offsetRow=0, offsetCol=0)
 heatmap.2(x, offsetRow=1, offsetCol=1)
 heatmap.2(x, offsetRow=2, offsetCol=2)
 heatmap.2(x, offsetRow=-1, offsetCol=-1)

 heatmap.2(x, srtRow=0, srtCol=90, offsetRow=0, offsetCol=0)
 heatmap.2(x, srtRow=0, srtCol=90, offsetRow=1, offsetCol=1)
 heatmap.2(x, srtRow=0, srtCol=90, offsetRow=2, offsetCol=2)
 heatmap.2(x, srtRow=0, srtCol=90, offsetRow=-1, offsetCol=-1)


 ## Show how to use 'extrafun' to replace the 'key' with a scatterplot
 lmat &lt;- rbind( c(5,3,4), c(2,1,4) )
 lhei &lt;- c(1.5, 4)
 lwid &lt;- c(1.5, 4, 0.75)

 myplot &lt;- function() {
             oldpar &lt;- par("mar")
             par(mar=c(5.1, 4.1, 0.5, 0.5))
             plot(mpg ~ hp, data=x)
           }

 heatmap.2(x, lmat=lmat, lhei=lhei, lwid=lwid, key=FALSE, extrafun=myplot)

 ## show how to customize the color key
 heatmap.2(x,
           key.title=NA, # no title
           key.xlab=NA,  # no xlab
           key.par=list(mgp=c(1.5, 0.5, 0),
                        mar=c(2.5, 2.5, 1, 0)),
           key.xtickfun=function() {
                 breaks &lt;- parent.frame()$breaks
                 return(list(
                      at=parent.frame()$scale01(c(breaks[1],
                                                  breaks[length(breaks)])),
                      labels=c(as.character(breaks[1]),
                               as.character(breaks[length(breaks)]))
                      ))
           })

 heatmap.2(x,
          breaks=256,
          key.title=NA,
          key.xlab=NA,
          key.par=list(mgp=c(1.5, 0.5, 0),
                       mar=c(1, 2.5, 1, 0)),
          key.xtickfun=function() {
               cex &lt;- par("cex")*par("cex.axis")
               side &lt;- 1
               line &lt;- 0
               col &lt;- par("col.axis")
               font &lt;- par("font.axis")
               mtext("low", side=side, at=0, adj=0,
                     line=line, cex=cex, col=col, font=font)
               mtext("high", side=side, at=1, adj=1,
                     line=line, cex=cex, col=col, font=font)
               return(list(labels=FALSE, tick=FALSE))
          })


 ##
 ## Show effect of z-score scaling within columns, blue-red color scale
 ##
 hv &lt;- heatmap.2(x, col=bluered, scale="column", tracecol="#303030")

 ###
 ## Look at the return values
 ###
 names(hv)

 ## Show the mapping of z-score values to color bins
 hv$colorTable

 ## Extract the range associated with white
 hv$colorTable[hv$colorTable[,"color"]=="#FFFFFF",]

 ## Determine the original data values that map to white
 whiteBin &lt;- unlist(hv$colorTable[hv$colorTable[,"color"]=="#FFFFFF",1:2])
 rbind(whiteBin[1] * hv$colSDs + hv$colMeans,
       whiteBin[2] * hv$colSDs + hv$colMeans )
 ##
 ## A more decorative heatmap, with z-score scaling along columns
 ##
 hv &lt;- heatmap.2(x, col=cm.colors(255), scale="column",
	       RowSideColors=rc, ColSideColors=cc, margin=c(5, 10),
	       xlab="specification variables", ylab= "Car Models",
	       main="heatmap(&lt;Mtcars data&gt;, ..., scale=\"column\")",
         tracecol="green", density="density")
 ## Note that the breakpoints are now symmetric about 0

 ## Color the labels to match RowSideColors and ColSideColors
 hv &lt;- heatmap.2(x, col=cm.colors(255), scale="column",
         RowSideColors=rc, ColSideColors=cc, margin=c(5, 10),
	       xlab="specification variables", ylab= "Car Models",
	       main="heatmap(&lt;Mtcars data&gt;, ..., scale=\"column\")",
         tracecol="green", density="density", colRow=rc, colCol=cc,
         srtCol=45, adjCol=c(0.5,1))




 data(attitude)
 round(Ca &lt;- cor(attitude), 2)
 symnum(Ca) # simple graphic

 # with reorder
 heatmap.2(Ca, 		 symm=TRUE, margin=c(6, 6), trace="none" )

 # without reorder
 heatmap.2(Ca, Rowv=FALSE, symm=TRUE, margin=c(6, 6), trace="none" )

 ## Place the color key below the image plot
 heatmap.2(x, lmat=rbind( c(0, 3), c(2,1), c(0,4) ), lhei=c(1.5, 4, 2 ) )

 ## Place the color key to the top right of the image plot
 heatmap.2(x, lmat=rbind( c(0, 3, 4), c(2,1,0 ) ), lwid=c(1.5, 4, 2 ) )

 ## For variable clustering, rather use distance based on cor():
 data(USJudgeRatings)
 symnum( cU &lt;- cor(USJudgeRatings) )

 hU &lt;- heatmap.2(cU, Rowv=FALSE, symm=TRUE, col=topo.colors(16),
              distfun=function(c) as.dist(1 - c), trace="none")

 ## The Correlation matrix with same reordering:
 hM &lt;- format(round(cU, 2))
 hM

 # now with the correlation matrix on the plot itself

 heatmap.2(cU, Rowv=FALSE, symm=TRUE, col=rev(heat.colors(16)),
             distfun=function(c) as.dist(1 - c), trace="none",
             cellnote=hM)

 ## genechip data examples
 ## Not run: 
 library(affy)
 data(SpikeIn)
 pms &lt;- SpikeIn@pm

 # just the data, scaled across rows
 heatmap.2(pms, col=rev(heat.colors(16)), main="SpikeIn@pm",
              xlab="Relative Concentration", ylab="Probeset",
              scale="row")

 # fold change vs "12.50" sample
 data &lt;- pms / pms[, "12.50"]
 data &lt;- ifelse(data&gt;1, data, -1/data)
 heatmap.2(data, breaks=16, col=redgreen, tracecol="blue",
               main="SpikeIn@pm Fold Changes\nrelative to 12.50 sample",
               xlab="Relative Concentration", ylab="Probeset")
 
## End(Not run)

</code></pre>

<hr>
<h2 id='hist2d'> Compute and Plot a 2-Dimensional Histogram </h2><span id='topic+hist2d'></span><span id='topic+print.hist2d'></span>

<h3>Description</h3>

<p>Compute and plot a 2-dimensional histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist2d(x,y=NULL, nbins=200, same.scale=FALSE, na.rm=TRUE, show=TRUE,
       col=c("black", heat.colors(12)), FUN=base::length, xlab, ylab,
       ... )
## S3 method for class 'hist2d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist2d_+3A_x">x</code></td>
<td>
<p>either a vector containing the x coordinates
or a matrix with 2 columns. </p>
</td></tr>
<tr><td><code id="hist2d_+3A_y">y</code></td>
<td>
<p>a vector contianing the y coordinates, not required if &lsquo;x&rsquo;
is matrix</p>
</td></tr>
<tr><td><code id="hist2d_+3A_nbins">nbins</code></td>
<td>
<p>number of bins in each dimension. May be a scalar or a
2 element vector.  Defaults to 200.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_same.scale">same.scale</code></td>
<td>
<p>use the same range for x and y. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_na.rm">na.rm</code></td>
<td>
<p> Indicates whether missing values should be
removed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_show">show</code></td>
<td>
<p> Indicates whether the histogram be displayed using
<code>image</code> once it has
been computed. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_col">col</code></td>
<td>
<p> Colors for the histogram. Defaults to &quot;black&quot; for
bins containing no elements, a set of 16 heat colors for other bins.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_fun">FUN</code></td>
<td>
<p>Function used to summarize bin contents.  Defaults to
<code>base::length</code>. Use, e.g., <code>mean</code> to calculate means for each bin
instead of counts.</p>
</td></tr>
<tr><td><code id="hist2d_+3A_xlab">xlab</code>, <code id="hist2d_+3A_ylab">ylab</code></td>
<td>
<p>(Optional) x and y axis labels</p>
</td></tr>
<tr><td><code id="hist2d_+3A_...">...</code></td>
<td>
<p> Parameters passed to the image function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This fucntion creates a 2-dimensional histogram by cutting the x and
y dimensions into <code>nbins</code> sections.  A 2-dimensional matrix is
then constucted which holds the counts of the number of observed (x,y) pairs
that fall into each bin.  If <code>show=TRUE</code>, this matrix is then
then passed to <code>image</code> for display.
</p>


<h3>Value</h3>

<p>A list containing 5 elements:
</p>
<table role = "presentation">
<tr><td><code>counts</code></td>
<td>
<p>Matrix containing the number of points falling into each
bin</p>
</td></tr>
<tr><td><code>x.breaks</code>, <code>y.breaks</code></td>
<td>
<p>Lower and upper limits of each bin</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>midpoints of each bin</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="r2d2.html#topic+freq2d">freq2d</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## example data, bivariate normal, no correlation
   x &lt;- rnorm(2000, sd=4)
   y &lt;- rnorm(2000, sd=1)

   ## separate scales for each axis, this looks circular
   hist2d(x,y)

   ## same scale for each axis, this looks oval
   hist2d(x,y, same.scale=TRUE)

   ## use different ## bins in each dimension
   hist2d(x,y, same.scale=TRUE, nbins=c(100,200) )

   ## use the hist2d function to create an h2d object
   h2d &lt;- hist2d(x,y,show=FALSE, same.scale=TRUE, nbins=c(20,30))

   ## show object summary
   h2d

   ## object contents
   str(h2d)

   ## perspective plot
   persp( h2d$x, h2d$y, h2d$counts,
          ticktype="detailed", theta=30, phi=30,
          expand=0.5, shade=0.5, col="cyan", ltheta=-30)

   ## for contour (line) plot ...
   contour( h2d$x, h2d$y, h2d$counts, nlevels=4 )

   ## for a filled contour plot ...
   filled.contour( h2d$x, h2d$y, h2d$counts, nlevels=4,
                   col=gray((4:0)/4) )



</code></pre>

<hr>
<h2 id='lmplot2'>
Plots to assess the goodness of fit for the linear model objects
</h2><span id='topic+lmplot2'></span>

<h3>Description</h3>

<p>Plots to assess the goodness of fit for the linear model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   lmplot2(
            x,
            which = 1:5,
            caption = c("Residuals vs Fitted", "Normal Q-Q plot",
              "Scale-Location plot", "Cook's distance plot"),
            panel = panel.smooth,
            sub.caption = deparse(x$call),
            main = "",
            ask = interactive() &amp;&amp; nb.fig &lt; length(which)
            &amp;&amp; .Device != "postscript",
            ...,
            id.n = 3,
            labels.id = names(residuals(x)),
            cex.id = 0.75,
            band=TRUE,
            rug=TRUE,
            width=1/10,
            max.n=5000
            )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmplot2_+3A_x">x</code></td>
<td>
<p>lm object</p>
</td></tr>
<tr><td><code id="lmplot2_+3A_which">which</code></td>
<td>
<p>Numerical values between 1 and 5, indicating which plots
to be shown. The codes are:
</p>

<dl>
<dt>1</dt><dd><p>Fitted vs residuals</p>
</dd>
<dt>2</dt><dd><p>Normal Q-Q</p>
</dd>
<dt>3</dt><dd><p>Scale-Location</p>
</dd>
<dt>4</dt><dd><p>Cook's distance</p>
</dd>
<dt>5</dt><dd><p>Residuals vs. predictor</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="lmplot2_+3A_caption">caption</code></td>
<td>
<p> Caption for each type of plot</p>
</td></tr>
<tr><td><code id="lmplot2_+3A_panel">panel</code></td>
<td>
<p> function to draw on the existing plot</p>
</td></tr>
<tr><td><code id="lmplot2_+3A_sub.caption">sub.caption</code></td>
<td>
<p> SubCaption for the plots </p>
</td></tr>
<tr><td><code id="lmplot2_+3A_main">main</code></td>
<td>
<p>Main title of the plot</p>
</td></tr>
<tr><td><code id="lmplot2_+3A_ask">ask</code></td>
<td>
<p>whether interactive graphics</p>
</td></tr>
<tr><td><code id="lmplot2_+3A_...">...</code></td>
<td>
<p> parameters passed to <code>lmplot2</code>. </p>
</td></tr>
<tr><td><code id="lmplot2_+3A_id.n">id.n</code></td>
<td>
<p> integer value, less than or equal to residuals of lm object </p>
</td></tr>
<tr><td><code id="lmplot2_+3A_labels.id">labels.id</code></td>
<td>
<p>Names of the residuals of the lm object</p>
</td></tr>
<tr><td><code id="lmplot2_+3A_cex.id">cex.id</code></td>
<td>
<p>Parameter to control the height of text stringsx</p>
</td></tr>
<tr><td><code id="lmplot2_+3A_band">band</code></td>
<td>
<p>logical vector indicating whether bandplot should also be plotted </p>
</td></tr>
<tr><td><code id="lmplot2_+3A_rug">rug</code></td>
<td>
<p>logical vector indicating whether rug should be added to
the existing plot </p>
</td></tr>
<tr><td><code id="lmplot2_+3A_width">width</code></td>
<td>
<p>Fraction of the data to use for plot smooths</p>
</td></tr>
<tr><td><code id="lmplot2_+3A_max.n">max.n</code></td>
<td>
<p>Maximum number of points to display in plots</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function replaces <code>plot.lm2</code>, which has been deprecated
to avoid potential problems with S3 method dispatching.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> and Nitin
Jain <a href="mailto:nitin.jain@pfizer.com">nitin.jain@pfizer.com</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.lm">plot.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctl &lt;- rnorm(100, 4)
trt &lt;- rnorm(100, 4.5)
group &lt;- gl(2,100,200, labels=c("Ctl","Trt"))
weight &lt;- c(ctl, trt)
wt.err &lt;- rnorm(length(weight), mean=weight, sd=1/2)
x &lt;- lm(weight ~ group + wt.err)

lmplot2(x)

lmplot2(x, which=1,   width=1/3)
lmplot2(x, which=1:3, width=1/3)
</code></pre>

<hr>
<h2 id='lowess'>Scatter Plot Smoothing</h2><span id='topic+lowess'></span><span id='topic+lowess.default'></span><span id='topic+lowess.formula'></span><span id='topic+plot.lowess'></span><span id='topic+plotLowess'></span>

<h3>Description</h3>

<p>The <code>lowess</code> function performs the computations for the
<em>LOWESS</em> smoother (see the reference below).
<code>lowess</code> returns a an object containing components
<code>x</code> and <code>y</code> which give the coordinates of the smooth.
The smooth can then be added to a plot of the original
points with the function <code>lines</code>.
</p>
<p>Alternatively, <code>plot</code> can be called directly on the object
returned from <code>lowess</code> and the 'lowess' method for <code>plot</code>
will generate a scatterplot of the original data with a <code>lowess</code>
line superimposed.
</p>
<p>Finally, the <code>plotLowess</code> function both calculates the
<code>lowess</code> smooth and plots the original data with a <code>lowess</code>
smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowess(x, ...)

## Default S3 method:
lowess(x, y=NULL, f=2/3, iter=3L, delta=0.01 *
       diff(range(x)), ...)

## S3 method for class 'formula'
lowess(formula,data=parent.frame(), ..., subset, f=2/3,
       iter=3L, delta=.01*diff(range(mf[-response])))

## S3 method for class 'lowess'
plot(x, y, ..., col.lowess="red", lty.lowess=2)

plotLowess(formula, data=parent.frame(), ..., subset=parent.frame(),
           col.lowess="red", lty.lowess=2  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lowess_+3A_formula">formula</code></td>
<td>
<p> formula providing a single dependent variable (y) and
an single independent variable (x) to use as coordinates in the
scatter plot.</p>
</td></tr>
<tr><td><code id="lowess_+3A_data">data</code></td>
<td>
<p>a data.frame (or list) from which the variables in &lsquo;formula&rsquo;
should be taken.</p>
</td></tr>
<tr><td><code id="lowess_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations
to be used in the fitting process. </p>
</td></tr>
<tr><td><code id="lowess_+3A_x">x</code>, <code id="lowess_+3A_y">y</code></td>
<td>
<p>vectors giving the coordinates of the points in the scatter
plot. Alternatively a single plotting structure can be specified.</p>
</td></tr>
<tr><td><code id="lowess_+3A_f">f</code></td>
<td>
<p>the smoother span. This gives the proportion of points in
the plot which influence the smooth at each value.
Larger values give more smoothness.</p>
</td></tr>
<tr><td><code id="lowess_+3A_iter">iter</code></td>
<td>
<p>the number of robustifying iterations which should be
performed.
Using smaller values of <code>iter</code> will make <code>lowess</code> run
faster.</p>
</td></tr>
<tr><td><code id="lowess_+3A_delta">delta</code></td>
<td>
<p>values of <code>x</code> which lie within <code>delta</code>
of each other replaced by a single value in the output from
<code>lowess</code>.</p>
</td></tr>
<tr><td><code id="lowess_+3A_...">...</code></td>
<td>
<p>parameters for methods.</p>
</td></tr>
<tr><td><code id="lowess_+3A_col.lowess">col.lowess</code>, <code id="lowess_+3A_lty.lowess">lty.lowess</code></td>
<td>
<p>color and line type for plotted line</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cleveland, W. S. (1979)
Robust locally weighted regression and smoothing scatterplots.
<em>J. Amer. Statist. Assoc.</em> <b>74</b>, 829&ndash;836.
</p>
<p>Cleveland, W. S. (1981)
LOWESS: A program for smoothing scatterplots by robust locally weighted
regression. <em>The American Statistician</em>, <b>35</b>, 54.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+loess">loess</a></code> (in package <code>modreg</code>), a newer
formula based version of <code>lowess</code> (with different defaults!).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cars)

#
# x,y method
#
plot(cars$speed, cars$dist, main="lowess(cars)")
lines(lowess(cars$speed, cars$dist), col=2)
lines(lowess(cars$speed, cars$dist, f=.2), col=3)
legend(5, 120, c(paste("f=", c("2/3", ".2"))), lty=1, col=2:3)

#
# formula method: plot, then calculate the lowess smoother,
#                 then add smooth to the plot
#
plot(dist ~ speed, data=cars, main="lowess(cars)")
lines(lowess(dist ~ speed, data=cars), col=2, lty=2)
lines(lowess(dist ~ speed, data=cars, f=.2), col=3) # smaller bandwith
legend(5, 120, c(paste("f=", c("2/3", ".2"))), lty=1, col=2:3)

#
# formula method: calculate lowess() smoother, then call plot()
#                  on the lowess object
#
lw &lt;- lowess(dist ~ speed, data=cars)
plot(lw, main="lowess(cars)"  )

#
# formula method: calculate and plot in a single command
#
plotLowess(dist ~ speed, data=cars, main="lowess(cars)")

 

</code></pre>

<hr>
<h2 id='ooplot.default'>Create an OpenOffice style plot</h2><span id='topic+ooplot.default'></span><span id='topic+ooplot'></span>

<h3>Description</h3>

<p>An extension of barplot2. Creates bar- and line-plots mimicking the
style of OpenOffice plots.  This utility can plot the values next to
each point or bar as well as confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ooplot(data, ...)
## Default S3 method:
ooplot(data, width=1, space=NULL, names.arg=NULL, 
                           legend.text=NULL, horiz=FALSE, 
                           density=NULL, angle=45, kmg="fpnumkMGTP", 
                           kmglim=TRUE, 
                           type=c("xyplot", "linear", "barplot", "stackbar"), 
                           col=heat.colors(NC), prcol=NULL, 
                           border=par("fg"), main=NULL, sub=NULL, 
                           xlab=NULL, ylab=NULL, xlim=NULL, ylim=NULL, 
                           xpd=TRUE, log="", axes=TRUE, 
                           axisnames=TRUE, prval=TRUE, lm=FALSE,
                           cex.axis=par("cex.axis"), 
                           cex.names=par("cex.axis"),
                           cex.values=par("cex"),inside=TRUE, 
                           plot=TRUE, axis.lty=0, plot.ci=FALSE, 
                           ci.l=NULL, ci.u=NULL, ci.color="black", 
                           ci.lty="solid", ci.lwd=1, plot.grid=FALSE, 
                           grid.inc=NULL, grid.lty="dotted", 
                           grid.lwd=1, grid.col="black", add=FALSE, 
                           by.row=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ooplot.default_+3A_data">data</code></td>
<td>
<p>a matrix of values describing the values that make up the
plot. The first column of <code>data</code> is taken as the axis against
which all the other values are plotted. The first column of
<code>data</code> may not be sparse.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_width">width</code></td>
<td>
<p>optional vector of barwidths. Re-cycled to the number of
bars drawn. A single value will have no visible effect. </p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_space">space</code></td>
<td>
<p> the amount of space left before each bar. May be given
as a single number or one number per bar. If <code>type</code> is
<code>stackbar</code>, <code>space</code> may be specified by two numbers, where
the first is the space between bars in the same group, and the second
the space between groups. Defaults to <code>c(0,1)</code> if <code>type</code> is
a <code>stackbar</code>, and to 0.2 otherwise. </p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_names.arg">names.arg</code></td>
<td>
<p>a vector of names to be plotted below each bar or
group of bars.  If this argument is omitted, then the names are
taken from the  row names of <code>data</code>. </p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_legend.text">legend.text</code></td>
<td>
<p>a vector of text used to construct a legend for the
plot, or a logical indicating whether a legend should be included;
if <code>legend.text</code> is true, the row names of <code>data</code> will
be used as labels if they are non-null.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_horiz">horiz</code></td>
<td>
<p>a logical value.  If <code>FALSE</code>, the bars are drawn
vertically with the first bar to the left.  If <code>TRUE</code>, the
bars are drawn horizontally with the first at the bottom.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_density">density</code></td>
<td>
<p>a vector giving the the density of shading lines, in
lines per inch, for the bars or bar components.
The default value of <code>NULL</code> means that no shading lines
are drawn. Non-positive values of <code>density</code> also inhibit the
drawing of shading lines.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_angle">angle</code></td>
<td>
<p>the slope of shading lines, given as an angle in
degrees (counter-clockwise), for the bars or bar components.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_kmg">kmg</code></td>
<td>
<p>the set of SI units to convert, defaults to
&quot;fpnumkMGTP&quot;. See below for details. </p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_kmglim">kmglim</code></td>
<td>
<p>logical. If <code>FALSE</code> the conversion to SI units is not
performed. Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_type">type</code></td>
<td>
<p>a string indicating the preferred format of the plot,
choices are:
xyplot : plot where y is plotted against the x-value.
linear : plot where y values are plotted against equidistant x-values.
barplot : plot where y values are represented as bars against
equidistant x-values.
stackplot : plot where y values are stacked for identical x-values
and bars are equidistant.
</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_col">col</code></td>
<td>
<p>a vector of colors for the bars or bar components.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_prcol">prcol</code></td>
<td>
<p>the color to be used for the plot region.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_border">border</code></td>
<td>
<p>the color to be used for the border of the bars.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_main">main</code>, <code id="ooplot.default_+3A_sub">sub</code></td>
<td>
<p>overall and sub titles for the plot.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_xlim">xlim</code></td>
<td>
<p>limits for the x axis.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_xpd">xpd</code></td>
<td>
<p>logical. Should bars be allowed to go outside region?</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_log">log</code></td>
<td>
<p>a character string which contains &lsquo;&quot;x&quot;&rsquo; if the x axis is
to be logarithmic, &lsquo;&quot;y&quot;&rsquo; if the y axis is to be logarithmic and
&lsquo;&quot;xy&quot;&rsquo; or &lsquo;&quot;yx&quot;&rsquo; if both axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_axes">axes</code></td>
<td>
<p>logical.  If <code>TRUE</code>, a vertical (or horizontal, if
<code>horiz</code> is true) axis is drawn.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_axisnames">axisnames</code></td>
<td>
<p>logical.  If <code>TRUE</code>, and if there are
<code>names.arg</code> (see above), the
other axis is drawn (with <code>lty=0</code>) and labeled.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_prval">prval</code></td>
<td>
<p>logical. If <code>TRUE</code>, then values are plotted above
all points and bars.
</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_lm">lm</code></td>
<td>
<p>logical. If <code>TRUE</code>, the linear fit is plotted.
</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_cex.axis">cex.axis</code>, <code id="ooplot.default_+3A_cex.names">cex.names</code>, <code id="ooplot.default_+3A_cex.values">cex.values</code></td>
<td>
<p>character scaling factor for
numeric axis labels,
names, and displayed values, respectively.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_inside">inside</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the lines which divide
adjacent (non-stacked!) bars will be drawn.  Only applies when
<code>space = 0</code> (which it partly is when <code>beside = TRUE</code>).</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_plot">plot</code></td>
<td>
<p>logical.  If <code>FALSE</code>, nothing is plotted.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_axis.lty">axis.lty</code></td>
<td>
<p>the graphics parameter <code>lty</code> applied to the axis
and tick marks of the categorical (default horzontal) axis.  Note
that by default the axis is suppressed.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_plot.ci">plot.ci</code></td>
<td>
<p>logical. If <code>TRUE</code>, confidence intervals are plotted
over the bars. Note that if a stacked bar plot is generated, confidence
intervals will not be plotted even if <code>plot.ci = TRUE</code></p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_ci.l">ci.l</code>, <code id="ooplot.default_+3A_ci.u">ci.u</code></td>
<td>
<p>The confidence intervals (ci.l = lower bound, ci.u =
upper bound) to be plotted if <code>plot.ci</code> = <code>TRUE</code>. Values must have
the same dim structure as <code>height</code>.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_ci.color">ci.color</code></td>
<td>
<p>the color for the confidence interval line segments</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_ci.lty">ci.lty</code></td>
<td>
<p>the line type for the confidence interval line segments</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_ci.lwd">ci.lwd</code></td>
<td>
<p>the line width for the confidence interval line segments</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_plot.grid">plot.grid</code></td>
<td>
<p>if <code>TRUE</code> a lined grid will be plotted behind the bars</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_grid.inc">grid.inc</code></td>
<td>
<p>the number of grid increments to be plotted</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_grid.lty">grid.lty</code></td>
<td>
<p>the line type for the grid</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_grid.lwd">grid.lwd</code></td>
<td>
<p>the line width for the grid</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_grid.col">grid.col</code></td>
<td>
<p>the line color for the grid</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_add">add</code></td>
<td>
<p>logical, if <code>TRUE</code> add barplot to current plot.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_by.row">by.row</code></td>
<td>
<p>Logical value.  If <code>TRUE</code> the data matrix is
organized with variables along rows rather than down colums.</p>
</td></tr>
<tr><td><code id="ooplot.default_+3A_...">...</code></td>
<td>
<p>further graphical parameters (<code><a href="graphics.html#topic+par">par</a></code>) are
passed to <code><a href="graphics.html#topic+plot.window">plot.window</a>()</code>, <code><a href="graphics.html#topic+title">title</a>()</code> and
<code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot units are automatically scaled to SI units based on the
maximum value present, according to the set of units specified by
characters in the <code>kmg</code> parameter.  These letters are interpreted
as
</p>

<dl>
<dt>P</dt><dd><p>peta = 1E15</p>
</dd>
<dt>T</dt><dd><p>tera = 1E12</p>
</dd>
<dt>G</dt><dd><p>giga = 1E09</p>
</dd>
<dt>M</dt><dd><p>mega = 1E06</p>
</dd>
<dt>k</dt><dd><p>kilo = 1E03</p>
</dd>
<dt>m</dt><dd><p>milli= 1E-03</p>
</dd>
<dt>u</dt><dd><p>micro= 1E-06</p>
</dd>
<dt>n</dt><dd><p>nano = 1E-09</p>
</dd>
<dt>p</dt><dd><p>pico = 1E-12</p>
</dd>
<dt>f</dt><dd><p>femto= 1E-15</p>
</dd>
</dl>

<p>with the default being &quot;fpnumkMGTP&quot; (all of these units).  For
example, if the largest value plotted is 1243000, it would be
presented as 1.234M.
</p>


<h3>Value</h3>

<p>A numeric vector (or matrix, when <code>beside = TRUE</code>), say
<code>mp</code>, giving the coordinates of <em>all</em> the bar midpoints
drawn, useful for adding to the graph.
</p>
<p>If <code>beside</code> is true, use <code>colMeans(mp)</code> for the
midpoints of each <em>group</em> of bars, see example.
</p>


<h3>Author(s)</h3>

<p>Lodewijk Bonebakker <a href="mailto:bonebakker@comcast.net">bonebakker@comcast.net</a> with modifications
by Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>.
Based on barplot2().
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+boxplot">boxplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>     data(VADeaths, package = "datasets")

     VADeaths &lt;- cbind( Age=c(50,55,60,65,70), VADeaths)

     mp &lt;- ooplot(VADeaths) # default
     mp &lt;- ooplot(VADeaths, type="xyplot")  # same as default
     mp &lt;- ooplot(VADeaths, type="linear")  # linear scale
     mp &lt;- ooplot(VADeaths, type="linear", log="y") # log scale on y axis
     mp &lt;- ooplot(VADeaths, type="barplot") # barplot
     mp &lt;- ooplot(VADeaths, type="stackbar") # stacked


     tot &lt;- colMeans(VADeaths[,-1])
     ooplot(VADeaths, 
             col = c("lightblue", "mistyrose", "lightcyan", "lavender"),
             legend = colnames(VADeaths)[-1], ylim = c(0, 100),
             type="barplot", cex.values=0.75)
     title(main = "Death Rates in Virginia", font.main = 4)


     ##
     ## Capability demo
     ##
     ## examples for the ooplot routine
     ##
     ## create some test data
     test1 &lt;- data.frame(x=c(0,1,2,3,4), lin=c(0,1,2,3,4))
     test2 &lt;- data.frame(x=c(0,1,2,3,4), par=c(0,1,4,9,16))
     test3 &lt;- data.frame(x=c(-2,-1,0,1,2),y2=c(4,1,0,1,4))
     ## single line test example
     test1f &lt;- test1
     ## two column example
     test2f &lt;- merge(test1,test2,by.x="x",all=TRUE,sort=TRUE)
     ## three column example
     test3f &lt;- merge(test2f,test3,by.x="x",all=TRUE,sort=TRUE)
     ## subset, single row, example
     test5r &lt;- test3f[5,]  
     
     ##
     ## xyplot, linear, barplot, stackbar
     dev.off()
     mat &lt;- matrix(c(1:16),4,4,byrow=TRUE)
     layout(mat)
     
     ooplot(test1f,type="barplot",col=c("red"))
     title(main="barplot")
     ooplot(test2f,type="barplot",col=c("red","blue"))
     ooplot(test3f,type="barplot",col=c("red","blue","green"))
     ooplot(test5r,type="barplot",col=c("red","blue","green"))
     
     ooplot(test1f,type="xyplot",col=c("red"))
     title(main="xyplot")
     ooplot(test2f,type="xyplot",col=c("red","blue"))
     ooplot(test3f,type="xyplot",col=c("red","blue","green"))
     ooplot(test5r,type="xyplot",col=c("red","blue","green"))
     
     ooplot(test1f,type="linear",col=c("red"))
     title(main="linear")
     ooplot(test2f,type="linear",col=c("red","blue"))
     ooplot(test3f,type="linear",col=c("red","blue","green"))
     ooplot(test5r,type="linear",col=c("red","blue","green"))
     
     ooplot(test1f,type="stackbar",col=c("red"))
     title(main="stackbar")
     ooplot(test2f,type="stackbar",col=c("red","blue"))
     ooplot(test3f,type="stackbar",col=c("red","blue","green"))
     ooplot(test5r,type="stackbar",col=c("red","blue","green"))

     # restore default layout (1 plot/page)
     layout(1)
</code></pre>

<hr>
<h2 id='overplot'>Plot multiple variables on the same region, with appropriate axes</h2><span id='topic+overplot'></span><span id='topic+panel.overplot'></span>

<h3>Description</h3>

<p><code>overplot</code> graphs a set of variables defined on the same x-range
but which have varying y-ranges on the same plotting area.  For each
set of y-values it uses a different color and line-type and and draws
a correspondingly colored and line-typed axis.  <code>panel.overplot</code>
is used by <code>overplot</code> to draw the individual graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overplot(formula, data = parent.frame(), same.scale = FALSE, xlab, ylab,
         xlim, ylim, min.y, max.y, log = "", panel = "panel.overplot",
         subset, plot = TRUE, groups, main, f = 2/3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overplot_+3A_formula">formula</code></td>
<td>
<p>Formula describing the x and y variables.  It should be
of the form x ~ y|z. The conditioning variable (z) should be a factor.</p>
</td></tr>
<tr><td><code id="overplot_+3A_same.scale">same.scale</code></td>
<td>
<p> Logical value indicating whether the plot region
should have the same range for all plots.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="overplot_+3A_xlab">xlab</code>, <code id="overplot_+3A_ylab">ylab</code>, <code id="overplot_+3A_xlim">xlim</code>, <code id="overplot_+3A_ylim">ylim</code>, <code id="overplot_+3A_main">main</code></td>
<td>
<p> Standard plotting parameters.  See
<code><a href="base.html#topic+plot">plot</a></code> for details</p>
</td></tr>
<tr><td><code id="overplot_+3A_min.y">min.y</code>, <code id="overplot_+3A_max.y">max.y</code></td>
<td>
<p>Scalar or vector values used to specify the y
plotting limits for individual plots.  If a single scalar value is
provided, it will be used for all plots. These parameters can be
used specify one end of the individual plot ranges, while allowing
the other end to vary with the data.  EG, to force 0 to always be
within the plot region.</p>
</td></tr>
<tr><td><code id="overplot_+3A_log">log</code></td>
<td>
<p> character string &rdquo;, 'x', 'y', or 'xy', indicating which axes
should be plotted on a log scale. Defaults to &rdquo; (neither).</p>
</td></tr>
<tr><td><code id="overplot_+3A_panel">panel</code></td>
<td>
<p> a plotting function to be called to draw the individual
plots.  Defaults to <code>overplot.panel</code>, which plots the points
and a <code>lowess</code> smooth. </p>
</td></tr>
<tr><td><code id="overplot_+3A_plot">plot</code></td>
<td>
<p>Logical value indicating whether to draw the plot.</p>
</td></tr>
<tr><td><code id="overplot_+3A_groups">groups</code></td>
<td>
<p>(optional) character vector giving the names of levels
of the conditioning variable to plot. Defaults to all levels of the
conditioning variable.</p>
</td></tr>
<tr><td><code id="overplot_+3A_f">f</code></td>
<td>
<p>Smoothing parameter for <code>lowess</code></p>
</td></tr>
<tr><td><code id="overplot_+3A_data">data</code>, <code id="overplot_+3A_subset">subset</code>, <code id="overplot_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>model.frame</code> to
obtain the data to be plotted from the formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function essentially performs
</p>
<p>tmp &lt;- split(data, z)
</p>
<p>for(i in levels(z))
</p>
<p>plot( x ~ y, data=tmp[[z]] )
</p>
<p>except that all of the plots are shown on the same plotting region and
varying scales for each value of z are handled nicely.
</p>


<h3>Value</h3>

<p>A copy of the data split by the conditioning variable.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+interaction.plot">interaction.plot</a></code>,
<code><a href="graphics.html#topic+coplot">coplot</a></code> for alternative visualizations of 3-way data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example teratogenicity rtPCR data
data(rtPCR)

# same scale
overplot( RQ ~ Conc..ug.ml. | Test.Substance,
         data=rtPCR,
         subset=Detector=="ProbeType 1" &amp; Conc..ug.ml. &gt; 0,
         same.scale=TRUE,
         log="xy",
         f=3/4,
         main="Detector=ProbeType 1",
         xlab="Concentration (ug/ml)",
         ylab="Relative Gene Quantification"
         )

# different scales, but force lower limit to 0.01 
overplot( RQ ~ Conc..ug.ml. | Test.Substance,
         data=rtPCR,
         subset=Detector=="ProbeType 8" &amp; Conc..ug.ml. &gt; 0,
         log="xy",
         f=3/4,
         main="Detector=ProbeType 8",
         xlab="Concentration (ug/ml)",
         ylab="Relative Gene Quantification",
         min.y=0.01
         )

</code></pre>

<hr>
<h2 id='plotCI'>Plot Error Bars and Confidence Intervals</h2><span id='topic+plotCI'></span>

<h3>Description</h3>

<p>Given a set of x and y values and interval width or upper and lower bounds,
plot the points with error bars.  This can be a useful tool for
visualizing confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCI(x, y = NULL, uiw, liw = uiw, ui, li, err='y', ylim=NULL,
       xlim=NULL, type="p",  col=par("col"), barcol=col,
       pt.bg = par("bg"),  sfrac = 0.01, gap=1, lwd=par("lwd"),
       lty=par("lty"), labels=FALSE, add=FALSE, xlab, ylab,  minbar,
       maxbar, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCI_+3A_x">x</code>, <code id="plotCI_+3A_y">y</code></td>
<td>
<p> coordinates for the center of error bars. <code>y</code>
defaults to <code>1:n</code>.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_uiw">uiw</code></td>
<td>
<p> width of the upper or right error bar. Set to <code>NULL</code>
or <code>NA</code> to omit upper bars.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_liw">liw</code></td>
<td>
<p> width of the lower or left error bar.  Defaults to same value as
<code>uiw</code>.  Set to <code>NULL</code> or <code>NA</code> to omit lower bars. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_ui">ui</code></td>
<td>
<p> upper end of error bars.  Defaults to <code>y + uiw</code> or
<code>x + uiw</code> depeding on <code>err</code>.  Set to <code>NULL</code>  or
<code>NA</code> to omit upper bars. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_li">li</code></td>
<td>
<p> lower end of error bars.  Defaults to <code>y - liw</code> or
<code>x - liw</code> depedning on <code>err</code>.  Set to <code>NULL</code>  or
<code>NA</code> to omit lower bars.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_err">err</code></td>
<td>
<p> direction for error bars. Set to &quot;y&quot; for vertical bars.
Set to &quot;x&quot; for horizontal bars. Defaults to &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_col">col</code></td>
<td>
<p> color of plotting character used center marker of error
bars. Default is &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_xlim">xlim</code>, <code id="plotCI_+3A_ylim">ylim</code></td>
<td>
<p> range of x/y values to include in the plotting area. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_type">type</code></td>
<td>
<p>point/line type; passed to <code><a href="graphics.html#topic+points">points</a></code></p>
</td></tr>
<tr><td><code id="plotCI_+3A_barcol">barcol</code></td>
<td>
<p>color of the error bars.  Defaults to the same value as
<code>col</code> </p>
</td></tr>
<tr><td><code id="plotCI_+3A_pt.bg">pt.bg</code></td>
<td>
<p>background color of points (use
<code>pch=21, pt.bg=par("bg")</code> to get open points superimposed on
error bars).</p>
</td></tr>
<tr><td><code id="plotCI_+3A_sfrac">sfrac</code></td>
<td>
<p> width of &quot;crossbar&quot; at the end of error bar as a fraction
of the x plotting region. Defaults to 0.01. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_gap">gap</code></td>
<td>
<p> space left between the center of the error bar and the
lines marking the error bar in units of the height (width) of the
letter &quot;O&quot;.  Defaults to 1.0 </p>
</td></tr>
<tr><td><code id="plotCI_+3A_lwd">lwd</code></td>
<td>
<p> width of bar lines. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_lty">lty</code></td>
<td>
<p> line type of bar lines. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_labels">labels</code></td>
<td>
<p> either a logical value indicating whether the circles
representing the x values should be replaced with text giving the
actual values or a vector containing labels to use
instead. Defaults to <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_add">add</code></td>
<td>
<p>logical indicating whether error bars should be added to
the current plot.  If <code>FALSE</code> (the defailt), a new plot will be
created and symbols/labels for the x values will be plotted before
drawing error bars.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_minbar">minbar</code></td>
<td>
<p>minumum allowed value for bar ends.  If specified,
values smaller than <code>minbar</code> will be replaced with
<code>minbar</code>. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_maxbar">maxbar</code></td>
<td>
<p>maximum allowed value for bar ends.  If specified,
values larger than <code>maxbar</code> will be replaced with
<code>maxbar</code>. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_...">...</code></td>
<td>
<p> optional plotting parameters </p>
</td></tr>
<tr><td><code id="plotCI_+3A_xlab">xlab</code></td>
<td>
<p> label for x axis. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Original version by Bill Venables
<a href="mailto:wvenable@attunga.stats.adelaide.edu.au">wvenable@attunga.stats.adelaide.edu.au</a> posted to r-help on
Sep. 20, 1997.  Enhanced version posted to r-help by Ben Bolker
<a href="mailto:ben@zoo.ufl.edu">ben@zoo.ufl.edu</a> on Apr. 16, 2001.  This version was modified
and extended by Gregory R. Warnes
<a href="mailto:greg@warnes.net">greg@warnes.net</a>.  Additional changes
suggested by Martin Maechler <a href="mailto:maechler@stat.math.ethz.ch">maechler@stat.math.ethz.ch</a>
integrated on July 29, 2004.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plotmeans">plotmeans</a></code> provides an enhanced wrapper to
<code>plotCI</code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # plot means and
  data(state)
  tmp   &lt;- split(state.area, state.region)
  means &lt;- sapply(tmp, mean)
  stdev &lt;- sqrt(sapply(tmp, var))
  n     &lt;- sapply(tmp,length)
  ciw   &lt;- qt(0.975, n) * stdev / sqrt(n)

  # plain
  plotCI(x=means, uiw=ciw)

  # prettier
  plotCI(x=means, uiw=ciw, col="black", barcol="blue", lwd=1)

  # give mean values
  plotCI(x=means, uiw=ciw, col="black", barcol="blue",
         labels=round(means,-3), xaxt="n", xlim=c(0,5) )
  axis(side=1, at=1:4, labels=names(tmp), cex=0.7)

  # better yet, just use plotmeans ... #
  plotmeans( state.area ~ state.region )




</code></pre>

<hr>
<h2 id='plotmeans'>Plot Group Means and Confidence Intervals</h2><span id='topic+plotmeans'></span>

<h3>Description</h3>

<p>Plot group means and confidence intervals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmeans(formula, data=NULL, subset, na.action,
          bars=TRUE, p=0.95, minsd=0, minbar, maxbar,
          xlab=names(mf)[2], ylab=names(mf)[1], mean.labels=FALSE,
          ci.label=FALSE, n.label=TRUE, text.n.label="n=",
          digits=getOption("digits"), col="black", barwidth=1,
          barcol="blue", connect=TRUE, ccol=
          col, legends=names(means), xaxt, use.t=TRUE,
          lwd=par("lwd"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotmeans_+3A_formula">formula</code></td>
<td>
<p>symbolic expression specifying the outcome (continuous)
and grouping variable (factor).  See lm() for details.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain &lsquo;NA&rsquo;s.  See lm() for details. </p>
</td></tr>
<tr><td><code id="plotmeans_+3A_bars">bars</code></td>
<td>
<p>a logical value indicating whether confidence interval
bars should be plotted. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_p">p</code></td>
<td>
<p>confidence level for error bars.  Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_minsd">minsd</code></td>
<td>
<p>minumum permitted value for the standard deviation within
each factor level.  Any standard deviation estimates smaller than
<code>minsd</code> will be replaced with <code>minsd</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_minbar">minbar</code></td>
<td>
<p>minumum allowed value for bar ends.  If specified,
values smaller than <code>minbar</code> will be replaced with
<code>minbar</code>. </p>
</td></tr>
<tr><td><code id="plotmeans_+3A_maxbar">maxbar</code></td>
<td>
<p>maximum allowed value for bar ends.  If specified,
values larger than <code>maxbar</code> will be replaced with
<code>maxbar</code>. </p>
</td></tr>
<tr><td><code id="plotmeans_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_mean.labels">mean.labels</code></td>
<td>
<p> either a logical value indicating whether the circles
representing the group means should be replaced with text giving the
actual mean values or a vector containing labels to use
instead. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_ci.label">ci.label</code></td>
<td>
<p> a logical value indicating whether text giving the
actual interval end values should be placed at the end of each
confidence interval bar. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_n.label">n.label</code></td>
<td>
<p> a logical value indicating whether text giving the number of
observations in each group should should be added to the plot. </p>
</td></tr>
<tr><td><code id="plotmeans_+3A_text.n.label">text.n.label</code></td>
<td>
<p>Prefix text for labeling observation counts.
Defaults to &quot;n=&quot;. </p>
</td></tr>
<tr><td><code id="plotmeans_+3A_digits">digits</code></td>
<td>
<p> number of significant digits to use when displaying
mean or confidince limit values.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_col">col</code></td>
<td>
<p> color of cicles marking group means.  Default is &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_barwidth">barwidth</code></td>
<td>
<p> linewidth of interval bars and end marks. Default is
1.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_barcol">barcol</code></td>
<td>
<p> color of interval bars and end marks.  Default is
&quot;blue&quot;.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_connect">connect</code></td>
<td>
<p> either a logical value indicating whether the means of
each group should be connected by a line, or a list of vectors giving the
index of bars that should be connected by a line. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_ccol">ccol</code></td>
<td>
<p> color of lines used to connect means. Defaults to the
same color as &quot;col&quot;.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_legends">legends</code></td>
<td>
<p> vector containing strings used to label groups along
the x axis. Defaults to group names.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_xaxt">xaxt</code></td>
<td>
<p>A character which specifies the axis type. Specifying &lsquo;&quot;n&quot;&rsquo;
causes an axis to be set up, but not plotted.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_use.t">use.t</code></td>
<td>
<p> a logical value indicating whether the t distribution
should be used to compute confidence intervals.  If <code>TRUE</code>, the
default, a t distribution will the correct number of degrees of
freedom for each group be used.  If <code>FALSE</code>, the a normal
distribution will be used.</p>
</td></tr>
<tr><td><code id="plotmeans_+3A_lwd">lwd</code></td>
<td>
<p>Width of connecting lines  </p>
</td></tr>
<tr><td><code id="plotmeans_+3A_...">...</code></td>
<td>
<p> optional plotting parameters. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCI">plotCI</a></code>, <code><a href="graphics.html#topic+boxplot">boxplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # library(gplots)
  # show comparison with boxplot
  data(state)
  plotmeans(state.area ~ state.region)

  # show some color and mean labels
  plotmeans(state.area ~ state.region,
             mean.labels=TRUE, digits=-3,
             col="red", connect=FALSE)

  # show how to specify which means should be connected
  plotmeans(state.area ~ state.region, connect=list(1:2, 3:4),
            ccol="red", pch=7 )

  # more complicated example showing how to show an interaction
  data(esoph)
  par(las=2,                        # use perpendicular axis labels
      mar=c(10.1,4.1,4.1,2.1),      # create enough space for long x labels
      mgp=c(8,1,0)                  # move x axis legend down to avoid overlap
      )
  plotmeans(ncases/ncontrols ~ interaction(agegp , alcgp, sep ="   "),
            connect=list(1:6,7:12,13:18,19:24),
            barwidth=2,
            col="dark green",
            data=esoph,
            xlab="Age Group and Alcohol Consumption",
            ylab="# Cases / # Controls",
            ylim = c(-.9,1.4),
            main=c("Fraction of Cases for by Age and Alcohol Consumption",
                   "Ile-et-Vilaine Esophageal Cancer Study")
            )
  abline(v=c(6.5, 12.5, 18.5), lty=2)

</code></pre>

<hr>
<h2 id='qqnorm.aov'> Makes a half or full normal plot for the effects from an aov model </h2><span id='topic+qqnorm.aov'></span>

<h3>Description</h3>

<p>Makes a half or full normal plot for the effects from a model
inheriting from
class <code>aov</code>. One can interactively label the points in the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aov'
qqnorm(y, full=FALSE, label=FALSE, omit=NULL,
           xlab=paste(if (full) "" else "Half", " Normal plot"), 
           ylab="Effects", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qqnorm.aov_+3A_y">y</code></td>
<td>
<p>A model object inheriting from <code>aov</code></p>
</td></tr>
<tr><td><code id="qqnorm.aov_+3A_full">full</code></td>
<td>
<p>Full or half normal plot (half is default) </p>
</td></tr>
<tr><td><code id="qqnorm.aov_+3A_label">label</code></td>
<td>
<p>If <code>TRUE</code>, function allows interactive
labelling of points in plot, using the mouse </p>
</td></tr>
<tr><td><code id="qqnorm.aov_+3A_omit">omit</code></td>
<td>
<p>Numeric or character vector of effects to omit,
the intercept is always omitted</p>
</td></tr>
<tr><td><code id="qqnorm.aov_+3A_xlab">xlab</code></td>
<td>
<p>Horizontal axix label </p>
</td></tr>
<tr><td><code id="qqnorm.aov_+3A_ylab">ylab</code></td>
<td>
<p>Vertical axis label </p>
</td></tr>
<tr><td><code id="qqnorm.aov_+3A_...">...</code></td>
<td>
<p>Further arguments to be given to the plot function </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a (half) normal plot of the effects from an AOV model. The
idea behind the plot is that most effects will be small or null, and
this effects can be used as a basis for estimation of the
experimental variance. This small effects will show up in the plot as
a straight line, other effects can be judged against this as a
background. Heavily used by Box, Hunter &amp; Hunter, which attributes
the idea to Daniel.
</p>


<h3>Value</h3>

<p>If <code>label=TRUE</code>, the vector of points identified, else nothing of
interest.
</p>


<h3>Author(s)</h3>

<p>Kjetil Halvorsen <a href="mailto:kjetil@entelnet.bo">kjetil@entelnet.bo</a></p>


<h3>References</h3>

<p>Box, Hunter and Hunter: Statistics for Experimenters. An Introduction
to Design, Data Analysis and Model Building. Wiley. <br />
Daniel, C (1976): Applications of Statistics to Industrial
Experimentation. Wiley. <br />
Daniel, C (1959): Use of half-normal plot in interpreting factorial
two-level experiments. <em>Technometrics.</em><b>1</b>, 149.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
data(npk)
npk.aov &lt;- aov(yield ~ block + N*P*K, npk)
qqnorm(npk.aov)

## interactive labeling of points.  Click mouse on points to show label.
if (dev.interactive()) qqnorm(npk.aov, omit=2:6, label=TRUE)
</code></pre>

<hr>
<h2 id='reorder.factor'>Reorder the Levels of a Factor</h2><span id='topic+reorder.factor'></span>

<h3>Description</h3>

<p>Reorder the levels of a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factor'
reorder(x, X, FUN, ..., order=is.ordered(x), new.order, sort=mixedsort)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorder.factor_+3A_x">x</code></td>
<td>
<p>factor</p>
</td></tr>
<tr><td><code id="reorder.factor_+3A_x">X</code></td>
<td>
<p>auxillary data vector</p>
</td></tr>
<tr><td><code id="reorder.factor_+3A_fun">FUN</code></td>
<td>
<p>function to be applied to subsets of <code>X</code> determined by
<code>x</code>, to determine factor order</p>
</td></tr>
<tr><td><code id="reorder.factor_+3A_...">...</code></td>
<td>
<p>optional parameters to <code>FUN</code></p>
</td></tr>
<tr><td><code id="reorder.factor_+3A_order">order</code></td>
<td>
<p>logical value indicating whether the returned
object should be an <code><a href="base.html#topic+ordered">ordered</a></code> factor</p>
</td></tr>
<tr><td><code id="reorder.factor_+3A_new.order">new.order</code></td>
<td>
<p>a vector of indexes or a vector of label names giving
the order of the new factor levels</p>
</td></tr>
<tr><td><code id="reorder.factor_+3A_sort">sort</code></td>
<td>
<p>function to use to sort the factor level names, used only
when <code>new.order</code> is missing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes the order of the levels of a factor. It can do
so via three different mechanisms, depending on whether, <code>X</code>
<em>and</em> <code>FUN</code>, <code>new.order</code> or <code>sort</code> are provided.
</p>
<p>If <code>X</code> <em>and</em> <code>Fun</code> are provided: The data in <code>X</code>
is grouped by the levels of <code>x</code> and <code>FUN</code> is applied.
The groups are then sorted by this value, and the resulting order is
used for the new factor level names.
</p>
<p>If <code>new.order</code> is a numeric vector, the new factor level names
are constructed by reordering the factor levels according to the
numeric values. If <code>new.order</code> is a chraccter vector,
<code>new.order</code> gives the list of new factor level names. In either
case levels omitted from <code>new.order</code> will become missing
(<code>NA</code>) values.
</p>
<p>If <code>sort</code> is provided (as it is by default): The new factor level
names are generated by calling the function specified by <code>sort</code>
to the existing factor level <em>names</em>. With <code>sort=mixedsort</code>
(the default) the factor levels are sorted so that combined numeric
and character strings are sorted in according to character rules on
the character sections (including ignoring case), and the numeric
rules for the numeric sections. See <code><a href="gtools.html#topic+mixedsort">mixedsort</a></code>
for details.
</p>


<h3>Value</h3>

<p> A new factor with reordered levels </p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>
and
<code><a href="stats.html#topic+reorder">reorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


   # Create a 4 level example factor
   trt &lt;- factor( sample( c("PLACEBO", "300 MG", "600 MG", "1200 MG"),
                  100, replace=TRUE ) )
   summary(trt)
   # Note that the levels are not in a meaningful order.

   # Change the order to something useful..
   # - default "mixedsort" ordering
   trt2 &lt;- reorder(trt)
   summary(trt2)
   # - using indexes:
   trt3 &lt;- reorder(trt, new.order=c(4, 2, 3, 1))
   summary(trt3)
   # - using label names:
   trt4 &lt;- reorder(trt, new.order=c("PLACEBO", "300 MG", "600 MG", "1200 MG"))
   summary(trt4)
   # - using frequency
   trt5 &lt;- reorder(trt, X=rnorm(100), FUN=mean)
   summary(trt5)

   # Drop out the '300 MG' level
   trt6 &lt;- reorder(trt, new.order=c("PLACEBO", "600 MG", "1200 MG"))
   summary(trt6)
</code></pre>

<hr>
<h2 id='residplot'>Undocumented functions</h2><span id='topic+residplot'></span>

<h3>Description</h3>

<p>These functions are undocumented.  Some are internal and not intended
for direct use.  Others simply haven't been documented yet.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residplot(model, formula, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residplot_+3A_model">model</code></td>
<td>
<p>Undocumented</p>
</td></tr>
<tr><td><code id="residplot_+3A_formula">formula</code></td>
<td>
<p>Undocumented</p>
</td></tr>
<tr><td><code id="residplot_+3A_...">...</code></td>
<td>
<p> arguments to be passed to <code>fun</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are undocumented.  Some are internal and not intended
for direct use.  Others simply haven't been documented yet.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>

<hr>
<h2 id='rich.colors'>Rich Color Palettes</h2><span id='topic+rich.colors'></span>

<h3>Description</h3>

<p>Create a vector of <code>n</code> colors that are perceptually equidistant
and in an order that is easy to interpret.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rich.colors(n, palette="temperature", alpha=1.0, rgb=FALSE, plot=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rich.colors_+3A_n">n</code></td>
<td>
<p>number of colors to generate.</p>
</td></tr>
<tr><td><code id="rich.colors_+3A_palette">palette</code></td>
<td>
<p>palette to use: <code>"temperature"</code> contains
blue-green-yellow-red, and <code>"blues"</code> contains
black-blue-white.</p>
</td></tr>
<tr><td><code id="rich.colors_+3A_alpha">alpha</code></td>
<td>
<p>alpha transparency, from 0 (fully transparent)  to 1
(opaque).</p>
</td></tr> 
<tr><td><code id="rich.colors_+3A_rgb">rgb</code></td>
<td>
<p>if <code>TRUE</code> then a matrix of RGBA values is included as an
attribute.</p>
</td></tr>
<tr><td><code id="rich.colors_+3A_plot">plot</code></td>
<td>
<p>whether to plot a descriptive color diagram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of color codes.</p>


<h3>Author(s)</h3>

<p>Arni Magnusson.</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+rgb">rgb</a></code>, <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, <code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- abs(matrix(1:120+rnorm(120), nrow=15, ncol=8))
opar &lt;- par(bg="gray", mfrow=c(1,2))
matplot(m, type="l", lty=1, lwd=3, col=rich.colors(8))
matplot(m, type="l", lty=1, lwd=3, col=rich.colors(8,"blues"))
par(opar)

barplot(rep(1,100), col=rich.colors(100), space=0, border=0, axes=FALSE)
barplot(rep(1,20), col=rich.colors(40)[11:30]) # choose subset

plot(m, rev(m), ylim=c(120,0), pch=16, cex=2,
     col=rich.colors(200,"blues",alpha=0.6)[1:120]) # semitransparent

rich.colors(100, plot=TRUE)  # describe rgb recipe

par(mfrow=c(2,2))
barplot(m, col=heat.colors(15), main="\nheat.colors")
barplot(m, col=1:15, main="\ndefault palette")
barplot(m, col=rich.colors(15), main="\nrich.colors")
barplot(m, col=rainbow(15), main="\nrainbow")
par(opar)
</code></pre>

<hr>
<h2 id='rtPCR'>Teratogenesis rtPCR data</h2><span id='topic+rtPCR'></span>

<h3>Description</h3>

<p>rtPCR data for experiments investigating a variety of markers for
characterizing teratogenicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rtPCR)</code></pre>


<h3>Format</h3>

<p>A data frame with 1672 observations on the following 21 variables.
</p>

<dl>
<dt>PlateID</dt><dd><p>a factor with levels <code>A0027002</code> through
<code>A0054019</code></p>
</dd>
<dt>Test.Substance</dt><dd><p>a factor with levels <code>Compound A</code> through
<code>Compound H</code></p>
</dd>
<dt>Teratogenicity.in.vivo</dt><dd><p>a factor with levels <code>Non</code>
<code>Strong</code> <code>Weak / Moderate</code></p>
</dd>
<dt>Sample</dt><dd><p>a factor with levels <code>Sample 1</code> - <code>Sample 152</code></p>
</dd>
<dt>Rep..</dt><dd><p>a factor with levels <code>Rep 1</code> - <code>Rep 21</code></p>
</dd>
<dt>Label</dt><dd><p>a factor with levels <code>Ctrl</code>, <code>Neg. Ctrl</code>
<code>P1</code> - <code>P9</code>, <code>No Vehicle Ctrl</code>, and <code>Pos. Ctrl</code></p>
</dd>
<dt>Conc..ug.ml.</dt><dd><p>a numeric vector</p>
</dd>
<dt>Detector</dt><dd><p>a factor with levels <code>ProbeType 1</code> -
<code>ProbeType 17</code></p>
</dd>
<dt>Avg.delta.Ct</dt><dd><p>a numeric vector</p>
</dd>
<dt>delta.Ct.SD</dt><dd><p>a numeric vector</p>
</dd>
<dt>delta.delta.Ct</dt><dd><p>a numeric vector</p>
</dd>
<dt>RQ</dt><dd><p>a numeric vector</p>
</dd>
<dt>X..RQ</dt><dd><p>a numeric vector</p>
</dd>
<dt>X100..Custom..</dt><dd><p>a numeric vector</p>
</dd>
<dt>X100...Custom..</dt><dd><p>a numeric vector</p>
</dd>
<dt>Custom..</dt><dd><p>a numeric vector</p>
</dd>
<dt>Custom...1</dt><dd><p>a numeric vector</p>
</dd>
<dt>RQ.Min</dt><dd><p>a numeric vector</p>
</dd>
<dt>RQ.Max</dt><dd><p>a numeric vector</p>
</dd>
<dt>Threshold</dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>TBA
</p>


<h3>Source</h3>

<p>Anonymized data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rtPCR)

# same scale
overplot( RQ ~ Conc..ug.ml. | Test.Substance,
         data=rtPCR,
         subset=Detector=="ProbeType 7" &amp; Conc..ug.ml. &gt; 0,
         same.scale=TRUE,
         log="xy",
         f=3/4,
         main="Detector=ProbeType 7",
         xlab="Concentration (ug/ml)",
         ylab="Relative Gene Quantification"
         )

# different scales, but force lower limit to 0.01 
overplot( RQ ~ Conc..ug.ml. | Test.Substance,
         data=rtPCR,
         subset=Detector=="ProbeType 7" &amp; Conc..ug.ml. &gt; 0,
         log="xy",
         f=3/4,
         main="Detector=ProbeType 7",
         xlab="Concentration (ug/ml)",
         ylab="Relative Gene Quantification",
         min.y=0.01
         )
</code></pre>

<hr>
<h2 id='sinkplot'>Send textual R output to a graphics device</h2><span id='topic+sinkplot'></span>

<h3>Description</h3>

<p>Divert R's standard text output to a graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinkplot(operation = c("start", "plot", "cancel"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sinkplot_+3A_operation">operation</code></td>
<td>
<p>See below</p>
</td></tr>
<tr><td><code id="sinkplot_+3A_...">...</code></td>
<td>
<p>Plot arguments. (Ignored unless <code>operation</code>=&quot;plot&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the printed output of R commands to be captured
and displayed on a graphics device.
</p>
<p>The capture process is started by calling
<code>sinkplot("start")</code>. Now R commands can be executed and all
printed output (except errors) will be captured.  When the desired
text has been captured <code>sinkplot("plot")</code> can be called to
actually display the output.  <code>sinkplot("cancel")</code> can be used to
abort the output capture without plotting.
</p>
<p>The current implementation does not allow <code>sinkplot</code> to be nested.
</p>


<h3>Value</h3>

<p>Invisibly returns a character vector containing one element for each
line of the captured output.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>  </p>


<h3>References</h3>

<p>Functionality requested by Kevin Wright
<a href="mailto:kwright@eskimo.com">kwright@eskimo.com</a> in the R-devel newlist posting
<a href="https://stat.ethz.ch/pipermail/r-devel/2004-January/028483.html">https://stat.ethz.ch/pipermail/r-devel/2004-January/028483.html</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="utils.html#topic+capture.output">capture.output</a></code>, <code><a href="#topic+textplot">textplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   set.seed(12456)
   x &lt;- factor(sample( LETTERS[1:5], 50, replace=TRUE))
   y &lt;- rnorm(50, mean=as.numeric(x), sd=1)

   ## construct a figure showing a box plot of the data, followed by an
   ## analysis of variance table for the data
   layout(cbind(1:2), heights=c(2,1))

   boxplot(y~x, col="darkgreen")

   sinkplot()
   anova(lm(y~x))
   sinkplot("plot",col="darkgreen")
</code></pre>

<hr>
<h2 id='space'>Space points in an x-y plot so they don't overlap.</h2><span id='topic+space'></span>

<h3>Description</h3>

<p>Space points in an x-y plot so they don't overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space(x, y, s=1/50, na.rm=TRUE, direction="x")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="space_+3A_x">x</code></td>
<td>
<p>numeric vector of x coordonates.</p>
</td></tr>
<tr><td><code id="space_+3A_y">y</code></td>
<td>
<p>numeric vector of x coordonates.</p>
</td></tr>
<tr><td><code id="space_+3A_s">s</code></td>
<td>
<p>either a single numeric value or 2 element vector specifying
the minimum distance between points in the x and y dimensions as a
fraction of the x and y range.  Defaults to 1/50.</p>
</td></tr>
<tr><td><code id="space_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether pairs where one or both
elements are missing should be removed.  Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="space_+3A_direction">direction</code></td>
<td>
<p>&quot;x&quot; or &quot;y&quot;, indicating which direction points should
be moved to accomplish spacine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an x-y plot where at least one variable has discrete levels several
points may be plotted at or very near the same coordonates.
This makes it difficult to guage the number of points in a specific
region.  A common method of resolving this problem is to 'jitter' the
points by adding random noise.
</p>
<p>This function takes a different approach to the same problem.  
</p>
<p>When there are two or more points with the same (x,y) value (or
within x+-s[1] and x+-s[2]), it spaces these out in the x direction
so that the points are separated by at least distance s.
</p>
<p>Another method for dealing with overploting is available in the
<code><a href="graphics.html#topic+sunflowerplot">sunflowerplot</a></code> function.
</p>


<h3>Value</h3>

<p>list with two components
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>(modified) x location for each input point</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y location of each input point</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+jitter">jitter</a></code>, <code><a href="graphics.html#topic+sunflowerplot">sunflowerplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- rep(1:5, 10)
   y &lt;- round(rnorm(length(x),x))

   prepar &lt;- par("mfrow")
   par(mfrow=c(1,3))

   # standard x-y plot: noverlapping points are hidden
   plot(x,y)
   title("Standard Plot") 

   # 'spaced' plot: overlapping points are spread out and visible
   plot(space(x,y))
   title("Plot with 'space'")


   # 'spaced' plot: overlapping points are spread out along y and visible
   plot(space(x,y, direction='y'))
   title("Plot with 'space', direction='y' ")


   # 'sunflower' plot, another approach, overlapping points are
   # indicated via petals
   sunflowerplot(x,y)
   title("Sunflower Plot")

   

   par(mfrow=prepar)
</code></pre>

<hr>
<h2 id='textplot'>Display text information in a graphics plot.</h2><span id='topic+textplot'></span><span id='topic+textplot.default'></span><span id='topic+textplot.character'></span><span id='topic+textplot.matrix'></span><span id='topic+textplot.data.frame'></span>

<h3>Description</h3>

<p>This function displays text output in a graphics window.  It is the
equivalent of 'print' except that the output is displayed as a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textplot(object, halign="center", valign="center", cex, ...)
## Default S3 method:
textplot(object, halign=c("center","left","right"),
         valign=c("center", "top", "bottom"), cex, ... )
## S3 method for class 'character'
textplot(object, halign = c("center", "left", "right"),
         valign = c("center", "top", "bottom"), cex, fixed.width=TRUE,
         cspace=1, lspace=1, mar=c(0, 0, 3, 0) + 0.1,
         tab.width = 8, ...)
## S3 method for class 'data.frame'
textplot(object, halign = c("center", "left", "right"),
         valign = c("center", "top", "bottom"), cex, ...)
## S3 method for class 'matrix'
textplot(object, halign = c("center", "left", "right"),
         valign = c("center", "top", "bottom"), cex, cmar = 2,
         rmar = 0.5, show.rownames = TRUE, show.colnames = TRUE,
         hadj = 1, vadj = 1, mar = c(1, 1, 4, 1) + 0.1,
         col.data = par("col"), col.rownames = par("col"), 
         col.colnames = par("col"), ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="textplot_+3A_object">object</code></td>
<td>
<p>Object to be displayed.</p>
</td></tr>
<tr><td><code id="textplot_+3A_halign">halign</code></td>
<td>
<p>Alignment in the x direction, one of &quot;center&quot;, &quot;left&quot;,
or &quot;right&quot;. </p>
</td></tr>
<tr><td><code id="textplot_+3A_valign">valign</code></td>
<td>
<p>Alignment in the y direction, one of &quot;center&quot;, &quot;top&quot; ,
or &quot;bottom&quot;</p>
</td></tr>
<tr><td><code id="textplot_+3A_cex">cex</code></td>
<td>
<p>Character size, see <code><a href="graphics.html#topic+par">par</a></code> for details. If
unset, the code will attempt to use the largest value which allows
the entire object to be displayed.</p>
</td></tr>
<tr><td><code id="textplot_+3A_fixed.width">fixed.width</code></td>
<td>
<p>Logical value indicating whether to emulate a
fixed-width font by aligning characters in each row of text. This is
usually necessary for text-formatted tables display properly.
Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="textplot_+3A_cspace">cspace</code></td>
<td>
<p>Space between characters as a
multiple of the width of the letter 'W'. This only applies when 
<code>fixed.width==TRUE</code>. </p>
</td></tr>
<tr><td><code id="textplot_+3A_lspace">lspace</code></td>
<td>
<p>Line spacing. This only applies when
<code>fixed.width==TRUE</code>.</p>
</td></tr>
<tr><td><code id="textplot_+3A_mar">mar</code></td>
<td>
<p>Figure margins, see the documentation for <code>par</code>.</p>
</td></tr>
<tr><td><code id="textplot_+3A_rmar">rmar</code>, <code id="textplot_+3A_cmar">cmar</code></td>
<td>
<p>Space between rows or columns, in
fractions of the size of the letter 'M'.</p>
</td></tr>
<tr><td><code id="textplot_+3A_show.rownames">show.rownames</code>, <code id="textplot_+3A_show.colnames">show.colnames</code></td>
<td>
<p>Logical value indicating whether row or
column names will be displayed.</p>
</td></tr>
<tr><td><code id="textplot_+3A_hadj">hadj</code>, <code id="textplot_+3A_vadj">vadj</code></td>
<td>
<p>Vertical and horizontal location of elements within
matrix cells.  These have the same meaning as the <code>adj</code> graphics
paramter (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="textplot_+3A_col.data">col.data</code></td>
<td>
<p>Colors for data elements.  If a single value is
provided, all data elements will be the same color.  If a matrix
matching the dimensions of the data is provided, each data element
will receive the specified color.</p>
</td></tr>
<tr><td><code id="textplot_+3A_col.rownames">col.rownames</code>, <code id="textplot_+3A_col.colnames">col.colnames</code></td>
<td>
<p>Colors for row names and column
names, respectively.  Either may be specified as a scalar or a
vector of appropriate length.</p>
</td></tr>
<tr><td><code id="textplot_+3A_tab.width">tab.width</code></td>
<td>
<p>Width of a single tab stop, in characters</p>
</td></tr>
<tr><td><code id="textplot_+3A_...">...</code></td>
<td>
<p> Optional arguments passed to the text plotting command
or specialied object methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A new plot is created and the object is displayed
using the largest font that will fit on in the plotting region.  The
<code>halign</code> and <code>valign</code> parameters can be used to control the
location of the string within the plotting region.
</p>
<p>For matrixes and vectors a specialized textplot function is available,
which plots each of the cells individually, with column widths set
according to the sizes of the column elements.  If present, row and
column labels will be displayed in a bold font.  
</p>


<h3>Value</h3>

<p>The character scaling factor (<code>cex</code>) used.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+text">text</a></code>, 
<code><a href="utils.html#topic+capture.output">capture.output</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### simple examples
# show R version information
textplot(version)

# show the alphabet as a single string
textplot( paste(letters[1:26], collapse=" ") )

# show the alphabet as a matrix
textplot( matrix(letters[1:26], ncol=2))

### Make a nice 4 way display with two plots and two text summaries

data(iris)
par(mfrow=c(2,2))
plot( Sepal.Length ~ Species, data=iris, border="blue", col="cyan",
      main="Boxplot of Sepal Length by Species" )
plotmeans( Sepal.Length ~ Species, data=iris, barwidth=2, connect=FALSE,
           main="Means and 95% Confidence Intervals\nof Sepal Length by Species")

info &lt;- sapply( split(iris$Sepal.Length, iris$Species),
                function(x) round(c(Mean=mean(x), SD=sd(x), N=nrow(x)),2) )

textplot( info, valign="top"  )
title("Sepal Length by Species")

reg &lt;- lm( Sepal.Length ~ Species, data=iris )
textplot( capture.output(summary(reg)), valign="top")
title("Regression of Sepal Length by Species")

par(mfrow=c(1,1))

### Show how to control text color
cols &lt;- c("red", "green", "magenta", "forestgreen")
mat &lt;- cbind(name=cols, t(col2rgb(cols)), hex=col2hex(cols))

textplot(mat,
         col.data=matrix(cols, nrow=length(cols), byrow=FALSE, ncol=5),
         )

### Show how to manually tune the character size
data(iris)
reg &lt;- lm( Sepal.Length ~ Species, data=iris )
text &lt;- capture.output(summary(reg))

# do the plot and capture the character size used
textplot(text, valign="top")

# see what size was used
cex

# now redo the plot at 80% size
textplot( text, valign="top", cex=cex*0.80)




## End(Not run)
</code></pre>

<hr>
<h2 id='venn'>Plot a Venn diagram</h2><span id='topic+venn'></span><span id='topic+plot.venn'></span>

<h3>Description</h3>

<p>Plot a Venn diagrams for up to 5 sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venn(data, universe=NA, small=0.7, showSetLogicLabel=FALSE,
     simplify=FALSE, show.plot=TRUE, intersections=TRUE, names,
     ...)

## S3 method for class 'venn'
plot(x, y, ..., small=0.7, showSetLogicLabel=FALSE,
     simplify=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="venn_+3A_data">data</code>, <code id="venn_+3A_x">x</code></td>
<td>
<p>Either a list list containing vectors of names or indices
of group intersections, or a data frame containing boolean indicators of
group intersectionship (see below)</p>
</td></tr>
<tr><td><code id="venn_+3A_universe">universe</code></td>
<td>
<p>Subset of valid name/index elements. Values  ignore values
in <code>data</code> not in this list will be ignored. Use <code>NA</code> to
use all elements of <code>data</code> (the default).</p>
</td></tr>
<tr><td><code id="venn_+3A_small">small</code></td>
<td>
<p>Character scaling of the smallest group counts</p>
</td></tr>
<tr><td><code id="venn_+3A_showsetlogiclabel">showSetLogicLabel</code></td>
<td>
<p>Logical flag indicating whether the internal
group label should be displayed</p>
</td></tr>
<tr><td><code id="venn_+3A_simplify">simplify</code></td>
<td>
<p>Logical flag indicating whether unobserved groups
should be omitted.</p>
</td></tr>
<tr><td><code id="venn_+3A_show.plot">show.plot</code></td>
<td>
<p>Logical flag indicating whether the plot should be
displayed.  If false, simply returns the group count matrix.</p>
</td></tr>
<tr><td><code id="venn_+3A_intersections">intersections</code></td>
<td>
<p>Logical flag indicating
if the returned object should have the attribute
&quot;individuals.in.intersections&quot; featuring for every set a list of
individuals that are assigned to it.</p>
</td></tr>
<tr><td><code id="venn_+3A_y">y</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="venn_+3A_...">...</code></td>
<td>
<p>Optional graphical parameters.</p>
</td></tr>
<tr><td><code id="venn_+3A_names">names</code></td>
<td>
<p>Optional vector of group names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> should be either a named list of vectors containing
character string names (&quot;GeneAABBB&quot;, &quot;GeneBBBCY&quot;, .., &quot;GeneXXZZ&quot;) or
indexes of group intersections (1, 2, .., N), or a data frame containing
indicator variables (TRUE, FALSE, TRUE, ..) for group intersectionship.
Group names will be taken from the component list element or column
names.
</p>


<h3>Value</h3>

<p>Invisibly returns an object of class &quot;venn&quot;, containing:
</p>

<ul>
<li><p> A matrix of all possible sets of groups, and the observed count
of items belonging to each The fist column contains observed
counts, subsequent columns contain 0-1 indicators of group
intersectionship.
</p>
</li>
<li><p> If <code>intersections=TRUE</code>, the attribute <code>intersections</code>
will be a list of vectors containing the names of the elements
belonging to each subset.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Steffen Moeller, with cleanup and packaging by Gregory R. Warnes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## Example using a list of item names belonging to the
## specified group.
##

## construct some fake gene names..
oneName &lt;- function() paste(sample(LETTERS,5,replace=TRUE),collapse="")
geneNames &lt;- replicate(1000, oneName())

##
GroupA &lt;- sample(geneNames, 400, replace=FALSE)
GroupB &lt;- sample(geneNames, 750, replace=FALSE)
GroupC &lt;- sample(geneNames, 250, replace=FALSE)
GroupD &lt;- sample(geneNames, 300, replace=FALSE)
input  &lt;-list(GroupA,GroupB,GroupC,GroupD)
input

tmp &lt;- venn(input)
attr(tmp, "intersections")

##
## Example using a list of item indexes belonging to the
## specified group.
##
GroupA.i &lt;- which(geneNames %in% GroupA)
GroupB.i &lt;- which(geneNames %in% GroupB)
GroupC.i &lt;- which(geneNames %in% GroupC)
GroupD.i &lt;- which(geneNames %in% GroupD)
input.i  &lt;-list(A=GroupA.i,B=GroupB.i,C=GroupC.i,D=GroupD.i)
input.i

venn(input.i)

##
## Example using a data frame of indicator ('f'lag) columns
##
GroupA.f &lt;- geneNames %in% GroupA
GroupB.f &lt;- geneNames %in% GroupB
GroupC.f &lt;- geneNames %in% GroupC
GroupD.f &lt;- geneNames %in% GroupD
input.df &lt;- data.frame(A=GroupA.f,B=GroupB.f,C=GroupC.f,D=GroupD.f)
head(input.df)
venn(input.df)

## smaller set to create empty groupings
small &lt;- input.df[1:20,]

venn(small, simplify=FALSE) # with empty groupings
venn(small, simplify=TRUE)  # without empty groupings

## Capture group counts, but don't plot
tmp &lt;- venn(input, show.plot=FALSE)
tmp

## Show internal binary group labels
venn(input, showSetLogicLabel=TRUE)

## Limit  universe
tmp &lt;- venn(input, universe=geneNames[1:100])
tmp

##
## Example to determine which elements are in A and B but not in
## C and D using the 'intersections' attribute.
##
tmp &lt;- venn(input, intersection=TRUE)
isect &lt;- attr(tmp, "intersection")

# Look at all of the subsets
str(isect)

# Extract and combine the subsets of interest..
AandB &lt;- unique(c(isect$A, isect$B, isect$'A:B'))

# and look at the results
str(AandB)

##
## The full set of elements of each intersection is provided in the
## "interesections" attribute.
##
a&lt;-venn(list(1:5,3:8), show.plot=FALSE)
intersections&lt;-attr(a,"intersections")
print(intersections)
# $A
# [1] "1" "2"
#
# $B
# [1] "6" "7" "8"
#
# $`A:B`
# [1] "3" "4" "5"
</code></pre>

<hr>
<h2 id='wapply'>Compute the Value of a Function Over a Local Region Of An X-Y Plot</h2><span id='topic+wapply'></span>

<h3>Description</h3>

<p>This function applies the specified function to the sets of y values
that are defined by overlapping &quot;windows&quot; in the x-dimension. For
example, setting <code>fun=mean</code> returns local means, while setting
<code>fun=function(x) sqrt(var(x))</code> returns local estimates of
the standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wapply(x, y, fun=mean, method="range", width, n=50, drop.na=TRUE,
       pts, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wapply_+3A_x">x</code></td>
<td>
<p> vector of x values for (x,y) pairs </p>
</td></tr>
<tr><td><code id="wapply_+3A_y">y</code></td>
<td>
<p> vector of y values for (x,y) pairs </p>
</td></tr>
<tr><td><code id="wapply_+3A_fun">fun</code></td>
<td>
<p> function to be applied </p>
</td></tr>
<tr><td><code id="wapply_+3A_method">method</code></td>
<td>
<p> method of defining an x-neighborhood.  One of
&quot;width&quot;,&quot;nobs&quot;,&quot;range&quot;, or &quot;fraction&quot;.  See details.</p>
</td></tr>
<tr><td><code id="wapply_+3A_width">width</code></td>
<td>
<p> width of an x-neighborhood. See details. </p>
</td></tr>
<tr><td><code id="wapply_+3A_n">n</code></td>
<td>
<p> Number of equally spaced points at which to compute local
estimates. See details.</p>
</td></tr>
<tr><td><code id="wapply_+3A_drop.na">drop.na</code></td>
<td>
<p> should points which result in missing values <code>NA</code>
be omitted from the return value. Defaults to true. </p>
</td></tr>
<tr><td><code id="wapply_+3A_pts">pts</code></td>
<td>
 <p><code>x</code> locations at which to compute the local mean when
using the &quot;width&quot; or &quot;range&quot; methods. Ignored otherwise.</p>
</td></tr>
<tr><td><code id="wapply_+3A_...">...</code></td>
<td>
<p> arguments to be passed to <code>fun</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two basic techniques are available for determining what points fall
within the same x-neighborhood.  The first technique uses a window with
a fixed width in the x-dimension and is is selected by
setting <code>method="width"</code> or <code>method="range"</code>.  For
<code>method="width"</code> the <code>width</code> argument is an absolute
distance in the x-dimension.  For <code>method="range"</code>, the width is
expressed as a fraction of the x-range.  In both cases, <code>pts</code>
specifies the points at which evaluation of <code>fun</code> occurs.  When
<code>pts</code> is omitted, <code>n</code> x values equally spaced along the x
range are used.
</p>
<p>The second technique uses windows containing  k neighboring points.  The
(x,y) pairs are sorted by the x-values and the nearest k/2 points with
higher x values and the k/2 nearest points with lower x values are
included in the window.  When <code>method="nobs"</code>, k equals
<code>width</code> (actually 2*floor(<code>width</code>/2) ).  When
<code>method="fraction"</code>, <code>width</code> specifies what fraction of the
total number of points should be included. The actual number of points
included in each window will be floor(n*frac/2)*2.  Regardless of the
value of <code>pts</code>, the function <code>fun</code> will be evaluated at all
x locations.
</p>


<h3>Value</h3>

<p>Returns a list with components 
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>x location'</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Result of applying <code>fun</code> to the window about each x location</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#show local mean and inner 2-sd interval to help diagnose changing mean
#or variance structure
x &lt;- 1:1000
y &lt;- rnorm(1000, mean=1, sd=1 + x/1000 )

plot(x,y)
lines(wapply(x,y,mean),col="red")

CL &lt;- function(x,sd) mean(x)+sd*sqrt(var(x))

lines(wapply(x,y,CL,sd= 1),col="blue") 
lines(wapply(x,y,CL,sd=-1),col="blue") 
lines(wapply(x,y,CL,sd= 2),col="green")
lines(wapply(x,y,CL,sd=-2),col="green")

#show local mean and inner 2-sd interval to help diagnose changing mean
#or variance structure
x &lt;- 1:1000
y &lt;- rnorm(1000, mean=x/1000, sd=1)

plot(x,y)
lines(wapply(x,y,mean),col="red")

CL &lt;- function(x,sd) mean(x)+sd*sqrt(var(x))

lines(wapply(x,y,CL,sd= 1,method="fraction",width=1/20),col="blue")
lines(wapply(x,y,CL,sd=-1,method="fraction",width=1/20),col="blue")
lines(wapply(x,y,CL,sd= 2,method="nobs",width=250),col="green")
lines(wapply(x,y,CL,sd=-2,method="nobs",width=250),col="green")


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
