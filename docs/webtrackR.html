<!DOCTYPE html><html><head><title>Help for package webtrackR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {webtrackR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_duration'><p>Add time spent on a visit in seconds</p></a></li>
<li><a href='#add_next_visit'><p>Add the next visit as a new column</p></a></li>
<li><a href='#add_panelist_data'><p>Add panelist features to tracking data</p></a></li>
<li><a href='#add_previous_visit'><p>Add the previous visit as a new column</p></a></li>
<li><a href='#add_referral'><p>Add social media referrals as a new column</p></a></li>
<li><a href='#add_session'><p>Add a session variable</p></a></li>
<li><a href='#add_title'><p>Download and add the &quot;title&quot; of a URL</p></a></li>
<li><a href='#audience_incidence'><p>Create incidence matrix for two-mode networks including audiences</p></a></li>
<li><a href='#audience_network'><p>Create audience networks</p></a></li>
<li><a href='#bakshy'><p>Bakshy Top500</p>
Ideological alignment of 500 domains based on facebook data</a></li>
<li><a href='#classify_visits'><p>Classify visits by matching to a list of classes</p></a></li>
<li><a href='#create_urldummy'><p>Create an urldummy variable from a data.table object</p></a></li>
<li><a href='#deduplicate'><p>Deduplicate visits</p></a></li>
<li><a href='#domain_list'><p>Domain list</p>
classification of domains into news,portals, search, and social media</a></li>
<li><a href='#drop_query'><p>Drop the query and fragment from URL</p></a></li>
<li><a href='#extract_domain'><p>Extract the domain from URL</p></a></li>
<li><a href='#extract_host'><p>Extract the host from URL</p></a></li>
<li><a href='#extract_path'><p>Extract the path from URL</p></a></li>
<li><a href='#isolation_index'><p>Isolation Index</p></a></li>
<li><a href='#news_types'><p>News Types</p></a></li>
<li><a href='#print.wt_dt'><p>Print web tracking data</p></a></li>
<li><a href='#sum_activity'><p>Summarize activity per person</p></a></li>
<li><a href='#sum_durations'><p>Summarize visit duration by person</p></a></li>
<li><a href='#sum_visits'><p>Summarize number of visits by person</p></a></li>
<li><a href='#summary.wt_dt'><p>Summary function for web tracking data</p></a></li>
<li><a href='#testdt_survey_l'><p>Test survey</p></a></li>
<li><a href='#testdt_survey_w'><p>Test survey</p></a></li>
<li><a href='#testdt_tracking'><p>Test data</p></a></li>
<li><a href='#vars_exist'><p>Check if columns are present</p></a></li>
<li><a href='#webtrackR-package'><p>webtrackR: Preprocessing and Analyzing Web Tracking Data</p></a></li>
<li><a href='#wt_dt'><p>An S3 class, based on data.table, to store web tracking data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Preprocessing and Analyzing Web Tracking Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Data structures and methods to work with web tracking data. The functions cover data preprocessing steps, enriching web tracking data with external information and methods for the analysis of digital behavior as used in several academic papers (e.g., Clemm von Hohenberg et al., 2023 &lt;<a href="https://doi.org/10.17605%2FOSF.IO%2FM3U9P">doi:10.17605/OSF.IO/M3U9P</a>&gt;; Stier et al., 2022 &lt;<a href="https://doi.org/10.1017%2FS0003055421001222">doi:10.1017/S0003055421001222</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/schochastics/webtrackR">https://github.com/schochastics/webtrackR</a>,
<a href="https://schochastics.github.io/webtrackR/">https://schochastics.github.io/webtrackR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/schochastics/webtrackR/issues">https://github.com/schochastics/webtrackR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, tibble, igraph, urltools, utils, rvest, httr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>backbone, stats, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-30 18:46:08 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Schoch <a href="https://orcid.org/0000-0003-2952-4812"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Bernhard Clemm von Hohenberg
    <a href="https://orcid.org/0000-0002-6976-9745"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Frank Mangold <a href="https://orcid.org/0000-0002-9776-3113"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sebastian Stier <a href="https://orcid.org/0000-0002-1217-5778"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Schoch &lt;david@schochastics.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-31 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_duration'>Add time spent on a visit in seconds</h2><span id='topic+add_duration'></span>

<h3>Description</h3>

<p><code>add_duration()</code> approximates the time spent on a visit based on the difference
between two consecutive timestamps, replacing differences exceeding <code>cutoff</code> with
the value defined in <code>replace_by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_duration(
  wt,
  cutoff = 300,
  replace_by = NA,
  last_replace_by = NA,
  device_switch_na = FALSE,
  device_var = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_duration_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="add_duration_+3A_cutoff">cutoff</code></td>
<td>
<p>numeric (seconds). If duration is greater than this value,
it is reset to the value defined by <code>replace_by</code>. Defaults to 300 seconds.</p>
</td></tr>
<tr><td><code id="add_duration_+3A_replace_by">replace_by</code></td>
<td>
<p>numeric. Determines whether differences greater than
the cutoff are set to <code>NA</code>, or some value. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="add_duration_+3A_last_replace_by">last_replace_by</code></td>
<td>
<p>numeric. Determines whether the last visit
for an individual is set to <code>NA</code>, or some value. Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="add_duration_+3A_device_switch_na">device_switch_na</code></td>
<td>
<p>boolean. Relevant only when data was collected
from multiple devices. When visits are ordered by timestamp sequence,
two consecutive visits can come from different devices, which makes the
timestamp difference less likely to be the true duration. It may be
preferable to set the duration of the visit to <code>NA</code> (<code>TRUE</code>) rather than
the difference to the next timestamp (<code>FALSE</code>). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add_duration_+3A_device_var">device_var</code></td>
<td>
<p>character. Column indicating device.
Required if 'device_switch_na' set to <code>TRUE</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table (ordered by panelist_id and timestamp) with
the same columns as wt and a new column called <code>duration</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
wt &lt;- add_duration(wt)
# Defining cutoff at 10 minutes, replacing those exceeding cutoff to 5 minutes,
# and setting duration before device switch to `NA`:
wt &lt;- add_duration(wt,
  cutoff = 600, replace_by = 300,
  device_switch_na = TRUE, device_var = "device"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_next_visit'>Add the next visit as a new column</h2><span id='topic+add_next_visit'></span>

<h3>Description</h3>

<p><code>add_next_visit()</code> adds the subsequent visit, as determined by order of
timestamps as a new column. The next visit can be added as either the full URL,
the extracted host or the extracted domain, depending on <code>level</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_next_visit(wt, level = "url")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_next_visit_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="add_next_visit_+3A_level">level</code></td>
<td>
<p>character. Either <code>"url"</code>, <code>"host"</code> or <code>"domain"</code>. Defaults to <code>"url"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt and
a new column called <code>url_next</code>,<code>host_next</code> or <code>domain_next</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# Adding next full URL as new column
wt &lt;- add_next_visit(wt, level = "url")
# Adding next host as new column
wt &lt;- add_next_visit(wt, level = "host")
# Adding next domain as new column
wt &lt;- add_next_visit(wt, level = "domain")

## End(Not run)
</code></pre>

<hr>
<h2 id='add_panelist_data'>Add panelist features to tracking data</h2><span id='topic+add_panelist_data'></span>

<h3>Description</h3>

<p><code>add_panelist_data()</code> adds information about panelists (e.g., from a survey)
to the tracking data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_panelist_data(wt, data, cols = NULL, join_on = "panelist_id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_panelist_data_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="add_panelist_data_+3A_data">data</code></td>
<td>
<p>a data.table (or object that can be converted to data.table)
which contains columns about panelists</p>
</td></tr>
<tr><td><code id="add_panelist_data_+3A_cols">cols</code></td>
<td>
<p>character vector of columns to add. If <code>NULL</code>, all columns are added.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="add_panelist_data_+3A_join_on">join_on</code></td>
<td>
<p>which columns to join on. Defaults to <code>"panelist_id"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack object with the same columns and the columns from <code>data</code>
specified in <code>cols</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
data("testdt_survey_w")
wt &lt;- as.wt_dt(testdt_tracking)
# add survey test data
add_panelist_data(wt, testdt_survey_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_previous_visit'>Add the previous visit as a new column</h2><span id='topic+add_previous_visit'></span>

<h3>Description</h3>

<p><code>add_previous_visit()</code> adds the previous visit, as determined by order of
timestamps as a new column The previous visit can be added as either the full URL,
the extracted host or the extracted domain, depending on <code>level</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_previous_visit(wt, level = "url")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_previous_visit_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="add_previous_visit_+3A_level">level</code></td>
<td>
<p>character. Either <code>"url"</code>, <code>"host"</code> or <code>"domain"</code>. Defaults to <code>"url"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt and
a new column called <code>url_previous</code>,<code>host_previous</code> or <code>domain_previous.</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# Adding previous full URL as new column
wt &lt;- add_previous_visit(wt, level = "url")
# Adding previous host as new column
wt &lt;- add_previous_visit(wt, level = "host")
# Adding previous domain as new column
wt &lt;- add_previous_visit(wt, level = "domain")

## End(Not run)
</code></pre>

<hr>
<h2 id='add_referral'>Add social media referrals as a new column</h2><span id='topic+add_referral'></span>

<h3>Description</h3>

<p>Identifies whether a visit was referred to from social media and
adds it as a new column. See details for method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_referral(wt, platform_domains, patterns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_referral_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="add_referral_+3A_platform_domains">platform_domains</code></td>
<td>
<p>character. A vector of platform domains for which
referrers should be identified. Order and length must correspondent to <code>patterns</code> argument</p>
</td></tr>
<tr><td><code id="add_referral_+3A_patterns">patterns</code></td>
<td>
<p>character. A vector of patterns for which referrers should
be identified. Order and length must correspondent to <code>platform_domains</code> vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To identify referrals, we rely on the method described as most valid
in Schmidt et al.: When the domain preceding a visit was to the platform in question,
and the query string of the visit's URL contains a certain pattern,
we count it as a referred visit. For Facebook, the pattern has been identified
by Schmidt et al. as <code>'fbclid='</code>, although this can change in future.
</p>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt and a new column called <code>referral</code>,
which takes on NA if no referral has been identified, or the name specified
platform_domains if a referral from that platform has been identified
</p>


<h3>References</h3>

<p>Schmidt, Felix, Frank Mangold, Sebastian Stier and Roberto Ulloa. &quot;Facebook as an Avenue to News: A Comparison and Validation of Approaches to Identify Facebook Referrals&quot;. Working paper.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
wt &lt;- add_referral(wt, platform_domains = "facebook.com", patterns = "fbclid=")
wt &lt;- add_referral(wt,
  platform_domains = c("facebook.com", "twitter.com"),
  patterns = c("fbclid=", "utm_source=twitter")
)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_session'>Add a session variable</h2><span id='topic+add_session'></span>

<h3>Description</h3>

<p><code>add_session()</code> groups visits into &quot;sessions&quot;, defining a session to end
when the difference between two consecutive timestamps exceeds a <code>cutoff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_session(wt, cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_session_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="add_session_+3A_cutoff">cutoff</code></td>
<td>
<p>numeric (seconds). If the difference between two consecutive
timestamps exceeds this value, a new browsing session is defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table (ordered by panelist_id and timestamp)
with the same columns as wt and a new column called <code>session</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# Setting cutoff to 30 minutes
wt &lt;- add_session(wt, cutoff = 1800)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_title'>Download and add the &quot;title&quot; of a URL</h2><span id='topic+add_title'></span>

<h3>Description</h3>

<p><code>add_title()</code> gets the title of a URL by accessing the web address online
and adds the title as a new column. See details for the meaning of &quot;title&quot;.
You need an internet connection to run this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_title(wt, lang = "en-US,en-GB,en")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_title_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="add_title_+3A_lang">lang</code></td>
<td>
<p>character (a language tag). Language accepted by the request.
Defaults to <code>"en-US,en-GB,en"</code>. Note that you are likely to still obtain titles
different from the ones seen originally by the user, because the language
also depend on the user's IP and device settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The title of a website (the text within the <code style="white-space: pre;">&#8288;&lt;title&gt;&#8288;</code> tag
of a web site's <code style="white-space: pre;">&#8288;&lt;head&gt;&#8288;</code>) #' is the text that is shown on the &quot;tab&quot;
when looking at the website in a browser. It can contain useful information
about a URL's content and can be used, for example, for classification purposes.
Note that it may take a while to run this function for a large number of URLs.
</p>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt and a new column
called <code>"title"</code>, which will be <code>NA</code> if the title cannot be retrieved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)[1:2]
# Get titles with `lang` set to default English
wt_titles &lt;- add_title(wt)
# Get titles with `lang` set to German
wt_titles &lt;- add_title(wt, lang = "de")

## End(Not run)
</code></pre>

<hr>
<h2 id='audience_incidence'>Create incidence matrix for two-mode networks including audiences</h2><span id='topic+audience_incidence'></span>

<h3>Description</h3>

<p><code>audience_incidence()</code> created an incidence matrix, which is a matrix A
with entries <code>A[i,j]=1</code> if panelist <code>i</code> visited web site <code>j</code> at least once.
Web site can be defined, for example, by the URL's domain, or its host.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audience_incidence(wt, mode2 = "domain", cutoff = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="audience_incidence_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="audience_incidence_+3A_mode2">mode2</code></td>
<td>
<p>character. Name of column that includes the second mode (e.g.,
<code>domain</code> or <code>host</code>)</p>
</td></tr>
<tr><td><code id="audience_incidence_+3A_cutoff">cutoff</code></td>
<td>
<p>visits below this cutoff will not be considered as a visit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix of a two-mode network
</p>


<h3>See Also</h3>

<p>To create audience networks see <a href="#topic+audience_network">audience_network</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
wt &lt;- add_duration(wt)
wt &lt;- suppressWarnings(extract_domain(wt))
# create incidence matrix using domains as second mode
incidence &lt;- audience_incidence(wt)
# create incidence matrix using hosts as second mode
wt &lt;- suppressWarnings(extract_host(wt))
incidence &lt;- audience_incidence(wt, mode2 = "host")

## End(Not run)
</code></pre>

<hr>
<h2 id='audience_network'>Create audience networks</h2><span id='topic+audience_network'></span>

<h3>Description</h3>

<p>audience network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audience_network(wt, mode2 = "domain", cutoff = 3, type = "pmi", alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="audience_network_+3A_wt">wt</code></td>
<td>
<p>webtrack data object</p>
</td></tr>
<tr><td><code id="audience_network_+3A_mode2">mode2</code></td>
<td>
<p>character. name of column that includes the second mode (e.g.
'domain' or 'host')</p>
</td></tr>
<tr><td><code id="audience_network_+3A_cutoff">cutoff</code></td>
<td>
<p>visits below this cutoff will not be considered as a visit</p>
</td></tr>
<tr><td><code id="audience_network_+3A_type">type</code></td>
<td>
<p>one of &quot;pmi&quot;, &quot;phi&quot;, &quot;disparity&quot;, &quot;sdsm, &quot;or &quot;fdsm&quot;.</p>
</td></tr>
<tr><td><code id="audience_network_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>audience network as igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
wt &lt;- add_duration(wt)
wt &lt;- suppressWarnings(extract_domain(wt))
network &lt;- audience_network(wt, type = "pmi", cutoff = 120)

## End(Not run)
</code></pre>

<hr>
<h2 id='bakshy'>Bakshy Top500
Ideological alignment of 500 domains based on facebook data</h2><span id='topic+bakshy'></span>

<h3>Description</h3>

<p>Bakshy Top500
Ideological alignment of 500 domains based on facebook data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bakshy
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 500 rows and 7 columns.
</p>


<h3>References</h3>

<p>Bakshy, Eytan, Solomon Messing, and Lada A. Adamic. &quot;Exposure to ideologically diverse news and opinion on Facebook.&quot; Science 348.6239 (2015): 1130-1132.
</p>

<hr>
<h2 id='classify_visits'>Classify visits by matching to a list of classes</h2><span id='topic+classify_visits'></span>

<h3>Description</h3>

<p><code>classify_visits()</code> categorizes visits by either extracting the visit URL's
domain or host and matching them to a list of domains or hosts;
or by matching a list of regular expressions against the visit URL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_visits(
  wt,
  classes,
  match_by = "domain",
  regex_on = NULL,
  return_rows_by = NULL,
  return_rows_val = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_visits_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="classify_visits_+3A_classes">classes</code></td>
<td>
<p>a data.table containing classes that can be matched to visits.</p>
</td></tr>
<tr><td><code id="classify_visits_+3A_match_by">match_by</code></td>
<td>
<p>character. Whether to match list entries from <code>classes</code> to
the domain of a visit (<code>"domain"</code>) or the host (<code>"host"</code>) with an exact match;
or with a regular expression against the whole URL of a visit (<code>"regex"</code>).
If set to <code>"domain"</code> or <code>"host"</code>, both <code>wt</code> and <code>classes</code> need to have
a column called accordingly. If set to <code>"regex"</code>, the <code>url</code> column of <code>wt</code>
will be used, and you need to set <code>regex_on</code> to the column in <code>classes</code>
for which to do the pattern matching. Defaults to <code>"domain"</code>.</p>
</td></tr>
<tr><td><code id="classify_visits_+3A_regex_on">regex_on</code></td>
<td>
<p>character. Column in <code>classes</code> which to use for
pattern matching. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="classify_visits_+3A_return_rows_by">return_rows_by</code></td>
<td>
<p>character. A column in <code>classes</code> on which to
subset the returning data. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="classify_visits_+3A_return_rows_val">return_rows_val</code></td>
<td>
<p>character. The value of the columns specified in
<code>return_rows_by</code>, for which data should be returned. For example, if your
<code>classes</code> data contains a column <code>type</code>, which has a value called <code>"shopping"</code>,
setting <code>return_rows_by</code> to <code>"type"</code> and <code>return_rows_val</code> to <code>"shopping"</code>
will only return visits classified as <code>"shopping"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table with the same columns as <code>wt</code> and any column
in <code>classes</code> except the column specified by <code>match_by</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
data("domain_list")
wt &lt;- as.wt_dt(testdt_tracking)
# classify visits via domain
wt_domains &lt;- extract_domain(wt, drop_na = FALSE)
wt_classes &lt;- classify_visits(wt_domains, classes = domain_list, match_by = "domain")
# classify visits via domain
# for the example, just renaming "domain" column
domain_list$host &lt;- domain_list$domain
wt_hosts &lt;- extract_host(wt, drop_na = FALSE)
wt_classes &lt;- classify_visits(wt_hosts, classes = domain_list, match_by = "host")
# classify visits with pattern matching
# for the example, any value in "domain" treated as pattern
data("domain_list")
regex_list &lt;- domain_list[type == "facebook"]
wt_classes &lt;- classify_visits(wt[1:5000],
  classes = regex_list,
  match_by = "regex", regex_on = "domain"
)
# classify visits via domain and only return class "search"
data("domain_list")
wt_classes &lt;- classify_visits(wt_domains,
  classes = domain_list,
  match_by = "domain", return_rows_by = "type",
  return_rows_val = "search"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='create_urldummy'>Create an urldummy variable from a data.table object</h2><span id='topic+create_urldummy'></span>

<h3>Description</h3>

<p>Create an urldummy variable from a data.table object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_urldummy(wt, dummy, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_urldummy_+3A_wt">wt</code></td>
<td>
<p>webtrack data object</p>
</td></tr>
<tr><td><code id="create_urldummy_+3A_dummy">dummy</code></td>
<td>
<p>a vector of urls that should be dummy coded</p>
</td></tr>
<tr><td><code id="create_urldummy_+3A_name">name</code></td>
<td>
<p>name of dummy variable to create.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack object with the same columns and a new column called &quot;name&quot; including the dummy variable
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
wt &lt;- extract_domain(wt)
code_urls &lt;- "https://dkr1.ssisurveys.com/tzktsxomta"
create_urldummy(wt, dummy = code_urls, name = "test_dummy")

## End(Not run)
</code></pre>

<hr>
<h2 id='deduplicate'>Deduplicate visits</h2><span id='topic+deduplicate'></span>

<h3>Description</h3>

<p><code>deduplicate()</code> flags, drops or aggregates duplicates, which are defined as
consecutive visits to the same URL within a certain time frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deduplicate(
  wt,
  method = "aggregate",
  within = 1,
  duration_var = "duration",
  keep_nvisits = FALSE,
  same_day = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deduplicate_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="deduplicate_+3A_method">method</code></td>
<td>
<p>character. One of <code>"aggregate"</code>, <code>"flag"</code> or <code>"drop"</code>.
If set to <code>"aggregate"</code>, consecutive visits (no matter the time difference)
to the same URL are combined and their duration aggregated.
In this case, a duration column must be specified via <code>"duration_var"</code>.
If set to <code>"flag"</code>, duplicates within a certain time frame are flagged in a new
column called <code>duplicate</code>. In this case, <code>within</code> argument must be specified.
If set to <code>"drop"</code>, duplicates are dropped. Again, <code>within</code> argument must be specified.
Defaults to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="deduplicate_+3A_within">within</code></td>
<td>
<p>numeric (seconds). If <code>method</code> set to <code>"flag"</code> or <code>"drop"</code>,
a subsequent visit is only defined as a duplicate when happening within
this time difference. Defaults to 1 second.</p>
</td></tr>
<tr><td><code id="deduplicate_+3A_duration_var">duration_var</code></td>
<td>
<p>character. Name of duration variable. Defaults to <code>"duration"</code>.</p>
</td></tr>
<tr><td><code id="deduplicate_+3A_keep_nvisits">keep_nvisits</code></td>
<td>
<p>boolean. If method set to <code>"aggregate"</code>, this determines whether
number of aggregated visits should be kept as variable. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="deduplicate_+3A_same_day">same_day</code></td>
<td>
<p>boolean. If method set to <code>"aggregate"</code>, determines
whether to count visits as consecutive only when on the same day. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt with updated duration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
wt &lt;- add_duration(wt, cutoff = 300, replace_by = 300)
# Dropping duplicates with one-second default
wt_dedup &lt;- deduplicate(wt, method = "drop")
# Flagging duplicates with one-second default
wt_dedup &lt;- deduplicate(wt, method = "flag")
# Aggregating duplicates
wt_dedup &lt;- deduplicate(wt[1:1000], method = "aggregate")
# Aggregating duplicates and keeping number of visits for aggregated visits
wt_dedup &lt;- deduplicate(wt[1:1000], method = "aggregate", keep_nvisits = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='domain_list'>Domain list
classification of domains into news,portals, search, and social media</h2><span id='topic+domain_list'></span>

<h3>Description</h3>

<p>Domain list
classification of domains into news,portals, search, and social media
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain_list
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 663 rows and 2 columns.
</p>


<h3>References</h3>

<p>Stier, S., Mangold, F., Scharkow, M., &amp; Breuer, J. (2022). Post Post-Broadcast Democracy? News Exposure in the Age of Online Intermediaries. American Political Science Review, 116(2), 768-774.
</p>

<hr>
<h2 id='drop_query'>Drop the query and fragment from URL</h2><span id='topic+drop_query'></span>

<h3>Description</h3>

<p><code>drop_query()</code> adds the URL without query and fragment as a new column.
The query is defined as the part following a &quot;?&quot; after the path.
The fragement is anything following a &quot;#&quot; after the query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_query(wt, varname = "url")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_query_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="drop_query_+3A_varname">varname</code></td>
<td>
<p>character. name of the column from which to extract the host.
Defaults to <code>"url"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt
and a new column called <code>'&lt;varname&gt;_noquery'</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# Extract URL without query/fragment
wt &lt;- drop_query(wt)

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_domain'>Extract the domain from URL</h2><span id='topic+extract_domain'></span>

<h3>Description</h3>

<p><code>extract_domain()</code> adds the domain of a URL as a new column.
By &quot;domain&quot;, we mean the &quot;top private domain&quot;, i.e., the domain under
the public suffix (e.g., &quot;<code>com</code>&quot;) as defined by the Public Suffix List.
See details.
</p>
<p>Extracts the domain from urls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_domain(wt, varname = "url", drop_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_domain_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="extract_domain_+3A_varname">varname</code></td>
<td>
<p>character. Name of the column from which to extract the host.
Defaults to <code>"url"</code>.</p>
</td></tr>
<tr><td><code id="extract_domain_+3A_drop_na">drop_na</code></td>
<td>
<p>boolean. Determines whether rows for which no host can be extracted
should be dropped from the data. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We define a &quot;web domain&quot; in the common colloquial meaning, that is,
the part of an web address that identifies the person or organization in control.
is <code>google.com</code>. More technically, what we mean by &quot;domain&quot; is the
&quot;top private domain&quot;, i.e., the domain under the public suffix,
as defined by the Public Suffix List.
Note that this definition sometimes leads to counterintuitive results because
not all public suffixes are &quot;registry suffixes&quot;. That is, they are not controlled
by a domain name registrar, but allow users to directly register a domain.
One example of such a public, non-registry suffix is <code>blogspot.com</code>. For a URL like
<code>www.mysite.blogspot.com</code>, our function, and indeed the packages we are aware of,
would extract the domain as <code>mysite.blogspot.com</code>, although you might think of
<code>blogspot.com</code> as the domain.
For details, see <a href="https://github.com/google/guava/wiki/InternetDomainNameExplained">here</a>
</p>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt
and a new column called <code>'domain'</code>
(or, if varname not equal to <code>'url'</code>, <code>'&lt;varname&gt;_domain'</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# Extract domain and drop rows without domain
wt &lt;- extract_domain(wt)
# Extract domain and keep rows without domain
wt &lt;- extract_domain(wt, drop_na = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_host'>Extract the host from URL</h2><span id='topic+extract_host'></span>

<h3>Description</h3>

<p><code>extract_host()</code> adds the host of a URL as a new column.
The host is defined as the part following the scheme (e.g., &quot;https://&quot;) and
preceding the subdirectory (anything following the next &quot;/&quot;). Note that
for URL entries like <code style="white-space: pre;">&#8288;chrome-extension://soomething&#8288;</code> or <code style="white-space: pre;">&#8288;http://192.168.0.1/something&#8288;</code>,
result will be set to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_host(wt, varname = "url", drop_na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_host_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="extract_host_+3A_varname">varname</code></td>
<td>
<p>character. Name of the column from which to extract the host.
Defaults to <code>"url"</code>.</p>
</td></tr>
<tr><td><code id="extract_host_+3A_drop_na">drop_na</code></td>
<td>
<p>boolean. Determines whether rows for which no host can be extracted
should be dropped from the data. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt
and a new column called <code>'host'</code> (or, if varname not equal to <code>'url'</code>, <code>'&lt;varname&gt;_host'</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# Extract host and drop rows without host
wt &lt;- extract_host(wt)
# Extract host and keep rows without host
wt &lt;- extract_host(wt, drop_na = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='extract_path'>Extract the path from URL</h2><span id='topic+extract_path'></span>

<h3>Description</h3>

<p><code>extract_path()</code> adds the path of a URL as a new column.
The path is defined as the part following the host but not including a
query (anything after a &quot;?&quot;) or a fragment (anything after a &quot;#&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_path(wt, varname = "url")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_path_+3A_wt">wt</code></td>
<td>
<p>webtrack data object</p>
</td></tr>
<tr><td><code id="extract_path_+3A_varname">varname</code></td>
<td>
<p>character. name of the column from which to extract the host.
Defaults to <code>"url"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>webtrack data.table with the same columns as wt
and a new column called <code>'path'</code> (or, if varname not equal to <code>'url'</code>, <code>'&lt;varname&gt;_path'</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# Extract path
wt &lt;- extract_path(wt)

## End(Not run)
</code></pre>

<hr>
<h2 id='isolation_index'>Isolation Index</h2><span id='topic+isolation_index'></span>

<h3>Description</h3>

<p>Given two groups (A and B) of individuals, the isolation index captures the
extent to which group A disproportionately visit websites whose other visitors
are also members of group A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolation_index(grp_A, grp_B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isolation_index_+3A_grp_a">grp_A</code></td>
<td>
<p>vector (usually corresponds to a column in a webtrack
data.table) indicating the number of individuals of group A using a website</p>
</td></tr>
<tr><td><code id="isolation_index_+3A_grp_b">grp_B</code></td>
<td>
<p>vector (usually corresponds to a column in a webtrack
data.table) indicating the number of individuals of group B using a website</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a value of 1 indicates that the websites visited by group A and group B do not overlap.
A value of 0 means both visit exactly the same websites
</p>


<h3>Value</h3>

<p>numeric value between 0 and 1. 0 indicates no isolation and 1 perfect isolation
</p>


<h3>References</h3>

<p>Cutler, David M., Edward L. Glaeser, and Jacob L. Vigdor. &quot;The rise and decline of the American ghetto.&quot; Journal of political economy 107.3 (1999): 455-506.
Gentzkow, Matthew, and Jesse M. Shapiro. &quot;Ideological segregation online and offline.&quot; The Quarterly Journal of Economics 126.4 (2011): 1799-1839.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># perfect isolation
left &lt;- c(5, 5, 0, 0)
right &lt;- c(0, 0, 5, 5)
isolation_index(left, right)

# perfect overlap
left &lt;- c(5, 5, 5, 5)
right &lt;- c(5, 5, 5, 5)
isolation_index(left, right)
</code></pre>

<hr>
<h2 id='news_types'>News Types</h2><span id='topic+news_types'></span>

<h3>Description</h3>

<p>Classification of domains into different news types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>news_types
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 690 rows and 2 columns.
</p>


<h3>References</h3>

<p>Stier, S., Mangold, F., Scharkow, M., &amp; Breuer, J. (2022). Post Post-Broadcast Democracy? News Exposure in the Age of Online Intermediaries. American Political Science Review, 116(2), 768-774.
</p>

<hr>
<h2 id='print.wt_dt'>Print web tracking data</h2><span id='topic+print.wt_dt'></span>

<h3>Description</h3>

<p>Print web tracking data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wt_dt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.wt_dt_+3A_x">x</code></td>
<td>
<p>object of class wt_dt</p>
</td></tr>
<tr><td><code id="print.wt_dt_+3A_...">...</code></td>
<td>
<p>additional parameters for print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='sum_activity'>Summarize activity per person</h2><span id='topic+sum_activity'></span>

<h3>Description</h3>

<p><code>sum_activity()</code> counts the number of active time periods (i.e., days, weeks,
months, years, or waves) by <code>panelist_id</code>. A period counts as &quot;active&quot; if
the panelist provided at least one visit for that period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_activity(wt, timeframe = "date")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_activity_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="sum_activity_+3A_timeframe">timeframe</code></td>
<td>
<p>character. Indicates for what time frame to aggregate visits.
Possible values are <code>"date"</code>, <code>"week"</code>, <code>"month"</code>, <code>"year"</code> or <code>"wave"</code>. If
set to <code>"wave"</code>, <code>wt</code> must contain a column call <code>wave</code>. Defaults to <code>"date"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with columns <code>panelist_id</code>, column indicating the
number of active time units.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# summarize activity by day
wt_sum &lt;- sum_activity(wt, timeframe = "date")

## End(Not run)
</code></pre>

<hr>
<h2 id='sum_durations'>Summarize visit duration by person</h2><span id='topic+sum_durations'></span>

<h3>Description</h3>

<p><code>sum_durations()</code> summarizes the duration of visits by person within a <code>timeframe</code>,
and optionally by <code>visit_class</code> of visit. Note:
</p>

<ul>
<li><p> If for a time frame all rows are NA on the duration column, the summarized duration for that time frame will be NA.
</p>
</li>
<li><p> If only some of the rows of a time frame are NA on the duration column, the function will ignore those NA rows.
</p>
</li>
<li><p> If there were no visits to a class (i.e., a value of the 'visit_class' column) for a time frame, the summarized duration for that time frame will be zero; if there were visits, but NA on duration, the summarized duration will be NA.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sum_durations(wt, var_duration = NULL, timeframe = NULL, visit_class = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_durations_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="sum_durations_+3A_var_duration">var_duration</code></td>
<td>
<p>character. Name of the duration variable if already present.
Defaults to <code>NULL</code>, in which case duration will be approximated with
<code>add_duration(wt, cutoff = 300, replace_by = "na", replace_val = NULL)</code></p>
</td></tr>
<tr><td><code id="sum_durations_+3A_timeframe">timeframe</code></td>
<td>
<p>character. Indicates for what time frame to aggregate visit durations.
Possible values are <code>"date"</code>, <code>"week"</code>, <code>"month"</code>, <code>"year"</code>, <code>"wave"</code> or <code>NULL</code>.
If set to <code>"wave"</code>, <code>wt</code> must contain a column call <code>wave</code>. Defaults to <code>NULL</code>,
in which case the output contains duration of visits for the entire time.</p>
</td></tr>
<tr><td><code id="sum_durations_+3A_visit_class">visit_class</code></td>
<td>
<p>character. Column that contains a classification of visits.
For each value in this column, the output will have a column indicating the
number of visits belonging to that value. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with columns <code>panelist_id</code>, column indicating the time unit
(unless <code>timeframe</code> set to <code>NULL</code>), <code>duration_visits</code> indicating the duration of visits
(in seconds, or whatever the unit of the variable specified by <code>var_duration</code> parameter),
and a column for each value of <code>visit_class</code>, if specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# summarize for whole period
wt_summ &lt;- sum_durations(wt)
# summarize by week
wt_summ &lt;- sum_durations(wt, timeframe = "week")
# create a class variable to summarize by class
wt &lt;- suppressWarnings(extract_domain(wt, drop_na = TRUE))
wt[, google := ifelse(domain == "google.com", 1, 0)]
wt_summ &lt;- sum_durations(wt, timeframe = "week", visit_class = "google")

## End(Not run)
</code></pre>

<hr>
<h2 id='sum_visits'>Summarize number of visits by person</h2><span id='topic+sum_visits'></span>

<h3>Description</h3>

<p><code>sum_visits()</code> summarizes the number of visits by person within a <code>timeframe</code>,
and optionally by <code>visit_class</code> of visit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_visits(wt, timeframe = NULL, visit_class = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_visits_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="sum_visits_+3A_timeframe">timeframe</code></td>
<td>
<p>character. Indicates for what time frame to aggregate visits.
Possible values are <code>"date"</code>, <code>"week"</code>, <code>"month"</code>, <code>"year"</code>, <code>"wave"</code> or <code>NULL</code>.
If set to <code>"wave"</code>, <code>wt</code> must contain a column call <code>wave</code>. Defaults to <code>NULL</code>,
in which case the output contains number of visits for the entire time.</p>
</td></tr>
<tr><td><code id="sum_visits_+3A_visit_class">visit_class</code></td>
<td>
<p>character. Column that contains a classification of visits.
For each value in this column, the output will have a column indicating the
number of visits belonging to that value. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table with columns <code>panelist_id</code>, column indicating the time unit
(unless <code>timeframe</code> set to <code>NULL</code>), <code>n_visits</code> indicating the number of visits,
and a column for each value of <code>visit_class</code>, if specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
# summarize for whole period
wt_summ &lt;- sum_visits(wt)
# summarize by week
wt_summ &lt;- sum_visits(wt, timeframe = "week")
# create a class variable to summarize by class
wt &lt;- suppressWarnings(extract_domain(wt, drop_na = TRUE))
wt[, google := ifelse(domain == "google.com", 1, 0)]
wt_summ &lt;- sum_visits(wt, timeframe = "week", visit_class = "google")

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.wt_dt'>Summary function for web tracking data</h2><span id='topic+summary.wt_dt'></span>

<h3>Description</h3>

<p>Summary function for web tracking data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wt_dt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.wt_dt_+3A_object">object</code></td>
<td>
<p>object of class wt_dt</p>
</td></tr>
<tr><td><code id="summary.wt_dt_+3A_...">...</code></td>
<td>
<p>additional parameters for summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='testdt_survey_l'>Test survey</h2><span id='topic+testdt_survey_l'></span>

<h3>Description</h3>

<p>Same randomly generated survey data, one row per person/wave (long format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdt_survey_l
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 15 rows and 7 columns.
</p>

<hr>
<h2 id='testdt_survey_w'>Test survey</h2><span id='topic+testdt_survey_w'></span>

<h3>Description</h3>

<p>Randomly generated survey data only used for illustrative purposes (wide format)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdt_survey_w
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 5 rows and 8 columns.
</p>

<hr>
<h2 id='testdt_tracking'>Test data</h2><span id='topic+testdt_tracking'></span>

<h3>Description</h3>

<p>Sample of fully anomymized webtrack data from a research project with US participants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdt_tracking
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 49612 rows and 5 columns.
</p>

<hr>
<h2 id='vars_exist'>Check if columns are present</h2><span id='topic+vars_exist'></span>

<h3>Description</h3>

<p><code>vars_exist()</code> checks if columns are present in a webtrack data object.
By default, checks whether the data has a <code>panelist_id</code>, a <code>ulr</code> and a
<code>timestamp</code> column.#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars_exist(wt, vars = c("panelist_id", "url", "timestamp"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_exist_+3A_wt">wt</code></td>
<td>
<p>webtrack data object.</p>
</td></tr>
<tr><td><code id="vars_exist_+3A_vars">vars</code></td>
<td>
<p>character vector of variables.
Defaults to <code>c("panelist_id", "url", "timestamp")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table object.
</p>

<hr>
<h2 id='webtrackR-package'>webtrackR: Preprocessing and Analyzing Web Tracking Data</h2><span id='topic+webtrackR'></span><span id='topic+webtrackR-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Data structures and methods to work with web tracking data. The functions cover data preprocessing steps, enriching web tracking data with external information and methods for the analysis of digital behavior as used in several academic papers (e.g., Clemm von Hohenberg et al., 2023 <a href="https://doi.org/10.17605/OSF.IO/M3U9P">doi:10.17605/OSF.IO/M3U9P</a>; Stier et al., 2022 <a href="https://doi.org/10.1017/S0003055421001222">doi:10.1017/S0003055421001222</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Schoch <a href="mailto:david@schochastics.net">david@schochastics.net</a> (<a href="https://orcid.org/0000-0003-2952-4812">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Bernhard Clemm von Hohenberg <a href="mailto:bernhard.clemm@gesis.org">bernhard.clemm@gesis.org</a> (<a href="https://orcid.org/0000-0002-6976-9745">ORCID</a>)
</p>
</li>
<li><p> Frank Mangold <a href="mailto:frank.mangold@gesis.org">frank.mangold@gesis.org</a> (<a href="https://orcid.org/0000-0002-9776-3113">ORCID</a>)
</p>
</li>
<li><p> Sebastian Stier <a href="mailto:sebastian.stier@gesis.org">sebastian.stier@gesis.org</a> (<a href="https://orcid.org/0000-0002-1217-5778">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/schochastics/webtrackR">https://github.com/schochastics/webtrackR</a>
</p>
</li>
<li> <p><a href="https://schochastics.github.io/webtrackR/">https://schochastics.github.io/webtrackR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/schochastics/webtrackR/issues">https://github.com/schochastics/webtrackR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='wt_dt'>An S3 class, based on <a href="data.table.html#topic+data.table">data.table</a>, to store web tracking data</h2><span id='topic+wt_dt'></span><span id='topic+as.wt_dt'></span><span id='topic+is.wt_dt'></span>

<h3>Description</h3>

<p>An S3 class, based on <a href="data.table.html#topic+data.table">data.table</a>, to store web tracking data
</p>
<p>Convert a data.frame containing web tracking data to a <code>wt_dt</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.wt_dt(
  x,
  timestamp_format = "%Y-%m-%d %H:%M:%OS",
  varnames = c(panelist_id = "panelist_id", url = "url", timestamp = "timestamp")
)

is.wt_dt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt_dt_+3A_x">x</code></td>
<td>
<p>data.frame containing a necessary set of columns, namely
panelist's ID, visit URL and visit timestamp.</p>
</td></tr>
<tr><td><code id="wt_dt_+3A_timestamp_format">timestamp_format</code></td>
<td>
<p>string. Specifies the raw timestamp's formatting.
Defaults to <code>"%Y-%m-%d %H:%M:%OS"</code>.</p>
</td></tr>
<tr><td><code id="wt_dt_+3A_varnames">varnames</code></td>
<td>
<p>Named vector of column names, which contain the panelist's ID
(<code>panelist_id</code>), the visit's URL (<code>url</code>) and the visit's timestamp (<code>timestamp</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>wt_dt</code> table is a <a href="data.table.html#topic+data.table">data.table</a>.
Therefore, it can be used by any function that would work on a <a href="base.html#topic+data.frame">data.frame</a> or a <a href="data.table.html#topic+data.table">data.table</a>.
Most of the operation such as variable creation, subsetting and joins are inherited from the <a href="data.table.html#topic+data.table">data.table</a>
<code style="white-space: pre;">&#8288;[]&#8288;</code> operator, following the convention <code>DT[i,j,by]</code> (see data table package for detail).
</p>


<h3>Value</h3>

<p>a webtrack data object with at least columns <code>panelist_id</code>, <code>url</code>
and <code>timestamp</code>
</p>
<p>logical. TRUE if x is a webtrack data object and FALSE otherwise
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="data.table.html#topic+data.table">data.table</a> &ndash; on which <code>wt_dt</code> is based
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("testdt_tracking")
wt &lt;- as.wt_dt(testdt_tracking)
is.wt_dt(wt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
