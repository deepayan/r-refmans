<!DOCTYPE html><html><head><title>Help for package IDPmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IDPmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IDPmisc-package'><p>Utilities of Institute of Data Analyses and Process Design (www.zhaw.ch/idp)</p></a></li>
<li><a href='#Arrows'><p>Pretty Open or Closed Arrows</p></a></li>
<li><a href='#cart2clock'><p> Convert Cartesian Coordinates to Clock Coordinates</p></a></li>
<li><a href='#clock2cart'><p> Convert Clock Coordinates to Cartesian Coordinates</p></a></li>
<li><a href='#col2hsv'>
<p>Convert Color to hsv Code</p></a></li>
<li><a href='#data.sheet'><p>Coerce a list to a data.frame</p></a></li>
<li><a href='#draw.leg'><p>Produce a Legend or Key (Grid Function)</p></a></li>
<li><a href='#general.control'><p> Auxilary for Controlling  the General Appearance of a Rose Plot</p></a></li>
<li><a href='#getXY'><p> Easy and Flexible Input for One- and Two Dimensional Data</p></a></li>
<li><a href='#grid.control'><p> Auxilary for Controlling  the Grid Appearance of a Rose Plot</p></a></li>
<li><a href='#humidity'>
<p>Converting Humidity Measures into Each Other</p></a></li>
<li><a href='#IDPcolorRamp'><p>Color Ramp for Ordered Values</p></a></li>
<li><a href='#ilagplot'><p>Image Lag Plot Matrix for Large Time Series</p></a></li>
<li><a href='#Image'><p>Display the Density of Points in a Scatter Plot by Colors</p></a></li>
<li><a href='#internals'><p>Internal Functions</p></a></li>
<li><a href='#ipairs'><p>Image Scatter Plot Matrix for Large Datasets</p></a></li>
<li><a href='#ipanel.smooth'><p> Panelplot for itermplot</p></a></li>
<li><a href='#iplot'><p>Image Scatter Plot for Large Datasets</p></a></li>
<li><a href='#iplotLegend'><p> Plots Legend for Color Ramp</p></a></li>
<li><a href='#itermplot'><p> Plot Regression Terms for Huge Datasets</p></a></li>
<li><a href='#key.control'><p> Auxilary for Controlling the Appearance of the Legend of a Rose</p>
Plot</a></li>
<li><a href='#longtsPlot'><p> Plot Very Long Regular Time Series</p></a></li>
<li><a href='#MS'><p> Spectrum Measured by a SELDI TOF Mass Spectrometer</p></a></li>
<li><a href='#NaRV.omit'><p>Omit Observations with NA, NaN, Inf and -Inf Values</p></a></li>
<li><a href='#ok'><p>Sets NAs in Logical Objects to FALSE</p></a></li>
<li><a href='#peaks'><p> Finding Peaks in Raw Data</p></a></li>
<li><a href='#plot.rose'><p> Plot Method for Class &quot;rose&quot;  (Grid Graphics Function)</p></a></li>
<li><a href='#poster.plot'><p>Convenient xyplot with Differently Colored Margin and Plot Region</p></a></li>
<li><a href='#rfbaseline'><p>Robust Fitting of Baselines</p></a></li>
<li><a href='#rfbaselineScale'><p> Estimation of the Scale Parameter</p></a></li>
<li><a href='#rose'><p>Creates a rose object out of circular data</p></a></li>
<li><a href='#rose-class'><p>rose-class</p></a></li>
<li><a href='#showColors'><p>Displays vectors of colors</p></a></li>
<li><a href='#title.control'><p> Auxilary for Controlling  the Title of a Rose Plot</p></a></li>
<li><a href='#zoom'><p>Zooming in and out in a 2d-Plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.21</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-07</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, grid, lattice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SwissAir(&ge; 1.1.3)</td>
</tr>
<tr>
<td>Title:</td>
<td>'Utilities of Institute of Data Analyses and Process Design
(www.zhaw.ch/idp)'</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christoph Hofer &lt;christoph.hofer@zhaw.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Different high-level graphics functions for displaying large datasets, displaying circular data in a very flexible way, finding local maxima, brewing color ramps, drawing nice arrows, zooming 2D-plots, creating figures with differently colored margin and plot region.  In addition, the package contains auxiliary functions for data manipulation like omitting observations with irregular values or selecting data by logical vectors, which include NAs. Other functions are especially useful in spectroscopy and analyses of environmental data: robust baseline fitting, finding peaks in spectra, converting humidity measures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 16:45:37 UTC; hofc</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph Hofer [cre],
  Rene Locher [aut],
  Andreas Ruckstuhl [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 23:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='IDPmisc-package'>Utilities of Institute of Data Analyses and Process Design (www.zhaw.ch/idp)
</h2><span id='topic+IDPmisc-package'></span><span id='topic+IDPmisc'></span>

<h3>Description</h3>

<p>Different high-level graphics functions for displaying large datasets, displaying circular data in a very flexible way, finding local maxima, brewing color ramps, drawing nice arrows, zooming 2D-plots, creating figures with differently colored margin and plot region.  In addition, the package contains auxiliary functions for data manipulation like omitting observations with irregular values or selecting data by logical vectors, which include NAs. Other functions are especially useful in spectroscopy and analyses of environmental data: robust baseline fitting, finding peaks in spectra, converting humidity measures.
</p>


<h3>Author(s)</h3>

<p>Rene Locher, Andreas Ruckstuhl et al.
Maintainer: Christoph Hofer &lt;christoph.hofer@zhaw.ch&gt;
</p>

<hr>
<h2 id='Arrows'>Pretty Open or Closed Arrows</h2><span id='topic+Arrows'></span>

<h3>Description</h3>

<p>Draws a set of open or closed arrows which can be shaped by
many arguments.  <code>Arrows</code> is an extended version of
<code><a href="sfsmisc.html#topic+p.arrows">p.arrows</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Arrows(x1, y1, x2, y2, size = 1, width = 1.2/4/cin, open = TRUE,
       sh.adj = 0.1, sh.lwd = 1, sh.col = par("fg"),
       sh.lty = 1,
       h.col = sh.col, h.col.bo = sh.col, h.lwd = sh.lwd, h.lty = sh.lty,
       verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arrows_+3A_x1">x1</code>, <code id="Arrows_+3A_y1">y1</code></td>
<td>
<p>Coordinates of points <b>from</b> which to draw.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_x2">x2</code>, <code id="Arrows_+3A_y2">y2</code></td>
<td>
<p>Coordinates of points <b>to</b> which to draw.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_size">size</code></td>
<td>
<p>Head size as a fraction of a character height.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_width">width</code></td>
<td>
<p>Width of the arrow head.  See argument <code>verbose</code>.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_open">open</code></td>
<td>
<p>Defines if arrows are open or closed.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_sh.adj">sh.adj</code></td>
<td>
<p>Defines gap between end of the shaft and the top of the
head of the arrow (see details)</p>
</td></tr>
<tr><td><code id="Arrows_+3A_sh.lwd">sh.lwd</code></td>
<td>
<p>Thickness of shaft.  cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="Arrows_+3A_sh.col">sh.col</code></td>
<td>
<p>Color of shaft.  cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="Arrows_+3A_sh.lty">sh.lty</code></td>
<td>
<p>Line type of shaft.  cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="Arrows_+3A_h.col">h.col</code></td>
<td>
<p>Color of head.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_h.col.bo">h.col.bo</code></td>
<td>
<p>Color of border of head.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_h.lwd">h.lwd</code></td>
<td>
<p>Line width of border of head.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_h.lty">h.lty</code></td>
<td>
<p>Line type of border of head.</p>
</td></tr>
<tr><td><code id="Arrows_+3A_verbose">verbose</code></td>
<td>
<p>When TRUE, the width used is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Definition of sh.adj:
</p>

<dl>
<dt>=0</dt><dd><p>End of shaft at top of head,</p>
</dd>
<dt>=1</dt><dd><p>End of shaft at bottom of head,</p>
</dd>
<dt>&gt;1</dt><dd><p>Gap between shaft and head,</p>
</dd>
<dt>&lt;0</dt><dd><p>Head is on the shaft.</p>
</dd>
</dl>
<p><br /> This function is based on <span class="pkg"><a href="graphics.html#topic+graphics">graphics</a></span>
</p>


<h3>Value</h3>

<p>A value is only returned, when <code>verbose == TRUE</code>.
</p>


<h3>Note</h3>

<p>The plotting device should not be resized manually after plotting as
this changes in general the aspect ratio of the plot and deforms hereby
the plotted arrows. The beauty of the arrows depends from the resolution
of the device. The higher resolutions give better results.
</p>


<h3>Author(s)</h3>

<p>Andreas Ruckstuhl, refined by Rene Locher
</p>


<h3>See Also</h3>

<p><code><a href="sfsmisc.html#topic+p.arrows">p.arrows</a></code>, <code><a href="graphics.html#topic+arrows">arrows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a bunch of different arrows
plot(c(0,10), c(0,10), type="n")
Arrows(5, 5, 5,10, size=3,
       sh.lwd=5, sh.lty=2,
       h.lwd=5)
Arrows(5, 5, 7.5, 9, size=3, open=TRUE,
       sh.adj=0.7, sh.lwd=5, sh.lty=2,
       h.col.bo="red",h.lwd=5)
Arrows(5, 5, 9, 7.5, size=3, open=FALSE,
       sh.adj=1, sh.lwd=5, sh.col="blue",
       h.col.bo="red",h.lwd=2)
Arrows(5, 5, 10, 5, size=2.5, width=1.5, open=FALSE,
       sh.adj=1, sh.lwd=7, sh.col="blue")
Arrows(5, 5, 9, 2.5, size=4, open=FALSE,
       sh.lty=0,
       h.col.bo="black",h.lwd=5)
Arrows(5, 5, 7.5, 1)
Arrows(5, 5, 5, 0, size=2)
Arrows(5, 5, 2.5, 1, size=2, width=1)

## vector field
x&lt;- runif( 20)
y&lt;- runif( 20)
u&lt;- 0.1+0.02*rnorm(20)
v&lt;- 0.1+0.02*rnorm(20)
plot(x,y,xlim=range(c(x,x+u)),ylim=range(c(y,y+v)),type="n")
Arrows(x,y,x+u,y+v,sh.col="blue")
</code></pre>

<hr>
<h2 id='cart2clock'> Convert Cartesian Coordinates to Clock Coordinates </h2><span id='topic+cart2clock'></span>

<h3>Description</h3>

<p>Converts cartesian coordinates (<code>x</code>, <code>y</code> to clock
coordinates (<code>rho</code>, <code>phi</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cart2clock(x, y, circle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cart2clock_+3A_x">x</code>, <code id="cart2clock_+3A_y">y</code></td>
<td>
<p> Cartesian coordinates. </p>
</td></tr>
<tr><td><code id="cart2clock_+3A_circle">circle</code></td>
<td>
<p>  Defines the full circle in the units of <code>phi</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be aware that in clock coordinates and polar coordinate the angle phi
is differently defined!
</p>


<h3>Value</h3>

<p>Data frame with
</p>
<table>
<tr><td><code>rho</code></td>
<td>
<p> Distance of point from center of coordinate system.  </p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p> Angle between North (12 o' clock), center and the point,
measured clockwise. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="#topic+clock2cart">clock2cart</a></code>, <code><a href="#topic+rose-class">rose-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## convert clock coordinates to cartesian coordinates
xy &lt;- clock2cart(rho=rep(1,33),phi=seq(0,to=360,length.out=33),circle=360)

## convert the cartesian coordinates back to clock coordinates
rhophi &lt;- cart2clock(xy$x,xy$y,circle=360)

round(clock2cart(rhophi,circle=360)-xy)
## QED
</code></pre>

<hr>
<h2 id='clock2cart'> Convert Clock Coordinates to Cartesian Coordinates </h2><span id='topic+clock2cart'></span>

<h3>Description</h3>

<p>Converts clock coordinates (<code>rho</code>, <code>phi</code>) to cartesian
coordinates (<code>x</code>, <code>y</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clock2cart(rho, phi, circle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clock2cart_+3A_rho">rho</code></td>
<td>
<p> Distance of point from center of coordinate system.  </p>
</td></tr>
<tr><td><code id="clock2cart_+3A_phi">phi</code></td>
<td>
<p> Angle between North (12 o' clock), center and the point,
measured clockwise. </p>
</td></tr>
<tr><td><code id="clock2cart_+3A_circle">circle</code></td>
<td>
<p> Defines the full circle in the units of <code>phi</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be aware that in clock coordinates and polar coordinate the angle phi
is differently defined!
</p>


<h3>Value</h3>

<p>Data frame with
</p>
<table>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>Cartesian coordinates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cart2clock">cart2clock</a></code>, <code><a href="#topic+rose-class">rose-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## an easy way to plot a circle
xy &lt;- clock2cart(rho=rep(1,33),phi=seq(0,to=360,length.out=33),circle=360)
plot(xy)
</code></pre>

<hr>
<h2 id='col2hsv'>
Convert Color to hsv Code
</h2><span id='topic+col2hsv'></span>

<h3>Description</h3>

<p>Converts color names or values to hsv code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2hsv(col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col2hsv_+3A_col">col</code></td>
<td>
<p>Vector of color code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with the rows
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p>Hue of hsv-Signal: 0=red, 1/3=green, 2/3=blue, 1=red.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Saturation of hsv-Signal: 0=white, 1=full color.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Value of hsv-Signal: 0=black, 1=full color.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rene Locher</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>, <code><a href="grDevices.html#topic+rgb2hsv">rgb2hsv</a></code>, <code><a href="grDevices.html#topic+hsv">hsv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>col2hsv(c("blue","green","red"))
</code></pre>

<hr>
<h2 id='data.sheet'>Coerce a list to a data.frame</h2><span id='topic+data.sheet'></span>

<h3>Description</h3>

<p>Coerces a list with vectors of different length into a data.frame.  Fills the shorter vectors with NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.sheet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.sheet_+3A_x">x</code></td>
<td>
<p>List to be converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is convenient for comparing / controling data in Lists
whose components should have approximately the same length.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Thomas Unternaehrer</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.sheet(list(a=1:5,b=1:4))
</code></pre>

<hr>
<h2 id='draw.leg'>Produce a Legend or Key (Grid Function)</h2><span id='topic+draw.leg'></span>

<h3>Description</h3>

<p>Produces (and possibly draws) a Grid frame grob which is a legend that
can be placed in other Grid plots.  <code>draw.leg</code> is a
slightly enhanced version of <code><a href="lattice.html#topic+draw.key">draw.key</a></code> in
package <span class="pkg">lattice</span> V 0.12-3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.leg(key, draw=FALSE, vp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw.leg_+3A_key">key</code></td>
<td>
<p> A list determining the key.  See details below and the
documentation for <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="draw.leg_+3A_draw">draw</code></td>
<td>
<p> logical, whether the grob is to be drawn. </p>
</td></tr>
<tr><td><code id="draw.leg_+3A_vp">vp</code></td>
<td>
<p> viewport </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three new components are added to the list <code>key</code> of the original code
in package <span class="pkg">lattice</span> V 0.12-3: <code>between.rows</code>,
<code>between.title</code>, <code>adj.title</code>.  They allow to format the
legend in a more flexible way.  To ease the use of <code>draw.leg</code>, the
full description of <code><a href="lattice.html#topic+draw.key">draw.key</a></code> and the here
interesting part of <code><a href="lattice.html#topic+xyplot">xyplot</a></code> are also included:
<br />
The key essentially consists of a number of columns, possibly
divided into blocks, each containing some rows.   The contents of the
key are determined by (possibly repeated) components named
&ldquo;rectangles&rdquo;, &ldquo;lines&rdquo;, &ldquo;points&rdquo; or &ldquo;text&rdquo;.  Each of these
must be lists with relevant graphical parameters (see later)
controlling their appearance.  The <code>key</code> list itself can contain
graphical parameters, these would be used if relevant graphical
components are omitted from the other components.
</p>
<p>The length (number of rows) of each such column (except &ldquo;text&rdquo;s)
is taken to be the largest of the lengths of the graphical
components, including the ones specified outside (see the entry for
<code>rep</code> below for details on this).  The &ldquo;text&rdquo; component has to
have a character or expression vector as its first component, and
the length of this vector determines the number of rows.
</p>
<p>The graphical components that can be included in <code>key</code> (and
also in the components named &ldquo;text&rdquo;, &ldquo;lines&rdquo;, &ldquo;points&rdquo; and
&ldquo;rectangles&rdquo; as appropriate) are:
</p>

<ul>
<li> <p><code>cex=1</code>
</p>
</li>
<li> <p><code>col="black"</code>
</p>
</li>
<li> <p><code>lty=1</code>
</p>
</li>
<li> <p><code>lwd=1</code>
</p>
</li>
<li> <p><code>font=1</code>
</p>
</li>
<li> <p><code>fontface</code>
</p>
</li>
<li> <p><code>fontfamily</code>
</p>
</li>
<li> <p><code>pch=8</code>
</p>
</li>
<li> <p><code>adj=0</code>
</p>
</li>
<li> <p><code>type="l"</code>
</p>
</li>
<li> <p><code>size=5</code>
</p>
</li>
<li> <p><code>angle=0</code>
</p>
</li>
<li> <p><code>density=-1</code>
</p>
</li></ul>

<p><code>adj</code>, <code>angle</code> and <code>density</code> are currently
unimplemented.   <code>size</code> determines the width of columns of
rectangles and lines in character widths.  <code>type</code> is relevant
for lines; <code>"l"</code> denotes a line, <code>"p"</code> denotes a point,
and <code>"b"</code> and <code>"o"</code> both denote both together.
</p>
<p>Other possible components of <code>key</code> are:
</p>

<dl>
<dt><code>between</code></dt><dd>
<p>numeric vector giving the amount of space (character widths)
surrounding each column (split equally on both sides),
</p>
</dd>
<dt><code>title</code></dt><dd>
<p>string or expression giving a title for the key
</p>
</dd>
<dt><code>rep</code></dt><dd>
<p>logical, defaults to <code>TRUE</code>.   By default, it's assumed that
all columns in the key (except the &ldquo;text&rdquo;s) will have the same
number of rows, and all components are replicated to be as long
as the longest.  This can be suppressed by specifying
<code>rep=FALSE</code>, in which case the length of each column will
be determined by components of that column alone.
</p>
</dd>
<dt><code>cex.title</code></dt><dd>
<p>cex for the title
</p>
</dd>
<dt><code>background</code></dt><dd>
<p>background color, defaults to default background
</p>
</dd>
<dt><code>border</code></dt><dd>
<p>either a color for the border, or a logical.  In the latter
case, the border color is black if <code>border</code> is
<code>TRUE</code>, and no border is drawn if it is <code>FALSE</code> (the
default)
</p>
</dd>
<dt><code>transparent=FALSE</code></dt><dd>
<p>logical, whether key area should have a transparent background
</p>
</dd>
<dt><code>columns</code></dt><dd>
<p>the number of columns column-blocks the key is to be divided
into, which are drawn side by side.
</p>
</dd>
<dt><code>between.columns</code></dt><dd>
<p>Space between column blocks, in addition to <code>between</code>.
</p>
</dd>
<dt><code>between.rows</code></dt><dd>
<p>New argument: Space between rows.
</p>
</dd>
<dt><code>between.title</code></dt><dd>
<p>New argument: Space between top row and title of legend.
</p>
</dd>
<dt><code>adj.title</code></dt><dd>
<p>New argument: Adjustment of title in respect to body of
legend.
<br /> <code>adj.title = 0</code> adjusts the title to the left,
<br /> <code>adj.title = 1</code> adjusts the title to the right and
<br /> <code>adj.title = 0.5</code> (=default) centers the title.
</p>
</dd>
<dt><code>divide</code></dt><dd>
<p>Number of point symbols to divide each line when <code>type</code> is
<code>"b"</code> or <code>"o"</code> in <code>lines</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A Grid frame object (that inherits from &ldquo;grob&rdquo;)
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar, modified by Rene Locher</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(grid)

## Legend 2 cm below and 1 cm left of the upper right corner
grid.newpage()
key &lt;- draw.leg(key =
                    list(rectangles = list(col=1:3,
                             size = 2,
                             lwd = 0.5),
                         text = list(LETTERS[1:3]),
                         cex = 1.2,
                         between = 2,
                         between.rows = 0.5,
                         between.title = 0.7,
                         title = "component",
                         cex.title = 1.4,
                         transparent = TRUE))

vp.key &lt;-  viewport(x = convertX(unit(1,"npc")-unit(1,"cm"),"cm"),
                    y = convertY(unit(1,"npc")-unit(2,"cm"),"cm"),
                    width=grobWidth(key),
                    height=grobHeight(key),
                    just=c("right","top"))

pushViewport(vp.key)
grid.draw(key)
popViewport()

##----------------------------------------
## Legend 1 cm above the lower left corner
key &lt;- draw.leg(key = list(rectangles = list(col=1:3,
                             size = 4,
                             lwd = 0.5),
                  text=list(letters[1:3]),
                  lines=list(col=1:3),
                  cex=2,
                  between=2,
                  between.rows=0.5,
                  between.title=0.7,
                  title = "component",
                  adj.title = 0,
                  cex.title = 2.4,
                  transparent = TRUE))

vp.key &lt;-  viewport(x = 0,
                    y = unit(1,"cm"),
                    width=grobWidth(key),
                    height=grobHeight(key),
                    just=c("left","bottom"))

grid.newpage()
pushViewport(vp.key)
grid.draw(key)
popViewport()
</code></pre>

<hr>
<h2 id='general.control'> Auxilary for Controlling  the General Appearance of a Rose Plot
</h2><span id='topic+general.control'></span>

<h3>Description</h3>

<p>Defines  the General Appearance of rose plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general.control(stacked = FALSE,
                rose.rad = NULL, rose.x = NULL, rose.y = NULL,
                mar = rep(0.3, 4),
                rev.col = FALSE,
                shift = 0,
                cex = 1, col = NULL, lty = 1:3, lwd = 1, type = "s")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="general.control_+3A_stacked">stacked</code></td>
<td>
 <p><code>stacked = FALSE</code>: For each point
<code>(object@rho[i,j], object@cyclVar[i])</code> with <code>x</code> equal to a
<code><a href="#topic+rose">rose</a></code> object, the radius is <code>object@rho[i,j]</code> -
<code>ray.lim[1]</code> as defined in <code><a href="#topic+grid.control">grid.control</a></code>.  Points
with identical <code>j</code> are connected by a colored line.
<br /> <code>stacked = TRUE</code>: For each point
<code>(object@rho[i,j], object@cyclVar[i])</code>,
the radius is <code>sum(object@rho[1:i,j])</code>.  No negative values are
allowed in the stacked case as this feature makes sense only for
variables like proportions, counts or concentrations.  Areas
between two adjacent <code>j</code> are filled by color.
<br /> <code>NA</code> values in <code>object@rho</code> are interpreted as <code>0</code>
and a warning is issued.</p>
</td></tr>
<tr><td><code id="general.control_+3A_rose.rad">rose.rad</code>, <code id="general.control_+3A_rose.x">rose.x</code>, <code id="general.control_+3A_rose.y">rose.y</code></td>
<td>
<p> Approximate length of radius, x- and
y-position of rose.  Default units are mm but any valid grid unit
might be chosen (cf. <code><a href="grid.html#topic+unit">unit</a></code>.  If one or more of
these arguments are defined, the user of the plot function must make
sure that the size of the viewport is large enough to show the
complete rose and the legend.  These arguments are especially useful
when a series of plots of exactly the same size and position of the
rose on the viewport has to be produced.</p>
</td></tr>
<tr><td><code id="general.control_+3A_mar">mar</code></td>
<td>
<p> Margin around the plotting area. Default units are
<code>grid.control(cyclVar.cex)</code>. Other units can be defined by
<code><a href="grid.html#topic+unit">unit</a></code>.</p>
</td></tr>
<tr><td><code id="general.control_+3A_rev.col">rev.col</code></td>
<td>
 <p><code>= TRUE</code>: Ordering of the columns of <code>object@rho</code>
is reversed. </p>
</td></tr>
<tr><td><code id="general.control_+3A_shift">shift</code></td>
<td>
<p> Shifts the plot in clockwise direction by this
angle.  Units of <code>shift</code> must be identical with units of
<code>cyclVar</code> in <code>link{plot.rose}</code></p>
</td></tr>
<tr><td><code id="general.control_+3A_cex">cex</code></td>
<td>
<p> Basic size of characters in the plot. </p>
</td></tr>
<tr><td><code id="general.control_+3A_col">col</code></td>
<td>
<p> Colors of lines when <code>stacked = FALSE</code> or colors of
stacked areas else.  In the first case colors are by default as
distinct as possible; in the latter case, all colors are matched by
default to the range green (=center of rose) to blue (outside of rose). </p>
</td></tr>
<tr><td><code id="general.control_+3A_lty">lty</code>, <code id="general.control_+3A_lwd">lwd</code></td>
<td>
<p> Line type and line width. When <code>stacked = TRUE</code>
and <code>lwd = 0</code> the colored aereas are drawn without black
borders.</p>
</td></tr> 
<tr><td><code id="general.control_+3A_type">type</code></td>
<td>
<p>1-character string giving the type of plot desired: <br />
&quot;s&quot; plots observations as segments. This option is the proper way to
distplay rose data. <br />
&quot;l&quot; plots a line joining the data points. This option is a nicer to
look at when data are smoothly distributed in all directions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the arguments conveniently packaged up in a list to supply the
general arguments for <code><a href="#topic+plot.rose">plot.rose</a></code>.
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.rose">plot.rose</a></code>, <code><a href="#topic+grid.control">grid.control</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>general.control()
</code></pre>

<hr>
<h2 id='getXY'> Easy and Flexible Input for One- and Two Dimensional Data </h2><span id='topic+getXY'></span>

<h3>Description</h3>

<p>The function accepts one- or two dimensional data, checks them for
compatibility and gives a dataframe back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getXY(x, y = NULL, unidim.allowed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getXY_+3A_x">x</code></td>
<td>
<p> Vector, matrix, dataframe or list. If <code>x</code> is a vector,
the second dimension may be defined by argument <code>y</code>. If
<code>x</code> is a matrix, dataframe or list and a second column or
element exists, this second element is used instead of <code>y</code>. </p>
</td></tr>
<tr><td><code id="getXY_+3A_y">y</code></td>
<td>
<p> Optional vector of the same length as <code>x</code>.
<br /> When argument <code>x</code> is onedimensional, argument <code>y</code> does
not exist <em>and</em> unidim.allowed is TRUE, argument <code>x</code> is
coerced to a vector and returned as <code>y</code> component where the
resulting <code>x</code> is just the index vector 1:n. </p>
</td></tr>
<tr><td><code id="getXY_+3A_unidim.allowed">unidim.allowed</code></td>
<td>
<p> Logical.
<br /> When unidim.allowed is TRUE (=default), one and two dimensional
input is accepted for any reasonable combination of x and y. In this
mode <code>getXY</code> behaves very similar to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>
<br /> An error message is returned, when <code>unidim.allowed</code> is
FALSE, argument <code>x</code> is onedimenional und <code>y</code> does not
exist.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input is checked for compatibility: When <code>x</code> is a list, the
first two elements must have identical length. When <code>y</code> is
defined, <code>x</code> must be one dimensional and must have the same
length as argument <code>y</code>. When <code>onedim.allowed</code> is
FALSE, input must be twodimensional.
</p>
<p>When input is one dimensional and <code>unidim</code> is TRUE, <code>y</code>
gives the numbers of elements back.
</p>
<p>Function works similar to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>
</p>


<h3>Value</h3>

<p>dataframe with the components <code>x</code> and <code>y</code>
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>Examples</h3>

<pre><code class='language-R'>getXY(3:4, 1:2)
getXY(matrix(1:4,ncol=2))
getXY(as.data.frame(matrix(1:4,ncol=2)))
getXY(4:1)
getXY(list(a=1:2,b=9:10))
</code></pre>

<hr>
<h2 id='grid.control'> Auxilary for Controlling  the Grid Appearance of a Rose Plot </h2><span id='topic+grid.control'></span>

<h3>Description</h3>

<p>Defines the appearance of the guiding elements of rose plots such as
circles, rays and labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.control(circ.n = 4, circ.r = NULL,
             circ.col = "gray30", circ.lwd = 0.5,
             circ.cex = 0.8, circ.between = 0.3,
             circ.dir = pi/16 * 9,
             circ.sub.n = NULL, circ.sub.r = NULL,
             circ.sub.col = "gray70", circ.sub.lwd = 0.5,
             cyclVar.lab = c("N","NE","E","SE","S","SW","W","NW"),
             cyclVar.cex = 1.2, cyclVar.between = 0,
             cyclVar.centered = TRUE,
             ray.lim = NULL, ray.n = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.control_+3A_circ.n">circ.n</code>, <code id="grid.control_+3A_circ.r">circ.r</code></td>
<td>
<p> Number of (main)circles or, alternatively,
radius of circles to be drawn, which will be labeled.</p>
</td></tr>
<tr><td><code id="grid.control_+3A_circ.col">circ.col</code>, <code id="grid.control_+3A_circ.lwd">circ.lwd</code></td>
<td>
<p> Color and line width of circles. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_circ.cex">circ.cex</code></td>
<td>
<p> Character size of labels of main circles in
multiples of <code>cex</code> as defined in <code><a href="#topic+general.control">general.control</a></code>. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_circ.between">circ.between</code></td>
<td>
<p> Distance between labels of the main circle and the
circle itself in multiples of circ.cex. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_circ.dir">circ.dir</code></td>
<td>
<p> Direction along which the labels of the
main circles should be drawn, measured clockwise as radian
from North. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_circ.sub.n">circ.sub.n</code>, <code id="grid.control_+3A_circ.sub.r">circ.sub.r</code></td>
<td>
<p> Number of subcircle intervals
between two main circles, or, alternatively, the radii of <em>all</em>
subcircles. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_circ.sub.col">circ.sub.col</code>, <code id="grid.control_+3A_circ.sub.lwd">circ.sub.lwd</code></td>
<td>
<p> Color and line width of
subcircles. </p>
</td></tr> 
<tr><td><code id="grid.control_+3A_cyclvar.lab">cyclVar.lab</code></td>
<td>
<p> Labels of cyclic variable placed along the
outmost circle. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_cyclvar.cex">cyclVar.cex</code></td>
<td>
<p> Charactersize of labels of cyclic
variable in multiples of cex as defined in
<code><a href="#topic+general.control">general.control</a></code> </p>
</td></tr> 
<tr><td><code id="grid.control_+3A_cyclvar.between">cyclVar.between</code></td>
<td>
<p> Distance between labels of the cyclic
variable and the outmost circle of the rose in multiples of
<code>cyclVar.cex</code>. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_cyclvar.centered">cyclVar.centered</code></td>
<td>
<p> Labels are positioned relative
to their center.  <code>cyclVar.centered = FALSE</code> is used for very
long labels like (unabbreviated) days of the week.  In this case, the
labels are positioned relative to the side of the label, which is
closest to the circle. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_ray.lim">ray.lim</code></td>
<td>
<p> Defines the values for the center and the
maximum radius in user coordinates.  Be careful with specifying the
center different from 0 as this might result in misleading roses. </p>
</td></tr>
<tr><td><code id="grid.control_+3A_ray.n">ray.n</code></td>
<td>
<p> Number of rays. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the arguments conveniently packaged up in a list to supply the
arguments for the grid appearance of rose plot.
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.rose">plot.rose</a></code>, <code><a href="#topic+general.control">general.control</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.control()
</code></pre>

<hr>
<h2 id='humidity'>
Converting Humidity Measures into Each Other
</h2><span id='topic+hr'></span><span id='topic+pw'></span><span id='topic+pw.ai'></span><span id='topic+pw.aw'></span><span id='topic+Td'></span><span id='topic+Td.aw'></span><span id='topic+Tf.ai'></span>

<h3>Description</h3>

<p>Converting dew point (of water in air) into vapor pressure or relative humidity and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr(T, Td, warn = TRUE)
pw(Td, warn = TRUE)
pw.ai(Td, warn = TRUE)
pw.aw(Td, warn = TRUE)
Td(pw = NULL, T = NULL, hr = NULL, warn = TRUE)
Td.aw(pw = NULL, T = NULL, hr = NULL, warn = TRUE)
Tf.ai(pw = NULL, T = NULL, hr = NULL, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="humidity_+3A_hr">hr</code></td>
<td>

<p>Relative humidity in <code class="reqn">[\textnormal{\%}]</code>.
</p>
</td></tr>
<tr><td><code id="humidity_+3A_t">T</code></td>
<td>

<p>Temperature of air in <code class="reqn">[^\circ \textnormal{C}]</code>.
</p>
</td></tr>
<tr><td><code id="humidity_+3A_td">Td</code></td>
<td>

<p>Dew point of air in <code class="reqn">[^\circ \textnormal{C}]</code>.
</p>
</td></tr>
<tr><td><code id="humidity_+3A_pw">pw</code></td>
<td>

<p>Saturation vapour pressure in <code class="reqn">[\textnormal{hPa}]</code>.
</p>
</td></tr>
<tr><td><code id="humidity_+3A_warn">warn</code></td>
<td>

<p>When <code>TRUE</code> and arguments are out of range, a warning is thrown.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All vapour pressures correspond to pure water vapour and are not
adjusted to water vapour in air.
</p>


<h3>Value</h3>

<p><code>hr</code> transforms dew point above ice / water at a certain temperature into
relative humidity (<code class="reqn">-65^\circ\textnormal{C} &lt;= T &lt;=
    60^\circ\textnormal{C}</code>).<br />
<code>pw</code> transforms dew point into saturation vapour pressure above ice
(<code class="reqn">-65^\circ\textnormal{C} &lt;= T &lt;=
    0^\circ\textnormal{C}</code>)  and above water (<code class="reqn">0^\circ\textnormal{C} &lt; T &lt;=
    60^\circ\textnormal{C}</code>) respectively.<br />
<code>pw.ai</code> transforms dew point into saturation vapour
pressure above ice (<code class="reqn">-65^\circ\textnormal{C} &lt;= T &lt;=
    0^\circ\textnormal{C}</code>).<br />
<code>pw.aw</code> transforms dew point into saturation vapour
pressure above liquid water (<code class="reqn">-45^\circ\textnormal{C} &lt;= T &lt;=
    60^\circ\textnormal{C}</code>).<br />
<code>Td</code> transforms vapour pressure or relative humidity and
temperature into frost point above ice (<code class="reqn">-65^\circ\textnormal{C} &lt;= T &lt;=
    0^\circ\textnormal{C}</code>) and dew point above water (<code class="reqn">0^\circ\textnormal{C} &lt; T &lt;=
    60^\circ\textnormal{C}</code>) respectively.<br />
<code>Td.aw</code> transforms vapour pressure or relative humidity and
temperature into dew point above water (<code class="reqn">-45^\circ\textnormal{C} &lt;= T &lt;=
    60^\circ\textnormal{C}</code>).<br />
<code>Tf.ai</code> transforms vapour pressure or relative humidity and
temperature into frost point above ice (<code class="reqn">-65^\circ\textnormal{C} &lt;= T &lt;=
    0^\circ\textnormal{C}</code>).
</p>


<h3>Author(s)</h3>

<p>Rene Locher
</p>


<h3>References</h3>

<p>Guide to Meteorological Instruments and Methods of Observation, WMO,
WMO-No. 8, Seventh edition, 2008, updated 2010, 1.4-29 Annex 4.B
</p>


<h3>Examples</h3>

<pre><code class='language-R'> pw(Td = c(-65, -45, 0, 30, 60))
 Td(pw = pw(c(-20, 0, 20)))

 hr(T = c(20, 30, 40), Td = c(0, 20, 30))
 ## [1] 26.20257 55.09561 57.46519

 hr(T = seq(0, 60, 5), Td = 0)
</code></pre>

<hr>
<h2 id='IDPcolorRamp'>Color Ramp for Ordered Values</h2><span id='topic+IDPcolorRamp'></span>

<h3>Description</h3>

<p>Produces color ramps which change simultanously hues, saturation and
values as defined in the <code><a href="grDevices.html#topic+hsv">hsv</a></code> modus.  This
allows to produce especially smooth transitions from one color to the
next.  The default color ramp starts with light blue, continues with
green, yellow, red and ends with dark violet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDPcolorRamp(n,
             colInt = data.frame(h = c(0.47, 0.28, 0.16, 0, 1, 0.8),
                                 s = c(0.31, 0.55, 0.7, 0.8, 0.8, 1),
                                 v = c(1, 1, 1, 1, 1, 0.4)),
             fr = c(0.27, 0.27, 0.27, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IDPcolorRamp_+3A_n">n</code></td>
<td>
<p>Total number of different colors in color ramp.</p>
</td></tr>
<tr><td><code id="IDPcolorRamp_+3A_colint">colInt</code></td>
<td>
<p>Data.frame or matrix with the columns h,s &amp; v
which defines the Intervals for individual color subramps, with
nrow(colInt) = nsr+1 with nsr&gt;1.  See details</p>
</td></tr>
<tr><td><code id="IDPcolorRamp_+3A_fr">fr</code></td>
<td>
<p>Fraction of the colors in each of the first nsr-1 subramps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function distributes the number of colors in the subramps, given
the fractions fr, as smoothly as possible. The default arguments are
optimized to most distinct colors possible, also for very small
<code>n</code>. There is at least one color in the first and the last
subramp.<br />
Definition of hsv code:
</p>

<dl>
<dt><code>h</code></dt><dd><p>Hue of hsv-Signal: 0=red, 1/3=green, 2/3=blue, 1=red.</p>
</dd>
<dt><code>s</code></dt><dd><p>Saturation of hsv-Signal: 0=white, 1=full color.</p>
</dd>
<dt><code>v</code></dt><dd><p>Value of hsv-Signal: 0=black, 1=full color.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A vector of <code>n</code> colors.
</p>


<h3>Note</h3>

<p>If there are subramps which are not adjacent in the color space
(as is here the case for red and violet), you need a virtual subramp
(here from h=0.00 to h=1.00) with corresponding fraction fr == 0.</p>


<h3>Author(s)</h3>

<p>Rene Locher</p>


<h3>See Also</h3>

<p><code><a href="#topic+showColors">showColors</a></code>,
<code><a href="RColorBrewer.html#topic+ColorBrewer">ColorBrewer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IDPcolorRamp(10)

## Default IDPcolorRamp in 21 colors
n &lt;- 21
showColors(IDPcolorRamp(n),border=FALSE)

## colorRamp optimized to return at equidistant indices the colors
## light blue, light green, yellow, orange, red, dark violet
## works fine with n &gt; 7
cInt &lt;- data.frame(h = c(0.47, 0.28, 0.16, 0, 1, 0.8),
                   s = c(0.31, 0.55, 0.7, 0.8, 0.8, 1),
                   v = c(1, 1, 1, 1, 1, 0.5))

fr &lt;- c(0.15, 0.25, 0.45, 0.0)
ii &lt;- seq(1,n,length.out=6)

## colors at equidistant indices
showColors(IDPcolorRamp(n, colInt = cInt, fr =fr)[ii], border=FALSE)

## Alternative ramp in 21 colors
showColors(IDPcolorRamp(n, colInt = cInt, fr =fr), border=FALSE)
</code></pre>

<hr>
<h2 id='ilagplot'>Image Lag Plot Matrix for Large Time Series</h2><span id='topic+ilagplot'></span>

<h3>Description</h3>

<p>Produces an image lag plot matrix of large timeseries where the colors
encode the density of the points in the lag plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ilagplot(x, set.lags = 1,
         pixs = 1, zmax = NULL, ztransf = function(x){x},
         colramp = IDPcolorRamp, mfrow=NULL, cex=par("cex"),
         main = NULL, d.main = 1, cex.main = 1.5*par("cex.main"),
         legend = TRUE, d.legend = 1,
         cex.axis = par("cex.axis"), las = 1,
         border=FALSE, mar = c(2,2,2,0), oma = rep(0,4)+0.1,
         mgp = c(2,0.5,0)*cex.axis, tcl = -0.3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ilagplot_+3A_x">x</code></td>
<td>
<p>ts object or ordinary vector</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_set.lags">set.lags</code></td>
<td>
<p>vector of lags to be displayed</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_pixs">pixs</code></td>
<td>
<p>Pixel size in mm</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_zmax">zmax</code></td>
<td>
<p>Maximum counts per Pixel to be plotted.  When NULL each
lag plot has its individual scale.  If a number &gt;= maximum number of
counts per pixel is supplied, the scale will be identical for all
lag plots.  The maximum of the number per pixel is delivered by the
return value. Beware: <code>zmax</code> has its meaning only for ilagplots
with identical settings for main, legend, mar and oma!</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_ztransf">ztransf</code></td>
<td>
<p>Function to transform the counts.  The user has to make
sure that the transformed counts lie in the range [0,zmax], where
zmax is any positive number (&gt;=2).</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_colramp">colramp</code></td>
<td>
<p>Color ramp to encode the density of the points within a
pixel</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_mfrow">mfrow</code></td>
<td>
<p>See Argument <code>mfrow</code> in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="ilagplot_+3A_cex">cex</code></td>
<td>
<p>See Argument <code>cex</code> in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="ilagplot_+3A_main">main</code></td>
<td>
<p>Title</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_d.main">d.main</code></td>
<td>
<p>Vertical distance between upper border of scatter plots
and the title line in multiples of title height.</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_cex.main">cex.main</code></td>
<td>
<p>Magnification used for title relative to the current
setting of cex.</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_legend">legend</code></td>
<td>
<p>Logical. When <code>FALSE</code>, no legend is plotted and
space is saved in figure region. </p>
</td></tr>
<tr><td><code id="ilagplot_+3A_d.legend">d.legend</code></td>
<td>
<p>Horizontal distance between right border of scatter
plots and legend in multiples of title height.</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Magnification used for axis annotation
relative to the current setting of cex. </p>
</td></tr>
<tr><td><code id="ilagplot_+3A_las">las</code></td>
<td>
<p>Orientation of labels on axes.</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_border">border</code></td>
<td>
<p>Logical. When <code>TRUE</code>, a border is drawn around the
individual colors in the legend.</p>
</td></tr>
<tr><td><code id="ilagplot_+3A_mar">mar</code>, <code id="ilagplot_+3A_oma">oma</code></td>
<td>
<p>Margin and outer margin respectively.
Cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="ilagplot_+3A_mgp">mgp</code>, <code id="ilagplot_+3A_tcl">tcl</code></td>
<td>
<p>Cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="ilagplot_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code is based on R function <code><a href="stats.html#topic+lag.plot">lag.plot</a></code> V1.7.
Tip: Legend looks  better when <code>mar</code> is defined symmetrically.
</p>


<h3>Value</h3>

<p>Maximum number of counts per Pixel found.
</p>


<h3>Note</h3>

<p>When you get the error message &quot;Zmax too small! Densiest aereas
are out of range!&quot; you must run the function with identical parameters
but without specifying zmax. The value returned gives you the minimum
value allowed for zmax.</p>


<h3>Author(s)</h3>

<p>Andreas Ruckstuhl, refined by Rene Locher</p>


<h3>See Also</h3>

<p><code><a href="#topic+ipairs">ipairs</a></code>, <code><a href="#topic+iplot">iplot</a></code>,
<code><a href="#topic+Image">Image</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(SwissAir)) {
  data(AirQual)

  ilagplot(AirQual[,c("ad.O3")],set.lags = 1:4,
           ztransf = function(x){x[x&lt;1] &lt;- 1; log2(x)},
           main = "Low correlation")

  Ox &lt;- AirQual[,c("ad.O3","lu.O3","sz.O3")]+
    AirQual[,c("ad.NOx","lu.NOx","sz.NOx")]-
      AirQual[,c("ad.NO","lu.NO","sz.NO")]
  names(Ox) &lt;- c("ad","lu","sz")
  ilagplot(Ox$ad,set.lags = 1:4,
           ztransf = function(x){x[x&lt;1] &lt;- 1; log2(x)},
           main = "High correlation")

  ## cf. ?AirQual for the explanation of the physical
  ## and chemical background
} else print("Package SwissAir is not available")
</code></pre>

<hr>
<h2 id='Image'>Display the Density of Points in a Scatter Plot by Colors</h2><span id='topic+Image'></span>

<h3>Description</h3>

<p>The density of points in a scatter plot is encoded by color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Image(x, y = NULL, pixs = 1, zmax = NULL, ztransf = function(x){x},
      colramp = IDPcolorRamp, factors = c(FALSE, FALSE),
      matrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Image_+3A_x">x</code>, <code id="Image_+3A_y">y</code></td>
<td>
<p>Coordinates of points whose density is plotted.  If
<code>x</code> is a matrix or a data.frame, the first two column are used
as x and y respectively.  <code>y</code> must be in this case NULL.
<code>x</code> and <code>y</code> may be numeric or factor variable.</p>
</td></tr>
<tr><td><code id="Image_+3A_pixs">pixs</code></td>
<td>
<p>Size of pixel in x- and y-direction in [mm] on the
plotting device.  When <code>x</code> and <code>y</code> are numeric,
pixels are square.  When <code>x</code> and <code>y</code> are factors or should
be handled as factors  (see argument <code>factors</code>), pixels are no
longer square.  The pixels are enlarged in the dimension in which the
factors are displayed, so that the rectangular pixels are centered
at the factor levels.</p>
</td></tr>
<tr><td><code id="Image_+3A_zmax">zmax</code></td>
<td>
<p>Maximum number of counts per pixel in the plot.  When
<code>NULL</code>, the density in the scatter plot is encoded from 0
to maximum number of counts per pixel observed.  <code>zmax</code> must be
equal or larger than maximum number of counts found. The maximum
number of counts per pixel is delivered by the return value.</p>
</td></tr>
<tr><td><code id="Image_+3A_ztransf">ztransf</code></td>
<td>
<p>Function to transform the number of counts per
pixel, which will be mapped by the function in
<code>colramp</code> to well defined colors.  The user
has to make  sure that the transformed density lies in the range
[0,zmax], where zmax is any positive number (&gt;=2).  For examples see
<code><a href="#topic+ipairs">ipairs</a></code> and <code><a href="#topic+ilagplot">ilagplot</a></code>.</p>
</td></tr>
<tr><td><code id="Image_+3A_colramp">colramp</code></td>
<td>
<p>Color ramp to encode the number of the counts within a
pixel by color.</p>
</td></tr>
<tr><td><code id="Image_+3A_factors">factors</code></td>
<td>
<p>Vector of logicals indicating whether <code>x</code> and / or
<code>y</code> should be handled as factors
independently of their <code>class</code>.</p>
</td></tr>
<tr><td><code id="Image_+3A_matrix">matrix</code></td>
<td>
<p>Boolean. Should all counts be returned in a xyz-matrix
or just the maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before calling <code>Image</code> a plot must have been created by, e.g.,
calling <code>plot(x,y,type="n")</code>.  This function ensures
by default that the pixel has the same size in x- and y-direction.  As
a drawback, pixels may be unequally spaced, when there are only very
few distinct (integer) values in x- or y-direction.  When this is the
case, the corresponding dimension should be declared as a factor.
(cf. argument <code>factors</code>). <br />
</p>
<p>This function is based on <span class="pkg"><a href="graphics.html#topic+graphics">graphics</a></span>
</p>


<h3>Value</h3>

<p>Maximum number of counts per pixel found (<code>matrix = FALSE</code>) or
the full matrix.</p>


<h3>Author(s)</h3>

<p>Andreas Ruckstuhl, Rene Locher</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ipairs">ipairs</a></code>, <code><a href="#topic+ilagplot">ilagplot</a></code>,
<code><a href="#topic+iplot">iplot</a></code>, <code><a href="graphics.html#topic+image">image</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot.default(iris$Species, iris$Petal.Width, xlim=c(0.5,3.5),
             type="n", axes=FALSE)
axis(1, at=1:3, labels=levels(iris$Species))
axis(2)
Image(iris$Species, iris$Petal.Width, pixs=3)

##
x &lt;- rnorm(10000)
y &lt;- rnorm(10000, 10)
plot(x+y, y, type="n")
Image(x+y, y)
abline(a=0, b=1)

## The above can be merged to
iplot(x+y, y, legend=FALSE, oma=c(5, 4, 4, 2) + 0.1)
abline(a=0, b=1)
</code></pre>

<hr>
<h2 id='internals'>Internal Functions</h2><span id='topic+rose.grob'></span><span id='topic+plotdat'></span><span id='topic+plotPage'></span><span id='topic+iplotMain'></span><span id='topic+segments.circle'></span><span id='topic+griddat'></span>

<h3>Description</h3>

<p>These functions are for internal use only and not documented further.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
iplotMain(main, cex.main, cex)

plotPage(y1, y2, names1, names2,
         startP, upf, fpp, overlap,
         x.at, x.ann, x.tick,
         y1.at, y1.ann, y1.tick,
         y2.at, y2.ann, y2.tick,
         ny.ann, cex.ann, xlab, y1lab, y2lab, las,
         col.y1, col.y2,
         cex.lab, y1lim, y2lim, lty1, lty2, lwd1, lwd2, col1, col2,
         leg, y1nam.leg, y2nam.leg, ncol.leg, cex.leg = 1.5,
         h1, h2, col.h1, col.h2,
         mgp, main, cex.main, xpd, cex,
         type1, type2, pch1, pch2, cex.pt1, cex.pt2)

rose.grob(rho, cyclVar, circle, transf, general, grid, title, gdat)

segments.circle(rho, shift, circle = 360, ncp = 1000, gp = gpar())

griddat(rho, cyclVar, circle, vp, grid, title)

plotdat(rho, cyclVar, circle, transf, general, grid)
</code></pre>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Functions </td><td style="text-align: left;"> used in</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>iplotMain</code> </td><td style="text-align: left;"> <code><a href="#topic+ipairs">ipairs</a></code>,
    <code><a href="#topic+ilagplot">ilagplot</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>plot.page</code> </td><td style="text-align: left;"> <code><a href="#topic+longtsPlot">longtsPlot</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rose.grob</code> </td><td style="text-align: left;"> <code><a href="#topic+plot.rose">plot.rose</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>segments.circle</code> </td><td style="text-align: left;"> <code><a href="#topic+rose.grob">rose.grob</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>griddat</code> </td><td style="text-align: left;"> <code><a href="#topic+plot.rose">plot.rose</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>plotdat</code> </td><td style="text-align: left;"> <code><a href="#topic+plot.rose">plot.rose</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Rene Locher</p>

<hr>
<h2 id='ipairs'>Image Scatter Plot Matrix for Large Datasets</h2><span id='topic+ipairs'></span>

<h3>Description</h3>

<p>Produces an image scatter plot matrix of large datasets where the colors
encode the density of the points in the scatter plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipairs(x,
       pixs = 1, zmax = NULL, ztransf=function(x){x},
       colramp = IDPcolorRamp, cex = par("cex"),
       lab.diag, cex.diag = NULL,
       main = NULL, d.main = 1.5, cex.main = 1.5*par("cex.main"),
       legend = TRUE, d.legend = 1.5, cex.axis = 0.8*par("cex.axis"),
       nlab.axis = 5, minL.axis = 2, las = 1, border = FALSE,
       mar = rep(0,4), oma = c(3,3,1,0), mgp = c(2,0.5,0)*cex.axis,
       tcl = -0.3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipairs_+3A_x">x</code></td>
<td>
<p>data.frame or matrix</p>
</td></tr>
<tr><td><code id="ipairs_+3A_pixs">pixs</code></td>
<td>
<p>Pixel size in mm on the plotting device.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_zmax">zmax</code></td>
<td>
<p>Maximum number of counts per pixel in the plot.  When NULL,
each scatter plot has its individual scale.  If a number &gt;= maximum
number of counts per pixel is supplied, the scale will be identical
for all scatter plots.  The maximum number of counts per pixel is
delivered by the return value.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_ztransf">ztransf</code></td>
<td>
<p>Function to transform the counts per
pixel, which will be mapped by the function in
<code>colramp</code> to well defined colors. The user has to make
sure that the transformed counts lie in the range [0,zmax], where
zmax is any positive number (&gt;=2).</p>
</td></tr>
<tr><td><code id="ipairs_+3A_colramp">colramp</code></td>
<td>
<p>Color ramp to encode the number of counts within a
pixel.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_cex">cex</code></td>
<td>
<p>See Argument <code>cex</code> in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="ipairs_+3A_lab.diag">lab.diag</code></td>
<td>
<p>Labels of columns, written into the diagonal of the
matrix. When  <code>NULL</code>, the names of x are used.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_cex.diag">cex.diag</code></td>
<td>
<p>Magnification used for text in diagonal  relative to
the current setting of cex.
When  <code>NULL</code>, they are calculated automatically.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_main">main</code></td>
<td>
<p>Titel. When <code>NULL</code></p>
</td></tr>
<tr><td><code id="ipairs_+3A_d.main">d.main</code></td>
<td>
<p>Vertical distance between upper border of scatter plots
and the title line in multiples of title height.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_cex.main">cex.main</code></td>
<td>
<p>Magnification used for title relative to the current
setting of cex.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_legend">legend</code></td>
<td>
<p>Logical. When <code>FALSE</code>, no legend is plotted and
space is saved in figure region. </p>
</td></tr>
<tr><td><code id="ipairs_+3A_d.legend">d.legend</code></td>
<td>
<p>Horizontal distance between right border of scatter
plots and legend in multiples of title height.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Magnification used for axis annotation
relative to the current setting of cex. </p>
</td></tr>
<tr><td><code id="ipairs_+3A_nlab.axis">nlab.axis</code></td>
<td>
<p>Approximate number of labels on axes.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_minl.axis">minL.axis</code></td>
<td>
<p>The minimum length of the abbreviations of factor
levels, used to label the axes ticks.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_las">las</code></td>
<td>
<p>Orientation of labels on axes.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_border">border</code></td>
<td>
<p>Logical. When <code>TRUE</code>, a border is drawn around the
individual colors in the legend.</p>
</td></tr>
<tr><td><code id="ipairs_+3A_mar">mar</code>, <code id="ipairs_+3A_oma">oma</code></td>
<td>
<p>Margin and outer margin respectively.
Cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="ipairs_+3A_mgp">mgp</code>, <code id="ipairs_+3A_tcl">tcl</code></td>
<td>
<p>Cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="ipairs_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea is similar to <code><a href="hexbin.html#topic+gplot.hexbin">gplot.hexbin</a></code>.  The
hexagons are better suited to reflect the density of points in a plane
than the squares used here.  Nevertheless squares are, contrary to
hexagons, invariant to reflexions at the x- <em>and</em> y-axis and
therefore better suited for scatter plot matrices and also for
plotting factors.
</p>
<p>The code is based on R function <code><a href="graphics.html#topic+pairs">pairs</a></code> V1.7.
</p>


<h3>Value</h3>

<p>Maximum number of counts per Pixel found.  Additional elements are
returned when <code>verbose == TRUE</code>.
</p>


<h3>Note</h3>

<p>When you get the error message &quot;Zmax too small! Densiest aereas
are out of range!&quot; you must run the function with identical parameters
but without specifying zmax. The value returned gives you the minimum
value allowed for zmax.</p>


<h3>Author(s)</h3>

<p>Andreas Ruckstuhl, Rene Locher</p>


<h3>See Also</h3>

<p><code><a href="#topic+ilagplot">ilagplot</a></code>, <code><a href="#topic+iplot">iplot</a></code>,
<code><a href="#topic+Image">Image</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Small numbers of different values are plotted nicer
## when converted to factors
AQ &lt;- airquality
AQ$Month &lt;- as.factor(AQ$Month)

zmax &lt;- ipairs(AQ, pixs=2, main="Air Quality")
ipairs(AQ, pixs=2, zmax=zmax, main="Air Quality",border=TRUE)

## example with factors
ipairs(iris,pixs=2)

## a really huge dataset
## Not run: 
  if(require(SwissAir)) {
    data(AirQual)

    ## low correlation
    dev.new()
    ipairs(AirQual[,c("ad.O3","lu.O3","sz.O3")],
    ztransf=function(x){x[x&lt;1] &lt;- 1; log2(x)})
    
    dev.new()
    ipairs(AirQual[,c("ad.NO","lu.NO","sz.NO")],
    ztransf=function(x){x[x&lt;1] &lt;- 1; log2(x)})
    
    ## high correlation
    Ox &lt;- AirQual[,c("ad.O3","lu.O3","sz.O3")]+
    AirQual[,c("ad.NOx","lu.NOx","sz.NOx")]-
    AirQual[,c("ad.NO","lu.NO","sz.NO")]
    names(Ox) &lt;- c("ad","lu","sz")
    dev.new()
    ipairs(Ox, ztransf=function(x){x[x&lt;1] &lt;- 1; log2(x)})

    ## cf. ?AirQual for the explanation of the physical and
    ## chemical background
  } else print("Package SwissAir is not available")

## End(Not run)
</code></pre>

<hr>
<h2 id='ipanel.smooth'> Panelplot for itermplot </h2><span id='topic+ipanel.smooth'></span>

<h3>Description</h3>

<p>An example of a useful panel function for huge datasets</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipanel.smooth(x, y = NULL, pixs = 1, zmax = NULL,
              ztransf = function(x) {x},
              colramp = IDPcolorRamp, col = "black", lwd = 2,
              span = 2/3, iter = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipanel.smooth_+3A_x">x</code>, <code id="ipanel.smooth_+3A_y">y</code></td>
<td>
<p> Numeric vectors of the same length. </p>
</td></tr>
<tr><td><code id="ipanel.smooth_+3A_pixs">pixs</code></td>
<td>
<p> Size of pixel in x- and y-direction in [mm] on the
plotting device. When x and y are numeric, pixels are square.  When x
and y are factors, pixels are no longer square.  The pixels are
enlarged in x-direction. </p>
</td></tr>
<tr><td><code id="ipanel.smooth_+3A_zmax">zmax</code></td>
<td>
<p> Maximum number of counts per Pixel in the plot. When
NULL, the density in the scatter plot is encoded from 0 pixel to
maximum number of counts observed.  zmax must be equal or larger than
maximum number of counts found. </p>
</td></tr>
<tr><td><code id="ipanel.smooth_+3A_ztransf">ztransf</code></td>
<td>
<p> Function to transform the number of counts per pixel,
which will be mapped by the function in <code>colramp</code> to well
defined colors.  The user has to make sure that the transformed
density lies in the range [0,zmax], where zmax is any positive
number (&gt;=2).  For examples see <code><a href="#topic+ipairs">ipairs</a></code> and
<code><a href="#topic+ilagplot">ilagplot</a></code>.</p>
</td></tr>
<tr><td><code id="ipanel.smooth_+3A_colramp">colramp</code></td>
<td>
<p> Color ramp to encode the number of counts within
a pixel by color. </p>
</td></tr>
<tr><td><code id="ipanel.smooth_+3A_col">col</code>, <code id="ipanel.smooth_+3A_lwd">lwd</code></td>
<td>
<p> Color and line width of the &ldquo;smoothed curve&rdquo;. </p>
</td></tr>
<tr><td><code id="ipanel.smooth_+3A_span">span</code></td>
<td>
<p> the smoother span. This gives the proportion of points in
the plot which influence the smooth at each value. Larger values
give more smoothness. </p>
</td></tr>
<tr><td><code id="ipanel.smooth_+3A_iter">iter</code></td>
<td>
<p> The number of robustifying iterations which should be
performed. Using smaller values of iter will make lowess run
faster. </p>
</td></tr>
<tr><td><code id="ipanel.smooth_+3A_...">...</code></td>
<td>
<p> Other graphical parameters as arguments to the
<code><a href="graphics.html#topic+lines">lines</a> function. </code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+lowess">lowess</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r.lm &lt;- lm(Sepal.Length~Sepal.Width+Petal.Length+Petal.Width+Species,
           data = iris)
par(mfrow = c(2,2), pty = "s")
itermplot(r.lm, se = TRUE, partial.res = TRUE, smooth = ipanel.smooth,
          lwd.smth = 3, pixs = 2, ask = FALSE)

if (require(SwissAir)) {
  par(mfrow = c(1,1))
  dat &lt;- log(AirQual[,c("ad.O3", "ad.WS")])
  pairs(dat,
        panel = ipanel.smooth)
} else print("Package SwissAir is not available")

</code></pre>

<hr>
<h2 id='iplot'>Image Scatter Plot for Large Datasets</h2><span id='topic+iplot'></span>

<h3>Description</h3>

<p>Produces an image scatter plot of large datasets where the colors
encode the density of the points in the scatter plot.  Works also with factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iplot(x, y = NULL,
      pixs = 1, zmax = NULL, ztransf = function(x){x},
      colramp = IDPcolorRamp, cex = par("cex"),
      main = NULL, d.main = 1, cex.main = par("cex.main"),
      xlab = NULL, ylab = NULL, cex.lab = 1,
      legend = TRUE, d.legend = 1,
      cex.axis = par("cex.axis"), nlab.xaxis = 5, nlab.yaxis = 5,
      minL.axis = 3, las = 1, border = FALSE,
      oma = c(5,4,1,0)+0.1, mgp = c(2,0.5,0)*cex.axis, tcl = -0.3, ...
      )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iplot_+3A_x">x</code>, <code id="iplot_+3A_y">y</code></td>
<td>
<p>Coordinates of points whose density is to be plotted.  If
<code>x</code> ist a matrix or a data.frame, the first two column are used
as x and y respectively.  <code>y</code> must be in this case NULL.
<code>x</code> and <code>y</code> may be numeric or factor variable. </p>
</td></tr>
<tr><td><code id="iplot_+3A_pixs">pixs</code></td>
<td>
<p>Pixelsize in mm.</p>
</td></tr>
<tr><td><code id="iplot_+3A_zmax">zmax</code></td>
<td>
<p>Maximum number of counts per pixel in the plot.  When
<code>NULL</code>, the density in the scatter plot is encoded from 0
to maximum number of counts per pixel observed.  <code>zmax</code> must be
equal or larger than maximum number of counts found.  The maximum
number of counts per pixel is delivered by the return value.</p>
</td></tr>
<tr><td><code id="iplot_+3A_ztransf">ztransf</code></td>
<td>
<p>Function to transform the number of counts per
pixel, which will be mapped by the function in  <code>colramp</code> to
well defined colors.  The user
has to make  sure that the transformed density lies in the range
[0,zmax], where zmax is any positive number (&gt;=2).  For examples see
<code><a href="#topic+ipairs">ipairs</a></code> and <code><a href="#topic+ilagplot">ilagplot</a></code>.</p>
</td></tr>
<tr><td><code id="iplot_+3A_colramp">colramp</code></td>
<td>
<p>Color ramp to encode the number of counts within a
pixel.</p>
</td></tr>
<tr><td><code id="iplot_+3A_cex">cex</code></td>
<td>
<p>Magnification of text relative to default.</p>
</td></tr>
<tr><td><code id="iplot_+3A_main">main</code></td>
<td>
<p>Title.</p>
</td></tr>
<tr><td><code id="iplot_+3A_d.main">d.main</code></td>
<td>
<p>Vertical distance between upper border of scatter plots
and the title line in multiples of title height.</p>
</td></tr>
<tr><td><code id="iplot_+3A_cex.main">cex.main</code></td>
<td>
<p>Magnification used for title relative to the current
setting of cex.</p>
</td></tr>
<tr><td><code id="iplot_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="iplot_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="iplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Magnification used for text in axis labels relative to
the current setting of cex</p>
</td></tr>
<tr><td><code id="iplot_+3A_legend">legend</code></td>
<td>
<p>Logical. When <code>FALSE</code>, no legend is plotted and
space is saved in figure region. </p>
</td></tr>
<tr><td><code id="iplot_+3A_d.legend">d.legend</code></td>
<td>
<p>Horizontal distance between right border of
scatter plot and legend in multiples of title height.</p>
</td></tr>
<tr><td><code id="iplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Magnification used for axis annotation
relative to the current setting of cex. </p>
</td></tr>
<tr><td><code id="iplot_+3A_nlab.xaxis">nlab.xaxis</code>, <code id="iplot_+3A_nlab.yaxis">nlab.yaxis</code></td>
<td>
<p>Approximate number of labels on x- and
y-axes respectively.</p>
</td></tr>
<tr><td><code id="iplot_+3A_minl.axis">minL.axis</code></td>
<td>
<p>The minimum length of the abbreviations of factor
levels, used to label the axes ticks.</p>
</td></tr>
<tr><td><code id="iplot_+3A_las">las</code></td>
<td>
<p>Orientation of labels on axes.</p>
</td></tr>
<tr><td><code id="iplot_+3A_border">border</code></td>
<td>
<p>Logical. When <code>TRUE</code>, a border is drawn around the
individual colors in the legend.</p>
</td></tr>
<tr><td><code id="iplot_+3A_oma">oma</code></td>
<td>
<p>Outer margin. Cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="iplot_+3A_mgp">mgp</code>, <code id="iplot_+3A_tcl">tcl</code></td>
<td>
<p>Cf. <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="iplot_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea of this plot is similar to
<code><a href="hexbin.html#topic+gplot.hexbin">gplot.hexbin</a></code>.  The
hexagons are better suited to reflect the density of points in a plane
than the squares used here.  Nevertheless squares are, contrary to
hexagons, invariant to reflexions at the x- <em>and</em> y-axis and
therefore suited for scatter plot matrices and also for plotting
factors.
</p>


<h3>Value</h3>

<p>Maximum number of counts per Pixel found.
</p>


<h3>Note</h3>

<p>When you get the error message &quot;Zmax too small! Densiest aereas
are out of range!&quot; you must run the function again without specifying
zmax.  The value returned gives you the minimum value allowed for zmax.</p>


<h3>Author(s)</h3>

<p>Andreas Ruckstuhl, Rene Locher</p>


<h3>See Also</h3>

<p><code><a href="#topic+ilagplot">ilagplot</a></code>, <code><a href="#topic+ipairs">ipairs</a></code>, <code><a href="#topic+Image">Image</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-  rnorm(10000)
y &lt;- atan(rnorm(10000, 0))
iplot(x, y)
iplot(x, pixs = 2)

oma &lt;- c(5,5,0,0)
iplot(iris[,1:2], pixs = 4, oma = oma)
iplot(iris[,"Petal.Width"], iris[,"Species"], pixs = 4, oma = oma)
iplot(x = iris[,"Species"], y = iris[,"Petal.Width"], pixs = 10,border = TRUE,
        xlab = "Species",
        ylab = "Petal Width",
        main = "Iris Species and Petal Width", oma = oma)

iplot(iris$Species, iris$Petal.Width,pixs = 3, minL.axis = 10,
      oma = c(3,6,0,0), mgp = c(4, 1, 0),
      cex.axis = 2, cex.lab = 2, cex.main = 2, main = "Larger fonts")
</code></pre>

<hr>
<h2 id='iplotLegend'> Plots Legend for Color Ramp</h2><span id='topic+iplotLegend'></span>

<h3>Description</h3>

<p>Plots legend for color ramp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iplotLegend(colramp, ncol = NULL,
            cex.axis = par("cex.axis"), border = FALSE,
            mar = c(0, 0, 0, 3), las = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iplotLegend_+3A_colramp">colramp</code></td>
<td>
<p> Function defining color ramp,
e.g. <code><a href="#topic+IDPcolorRamp">IDPcolorRamp</a></code> </p>
</td></tr>
<tr><td><code id="iplotLegend_+3A_ncol">ncol</code></td>
<td>
<p> Number of individual colors in color ramp. See details. </p>
</td></tr>
<tr><td><code id="iplotLegend_+3A_cex.axis">cex.axis</code></td>
<td>
<p> Magnification to be used for labels. </p>
</td></tr>
<tr><td><code id="iplotLegend_+3A_border">border</code></td>
<td>
<p> Logical. When <code>TRUE</code>, a border is drawn around
the individual colors in the legend. </p>
</td></tr>
<tr><td><code id="iplotLegend_+3A_mar">mar</code></td>
<td>
<p> Margin. See <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="iplotLegend_+3A_las">las</code></td>
<td>
<p> Orientation of labels on axis. See <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="iplotLegend_+3A_...">...</code></td>
<td>
<p> Additional arguments to <code>par</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A color ramp of <code>ncol+1</code> individual colors is plotted, starting
with the background color (= color 0).
When <code>ncol = NULL</code> a color ramp of 101 individual colors is
plotted. The color at the bottom is labeled by '0', the color at the
top by 'max'.
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
par(oma = rep(2, 4))
layout(matrix(c(1, 2), ncol = 2),
      width = c(lcm(par("csi")*5*2.54), 1),
      heights = 1)
## End(Not run)
iplotLegend(IDPcolorRamp, ncol = 15)
</code></pre>

<hr>
<h2 id='itermplot'> Plot Regression Terms for Huge Datasets </h2><span id='topic+itermplot'></span>

<h3>Description</h3>

<p>Plots regression terms against their predictors, optionally with
standard errors and partial residuals in a density plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itermplot(model, data = NULL, envir = environment(formula(model)),
          partial.resid = FALSE, scale=0, pixs = 1,
          zmax=NULL, ztransf = function(x) {x}, colramp = IDPcolorRamp,
          terms = NULL, se = FALSE,
          xlabs = NULL, ylabs = NULL, main = NULL,
          col.term = "black", lwd.term = 2,
          col.se = "gray", lty.se = 2, lwd.se = 1,
          col.smth = "darkred", lty.smth = 2,
          lwd.smth = 2, span.smth = 2/3,
          ask = interactive() &amp;&amp; nb.fig &lt; n.tms &amp;&amp;
                .Device != "postscript",
          use.factor.levels = TRUE, smooth = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itermplot_+3A_model">model</code></td>
<td>
<p> Fitted model object </p>
</td></tr>
<tr><td><code id="itermplot_+3A_data">data</code></td>
<td>
<p> Data frame in which variables in model can be found </p>
</td></tr>
<tr><td><code id="itermplot_+3A_envir">envir</code></td>
<td>
<p> Environment in which variables in model can be found </p>
</td></tr>
<tr><td><code id="itermplot_+3A_partial.resid">partial.resid</code></td>
<td>
<p> Logical; should partial residuals be plotted? </p>
</td></tr>
<tr><td><code id="itermplot_+3A_scale">scale</code></td>
<td>
<p> A lower limit for the number of units covered by the
limits on the &lsquo;y&rsquo; for each plot. The default is <code>scale = 0</code>, in
which case each plot uses the range of the functions being plotted
to create their ylim. By setting scale to be the maximum value of
diff(ylim) or above for all the plots, then all subsequent plots
will be produced in the same vertical units. This is essential for
comparing the importance of fitted terms in additive models. </p>
</td></tr>
<tr><td><code id="itermplot_+3A_pixs">pixs</code></td>
<td>
<p> Size of pixel in x- and y-direction in [mm] on the
plotting device. When x and y are numeric, pixels are square. When x
and y are factors, pixels are no longer square. The pixels are
enlarged in x-direction. </p>
</td></tr>
<tr><td><code id="itermplot_+3A_zmax">zmax</code></td>
<td>
<p> Maximum number of counts per pixel in the plot.  When
NULL, each scatter plot has its individual scale.  If a number &gt;=
maximum number of counts per pixel is supplied, the scale will be
identical for all scatter plots.  The maximum number of counts per
pixel is delivered by the return value. </p>
</td></tr>
<tr><td><code id="itermplot_+3A_ztransf">ztransf</code></td>
<td>
<p> Function to transform the number of counts per pixel.
The user has to make sure that the transformed density lies in the
range [0,zmax], where zmax is any positive number (&gt;=2).  For
examples see <code><a href="#topic+ipairs">ipairs</a></code> and <code><a href="#topic+ilagplot">ilagplot</a></code>.</p>
</td></tr>
<tr><td><code id="itermplot_+3A_colramp">colramp</code></td>
<td>
<p> Color ramp to encode the number of counts within a
pixel by color. </p>
</td></tr>
<tr><td><code id="itermplot_+3A_terms">terms</code></td>
<td>
<p> Numeric. Which terms to plot (default NULL means all
terms) </p>
</td></tr>
<tr><td><code id="itermplot_+3A_se">se</code></td>
<td>
<p> Logical. Plot pointwise standard errors? </p>
</td></tr>
<tr><td><code id="itermplot_+3A_xlabs">xlabs</code></td>
<td>
<p> Vector of labels for the x axes </p>
</td></tr>
<tr><td><code id="itermplot_+3A_ylabs">ylabs</code></td>
<td>
<p> Vector of labels for the y axes </p>
</td></tr>
<tr><td><code id="itermplot_+3A_main">main</code></td>
<td>
<p> Logical, or vector of main titles; if TRUE, the model's
call is taken as main title, NULL or FALSE mean no titles. </p>
</td></tr>
<tr><td><code id="itermplot_+3A_col.term">col.term</code>, <code id="itermplot_+3A_lwd.term">lwd.term</code></td>
<td>
<p> Color and line width for the &ldquo;term
curve&rdquo; </p>
</td></tr>
<tr><td><code id="itermplot_+3A_col.se">col.se</code>, <code id="itermplot_+3A_lty.se">lty.se</code>, <code id="itermplot_+3A_lwd.se">lwd.se</code></td>
<td>
<p> Color, line type and line width for the
&ldquo;twice-standard-error curve&rdquo; when se = TRUE. </p>
</td></tr>
<tr><td><code id="itermplot_+3A_col.smth">col.smth</code>, <code id="itermplot_+3A_lty.smth">lty.smth</code>, <code id="itermplot_+3A_lwd.smth">lwd.smth</code></td>
<td>
<p> Color, line type and line width
for the smoothed curve</p>
</td></tr>
<tr><td><code id="itermplot_+3A_span.smth">span.smth</code></td>
<td>
<p> Smoothing parameter f for <code><a href="stats.html#topic+lowess">lowess</a></code>.</p>
</td></tr>
<tr><td><code id="itermplot_+3A_ask">ask</code></td>
<td>
<p> Logical. Should user be asked before each plot? cf.
<code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="itermplot_+3A_use.factor.levels">use.factor.levels</code></td>
<td>
<p> Logical. Should x-axis ticks use factor
levels or numbers for factor terms? </p>
</td></tr>
<tr><td><code id="itermplot_+3A_smooth">smooth</code></td>
<td>
<p> NULL or a function with the same arguments as
<code><a href="#topic+ipanel.smooth">ipanel.smooth</a></code> to draw a smooth through the partial
residuals for non-factor terms </p>
</td></tr>
<tr><td><code id="itermplot_+3A_...">...</code></td>
<td>
<p> Other graphical parameters  </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>itermplot</code> is a modified version of
<code><a href="stats.html#topic+termplot">termplot</a></code> of R V2.3.1. Partial residuals are
displayed here as a density plot and is therfore especially suited for
models of huge datasets.
The model object must have a predict method that accepts type=terms,
eg glm in the base package, coxph and survreg in the survival
package.
</p>
<p>For the partial.resid=TRUE option it must have a residuals method that
accepts type=&quot;partial&quot;, which <code><a href="stats.html#topic+lm">lm</a></code>,  <code><a href="stats.html#topic+glm">glm</a></code> and
<code><a href="mgcv.html#topic+gam">gam</a></code> do.
</p>
<p>The data argument should rarely be needed, but in some cases termplot
may be unable to reconstruct the original data frame. Using
na.action=na.exclude makes these problems less likely.
</p>
<p>Nothing sensible happens for interaction terms.
</p>


<h3>Value</h3>

<p>Maximum number of counts per pixel found.
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+termplot">termplot</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>r.lm &lt;- lm(Sepal.Length~Sepal.Width+Petal.Length+Petal.Width+Species,
           data=iris)
par(mfrow=c(2,2),pty="s")
itermplot(r.lm, se = TRUE, partial.res=TRUE, lwd.term = 3,
          lwd.se = 2, pixs = 2)

if (require(SwissAir)) {
  data(AirQual)
  r.lm &lt;- lm(log(ad.O3)~log(ad.NOx)+ad.T+ad.Td+ad.WS, data=AirQual)
  par(mfrow=c(2,2),pty="s")
  itermplot(r.lm, se = TRUE, partial.resid=TRUE, smooth=ipanel.smooth,
            lwd.smth = 3, pixs = 1, ask=FALSE)
} else print("Package SwissAir is not available")

</code></pre>

<hr>
<h2 id='key.control'> Auxilary for Controlling the Appearance of the Legend of a Rose
Plot </h2><span id='topic+key.control'></span>

<h3>Description</h3>

<p>Defines the appearance of the legend of a Rose Plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>key.control(plot = TRUE, lab = NULL, title = NULL, between = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="key.control_+3A_plot">plot</code></td>
<td>
<p> Defines whether legend should be drawn.  When
<code>FALSE</code>, the full width of the viewport is used for the rose itself.  </p>
</td></tr>
<tr><td><code id="key.control_+3A_lab">lab</code>, <code id="key.control_+3A_title">title</code></td>
<td>
<p> Labels and title of
legend. When <code>lab = NULL</code>, labels are extracted from the
names of the slot <code>x@rho</code> of <code><a href="#topic+rose">rose</a></code> object. </p>
</td></tr>
<tr><td><code id="key.control_+3A_between">between</code></td>
<td>
<p>Distance between label East and left edge of legend in
<code>cex</code> as defined in <code><a href="#topic+general.control">general.control</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the arguments conveniently packaged up in a list to supply the
arguments for the legend in <code><a href="#topic+plot.rose">plot.rose</a></code>
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>key.control()
</code></pre>

<hr>
<h2 id='longtsPlot'> Plot Very Long Regular Time Series </h2><span id='topic+longtsPlot'></span>

<h3>Description</h3>

<p>Plot one or more regular time series in multiple figures on one or
more pages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longtsPlot(y1, y2 = NULL,
           names1 = NULL, names2 = NULL,
           startP = start(y1)[1], upf = 400, fpp = 4, overlap = 20,
           x.at = NULL, x.ann = NULL, x.tick = NULL,
           y1.at = NULL, y1.ann = NULL, y1.tick = NULL,
           y2.at = NULL, y2.ann = NULL, y2.tick = NULL,
           nx.ann = 10, ny.ann = 3, cex.ann = par("cex.axis"),
           xlab = "", y1lab = "", y2lab = "", las = 0,
           col.y1 = "black", col.y2 = col.y1,
           cex.lab = par("cex.lab"),
           y1lim = range(y1, na.rm = TRUE, finite=TRUE),
           y2lim = range(y2, na.rm = TRUE, finite=TRUE),
           lty1 = 1, lty2 = 2, lwd1 = 1, lwd2 = lwd1,
           col1 = NULL, col2 = NULL,
           leg = TRUE, y1nam.leg = NULL, y2nam.leg = NULL,
           ncol.leg = NULL, cex.leg = par("cex"),
           h1 = NULL, h2 = NULL, col.h1 = "gray70", col.h2 = "gray70",
           main = NULL, cex.main = par("cex.main"),
           automain = is.null(main),
           mgp = c(2, 0.7, 0), mar = c(2,3,1,3)+.2,
           oma = if (automain|!is.null(main))
                             c(0,0,2,0) else par("oma"),
           xpd = par("xpd"), cex = par("cex"),
           type1 = "s", type2 = type1,
           pch1 = 46, pch2 = pch1, cex.pt1 = 2, cex.pt2 = cex.pt1,
           slide = FALSE, each.fig = 1,
           filename = NULL, extension = NULL, filetype = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longtsPlot_+3A_y1">y1</code>, <code id="longtsPlot_+3A_y2">y2</code></td>
<td>
<p> Regular time series, time series matrices or ordinary
vectors, dataframes or matrices with values corresponding to regular
time intervals. Corresponding axes are on the left (for <code>y1</code>)
and on the right (for <code>y2</code>) respectively. <code>y2</code> is optional
and may have a different frequency and a different start time. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_names1">names1</code>, <code id="longtsPlot_+3A_names2">names2</code></td>
<td>
<p> Names for time series used for legend. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_startp">startP</code></td>
<td>
<p> Start time of plot. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_upf">upf</code></td>
<td>
<p> Number of time units plottet per figure. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_fpp">fpp</code></td>
<td>
<p> Number of figures per page (screen). </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_overlap">overlap</code></td>
<td>
<p> Length of time series on the right end of the figures
which is identical with the left start of the next figure. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_x.at">x.at</code></td>
<td>
<p> Time points at which long ticks on x-axis and annotations
are set. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_x.ann">x.ann</code></td>
<td>
<p> Time annotations (character vector) for long ticks on
x-axis </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_x.tick">x.tick</code></td>
<td>
<p> Time points at which short ticks are set on x-axis. If
Null, no short ticks are set. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_y1.at">y1.at</code>, <code id="longtsPlot_+3A_y1.ann">y1.ann</code>, <code id="longtsPlot_+3A_y1.tick">y1.tick</code>, <code id="longtsPlot_+3A_y2.at">y2.at</code>, <code id="longtsPlot_+3A_y2.ann">y2.ann</code>, <code id="longtsPlot_+3A_y2.tick">y2.tick</code></td>
<td>
<p>Arguments
starting with 'y1' ('y2') correspond to arguments for left (right)
axis. For details see arguments for x-axis.</p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_nx.ann">nx.ann</code>, <code id="longtsPlot_+3A_ny.ann">ny.ann</code></td>
<td>
<p>Approximate number of annotations on x- and
y-axes, respectively </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_cex.ann">cex.ann</code></td>
<td>
<p> The magnification to be used for axis annotation
relative to the current setting of cex. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_xlab">xlab</code></td>
<td>
<p> Label for x-axis. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_y1lab">y1lab</code>, <code id="longtsPlot_+3A_y2lab">y2lab</code></td>
<td>
<p> Labels for y-axes on the left and on the right
end of the figure. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_las">las</code></td>
<td>
<p> Cf. <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_col.y1">col.y1</code>, <code id="longtsPlot_+3A_col.y2">col.y2</code></td>
<td>
<p> Colors for left and right axis respectively. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_cex.lab">cex.lab</code></td>
<td>
<p> cex of labels. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_y1lim">y1lim</code>, <code id="longtsPlot_+3A_y2lim">y2lim</code></td>
<td>
<p> Limits for left and right axis respectively. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_lty1">lty1</code>, <code id="longtsPlot_+3A_lty2">lty2</code></td>
<td>
<p> Vector of line types for each time series, possibly
recycled. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_lwd1">lwd1</code>, <code id="longtsPlot_+3A_lwd2">lwd2</code></td>
<td>
<p> Vector of line widths for each time series,
possibly recycled. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_col1">col1</code>, <code id="longtsPlot_+3A_col2">col2</code></td>
<td>
<p> Vector of color for each time series, possibly
recycled. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_leg">leg</code></td>
<td>
<p> Logical. When TRUE, legend is drawn. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_y1nam.leg">y1nam.leg</code>, <code id="longtsPlot_+3A_y2nam.leg">y2nam.leg</code></td>
<td>
<p> Name of y1- and y2-axis in legend.  </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_ncol.leg">ncol.leg</code></td>
<td>
<p> Number of columns in legend. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_cex.leg">cex.leg</code></td>
<td>
<p> cex for legend. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_h1">h1</code>, <code id="longtsPlot_+3A_h2">h2</code></td>
<td>
<p> Vector of y-positions of horizontal lines in the
coordinate systems represented by the left and the right axis
respectively. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_col.h1">col.h1</code>, <code id="longtsPlot_+3A_col.h2">col.h2</code></td>
<td>
<p> Vector of colors for horizontal lines. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_main">main</code></td>
<td>
<p> Title of plot.</p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_cex.main">cex.main</code></td>
<td>
<p> cex of title.  </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_automain">automain</code></td>
<td>
<p> Logical. When <code>TRUE</code>, the units of the start and
the end on the page are printed in the title.</p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_mgp">mgp</code>, <code id="longtsPlot_+3A_mar">mar</code>, <code id="longtsPlot_+3A_oma">oma</code></td>
<td>
<p> Cf. <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_xpd">xpd</code></td>
<td>
<p> Define whether data points are clipped to the plot region
(=FALSE) or not (=TRUE). Horizontal lines, defined by <code>h1</code> or
<code>h2</code> are always clipped. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_cex">cex</code></td>
<td>
<p> Cf. <code><a href="graphics.html#topic+par">par</a></code>. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_type1">type1</code>, <code id="longtsPlot_+3A_type2">type2</code></td>
<td>
<p> For plotting lines or
points. Cf. <code><a href="graphics.html#topic+plot">plot</a></code>. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_pch1">pch1</code>, <code id="longtsPlot_+3A_pch2">pch2</code>, <code id="longtsPlot_+3A_cex.pt1">cex.pt1</code>, <code id="longtsPlot_+3A_cex.pt2">cex.pt2</code></td>
<td>
<p>Plotting symbols and there sizes
when 'type1' or 'type2' = &quot;p&quot;</p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_slide">slide</code></td>
<td>
<p> Logical. When <code>FALSE</code>, the first page (screen) is
plotted only. When <code>TRUE</code>, user may leaf through the pages
interactively. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_each.fig">each.fig</code></td>
<td>
<p> For <code>each.fig==1</code> all data are plotted.
for <code>each.fig==2</code> every 2nd page is plotted and
so on. </p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_filename">filename</code></td>
<td>
<p>When <code>filename</code> is not
<code>NULL</code>, the displayed screen(s) are saved to
disk and there is no question whether the next page should be
printed. When <code>slide = TRUE</code>, the filename of the plots is
extended by a serial number.</p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_extension">extension</code></td>
<td>
<p>The extension is defined automatically
on windows systems and must be defined manually on the other
systems.</p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_filetype">filetype</code></td>
<td>
 <p><em>On Windows</em>:
The type of plot, Windows metafile, PNG, JPEG,
BMP (Windows bitmap format), TIFF, PostScript or PDF.
Defaults to Windows meta file, <code>"wmf"</code> ,
with the extension <code>".wmf"</code>.
Cf. <code><a href="grDevices.html#topic+savePlot">savePlot</a></code>.
<br />
<em>On non Windows operating systems</em>: A device
function (e.g., x11, postscript,...). The filetype
defaults to <code>postscript</code> , with the extension
<code>".ps"</code>. Cf. <code><a href="grDevices.html#topic+dev.print">dev.print</a></code>
</p>
</td></tr>
<tr><td><code id="longtsPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments to
<code><a href="grDevices.html#topic+savePlot">savePlot</a></code> and
<code><a href="grDevices.html#topic+dev.print">dev.print</a></code> respectively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For longer time-series, it is sometimes important to spread several
time-series plots over several subplots or even over several pages
with several subplots in each. Moreover, these series have often
different ranges, frequencies and start times. There is sometimes also
the need of a more flexible annotation of axes than <code>plot.ts</code>
provides. <code>longtsPlot</code> provides the user with all these features
for one or two matrices or regular time series (time series matrices).
</p>


<h3>Side Effects</h3>

<p>One or more pages of time series plots are drawn on the current
graphic device and, optionally, saved in one or more files.
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>Examples</h3>

<pre><code class='language-R'>## sunspots, y-axis only on the left
data(sunspots)
longtsPlot(sunspots,upf=ceiling((end(sunspots)-start(sunspots))[1]/5))

## air quality (left axis) and meteo data (right axis)
## use xpd=TRUE for time series with rare but large values
if (require(SwissAir)) {
  data(AirQual)
  st &lt;- 6.5*30*48
  x.at &lt;- seq(st,nrow(AirQual),48)
  longtsPlot(y1=AirQual[,c("ad.O3","ad.NOx")], y2 = AirQual$ad.T,
             names1=c("O3","NOx"),names2 = "Temp",
             startP = st, upf=7*48,
             x.at = x.at, x.ann = substr(AirQual$start,1,6)[x.at],
             x.tick = seq(st,nrow(AirQual),12),
             y1.at = c(0,100), y1.tick = seq(0,150,50),
             y2.at = c(10,30), y2.tick = seq(10,30,10),
             y1lab="[ppb]", y2lab="[C]",
             y1lim = c(0,100), y2lim = c(10,30), xpd=TRUE,
             col2 = "red", type1 = "l")
}

## Two time series with different frequencies and start times
## on the same figures
set.seed(13)
len &lt;- 4*6*400
x &lt;- sin((1:len)/200*pi)
d &lt;- sin(cumsum(1+ rpois(len, lambda= 2.5)))

y1 &lt;- ts(10*x,start=0,frequency=6)+d*rnorm(len)
y2 &lt;- ts(100*x,start=100,frequency=13)+10*rnorm(len)
longtsPlot(y1,y2)

## plot your own legend
longtsPlot(sunspots, upf = ceiling((end(sunspots)-start(sunspots))[1]/5),
           fpp = 1, leg = FALSE)
legend(1750, 260, legend = "Monthly Sunspot Numbers", col = "blue", lwd = 1,
       bty = "n")
</code></pre>

<hr>
<h2 id='MS'> Spectrum Measured by a SELDI TOF Mass Spectrometer</h2><span id='topic+MS'></span>

<h3>Description</h3>

<p>The spectrum was taken from a sample of sheep blood. The instrument
used was a so called SELDI TOF (Surface Enhanced
Laser Desorption Ionisation, Time Of Flight) Mass Spectrometer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MS)</code></pre>


<h3>Format</h3>

<p>A data frame with 45213 observations on the following 2 variables.
</p>

<dl>
<dt><code>mz</code></dt><dd><p>mass / charge</p>
</dd>
<dt><code>I</code></dt><dd><p>Intensity</p>
</dd>
</dl>



<h3>Details</h3>

<p>The measured masses lie between m/z=1000 and 200000. The intensities
are raw output. Neither smoothing nor background subtraction was
applied to the spectrum.
</p>


<h3>Source</h3>

<p>Medical research project.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MS)

MS1 &lt;- log10(MS[MS$mz&gt;12000&amp;MS$mz&lt;1e5,])
P &lt;- peaks(MS1, minPH=0.025, minPW=0.0015)

plot(MS1, ty="l", xlim=c(4.15,5))
points(P,col="red")

</code></pre>

<hr>
<h2 id='NaRV.omit'>Omit Observations with NA, NaN, Inf and -Inf Values</h2><span id='topic+NaRV.omit'></span>

<h3>Description</h3>

<p>Omits observations with values which a not regular (=Not a Regular
Value) when object is a vector, a factor, a data.frame or a matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NaRV.omit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NaRV.omit_+3A_x">x</code></td>
<td>
<p><code>Vector</code>, <code>data.frame</code> or <code>matrix</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Irregular values are defined as <code>NA</code>, <code>NaN</code>, <code>Inf</code> and
<code>-Inf</code> Values in numerics and <code>NA</code> in factors and
characters.  
</p>


<h3>Value</h3>

<p>Returns objects of <code>class</code> vector, factor, data.frame or matrix
in the same way as <code><a href="stats.html#topic+na.omit">na.omit</a></code> does.  Returns all other
objects unchanged and prints a warning. 
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.omit">na.omit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(NA,1:7,NA),nrow=3)
M
NaRV.omit(M)

DF &lt;- iris[sample(1:nrow(iris),12),]
DF[1,1] &lt;- NA
DF[10,5] &lt;- NA
row.names(DF) &lt;- 1:12
DF
NaRV.omit(DF)

NaRV.omit(c(NA,1:10,NA))

fac &lt;- factor(c(NA,sample(c(1:9))))
NaRV.omit(fac)

fac &lt;- factor(c(NA,sample(c(1:9))),exclude=NULL)
fac
NaRV.omit(fac)
</code></pre>

<hr>
<h2 id='ok'>Sets NAs in Logical Objects to FALSE</h2><span id='topic+ok'></span>

<h3>Description</h3>

<p>Sets NAs in logical vectors and matrices to FALSE.  This is especially
useful for conditional selections of data when the variables the
condition is based on contain <code>NA</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ok(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ok_+3A_x">x</code></td>
<td>
<p>Logical vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector or matrix, containing no <code>NA</code>s.
</p>


<h3>Author(s)</h3>

<p>Rene Locher</p>


<h3>Examples</h3>

<pre><code class='language-R'>ok(c(FALSE,TRUE,NA,TRUE))
</code></pre>

<hr>
<h2 id='peaks'> Finding Peaks in Raw Data </h2><span id='topic+peaks'></span>

<h3>Description</h3>

<p>Returns position, signal height and approximate width at half
maximum peak height. </p>


<h3>Usage</h3>

<pre><code class='language-R'>peaks(x, y = NULL, minPH, minPW, thr, stepF = 0.49)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peaks_+3A_x">x</code>, <code id="peaks_+3A_y">y</code></td>
<td>
<p> Position and height of signal. Any reasonable way of
defining the coordinates is acceptable. See function
<code>link{getXY}</code> for details.</p>
</td></tr>
<tr><td><code id="peaks_+3A_minph">minPH</code></td>
<td>
<p> Mimimum height of peak to be reported. </p>
</td></tr>
<tr><td><code id="peaks_+3A_minpw">minPW</code></td>
<td>
<p> Minimum width of peak at half maximum to be reported. </p>
</td></tr>
<tr><td><code id="peaks_+3A_thr">thr</code></td>
<td>
<p> Threshold below which the signal is not processed. </p>
</td></tr>
<tr><td><code id="peaks_+3A_stepf">stepF</code></td>
<td>
 <p><code>StepF</code> defines indirectly the accuracy of the
selection criteria <code>minPH</code> and <code>minPW</code> and of the value of
the calculated width: The smaller the more accurate and the slower
the function. It must be &lt;0.5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is especially useful for signals in which both very broad
and very narrow peaks are of interest. The peaks may lie very close to
each other or might even be superpositioned on top of each
other, e.g. peaks on broader shoulders. The algorithm is also very
useful when the resolution of the signal is poor and the noise is
small.
</p>
<p>The function is looking for peaks without any preceding baseline
substraction or smoothing, which could distort the spectrum.
</p>
<p>The selection criteria <code>minPH</code> and <code>minPW</code> and the values
for the calculated peak widths are only approximate.</p>


<h3>Value</h3>

<p>dataframe consisting of
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Position of peak</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Signal height</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Approximate width at half maximum of peak</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the function, the main selection criterium for the peaks is the
height of the peaks, the second optional criterium is the width of the
peaks.
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200
freq &lt;- 1:n
theory &lt;- sin(freq/n*4*pi)*cos(freq/n*3*pi)
spec &lt;- theory + 0.1*rnorm(n)

plot(spec,type="b")
lines(theory,lwd=2)

pts &lt;- peaks(spec, minPH=0.7)
points(pts,col="red",cex=1.2, pch=20)

## peaks after smoothing the spectrum
spec.sm &lt;- loess.smooth(freq, spec, span=0.2,
                        degree = 2, evaluation = 100)
lines(spec.sm$x, spec.sm$y, col="steelblue", lwd=2)
pts &lt;- peaks(spec.sm, minPH=0.4)
points(pts,col="green",cex=1.2,pch=20)

## Analyses of Mass Spectrum between 12000 and 100'000
## without smoothing, without baseline substraction
data(MS)
MS1 &lt;- log10(MS[MS$mz&gt;12000&amp;MS$mz&lt;1e5,])

P &lt;- peaks(MS1, minPH=0.02, minPW=0.001)
plot(MS1, type="l", xlab="log10(mz)", ylab="log10(I)")
points(P,col="blue",cex=1.6)

</code></pre>

<hr>
<h2 id='plot.rose'> Plot Method for Class &quot;rose&quot;  (Grid Graphics Function)</h2><span id='topic+plot.rose'></span><span id='topic+plot'></span><span id='topic+plot+2Crose+2Cmissing-method'></span>

<h3>Description</h3>

<p>Describes plot method for class &quot;rose&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'rose,missing'
plot(
          x,
          transf = function(x) sqrt(x),
          subset.col = NULL,
          warn = TRUE,
          general = general.control(),
          grid = grid.control(),
          title = title.control(),
          key = key.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rose_+3A_x">x</code></td>
<td>
<p> Object <code><a href="#topic+rose">rose</a></code>. </p>
</td></tr>
<tr><td><code id="plot.rose_+3A_transf">transf</code></td>
<td>
<p> Transformation function for <code>x@rho</code>.  It defaults to
the square root, resulting in equal area roses.</p>
</td></tr>
<tr><td><code id="plot.rose_+3A_subset.col">subset.col</code></td>
<td>
<p> Display only a subset of the columns of
<code>x@rho</code>.  Subset might be declared by numerical values or by
name. </p>
</td></tr>
<tr><td><code id="plot.rose_+3A_warn">warn</code></td>
<td>
<p> Logical. If <code>FALSE</code>, warnings are suppressed.</p>
</td></tr>
<tr><td><code id="plot.rose_+3A_general">general</code></td>
<td>
<p> Settings for general appearance of plot, defined in
<code><a href="#topic+general.control">general.control</a></code>.</p>
</td></tr>
<tr><td><code id="plot.rose_+3A_grid">grid</code></td>
<td>
<p> Settings for appearance of guiding elements of rose such
as circles, rays and labels, defined in <code><a href="#topic+grid.control">grid.control</a></code></p>
</td></tr>
<tr><td><code id="plot.rose_+3A_title">title</code></td>
<td>
<p> Settings for title, defined in
<code><a href="#topic+title.control">title.control</a></code>.</p>
</td></tr>
<tr><td><code id="plot.rose_+3A_key">key</code></td>
<td>
<p> Settings for appearance of the legend, defined in
<code><a href="#topic+key.control">key.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function appeals especially to environmental specialists who
often have response variables, which depend from cyclic variables like
the direction of wind, the hour of the day, the month etc.  All these
variables are displayed usually clockwise,
starting with 0 in the north (12 o' clock).  We call this
kind of coordinates 'clock coordinates', to distinct them from the
polar coordinates as used in mathematical context.  The
<code><a href="#topic+rose">rose</a></code> object is displayed as the time on a clock,
measuring the angle defined in slot <code>cyclVar</code> in the clockwise
direction from the north. <br />
The eye takes the area of a graphical object as a measure of its
size.  This is why the default transformation of <code>x@rho</code> is
chosen to be the square root.  For equal distance roses use the
transformation function <code>function(x) x</code>. <br />
All labels, titles and line sizes are defined in multiples of cex. <br />
This graphic function is based on package <span class="pkg"><a href="graphics.html#topic+grid">grid</a></span>:
Viewport <code>vp.rose</code> which was used to draw the rose and viewport
<code>vp.key</code> which was used to draw the key may be addressed by
<code>pushviewport()</code> after having drawn the figure.
</p>


<h3>Value</h3>

<p>No value returned
</p>


<h3>Note</h3>

<p>The function is designed to use the area on the active viewport in an
optimal way, but the plot is not scalable after having been drawn. <br />
Furthermore this function is still experimental so that some features
may change in future versions. <br />
You will find another nice example for this plot method in <code><a href="SwissAir.html#topic+AirQual">AirQual</a></code>
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="#topic+rose">rose</a></code>, <code><a href="#topic+rose-class">rose-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>hour &lt;- rep(0:23,100)
WD &lt;- c(rnorm(24*90, mean=sample(c(190,220,50),24*90,
                                          replace = TRUE),sd=10),
                           rnorm(24*10, mean=360, sd=180))%%360
dat &lt;- data.frame(A = (2*cos((hour+6)/6*pi)+
                       2*cos((WD+60)/180*pi)+rnorm(24*100,4))^2,
                  B = (2*cos((hour+4)/6*pi)+rnorm(24*100,1,8))^2)
dat$B[dat$B&gt;1000] &lt;- 1000

## two different response variables, scalar summary function
mean.dayrose &lt;- rose(dat[,c("A","B")],
                cyclVar = hour,
                n.cyclVar = 24,
                circle = 24,
                FUN=mean, na.rm=TRUE)

## one response variable, vector summary function
quant.windrose &lt;- rose(dat$A,
                       cyclVar = WD,
                       n.cyclVar = 16, circle = 360,
                       FUN=quantile, na.rm=TRUE)

## one response variable, second (non cyclic) explanatory variable,
## scalar summary function
windrose &lt;- rose(dat[,c("A")],
                 cyclVar = WD,
                 n.cyclVar=8,
                 circle = 360,
                 cut = dat$B,
                 breaks = c(0,10,100,1000),
                 include.lowest = TRUE, dig.lab = 4,
                 FUN = function(x) sum(!is.na(x)))

grid::grid.newpage()
plot(mean.dayrose,
     general = general.control(
       mar = rep(1,4),
       stacked = FALSE,
       lwd = 3,
       lty = c(1:2)),
     grid = grid.control(
       circ.n = 2,
       circ.sub.n = 2,
       circ.lwd = 2,
       circ.sub.col = "black",
       ray.n = 12,
       cyclVar.lab = seq(0,by=2,to=22)),
     title = title.control(text = "unstacked dayrose"),
     key = key.control(title = "Mean",
                       between = 0))

grid::grid.newpage()
plot(quant.windrose)

grid::grid.newpage()
plot(windrose,
     general = general.control(
       stacked = TRUE,
       lwd = 3),
     grid = grid.control(
       circ.n = 2,
       circ.sub.n = 2),
     title = title.control(
       text = "Stacked windrose:\nCounts of A-Values"),
     key = key.control(title = "Value of B"))


if (require(SwissAir)){
  data(AirQual)
  dat &lt;-
    data.frame(month =as.numeric(substr(AirQual$start,4,5)),
               hour = as.numeric(substr(AirQual$start,12,13)),
               WD = AirQual$ad.WD,
               NOx = AirQual$ad.NOx,
               ## NO2 = AirQual$ad.NOx-AirQual$ad.NO,
               ## NO  = AirQual$ad.NO,
               O3  = AirQual$ad.O3,
               Ox  = AirQual$ad.O3+AirQual$ad.NOx-AirQual$ad.NO)


  ## Windrose
  windrose &lt;- rose(dat$WD,
                   cyclVar = dat$WD, n.cyclVar = 32, circle = 360,
                   FUN = function(x) sum(!is.na(x)))

  grid::grid.newpage()
  plot(windrose,
       general =
       general.control(lwd = 2),
       grid =
       grid.control(circ.n = 2,
                    circ.sub.n = 2))

  ## median of concentrations as a function of daytime
  ## from May to September
  med.dayrose &lt;- rose(dat[,c("NOx","O3","Ox")],
                      subset= dat$month&gt;4 &amp; dat$month&lt;10,
                      cyclVar=dat$hour, n.cyclVar=24, circle=24,
                      FUN=median, na.rm=TRUE)

  ## line type version of rose
  grid::grid.newpage()
  plot(med.dayrose,
       general = general.control(lwd=2, type="l"),
       grid =
       grid.control(ray.n = 12,
                    circ.n =2,
                    circ.sub.n = 2,
                    cyclVar.lab = seq(0,by=2,to=22)),
       title = title.control(text =
         "Day Rose of Medians\nduring summer"))

  ## quantiles of concentrations as a function of daytime
  ## from May to September
  quant.dayrose &lt;- rose(dat$NOx,
                        subset= dat$month&gt;4 &amp; dat$month&lt;10,
                        cyclVar=dat$hour, n.cyclVar=24, circle=24,
                        FUN=quantile, na.rm=TRUE)
  grid::grid.newpage()
  plot(quant.dayrose,
       general =
       general.control(mar = c(0.3, 0.3, 0.3, 2),
                       lwd = 2),
       grid =
       grid.control(ray.n = 12,
                    cyclVar.lab = seq(0,by=2,to=22)),
       title = title.control(text = "Concentration of NOx [ppb]\nduring summer"),
       key = key.control(title = "Quantiles"))
} else print("Package SwissAir is not available")

</code></pre>

<hr>
<h2 id='poster.plot'>Convenient xyplot with Differently Colored Margin and Plot Region</h2><span id='topic+poster.plot'></span>

<h3>Description</h3>

<p>Convenient xyplot with Colored Background.  Background of margin may be
chosen independently from background in plot region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poster.plot(x, y = NULL, type = "p",
            col = col.fg, col.axis = col.fg, col.lab = col.fg,
            col.fg = "blue", col.bg = "lavender", col.box = "cornsilk",
            xlim = NULL, ylim = NULL, xlab = "", ylab = "",
            main = "", cex = 1.2, axes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poster.plot_+3A_x">x</code></td>
<td>
<p>A vector, data.frame or matrix.  When x is data.frame or
matrix only first two columns are used.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_y">y</code></td>
<td>
<p>A vector or <code>NULL</code></p>
</td></tr>
<tr><td><code id="poster.plot_+3A_type">type</code></td>
<td>
<p>See Argument <code>type</code> in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="poster.plot_+3A_col">col</code></td>
<td>
<p>Color of points.  If <code>length(col)</code> &gt; 1, colors are recycled.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_col.axis">col.axis</code></td>
<td>
<p>Color of axis.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_col.lab">col.lab</code></td>
<td>
<p>Color  of labels on axis.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_col.fg">col.fg</code></td>
<td>
<p>Color  of foreground.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_col.bg">col.bg</code></td>
<td>
<p>Color of background outside of figure.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_col.box">col.box</code></td>
<td>
<p>Color of background inside of figure</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_xlim">xlim</code></td>
<td>
<p>Limits of x-axis.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_ylim">ylim</code></td>
<td>
<p>Limits of y-axis</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_main">main</code></td>
<td>
<p>Titel.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_cex">cex</code></td>
<td>
<p>Size of characters.</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_axes">axes</code></td>
<td>
<p>Should axis be plotted?</p>
</td></tr>
<tr><td><code id="poster.plot_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Side effect: <code>par</code> options will remain changed so that other
graphic elements can be added comfortably.
</p>


<h3>Author(s)</h3>

<p>Andreas Ruckstuhl, refined by Rene Locher</p>


<h3>Examples</h3>

<pre><code class='language-R'>poster.plot(iris[,1],iris[,2],
            xlab="Sepal.Length", ylab="Sepal.Width")

poster.plot(iris[,1], col="red", col.box="grey95", ylab="Sepal.Length")

## plotting lines
n &lt;- 200
freq &lt;- 1:n
y &lt;- sin(freq/n*4*pi)*cos(freq/n*3*pi) + 0.1*rnorm(n)
poster.plot(y,col.fg="grey30",type="l")
</code></pre>

<hr>
<h2 id='rfbaseline'>Robust Fitting of Baselines </h2><span id='topic+rfbaseline'></span>

<h3>Description</h3>

<p>Robust fitting of local regression models for estimating a baseline or a background signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfbaseline(x, y, span = 2/3, NoXP = NULL,
           maxit = c(2, 2), b = 3.5, weight = NULL,
           Scale = function(r) median(abs(r))/0.6745,
           delta = NULL, SORT = TRUE, DOT = FALSE, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfbaseline_+3A_x">x</code>, <code id="rfbaseline_+3A_y">y</code></td>
<td>
<p> Abscissa and ordinate of the points on the scatterplot. </p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_span">span</code></td>
<td>
<p> Specifies the amount of smoothing; span is the fraction
of points used to compute each fitted value; as span increases the
output becomes smoother. </p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_noxp">NoXP</code></td>
<td>
<p> Another way of specifying the amount of smoothing; NoXP
is the Number of X Points used to compute each fitted value; it must
be larger than 3.</p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_maxit">maxit</code></td>
<td>
<p> The number of iterations in the robust fit; if
maxit=c(0,0), the nonrobust fit is  returned; the first entry
specifies the number of iterations using an asymmetric biweight
function, whereas the second entry specifies the number of
iterations using the usual (symmetric) biweight function. </p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_b">b</code></td>
<td>
<p> Tuning constant in the biweight function. </p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_weight">weight</code></td>
<td>
<p> Optional weights to be given to individual
observations. </p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_scale">Scale</code></td>
<td>
<p> function specifying how to calculate the scale of the
residuals. </p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_delta">delta</code></td>
<td>
<p> Nonnegative parameter which may be used to save
computation. By default, if <code>length(x) &lt;= 100</code>, delta is
set equal to 0; if <code>length(x) &gt; 100</code> set to 1/100th of the
range of <code>x</code>.</p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_sort">SORT</code></td>
<td>
<p> Boolean variable indicating whether x data must be
sorted. Change it only when the x are sorted and you want to safe
computer time. </p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_dot">DOT</code></td>
<td>
<p> If TRUE disregard outliers totally; that is, observations
with weight 0 are disregarded even when the neighbourhood is
determined. </p>
</td></tr>
<tr><td><code id="rfbaseline_+3A_init">init</code></td>
<td>
<p> Values of an initial fit. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Sorted input vector x with  duplicate points removed</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Corresponding input vector y</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Fitted values at x</p>
</td></tr>
<tr><td><code>rw</code></td>
<td>
<p>Robust weights of (x,y)-Points used in last iteration of fit</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>Scale used in last iteration of fit</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Andreas Ruckstuhl </p>


<h3>References</h3>

<p>Ruckstuhl, Andreas F., Matthew P. Jacobson,   Robert W. Field and James
A. Dodd (2001); Baseline Subtraction Using Robust Local Regression
Estimation; Journal of Quantitative Spectroscopy and Radiative
Transfer <b>68</b>: 179 &ndash; 193
</p>
<p>Ruckstuhl, Andreas F., et al.; Estimation of background concentrations
of atmospheric trace gases using robust local regression; to be
published </p>


<h3>See Also</h3>

<p> See Also as <code><a href="stats.html#topic+loess">loess</a></code> and <code><a href="stats.html#topic+lowess">lowess</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MS)
MS1 &lt;- log10(MS[MS$mz&gt;12000&amp;MS$mz&lt;1e5,])

MS1.rfb2 &lt;- rfbaseline(x=MS1$mz, y=MS1$I, NoXP=2200, maxit=c(5,0))
plot(x=MS1$mz, y=MS1$I, type="l",
     xlab="log(mass/charge)", ylab="log(intensity)")
lines(MS1.rfb2$x, MS1.rfb2$fit, col="orange", lwd=3)

MS1.rfb3 &lt;- rfbaseline(x=MS1$mz, y=MS1$I, NoXP=1100, maxit=c(5,0),
                       DOT=TRUE, Scale=function(x) mad(x, center=0))
plot(x=MS1$mz, y=MS1$I, type="l",
     xlab="log(mass/charge)", ylab="log(intensity)")
lines(MS1.rfb3$x, MS1.rfb3$fit, col="orange", lwd=3)

## 'delta=0' needs much more computer time
## Not run: 
MS1.rfb4 &lt;- rfbaseline(x=MS1$mz, y=MS1$I, NoXP=2200,
                       delta=0, maxit=c(5,0))
plot(x=MS1$mz, y=MS1$I,ty="l",
     xlab="log(mass/charge)", ylab="log(intensity)")
lines(MS1.rfb4$x, MS1.rfb4$fit, col="orange", lwd=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='rfbaselineScale'> Estimation of the Scale Parameter </h2><span id='topic+rfbaselineScale'></span>

<h3>Description</h3>

<p>Estimation of the scale parameter based on data smaller than its first
mode. Mainly used in rfbaseline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfbaselineScale(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfbaselineScale_+3A_r">r</code></td>
<td>
<p> residuals </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated scale.
</p>


<h3>Author(s)</h3>

<p> Andreas Ruckstuhl</p>


<h3>See Also</h3>

<p> See also <code><a href="stats.html#topic+mad">mad</a></code> </p>

<hr>
<h2 id='rose'>Creates a rose object out of circular data</h2><span id='topic+rose'></span>

<h3>Description</h3>

<p><code>rose</code> splits data into subsets according to one or two
grouping elements, computes summary statistics for each, and returns
the result in a rose object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose(x, subset = NULL,
     cyclVar = NULL, circle = NULL, n.cyclVar = 8,
     cut = NULL, labels = NULL,
     breaks = NULL, include.lowest = FALSE, right = TRUE, dig.lab = 2,
     warn = TRUE, FUN = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_+3A_x">x</code></td>
<td>
<p>Vector, data frame or matrix containing the response.</p>
</td></tr>
<tr><td><code id="rose_+3A_subset">subset</code></td>
<td>
<p> An optional vector specifying a subset of observations
to be used in the aggregating process. </p>
</td></tr>
<tr><td><code id="rose_+3A_cyclvar">cyclVar</code></td>
<td>
<p>Cyclic variable as first grouping
element.  <code>cyclVar</code> must be a numeric vector whose length is
equal to the number of rows in <code>x</code> with 0 &lt;= <code>cyclVar</code> &lt;
<code>circle</code>.  Observations where cyclic variables are NA are
automatically excluded from the rose object. </p>
</td></tr>
<tr><td><code id="rose_+3A_circle">circle</code></td>
<td>
<p>Defines the value of a full circle with no default.</p>
</td></tr>
<tr><td><code id="rose_+3A_n.cyclvar">n.cyclVar</code></td>
<td>
<p>Defines the number of equally spaced intervals of the
cyclic variable, into which the data are split.  The first interval is
labeled with 0 and is always centered around 0.</p>
</td></tr>
<tr><td><code id="rose_+3A_cut">cut</code></td>
<td>
<p>Vector of numerics, logicals  or factors as second grouping
elements.  Its length is equal to the number of rows in
<code>x</code>.  <code>cut</code> is used  to group the observations similar to
function <code><a href="base.html#topic+cut">cut</a></code>. </p>
</td></tr>
<tr><td><code id="rose_+3A_labels">labels</code></td>
<td>
<p> Labels for the corresponding intervals.  When cut is a
logical, labels has to be named in the order: FALSE, TRUE.</p>
</td></tr>
<tr><td><code id="rose_+3A_breaks">breaks</code>, <code id="rose_+3A_include.lowest">include.lowest</code>, <code id="rose_+3A_right">right</code>, <code id="rose_+3A_dig.lab">dig.lab</code></td>
<td>
<p> These arguments are
only active when <code>cut</code> is numeric and  are used
in exactly the same way as in <a href="base.html#topic+cut">cut</a>. <br />
<code>breaks</code> defines the break points. <br />
<code>include.lowest = TRUE</code> indicates that the lowest (or
highest, for right = FALSE) breaks value should be also
included. <br />
<code>right = TRUE</code> indicates that the intervals should be closed
on the right (and open on the left) or vice versa for <code>right =
      FALSE</code>. <br />
<code>dig.lab</code> number of digits for breaks labeling when labels
are <em>not</em> given explicitely.</p>
</td></tr>
<tr><td><code id="rose_+3A_warn">warn</code></td>
<td>
<p> Logical, indicating if warnings should be issued
for NAs in <code>cyclVar</code> and / or x-values outside of breaks range. </p>
</td></tr>
<tr><td><code id="rose_+3A_fun">FUN</code></td>
<td>
<p> Summary function, returning a scalar or vector. </p>
</td></tr>
<tr><td><code id="rose_+3A_...">...</code></td>
<td>
<p> Additional arguments for summary function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first grouping element, <code>cyclVar</code>, for the summary statistics
must be circular and numeric.  The second grouping element, <code>cut</code>,
can be numeric, logical or a factor. <br />
Not all combinations of arguments are allowed: <br />
Argument <code>cut</code> can only be defined when summary consists of a
scalar and <code>x</code> consists of 1 column. <br />
When <code>x</code> contains only one column and <code>cut</code> is <em>not</em>
defined, the summary function may also be a vector with the
restriction, that the summary of each subset, defined by the cyclic
variable, must have the same number of elements. <br />
When <code>x</code> is a data frame or matrix with more than 1 column,
the summary function must be scalar.
</p>


<h3>Value</h3>

<p>Object of class <code>rose</code>
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><a href="#topic+rose-class">rose-class</a>, <a href="#topic+plot.rose">plot.rose</a>, <code><a href="#topic+cart2clock">cart2clock</a></code>,
<code><a href="#topic+clock2cart">clock2cart</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## artificial example:
## concentration of A and B as function of
## hour of day (hour) and wind direction (WD)
hour &lt;- rep(0:23,100)
dat &lt;- data.frame(hour = hour,
                  A =    (2*cos((hour+6)/6*pi)+rnorm(24*100,1))^2,
                  B =    (2*cos((hour+4)/6*pi)+rnorm(24*100,1,2))^2,
                  WD =   rnorm(24*100,
                           mean=sample(c(190,220,50),24*100, replace = TRUE),
                           sd=30)%%360)

## two different responses, scalar summary function
mean.windrose &lt;- rose(dat[,c("A","B")],
                      cyclVar=dat$WD,
                      circle=360,
                      FUN=mean, na.rm=TRUE)
mean.windrose

## one response, vectorial summary function
quant.dayrose &lt;- rose(dat$A,
                      cyclVar=dat$hour,
                      n.cyclVar=24, circle=24,
                      FUN=quantile, na.rm=TRUE)
quant.dayrose


mean.windroseB &lt;- rose(dat[,c("A")],
                       cyclVar=dat$WD,
                       circle=360,
                       cut=dat$B,
                       breaks=c(0,30,100),
                       dig.lab=3,
                       FUN=mean, na.rm=TRUE)
mean.windroseB

</code></pre>

<hr>
<h2 id='rose-class'>rose-class</h2><span id='topic+rose-class'></span>

<h3>Description</h3>

<p> Summary statistics of cyclic data. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>rose(x, cyclVar = NULL, circle = NULL, n.cyclVar = 8,
    cut = NULL, breaks = NULL,
    labels = NULL, dig.lab = 2,
    include.lowest = FALSE, subset = NULL,
    na.warning = TRUE, FUN = mean, ...) </code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>rho</code>:</dt><dd><p>Object of class <code>matrix</code>.  <code>rho[i,]</code>
contains the summary values of all data within the interval
defined by the cyclic Variable <code>cyclVar[i]</code>.  Column  and row
names are mandatory.  The different columns of <code>rho</code>
correspond to different responses when the summary statistics is a
scalar <em>or</em> to the different elements of a vector summary of
one response <em>or</em> to the different subsets of the second
grouping element. </p>
</dd>
<dt><code>cyclVar</code>:</dt><dd><p>Object of class <code>numeric</code> containing
the center of the interval of the cyclic variable.  The values are
sorted by increasing values, are unique and cannot contain NA
values. </p>
</dd>
<dt><code>circle</code>:</dt><dd><p>Scalar of class <code>numeric</code>, defining the
full circle. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

<p>For the details of how to create and plot a <code><a href="#topic+rose">rose</a></code> object
see <code><a href="#topic+rose">rose</a></code> and <code><a href="#topic+plot.rose">plot.rose</a></code>.
</p>

<hr>
<h2 id='showColors'>Displays vectors of colors</h2><span id='topic+showColors'></span>

<h3>Description</h3>

<p>Displays colors produced by a color vector <code>col</code> and labels them by the
corresponding number of the element of <code>col</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showColors(col = IDPcolorRamp(20),
           ntm = min(length(col), 20),
           border = TRUE, mar = rep(0,4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showColors_+3A_col">col</code></td>
<td>
<p>Color vector</p>
</td></tr>
<tr><td><code id="showColors_+3A_ntm">ntm</code></td>
<td>
<p>Approximate number of labels printed</p>
</td></tr>
<tr><td><code id="showColors_+3A_border">border</code></td>
<td>
<p>Shall border be drawn between the colors in the legend:
<code>TRUE</code> / <code>FALSE</code></p>
</td></tr>
<tr><td><code id="showColors_+3A_mar">mar</code></td>
<td>
<p>Margin. cf <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rene Locher</p>


<h3>See Also</h3>

<p><code><a href="#topic+IDPcolorRamp">IDPcolorRamp</a></code>,
<code><a href="RColorBrewer.html#topic+ColorBrewer">ColorBrewer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>showColors(IDPcolorRamp(5))
showColors(IDPcolorRamp(200),border=FALSE)
showColors(IDPcolorRamp(200),border=FALSE,ntm=5)

showColors(IDPcolorRamp(4,
                        colInt = data.frame(
                            h = c(0.47, 0.28, 0.22, 0.2, 0.00),
                            s = c(0.3, 0.55, 0.75, 0.75, 0.75),
                            v = c(1, 1, 1, 1, 1)),
                        fr     = c(0.2,0.2,0.2))
           ,border=FALSE)

showColors(IDPcolorRamp(200,
                        t(col2hsv(c("darkviolet","blue",
                                    "green","yellow","red"))),
                        fr=rep(0.25,3)),border=FALSE)

</code></pre>

<hr>
<h2 id='title.control'> Auxilary for Controlling  the Title of a Rose Plot </h2><span id='topic+title.control'></span>

<h3>Description</h3>

<p>Auxilary for controlling  the title of a rose plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>title.control(text = NULL, cex = 1.5,
              between = if (is.null(text)) 0 else 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="title.control_+3A_text">text</code></td>
<td>
<p> Title. </p>
</td></tr>
<tr><td><code id="title.control_+3A_cex">cex</code></td>
<td>
<p> Size of characters in title in multiples of <code>cex</code> as
defined in <code><a href="#topic+general.control">general.control</a></code>.</p>
</td></tr>
<tr><td><code id="title.control_+3A_between">between</code></td>
<td>
<p> Distance between title and label North. Default units
are <code>grid.control(cyclVar.cex)</code>. Other units can be defined by
<code><a href="grid.html#topic+unit">unit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the arguments conveniently packaged up in a list to supply the
arguments for the title of <code><a href="#topic+plot.rose">plot.rose</a></code>.
</p>


<h3>Author(s)</h3>

<p> Rene Locher </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.rose">plot.rose</a></code>, <code><a href="#topic+general.control">general.control</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>title.control()
</code></pre>

<hr>
<h2 id='zoom'>Zooming in and out in a 2d-Plot</h2><span id='topic+zoom'></span>

<h3>Description</h3>

<p>Function to zoom in and out by mouse click in a 2D-plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoom(fun = plot, zoom.col = "red", delay = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zoom_+3A_fun">fun</code></td>
<td>
<p>2D-plotting function</p>
</td></tr>
<tr><td><code id="zoom_+3A_zoom.col">zoom.col</code></td>
<td>
<p>Color of clicked points</p>
</td></tr>
<tr><td><code id="zoom_+3A_delay">delay</code></td>
<td>
<p>Number of sec during which the 2 zooming points are shown
on the plot before zooming</p>
</td></tr>
<tr><td><code id="zoom_+3A_...">...</code></td>
<td>
<p>Arguments to plotting function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the clicked points lay within the plot region range, the points
define the new plotting limits.  When the clicked points lay in the
margin,  the plotting limits will be moved into the corresponding
direction by 1/3 out of the actual range.  There is no special
sequential order for the zooming points required.  The zooming function
is stopped by right clicking and choosing the menu item &quot;stop&quot;.
</p>


<h3>Value</h3>

<p>No value returned.
</p>


<h3>Author(s)</h3>

<p>Rene Locher</p>


<h3>Examples</h3>

<pre><code class='language-R'>i &lt;- 1:100
y &lt;- i*sin(i*(pi/16))
y &lt;- c(rev(y),y)

## Not run:
zoom(fun=plot, zoom.col="red", x=1:200, y=y, type="l", xlab="index")
## End( Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
