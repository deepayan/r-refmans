<!DOCTYPE html><html><head><title>Help for package vdar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vdar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_estimate_true_var'><p>Estimate true group variance</p></a></li>
<li><a href='#dataobs'><p>Simulated observation data</p></a></li>
<li><a href='#dataobs_coda'><p>Simulated observation of compositional data</p></a></li>
<li><a href='#datatrue'><p>Simulated true data</p></a></li>
<li><a href='#datatrue_coda'><p>Simulated true compositional data</p></a></li>
<li><a href='#force_posdef'><p>Force positive definiteness</p></a></li>
<li><a href='#generalized_mean'><p>Generalized mean</p></a></li>
<li><a href='#predict.vqda'><p>predict.vqda</p></a></li>
<li><a href='#uncertainties'><p>Simulated observation uncertainties</p></a></li>
<li><a href='#uncertainties_coda'><p>Simulated observation uncertainties of compositional data</p></a></li>
<li><a href='#vlda'><p>Weighted Linear Discriminant Analysis</p></a></li>
<li><a href='#vqda'><p>Weighted Quadratic Discriminant Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Discriminant Analysis Incorporating Individual Uncertainties</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3-2</td>
</tr>
<tr>
<td>Author:</td>
<td>Solveig Pospiech [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Solveig Pospiech &lt;s.pospiech@hzdr.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The qda() function from package 'MASS' is extended to calculate a weighted linear (LDA) and quadratic discriminant analysis (QDA) by changing the group variances and group means based on cell-wise uncertainties.
    The uncertainties can be derived e.g. through relative errors for each individual measurement (cell), not only row-wise or column-wise uncertainties.
    The method can be applied compositional data (e.g. portions of substances, concentrations) and non-compositional data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>compositions</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, ggthemes, ggtern</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-04 18:57:12 UTC; solveig</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-04 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_estimate_true_var'>Estimate true group variance</h2><span id='topic+calc_estimate_true_var'></span><span id='topic+calc_estimate_true_var.default'></span><span id='topic+calc_estimate_true_var.rmult'></span>

<h3>Description</h3>

<p>Estimation of true group variance incorporating observation wise variances.
The function uses the data from x and the individual variances for each observation, for example derived from uncertainties, to calculate a 'true' group variance.
The variance of the matrix is corrected for the sum of the individual variances of the data set, which is normalized to the number of rows of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_estimate_true_var(x, ...)

## Default S3 method:
calc_estimate_true_var(x, individual_var, force_pos_def = T, ...)

## S3 method for class 'rmult'
calc_estimate_true_var(x, individual_var, force_pos_def = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_estimate_true_var_+3A_x">x</code></td>
<td>
<p>a matrix of data</p>
</td></tr>
<tr><td><code id="calc_estimate_true_var_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="calc_estimate_true_var_+3A_individual_var">individual_var</code></td>
<td>
<p>a matrix of cell-wise uncertainties, corresponding to the entries of 'x'</p>
</td></tr>
<tr><td><code id="calc_estimate_true_var_+3A_force_pos_def">force_pos_def</code></td>
<td>
<p>force positive definiteness of the new group variances, default TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of corrected group variance
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: for class matrix or data.frame
</p>
</li>
<li> <p><code>rmult</code>: for class rmult
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Solveig Pospiech, K. Gerald v.d. Boogaart
</p>

<hr>
<h2 id='dataobs'>Simulated observation data</h2><span id='topic+dataobs'></span>

<h3>Description</h3>

<p>A data set of 200 simulated observations with two observed variables and two groups, non-compositional
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataobs
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 3 columns
</p>

<dl>
<dt>Var1</dt><dd><p>simulated observed variable</p>
</dd>
<dt>Var2</dt><dd><p>simulated observed variable</p>
</dd>
<dt>Group</dt><dd><p>Factor with levels 'Group 1' and 'Group 2'</p>
</dd>
</dl>


<hr>
<h2 id='dataobs_coda'>Simulated observation of compositional data</h2><span id='topic+dataobs_coda'></span>

<h3>Description</h3>

<p>A data set of 200 simulated observations with three observed variables and two groups, compositional
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataobs_coda
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 4 columns
</p>

<dl>
<dt>Var1</dt><dd><p>simulated observed variable, compositional</p>
</dd>
<dt>Var2</dt><dd><p>simulated observed variable, compositional</p>
</dd>
<dt>Var3</dt><dd><p>simulated observed variable, compositional</p>
</dd>
<dt>Group</dt><dd><p>Factor with levels 'Group 1' and 'Group 2'</p>
</dd>
</dl>


<hr>
<h2 id='datatrue'>Simulated true data</h2><span id='topic+datatrue'></span>

<h3>Description</h3>

<p>A data set of 200 simulated 'true' data, from which the observations are deduced, with two observed variables and two groups, non-compositional
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datatrue
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 3 columns
</p>

<dl>
<dt>Var1</dt><dd><p>simulated variable</p>
</dd>
<dt>Var2</dt><dd><p>simulated variable</p>
</dd>
<dt>Group</dt><dd><p>Factor with levels 'Group 1' and 'Group 2'</p>
</dd>
</dl>


<hr>
<h2 id='datatrue_coda'>Simulated true compositional data</h2><span id='topic+datatrue_coda'></span>

<h3>Description</h3>

<p>A data set of 200 simulated 'true' data, from which the observations are deduced, with three observed variables and two groups, compositional
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datatrue_coda
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 4 columns
</p>

<dl>
<dt>Var1</dt><dd><p>simulated variable, compositional</p>
</dd>
<dt>Var2</dt><dd><p>simulated variable, compositional</p>
</dd>
<dt>Var3</dt><dd><p>simulated variable, compositional</p>
</dd>
<dt>Group</dt><dd><p>Factor with levels 'Group 1' and 'Group 2'</p>
</dd>
</dl>


<hr>
<h2 id='force_posdef'>Force positive definiteness</h2><span id='topic+force_posdef'></span>

<h3>Description</h3>

<p>Function to force positive definiteness on a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_posdef(x, verbose = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="force_posdef_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="force_posdef_+3A_verbose">verbose</code></td>
<td>
<p>logical, default TRUE. Should the function print the corrected eigenvalues?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>positive definite matrix
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech
</p>

<hr>
<h2 id='generalized_mean'>Generalized mean</h2><span id='topic+generalized_mean'></span><span id='topic+generalized_mean.default'></span><span id='topic+generalized_mean.rmult'></span>

<h3>Description</h3>

<p>Calculates the generalized mean of a data set by using a given group variance and individual, observation-wise variances for each observation of the data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generalized_mean(x, ...)

## Default S3 method:
generalized_mean(
  x,
  var,
  individual_var = matrix(0, nrow = nrow(x), ncol = ncol(x)),
  ...
)

## S3 method for class 'rmult'
generalized_mean(
  x,
  var,
  individual_var = matrix(0, nrow = nrow(x), ncol = ncol(x)^2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalized_mean_+3A_x">x</code></td>
<td>
<p>a matrix containing the data for which the mean should be calculated</p>
</td></tr>
<tr><td><code id="generalized_mean_+3A_...">...</code></td>
<td>
<p>not implemented</p>
</td></tr>
<tr><td><code id="generalized_mean_+3A_var">var</code></td>
<td>
<p>a matrix containing the corrected (estimated true) group variances</p>
</td></tr>
<tr><td><code id="generalized_mean_+3A_individual_var">individual_var</code></td>
<td>
<p>a matrix containing individual variances. Default is a 0 - matrix with the dimensions of x, can be used for implementing the individual uncertainties</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of lenght of ncol(x) of generalized means
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: for class matrix or data.frame
</p>
</li>
<li> <p><code>rmult</code>: for class rmult of package 'compositions'
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Solveig Pospiech, K. Gerald v.d. Boogaart
</p>

<hr>
<h2 id='predict.vqda'>predict.vqda</h2><span id='topic+predict.vqda'></span><span id='topic+predict.vlda'></span>

<h3>Description</h3>

<p>Classify multivariate observations in conjunction with qda() or lda() of class 'vqda' or 'vlda'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vqda'
predict(object, newdata, newerror, prior = object$prior, ...)

## S3 method for class 'vlda'
predict(object, newdata, newerror, prior = object$prior, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.vqda_+3A_object">object</code></td>
<td>
<p>object of class 'vqda' or 'vlda'.</p>
</td></tr>
<tr><td><code id="predict.vqda_+3A_newdata">newdata</code></td>
<td>
<p>data frame or matrix of cases to be classified or, if object has a formula, a data frame with columns of the same names as the variables used.
A vector will be interpreted as a row vector. If newdata is missing, an attempt will be made to retrieve the data used to fit the qda object.</p>
</td></tr>
<tr><td><code id="predict.vqda_+3A_newerror">newerror</code></td>
<td>
<p>data frame or matrix of uncertainties corresponding to the cases in 'newdata'.</p>
</td></tr>
<tr><td><code id="predict.vqda_+3A_prior">prior</code></td>
<td>
<p>the prior probabilities of group membership. If unspecified, the prior of the object are used.</p>
</td></tr>
<tr><td><code id="predict.vqda_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following components:
<code>class</code> factor containing the predicted group
<code>likelihood</code> matrix of dimension 'number of samples' x 'number of groups', containing the likelihood for each sample to belong to one of the groups
<code>grouping</code> original grouping of the samples, copied from the input object
</p>
<p>list containing the following components:
<code>class</code> factor containing the predicted group
<code>likelihood</code> matrix of dimension 'number of samples' x 'number of groups', containing the likelihood for each sample to belong to one of the groups
<code>grouping</code> original grouping of the samples, copied from the input object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>vqda</code>: predict() for class 'vqda'
</p>
</li>
<li> <p><code>vlda</code>: predict() for class 'vlda'
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Solveig Pospiech, package 'MASS'
</p>

<hr>
<h2 id='uncertainties'>Simulated observation uncertainties</h2><span id='topic+uncertainties'></span>

<h3>Description</h3>

<p>A data set of 200 simulated uncertainties with two variables and two groups, non-compositional
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncertainties
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 3 columns
</p>

<dl>
<dt>Var1</dt><dd><p>simulated observed variable</p>
</dd>
<dt>Var2</dt><dd><p>simulated observed variable</p>
</dd>
<dt>Group</dt><dd><p>Factor with levels 'Group 1' and 'Group 2'</p>
</dd>
</dl>


<hr>
<h2 id='uncertainties_coda'>Simulated observation uncertainties of compositional data</h2><span id='topic+uncertainties_coda'></span>

<h3>Description</h3>

<p>A data set of 200 simulated uncertainties with three variables and two groups, compositional
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncertainties_coda
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 rows and 4 columns
</p>

<dl>
<dt>Var1</dt><dd><p>simulated observed variable, compositional</p>
</dd>
<dt>Var2</dt><dd><p>simulated observed variable, compositional</p>
</dd>
<dt>Var3</dt><dd><p>simulated observed variable, compositional</p>
</dd>
<dt>Group</dt><dd><p>Factor with levels 'Group 1' and 'Group 2'</p>
</dd>
</dl>


<hr>
<h2 id='vlda'>Weighted Linear Discriminant Analysis</h2><span id='topic+vlda'></span>

<h3>Description</h3>

<p>Extension of the qda() of package 'MASS' (not the lda() function) to calculate a LDA incorporating individual, cell-wise uncertainties,
e.g. if the uncertainties are expressed as individual variances for each measurand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlda(x, uncertainties, grouping, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vlda_+3A_x">x</code></td>
<td>
<p>frame or matrix containing the data to be discriminated</p>
</td></tr>
<tr><td><code id="vlda_+3A_uncertainties">uncertainties</code></td>
<td>
<p>data frame or matrix containing the values for uncertainties per cell. Uncertainties should be relative errors, e.g. the relative standard deviation of the  measurand</p>
</td></tr>
<tr><td><code id="vlda_+3A_grouping">grouping</code></td>
<td>
<p>a factor or character vector specifying the group for each observation (row).</p>
</td></tr>
<tr><td><code id="vlda_+3A_prior">prior</code></td>
<td>
<p>the prior probabilities of class membership. If unspecified, the class proportions for the training set are used. If present, the probabilities should be specified in the order of the factor levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uncertainties can be considered in a statistical analysis either by each measured variable, by each observation or by using the individual, cell-wise uncertainties.
There are several methods for incorporating variable-wise or observation-wise uncertainties into a QDA, most of them using the uncertainties as weights for the variables or observations of the data set.
The term 'cell-wise uncertainties' describe a data set of $d$ analysed variables where each observation has an individual uncertainty for each of the $d$ variables conforming it.
Hence, a data set of $n \times d$ data values has associated a data set of $n \times d$ individual uncertainties.
Instead of weighting the columns or rows of the data set, the vlda() function uses uncertainties to recalculate better estimates of the group variances and group means.
It is internally very similar to the <code><a href="#topic+vqda">vqda</a></code> function, but with an averaged group variance for all groups.
If the presence of uncertainties is not accounted for, the decision rules  are based on the group variances calculated by the given data set.
But this observed group variance might deviate notably from the group variance, which can be estimated including the uncertainties.
This methodological framework does not only allow to incorporate cell-wise uncertainties, but also would largely be valid if the information about the co-dependency between uncertainties within each observation would be reported.
</p>


<h3>Value</h3>

<p>object of class 'vlda' containing the following components:
<code>prior</code> the prior probabilities used.
<code>counts</code> counts per group.
<code>means</code> the group means.
<code>generalizedMeans</code> the group means calculated by the function <code><a href="#topic+generalized_mean">generalized_mean</a></code>
<code>groupVarCorrected</code> the group variances calculated by the function <code><a href="#topic+calc_estimate_true_var">calc_estimate_true_var</a></code>
<code>lev</code> the levels of the grouping factor.
<code>grouping</code> the factor specifying the class for each observation.
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech, package 'MASS'
</p>


<h3>References</h3>

<p>Pospiech, S., R. Tolosana-Delgado and K.G. van den Boogaart (2020) Discriminant Analysis for Compositional Data Incorporating Cell-Wise Uncertainties, Mathematical Geosciences
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for non-compositional data:
data("dataobs")
data("uncertainties")
mylda = vlda(x = dataobs[, 1:2], uncertainties = uncertainties[, 1:2], grouping = dataobs$Group)
mypred = predict(mylda, newdata = dataobs[, 1:2], newerror = uncertainties[, 1:2])
forplot = cbind(dataobs, LG1 = mypred$posterior[,1])
if (require("ggplot2")) {
  scatter_plot = ggplot(data = forplot, aes(x = Var1, y = Var2)) +
    geom_point(aes(shape = Group, color = LG1))
  if (require("ggthemes")) {
    scatter_plot = scatter_plot +
        scale_color_gradientn(colours = colorblind_pal()(5))
  }
  scatter_plot
}

# for compositional data
data("dataobs_coda")
data("uncertainties_coda")
require(compositions)
# generate ilr-transformation (from package 'compositions')
data_ilr = ilr(dataobs_coda[, 1:3])
uncert_ilr = t(simplify2array(apply(uncertainties_coda[, 1:3],1,
                       function(Delta) clrvar2ilr(diag(Delta)))))
uncert_ilr = compositions::rmult(uncert_ilr) # change class into rmult from package 'compositions'
mylda_coda = vlda(x = data_ilr, uncertainties = uncert_ilr, grouping = dataobs_coda$Group)
mypred_coda = predict(mylda_coda, newdata = data_ilr, newerror = uncert_ilr)
forplot_coda = cbind(dataobs_coda, LG1 = mypred_coda$posterior[,1])
# if 'ggtern' is installed, you can plot via ggtern:
# if (require("ggtern")) {
#   ternary_plot = ggtern(data = forplot_coda, aes(x = Var1, y = Var2, z = Var3)) +
#     geom_point(aes(shape = Group, color = LG1))
#   if (require("ggthemes")) {
#     ternary_plot = ternary_plot +
#         scale_color_gradientn(colours = colorblind_pal()(5))
#   }
#   ternary_plot
# }

</code></pre>

<hr>
<h2 id='vqda'>Weighted Quadratic Discriminant Analysis</h2><span id='topic+vqda'></span>

<h3>Description</h3>

<p>Extension of the qda() of package 'MASS' to calculate a QDA incorporating individual, cell-wise uncertainties,
e.g. if the uncertainties are expressed as individual variances for each measurand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vqda(x, uncertainties, grouping, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vqda_+3A_x">x</code></td>
<td>
<p>data frame or matrix containing the data to be discriminated</p>
</td></tr>
<tr><td><code id="vqda_+3A_uncertainties">uncertainties</code></td>
<td>
<p>data frame or matrix containing the values for uncertainties per cell. Uncertainties should be relative errors, e.g. the relative standard deviation of the  measurand</p>
</td></tr>
<tr><td><code id="vqda_+3A_grouping">grouping</code></td>
<td>
<p>a factor or character vector specifying the group for each observation (row).</p>
</td></tr>
<tr><td><code id="vqda_+3A_prior">prior</code></td>
<td>
<p>the prior probabilities of class membership. If unspecified, the class proportions for the training set are used. If present, the probabilities should be specified in the order of the factor levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uncertainties can be considered in a statistical analysis either by each measured variable, by each observation or by using the individual, cell-wise uncertainties.
There are several methods for incorporating variable-wise or observation-wise uncertainties into a QDA, most of them using the uncertainties as weights for the variables or observations of the data set.
The term 'cell-wise uncertainties' describe a data set of $d$ analysed variables where each observation has an individual uncertainty for each of the $d$ variables conforming it.
Hence, a data set of $n \times d$ data values has associated a data set of $n \times d$ individual uncertainties.
Instead of weighting the columns or rows of the data set, the vqda() function uses uncertainties to recalculate better estimates of the group variances and group means.
If the presence of uncertainties is not accounted for, the decision rules  are based on the group variances calculated by the given data set.
But this observed group variance might deviate notably from the group variance, which can be estimated including the uncertainties.
This methodological framework does not only allow to incorporate cell-wise uncertainties, but also would largely be valid if the information about the co-dependency between uncertainties within each observation would be reported.
</p>


<h3>Value</h3>

<p>object of class 'vqda' containing the following components:
<code>prior</code> the prior probabilities used.
<code>counts</code> counts per group.
<code>means</code> the group means.
<code>generalizedMeans</code> the group means calculated by the function <code><a href="#topic+generalized_mean">generalized_mean</a></code>
<code>groupVarCorrected</code> the group variances calculated by the function <code><a href="#topic+calc_estimate_true_var">calc_estimate_true_var</a></code>
<code>lev</code> the levels of the grouping factor.
<code>grouping</code> the factor specifying the class for each observation.
</p>


<h3>Author(s)</h3>

<p>Solveig Pospiech, package 'MASS'
</p>


<h3>References</h3>

<p>Pospiech, S., R. Tolosana-Delgado and K.G. van den Boogaart (2020) Discriminant Analysis for Compositional Data Incorporating Cell-Wise Uncertainties, Mathematical Geosciences
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for non-compositional data:
data("dataobs")
data("uncertainties")
myqda = vqda(x = dataobs[, 1:2], uncertainties = uncertainties[, 1:2], grouping = dataobs$Group)
mypred = predict(myqda, newdata = dataobs[, 1:2], newerror = uncertainties[, 1:2])
forplot = cbind(dataobs, LG1 = mypred$posterior[,1])
if (require("ggplot2")) {
  scatter_plot = ggplot(data = forplot, aes(x = Var1, y = Var2)) +
    geom_point(aes(shape = Group, color = LG1))
  if (require("ggthemes")) {
    scatter_plot = scatter_plot +
        scale_color_gradientn(colours = colorblind_pal()(5))
  }
  scatter_plot
}

# for compositional data
data("dataobs_coda")
data("uncertainties_coda")
require(compositions)
# generate ilr-transformation (from package 'compositions')
data_ilr = ilr(dataobs_coda[, 1:3])
uncert_ilr = t(simplify2array(apply(uncertainties_coda[, 1:3],1,
                       function(Delta) clrvar2ilr(diag(Delta)))))
uncert_ilr = compositions::rmult(uncert_ilr) # change class into rmult from package 'compositions'
myqda_coda = vqda(x = data_ilr, uncertainties = uncert_ilr, grouping = dataobs_coda$Group)
mypred_coda = predict(myqda_coda, newdata = data_ilr, newerror = uncert_ilr)
forplot_coda = cbind(dataobs_coda, LG1 = mypred_coda$posterior[,1])
# if 'ggtern' is installed, you can plot via ggtern:
# if (require("ggtern")) {
#   ternary_plot = ggtern(data = forplot_coda, aes(x = Var1, y = Var2, z = Var3)) +
#     geom_point(aes(shape = Group, color = LG1))
#   if (require("ggthemes")) {
#     ternary_plot = ternary_plot +
#         scale_color_gradientn(colours = colorblind_pal()(5))
#   }
#   ternary_plot
# }

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
