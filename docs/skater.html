<!DOCTYPE html><html><head><title>Help for package skater</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {skater}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#arrange_ids'><p>Order IDs across two columns</p></a></li>
<li><a href='#calc_accuracy'><p>Calculate Accuracy</p></a></li>
<li><a href='#calc_stats'><p>Calculate various statistics from a confusion matrix</p></a></li>
<li><a href='#confusion_matrix'><p>Calculate various statistics from a confusion matrix</p></a></li>
<li><a href='#dibble'><p>Degree tibble</p></a></li>
<li><a href='#fam2ped'><p>Fam to pedigree</p></a></li>
<li><a href='#ibd2kin'><p>Compute kinship coefficient from IBD segments</p></a></li>
<li><a href='#interpolate'><p>Interpolate over segments</p></a></li>
<li><a href='#kin2cm'><p>Kinship coefficient to cM</p></a></li>
<li><a href='#kin2degree'><p>Kinship coefficient to degree</p></a></li>
<li><a href='#ped2kinpair'><p>Pedigree to pairwise kinship</p></a></li>
<li><a href='#plot_pedigree'><p>Plot pedigree</p></a></li>
<li><a href='#read_akt'><p>Read AKT kin output file</p></a></li>
<li><a href='#read_fam'><p>Read PLINK-formatted .fam file</p></a></li>
<li><a href='#read_ibd'><p>Read IBD segment file</p></a></li>
<li><a href='#read_ibis'><p>Read IBIS coef output file</p></a></li>
<li><a href='#read_map'><p>Read genetic map file</p></a></li>
<li><a href='#read_plink2_king'><p>Read PLINK KING table</p></a></li>
<li><a href='#skater-package'><p>skater: Utilities for SNP-Based Kinship Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utilities for SNP-Based Kinship Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities for single nucleotide polymorphism (SNP) based kinship analysis
    testing and evaluation. The 'skater' package contains functions for importing, parsing, 
    and analyzing pedigree data, performing relationship degree inference, benchmarking 
    relationship degree classification, and summarizing identity by descent (IBD) segment data.
    Package functions and methods are described in Turner et al. (2021) "skater: An R package 
    for SNP-based Kinship Analysis, Testing, and Evaluation" &lt;<a href="https://doi.org/10.1101%2F2021.07.21.453083">doi:10.1101/2021.07.21.453083</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/signaturescience/skater">https://github.com/signaturescience/skater</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/signaturescience/skater/issues">https://github.com/signaturescience/skater/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, dplyr, tidyr, readr, purrr, kinship2, corrr,
grDevices, tibble, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, markdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-31 13:02:27 UTC; turner</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen Turner <a href="https://orcid.org/0000-0001-9140-9028"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Matthew Scholz <a href="https://orcid.org/0000-0003-3686-1227"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  VP Nagraj <a href="https://orcid.org/0000-0003-0060-566X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Signature Science, LLC. [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen Turner &lt;vustephen@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-31 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code style="white-space: pre;">&#8288;magrittr::[\%&gt;\%][magrittr::pipe]&#8288;</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='arrange_ids'>Order IDs across two columns</h2><span id='topic+arrange_ids'></span>

<h3>Description</h3>

<p>Some types of data or results are indexed by two identifiers in
two different columns corresponding to data points for <em>pairs</em> of
observations. E.g., you may have columns called <code>id1</code> and <code>id2</code> that index
the tibble for all possible pairs of results between samples A, B, and C.
If you attempt to join two tibbles with <code>by=c("id1", "id2")</code>, the join will
fail if samples are flipped from one dataset to another. E.g., one tibble
may have id1=A and id2=B while the other has id1=B and id2=A. This function
ensures that id1 is alphanumerically first while id2 is alphanumerically
second. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange_ids(.data, .id1, .id2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_ids_+3A_.data">.data</code></td>
<td>
<p>A tibble with two ID columns to arrange.</p>
</td></tr>
<tr><td><code id="arrange_ids_+3A_.id1">.id1</code></td>
<td>
<p>Unquoted name of the &quot;id1&quot; column. See examples.</p>
</td></tr>
<tr><td><code id="arrange_ids_+3A_.id2">.id2</code></td>
<td>
<p>Unquoted name of the &quot;id2&quot; column. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with id1 and id2 rearranged alphanumerically.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- tibble::tribble(
  ~id1, ~id2, ~results1,
  "a",  "b",       10L,
  "a",  "c",       20L,
  "c",  "b",       30L
)
d2 &lt;- tibble::tribble(
  ~id1, ~id2,  ~results2,
  "b",  "a",       101L,
  "c",  "a",       201L,
  "b",  "c",       301L
)
# Inner join fails because id1!=id2.
dplyr::inner_join(d1, d2, by=c("id1", "id2"))
# Arrange IDs
d1 %&gt;% arrange_ids(id1, id2)
d2 %&gt;% arrange_ids(id1, id2)
# Inner join
dplyr::inner_join(arrange_ids(d1, id1, id2), arrange_ids(d2, id1, id2), by=c("id1", "id2"))
# Recursively, if you had more than two tibbles
list(d1, d2) %&gt;%
  purrr::map(arrange_ids, id1, id2) %&gt;%
  purrr::reduce(dplyr::inner_join, by=c("id1", "id2"))
</code></pre>

<hr>
<h2 id='calc_accuracy'>Calculate Accuracy</h2><span id='topic+calc_accuracy'></span>

<h3>Description</h3>

<p>Calculates accuracy and related metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_accuracy(tabble)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_accuracy_+3A_tabble">tabble</code></td>
<td>
<p>A frequency table created with <code><a href="base.html#topic+table">table</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates accuracy, lower and upper bounds, the guessing rate and
p-value of the accuracy vs. the guessing rate. This function is called by
<code>confusion_matrix</code>, but if this is all you want, you can simply supply
the table to this function.
</p>


<h3>Value</h3>

<p>A tibble with the corresponding statistics
</p>


<h3>Author(s)</h3>

<p>Michael Clark (see <a href="https://github.com/m-clark/confusionMatrix">m-clark/confusion_matrix</a>).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+binom.test">binom.test</a></code>
</p>

<hr>
<h2 id='calc_stats'>Calculate various statistics from a confusion matrix</h2><span id='topic+calc_stats'></span>

<h3>Description</h3>

<p>Given a frequency table of predictions versus target values,
calculate numerous statistics of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_stats(tabble, prevalence = NULL, positive, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_stats_+3A_tabble">tabble</code></td>
<td>
<p>A frequency table created with <code><a href="base.html#topic+table">table</a></code></p>
</td></tr>
<tr><td><code id="calc_stats_+3A_prevalence">prevalence</code></td>
<td>
<p>Prevalence value. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="calc_stats_+3A_positive">positive</code></td>
<td>
<p>Positive class</p>
</td></tr>
<tr><td><code id="calc_stats_+3A_...">...</code></td>
<td>
<p>Other, not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used within confusion_matrix to calculate various confusion matrix
metrics. This is called by <code>confusion_matrix</code>, but if this is all you
want you can simply supply the table.
</p>
<p>Suppose a 2x2 table with notation
</p>

<table>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: center;"> target </td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: right;"> Predicted </td><td style="text-align: center;"> Event </td><td style="text-align: center;"> No Event
</td>
</tr>
<tr>
 <td style="text-align: right;"> Event </td><td style="text-align: center;"> A </td><td style="text-align: center;"> B </td>
</tr>
<tr>
 <td style="text-align: right;"> No Event </td><td style="text-align: center;"> C </td><td style="text-align: center;"> D </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>

<p>The formulas used here are:
</p>
<p style="text-align: center;"><code class="reqn">Sensitivity = A/(A+C)</code>
</p>

<p style="text-align: center;"><code class="reqn">Specificity = D/(B+D)</code>
</p>

<p style="text-align: center;"><code class="reqn">Prevalence = (A+C)/(A+B+C+D)</code>
</p>

<p style="text-align: center;"><code class="reqn">Positive Predictive Value = (sensitivity * prevalence)/((sensitivity*prevalence) + ((1-specificity)*(1-prevalence)))</code>
</p>

<p style="text-align: center;"><code class="reqn">Negative Predictive Value = (specificity * (1-prevalence))/(((1-sensitivity)*prevalence) + ((specificity)*(1-prevalence)))</code>
</p>
 <p style="text-align: center;"><code class="reqn">Detection Rate = A/(A+B+C+D)</code>
</p>

<p style="text-align: center;"><code class="reqn">Detection Prevalence = (A+B)/(A+B+C+D)</code>
</p>

<p style="text-align: center;"><code class="reqn">Balanced Accuracy = (sensitivity+specificity)/2</code>
</p>

<p style="text-align: center;"><code class="reqn">Precision = A/(A+B)</code>
</p>

<p style="text-align: center;"><code class="reqn">Recall = A/(A+C)</code>
</p>

<p style="text-align: center;"><code class="reqn">F1 = harmonic mean of precision and recall = (1+beta^2)*precision*recall/((beta^2 * precision)+recall)</code>
</p>

<p>where <code>beta = 1</code> for this function.
</p>
<p style="text-align: center;"><code class="reqn">False Discovery Rate = 1 - Positive Predictive Value</code>
</p>

<p style="text-align: center;"><code class="reqn">False Omission Rate = 1 - Negative Predictive Value</code>
</p>

<p style="text-align: center;"><code class="reqn">False Positive Rate = 1 - Specificity</code>
</p>

<p style="text-align: center;"><code class="reqn">False Negative Rate = 1 - Sensitivity</code>
</p>

<p style="text-align: center;"><code class="reqn">D' = qnorm(Sensitivity) - qnorm(1 - Specificity)</code>
</p>

<p style="text-align: center;"><code class="reqn">AUC ~= pnorm(D'/sqrt(2))</code>
</p>

<p>See the references for discussions of the first five formulas.
Abbreviations:
</p>

<dl>
<dt>Positive Predictive Value: PPV</dt><dd></dd>
<dt>Negative Predictive Value: NPV</dt><dd></dd>
<dt>False Discovery Rate: FDR</dt><dd></dd>
<dt>False Omission Rate: FOR</dt><dd></dd>
<dt>False Positive Rate: FPR</dt><dd></dd>
<dt>False Negative Rate: FNR</dt><dd></dd>
</dl>



<h3>Value</h3>

<p>A tibble with (at present) columns for sensitivity, specificity, PPV, NPV, F1 score, detection rate, detection prevalence, balanced accuracy, FDR, FOR, FPR, FNR.  For
more than 2 classes, these statistics are provided for each class.
</p>


<h3>Note</h3>

<p>Different names are used for the same statistics.
</p>

<dl>
<dt>Sensitivity: True Positive Rate, Recall, Hit Rate, Power</dt><dd></dd>
<dt>Specificity: True Negative Rate</dt><dd></dd>
<dt>Positive Predictive Value: Precision</dt><dd></dd>
<dt>False Negative Rate: Miss Rate, Type II error rate, beta</dt><dd></dd>
<dt>False Positive Rate: Fallout, Type I error rate, alpha</dt><dd></dd>
</dl>

<p>This function is called by <code>confusion_matrix</code>, but if this is all you
want, you can simply supply the table to this function.
</p>


<h3>Author(s)</h3>

<p>Michael Clark (see <a href="https://github.com/m-clark/confusionMatrix">m-clark/confusion_matrix</a>).
</p>


<h3>References</h3>

<p>Kuhn, M. (2008), &quot;Building predictive models in R using the
caret package, &quot; <em>Journal of Statistical Software</em>,
(<a href="https://www.jstatsoft.org/article/view/v028i05">https://www.jstatsoft.org/article/view/v028i05</a>).
</p>
<p>Altman, D.G., Bland, J.M. (1994) &quot;Diagnostic tests 1: sensitivity and
specificity&quot;, <em>British Medical Journal</em>, vol 308, 1552.
</p>
<p>Altman, D.G., Bland, J.M. (1994) &quot;Diagnostic tests 2: predictive values,&quot;
<em>British Medical Journal</em>, vol 309, 102.
</p>
<p>Velez, D.R., et. al. (2008) &quot;A balanced accuracy function for epistasis
modeling in imbalanced datasets using multifactor dimensionality
reduction.,&quot; <em>Genetic Epidemiology</em>, vol 4, 306.
</p>

<hr>
<h2 id='confusion_matrix'>Calculate various statistics from a confusion matrix</h2><span id='topic+confusion_matrix'></span>

<h3>Description</h3>

<p>Given a vector of predictions and target values, calculate
numerous statistics of interest. Modified from
<a href="https://github.com/m-clark/confusionMatrix">m-clark/confusion_matrix</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confusion_matrix(
  prediction,
  target,
  positive = NULL,
  prevalence = NULL,
  dnn = c("Predicted", "Target"),
  longer = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confusion_matrix_+3A_prediction">prediction</code></td>
<td>
<p>A vector of predictions</p>
</td></tr>
<tr><td><code id="confusion_matrix_+3A_target">target</code></td>
<td>
<p>A vector of target values</p>
</td></tr>
<tr><td><code id="confusion_matrix_+3A_positive">positive</code></td>
<td>
<p>The positive class for a 2-class setting. Default is
<code>NULL</code>, which will result in using the first level of <code>target</code>.</p>
</td></tr>
<tr><td><code id="confusion_matrix_+3A_prevalence">prevalence</code></td>
<td>
<p>Prevalence rate.  Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="confusion_matrix_+3A_dnn">dnn</code></td>
<td>
<p>The row and column headers for the contingency table returned.
Default is 'Predicted' for rows and 'Target' for columns.</p>
</td></tr>
<tr><td><code id="confusion_matrix_+3A_longer">longer</code></td>
<td>
<p>Transpose the output to long form.  Default is FALSE (requires
<code>tidyr 1.0</code>).</p>
</td></tr>
<tr><td><code id="confusion_matrix_+3A_...">...</code></td>
<td>
<p>Other parameters, not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns accuracy, agreement, and other statistics. See the
functions below to find out more. Originally inspired by the
<code>confusionMatrix</code> function from the <code>caret</code> package.
</p>


<h3>Value</h3>

<p>A list of tibble(s) with the associated statistics and possibly the
frequency table as list column of the first element. If classes contain &gt;1
numeric class and a single non-numeric class (e.g., &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, and
&quot;Unrelated&quot;, the RMSE of the reciprocal of the Targets + 0.5 will also be
returned.)
</p>


<h3>References</h3>

<p>Kuhn, M., &amp; Johnson, K. (2013). Applied predictive modeling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_accuracy">calc_accuracy</a></code> <code><a href="#topic+calc_stats">calc_stats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prediction = c(0,1,1,0,0,1,0,1,1,1)
target     = c(0,1,1,1,0,1,0,1,0,1)
confusion_matrix(prediction, target, positive = '1')

set.seed(42)
prediction = sample(letters[1:4], 250, replace = TRUE, prob = 1:4)
target     = sample(letters[1:4], 250, replace = TRUE, prob = 1:4)
confusion_matrix(prediction, target)

prediction = c(rep(1, 50), rep(2, 40), rep(3, 60))
target     = c(rep(1, 50), rep(2, 50), rep(3, 50))
confusion_matrix(prediction, target)
confusion_matrix(prediction, target) %&gt;% purrr::pluck("Table")
confusion_matrix(prediction, target, longer=TRUE)
confusion_matrix(prediction, target, longer=TRUE) %&gt;%
  purrr::pluck("Other") %&gt;%
  tidyr::spread(Class, Value)

# Prediction with an unrelated class
prediction = c(rep(1, 50), rep(2, 40), rep(3, 60), rep("Unrelated", 55))
target     = c(rep(1, 50), rep(2, 50), rep(3, 55), rep("Unrelated", 50))
confusion_matrix(prediction, target)
# Prediction with two unrelated classes
prediction = c(rep(1, 50), rep(2, 40), rep("Third", 60), rep("Unrelated", 55))
target     = c(rep(1, 50), rep(2, 50), rep("Third", 55), rep("Unrelated", 50))
confusion_matrix(prediction, target)

</code></pre>

<hr>
<h2 id='dibble'>Degree tibble</h2><span id='topic+dibble'></span>

<h3>Description</h3>

<p>Creates a tibble with degree, expected kinship coefficient, and inference boundaries.
</p>
<p>Rows will be created up to the <code>max_degree</code>, with an additional row for any
relationship more distant than <code>max_degree</code>. The <code>degree</code> value for the final
row will be <code>NA</code>. This represents inference criteria for &quot;unrelated&quot;
individuals. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dibble(max_degree = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dibble_+3A_max_degree">max_degree</code></td>
<td>
<p>The most distant degree you want to measure (usually between 3-9, default 3).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the degree, expected kinship coefficient (<code>k</code>),
lower (<code>l</code>) and upper (<code>u</code>) inference bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dibble(3)
dibble(10)

</code></pre>

<hr>
<h2 id='fam2ped'>Fam to pedigree</h2><span id='topic+fam2ped'></span>

<h3>Description</h3>

<p>Converts a <a href="https://www.cog-genomics.org/plink/1.9/formats#fam">PLINK-formatted fam file</a> to a pedigree object using <a href="kinship2.html#topic+pedigree">kinship2::pedigree</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam2ped(fam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fam2ped_+3A_fam">fam</code></td>
<td>
<p>A tibble with six columns of PLINK .fam data as read in by <a href="#topic+read_fam">read_fam</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with new listcol <code>ped</code> containing pedigrees from <code>kinship2::pedigree</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>famfile &lt;- system.file("extdata", "3gens.fam", package="skater", mustWork=TRUE)
fam &lt;- read_fam(famfile)
fam2ped(fam)

</code></pre>

<hr>
<h2 id='ibd2kin'>Compute kinship coefficient from IBD segments</h2><span id='topic+ibd2kin'></span>

<h3>Description</h3>

<p>This function is used to retrieve a relatedness measure from IBD segments.
The relatedness value returned is the kinship coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibd2kin(.ibd_data, .map, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibd2kin_+3A_.ibd_data">.ibd_data</code></td>
<td>
<p>Tibble with IBD segments created using the <a href="#topic+read_ibd">read_ibd</a> function</p>
</td></tr>
<tr><td><code id="ibd2kin_+3A_.map">.map</code></td>
<td>
<p>Tibble with the genetic map data created using the <a href="#topic+read_map">read_map</a> function</p>
</td></tr>
<tr><td><code id="ibd2kin_+3A_type">type</code></td>
<td>
<p>Type of IBD to use for kinship coefficient calculation; must be <code>'IBD1'</code>, <code>'IBD2'</code>, or <code>NULL</code> (both IBD1 and IBD2 will be treated the same); default is <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should be pairwise IBD segments prepared via
<a href="#topic+read_ibd">read_ibd</a>. The function will internally loop over each
chromosome, and use a specified genetic map to convert shared segments to
genetic units. After doing so, the function converts the shared length to a
kinship coefficient by summing <code class="reqn">0.5*IBD2 + 0.25*IBD1</code>.
</p>
<p>Note that the data read in by <a href="#topic+read_ibd">read_ibd</a> when <code>source="pedsim"</code> returns a
list with separate tibbles for IBD1 and IBD2 segments. The current
implementation of this function requires running this function independently
on IBD1 and IBD2 segments, then summarizing (adding) the corresponding
proportions. See examples.
</p>


<h3>Value</h3>

<p>Tibble with three columns:
</p>

<ol>
<li><p> id1 (sample identifier 1)
</p>
</li>
<li><p> id2 (sample identifier 2)
</p>
</li>
<li><p> kinship (kinship coefficent derived from shared segments)
</p>
</li></ol>



<h3>References</h3>

<p>http://faculty.washington.edu/sguy/ibd_relatedness.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pedsim_fp &lt;- system.file("extdata", "GBR.sim.seg.gz", package="skater", mustWork=TRUE)
pedsim_seg &lt;- read_ibd(pedsim_fp, source = "pedsim")
gmapfile &lt;- system.file("extdata", "sexspec-avg-min.plink.map", package="skater", mustWork=TRUE)
gmap &lt;- read_map(gmapfile)
ibd1_dat &lt;- ibd2kin(.ibd_data=pedsim_seg$IBD1, .map=gmap, type="IBD1")
ibd2_dat &lt;- ibd2kin(.ibd_data=pedsim_seg$IBD2, .map=gmap, type="IBD2")
dplyr::bind_rows(ibd1_dat,ibd2_dat) %&gt;%
  dplyr::group_by(id1,id2) %&gt;%
  dplyr::summarise(kinship = sum(kinship), .groups = "drop")

</code></pre>

<hr>
<h2 id='interpolate'>Interpolate over segments</h2><span id='topic+interpolate'></span>

<h3>Description</h3>

<p>This is an unexported helper used in in <a href="#topic+ibd2kin">ibd2kin</a>. The function interpolates over segments to apply genetic length to the segment. It is inspired by Python code distributed by the Browning lab (<a href="http://faculty.washington.edu/sguy/ibd_relatedness.html">documentation</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(ibd_bp, chromgpos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_+3A_ibd_bp">ibd_bp</code></td>
<td>
<p>Base pair for the IBD segment over which to interpolate</p>
</td></tr>
<tr><td><code id="interpolate_+3A_chromgpos">chromgpos</code></td>
<td>
<p>Genetic map data for a specific chromosome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the genetic distance shared at the segment.
</p>


<h3>References</h3>

<p>http://faculty.washington.edu/sguy/ibd_relatedness.html
</p>

<hr>
<h2 id='kin2cm'>Kinship coefficient to cM</h2><span id='topic+kin2cm'></span>

<h3>Description</h3>

<p>&quot;Converts&quot; a kinship coefficient to put on the same scale as shared cM using the formula
<code class="reqn">cm &lt;- pmin(3560, 4*pmax(0, k)*3560)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kin2cm(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kin2cm_+3A_k">k</code></td>
<td>
<p>Kinship coefficient (numeric, typically between 0 and .5, although KING can produce values &lt;0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric estimated cM, ranging from 0-3560.
</p>


<h3>References</h3>

<p><a href="https://dnapainter.com/tools/sharedcmv4">https://dnapainter.com/tools/sharedcmv4</a>.
</p>
<p><a href="https://www.ancestry.com/dna/resource/whitePaper/AncestryDNA-Matching-White-Paper.pdf">https://www.ancestry.com/dna/resource/whitePaper/AncestryDNA-Matching-White-Paper.pdf</a>.
</p>
<p><a href="https://verogen.com/wp-content/uploads/2021/03/snp-typing-uas-kinship-estimation-gedmatch-pro-tech-note-vd2020058-a.pdf">https://verogen.com/wp-content/uploads/2021/03/snp-typing-uas-kinship-estimation-gedmatch-pro-tech-note-vd2020058-a.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kin2cm(.25)
kin2cm(.125)
kin2cm(.0625)
dibble(9) %&gt;% dplyr::mutate(cm=kin2cm(k))

</code></pre>

<hr>
<h2 id='kin2degree'>Kinship coefficient to degree</h2><span id='topic+kin2degree'></span>

<h3>Description</h3>

<p>Infers relationship degree given a kinship coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kin2degree(k, max_degree = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kin2degree_+3A_k">k</code></td>
<td>
<p>Kinship coefficient (numeric, typically between 0 and .5, although KING can produce values &lt;0).</p>
</td></tr>
<tr><td><code id="kin2degree_+3A_max_degree">max_degree</code></td>
<td>
<p>Max degree resolution (default 3). Used to seed
<a href="#topic+dibble">dibble</a>. Anything below the inference range of
<code>max_degree</code> will report <code>NA</code>. See <a href="#topic+dibble">dibble</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with inferred degree, up to the maximum degree in <code>dibble</code> (anything more distant is <code>NA</code>, i.e., unrelated).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kin2degree(0.5)
kin2degree(0.25)
kin2degree(0.125)
kin2degree(0.0625)
kin2degree(0.03125)
kin2degree(0.03125, max_degree=5)
kin2degree(-0.05)
k &lt;- seq(.02, .5, .03)
kin2degree(k)
kin2degree(k, max_degree=5)
tibble::tibble(k=k) %&gt;% dplyr::mutate(degree=kin2degree(k))

</code></pre>

<hr>
<h2 id='ped2kinpair'>Pedigree to pairwise kinship</h2><span id='topic+ped2kinpair'></span>

<h3>Description</h3>

<p>Converts a pedigree class object from <a href="#topic+fam2ped">fam2ped</a> to a pairwise list of relationships and their expected/theoretical kinship coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2kinpair(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped2kinpair_+3A_ped">ped</code></td>
<td>
<p>A &quot;pedigree&quot; class object from <a href="#topic+fam2ped">fam2ped</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing all pairwise kinship coefficients from the input pedigree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>famfile &lt;- system.file("extdata", "3gens.fam", package="skater", mustWork=TRUE)
famfile %&gt;%
  read_fam() %&gt;%
  fam2ped() %&gt;%
  dplyr::mutate(kinpairs=purrr::map(ped, ped2kinpair)) %&gt;%
  dplyr::select(fid, kinpairs) %&gt;%
  tidyr::unnest(cols=kinpairs)
</code></pre>

<hr>
<h2 id='plot_pedigree'>Plot pedigree</h2><span id='topic+plot_pedigree'></span>

<h3>Description</h3>

<p>Plot pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pedigree(ped, file = NULL, width = 10, height = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pedigree_+3A_ped">ped</code></td>
<td>
<p>List of pedigree objects from <a href="#topic+fam2ped">fam2ped</a></p>
</td></tr>
<tr><td><code id="plot_pedigree_+3A_file">file</code></td>
<td>
<p>Output file path (must end in &quot;.pdf&quot;)</p>
</td></tr>
<tr><td><code id="plot_pedigree_+3A_width">width</code></td>
<td>
<p>Width of output PDF</p>
</td></tr>
<tr><td><code id="plot_pedigree_+3A_height">height</code></td>
<td>
<p>Height of output PDF</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='read_akt'>Read AKT kin output file</h2><span id='topic+read_akt'></span>

<h3>Description</h3>

<p>Reads in an <code style="white-space: pre;">&#8288;akt kin&#8288;</code> <a href="https://illumina.github.io/akt/#kin">results file</a>. Input <code>file</code> must have seven columns, whitespace delimited:
</p>

<ol>
<li><p> id1 (member 1)
</p>
</li>
<li><p> id2 (member 2)
</p>
</li>
<li><p> IBD0 (ratio of IBD0/All SNPS)
</p>
</li>
<li><p> IBD1 (ratio of IBD1/All SNPS)
</p>
</li>
<li><p> Kinship Coefficient
</p>
</li>
<li><p> NSNPS
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>read_akt(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_akt_+3A_file">file</code></td>
<td>
<p>Input file path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the 7 columns from the akt file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aktFile &lt;- system.file("extdata", "3gens.akt", package="skater", mustWork=TRUE)
akt &lt;- read_akt(aktFile)
akt

</code></pre>

<hr>
<h2 id='read_fam'>Read PLINK-formatted .fam file</h2><span id='topic+read_fam'></span>

<h3>Description</h3>

<p>Reads in a <a href="https://www.cog-genomics.org/plink/1.9/formats#fam">PLINK-formatted .fam file</a>. Input <code>file</code> must have six columns:
</p>

<ol>
<li><p> Family ID
</p>
</li>
<li><p> Individual ID
</p>
</li>
<li><p> Father ID
</p>
</li>
<li><p> Mother ID
</p>
</li>
<li><p> Sex
</p>
</li>
<li><p> Affected Status
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>read_fam(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fam_+3A_file">file</code></td>
<td>
<p>Input file path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the 6 columns from the fam file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>famfile &lt;- system.file("extdata", "3gens.fam", package="skater", mustWork=TRUE)
fam &lt;- read_fam(famfile)
fam

</code></pre>

<hr>
<h2 id='read_ibd'>Read IBD segment file</h2><span id='topic+read_ibd'></span>

<h3>Description</h3>

<p>Reads in the inferred IBD segments from <code>hapibd</code> (<a href="https://github.com/browning-lab/hap-ibd#output-files">documentation</a>) or IBD segment file generated by <code>ped-sim</code> (<a href="https://github.com/williamslab/ped-sim#output-ibd-segments-file">documentation</a>).
</p>
<p>If reading a <code>hapibd</code> segment file, the input data should have the following columns:
</p>

<ol>
<li><p> First sample identifier
</p>
</li>
<li><p> First sample haplotype index (1 or 2)
</p>
</li>
<li><p> Second sample identifier
</p>
</li>
<li><p> Second sample haplotype index (1 or 2)
</p>
</li>
<li><p> Chromosome
</p>
</li>
<li><p> Base coordinate of first marker in segment
</p>
</li>
<li><p> Base coordinate of last marker in segment
</p>
</li>
<li><p> cM length of IBD segment
</p>
</li></ol>

<p>If read a <code>pedsim</code> segment file, the input data should have the following columns:
</p>

<ol>
<li><p> First sample identifier
</p>
</li>
<li><p> Second sample identifer
</p>
</li>
<li><p> Chromosome
</p>
</li>
<li><p> Physical position start
</p>
</li>
<li><p> Physical position end
</p>
</li>
<li><p> IBD type
</p>
</li>
<li><p> Genetic position start
</p>
</li>
<li><p> Genetic position end
</p>
</li>
<li><p> Genetic length (end - start)
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>read_ibd(file, source)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ibd_+3A_file">file</code></td>
<td>
<p>Input file path</p>
</td></tr>
<tr><td><code id="read_ibd_+3A_source">source</code></td>
<td>
<p>Source of the input file; must be one of <code>"hapibd"</code> or <code>"pedsim"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>source="hapibd"</code>, a tibble is returned.
If <code>source="pedsim"</code>, a list with two tibble elements, <code>IBD1</code> and <code>IBD2</code> is returned.
Both the <code>hapibd</code> tibble, and the two <code>pedsim</code> tibbles contain six columns:
</p>

<ol>
<li><p> id1 (sample identifier 1)
</p>
</li>
<li><p> id2 (sample identifier 2)
</p>
</li>
<li><p> chr (chromosome)
</p>
</li>
<li><p> start (segment bp start coordinate)
</p>
</li>
<li><p> end (segment bp end coordinate)
</p>
</li>
<li><p> length (shared segment length in genetic units, cM)
</p>
</li></ol>



<h3>References</h3>

<p><a href="https://github.com/browning-lab/hap-ibd#output-files">https://github.com/browning-lab/hap-ibd#output-files</a>
</p>
<p><a href="https://github.com/williamslab/ped-sim#output-ibd-segments-file">https://github.com/williamslab/ped-sim#output-ibd-segments-file</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hapibd_fp &lt;- system.file("extdata", "GBR.sim.ibd.gz", package="skater", mustWork=TRUE)
hapibd_seg &lt;- read_ibd(hapibd_fp, source = "hapibd")
pedsim_fp &lt;- system.file("extdata", "GBR.sim.seg.gz", package="skater", mustWork=TRUE)
pedsim_seg &lt;- read_ibd(pedsim_fp, source = "pedsim")
</code></pre>

<hr>
<h2 id='read_ibis'>Read IBIS coef output file</h2><span id='topic+read_ibis'></span>

<h3>Description</h3>

<p>Reads in an <code>ibis</code> <a href="https://github.com/williamslab/ibis">results file</a>. Input <code>file</code> must have six columns, whitespace delimited:
</p>

<ol>
<li><p> id1 (member 1)
</p>
</li>
<li><p> id2 (member 2)
</p>
</li>
<li><p> Kinship Coefficient
</p>
</li>
<li><p> IBD2 (ratio of IBD2/All SNPS)
</p>
</li>
<li><p> Segment count
</p>
</li>
<li><p> Kinship Degree
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>read_ibis(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ibis_+3A_file">file</code></td>
<td>
<p>Input file path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the 6 columns from the ibis file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ibisFile &lt;- system.file("extdata", "3gens.ibis.coef", package="skater", mustWork=TRUE)
ibis &lt;- read_ibis(ibisFile)
ibis

</code></pre>

<hr>
<h2 id='read_map'>Read genetic map file</h2><span id='topic+read_map'></span>

<h3>Description</h3>

<p>This function reads in the content from a genetic map file to translate physical distance to genetic units (i.e. cM). Regardless of the source, the input file must be sex-averaged and in a tab-separated &quot;Plink&quot; format (<a href="https://www.cog-genomics.org/plink/1.9/formats#map">documentation</a>) with the following four columns and no header (i.e. no column names):
</p>

<ol>
<li><p> Chromosome
</p>
</li>
<li><p> Identifier (ignored in <code>read_map()</code>)
</p>
</li>
<li><p> Length (genetic length within the physical position boundary)
</p>
</li>
<li><p> Position (physical position boundary)
</p>
</li></ol>

<p>The columns must be in the order above. Note that only the first, third, and fourth columns are used in the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_map(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_map_+3A_file">file</code></td>
<td>
<p>Input file path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genetic map could come from different sources. One source is the HapMap map distributed by the Browning Lab (<a href="https://bochet.gcc.biostat.washington.edu/beagle/genetic_maps/">documentation</a>). If this map file is used, the non-sex chromosomes can be downloaded and concatenated to a single file as follows:
</p>
<div class="sourceCode"><pre>wget https://bochet.gcc.biostat.washington.edu/beagle/genetic_maps/plink.GRCh37.map.zip
unzip plink.GRCh37.map.zip
cat *chr[0-9]*GRCh37.map | sort -k1,1 -k4,4 --numeric-sort &gt; plink.allchr.GRCh37.map
</pre></div>
<p>Another source is a sex-specific map (&quot;bherer&quot;) originally published by Bherer et al and recommended by the developers of <code>ped-sim</code> for simulating IBD segments (<a href="https://github.com/williamslab/ped-sim#map-file">documentation</a>). To retrieve and prep this map file for simulation:
</p>
<div class="sourceCode"><pre># Get the refined genetic map and extract
wget --no-check-certificate https://github.com/cbherer/Bherer_etal_SexualDimorphismRecombination/raw/master/Refined_genetic_map_b37.tar.gz
tar xvfpz Refined_genetic_map_b37.tar.gz

# Format for ped-sim as per https://github.com/williamslab/ped-sim#map-file-
printf "#chr\tpos\tmale_cM\tfemale_cM\n" &gt; sexspec.pedsim.map
for chr in {1..22}; do
  paste Refined_genetic_map_b37/male_chr$chr.txt Refined_genetic_map_b37/female_chr$chr.txt \
    | awk -v OFS="\t" 'NR &gt; 1 &amp;&amp; $2 == $6 {print $1,$2,$4,$8}' \
    | sed 's/^chr//' &gt;&gt; sexspec.pedsim.map;
done

# Clean up
rm -rf Refined_genetic_map_b37*
</pre></div>
<p>After this, the <code>sexspec.pedsim.map</code> file is ready for use in simulation. However, it must be averaged and reformatted to &quot;Plink format&quot; to use here:
</p>
<div class="sourceCode"><pre>cat sexspec.pedsim.map | grep -v "^#" | awk -v OFS="\t" '{print $1,".",($3+$4)/2,$2}' &gt; sexspec-avg.plink.map
</pre></div>
<p>#' The genetic maps created above are in the tens of megabytes size range. This is trivial to store for most systems but a reduced version would increase portability and ease testing. This &quot;minimum viable genetic map&quot; could be used for testing and as installed package data in an R package for example analysis. Read more about minimum viable genetic maps at:
</p>

<ul>
<li><p> Blog post: <a href="https://hapi-dna.org/2020/11/minimal-viable-genetic-maps/">https://hapi-dna.org/2020/11/minimal-viable-genetic-maps/</a>
</p>
</li>
<li><p> Github repo with python code: <a href="https://github.com/williamslab/min_map">https://github.com/williamslab/min_map</a>
</p>
</li></ul>

<p>The code as written below reduces the averaged sex-specific genetic map from 833776 to 28726 positions (~30X reduction!).
</p>
<div class="sourceCode"><pre># Get minmap script from github
wget https://raw.githubusercontent.com/williamslab/min_map/main/min_map.py

# Create empty minmap
echo -n &gt; sexspec-avg-min.plink.map

# For each autosome...
for chr in {1..22}; do
  echo "Working on chromosome $chr..."
  # First pull out just one chromosome
  grep "^${chr}[[:space:]]" sexspec-avg.plink.map &gt; tmp.${chr}
  # Run the python script on that chromosome.
  # The genetic map column is 3rd column (2nd in 0-start). Physical position is last column (3 in 0-based)
  python3 min_map.py -mapfile tmp.${chr} -chr ${chr} -genetcol 2 -physcol 3 -noheader -error 0.05
  # Strip out the header and reformat back to plink format, and append to minmap file
  cat min_viable_map${chr}.txt | grep -v "^#" | awk -v OFS="\t" '{print $1,".",$4,$2}' &gt;&gt; sexspec-avg-min.plink.map
  # Clean up
  rm -f min_viable_map${chr}.txt tmp.${chr}
done
</pre></div>
<p>This averaged version of the Bherer sex-specific map, reduced to a minimum viable genetic map with at most 5% error, in Plink format, is available as installed package data (see examples). This is useful for testing code, but the full genetic map should be used for most analysis operations.
</p>


<h3>Value</h3>

<p>A tibble containing 3 columns:
</p>

<ol>
<li><p> chr (chromosome)
</p>
</li>
<li><p> value (genetic length within the physical position boundary)
</p>
</li>
<li><p> bp (physical position boundary)
</p>
</li></ol>



<h3>References</h3>

<p><a href="https://www.cog-genomics.org/plink/1.9/formats#map">https://www.cog-genomics.org/plink/1.9/formats#map</a>
</p>
<p><a href="https://bochet.gcc.biostat.washington.edu/beagle/genetic_maps/">https://bochet.gcc.biostat.washington.edu/beagle/genetic_maps/</a>
</p>
<p><a href="https://github.com/williamslab/ped-sim#map-file">https://github.com/williamslab/ped-sim#map-file</a>
</p>
<p><a href="https://www.nature.com/articles/ncomms14994">https://www.nature.com/articles/ncomms14994</a>
</p>
<p><a href="https://www.nature.com/articles/ncomms14994">https://www.nature.com/articles/ncomms14994</a>
</p>
<p><a href="https://github.com/cbherer/Bherer_etal_SexualDimorphismRecombination">https://github.com/cbherer/Bherer_etal_SexualDimorphismRecombination</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gmapfile &lt;- system.file("extdata", "sexspec-avg-min.plink.map", package="skater", mustWork=TRUE)
gmap &lt;- read_map(gmapfile)

</code></pre>

<hr>
<h2 id='read_plink2_king'>Read PLINK KING table</h2><span id='topic+read_plink2_king'></span>

<h3>Description</h3>

<p>Reads in the output from <code>plink2 --make-king-table</code> (<a href="https://www.cog-genomics.org/plink/2.0/distance#make_king">documentation</a>).
Input <code>file</code> must have six columns, tab delimited:
</p>

<ol>
<li><p> id1 (member 1)
</p>
</li>
<li><p> id2 (member 2)
</p>
</li>
<li><p> nsnps
</p>
</li>
<li><p> hethet: proportion of sites where both are heterozygous
</p>
</li>
<li><p> k: Kinship Coefficient
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>read_plink2_king(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_plink2_king_+3A_file">file</code></td>
<td>
<p>Input file path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the 6 columns from the <code>plink2 --make-king-table</code> output.
</p>


<h3>References</h3>

<p><a href="https://www.cog-genomics.org/plink/2.0/distance#make_king">https://www.cog-genomics.org/plink/2.0/distance#make_king</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plink2kingFile &lt;- system.file("extdata", "plink2-king-table.tsv", package="skater", mustWork=TRUE)
plink2king &lt;- read_plink2_king(plink2kingFile)
plink2king
plink2king %&gt;% dplyr::filter(k&gt;0.01)

</code></pre>

<hr>
<h2 id='skater-package'>skater: Utilities for SNP-Based Kinship Analysis</h2><span id='topic+skater'></span><span id='topic+skater-package'></span>

<h3>Description</h3>

<p>Utilities for single nucleotide polymorphism (SNP) based kinship analysis testing and evaluation. The 'skater' package contains functions for importing, parsing, and analyzing pedigree data, performing relationship degree inference, benchmarking relationship degree classification, and summarizing identity by descent (IBD) segment data. Package functions and methods are described in Turner et al. (2021) &quot;skater: An R package for SNP-based Kinship Analysis, Testing, and Evaluation&quot; <a href="https://doi.org/10.1101/2021.07.21.453083">doi:10.1101/2021.07.21.453083</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stephen Turner <a href="mailto:vustephen@gmail.com">vustephen@gmail.com</a> (<a href="https://orcid.org/0000-0001-9140-9028">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Matthew Scholz (<a href="https://orcid.org/0000-0003-3686-1227">ORCID</a>)
</p>
</li>
<li><p> VP Nagraj (<a href="https://orcid.org/0000-0003-0060-566X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Signature Science, LLC. [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/signaturescience/skater">https://github.com/signaturescience/skater</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/signaturescience/skater/issues">https://github.com/signaturescience/skater/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
