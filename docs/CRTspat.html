<!DOCTYPE html><html lang="en"><head><title>Help for package CRTspat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CRTspat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CRTspat-package'><p>CRTspat: Workflow for Cluster Randomised Trials with Spillover</p></a></li>
<li><a href='#aggregateCRT'><p>Aggregate data across records with duplicated locations</p></a></li>
<li><a href='#anonymize_site'><p>Anonymize locations of a trial site</p></a></li>
<li><a href='#coef.CRTanalysis'><p>Extract model coefficients</p></a></li>
<li><a href='#compute_distance'><p>Compute distance or surround values for a cluster randomized trial</p></a></li>
<li><a href='#compute_mesh'><p>Create INLA mesh for spatial analysis</p></a></li>
<li><a href='#CRTanalysis'><p>Analysis of cluster randomized trial with spillover</p></a></li>
<li><a href='#CRTpower'><p>Power and sample size calculations for a cluster randomized trial</p></a></li>
<li><a href='#CRTsp'><p>Create or update a <code>"CRTsp"</code> object</p></a></li>
<li><a href='#CRTwrite'><p>Export of GIS layer from <code>'CRTsp'</code></p></a></li>
<li><a href='#fitted.CRTanalysis'><p>Extract model fitted values</p></a></li>
<li><a href='#latlong_as_xy'><p>Convert lat long co-ordinates to x,y</p></a></li>
<li><a href='#plotCRT'><p>Graphical displays of the geography of a CRT</p></a></li>
<li><a href='#predict.CRTanalysis'><p>Model predictions</p></a></li>
<li><a href='#randomizeCRT'><p>Randomize a two-armed cluster trial</p></a></li>
<li><a href='#readdata'><p>Read example dataset</p></a></li>
<li><a href='#residuals.CRTanalysis'><p>Extract model residuals</p></a></li>
<li><a href='#simulateCRT'><p>Simulation of cluster randomized trial with spillover</p></a></li>
<li><a href='#specify_buffer'><p>Specification of buffer zone in a cluster randomized trial</p></a></li>
<li><a href='#specify_clusters'><p>Assign locations to clusters in a CRT</p></a></li>
<li><a href='#summary.CRTanalysis'><p>Summary of the results of a statistical analysis of a CRT</p></a></li>
<li><a href='#summary.CRTsp'><p>Summary description of a <code>"CRTsp"</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Workflow for Cluster Randomised Trials with Spillover</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Smith &lt;Thomas-a.Smith@unibas.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Design, workflow and statistical analysis of Cluster Randomised Trials of (health) interventions where there may be spillover between the arms (see <a href="https://thomasasmith.github.io/index.html">https://thomasasmith.github.io/index.html</a>). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/stable/">https://inla.r-inla-download.org/R/stable/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, stats, utils, MASS, tidyr, magrittr, dplyr, OOR,
lme4, sf, Matrix, spatstat.geom, spatstat.random, jagsUI, TSP,
gee, sp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, INLA, testthat (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-27 18:02:10 UTC; smith</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Smith <a href="https://orcid.org/0000-0002-3650-9381"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Lea Multerer [ctb],
  Mariah Silkey [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-27 18:20:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='CRTspat-package'>CRTspat: Workflow for Cluster Randomised Trials with Spillover</h2><span id='topic+CRTspat'></span><span id='topic+CRTspat-package'></span>

<h3>Description</h3>

<p>Design, workflow and statistical analysis of Cluster Randomised Trials of (health) interventions where there may be spillover between the arms (see <a href="https://thomasasmith.github.io/index.html">https://thomasasmith.github.io/index.html</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Smith <a href="mailto:Thomas-a.Smith@unibas.ch">Thomas-a.Smith@unibas.ch</a> (<a href="https://orcid.org/0000-0002-3650-9381">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Lea Multerer [contributor]
</p>
</li>
<li><p> Mariah Silkey [contributor]
</p>
</li></ul>


<hr>
<h2 id='aggregateCRT'>Aggregate data across records with duplicated locations</h2><span id='topic+aggregateCRT'></span>

<h3>Description</h3>

<p><code>aggregateCRT</code> aggregates data from a <code>"CRTsp"</code> object or trial data frame containing multiple records with the same location,
and outputs a list of class <code>"CRTsp"</code> containing single values for each location, for both the coordinates and the auxiliary variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateCRT(trial, auxiliaries = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregateCRT_+3A_trial">trial</code></td>
<td>
<p>An object of class <code>"CRTsp"</code> containing locations (x,y) and variables to be summed</p>
</td></tr>
<tr><td><code id="aggregateCRT_+3A_auxiliaries">auxiliaries</code></td>
<td>
<p>vector of names of auxiliary variables to be summed across each location</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables that in the trial dataframe that are not included in <code>auxiliaries</code> are retained in the output
algorithm <code>"CRTsp"</code> object, with the value corresponding to that of the first record for the location
in the input data frame
</p>


<h3>Value</h3>

<p>A list of class <code>"CRTsp"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
trial &lt;- readdata('example_site.csv')
trial$base_denom &lt;- 1
aggregated &lt;- aggregateCRT(trial, auxiliaries = c("RDT_test_result","base_denom"))
}
</code></pre>

<hr>
<h2 id='anonymize_site'>Anonymize locations of a trial site</h2><span id='topic+anonymize_site'></span>

<h3>Description</h3>

<p><code>anonymize_site</code> transforms coordinates to remove potential identification information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anonymize_site(trial, ID = NULL, latvar = "lat", longvar = "long")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anonymize_site_+3A_trial">trial</code></td>
<td>
<p><code>"CRTsp"</code> object or trial data frame with co-ordinates of households</p>
</td></tr>
<tr><td><code id="anonymize_site_+3A_id">ID</code></td>
<td>
<p>name of column used as an identifier for the points</p>
</td></tr>
<tr><td><code id="anonymize_site_+3A_latvar">latvar</code></td>
<td>
<p>name of column containing latitudes in decimal degrees</p>
</td></tr>
<tr><td><code id="anonymize_site_+3A_longvar">longvar</code></td>
<td>
<p>name of column containing longitudes in decimal degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coordinates are transformed to support confidentiality of
information linked to households by replacing precise geo-locations with transformed co-ordinates which preserve distances
but not positions. The input may have either <code>lat long</code> or <code>x,y</code> coordinates.
The function first searches for any <code>lat long</code> co-ordinates and converts these to <code>x,y</code>
Cartesian coordinates. These are then are rotated by a random angle about a random origin. The returned object
has transformed co-ordinates re-centred at the origin. Centroids stored in the <code>"CRTsp"</code> object are removed.
Other data are unchanged.
</p>


<h3>Value</h3>

<p>A list of class <code>"CRTsp"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Rotate and reflect test site locations
transformedTestlocations &lt;- anonymize_site(trial =  readdata("exampleCRT.txt"))
</code></pre>

<hr>
<h2 id='coef.CRTanalysis'>Extract model coefficients</h2><span id='topic+coef.CRTanalysis'></span>

<h3>Description</h3>

<p><code>coef.CRTanalysis</code> method for extracting model fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRTanalysis'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.CRTanalysis_+3A_object">object</code></td>
<td>
<p>CRTanalysis object</p>
</td></tr>
<tr><td><code id="coef.CRTanalysis_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the model coefficients returned by the statistical model run within the <code>CRTanalysis</code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{example &lt;- readdata('exampleCRT.txt')
exampleGEE &lt;- CRTanalysis(example, method = "GEE")
coef(exampleGEE)
}
</code></pre>

<hr>
<h2 id='compute_distance'>Compute distance or surround values for a cluster randomized trial</h2><span id='topic+compute_distance'></span>

<h3>Description</h3>

<p><code>compute_distance</code> computes distance or surround values for a cluster randomized trial (CRT)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_distance(
  trial,
  distance = "nearestDiscord",
  scale_par = NULL,
  auxiliary = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_distance_+3A_trial">trial</code></td>
<td>
<p>an object of class <code>"CRTsp"</code> or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor <code>cluster</code>), and arm assignments (factor <code>arm</code>).</p>
</td></tr>
<tr><td><code id="compute_distance_+3A_distance">distance</code></td>
<td>
<p>the quantity(s) to be computed. Options are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"nearestDiscord"</code> </td><td style="text-align: left;"> distance to nearest discordant location (km)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"distanceAssigned"</code> </td><td style="text-align: left;"> distance to the nearest pixel in the assigned cluster (km)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"disc"</code> </td><td style="text-align: left;"> disc </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"kern"</code> </td><td style="text-align: left;"> kernel-based measure </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"hdep"</code> </td><td style="text-align: left;"> Tukey half space depth</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"sdep"</code> </td><td style="text-align: left;"> simplicial depth</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="compute_distance_+3A_scale_par">scale_par</code></td>
<td>
<p>scale parameter equal to the disc radius in km if <code>distance = "disc"</code>
or to the standard deviance of the kernels if <code>distance = "kern"</code></p>
</td></tr>
<tr><td><code id="compute_distance_+3A_auxiliary">auxiliary</code></td>
<td>
<p><code>"CRTsp"</code> object containing external cluster and or arm assignments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each selected distance measure, the function first checks whether the variable is already present, and carries out
the calculations only if the corresponding field is absent from the <code>trial</code> data frame.<br /><br />
If <code>distance = "nearestDiscord"</code> is selected the computed values are Euclidean distances
assigned a positive sign for the intervention arm of the trial, and a negative sign for the control arm.<br /><br />
If <code>distance = "distanceAssigned"</code> is selected the computed values are Euclidean distances
to the nearest pixel in the <code>auxiliary</code> <code>"CRTsp"</code> object.<br /><br />
If <code>distance = "disc"</code> is specified, the disc statistic is computed for each location as the number of locations
within the specified radius that are in the intervention arm
(<a href="https://onlinelibrary.wiley.com/doi/full/10.1111/biom.13316">Anaya-Izquierdo &amp; Alexander(2020)</a>). The input
value of <code>scale_par</code> is stored in the <code>design</code> list
of the output <code>"CRTsp"</code> object. Recalculation is carried out if the input value of
<code>scale_par</code> differs from the one in the input <code>design</code> list. The value of the the surround calculated
based on intervened locations is divided by the value of the surround calculated on the basis of all locations, so the
value returned is a proportion.<br /><br />
If <code>distance = "kern"</code> is specified, the Normal curve with standard deviation
<code>scale_par</code> is used to simulate diffusion of the intervention effect by Euclidean
distance. For each location in the trial, the contributions of all intervened locations are
summed. As with <code>distance = "disc"</code>, when <code>distance = "kern"</code> the surround calculated
based on intervened locations is divided by the value of the surround calculated on the basis of all locations, so the
value returned is a proportion.<br /><br />
If either <code>distance = "hdep"</code> or <code>distance = "sdep"</code> is specified then both the simplicial depth and
Tukey half space depth are calculated using the algorithm of
<a href="https://www.jstor.org/stable/2986073">Rousseeuw &amp; Ruts(1996)</a>. The half-depth probability within the intervention cloud (di) is computed
with respect to other locations in the intervention arm (<a href="https://onlinelibrary.wiley.com/doi/full/10.1111/biom.13316">Anaya-Izquierdo &amp; Alexander(2020)</a>). The half-depth within
the half-depth within the control cloud (dc) is also computed. <code>CRTspat</code> returns the proportion di/(dc + di). <br /><br />
If an auxiliary <code>auxiliary</code> <code>"CRTsp"</code> object is specified then either <code>distanceAssigned</code> or <code>nearestDiscord</code> (the default)
is computed with respect to the assignments in the auxiliary. If the auxiliary is a grid with <code>design$geometry</code> set to <code>'triangle'</code>,
<code>'square'</code> or <code>'hexagon'</code> then the distance is computed to the edge of the nearest grid pixel in the discordant arm
(using a circular approximation for the perimeter) rather than to the point location itself.<br />
</p>


<h3>Value</h3>

<p>The input <code>"CRTsp"</code> object with additional column(s) added to the <code>trial</code> data frame
with variable name corresponding to the input value of <code>distance</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
# Calculate the disc with a radius of 0.5 km
exampletrial &lt;- compute_distance(trial = readdata('exampleCRT.txt'),
distance = 'disc', scale_par = 0.5)
}
</code></pre>

<hr>
<h2 id='compute_mesh'>Create INLA mesh for spatial analysis</h2><span id='topic+compute_mesh'></span>

<h3>Description</h3>

<p><code>compute_mesh</code> create objects required for INLA analysis of an object of class <code>"CRTsp"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mesh(
  trial = trial,
  offset = -0.1,
  max.edge = 0.25,
  inla.alpha = 2,
  maskbuffer = 0.5,
  pixel = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_mesh_+3A_trial">trial</code></td>
<td>
<p>an object of class <code>"CRTsp"</code> or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor <code>cluster</code>), and arm assignments (factor <code>arm</code>) and outcome.</p>
</td></tr>
<tr><td><code id="compute_mesh_+3A_offset">offset</code></td>
<td>
<p>see <code>inla.mesh.2d</code> documentation</p>
</td></tr>
<tr><td><code id="compute_mesh_+3A_max.edge">max.edge</code></td>
<td>
<p>see <code>inla.mesh.2d</code> documentation</p>
</td></tr>
<tr><td><code id="compute_mesh_+3A_inla.alpha">inla.alpha</code></td>
<td>
<p>parameter related to the smoothness (see <code>inla</code> documentation)</p>
</td></tr>
<tr><td><code id="compute_mesh_+3A_maskbuffer">maskbuffer</code></td>
<td>
<p>numeric: width of buffer around points (km)</p>
</td></tr>
<tr><td><code id="compute_mesh_+3A_pixel">pixel</code></td>
<td>
<p>numeric: size of pixel (km)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compute_mesh</code> carries out the computationally intensive steps required for setting-up an
INLA analysis of an object of class <code>"CRTsp"</code>, creating the prediction mesh and the projection matrices.
The mesh can be reused for different models fitted to the same
geography. The computational resources required depend largely on the resolution of the prediction mesh.
The prediction mesh is thinned to include only pixels centred at a distance less than
<code>maskbuffer</code> from the nearest point.<br />
A warning may be generated if the <code>Matrix</code> library is not loaded.
</p>


<h3>Value</h3>

<p>list
</p>

<ul>
<li> <p><code>prediction</code> Data frame containing the prediction points and covariate values
</p>
</li>
<li> <p><code>A</code> projection matrix from the observations to the mesh nodes.
</p>
</li>
<li> <p><code>Ap</code> projection matrix from the prediction points to the mesh nodes.
</p>
</li>
<li> <p><code>indexs</code> index set for the SPDE model
</p>
</li>
<li> <p><code>spde</code> SPDE model
</p>
</li>
<li> <p><code>pixel</code> pixel size (km)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>{
# low resolution mesh for test dataset
library(Matrix)
library(sp)
example &lt;- readdata('exampleCRT.txt')
exampleMesh=compute_mesh(example, pixel = 0.5)
}
</code></pre>

<hr>
<h2 id='CRTanalysis'>Analysis of cluster randomized trial with spillover</h2><span id='topic+CRTanalysis'></span>

<h3>Description</h3>

<p><code>CRTanalysis</code> carries out a statistical analysis of a cluster randomized trial (CRT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRTanalysis(
  trial,
  method = "GEE",
  distance = "nearestDiscord",
  scale_par = NULL,
  cfunc = "L",
  link = "logit",
  numerator = "num",
  denominator = "denom",
  excludeBuffer = FALSE,
  alpha = 0.05,
  baselineOnly = FALSE,
  baselineNumerator = "base_num",
  baselineDenominator = "base_denom",
  personalProtection = FALSE,
  clusterEffects = TRUE,
  spatialEffects = FALSE,
  requireMesh = FALSE,
  inla_mesh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CRTanalysis_+3A_trial">trial</code></td>
<td>
<p>an object of class <code>"CRTsp"</code> or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor <code>cluster</code>), and arm assignments (factor <code>arm</code>) and outcome data (see details).</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_method">method</code></td>
<td>
<p>statistical method with options:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"EMP"</code> </td><td style="text-align: left;"> simple averages of the data   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"T"</code>   </td><td style="text-align: left;"> comparison of cluster means by t-test </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"GEE"</code> </td><td style="text-align: left;"> Generalised Estimating Equations </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"LME4"</code> </td><td style="text-align: left;"> Generalized Linear Mixed-Effects Models </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"INLA"</code></td><td style="text-align: left;"> Integrated Nested Laplace Approximation (INLA) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"MCMC"</code></td><td style="text-align: left;"> Markov chain Monte Carlo using <code>"JAGS"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"WCA"</code></td><td style="text-align: left;"> Within cluster analysis </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_distance">distance</code></td>
<td>
<p>Measure of distance or surround with options: <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"nearestDiscord"</code> </td><td style="text-align: left;"> distance to nearest discordant location (km)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"disc"</code> </td><td style="text-align: left;"> disc</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"kern"</code> </td><td style="text-align: left;"> surround based on sum of normal kernels</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"hdep"</code> </td><td style="text-align: left;"> Tukey half space depth</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"sdep"</code> </td><td style="text-align: left;"> simplicial depth</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_scale_par">scale_par</code></td>
<td>
<p>numeric: pre-specified value of the spillover parameter or disc radius for models where this is fixed (<code>cfunc = "R"</code>).<br /><br /></p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_cfunc">cfunc</code></td>
<td>
<p>transformation defining the spillover function with options:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"Z"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> arm effects not considered</td><td style="text-align: left;"> reference model</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"X"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> spillover not modelled</td><td style="text-align: left;"> the only valid value of <code>cfunc</code> for methods <code>"EMP"</code>, <code>"T"</code> and <code>"GEE"</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"L"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> inverse logistic (sigmoid)</td><td style="text-align: left;"> the default for <code>"INLA"</code> and <code>"MCMC"</code> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"P"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> inverse probit (error function)</td><td style="text-align: left;"> available with <code>"INLA"</code> and <code>"MCMC"</code> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"S"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> piecewise linear</td><td style="text-align: left;"> only available with the <code>"MCMC"</code> method</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"E"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> estimation of scale factor</td><td style="text-align: left;"> only available with <code>distance = "disc"</code> or <code>distance = "kern"</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"R"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> rescaled linear</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_link">link</code></td>
<td>
<p>link function with options:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"logit"</code></td><td style="text-align: left;"> (the default). <code>numerator</code> has a binomial distribution with denominator <code>denominator</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"log"</code>  </td><td style="text-align: left;"> <code>numerator</code> is Poisson distributed with an offset of log(<code>denominator</code>).</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"cloglog"</code> </td><td style="text-align: left;"> <code>numerator</code> is Bernoulli distributed with an offset of log(<code>denominator</code>).</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"identity"</code></td><td style="text-align: left;"> The outcome is <code>numerator/denominator</code> with a normally distributed error function.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_numerator">numerator</code></td>
<td>
<p>string: name of numerator variable for outcome</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_denominator">denominator</code></td>
<td>
<p>string: name of denominator variable for outcome data (if present)</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_excludebuffer">excludeBuffer</code></td>
<td>
<p>logical: indicator of whether any buffer zone (records with <code>buffer=TRUE</code>) should be excluded from analysis</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_alpha">alpha</code></td>
<td>
<p>numeric: confidence level for confidence intervals and credible intervals</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_baselineonly">baselineOnly</code></td>
<td>
<p>logical: indicator of whether required analysis is of effect size or of baseline only</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_baselinenumerator">baselineNumerator</code></td>
<td>
<p>string: name of numerator variable for baseline data (if present)</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_baselinedenominator">baselineDenominator</code></td>
<td>
<p>string: name of denominator variable for baseline data (if present)</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_personalprotection">personalProtection</code></td>
<td>
<p>logical: indicator of whether the model includes local effects with no spillover</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_clustereffects">clusterEffects</code></td>
<td>
<p>logical: indicator of whether the model includes cluster random effects</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_spatialeffects">spatialEffects</code></td>
<td>
<p>logical: indicator of whether the model includes spatial random effects
(available only for <code>method = "INLA"</code>)</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_requiremesh">requireMesh</code></td>
<td>
<p>logical: indicator of whether spatial predictions are required
(available only for <code>method = "INLA"</code>)</p>
</td></tr>
<tr><td><code id="CRTanalysis_+3A_inla_mesh">inla_mesh</code></td>
<td>
<p>string: name of pre-existing INLA input object created by <code>compute_mesh()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CRTanalysis</code> is a wrapper for the statistical analysis packages:
<a href="https://CRAN.R-project.org/package=gee">gee</a>,
<a href="https://www.r-inla.org/">INLA</a>,
<a href="https://CRAN.R-project.org/package=jagsUI">jagsUI</a>,
and the <a href="https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/t.test">t.test</a>
function of package <code>stats</code>.<br /><br />
The wrapper does not provide an interface to the full functionality of these packages.
It is specific for typical analyses of cluster randomized trials with geographical clustering. Further details
are provided in the <a href="https://thomasasmith.github.io/articles/Usecase5.html">vignette</a>.<br /><br />
The key results of the analyses can be extracted using a <code>summary()</code> of the output list.
The <code>model_object</code> in the output list is the usual output from the statistical analysis routine,
and can be also be inspected with <code>summary()</code>, or analysed using <code>stats::fitted()</code>
for purposes of evaluation of model fit etc..<br /><br />
For models with a complementary log-log link function specified with <code>link = "cloglog"</code>.
the numerator must be coded as 0 or 1. Technically the binomial denominator is then 1.
The value of <code>denominator</code> is used as a rate multiplier.<br /><br />
With the <code>"INLA"</code> and <code>"MCMC"</code> methods 'iid' random effects are used to model extra-Poisson variation.<br /><br />
Interval estimates for the coefficient of variation of the cluster level outcome are calculated using the method of
<a href="https://www.jstor.org/stable/2685039">Vangel (1996)</a>.
</p>


<h3>Value</h3>

<p>list of class <code>CRTanalysis</code> containing the following results of the analysis:
</p>

<ul>
<li> <p><code>description</code> : description of the dataset
</p>
</li>
<li> <p><code>method</code> : statistical method
</p>
</li>
<li> <p><code>pt_ests</code> : point estimates
</p>
</li>
<li> <p><code>int_ests</code> : interval estimates
</p>
</li>
<li> <p><code>model_object</code> : object returned by the fitting routine
</p>
</li>
<li> <p><code>spillover</code> : function values and statistics describing the estimated spillover
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
example &lt;- readdata('exampleCRT.txt')
# Analysis of test dataset by t-test
exampleT &lt;- CRTanalysis(example, method = "T")
summary(exampleT)
# Standard GEE analysis of test dataset ignoring spillover
exampleGEE &lt;- CRTanalysis(example, method = "GEE")
summary(exampleGEE)
# LME4 analysis with error function spillover function
exampleLME4 &lt;- CRTanalysis(example, method = "LME4", cfunc = "P")
summary(exampleLME4)

</code></pre>

<hr>
<h2 id='CRTpower'>Power and sample size calculations for a cluster randomized trial</h2><span id='topic+CRTpower'></span>

<h3>Description</h3>

<p><code>CRTpower</code> carries out power and sample size calculations for cluster randomized trials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRTpower(
  trial = NULL,
  locations = NULL,
  alpha = 0.05,
  desiredPower = 0.8,
  effect = NULL,
  yC = NULL,
  outcome_type = "d",
  sigma2 = NULL,
  denominator = 1,
  N = 1,
  ICC = NULL,
  cv_percent = NULL,
  c = NULL,
  sd_h = 0,
  spillover_interval = 0,
  contaminate_pop_pr = 0,
  distance_distribution = "normal"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CRTpower_+3A_trial">trial</code></td>
<td>
<p>dataframe or <code>'CRTsp'</code> object: optional list of locations</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_locations">locations</code></td>
<td>
<p>numeric: total number of units available for randomization (required if <code>trial</code> is not specified)</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_alpha">alpha</code></td>
<td>
<p>numeric: confidence level</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_desiredpower">desiredPower</code></td>
<td>
<p>numeric: desired power</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_effect">effect</code></td>
<td>
<p>numeric: required effect size</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_yc">yC</code></td>
<td>
<p>numeric: baseline (control) value of outcome</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_outcome_type">outcome_type</code></td>
<td>
<p>character: with options -
<code>'y'</code>: continuous;
<code>'n'</code>: count;
<code>'e'</code>: event rate;
<code>'p'</code>: proportion;
<code>'d'</code>: dichotomous.</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_sigma2">sigma2</code></td>
<td>
<p>numeric: variance of the outcome (required for <code>outcome_type = 'y'</code>)</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_denominator">denominator</code></td>
<td>
<p>numeric: rate multiplier (for <code>outcome_type = 'n'</code> or <code>outcome_type = 'e'</code>)</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_n">N</code></td>
<td>
<p>numeric: mean of the denominator for proportions (for <code>outcome_type = 'p'</code>)</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_icc">ICC</code></td>
<td>
<p>numeric: Intra-cluster correlation</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_cv_percent">cv_percent</code></td>
<td>
<p>numeric: Coefficient of variation of the outcome (expressed as a percentage)</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_c">c</code></td>
<td>
<p>integer: number of clusters in each arm (required if <code>trial</code> is not specified)</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_sd_h">sd_h</code></td>
<td>
<p>numeric: standard deviation of number of units per cluster (required if <code>trial</code> is not specified)</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_spillover_interval">spillover_interval</code></td>
<td>
<p>numeric:  95% spillover interval (km)</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_contaminate_pop_pr">contaminate_pop_pr</code></td>
<td>
<p>numeric: Proportion of the locations within the 95% spillover interval.</p>
</td></tr>
<tr><td><code id="CRTpower_+3A_distance_distribution">distance_distribution</code></td>
<td>
<p>numeric: algorithm for computing distribution of spillover, with options -
<code>'empirical'</code>: empirical distribution;
<code>'normal'</code>: normal distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Power and sample size calculations are for an unmatched two-arm trial. For counts
or event rate data the formula of Hayes &amp; Bennett (1999), Int. J. Epi., 28(2) pp319â€“326 is used. This requires as an input the
between cluster coefficient of variation (<code>cv_percent</code>). For continuous outcomes and proportions the formulae of
<a href="https://bmcmedresmethodol.biomedcentral.com/articles/10.1186/1471-2288-11-102">Hemming et al, 2011</a> are used. These make use of
the intra-cluster correlation in the outcome (<code>ICC</code>) as an input. If the coefficient of variation and not the ICC is supplied then
the intra-cluster correlation is computed from the coefficient of variation using the formulae
from <a href="https://www.taylorfrancis.com/books/mono/10.1201/9781584888178/cluster-randomised-trials-richard-hayes-lawrence-moulton">Hayes &amp; Moulton</a>. If incompatible values for <code>ICC</code> and <code>cv_percent</code> are supplied
then the value of the <code>ICC</code> is used.<br /><br />
The calculations do not consider any loss in power due to loss to follow-up and by default there is no adjustment for effects of spillover.<br /><br />
Spillover bias can be allowed for using a diffusion model of mosquito movement. If no location or arm assignment information is available
then <code>contaminate_pop_pr</code> is used to parameterize the model using a normal approximation for the distribution of distance
to discordant locations.<br /><br />
If a trial data frame or <code>'CRTsp'</code> object is input then this is used to determine the number of locations. If this input object
contains cluster assignments then the numbers and sizes of clusters in the input data are used to estimate the power.
If <code>spillover_interval &gt; 0</code> and <code>distance_distribution = 'empirical'</code> then effects of spillover are
incorporated into the power calculations based on the empirical distribution of distances to the nearest
discordant location. (If <code>distance_distribution is not equal to 'empirical'</code> then the distribution of distances is assumed to
be normal.<br /><br />
If geolocations are not input then power and sample size calculations are based on the scalar input parameters.<br /><br />
If buffer zones have been specified in the <code>'CRTsp'</code> object then separate calculations are made for the core area and for the full site.<br /><br />
The output is an object of class <code>'CRTsp'</code> containing any input trial data frame and values for:
</p>

<ul>
<li><p> The required numbers of clusters to achieve the specified power.
</p>
</li>
<li><p> The design effect based on the input ICC.
</p>
</li>
<li><p> Calculations of the power ignoring any bias caused by loss to follow-up etc.<br />
</p>
</li>
<li><p> Calculations of <code>delta</code>, the expected spillover bias.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class <code>'CRTsp'</code> object comprising the input data, cluster and arm assignments,
trial description and results of power calculations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{# Power calculations for a binary outcome without input geolocations
examplePower1 &lt;- CRTpower(locations = 3000, ICC = 0.10, effect = 0.4, alpha = 0.05,
    outcome_type = 'd', desiredPower = 0.8, yC=0.35, c = 20, sd_h = 5)
summary(examplePower1)
# Power calculations for a rate outcome without input geolocations
examplePower2 &lt;- CRTpower(locations = 2000, cv_percent = 40, effect = 0.4, denominator = 2.5,
    alpha = 0.05, outcome_type = 'e', desiredPower = 0.8, yC = 0.35, c = 20, sd_h=5)
summary(examplePower2)
# Example with input geolocations
examplePower3 &lt;- CRTpower(trial = readdata('example_site.csv'), desiredPower = 0.8,
    effect=0.4, yC=0.35, outcome_type = 'd', ICC = 0.05, c = 20)
summary(examplePower3)
# Example with input geolocations, randomisation, and spillover
example4 &lt;- randomizeCRT(specify_clusters(trial = readdata('example_site.csv'), c = 20))
examplePower4 &lt;- CRTpower(trial = example4, desiredPower = 0.8,
    effect=0.4, yC=0.35, outcome_type = 'd', ICC = 0.05, contaminate_pop_pr = 0.3)
summary(examplePower4)
}
</code></pre>

<hr>
<h2 id='CRTsp'>Create or update a <code>"CRTsp"</code> object</h2><span id='topic+CRTsp'></span>

<h3>Description</h3>

<p><code>CRTsp</code> coerces data frames containing co-ordinates and location attributes
into objects of class <code>"CRTsp"</code> or creates a new <code>"CRTsp"</code> object by simulating a set of Cartesian co-ordinates for use as the locations in a simulated trial site
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRTsp(
  x = NULL,
  design = NULL,
  geoscale = NULL,
  locations = NULL,
  kappa = NULL,
  mu = NULL,
  geometry = "point"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CRTsp_+3A_x">x</code></td>
<td>
<p>an object of class <code>"CRTsp"</code> or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor <code>cluster</code>), and arm assignments (factor <code>arm</code>). Optionally specification of a buffer zone (logical <code>buffer</code>);
any other variables required for subsequent analysis.</p>
</td></tr>
<tr><td><code id="CRTsp_+3A_design">design</code></td>
<td>
<p>list: an optional list containing the requirements for the power of the trial</p>
</td></tr>
<tr><td><code id="CRTsp_+3A_geoscale">geoscale</code></td>
<td>
<p>numeric: standard deviation of random displacement from each settlement cluster center (for new objects)</p>
</td></tr>
<tr><td><code id="CRTsp_+3A_locations">locations</code></td>
<td>
<p>integer: number of locations in population (for new objects)</p>
</td></tr>
<tr><td><code id="CRTsp_+3A_kappa">kappa</code></td>
<td>
<p>numeric: intensity of Poisson process of settlement cluster centers (for new objects)</p>
</td></tr>
<tr><td><code id="CRTsp_+3A_mu">mu</code></td>
<td>
<p>numeric: mean number of points per settlement cluster (for new objects)</p>
</td></tr>
<tr><td><code id="CRTsp_+3A_geometry">geometry</code></td>
<td>
<p>with valid values <code>'point'</code> (the default, corresponding to point locations), <code>'triangle'</code>,
<code>'square'</code> and <code>'hexagon'</code> corresponding to grids constructed from pixels of regular polygons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a data frame or <code>"CRTsp"</code> object is input then the output <code>"CRTsp"</code> object is validated,
a description of the geography is computed and power calculations are carried out.<br /><br />
If <code>geoscale, locations, kappa</code> and <code>mu</code> are specified then a new trial dataframe is constructed
corresponding to a novel simulated human settlement pattern. This is generated using the
Thomas algorithm (<code>rThomas</code>) in <a href="https://CRAN.R-project.org/package=spatstat.random"><code>spatstat.random</code></a>
allowing the user to defined the density of locations and degree of spatial clustering.
The resulting trial data frame comprises a set of Cartesian coordinates centred at the origin.<br /><br />
</p>


<h3>Value</h3>

<p>A list of class <code>"CRTsp"</code> containing the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>design</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> parameters required for power calculations</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>geom_full</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the site </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>geom_core</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the core area
(when a buffer is specified)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>trial</code> </td><td style="text-align: left;"> data frame: </td><td style="text-align: left;"> rows correspond to geolocated points, as follows:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>x</code> </td><td style="text-align: left;"> numeric vector: x-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>y</code> </td><td style="text-align: left;"> numeric vector: y-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>cluster</code> </td><td style="text-align: left;"> factor: assignments to cluster of each location  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>arm</code> </td><td style="text-align: left;"> factor: assignments to <code>"control"</code> or <code>"intervention"</code> for each location </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>nearestDiscord</code> </td><td style="text-align: left;"> numeric vector: Euclidean distance to nearest discordant location (km) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>buffer</code> </td><td style="text-align: left;"> logical: indicator of whether the point is within the buffer </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>...</code> </td><td style="text-align: left;"> other objects included in the input <code>"CRTsp"</code> object or data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>{# Generate a simulated area with 10,000 locations
example_area = CRTsp(geoscale = 1, locations=10000, kappa=3, mu=40)
summary(example_area)
}
</code></pre>

<hr>
<h2 id='CRTwrite'>Export of GIS layer from <code>'CRTsp'</code></h2><span id='topic+CRTwrite'></span>

<h3>Description</h3>

<p><code>CRTwrite</code> exports a simple features object in a GIS format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRTwrite(
  object,
  dsn,
  feature = "clusters",
  buffer_width,
  maskbuffer = 0.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CRTwrite_+3A_object">object</code></td>
<td>
<p>object of class <code>'CRTsp'</code></p>
</td></tr>
<tr><td><code id="CRTwrite_+3A_dsn">dsn</code></td>
<td>
<p>dataset name (relative path) for output objects</p>
</td></tr>
<tr><td><code id="CRTwrite_+3A_feature">feature</code></td>
<td>
<p>feature to be exported, options are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>'cluster'</code></td><td style="text-align: left;"> cluster assignments </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'arms'</code></td><td style="text-align: left;"> arm assignments </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'buffer'</code></td><td style="text-align: left;"> buffer zone or spillover zone</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'mask'</code></td><td style="text-align: left;"> mask for areas that are distant from habitations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="CRTwrite_+3A_buffer_width">buffer_width</code></td>
<td>
<p>width of buffer between discordant locations (km)</p>
</td></tr>
<tr><td><code id="CRTwrite_+3A_maskbuffer">maskbuffer</code></td>
<td>
<p>radius of buffer drawn around inhabited areas (km)</p>
</td></tr>
<tr><td><code id="CRTwrite_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>'sf::write_sf'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>'sf::write_sf'</code> is used to format the output. The function returns TRUE on success,
FALSE on failure, invisibly. <br /><br />
If the input object contains a <code>'centroid'</code> then this is used to compute lat long
coordinates, which are assigned the &quot;WGS84&quot; coordinate reference system.
Otherwise the objects have equirectangular co-ordinates with centroid (0,0).<br /><br />
If <code>feature = 'buffer'</code> then buffer width determination is as described under
<code>plotCRT()</code>.
<br /><br />
The output vector objects are constructed by forming a Voronoi tessellation of polygons around
each of the locations and combining these polygons. The polygons on the outside of the study area
extend outwards to an external rectangle. The <code>'mask'</code> is used to mask out the areas of
these polygons that are at a distance &gt; <code>maskbuffer</code> from the nearest location.
</p>


<h3>Value</h3>

<p><code>obj</code>, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
        tmpdir = tempdir()
        dsn &lt;- paste0(tmpdir,'/arms')
        CRTwrite(readdata('exampleCRT.txt'), dsn = dsn, feature = 'arms',
        driver = 'ESRI Shapefile', maskbuffer = 0.2)
    
</code></pre>

<hr>
<h2 id='fitted.CRTanalysis'>Extract model fitted values</h2><span id='topic+fitted.CRTanalysis'></span>

<h3>Description</h3>

<p><code>fitted.CRTanalysis</code> method for extracting model fitted values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRTanalysis'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.CRTanalysis_+3A_object">object</code></td>
<td>
<p>CRTanalysis object</p>
</td></tr>
<tr><td><code id="fitted.CRTanalysis_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the fitted values returned by the statistical model run within the <code>CRTanalysis</code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{example &lt;- readdata('exampleCRT.txt')
exampleGEE &lt;- CRTanalysis(example, method = "GEE")
fitted_values &lt;- fitted(exampleGEE)
}
</code></pre>

<hr>
<h2 id='latlong_as_xy'>Convert lat long co-ordinates to x,y</h2><span id='topic+latlong_as_xy'></span>

<h3>Description</h3>

<p><code>latlong_as_xy</code> converts co-ordinates expressed as decimal degrees into x,y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong_as_xy(trial, latvar = "lat", longvar = "long")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="latlong_as_xy_+3A_trial">trial</code></td>
<td>
<p>A trial dataframe or list of class <code>"CRTsp"</code> containing latitudes and longitudes in decimal degrees</p>
</td></tr>
<tr><td><code id="latlong_as_xy_+3A_latvar">latvar</code></td>
<td>
<p>name of column containing latitudes in decimal degrees</p>
</td></tr>
<tr><td><code id="latlong_as_xy_+3A_longvar">longvar</code></td>
<td>
<p>name of column containing longitudes in decimal degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output object contains the input locations replaced with Cartesian
coordinates in units of km, centred on (0,0), corresponding to using the equirectangular projection
(valid for small areas). Other data are unchanged.
</p>


<h3>Value</h3>

<p>A list of class <code>"CRTsp"</code> containing the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>geom_full</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the site </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>trial</code> </td><td style="text-align: left;"> data frame: </td><td style="text-align: left;"> rows correspond to geolocated points, as follows:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>x</code> </td><td style="text-align: left;"> numeric vector: x-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>y</code> </td><td style="text-align: left;"> numeric vector: y-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>...</code> </td><td style="text-align: left;"> other objects included in the input <code>"CRTsp"</code> object or data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>examplexy &lt;- latlong_as_xy(readdata("example_latlong.csv"))

</code></pre>

<hr>
<h2 id='plotCRT'>Graphical displays of the geography of a CRT</h2><span id='topic+plotCRT'></span>

<h3>Description</h3>

<p><code>plotCRT</code> returns graphical displays of the geography of a CRT
or of the results of statistical analyses of a CRT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCRT(
  object,
  map = FALSE,
  distance = "nearestDiscord",
  fill = "arms",
  showLocations = FALSE,
  showClusterBoundaries = TRUE,
  showClusterLabels = FALSE,
  showBuffer = FALSE,
  cpalette = NULL,
  buffer_width = NULL,
  maskbuffer = 0.2,
  labelsize = 4,
  legend.position = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCRT_+3A_object">object</code></td>
<td>
<p>object of class <code>'CRTanalysis'</code> produced by <code>CRTanalysis()</code></p>
</td></tr>
<tr><td><code id="plotCRT_+3A_map">map</code></td>
<td>
<p>logical: indicator of whether a map is required</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_distance">distance</code></td>
<td>
<p>measure of distance or surround with options: <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"nearestDiscord"</code> </td><td style="text-align: left;"> distance to nearest discordant location (km)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"disc"</code> </td><td style="text-align: left;"> disc</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"hdep"</code> </td><td style="text-align: left;"> Tukey's half space depth</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"sdep"</code> </td><td style="text-align: left;"> simplicial depth</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="plotCRT_+3A_fill">fill</code></td>
<td>
<p>fill layer of map with options:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>'cluster'</code> </td><td style="text-align: left;"> cluster assignment </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'arms'</code>   </td><td style="text-align: left;"> arm assignment </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'nearestDiscord'</code> </td><td style="text-align: left;"> distance to the nearest discordant location</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'disc'</code> </td><td style="text-align: left;"> disc measure of surround</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'hdep'</code> </td><td style="text-align: left;"> Tukey's half space depth</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'sdep'</code> </td><td style="text-align: left;"> simplicial depth</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'prediction'</code></td><td style="text-align: left;"> model prediction of the outcome </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>'none'</code></td><td style="text-align: left;"> No fill </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="plotCRT_+3A_showlocations">showLocations</code></td>
<td>
<p>logical: determining whether locations are shown</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_showclusterboundaries">showClusterBoundaries</code></td>
<td>
<p>logical: determining whether cluster boundaries are shown</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_showclusterlabels">showClusterLabels</code></td>
<td>
<p>logical: determining whether the cluster numbers are shown</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_showbuffer">showBuffer</code></td>
<td>
<p>logical: whether a buffer zone should be overlayed</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_cpalette">cpalette</code></td>
<td>
<p>colour palette (to use different colours for clusters this must be at
least as long as the number of clusters.</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_buffer_width">buffer_width</code></td>
<td>
<p>width of buffer zone to be overlayed (km)</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_maskbuffer">maskbuffer</code></td>
<td>
<p>radius of buffer around inhabited areas (km)</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_labelsize">labelsize</code></td>
<td>
<p>size of cluster number labels</p>
</td></tr>
<tr><td><code id="plotCRT_+3A_legend.position">legend.position</code></td>
<td>
<p>(using <code>ggplot2::themes</code> syntax)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>map = FALSE</code> and the input is a trial data frame or a <code>CRTsp</code> object,
containing a randomisation to arms, a stacked bar chart of the outcome
grouped by the specified <code>distance</code> is produced. If the specified <code>distance</code>
has not yet been calculated an error is returned.<br /><br />
If <code>map = FALSE</code> and the input is a <code>CRTanalysis</code> object a plot of the
estimated spillover function is generated. The fitted spillover function is plotted
as a continuous blue line against the measure
the surround or of the distance to the nearest discordant location. Using the same axes, data summaries are plotted for
ten categories of distance from the boundary. Both the
average of the outcome and confidence intervals are plotted.
</p>

<ul>
<li><p> For analyses with logit link function the outcome is plotted as a proportion. <br />
</p>
</li>
<li><p> For analyses with log or cloglog link function the data are plotted on a scale of the Williams mean
(mean of exp(log(x + 1))) - 1) rescaled so that the median matches the fitted curve at the midpoint.<br />
</p>
</li></ul>

<p>If <code>map = TRUE</code> a thematic map corresponding to the value of <code>fill</code> is generated.
</p>

<ul>
<li> <p><code>fill = 'clusters'</code> or leads to thematic map showing the locations of the clusters
</p>
</li>
<li> <p><code>fill = 'arms'</code> leads to a thematic map showing the geography of the randomization
</p>
</li>
<li> <p><code>fill = 'distance'</code> leads to a raster plot of the distance to the nearest discordant location.
</p>
</li>
<li> <p><code>fill = 'prediction'</code> leads to a raster plot of predictions from an <code>'INLA'</code> model.
</p>
</li></ul>

<p>If <code>showBuffer = TRUE</code> the map is overlaid with a grey transparent layer showing which
areas are within a defined distance of the boundary between the arms. Possibilities are:
</p>

<ul>
<li><p> If the trial has not been randomised or if <code>showBuffer = FALSE</code> no buffer is displayed
</p>
</li>
<li><p> If <code>buffer_width</code> takes a positive value then buffers of this width are
displayed irrespective of any pre-specified or spillover limits.
</p>
</li>
<li><p> If the input is a <code>'CRTanalysis'</code> and spillover limits have been estimated by
an <code>'LME4'</code> or <code>'INLA'</code> model then these limits are used to define the displayed buffer.
</p>
</li>
<li><p> If <code>buffer_width</code> is not specified and no spillover limits are available, then any
pre-specified buffer (e.g. one generated by <code>specify_buffer()</code>) is displayed.
</p>
</li></ul>

<p>A message is output indicating which of these possibilities applies.
</p>


<h3>Value</h3>

<p>graphics object produced by the <code>ggplot2</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{example &lt;- readdata('exampleCRT.txt')
#Plot of data by distance
plotCRT(example)
#Map of locations only
plotCRT(example, map = TRUE, fill = 'none', showLocations = TRUE,
           showClusterBoundaries=FALSE, maskbuffer=0.2)
#show cluster boundaries and number clusters
plotCRT(example, map = TRUE, fill ='none', showClusterBoundaries=TRUE,
           showClusterLabels=TRUE, maskbuffer=0.2, labelsize = 2)
#show clusters in colour
plotCRT(example, map = TRUE, fill = 'clusters', showClusterLabels = TRUE,
          labelsize=2, maskbuffer=0.2)
#show arms
plotCRT(example, map = TRUE,
fill = 'arms', maskbuffer=0.2, legend.position=c(0.8,0.8))
#spillover plot
analysis &lt;- CRTanalysis(example)
 plotCRT(analysis, map = FALSE)
}
</code></pre>

<hr>
<h2 id='predict.CRTanalysis'>Model predictions</h2><span id='topic+predict.CRTanalysis'></span>

<h3>Description</h3>

<p><code>predict.CRTanalysis</code> method for extracting model predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRTanalysis'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.CRTanalysis_+3A_object">object</code></td>
<td>
<p>CRTanalysis object</p>
</td></tr>
<tr><td><code id="predict.CRTanalysis_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the model predictions returned by the statistical model run within the <code>CRTanalysis</code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{example &lt;- readdata('exampleCRT.txt')
exampleGEE &lt;- CRTanalysis(example, method = "GEE")
predictions &lt;- predict(exampleGEE)
}#'
</code></pre>

<hr>
<h2 id='randomizeCRT'>Randomize a two-armed cluster trial</h2><span id='topic+randomizeCRT'></span>

<h3>Description</h3>

<p><code>randomizeCRT</code> carries out randomization of clusters and
augments the trial data frame with assignments to arms <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomizeCRT(
  trial,
  matchedPair = FALSE,
  baselineNumerator = "base_num",
  baselineDenominator = "base_denom"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomizeCRT_+3A_trial">trial</code></td>
<td>
<p>an object of class <code>"CRTsp"</code> or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor <code>cluster</code>), and arm assignments (factor <code>arm</code>). Optionally: specification of a buffer zone (logical <code>buffer</code>);
any other variables required for subsequent analysis.</p>
</td></tr>
<tr><td><code id="randomizeCRT_+3A_matchedpair">matchedPair</code></td>
<td>
<p>logical: indicator of whether pair-matching on the
baseline data should be used in randomization</p>
</td></tr>
<tr><td><code id="randomizeCRT_+3A_baselinenumerator">baselineNumerator</code></td>
<td>
<p>name of numerator variable for baseline data (required for
matched-pair randomization)</p>
</td></tr>
<tr><td><code id="randomizeCRT_+3A_baselinedenominator">baselineDenominator</code></td>
<td>
<p>name of denominator variable for baseline data (required for
matched-pair randomization)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"CRTsp"</code> containing the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>design</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> parameters required for power calculations</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>geom_full</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the site</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>geom_core</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the core area
(when a buffer is specified)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>trial</code> </td><td style="text-align: left;"> data frame: </td><td style="text-align: left;"> rows correspond to geolocated points, as follows:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>x</code> </td><td style="text-align: left;"> numeric vector: x-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>y</code> </td><td style="text-align: left;"> numeric vector: y-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>cluster</code> </td><td style="text-align: left;"> factor: assignments to cluster of each location  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>pair</code> </td><td style="text-align: left;"> factor: assigned matched pair of each location
(for <code>matchedPair</code> randomisations) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>arm</code> </td><td style="text-align: left;"> factor: assignments to <code>"control"</code> or <code>"intervention"</code> for each location </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>...</code> </td><td style="text-align: left;"> other objects included in the input <code>"CRTsp"</code> object or data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># Randomize the clusters in an example trial
exampleCRT &lt;- randomizeCRT(trial = readdata('exampleCRT.txt'), matchedPair = TRUE)
</code></pre>

<hr>
<h2 id='readdata'>Read example dataset</h2><span id='topic+readdata'></span>

<h3>Description</h3>

<p><code>readdata</code> reads a file from the package library of example datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readdata(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readdata_+3A_filename">filename</code></td>
<td>
<p>name of text file stored within the package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file name should include the extension (either .csv or .txt).
The resulting object is a data frame if the extension is .csv.
</p>


<h3>Value</h3>

<p>R object corresponding to the text file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleCRT &lt;- readdata('exampleCRT.txt')

</code></pre>

<hr>
<h2 id='residuals.CRTanalysis'>Extract model residuals</h2><span id='topic+residuals.CRTanalysis'></span>

<h3>Description</h3>

<p><code>residuals.CRTanalysis</code> method for extracting model residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRTanalysis'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.CRTanalysis_+3A_object">object</code></td>
<td>
<p>CRTanalysis object</p>
</td></tr>
<tr><td><code id="residuals.CRTanalysis_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the residuals from the statistical model run within the <code>CRTanalysis</code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{example &lt;- readdata('exampleCRT.txt')
exampleGEE &lt;- CRTanalysis(example, method = "GEE")
residuals &lt;- residuals(exampleGEE)
}
</code></pre>

<hr>
<h2 id='simulateCRT'>Simulation of cluster randomized trial with spillover</h2><span id='topic+simulateCRT'></span>

<h3>Description</h3>

<p><code>simulateCRT</code> generates simulated data for a cluster randomized trial (CRT) with geographic spillover between arms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateCRT(
  trial = NULL,
  effect = 0,
  outcome0 = NULL,
  generateBaseline = TRUE,
  matchedPair = TRUE,
  scale = "proportion",
  baselineNumerator = "base_num",
  baselineDenominator = "base_denom",
  denominator = NULL,
  ICC_inp = NULL,
  kernels = 200,
  sigma_m = NULL,
  spillover_interval = NULL,
  tol = 0.005
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateCRT_+3A_trial">trial</code></td>
<td>
<p>an object of class <code>"CRTsp"</code> or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor <code>cluster</code>), and arm assignments (factor <code>arm</code>). Each location may also be
assigned a <code>propensity</code> (see details).</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_effect">effect</code></td>
<td>
<p>numeric. The simulated effect size (defaults to 0)</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_outcome0">outcome0</code></td>
<td>
<p>numeric. The anticipated value of the outcome in the absence of intervention</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_generatebaseline">generateBaseline</code></td>
<td>
<p>logical. If <code>TRUE</code> then baseline data and the <code>propensity</code> will be simulated</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_matchedpair">matchedPair</code></td>
<td>
<p>logical. If <code>TRUE</code> then the function tries to carry out randomization
using pair-matching on the baseline data (see details)</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_scale">scale</code></td>
<td>
<p>measurement scale of the outcome. Options are: 'proportion' (the default); 'count'; 'continuous'.</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_baselinenumerator">baselineNumerator</code></td>
<td>
<p>optional name of numerator variable for pre-existing baseline data</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_baselinedenominator">baselineDenominator</code></td>
<td>
<p>optional name of denominator variable for pre-existing baseline data</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_denominator">denominator</code></td>
<td>
<p>optional name of denominator variable for the outcome</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_icc_inp">ICC_inp</code></td>
<td>
<p>numeric. Target intra cluster correlation, provided as input when baseline data are to be simulated</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_kernels">kernels</code></td>
<td>
<p>number of kernels used to generate a de novo <code>propensity</code></p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_sigma_m">sigma_m</code></td>
<td>
<p>numeric. standard deviation of the normal kernel measuring spatial smoothing leading to spillover</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_spillover_interval">spillover_interval</code></td>
<td>
<p>numeric. input spillover interval</p>
</td></tr>
<tr><td><code id="simulateCRT_+3A_tol">tol</code></td>
<td>
<p>numeric. tolerance of output ICC</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Synthetic data are generated by sampling around the values of
variable <code>propensity</code>, which is a numerical vector
(taking positive values) of length equal to the number of locations.
There are three ways in which <code>propensity</code> can arise:
</p>

<ol>
<li> <p><code>propensity</code> can be provided as part of the input <code>trial</code> object.
</p>
</li>
<li><p> Baseline numerators and denominators (values of <code>baselineNumerator</code>
and <code>baselineDenominator</code> may be provided.
<code>propensity</code> is then generated as the numerator:denominator ratio
for each location in the input object
</p>
</li>
<li><p> Otherwise <code>propensity</code> is generated using a 2D Normal
kernel density. The <a href="https://rdrr.io/cran/OOR/man/StoSOO.html"><code>OOR::StoSOO</code></a>
is used to achieve an intra-cluster correlation coefficient (ICC) that approximates
the value of <code>'ICC_inp'</code> by searching for an appropriate value of the kernel bandwidth.
</p>
</li></ol>

<p><code>num[i]</code>, the synthetic outcome for location <code>i</code>
is simulated with expectation: <br />
</p>
<p style="text-align: center;"><code class="reqn">E(num[i]) = outcome0[i] * propensity[i] * denom[i] * (1 - effect*I[i])/mean(outcome0[] * propensity[])</code>
</p>
 <p><br />
The sampling distribution of <code>num[i]</code> depends on the value of <code>scale</code> as follows: <br />
</p>

<ul>
<li> <p><code>scale</code>=â€™continuousâ€™: Values of <code>num</code> are sampled from a
Normal distributions with means <code>E(num[i])</code>
and variance determined by the fitting to <code>ICC_inp</code>.<br />
</p>
</li>
<li> <p><code>scale</code>=â€™countâ€™: Simulated events are allocated to locations via multivariate hypergeometric distributions
parameterised with <code>E(num[i])</code>.<br />
</p>
</li>
<li> <p><code>scale</code>=â€™proportionâ€™: Simulated events are allocated to locations via multinomial distributions
parameterised with <code>E(num[i])</code>.<br />
</p>
</li></ul>

<p><code>denominator</code> may specify a vector of numeric (non-zero) values
in the input <code>"CRTsp"</code> or <code>data.frame</code> which is returned
as variable <code>denom</code>. It acts as a scale-factor for continuous outcomes, rate-multiplier
for counts, or denominator for proportions. For discrete data all values of <code>denom</code>
must be &gt; 0.5 and are rounded to the nearest integer in calculations of <code>num</code>.<br /><br />
By default, <code>denom</code> is generated as a vector of ones, leading to simulation of
dichotomous outcomes if <code>scale</code>=â€™proportionâ€™.<br />
</p>
<p>If baseline numerators and denominators are provided then the output vectors
<code>base_denom</code> and  <code>base_num</code> are set to the input values. If baseline numerators and denominators
are not provided then the synthetic baseline data are generated by sampling around <code>propensity</code> in the same
way as the outcome data, but with the effect size set to zero.
</p>
<p>If <code>matchedPair</code> is <code>TRUE</code> then pair-matching on the baseline data will be used in randomization providing
there are an even number of clusters. If there are an odd number of clusters then matched pairs are not generated and
an unmatched randomization is output.
</p>
<p>Either <code>sigma_m</code> or <code>spillover_interval</code> must be provided. If both are provided then
the value of <code>sigma_m</code> is overwritten
by the standard deviation implicit in the value of <code>spillover_interval</code>.
Spillover is simulated as arising from a diffusion-like process.
</p>
<p>For further details see <a href="https://edoc.unibas.ch/85228/">Multerer (2021)</a>
</p>


<h3>Value</h3>

<p>A list of class <code>"CRTsp"</code> containing the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>geom_full</code></td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the site
cluster assignments, and randomization </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>design</code></td><td style="text-align: left;"> list: </td><td style="text-align: left;"> values of input parameters to the design </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>trial</code> </td><td style="text-align: left;"> data frame: </td><td style="text-align: left;"> rows correspond to geolocated points, as follows:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>x</code> </td><td style="text-align: left;"> numeric vector:  x-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>y</code> </td><td style="text-align: left;"> numeric vector:  y-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>cluster</code> </td><td style="text-align: left;"> factor:  assignments to cluster of each location  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>arm</code> </td><td style="text-align: left;"> factor:  assignments to <code>control</code> or <code>intervention</code> for each location </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>nearestDiscord</code> </td><td style="text-align: left;"> numeric vector:  signed Euclidean distance to nearest discordant location (km) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>propensity</code> </td><td style="text-align: left;"> numeric vector:  propensity for each location </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>base_denom</code> </td><td style="text-align: left;"> numeric vector:  denominator for baseline </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>base_num</code> </td><td style="text-align: left;"> numeric vector:  numerator for baseline </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>denom</code> </td><td style="text-align: left;"> numeric vector:  denominator for the outcome </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>num</code> </td><td style="text-align: left;"> numeric vector:  numerator for the outcome </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"><code>...</code> </td><td style="text-align: left;"> other objects included in the input <code>"CRTsp"</code> object
or <code>data.frame</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>{smalltrial &lt;- readdata('smalltrial.csv')
 simulation &lt;- simulateCRT(smalltrial,
  effect = 0.25,
  ICC_inp = 0.05,
  outcome0 = 0.5,
  matchedPair = FALSE,
  scale = 'proportion',
  sigma_m = 0.6,
  tol = 0.05)
 summary(simulation)
 }
</code></pre>

<hr>
<h2 id='specify_buffer'>Specification of buffer zone in a cluster randomized trial</h2><span id='topic+specify_buffer'></span>

<h3>Description</h3>

<p><code>specify_buffer</code> specifies a buffer zone in a cluster randomized
trial (CRT) by flagging those locations that are within a defined distance of
those in the opposite arm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_buffer(trial, buffer_width = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specify_buffer_+3A_trial">trial</code></td>
<td>
<p>an object of class <code>"CRTsp"</code> or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor <code>cluster</code>), and arm assignments (factor <code>arm</code>).</p>
</td></tr>
<tr><td><code id="specify_buffer_+3A_buffer_width">buffer_width</code></td>
<td>
<p>minimum distance between locations in
opposing arms for them to qualify to be included in the core area (km)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"CRTsp"</code> containing the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>geom_full</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the site,
cluster assignments, and randomization.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>geom_core</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the core area </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>trial</code> </td><td style="text-align: left;"> data frame: </td><td style="text-align: left;"> rows correspond to geolocated points, as follows:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>x</code> </td><td style="text-align: left;"> numeric vector: x-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>y</code> </td><td style="text-align: left;"> numeric vector: y-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>cluster</code> </td><td style="text-align: left;"> factor: assignments to cluster of each location  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>arm</code> </td><td style="text-align: left;"> factor: assignments to <code>"control"</code> or <code>"intervention"</code> for each location </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>nearestDiscord</code> </td><td style="text-align: left;"> numeric vector: signed Euclidean distance to nearest discordant location (km) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>buffer</code> </td><td style="text-align: left;"> logical: indicator of whether the point is within the buffer </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>...</code> </td><td style="text-align: left;"> other objects included in the input <code>"CRTsp"</code> object or data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>#Specify a buffer of 200m
exampletrial &lt;- specify_buffer(trial = readdata('exampleCRT.txt'), buffer_width = 0.2)
</code></pre>

<hr>
<h2 id='specify_clusters'>Assign locations to clusters in a CRT</h2><span id='topic+specify_clusters'></span>

<h3>Description</h3>

<p><code>specify_clusters</code> algorithmically assigns locations to clusters by grouping them geographically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_clusters(
  trial = trial,
  c = NULL,
  h = NULL,
  algorithm = "NN",
  reuseTSP = FALSE,
  auxiliary = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specify_clusters_+3A_trial">trial</code></td>
<td>
<p>A CRT object or data frame containing (x,y) coordinates of
households</p>
</td></tr>
<tr><td><code id="specify_clusters_+3A_c">c</code></td>
<td>
<p>integer: number of clusters in each arm</p>
</td></tr>
<tr><td><code id="specify_clusters_+3A_h">h</code></td>
<td>
<p>integer: number of locations per cluster</p>
</td></tr>
<tr><td><code id="specify_clusters_+3A_algorithm">algorithm</code></td>
<td>
<p>algorithm for cluster boundaries, with options:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>NN</code></td><td style="text-align: left;"> Nearest neighbour: assigns equal numbers of locations to each cluster </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>kmeans</code></td><td style="text-align: left;"> kmeans clustering: aims to partition locations so that each
belongs to the cluster with the nearest centroid.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>TSP</code></td><td style="text-align: left;"> travelling salesman problem heuristic: Assigns locations sequentially
along a travelling salesman path.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="specify_clusters_+3A_reusetsp">reuseTSP</code></td>
<td>
<p>logical: indicator of whether a pre-existing path should be used by
the TSP algorithm</p>
</td></tr>
<tr><td><code id="specify_clusters_+3A_auxiliary">auxiliary</code></td>
<td>
<p><code>"CRTsp"</code> object containing external cluster and or arm assignments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>c</code> or <code>h</code> must be specified. If both are specified
the input value of <code>c</code> is ignored.<br /><br />
The <code>reuseTSP</code> parameter is used to allow the path to be reused
for creating alternative allocations with different cluster sizes.<br /><br />
If an auxiliary <code>auxiliary</code> <code>"CRTsp"</code> object is specified then the other options are ignored
and the cluster assignments (and arm assignments if available) are taken from the auxiliary object.
The trial data frame is augmented with a column <code>"nearestPixel"</code> containing the distance to boundary of the nearest
grid pixel in the auxiliary. If the auxiliary is a grid with <code>design$geometry</code> set to <code>'triangle'</code>,
<code>'square'</code> or <code>'hexagon'</code> then the distance is computed to the edge of the nearest grid pixel in the discordant arm
(using a circular approximation for the perimeter) rather than to the point location itself. If the point is within
the pixel then the distance is given a negative sign.<br />
</p>


<h3>Value</h3>

<p>A list of class <code>"CRTsp"</code> containing the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>geom_full</code>   </td><td style="text-align: left;"> list: </td><td style="text-align: left;"> summary statistics describing the site,
and cluster assignments.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>trial</code> </td><td style="text-align: left;"> data frame: </td><td style="text-align: left;"> rows correspond to geolocated points, as follows:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>x</code> </td><td style="text-align: left;"> numeric vector: x-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>y</code> </td><td style="text-align: left;"> numeric vector: y-coordinates of locations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>cluster</code> </td><td style="text-align: left;"> factor: assignments to cluster of each location  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>...</code> </td><td style="text-align: left;"> other objects included in the input <code>"CRTsp"</code> object or data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>#Assign clusters of average size h = 40 to a test set of co-ordinates, using the kmeans algorithm
exampletrial &lt;- specify_clusters(trial = readdata('exampleCRT.txt'),
                            h = 40, algorithm = 'kmeans', reuseTSP = FALSE)
</code></pre>

<hr>
<h2 id='summary.CRTanalysis'>Summary of the results of a statistical analysis of a CRT</h2><span id='topic+summary.CRTanalysis'></span>

<h3>Description</h3>

<p><code>summary.CRTanalysis</code> generates a summary of a <code>CRTanalysis</code> including the main results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRTanalysis'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CRTanalysis_+3A_object">object</code></td>
<td>
<p>an object of class <code>"CRTanalysis"</code></p>
</td></tr>
<tr><td><code id="summary.CRTanalysis_+3A_...">...</code></td>
<td>
<p>other arguments used by summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, writes text to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{example &lt;- readdata('exampleCRT.txt')
exampleT &lt;- CRTanalysis(example, method = "T")
summary(exampleT)
}
</code></pre>

<hr>
<h2 id='summary.CRTsp'>Summary description of a <code>"CRTsp"</code> object</h2><span id='topic+summary.CRTsp'></span>

<h3>Description</h3>

<p><code>summary.CRTsp</code> provides a description of a <code>"CRTsp"</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRTsp'
summary(object, maskbuffer = 0.2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CRTsp_+3A_object">object</code></td>
<td>
<p>an object of class <code>"CRTsp"</code> or a data frame containing locations in (x,y) coordinates, cluster
assignments (factor <code>cluster</code>), arm assignments (factor <code>arm</code>) and buffer zones (logical <code>buffer</code>),
together with any other variables required for subsequent analysis.</p>
</td></tr>
<tr><td><code id="summary.CRTsp_+3A_maskbuffer">maskbuffer</code></td>
<td>
<p>radius of area around a location to include in calculation of areas</p>
</td></tr>
<tr><td><code id="summary.CRTsp_+3A_...">...</code></td>
<td>
<p>other arguments used by summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, write text to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(CRTsp(readdata('exampleCRT.txt')))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
