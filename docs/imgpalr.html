<!DOCTYPE html><html><head><title>Help for package imgpalr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {imgpalr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#image_load'><p>Load PNG, JPG, BMP or GIF</p></a></li>
<li><a href='#image_pal'><p>Create a color palette from an image</p></a></li>
<li><a href='#image_quantmap'><p>Quantize an image using an existing color palette</p></a></li>
<li><a href='#imgpalr'><p>imgpalr: Create color palettes from images</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Create Color Palettes from Images</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides ability to create color palettes from image files. It 
    offers control over the type of color palette to derive from an image 
    (qualitative, sequential or divergent) and other palette properties.
    Quantiles of an image color distribution can be trimmed. Near-black or 
    near-white colors can be trimmed in RGB color space independent of trimming 
    brightness or saturation distributions in HSV color space. Creating 
    sequential palettes also offers control over the order of HSV color 
    dimensions to sort by. This package differs from other related packages 
    like 'RImagePalette' in approaches to quantizing and extracting colors in 
    images to assemble color palettes and the level of user control over 
    palettes construction.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/leonawicz/imgpalr">https://github.com/leonawicz/imgpalr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/leonawicz/imgpalr/issues">https://github.com/leonawicz/imgpalr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>downloader, farver, tibble, magrittr, dplyr, jpeg</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, bmp, png, magick</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-10 02:37:27 UTC; Matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Leonawicz <a href="https://orcid.org/0000-0001-9452-2771"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Leonawicz &lt;mfleonawicz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-10 03:10:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='image_load'>Load PNG, JPG, BMP or GIF</h2><span id='topic+image_load'></span>

<h3>Description</h3>

<p>Load PNG, JPG, BMP or GIF from disk or URL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_load(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_load_+3A_file">file</code></td>
<td>
<p>character, file name. A local file or URL. Extension must be one of png, jpg, jpeg, bmp or gif.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will prompt you of the need to install a format-specific package if not installed and needed for
the given <code>file</code> extension; <code>png</code>, <code>bmp</code>, <code>magick</code> (for GIF). <code>jpeg</code> is already imported for purpose of running examples.
</p>


<h3>Value</h3>

<p>an RBG array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- paste0(system.file(package = "imgpalr"), "/blue-yellow.",
  c("jpg", "png", "bmp", "gif"))
str(image_load(x[1]))
if(require(png)) str(image_load(x[2]))
if(require(bmp)) str(image_load(x[3]))
if(require(magick)) str(image_load(x[4]))
</code></pre>

<hr>
<h2 id='image_pal'>Create a color palette from an image</h2><span id='topic+image_pal'></span>

<h3>Description</h3>

<p>Derive qualitative, sequential and divergent color palettes from an image on disk or at a URL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_pal(
  file,
  n = 9,
  type = c("qual", "seq", "div"),
  k = 100,
  bw = c(0, 1),
  brightness = c(0, 1),
  saturation = c(0, 1),
  seq_by = "hsv",
  div_center = "#FFFFFF",
  seed = NULL,
  plot = FALSE,
  labels = TRUE,
  label_size = 1,
  label_color = "#000000",
  keep_asp = TRUE,
  quantize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_pal_+3A_file">file</code></td>
<td>
<p>character, file path or URL to an image.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_n">n</code></td>
<td>
<p>integer, number of colors.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_type">type</code></td>
<td>
<p>character, type of palette: qualitative, sequential or divergent (<code>"qual"</code>, <code>"seq"</code>, or <code>"div"</code>).</p>
</td></tr>
<tr><td><code id="image_pal_+3A_k">k</code></td>
<td>
<p>integer, the number of k-means cluster centers to consider in the image. See details.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_bw">bw</code></td>
<td>
<p>a numeric vector of length two giving the lower and upper quantiles to trim trim near-black and near-white colors in RGB space.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_brightness">brightness</code></td>
<td>
<p>as above, trim possible colors based on brightness in HSV space.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_saturation">saturation</code></td>
<td>
<p>as above, trim possible colors based on saturation in HSV space.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_seq_by">seq_by</code></td>
<td>
<p>character, sort sequential palette by HSV dimensions in a specific order, e.g., <code>"hsv"</code>, <code>"svh"</code>. See details.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_div_center">div_center</code></td>
<td>
<p>character, color used for divergent palette center, defaults to white.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_seed">seed</code></td>
<td>
<p>numeric, set the seed for reproducible results.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_plot">plot</code></td>
<td>
<p>logical, plot the palette.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_labels">labels</code></td>
<td>
<p>logical, show hex color values in plot.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_label_size">label_size</code></td>
<td>
<p>numeric, label size in plot.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_label_color">label_color</code></td>
<td>
<p>text label color.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_keep_asp">keep_asp</code></td>
<td>
<p>logical, adjust rectangles in plot to use the image aspect ratio.</p>
</td></tr>
<tr><td><code id="image_pal_+3A_quantize">quantize</code></td>
<td>
<p>logical, quantize the reference thumbnail image in the plot using the derived color palette. See <code>image_quantmap</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ordering colors is a challenging problem. There are many ways to do it; none are perfect.
Color is a multi-dimensional property; any reduction to a a one dimensional color spectrum necessarily removes information.
</p>
<p>Creating a sequential palette from an arbitrary image that contains several hues, at different saturation and brightness levels, and making a palette that looks sequential is particularly problematic.
This function does a decent job of creating qualitative, sequential and divergent palettes from images, but additional tweaking of function arguments is needed on a case by case basis.
This can include trimming the extreme values of the color distribution in terms of brightness, saturation and presence of near-black/white colors as pre-processing steps.
There is also variation in possible palettes from a given image, depending on the image complexity and other properties, though you can set the random seed for reproducibility.
</p>
<p>The number of k-means centers <code>k</code> defines the maximum number of unique colors to consider in the image for color binning prior to palette construction.
This is different from <code>n</code>, the number of colors are desired in the derived palette. It is limited by the number of unique colors in the image.
Larger <code>k</code> may allow for better palette construction under some conditions, but takes longer to run.
<code>k</code> applies to sequential and qualitative palettes, but not divergent palettes.
</p>


<h3>Value</h3>

<p>character vector of hex colors, optionally draws a plot
</p>


<h3>Trimming color distribution</h3>

<p>Some pre-processing can be done to limit undesirable colors from ending up in a palette.
<code>bw</code> specifically drops near-black and near-white colors as soon as the image is loaded by looking at the average values in RGB space.
<code>brightness</code> and <code>saturation</code> trimming are applied subsequently to trim lower and upper quantiles of the HSV value and saturation, respectively.
If you have already trimmed black and white, keep in mind these two arguments will trim further from what remains of the color distribution.
</p>


<h3>Choosing appropriate palette type</h3>

<p>Keep in mind that many images simple do not make sense to try to derive sensible color palettes from.
For images that do lend themselves to a useful color palette derivation, some may only make sense to consider for a divergent palette, or an increasing/decreasing sequential palette,
or only a qualitative palette if there are too many colors that are difficult to order.
For divergent palettes in particular, it is recommended to trim white, e.g. <code>bw = c(0, 0.9)</code>, depending on the white space of a given image, since the divergent palettes are centered on white.
</p>


<h3>Sorting sequential palettes</h3>

<p><code>seq_by = "hsv"</code> orders the final palette by hue, then saturation, then value (brightness). This default is not meant to be ideal for all images.
It work better in cases where sequential palettes may contain several distinct hues, but not much variation in saturation or brightness.
However, for example, palettes derived from an image with relatively little variation in hue may appear more sorted to the human eye if ordered by hue last using <code>"svh"</code> or <code>"vsh"</code>,
depending on whether you want the palette to appear to transition more from lower saturation or lower brightness to the predominant hue.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+image_quantmap">image_quantmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- system.file("blue-yellow.jpg", package = "imgpalr")

# Focus on bright, saturated colors for divergent palette:
image_pal(x, n = 3, type = "div",
  saturation = c(0.75, 1), brightness = c(0.75, 1), plot = TRUE)


image_pal(x, n = 5, type = "seq", k = 2, saturation = c(0.5, 1),
  brightness = c(0.25, 1), seq_by = "hsv")

</code></pre>

<hr>
<h2 id='image_quantmap'>Quantize an image using an existing color palette</h2><span id='topic+image_quantmap'></span>

<h3>Description</h3>

<p>Quantize image colors by mapping all pixels to the nearest color in RGB space, respectively, given an arbitrary palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_quantmap(
  file,
  pal,
  pal2 = NULL,
  k = 100,
  plot = FALSE,
  show_pal = TRUE,
  labels = TRUE,
  label_size = 1,
  label_color = "#000000",
  keep_asp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_quantmap_+3A_file">file</code></td>
<td>
<p>if character, file path or URL to an image. You can also provide an RGB array from an already loaded image file.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_pal">pal</code></td>
<td>
<p>character, vector of hex colors, the color palette used to quantize the image colors.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_pal2">pal2</code></td>
<td>
<p>character, optional vector of hex colors, same length as <code>pal</code>.
After quantizing image to <code>pal</code>, you can subsequently remap <code>pal</code> to <code>pal2</code>.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_k">k</code></td>
<td>
<p>integer, the number of k-means cluster centers to consider in the image. See details.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_plot">plot</code></td>
<td>
<p>logical, plot the palette with quantized image reference thumbnail. If <code>FALSE</code>, only return the RGB array.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_show_pal">show_pal</code></td>
<td>
<p>logical, show the palette like with <code>image_pal</code>. If <code>FALSE</code>, plot only the image; all subsequent arguments ignored.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_labels">labels</code></td>
<td>
<p>logical, show hex color values in plot.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_label_size">label_size</code></td>
<td>
<p>numeric, label size in plot.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_label_color">label_color</code></td>
<td>
<p>text label color.</p>
</td></tr>
<tr><td><code id="image_quantmap_+3A_keep_asp">keep_asp</code></td>
<td>
<p>logical, adjust rectangles in plot to use the image aspect ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The palette <code>pal</code> does not need to be related to the image colors.
Each pixel will be assigned to whichever color in <code>pal</code> that it is nearest to in RGB space.
You can use <code>pal2</code> to remap to arbitrary colors after quantizing.
This function returns the new RGB array. You can plot a preview just like with <code>image_pal</code> using <code>plot = TRUE</code>.
The number of k-means centers <code>k</code> is for binning image colors prior to mapping the palette <code>pal</code>.
It is limited by the number of unique colors in the image. Larger <code>k</code> provides more binned distances between image colors and palette colors,
but takes longer to run.
</p>


<h3>Value</h3>

<p>an RGB array with values ranging from 0 to 1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+image_pal">image_pal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- system.file("blue-yellow.jpg", package = "imgpalr")
pal &lt;- c("black", "navyblue", "dodgerblue", "yellow")
pal2 &lt;- c("darkred", "darkgreen", "tomato", "orange")

a &lt;- image_quantmap(x, pal, k = 7, plot = TRUE)
str(a)

a &lt;- image_quantmap(x, pal, pal2, k = 7, plot = TRUE)
</code></pre>

<hr>
<h2 id='imgpalr'>imgpalr: Create color palettes from images</h2><span id='topic+imgpalr'></span><span id='topic+imgpalr-package'></span>

<h3>Description</h3>

<p>The <code>imgpalr</code> package is used for generating color palettes from image files.
It offers control over the type of color palette to derive from an image (qualitative, sequential or divergent) and other palette properties.
Quantiles of an image color distribution can be trimmed.
Near-black or near-white colors can be trimmed in RGB color space independent of trimming brightness or saturation distributions in HSV color space.
Creating sequential palettes also offers control over the order of HSV color dimensions to sort by.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
