<!DOCTYPE html><html lang="en"><head><title>Help for package RankAggSIgFUR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RankAggSIgFUR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_avg_tau'><p>Compute Average tau</p></a></li>
<li><a href='#data100x15'><p>Simulated 100  <code class="reqn">\times</code>  15 Data</p></a></li>
<li><a href='#data240x4'><p>PrefLib 240  <code class="reqn">\times</code> 4 Data</p></a></li>
<li><a href='#data400x15'><p>Simulated 400  <code class="reqn">\times</code>  15 Data</p></a></li>
<li><a href='#data50x15'><p>Simulated 50  <code class="reqn">\times</code>  15 Data</p></a></li>
<li><a href='#fur'><p>FUR</p></a></li>
<li><a href='#get_indices'><p>Determine Indices of Ranked Objects</p></a></li>
<li><a href='#get_sub_rkgs'><p>Determine a Subset of Rankings for Greedy Algorithm</p></a></li>
<li><a href='#mean_seed'><p>Mean Seed Ranking</p></a></li>
<li><a href='#mod_kemeny'><p>Modified Kemeny Rank Aggregation</p></a></li>
<li><a href='#prepare_data'><p>Preparing Data</p></a></li>
<li><a href='#rap_greedy_alg'><p>Greedy Algorithm for Rank Aggregation</p></a></li>
<li><a href='#seed_based_iteration'><p>Seed-Based Iteration</p></a></li>
<li><a href='#sigfur'><p>SIgFUR</p></a></li>
<li><a href='#subit_convergence'><p>Subiterative Convergence</p></a></li>
<li><a href='#totalKem_mult'><p>Summary Statistics of Multiple given Rankings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Polynomially Bounded Rank Aggregation under Kemeny's Axiomatic
Approach</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Polynomially bounded algorithms to aggregate complete rankings under Kemeny's axiomatic framework. 'RankAggSIgFUR' (pronounced as rank-agg-cipher) contains two heuristics algorithms: FUR and SIgFUR. For details, please see Badal and Das (2018) &lt;<a href="https://doi.org/10.1016%2Fj.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rfast, combinat, data.table, plyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/prakashvs613/RankAggSIgFUR">https://github.com/prakashvs613/RankAggSIgFUR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/prakashvs613/RankAggSIgFUR/issues">https://github.com/prakashvs613/RankAggSIgFUR/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-19 00:40:05 UTC; rsingh</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannah Parker [aut],
  Rakhi Singh <a href="https://orcid.org/0000-0003-3469-295X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut],
  Prakash Singh Badal
    <a href="https://orcid.org/0000-0003-4097-8444"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rakhi Singh &lt;agrakhi@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-19 03:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_avg_tau'>Compute Average tau</h2><span id='topic+compute_avg_tau'></span>

<h3>Description</h3>

<p>Calculates the average tau correlation coefficient defined by Emond and Mason (2002).
The average tau correlation has a one-to-one relationship with total Kemeny distance,
While it is more common, total Kemeny distance may be preferred to avoid rounding error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_avg_tau(total_K, n, k, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_avg_tau_+3A_total_k">total_K</code></td>
<td>
<p>a positive integer as the total Kemeny distance of a ranking versus
the input rankings.</p>
</td></tr>
<tr><td><code id="compute_avg_tau_+3A_n">n</code></td>
<td>
<p>a positive integer for the number of objects in the ranking.</p>
</td></tr>
<tr><td><code id="compute_avg_tau_+3A_k">k</code></td>
<td>
<p>a positive integer for the number of judges or attributes in the given
ranking problem. This is also the number of input rankings from the problem.</p>
</td></tr>
<tr><td><code id="compute_avg_tau_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric of the average tau correlation based on the total Kemeny distance.
</p>


<h3>References</h3>

<p>Emond, E. J., &amp; Mason, D. W. (2002). A new rank correlation coefficient with
application to the consensus ranking problem. Journal of Multi-Criteria Decision
Analysis, 11(1), 17-28.
</p>

<hr>
<h2 id='data100x15'>Simulated 100  <code class="reqn">\times</code>  15 Data</h2><span id='topic+data100x15'></span>

<h3>Description</h3>

<p>Data of 100 objects and 15 attributes, in which the first column contains the object
names and each subsequent column is a complete ranking of the 100 objects. The
included 50  <code class="reqn">\times</code>  15 and 400  <code class="reqn">\times</code>  15 datasets were generated from this dataset (see
<code><a href="#topic+data50x15">data50x15</a></code> and <code><a href="#topic+data400x15">data400x15</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data100x15)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 16 columns:
</p>

<dl>
<dt>Object</dt><dd><p>object name</p>
</dd>
<dt>Ranking 1</dt><dd><p>ranking on the first attribute</p>
</dd>
<dt>Ranking 2</dt><dd><p>ranking on the second attribute</p>
</dd>
<dt>Ranking 3</dt><dd><p>ranking on the third attribute</p>
</dd>
<dt>Ranking 4</dt><dd><p>ranking on the fourth attribute</p>
</dd>
<dt>Ranking 5</dt><dd><p>ranking on the fifth attribute</p>
</dd>
<dt>Ranking 6</dt><dd><p>ranking on the sixth attribute</p>
</dd>
<dt>Ranking 7</dt><dd><p>ranking on the seventh attribute</p>
</dd>
<dt>Ranking 8</dt><dd><p>ranking on the eigth attribute</p>
</dd>
<dt>Ranking 9</dt><dd><p>ranking on the ninth attribute</p>
</dd>
<dt>Ranking 10</dt><dd><p>ranking on the tenth attribute</p>
</dd>
<dt>Ranking 11</dt><dd><p>ranking on the eleventh attribute</p>
</dd>
<dt>Ranking 12</dt><dd><p>ranking on the twelfth attribute</p>
</dd>
<dt>Ranking 13</dt><dd><p>ranking on the thirteenth attribute</p>
</dd>
<dt>Ranking 14</dt><dd><p>ranking on the fourteenth attribute</p>
</dd>
<dt>Ranking 15</dt><dd><p>ranking on the fifteenth attribute</p>
</dd>
</dl>



<h3>Source</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data100x15)
input_rkgs &lt;- t(as.matrix(data100x15[, -1]))
obj_names &lt;- data100x15[,1]

# Determine the mean seed ranking
mean_seed(input_rkgs)
</code></pre>

<hr>
<h2 id='data240x4'>PrefLib 240  <code class="reqn">\times</code> 4 Data</h2><span id='topic+data240x4'></span>

<h3>Description</h3>

<p>Data of 240 cities across the globe ranked on four criteria from the
ED-00015-001.soc dataset in the PrefLib repository. The first column contains
the object names and each subsequent column is a complete ranking of the 240
objects with no ties)
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data240x4)
</code></pre>


<h3>Format</h3>

<p>A data frame with 240 rows and 5 columns:
</p>

<dl>
<dt>Object</dt><dd><p>object name</p>
</dd>
<dt>Ranking 1</dt><dd><p>ranking on the first criterion</p>
</dd>
<dt>Ranking 2</dt><dd><p>ranking on the second criterion</p>
</dd>
<dt>Ranking 3</dt><dd><p>ranking on the third criterion</p>
</dd>
<dt>Ranking 4</dt><dd><p>ranking on the fourth criterion</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.preflib.org/">https://www.preflib.org/</a>
</p>


<h3>References</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>
<p>Mattei, N., &amp; Walsh, T. (2013, November). Preflib: A library for
preferences <a href="https://www.preflib.org/">https://www.preflib.org/</a>. In International conference on algorithmic
decision theory (pp. 259-270). Springer, Berlin, Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data240x4)
input_rkgs &lt;- t(as.matrix(data240x4[, -1]))
obj_names &lt;- data240x4[,1]

# Determine the mean seed ranking
mean_seed(input_rkgs)
</code></pre>

<hr>
<h2 id='data400x15'>Simulated 400  <code class="reqn">\times</code>  15 Data</h2><span id='topic+data400x15'></span>

<h3>Description</h3>

<p>Data of 400 objects and 15 attributes in which the first column contains the object
names and each subsequent column is a complete ranking of the 400 objects. This
data set is generated from the 100 <code class="reqn">\times</code> 15 dataset (see <code><a href="#topic+data50x15">data50x15</a></code>)
by adding 100 to the ranks of the objects numbered 1 through 100 to get the ranks of
objects numbered 101 through 200. Similarly, by adding 200 to obtain ranking 201
through 300, and by adding 300 to obtain ranking 301 through 400.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data400x15)
</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and 16 columns:
</p>

<dl>
<dt>Objects</dt><dd><p>object name</p>
</dd>
<dt>Ranking 1</dt><dd><p>ranking on the first attribute</p>
</dd>
<dt>Ranking 2</dt><dd><p>ranking on the second attribute</p>
</dd>
<dt>Ranking 3</dt><dd><p>ranking on the third attribute</p>
</dd>
<dt>Ranking 4</dt><dd><p>ranking on the fourth attribute</p>
</dd>
<dt>Ranking 5</dt><dd><p>ranking on the fifth attribute</p>
</dd>
<dt>Ranking 6</dt><dd><p>ranking on the sixth attribute</p>
</dd>
<dt>Ranking 7</dt><dd><p>ranking on the seventh attribute</p>
</dd>
<dt>Ranking 8</dt><dd><p>ranking on the eigth attribute</p>
</dd>
<dt>Ranking 9</dt><dd><p>ranking on the ninth attribute</p>
</dd>
<dt>Ranking 10</dt><dd><p>ranking on the tenth attribute</p>
</dd>
<dt>Ranking 11</dt><dd><p>ranking on the eleventh attribute</p>
</dd>
<dt>Ranking 12</dt><dd><p>ranking on the twelfth attribute</p>
</dd>
<dt>Ranking 13</dt><dd><p>ranking on the thirteenth attribute</p>
</dd>
<dt>Ranking 14</dt><dd><p>ranking on the fourteenth attribute</p>
</dd>
<dt>Ranking 15</dt><dd><p>ranking on the fifteenth attribute</p>
</dd>
</dl>



<h3>Source</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data400x15)
input_rkgs &lt;- t(as.matrix(data400x15[, -1]))
obj_names &lt;- data400x15[,1]

# Determine the mean seed ranking
mean_seed(input_rkgs)
</code></pre>

<hr>
<h2 id='data50x15'>Simulated 50  <code class="reqn">\times</code>  15 Data</h2><span id='topic+data50x15'></span>

<h3>Description</h3>

<p>Data of 50 objects and 15 attributes, which were randomly generated from the
100  <code class="reqn">\times</code>  15 simulated dataset (see <code><a href="#topic+data100x15">data100x15</a></code>). The first column contains the object
names and each subsequent column is a complete ranking of the 50 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data50x15)
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 16 columns:
</p>

<dl>
<dt>Object</dt><dd><p>object name</p>
</dd>
<dt>Ranking 1</dt><dd><p>ranking on the first attribute</p>
</dd>
<dt>Ranking 2</dt><dd><p>ranking on the second attribute</p>
</dd>
<dt>Ranking 3</dt><dd><p>ranking on the third attribute</p>
</dd>
<dt>Ranking 4</dt><dd><p>ranking on the fourth attribute</p>
</dd>
<dt>Ranking 5</dt><dd><p>ranking on the fifth attribute</p>
</dd>
<dt>Ranking 6</dt><dd><p>ranking on the sixth attribute</p>
</dd>
<dt>Ranking 7</dt><dd><p>ranking on the seventh attribute</p>
</dd>
<dt>Ranking 8</dt><dd><p>ranking on the eigth attribute</p>
</dd>
<dt>Ranking 9</dt><dd><p>ranking on the ninth attribute</p>
</dd>
<dt>Ranking 10</dt><dd><p>ranking on the tenth attribute</p>
</dd>
<dt>Ranking 11</dt><dd><p>ranking on the eleventh attribute</p>
</dd>
<dt>Ranking 12</dt><dd><p>ranking on the twelfth attribute</p>
</dd>
<dt>Ranking 13</dt><dd><p>ranking on the thirteenth attribute</p>
</dd>
<dt>Ranking 14</dt><dd><p>ranking on the fourteenth attribute</p>
</dd>
<dt>Ranking 15</dt><dd><p>ranking on the fifteenth attribute</p>
</dd>
</dl>



<h3>Source</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data50x15)
input_rkgs &lt;- t(as.matrix(data50x15[, -1]))
obj_names &lt;- data50x15[,1]

# Determine the mean seed ranking
mean_seed(input_rkgs)
</code></pre>

<hr>
<h2 id='fur'>FUR</h2><span id='topic+fur'></span>

<h3>Description</h3>

<p><em>FUR</em> is a heuristic algorithm to obtain a consensus ranking.
It contains three branches &ndash; Fixed, Update, and Range &ndash; that use
<em>Subiterative Convergence</em> and <em>Greedy Algorithm</em> iteratively.
See &lsquo;Details&rsquo; for more information on each branch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fur(
  input_rkgs,
  subit_len_list,
  search_radius,
  seed_rkg = c(),
  objNames = c(),
  wt = c()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fur_+3A_input_rkgs">input_rkgs</code></td>
<td>
<p>a <code>n</code> by <code>k</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each column is a complete ranking.</p>
</td></tr>
<tr><td><code id="fur_+3A_subit_len_list">subit_len_list</code></td>
<td>
<p>a vector containing positive integer(s) for the subiteration
lengths to <em>Subiterative Convergence</em>. Recommended values are between 2 and 8.
Smaller subiteration lengths result in shorter run-time.</p>
</td></tr>
<tr><td><code id="fur_+3A_search_radius">search_radius</code></td>
<td>
<p>a positive integer for the maximum change in the rank of each
object in the <em>Greedy Algorithm</em>. The default value
of <code>0</code> considers all possible rank changes for each object. It is
recommended to use a search radius of less than or equal to <code class="reqn">\min(30, \lfloor \mbox{n}/2 \rfloor)</code>.</p>
</td></tr>
<tr><td><code id="fur_+3A_seed_rkg">seed_rkg</code></td>
<td>
<p>a vector of length <code>n</code> with an initial ranking to begin FUR. If
the default value of an empty vector is used, then the <code>mean seed ranking</code> is adopted
as the initial ranking to FUR.</p>
</td></tr>
<tr><td><code id="fur_+3A_objnames">objNames</code></td>
<td>
<p>a <code>n</code>-length vector containing object names. An optional
parameter.</p>
</td></tr>
<tr><td><code id="fur_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Fixed branch applies <em>Subiterative Convergence</em> using one subiteration
length from <code>subit_len_list</code> at a time.
</p>
<p>The Update branch executes <em>Subiterative Convergence</em> using the first
subiteration length in <code>subit_len_list</code>, and then uses its output in the
next call to <em>Subiterative Convergence</em> with the next subiteration length in the list.
This process repeats until <code>subit_len_list</code> is exhausted.
</p>
<p>The Range branch calls <em>Subiterative Convergence</em> on all subiteration lengths in
<code>subit_len_list</code> and only retains the best ranking among these separate calls.
</p>
<p>The output from the <em>Subiterative Convergence</em> calls are fed into the <em>Greedy Algorithm</em>
as its seed ranking, and the FUR algorithm is terminated when the input to the
<em>Greedy Algorithm</em> converges to the output and all branches have been executed at
least once.
</p>


<h3>Value</h3>

<p>A list containing the consensus ranking (expressed as ordering), total Kemeny distance, and average
tau correlation coefficient corresponding to the consensus ranking.
</p>


<h3>References</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean_seed">mean_seed</a></code>, <code><a href="#topic+subit_convergence">subit_convergence</a></code>, <code><a href="#topic+rap_greedy_alg">rap_greedy_alg</a></code>, <code><a href="#topic+sigfur">sigfur</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One subiteration length
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
subit_len_list &lt;- 2
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius) # Determined the consensus ranking, total Kemeny
                                              # distance, and average tau correlation coefficient

## Multiple subiteration lengths
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
subit_len_list &lt;- c(2,3)
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius)

## Five input rankings with five objects 
## 2nd ranking == 3rd ranking, so if a third object is weighted as zero,
## we should get the same answer as the first examples
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
## Multiple subiteration lengths
wt = c(1,1,0,1,1)
subit_len_list &lt;- c(2,3)
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius,wt=wt)

## Using five input rankings with five objects with prepare_data to 
## automatically prepare the weight vector
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
out = prepare_data(input_rkgs) 
input_rkgs = out$input_rkgs
wt = out$wt
subit_len_list &lt;- c(2,3)
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius,wt=wt)

## Included dataset of 15 input rankings of 50 objects
data(data50x15)
input_rkgs &lt;- as.matrix(data50x15[, -1])
subit_len_list &lt;- c(2, 3)
search_radius &lt;- 1
fur(input_rkgs, subit_len_list, search_radius)

</code></pre>

<hr>
<h2 id='get_indices'>Determine Indices of Ranked Objects</h2><span id='topic+get_indices'></span>

<h3>Description</h3>

<p>Used in <em>Subiterative Convergence</em> to determine the index of
the subset of objects from the output from <em>Modified Kemeny</em>. These indices
are then used to find the object indices for the next step in <em>Subiterative Convergence</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_indices(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_indices_+3A_x">x</code></td>
<td>
<p>a vector of integers, typically a series from 1 to <code class="reqn">\eta</code> from <em>Subiterative Convergence</em>.</p>
</td></tr>
<tr><td><code id="get_indices_+3A_y">y</code></td>
<td>
<p>a vector containing the ranking, typically the output from <em>Modified Kemeny</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index or indices of the ranked objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subit_convergence">subit_convergence</a></code>
</p>

<hr>
<h2 id='get_sub_rkgs'>Determine a Subset of Rankings for Greedy Algorithm</h2><span id='topic+get_sub_rkgs'></span>

<h3>Description</h3>

<p>This function creates the new rankings for <em>Greedy Algorithm</em>
after moving an object to a higher and lower rank within the search radius.
Cyclical moving is permitted in the event of overflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sub_rkgs(seed_rkg, move_ind, search_radius)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_sub_rkgs_+3A_seed_rkg">seed_rkg</code></td>
<td>
<p>a vector containing the initial ranking on which subsequent moves will be based.</p>
</td></tr>
<tr><td><code id="get_sub_rkgs_+3A_move_ind">move_ind</code></td>
<td>
<p>an integer representing the index of the object to be moved.</p>
</td></tr>
<tr><td><code id="get_sub_rkgs_+3A_search_radius">search_radius</code></td>
<td>
<p>a positive integer of the maximum shift allowed to increase or decrease
the rank of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the subset of rankings, with each row as a new ranking with the moved object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rap_greedy_alg">rap_greedy_alg</a></code>
</p>

<hr>
<h2 id='mean_seed'>Mean Seed Ranking</h2><span id='topic+mean_seed'></span>

<h3>Description</h3>

<p>Determine the <em>mean seed ranking</em> of the given input rankings.
The average rank of an object is the sum of its various rankings from each input
ranking divided by the total number of rankings. The mean seed ranking is formed
by ranking the objects based on their average ranks, and ties are broken by ranking
the first tied object with a higher rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_seed(input_rkgs, wt = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_seed_+3A_input_rkgs">input_rkgs</code></td>
<td>
<p>a <code>k</code> by <code>n</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each row is a complete ranking. Note that this is a transpose of
matrix used for functions like <code>fur</code>, <code>sigfur</code>, <code>rap_greedy_alg</code>,
and <code>subit_convergence</code>.</p>
</td></tr>
<tr><td><code id="mean_seed_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the mean seed ranking of the input rankings.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rank">rank</a></code>, <code><a href="#topic+subit_convergence">subit_convergence</a></code>, <code><a href="#topic+fur">fur</a></code>, <code><a href="#topic+sigfur">sigfur</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Four input rankings of five objects
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
mean_seed(t(input_rkgs)) # Found the mean seed ranking

## Five input rankings with five objects 
## 2nd ranking == 3rd ranking, so if a third object is weighted as zero,
## we should get the same answer as the first examples
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
wt = c(1,1,0,1,1)
mean_seed(t(input_rkgs),wt=wt) # Found the mean seed ranking

## Included dataset of 15 input rankings of 50 objects
data(data50x15)
input_rkgs &lt;- t(as.matrix(data50x15[, -1]))
mean_seed(input_rkgs)

</code></pre>

<hr>
<h2 id='mod_kemeny'>Modified Kemeny Rank Aggregation</h2><span id='topic+mod_kemeny'></span>

<h3>Description</h3>

<p><em>Modified Kemeny</em> algorithm determines the consensus ranking of <code>n</code> objects using
the set of all possible rankings compared to the input rankings. The algorithm is based on
Kemeny's axiomatic approach of minimizing the total Kemeny distance from the input rankings.
In case of multiple rankings with minimum total Kemeny distance, the consensus ranking is
determined using two additional criteria. See &lsquo;Details&rsquo; for additional criteria.
The method involves <code>n</code>! comparisons. Hence, it works best on a set of rankings with a small
number of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_kemeny(input_rkgs, universe_rkgs, obj_pairs, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mod_kemeny_+3A_input_rkgs">input_rkgs</code></td>
<td>
<p>a <code>k</code> by <code>n</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each row is a complete ranking. Note that this is a transpose of
matrix used for functions like <code>fur</code>, <code>sigfur</code>, <code>rap_greedy_alg</code>,
and <code>subit_convergence</code>.</p>
</td></tr>
<tr><td><code id="mod_kemeny_+3A_universe_rkgs">universe_rkgs</code></td>
<td>
<p>a matrix containing all possible permutations of ranking
n objects. Each row in this matrix represents one permuted ranking.</p>
</td></tr>
<tr><td><code id="mod_kemeny_+3A_obj_pairs">obj_pairs</code></td>
<td>
<p>a <code>2</code> by <code>n choose 2</code> matrix of all combinations of
object pairs of n objects, where each column contains a pair of object indices.</p>
</td></tr>
<tr><td><code id="mod_kemeny_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under Kemeny's axiomatic approach, rankings with minimum total Kemeny distance are
considered equally optimal. Modified Kemeny attempts to break the tie among such rankings by
imposing two additional criteria on the basis of minimizing (a) the maximum and (b) the variance
of individual Kemeny distances, applied sequentially.
</p>


<h3>Value</h3>

<p>A list containing the consensus ranking (expressed as ordering), total Kemeny distance, and average
tau correlation coefficient corresponding to the consensus ranking.
</p>


<h3>References</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Consensus ranking from four rankings of five objects
n &lt;- 5
input_rkgs &lt;- matrix(c(3, 2, 5, 1, 2, 3, 1, 2, 5, 1, 3, 4, 4, 5, 4, 5, 1, 4, 2, 3), ncol = n)
uni_rkgs &lt;- matrix(unlist(combinat::permn(c(1:n))), byrow = TRUE, ncol = n)
obj_pairs &lt;- combinat::combn(1:n,2, simplify=TRUE)
wt &lt;- rep(1,nrow(input_rkgs))
mod_kemeny(input_rkgs, uni_rkgs, obj_pairs,wt=wt) # Computed consensus ranking, 
                                                  # total Kemeny distance,
                                            #and average tau correlation coefficient

</code></pre>

<hr>
<h2 id='prepare_data'>Preparing Data</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p>Prepares the given data for rank aggregation functions. The function
returns a matrix of input rankings and a vector indicating weights of the
ranking for each judge. Useful when scores need to be converted to rankings.
Also helpful in reducing the size of the problem for large <code>p</code>, especially
when <code>p</code> &gt; <code>n</code>!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(df, HighertheBetter = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare_data_+3A_df">df</code></td>
<td>
<p>a <code>n</code> by <code>p</code> matrix or dataframe of scores of <code>n</code>
objects given by <code>p</code> judges. Each column corresponds to a different judge.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_higherthebetter">HighertheBetter</code></td>
<td>
<p>an integer with 1 indicating that the higher values in the
input correspond to the better rank. An optional parameter. Default value is 0,
i.e., the lower the score the better the rank (e.g., score of 1 is the topmost rank).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a matrix of input rankings (named <code>input_rkgs</code>) and a
weight vector corresponding to weights for each judge (named <code>wt</code>). These
two objects are used as inputs to <code><a href="#topic+subit_convergence">subit_convergence</a></code>,
<code><a href="#topic+rap_greedy_alg">rap_greedy_alg</a></code>, <code><a href="#topic+fur">fur</a></code>, and <code><a href="#topic+sigfur">sigfur</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subit_convergence">subit_convergence</a></code>, <code><a href="#topic+rap_greedy_alg">rap_greedy_alg</a></code>, <code><a href="#topic+fur">fur</a></code>, <code><a href="#topic+sigfur">sigfur</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Five input rankings with five objects 
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
out = prepare_data(input_rkgs) 
input_rkgs = out$input_rkgs
wt = out$wt

## Five input rankings with five objects
## testing the higher the better 
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
input_rkgs = input_rkgs*2+input_rkgs #artificially create a score matrix
# Testing the higher the better rank
out = prepare_data(input_rkgs, HighertheBetter = 1) 
input_rkgs = out$input_rkgs
wt = out$wt

</code></pre>

<hr>
<h2 id='rap_greedy_alg'>Greedy Algorithm for Rank Aggregation</h2><span id='topic+rap_greedy_alg'></span>

<h3>Description</h3>

<p><em>Greedy Algorithm</em> is a heuristic method that hunts for improved rankings
by moving one object at a time (up or down). In case an objectâ€™s movement results in an
improved ranking, the next object is moved with respect to this improved ranking. The process
is repeated until all objects are considered once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rap_greedy_alg(
  seed_rkg,
  input_rkgs,
  search_radius = 0,
  objNames = c(),
  wt = c()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rap_greedy_alg_+3A_seed_rkg">seed_rkg</code></td>
<td>
<p>an initial ranking to begin the algorithm. The algorithm is often used in
conjunction with <em>Subiterative Convergence</em>.</p>
</td></tr>
<tr><td><code id="rap_greedy_alg_+3A_input_rkgs">input_rkgs</code></td>
<td>
<p>a <code>n</code> by <code>k</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each column is a complete ranking.</p>
</td></tr>
<tr><td><code id="rap_greedy_alg_+3A_search_radius">search_radius</code></td>
<td>
<p>a positive integer for the maximum change in the rank of each
object. The default value of <code>0</code> considers all possible rank changes for each object.
Recommended value of search radius is less than or equal to <code class="reqn">\min(30, \lfloor \mbox{n}/2 \rfloor)</code>.</p>
</td></tr>
<tr><td><code id="rap_greedy_alg_+3A_objnames">objNames</code></td>
<td>
<p>a <code>n</code>-length vector containing object names. An optional
parameter.</p>
</td></tr>
<tr><td><code id="rap_greedy_alg_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the consensus ranking (expressed as ordering), total Kemeny distance, and average
tau correlation coefficient corresponding to the consensus ranking.
</p>


<h3>References</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subit_convergence">subit_convergence</a></code>, <code><a href="#topic+fur">fur</a></code>, <code><a href="#topic+sigfur">sigfur</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Four input rankings of five objects
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
mean_seed_rkg &lt;- mean_seed(t(input_rkgs))
rap_greedy_alg(mean_seed_rkg, input_rkgs, search_radius = 0) # Determined the consensus ranking,
                                                             # total Kemeny distance, and average
                                                             # tau correlation coefficient

## Five input rankings with five objects 
## 2nd ranking == 3rd ranking, so if a third object is weighted as zero,
## we should get the same answer as the first examples
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
wt = c(1,1,0,1,1)
mean_seed_rkg &lt;- mean_seed(t(input_rkgs),wt=wt)
rap_greedy_alg(mean_seed_rkg, input_rkgs, search_radius = 0,wt=wt) # Determined the
#consensus ranking,  total Kemeny distance, and average tau correlation coefficient


## Using five input rankings with five objects with prepare_data to 
## automatically prepare the weight vector
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
out = prepare_data(input_rkgs) 
input_rkgs = out$input_rkgs
wt = out$wt
mean_seed_rkg &lt;- mean_seed(t(input_rkgs),wt=wt)
rap_greedy_alg(mean_seed_rkg, input_rkgs, search_radius = 0,wt=wt) # Determined the
#consensus ranking,  total Kemeny distance, and average tau correlation coefficient

## Included dataset of 15 input rankings of 50 objects
data(data50x15)
input_rkgs &lt;- as.matrix(data50x15[, -1])
mean_seed_rkg &lt;- mean_seed(t(input_rkgs)) # Use the mean seed ranking as the seed ranking
rap_greedy_alg(mean_seed_rkg, input_rkgs, search_radius = 1)

</code></pre>

<hr>
<h2 id='seed_based_iteration'>Seed-Based Iteration</h2><span id='topic+seed_based_iteration'></span>

<h3>Description</h3>

<p><em>Seed-Based Iteration</em> is a heuristic-based seed generation used in <em>SIgFUR</em>
to iteratively perturb the ranking to improve the consensus ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seed_based_iteration(eta, omega, input_rkgs, wt = c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seed_based_iteration_+3A_eta">eta</code></td>
<td>
<p>a subiteration length for intermittent <em>Subiterative Convergence</em>. The recommended
values are between 2 and 8. Smaller subiteration lengths result in shorter run-time.</p>
</td></tr>
<tr><td><code id="seed_based_iteration_+3A_omega">omega</code></td>
<td>
<p>a positive integer for the number of repetitions of perturbing
the seed ranking. An <code>omega</code> value of 1 corresponds to a single application of
<em>Subiterative Convergence</em>.</p>
</td></tr>
<tr><td><code id="seed_based_iteration_+3A_input_rkgs">input_rkgs</code></td>
<td>
<p>a <code>k</code> by <code>n</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each row is a complete ranking. Note that this is a transpose of
matrix used for functions like <code>fur</code>, <code>sigfur</code>, <code>rap_greedy_alg</code>,
and <code>subit_convergence</code>.</p>
</td></tr>
<tr><td><code id="seed_based_iteration_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the consensus ranking (expressed as ordering) and total
Kemeny distance corresponding to the consensus ranking.
</p>


<h3>References</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sigfur">sigfur</a></code>, <code><a href="#topic+subit_convergence">subit_convergence</a></code>, <code><a href="#topic+mean_seed">mean_seed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Four input rankings of five objects
eta &lt;- 2
omega &lt;- 10
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
seed_based_iteration(eta, omega, t(input_rkgs)) # Determined seed-based iterations

## Five input rankings with five objects
## 2nd ranking == 3rd ranking, so if a third object is weighted as zero,
## we should get the same answer as the first examples
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
eta &lt;- 2
omega &lt;- 10
wt = c(1,1,0,1,1)
seed_based_iteration(eta, omega, t(input_rkgs), wt=wt) # Determined seed-based iterations

## Included dataset of 15 input rankings of 50 objects
eta &lt;- 3
omega &lt;- 5
data(data50x15)
input_rkgs &lt;- as.matrix(data50x15[, -1])
seed_based_iteration(eta, omega, t(input_rkgs)) # Determined seed-based iterations

</code></pre>

<hr>
<h2 id='sigfur'>SIgFUR</h2><span id='topic+sigfur'></span>

<h3>Description</h3>

<p><em>SIgFUR</em> applies <em>Seed-Based Iteration</em>, <em>Greedy Algorithm</em>,
and <em>FUR</em> in sequence for each element of <code>subit_len_list_sbi</code>. The
<em>mean seed ranking</em> is used as the input to <em>Seed-Based Iteration</em>.
The best of all output rankings from <em>FUR</em> is considered as the consensus
ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigfur(
  input_rkgs,
  subit_len_list_sbi,
  omega_sbi,
  subit_len_list_fur,
  search_radius,
  objNames = c(),
  wt = c()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigfur_+3A_input_rkgs">input_rkgs</code></td>
<td>
<p>a <code>n</code> by <code>k</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each column is a complete ranking.</p>
</td></tr>
<tr><td><code id="sigfur_+3A_subit_len_list_sbi">subit_len_list_sbi</code></td>
<td>
<p>a vector containing positive integer(s) for the subiteration
lengths to <em>Seed-Based Iteration</em>. Recommended values are between 2 and 8.
Smaller subiteration lengths result in shorter run-time.</p>
</td></tr>
<tr><td><code id="sigfur_+3A_omega_sbi">omega_sbi</code></td>
<td>
<p>a positive integer for the number of repetitions of perturbing
the seed ranking in <em>Seed-Based Iteration</em>. An <code>omega_sbi</code> value of 1
corresponds to a single application of <em>Subiterative Convergence</em>.</p>
</td></tr>
<tr><td><code id="sigfur_+3A_subit_len_list_fur">subit_len_list_fur</code></td>
<td>
<p>a vector containing positive integer(s) for the subiteration
lengths to <em>FUR</em>.</p>
</td></tr>
<tr><td><code id="sigfur_+3A_search_radius">search_radius</code></td>
<td>
<p>a positive integer for the maximum change in the rank of each
object in the <em>Greedy Algorithm</em> and <em>FUR</em>. The default value
of <code>0</code> considers all possible rank changes for each object. It is
recommended to use a search radius of less than or equal to <code class="reqn">\min(30, \lfloor \mbox{n}/2 \rfloor)</code>.</p>
</td></tr>
<tr><td><code id="sigfur_+3A_objnames">objNames</code></td>
<td>
<p>a <code>n</code>-length vector containing object names. An optional
parameter.</p>
</td></tr>
<tr><td><code id="sigfur_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the consensus ranking (expressed as ordering), total Kemeny distance, and average
tau correlation coefficient corresponding to the consensus ranking.
</p>


<h3>References</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seed_based_iteration">seed_based_iteration</a></code>, <code><a href="#topic+rap_greedy_alg">rap_greedy_alg</a></code>, <code><a href="#topic+fur">fur</a></code>, <code><a href="#topic+mean_seed">mean_seed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Four input rankings of five objects
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
subit_len_list_sbi &lt;- c(2:3)
omega_sbi &lt;- 10
subit_len_list_fur &lt;- c(2:3)
search_radius &lt;- 1
sigfur(input_rkgs, subit_len_list_sbi, omega_sbi, subit_len_list_fur, search_radius)
# Determined the consensus ranking, total Kemeny distance, and average tau correlation coefficient

## Five input rankings with five objects
## 2nd ranking == 3rd ranking, so if a third object is weighted as zero,
## we should get the same answer as the first examples
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
subit_len_list_sbi &lt;- c(2:3)
omega_sbi &lt;- 10
subit_len_list_fur &lt;- c(2:3)
search_radius &lt;- 1
wt = c(1,1,0,1,1)
sigfur(input_rkgs, subit_len_list_sbi, omega_sbi, subit_len_list_fur, search_radius, wt=wt)
# Determined the consensus ranking, total Kemeny distance, and average tau correlation coefficient

## Using five input rankings with five objects with prepare_data to 
## automatically prepare the weight vector
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
out = prepare_data(input_rkgs) 
input_rkgs = out$input_rkgs
wt = out$wt
subit_len_list_sbi &lt;- c(2:3)
omega_sbi &lt;- 10
subit_len_list_fur &lt;- c(2:3)
search_radius &lt;- 1
sigfur(input_rkgs, subit_len_list_sbi, omega_sbi, subit_len_list_fur, search_radius, wt=wt)
# Determined the consensus ranking, total Kemeny distance, and average tau correlation coefficient

## Included dataset of 15 input rankings of 50 objects
data(data50x15)
input_rkgs &lt;- as.matrix(data50x15[, -1])
subit_len_list_sbi &lt;- c(3)
omega_sbi &lt;- 5
subit_len_list_fur &lt;- c(2:3)
search_radius &lt;- 1
sigfur(input_rkgs, subit_len_list_sbi, omega_sbi, subit_len_list_fur, search_radius)

</code></pre>

<hr>
<h2 id='subit_convergence'>Subiterative Convergence</h2><span id='topic+subit_convergence'></span>

<h3>Description</h3>

<p><em>Subiterative Convergence</em> finds the consensus ranking by iteratively applying the
<em>Modified Kemeny</em> algorithm on smaller number of objects, <code class="reqn">\eta</code>. Starting with a given seed
ranking, the consensus ranking is obtained when the algorithm converges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subit_convergence(
  eta,
  seed_rkg,
  input_rkgs,
  universe_rkgs = c(),
  objNames = c(),
  wt = c()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subit_convergence_+3A_eta">eta</code></td>
<td>
<p>a subiteration length of number of objects to consider in the smaller
subset. Recommended <code>eta</code> values are between 2 and 8. Smaller <code>eta</code> values result in shorter run-time.</p>
</td></tr>
<tr><td><code id="subit_convergence_+3A_seed_rkg">seed_rkg</code></td>
<td>
<p>an initial ranking to start the algorithm. An ideal seed ranking for
<em>Subiterative Convergence</em> is the <em>mean seed ranking</em> of input rankings.</p>
</td></tr>
<tr><td><code id="subit_convergence_+3A_input_rkgs">input_rkgs</code></td>
<td>
<p>a <code>n</code> by <code>k</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each column is a complete ranking.</p>
</td></tr>
<tr><td><code id="subit_convergence_+3A_universe_rkgs">universe_rkgs</code></td>
<td>
<p>a matrix containing all possible permutations of ranking
<code>n</code> objects. Each column in this matrix represents one permuted ranking.
An optional parameter.</p>
</td></tr>
<tr><td><code id="subit_convergence_+3A_objnames">objNames</code></td>
<td>
<p>a <code>n</code>-length vector containing object names. An optional
parameter.</p>
</td></tr>
<tr><td><code id="subit_convergence_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the consensus ranking (expressed as ordering), total Kemeny distance, and average
tau correlation coefficient corresponding to the consensus ranking.
</p>


<h3>References</h3>

<p>Badal, P. S., &amp; Das, A. (2018). Efficient algorithms using subiterative
convergence for Kemeny ranking problem. Computers &amp; Operations Research, 98, 198-210.
<a href="https://doi.org/10.1016/j.cor.2018.06.007">doi:10.1016/j.cor.2018.06.007</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mod_kemeny">mod_kemeny</a></code>, <code><a href="#topic+fur">fur</a></code>, <code><a href="#topic+sigfur">sigfur</a></code>, <code><a href="#topic+mean_seed">mean_seed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Four input rankings of five objects
eta &lt;- 3
seed_rkg &lt;- c(1, 2, 3, 4, 5)
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
subit_convergence(eta, seed_rkg, input_rkgs) # Determined the consensus ranking, total Kemeny
                                             # distance, and average tau correlation coefficient

## Example with eta=1
eta &lt;- 1
seed_rkg &lt;- c(1, 2, 3, 4, 5)
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 2, 4, 5, 3),
    byrow = FALSE, ncol = 4)
subit_convergence(eta, seed_rkg, input_rkgs) # Shows a warning and returns seed ranking

## Five input rankings with five objects
## 2nd ranking == 3rd ranking, so if a third object is weighted as zero,
## we should get the same answer as the first examples
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
eta &lt;- 3
seed_rkg &lt;- c(1, 2, 3, 4, 5)
wt = c(1,1,0,1,1)
subit_convergence(eta, seed_rkg, input_rkgs, wt=wt) # Determined the consensus ranking, total Kemeny
                                             # distance, and average tau correlation coefficient

## Using five input rankings with five objects with prepare_data to 
## automatically prepare the weight vector
input_rkgs &lt;- matrix(c(3, 2, 5, 4, 1, 2, 3, 1, 5, 4, 2, 3, 1, 5, 4, 5, 1, 3, 4, 2, 1, 
                       2, 4, 5, 3),byrow = FALSE, ncol = 5)
out = prepare_data(input_rkgs) 
input_rkgs = out$input_rkgs
wt = out$wt
eta &lt;- 3
seed_rkg &lt;- c(1, 2, 3, 4, 5)
subit_convergence(eta, seed_rkg, input_rkgs, wt=wt) # Determined the consensus ranking, total Kemeny
                                             # distance, and average tau correlation coefficient

## Included dataset of 15 input rankings of 50 objects
data(data50x15)
input_rkgs &lt;- as.matrix(data50x15[, -1])
mean_seed_rkg &lt;- mean_seed(t(input_rkgs)) # Use the mean seed ranking as the seed ranking
eta &lt;- 2
subit_convergence(eta, seed_rkg = mean_seed_rkg, input_rkgs)

</code></pre>

<hr>
<h2 id='totalKem_mult'>Summary Statistics of Multiple given Rankings</h2><span id='topic+totalKem_mult'></span>

<h3>Description</h3>

<p>Calculates the sum, maximum, and variance of <code>k</code> individual Kemeny distances of
multiple given rankings from input rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totalKem_mult(rkgs, input_rkgs, pairs, wt = wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="totalKem_mult_+3A_rkgs">rkgs</code></td>
<td>
<p>a matrix of rankings to be compared against the input rankings. Each row must be a
complete ranking, meaning that all of the objects have a rank.</p>
</td></tr>
<tr><td><code id="totalKem_mult_+3A_input_rkgs">input_rkgs</code></td>
<td>
<p>a <code>k</code> by <code>n</code> matrix of <code>k</code> rankings of <code>n</code>
objects, where each row is a complete ranking. Note that this is a transpose of
matrix used for functions like <code>fur</code>, <code>sigfur</code>, <code>rap_greedy_alg</code>,
and <code>subit_convergence</code>.</p>
</td></tr>
<tr><td><code id="totalKem_mult_+3A_pairs">pairs</code></td>
<td>
<p>a <code>2</code> by <code>n choose 2</code> matrix of all combinations of
object pairs of n objects, where each column contains a pair of object indices.</p>
</td></tr>
<tr><td><code id="totalKem_mult_+3A_wt">wt</code></td>
<td>
<p>a <code>k</code>-length vector containing weights for each
judge or attribute. An optional parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the total Kemeny distance, the maximum Kemeny distance of
the individual Kemeny distances, and the variance of the individual Kemeny distances.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mod_kemeny">mod_kemeny</a></code>, <code><a href="#topic+subit_convergence">subit_convergence</a></code>, <code><a href="#topic+rap_greedy_alg">rap_greedy_alg</a></code>,
<code><a href="#topic+seed_based_iteration">seed_based_iteration</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
