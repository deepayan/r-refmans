<!DOCTYPE html><html lang="en"><head><title>Help for package rBDAT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rBDAT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rBDAT-package'><p>Implementation of BDAT Tree Taper Fortran Functions</p></a></li>
<li><a href='#BDAT20'><p>BDAT 2.0 assortment function</p></a></li>
<li><a href='#BDATBIOMASSE'><p>Get total aboveground biomasse</p></a></li>
<li><a href='#BDATDMRHX'><p>Calculate diameter in height Hx over bark.</p></a></li>
<li><a href='#BDATDORHX'><p>Calculate diameter in height Hx under bark.</p></a></li>
<li><a href='#BDATRINDE2HX'><p>Calculate double bark thickness</p></a></li>
<li><a href='#BDATVOLABMR'><p>Calculate wood volume over bark of a tree between height A and B</p></a></li>
<li><a href='#BDATVOLABOR'><p>Calculate volume under bark of a tree between height A and B</p></a></li>
<li><a href='#BDATVOLDHMR'><p>Calculate (coarse) wood volume over bark of a tree up to given diameter</p></a></li>
<li><a href='#BDATVOLDHOR'><p>Calculate (coarse) wood volume under bark of a tree up to given diameter</p></a></li>
<li><a href='#buildTree'><p>Build and check tree data for subsequent use in</p>
BDAT Fortran subroutines</a></li>
<li><a href='#clearError'><p>clear errors from subroutine BDAT20</p></a></li>
<li><a href='#errormessage'><p>Return dedicated error message</p></a></li>
<li><a href='#getAssortment'><p>Get assortments for one or many trees</p></a></li>
<li><a href='#getBark'><p>Get double bark thickness of tree at given height Hx</p></a></li>
<li><a href='#getBiomass'><p>Get total aboveground biomass of tree</p></a></li>
<li><a href='#getDiameter'><p>Get diameter in given height inside tree taper</p></a></li>
<li><a href='#getForm'><p>Get estimated mean of form factor q03</p></a></li>
<li><a href='#getHeight'><p>Get height of given diameter inside tree taper</p></a></li>
<li><a href='#getSpeciesCode'><p>Get BDAT species code or transform it to a name.</p></a></li>
<li><a href='#getVolume'><p>Get segment volume for one or many trees</p></a></li>
<li><a href='#plot.datBDAT'><p>Plot taper curve of a tree</p></a></li>
<li><a href='#throw'><p>Throw a Condition</p></a></li>
<li><a href='#transformBDAT20'><p>transform BDAT20-matrix</p></a></li>
<li><a href='#updateBdatNamespace'><p>replace NAMESPACE from 'rBDATPRO' to 'rBDAT'.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Implementation of BDAT Tree Taper Fortran Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementing the BDAT tree taper Fortran routines, which were
  developed for the German National Forest Inventory (NFI), to calculate 
  diameters, volume, assortments, double bark thickness and biomass for
  different tree species based on tree characteristics and sorting information.
  See Kublin (2003) &lt;<a href="https://doi.org/10.1046%2Fj.1439-0337.2003.00183.x">doi:10.1046/j.1439-0337.2003.00183.x</a>&gt; for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/vochr/rbdat">https://gitlab.com/vochr/rbdat</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, pkgload, rmarkdown, RUnit, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 13:43:07 UTC; christian.vonderach</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Vonderach [aut, cre],
  Edgar Kublin [aut],
  Bernhard Bösch [aut],
  Gerald Kändler [aut],
  Dominik Cullmann [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Vonderach &lt;christian.vonderach@forst.bwl.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 00:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='rBDAT-package'>Implementation of BDAT Tree Taper Fortran Functions</h2><span id='topic+rBDAT-package'></span>

<h3>Description</h3>

<p>Implementing the BDAT tree taper Fortran routines, which were
developed for the German National Forest Inventory (NFI), to calculate
diameters, volume, assortments, double bark thickness and biomass for
different tree species based on tree characteristics and sorting information.
</p>


<h3>References</h3>

<p>Kublin E. (2003): Einheitliche Beschreibung der Schaftform –
Methoden und Programme – BDATPro. Forstw. Cbl. 122, 183–200,
<a href="https://link.springer.com/article/10.1046/j.1439-0337.2003.00183.x">https://link.springer.com/article/10.1046/j.1439-0337.2003.00183.x</a>
</p>
<p>Kublin E., Scharnagl. G. (1988): Verfahrens- und
Programmbeschreibung zum BWI-Unterprogramm BDAT: Abschlußbericht zum
Forschungsauftrag: &quot;Biometrische Lösungen für die Berechnung des Volumens,
der Sortierung, der Rindenabzüge und der Ernteverluste im Rahmen der
Bundeswaldinventur&quot;. ISSN: 0178-3165. Available at
<a href="https://gitlab.com/vochr/rbdat/-/blob/master/bdatdocs/">https://gitlab.com/vochr/rbdat/-/blob/master/bdatdocs/</a>
</p>

<hr>
<h2 id='BDAT20'>BDAT 2.0 assortment function</h2><span id='topic+BDAT20'></span>

<h3>Description</h3>

<p>Calculates volumes and assortments for given tree/s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDAT20(
  BDATArtNr,
  D1,
  H1 = 0,
  D2 = 0,
  H2 = 0,
  H,
  lX = 0,
  Hkz = 0,
  Skz = 0,
  Az = 0,
  Hsh = 0,
  Zsh = 0,
  Zab = 0,
  Sokz = 1,
  NMaxFixLng = 0,
  FixLngDef = matrix(rep(0, length(BDATArtNr) * 4), ncol = 4),
  result = "raw"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDAT20_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric, 1 &lt;= spp &lt;= 36, see <code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code></p>
</td></tr>
<tr><td><code id="BDAT20_+3A_d1">D1</code></td>
<td>
<p>numeric, first measured diameter [cm], usually in 1.3m</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_h1">H1</code></td>
<td>
<p>numeric, height of first measured diameter [m]</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_d2">D2</code></td>
<td>
<p>numeric, second measured diameter [cm], or form parameter,
see <code><a href="#topic+buildTree">buildTree</a></code>.</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_h2">H2</code></td>
<td>
<p>H2: numeric, height of second measured diameter [m], or form
parameter, see <code><a href="#topic+buildTree">buildTree</a></code>.</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_h">H</code></td>
<td>
<p>numeric, tree height [m]</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_lx">lX</code></td>
<td>
<p>length of unusable wood at stem foot [m], defaults to 0</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_hkz">Hkz</code></td>
<td>
<p>indicator for tree top, 0 - normal (default), 1 - Wipfelbruch,
2 - Gipfelbruch</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_skz">Skz</code></td>
<td>
<p>indicator for stem type, defaults to 0, see <code><a href="#topic+buildTree">buildTree</a></code></p>
</td></tr>
<tr><td><code id="BDAT20_+3A_az">Az</code></td>
<td>
<p>minimum cutting diameter over bark [cm], defaults to 0, using
tabulated data depending on DBH (not documented)</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_hsh">Hsh</code></td>
<td>
<p>usable stem height, defaults to 0, i.e. 0.7*H</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_zsh">Zsh</code></td>
<td>
<p>minimum cutting diameter under bark for stem wood [cm],
defaults to 0, using tabulated data depending on DBH (not documented)</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_zab">Zab</code></td>
<td>
<p>minimum cutting diameter under bark for top segment [cm],
defaults to 0, i.e. 14cm under bark.</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_sokz">Sokz</code></td>
<td>
<p>type assortment calculation, 0 - no assortment,
1 - mid diameter (Mittenstärke), 2 - Heilbronner Sortierung, defaults to 1</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_nmaxfixlng">NMaxFixLng</code></td>
<td>
<p>number of fixed length assortments at stem foot, defaults
to 0 (no fixed length assortments, irrespective of <code>FixLngDef</code>)</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_fixlngdef">FixLngDef</code></td>
<td>
<p>matrix of 4 * length(spp), having minimum cutting diameter,
required assortment length, absolute and relative add-on</p>
</td></tr>
<tr><td><code id="BDAT20_+3A_result">result</code></td>
<td>
<p>indicator about what information should be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Using default value of <code>result</code>, which is 'raw', a list is
returned keeping information about the input value and produced assortments -
the unprocessed returns from the Fortran code.
</p>
<p>See <code><a href="#topic+getAssortment">getAssortment</a></code> for more details, as this function is
internally called.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAssortment">getAssortment</a></code> for a more flexible function with a
more convenient english name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BDAT20(BDATArtNr = c(1, 1), D1 = c(30, 25), H = c(25, 20)) # returns long list
BDAT20(BDATArtNr = c(1, 1), D1 = c(30, 25), H = c(25, 20), result = "Vol")
# size class
BDAT20(BDATArtNr = c(1, 1), D1 = c(30, 25), H = c(25, 20), result = "Skl")
BDAT20(
  BDATArtNr = c(1, 1), D1 = c(30, 25), H = c(25, 20), NMaxFixLng = 1,
  result = "Fix"
)
</code></pre>

<hr>
<h2 id='BDATBIOMASSE'>Get total aboveground biomasse</h2><span id='topic+BDATBIOMASSE'></span>

<h3>Description</h3>

<p>BDAT-Function to get total aboveground biomass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDATBIOMASSE(BDATArtNr, D1, H1 = 0, D2 = 0, H2 = 0, H)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDATBIOMASSE_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric vector of species code, see
<code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code></p>
</td></tr>
<tr><td><code id="BDATBIOMASSE_+3A_d1">D1</code></td>
<td>
<p>first measured diameter of tree [cm], e.g. diameter in breast
height</p>
</td></tr>
<tr><td><code id="BDATBIOMASSE_+3A_h1">H1</code></td>
<td>
<p>measurement height of <code>D1</code> [m]</p>
</td></tr>
<tr><td><code id="BDATBIOMASSE_+3A_d2">D2</code></td>
<td>
<p>second measured diameter of tree, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATBIOMASSE_+3A_h2">H2</code></td>
<td>
<p>measurement height of D2, see <code><a href="#topic+buildTree">buildTree</a></code> for details
on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATBIOMASSE_+3A_h">H</code></td>
<td>
<p>total tree height [m]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns total aboveground biomass for given tree/s,
based on the biomass functions developed for the german NFI 3. See the
additional material for some german reference.
</p>


<h3>Value</h3>

<p>vector of biomass for given trees
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getBiomass">getBiomass</a></code> for a function with more convenient english
name
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple call of function, with all parameters given
BDATBIOMASSE(1, 30, 1.3, 0, 0, 25)

## same with variables
BDATArtNr &lt;- 1
D1 &lt;- 30
H1 &lt;- 1.3
D2 &lt;- 0
H2 &lt;- 0
H &lt;- 25
BDATBIOMASSE(BDATArtNr = BDATArtNr, D1 = D1, H1 = H1, D2 = D2, H2 = H2, H = H)

## calling with a subset of tree characteristics
## german species names, abbreviated
BDATBIOMASSE(getSpeciesCode(c("Fi", "Bu")), 30, H = 25)
## english abbreviated
BDATBIOMASSE(getSpeciesCode(c("NS", "BE")), 30, H = 25)
</code></pre>

<hr>
<h2 id='BDATDMRHX'>Calculate diameter in height Hx over bark.</h2><span id='topic+BDATDMRHX'></span>

<h3>Description</h3>

<p>Function to call BDAT Fortran subroutine to calculate diameter
over bark in height Hx for specified tree/s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDATDMRHX(BDATArtNr, D1, H1, D2, H2, H, Hx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDATDMRHX_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric vector of species code; see
<code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code>.</p>
</td></tr>
<tr><td><code id="BDATDMRHX_+3A_d1">D1</code></td>
<td>
<p>first measured diameter of tree [cm], e.g. diameter in breast
height.</p>
</td></tr>
<tr><td><code id="BDATDMRHX_+3A_h1">H1</code></td>
<td>
<p>measurement height of <code>D1</code> [m]</p>
</td></tr>
<tr><td><code id="BDATDMRHX_+3A_d2">D2</code></td>
<td>
<p>second measured diameter of tree, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATDMRHX_+3A_h2">H2</code></td>
<td>
<p>measurement height of D2, see <code><a href="#topic+buildTree">buildTree</a></code> for details
on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATDMRHX_+3A_h">H</code></td>
<td>
<p>total tree height [m]</p>
</td></tr>
<tr><td><code id="BDATDMRHX_+3A_hx">Hx</code></td>
<td>
<p>height in tree for which diameter over bark is required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>conventional function interface for Fortran function BDATDMRHX. See
<code><a href="#topic+getDiameter">getDiameter</a></code> for more details.
</p>


<h3>Value</h3>

<p>vector of diameters over bark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BDATDORHX">BDATDORHX</a></code> for BDAT routine calculating diameter under
bark and <code><a href="#topic+getDiameter">getDiameter</a></code> for a function with a more convenient
english name, more options and including a bark switch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple call of function, with all parameters
BDATDMRHX(1, 30, 1.3, 0, 0, 25, Hx = 1.3)
# same with variables
BDATArtNr &lt;- 1
D1 &lt;- 30
H1 &lt;- 1.3
D2 &lt;- 0
H2 &lt;- 0
H &lt;- 25
Hx &lt;- 1.3
BDATDMRHX(BDATArtNr = BDATArtNr, D1 = D1, H1 = H1, D2 = D2, H2 = H2, H = H, Hx = Hx)
## calling with a subset of tree characteristics
## german species names, abbreviated
BDATDMRHX(getSpeciesCode(c("Fi", "Bu")), 30, 0, 0, 0, H = 25, Hx = 1.3)
## english species names abbreviated
BDATDMRHX(getSpeciesCode(c("NS", "BE")), 30, 0, 0, 0, H = 25, Hx = 1.3)
</code></pre>

<hr>
<h2 id='BDATDORHX'>Calculate diameter in height Hx under bark.</h2><span id='topic+BDATDORHX'></span>

<h3>Description</h3>

<p>Function to call BDAT Fortran subroutine to calculate diameter
under bark in height Hx for specified tree/s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDATDORHX(BDATArtNr, D1, H1, D2, H2, H, Hx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDATDORHX_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric vector of species code; see
<code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code>.</p>
</td></tr>
<tr><td><code id="BDATDORHX_+3A_d1">D1</code></td>
<td>
<p>first measured diameter of tree [cm], e.g. diameter in breast
height</p>
</td></tr>
<tr><td><code id="BDATDORHX_+3A_h1">H1</code></td>
<td>
<p>measurement height of <code>D1</code> [m]</p>
</td></tr>
<tr><td><code id="BDATDORHX_+3A_d2">D2</code></td>
<td>
<p>second measured diameter of tree, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATDORHX_+3A_h2">H2</code></td>
<td>
<p>measurement height of D2, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATDORHX_+3A_h">H</code></td>
<td>
<p>total tree height [m]</p>
</td></tr>
<tr><td><code id="BDATDORHX_+3A_hx">Hx</code></td>
<td>
<p>height in tree for which diameter under bark is required</p>
</td></tr>
</table>


<h3>Details</h3>

<p>conventional function interface for BDATDORHX. See
<code><a href="#topic+getDiameter">getDiameter</a></code> for more details.
</p>


<h3>Value</h3>

<p>vector of diameters under bark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BDATDMRHX">BDATDMRHX</a></code> for BDAT routine calculating diameter over
bark, <code><a href="#topic+getDiameter">getDiameter</a></code> for a function with a more convenient english
name, more options and a bark switch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple call of function, with all parameters
BDATDORHX(1, 30, 1.3, 0, 0, 25, Hx = 1.3)
# same with variables
BDATArtNr &lt;- 1
D1 &lt;- 30
H1 &lt;- 1.3
D2 &lt;- 0
H2 &lt;- 0
H &lt;- 25
Hx &lt;- 1.3
BDATDORHX(BDATArtNr = BDATArtNr, D1 = D1, H1 = H1, D2 = D2, H2 = H2, H = H, Hx = Hx)
## calling with a subset of tree characteristics
## german species names, abbreviated
BDATDORHX(getSpeciesCode(c("Fi", "Bu")), 30, 0, 0, 0, H = 25, Hx = 1.3)
## english species names abbreviated
BDATDORHX(getSpeciesCode(c("NS", "BE")), 30, 0, 0, 0, H = 25, Hx = 1.3)
</code></pre>

<hr>
<h2 id='BDATRINDE2HX'>Calculate double bark thickness</h2><span id='topic+BDATRINDE2HX'></span>

<h3>Description</h3>

<p>BDAT-Function to get double bark thickness at given height Hx
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDATRINDE2HX(BDATArtNr, D1, H1 = 1.3, D2 = 0, H2 = 0, H, Hx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDATRINDE2HX_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric vector of species code; see
<code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code>.</p>
</td></tr>
<tr><td><code id="BDATRINDE2HX_+3A_d1">D1</code></td>
<td>
<p>first measured diameter of tree [cm] e.g. diameter in breast height</p>
</td></tr>
<tr><td><code id="BDATRINDE2HX_+3A_h1">H1</code></td>
<td>
<p>measurement height of <code>D1</code> [m]</p>
</td></tr>
<tr><td><code id="BDATRINDE2HX_+3A_d2">D2</code></td>
<td>
<p>second measured diameter of tree, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATRINDE2HX_+3A_h2">H2</code></td>
<td>
<p>measurement height of D2, see <code><a href="#topic+buildTree">buildTree</a></code> for details
on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATRINDE2HX_+3A_h">H</code></td>
<td>
<p>total tree height [m]</p>
</td></tr>
<tr><td><code id="BDATRINDE2HX_+3A_hx">Hx</code></td>
<td>
<p>height for which double bark thickness is required [m]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns double bark thickness in given height
<code>Hx</code> in stem
taper (hence, it depends on the diameter in given height). This can be added
onto a diameter under bark to receive diameter over bark.
</p>


<h3>Value</h3>

<p>vector of double bark thickness given height <code>Hx</code> inside stem
taper.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getBark">getBark</a></code> for a function with a convenient english name
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple call of function, with all parameters given
BDATRINDE2HX(1, 30, 1.3, 0, 0, 25, Hx = 1.3)

## same with variables
BDATArtNr &lt;- 1
D1 &lt;- 30
H1 &lt;- 1.3
D2 &lt;- 0
H2 &lt;- 0
H &lt;- 25
Hx &lt;- 1.3
BDATRINDE2HX(BDATArtNr = BDATArtNr, D1 = D1, H1 = H1, D2 = D2, H2 = H2, H = H, Hx = Hx)
## calling with a subset of tree characteristics
## german species names, abbreviated
BDATRINDE2HX(getSpeciesCode(c("Fi", "Bu")), 30, 0, 0, 0, H = 25, Hx = 1.3)
## english abbreviated
BDATRINDE2HX(getSpeciesCode(c("NS", "BE")), 30, 0, 0, 0, H = 25, Hx = 1.3)
</code></pre>

<hr>
<h2 id='BDATVOLABMR'>Calculate wood volume over bark of a tree between height A and B</h2><span id='topic+BDATVOLABMR'></span>

<h3>Description</h3>

<p>BDAT-Function to get wood volume over bark of one or many trees
of a section between height A and height B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDATVOLABMR(BDATArtNr, D1, H1 = 1.3, D2 = 0, H2 = 0, H, A, B, SekLng = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDATVOLABMR_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric vector of species code; see
<code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code>.</p>
</td></tr>
<tr><td><code id="BDATVOLABMR_+3A_d1">D1</code></td>
<td>
<p>first measured diameter of tree [cm], e.g. diameter in breast
height.</p>
</td></tr>
<tr><td><code id="BDATVOLABMR_+3A_h1">H1</code></td>
<td>
<p>measurement height of <code>D1</code> [m]</p>
</td></tr>
<tr><td><code id="BDATVOLABMR_+3A_d2">D2</code></td>
<td>
<p>second measured diameter of tree, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATVOLABMR_+3A_h2">H2</code></td>
<td>
<p>measurement height of D2, see <code><a href="#topic+buildTree">buildTree</a></code> for details
on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATVOLABMR_+3A_h">H</code></td>
<td>
<p>total tree height [m]</p>
</td></tr>
<tr><td><code id="BDATVOLABMR_+3A_a">A</code></td>
<td>
<p>lower height of section for which volume is required [m]</p>
</td></tr>
<tr><td><code id="BDATVOLABMR_+3A_b">B</code></td>
<td>
<p>upper height of section for which volume is required [m]</p>
</td></tr>
<tr><td><code id="BDATVOLABMR_+3A_seklng">SekLng</code></td>
<td>
<p>length of section over which the integral of taper form should
be applied, defaults to 2.0m</p>
</td></tr>
</table>


<h3>Details</h3>

<p>wood volume is calculated using BDAT Fortran routines.
</p>


<h3>Value</h3>

<p>vector of same length as input variables transformed into a
data.frame, returning the required wood volume in cubic meter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BDATVOLABOR">BDATVOLABOR</a></code> for BDAT routine calculating volume under
bark, <code><a href="#topic+getVolume">getVolume</a></code> for a function with a convenient english name,
more options and a bark switch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple call of function, with all parameters
BDATVOLABMR(1, 30, 1.3, 0, 0, 25, .25, 5.25, 2.0)
BDATArtNr &lt;- 1
D1 &lt;- 30
H1 &lt;- 1.3
D2 &lt;- 0
H2 &lt;- 0
H &lt;- 25
A &lt;- 1
B &lt;- 10

## same given variables
BDATVOLABMR(BDATArtNr = BDATArtNr, D1 = D1, H1 = H1, D2 = D2, H2 = H2, H = H, A = A, B = B)

## calling with a subset of tree characteristics
## german species names, abbreviated
BDATVOLABMR(getSpeciesCode(c("Fi", "Bu")), 30, 0, 0, 0, H = 25, A = 0, B = 25)
## english abbreviated
BDATVOLABMR(getSpeciesCode(c("NS", "BE")), 30, 0, 0, 0, H = 25, A = 0, B = 25)
</code></pre>

<hr>
<h2 id='BDATVOLABOR'>Calculate volume under bark of a tree between height A and B</h2><span id='topic+BDATVOLABOR'></span>

<h3>Description</h3>

<p>BDAT-Function to get wood volume under bark of one or many trees
of a section between height A and height B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDATVOLABOR(BDATArtNr, D1, H1 = 1.3, D2 = 0, H2 = 0, H, A, B, SekLng = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDATVOLABOR_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric vector of species code; see <code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code></p>
</td></tr>
<tr><td><code id="BDATVOLABOR_+3A_d1">D1</code></td>
<td>
<p>first measured diameter of tree [cm], e.g. diameter in breast height</p>
</td></tr>
<tr><td><code id="BDATVOLABOR_+3A_h1">H1</code></td>
<td>
<p>measurement height of <code>D1</code> [m]</p>
</td></tr>
<tr><td><code id="BDATVOLABOR_+3A_d2">D2</code></td>
<td>
<p>second measured diameter of tree, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATVOLABOR_+3A_h2">H2</code></td>
<td>
<p>measurement height of D2, see <code><a href="#topic+buildTree">buildTree</a></code> for details
on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATVOLABOR_+3A_h">H</code></td>
<td>
<p>total tree height [m]</p>
</td></tr>
<tr><td><code id="BDATVOLABOR_+3A_a">A</code></td>
<td>
<p>lower height of section for which volume is required [m]</p>
</td></tr>
<tr><td><code id="BDATVOLABOR_+3A_b">B</code></td>
<td>
<p>upper height of section for which volume is required [m]</p>
</td></tr>
<tr><td><code id="BDATVOLABOR_+3A_seklng">SekLng</code></td>
<td>
<p>length of section over which the integral of taper form should
be applied, defaults to 2.0m</p>
</td></tr>
</table>


<h3>Details</h3>

<p>wood volume is calculated using BDAT Fortran routines.
</p>


<h3>Value</h3>

<p>vector of same length as input variables transformed into a
data.frame, returning the required wood volume in cubic meter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BDATVOLABMR">BDATVOLABMR</a></code> for BDAT routine calculating volume over
bark, <code><a href="#topic+getVolume">getVolume</a></code> for a function with a convenient english name,
more options and including a bark switch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple call of function, with all parameters
BDATVOLABOR(1, 30, 1.3, 0, 0, 25, .25, 5.25, 2.0)
BDATArtNr &lt;- 1
D1 &lt;- 30
H1 &lt;- 1.3
D2 &lt;- 0
H2 &lt;- 0
H &lt;- 25
A &lt;- 1
B &lt;- 10

## same with variables
BDATVOLABOR(BDATArtNr = BDATArtNr, D1 = D1, H1 = H1, D2 = D2, H2 = H2, H = H, A = A, B = B)

## calling with a subset of tree characteristics
## german species names, abbreviated
BDATVOLABOR(getSpeciesCode(c("Fi", "Bu")), 30, 0, 0, 0, H = 25, A = 0, B = 25)
## english abbreviation
BDATVOLABOR(getSpeciesCode(c("NS", "BE")), 30, 0, 0, 0, H = 25, A = 0, B = 25)
</code></pre>

<hr>
<h2 id='BDATVOLDHMR'>Calculate (coarse) wood volume over bark of a tree up to given diameter</h2><span id='topic+BDATVOLDHMR'></span>

<h3>Description</h3>

<p>BDAT-Function to get (coarse) wood volume over bark up to a
given diameter of one or many trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDATVOLDHMR(BDATArtNr, D1, H1 = 1.3, D2 = 0, H2 = 0, H, DHGrz = 7, SekLng = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDATVOLDHMR_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric vector of species code; see
<code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code>.</p>
</td></tr>
<tr><td><code id="BDATVOLDHMR_+3A_d1">D1</code></td>
<td>
<p>first measured diameter of tree [cm], e.g. diameter in breast
height.</p>
</td></tr>
<tr><td><code id="BDATVOLDHMR_+3A_h1">H1</code></td>
<td>
<p>measurement height of <code>D1</code> [m]</p>
</td></tr>
<tr><td><code id="BDATVOLDHMR_+3A_d2">D2</code></td>
<td>
<p>second measured diameter of tree, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATVOLDHMR_+3A_h2">H2</code></td>
<td>
<p>measurement height of D2, see <code><a href="#topic+buildTree">buildTree</a></code> for details
on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATVOLDHMR_+3A_h">H</code></td>
<td>
<p>total tree height [m]</p>
</td></tr>
<tr><td><code id="BDATVOLDHMR_+3A_dhgrz">DHGrz</code></td>
<td>
<p>diameter over bark up to which volume should be calculated</p>
</td></tr>
<tr><td><code id="BDATVOLDHMR_+3A_seklng">SekLng</code></td>
<td>
<p>length of section over which the integral of taper form should
be applied, defaults to 2.0m.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Volume is calculated using BDAT Fortran routines. In particular,
<code>BDATVOLDHMR</code> internally calls <code><a href="#topic+BDATVOLABMR">BDATVOLABMR</a></code> with parameter
<code>A = 0</code>, i.e. volume is calculated from forest floor up to given
diameter, which itself is transformed into height <code>B</code>.
</p>


<h3>Value</h3>

<p>vector of same length as input variables transformed into a
data.frame, returning the required volume in cubic meter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BDATVOLDHOR">BDATVOLDHOR</a></code> for BDAT routine calculating volume under
bark, <code><a href="#topic+getVolume">getVolume</a></code> for a function with a convenient english name,
more options and including a bark switch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple call of function, with all parameters given
BDATVOLDHMR(1, 30, 1.3, 0, 0, 25, 7, 2.0)
BDATArtNr &lt;- 1
D1 &lt;- 30
H1 &lt;- 1.3
D2 &lt;- 0
H2 &lt;- 0
H &lt;- 25
DHGrz &lt;- 7

## same using variables
BDATVOLDHMR(BDATArtNr = BDATArtNr, D1 = D1, H1 = H1, D2 = D2, H2 = H2, H = H, DHGrz = DHGrz)

## calling with a subset of tree characteristics
## german species names, abbreviated
BDATVOLDHMR(getSpeciesCode(c("Fi", "Bu")), 30, 0, 0, 0, H = 25, DHGrz = 7)
## english abbreviation
BDATVOLDHMR(getSpeciesCode(c("NS", "BE")), 30, 0, 0, 0, H = 25, DHGrz = 7)
</code></pre>

<hr>
<h2 id='BDATVOLDHOR'>Calculate (coarse) wood volume under bark of a tree up to given diameter</h2><span id='topic+BDATVOLDHOR'></span>

<h3>Description</h3>

<p>BDAT-Function to get (coarse) wood volume under bark up to a given
diameter of one or many trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDATVOLDHOR(BDATArtNr, D1, H1 = 1.3, D2 = 0, H2 = 0, H, DHGrz = 7, SekLng = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BDATVOLDHOR_+3A_bdatartnr">BDATArtNr</code></td>
<td>
<p>numeric vector of species code; see
<code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code>.</p>
</td></tr>
<tr><td><code id="BDATVOLDHOR_+3A_d1">D1</code></td>
<td>
<p>first measured diameter of tree [cm], e.g. diameter in breast
height.</p>
</td></tr>
<tr><td><code id="BDATVOLDHOR_+3A_h1">H1</code></td>
<td>
<p>measurement height of <code>D1</code>, [m].</p>
</td></tr>
<tr><td><code id="BDATVOLDHOR_+3A_d2">D2</code></td>
<td>
<p>second measured diameter of tree, see <code><a href="#topic+buildTree">buildTree</a></code> for
details on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATVOLDHOR_+3A_h2">H2</code></td>
<td>
<p>measurement height of D2, see <code><a href="#topic+buildTree">buildTree</a></code> for details
on how to specify different taper forms</p>
</td></tr>
<tr><td><code id="BDATVOLDHOR_+3A_h">H</code></td>
<td>
<p>total tree height [m]</p>
</td></tr>
<tr><td><code id="BDATVOLDHOR_+3A_dhgrz">DHGrz</code></td>
<td>
<p>diameter inside bark up to which volume should be calculated</p>
</td></tr>
<tr><td><code id="BDATVOLDHOR_+3A_seklng">SekLng</code></td>
<td>
<p>length of section over which the integral of taper form should
be applied, defaults to 2.0m.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Volume is calculated using BDAT Fortran routines. In particular,
<code>BDATVOLDHOR</code> internally calls <code><a href="#topic+BDATVOLABOR">BDATVOLABOR</a></code> with parameter
<code>A = 0</code>, i.e. volume is calculated from forest floor up to given
diameter, which itself is transformed into height <code>B</code>.
</p>


<h3>Value</h3>

<p>vector of same length as input variables transformed into a data.frame,
returning the required volume in cubic meter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BDATVOLDHMR">BDATVOLDHMR</a></code> for BDAT routine calculating volume over
bark, <code><a href="#topic+getVolume">getVolume</a></code> for a function with a convenient english name,
more options and including a bark switch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple call of function, with all parameters
BDATVOLDHOR(1, 30, 1.3, 0, 0, 25, 7, 2.0)

## same using variables
BDATArtNr &lt;- 1
D1 &lt;- 30
H1 &lt;- 1.3
D2 &lt;- 0
H2 &lt;- 0
H &lt;- 25
DHGrz &lt;- 7
BDATVOLDHOR(BDATArtNr = BDATArtNr, D1 = D1, H1 = H1, D2 = D2, H2 = H2, H = H, DHGrz = DHGrz)

## calling with a subset of tree characteristics
## german species names, abbreviated
BDATVOLDHOR(getSpeciesCode(c("Fi", "Bu")), 30, 0, 0, 0, H = 25, DHGrz = 7)
## english abbreviation
BDATVOLDHOR(getSpeciesCode(c("NS", "BE")), 30, 0, 0, 0, H = 25, DHGrz = 7)
</code></pre>

<hr>
<h2 id='buildTree'>Build and check tree data for subsequent use in
BDAT Fortran subroutines</h2><span id='topic+buildTree'></span>

<h3>Description</h3>

<p>this functions takes the data provided and builds a data.frame
to be used in other BDAT get*-functions. It discriminates between different
type of required output via the <code>check</code>-parameter. Checks are done on
the type and range of the variables given to make sure calls to the
Fortran routines do not suffer from type-mismatch (with potential freezing
of R).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildTree(tree, check = NULL, vars = NULL, mapping = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildTree_+3A_tree">tree</code></td>
<td>
<p>either a data.frame or a list containing the variables needed,
i.e. spp, D1, H and optionally H1, D2, H2. See details for more
information and parameter <code>mapping</code> for mapping of variable names.</p>
</td></tr>
<tr><td><code id="buildTree_+3A_check">check</code></td>
<td>
<p>character vector which indicates the type of required output and
determines the checks to be done</p>
</td></tr>
<tr><td><code id="buildTree_+3A_vars">vars</code></td>
<td>
<p>named list with additional variables for the specific
BDAT-functions; see <code><a href="#topic+getDiameter">getDiameter</a></code>, <code><a href="#topic+getHeight">getHeight</a></code>,
<code><a href="#topic+getVolume">getVolume</a></code>, <code><a href="#topic+getBiomass">getBiomass</a></code>, <code><a href="#topic+getBark">getBark</a></code>,
<code><a href="#topic+getForm">getForm</a></code> and <code><a href="#topic+getAssortment">getAssortment</a></code>.
These variables might be included to <code>tree</code> as well, see details.</p>
</td></tr>
<tr><td><code id="buildTree_+3A_mapping">mapping</code></td>
<td>
<p>mapping of variable names in case a data.frame is given into
parameter <code>tree</code> and <code>vars</code> between final <code>colnames(tree)</code> and
required parameter names. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter <code>tree</code> is able to take either a data.frame with
correct variables names or arbitrary names if <code>mapping</code> is provided to
map the data.frame names to the required names by
<code>c("df-colname" = "var-name")</code> or to take a named list. If same-named
variables are present in both <code>tree</code> and <code>vars</code>, priority is put
on the ones in <code>vars</code> since explicitly given.
</p>
<p>Possible variables are (*=required, depending on function):
</p>

<ul>
<li><p> spp*: numeric, 1 &lt;= spp &lt;= 36, see <code><a href="#topic+getSpeciesCode">getSpeciesCode</a></code>
</p>
</li>
<li><p> D1*: numeric, first measured diameter [cm], usually at 1.3m
</p>
</li>
<li><p> H1: numeric, height of first measured diameter [m], if zero,
internally transformed to 1.3m
</p>
</li>
<li><p> D2: numeric, second measured diameter [cm], or form parameter: latter
is defined in conjunction with <code>H2</code>:
</p>

<ul>
<li><p> D2=0 and H2=0 =&gt; taper form of volume tables according to
Grundner &amp; Schwappach (1906-1938), the default
</p>
</li>
<li><p> D2=0 and 0 &lt; H2 &lt; 100 =&gt; german NFI1-taper form, with H2 given as
percentile of the NFI1-<code class="reqn">q_{0.30}</code>-distribution; H2=50
corresponds to mean NFI1 taper form, H2&lt;50 to slenderly and H2&gt;50 to
thicker trees; see <code><a href="#topic+getForm">getForm</a></code> for more information about
<code class="reqn">q_{0.30}</code>
</p>
</li>
<li><p> D2=0 and H2&gt;100 =&gt; mean NFI1 taper form
</p>
</li>
<li><p> D2&gt;0 and H2=0 =&gt; D2 is a diameter and H2 is assumed to be 7m
</p>
</li>
<li><p> D2&gt;0 and H2&gt;0 =&gt; D2 and H2 are given as diameter and height
</p>
</li>
<li><p> -1&lt;D2&lt;0 =&gt; abs(D2) is interpreted as <code class="reqn">q_{0.30}</code>
</p>
</li>
<li><p> -1&gt;D2 =&gt; mean NFI1 taper form
</p>
</li></ul>

</li>
<li><p> H2: numeric, height of second measured diameter [m], or in
conjunction with <code>D2</code>, see there.
</p>
</li>
<li><p> H*: numeric, tree height [m]
</p>
</li>
<li><p> A*: numeric, lower diameter [cm] or height [m] of section for which
volume should be calculated, interpretation depends on <code>iAB</code>, see
<code><a href="#topic+getVolume">getVolume</a></code>
</p>
</li>
<li><p> B*: numeric, upper diameter [cm] or height [m] of section for which
volume should be calculated, interpretation depends on <code>iAB</code>, see
<code><a href="#topic+getVolume">getVolume</a></code>
</p>
</li>
<li><p> sl: numeric, length of section over which should be integrated,
defaults to 2.0m
</p>
</li>
<li><p> Dx*: diameter for which height or bark thickness is required
</p>
</li>
<li><p> Hx*: height for which diameter is required
</p>
</li>
<li><p> inv: inventory for which mean q03 is required, defaults to 1, see
<code><a href="#topic+getForm">getForm</a></code>
</p>
</li></ul>

<p>For deriving assortments, the following variables are optional (if not given,
default values are used):
</p>

<ul>
<li><p> lX: length of unusable wood at stem foot [m], defaults to 0 (X-Holz)
</p>
</li>
<li><p> Hkz: indicator for tree top, 0 - normal (default), 1 - Wipfelbruch, 2 - Gipfelbruch
</p>

<ul>
<li><p> 0 =&gt; H=H
</p>
</li>
<li><p> 1 =&gt; H=H+2
</p>
</li>
<li><p> 2 =&gt; DBH &lt; 30 =&gt; H=DBH; dbh &gt; 30 =&gt; H = 30 + (DBH-30) * 0.3
</p>
</li></ul>

</li>
<li><p> Skz: indicator for stem type, defaults to 0
</p>

<ul>
<li><p> 0 =&gt; conifer trees =&gt; no restriction; deciduous trees =&gt; no assortments
</p>
</li>
<li><p> 1 =&gt; monopodial deciduous trees =&gt; Hsh = 0.7*H
</p>
</li>
<li><p> 2 =&gt; branching between dbh and 7m =&gt; Hsh = 5m
</p>
</li>
<li><p> 3 =&gt; crown base &lt; 3m =&gt; Hsh=0.1
</p>
</li>
<li><p> 4 =&gt; dead or broken stem =&gt; Az = H*0.7
</p>
</li>
<li><p> 5 =&gt; dead tree =&gt; non-usable wood
</p>
</li></ul>

</li>
<li><p> Hsh: usable stem height, defaults to 0, i.e. 0.7*H
</p>
</li>
<li><p> Az: minimum cutting diameter over bark [cm], defaults to 0,
using an exponential function given DBH
</p>
</li>
<li><p> Zsh: minimum cutting diameter under bark for stem wood [cm], defaults
to 0, using parameter <code>Az</code> if estimated length &lt; maximum length (i.e. 20m)
</p>
</li>
<li><p> Zab: minimum cutting diameter under bark for top segment [cm], defaults
to 0, i.e. 14cm under bark
</p>
</li>
<li><p> Sokz: type assortment calculation, 0 - no assortment,
1 - Mid diameter (Mittenstärke), 2 - Heilbronner Sortierung, defaults to 1
</p>
</li>
<li><p> fixN: number of fixed length assortments at stem foot, defaults to 0
(no fixed length assortments, irrespective of other fix* parameters)
</p>
</li>
<li><p> fixZ: mininum diameter under bark for fixed length assortment at
stem foot, defaults to 0
</p>
</li>
<li><p> fixL: length of fixed length assortment at stem foot, defaults to 0
</p>
</li>
<li><p> fixA: fixed length assortement add-on in [cm], defaults to 0
</p>
</li>
<li><p> fixR: fixed length assortement add-on in [%], defaults to 0
</p>
</li></ul>

<p>If parameter <code>tree</code> is used to hand over all tree data in form of
a data.frame, at least the parameter spp, D1, H must be provided, eventually
mapped via <code>mapping</code>.
Parameter <code>Hx</code> and <code>Dx</code>, which specify height and diameter for
which a diameter or height is requested, respectively, can either be included
to the definition of the tree data or alternatively given separately using
the vars parameter. In that case, vars is used in priority to a identically
named variable in <code>tree</code>. Additionally, <code>tree</code> and <code>vars</code> are
merged via a full outer join.
The add-on in fixed length assortments can be given in absolute and relative
units at the same time, but the higher value will be used.
</p>


<h3>Value</h3>

<p>a data.frame of class datBDAT.&lt;check&gt; having all variables needed in
specific functions. If <code>check</code> is NULL, only a basic tree-data.frame of
class &quot;datBDAT&quot; is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example for only tree data
tree &lt;- list(spp = c(1, 1), D1 = c(30, 25), H = c(25, 30))
res &lt;- buildTree(tree = tree)
head(res)
class(res)

tree &lt;- list(species = c(1, 1), dbh = c(30, 25), h = c(25, 30))
mapping &lt;- c("species" = "spp", "dbh" = "D1", "h" = "H")
res &lt;- buildTree(tree = tree, mapping = mapping)
head(res)
class(res)

## example for diameter calculation
tree &lt;- list(spp = c(1, 1), D1 = c(30, 25), H = c(25, 30))
vars &lt;- list(Hx = c(1.3, 1.3))
mapping &lt;- NULL
res &lt;- buildTree(tree = tree, check = "diameter", vars = vars)
head(res)
class(res)
tree &lt;- list(Art = c(1, 1), Bhd = c(30, 25), H = c(25, 30))
vars &lt;- list(X = c(1.3, 1.3))
mapping &lt;- c("Art" = "spp", "Bhd" = "D1", "X" = "Hx")
res &lt;- buildTree(tree = tree, check = "diameter", vars = vars, mapping = mapping)
head(res)
class(res)

## example with many diameters for one tree
tree &lt;- list(spp = c(1), D1 = c(30), H = c(25))
vars &lt;- list(Hx = seq(0, 25, 0.1))
mapping &lt;- NULL
res &lt;- buildTree(tree = tree, check = "diameter", vars = vars)

tree &lt;- data.frame(s = 1, d = 30, h = 25, hx = 1.3)
mapping &lt;- c("s" = "spp", "d" = "D1", "h" = "H", "hx" = "Hx")
res &lt;- buildTree(tree, check = "diameter", mapping = mapping)
head(res)
class(res)

## example for height calculation
tree &lt;- list(spp = c(1, 1), D1 = c(30, 25), H = c(25, 30))
vars &lt;- list(Dx = c(30, 25))
res &lt;- buildTree(tree = tree, check = "height", vars = vars)
head(res)
class(res)

## example for volume calculation
tree &lt;- list(spp = c(1, 1), D1 = c(30, 25), H = c(25, 30))
check &lt;- "volume"
vars &lt;- list(A = c(30, 25), B = c(7, 7), sl = 0.1)
mapping &lt;- NULL
res &lt;- buildTree(tree = tree, check = "volume", vars = vars)
head(res)
class(res)

## example for bark calculation
tree &lt;- list(spp = c(1, 1), D1 = c(30, 25), H = c(25, 30))
vars &lt;- list(Hx = c(1.3, 1.3))
res &lt;- buildTree(tree = tree, check = "bark", vars = vars)
head(res)
class(res)

## example for assortment calculation
tree &lt;- list(spp = c(1, 1), D1 = c(30, 25), H = c(25, 30))
vars &lt;- list(fixN = 1, fixZ = 10, fixL = 5, fixA = 10, fixR = 0.1)
res &lt;- buildTree(tree = tree, check = "assortment", vars = vars)
head(res)
class(res)

## for cases where 'vars' could be a vector (i.e. getBark, getDiameter and
## getHeight), the following is also possible
tree &lt;- list(spp = c(1, 1), D1 = c(30, 25), H = c(25, 30))
vars &lt;- c(1.3, 1.3)
res &lt;- buildTree(tree = tree, check = "bark", vars = vars)
head(res)
class(res)

res &lt;- buildTree(tree = tree, check = "height", vars = vars)
head(res)
class(res)

## but it is not possible in case of getVolume or getAssortment
## instead, use a named list to achieve a cross join / cartesian product
vars &lt;- list(A = rep(1, 3), B = 5:7)
res &lt;- buildTree(tree = tree, check = "volume", vars = vars)
head(res)
class(res)

## example for 'biomass' calculation
tree &lt;- list(spp = c(1, 1), D1 = c(30, 25), H = c(25, 30))
res &lt;- buildTree(tree = tree, check = "biomass")
head(res)
class(res)

## example with H1 != 1.3m
tree &lt;- list(
  spp = c(1, 1), D1 = c(30, 25), H1 = c(2, 2), H = c(25, 30)
)
res &lt;- buildTree(tree = tree, check = "biomass")
head(res)
class(res)
getBiomass(res)
</code></pre>

<hr>
<h2 id='clearError'>clear errors from subroutine BDAT20</h2><span id='topic+clearError'></span>

<h3>Description</h3>

<p>Returns the NA'd data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearError(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clearError_+3A_data">data</code></td>
<td>
<p>result of subroutine BDAT20</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a corrected, i.e. NA'd version of the input
</p>

<hr>
<h2 id='errormessage'>Return dedicated error message</h2><span id='topic+errormessage'></span>

<h3>Description</h3>

<p>Returns the correct error message of SUBROUTINE BDAT20 according to help
file of BDAT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errormessage(code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="errormessage_+3A_code">code</code></td>
<td>
<p>error codes from subroutine BDAT20 (parameter 'Ifeh')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the error message of the respective codes
</p>

<hr>
<h2 id='getAssortment'>Get assortments for one or many trees</h2><span id='topic+getAssortment'></span><span id='topic+getAssortment.data.frame'></span><span id='topic+getAssortment.list'></span><span id='topic+getAssortment.datBDAT'></span>

<h3>Description</h3>

<p>Function to get assortments given harvest specifications for a
tree of dimension D1, possible D2, and H. Assortments could be diameter
or length constrained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAssortment(tree, ...)

## S3 method for class 'data.frame'
getAssortment(tree, sort = NULL, mapping = NULL, value = "merge", ...)

## S3 method for class 'list'
getAssortment(tree, sort = NULL, mapping = NULL, value = "merge", ...)

## S3 method for class 'datBDAT'
getAssortment(tree, sort = NULL, mapping = NULL, value = "merge", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAssortment_+3A_tree">tree</code></td>
<td>
<p>either an object of class 'datBDAT.assortment' or a data.frame or
list containing the variables needed, i.e. spp, D1, H, and optionally
H1, D2, H2 for specifying the tree. See <code><a href="#topic+buildTree">buildTree</a></code> for more
information and parameter <code>mapping</code> for mapping of variable names.
Indeed, <code>tree</code> could additionally take the variables specified in
<code>sort</code>; otherwise a full outer join is produced between <code>tree</code>
and <code>sort</code></p>
</td></tr>
<tr><td><code id="getAssortment_+3A_...">...</code></td>
<td>
<p>passing arguments to methods.</p>
</td></tr>
<tr><td><code id="getAssortment_+3A_sort">sort</code></td>
<td>
<p>named list with variables specifying assortments, see
<code><a href="#topic+buildTree">buildTree</a></code>.</p>
</td></tr>
<tr><td><code id="getAssortment_+3A_mapping">mapping</code></td>
<td>
<p>mapping of variable names in case a data.frame is given into
parameter <code>tree</code> between colnames(<code>tree</code>) and required parameter
names. See details.</p>
</td></tr>
<tr><td><code id="getAssortment_+3A_value">value</code></td>
<td>
<p>character vector indicating return type: either &quot;Vol&quot;, &quot;Skl&quot;,
&quot;Fix&quot;, &quot;LDSort&quot;, &quot;merge&quot; (default) or &quot;raw&quot;. See section Value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter 'tree' is able to take either a data.frame with correct
variables names or arbitrary names if <code>mapping</code> is provided to map the
data.frame names to the required names by <code>c("df-colname" = "var-name")</code>
or to take a named list.
</p>
<p>Assortments are calculated using BDAT2.0 Fortran routines. Slightly extended,
it now is possible to return length and diameter information also about
standard assortments (which are held in &quot;Vol&quot;-element of return list,
if value=&quot;raw&quot; or value=&quot;Vol&quot;).
</p>
<p>The standard assortment names are:
</p>

<ul>
<li><p> X = non-usable wood at stem foot (X-Holz)
</p>
</li>
<li><p> Sth = stem wood
</p>
</li>
<li><p> Ab = upper part of stem wood, second length after transport cut
</p>
</li>
<li><p> Ind = industrial wood
</p>
</li>
<li><p> nvDh = non-usable coarse wood
</p>
</li></ul>



<h3>Value</h3>

<p>depending on <code>value</code> either information about 'Skl,' 'Vol' or
'Fix' (these are elements of standard output of Fortran BDAT20 subroutine)
and, additionally, information about the 'Vol' elements is retrieved by
<code>value="LDSort"</code> or
if <code>value</code> = 'merge' than a combined information of all produced
assortments with name, base position, assortment length, mid-diameter,
top-diameter and volume is produced. This is most likely what you want,
hence the default. Standard output of BDAT is provided by <code>value="raw"</code>.
Since v0.4.0 a vectorized BDAT-fortran-function is implemented, so each
element of the returned list in case of value=&quot;raw&quot; keeps information of all
trees given. Make sure to appropriately split and manipulate this data.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getAssortment(data.frame)</code>: transforming <code>data.frame</code> before calling
<code>getAssortment</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getAssortment(list)</code>: transforming <code>list</code> before calling
<code>getAssortment</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getAssortment(datBDAT)</code>: class method for class <code>datBDAT</code>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+BDATVOLABMR">BDATVOLABMR</a></code> and <code><a href="#topic+BDATVOLABOR">BDATVOLABOR</a></code> for a
BDAT-type wrapper and function to keep back-compatability. To get coarse wood
volume over bark (&gt;=7m diameter over bark) BDAT-type functions are
<code><a href="#topic+BDATVOLDHMR">BDATVOLDHMR</a></code> and <code><a href="#topic+BDATVOLDHOR">BDATVOLDHOR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- data.frame(spp = 1, D1 = 30, H = 25)
sort &lt;- list(Az = 7, Sokz = 1)
getAssortment(tree, sort, value = "Vol")
getAssortment(tree, sort, value = "Skl")
sort &lt;- list(Az = 7, Sokz = 1, fixN = 1, fixZ = 10, fixL = 5,
             fixA = 10, fixR = 1)
getAssortment(tree, sort, value = "Vol")
getAssortment(tree, sort, value = "Skl")
getAssortment(tree, sort, value = "Fix")
getAssortment(tree, sort, value = "LDSort")
getAssortment(tree, sort, value = "merge")

## prepare data for repeated sorting
## (get rid of preparating data handling)
n &lt;- 3
tree &lt;- data.frame(
  spp = rep(1, n), D1 = seq(20, 50, length.out = n),
  H = seq(15, 40, length.out = n)
)
sort &lt;- list(lX = 0, Sokz = 1, Az = 7,
             fixN = 2, fixZ = 10, fixL = 5,
             fixA = 10, fixR = 1)
tree &lt;- buildTree(tree = tree, check = "assortment", vars = sort)
getAssortment(tree, value = "Vol")
getAssortment(tree, value = "Skl")
getAssortment(tree, value = "Fix")
getAssortment(tree, value = "LDSort")
getAssortment(tree, value = "merge")

## to get bare BDAT-Output, use value='raw'
# very long list, each element keeping all trees
getAssortment(tree, value="raw")
# bonus: it returns the calling parameters as well

</code></pre>

<hr>
<h2 id='getBark'>Get double bark thickness of tree at given height Hx</h2><span id='topic+getBark'></span><span id='topic+getBark.data.frame'></span><span id='topic+getBark.list'></span><span id='topic+getBark.datBDAT'></span>

<h3>Description</h3>

<p>this function calculates double bark thickness in given height
for a given tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBark(tree, ...)

## S3 method for class 'data.frame'
getBark(tree, Hx = NULL, mapping = NULL, ...)

## S3 method for class 'list'
getBark(tree, Hx = NULL, mapping = NULL, ...)

## S3 method for class 'datBDAT'
getBark(tree, Hx = NULL, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBark_+3A_tree">tree</code></td>
<td>
<p>either a data.frame or a list containing the variables needed to
decribe a tree, i.e. spp, D1, H, and optionally H1, D2, H2. Additionally,
parameter <code>Hx</code> might be directly given via <code>tree</code>. See
<code><a href="#topic+buildTree">buildTree</a></code> for more details and parameter <code>mapping</code> for
mapping of variable names.</p>
</td></tr>
<tr><td><code id="getBark_+3A_...">...</code></td>
<td>
<p>passing arguments to methods.</p>
</td></tr>
<tr><td><code id="getBark_+3A_hx">Hx</code></td>
<td>
<p>height in tree for which double bark thickness is required</p>
</td></tr>
<tr><td><code id="getBark_+3A_mapping">mapping</code></td>
<td>
<p>mapping of variable names in case a data.frame is given into
parameter <code>tree</code> between colnames(<code>tree</code>) and required parameter
names. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns double bark thickness in given height <code>Hx</code> in stem
taper (hence, it depends on the diameter in given height). This can be added
to an diameter under bark to get the diameter over bark.
Parameter <code>tree</code> is able to take either a data.frame with correct
variables names or arbitrary names if <code>mapping</code> is provided to map the
data.frame names to the required names by <code>c("df-colname" = "var-name")</code>
or to take a named list.
</p>


<h3>Value</h3>

<p>vector of double bark thickness given height <code>Hx</code> inside stem taper
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getBark(data.frame)</code>: transforming <code>data.frame</code> before calling
<code>getBark</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getBark(list)</code>: transforming <code>list</code> before calling
<code>getBark</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getBark(datBDAT)</code>: class method for class <code>datBDAT</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- data.frame(spp = c(1, 1), D1 = c(30, 25), H = c(25, 25), Hx = c(1.3, 22.248))
getBark(tree)
tree &lt;- data.frame(BDATCode = c(1, 1), dbh = c(30, 25), h = c(25, 25), Hx = c(1.3, 22.248))
getBark(tree, mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H"))
tree &lt;- data.frame(BDATCode = c(1, 1), dbh = c(30, 25), h = c(25, 25))
Hx &lt;- list(Hx = c(1.3, 22.248))
getBark(tree = tree, Hx = Hx, mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H"))
</code></pre>

<hr>
<h2 id='getBiomass'>Get total aboveground biomass of tree</h2><span id='topic+getBiomass'></span><span id='topic+getBiomass.data.frame'></span><span id='topic+getBiomass.list'></span><span id='topic+getBiomass.datBDAT'></span>

<h3>Description</h3>

<p>this function calculates total aboveground biomass
for a given tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBiomass(tree, ...)

## S3 method for class 'data.frame'
getBiomass(tree, mapping = NULL, ...)

## S3 method for class 'list'
getBiomass(tree, mapping = NULL, ...)

## S3 method for class 'datBDAT'
getBiomass(tree, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBiomass_+3A_tree">tree</code></td>
<td>
<p>either a data.frame or a list containing the variables needed to
decribe a tree, i.e. spp, D1, H, and optionally H1, D2, H2. See
<code><a href="#topic+buildTree">buildTree</a></code> for details and parameter <code>mapping</code> for
mapping of variable names</p>
</td></tr>
<tr><td><code id="getBiomass_+3A_...">...</code></td>
<td>
<p>passing arguments to methods.</p>
</td></tr>
<tr><td><code id="getBiomass_+3A_mapping">mapping</code></td>
<td>
<p>mapping of variable names in case a data.frame is given into
parameter <code>tree</code> between colnames(<code>tree</code>) and required parameter
names. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns total aboveground biomass according to the biomass
functions developed for the german NFI3 (BWI3) on the basis of a field survey
covering whole Germany from 2007 to 2010. Hence, the base data differs from
those used to fit the taper functions. Neverteless and although the original
fortran code does not provide an interface to pass H2 or negative D2 values
to the functions (they were fitted with abolute D03-values, i.e. diameter
in 30
for reasons of consistency.
</p>
<p>The functions themselves are fitted for four species (Norway spruce, Scots
pine, European beech and Oak spp.) directly, and for another fourteen species
by generating pseudo-observations and fitting the functions to these. See
the enclosed report for details.
</p>
<p>The biomass functions integrate four different ranges of validity: (i) tree
height below 1.3m, (ii) dbh below 10cm, (iii) dbh between 10cm and the
99th-quantile of the data and (iv) dbh above.
</p>


<h3>Value</h3>

<p>vector of total aboveground biomass
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getBiomass(data.frame)</code>: transforming <code>data.frame</code> before calling
<code>getBiomass</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getBiomass(list)</code>: transforming <code>list</code> before calling
<code>getBiomass</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getBiomass(datBDAT)</code>: class method for class <code>datBDAT</code>
</p>
</li></ul>


<h3>References</h3>

<p>Riedel, T. and G. Kaendler (2017). &quot;Nationale
Treibhausgasberichterstattung: Neue Funktionen zur Schätzung der
oberirdischen Biomasse am Einzelbaum.&quot; Forstarchiv 88(2): 31-38.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- data.frame(spp = c(1, 1), D1 = c(30, 25), H = c(25, 25))
getBiomass(tree)

tree &lt;- data.frame(BDATCode = c(1, 1), dbh = c(30, 25), h = c(25, 25))
getBiomass(tree, mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H"))

tree &lt;- data.frame(BDATCode = c(1, 1), dbh = c(30, 25), h = c(25, 25))
getBiomass(tree = tree, mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H"))

## this is standard usage of the fortran code
## now changing the taper form via second diameter D2
tree &lt;- data.frame(spp = 1, D1 = 30, D2 = c(26, 24), H = 25)
getBiomass(tree)

## the following usage of D2 and H2 w.r.t. the biomass functions are new
## and unique to R
## now changing the taper form via quantile of second diameter in H2
tree &lt;- data.frame(spp = 1, D1 = 30, H2 = c(25, 50, 75), H = 25)
getBiomass(tree)

## now changing the taper form via form quotient (i.e. negative D2)
fq &lt;- getForm(list(spp = 1, D1 = 30, H = 25), inv = 1:4)
tree &lt;- data.frame(spp = 1, D1 = 30, D2 = -fq, H = 25)
getBiomass(tree) # biomass of an average tree according to different inventories
</code></pre>

<hr>
<h2 id='getDiameter'>Get diameter in given height inside tree taper</h2><span id='topic+getDiameter'></span><span id='topic+getDiameter.data.frame'></span><span id='topic+getDiameter.list'></span><span id='topic+getDiameter.datBDAT'></span>

<h3>Description</h3>

<p>this function calculates the diameter inside or outside bark of
in given height for a given tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDiameter(tree, ...)

## S3 method for class 'data.frame'
getDiameter(tree, Hx = NULL, bark = TRUE, mapping = NULL, ...)

## S3 method for class 'list'
getDiameter(tree, Hx = NULL, bark = TRUE, mapping = NULL, ...)

## S3 method for class 'datBDAT'
getDiameter(tree, Hx = NULL, bark = TRUE, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDiameter_+3A_tree">tree</code></td>
<td>
<p>either a data.frame, a list or an object of class <code>datBDAT</code>
containing the variables needed to decribe a tree, i.e. spp, D1, H, and
optionally H1, D2, H2. See <code><a href="#topic+buildTree">buildTree</a></code> for details and parameter
<code>mapping</code> for mapping of variable names</p>
</td></tr>
<tr><td><code id="getDiameter_+3A_...">...</code></td>
<td>
<p>passing arguments to methods.</p>
</td></tr>
<tr><td><code id="getDiameter_+3A_hx">Hx</code></td>
<td>
<p>height in tree for which diameter over or under bark is required;
defaults to NULL</p>
</td></tr>
<tr><td><code id="getDiameter_+3A_bark">bark</code></td>
<td>
<p>logical, if TRUE returned diameter <code>Dx</code> is over bark,
if FALSE returned diameter is under bark. Coerced to logical by
<code><a href="base.html#topic+as.logical">as.logical</a>(bark[1])</code>.</p>
</td></tr>
<tr><td><code id="getDiameter_+3A_mapping">mapping</code></td>
<td>
<p>mapping of variable names in case a data.frame is given into
parameter <code>tree</code> between colnames(<code>tree</code>) and required parameter
names. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if tree does not includes variable Hx, a full outer join is
generated between both
</p>


<h3>Value</h3>

<p>a matrix with one row for each tree and one column for each <code>Hx</code>
given, holding the diameter over or under bark of provided height <code>Hx</code>
inside stem taper. The matrix is simplified by <code>[,,drop=TRUE]</code>,
especially if <code>Hx=NULL</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getDiameter(data.frame)</code>: transforming <code>data.frame</code> before calling
<code>getDiameter</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getDiameter(list)</code>: transforming <code>list</code> before calling
<code>getDiameter</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getDiameter(datBDAT)</code>: class method for class <code>datBDAT</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- data.frame(spp = c(1, 1), D1 = c(30, 30), H = c(25, 25), Hx = c(1.3, 22.248))
getDiameter(tree, bark = TRUE)
getDiameter(tree, bark = FALSE)

tree &lt;- data.frame(BDATCode = c(1, 1), dbh = c(30, 30), h = c(25, 25), Hx = c(1.3, 22.248))
getDiameter(tree, bark = TRUE, mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H"))

tree &lt;- data.frame(BDATCode = c(1, 1), dbh = c(30, 30), h = c(25, 25))
Hx &lt;- c(1.3, 22.248)
getDiameter(tree, Hx = Hx, bark = TRUE, mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H"))
</code></pre>

<hr>
<h2 id='getForm'>Get estimated mean of form factor q03</h2><span id='topic+getForm'></span><span id='topic+getForm.data.frame'></span><span id='topic+getForm.list'></span><span id='topic+getForm.datBDAT'></span>

<h3>Description</h3>

<p>this function returns for a given dbh-height-class and species
the estimated mean of the q03-distribution, which can be considered as a
form factor for different inventories (i.e. NFI 1, NSoG, IS08, NFI3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getForm(tree, ...)

## S3 method for class 'data.frame'
getForm(tree, inv = NULL, mapping = NULL, ...)

## S3 method for class 'list'
getForm(tree, inv = NULL, mapping = NULL, ...)

## S3 method for class 'datBDAT'
getForm(tree, inv = NULL, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getForm_+3A_tree">tree</code></td>
<td>
<p>either a data.frame or a list containing the variables needed to
decribe a tree, i.e. spp, D1, H, and optionally H1, D2, H2. See
<code><a href="#topic+buildTree">buildTree</a></code> for details and parameter <code>mapping</code> for
mapping of variable names</p>
</td></tr>
<tr><td><code id="getForm_+3A_...">...</code></td>
<td>
<p>passing arguments to methods.</p>
</td></tr>
<tr><td><code id="getForm_+3A_inv">inv</code></td>
<td>
<p>integer, indicator for which inventory the form factor should be
returned; defaults to 1 (0=volume tables of Grundner-Schwappach 1921,
1=NFI1, 2=NSoG, 3=IS08, 4=NFI3).
Any other value is silently set back to <code>inv=1</code>.</p>
</td></tr>
<tr><td><code id="getForm_+3A_mapping">mapping</code></td>
<td>
<p>mapping of variable names in case a data.frame is given into
parameter <code>tree</code> between colnames(<code>tree</code>) and required parameter
names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the estimated mean of the q03-distribution for a given
dbh-height-class and species. The q03-distribution is the ratio between the
diameter in 30% of tree height and 5% of tree height and describes the form
of the taper curve. This value can be returned for different inventories,
during which upper stem diameters have been sampled.
</p>
<p>Only spp, D1 and H are used to estimate mean q03, if provided and H1 equals
1.3m, otherwise dbh is estimated using BDAT functions (i.e.
getDiameter(tree, Hx=1.3)).
</p>


<h3>Value</h3>

<p>vector of form factor q03.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getForm(data.frame)</code>: transforming <code>data.frame</code> before calling
<code>getForm</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getForm(list)</code>: transforming <code>list</code> before calling
<code>getForm</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getForm(datBDAT)</code>: class method for class <code>datBDAT</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- data.frame(spp = c(1, 1), D1 = c(30, 25), H = c(25, 25))
tree &lt;- buildTree(tree, check = "form", vars = list(inv = 1))
str(tree)
getForm(tree) # default is 'inv=1'
getForm(tree, inv = 0) # taper form of BDAT from model fit
getForm(tree, inv = 1) # NFI 1 (without NSoG)
getForm(tree, inv = 2) # NSoG = New States of Germany
getForm(tree, inv = 3) # carbon inventory 2008
getForm(tree, inv = 4) # NFI 3 (reunificated Germany)
</code></pre>

<hr>
<h2 id='getHeight'>Get height of given diameter inside tree taper</h2><span id='topic+getHeight'></span><span id='topic+getHeight.data.frame'></span><span id='topic+getHeight.list'></span><span id='topic+getHeight.datBDAT'></span>

<h3>Description</h3>

<p>this function calculates the height of a given diameter inside
or outside bark for a given tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHeight(tree, ...)

## S3 method for class 'data.frame'
getHeight(tree, Dx = NULL, bark = TRUE, mapping = NULL, ...)

## S3 method for class 'list'
getHeight(tree, Dx = NULL, bark = TRUE, mapping = NULL, ...)

## S3 method for class 'datBDAT'
getHeight(tree, Dx = NULL, bark = TRUE, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getHeight_+3A_tree">tree</code></td>
<td>
<p>either a data.frame or a list containing the variables needed to
decribe a tree, i.e. spp, D1, H, and optionally H1, D2, H2. See
<code><a href="#topic+buildTree">buildTree</a></code> for details and parameter <code>mapping</code> for
mapping of variable names</p>
</td></tr>
<tr><td><code id="getHeight_+3A_...">...</code></td>
<td>
<p>passing arguments to methods.</p>
</td></tr>
<tr><td><code id="getHeight_+3A_dx">Dx</code></td>
<td>
<p>diameter of tree for which height is required; defaults to NULL</p>
</td></tr>
<tr><td><code id="getHeight_+3A_bark">bark</code></td>
<td>
<p>logical, if TRUE given diameter <code>Dx</code> is considered over
bark, if FALSE diameter is considered to be under bark. Coerced to logical by
<code><a href="base.html#topic+as.logical">as.logical</a>(bark[1])</code>.</p>
</td></tr>
<tr><td><code id="getHeight_+3A_mapping">mapping</code></td>
<td>
<p>mapping of variable names in case a data.frame is given into
parameter <code>tree</code> between colnames(<code>tree</code>) and required parameter
names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+buildTree">buildTree</a></code> for how to specify a tree object
</p>


<h3>Value</h3>

<p>a matrix with one row for each tree and one column for each <code>Dx</code>
given, holding the height of provided diameter <code>Dx</code> inside stem taper.
The matrix is simplified by <code>[,,drop=TRUE]</code>, especially if
<code>Dx=NULL</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getHeight(data.frame)</code>: transforming <code>data.frame</code> before calling
<code>getHeight</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getHeight(list)</code>: transforming <code>list</code> before calling
<code>getHeight</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getHeight(datBDAT)</code>: class method for class <code>datBDAT</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tree &lt;- data.frame(spp = c(1, 1), D1 = c(30, 25), H = c(25, 20), Dx = c(7, 7))
getHeight(tree, bark = TRUE)
getHeight(tree, bark = FALSE)

tree &lt;- data.frame(BDATCode = c(1, 1), dbh = c(30, 25), h = c(25, 20), Dx = c(7, 7))
getHeight(tree, bark = TRUE, mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H"))

tree &lt;- data.frame(BDATCode = c(1, 1), dbh = c(30, 25), h = c(25, 20))
Dx &lt;- c(7, 5)
getHeight(tree, Dx = Dx, bark = TRUE, mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H"))

tree &lt;- data.frame(spp = c(1, 1), D1 = c(30, 25), H = c(25, 20), Dx = c(7, 7))
getHeight(tree, Dx = c(1:5), bark = TRUE)
</code></pre>

<hr>
<h2 id='getSpeciesCode'>Get BDAT species code or transform it to a name.</h2><span id='topic+getSpeciesCode'></span>

<h3>Description</h3>

<p>Function to get BDAT species code, or transform it to a
german or english name, possibly an abbreviated version or even a scientific
name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSpeciesCode(inSp = NULL, outSp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSpeciesCode_+3A_insp">inSp</code></td>
<td>
<p>species information given, either numeric or character</p>
</td></tr>
<tr><td><code id="getSpeciesCode_+3A_outsp">outSp</code></td>
<td>
<p>character vector of names, for which information should be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function matches inSp to outSp. Depending on inSp, being either
a numeric vector of values between 1 and 36 or a character vector of species
names. Possible names are those which could be return values. One can get all
names and the respective species code by calling the function with inSP=NULL
and outSP=NULL (the default).
</p>
<p>English species names and codes are taken from
https://www.forestry.gov.uk/pdf/PF2011_Tree_Species.pdf/$FILE/PF2011_Tree_Species.pdf
while slightly adjusting the codes to be unique compared to the german codes
(e.g. European larch is now ELA instead of EL).
</p>
<p>Any given species code outside the interval [1, 36] is given the code 1
(i.e. Norway spruce), while throwing a warning. If any inSp - name is invalid,
i.e. not in species list, this throws an error.
</p>
<p>All elements of outSp, which are not colnames of the default returned
data.frame, are silently dropped.
</p>


<h3>Value</h3>

<p>vector or data.frame, depending on length of 'outSp'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getSpeciesCode(inSp = NULL, outSp = NULL) ## the default
getSpeciesCode() ## the same
getSpeciesCode(outSp = "scientific")
getSpeciesCode(inSp = c(1, 2)) ## giving codes
getSpeciesCode(inSp = c(1, 2, -1, 37)) ## values outside [1, 36] are given code 1
getSpeciesCode(inSp = c(1, 2), outSp = c("scientific")) ## output a vector
getSpeciesCode(inSp = c("Bu", "Fi")) ## asking for codes of abbreviated german names
getSpeciesCode(inSp = c("Bu", "Fi", "Bu")) ## order is preserved
getSpeciesCode(inSp = c("Buche", "Fichte")) ## asking for codes of german names
getSpeciesCode(inSp = c("BE", "NS")) ## ... abbreviated english names
getSpeciesCode(inSp = c("beech", "Norway spruce")) ## ... english names
getSpeciesCode(inSp = c("Fagus sylvatica", "Picea abies")) ### ... scientific names
</code></pre>

<hr>
<h2 id='getVolume'>Get segment volume for one or many trees</h2><span id='topic+getVolume'></span><span id='topic+getVolume.data.frame'></span><span id='topic+getVolume.list'></span><span id='topic+getVolume.datBDAT'></span>

<h3>Description</h3>

<p>Function to get segment volume over or under bark for a tree of
dimension D1, possible D2, and H. Volume is calculated for a given segment
defined by A and B, which might be specified as heights or diameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVolume(tree, ...)

## S3 method for class 'data.frame'
getVolume(tree, AB = NULL, iAB = "H", bark = TRUE, mapping = NULL, ...)

## S3 method for class 'list'
getVolume(tree, AB = NULL, iAB = "H", bark = TRUE, mapping = NULL, ...)

## S3 method for class 'datBDAT'
getVolume(tree, AB = NULL, iAB = "H", bark = TRUE, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getVolume_+3A_tree">tree</code></td>
<td>
<p>either a data.frame or a list containing the variables needed to
decribe a tree, i.e. spp, D1, H, and optionally H1, D2, H2. See
<code><a href="#topic+buildTree">buildTree</a></code> for details and parameter <code>mapping</code> for
mapping of variable names</p>
</td></tr>
<tr><td><code id="getVolume_+3A_...">...</code></td>
<td>
<p>passing arguments to methods.</p>
</td></tr>
<tr><td><code id="getVolume_+3A_ab">AB</code></td>
<td>
<p>list with heights or diameters A and B of section for which volume
over or under bark should be calculated. Additionally, add in <code>sl</code> for
the segment length over which the integral should be calculated. See details.</p>
</td></tr>
<tr><td><code id="getVolume_+3A_iab">iAB</code></td>
<td>
<p>character indicating how to interpret given A and B values. Either
&quot;H&quot; (the default), &quot;Dob&quot; (diameter over bark) or &quot;Dub&quot; (diameter under bark).
Could be of length one or two, depending on whether A and B are both height
or diameter variables or not. See examples.</p>
</td></tr>
<tr><td><code id="getVolume_+3A_bark">bark</code></td>
<td>
<p>boolean of length one indicator for whether required volume should
include bark volume or not. Defaults to TRUE. Coerced to logical by
<code><a href="base.html#topic+as.logical">as.logical</a>(bark[1])</code>.</p>
</td></tr>
<tr><td><code id="getVolume_+3A_mapping">mapping</code></td>
<td>
<p>mapping of variable names in case a data.frame is given into
parameter <code>tree</code> between colnames(<code>tree</code>) and required parameter
names. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>iAB</code> can be a vector of length two, indicating how to interpret
<code>A</code> and <code>B</code>. Hence, one can calculate volume between a given
height and a given diameter, either over or under bark. If of length one,
it is assumed the indicator applies to both A and B.
</p>
<p>Internally, provided diameters in <code>A</code> or <code>B</code> are tranformed to
heights by <code>BDATHXDX</code> if iAB=&quot;dob&quot; or by <code>BDATHXDXOR</code> if
iAB=&quot;dub&quot;.
</p>


<h3>Value</h3>

<p>vector of same length as tree, returning the required volume in
cubic meter.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>getVolume(data.frame)</code>: transforming <code>data.frame</code> before calling
<code>getVolume</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getVolume(list)</code>: transforming <code>data.frame</code> before calling
<code>getVolume</code> using <code>buildTree</code>
</p>
</li>
<li> <p><code>getVolume(datBDAT)</code>: class method for class <code>datBDAT</code>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+BDATVOLABMR">BDATVOLABMR</a></code> and <code><a href="#topic+BDATVOLABOR">BDATVOLABOR</a></code> for a
BDAT-type wrapper and function to keep back-compatability. To get total
coarse wood volume (&gt;=7m diameter over bark) BDAT-type functions are
<code><a href="#topic+BDATVOLDHMR">BDATVOLDHMR</a></code> and <code><a href="#topic+BDATVOLDHOR">BDATVOLDHOR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## default return with just one or several trees given is total coarse wood
## volume over bark, i.e. stock volume (in german: Vfm m.R.)
getVolume(list(spp = 1, D1 = 30, H = 25))

## first using a data.frame and height information
tree &lt;- data.frame(spp = 1, D1 = 30, H = 25, A = 0.1, B = 10)
getVolume(tree) # iAB = "H", bark = TRUE, mapping = NULL as default values
getVolume(tree, iAB = "H", bark = FALSE, mapping = NULL)

## now, use diameter information
tree &lt;- data.frame(spp = 1, D1 = 30, H = 25, A = 30, B = 7)
getVolume(tree, iAB = "Dob", bark = TRUE, mapping = NULL)

## now use both diameter and height information
tree &lt;- data.frame(spp = 1, D1 = 30, H = 25, A = 0, B = 7)
getVolume(tree, iAB = c("H", "Dob"), bark = TRUE, mapping = NULL)
## is equivalent to the original BDAT-function:
BDATVOLDHMR(1, 30, 0, 0, 0, H = 25)
## and
getVolume(tree, iAB = c("H", "Dob"), bark = FALSE, mapping = NULL)
## is equivalent to:
BDATVOLDHOR(1, 30, 0, 0, 0, H = 25)

## use a misnamed data.frame and mapping argument
tree &lt;- data.frame(BDATCode = 1, dbh = 30, h = 25, l = 30, u = 7)
getVolume(tree,
  iAB = "Dob", bark = TRUE,
  mapping = c("BDATCode" = "spp", "dbh" = "D1", "h" = "H", "l" = "A", "u" = "B")
)

## using a list to provide the data
tree &lt;- list(
  spp = c(1, 1), D1 = c(30, 25), H = c(25, 30), A = c(30, 25),
  B = c(7, 7)
)
getVolume(tree, iAB = "Dob") #' defaults: bark = TRUE, mapping = NULL
getVolume(tree, iAB = "Dob", bark = FALSE) #' defaults: mapping = NULL

## using a misnamed list and mapping argument
tree &lt;- list(
  BDATCode = c(1, 1), dbh = c(30, 25), H = c(25, 30),
  A = c(0.1, 0.1), B = c(1, 1)
)
getVolume(tree, mapping = c("BDATCode" = "spp", "dbh" = "D1"))

## using parameter AB to provide the segment data
## in this case a cross join between tree and AB is produced and evaluated
tree &lt;- list(BDATCode = c(1, 1), dbh = c(30, 25), H = c(25, 30))
AB &lt;- list(A = c(0.1, 1), B = c(1, 2))
getVolume(tree, AB, iAB = "H", bark = TRUE, mapping = c("BDATCode" = "spp", "dbh" = "D1"))

## effect of adjusting 'sl'
tree &lt;- list(spp = 1, D1 = 30, H = 25)
getVolume(tree = tree, AB = list(A = 0.1, B = 5.1, sl = 2)) # default
getVolume(tree = tree, AB = list(A = 0.1, B = 5.1, sl = 1))
getVolume(tree = tree, AB = list(A = 0.1, B = 5.1, sl = 0.1))
getVolume(tree = tree, AB = list(A = 0.1, B = 5.1, sl = 0.01))

## compare Smalian formula to mid-diameter volume for sl=5
R1 &lt;- getDiameter(tree, Hx = 1.3) / 100 / 2 # radius in m
R2 &lt;- getDiameter(tree, Hx = 6.3) / 100 / 2 # radius in m
h &lt;- 5
pi * ((R1 + R2) / 2)^2 * h # average of bottom and top diameter
(h * pi) / 3 * (R1^2 + R1 * R2 + R2^2) # truncated-cone volume
getVolume(tree, AB = list(A = 1.3, B = 6.3, sl = 5)) # mid-diameter volume
getVolume(tree, AB = list(A = 1.3, B = 6.3, sl = 0.01)) # physical volume

</code></pre>

<hr>
<h2 id='plot.datBDAT'>Plot taper curve of a tree</h2><span id='topic+plot.datBDAT'></span>

<h3>Description</h3>

<p>creating a plot of the taper curve of a tree, over or under bark
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'datBDAT'
plot(x, bark = NULL, col.bark = NULL, legend = FALSE, assort = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.datBDAT_+3A_x">x</code></td>
<td>
<p>an object of class 'datBDAT'</p>
</td></tr>
<tr><td><code id="plot.datBDAT_+3A_bark">bark</code></td>
<td>
<p>either NULL or logical; if TRUE taper curve over bark is plotted,
if FALSE taper curve under bark is plotted; if NULL, both are plotted</p>
</td></tr>
<tr><td><code id="plot.datBDAT_+3A_col.bark">col.bark</code></td>
<td>
<p>color to be used for plot of bark, if plot of taper curve
over and under bark is requested</p>
</td></tr>
<tr><td><code id="plot.datBDAT_+3A_legend">legend</code></td>
<td>
<p>logical, if legend should be added</p>
</td></tr>
<tr><td><code id="plot.datBDAT_+3A_assort">assort</code></td>
<td>
<p>assortments produced by <code>getAssortment(, value="merge")</code></p>
</td></tr>
<tr><td><code id="plot.datBDAT_+3A_...">...</code></td>
<td>
<p>further arguments for <code>plot</code> and <code>points</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates graphics of the taper curve of trees. Either over bark or
under bark, or both. Elements design can partly be chosen. If assortments are
given, these are added to the plot. Doing that, the assortment bottom and top
position is indicated by a vertical line and mid-diameter is shown as a point
with vertical dashed line. N.B. the mid-diameter shown is under bark and
rounded downwards for 0.5 cm if mid-diameter &lt; 20 and for 0.75 cm if bigger.
Assortment volume is calculated using this diameter according to the legal
rules for roundwood assortments (formerly german Forst-HKS and now RVR).
Additionally, assortment names are indicated.
One can provide assortment names in a column of <code>assort</code> named
'assortname', which will be used if available, otherwise the 'Sort'-column
will be used. See Examples.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plotting the taper curve of a tree
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 1))
t &lt;- data.frame(spp = 1, D1 = 40, H = 35)
tree &lt;- buildTree(tree = t)
plot(tree, type = "l", las = 1, legend = TRUE)
plot(tree, bark = TRUE, las = 1)
plot(tree, bark = FALSE, las = 1)
t &lt;- data.frame(spp = c(1, 1), D1 = c(40, 35), H = c(35, 30))
tree &lt;- buildTree(tree = t)
plot(tree, bark = FALSE, las = 1, legend = TRUE)
plot(tree, bark = TRUE, las = 1, legend = TRUE)

t &lt;- data.frame(spp = c(1, 8), D1 = 40, H = 35)
tree &lt;- buildTree(tree = t)
plot(tree, bark = NULL, las = 1, col.bark = "blue", legend = TRUE)
plot(tree[1, ], main = getSpeciesCode(tree[1, ]$spp, out = "long"))
plot(tree[2, ], main = getSpeciesCode(tree[2, ]$spp, out = "scientific"))
par(mfrow = c(2, 1))
plot(tree, bark = TRUE, las = 1)

## now add assortments into taper curve
par(mfrow = c(1, 1))
ass &lt;- getAssortment(tree, sort = list(lX = 1, fixN = 2, fixL = 4, fixA = 10))
plot(tree, assort = ass)
plot(tree, bark = FALSE, assort = ass)
plot(tree, bark = FALSE, assort = ass, legend = TRUE)
plot(tree[1, ], assort = ass[ass$tree == 1, ], main = "first tree in subset")
plot(tree[2, ], assort = ass[ass$tree == 2, ], main = "second tree in subset")

## adding own assortment labels using column 'assortname'
ass$assortname &lt;- ifelse(grepl("Fix", ass$Sort), paste0("Fix:", ass$length), ass$Sort)
plot(tree, assort = ass)
par(oldpar)
</code></pre>

<hr>
<h2 id='throw'>Throw a Condition</h2><span id='topic+throw'></span>

<h3>Description</h3>

<p>Throws a condition of class c(&quot;error&quot;, &quot;rBDAT&quot;, &quot;condition&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>throw(message_string, system_call = sys.call(-1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="throw_+3A_message_string">message_string</code></td>
<td>
<p>The message to be thrown.</p>
</td></tr>
<tr><td><code id="throw_+3A_system_call">system_call</code></td>
<td>
<p>The call to be thrown.</p>
</td></tr>
<tr><td><code id="throw_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to
<code><a href="base.html#topic+structure">base::structure</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We use this condition as an error dedicated to <span class="pkg"> rBDAT.</span>
</p>


<h3>Value</h3>

<p>The function does never return anything, it stops with a
condition of class c(&quot;error&quot;, &quot;rBDAT&quot;, &quot;condition&quot;).
</p>

<hr>
<h2 id='transformBDAT20'>transform BDAT20-matrix</h2><span id='topic+transformBDAT20'></span>

<h3>Description</h3>

<p>transforms an intermediate BDAT20-matrix into a data.frame,
names it appropriately and removes &lt;zero&gt;-entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformBDAT20(assort, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformBDAT20_+3A_assort">assort</code></td>
<td>
<p>a matrix, produced by calling Fortran-BDAT20-subroutine and
extracting one list element to a matrix</p>
</td></tr>
<tr><td><code id="transformBDAT20_+3A_value">value</code></td>
<td>
<p>character vector indicating return type: either &quot;Vol&quot;, &quot;Skl&quot;
or &quot;Fix&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fortran subroutine BDAT20 returns a list with many entries for each
tree; most relevant are 'Vol', 'FixLng' and maybe 'Skl'. These elements are
transformed into a matrix and properly whiped into shape.
</p>


<h3>Value</h3>

<p>a transformed BDAT20-result, usually a data.frame
</p>

<hr>
<h2 id='updateBdatNamespace'>replace NAMESPACE from 'rBDATPRO' to 'rBDAT'.</h2><span id='topic+updateBdatNamespace'></span>

<h3>Description</h3>

<p>function replaces calls to package 'rBDATPRO' by calls to
package 'rBDAT', simply by replacing the package name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateBdatNamespace(inpath = file.choose(), outpath = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateBdatNamespace_+3A_inpath">inpath</code></td>
<td>
<p>path of file to process</p>
</td></tr>
<tr><td><code id="updateBdatNamespace_+3A_outpath">outpath</code></td>
<td>
<p>either a file name or a directory, both or NULL, see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function merely exists to account for the renaming of the
package from <code>rBDATPRO</code> (which was internally used for some period of
time) to <code>rBDAT</code>. Its sole purpose is to update R-scripts which use
<code>rBDATPRO</code> and now should be updated to use <code>rBDAT</code>. Internally,
<code>gsub</code> is used.
</p>
<p><code>outpath</code> can be (i) a filename, then the newly generated file
is stored under that name in the <code>inpath</code> directory, (ii) a directory,
then the <code>inpath</code>-filename is used with prefixed <code>rbdat_</code>, (iii) a
complete path (directory name and file name), then this is used to store the
file, (iv) NULL, then the inpath is used with prefixed <code>rbdat_</code> to the
inpath filename.
</p>


<h3>Value</h3>

<p>a character holding path and filename of the updated file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p &lt;- tempdir()
f &lt;- "rbdatpro.r"
tx &lt;- c("require(rBDATPRO)", "library(rBDATPRO)",
        "rBDATPRO::getDiameter(list(spp=1, D1=30, H=27))")
pf &lt;- file.path(p, f)
writeLines(tx, con=pf)
file.exists(pf)
list.files(p)
# file.show(pf)

## define different output specs
outpath1 &lt;- file.path(tempdir(), "devel/rbdatScript.r")
outpath2 &lt;- p
outpath3 &lt;- "rbdatScript.r"

(updated_file &lt;- updateBdatNamespace(pf, outpath = NULL))
list.files(p)
# file.show(updated_file)

(updated_file &lt;- updateBdatNamespace(pf, outpath1))
list.files(file.path(p, "devel"))
# file.show(updated_file)

(updated_file &lt;- updateBdatNamespace(pf, outpath2))
list.files(p)
# file.show(updated_file)

(updated_file &lt;- updateBdatNamespace(pf, outpath3))
list.files(p)
# file.show(updated_file)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
