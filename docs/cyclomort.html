<!DOCTYPE html><html><head><title>Help for package cyclomort</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cyclomort}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cyclomort-package'><p>Cyclomort: periodic survival modeling</p></a></li>
<li><a href='#censor_cycloSurv'><p>Censor and Trim</p></a></li>
<li><a href='#create_cycloSurv'><p>Create a cycloSurv object</p></a></li>
<li><a href='#factorfit_cyclomort'><p>Factorial analysis of seasonal survival models</p></a></li>
<li><a href='#findDelta'><p>Converting between Rho to Delta</p></a></li>
<li><a href='#fit_cyclomort'><p>Estimate periodic hazard function.</p></a></li>
<li><a href='#guess_initial_parameters'><p>Produce initial parameter estimates based on mortality data</p></a></li>
<li><a href='#loglike'><p>Obtain log-likelihood value from a data set given a set of parameter values</p></a></li>
<li><a href='#loglike_optim'><p>Log-likelihood function</p></a></li>
<li><a href='#nwt_morts'><p>Mortality data for Northwest territory boreal woodland caribou.</p></a></li>
<li><a href='#plot.cmfactorfit'><p>Plot cmfactorfit objects</p></a></li>
<li><a href='#plot.cmfit'><p>Plot cmfit objects</p></a></li>
<li><a href='#predict.cmfit'><p>Prediction method for cyclomort fits</p></a></li>
<li><a href='#seasonalsex'><p>Simulated data of seasonal mortality data for two sex groups</p></a></li>
<li><a href='#select_seasons'><p>Select the number of  mortality seasons</p></a></li>
<li><a href='#simulate_cycloSurv'><p>Simulate periodic mortality process</p></a></li>
<li><a href='#summary.cmfactorfit'><p>Summary method for cyclomort factorial fit</p></a></li>
<li><a href='#summary.cmfit'><p>Provide a short summary of cmfit (parameter estimates for periodic mortality curves) objects</p></a></li>
<li><a href='#summary.cmfitlist'><p>Summary method for cmfitlist objects</p></a></li>
<li><a href='#timetoeventprediction'><p>Example fitted time to event prediction</p></a></li>
<li><a href='#wah_morts'><p>Mortality data for Western Arctic Herd Caribou</p></a></li>
<li><a href='#wc'><p>Wrapped Cauchy and Integrated Wrapped Cauchy functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Survival Modeling with a Periodic Hazard Function</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-07-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Modeling periodic mortality (or other time-to event) processes from right-censored data. Given observations of a process with a known period (e.g. 365 days, 24 hours), functions determine the number, intensity, timing, and duration of peaks of periods of elevated hazard within a period.  The underlying model is a mixed wrapped Cauchy function fitted using maximum likelihoods (details in Gurarie et al. (2020) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13305">doi:10.1111/2041-210X.13305</a>&gt;). The development of these tools was motivated by the strongly seasonal mortality patterns observed in many wild animal populations, such that the respective periods of higher mortality can be identified as "mortality seasons". </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>flexsurv, lubridate, magrittr, mvtnorm, plyr, scales, stats,
survival</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EliGurarie/cyclomort">https://github.com/EliGurarie/cyclomort</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EliGurarie/cyclomort/issues">https://github.com/EliGurarie/cyclomort/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-12 17:37:13 UTC; elie</td>
</tr>
<tr>
<td>Author:</td>
<td>Eliezer Gurarie [aut, cre],
  Thompson Peter [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eliezer Gurarie &lt;egurarie@umd.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-20 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cyclomort-package'>Cyclomort: periodic survival modeling</h2><span id='topic+cyclomort'></span><span id='topic+cyclomort-package'></span>

<h3>Description</h3>

<p>This package allows users to estimate parametric hazard functions 
with a known periodicity and one of more peak seasons of heightened mortality risk. 
It was motivated by the strongly seasonal mortality signal observed in many wild 
animal populations, but the model may be useful for any periodic time-to-event process.
</p>


<h3>Details</h3>

<p>The central estimation function <code><a href="#topic+fit_cyclomort">fit_cyclomort</a></code> produces estimates 
for timing, duration and intensity of mortality peaks from right-censored survival data. 
Other functions simulate survival data from periodic hazard functions 
(<code><a href="#topic+simulate_cycloSurv">simulate_cycloSurv</a></code>), perform model selection to identify the number of 
seasons (<code><a href="#topic+select_seasons">select_seasons</a></code>), perform simple hypothesis tests 
(<code><a href="#topic+factorfit_cyclomort">factorfit_cyclomort</a></code>), and various methods for visualizing and summarizing 
fits and model predictions.  Several data sets are also included. 
</p>
<p>Details of the underlying model, motivation, and examples of implementation on mortality 
data are in the Gurarie et al. (2020). An active development version is on GitHub at 
<a href="https://github.com/EliGurarie/cyclomort">https://github.com/EliGurarie/cyclomort</a>. The vignette provides several examples 
of the functionality of the package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eliezer Gurarie <a href="mailto:egurarie@umd.edu">egurarie@umd.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Thompson Peter
</p>
</li></ul>



<h3>References</h3>

<p>E. Gurarie, P. Thompson, A. Kelly, N. Larter, W. Fagan and K. Joly. 2020. 
For Everything There is a Season: Estimating periodic hazard functions with the cyclomort 
R package. <em>Methods in Ecology and Evolution</em>, 11(1):129-139. &lt;doi:10.1111/2041-210X.13305&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/EliGurarie/cyclomort">https://github.com/EliGurarie/cyclomort</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/EliGurarie/cyclomort/issues">https://github.com/EliGurarie/cyclomort/issues</a>
</p>
</li></ul>


<hr>
<h2 id='censor_cycloSurv'>Censor and Trim</h2><span id='topic+censor_cycloSurv'></span><span id='topic+trim_cycloSurv'></span>

<h3>Description</h3>

<p>Functions for right-censoring and left-trimming survival data. They are convenient
for comparing cyclomort fits before and after some cut-off time, as in the example
below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>censor_cycloSurv(x, censor.time)

trim_cycloSurv(x, trim.time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="censor_cycloSurv_+3A_x">x</code></td>
<td>
<p>cycloSurv object</p>
</td></tr>
<tr><td><code id="censor_cycloSurv_+3A_censor.time">censor.time</code></td>
<td>
<p>time of (right) censoring, or vector of times of censoring</p>
</td></tr>
<tr><td><code id="censor_cycloSurv_+3A_trim.time">trim.time</code></td>
<td>
<p>time of (left) trimming</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Censored Surv object
</p>
<p>Trimmed Surv object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load Western Arctic Herd data and convert to cycloSurv
data(wah_morts)
wah &lt;- with(wah_morts, create_cycloSurv(start = start, end = end, 
                                        event = fate == "dead", period = 365))

# censor and trim
cutoff = "2016-01-01"
wah_pre = censor_cycloSurv(wah, censor.time = cutoff)
wah_post = trim_cycloSurv(wah, trim.time = cutoff)

# combine into dataframe
par.init &lt;- par(no.readonly = TRUE)

par(mfrow = c(1,2))
plot(wah_pre[,1], 1:length(wah_pre), xlim = range(wah_pre[,1:2]), type= "n", main = "pre")
segments(wah_pre[,1], 1:length(wah_pre), wah_pre[,2], 1:length(wah_pre), col = wah_pre[,3]+1)
plot(wah_post[,1], 1:length(wah_post), xlim = range(wah_post[,1:2]), type= "n", main = "post")
segments(wah_post[,1], 1:length(wah_post), wah_post[,2], 1:length(wah_post), col = wah_pre[,3]+1)

# fit seasonal model before and after
wah_fit_pre &lt;- fit_cyclomort(wah_pre, n.seasons = 1)
wah_fit_post &lt;- fit_cyclomort(wah_post, n.seasons = 1)

# some evidence of a shift, though confidence intervals are wide
summary(wah_fit_pre)
summary(wah_fit_post)


par(mfrow = c(1,2))
plot(wah_fit_pre, plotCI = TRUE, breaks = 10); title("pre cut-off")
plot(wah_fit_post, plotCI = TRUE, breaks = 10); title("post cut-off")

par(par.init)
</code></pre>

<hr>
<h2 id='create_cycloSurv'>Create a cycloSurv object</h2><span id='topic+create_cycloSurv'></span>

<h3>Description</h3>

<p><code>cycloSurv</code> is a superclass of <code>Surv</code>, the standard data type for
survival analysis in R, with an additional period attribute necessary for 
estimating periodic hazard functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_cycloSurv(start, end, event, t0 = NULL, period, timeunits = "days")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_cycloSurv_+3A_start">start</code></td>
<td>
<p>a vector measuring time an individual enters a population
(can be POSIX, numeric, or Date)</p>
</td></tr>
<tr><td><code id="create_cycloSurv_+3A_end">end</code></td>
<td>
<p>a vector measuring time an individual leaves a population, e.g. via 
death (or other precipitation event of interest) or censoring. 
(as a POSIXct, numeric, or Date)</p>
</td></tr>
<tr><td><code id="create_cycloSurv_+3A_event">event</code></td>
<td>
<p>the status indicator, normally 0=alive/censored, 1=dead.</p>
</td></tr>
<tr><td><code id="create_cycloSurv_+3A_t0">t0</code></td>
<td>
<p>reference time for event times.  By default, <code>t0</code> is set to 
January 1 of the first year of observations if times are POSIXct. There are 
many reasons why a biological year may more conveniently start on a different 
day.  All else being equal, it can be useful to start a &quot;mortality year&quot; at a 
period of low mortality to better isolate the seasons of higher mortality.</p>
</td></tr>
<tr><td><code id="create_cycloSurv_+3A_period">period</code></td>
<td>
<p>length of one period in the input data</p>
</td></tr>
<tr><td><code id="create_cycloSurv_+3A_timeunits">timeunits</code></td>
<td>
<p>units that dates are inputted in if dates are being used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>cycloSurv</code> which is identical to and 
compatible with a '<code>Surv</code> object, with, however, an addition &quot;period&quot; 
attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>startTimes = as.Date(origin = "2010-01-01", 
                    c(0, 0, 0, 50, 0, 50, 100, 150, 0, 100)) #in days
endTimes = as.Date(origin = "2010-01-01", 
                  c(50, 50, 100, 150, 150, 200, 200, 250, 350, 500)) #in days
censored = c(1, 1, 0, 1, 1, 0, 1, 0, 0, 0)
period = 365
morts = create_cycloSurv(start = startTimes, end = endTimes, 
                       event = censored, period = period)
</code></pre>

<hr>
<h2 id='factorfit_cyclomort'>Factorial analysis of seasonal survival models</h2><span id='topic+factorfit_cyclomort'></span>

<h3>Description</h3>

<p>This function takes a <code>Y~X</code> style formula to compare null models of 
pooled data against separately fitted models against a given factor.  For now 
this works only for a single discrete factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorfit_cyclomort(f, data = NULL, n.seasons = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorfit_cyclomort_+3A_f">f</code></td>
<td>
<p>formula object used for identifying different classes</p>
</td></tr>
<tr><td><code id="factorfit_cyclomort_+3A_data">data</code></td>
<td>
<p>a data frame containing a cycloSurv object detailing mortalities 
for a set of observations and a factor identifying the value of a categorical 
variable for each observation</p>
</td></tr>
<tr><td><code id="factorfit_cyclomort_+3A_n.seasons">n.seasons</code></td>
<td>
<p>number of seasons to fit model to</p>
</td></tr>
<tr><td><code id="factorfit_cyclomort_+3A_...">...</code></td>
<td>
<p>additional arguments to fit_cyclomort call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table comparing outputs from null (factor has no effect on mortality 
and they are all in the same group) model to multi-factor model using AIC, 
log-likelihood and likelihood ratio test
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit factorial model
data(seasonalsex)
seasonalsex.factorfit &lt;- factorfit_cyclomort(event ~ sex, data = seasonalsex, n.seasons = 1)

# summary
summary(seasonalsex.factorfit, coefs = TRUE)
plot(seasonalsex.factorfit)
</code></pre>

<hr>
<h2 id='findDelta'>Converting between Rho to Delta</h2><span id='topic+findDelta'></span><span id='topic+findRho'></span><span id='topic+DeltaToRho'></span>

<h3>Description</h3>

<p>Functions for converting the concentration parameter rho to the season 
duration parameter delta and vice versa.  They are: <code>findDelta(rho)</code>.  
These are mainly internal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findDelta(rho)

findRho(delta)

DeltaToRho(delta, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findDelta_+3A_rho">rho</code></td>
<td>
<p>concentration parameter on interval [0, 1]</p>
</td></tr>
<tr><td><code id="findDelta_+3A_delta">delta</code></td>
<td>
<p>duration parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>duration parameter delta
</p>
<p>concentration parameter rho on interval [0, 1]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findDelta(rho = 0.9); findRho(0.0167)
findDelta(rho = 0.1); findRho(0.218)
 
# Plot the relationship
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))
rhos &lt;- seq(0, 1, length = 1e3)
plot(rhos, findDelta(rhos), ylab = "deltas", type = "l")
deltas &lt;- seq(0, .5, length = 1e3)
plot(deltas, findRho(deltas), ylab = "rhos", type = "l")
par(oldpar)
</code></pre>

<hr>
<h2 id='fit_cyclomort'>Estimate periodic hazard function.</h2><span id='topic+fit_cyclomort'></span>

<h3>Description</h3>

<p>This function takes time-to-event data formatted as a <code>cycloSurv</code> object 
and estimates an underlying hazard function for a given number of seasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_cyclomort(
  x,
  inits = NULL,
  n.seasons = 2,
  method = "L-BFGS-B",
  period = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_cyclomort_+3A_x">x</code></td>
<td>
<p>a cycloSurv object recording start and end times as well as status 
(dead/censored) and the length of one full period</p>
</td></tr>
<tr><td><code id="fit_cyclomort_+3A_inits">inits</code></td>
<td>
<p>set of initial guesses; a named vector or list with values for 
&quot;peak&quot; and &quot;duration&quot;. Leaving some or all of these parameters as NULL will 
trigger the automatic selection of an initial guess.</p>
</td></tr>
<tr><td><code id="fit_cyclomort_+3A_n.seasons">n.seasons</code></td>
<td>
<p>number of seasons to fit model to</p>
</td></tr>
<tr><td><code id="fit_cyclomort_+3A_method">method</code></td>
<td>
<p>method for optim call</p>
</td></tr>
<tr><td><code id="fit_cyclomort_+3A_period">period</code></td>
<td>
<p>expected periodicity of survival data. Can be passed in with 
cycloSurv input parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cmfit object containing parameter estimates for peaks, durations, 
and weights for each season
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data
T.morts1 &lt;- simulate_cycloSurv(1000, period = 365, 
                             meanhazard = 0.3 / 365, 
                             peaks = c(0.25 * 365, 0.75 * 365), 
                             durations = c(0.3 * 365, 0.1 * 365), 
                             weights = c(0.7,0.3), 
                             plotme = FALSE)

# Estimate simulated data
fits &lt;- fit_cyclomort(T.morts1, n.seasons = 2)
fits

# Plot results
plot(fits, nreps = 1000, monthlabs = TRUE)
# NB: `nreps` is for the bootstrap of the confidence interval 
# The default (5000) is slower but smoother

# Actual parameter values from simulated data
attributes(T.morts1)
</code></pre>

<hr>
<h2 id='guess_initial_parameters'>Produce initial parameter estimates based on mortality data</h2><span id='topic+guess_initial_parameters'></span>

<h3>Description</h3>

<p>Uses a basic flexsurvreg exponential mortality model to find the average 
hazard value, and fits a mixed normal distribution model to estimate the 
peaks, season durations, and weight distributions for the model. These 
estimates are not meant to be fully accurate but instead are meant to be 
good initial guesses for the fit_cyclomort function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_initial_parameters(x, n, null_fits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_initial_parameters_+3A_x">x</code></td>
<td>
<p><code>cycloSurv</code> object representing time of death or censorship</p>
</td></tr>
<tr><td><code id="guess_initial_parameters_+3A_n">n</code></td>
<td>
<p>expected number of mortality seasons within a period</p>
</td></tr>
<tr><td><code id="guess_initial_parameters_+3A_null_fits">null_fits</code></td>
<td>
<p>original estimate for mortality rate assuming constant 
hazard function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of guesses for parameter values, used to initialize 
the fitting process
</p>

<hr>
<h2 id='loglike'>Obtain log-likelihood value from a data set given a set of parameter values</h2><span id='topic+loglike'></span>

<h3>Description</h3>

<p>Obtain log-likelihood value from a data set given a set of parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglike(x, gammas, mus, rhos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglike_+3A_x">x</code></td>
<td>
<p>a cycloSurv object</p>
</td></tr>
<tr><td><code id="loglike_+3A_gammas">gammas</code></td>
<td>
<p>k-vector of average hazard values for each component</p>
</td></tr>
<tr><td><code id="loglike_+3A_mus">mus</code></td>
<td>
<p>k-vector of peaks</p>
</td></tr>
<tr><td><code id="loglike_+3A_rhos">rhos</code></td>
<td>
<p>k-vector of concentration parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the maximum likelihood value for this set of data
</p>

<hr>
<h2 id='loglike_optim'>Log-likelihood function</h2><span id='topic+loglike_optim'></span>

<h3>Description</h3>

<p>Internal function used for computing the log-likelihood of a parameterized 
model within <code><a href="#topic+fit_cyclomort">fit_cyclomort</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglike_optim(pars, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglike_optim_+3A_pars">pars</code></td>
<td>
<p>named vector including &quot;gamma&quot;, &quot;mu&quot;, and &quot;rho&quot; 
parameters for the appropriate number of seasons</p>
</td></tr>
<tr><td><code id="loglike_optim_+3A_x">x</code></td>
<td>
<p>times of death or censoring as Surv objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>likelihood value given named vector of parameters as well as set of 
observations
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_cyclomort">fit_cyclomort</a></code>
</p>

<hr>
<h2 id='nwt_morts'>Mortality data for Northwest territory boreal woodland caribou.</h2><span id='topic+nwt_morts'></span>

<h3>Description</h3>

<p>Mortality data for Northwest territory boreal woodland caribou, anonymized 
and randomized by year, thereby retaining the multi-seasonal signal without, 
with grateful acknowledgements to A. Kelly and N. Larter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nwt_morts)
</code></pre>


<h3>Format</h3>

<p>Data frame with 370 rows and the following columns:
</p>

<dl>
<dt>id</dt><dd><p>ID of animal</p>
</dd>
<dt>start</dt><dd><p>Date of beginning of collaring</p>
</dd>
<dt>end</dt><dd><p>Date of death or censoring</p>
</dd>
<dt>status</dt><dd><p>&quot;Mort&quot; or &quot;Cens&quot; (dead or censored)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Government of Northwest Territories, Canada
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nwt_morts)
require(ggplot2); require(magrittr); require(plyr)
ggplot(nwt_morts %&gt;% arrange(start) %&gt;% mutate(id = factor(id, levels = id)),
aes(x = start, y = id, col = status)) +
  geom_errorbarh(aes(xmin = start, xmax = end))

</code></pre>

<hr>
<h2 id='plot.cmfactorfit'>Plot cmfactorfit objects</h2><span id='topic+plot.cmfactorfit'></span>

<h3>Description</h3>

<p>Plot cmfactorfit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmfactorfit'
plot(x, fit = "both", colors = NULL, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cmfactorfit_+3A_x">x</code></td>
<td>
<p>a cmfactorfit object</p>
</td></tr>
<tr><td><code id="plot.cmfactorfit_+3A_fit">fit</code></td>
<td>
<p>a character (either &quot;null&quot;, &quot;alt&quot;, or &quot;both&quot;) that dictates what fits will be plotted</p>
</td></tr>
<tr><td><code id="plot.cmfactorfit_+3A_colors">colors</code></td>
<td>
<p>vector of colors (one component for each individual fit being plotted) for the hazard estimates</p>
</td></tr>
<tr><td><code id="plot.cmfactorfit_+3A_legend">legend</code></td>
<td>
<p>boolean parameter dictating whether or not a legend will be added to the plot</p>
</td></tr>
<tr><td><code id="plot.cmfactorfit_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to the <code><a href="#topic+plot.cmfit">plot.cmfit</a></code> function. Perhaps most usefully: lowering the default nreps (e.g. to 1000) makes plotting much faster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot comparing the hazard estimates from the null model with the individual estimates from each factor level
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit factorial model
data(seasonalsex)
seasonalsex.factorfit &lt;- factorfit_cyclomort(event ~ sex, data = seasonalsex, n.seasons = 1)

# summary
summary(seasonalsex.factorfit, coefs = TRUE)
plot(seasonalsex.factorfit)
</code></pre>

<hr>
<h2 id='plot.cmfit'>Plot cmfit objects</h2><span id='topic+plot.cmfit'></span>

<h3>Description</h3>

<p>Plot cmfit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmfit'
plot(
  x,
  plotCI = TRUE,
  CI.level = 0.95,
  histogram = TRUE,
  add = FALSE,
  monthlabs = FALSE,
  nreps = 5000,
  hazcolor = "black",
  alpha = 0.3,
  ymax = NULL,
  prediction = NULL,
  yaxt = par()$yaxt,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cmfit_+3A_x">x</code></td>
<td>
<p>a cmfit object</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_plotci">plotCI</code></td>
<td>
<p>whether confidence intervals should also be drawn.</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_ci.level">CI.level</code></td>
<td>
<p>confidence level (default 0.95) for CIs (if CI is TRUE)</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_histogram">histogram</code></td>
<td>
<p>boolean dictating whether a histogram of actual mortalities will be included in the plot</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_add">add</code></td>
<td>
<p>boolean dictating whether the plot will be added to an existing plot</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_monthlabs">monthlabs</code></td>
<td>
<p>whether or not to label the x-axis with months - suitable for (common) annual seasonal data.
If FALSE, labels are numeric within the period [0,1]</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_nreps">nreps</code></td>
<td>
<p>number of samples from parameter estimates for confidence intervals (see <code><a href="#topic+predict.cmfit">predict.cmfit</a></code>)</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_hazcolor">hazcolor</code></td>
<td>
<p>color of lines for hazard function and confidence intervals</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_alpha">alpha</code></td>
<td>
<p>transparency of confidence interval polygon</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_ymax">ymax</code></td>
<td>
<p>maximum value for the y-axis - can be useful for scaling purposes</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_prediction">prediction</code></td>
<td>
<p>an optional <code><a href="#topic+predict.cmfit">predict.cmfit</a></code> object- otherwise the function will estimate this every 
time which can be a bit slow.</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_yaxt">yaxt</code></td>
<td>
<p>location for y-axis label</p>
</td></tr>
<tr><td><code id="plot.cmfit_+3A_...">...</code></td>
<td>
<p>additional parameters to <code><a href="graphics.html#topic+hist">hist</a></code> (e.g., number of breaks)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot comparing the estimated mortality curve (based on parameter estimates)
and the actual results (as a histogram).
</p>


<h3>See Also</h3>

<p>predict.cmfit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data
T.morts1 &lt;- simulate_cycloSurv(1000, period = 365, 
                             meanhazard = 0.3 / 365, 
                             peaks = c(0.25 * 365, 0.75 * 365), 
                             durations = c(0.3 * 365, 0.1 * 365), 
                             weights = c(0.7,0.3), 
                             plotme = FALSE)

# Estimate simulated data
fits &lt;- fit_cyclomort(T.morts1, n.seasons = 2)
fits

# Plot results
plot(fits, nreps = 1000, monthlabs = TRUE)
# NB: `nreps` is for the bootstrap of the confidence interval 
# The default (5000) is slower but smoother

# Actual parameter values from simulated data
attributes(T.morts1)
</code></pre>

<hr>
<h2 id='predict.cmfit'>Prediction method for cyclomort fits</h2><span id='topic+predict.cmfit'></span>

<h3>Description</h3>

<p>Obtain predictions and confidence intervals for the hazard function or the 
time to event from a fitted cyclomort object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmfit'
predict(
  object,
  ...,
  t = seq(0, object$period, length = 500),
  type = "hazard",
  CI = FALSE,
  CI.level = 0.95,
  nreps = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cmfit_+3A_object">object</code></td>
<td>
<p>a cmfit object</p>
</td></tr>
<tr><td><code id="predict.cmfit_+3A_...">...</code></td>
<td>
<p>(not implemented)</p>
</td></tr>
<tr><td><code id="predict.cmfit_+3A_t">t</code></td>
<td>
<p>times for prediction.  By default, covers 100 observations over a 
single period.</p>
</td></tr>
<tr><td><code id="predict.cmfit_+3A_type">type</code></td>
<td>
<p>either <code>hazard</code> or <code>timetoevent</code> - dictates what 
exactly will be predicted</p>
</td></tr>
<tr><td><code id="predict.cmfit_+3A_ci">CI</code></td>
<td>
<p>a boolean dictating whether or not to compute confidence intervals</p>
</td></tr>
<tr><td><code id="predict.cmfit_+3A_ci.level">CI.level</code></td>
<td>
<p>confidence level (default 0.95) for CIs (if CI is TRUE)</p>
</td></tr>
<tr><td><code id="predict.cmfit_+3A_nreps">nreps</code></td>
<td>
<p>number of samples drawn to generate confidence intervals.  The 
default 10^3 is generally sufficient, and very fast for the hazard function, 
but possibly prohibitively slow for the time-to-event functionality.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence intervals are produced by sampling from the multivariate 
normal distribution of the MLE parameter estimates accounting for the 
covariance in the estimates by using the Hessian of the MLE.
</p>


<h3>Value</h3>

<p>a list of vectors containing predictions for each value in <code>t</code>, 
as well as (optional) confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate two-peak mortality process
sim.morts &lt;- simulate_cycloSurv(300, period = 1, peaks = c(0.3, 0.8), 
                      durations = c(0.15, 0.20), weights = c(3, 2)/5, 
                      meanhazard = 1, plotme = FALSE, max.periods = 6)
sim.morts &lt;- simulate_cycloSurv(300, period = 365, peaks = c(0.3, 0.8)*365, 
                                durations = c(0.15, 0.20)*365, weights = c(3, 2)/5, 
                                meanhazard = 1/365, plotme = FALSE, max.periods = 6)

# estimate parameters
sim.morts.fit &lt;- fit_cyclomort(sim.morts, n.seasons = 2)

# compute predictions for one moment in time (with 95% confidence interval)
predict(sim.morts.fit, CI = TRUE, type = "hazard")

# compute predictions for a range of times
predict(sim.morts.fit, t = 1:365, CI = FALSE, type = "hazard")

# these predictions are used (internally) in the plot.cmfit method:


plot(sim.morts.fit, CI.level = 0.95, months = FALSE, histogram = FALSE, monthlabs = TRUE)
plot(sim.morts.fit, CI.level = 0.8, months = FALSE, histogram = FALSE, add = TRUE)
plot(sim.morts.fit, CI.level = 0.5, months = FALSE, histogram = FALSE, add = TRUE)


# predict time to event given a start at times (this is a very slow calculation!)


timetoeventprediction &lt;- predict(sim.morts.fit, t = seq(1,365,3), type = "timetoevent",
                       CI = TRUE, nreps = 1e2)


# the following object contains a prediction
data(timetoeventprediction)

with(timetoeventprediction, {
  plot(t, fit, type = "l", lwd = 2,  main = "expected time to event", 
       ylim = c(100,365), ylab = "days")
  lines(t, CI[1,], lty = 3)
  lines(t, CI[2,], lty = 3)
})
</code></pre>

<hr>
<h2 id='seasonalsex'>Simulated data of seasonal mortality data for two sex groups</h2><span id='topic+seasonalsex'></span>

<h3>Description</h3>

<p>See examples below for the process of simulating and visualizing these data 
using <code><a href="#topic+simulate_cycloSurv">simulate_cycloSurv</a></code>, and an example of analyzing these 
data with <code><a href="#topic+factorfit_cyclomort">factorfit_cyclomort</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seasonalsex)
</code></pre>


<h3>Format</h3>

<p>Simulated data of single-season mortalities for two sex groups:
</p>

<dl>
<dt>sex</dt><dd><p>female (F) or male (M)</p>
</dd>
<dt>event</dt><dd><p><code>cycloSurv</code> object of (censored) survival data</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># useful packages
require(ggplot2); require(magrittr); require(plyr)

# Example of simulating multi-factor data:
## Not run:** 
n &lt;- 100
T.male = simulate_cycloSurv(n, period = 1, meanhazard = 0.3, peaks = .25, durations = .3)
T.female = simulate_cycloSurv(n, period = 1, meanhazard = 0.3, peaks = .75, durations = .3)
T.joint &lt;- with(rbind(T.male, T.female) %&gt;% data.frame,
          create_cycloSurv(start = start, end = stop, 
                           event = status, period = 1))
seasonalsex &lt;- data.frame( sex = rep(c("M","F"), each = n), T = T.joint)
## End(**Not run**)

# load and visualize simulated sex-specific survival data
data("seasonalsex")

seasonsex.df &lt;- cbind(seasonalsex, as.matrix(seasonalsex$event) %&gt;% as.data.frame) %&gt;%
  arrange(sex,stop) %&gt;% mutate(id = 1:length(start) %&gt;% factor, 
                               status = c("Dead", "Censored")[2-status])

require(ggplot2)
ggplot(seasonsex.df, aes(x = start, y = id, col = status)) + 
  geom_errorbarh(aes(xmin = start, xmax = stop)) + 
  facet_wrap(.~sex, scales = "free_y", ncol = 1) + 
  ggtitle("Simulated sex-specific mortality data")

seasonsex.df$time.trunc &lt;- with(seasonsex.df, stop - floor(stop))
with(seasonsex.df, {
  hist(time.trunc[sex == "M"], col = rgb(0,0,1,.3), breaks = seq(0,1,.1), 
       bor = NA, freq = FALSE, xlab = "Time (within period)", 
       main = "Male vs. Female (simulated) mortalities")  
  hist(time.trunc[sex == "F"], col = rgb(1,0,0,.3), breaks = seq(0,1,.1), 
       bor = NA, add = TRUE, freq = FALSE)  
  lines(density(time.trunc[sex == "M"], from = 0, to = 1), col = "darkblue", lwd = 2)
  lines(density(time.trunc[sex == "F"], from = 0, to = 1), col = "darkred", lwd = 2)
  legend("topleft", fill = c("blue", "red"), legend = c("M","F"), title = "Sex")
})

# test differences

sex.fit &lt;- factorfit_cyclomort(event ~ sex, data = seasonalsex, n.seasons = 1)
summary(sex.fit)

plot(sex.fit, ymax = 1.3)

</code></pre>

<hr>
<h2 id='select_seasons'>Select the number of  mortality seasons</h2><span id='topic+select_seasons'></span>

<h3>Description</h3>

<p>Compute a delta AIC table (and, optionally, likelihood ratio tests) for a sequence of models with a different number of seasons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_seasons(x, max.season = 4, lrt = FALSE, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_seasons_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+create_cycloSurv">create_cycloSurv</a></code> object</p>
</td></tr>
<tr><td><code id="select_seasons_+3A_max.season">max.season</code></td>
<td>
<p>maximum number of seasons to fit</p>
</td></tr>
<tr><td><code id="select_seasons_+3A_lrt">lrt</code></td>
<td>
<p>whether or not to perform and return the complete results of nested likelihood ratio tests</p>
</td></tr>
<tr><td><code id="select_seasons_+3A_print">print</code></td>
<td>
<p>boolean parameter; if TRUE the function prints the table out as a side effect of creating the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing (1) a list of all the fitted objects, and (2) an AIC (and, optionally, LRT) summary table.  Also prints both tables by default.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T.morts1 &lt;- simulate_cycloSurv(1000, period = 1, 
                             meanhazard = 0.3, 
                             peaks = c(0.25, 0.75), 
                             durations = c(0.2, 0.1), 
                             weights = c(0.3, 0.7), 
                             plotme = FALSE)


model_selection = select_seasons(T.morts1, max.season = 4)
summary(model_selection$fits)

</code></pre>

<hr>
<h2 id='simulate_cycloSurv'>Simulate periodic mortality process</h2><span id='topic+simulate_cycloSurv'></span>

<h3>Description</h3>

<p>Simulate periodic mortality process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_cycloSurv(
  n,
  period = 1,
  meanhazard = 0.5,
  peaks = c(0.25, 0.75),
  durations = c(0.2, 0.1),
  weights = c(0.5, 0.5),
  censoring = "random",
  censor.times = max.periods * period/2,
  max.periods = 10,
  n.times = 1000,
  plotme = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_cycloSurv_+3A_n">n</code></td>
<td>
<p>number of simulated mortality/censoring events</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_period">period</code></td>
<td>
<p>length of one mortality cycle</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_meanhazard">meanhazard</code></td>
<td>
<p>average hazard value</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_peaks">peaks</code></td>
<td>
<p>k-vector of peaks</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_durations">durations</code></td>
<td>
<p>k-vector of season length parameters, based on concentration parameter from wrapped Cauchy distribution</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_weights">weights</code></td>
<td>
<p>k-vector of weights ((k-1)-vector is also accepted)</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_censoring">censoring</code></td>
<td>
<p>the type of censoring in the simulated data. Either &quot;none&quot; (all data is uncensored), &quot;fixed&quot; (all data is censored at a specified time), or &quot;random&quot; (data is randomly censored throughout).</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_censor.times">censor.times</code></td>
<td>
<p>numeric or vector listing times for censoring (only applicable if censoring == &quot;fixed&quot;).</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_max.periods">max.periods</code></td>
<td>
<p>maximum number of cycles</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_n.times">n.times</code></td>
<td>
<p>number of x-values for plots (a higher value results in more precision for curves)</p>
</td></tr>
<tr><td><code id="simulate_cycloSurv_+3A_plotme">plotme</code></td>
<td>
<p>if TRUE, produces a set of plots for the simulation to display its accuracy</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>cycloSurv</code> object (a type of Surv object; see <code><a href="survival.html#topic+Surv">Surv</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par.init &lt;- par(no.readonly = TRUE)
par(oma = c(2,0,2,0))
T.morts1 &lt;- simulate_cycloSurv(1000, period = 1, 
                             meanhazard = 0.3, 
                             peaks = c(0.25, 0.75), 
                             durations = c(0.2, 0.1), 
                             weights = c(0.3, 0.7), 
                             plotme = TRUE)

with(attributes(T.morts1),
     title(paste0("mean hazard: ", meanhazard, "; peaks: ",
                  paste(peaks, collapse = ",")), outer = TRUE))

par(oma = c(2,0,2,0))
T.morts2 &lt;- simulate_cycloSurv(300, period = 365, 
                             meanhazard = 0.5/365, 
                             peaks = c(100, 250), 
                             durations = c(20, 40), 
                             weights = c(0.4, 0.6), 
                             plotme = TRUE,
                             max.periods = 5)

with(attributes(T.morts2),
     title(paste0("mean hazard: ", round(meanhazard, 3), "; peaks: ",
                  paste(peaks, collapse = ",")), outer = TRUE))



par(mfrow = c(1,1))
require(magrittr)
h &lt;- with(as.matrix(T.morts1) %&gt;% data.frame %&gt;% subset(status == 1),
    hist(stop - floor(stop), breaks = 20, col = "grey", bor = "darkgrey"))

with(attributes(T.morts1), curve(mwc(x, mus = peaks, 
                                     rhos = findRho(durations), gammas = weights, 
                                     tau = period)* mean(h$counts), add = TRUE))
par(par.init)
</code></pre>

<hr>
<h2 id='summary.cmfactorfit'>Summary method for cyclomort factorial fit</h2><span id='topic+summary.cmfactorfit'></span>

<h3>Description</h3>

<p>Summary method for cyclomort factorial fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmfactorfit'
summary(object, ..., coefs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cmfactorfit_+3A_object">object</code></td>
<td>
<p>a <code>cmfactorfit</code> object - the output of <code><a href="#topic+factorfit_cyclomort">factorfit_cyclomort</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cmfactorfit_+3A_...">...</code></td>
<td>
<p>(not implemented)</p>
</td></tr>
<tr><td><code id="summary.cmfactorfit_+3A_coefs">coefs</code></td>
<td>
<p>whether or not to report the individual summaries of each model component along with the statistical test results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table comparing log-likelihood and AIC between null and multi-factor model, and a p-value from likelihood ratio test, optionally combined with the individual model summaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit factorial model
data(seasonalsex)
seasonalsex.factorfit &lt;- factorfit_cyclomort(event ~ sex, data = seasonalsex, n.seasons = 1)

# summary
summary(seasonalsex.factorfit, coefs = TRUE)
plot(seasonalsex.factorfit)
</code></pre>

<hr>
<h2 id='summary.cmfit'>Provide a short summary of cmfit (parameter estimates for periodic mortality curves) objects</h2><span id='topic+summary.cmfit'></span>

<h3>Description</h3>

<p>Provide a short summary of cmfit (parameter estimates for periodic mortality curves) objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmfit'
summary(object, date = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cmfit_+3A_object">object</code></td>
<td>
<p>a cmfit object</p>
</td></tr>
<tr><td><code id="summary.cmfit_+3A_date">date</code></td>
<td>
<p>logical dictating whether peaks of high mortality are expressed as Dates</p>
</td></tr>
<tr><td><code id="summary.cmfit_+3A_...">...</code></td>
<td>
<p>(not implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing a short summary of the estimates for each parameter along with confidence intervals and AIC
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data
T.morts1 &lt;- simulate_cycloSurv(1000, period = 365, 
                             meanhazard = 0.3 / 365, 
                             peaks = c(0.25 * 365, 0.75 * 365), 
                             durations = c(0.3 * 365, 0.1 * 365), 
                             weights = c(0.7,0.3), 
                             plotme = FALSE)

# Estimate simulated data
fits &lt;- fit_cyclomort(T.morts1, n.seasons = 2)
fits

# Plot results
plot(fits, nreps = 1000, monthlabs = TRUE)
# NB: `nreps` is for the bootstrap of the confidence interval 
# The default (5000) is slower but smoother

# Actual parameter values from simulated data
attributes(T.morts1)
</code></pre>

<hr>
<h2 id='summary.cmfitlist'>Summary method for cmfitlist objects</h2><span id='topic+summary.cmfitlist'></span>

<h3>Description</h3>

<p>Summary method for cmfitlist objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmfitlist'
summary(object, ..., coefs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cmfitlist_+3A_object">object</code></td>
<td>
<p>a <code>cmfitlist</code> object - output of <code><a href="#topic+select_seasons">select_seasons</a></code></p>
</td></tr>
<tr><td><code id="summary.cmfitlist_+3A_...">...</code></td>
<td>
<p>(currently not implemented)</p>
</td></tr>
<tr><td><code id="summary.cmfitlist_+3A_coefs">coefs</code></td>
<td>
<p>whether or not to return model coefficients along with statistic test table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame describing the AIC, log-likelihood, number of parameters and parameter estimates for each model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T.morts1 &lt;- simulate_cycloSurv(1000, period = 1, 
                             meanhazard = 0.3, 
                             peaks = c(0.25, 0.75), 
                             durations = c(0.2, 0.1), 
                             weights = c(0.3, 0.7), 
                             plotme = FALSE)


model_selection = select_seasons(T.morts1, max.season = 4)
summary(model_selection$fits)

</code></pre>

<hr>
<h2 id='timetoeventprediction'>Example fitted time to event prediction</h2><span id='topic+timetoeventprediction'></span>

<h3>Description</h3>

<p>Example fitted time to event prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(timetoeventprediction)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Code that generates this object - following example in vignette
set.seed(10)
T.morts.sim &lt;- simulate_cycloSurv(300, period = 365, meanhazard = 1/365, 
peaks = c(100, 250), durations = c(25, 40), weights = c(0.4, 0.6), plotme = FALSE)
T.morts.fit &lt;- fit_cyclomort(T.morts.sim, n.seasons = 2)
timetoeventprediction &lt;- predict(T.morts.fit, t = 1:365, 
                                 type = "timetoevent", CI = TRUE, nreps = 100)

data(timetoeventprediction)
with(timetoeventprediction, {
plot(t, fit, type = "l", ylab = "Time to event", ylim = range(CI), lwd = 2)
lines(t, CI[1,])
lines(t, CI[2,])})
</code></pre>

<hr>
<h2 id='wah_morts'>Mortality data for Western Arctic Herd Caribou</h2><span id='topic+wah_morts'></span>

<h3>Description</h3>

<p>Anonymized mortality data on Western Arctic Herd caribou collected by the 
U.S. National Park Service, Alaska, with grateful acknowledgments to K. Joly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wah_morts)
</code></pre>


<h3>Format</h3>

<p>Data frame with 171 rows and the following columns:
</p>

<dl>
<dt>id</dt><dd><p>ID of animal</p>
</dd>
<dt>start</dt><dd><p>Date of beginning of collaring</p>
</dd>
<dt>end</dt><dd><p>Date of death or censoring</p>
</dd>
<dt>fate</dt><dd><p>One of &quot;dead&quot;, or &quot;censored&quot;</p>
</dd>
</dl>



<h3>Source</h3>

<p>U.S. National Park Service, Alaska
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wah_morts)
require(ggplot2); require(magrittr); require(plyr)
ggplot(wah_morts %&gt;% arrange(start),
aes(x = start, y = id, col = fate)) + 
  geom_errorbarh(aes(xmin = start, xmax = end))

</code></pre>

<hr>
<h2 id='wc'>Wrapped Cauchy and Integrated Wrapped Cauchy functions</h2><span id='topic+wc'></span><span id='topic+iwc'></span><span id='topic+mwc'></span><span id='topic+imwc'></span>

<h3>Description</h3>

<p>Fundamental periodic hazard function, mixed hazard function, and their (analytical) integrals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wc(t, mu, rho, tau)

iwc(t, mu, rho, tau)

mwc(t, mus, rhos, gammas, tau)

imwc(t, mus, rhos, gammas, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wc_+3A_t">t</code></td>
<td>
<p>time (numeric, can be vectorized)</p>
</td></tr>
<tr><td><code id="wc_+3A_mu">mu</code></td>
<td>
<p>mean peak</p>
</td></tr>
<tr><td><code id="wc_+3A_rho">rho</code></td>
<td>
<p>concentration parameter (0 &lt;= rho &lt;= 1)</p>
</td></tr>
<tr><td><code id="wc_+3A_tau">tau</code></td>
<td>
<p>period</p>
</td></tr>
<tr><td><code id="wc_+3A_mus">mus</code></td>
<td>
<p>k-vector of mean peaks (assuming k seasons)</p>
</td></tr>
<tr><td><code id="wc_+3A_rhos">rhos</code></td>
<td>
<p>k-vector of concentration parameters</p>
</td></tr>
<tr><td><code id="wc_+3A_gammas">gammas</code></td>
<td>
<p>k-vector of average hazard values for each component</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are mainly internal. <code>wc</code> and  <code>iwc</code> are both parameterized in terms of 
peak mean  <code class="reqn">\mu</code>, concentration parameter  <code class="reqn">\rho</code>, and period <code class="reqn">\tau</code> and are &quot;unweighted&quot;, i.e. 
</p>
<p style="text-align: center;"><code class="reqn">\int_0^\tau f(t) dt = \tau</code>
</p>

<p>The mixture model versions, <code>mwc</code> and <code>imwc</code>, are correspondingly parameterized in terms of 
vectors <code>mus</code>, <code>rhos</code>, and also <code>gammas</code> which correspond to the mean hazard contribution 
of each peak, such that 
</p>
<p style="text-align: center;"><code class="reqn">\int_0^\tau f(t) dt = k\gamma\tau</code>
</p>



<h3>Value</h3>

<p>numeric value (or vector of values of same length as <code>t</code>) of the respective function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# wrapped Cauchy functions
curve(wc(x, mu = 100, rho = .7, tau = 365), xlim = c(0,365), n = 1e4, 
      ylab = "hazard", xlab = "time")
curve(wc(x, mu = 100, rho = .5, tau = 365), add = TRUE, col = 2)
curve(wc(x, mu = 100, rho = .3, tau = 365), add = TRUE, col = 3)

# mixed wrapped Cauchy functions
curve(mwc(x, mus = c(0.125, 0.5), rhos = c(0.7, 0.5), 
          gammas = c(2, 1), tau = 1), xlim = c(0,1), ylab = "hazard", xlab = "time")
curve(mwc(x, mus = c(0.25, 0.75), rhos = c(0.3, 0.8), 
          gammas = c(0.6, 0.4), tau = 1), add = TRUE, col = 2)
curve(mwc(x, mus = c(0.25, 0.5, 0.75), rhos = c(0.6, 0.5, 0.4), 
          gammas = c(0.5, 0.2, 0.3), tau = 1), add = TRUE, col = 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
