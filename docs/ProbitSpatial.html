<!DOCTYPE html><html lang="en"><head><title>Help for package ProbitSpatial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ProbitSpatial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ProbitSpatial-package'><p>Probit with Spatial Dependence, SAR, SEM, and SARAR Models.</p></a></li>
<li><a href='#+24+2CProbitSpatial-method'><p>Extract from ProbitSpatial class.</p></a></li>
<li><a href='#coef.ProbitSpatial'><p>Estimated coefficients of a spatial probit model.</p></a></li>
<li><a href='#conditional_SAR_UC'><p>Conditional SAR UC.</p></a></li>
<li><a href='#conditional_SAR_UP'><p>Conditional SAR UP.</p></a></li>
<li><a href='#conditional_SARAR_UC'><p>Conditional SARAR UC.</p></a></li>
<li><a href='#conditional_SARAR_UP'><p>Conditional SARAR UP.</p></a></li>
<li><a href='#conditional_SEM_UC'><p>Conditional SEM UC.</p></a></li>
<li><a href='#conditional_SEM_UP'><p>Conditional SEM UP.</p></a></li>
<li><a href='#effects_ProbitSpatial'><p>Effects of a spatial probit model.</p></a></li>
<li><a href='#fitted.ProbitSpatial'><p>Extract spatial probit model fitted values.</p></a></li>
<li><a href='#generate_W'><p>Generate a random spatial weight matrix.</p></a></li>
<li><a href='#Katrina'><p>New Orleans business recovery in the aftermath of Hurricane Katrina.</p></a></li>
<li><a href='#names.ProbitSpatial'><p>Extract names of ProbitSpatial class.</p></a></li>
<li><a href='#predict.ProbitSpatial'><p>Spatial probit model predictions.</p></a></li>
<li><a href='#ProbitSpatial-class'><p>Class of Spatial Probit Model.</p></a></li>
<li><a href='#ProbitSpatialFit'><p>Fit a spatial probit model.</p></a></li>
<li><a href='#residuals.ProbitSpatial'><p>Extract spatial probit model residuals.</p></a></li>
<li><a href='#sim_binomial_probit'><p>Simulate the dependent variable of a SAR/SEM/SARAR model.</p></a></li>
<li><a href='#summary.ProbitSpatial'><p>Spatial probit model summaries.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Probit with Spatial Dependence, SAR, SEM and SARAR Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davide Martinetti &lt;davide.martinetti@inrae.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast estimation of binomial spatial probit regression models with spatial autocorrelation for big datasets.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv, RANN, Rcpp (&ge; 1.0.4.6), methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-28 15:02:14 UTC; dmartinetti</td>
</tr>
<tr>
<td>Author:</td>
<td>Davide Martinetti <a href="https://orcid.org/0000-0003-2047-1793"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ghislain Geniaux [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-30 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ProbitSpatial-package'>Probit with Spatial Dependence, SAR, SEM, and SARAR Models.</h2><span id='topic+ProbitSpatial'></span><span id='topic+ProbitSpatial-package'></span>

<h3>Description</h3>

<p><code>ProbitSpatial</code> package allows to fit spatial autoregressive (SAR) and 
spatial error (SEM) probit models. It also provides functions to simulated 
spatial binary data, an empirical data set and different methods for the 
diagnostic of the estimated model.
</p>


<h3>Details</h3>

<p>The main function of this package is <code>ProbitSpatialFit</code>. It allows to 
fit both SAR and SEM models for big datasets in a reasonable time. The 
function is based on the maximisation of the approximate likelihood 
function. The approximation is inspired by the Mendell and Elston algorithm 
for computing multivariate normal probabilities and take advantage of the 
sparsity of the spatial weight matrix. Two methods are available for the 
estimation of the model parameter: the first one is known as conditional 
method (see Case (1992)) and performs relatively well in terms of accuracy 
of the estimated parameters and is very rapid. The second method, that 
minimises the full-log-likelihood, is slower but it should be more accurate. 
Monte Carlo experiments on simulated data reported in Martinetti and Geniaux 
(2017) showed that the full-log-likelihood approach is not always 
overperforming the conditional method in terms of accuracy. At the present 
stage, our suggestion is to use the conditional method for a first 
estimation and only attempt the full-likelihood approach in a second moment, 
when the dataset size is not bigger than a few thousands. 
</p>
<p>Another feature of the <code>ProbitSpatialFit</code> function is the possibility 
to fit the model using the precision matrix instead of the 
variance-covariance matrix, since it is usually sparser and hence allows 
faster computations (see LeSage and Pace (2009)).
</p>
<p>The output of <code>ProbitSpatialFit</code> function is an object of class 
<code>ProbitSpatial</code>, for which the methods  
<code>residuals</code>, <code>fitted</code>, <code>effects</code>, <code>predict</code> and 
<code>coef</code> are available.
</p>
<p>The package also contains the function <code>sim_binomial_probit</code> that 
allows to simulate data samples of both SAR and SEM models. It can be used 
to replicate the Monte Carlo experiments reported in Martinetti and Geniaux 
(2017) as well as the experiment of Calabrese and Elkink (2014). 
An empirical data set <code><a href="#topic+Katrina">Katrina</a></code> on the reopening decisions of 
firms in the aftermath of the Katrina Hurricane in New Orleans is also 
available (LeSage et al.(2011)).
</p>
<p>Other packages in CRAN repository on the same subject are 
<code>McSpatial</code> (McMillen (2013)) and 
<code>spatialprobit</code> (Wilhelm and Godinho de Matos 
(2013)).
</p>
<p>The core functions of the present package have been coded using the 
<code>Rcpp</code> and <code>RcppEigen</code> libraries (Bates and Eddelbuettel (2013)), 
that allow direct interchange of rich R objects between R and C++.
</p>


<h3>Author(s)</h3>

<p>Davide Martinetti <a href="mailto:davide.martinetti@inra.fr">davide.martinetti@inra.fr</a> and 
Ghislain Geniaux  <a href="mailto:ghislain.geniaux@inra.fr">ghislain.geniaux@inra.fr</a>
</p>


<h3>References</h3>


<dl>
<dt>Bates and Eddelbuettel (2013)</dt><dd><p>D. Bates and D. Eddelbuettel. Fast and 
elegant numerical linear algebra using the RcppEigen package. <em>Journal 
of Statistical Software</em> 52, 1&ndash;24, 2013.</p>
</dd>
<dt>Case (1992)</dt><dd><p>A. C. Case. Neighborhood Influence and Technological 
Change. <em>Regional Science and Urban Economics</em> 22, 491&ndash;508, 1992.</p>
</dd>
<dt>Calabrese and Elkink (2014)</dt><dd><p>R. Calabrese and J.A. Elkink. Estimators 
of binary spatial autoregressive models: a Monte Carlo study. <em>Journal 
of Regional Science</em> 54, 664&ndash;687, 2014.</p>
</dd>
<dt>LeSage and Pace (2009)</dt><dd><p>J. LeSage and R.K. Pace. <em>Introduction to 
Spatial Econometrics</em>, CRC Press, chapter 10.1.6, 2009.</p>
</dd>
<dt>LeSage et al. (2011)</dt><dd><p>P. LeSage, R. K. Pace, N. Lam, R. Campanella and 
X. Liu. New Orleans business recovery in the aftermath of Hurricane 
Katrina. <em>Journal of the Royal Statistical Society A</em> 174, 1007&ndash;1027, 
2011.</p>
</dd>
<dt>Martinetti and Geniaux (2017)</dt><dd><p>D. Martinetti and G. Geniaux. 
Approximate likelihood estimation of spatial probit models. <em>Regional 
Science and Urban Economics</em> 64, 30-45, 2017.</p>
</dd>
<dt>McMillen (2013)</dt><dd><p>D. McMillen. McSpatial: Nonparametric spatial data 
analysis. R package version 2.0, 2013.</p>
</dd>
<dt>Mendell and Elston (1974)</dt><dd><p>N. Mendell and R. Elston. Multifactorial 
qualitative traits: genetic analysis and prediction of recurrence risks. 
<em>Biometrics</em> 30, 41&ndash;57, 1974.</p>
</dd>
<dt>Wilhelm and Godinho de Matos (2013)</dt><dd><p>S. Wilhelm and M. Godinho de 
Matos. Estimating Spatial Probit Models in R. <em>The R Journal</em> 5, 
130&ndash;143, 2013.</p>
</dd>
</dl>


<hr>
<h2 id='+24+2CProbitSpatial-method'>Extract from ProbitSpatial class.</h2><span id='topic++24+2CProbitSpatial-method'></span>

<h3>Description</h3>

<p>extract a slot from <code>ProbitSpatial</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ProbitSpatial'
x$name
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B24+2B2CProbitSpatial-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>ProbitSpatial</code>.</p>
</td></tr>
<tr><td><code id="+2B24+2B2CProbitSpatial-method_+3A_name">name</code></td>
<td>
<p>of the slot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The content of the slot.
</p>

<hr>
<h2 id='coef.ProbitSpatial'>Estimated coefficients of a spatial probit model.</h2><span id='topic+coef.ProbitSpatial'></span>

<h3>Description</h3>

<p>Returns the coefficients estimated by a <code>ProbitSpatial</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ProbitSpatial'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.ProbitSpatial_+3A_object">object</code></td>
<td>
<p>an object of class <code>ProbitSpatial</code>.</p>
</td></tr>
<tr><td><code id="coef.ProbitSpatial_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns the value of the estimated parameters.
</p>

<hr>
<h2 id='conditional_SAR_UC'>Conditional SAR UC.</h2><span id='topic+conditional_SAR_UC'></span>

<h3>Description</h3>

<p>Performs conditional estimation of SAR model with variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_SAR_UC(myenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_SAR_UC_+3A_myenv">myenv</code></td>
<td>
<p>an <code>environment</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We discourage the direct use of this function.
</p>


<h3>Value</h3>

<p>the log-likelihood and the estimated parameters.
</p>

<hr>
<h2 id='conditional_SAR_UP'>Conditional SAR UP.</h2><span id='topic+conditional_SAR_UP'></span>

<h3>Description</h3>

<p>Performs conditional estimation of SAR model with precision matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_SAR_UP(myenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_SAR_UP_+3A_myenv">myenv</code></td>
<td>
<p>an <code>environment</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We discourage the direct use of this function.
</p>


<h3>Value</h3>

<p>the log-likelihood and the estimated parameters.
</p>

<hr>
<h2 id='conditional_SARAR_UC'>Conditional SARAR UC.</h2><span id='topic+conditional_SARAR_UC'></span>

<h3>Description</h3>

<p>Performs conditional estimation of SARAR model with variance-covariance 
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_SARAR_UC(myenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_SARAR_UC_+3A_myenv">myenv</code></td>
<td>
<p>an <code>environment</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We discourage the direct use of this function.
</p>


<h3>Value</h3>

<p>the log-likelihood and the estimated parameters.
</p>

<hr>
<h2 id='conditional_SARAR_UP'>Conditional SARAR UP.</h2><span id='topic+conditional_SARAR_UP'></span>

<h3>Description</h3>

<p>Performs conditional estimation of SARAR model with precision matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_SARAR_UP(myenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_SARAR_UP_+3A_myenv">myenv</code></td>
<td>
<p>an <code>environment</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We discourage the direct use of this function.
</p>


<h3>Value</h3>

<p>the log-likelihood and the estimated parameters.
</p>

<hr>
<h2 id='conditional_SEM_UC'>Conditional SEM UC.</h2><span id='topic+conditional_SEM_UC'></span>

<h3>Description</h3>

<p>Performs conditional estimation of SEM model with variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_SEM_UC(myenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_SEM_UC_+3A_myenv">myenv</code></td>
<td>
<p>an <code>environment</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We discourage the direct use of this function.
</p>


<h3>Value</h3>

<p>the log-likelihood and the estimated parameters.
</p>

<hr>
<h2 id='conditional_SEM_UP'>Conditional SEM UP.</h2><span id='topic+conditional_SEM_UP'></span>

<h3>Description</h3>

<p>Performs conditional estimation of SEM model with precision matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_SEM_UP(myenv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_SEM_UP_+3A_myenv">myenv</code></td>
<td>
<p>an <code>environment</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We discourage the direct use of this function.
</p>


<h3>Value</h3>

<p>the log-likelihood and the estimated parameters.
</p>

<hr>
<h2 id='effects_ProbitSpatial'>Effects of a spatial probit model.</h2><span id='topic+effects_ProbitSpatial'></span>

<h3>Description</h3>

<p>Returns the marginal effects of a <code>ProbitSpatial</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effects_ProbitSpatial(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="effects_ProbitSpatial_+3A_object">object</code></td>
<td>
<p>an object of class <code>ProbitSpatial</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>effects</code> function has different outputs according to the 
DGP of the <code>ProbitSpatial</code> model:
</p>

<dl>
<dt><code>"SAR"</code></dt><dd><p>The marginal effects of a spatial autoregressive 
model are more complicated than usual measurements of impacts for non 
spatial models. Here we follow LeSage and Pace and propose the following 
summaries for impact measures:</p>
</dd>
</dl>

<dl>
<dt>Average direct effects:</dt><dd><p>the average over all the observations of 
the effects of the change of an explanatory variable of a single 
observation on the choice probability of that same observation.</p>
</dd>
<dt>Average indirect effects:</dt><dd><p>the average over all the observations 
of the effect of a change on a explanatory variable on the choice 
probability of the neighbouring observations.</p>
</dd>
<dt>Average total effects:</dt><dd><p>the sum of direct and indirect impacts.</p>
</dd>
</dl>

<dl>
<dt><code>"SEM"</code></dt><dd><p>marginal effects should be interpreted as if it were a 
standard probit model.</p>
</dd>
</dl>



<h3>Value</h3>

<p>It returns the marginal effects of the estimated 
<code>ProbitSpatial</code> model.
</p>


<h3>References</h3>

<p>J. LeSage and R.K. Pace. <em>Introduction to Spatial Econometrics</em>, CRC 
Press, chapter 10.1.6, 2009.
</p>

<hr>
<h2 id='fitted.ProbitSpatial'>Extract spatial probit model fitted values.</h2><span id='topic+fitted.ProbitSpatial'></span>

<h3>Description</h3>

<p>Extract the fitted values of a <code>ProbitSpatial</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ProbitSpatial'
fitted(object, type = c("link", "response", "binary"), cut = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.ProbitSpatial_+3A_object">object</code></td>
<td>
<p>an object of class <code>ProbitSpatial</code>.</p>
</td></tr>
<tr><td><code id="fitted.ProbitSpatial_+3A_type">type</code></td>
<td>
<p>the type of output: 
</p>

<dl>
<dt><code>"link"</code></dt><dd><p>the value of the latent variable. Default.</p>
</dd>
<dt><code>"response"</code></dt><dd><p>probability.</p>
</dd>
<dt><code>"binary"</code></dt><dd><p>binary 0/1 output.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitted.ProbitSpatial_+3A_cut">cut</code></td>
<td>
<p>the threshold probability for the <code>"binary"</code> type. 
Default is 0.5.</p>
</td></tr>
<tr><td><code id="fitted.ProbitSpatial_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the vector of fitted values of the <code>ProbitSpatial</code> model
</p>

<hr>
<h2 id='generate_W'>Generate a random spatial weight matrix.</h2><span id='topic+generate_W'></span>

<h3>Description</h3>

<p>Generate a spatial weight matrix of given size and number of nearest 
neighbors from randomly-located observations on the unit square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_W(n, nneigh, seed=123)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_W_+3A_n">n</code></td>
<td>
<p>the size of the matrix.</p>
</td></tr>
<tr><td><code id="generate_W_+3A_nneigh">nneigh</code></td>
<td>
<p>the number of nearest neighbors.</p>
</td></tr>
<tr><td><code id="generate_W_+3A_seed">seed</code></td>
<td>
<p>an integer to set the seed for the random generated
locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output matrix has zero diagonal and it is row-standardised. 
The <code>n</code> observations are allocated randomly in the unit square.  
For each observation, the <code>nneigh</code> closests observations w.r.t. the 	
Euclidean distance are assigned with a weight equal to 1/<code>nneigh</code>.
</p>


<h3>Value</h3>

<p>a matrix of class <code>dgCMatrix</code> (sparse matrix).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_binomial_probit">sim_binomial_probit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>W &lt;- generate_W(100,4,seed=12)
</code></pre>

<hr>
<h2 id='Katrina'>New Orleans business recovery in the aftermath of Hurricane Katrina.</h2><span id='topic+Katrina'></span>

<h3>Description</h3>

<p>This dataset has been used in the LeSage et al. (2011) paper entitled &quot;New 
Orleans business recovery in the aftermath of Hurricane Katrina&quot; to study 
the decisions of shop owners to reopen business after Hurricane Katrina. The 
dataset contains 673 observations on 3 streets in New Orleans and can be 
used to estimate the spatial probit models and to replicate the findings in 
the paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Katrina)
</code></pre>


<h3>Format</h3>

<p>Katrina is a data frame with 673 observations on the following 15 
variables:
</p>

<dl>
<dt><code>code</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>long</code></dt><dd><p>longitude coordinate of store</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude coordinate of store</p>
</dd>
<dt><code>street1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>medinc</code></dt><dd><p>median income</p>
</dd>
<dt><code>perinc</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>elevation</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>flood</code></dt><dd><p>flood depth (measured in feet)</p>
</dd>
<dt><code>owntype</code></dt><dd><p>type of store ownership: &quot;sole proprietorship&quot; vs. 
&quot;local chain&quot; vs. &quot;national chain&quot;</p>
</dd>
<dt><code>sesstatus</code></dt><dd><p>socio-economic status of clientele (1-5): 1-2 = low #'		status customers, 3 = middle, 4-5 = high status customers</p>
</dd>
<dt><code>sizeemp</code></dt><dd><p>&quot;small size&quot; vs. &quot;medium size&quot; vs. &quot;large size&quot; 
firms</p>
</dd>
<dt><code>openstatus1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>openstatus2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>days</code></dt><dd><p>days to reopen business</p>
</dd>
<dt><code>street</code></dt><dd><p>1=Magazine Street, 2=Carrollton Avenue, 3=St. Claude 
Avenue</p>
</dd>
</dl>

<p>Katrina is a data frame with 673 observations on the following 13 variables.
</p>

<dl>
<dt><code>long</code></dt><dd><p>longitude coordinate of store</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude coordinate of store</p>
</dd>
<dt><code>flood_depth</code></dt><dd><p>flood depth (measured in feet)</p>
</dd>
<dt><code>log_medinc</code></dt><dd><p>log median income</p>
</dd>
<dt><code>small_size</code></dt><dd><p>binary variable for &quot;small size&quot; firms</p>
</dd>
<dt><code>large_size</code></dt><dd><p>binary variable for &quot;large size&quot; firms</p>
</dd>
<dt><code>low_status_customers</code></dt><dd><p>binary variable for low socio-economic 
status of clientele</p>
</dd>
<dt><code>high_status_customers</code></dt><dd><p>binary variable for high socio-economic 
status of clientele</p>
</dd>
<dt><code>owntype_sole_proprietor</code></dt><dd><p>a binary variable indicating &quot;sole 
proprietor&quot; ownership type</p>
</dd>
<dt><code>owntype_national_chain</code></dt><dd><p>a binary variable indicating 
&quot;national_chain&quot; ownership type</p>
</dd>
<dt><code>y1</code></dt><dd><p>reopening status in the very short period 0-3 months; 
1=reopened, 0=not reopened</p>
</dd>
<dt><code>y2</code></dt><dd><p>reopening status in the period 0-6 months; 1=reopened, 
0=not reopened</p>
</dd>
<dt><code>y3</code></dt><dd><p>reopening status in the period 0-12 months; 1=reopened, 
0=not reopened</p>
</dd>
</dl>



<h3>Details</h3>

<p>The Katrina dataset contains the data found on the website before some 
of the variables are recoded. For example, the socio-economic status of 
clientele is coded as 1-5 in the raw data, but only 3 levels will be used in 
estimation: 1-2 = low status customers, 3 = middle, 4-5 = high status 
customers. Hence, with &quot;middle&quot; as the reference category, Katrina contains 
2 dummy variables for low status customers and high status customers.
</p>
<p>The dataset Katrina is the result of these recoding operations and can be 
directly used for model estimation.
</p>


<h3>Note</h3>

<p>When definining the reopening status variables y1 (0-3 months), y2 (0-6 
months), and y3 (0-12 months) from the days variable, the Matlab code 
ignores the seven cases where days=90. To be consistent with the number of 
cases in the paper, we define y1,y2,y3 in the same way: y1=sum(days &lt; 90), 
y2=sum(days &lt; 180 &amp; days != 90), y3=sum(days &lt; 365 &amp; days != 90). So this is 
not a bug, its a feature.
</p>


<h3>Source</h3>

<p>The raw data was obtained from the Royal Statistical Society dataset website and brought 
to RData format by Wilhelm and Godinho de Matos (2013).
</p>


<h3>References</h3>


<dl>
<dt>LeSage et al. (2011)</dt><dd><p>P. LeSage, R. K. Pace, N. Lam, R. Campanella and 
X. Liu. New Orleans business recovery in the aftermath of Hurricane 
Katrina. <em>Journal of the Royal Statistical Society A</em>, 174, 1007&ndash;1027, 
2011.</p>
</dd>
<dt>Wilhelm and Godinho de Matos (2013)</dt><dd><p>S. Wilhelm and M. Godinho de 
Matos. Estimating Spatial Probit Models in R. <em>The R Journal</em> 5, 
130&ndash;143, 2013.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(Katrina)
	attach(Katrina)
	table(y1) # 300 of the 673 firms reopened during 0-3 months horizon, p.1016
	table(y2) # 425 of the 673 firms reopened during 0-6 months horizon, p.1016
	table(y3) # 478 of the 673 firms reopened during 0-12 months horizon, p.1016
	detach(Katrina)


	# replicate LeSage et al. (2011), Table 3, p.1017
	require(spdep)
 
	# (a) 0-3 months time horizon
	# LeSage et al. (2011) use k=11 nearest neighbors in this case
	nb &lt;- knn2nb(knearneigh(cbind(Katrina$lat, Katrina$long), k=11))
	listw &lt;- nb2listw(nb, style="W")
	W1 &lt;- as(as_dgRMatrix_listw(listw), "CsparseMatrix")

	fit1_cond &lt;- ProbitSpatialFit(y1 ~ flood_depth + log_medinc + small_size + 
		large_size +low_status_customers +  high_status_customers + 
		owntype_sole_proprietor + owntype_national_chain, 
		W=W1, data=Katrina, DGP='SAR', method="conditional", varcov="varcov")
	summary(fit1_cond)

	fit1_FL &lt;- ProbitSpatialFit(y1 ~ flood_depth + log_medinc + small_size + 
		large_size +low_status_customers +  high_status_customers + 
		owntype_sole_proprietor + owntype_national_chain, 
		W=W1, data=Katrina, DGP='SAR', method="full-lik", varcov="varcov")
	summary(fit1_FL)

	fit1_cond_10nn &lt;- ProbitSpatialFit(y1 ~ flood_depth+ log_medinc+ small_size+
		large_size +low_status_customers +  high_status_customers + 
		owntype_sole_proprietor + owntype_national_chain, 
		W=W1, data=Katrina, DGP='SAR', method="conditional", varcov="varcov",
		control=list(iW_CL=10))
	summary(fit1_cond_10nn)

# (b) 0-6 months time horizon
# LeSage et al. (2011) use k=15 nearest neighbors
nb &lt;- knn2nb(knearneigh(cbind(Katrina$lat, Katrina$long), k=15))
listw &lt;- nb2listw(nb, style="W")
W2 &lt;- as(as_dgRMatrix_listw(listw), "CsparseMatrix")

fit2_cond &lt;- ProbitSpatialFit(y2 ~ flood_depth + log_medinc + small_size + 
	large_size + low_status_customers + high_status_customers + 
	owntype_sole_proprietor + owntype_national_chain, 
	W=W2, data=Katrina, DGP="SAR", method="full-lik", varcov="varcov")
summary(fit2_cond)  

fit2_FL &lt;- ProbitSpatialFit(y2 ~ flood_depth + log_medinc + small_size + 
	large_size + low_status_customers + high_status_customers + 
	owntype_sole_proprietor + owntype_national_chain, 
	W=W2, data=Katrina, DGP="SAR", method="full-lik", varcov="varcov")
summary(fit2_FL)  

# (c) 0-12 months time horizon
# LeSage et al. (2011) use k=15 nearest neighbors as in 0-6 months
W3 &lt;- W2
fit3_cond &lt;- ProbitSpatialFit(y3 ~ flood_depth + log_medinc + small_size + 	
	large_size + low_status_customers + high_status_customers + 
	owntype_sole_proprietor + owntype_national_chain, 
	W=W3, data=Katrina, DGP="SAR", method="conditional", varcov="varcov")
summary(fit3_cond)

fit3_FL &lt;- ProbitSpatialFit(y3 ~ flood_depth + log_medinc + small_size + 
	large_size + low_status_customers + high_status_customers + 
	owntype_sole_proprietor + owntype_national_chain, 
	W=W3, data=Katrina, DGP="SAR", method="full-lik", varcov="varcov")
summary(fit3_FL)

# replicate LeSage et al. (2011), Table 4, p.1018
# SAR probit model effects estimates for the 0-3-month time horizon
effects(fit1_cond)  

# replicate LeSage et al. (2011), Table 5, p.1019
# SAR probit model effects estimates for the 0-6-month time horizon
effects(fit2_cond)

# replicate LeSage et al. (2011), Table 6, p.1020
# SAR probit model effects estimates for the 0-12-month time horizon
effects(fit3_cond)

## End(Not run)

</code></pre>

<hr>
<h2 id='names.ProbitSpatial'>Extract names of ProbitSpatial class.</h2><span id='topic+names.ProbitSpatial'></span>

<h3>Description</h3>

<p>Extract names of ProbitSpatial class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ProbitSpatial'
names(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.ProbitSpatial_+3A_x">x</code></td>
<td>
<p>an object of class <code>ProbitSpatial</code>.</p>
</td></tr>
<tr><td><code id="names.ProbitSpatial_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the names of the <code>ProbitSpatial</code> object.
</p>

<hr>
<h2 id='predict.ProbitSpatial'>Spatial probit model predictions.</h2><span id='topic+predict.ProbitSpatial'></span>

<h3>Description</h3>

<p>Predicts of a <code>ProbitSpatial</code> model on a set <code>X</code> of covariates.
Works on both in-sample and out-of-sample using BLUP formula from Goulard et 
al. (2017)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ProbitSpatial'
predict(
  object,
  X,
  type = c("link", "response", "binary"),
  cut = 0.5,
  oos = FALSE,
  WSO = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.ProbitSpatial_+3A_object">object</code></td>
<td>
<p>an object of class <code>ProbitSpatial</code>.</p>
</td></tr>
<tr><td><code id="predict.ProbitSpatial_+3A_x">X</code></td>
<td>
<p>a matrix of explanatory variables. If oos=TRUE, it may contain more 
observations than the dataset on which the model has been trained</p>
</td></tr>
<tr><td><code id="predict.ProbitSpatial_+3A_type">type</code></td>
<td>
<p>the type of output: 
</p>

<dl>
<dt><code>"link"</code></dt><dd><p>the value of the latent variable. Default</p>
</dd>
<dt><code>"response"</code></dt><dd><p>probability.</p>
</dd>
<dt><code>"binary"</code></dt><dd><p>binary 0/1 output.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="predict.ProbitSpatial_+3A_cut">cut</code></td>
<td>
<p>the threshold probability for the <code>"binary"</code> type. 
Default is 0.5.</p>
</td></tr>
<tr><td><code id="predict.ProbitSpatial_+3A_oos">oos</code></td>
<td>
<p>logical. If TRUE, out-of-sample predictions are returned.</p>
</td></tr>
<tr><td><code id="predict.ProbitSpatial_+3A_wso">WSO</code></td>
<td>
<p>W matrix containing weights of in-sample and 
out-of-sample data. Observations must be ordered in such a way that
the first elements belong to the in-sample data and the remaining ones
to the out-of-sample data.</p>
</td></tr>
<tr><td><code id="predict.ProbitSpatial_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>oos=FALSE</code>, the function computes the predicted values for  #' the estimated model (same as <code>fitted</code>). Otherwise, it applies the BLUP #' formula of Goulard et al. (2017):
</p>
<p style="text-align: center;"><code class="reqn">\hat{y} = (\hat(y_S),\hat(y_O)),</code>
</p>

<p>where the sub-indexes S and O refer, respectively, to the in-sample and
out-of-sample data. <code class="reqn">\hat{y_S}</code> corresponds to fitted values, while
<code class="reqn">\hat{y_O}</code> is computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">\hat{y_O} = (I-\rho W)^{-1}(X\beta)-Q_{OO}^{-1}Q_{OS}(y_S-\hat{y_S}),</code>
</p>

<p>where <code class="reqn">Q</code> is the precision matrix of 
<code class="reqn">\Sigma=\sigma^2((I-\rho W)'(I-\rho W))^{-1}.</code> and the sub-indexes OO and 
OS refer to the corresponding block matrices.
</p>


<h3>Value</h3>

<p>Returns a vector of predicted values for the set <code>X</code> of 
covariates if <code>oos=FALSE</code> or the best linear unbiased predictors of the #' set <code>XOS</code> if <code>oos=TRUE</code>.
</p>


<h3>References</h3>


<dl>
<dt>Goulard et al. (2017)</dt><dd><p>M. Goulard, T. Laurent and C. Thomas-Agnan. 
About predictions in spatial autoregressive models: optimal and almost
optimal strategies. <em>Spatial Economic Analysis</em> 12, 304-325, 2017.</p>
</dd></dl>


<hr>
<h2 id='ProbitSpatial-class'>Class of Spatial Probit Model.</h2><span id='topic+ProbitSpatial-class'></span>

<h3>Description</h3>

<p>Class of Spatial Probit Model.
</p>


<h3>Slots</h3>


<dl>
<dt><code>beta</code></dt><dd><p>numeric, the estimated parameters for the covariates.</p>
</dd>
<dt><code>rho</code></dt><dd><p>numeric, the estimated spatial autocorrelation parameter.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>numeric, the estimated spatial error autocorrelation parameter.</p>
</dd>
<dt><code>coeff</code></dt><dd><p>numeric, all estimated parameters.</p>
</dd>
<dt><code>loglik</code></dt><dd><p>numeric, the likelihood associated to the estimated model.</p>
</dd>
<dt><code>formula</code></dt><dd><p><code>formula</code>.</p>
</dd>
<dt><code>nobs</code></dt><dd><p>numeric, number of observations.</p>
</dd>
<dt><code>nvar</code></dt><dd><p>numeric, number of covariates.</p>
</dd>
<dt><code>y</code></dt><dd><p>numeric, vector of observed dependent variable.</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix, matrix of covariates.</p>
</dd>
<dt><code>time</code></dt><dd><p>numeric, estimation time.</p>
</dd>
<dt><code>DGP</code></dt><dd><p>character, DGP of the model (SAR, SEM or SARAR).</p>
</dd>
<dt><code>method</code></dt><dd><p>character, estimation method (&quot;<code>conditional</code>&quot; or 
&quot;<code>full-lik</code>&quot;).</p>
</dd>
<dt><code>varcov</code></dt><dd><p>character, indicates the matrix used in the algorithm 
(&quot;<code>varcov</code>&quot; or &quot;<code>precision</code>&quot;).</p>
</dd>
<dt><code>W</code></dt><dd><p>SparseMatrix, the spatial weight matrix of y.</p>
</dd>
<dt><code>M</code></dt><dd><p>SparseMatrix, the spatial weight matrix of the disturbances.</p>
</dd>
<dt><code>iW_CL</code></dt><dd><p>numeric, the order of approximation used in the conditional 
method.</p>
</dd>
<dt><code>iW_FL</code></dt><dd><p>numeric, the order of approximation used inside the likelihood 
function for the <code>full-lik</code> method.</p>
</dd>
<dt><code>iW_FG</code></dt><dd><p>numeric, the order of approximation used inside the gradient 
functions for the <code>full-lik</code> method.</p>
</dd>
<dt><code>reltol</code></dt><dd><p>numeric, the relative convergence tolerance.</p>
</dd>
<dt><code>prune</code></dt><dd><p>numeric, the pruning for the gradient functions.</p>
</dd>
<dt><code>env</code></dt><dd><p>an <code>environment</code> containing information for use in later 
function calls to save time.</p>
</dd>
<dt><code>message</code></dt><dd><p>a integer giving any additional information or NULL.</p>
</dd>
</dl>

<hr>
<h2 id='ProbitSpatialFit'>Fit a spatial probit model.</h2><span id='topic+ProbitSpatialFit'></span>

<h3>Description</h3>

<p>Approximate likelihood estimation of the probit model with spatial 
autoregressive (SAR), spatial error (SEM), spatial autoregressive with 
autoregressive disturbances (SARAR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProbitSpatialFit(formula,data,W,
         DGP='SAR',method="conditional",varcov="varcov",
         M=NULL,control=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProbitSpatialFit_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>formula</code>: a symbolic 
description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="ProbitSpatialFit_+3A_data">data</code></td>
<td>
<p>the data set containing the variables of the model.</p>
</td></tr>
<tr><td><code id="ProbitSpatialFit_+3A_w">W</code></td>
<td>
<p>the spatial weight matrix of class <code>"dgCMatrix"</code>.</p>
</td></tr>
<tr><td><code id="ProbitSpatialFit_+3A_dgp">DGP</code></td>
<td>
<p>the data generating process of <code>data</code>: SAR, SEM, SARAR 
(Default is SAR).</p>
</td></tr>
<tr><td><code id="ProbitSpatialFit_+3A_method">method</code></td>
<td>
<p>the optimisation method: <code>"conditional"</code> or 
<code>"full-lik"</code> (Defaul is <code>"conditional"</code>, see Details).</p>
</td></tr>
<tr><td><code id="ProbitSpatialFit_+3A_varcov">varcov</code></td>
<td>
<p>the likelihood function is computed using the 
variance-covariance matrix (<code>"varcov"</code>) or the precision matrix 
(<code>"precision"</code>)? Default is <code>"varcov"</code>.</p>
</td></tr>
<tr><td><code id="ProbitSpatialFit_+3A_m">M</code></td>
<td>
<p>the second spatial weight matrix for SARAR models. Same class as W.</p>
</td></tr>
<tr><td><code id="ProbitSpatialFit_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation is based on the approximate value of the true likelihood of 
spatial probit models. 
The DGP of the spatial autoregressive model (SAR) model is the following
</p>
<p style="text-align: center;"><code class="reqn">y = \rho Wy + X\beta + \epsilon,</code>
</p>

<p>where the disturbances <code class="reqn">\epsilon</code> are iid standard normally distributed, 
<code class="reqn">W</code> is a sparse spatial weight matrix and <code class="reqn">\rho</code> is the spatial lag 
parameter. The variance of the error term is equal 
to <code class="reqn">\Sigma=\sigma^2((I_n-\rho W)^{-1}((I_n-\rho W)^{-1})^{t})</code>.
The DGP of the spatial error model (SEM) is as follows
</p>
<p style="text-align: center;"><code class="reqn">y = X\beta+u,</code>
</p>

<p style="text-align: center;"><code class="reqn">u = \rho W u + \epsilon,</code>
</p>

<p>where the disturbances <code class="reqn">\epsilon</code> are iid standard normally distributed, 
<code class="reqn">W</code> is a sparse spatial weight matrix and <code class="reqn">\rho</code> is the spatial 
error  parameter. The variance of the error term  
is equal to <code class="reqn">\Sigma=\sigma^2((I_n-\rho W)^{-1}((I_n-\rho W 
)^{-1})^{t})</code>.
The DGP of the spatial autoregressive model with autoregressive disturbances 
(SARAR) is as follows
</p>
<p style="text-align: center;"><code class="reqn">y = \rho Wy + X\beta + u,</code>
</p>

<p style="text-align: center;"><code class="reqn">u = \lambda M u + \epsilon,</code>
</p>

<p>where the disturbances <code class="reqn">\epsilon</code> are iid standard normally distributed, 
<code class="reqn">W</code> and <code class="reqn">M</code> are two sparse spatial weight matrix, while <code class="reqn">\rho</code> 
and <code class="reqn">\lambda</code> are the spatial lag and spatial error parameters, 
respectively. The variance of the error term  
is equal to <code class="reqn">\Sigma=\sigma^2((I_n-\rho W)^{-1}(I_n-\lambda 
M)^{-1}((I_n-\lambda M)^{-1})^{t}((I_n-\rho W)^{-1})^{t})</code>.
</p>
<p>The approximation is inspired by the Mendell-Elston approximation 
of the multivariante normal probabilities (see References). It makes use of 
the Cholesky decomposition of the variance-covariance matrix <code class="reqn">\Sigma</code>.
</p>
<p>The <code>ProbitSpatialFit</code> command estimates the model by maximising the 
approximate log-likelihood. We propose two optimisation method:
</p>

<dl>
<dt><code>"conditional"</code>:</dt><dd><p> it relies on a standard probit estimation  
which applies to the model estimated 
conditional on <code class="reqn">\rho</code>.</p>
</dd>
<dt><code>"full-lik"</code>:</dt><dd><p> it minimises the full-log-likelihood using the 
analytical gradient functions (only available for SAR and SEM 
specification). The optimisation is performed by means of the 
<code><a href="stats.html#topic+optim">optim</a></code> function with <code>method = "BFGS"</code>.</p>
</dd>
</dl>

<p>In both cases a <code>"conditional"</code> estimation is performed. If 
<code>method="conditional"</code>, then <code>ProbitSpatialFit</code> returns 
the results of this first estimation. In case <code>method="full-lik"</code>,
the function tries to improve the log-likelihood by means of a further 
exploration around the value of the parameters found by the conditional 
step.
The conditional step is usually very accurate and particularly fast. The 
second step is more time consuming and does not always improve the results
of the first step. We dissuade the user from using the full-likelihood 
method 	for sample sizes bigger than ten thousands, since the computation of 
the gradients is quite slow.  Simulation studies reported in Martinetti and 
Geniaux (2017) prove that the conditional estimation is highly reliable,
even  if compared to the full-likelihood ones.
</p>
<p>In order to reduce the computation time of the function
<code>ProbitSpatialFit</code>, we propose a variant of the likelihood-function 
estimation that uses the inverse of the variance-covariance matrix (a.k.a. 
precision matrix). This variant applies to both the <code>"conditional"</code> and 
the <code>"full-lik"</code> methods and can be invoked by setting 
<code>varcov="precision"</code>. Simulation studies reported in Martinetti and 
Geniaux (2017) suggest that the accuracy of the results with the precision 
matrix are sometimes worst than the one with the true variance-covariance 
matrix, but the estimation time is considerably reduced.
</p>
<p>The control argument is a list that can supply any of the following 
components:
</p>

<dl>
<dt><code>iW_CL</code></dt><dd><p>the order of approximation of <code class="reqn">(I_n-\rho W)^{-1}</code> 
used in the <code>"conditional"</code> method. Default is 6, while 0 means no 
approximation (it uses exact inversion of matrixes, not suitable for big 
sample sizes). See Martinetti and Geniaux (2017) for further references.</p>
</dd>
<dt><code>iW_FL</code></dt><dd><p>the order of approximation of <code class="reqn">(I_n-\rho W)^{-1}</code> 
used in the computation of the likelihood function for the <code>"full-lik"</code> 
method. Default is 0, meaning no approximation.</p>
</dd>
<dt><code>iW_FG</code></dt><dd><p>the order of approximation of <code class="reqn">(I_n-\rho W)^{-1}</code> 
used in the computation of the gradient functions for the <code>"full-lik"</code> 
method. Default is 0, meaning no approximation.</p>
</dd>
<dt><code>reltol</code></dt><dd><p>relative convergence tolerance. It represents 	
<code>tol</code> in <code><a href="stats.html#topic+optimize">optimize</a></code> function  for 
<code>method="conditional"</code> and  <code>reltol</code> in <code><a href="stats.html#topic+optim">optim</a></code> 
function for <code>method="full-lik"</code>. Default is 1e-5.</p>
</dd>
<dt><code>prune</code></dt><dd><p>the pruning value used in the gradients. Default is 0,
meaning no pruning. Typacl values are around 1e-3 and 1e-6. They help 
reducing the estimation time of the gradient functions.</p>
</dd>
<dt><code>silent</code></dt><dd><p>Default is TRUE.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Return an object of class <code>ProbitSpatial</code>.
</p>


<h3>References</h3>


<dl>
<dt>Mendell and Elston (1974)</dt><dd><p>N. Mendell and R. Elston. Multifactorial 
qualitative traits: genetic analysis and prediction of recurrence risks. 
<em>Biometrics</em> 30, 41&ndash;57, 1974.</p>
</dd>
<dt>Martinetti and Geniaux (2017)</dt><dd><p>D. Martinetti and G. Geniaux. 
Approximate likelihood estimation of spatial probit models. <em>Regional 
Science and Urban Economics</em> 64, 30-45, 2017.</p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 1000
nneigh &lt;- 3
rho &lt;- 0.5
beta &lt;- c(4,-2,1)
W &lt;- generate_W(n,nneigh,seed=123)
X &lt;- cbind(1,rnorm(n,2,2),rnorm(n,0,1))
colnames(X) &lt;- c("intercept","X1","X2")
y &lt;- sim_binomial_probit(W=W,X=X,beta=beta,rho=rho,model="SAR")
d &lt;- as.data.frame(cbind(y,X))
mod &lt;- ProbitSpatialFit(y~X1+X2,d,W,
       DGP='SAR',method="conditional",varcov="varcov")

</code></pre>

<hr>
<h2 id='residuals.ProbitSpatial'>Extract spatial probit model residuals.</h2><span id='topic+residuals.ProbitSpatial'></span>

<h3>Description</h3>

<p>Compute the residuals of an estimated <code>ProbitSpatial</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ProbitSpatial'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.ProbitSpatial_+3A_object">object</code></td>
<td>
<p>an object of class <code>ProbitSpatial</code>.</p>
</td></tr>
<tr><td><code id="residuals.ProbitSpatial_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector containing the generalised residuals of the 
<code>ProbitSpatial</code> model.
</p>

<hr>
<h2 id='sim_binomial_probit'>Simulate the dependent variable of a SAR/SEM/SARAR model.</h2><span id='topic+sim_binomial_probit'></span>

<h3>Description</h3>

<p>The function <code>sim_binomial_probit</code> is used to generate the dependent 
variable of a spatial binomial probit model, where all the data and 
parameters of the model can be modified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_binomial_probit(W,X,beta,rho,model="SAR",M=NULL,lambda=NULL,
sigma2=1,ord_iW=6,seed=123)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_binomial_probit_+3A_w">W</code></td>
<td>
<p>the spatial weight matrix (works for <code>"SAR"</code> and 
<code>"SEM"</code> models).</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_x">X</code></td>
<td>
<p>the matrix of covariates.</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_beta">beta</code></td>
<td>
<p>the value of the covariates parameters.</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_rho">rho</code></td>
<td>
<p>the value of the spatial dependence parameter (works for 
<code>"SAR"</code> and <code>"SEM"</code> models).</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_model">model</code></td>
<td>
<p>the type of model, between <code>"SAR"</code>, <code>"SEM"</code>, 
<code>"SARAR"</code> (Default is <code>"SAR"</code>).</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_m">M</code></td>
<td>
<p>the second spatial weight matrix (only if <code>model</code> is 
<code>"SARAR"</code>).</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_lambda">lambda</code></td>
<td>
<p>the value of the spatial dependence parameter (only if 
<code>model</code> is <code>"SARAR"</code>).</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_sigma2">sigma2</code></td>
<td>
<p>the variance of the error term (Defaul is 1).</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_ord_iw">ord_iW</code></td>
<td>
<p>the order of approximation of the matrix 
<code class="reqn">(I_n-\rho W)^{-1}</code>.</p>
</td></tr>
<tr><td><code id="sim_binomial_probit_+3A_seed">seed</code></td>
<td>
<p>to set the random generator seed of the error term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sim_binomial_probit</code> generates a vector of dependent 
variables for a spatial probit model. It allows to simulate the following 
DGPs (Data Generating Process):
SAR
</p>
<p style="text-align: center;"><code class="reqn">z = (I_n-\rho W)^{-1}(X\beta+\epsilon)	</code>
</p>

<p>SEM
</p>
<p style="text-align: center;"><code class="reqn">z = X\beta+(I_n-\rho W)^{-1}\epsilon	</code>
</p>

<p>SARAR
</p>
<p style="text-align: center;"><code class="reqn">z = (I_n-\rho W)^{-1}(X\beta+(I_n-\lambda M)^{-1}\epsilon)	</code>
</p>

<p>where <code class="reqn">\epsilon</code> are independent and normally distributed with mean zero 
and variance <code>sigma2</code> (default is 1).
</p>
<p>The matrix <code>X</code> of covariates, the corresponding parameters <code>beta</code>, 
the spatial weight matrix <code>W</code> and the corresponding spatial dependence 
parameter <code>rho</code> need to be passed by the user. Eventually, the same 
applies for <code>lambda</code> and <code>M</code> for the SARAR model.
</p>
<p>The matrix <code class="reqn">(I_n-\rho W)^{-1}</code> is computed using the 
<code>ApproxiW</code> function, that can either invert <code class="reqn">(I_n-\rho W)</code> 
exactely, if <code>order_iW=0</code> (not suitable for <code>n</code> bigger than 1000),  
or using the Taylor approximation 
</p>
<p style="text-align: center;"><code class="reqn">(I_n-\rho W)^{-1}= I_n+\rho W+\rho^2 W^2+\ldots 	</code>
</p>

<p>of order <code>order_iW</code> (default is approximation of order 6).
</p>


<h3>Value</h3>

<p>a vector of zeros and ones
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_W">generate_W</a></code>, <code><a href="#topic+ProbitSpatialFit">ProbitSpatialFit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
nneigh &lt;- 3
rho &lt;- 0.5
beta &lt;- c(4,-2,1)
W &lt;- generate_W(n,nneigh)
X &lt;- cbind(1,rnorm(n,2,2),rnorm(n,0,1))
#SAR
y &lt;- sim_binomial_probit(W,X,beta,rho,model="SAR") #SAR model
#SEM
y &lt;- sim_binomial_probit(W,X,beta,rho,model="SEM") #SEM model
#SARAR
M &lt;- generate_W(n,nneigh,seed=1)
lambda &lt;- -0.5
y &lt;- sim_binomial_probit(W,X,beta,rho,model="SARAR",M=M,lambda=lambda) 
</code></pre>

<hr>
<h2 id='summary.ProbitSpatial'>Spatial probit model summaries.</h2><span id='topic+summary.ProbitSpatial'></span>

<h3>Description</h3>

<p>Print the results of a <code>ProbitSpatial</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ProbitSpatial'
summary(object, covar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.ProbitSpatial_+3A_object">object</code></td>
<td>
<p>an object of class <code>ProbitSpatial</code>.</p>
</td></tr>
<tr><td><code id="summary.ProbitSpatial_+3A_covar">covar</code></td>
<td>
<p>should the statistics be computed with the matrix of
variance of the parametes or not. Default is FALSE, hence Likelihood-ratio 
statistics are printed.</p>
</td></tr>
<tr><td><code id="summary.ProbitSpatial_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary</code> function prints
</p>

<dl>
<dt>Model</dt><dd><p>Featurs on the model and dataset.</p>
</dd>
<dt>Time</dt><dd><p>Estimation time.</p>
</dd>
<dt>Statistics</dt><dd><p>Standard errors of the estimated parameters. If 
<code>covar=TRUE</code>, it uses the matrix of variance of the parameters, else the 
likelihood ratio test.</p>
</dd>
<dt>Accuracy</dt><dd><p>Confusion Matrix and accuracy of the estimated model.</p>
</dd>
</dl>



<h3>Value</h3>

<p>This functions does not return any value.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
